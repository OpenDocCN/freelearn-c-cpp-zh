- en: A Hands-On Approach to Allocators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配器的实践方法
- en: 'In [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml), *A Comprehensive
    Look at Memory Management*, we learned how to allocate and deallocate memory using
    C++-specific techniques, including the use of `std::unique_ptr` and `std::shared_ptr`.
    In addition, we learned about fragmentation and how it is capable of wasting large
    amounts of memory depending on how memory is allocated and then later deallocated.
    System programmers often have to allocate memory from different pools (sometimes
    originating from different sources), and handle fragmentation to prevent the system
    from running out of memory during operation. This is especially true for embedded
    programmers. Placement `new()` may be used to solve these types of issues, but
    implementations based on placement new are often hard to create and even harder
    to maintain. Placement `new()` is also only accessible from user-defined code,
    providing no control over the allocations that originate from the C++ standard
    library APIs (such as `std:: list` and `std:: map`).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中，*全面了解内存管理*，我们学习了如何使用C++特定的技术来分配和释放内存，包括使用`std::unique_ptr`和`std::shared_ptr`。此外，我们还了解了碎片化以及根据内存分配和后续释放的方式可能浪费大量内存。系统程序员经常需要从不同的池中分配内存（有时来自不同的来源），并处理碎片以防止系统在运行过程中耗尽内存。这对于嵌入式程序员来说尤其如此。可以使用放置`new()`来解决这些问题，但基于放置new的实现通常很难创建，甚至更难维护。放置`new()`也只能从用户定义的代码中访问，无法控制源自C++标准库API（如`std::list`和`std::map`）的分配。
- en: To solve these types of issues, C++ provides a concept called the **allocator**.
    C++ allocators define how memory should be allocated and deallocated for a specific
    type T. In this chapter, you will learn how to create your own allocators while
    covering the intricate details of the C++ allocator concept. This chapter will
    end with two different examples; the first example will demonstrate how to create
    a simple, cache-aligned allocator that is stateless, while the second will provide
    a functional example of a stateful object allocator that maintains a free pool
    for fast allocations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，C++提供了一个称为**分配器**的概念。C++分配器定义了如何为特定类型T分配和释放内存。在本章中，您将学习如何创建自己的分配器，同时涵盖C++分配器概念的复杂细节。本章将以两个不同的示例结束；第一个示例将演示如何创建一个简单的、缓存对齐的无状态分配器，而第二个示例将提供一个有状态对象分配器的功能示例，该分配器维护一个用于快速分配的空闲池。
- en: 'The objectives of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: Introducing the C++ allocators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C++分配器
- en: Studying an examples of stateless, cache-aligned allocator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究无状态的、缓存对齐的分配器的示例
- en: Studying an example of stateful, memory-pool allocator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究有状态的、内存池分配器的示例
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter09).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请参阅以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter09)。
- en: Introducing the C++ allocators
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C++分配器
- en: 'C++ allocators define a template class that allocates memory for a specific
    type T and are defined by the allocator concept definition. There are two different
    types of allocators:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++分配器定义了一个模板类，为特定类型T分配内存，并由分配器概念定义。有两种不同类型的分配器：
- en: Allocators that are equal
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等的分配器
- en: Allocators that are unequal
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不相等的分配器
- en: 'An allocator that is equal is an allocator that can allocate memory from one
    allocator and deallocate memory from another, for example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的分配器是指可以从一个分配器中分配内存并从另一个分配器中释放内存的分配器，例如：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As shown in the preceding example, we create two instances of `myallocator{}`.
    We allocate memory from one of the allocators and then deallocate memory from
    the other allocator. For this to be valid, the allocators must be equal:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了两个`myallocator{}`的实例。我们从一个分配器中分配内存，然后从另一个分配器中释放内存。为了使这有效，分配器必须是相等的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this does not hold true, the allocators are considered unequal, which greatly
    complicates how the allocators can be used. An unequal allocator is usually an
    allocator that is stateful, meaning it stores a state within itself that prevents
    an allocator from deallocating memory from another instance of the same allocator
    (because the state is different).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不成立，分配器被认为是不相等的，这极大地复杂了分配器的使用方式。不相等的分配器通常是有状态的分配器，这意味着它在自身内部存储了一个状态，阻止了一个分配器从另一个相同分配器的实例中释放内存（因为状态不同）。
- en: Learning about the basic allocator
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基本分配器
- en: 'Before we dive into the details of a stateful, unequal allocator, let''s review
    the most basic allocator, which is a stateless, equal allocator. This most basic
    allocator takes the following form:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究有状态的、不相等的分配器的细节之前，让我们回顾一下最基本的分配器，即无状态的、相等的分配器。这个最基本的分配器采用以下形式：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To start, all allocators are template classes, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有分配器都是模板类，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It should be noted that allocators can have any number of template arguments,
    but at least one is needed to define the type that the allocator will allocate
    and deallocate. In our example, we use the following aliases:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，分配器可以具有任意数量的模板参数，但至少需要一个来定义分配器将分配和释放的类型。在我们的示例中，我们使用以下别名：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Technically speaking, the only alias that is required is the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，唯一需要的别名是以下内容：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since, however, `T*` and `std::size_t` are required to create a minimal allocator,
    these aliases might as well be added to provide a more complete implementation.
    The optional aliases include the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于需要`T*`和`std::size_t`来创建最小的分配器，这些别名也可以添加以提供更完整的实现。可选的别名包括以下内容：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If a custom allocator doesn't provide these, the preceding default values will
    be provided for you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自定义分配器没有提供这些内容，将为您提供前面的默认值。
- en: As shown, all allocators must provide a default constructor. This is due to
    the fact that C++ containers will create the allocator on their own, in some cases
    more than once, and they will use the default constructor to do so, which means
    the construction of an allocator must be possible without the need of an additional
    argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，所有分配器必须提供默认构造函数。这是因为C++容器将自行创建分配器，在某些情况下可能会多次创建，并且它们将使用默认构造函数来执行此操作，这意味着必须能够在不需要额外参数的情况下构造分配器。
- en: 'The `allocate()` function in our example is the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的`allocate()`函数如下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As with all of the functions being explained in this example, the function signature
    of the `allocate()` function is defined by the allocator concept, which means
    that each function in the allocator must take on a specific signature; otherwise,
    the allocator will not compile correctly when used by existing containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与本示例中解释的所有函数一样，`allocate()`函数的函数签名由分配器概念定义，这意味着分配器中的每个函数必须采用特定的签名；否则，在现有容器使用时，分配器将无法正确编译。
- en: In the preceding example, `malloc()` is used to allocate some memory, and if
    `malloc` doesn't return `nullptr`, the resulting pointer is returned. Since the
    allocator allocates pointers of the `T*` type, and not `void *`, we must statically
    cast the result of `malloc()` before returning the pointer.  The number of bytes
    provided to `malloc()` is equal to `sizeof(T) * n`. This is because the `n` parameter
    defines the total number of objects the allocator must allocate—because some containers
    will allocate several objects at once and expect that the objects being allocated
    are contiguous in memory. Examples of this include `std::deque` and `std::vector`,
    and it's up to the allocator to ensure these rules hold true in memory. Finally,
    if `malloc()` returns `nullptr`, indicating the requested memory could not be
    allocated, we throw `std::bad_alloc()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用`malloc()`来分配一些内存，如果`malloc`没有返回`nullptr`，则返回结果指针。由于分配器分配`T*`类型的指针，而不是`void
    *`，我们必须在返回指针之前对`malloc()`的结果进行静态转换。提供给`malloc()`的字节数等于`sizeof(T) * n`。这是因为`n`参数定义了分配器必须分配的对象总数——因为一些容器将一次分配多个对象，并且期望被分配的对象在内存中是连续的。这包括`std::deque`和`std::vector`的示例，分配器必须确保这些规则在内存中成立。最后，如果`malloc()`返回`nullptr`，表示无法分配请求的内存，我们会抛出`std::bad_alloc()`。
- en: It should be noted that in our example, we use `malloc()` instead of `new()`.
    Here, `malloc()` should be used instead of `new()` because the container will
    construct the object being allocated for you. For this reason, we don't want to
    use `new()`, since it would also construct the object, meaning the object would
    be constructed twice, which would lead to corruption and undefined behavior. For
    this reason, `new()` and `delete()` should never be used in an allocator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在我们的示例中，我们使用`malloc()`而不是`new()`。在这里，应该使用`malloc()`而不是`new()`，因为容器将为您构造被分配的对象。因此，我们不希望使用`new()`，因为它也会构造对象，这意味着对象将被构造两次，这将导致损坏和未定义的行为。因此，`new()`和`delete()`不应该在分配器中使用。
- en: 'The `deallocate` function performs the opposite of the `allocate` function,
    freeing memory and releasing it back to the operating system:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`deallocate`函数执行与`allocate`函数相反的操作，释放内存并将其释放回操作系统：'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, to deallocate memory, we simply need to call `free()`.
    Note that we are creating an *equal* allocator, which means that `ptr` does not
    need to originate from the same allocator performing the deallocation. The number
    of allocations, `n`, however, must match the original allocation, which in our
    case may be safely ignored, since we are using `malloc()` and `free()`, which
    automatically keep track of the size of the original allocation for us. Not all
    allocators will have this property.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，要释放内存，我们只需要调用`free()`。请注意，我们创建了一个*相等*的分配器，这意味着`ptr`不需要来自执行解除分配的相同分配器。然而，分配的数量`n`必须与原始分配相匹配，在我们的情况下可能可以安全地忽略，因为我们使用的是`malloc()`和`free()`，它们会自动为我们跟踪原始分配的大小。并非所有的分配器都具有这个属性。
- en: 'In our simple example, there are two additional requirements to conform to
    a C++ allocator that are far less obvious in terms of what exactly their purpose
    is. The first is the use of a copy constructor using a template type of `U`, as
    follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，有两个额外的要求，以符合C++分配器，这些要求在其目的方面远不那么明显。第一个是使用模板类型`U`的复制构造函数，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is because when you use the allocator with a container, you specify the
    type in the container''s definition, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您在容器的定义中使用分配器时，您会指定容器中的类型，例如：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we create an `std::list` of the `myclass{}` type,
    with an allocator that allocates and deallocates `myclass{}` objects. The problem
    is, `std::list` has its own internal data structures that must also be allocated.
    Specifically, `std::list` implements a linked list, and as a result, `std::list`
    must be able to allocate and deallocate linked list nodes. In the preceding definition,
    we defined an allocator that allocates and deallocates `myclass{}` objects, but `std::list`
    will actually allocate and deallocate nodes and these two types are not the same.
    To solve this, `std::list` will create a copy of the `myclass{}` allocator using
    the template version of the copy constructor, providing `std::list` with the ability
    to create its own node allocator using the allocator that it was originally provided.
    For this reason, the template version of the copy constructor is required for
    a fully functional allocator.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个`myclass{}`类型的`std::list`，使用一个分配器来分配和释放`myclass{}`对象。问题是，`std::list`有自己的内部数据结构，也必须进行分配。具体来说，`std::list`实现了一个链表，因此`std::list`必须能够分配和释放链表节点。在前面的定义中，我们定义了一个分配器，用于分配和释放`myclass{}`对象，但`std::list`实际上将分配和释放节点，这两种类型并不相同。为了解决这个问题，`std::list`将使用复制构造函数的模板版本创建`myclass{}`分配器的副本，从而使`std::list`能够使用最初提供的分配器来创建自己的节点分配器。因此，完全功能的分配器需要模板版本的复制构造函数。
- en: 'The second odd addition to the preceding example is the use of the equality
    operators, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中前面的奇怪添加是使用相等运算符，如下所示：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The equality operators define whether the allocator is *equal* or *unequal*.
    In the preceding example, we have created a stateless allocator, which means that
    the following is valid:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相等运算符定义了分配器是*相等*还是*不相等*。在前面的示例中，我们创建了一个无状态的分配器，这意味着以下是有效的：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the preceding property holds true, the allocators are equal. Since, in our
    example, `myalloc1{}` calls `malloc()` when allocating, and `myalloc2{}` calls
    `free()` when deallocating, we know that they are interchangeable, which means
    the preceding holds true and our example implements an *equal* allocator. The
    preceding equality operators simply state this equality formally, providing APIs,
    such as C++ containers, with a means to create new allocators as needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的属性成立，那么分配器是相等的。由于在我们的示例中，`myalloc1{}`在分配时调用`malloc()`，在释放时调用`free()`，我们知道它们是可以互换的，这意味着前面的属性成立，我们的示例实现了一个*相等*的分配器。前面的相等运算符只是正式陈述了这种相等关系，为C++容器等提供了根据需要创建新分配器的API。
- en: Understanding the allocator's properties and options
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解分配器的属性和选项
- en: The basic allocator we just discussed provides only the required functionality
    to create and use an allocator with existing C++ data structures (and other user-defined
    types that leverage object allocation). In addition to the optional aliases we
    discussed, there are several other options and properties that make up C++ allocators.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的基本分配器仅提供了使用现有C++数据结构（以及利用对象分配的其他用户定义类型）的分配器所需的功能。除了我们讨论的可选别名之外，还有几个其他选项和属性构成了C++分配器。
- en: Learning the properties
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习属性
- en: C++ allocators must adhere to a certain set of properties, most of which are
    either obvious or easily adhered to.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++分配器必须遵守一定的属性集，其中大多数要么是显而易见的，要么很容易遵守。
- en: The value pointer type
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值指针类型
- en: 'The first set of properties ensures that the pointer type returned by the allocator
    is, in fact, a pointer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组属性确保分配器返回的指针类型实际上是一个指针：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the pointer returned by the allocator is truly a pointer, it's possible to
    dereference the pointer to access the memory it points to, as shown in the preceding
    example. It should also be noted that in this example, we get relatively random
    values returned when attempting to output the resulting allocated memory to `stdout`.
    This is because there is no requirement to zero memory from an allocator, as this
    operation is done for us by the container that uses this memory, which is more
    performant.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配器返回的指针确实是一个指针，就可以对指针进行解引用以访问其指向的内存，如前面的示例所示。还应该注意，在这个例子中，当尝试将分配的内存输出到`stdout`时，返回的值是相对随机的。这是因为分配器没有要求将内存清零，因为使用这个内存的容器会为我们执行此操作，这样更高效。
- en: Equality
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相等性
- en: 'As stated previously, if an allocator is equal when compared, they return `true`,
    as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果比较时分配器相等，则返回`true`，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If two allocators of the same type return `true`, it means a container that
    uses this allocator is free to allocate and deallocate memory with different instances
    of the same allocator freely, which ultimately enables the use of certain optimizations.
    For example, it's possible for a container to never actually store an internal
    reference to an allocator, and instead to create an allocator only when memory
    needs to be allocated. From that point on, the container manages memory internally,
    and only deallocates memory on destruction, at which time the container will create
    yet another allocator to perform deallocations, once again assuming the allocators
    are equal.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一类型的两个分配器返回`true`，这意味着使用此分配器的容器可以自由地使用不同实例的相同分配器来分配和释放内存，从而最终实现了某些优化的使用。例如，容器可以从不实际存储分配器的内部引用，而是只在需要分配内存时创建一个分配器。从那时起，容器在内部管理内存，并且只在销毁时释放内存，此时容器将再次创建另一个分配器来执行释放操作，再次假设分配器相等。
- en: As we've covered, allocator equality usually correlates with statefulness. Typically,
    stateful allocators are not equal, while stateless allocators are equal; but this
    rule doesn't always hold true, especially when a copy is made of a stateful allocator,
    which is required by the spec to provide equality (or at least the ability to
    deallocate previously-allocated memory that was allocated from the copy). We will
    provide more details on this specific issue when we cover stateful allocators.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，分配器的相等通常与状态有关。通常，有状态的分配器不相等，而无状态的分配器相等；但这个规则并不总是成立，特别是当对有状态的分配器进行复制时，规范要求提供相等性（或者至少能够释放从副本分配的先前分配的内存）。当我们涉及有状态的分配器时，我们将提供更多细节。
- en: One issue with allocators prior to C++17 was that there was no easy way for
    a container to identify whether an allocator was equal, without first creating
    two instances of the same allocator at initialization, comparing them, and then
    setting the internal state based on the result. Due to this limitation in the
    C++ allocator concept, containers either assumed stateless allocators (which was
    the case with older versions of C++ libraries), or they assumed all allocators
    were stateful, removing the possibility of optimizations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，分配器存在一个问题，即容器没有简单的方法来确定分配器是否相等，而不是在初始化时首先创建两个相同分配器的实例，进行比较，然后根据结果设置内部状态。由于C++分配器概念的这种限制，容器要么假定是无状态的分配器（这是旧版本C++库的情况），要么假定所有分配器都是有状态的，从而消除了优化的可能性。
- en: 'To overcome this, C++17 introduced the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一问题，C++17引入了以下内容：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If this is not provided by your allocator, as is the case with the preceding
    examples, the default value is `std::empty`, telling the container that the old-style
    comparisons are required to determine equality. If this alias is provided, the
    container will know how to optimize itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的分配器没有提供这个功能，就像前面的例子一样，默认值是`std::empty`，告诉容器需要使用旧式比较来确定相等性。如果提供了这个别名，容器将知道如何对自身进行优化。
- en: Different allocation types
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的分配类型
- en: 'How memory is allocated by a container depends entirely on the type of container,
    and as a result, an allocator must be able to support different allocation types,
    such as the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 容器如何分配内存完全取决于容器的类型，因此，分配器必须能够支持不同的分配类型，例如以下内容：
- en: All allocations by an allocator must be contiguous in memory. There is no requirement
    for one allocation to be contiguous in memory with another allocation, but each
    individual allocation must be contiguous.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器的所有分配必须在内存中是连续的。不要求一个分配在内存中与另一个分配是连续的，但每个单独的分配必须是连续的。
- en: An allocator must be able to allocate more than one element in a single allocation.
    This can sometimes be problematic depending on the allocator.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器必须能够在单个分配中分配多个元素。这有时可能会有问题，这取决于分配器。
- en: 'To explore these properties, let''s use the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探讨这些属性，让我们使用以下示例：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding allocator is the same as the first allocator, with the exception
    that debugging statements were added to the constructors and the allocate and
    deallocate functions, allowing us to see how a container is allocating memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的分配器与第一个分配器相同，唯一的区别是在构造函数和分配和释放函数中添加了调试语句，这样我们就可以看到容器是如何分配内存的。
- en: 'Let''s examine a simple example of `std::list`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的`std::list`的例子：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, we have a single allocation and deallocation from the allocator.
    The allocator is allocating memory of 24 bytes even though the type provided was
    an int, which is of 4 bytes in size. This is because `std::list` allocates linked
    list nodes, which in this case are 24 bytes. The allocator is located at `0x7ffe97b0e8e0`,
    and the allocation was located at `0x55c0793e8580`. Also, as shown, the number
    of elements allocated each time the allocate function was called was one. This
    is because `std::list` implements a linked list, which does a dynamic allocation
    for each element added to the list. Although this seems extremely wasteful when
    a custom allocator is leveraged, this can be quite helpful when performing system
    programming as it is sometimes easier to work with memory when only one element
    is being allocated at a time (instead of multiple).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，分配器只进行了一次分配和释放。尽管提供的类型是4字节的int，但分配器分配了24字节的内存。这是因为`std::list`分配了链表节点，这种情况下是24字节。分配器位于`0x7ffe97b0e8e0`，分配位于`0x55c0793e8580`。此外，如所示，每次调用分配函数时分配的元素数量为1。这是因为`std::list`实现了一个链表，对于添加到列表中的每个元素都进行了动态分配。尽管在使用自定义分配器时这似乎非常浪费，但在进行系统编程时，这可能非常有用，因为有时候一次只分配一个元素（而不是多个）时更容易处理内存。
- en: 'Now let''s look at `std::vector`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`std::vector`，如下所示：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we create `std::vector` with our customer allocator,
    and then, unlike the previous example, we add three integers to the vector instead
    of one. This is because `std::vector` has to maintain contiguous memory regardless
    of the number of elements in the vector (which is one of the main properties of
    `std::vector`). As a result, if `std::vector` fills up (that is, runs out of memory), `std::vector`
    must allocate a completely new, contiguous block of memory for all of the elements
    in `std::vector`, copy `std::vector` from the old memory to the new memory, and
    then deallocate the previous block of memory as it is no longer large enough.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用我们的客户分配器创建了`std::vector`，然后，与之前的例子不同，我们向向量中添加了三个整数，而不是一个。这是因为`std::vector`必须维护连续的内存，而不管向量中的元素数量如何（这是`std::vector`的主要属性之一）。因此，如果`std::vector`填满（即，内存用完了），`std::vector`必须为`std::vector`中的所有元素分配一个全新的连续内存块，将`std::vector`从旧内存复制到新内存，然后释放先前的内存块，因为它不再足够大。
- en: 'To demonstrate how this works, we add three elements to `std::vector`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这是如何工作的，我们向`std::vector`添加了三个元素：
- en: The first element allocates a block of memory that is four bytes in size (`n
    == 1` and `sizeof(T) == 4`).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素分配了一个四个字节大小的内存块（`n == 1`和`sizeof(T) == 4`）。
- en: The second time we add data to `std::vector`, the current block of memory is
    full (as only four bytes were allocated the first time around), so  `std::vector`
    must deallocate this previously-allocated memory, allocate a new block of memory,
    and then copy the old contents of `std::vector`. This time around, however, the
    allocation sets `n == 2`, so eight bytes are allocated.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次向`std::vector`添加数据时，当前的内存块已满（因为第一次只分配了四个字节），所以`std::vector`必须释放先前分配的内存，分配一个新的内存块，然后复制`std::vector`的旧内容。然而，这一次分配设置了`n
    == 2`，所以分配了八个字节。
- en: The third time we add an element, `std::vector` is out of memory again, and
    the process is repeated but with `n == 4`, which means that 16 bytes are allocated.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次添加元素时，`std::vector`再次用完内存，重复这个过程，但是`n == 4`，这意味着分配了16个字节。
- en: As a side note, the first allocation starts at `0x55bf9dbdd550`, which also
    happens to be the location of the third allocation. This is because `malloc()`
    is allocating memory that is aligned to 16 bytes, which means that the first allocation,
    although only 4 bytes in size, actually allocated 16 bytes, which would have been
    enough for `n == 4` in the first place (that is, the implementation of `std::vector`
    provided by GCC could use an optimization). Since the first allocation is deallocated
    the second time memory is added to the `std::vector`, this memory is free to be
    used for the third time an element is used, as the original allocation is still
    large enough for the requested amount.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，第一次分配从`0x55bf9dbdd550`开始，这也恰好是第三次分配的位置。这是因为`malloc()`分配的内存是按16字节对齐的，这意味着第一次分配，虽然只有4个字节，实际上分配了16个字节，这对于第一次就足够了（也就是说，由GCC提供的`std::vector`的实现可以使用优化）。由于第一次分配在第二次向`std::vector`添加内存时被释放，所以这块内存可以在第三次使用元素时被释放，因为原始分配仍然足够请求的数量。
- en: 'It is obvious looking at how the allocator is used, that unless you actually
    need contiguous memory, `std::vector` is not a good choice for storing a list,
    as it is slow. `std::list`, however, takes up a lot of additional memory, as each
    element is 24 bytes, instead of 4\. The next and final container to observe is
    `std::deque`, which finds a happy medium between `std::vector` and `std::list`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，看到分配器的使用方式，除非你真的需要连续的内存，否则`std::vector`不是存储列表的好选择，因为它很慢。然而，`std::list`占用了大量额外的内存，因为每个元素是24个字节，而不是4个字节。接下来要观察的下一个和最后一个容器是`std::deque`，它在`std::vector`和`std::list`之间找到了一个合适的平衡点：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`std::deque` creates a linked list of memory blocks that can be used to store
    more than one element. In other words, `std::deque` is a `std::list` of `std::vectors`.
    Like `std::list`, memory is not contiguous, but like `std::vector`, each element
    only consumes four bytes and a dynamic memory allocation is not needed for each
    element added. As shown, `sizeof(T) == 4` bytes, and during the creation of `std::deque`,
    a large buffer of memory is allocated to store several elements (`128` elements,
    to be specific). The second, smaller allocation is used for internal bookkeeping.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque`创建了一个内存块的链表，可以用来存储多个元素。换句话说，`std::deque`是`std::vectors`的`std::list`。像`std::list`一样，内存不是连续的，但像`std::vector`一样，每个元素只占用四个字节，并且不需要为每个添加的元素进行动态内存分配。如所示，`sizeof(T)
    == 4`字节，在创建`std::deque`时，分配了一个大的内存缓冲区来存储多个元素（具体来说是`128`个元素）。第二个较小的分配用于内部记录。'
- en: 'To further explore `std::deque`, let''s add a lot of elements to `std::deque`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索`std::deque`，让我们向`std::deque`添加大量元素：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we add `127` elements three times. This is because
    each allocation allocates enough for `128` elements, with one of the elements
    being used for bookkeeping. As shown, `std::deque` allocates three blocks of memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们三次添加了`127`个元素。这是因为每次分配都足够存储`128`个元素，其中一个元素用于记录。如所示，`std::deque`分配了三个内存块。
- en: Copying equal allocators
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制相等的分配器
- en: 'Copying containers with allocators that are equal is straightforward—this is
    because the allocators are interchangeable. To explore this, let''s add the following
    overloads to the previous allocator so that we may observe additional operations
    taking place:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相等分配器的容器的复制是直接的，因为分配器是可互换的。为了探索这一点，让我们在先前的分配器中添加以下重载，以便我们可以观察到额外的操作：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code adds a copy constructor, `copy assignment` operator, move
    constructor, and a `move assignment` operator, all of which have debug statements
    so that we may see what the container is doing. With the preceding addition, we
    will be able to see when a copy of an allocator is performed. Now let''s use this
    allocator in a container that is copied:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码添加了一个复制构造函数、`复制赋值`运算符、移动构造函数和一个`移动赋值`运算符，所有这些都有调试语句，以便我们可以看到容器在做什么。通过前面的添加，我们将能够看到分配器的复制是何时进行的。现在让我们在一个被复制的容器中使用这个分配器：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding example, we create two lists. In the first `std::list`, we
    add two elements to the list and then we copy the list to the second `std::list`.
    Finally, we add two more elements to the second `std::list`. The output is as
    follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了两个列表。在第一个`std::list`中，我们向列表添加了两个元素，然后将列表复制到第二个`std::list`。最后，我们向第二个`std::list`添加了两个元素。输出如下：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, each list creates the allocator that it plans to use, and the allocators
    create `std::list` nodes of 24 bytes. We then see the first allocator allocate
    memory for the two elements that are added to the first list. The second list
    is still empty just prior to copying the first list and, as a result, the second
    container creates a third, temporary allocator that it can use solely for copying
    the lists. Once this is done, we add the final two elements to the second list,
    and we can see the second list uses its original allocator to perform the allocations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，每个列表都创建了它打算使用的分配器，分配器创建了24字节的`std::list`节点。然后我们看到第一个分配器为添加到第一个列表中的两个元素分配内存。第二个列表在复制第一个列表之前仍然是空的，因此第二个容器创建了第三个临时分配器，它可以专门用于复制列表。完成这些操作后，我们将最后两个元素添加到第二个列表，我们可以看到第二个列表使用其原始分配器执行分配。
- en: '`std::list` is free to allocate memory from one allocator and deallocate from
    another, and this is seen in the deallocations, which is why `std::list` creates
    a temporary allocator during the copy, as it is free to do so. Whether a container
    should create temporary allocators is not the point (although it is likely a debatable
    optimization).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`可以自由地从一个分配器分配内存，然后从另一个分配器释放内存，这在释放内存时可以看到，这就是为什么`std::list`在复制期间创建临时分配器的原因。容器是否应该创建临时分配器并不是重点（尽管这可能是一个值得讨论的优化）。'
- en: Moving equal allocators
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动相等的分配器
- en: 'Moving a container is similar to copying a container if the allocators are
    equal. Once again, this is because there are no rules as to what the container
    has to do, since a container can use its original allocator to handle any memory,
    and if it needs to, it can create a new allocator, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 移动容器与复制容器类似，如果分配器相等。这是因为容器没有规则要做什么，因为容器可以使用其原始分配器来处理任何内存，如果需要，它可以创建一个新的分配器，如下所示：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, instead of copying the first container, we move it
    instead. As a result, the first container after the move is no longer valid, and
    the second container now owns the memory from the first container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不是复制第一个容器，而是移动它。因此，移动后的第一个容器不再有效，第二个容器现在拥有来自第一个容器的内存。
- en: 'The output of this example is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的输出如下：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similar to the copy example, the two lists are created and each `std::list`
    creates an allocator that manages the `std::list` nodes of 24 bytes. Two elements
    are added to the first list, and then the first list is moved into the second
    list. As a result, memory that belongs to the first list is now owned by the second
    container and no copies are performed. The second allocations to the second list
    are performed by its own allocator, as are all deallocations, since allocations
    from the first allocator can be deallocated using the second allocator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与复制示例类似，两个列表被创建，每个`std::list`创建一个管理24字节的`std::list`节点的分配器。两个元素被添加到第一个列表，然后第一个列表被移动到第二个列表。因此，属于第一个列表的内存现在由第二个容器拥有，并且不执行任何副本。第二个列表的第二个分配是由它自己的分配器执行的，所有的释放也是如此，因为可以使用第二个分配器来释放从第一个分配器分配的内存。
- en: Exploring some optional properties
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索一些可选属性
- en: 'C++ allocators provide some additional properties that are above and beyond `is_always_equal`.
    Specifically, the author of a C++ allocator can optionally define the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++分配器提供了一些额外的属性，这些属性超出了`is_always_equal`。具体来说，C++分配器的作者可以选择定义以下内容：
- en: '`propagate_on_container_copy_assignment`'
  id: totrans-113
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propagate_on_container_copy_assignment`'
- en: '`propagate_on_container_move_assignment`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propagate_on_container_move_assignment`'
- en: '`propagate_on_container_swap`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propagate_on_container_swap`'
- en: The optional properties tell a container how the allocator should be handled
    during a specific operation (that is, copy, move, and swap). Specifically, when
    a container is copied, moved, or swapped, the allocator isn't touched and, as
    we will show, this can result in inefficiencies. The propagate properties tell
    the container to propagate the operation to the allocator. For example, if `propagate_on_container_copy_assignment`
    is set to `std::true_type` and a container is being copied, the allocator must
    also be copied when normally it wouldn't be.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性告诉容器在特定操作（即复制、移动和交换）期间应如何处理分配器。具体来说，当容器被复制、移动或交换时，分配器不会被触及，这可能导致低效。传播属性告诉容器将操作传播到分配器。例如，如果`propagate_on_container_copy_assignment`设置为`std::true_type`并且正在复制容器，则在通常情况下不会复制分配器时，也必须复制分配器。
- en: To better explore these properties, let's create our first unequal allocator
    (that is, two different instances of the same allocator may not be equal). As
    stated, most allocators that are unequal are stateful. In this example, we will
    create a stateless, unequal allocator to keep things simple. Our last example
    in this chapter will create an unequal, stateful allocator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地探索这些属性，让我们创建我们的第一个不相等的分配器（即，相同分配器的两个不同实例可能不相等）。正如所述，大多数不相等的分配器是有状态的。在这个例子中，我们将创建一个无状态的不相等分配器，以保持简单。本章的最后一个例子将创建一个不相等的、有状态的分配器。
- en: 'To start our example, we first need to create a managed object for our allocator
    class, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的示例，我们首先需要为我们的分配器类创建一个托管对象，如下所示：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unequal allocators must adhere to the following properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不相等的分配器必须遵守以下属性：
- en: All copies of an allocator must be equal. This means that even if we create
    an unequal allocator, a copy of an allocator must still be equal. This becomes
    problematic when the rebind copy constructor is used, as this property still holds
    true (that is, even though two allocators may not have the same type, they may
    still have to be equal if one is the copy of another).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有分配器的副本必须相等。这意味着即使我们创建了一个不相等的分配器，分配器的副本仍必须相等。当使用重新绑定复制构造函数时，这会变得棘手，因为这个属性仍然成立（即使两个分配器可能不具有相同的类型，如果一个是另一个的副本，它们仍可能相等）。
- en: All equal allocators must be able to deallocate each other's memory. Once again,
    this becomes problematic when the rebind copy constructor is used. Specifically,
    this means that an allocator managing `int` objects might have to deallocate memory
    from an allocator managing `std::list` nodes.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有相等的分配器必须能够释放彼此的内存。再次，当使用重新绑定复制构造函数时，这变得棘手。具体来说，这意味着管理`int`对象的分配器可能必须从管理`std::list`节点的分配器中释放内存。
- en: 'To support these two rules, most unequal allocators end up being wrappers around
    a managed object. That is, an object is created that can allocate and deallocate
    memory and each allocator stores a pointer to this object. In the preceding example,  `myallocator_object{}`
    is the managed object capable of allocating and deallocating memory. To create
    this object, all we did was move `malloc()` and `free()` from the allocator itself
    into this `myallocator_object{}`; the code is the same. The only additional logic
    that was added to `myallocator_object{}` is the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这两条规则，大多数不相等的分配器最终都成为受控对象的包装器。也就是说，创建了一个可以分配和释放内存的对象，并且每个分配器都存储指向此对象的指针。在前面的示例中，`myallocator_object{}`是能够分配和释放内存的受控对象。要创建此对象，我们所做的就是将`malloc()`和`free()`从分配器本身移动到此`myallocator_object{}`中；代码是相同的。添加到`myallocator_object{}`的唯一附加逻辑是以下内容：
- en: The constructor takes a size. This is because we cannot create the managed object
    as a template class. Specifically, the managed object needs to be able to change
    the type of memory that it manages (because of the rules outlined). The specific
    need for this will be covered shortly.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数接受一个大小。这是因为我们无法将受控对象创建为模板类。具体来说，受控对象需要能够更改其管理的内存类型（根据所述规则）。不久将介绍此特定需求。
- en: A `rebind()` function was added that specifically changes the size of the memory
    being managed by the managed object. Once again, this allows us to change the
    size of the allocation being performed by `myallocator_object{}`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个`rebind()`函数，专门用于更改受控对象管理的内存大小。再次，这使我们能够更改`myallocator_object{}`执行的分配大小。
- en: 'Next, we need to define the allocator itself, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义分配器本身，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first part of the allocator is the same as the other allocators, requiring
    the use of a template class that allocators memory for some `T` type:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器的第一部分与其他分配器相同，需要使用为某个`T`类型分配内存的模板类：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next part of our allocator defines our type aliases and optional properties.
    As shown, all three propagate functions are undefined, which tells any container
    that uses this allocator that when a copy, move, or swap of the container occurs,
    the allocator is not copied, moved, or swapped as well (the container should continue
    using the same allocator it was given at construction).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配器的下一部分定义了我们的类型别名和可选属性。如图所示，所有三个传播函数都未定义，这告诉使用此分配器的任何容器，当容器发生复制、移动或交换时，分配器也不会被复制、移动或交换（容器应继续使用在构造时给定的相同分配器）。
- en: 'The next set of functions defines our constructors and operators. Let''s start
    with the default constructor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组函数定义了我们的构造函数和运算符。让我们从默认构造函数开始：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As with all of the constructors and operators, we output to `stdout` some debug
    information so that we can watch what the container is doing with the allocator.
    As shown, the default constructor allocates `myallocator_object{}` and stores
    it as `std::shared_ptr`. We leverage `std::shared_ptr`, as each copy of the allocator
    will have to be equal, and as a result, each copy must share the same managed
    object (so that memory allocated from one allocator can be deallocated from the
    copy). Since either allocator could be destroyed at any type, both *own* the managed
    object and as a result, `std::shared_ptr` is the more appropriate smart pointer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有构造函数和运算符一样，我们输出`stdout`一些调试信息，以便观察容器对分配器的操作。如图所示，默认构造函数分配`myallocator_object{}`并将其存储为`std::shared_ptr`。我们利用`std::shared_ptr`，因为每个分配器的副本都必须相等，因此每个副本必须共享相同的受控对象（以便可以从一个分配器分配的内存可以从副本中释放）。由于任何分配器都可能在任何时间被销毁，因此*拥有*受控对象，因此`std::shared_ptr`是更合适的智能指针。
- en: 'The next two functions are the move constructor and assignment operator:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数是移动构造函数和赋值运算符：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In both cases, we need to `std::move()` our managed object as a result of a
    move operation. The same thing applies for copying as well:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，由于移动操作的结果，我们需要`std::move()`我们的受控对象。对于复制也是一样的：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown, if a copy is made of the allocator, we must also copy the managed
    object. As a result, a copy of the allocator leverages the same managed object,
    which means that the copy can deallocate memory from the original.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，如果对分配器进行复制，我们也必须复制受控对象。因此，分配器的副本利用相同的受控对象，这意味着副本可以从原始对象中释放内存。
- en: 'The next function is what makes unequal allocators so difficult:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是使不相等的分配器如此困难的原因：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding function is the rebind copy constructor. The point of this constructor
    is to create a copy of another allocator of a different type. So for example,
    `std::list` starts off with `myallocator<int>{}`, but it really needs an allocator
    of the `myallocator<std::list::node>{}` type, not `myallocator<int>{}`. To overcome
    this, the preceding function allows a container to do something like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是重新绑定复制构造函数。此构造函数的目的是创建不同类型的另一个分配器的副本。例如，`std::list`从`myallocator<int>{}`开始，但实际上需要的是`myallocator<std::list::node>{}`类型的分配器，而不是`myallocator<int>{}`。为了克服这一点，前面的函数允许容器执行以下操作：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, `alloc2` is a copy of `alloc1`, even though `alloc1`
    and `alloc2` do not share the same `T` type. The problem is, an `int` is four
    bytes, while in our examples, `std::list::node` has been 24 bytes, which means
    that not only does the preceding function have to be able to create a copy of
    an allocator with a different type that is *equal*, it also has to be able to
    create a copy that is capable of deallocating memory of a different type (specifically,
    in this case, `alloc2` has to be able to deallocate ints even though it manages
    `std::list::node` elements). In our example, this is not a problem since we are
    using `malloc()` and `free()`, but as we will show in our last example, some stateful
    allocators, such as a memory pool, do not conform well to this requirement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`alloc2`是`alloc1`的副本，即使`alloc1`和`alloc2`的`T`类型不相同。问题是，一个`int`是四个字节，而在我们的例子中，`std::list::node`有24个字节，这意味着前面的函数不仅能够创建一个相等的不同类型的分配器的副本，还必须能够创建一个能够释放不同类型内存的副本（特别是在这种情况下，`alloc2`必须能够释放`int`，即使它管理`std::list::node`元素）。在我们的例子中，这不是问题，因为我们使用`malloc()`和`free()`，但正如我们将在最后的例子中展示的那样，一些有状态的分配器，比如内存池，不太符合这个要求。
- en: 'The `allocate` and `deallocate` functions are defined as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate`和`deallocate`函数定义如下：'
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since our managed object just calls `malloc()` and `free()`, we can treat the
    object's `allocate()` and `deallocate()` functions as `malloc()` and `free()`
    as well, and as such, the implementation is simple.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的托管对象只调用`malloc()`和`free()`，我们可以将对象的`allocate()`和`deallocate()`函数视为`malloc()`和`free()`，因此，实现很简单。
- en: 'Our private logic in the `allocator` class is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`allocator`类中的私有逻辑如下：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As stated, we store a smart pointer to the managed object, which allows us to
    create copies of the allocator. We also state that our equality functions are
    friends, and although we place these friend functions in the private portion of
    the class, we could have placed them anywhere as friend declarations are not affected
    by public/protected/private declarations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们存储了一个指向托管对象的智能指针，这允许我们创建分配器的副本。我们还声明我们的平等函数是友元的，尽管我们将这些友元函数放在类的私有部分，但我们可以将它们放在任何地方，因为友元声明不受公共/受保护/私有声明的影响。
- en: 'Finally, the equality functions are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，平等函数如下：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our *equal* allocator example simply returned true for `operator==` and false
    for `operator!=`, which stated that the allocators were equal (in addition to
    the use of `is_always_equal`). In this example, `is_always_equal` is set to `false`,
    and in our equality operators, we compare the managed objects. Each time a new
    allocator is created, a new managed object is created, and as a result, the allocators
    are not equal (that is, they are unequal allocators). The problem is, we cannot
    simply always return `false` for `operator==` because a copy of an allocator must
    always be equal to the original per the specification, which is the reason we
    use `std::shared_ptr`. Each copy of the allocator creates a copy of `std::shared_ptr`,
    and since we compare the address of the managed object if a copy of the allocator
    is made, the copy and the original have the same managed object and as a result,
    return `true` (that is, they are equal). Although `std::shared_ptr` may not be
    used, most unequal allocators are implemented this way, as it provides a simple
    way to handle the difference between equal and unequal allocators based on whether
    or not the allocator has been copied.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*equal*分配器示例只是对`operator==`返回true，对`operator!=`返回false，这表明分配器是相等的（除了使用`is_always_equal`）。在这个例子中，`is_always_equal`设置为`false`，在我们的相等运算符中，我们比较了托管对象。每次创建一个新的分配器，都会创建一个新的托管对象，因此，分配器不相等（也就是说，它们是不相等的分配器）。问题是，我们不能简单地总是对`operator==`返回`false`，因为根据规范，分配器的副本必须始终等于原始分配器，这就是我们使用`std::shared_ptr`的原因。每个分配器的副本都创建了一个`std::shared_ptr`的副本，因此，如果复制了分配器，我们比较托管对象的地址，复制和原始对象有相同的托管对象，因此返回`true`（也就是说，它们是相等的）。虽然可能不使用`std::shared_ptr`，但大多数不相等的分配器都是这样实现的，因为它提供了一种简单的处理相等和不相等分配器之间差异的方法，根据分配器是否已被复制。
- en: 'Now that we have an allocator, let''s test it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个分配器，让我们来测试一下：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, our allocator is capable of allocating and deallocating memory.
    The allocator in the preceding example was located at `0x561feb431590`, and the
    element that was allocated by the `std::list` container was located at `0x561feb43fec0`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的分配器能够分配和释放内存。在上面的例子中，分配器位于`0x561feb431590`，而由`std::list`容器分配的元素位于`0x561feb43fec0`。
- en: 'Copying an unequal container that has the propagate property set to `false`
    is simple, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个具有传播属性设置为“false”的不相等容器很简单，如下所示：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in the preceding example, we create two lists and populate both lists
    with two elements each. Once the lists are populated, we then copy the first container
    into the second, and we output to `stdout` so that we can see how the container
    handles this copy. Finally, we add two more elements to the just-copied container.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们创建了两个列表，并将两个列表都填充了两个元素。一旦列表填充完毕，我们就将第一个容器复制到第二个容器中，并输出到`stdout`，以便我们可以看到容器如何处理这个复制。最后，我们向刚刚复制的容器添加了两个元素。
- en: 'The output of this example is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的输出如下：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As shown, copying the containers does not involve the allocator. When the copy
    occurs, list two keeps the two allocations it already has, overwriting the values
    for the first two elements. Since the propagate properties are `false`, the second
    container keeps the allocator it was originally given, and uses the allocator
    to allocate the second two elements after the copy, but also deallocate all of
    the previously-allocated elements when the list loses scope.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，复制容器不涉及分配器。当发生复制时，列表2保留它已经拥有的两个分配，覆盖前两个元素的值。由于传播属性为`false`，第二个容器保留了它最初给定的分配器，并在复制后使用分配器来分配另外两个元素，但在列表失去作用域时也释放了之前分配的所有元素。
- en: The problem with this approach is the need for the container to loop through
    each element and perform a manual copy. For integers, this type of copy is fine,
    but we could have stored large structures in the list and as a result, copying
    the containers would have resulted in copying each element in the container, which
    is wasteful and expensive. Since the propagate property is `false`, the container
    has no choice as it cannot use the allocator from the first list and it cannot
    use its own allocator to copy the elements allocated in the first list (since
    the allocators are not equal). Although this is wasteful, as will be shown, this
    approach may still be the fastest approach.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于容器需要循环遍历每个元素并执行手动复制。对于整数来说，这种类型的复制是可以的，但是我们可能已经在列表中存储了大型结构，因此复制容器将导致复制容器中的每个元素，这是浪费和昂贵的。由于传播属性为`false`，容器没有选择，因为它不能使用第一个列表的分配器，也不能使用自己的分配器来复制在第一个列表中分配的元素（因为分配器不相等）。尽管这是浪费的，但如将会展示的，这种方法可能仍然是最快的方法。
- en: 'Moving a list has a similar issue:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 移动列表存在类似的问题：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, we do the same thing we did in the previous example.
    We create two lists, and add two elements to each list just before moving one
    list to another.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们做了与之前示例中相同的事情。我们创建了两个列表，并在将一个列表移动到另一个列表之前向每个列表添加了两个元素。
- en: 'The results of this example are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果如下：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, we can see that the same inefficiency exists. Since
    the propagate property is `false`, the container cannot use the allocator from
    the first list and instead, must continue to use the allocator that it already
    has. As a result, the move operation cannot simply move the internal container
    from one list to another, but instead it must loop through the entire container,
    executing `std::move()` on each individual element such that the memory associated
    with each node in the list is still managed by the second list's original allocator.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到相同的低效性。由于传播属性为`false`，容器不能使用第一个列表的分配器，而必须继续使用它已经拥有的分配器。因此，移动操作不能简单地将内部容器从一个列表移动到另一个列表，而必须循环遍历整个容器，在每个单独的元素上执行`std::move()`，以便与列表中的每个节点相关联的内存仍然由第二个列表的原始分配器管理。
- en: 'To overcome these issues, we will add the following to our allocator:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，我们将向我们的分配器添加以下内容：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These properties tell any container that uses this allocator that if a copy,
    move, or swap of the container occurs, the same operation should occur with the
    allocator. For example, if we copy `std::list`, the container must not only *copy* the
    elements, but it should also copy the allocator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性告诉使用这个分配器的任何容器，如果容器发生复制、移动或交换，分配器也应该执行相同的操作。例如，如果我们复制`std::list`，容器不仅必须*复制*元素，还必须复制分配器。
- en: 'Let''s look at the following copy example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下复制示例：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This copy example is the same as our previous copy example. We create two lists
    and add two elements to each list. We then copy the first list into the second
    list and then add two additional elements into the second list before finishing
    (which ultimately will deallocate the lists).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复制示例与我们之前的复制示例相同。我们创建两个列表，并向每个列表添加两个元素。然后我们将第一个列表复制到第二个列表，然后在完成之前向第二个列表添加两个额外的元素（最终将释放列表）。
- en: 'The results of this example are as follows. It should be noted that this output
    is a bit more complicated, so we will take this one step at a time:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果如下。应该注意，这个输出有点复杂，所以我们将一步一步地进行：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding output, both lists are created and two elements are added
    to each container. Next, the output will show what happens when we copy the second
    container into the first:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，两个列表都被创建，并且向每个容器添加了两个元素。接下来，输出将展示当我们将第二个容器复制到第一个容器时会发生什么：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since we set the propagate property to `false`, the container now has the option
    to keep the memory used by the first container (for example, to implement a copy-on-write
    implementation). This is because the container should create a copy of the allocator
    and any two copies of an allocator are equal (that is, they can deallocate each
    other's memory). This implementation of glibc does not do this. Instead, it attempts
    to create a clean view of memory. The two lists, allocators are not equal, which
    means that once the copy has taken place, the container will no longer be able
    to deallocate its own, previously-allocated memory (because it will likely no
    longer have access to its original allocator). As a result, the container deletes
    all of the memory it previously allocated as its first step. It then creates a
    temporary allocator using a rebind copy of the first list's allocator (which oddly
    seems to be unused), just before creating a direct copy of the first list's allocator
    and using it to allocator new memory for the elements that will be copied.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将传播属性设置为`false`，容器现在可以选择保留第一个容器使用的内存（例如，实现写时复制）。这是因为容器应该创建分配器的副本，任何两个分配器的副本都是相等的（即，它们可以释放彼此的内存）。glibc的这种实现并不这样做。相反，它试图创建一个干净的内存视图。两个列表的分配器不相等，这意味着一旦复制发生，容器将不再能够释放自己先前分配的内存（因为它可能不再能够访问其原始分配器）。因此，容器首先删除它先前分配的所有内存。然后，它使用第一个列表分配器的重新绑定副本创建一个临时分配器（这似乎是未使用的），然后创建第一个列表分配器的直接副本，并使用它来为将要复制的元素分配新的内存。
- en: 'Finally, now that the copy is complete, the last two elements can be added
    to the second list, and each list can be destroyed once they lose scope:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在复制完成，最后两个元素可以添加到第二个列表中，每个列表在失去作用域时都可以被销毁：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As shown, since the allocator was propagated, the same allocator is used to
    deallocate the elements from both lists. This is because once the copy is complete,
    both lists are now using the same allocator (as a copy of any two allocators must
    be equal, and the way that we chose to implement this was to create a copy of
    the same base allocator object when a copy occurs). It should also be noted that
    the glibc implementation does not choose to implement a copy-on-write scheme,
    which means not only that the implementation fails to take advantage of the possible
    optimizations that the propagate property provides, but the implementation of
    a copy is actually slower, as the copy not only has to copy each element one at
    a time, but must also allocate new memory for the copy as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所示，由于分配器被传播，因此相同的分配器用于从两个列表中释放元素。这是因为一旦复制完成，两个列表现在都使用相同的分配器（因为任何两个分配器的副本必须相等，我们选择实现的方式是在发生复制时创建相同基本分配器对象的副本）。还应该注意，glibc实现没有选择实现写时复制方案，这意味着实现不仅未能利用传播属性提供的可能优化，而且复制的实现实际上更慢，因为复制不仅必须逐个元素复制，还必须为复制分配新的内存。
- en: 'Now let''s look at a move example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个移动示例：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Like our previous move example, this creates two lists, and adds two elements
    to each list just before moving the first list into the second. Finally, our example
    adds two elements to the second list (which is now the first list), before completing
    and deallocating both lists when they lose scope.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的移动示例一样，这创建了两个列表，并在将第一个列表移动到第二个列表之前向每个列表添加了两个元素。最后，我们的示例在第二个列表（现在是第一个列表）中添加了两个元素，然后在失去作用域时完成并释放了两个列表。
- en: 'The resulting output of this example is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出结果如下：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Like the previous examples, you can see the lists being created and the first
    elements being added to each list. Once the move occurs, the second list deletes
    the memory associated with its previously-added elements. This is because once
    the move occurs, the memory associated with the second list is no longer needed
    (as it is about to be replaced with the memory allocated by the first list). This
    is possible since the first list's allocator will be moved to the second list
    (since the propagate property was set to `true`), and as a result, the second
    list will now own all of the first list's memory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的示例一样，你可以看到列表被创建，并且第一个元素被添加到每个列表中。一旦移动发生，第二个列表将删除与其先前添加的元素相关联的内存。这是因为一旦移动发生，与第二个列表相关联的内存就不再需要了（因为它将被第一个列表分配的内存替换）。这是可能的，因为第一个列表的分配器将被移动到第二个列表（因为传播属性被设置为`true`），因此第二个列表现在将拥有第一个列表的所有内存。
- en: Finally, the last two elements are added to the list and the lists lose scope
    and deallocate all of their memory. As shown, this is the most optimal implementation.
    No additional memory is allocated no element-by-element move is needed. The move
    operation simply moves the memory and allocator from one container to the other.
    Also, since no copy of the allocators is made, this is a simple operation for
    any allocator to support, and as such, this property should always be set to true.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个元素被添加到列表中，列表失去作用域并释放所有内存。正如所示，这是最优化的实现。不需要额外的内存分配，也不需要逐个元素的移动。移动操作只是将内存和分配器从一个容器移动到另一个容器。此外，由于没有复制分配器，这对于任何分配器来说都是一个简单的操作，因此，这个属性应该始终设置为true。
- en: Optional functions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选函数
- en: 'In addition to properties, there are several optional functions that provide
    containers with additional information about the type of allocator they are provided.
    One optional function is the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性之外，还有几个可选的函数，可以为容器提供有关所提供的分配器类型的附加信息。一个可选的函数如下：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `max_size()` function tells the container the max size, "n", that an allocator
    can allocate. In C++17, this function has been deprecated. The `max_size()` function
    returns the largest possible allocation that the allocator can perform. Curiously,
    in C++17, this defaults to `std::numeric_limits<size_type>::max() / sizeof(value_type)`,
    which in most cases is likely not a valid answer as most systems simply do not
    have this much available RAM, suggesting this function provides little value in
    practice. Instead, like other allocation schemes in C++, `std::bad_alloc` will
    be thrown if and when an allocation fails, indicating to the container that the
    allocation it attempted to perform is not possible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_size()` 函数告诉容器分配器可以分配的最大大小“n”。在C++17中，此函数已被弃用。`max_size()` 函数返回分配器可以执行的最大可能分配。耐人寻味的是，在C++17中，这默认为
    `std::numeric_limits<size_type>::max() / sizeof(value_type)`，在大多数情况下可能不是一个有效的答案，因为大多数系统根本没有这么多可用的RAM，这表明这个函数在实践中提供的价值很小。相反，就像C++中的其他分配方案一样，如果分配失败，将抛出`std::bad_alloc`，表示容器尝试执行的分配是不可能的。'
- en: 'Another set of optional functions in C++ is the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的另一组可选函数如下：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Just like with the `max_size()` function, the construct and destruct functions
    were deprecated in C++17\. Prior to C++17, these functions could be used to construct
    and destruct the object associated with the provided by `ptr`. It should be noted
    that this is why we do not use new and delete when allocating memory in a constructor,
    but instead use `malloc()` and `free()`. If we were to use `new()` and `delete()`,
    we would accidentally call the constructor and/or destructor of the object twice,
    which would lead to undefined behavior.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`max_size()`函数一样，构造和析构函数在C++17中已被弃用。在C++17之前，这些函数可以用于构造和析构与`ptr`提供的对象相关联的对象。应该注意的是，这就是为什么在构造函数中分配内存时我们不使用new和delete，而是使用`malloc()`和`free()`。如果我们使用`new()`和`delete()`，我们会意外地调用对象的构造函数和/或析构函数两次，这将导致未定义的行为。
- en: Studying an example of stateless, cache–aligned allocator
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究一个无状态、缓存对齐的分配器的示例
- en: In this example, we will create a stateless, equal allocator designed to allocator
    cache-aligned memory. The goal of this allocator is to show a C++17 allocator
    that can be leveraged to increase the efficiency of the objects a container is
    storing (for example, a linked list), as cache-thrashing is less likely to occur.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个无状态的、相等的分配器，旨在分配对齐缓存的内存。这个分配器的目标是展示一个可以利用的C++17分配器，以增加容器存储的对象（例如链表）的效率，因为缓存抖动不太可能发生。
- en: 'To start, we will define the allocator as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义分配器如下：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding allocator is similar to the other equal allocators that we have
    created in this chapter. There are a couple of notable differences:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的分配器类似于本章中创建的其他相等分配器。有一些显著的不同之处：
- en: The template signature of the allocator is different. Instead of just defining
    the allocator type `T`, we also added an `Alignment` parameter and set the default
    value to `0x40` (that is, the allocations will be 64-byte-aligned, which is the
    typical size of a cache line on Intel CPUs).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器的模板签名不同。我们不仅定义了分配器类型`T`，还添加了一个`Alignment`参数，并将默认值设置为`0x40`（即，分配将是64字节对齐的，这是Intel
    CPU上典型的缓存行大小）。
- en: We also provide our own rebind structure. Typically, this structure is provided
    for us, but since our allocator has more than one template argument, we must provide
    our own version of the rebind structure. This structure is used by a container,
    such as `std::list`, to create any allocator the container needs without having
    to create a copy (instead, it can directly create an allocator during initialization).
    In our version of this rebind structure, we pass the `Alignment` parameter that
    is provided by the original allocator.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还提供了自己的重新绑定结构。通常，这个结构是为我们提供的，但由于我们的分配器有多个模板参数，我们必须提供我们自己版本的重新绑定结构。这个结构被容器使用，比如`std::list`，来创建容器需要的任何分配器，而不必创建一个副本（相反，它可以在初始化期间直接创建一个分配器）。在我们的这个重新绑定结构版本中，我们传递了原始分配器提供的`Alignment`参数。
- en: The rebind copy constructor must also define the `Alignment` variable. In this
    case, we force the `Alignment` to be the same if a rebind is going to occur, which
    will be the case as the rebind structure provides the `Alignment` (which is also
    the same).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新绑定复制构造函数还必须定义`Alignment`变量。在这种情况下，如果要进行重新绑定，我们强制`Alignment`保持相同，这将是情况，因为重新绑定结构提供了`Alignment`（也是相同的）。
- en: 'To test our example, let''s create the allocator and output the address of
    an allocation to ensure that the memory is aligned:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的例子，让我们创建分配器并输出一个分配的地址，以确保内存对齐：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As shown, the memory that was allocated is at least 64-byte-aligned. The same
    thing is true for multiple allocations, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，分配的内存至少是64字节对齐的。多次分配也是如此：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As shown, the memory allocated is also at least 64-byte-aligned. We can also
    use this allocator with a container:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，分配的内存也至少是64字节对齐的。我们还可以将这个分配器与一个容器一起使用：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And once again, the memory is still properly aligned.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，内存仍然是正确对齐的。
- en: Compiling and testing
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方法编译这段代码：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To execute the example, run the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个例子，运行以下命令：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output should resemble the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As shown in the preceding snippet, we are able to allocate different types of
    memory, as well as deallocate this memory and all of the addresses are 64-byte-aligned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，我们能够分配不同类型的内存，以及释放这些内存，所有的地址都是64字节对齐的。
- en: Studying an example of a stateful, memory–pool allocator
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究一个有状态的、内存池分配器的例子
- en: In this example, we will create a far more complicated allocator, called a **pool
    allocator**. The goal of the pool allocator is to quickly allocate memory for
    a fixed-size type while simultaneously (and more importantly) reducing internal
    fragmentation of memory (that is, the amount of memory that is wasted by each
    allocation, even if the allocation size is not a multiple of two or some other
    optimized allocation size).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个更复杂的分配器，称为**内存池分配器**。内存池分配器的目标是快速为固定大小的类型分配内存，同时（更重要的是）减少内存的内部碎片（即，每个分配浪费的内存量，即使分配大小不是二的倍数或其他优化的分配大小）。
- en: Memory-pool allocators are so useful that some implementations of C++ already
    contain pool allocators. In addition, C++17 technically has support for a pool
    allocator in something called a **polymorphic allocator** (which is not covered
    in this book, as no major implementations of C++17 have support for polymorphic
    allocators at the time of writing), and most operating systems leverage pool allocators
    within the kernel to reduce internal fragmentation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 内存池分配器是如此有用，以至于一些C++的实现已经包含了内存池分配器。此外，C++17在技术上支持一种称为**多态分配器**的内存池分配器（本书未涵盖，因为在撰写时，没有主要的C++17实现支持多态分配器），大多数操作系统在内核中利用内存池分配器来减少内部碎片。
- en: 'The major advantages of a pool allocator are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 内存池分配器的主要优点如下：
- en: The use of `malloc()` is slow. Sometimes `free()` is slow too, but for some
    implementations, `free()` is as simple as flipping a bit, in which case it can
    be implemented incredibly fast.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`malloc()`是慢的。有时`free()`也很慢，但对于一些实现，`free()`就像翻转一个位一样简单，这样它可以实现非常快的速度。
- en: Most pool allocators leverage a deque structure, meaning the pool allocator
    allocates a large *block* of memory and then divides this memory up for allocations.
    Each *block* of memory is linked using a linked list so that more memory can be
    added to the pool as needed.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数池分配器利用deque结构，这意味着池分配器分配了一个大的内存*块*，然后将这个内存分割为分配。每个内存*块*都使用链表链接，以便根据需要向池中添加更多内存。
- en: Pool allocators also have an interesting property where the larger the block
    size, the larger the reduction is on internal fragmentation. The penalty for this
    optimization is that if the pool is not completely utilized, the amount of memory
    that is wasted increases as the block size increases, so pool allocators should
    be tailored to meet the needs of the application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 池分配器还具有一个有趣的特性，即块大小越大，内部碎片的减少就越大。这种优化的代价是，如果池没有完全利用，那么随着块大小的增加，浪费的内存量也会增加，因此池分配器应该根据应用程序的需求进行定制。
- en: To start our example, we will first create a `pool` class that manages a list
    of *blocks* and gives out memory from the blocks. The list of blocks will be stored
    in a stack that grows forever (that is, in this example, we will attempt to defragment
    the memory in the blocks, or remove a block from the stack if all memory from
    the block has been freed). Each time we add a block of memory to the pool, we
    will divide up the block into chunks of the size of `sizeof(T)`, and add the address
    of each chunk onto a second stack called the address stack. When memory is allocated,
    we will pop an address off the address stack, and when memory is deallocated,
    we will push the address back onto the stack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的示例，我们首先创建一个管理*块*列表并从*块*中分配内存的`pool`类。*块*列表将存储在一个永远增长的堆栈中（也就是说，在这个示例中，我们将尝试对*块*中的内存进行碎片整理，或者如果*块*中的所有内存都已被释放，则从堆栈中移除*块*）。每次我们向池中添加一个内存块时，我们将将内存块分割为`sizeof(T)`大小的块，并将每个块的地址添加到称为地址堆栈的第二个堆栈中。当分配内存时，我们将从地址堆栈中弹出一个地址，当释放内存时，我们将地址推回堆栈。
- en: 'The beginning of our pool is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们池的开始如下：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The pool will act as our managed object for our unequal allocator, as was the
    case with our previous unequal allocator example. As a result, the pool is not
    a template class, as we will need to change the size of the pool if the rebind
    copy constructor is used (more on that specific topic to come). As shown, in our
    constructor, we store the size of the pool, but we do not attempt to preload the
    pool.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 池将充当我们不均匀分配器的托管对象，就像我们以前的不均匀分配器示例一样。因此，池不是一个模板类，因为如果使用重新绑定复制构造函数，我们将需要更改池的大小（更多关于这个特定主题的内容即将到来）。如图所示，在我们的构造函数中，我们存储了池的大小，但我们并没有尝试预加载池。
- en: 'To allocate, we pop an address from our address stack and return it. If the
    address stack is empty, we add more addresses to the address stack by allocating
    another block of memory, adding it to the stack of blocks, dividing up the memory
    into chunks, and adding the divided up chunks to the address stack, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配，我们从地址堆栈中弹出一个地址并返回它。如果地址堆栈为空，我们通过分配另一个内存块并将其添加到块堆栈中，将内存分割成块，并将分割的块添加到地址堆栈中，如下所示：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To deallocate memory, we push the address provided to the address stack so
    that it can be allocated again later on. Using this method, allocating and deallocating
    memory for a container is as simple as popping and pushing an address to a single
    stack:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了释放内存，我们将提供的地址推送到地址堆栈中，以便以后可以重新分配。使用这种方法，为容器分配和释放内存就像从单个堆栈中弹出和推送地址一样简单：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will need to change the size of the pool if the rebind copy constructor
    is used. This type of copy should only occur when attempting to create an allocator
    of the `int` type to an allocator of the `std::list::node` type, which means that
    the allocator being copied will not have been used yet, meaning a resize is possible.
    If the allocator has been used, it would mean that the allocator has already allocated
    memory of a different size and, as a result, a rebind would be impossible with
    this implementation. Consider the following code for it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用重新绑定复制构造函数，则需要更改池的大小。这种类型的复制只有在尝试将`int`类型的分配器创建为`std::list::node`类型的分配器时才会发生，这意味着要复制的分配器尚未被使用，这意味着可以调整大小。如果分配器已经被使用，这意味着分配器已经分配了不同大小的内存，因此在这种实现中重新绑定是不可能的。考虑以下代码：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It should be noted that there are other ways to handle this specific issue.
    For example, a `std::list` could be created that doesn't attempt to use the rebind
    copy constructor. An allocator could also be created that is capable of managing
    more than one pool of memory, each pool being capable of allocating and deallocating
    memory of a specific type (which, of course, would result in a performance hit).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，还有其他处理这个特定问题的方法。例如，可以创建一个不尝试使用重新绑定复制构造函数的`std::list`。还可以创建一个能够管理多个内存池的分配器，每个池都能够分配和释放特定类型的内存（当然，这将导致性能下降）。
- en: 'In our private section, we have the `add_addrs()` function that was seen in
    the `allocate` function. The goal of, `this` function is to refill the address
    stack. To do this, the `this` function allocates another block of memory, divides
    the memory up, and adds it to the address stack:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的私有部分，我们有`add_addrs()`函数，这个函数在`allocate`函数中看到过。`this`函数的目标是重新填充地址堆栈。为此，`this`函数分配另一个内存块，将内存分割，并将其添加到地址堆栈中：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we have the private member variables, which includes the pool''s size,
    the address stack, and the stack of blocks. Note that we use `std::stack` for
    this. `std::stack` uses `std::deque` to implement the stack, and although a more
    efficient stack can be written that doesn''t leverage iterators, in testing, `std::stack`
    is nearly as performant:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有私有成员变量，其中包括池的大小、地址堆栈和块堆栈。请注意，我们使用`std::stack`。`std::stack`使用`std::deque`来实现堆栈，尽管可以编写一个不使用迭代器的更有效的堆栈，但在测试中，`std::stack`的性能几乎一样好：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The allocator itself is nearly identical to the previous unequal allocator
    we already defined:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器本身与我们已经定义的先前的不平等分配器几乎完全相同：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: One difference is that we define `propagate_on_container_copy_assignment` as
    `false`, specifically to prevent the allocator from being copied as much as possible.
    This choice is also backed by the fact that we already determined that glibc doesn't
    provide a huge benefit turning this property on when leveraging an unequal allocator.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区别是我们将`propagate_on_container_copy_assignment`定义为`false`，特意防止分配器尽可能少地被复制。这个选择也得到了支持，因为我们已经确定glibc在使用不平等分配器时并不会提供很大的好处。
- en: 'The constructors are the same as previously defined:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数与先前定义的相同：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `allocate` and `deallocate` functions are the same as previously defined,
    calling the pool''s allocation function. One difference is that our pool is only
    capable of allocating memory in single chunks (that is, the pool allocator is
    not capable of allocating more than one address while also preserving continuity).
    As a result, if `n` is something other than `1` (that is, the container is not
    `std::list` or `std::map`), we fall back to a `malloc()`/`free()` implementation,
    which is typically the default implementation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate`和`deallocate`函数与先前定义的相同，调用池的分配函数。一个区别是我们的池只能分配单个块的内存（也就是说，池分配器不能分配多个地址同时保持连续性）。因此，如果`n`不是`1`（也就是说，容器不是`std::list`或`std::map`），我们将退回到`malloc()`/`free()`实现，这通常是默认实现：'
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The rest of the allocator is the same:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器的其余部分与先前定义的相同：
- en: '[PRE67]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, before we can test our allocator, we will need to define a benchmarking
    function, capable of giving us an indication of how long a specific operation
    takes. This function will be defined in better detail in [Chapter 11](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml),
    *Time Interfaces in Unix*. For now, the most important thing to understand is
    that this function takes a callback function as an input (in our case, a Lambda),
    and returns a number. The higher the returned number, the longer the callback
    function took to execute:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在测试我们的分配器之前，我们需要定义一个基准测试函数，能够给我们一个特定操作所需时间的指示。这个函数将在[第11章](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml)中更详细地定义，*Unix中的时间接口*。目前，最重要的是要理解这个函数将一个回调函数作为输入（在我们的情况下是Lambda），并返回一个数字。返回的数字越高，回调函数执行的时间越长：
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first test we will perform is creating two lists and adding elements to
    each list, while timing how long it takes to add all of the elements to the list.
    Since each addition to the list requires an allocation, performing this test will
    give us a rough comparison on how much better our allocator is at allocating memory
    compared to the default allocator provided by glibc.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行的第一个测试是创建两个列表，并向每个列表添加元素，同时计算添加所有元素到列表所需的时间。由于每次添加到列表都需要分配，执行此测试将使我们大致比较我们的分配器在分配内存方面与glibc提供的默认分配器相比有多好。
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As stated, for each list, we add `100000` integers to the list and time how
    long it takes, giving us the ability to compare the allocators. The results are
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对于每个列表，我们向列表中添加`100000`个整数，并计算所需的时间，从而使我们能够比较分配器。结果如下：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As shown, our allocator is 219% faster than the default allocator at allocating
    memory.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们的分配器在分配内存方面比默认分配器快219%。
- en: 'In our next test, we will compare our allocator with the default allocator
    with respect to deallocating memory. To perform this test, we will do the same
    thing as before, but instead of timing our allocations, we will time how long
    it takes to remove elements from each list:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个测试中，我们将比较我们的分配器与默认分配器在释放内存方面的表现。为了执行此测试，我们将做与之前相同的事情，但是不是计时我们的分配，而是计时从每个列表中删除元素所需的时间：
- en: '[PRE71]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The results of the `this` function are as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`函数的结果如下：'
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As shown, our allocator is only 81% as fast as the default allocator. This is
    likely because the `free()` function is more efficient, which is not a surprise,
    as pushing to a stack could, in theory, be slower than some implementations of
    `free()`. Even though our `free()` function is slower, the difference is negligible
    compared to the improvement in both allocations and fragmentation. It is also
    important to note that the allocation and deallocation speeds are almost the same
    with this implementation, which is what we would expect.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们的分配器只有默认分配器的81%那么快。这可能是因为`free()`函数更有效率，这并不奇怪，因为理论上推送到堆栈可能比某些`free()`的实现更慢。即使我们的`free()`函数较慢，与分配和碎片化改进相比，差异微不足道。还要注意的是，这种实现的分配和释放速度几乎相同，这是我们所期望的。
- en: 'To ensure we wrote our allocator correctly, the following will run our test
    again, but instead of timing how long it takes to add elements to the list, we
    will add up each value in the list. If our total is as we expect, we will know
    that allocations and deallocations were performed properly:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们正确编写了分配器，以下将再次运行我们的测试，但是不是计算向列表添加元素所需的时间，而是计算列表中每个值的总和。如果我们的总和符合预期，我们将知道分配和释放已正确执行：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As expected, the output of our test is `success`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们的测试输出是“成功”。
- en: Compiling and testing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方式编译这段代码：
- en: '[PRE74]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To execute the example, run the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行示例，请运行以下命令：
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output should resemble the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As you can see, the output of our example matches the output we provided before.
    It should be noted that your results might very based on factors such as the hardware
    or what is already running on the box.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的示例输出与我们之前提供的输出相匹配。需要注意的是，你的结果可能会根据硬件或已在系统上运行的内容等因素而有所不同。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to create our own allocators, and covered
    the intricate details of the C++ allocator concept. Topics included the difference
    between equal and unequal allocators, how container propagation is handled, rebinding,
    and potential issues with stateful allocators. Finally, we concluded with two
    different examples. The first example demonstrated how to create a simple, cache-aligned
    allocator that is stateless, while the second provided a functional example of
    a stateful object allocator that maintains a free pool for fast allocations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何创建自己的分配器，并涵盖了C++分配器概念的复杂细节。主题包括相等和不相等分配器之间的区别，容器传播的处理方式，重新绑定以及有状态分配器可能出现的问题。最后，我们用两个不同的例子总结了。第一个例子演示了如何创建一个简单的、缓存对齐的无状态分配器，而第二个例子提供了一个有状态对象分配器的功能示例，该分配器维护一个用于快速分配的空闲池。
- en: In the next chapter, we will use several examples to demonstrate how to program
    POSIX sockets (that is, network programming) using C++.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用几个示例来演示如何使用C++编程POSIX套接字（即网络编程）。
- en: Questions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does `is_always_equal` mean?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is_always_equal`是什么意思？'
- en: What determines whether an allocator is equal or unequal?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么决定了分配器是相等还是不相等？
- en: Can a stateful allocator be equal?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个有状态的分配器可以是相等的吗？
- en: Can a stateless allocator be equal?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个无状态的分配器可以是相等的吗？
- en: What does `propagate_on_container_copy_assignment` do?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`propagate_on_container_copy_assignment`是做什么的？'
- en: What does the rebind copy constructor do for a container?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于容器，rebind复制构造函数的作用是什么？
- en: What is the difference between `std::list` and `std::vector` with respect to
    the `n` variable passed to the allocate function?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于传递给allocate函数的`n`变量，`std::list`和`std::vector`有什么区别？
- en: Further reading
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
