- en: '*Chapter 7*: Handling AST'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：处理 AST'
- en: In the previous chapter, we learned how Clang's preprocessor handles preprocessing
    directives in C-family languages. We also learned how to write different kinds
    of preprocessor plugins, such as pragma handlers, to extend Clang's functionalities.
    Those skills are especially useful when it comes to implementing field-specific
    logic or even custom language features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 Clang 预处理器如何处理 C 家族语言的预处理指令。我们还学习了如何编写不同类型的预处理器插件，例如 pragma 处理器，以扩展
    Clang 的功能。这些技能在实现特定领域的逻辑甚至自定义语言特性时特别有用。
- en: In this chapter, we're going to talk about a **semantic-aware** representation
    of the original source code file once it has been parsed, known as an **Abstract
    Syntax Tree (AST)**. An AST is a format that carries rich semantic information,
    including types, expression trees, and symbols, to name a few. It is not only
    used as a blueprint to generate LLVM IR for later compilation stages but is also
    the recommended format for performing static analysis. On top of that, Clang also
    provides a nice framework for developers to intercept and manipulate AST in the
    middle of the frontend pipeline via a simple plugin interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论原始源代码文件解析后的**语义感知**表示，称为**抽象语法树 (AST)**。AST 是一种包含丰富语义信息的格式，包括类型、表达式树和符号等。它不仅用作生成后续编译阶段的
    LLVM IR 的蓝图，也是执行静态分析的首选格式。除此之外，Clang 还为开发者提供了一个很好的框架，通过简单的插件接口在前端管道的中间拦截和操作 AST。
- en: 'In this chapter, we are going to cover how to process AST in Clang, the important
    APIs for in-memory AST representation, and how to write AST plugins to implement
    custom logic with little effort. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何在 Clang 中处理 AST，内存中 AST 表示的重要 API，以及如何编写 AST 插件以轻松实现自定义逻辑。我们将涵盖以下主题：
- en: Learning about AST in Clang
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Clang 中的 AST
- en: Writing AST plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 AST 插件
- en: By the end of this chapter, you will know how to work with AST in Clang in order
    to analyze programs at the source code level. In addition, you will know how to
    inject custom AST processing logic into Clang in an easy way via AST plugins.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何使用 Clang 处理 AST 以在源代码级别分析程序。此外，你将了解如何通过 AST 插件以简单的方式将自定义 AST 处理逻辑注入
    Clang。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter expects that you have a build of the `clang` executable. If you
    don''t, please build it using the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经构建了 `clang` 可执行文件。如果你还没有，请使用以下命令构建它：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition, you can use the following command-line flag to print out the textual
    representation of AST:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用以下命令行标志来打印出 AST 的文本表示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, let''s say `foo.c` contains the following content:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 `foo.c` 包含以下内容：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By using the `-Xclang -ast-dump` command-line flag, we can print out AST for
    `foo.c`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `-Xclang -ast-dump` 命令行标志，我们可以打印出 `foo.c` 的 AST：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This flag is useful for finding out what C++ class is used to represent a certain
    part of the code. For example, the formal function parameter/argument is represented
    by the `ParmVarDecl` class, which is highlighted in the previous code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志有助于找出用于表示代码特定部分的 C++ 类。例如，形式函数参数/参数由 `ParmVarDecl` 类表示，这在之前的代码中已突出显示。
- en: 'The code samples for this chapter can be found here: [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在以下位置找到：[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07)。
- en: Learning about AST in Clang
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Clang 中的 AST
- en: In this section, we are going to learn about Clang's AST in-memory representation
    and its essential API usage. The first part of this section will provide you with
    a high-level overview of Clang AST's hierarchy; the second part will focus on
    a more specific topic regarding type representation in Clang AST; and the final
    part will show you the basic usage of AST matcher, which is extremely useful when
    you're writing an AST plugin.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 Clang 的 AST 内存表示及其基本 API 使用。本节的第一部分将为你提供一个 Clang AST 层次结构的高级概述；第二部分将关注
    Clang AST 中类型表示的更具体主题；最后一部分将展示 AST 匹配器的基本用法，这在编写 AST 插件时非常有用。
- en: In-memory structure of Clang AST
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang AST 的内存结构
- en: 'The in-memory representation of AST in Clang is organized in a hierarchy structure
    that resembles the syntax structure of C-family language programs. Starting from
    the top-most level, there are two classes worth mentioning:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 中 AST 的内存表示组织成一个类似于 C 家族语言程序语法结构的层次结构。从最高层开始，有两个类值得提及：
- en: '`TranslationUnitDecl`: This class represents an input source file, also called
    a translation unit (most of the time). It contains all the top-level declarations
    – global variables, classes, and functions, to name a few – as its children, where
    each of those top-level declarations has its own subtree that recursively defines
    the rest of the AST.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TranslationUnitDecl`：此类表示一个输入源文件，也称为翻译单元（大多数情况下）。它包含所有顶级声明——全局变量、类和函数等，作为其子节点，其中每个顶级声明都有自己的子树，递归地定义了
    AST 的其余部分。'
- en: '`ASTContext`: As its name suggests, this class keeps track of all the AST nodes
    and other metadata from the input source files. If there are multiple input source
    files, each of them gets its own `TranslationUnitDecl`, but they all share the
    same `ASTContext`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASTContext`：正如其名称所示，此类跟踪来自输入源文件的所有 AST 节点和其他元数据。如果有多个输入源文件，每个文件都获得自己的 `TranslationUnitDecl`，但它们都共享相同的
    `ASTContext`。'
- en: 'In addition to the structure, the body of the AST – the AST nodes – can be
    further classified into three primary categories: `Decl`, `Expr`, and `Stmt` classes,
    respectively. In the following sections, we are going to introduce each of these
    in-memory AST representations.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构之外，AST 的主体——AST 节点——还可以进一步分为三个主要类别：`Decl`、`Expr` 和 `Stmt` 类。在以下各节中，我们将介绍这些内存中的
    AST 表示。
- en: Declarations
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: 'Language constructs such as variable declarations (global and local), functions,
    and struct/class declarations are represented by subclasses of `Decl`. Though
    we are not going to go into each of these subclasses here, the following diagram
    shows common declaration constructions in C/C++ and their corresponding AST classes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明（全局和局部）、函数和结构/类声明等语言结构由 `Decl` 的子类表示。虽然我们不会在这里深入探讨每个子类，但以下图表显示了 C/C++ 中常见的声明结构及其对应的
    AST 类：
- en: '![Figure 7.1 – Common declarations in C/C++ and their AST classes'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – Common declarations in C/C++ and their AST classes](img/Figure_7.1_B14590.jpg)'
- en: '](img/Figure_7.1_B14590.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – Common declarations in C/C++ and their AST classes](img/Figure_7.1_B14590.jpg)'
- en: Figure 7.1 – Common declarations in C/C++ and their AST classes
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – C/C++ 中常见的声明及其 AST 类
- en: 'Between more concrete subclasses, such as `FunctionDecl` and `Decl`, there
    are several important *abstract* classes that represent certain language concepts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在更具体的子类，如 `FunctionDecl` 和 `Decl` 之间，有几个重要的 *抽象* 类代表某些语言概念：
- en: '`NamedDecl`: For every declaration that has a name.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamedDecl`：对于每个具有名称的声明。'
- en: '`ValueDecl`: For declarations whose declared instances can be a value, and
    thus are associated with type information.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueDecl`：对于声明的实例可以是值的声明，因此与类型信息相关联。'
- en: '`DeclaratorDecl`: For every declaration that uses declarator (basically a statement
    in the form of `<type and qualifier> <identifier name>`). They provide extra information
    about parts other than the identifier. For example, they provide access to an
    in-memory object with namespace resolution, which acts as a qualifier in the declarator.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeclaratorDecl`：对于每个使用声明符（基本上是 `<类型和限定符> <标识符名称>` 形式的语句）。它们提供了关于标识符之外部分的其他信息。例如，它们提供了对具有命名空间解析的内存对象的访问，这充当声明符中的限定符。'
- en: To learn more about AST classes for other kinds of declarations, you can always
    navigate through the subclasses of `Decl` on LLVM's official API reference website.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于其他类型声明的 AST 类，你始终可以通过在 LLVM 的官方 API 参考网站上导航 `Decl` 的子类来获取。
- en: Statements
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句
- en: 'Most directives in a program that represent the concept of *actions* can be
    classified as statements and are represented by subclasses of `Stmt`, including
    *expressions*, which we are going to cover shortly. In addition to imperative
    statements such as function calls or return sites, `Stmt` also covers structural
    concepts such as `for` loops and `if` statements. Here is a diagram showing a
    common language construct represented by `Stmt` (except expression) in C/C++ and
    its corresponding AST classes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中表示 *动作* 概念的大多数指令都可以归类为语句，并由 `Stmt` 的子类表示，包括即将讨论的 *表达式*。除了函数调用或返回点等命令式语句之外，`Stmt`
    还涵盖了结构概念，如 `for` 循环和 `if` 语句。以下是显示 C/C++ 中由 `Stmt`（除表达式外）表示的常见语言结构及其对应 AST 类的图表：
- en: '![Figure 7.2 – Common statements (excluding expressions) in C/C++ and their
    AST classes'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2 – Common statements (excluding expressions) in C/C++ and their
    AST classes'
- en: '](img/Figure_7.2_B14590.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B14590.jpg)'
- en: Figure 7.2 – Common statements (excluding expressions) in C/C++ and their AST
    classes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – C/C++ 中常见的语句（不包括表达式）及其 AST 类
- en: 'There are two things worth mentioning about the previous diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于先前的图，有两点值得提及：
- en: '`CompoundStmt`, which is a container for multiple statements, represents not
    only the function body but basically any code block enclosed by curly braces `(''{'',
    ''}'')`. Therefore, though not shown in the preceding diagram due to a lack of
    space, `IfStmt`, `ForStmt`, `WhileStmt`, and `SwitchStmt` all have a `CompoundStmt`
    child node representing their bodies.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompoundStmt`，它是一个包含多个语句的容器，不仅代表了函数体，基本上还代表了任何由花括号 `(''{'', ''}'')` 包围的代码块。因此，尽管由于空间不足，在先前的图中没有显示，但
    `IfStmt`、`ForStmt`、`WhileStmt` 和 `SwitchStmt` 都有一个 `CompoundStmt` 子节点来表示它们的主体。'
- en: Declarations in a `CompoundStmt` will be wrapped by a `DeclStmt` node, in which
    the real `Decl` instance is its child node. This creates a simpler AST design.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `CompoundStmt` 中的声明将被 `DeclStmt` 节点包裹，其中实际的 `Decl` 实例是其子节点。这创建了一个更简单的 AST
    设计。
- en: Statements are one of the most prevailing directives in a typical C/C++ program.
    It is worth noting, however, that many statements are organized in a hierarchy
    (for example, `ForStmt` and its loop body), so it might take you extra steps to
    go down this hierarchy before you find the desired `Stmt` node.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是典型 C/C++ 程序中最普遍的指令之一。然而，值得注意的是，许多语句是有层次结构的（例如，`ForStmt` 及其循环体），因此你可能需要额外的步骤才能找到所需的
    `Stmt` 节点。
- en: Expressions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Expressions in Clang AST are a special kind of statement. Different from other
    statements, expressions always generate *values*. For example, a simple arithmetic
    expression, *3 + 4*, is expected to generate an integer value. All expressions
    in Clang AST are represented by subclasses of `Expr`. Here is a diagram showing
    a common language construct represented by `Expr` in C/C++ and its corresponding
    AST classes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Clang AST 中的表达式是一种特殊的语句。与其他语句不同，表达式总是生成 *值*。例如，一个简单的算术表达式，*3 + 4*，预期生成一个整数值。Clang
    AST 中的所有表达式都由 `Expr` 的子类表示。以下是一个图，展示了 C/C++ 中由 `Expr` 表示的常见语言结构及其对应的 AST 类：
- en: '![Figure 7.3 – Common expressions in C/C++ and their AST classes'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – Common expressions in C/C++ and their AST classes'
- en: '](img/Figure_7.3_B14590.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B14590.jpg)'
- en: Figure 7.3 – Common expressions in C/C++ and their AST classes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – C/C++ 中常见的表达式及其 AST 类
- en: One important `Expr` class is `DeclRefExpr`. It represents the concept of symbol
    reference. You can use one of its APIs, `DeclRefExpr::getDecl()`, to retrieve
    the referenced symbol's `Decl` object. Handy symbol information like this only
    appears after AST has been generated, so this is one of the reasons people always
    recommend implementing static analysis logic on AST rather on more primitive forms
    (inside the parser, for example).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的 `Expr` 类是 `DeclRefExpr`。它代表了符号引用的概念。你可以使用它的一个 API，`DeclRefExpr::getDecl()`，来检索被引用符号的
    `Decl` 对象。这种方便的符号信息仅在 AST 生成后才会出现，因此这也是人们总是推荐在 AST 而不是更原始的形式（例如在解析器内部）上实现静态分析逻辑的原因之一。
- en: Another interesting `Expr` class – not highlighted in the preceding diagram
    due to a lack of space – is `ParenExpr`, which represents the parentheses that
    wrap around an expression. For example, in the preceding diagram, `ParenExpr`
    with a `BinaryOperator` representing **x + 1** as its child.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的 `Expr` 类——由于空间不足，在先前的图中没有突出显示——是 `ParenExpr`，它代表了围绕表达式包裹的括号。例如，在先前的图中，`ParenExpr`
    以一个表示 **x + 1** 的 `BinaryOperator` 作为其子节点。
- en: Types in Clang AST
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang AST 中的类型
- en: The type system is one of the most crucial components in modern compilers, especially
    for statically typed languages such as C/C++. Type checking ensures that the input
    source code is well-formed (to some extent) and catches as many errors as possible
    at compile time. While we don't need to do type checking by ourselves in Clang,
    it is done by the `Sema` subsystem, which we introduced in [*Chapter 5*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067),
    *Exploring Clang's Architecture*. You will probably need to leverage this information
    when you're processing the AST. Let's learn how types are modeled in Clang AST.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统是现代编译器中最重要的组件之一，特别是对于如 C/C++ 这样的静态类型语言。类型检查确保输入源代码具有良好的格式（在一定程度上）并在编译时尽可能捕获错误。虽然我们不需要在
    Clang 中自行进行类型检查，但它是由我们之前在 [*第 5 章*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067)
    中介绍的 `Sema` 子系统完成的，*探索 Clang 的架构*。当你处理 AST 时，你可能会需要利用这些信息。让我们学习如何在 Clang AST 中建模类型。
- en: Core classes
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心类
- en: The core of Clang AST's type system is the `clang::Type` class. Each type in
    the input code – including primitive types such as `int` and user-defined types
    such as struct/class – is represented by a `Type`) object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Clang AST 类型系统的核心是 `clang::Type` 类。输入代码中的每个类型——包括如 `int` 这样的原始类型和如结构体/类这样的用户定义类型——都由一个
    `Type` 对象表示。
- en: Terminology
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 术语
- en: In the rest of this chapter, we will call types in the input source code **source
    code types**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将把输入源代码中的类型称为 **源代码类型**。
- en: A `Type` object for each of those types. One of the biggest advantages of this
    design is that you have an easier way to compare two `Type` objects. Let's say
    you have two `Type` pointers. By doing a simple pointer comparison (which is extremely
    fast) on them, you can tell if they're representing the same source code type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些类型中的每一个创建一个 `Type` 对象。这种设计最大的优点之一是，你有一个更简单的方式来比较两个 `Type` 对象。假设你有两个 `Type`
    指针。通过在它们上执行简单的指针比较（这非常快），你可以判断它们是否表示相同的源代码类型。
- en: Counter Example of a Singleton Design
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计的一个反例
- en: If `Type` in Clang AST is not using a singleton design, to compare if two `Type`
    pointers are representing the same source code types, you need to inspect the
    content of the objects they are pointing to, which is not efficient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Clang AST 中的 `Type` 不使用单例设计，要比较两个 `Type` 指针是否表示相同的源代码类型，你需要检查它们所指向的对象的内容，这并不高效。
- en: 'As we mentioned earlier, each source code type is actually represented by a
    subclass of `Type`. Here are some common `Type` subclasses:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，每个源代码类型实际上都由 `Type` 的一个子类表示。以下是一些常见的 `Type` 子类：
- en: '`BuiltinType`: For primitive types such as `int`, `char`, and `float`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuiltinType`: 对于如 `int`、`char` 和 `float` 这样的原始类型。'
- en: '`PointerType`: For all the pointer types. It has a function called `PointerType::getPointee()`
    for retrieving the source code type being pointed to by it.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointerType`: 对于所有指针类型。它有一个名为 `PointerType::getPointee()` 的函数，用于检索它所指向的源代码类型。'
- en: '`ArrayType`: For all the array types. Note that it has other subclasses for
    more specific arrays that have either a constant or variable length.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayType`: 对于所有数组类型。请注意，它还有其他子类，用于表示具有固定或可变长度的更特定数组。'
- en: '`RecordType`: For struct/class/union types. It has a function called `RecordType::getDecl()`
    for retrieving the underlying `RecordDecl`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecordType`: 对于结构体/类/联合体类型。它有一个名为 `RecordType::getDecl()` 的函数，用于检索底层的 `RecordDecl`。'
- en: '`FunctionType`: For representing a function''s signature; that is, a function''s
    argument types and return type (and other properties, such as its calling convention).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FunctionType`: 用于表示函数的签名；即函数的参数类型和返回类型（以及其他属性，如其调用约定）。'
- en: Let us now move on to the qualified types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续学习有资格的类型。
- en: Qualified types
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有资格的类型
- en: One of the most confusing things for people new to Clang's code base is that
    many places use the `QualType` class rather than subclasses of `Type` to represent
    source code types. `QualType` stands for `Type` to represent concepts such as
    `const <type>`, `volatile <type>`, and `restrict <type>*`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Clang 代码库的新手来说，最令人困惑的事情之一是许多地方使用 `QualType` 类而不是 `Type` 的子类来表示源代码类型。`QualType`
    代表 `Type`，用于表示如 `const <type>`、`volatile <type>` 和 `restrict <type>*` 这样的概念。
- en: 'To create a `QualType` from a `Type` pointer, you can use the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `Type` 指针创建 `QualType`，可以使用以下代码：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we learned about the type system in Clang AST. Let's now move
    on to ASTMatcher, a syntax to match patterns.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Clang AST 中的类型系统。现在让我们继续学习 ASTMatcher，这是一种匹配模式的语法。
- en: ASTMatcher
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASTMatcher
- en: 'When we are dealing with a program''s AST – for example, we''re checking if
    there is any suboptimal syntax – searching for specific AST nodes *pattern* is
    usually the first step, and one of the most common things people do. Using the
    knowledge we learned in the previous section, we know that this kind of pattern
    matching can be done by iterating through AST nodes via their in-memory classes
    APIs. For example, given a `FunctionDecl` – the AST class of a function – you
    can use the following code to find out if there is a `while` loop in its body
    and if the exit condition of that loop is always a literal Boolean value; that
    is, `true`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理程序的 AST 时——例如，我们正在检查是否存在任何子优化语法——搜索特定的 AST 节点 *模式* 通常是最先采取的步骤，也是人们最常做的事情之一。根据我们在上一节中学到的知识，我们知道这种模式匹配可以通过遍历
    AST 节点及其内存类 API 来完成。例如，给定一个 `FunctionDecl`（函数的 AST 类）——你可以使用以下代码来找出其体中是否存在 `while`
    循环，以及该循环的退出条件是否始终是一个字面量布尔值；即 `true`：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, it created more than three (indention) layers of `if` statements
    to complete such a simple check. Not to mention in real-world cases, we need to
    insert even more sanity checks among these lines! While Clang's AST design is
    not hard to understand, we need a more *concise* syntax to complete pattern matching
    jobs. Fortunately, Clang has already provided one – the **ASTMatcher**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它创建了超过三层（缩进）的 `if` 语句来完成这样一个简单的检查。更不用说在实际情况下，我们还需要在这些行之间插入更多的合理性检查！虽然 Clang
    的 AST 设计不难理解，但我们需要一个更 *简洁* 的语法来完成模式匹配任务。幸运的是，Clang 已经提供了一种——那就是 **ASTMatcher**。
- en: 'ASTMatcher is the utility that helps you write AST pattern matching logic via
    a clean, concise, and efficient **Domain-Specific Language** (**DSL**). Using
    ASTMatcher, doing the same matching shown in the previous snippet only takes few
    lines of code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ASTMatcher 是一个实用工具，它通过一个干净、简洁且高效的 **领域特定语言**（**DSL**）帮助您编写 AST 模式匹配逻辑。使用 ASTMatcher，执行与之前代码片段中相同的匹配操作只需几行代码：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Most of the directives in the preceding snippet are pretty straightforward:
    function calls such as `compoundStmt(…)` and `whileStmt(…)` check if the current
    node matches a specific node type. Here, the arguments in these function calls
    either represent pattern matchers on their subtree or check additional properties
    of the current node. There are also other directives for expressing qualifying
    concepts (for example, *for all substatements in this loop body, a return value
    exists*), such as `hasAnySubstatement(…)`, and directives for expressing data
    type and constant values such as the combination of `cxxBoolLiteral(equals(true))`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码片段中的大多数指令都很直观：例如 `compoundStmt(…)` 和 `whileStmt(…)` 函数调用检查当前节点是否匹配特定节点类型。在这里，这些函数调用中的参数要么代表其子树的模式匹配器，要么检查当前节点的额外属性。还有一些其他指令用于表达限定概念（例如，*在这个循环体中的所有子语句中，都存在一个返回值*），如
    `hasAnySubstatement(…)`，以及用于表达数据类型和常量值的指令，例如 `cxxBoolLiteral(equals(true))` 的组合。
- en: In short, using ASTMatcher can make your pattern matching logic more *expressive*.
    In this section, we showed you the basic usage of this elegant DSL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用 ASTMatcher 可以使你的模式匹配逻辑更加 *表达性*。在本节中，我们展示了这个优雅 DSL 的基本用法。
- en: Traversing AST
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历 AST
- en: Before we dive into the core syntax, let's learn how ASTMatcher traverses AST
    and how it passes the result back to users after the matching process is completed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入核心语法之前，让我们了解 ASTMatcher 如何遍历 AST 以及在匹配过程完成后如何将结果返回给用户。
- en: '`MatchFinder` is a commonly used driver for the pattern matching process. Its
    basic usage is pretty simple:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatchFinder` 是模式匹配过程的一个常用驱动器。其基本用法相当简单：'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`pattern1` and `pattern2` are pattern objects that are constructed by DSL,
    as shown previously. What''s more interesting is the `traverse` function and the
    `TK_AsIs` argument. The `traverse` function is a part of the pattern matching
    DSL, but instead of expressing patterns, it describes the action of traversing
    AST nodes. On top of that, the `TK_AsIs` argument represents the *traversing mode*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern1` 和 `pattern2` 是由 DSL 构建的模式对象，如之前所示。更有趣的是 `traverse` 函数和 `TK_AsIs`
    参数。`traverse` 函数是模式匹配 DSL 的一部分，但它不是表达模式，而是描述遍历 AST 节点的动作。此外，`TK_AsIs` 参数代表 *遍历模式*。'
- en: 'When we showed you the command-line flag for dumping AST in textual format
    (`-Xclang -ast-dump`) earlier in this chapter, you may have found that many *hidden
    AST nodes* were inserted into the tree to assist with the program''s semantics
    rather than representing the real code that was written by the programmers. For
    example, `ImplicitCastExpr` is inserted in lots of places to ensure the program''s
    type correctness. Dealing with these nodes might be a painful experience when
    you''re composing pattern matching logic. Thus, the `traverse` function provides
    an alternative, *simplified*, way to traverse the tree. Let''s say we have the
    following input source code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章前面展示了用于以文本格式转储AST的命令行标志（`-Xclang -ast-dump`）时，您可能已经发现许多*隐藏的AST节点*被插入到树中，以帮助程序语义而不是表示程序员编写的真实代码。例如，`ImplicitCastExpr`在许多地方被插入以确保程序的类型正确性。在编写模式匹配逻辑时处理这些节点可能是一种痛苦的经历。因此，`traverse`函数提供了一个替代的、*简化*的遍历树的方法。假设我们有以下输入源代码：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you pass `TK_AsIs` as the first argument to `traverse`, it observes the
    tree, similar to how `-ast-dump` does:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将`TK_AsIs`作为`traverse`的第一个参数传递时，它观察树，类似于`-ast-dump`的行为：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, by using `TK_IgnoreUnlessSpelledInSource` as the first argument, the
    tree that''s observed is equal to the following one:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用`TK_IgnoreUnlessSpelledInSource`作为第一个参数，观察到的树等于以下树：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As its name suggests, `TK_IgnoreUnlessSpelledInSource` only visit nodes that
    are really shown in the source code. This greatly simplifies the process of writing
    a matching pattern since we don't need to worry about the nitty-gritty details
    of AST anymore.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`TK_IgnoreUnlessSpelledInSource`仅访问实际在源代码中显示的节点。这极大地简化了编写匹配模式的过程，因为我们不再需要担心AST的细节。
- en: 'On the other hand, `Callback1` and `Callback2` in the first snippet are `MatchFinder::MatchCallback`
    objects that describe the actions to perform when there is a match. Here is the
    skeleton of a `MatchCallback` implementation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第一个片段中的`Callback1`和`Callback2`是`MatchFinder::MatchCallback`对象，它们描述了在匹配成功时执行的操作。以下是`MatchCallback`实现的骨架：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next section, we will show you how to bind a specific part of the pattern
    with a tag and retrieve it in `MatchCallback`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何将模式的一部分与一个标签绑定，并在`MatchCallback`中检索它。
- en: Last but not least, though we used `MatchFinder::match` and `MatchFinder::matchAST`
    in the first snippet to kick off the matching process, there are other ways to
    do this. For example, you can use `MatchFinder::newASTConsumer` to create an `ASTConsumer`
    instance that will run the described pattern matching activity. Alternatively,
    you can use `ast_matchers::match(…)` (not a member function under `MatchFinder`
    but a standalone function) to perform matching on a provided pattern and `ASTContext`
    in a single run, before returning the matched node.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，尽管我们在第一个片段中使用了`MatchFinder::match`和`MatchFinder::matchAST`来启动匹配过程，但还有其他方法可以做到这一点。例如，您可以使用`MatchFinder::newASTConsumer`创建一个`ASTConsumer`实例，该实例将运行所描述的模式匹配活动。或者，您可以使用`ast_matchers::match(…)`（不是`MatchFinder`下的成员函数，而是一个独立的函数）在单次运行中对提供的模式和`ASTContext`进行匹配，然后在返回匹配的节点之前。
- en: ASTMatcher DSL
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASTMatcher DSL
- en: ASTMatcher provides an easy-to-use and concise C++ DSL to help with matching
    AST. As we saw earlier, the *structure* of the desired pattern is expressed by
    nested function calls, where each of these functions represents the *type* of
    AST node to match.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ASTMatcher提供了一个易于使用且简洁的C++ DSL，以帮助进行AST匹配。正如我们之前所看到的，所需模式的*结构*通过嵌套函数调用表示，其中每个这样的函数代表要匹配的AST节点的*类型*。
- en: 'Using this DSL to express simple patterns cannot be easier. However, when you''re
    trying to compose patterns with multiple conditions/predicates, things get a little
    bit more complicated. For example, although we know a for loop (for example, `for(I
    = 0; I < 10; ++I){…}`) can be matched by the `forStmt(…)` directive, how do we
    add a condition to its initialize statement (`I = 0` ) and exit the condition
    (`I < 10`) or its loop body? Not only does the official API reference site (the
    doxygen website we usually use) lacks clear documentation on this part, most of
    these DSL functions are also pretty flexible in how they accept a wide range of
    arguments as their subpatterns. For example, following the question on matching
    a `for` loop, you can use the following code to check only the loop''s body:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 DSL 表达简单的模式简直不能再简单了。然而，当你试图用多个条件/谓词组合模式时，事情会变得稍微复杂一些。例如，虽然我们知道 for 循环（例如，`for(I
    = 0; I < 10; ++I){…}`）可以通过 `forStmt(…)` 指令进行匹配，但我们如何向其初始化语句（`I = 0`）和退出条件（`I <
    10`）或其循环体添加条件？不仅官方 API 参考网站（我们通常使用的 doxygen 网站）在这方面缺乏清晰的文档，而且这些 DSL 函数在如何接受广泛的参数作为其子模式方面也非常灵活。例如，在回答匹配
    `for` 循环的问题之后，你可以使用以下代码来仅检查循环体：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can check its loop body and its exit condition, like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以检查其循环体和退出条件，如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A generalized version of this question would be, given an arbitrary DSL directive,
    how do we know the *available* directives that can be combined with it?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的广义版本将是，给定一个任意的 DSL 指令，我们如何知道可以与之组合的 *可用* 指令？
- en: 'To answer this question, we will leverage a documentation website LLVM specifically
    created for ASTMatcher: [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html).
    This website consists of a huge three-column table showing the returned type and
    argument types for each of the DSL directives:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们将利用专门为 ASTMatcher 创建的 LLVM 文档网站：[https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)。这个网站包含一个巨大的三列表格，显示了每个
    DSL 指令返回的类型和参数类型：
- en: '![Figure 7.4 – Part of the ASTMatcher DSL reference'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – ASTMatcher DSL 参考的一部分'
- en: '](img/Figure_7.4_B14590.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B14590.jpg)'
- en: Figure 7.4 – Part of the ASTMatcher DSL reference
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – ASTMatcher DSL 参考的一部分
- en: Though this table is just a simplified version of normal API references, it
    already shows you how to search for candidate directives. For example, now that
    you know `forStmt(…)` takes zero or multiple `Matcher<ForStmt>`, we can search
    this table for directives that return either `Matcher<ForStmt>` or `Matcher<(parent
    class of ForStmt)>`, such as `Matcher<Stmt>`. In this case, we can quickly spot
    `hasCondition`, `hasBody`, `hasIncrement`, or `hasLoopInit` as candidates (of
    course, many other directives that return `Matcher<Stmt>` can also be used).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个表格只是正常 API 参考的简化版本，但它已经展示了如何搜索候选指令。例如，现在你知道 `forStmt(…)` 可以接受零个或多个 `Matcher<ForStmt>`，我们可以在表中搜索返回
    `Matcher<ForStmt>` 或 `Matcher<ForStmt> 的父类>` 的指令，例如 `Matcher<Stmt>`。在这种情况下，我们可以快速找到
    `hasCondition`、`hasBody`、`hasIncrement` 或 `hasLoopInit` 作为候选（当然，许多其他返回 `Matcher<Stmt>`
    的指令也可以使用）。
- en: 'When you''re performing pattern matching, there are many cases where you not
    only want to know if a pattern matches or not but also get the matched AST nodes.
    In the context of ASTMatcher, its DSL directives only check the *type* of the
    AST nodes. If you want to retrieve (part of the) concrete AST nodes that are being
    matched, you can use the `bind(…)` API. Here is an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行模式匹配时，有许多情况你不仅想知道模式是否匹配，还想获取匹配的 AST 节点。在 ASTMatcher 的上下文中，其 DSL 指令仅检查 AST
    节点的 *类型*。如果你想检索（部分）正在匹配的 concrete AST 节点，你可以使用 `bind(…)` API。以下是一个示例：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we used `expr()` as a wildcard pattern to match any `Expr` node. This
    directive also calls `bind(…)` to associate the matched `Expr` AST node with the
    name `exit_condition`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `expr()` 作为通配符模式来匹配任何 `Expr` 节点。此指令还调用 `bind(…)` 将匹配的 `Expr` AST 节点与名称
    `exit_condition` 关联。
- en: 'Then, in `MatchCallback`, which we introduced earlier, we can retrieve the
    bound node by using the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在之前介绍的 `MatchCallback` 中，我们可以使用以下代码检索绑定的节点：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `getNodeAs<…>(…)` function tries to fetch the bound AST node under the given
    name and cast it to the type suggested by the template argument.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNodeAs<…>(…)` 函数试图获取给定名称下的绑定 AST 节点并将其转换为模板参数建议的类型。'
- en: Note that you're allowed to bind different AST nodes under the same name, in
    which case only the last bounded one will be shown in `MatchCallback::run`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以将不同的AST节点绑定到同一个名称下，在这种情况下，只有最后绑定的节点会在`MatchCallback::run`中显示。
- en: Putting everything together
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一切整合
- en: Now that you've learned about both the pattern matching DSL syntax and how to
    traverse AST using ASTMatcher, let's put these two things together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模式匹配DSL语法以及如何使用ASTMatcher遍历AST，让我们将这两者结合起来。
- en: 'Let''s say we want to know the number of iterations – also known as the *trip
    count* – that a simple `for` loop (the loop index starts from zero and is incremented
    by one at each iteration and bounded by a literal integer) has in a function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道一个简单的`for`循环（循环索引从零开始，每次迭代增加一，由一个字面量整数限制）在函数中的迭代次数——也称为*遍历次数*）：
- en: 'First, we must write the following code for matching and traversing:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须编写以下代码来进行匹配和遍历：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding snippet also shows how *modular* DSL patterns are. You can create
    individual pattern fragments and compose them depending on your needs, as long
    as they're compatible.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码片段也展示了*模块化* DSL模式的样子。你可以根据需要创建单个模式片段并将它们组合起来，只要它们是兼容的。
- en: 'Finally, here is what `MyMatchCallback::run` looks like:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，这是`MyMatchCallback::run`的样子：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After this, you can use `Finder` to match the desired pattern (either by calling
    `MatchFinder::match` or `MatchFinder::matchAST`, or by creating an `ASTConsumer`
    using `MatchFinder::newASTConsumer`) on an AST. The matched trip count will be
    printed to `stderr`. For instance, if the input source code is `for(int i = 0;
    i < 10; ++i) {…}`, the output will simply be `10`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你可以使用`Finder`在AST上匹配所需的模式（通过调用`MatchFinder::match`或`MatchFinder::matchAST`，或者通过使用`MatchFinder::newASTConsumer`创建`ASTConsumer`）来匹配。匹配的遍历次数将被打印到`stderr`。例如，如果输入源代码是`for(int
    i = 0; i < 10; ++i) {…}`，输出将简单地是`10`。
- en: In this section, we learned how Clang structures its AST, how Clang AST is represented
    in memory, and how to use ASTMatcher to help developers with AST pattern matching.
    With this knowledge, in the next section, we will show you how to create an AST
    plugin, which is one of the easiest ways to inject custom logic into Clang's compilation
    pipeline.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Clang如何结构其AST，Clang AST如何在内存中表示，以及如何使用ASTMatcher帮助开发者进行AST模式匹配。有了这些知识，在下一节中，我们将向你展示如何创建AST插件，这是将自定义逻辑注入Clang编译管道的最简单方法之一。
- en: Writing AST plugins
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写AST插件
- en: In the previous section, we learned how AST is represented in Clang and learned
    what its in-memory classes look like. We also learned about some useful skills
    we can use to perform pattern matching on Clang AST. In this section, we will
    learn how to write plugins that allow you to insert custom AST processing logic
    into Clang's compilation pipeline.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何在Clang中表示AST以及它的内存中类的样子。我们还学习了可以使用的一些技巧来在Clang AST上执行模式匹配。在本节中，我们将学习如何编写插件，允许你将自定义的AST处理逻辑插入到Clang的编译管道中。
- en: 'This section will be divided into three parts:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将分为三个部分：
- en: '**Project overview**: The goal and overview of the demo project we are going
    to create in this section.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目概述**：本节将要创建的演示项目的目标和概述。'
- en: '`DiagnosticsEngine`, a powerful subsystem that helps you print out well-formatted
    and meaningful diagnostic messages. This will make our demo project more applicable
    to real-world scenarios.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticsEngine`，一个强大的子系统，可以帮助你打印出格式良好且具有意义的诊断信息。这将使我们的演示项目更适用于现实世界场景。'
- en: '**Creating the AST plugin**: This section will show you how to create an AST
    plugin from scratch, fill in all the implementation details, and how to run it
    with Clang.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建AST插件**：本节将展示如何从头开始创建AST插件，填写所有实现细节，以及如何使用Clang运行它。'
- en: Project overview
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this section, we will create a plugin that prompts the user with warning
    messages whenever there are `if`-`else` statements in the input code that can
    be converted into **ternary operators**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个插件，当输入代码中有可以转换为**三元运算符**的`if`-`else`语句时，它会提示用户警告信息。
- en: Quick Refresher – Ternary Operator
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾 – 三元运算符
- en: 'The ternary operator, `x? val_1 : val_2`, is evaluated to `val_1` when the
    `x` condition is true. Otherwise, it is evaluated to `val_2`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '当`x`条件为真时，三元运算符`x? val_1 : val_2`被评估为`val_1`。否则，它被评估为`val_2`。'
- en: 'For example, let''s look at the following C/C++ snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下C/C++代码片段：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `if`-`else` statements in both functions can be converted into ternary
    operators, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数中的`if`-`else`语句可以转换为三元运算符，如下所示：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this project, we will only focus on finding two kinds of potential ternary
    operator opportunities:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将只关注寻找两种潜在的三元运算符机会：
- en: Both the `then` block (true branch) and the `else` block (false branch) contain
    a single `return` statement. In this case, we can coalesce their return values
    and the branch condition into one ternary operator (as the new returned value).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`块（真分支）和`else`块（假分支）都包含一个`return`语句。在这种情况下，我们可以合并它们的返回值和分支条件为一个三元运算符（作为新的返回值）。'
- en: Both the `then` block and the `else` block only contain a single assignment
    statement. Both statements use a single `DeclRefExpr` – that is, a symbol reference
    – as the LHS, and both `DeclRefExpr` objects point to the same `Decl` (symbol).
    In other words, we are covering the case of the `bar` function shown in the preceding
    snippet. Note that we are not covering cases where the LHS is more complicated;
    for example, where an array subscription, `a[i]`, is used as the LHS.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`块（真分支）和`else`块（假分支）都只包含一个赋值语句。这两个语句都使用单个`DeclRefExpr` – 即符号引用 – 作为LHS，并且这两个`DeclRefExpr`对象都指向同一个`Decl`（符号）。换句话说，我们正在涵盖前面代码片段中显示的`bar`函数的情况。请注意，我们不包括LHS更复杂的情况；例如，当使用数组索引`a[i]`作为LHS时。'
- en: 'After identifying these patterns, we must prompt warning messages to the user
    and provide extra information to help the user fix this issue:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别这些模式后，我们必须向用户提示警告信息，并提供额外信息以帮助用户修复此问题：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each warning message – which tells you which `if`-`else` statement can be converted
    into a ternary operator – is followed by two notes pointing out the potential
    expressions to construct for the operator.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个警告信息 – 告诉你哪个`if`-`else`语句可以转换为三元运算符 – 后面跟着两个注释，指出为运算符构造的潜在表达式。
- en: Compared to handcrafting compiler messages, as we did in the *Developing custom
    preprocessor plugins and callbacks* section of [*Chapter 6*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Extending the Preprocessor*, here, we are using Clang's diagnostics infrastructure
    to print messages that carry richer information, such as the snapshot of code
    that the message is referring to. We will show you how to use that diagnostic
    infrastructure next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[*第6章*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078)的*扩展预处理器*部分中做的手动制作编译器信息相比，这里我们使用Clang的诊断基础设施来打印包含更丰富信息的消息，例如消息所引用的代码快照。我们将在下一节中向你展示如何使用这个诊断基础设施。
- en: Printing diagnostic messages
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印诊断信息
- en: In [*Chapter 6*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078), *Extending
    the Preprocessor*, we asked if you could improve the warning message format in
    the example project shown in the *Developing custom preprocessor plugins and callbacks*
    section, so that it's closer to the compiler messages you saw from Clang. One
    of the solutions to that question is using Clang's diagnostic framework. We are
    going to look at this in this section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078)中，*扩展预处理器*，我们询问你是否可以改进示例项目中在*开发自定义预处理器插件和回调*部分显示的警告信息格式，使其更接近你从Clang看到的编译器信息。针对这个问题的解决方案之一是使用Clang的诊断框架。我们将在本节中探讨这一点。
- en: 'Clang''s diagnostic framework consists of three primary parts:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Clang的诊断框架由三个主要部分组成：
- en: '**Diagnostic IDs**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断ID**'
- en: '**Diagnostic engine**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断引擎**'
- en: '**Diagnostic consumers (clients)**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断消费者（客户端**）'
- en: 'Their relationships can be seen in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的关系可以在以下图中看到：
- en: '![Figure 7.5 – High-level organization of Clang''s diagnostic framework'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – Clang诊断框架的高级组织结构'
- en: '](img/Figure_7.5_B14590.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B14590.jpg)'
- en: Figure 7.5 – High-level organization of Clang's diagnostic framework
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – Clang诊断框架的高级组织结构
- en: Diagnostic messages
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 诊断信息
- en: 'Starting from the left-hand side of the preceding diagram, most of the time,
    a diagnostic message – for example, *use of undeclared identifier "x"* – is associated
    with a message **template** that has its own diagnostic ID. Using the undeclared
    identifier message, for example, its message template looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面图的左侧开始，大多数情况下，一个诊断信息 – 例如，*使用未声明的标识符" x"* – 与一个具有自己的诊断ID的消息**模板**相关联。例如，使用未声明的标识符消息，其消息模板看起来像这样：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`%0` is a `x`, in the preceding example message). The number following `%`
    also suggests which supplemental data it will use. We will cover this format in
    detail shortly.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`%0` 是一个 `x`，在先前的示例消息中）。跟随 `%` 的数字也暗示了它将使用哪些补充数据。我们将在稍后详细介绍这种格式。'
- en: 'Templates are registered with the diagnostic engine via TableGen syntax. For
    example, the message we are discussing here is put inside `clang/include/clang/Basic/DiagnosticSemaKinds.td`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 模板通过TableGen语法注册到诊断引擎中。例如，我们正在讨论的消息被放入 `clang/include/clang/Basic/DiagnosticSemaKinds.td`：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We highlighted two parts in the preceding snippet. First, the name of this message
    template, `err_undeclared_var_use`, will be used later as the unique diagnostic
    ID. Second, the `Error` TableGen class suggested that this is an error message,
    or more formally speaking, its *diagnostic level* error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的片段中突出了两个部分。首先，此消息模板的名称 `err_undeclared_var_use` 将在以后作为唯一的诊断ID使用。其次，`Error`
    TableGen 类建议这是一个错误消息，或者更正式地说，它的 *诊断级别* 错误。
- en: In summary, a diagnostic message consists of a unique diagnostic ID – which
    is associated with a message template and its diagnostic level – and the supplemental
    data to put in the placeholders of the template, if there are any.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，一个诊断消息由一个唯一的诊断ID组成——它与一个消息模板及其诊断级别相关联——以及如果有的话，需要放入模板占位符中的补充数据。
- en: Diagnostic consumers
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 诊断消费者
- en: After the diagnostic message is sent to the diagnostic engine – represented
    by the `DiagnosticsEngine` class – the engine formats the messages into textual
    contents and send them to one of the **diagnostic consumers** (also called **clients**
    in the code base; we will use the term **consumer** in rest of this section).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在将诊断消息发送到诊断引擎（由 `DiagnosticsEngine` 类表示）之后，引擎将消息格式化为文本内容，并将它们发送到 **诊断消费者**（在代码库中也称为
    **客户端**；在本节的其余部分我们将使用术语 **消费者**）之一。
- en: A diagnostic consumer – an implementation of the `DiagnosticConsumer` class
    – post-processes the textual messages sent from `DiagnosticsEngine` and exports
    them via different mediums. For example, the default `TextDiagnosticPrinter` prints
    messages to the command-line interface; `LogDiagnosticPrinter`, on the other hand,
    decorates the incoming messages with simple XML tags before printing them into
    log files. In theory, you can even create a custom `DiagnosticConsumer` that sends
    diagnostic messages to a remote host!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断消费者——`DiagnosticConsumer` 类的实现——对从 `DiagnosticsEngine` 发送的文本消息进行后处理，并通过不同的介质导出它们。例如，默认的
    `TextDiagnosticPrinter` 将消息打印到命令行界面；另一方面，`LogDiagnosticPrinter` 在打印到日志文件之前，会用简单的XML标签装饰传入的消息。理论上，你甚至可以创建一个自定义的
    `DiagnosticConsumer`，将诊断消息发送到远程主机！
- en: Reporting diagnostic messages
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 报告诊断消息
- en: 'Now that you have learned how Clang''s diagnostic framework works, let''s learn
    how to send (report) a diagnostic message to `DiagnosticEngine`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Clang的诊断框架是如何工作的，让我们学习如何向 `DiagnosticEngine` 发送（报告）诊断消息：
- en: 'First, we need to retrieve a reference to `DiagnosticEngine`. The engine itself
    is sitting at the core of Clang''s compilation pipeline, so you can fetch it from
    various primary components, such as `ASTContext` and `SourceManager`. The following
    is an example:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要获取对 `DiagnosticEngine` 的引用。该引擎本身位于Clang编译管道的核心，因此您可以从各种主要组件中获取它，例如 `ASTContext`
    和 `SourceManager`。以下是一个示例：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to use the `DiagnosticsEngine::Report` function. This function
    always takes a diagnostic ID as one of its arguments. For example, to report `err_undeclared_var_use`,
    which we introduced earlier, use the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `DiagnosticsEngine::Report` 函数。此函数始终将诊断ID作为其参数之一。例如，要报告我们之前介绍的 `err_undeclared_var_use`，请使用以下代码：
- en: '[PRE24]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Diag.Report(diag::err_undeclared_var_use) << ident_name_str;
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Diag.Report(diag::err_undeclared_var_use) << ident_name_str;
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Recall that `err_undeclared_var_use` only has one placeholder, `%0`, so it
    picks up the first values in the following `<<` stream. Let''s say we have a diagnostic
    message, `err_invalid_placement`, with the following template:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下，`err_undeclared_var_use` 只有一个占位符 `%0`，因此它选择了 `<<` 流中的第一个值。让我们假设我们有一个诊断消息
    `err_invalid_placement`，其模板如下：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can report this using the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下代码来报告此内容：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition to simple placeholders, another useful feature is the `%select`
    directive. For example, we have a diagnostic message, `warn_exceed_limit`, with
    a template like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了简单的占位符之外，另一个有用的特性是 `%select` 指令。例如，我们有一个诊断消息 `warn_exceed_limit`，其模板如下：
- en: '[PRE28]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Diag.Report(diag::warn_exceed_limit) << 0 as the parameter after the stream
    operator (<<):'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Diag.Report(diag::warn_exceed_limit) << 0 作为流操作符（<<）之后的参数：
- en: '[PRE29]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will result in a message stating **you exceed the daily wifi limit**.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致一条消息指出**你超过了每日的 WiFi 限制**。
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s say you use another version of the `Report` function, which takes
    an additional `SourceLocation` argument:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设你使用另一个版本的 `Report` 函数，它接受一个额外的 `SourceLocation` 参数：
- en: '[PRE31]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'test.cc:2:10: error: use of undeclared identifier ''x'''
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'test.cc:2:10: 错误：使用了未声明的标识符 ''x'''
- en: return x + 1;
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return x + 1;
- en: ^
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ^
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Last but not least, though most of the diagnostic messages are registered with
    `DiagnosticsEngine` via TableGen code put *inside* Clang''s source tree, this
    doesn''t mean that developers cannot create their new diagnostic messages without
    modifying Clang''s source tree. Let''s introduce `DiagnosticsEngine::getCustomDiagID(…)`,
    the API that creates a new diagnostic ID from a message template and diagnostic
    level provided by developers:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，尽管大多数诊断消息是通过 TableGen 代码在 Clang 的源树内部注册到 `DiagnosticsEngine` 的，但这并不意味着开发者不能在不修改
    Clang 的源树的情况下创建他们自己的新诊断消息。让我们介绍 `DiagnosticsEngine::getCustomDiagID(…)`，这是一个 API，它可以从开发者提供的消息模板和诊断级别创建一个新的诊断
    ID：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Diag.Report(MyDiagID) << "cloudy";
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Diag.Report(MyDiagID) << "cloudy";
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this section, you learned how to leverage Clang's diagnostic framework to
    print out messages just like normal compiler messages.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何利用 Clang 的诊断框架打印出类似于正常编译器消息的消息。
- en: Next, we are going to combine all the skills we've learned about in this chapter
    to create a custom AST plugin.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将结合本章学到的所有技能来创建一个自定义的 AST 插件。
- en: Creating the AST plugin
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AST 插件
- en: In the previous sections of this chapter, we explored Clang's AST and learned
    how to use it in in-memory APIs. In this section, we will learn how to write a
    plugin that helps you insert your custom AST processing logic into Clang's compilation
    pipeline in an easy way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们探索了 Clang 的 AST 并学习了如何在内存 API 中使用它。在本节中，我们将学习如何编写一个插件，该插件可以帮助你以简单的方式将自定义的
    AST 处理逻辑插入到 Clang 的编译管道中。
- en: 'In [*Chapter 5*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067), *Exploring
    Clang''s Architecture*, we learned about the advantages of using Clang (AST) plugins:
    they can be developed even you are using a prebuilt `clang` executable, they are
    easy to write, and they have good integration with the existing toolchain and
    build systems, to name a few. In [*Chapter 6*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Extending the Preprocessor*, we developed a plugin for custom pragma handling
    in the preprocessor. In this chapter, we will also be writing a plugin, but this
    one will be designed for custom AST processing. The code skeletons for these two
    plugins are also quite different.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067) *探索 Clang 的架构* 中，我们学习了使用
    Clang (AST) 插件的优势：即使你使用预构建的 `clang` 可执行文件，也可以开发它们；它们易于编写，并且与现有的工具链和构建系统有很好的集成，仅举几例。在
    [*第 6 章*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078) *扩展预处理器* 中，我们开发了一个用于预处理器中自定义预处理指令处理的插件。在本章中，我们也将编写一个插件，但这个插件将设计用于自定义
    AST 处理。这两个插件的代码框架也相当不同。
- en: We introduced the sample project we will be using in this section in the *Project
    overview* section. This plugin will prompt users with warning messages if some
    `if`-`else` statements in the input code can be converted into ternary operators.
    In addition, it also shows extra hints about candidate expressions for building
    the ternary operator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节的 *项目概述* 部分介绍了我们将使用此节的示例项目。此插件将在输入代码中的某些 `if`-`else` 语句可以转换为三元运算符时向用户显示警告消息。此外，它还提供了关于构建三元运算符的候选表达式的额外提示。
- en: 'Here are the detailed steps for building the plugin:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建插件的详细步骤：
- en: Similar to the pragma plugin we saw in [*Chapter 6*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Extending the Preprocessor*, creating a plugin in Clang is basically like implementing
    a class. In the case of the AST plugin, this will be the `PluginASTAction` class.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们在 [*第 6 章*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078) *扩展预处理器* 中看到的预处理指令插件类似，在
    Clang 中创建插件基本上就像实现一个类。在 AST 插件的情况下，这将是一个 `PluginASTAction` 类。
- en: '`PluginASTAction` is a subclass of `ASTFrontendAction` – a `FrontendAction`
    specialized for handling AST (if you''re not familiar with `FrontendAction`, feel
    free to read [*Chapter 5*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067), *Exploring
    Clang''s Architecture*, again). Thus, we need to implement the `CreateASTConsumer`
    member function:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PluginASTAction`是`ASTFrontendAction`的子类——一个专门用于处理AST的`FrontendAction`（如果你不熟悉`FrontendAction`，可以自由阅读[*第5章*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067)，*探索Clang的架构*）因此，我们需要实现`CreateASTConsumer`成员函数：'
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We will fill in this function later.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们稍后会填充这个函数。
- en: 'In addition to `CreateASTConsumer`, there are two other member functions we
    can override to change some of the functionalities: `getActionType` and `ParseArgs`.
    The former tells Clang *how* this plugin should be executed by returning one of
    the enum values shown here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`CreateASTConsumer`之外，还有两个其他成员函数我们可以覆盖以改变一些功能：`getActionType`和`ParseArgs`。前者通过返回这里显示的枚举值之一来告诉Clang**如何**执行此插件：
- en: 'a. `Cmdline`: The plugin will be executed after the main action if users provide
    the `-plugin <plugin name>` (frontend) command-line flag.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `Cmdline`：如果用户提供了`-plugin <plugin name>`（前端）命令行标志，插件将在主动作之后执行。
- en: 'b. `ReplaceAction`: This replaces the original action Clang was going to perform.
    For example, if Clang was supposed to compile input code into an object file (the
    `-c` flag), it will execute the plugin''s action instead once the plugin has been
    loaded.'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `ReplaceAction`：这会替换Clang原本要执行的动作。例如，如果Clang原本应该将输入代码编译成目标文件（`-c`标志），一旦插件被加载，它将执行插件的动作。
- en: 'c. `AddBefore/AfterMainAction`: The original Clang action will still be executed,
    and the plugin action will be prepended/appended to it.'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `AddBefore/AfterMainAction`：原始的Clang动作仍然会被执行，插件动作将被添加到其前面或后面。
- en: 'Here, we will use the `Cmdline` action type:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`Cmdline`动作类型：
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'struct TernaryConverterAction : public PluginASTAction {'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'struct TernaryConverterAction : public PluginASTAction {'
- en: …
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: bool NoReturn and NoAssignment, to carry our command-line options' values. An
    important thing to know is the return value for ParseArgs. Instead of returning
    *if it parsed any custom flag*, ParseArgs is actually returning *if the plugin
    should continue its execution*. Therefore, you should always return true in most
    cases.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NoReturn`和`NoAssignment`，用于携带命令行选项的值。需要知道的一个重要的事情是`ParseArgs`的返回值。`ParseArgs`实际上返回的是**插件是否应该继续其执行**，而不是**是否解析了任何自定义标志**。因此，在大多数情况下，你应该始终返回true。'
- en: '[PRE37]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we are going to talk about the content of `CreateASTConsumer`. This function
    will return an `ASTConsumer` object, which is the main body that we will put our
    custom logic in. Nevertheless, we are not going to directly implement an `ASTConsumer`.
    Instead, we are going to us the `ASTConsumer` object that was generated by *ASTMatcher*,
    which we introduced earlier in this chapter.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将讨论`CreateASTConsumer`的内容。这个函数将返回一个`ASTConsumer`对象，这是我们将在其中放置自定义逻辑的主要部分。尽管如此，我们不会直接实现`ASTConsumer`。相反，我们将使用由*ASTMatcher*生成的`ASTConsumer`对象，我们在本章前面已经介绍过。
- en: 'Recall that two things are required to build a `MatchFinder` instance – the
    primary pattern matching driver in ASTMatcher (patterns written in ASTMatcher''s
    own DSL) and a `MatchCallback` implementation. Let''s separate our patterns and
    matcher callbacks into two categories: patterns for detecting potential ternary
    operator opportunities based on `return` statements and those for detecting *assignment-statement-based
    opportunities*.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，构建`MatchFinder`实例需要两个东西——ASTMatcher（模式匹配驱动程序）的主要模式匹配器和`MatchCallback`的实现。让我们将我们的模式和匹配器回调分为两类：基于`return`语句检测潜在三元运算符机会的模式，以及基于**赋值语句机会**的模式。
- en: 'Here is the skeleton for `CreateASTConsumer`:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是`CreateASTConsumer`的框架：
- en: '[PRE38]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s deal with the patterns first. The patterns we are looking for – both
    return-based and assignment-based patterns – have `if`-`else` statements (`IfStmt`)
    enclosed by a function (`FunctionDecl` for the entire function and `CompoundStmt`
    for the function body) in their outermost layout. Inside both, in the true branch
    and false branch of `IfStmt`, only one statement can exist. This structure can
    be illustrated like so:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们来处理模式。我们正在寻找的模式——无论是基于返回值还是基于赋值的模式——在其最外层布局中都被一个函数（对于整个函数是`FunctionDecl`，对于函数体是`CompoundStmt`）包围的`if`-`else`语句（`IfStmt`）。在这两者内部，无论是`IfStmt`的真分支还是假分支，都只能存在一个语句。这个结构可以这样表示：
- en: '[PRE39]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To convert this concept into ASTMatcher''s DSL, here is the DSL code that''s
    shared between the return-based and assignment-based patterns:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将这个概念转换为ASTMatcher的DSL，以下是返回型和基于赋值型模式之间共享的DSL代码：
- en: '[PRE40]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: StatementMatcher
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: StatementMatcher
- en: buildIfStmtMatcher(StatementMatcher truePattern,
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: buildIfStmtMatcher(StatementMatcher truePattern,
- en: StatementMatcher falsePattern) {
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: StatementMatcher falsePattern) {
- en: return functionDecl(
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return functionDecl(
- en: compoundStmt(hasAnySubstatement
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: compoundStmt(hasAnySubstatement
- en: IfStmt(
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IfStmt(
- en: hasThen(truePattern)
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hasThen(truePattern)
- en: hasElse(falsePattern))));
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hasElse(falsePattern))));
- en: '}'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE41]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For return-based patterns, the subpatterns for both the `if`-`else` branches
    mentioned in the previous step are identical and simple. We''re also using a separate
    function to create this pattern:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于基于返回的模式，上一步提到的 `if`-`else` 分支的子模式是相同的且简单的。我们还使用一个单独的函数来创建这个模式：
- en: '[PRE42]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: StatementMatcher buildAssignmentMatcher() {
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: StatementMatcher buildAssignmentMatcher() {
- en: return compoundStmt(statementCountIs(1),
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return compoundStmt(statementCountIs(1),
- en: hasAnySubstatement(
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hasAnySubstatement(
- en: binaryOperator(
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: binaryOperator(
- en: hasOperatorName("="),
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hasOperatorName("="),
- en: hasLHS(declRefExpr())
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hasLHS(declRefExpr())
- en: )));
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )));
- en: '}'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE43]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we've completed the skeleton for our patterns, it's time to implement
    `MatchCallback`. There are two things we are going to do in `MatchCallback::run`.
    First, for our assignment-based pattern, we need to check if the LHS' `DeclRefExpr`
    of those matched assignment candidates is pointing to the same `Decl`. Second,
    we want to print out messages that help users rewrite `if`-`else` branches as
    ternary operators. In other words, we need location information from some of the
    matched AST nodes.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模式框架，是时候实现 `MatchCallback` 了。在 `MatchCallback::run` 中，我们将做两件事。首先，对于基于赋值的模式，我们需要检查匹配的赋值候选的LHS的
    `DeclRefExpr` 是否指向相同的 `Decl`。其次，我们想要打印出帮助用户将 `if`-`else` 分支重写为三元运算符的消息。换句话说，我们需要从一些匹配的AST节点中获取位置信息。
- en: 'Let''s solve the first task using the *AST node binding technique*. The plan
    is to bind the candidate assignment''s LHS `DeclRefExpr` nodes so that we can
    retrieve them from `MatchCallback::run` later and perform further checks on their
    `Decl` nodes. Let''s change `buildAssignmentMatch` into this:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用*AST节点绑定技术*来解决第一个任务。计划是将候选赋值的LHS `DeclRefExpr` 节点绑定，以便我们可以在稍后的 `MatchCallback::run`
    中检索它们，并对它们的 `Decl` 节点进行进一步检查。让我们将 `buildAssignmentMatch` 改成这样：
- en: '[PRE44]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'StatementMatcher buildAssignmentMatcher(StringRef buildAssignmentMatcher, we
    will pass different suffixes for the different branches – either .true or .false.Finally,
    we must retrieve the bound nodes in `MatchCallback::run`. Here, we are creating
    different `MatchCallback` subclasses for return-based and assignment-based scenarios
    – `MatchReturnCallback` and `MatchAssignmentCallback`, respectively. Here is a
    part of the code in `MatchAssignmentCallback::run`:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'StatementMatcher buildAssignmentMatcher(StringRef buildAssignmentMatcher, we
    will pass different suffixes for the different branches – either .true or .false.Finally,
    we must retrieve the bound nodes in `MatchCallback::run`. Here, we are creating
    different `MatchCallback` subclasses for return-based and assignment-based scenarios
    – `MatchReturnCallback` and `MatchAssignmentCallback`, respectively. Here is a
    part of the code in `MatchAssignmentCallback::run`:'
- en: '[PRE45]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are going to solve the second task – printing useful information to users
    – in the next step.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在下一步解决第二个任务——向用户打印有用的信息。
- en: '[PRE46]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To print useful information – including *which* part of the code can be converted
    into a ternary operator, and *how* can you build that ternary operator – we need
    to retrieve some AST nodes from the matched patterns before getting their source
    location information. For this, we will use some node binding tricks, as we did
    in the previous step. This time, we will modify all the pattern building functions;
    that is, `buildIfStmtMatcher`, `buildReturnMatcher`, and `buildAssignmentMatcher`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了打印有用的信息——包括*哪些*代码部分可以转换为三元运算符，以及*如何*构建那个三元运算符——我们需要在获取它们的源位置信息之前从匹配的模式中检索一些AST节点。为此，我们将使用一些节点绑定技巧，就像我们在上一步所做的那样。这次，我们将修改所有模式构建函数；即
    `buildIfStmtMatcher`、`buildReturnMatcher` 和 `buildAssignmentMatcher`：
- en: '[PRE47]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'StatementMatcher buildReturnMatcher(StringRef MatchCallback::run and print
    out the message using the SourceLocation information that''s attached to those
    nodes.We are going to use Clang''s diagnostic framework to print out those messages
    here (feel free to read the *Printing diagnostic messages* section again if you''re
    not familiar with it). And since the prospective message formats are not existing
    ones in Clang''s code base, we are going to create our own diagnostic ID via `DiagnosticsEngine::getCustomDiagID(…)`.
    Here is what we will do in `MatchAssignmentCallback::run` (we will only demo `MatchAssignmentCallback`
    here since `MatchReturnCallback` is similar):'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`StatementMatcher buildReturnMatcher(StringRef MatchCallback::run)` 和 `print
    out the message using the SourceLocation information that''s attached to those
    nodes`。我们将使用Clang的诊断框架来打印这些消息（如果你不熟悉它，请随时再次阅读 *打印诊断消息* 部分）。由于预期的消息格式不是Clang代码库中的现有格式，我们将通过
    `DiagnosticsEngine::getCustomDiagID(…)` 创建我们自己的诊断ID。以下是我们在 `MatchAssignmentCallback::run`
    中将要做的事情（我们只会演示 `MatchAssignmentCallback`，因为 `MatchReturnCallback` 类似）：'
- en: '[PRE48]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Combining this with bound node retrievals, here is how we are going to print
    the messages:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此与节点检索结合使用，以下是我们将如何打印消息的方法：
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, go back to `CreateASTConsumer`. Here is how everything is pieced together:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到 `CreateASTConsumer`。以下是我们将如何将所有这些内容拼接在一起：
- en: '[PRE51]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And that wraps up all the things we need to do!
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就完成了我们所需做的所有事情！
- en: 'Last but not least, this is the command for running our plugin:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，这是运行我们的插件的命令：
- en: '[PRE52]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: -plugin-arg-<plugin name> format.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-plugin-arg-<插件名称>` 格式。'
- en: '[PRE53]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this section, you learned how to write an AST plugin that sends messages
    to users whenever there is an `if`-`else` statement that can be converted into
    a ternary operator. You did this by leveraging all the techniques that were covered
    in this chapter; that is, Clang AST's in-memory representation, ASTMatcher, and
    the diagnostic framework, to name a few.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何编写一个AST插件，每当有可以转换为三元运算符的 `if`-`else` 语句时，它就会向用户发送消息。你是通过利用本章中涵盖的所有技术来做到这一点的；即，Clang
    AST的内存表示、ASTMatcher和诊断框架，仅举几例。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When it comes to program analysis, AST is usually the recommended medium to
    use, thanks to its rich amount of semantic information and high-level structures.
    In this chapter, we learned about the powerful in-memory AST representation that's
    used in Clang, including its C++ classes and APIs. This gives you a clear picture
    of the source code you are analyzing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到程序分析时，AST通常是推荐的介质，因为它包含丰富的语义信息和高级结构。在本章中，我们了解了Clang中使用的强大内存AST表示，包括其C++类和API。这为你提供了分析源代码的清晰图景。
- en: Furthermore, we learned and practiced a concise way to do pattern matching on
    AST – a crucial procedure for program analysis – via Clang's ASTMatcher. Familiarizing
    yourself with this technique can greatly improve your efficiency when it comes
    to filtering out interesting areas from the input source code. Last but not least,
    we learned how to write an AST plugin that makes it easier for you to integrate
    custom logic into the default Clang compilation pipeline.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习和实践了一种简洁的方法来进行AST上的模式匹配——这是程序分析的一个关键过程——通过Clang的ASTMatcher。熟悉这项技术可以大大提高你在从输入源代码中过滤出有趣区域时的效率。最后但同样重要的是，我们学习了如何编写一个AST插件，这使得你更容易将自定义逻辑集成到默认的Clang编译管道中。
- en: In the next chapter, we will look at the **drivers** and **toolchains** in Clang.
    We will show you how they work and how to customize them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Clang中的 **驱动程序** 和 **工具链**。我们将向您展示它们是如何工作的以及如何自定义它们。
