- en: Chapter 16.  Extending SFML Classes, Particle Systems, and Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。扩展SFML类，粒子系统和着色器
- en: In this final chapter, we will explore the C++ concept of extending other people's
    classes. More specifically, we will look at the SFML `Drawable` class and the
    benefits of using it as a base class for our own classes. We will also scratch
    the surface of the topic of OpenGL shaders and see how writing code in another
    language **OpenGL Shading Language** (**GLSL**), which can be run directly on
    the graphics card, can lead to smooth graphical effects that might otherwise be
    impossible. As usual, we will also use our new skills and knowledge to enhance
    the current project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们将探讨C++中扩展他人类的概念。更具体地说，我们将看看SFML `Drawable`类以及将其用作我们自己类的基类的好处。我们还将浅尝OpenGL着色器的主题，并看看如何使用另一种语言**OpenGL着色语言**（**GLSL**）编写代码，可以直接在图形卡上运行，可以产生可能无法实现的平滑图形效果。像往常一样，我们还将利用我们的新技能和知识来增强当前项目。
- en: 'Here is a list of the topics in the order we will cover them:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将按顺序涵盖的主题列表：
- en: The SFML Drawable class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML Drawable类
- en: Building a particle system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个粒子系统
- en: OpenGl shaders and GLSL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL着色器和GLSL
- en: Using shaders in the Thomas Was Late game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Thomas Was Late游戏中使用着色器
- en: The SFML Drawable class
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML Drawable类
- en: "The `Drawable` class has just one function. It has no variables either. Furthermore,\
    \ its one and only function is pure virtual. This means that if we inherit from\
    \ `Drawable`, we must implement its one and only function. The purpose of this,\
    \ which you may remember from [Chapter 12](ch12.html \"Chapter 12. Abstraction\
    \ and Code Management – Making Better Use of OOP\"), *Abstraction and Code Management â\x80\
    \x94 Making Better Use of OOP*, is that we can then use our class, which inherits\
    \ from `drawable`, as a polymorphic type. Put more simply, anything that SFML\
    \ allows us to do with a `Drawable` object, we will be able to do with our class\
    \ that inherits from it. The only requirement is that we must provide a definition\
    \ for the pure virtual function, `draw`."
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawable`类只有一个函数。它也没有变量。此外，它唯一的功能是纯虚拟的。这意味着如果我们从`Drawable`继承，我们必须实现它唯一的功能。这个目的，你可能还记得来自[第12章](ch12.html
    "第12章。抽象和代码管理-更好地利用OOP")的*抽象和代码管理-更好地利用OOP*，就是我们可以使用继承自`drawable`的类作为多态类型。更简单地说，任何SFML允许我们对`Drawable`对象做的事情，我们都可以用继承自它的类来做。唯一的要求是我们必须为纯虚拟函数`draw`提供定义。'
- en: Some classes that inherit from `Drawable` already include `Sprite` and `VertexArray`
    (among others). Whenever we have used `Sprite` or `VertexArray`, we have passed
    them to the `draw` function of the `RenderWindow` class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些从`Drawable`继承的类已经包括`Sprite`和`VertexArray`（还有其他）。每当我们使用`Sprite`或`VertexArray`时，我们都将它们传递给`RenderWindow`类的`draw`函数。
- en: The reason that we have been able to draw every object we have drawn in this
    book is that they have all inherited from `Drawable`. We can use this knowledge
    to our advantage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能够绘制本书中绘制的每个对象，是因为它们都继承自`Drawable`。我们可以利用这个知识。
- en: 'We can inherit from `Drawable` with any object we like, as long as we implement
    the pure virtual `draw` function. This is also a straightforward process. The
    header file (`SpaceShip.h`) of a hypothetical `SpaceShip` class that inherits
    from `Drawable` would look as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用任何我们喜欢的对象从`Drawable`继承，只要我们实现纯虚拟的`draw`函数。这也是一个简单的过程。假设从`Drawable`继承的`SpaceShip`类的头文件（`SpaceShip.h`）将如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, we can see the pure virtual `draw` function and a Sprite.
    Notice there is no way to access the private `Sprite` outside of the class, not
    even a `getSprite` function!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到纯虚拟的`draw`函数和一个Sprite。请注意，没有办法在类的外部访问私有的`Sprite`，甚至没有`getSprite`函数！
- en: 'The `SpaceShip.cpp` file would then look something like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`SpaceShip.cpp`文件看起来会像下面这样：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code, notice the simple implementation of the `draw` function.
    The parameters are beyond the scope of the book. Just note that the `target` parameter
    is used to call `draw` and passes in `m_Sprite` as well as `states`, the other
    parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意`draw`函数的简单实现。参数超出了本书的范围。只需注意`target`参数用于调用`draw`并传入`m_Sprite`以及`states`，另一个参数。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'While it is not necessary to understand the parameters to take full advantage
    of `Drawable`, in the context of the book, you might be intrigued. You can read
    more about the SFML `Drawable` class on the SFML website: [http://www.sfml-dev.org/tutorials/2.3/graphics-vertex-array.php#creating-an-sfml-like-entity](http://www.sfml-dev.org/tutorials/2.3/graphics-vertex-array.php#creating-an-sfml-like-entity)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不需要理解参数来充分利用`Drawable`，但在本书的上下文中，你可能会感兴趣。你可以在SFML网站上阅读更多关于SFML `Drawable`类的信息：[http://www.sfml-dev.org/tutorials/2.3/graphics-vertex-array.php#creating-an-sfml-like-entity](http://www.sfml-dev.org/tutorials/2.3/graphics-vertex-array.php#creating-an-sfml-like-entity)
- en: 'In the main game loop, we could now treat a `SpaceShip` instance as if it were
    a `Sprite`, or any other class that inherits from `Drawable`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在主游戏循环中，我们现在可以将`SpaceShip`实例视为`Sprite`，或者从`Drawable`继承的任何其他类：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is because `SpaceShip` is a `Drawable` that we can treat it like a `Sprite`
    or `VertexArray`, and because we overrode the pure virtual `draw` function, everything
    just works as we want it to. Let's look at an alternative way of encapsulating
    the drawing code into the game object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为`SpaceShip`是一个`Drawable`，我们才能将其视为`Sprite`或`VertexArray`，并且因为我们覆盖了纯虚拟的`draw`函数，一切都按我们想要的方式运行。让我们看看另一种将绘图代码封装到游戏对象中的方法。
- en: An alternative to inheriting from Drawable
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Drawable继承的另一种选择
- en: 'It is also possible to keep all the drawing functionality within the class
    that is the object to be drawn by implementing our own function, within our class,
    perhaps like the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的类内部实现自己的函数，也许像以下代码一样，也可以将所有绘图功能保留在要绘制的对象类中：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous code assumes that `m_Sprite` represents the visual appearance
    of the current class we are drawing, as it has throughout this and the previous
    project. Assuming that the instance of the class that contains the `drawThisObject`
    function is called `playerHero`, and further assuming we have an instance of `RenderWindow`
    called `m_Window`, we could then draw the object from the main game loop with
    the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码假设`m_Sprite`代表了我们正在绘制的当前类的视觉外观，就像在这个和前一个项目中一直使用的那样。假设包含`drawThisObject`函数的类的实例被称为`playerHero`，并且进一步假设我们有一个名为`m_Window`的`RenderWindow`的实例，我们可以在主游戏循环中使用以下代码绘制对象：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this solution, we pass the `RenderWindow`, `m_Window`, into the `drawThisObject`
    function as a parameter. The `drawThisObject` function then uses the `RenderWindow`
    to draw the `Sprite`, `m_Sprite`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们将`RenderWindow` `m_Window`作为参数传递给`drawThisObject`函数。然后`drawThisObject`函数使用`RenderWindow`来绘制`Sprite`
    `m_Sprite`。
- en: This solution certainly seems simpler than extending `Drawable`. The reason
    we do things the way suggested (extending Drawable) isn't really of any great
    benefit, in its own right, for this project. The actual reason we will soon draw
    a neat explosion using this method is because it is a good technique to learn.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展`Drawable`相比，这个解决方案似乎更简单。我们之所以按照建议的方式（扩展Drawable）做事情的原因并不是因为这个项目本身有很大的好处。我们很快将用这种方法绘制一个整洁的爆炸，原因是这是一个很好的学习技巧。
- en: Why it is best to inherit from Drawable?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么最好继承自Drawable？
- en: With each project we have completed throughout the book, we have learned more
    about games, C++, and SFML. Possibly the biggest improvements we have made from
    one game to the next is in the structure of our code–the programming **patterns**
    that we have used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书完成的每个项目，我们都学到了更多关于游戏、C++和SFML。从一个游戏到下一个游戏，我们所做的最大的改进可能是我们的代码结构——我们所使用的编程**模式**。
- en: If there were a fourth project to this book, we could take things even further.
    Unfortunately, there isn't, but have a think about the following idea for improving
    our code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这本书有第四个项目，我们可以进一步发展。不幸的是，没有，但是想一想以下改进我们代码的想法。
- en: Imagine every object in our game is derived from a single, simple, abstract
    base class. Let's call it `GameObject`. Game object would probably have concrete
    functions for `getPosition` and others. It would likely have a pure virtual `update`
    function (because every object updates differently). Furthermore, consider that
    `GameObject` inherits from `Drawable`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们游戏中的每个对象都是从一个简单的抽象基类派生出来的。让我们称之为`GameObject`。游戏对象可能有具体的`getPosition`等函数。它可能有一个纯虚拟的`update`函数（因为每个对象的更新方式都不同）。此外，考虑`GameObject`继承自`Drawable`。
- en: 'Now look at this hypothetical code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个假设的代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is a big step up in terms of encapsulation, code manageability,
    and elegance when compared to even this final project. If you look at the previous
    code, you will notice there are, however, unanswered questions, such as where
    collision detection fits in, for example. Hopefully, however, you can see that
    further study (by building lots of games) will be necessary to master C++.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与甚至最终项目相比，上述代码在封装、代码可管理性和优雅方面有了很大的进步。如果你看一下以前的代码，你会注意到有一些未解答的问题，比如碰撞检测在哪里等等。然而，希望你能看到，进一步的学习（通过构建很多游戏）将是掌握C++所必需的。
- en: Although we will not be implementing an entire game in this manner, we will
    see how we can design a class (`ParticleSystem`) and pass it directly to `m_Window.draw(m_MyParticleSystemInstance)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会以这种方式实现整个游戏，但我们将看到如何设计一个类（`ParticleSystem`）并将其直接传递给`m_Window.draw(m_MyParticleSystemInstance)`。
- en: Building a particle system
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个粒子系统
- en: 'Before we start coding, it will be helpful to see exactly what it is we are
    trying to achieve. Take a look at the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，看一看我们要实现的确切目标将会很有帮助。看一下以下截图：
- en: '![Building a particle system](img/image_16_001.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个粒子系统](img/image_16_001.jpg)'
- en: This is a screenshot of the particle effect on a plain background. We will use
    the effect in our game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个纯背景上粒子效果的截图。我们将在我们的游戏中使用这个效果。
- en: 'The way we achieve the effect is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现效果的方式如下：
- en: Spawn 1,000 dots (particles), one on top of the other, at a chosen pixel position.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择的像素位置生成1,000个点（粒子），一个叠在另一个上面。
- en: In each frame of the game, move each of the 1,000 particles outward at a predetermined,
    but random, speed and angle.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏的每一帧中，以预定但随机的速度和角度将1,000个粒子向外移动。
- en: Repeat step two for two seconds and then make the particles disappear.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复第二步两秒钟，然后使粒子消失。
- en: We will use a `VertexArray` to draw all the dots and the primitive type of `Point`
    to represent each particle visually. Furthermore, we will inherit from `Drawable`
    so that our particle system can take care of drawing itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`VertexArray`来绘制所有的点，使用`Point`的原始类型来直观地表示每个粒子。此外，我们将继承自`Drawable`，以便我们的粒子系统可以自行绘制。
- en: Coding the Particle class
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Particle类
- en: The `Particle` class will be a simple class that represents just one of the
    1,000 particles. Let's get coding.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle`类将是一个简单的类，代表了1,000个粒子中的一个。让我们开始编码。'
- en: Coding Particle.h
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Particle.h
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `Particle.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `Particle`
    class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件**（`.h`）突出显示，然后在**名称**字段中键入`Particle.h`。最后，单击**添加**按钮。我们现在准备为`Particle`类编写头文件。
- en: 'Add the following code to the `Particle.h` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Particle.h`文件中：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have two `Vector2f` objects. One will represent the
    horizontal and vertical coordinates of the particle and the other will represent
    the horizontal and vertical speed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有两个`Vector2f`对象。一个代表粒子的水平和垂直坐标，另一个代表水平和垂直速度。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you have a rate of change (speed) in more than one direction, the combined
    values also define a direction. This is called **velocity**; hence, the Vector2f
    is called `m_Velocity`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个以上方向的变化率（速度）时，合并的值也定义了一个方向。这就是所谓的**速度**；因此，Vector2f被称为'm_Velocity'。
- en: We also have a number of public functions. First is the constructor. It takes
    a `Vector2f`, which will be used to let it know what direction/velocity this particle
    will have. This implies that the system, not the particle itself, will be choosing
    the velocity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些公共函数。首先是构造函数。它接受一个'Vector2f'，将用于让它知道这个粒子将具有什么方向/速度。这意味着系统，而不是粒子本身，将选择速度。
- en: Next is the `update` function, which takes the time the previous frame has taken.
    We will use this to move the particle by precisely the correct amount.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是'update'函数，它接受前一帧所花费的时间。我们将使用这个时间精确地移动粒子。
- en: The final two functions, `setPosition` and `getPosition`, are used to move the
    particle into position and find out its position, respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个函数，'setPosition'和'getPosition'，用于将粒子移动到位置并找出其位置。
- en: All these functions will make complete sense when we code them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写这些函数时，所有这些函数都会变得非常清晰。
- en: Coding the Particle.cpp file
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Particle.cpp文件
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** (`.cpp`) and then in the **Name** field, type `Particle.cpp`. Finally,
    click the **Add** button. We are now ready to code the `.cpp` file for the `Particle`
    class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中右键单击“源文件”，然后选择“添加”|“新项目...”。在“添加新项目”窗口中，突出显示（通过左键单击）“C++文件”（.cpp），然后在“名称”字段中键入“Particle.cpp”。最后，单击“添加”按钮。我们现在准备为Particle类编写.cpp文件。
- en: 'Add the following code to `Particle.cpp`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到'Particle.cpp'中：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All these functions use concepts we have seen before. The constructor sets up
    the `m_Velocity.x` and `m_Velocity.y` values using the passed-in `Vector2f` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都使用了我们之前见过的概念。构造函数使用传入的Vector2f对象设置了'm_Velocity.x'和'm_Velocity.y'的值。
- en: The `update` function moves the horizontal and vertical positions of the particle
    by multiplying `m_Velocity` by the elapsed time (`dtAsSeconds`). Notice that to
    achieve this, we simply add the two `Vector2f` objects together. There is no need
    to perform calculations for both the *x* and *y* members separately.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '''update''函数通过将经过的时间（''dtAsSeconds''）乘以''m_Velocity''来移动粒子的水平和垂直位置。请注意，为了实现这一点，我们只需将两个''Vector2f''对象相加即可。无需分别为''x''和''y''成员执行计算。'
- en: The `setPosition` function, as previously explained, initializes the `m_Position`
    object with the passed-in values. The `getPosition` function returns `m_Position`
    to the calling code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，'setPosition'函数使用传入的值初始化了'm_Position'对象。'getPosition'函数将'm_Position'返回给调用代码。
- en: We now have a fully functioning `Particle` class. Next, we will code a `ParticleSystem`
    class to spawn and control the particles.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的Particle类。接下来，我们将编写一个ParticleSystem类来生成和控制粒子。
- en: Coding the ParticleSystem class
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写ParticleSystem类
- en: The `ParticleSystem` class does most of the work for our particle effects. It
    is this class that we will create an instance of in the `Engine` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '''ParticleSystem''类为我们的粒子效果做了大部分工作。我们将在''Engine''类中创建这个类的一个实例。'
- en: Coding ParticleSystem.h
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写ParticleSystem.h
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `ParticleSystem.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `ParticleSystem` class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中右键单击“头文件”，然后选择“添加”|“新项目...”。在“添加新项目”窗口中，突出显示（通过左键单击）“头文件”（.h），然后在“名称”字段中键入“ParticleSystem.h”。最后，单击“添加”按钮。我们现在准备为ParticleSystem类编写头文件。
- en: 'Add the code for the `ParticleSystem` class to `ParticleSystem.h`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将ParticleSystem类的代码添加到ParticleSystem.h中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's go through this a bit at a time. Firstly, notice that we are inheriting
    from `Drawable`. This is what will enable us to pass our `ParticleSystem` instance
    to `m_Window.draw`, because `ParticleSystem` is a `Drawable`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一点点来看这个。首先，注意我们是从'Drawable'继承的。这将使我们能够将我们的'ParticleSystem'实例传递给'm_Window.draw'，因为'ParticleSystem'是一个'Drawable'。
- en: There is a vector named `m_Particles`, of type `Particle`. This vector will
    hold each and every instance of `Particle`. Next we have a `VertexArray` called
    `m_Vertices`. This will be used to draw all the particles in the form of a whole
    bunch of `Point` primitives.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为'm_Particles'的类型为'Particle'的向量。这个向量将保存每个'Particle'的实例。接下来我们有一个名为'm_Vertices'的'VertexArray'。这将用于以一堆'Point'原语的形式绘制所有的粒子。
- en: The `m_Duration`, `float` variable is how long each effect will last. We will
    initialize it in the constructor function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '''m_Duration''，''float''变量是每个效果持续的时间。我们将在构造函数中初始化它。'
- en: The Boolean  `m_IsRunning` variable will be used to indicate whether the particle
    system is currently in use or not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值'm_IsRunning'变量将用于指示粒子系统当前是否正在使用。
- en: Next, in the public section, we have the pure virtual function, `draw`, that
    we will soon implement to handle what happens when we pass our instance of `ParticleSystem`
    to `m_Window.draw`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在公共部分，我们有一个纯虚函数'draw'，我们将很快实现它来处理当我们将ParticleSystem的实例传递给'm_Window.draw'时发生的情况。
- en: The `init` function will prepare the `VertexArray` and the `vector`. It will
    also initialize all the `Particle` objects (held by the `vector`) with their velocities
    and initial positions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '''init''函数将准备''VertexArray''和''vector''。它还将使用它们的速度和初始位置初始化所有的''Particle''对象（由''vector''持有）。'
- en: The `update` function will loop through each and every `Particle` instance in
    the `vector` and call their individual `update` functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '''update''函数将循环遍历''vector''中的每个''Particle''实例，并调用它们各自的''update''函数。'
- en: The `running` function provides access to the `m_IsRunning` variable so that
    the game engine can query whether or not the `ParticleSystem` is currently in
    use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`running`函数提供对`m_IsRunning`变量的访问，以便游戏引擎可以查询`ParticleSystem`当前是否正在使用。'
- en: Let's code the function definitions to see what goes on inside `ParticleSystem`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写函数定义，看看`ParticleSystem`内部发生了什么。
- en: Coding the ParticleSystem.cpp file
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写ParticleSystem.cpp文件
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `ParticleSystem.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `ParticleSystem` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击**Solution Explorer**中的**Source Files**，然后选择**Add** | **New Item...**。在**Add
    New Item**窗口中，通过左键单击**C++ File (** `.cpp` **)**突出显示，然后在**Name**字段中键入`ParticleSystem.cpp`。最后，单击**Add**按钮。现在我们准备好为`ParticleSystem`类编写`.cpp`文件了。
- en: 'We will split this file into five sections to code and discuss it better. Add
    the first section of code as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个文件分成五个部分来编码和讨论。按照这里所示，添加代码的第一部分：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the necessary `includes`, we have the definition of the `init` function.
    We call `setPrimitiveType` with `Points` as the argument so that `m_VertexArray`
    knows what types of primitive it will be dealing with. We resize `m_Vertices`
    with `numParticles`, which was passed in to the `init` function when it was called.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在必要的`includes`之后，我们有`init`函数的定义。我们调用`setPrimitiveType`，参数为`Points`，以便`m_VertexArray`知道它将处理什么类型的基元。我们使用`numParticles`调整`m_Vertices`的大小，这是在调用`init`函数时传入的。
- en: The `for` loop creates random values for speed and angle. It then uses trigonometric
    functions to convert those values into a vector, which is stored in the `Vector2f`,
    `direction`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环创建速度和角度的随机值。然后使用三角函数将这些值转换为一个向量，存储在`Vector2f` `direction`中。'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to know more about how the trigonometric functions (`cos`, `sin`,
    and `tan`) convert angles and speeds into a vector, you can take a look at this
    article series: [http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解三角函数（`cos`、`sin`和`tan`）如何将角度和速度转换为向量，可以查看这篇文章系列：[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)
- en: The last thing that happens in the `for` loop (and the `init` function) is that
    the vector is passed in to the `Particle` constructor. The new `Particle` instance
    is stored in `m_Particles` using the `push_back` function. Therefore, a call to
    `init` with a value of `1000` would mean we have one thousand instances of `Particle`,
    with random velocity, stashed away in `m_Particles` just waiting to blow!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环（和`init`函数）中发生的最后一件事是将向量传递给`Particle`构造函数。新的`Particle`实例使用`push_back`函数存储在`m_Particles`中。因此，使用值`1000`调用`init`将意味着我们有一千个`Particle`实例，具有随机速度，藏在`m_Particles`中等待爆炸！'
- en: 'Next, add the `update` function to `ParticleSysytem.cpp`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`ParticleSysytem.cpp`中添加`update`函数：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `update` function is simpler than it looks at first glance. First of all,
    `m_Duration` is reduced by the passed-in time, `dt`. This is so we know when the
    two seconds have elapsed. A vector iterator, `i`, is declared for use with `m_Particles`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数比起初看起来要简单一些。首先，`m_Duration`会减去传入的时间`dt`，这样我们就知道两秒已经过去了。声明一个向量迭代器`i`，用于`m_Particles`。'
- en: The `for` loop goes through each of the `Particle` instances in `m_Particles`.
    For each and every one it calls its `update` function and passes in `dt`. Each
    particle will update its position. After the particle has updated itself, the
    appropriate vertex in `m_Vertices` is updated by using the particle's `getPosition`
    function. At the end of each pass through, the `for` loop `currentVertex` is incremented,
    ready for the next vertex.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环遍历`m_Particles`中的每个`Particle`实例。对于每一个粒子，它都调用其`update`函数并传入`dt`。每个粒子都将更新其位置。粒子更新完毕后，通过使用粒子的`getPosition`函数更新`m_Vertices`中的适当顶点。在每次循环结束时，`for`循环中的`currentVertex`都会递增，准备好下一个顶点。'
- en: After the `for` loop has completed, `if(m_Duration < 0)` checks whether it is
    time to switch off the effect. If two seconds have elapsed, `m_IsRunning` is set
    to `false`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环完成后，`if(m_Duration < 0)`检查是否是时候关闭效果了。如果两秒已经过去，`m_IsRunning`将设置为`false`。'
- en: 'Next, add the `emitParticles` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`emitParticles`函数：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the function we will call to start the particle system running. So,
    predictably, we set `m_IsRunning` to `true` and `m_Duration` to `2`. We declare
    an `iterator`, `i`, to iterate through all the `Particle` objects in `m_Particles`,
    and then we do so in a `for` loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将调用来启动粒子系统运行的函数。因此，可以预料到，我们将`m_IsRunning`设置为`true`，`m_Duration`设置为`2`。我们声明一个`iterator`
    `i`，用于遍历`m_Particles`中的所有`Particle`对象，然后在`for`循环中这样做。
- en: Inside the `for` loop, we set each particle in the vertex array to yellow and
    set each position to `startPosition`, which was passed in as a parameter. Remember
    that each particle starts life in exactly the same position, but they are each
    assigned a different velocity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们将顶点数组中的每个粒子设置为黄色，并将每个位置设置为传入的`startPosition`。请记住，每个粒子的生命都从完全相同的位置开始，但它们各自被分配了不同的速度。
- en: 'Next, add the pure virtual draw function definition:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加纯虚拟的draw函数定义：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous code, we simply use `target` to call `draw`, passing in `m_Vertices`
    and `states`. This is exactly as we discussed when talking about `Drawable` earlier
    in the chapter, except we pass in our `VertexArray`, which holds 1,000 point primitives
    instead of the hypothetical spaceship Sprite.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们简单地使用`target`调用`draw`，传入`m_Vertices`和`states`。这与我们在本章早些时候讨论`Drawable`时讨论的完全一样，只是我们传入了我们的`VertexArray`，其中包含了1000个点的基元，而不是假设的太空飞船Sprite。
- en: 'Finally, add the running function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`running`函数：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `running` function is a simple getter function that returns the value of
    `m_IsRunning`. We will see where this is useful to determine the current state
    of the particle system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`running`函数是一个简单的getter函数，返回`m_IsRunning`的值。我们将看到这在确定粒子系统的当前状态时是有用的。'
- en: Using ParticleSystem
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ParticleSystem
- en: To put our particle system to work is very straightforward, especially because
    we inherited from `Drawable`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的粒子系统工作非常简单，特别是因为我们继承自`Drawable`。
- en: Adding a ParticleSystem object to the Engine class
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向Engine类添加一个ParticleSystem对象
- en: 'Open `Engine.h` and add a `ParticleSystem` object, as shown in the following
    highlighted code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`并添加一个`ParticleSystem`对象，如下所示的高亮代码：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, initialize the system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化系统。
- en: Initializing ParticleSystem
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化ParticleSystem
- en: 'Open the `Engine.cpp` file and add the short highlighted code right at the
    end of the `Engine` constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.cpp`文件，并在`Engine`构造函数的最后添加短暗示代码：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `VertexArray` and the `vector` of `Particle` instances are ready for action.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexArray`和`Particle`实例的`vector`已经准备就绪。'
- en: Updating the particle system in each frame
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在每一帧更新粒子系统
- en: 'Open the `Update.cpp` file and add the following highlighted code. It can go
    right at the end of the `update` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Update.cpp`文件，并在`update`函数的最后添加以下高亮代码：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All that is needed in the previous code is the call to `update`. Notice that
    it is wrapped in a check to make sure the system is currently running. If it isn't
    running, there is no point updating it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码中，只需要调用`update`。请注意，它被包裹在一个检查中，以确保系统当前正在运行。如果它没有运行，更新它就没有意义。
- en: Starting the particle system
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动粒子系统
- en: Open the `DetectCollisions.cpp` file, which has the `detectCollisions` function
    in it. We left a comment in it when we originally coded it back in [Chapter 15](ch14.html
    "Chapter 14. Building Playable Levels and Collision Detection"), *Building Playable
    Levels and Collision Detection*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`DetectCollisions.cpp`文件，其中包含`detectCollisions`函数。当我们最初编写它时，我们在[第15章](ch14.html
    "第14章。构建可玩级别和碰撞检测")中留下了一个注释，*构建可玩级别和碰撞检测*。
- en: 'Identify the correct place from the context and add the highlighted code, as
    shown:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从上下文中找到正确的位置并添加高亮代码，如下所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First the code checks if the particle system is already running. If it isn't,
    it checks if the current tile being checked is either a water or a fire tile.
    If either is the case, it checks whether the character's feet are in contact.
    When each of these `if` statements is `true`, the particle system is started by
    calling the `emitParticles` function and passing in the location of the center
    of the character as the coordinates to start the effect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查粒子系统是否已经运行。如果没有运行，它会检查当前正在检查的瓦片是否是水瓦片或火瓦片。如果是这种情况，它会检查角色的脚是否接触。当这些`if`语句中的每一个为`true`时，通过调用`emitParticles`函数并传入角色中心的位置作为开始效果的坐标来启动粒子系统。
- en: Drawing the particle system
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制粒子系统
- en: This is the best bit. See how easy it is to draw the `ParticleSystem`. We pass
    our instance directly to the `m_Window.draw` function after checking that the
    particle system is actually running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最好的部分。看看绘制`ParticleSystem`有多容易。在检查粒子系统实际运行后，我们直接将实例传递给`m_Window.draw`函数。
- en: 'Open the `Draw.cpp` file and add the highlighted code in all the places shown
    in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Draw.cpp`文件，并在以下代码中显示的所有位置添加高亮代码：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice in the previous code that we have to draw the particle system in all
    of the left, right, and full-screen code blocks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上一个代码中，我们必须在所有的左侧、右侧和全屏代码块中绘制粒子系统。
- en: 'Run the game and move one of the character''s feet over the edge of a fire
    tile. Notice the particle system burst into life:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，并将角色的一只脚移动到火瓦片的边缘。注意粒子系统会突然活跃起来：
- en: '![Drawing the particle system](img/image_16_002.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![绘制粒子系统](img/image_16_002.jpg)'
- en: Now for something else that is new.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是另一件新事物。
- en: OpenGL, shaders, and GLSL
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL、着色器和GLSL
- en: '**Open Graphics Library **(**OpenGL**) is a programming library that handles
    2D and 3D graphics. OpenGL works on all major desktop operating systems and there
    is also a version, OpenGL ES, that works on mobile devices.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL**（**Open Graphics Library**）是一个处理2D和3D图形的编程库。OpenGL适用于所有主要桌面操作系统，还有一个适用于移动设备的版本OpenGL
    ES。'
- en: OpenGL was originally released in 1992\. It has been refined and improved over
    more than twenty years. Furthermore, graphics cards manufacturers design their
    hardware to make it work well with OpenGL. The point of telling you this is not
    for the history lesson, but to explain that it would be a fool's errand to try
    and improve upon OpenGL, and using it in 2D (and 3D) games on the desktop, especially
    if you want your game to run on more than just Windows, is the obvious choice.
    We are already using OpenGL because SFML uses OpenGL. Shaders are programs that
    run on the GPU itself, so let's find out more about them next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL最初是在1992年发布的。它在二十多年的时间里得到了改进和提高。此外，图形卡制造商设计他们的硬件使其与OpenGL良好地配合工作。告诉你这一点的目的不是为了历史课，而是为了解释如果你想让游戏在桌面上的2D（和3D）上运行，并且希望你的游戏不仅仅在Windows上运行，那么使用OpenGL是一个明显的选择。我们已经在使用OpenGL，因为SFML使用OpenGL。着色器是在GPU上运行的程序，所以让我们更多地了解它们。
- en: The programmable pipeline and shaders
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可编程管线和着色器
- en: Through OpenGL we have access to what is called a **programmable pipeline**.
    We can send our graphics off to be drawn, each frame, with the `RenderWindow` `draw`
    function. We can also write code that runs on the GPU, which is capable of manipulating
    each and every pixel independently**,** after the call to `draw`. This is a very
    powerful feature.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过OpenGL，我们可以访问所谓的**可编程管线**。我们可以发送我们的图形进行绘制，每一帧都可以使用`RenderWindow`的`draw`函数。我们还可以编写在调用`draw`后在GPU上运行的代码，它能够独立地操纵每一个像素。这是一个非常强大的功能。
- en: This extra code that runs on the GPU is called a **shader program**. We can
    write code to manipulate the geometry (position) of our graphics in what is called
    a **vertex shader**. We can also write code that manipulates the appearance of
    each and every pixel individually, in code called a **fragment shader**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上运行的这些额外代码称为**着色器程序**。我们可以编写代码来操纵我们图形的几何（位置），这称为**顶点着色器**。我们还可以编写代码，以在称为**片段着色器**的代码中单独操纵每个像素的外观。
- en: Although we will not be exploring shaders in any great depth, we will write
    some shader code using GLSL and we will get a glimpse of the possibilities offered.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会深入探讨着色器，但我们将使用GLSL编写一些着色器代码，并且将一窥所提供的可能性。
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry and we can also combine these
    elements to make the complex graphics that we see in today's modern games. These
    are collectively known as **primitives**. We have access to OpenGL primitives
    through the SFML primitives and `VertexArray`, as well as the `Sprite` and `Shape`
    classes we have seen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，一切都是点、线或三角形。此外，我们可以将颜色和纹理附加到这些基本几何图形，并且我们还可以将这些元素组合在一起，以制作我们在今天的现代游戏中看到的复杂图形。这些统称为**基元**。我们可以通过SFML基元和`VertexArray`以及我们所见过的`Sprite`和`Shape`类来访问OpenGL基元。
- en: In addition to primitives, OpenGL uses matrices. Matrices are a method and structure
    for performing arithmetic. This arithmetic can range from extremely simple high
    school-level calculations to move (translate) a coordinate, or it can be quite
    complex, to perform more advanced mathematics; such as, converting our game world
    coordinates into OpenGL screen coordinates that the GPU can use. Fortunately,
    it is this complexity that SFML handles for us behind the scenes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基元，OpenGL还使用矩阵。矩阵是一种执行算术的方法和结构。这种算术可以从非常简单的高中水平计算移动（平移）坐标，或者可以非常复杂，执行更高级的数学；例如，将我们的游戏世界坐标转换为OpenGL屏幕坐标，GPU可以使用。幸运的是，正是这种复杂性在幕后由SFML为我们处理。
- en: 'SFML also allows us to handle OpenGL directly. If you want to find out more
    about OpenGL, you can get started here: [http://learnopengl.com/#!Introduction](http://learnopengl.com/#!Introduction).
    If you want to use OpenGL directly alongside SFML, you can read the following
    article: [http://www.sfml-dev.org/tutorials/2.3/window-opengl.php](http://www.sfml-dev.org/tutorials/2.3/window-opengl.php).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SFML还允许我们直接处理OpenGL。如果您想了解更多关于OpenGL的信息，可以从这里开始：[http://learnopengl.com/#!Introduction](http://learnopengl.com/#!Introduction)。如果您想直接在SFML旁边使用OpenGL，可以阅读以下文章：[http://www.sfml-dev.org/tutorials/2.3/window-opengl.php](http://www.sfml-dev.org/tutorials/2.3/window-opengl.php)。
- en: An application can have many shaders. We can then *attach* different shaders
    to different game objects to create the desired effects. We will only have one
    vertex and one fragment shader in this game. We will apply it, each frame, to
    the background.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有许多着色器。然后我们可以*附加*不同的着色器到不同的游戏对象上，以创建所需的效果。在这个游戏中，我们只会有一个顶点着色器和一个片段着色器。我们将在每一帧将其应用到背景上。
- en: However, when you see how to attach a shader to a `draw` call, it will be plain
    that it is trivial to add more shaders.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当您了解如何将着色器附加到`draw`调用时，就会明显地知道可以轻松添加更多着色器。
- en: 'We will follow these steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤进行：
- en: First of all, we need the code for the shader that will be executed on the GPU.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在GPU上执行的着色器代码。
- en: Then we need to compile that code.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要编译该代码。
- en: Finally, we need to attach the shader to the appropriate draw call in the draw
    function of our game engine.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将着色器附加到游戏引擎的绘图函数中的适当绘图调用。
- en: GLSL is a language in its own right and it also has its own types, and variables
    of those types can be declared and utilized. Furthermore, we can interact with
    the shader program's variables from our C++ code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL是一种独立的语言，它也有自己的类型，可以声明和使用这些类型的变量。此外，我们可以从我们的C++代码与着色器程序的变量进行交互。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If gaining further knowledge about the power of programmable graphics pipelines
    and shaders is just too exciting to leave for another day, then I can highly recommend
    GLSL Essentials by Jacobo RodrÃ­guez: [https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials).
    The book explores OpenGL shaders on the desktop and is highly accessible to any
    reader with decent C++ programming knowledge and a willingness to learn a different
    language.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对可编程图形管线和着色器的强大功能有进一步了解的话，那么我强烈推荐Jacobo RodrÃ­guez的《GLSL Essentials》：[https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials)。该书探讨了桌面上的OpenGL着色器，并且对于具有良好的C++编程知识并且愿意学习不同语言的任何读者来说都非常易于理解。
- en: As we will see, GLSL has some syntax similarities to C++.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，GLSL与C++有一些语法相似之处。
- en: Coding a fragment shader
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写片段着色器
- en: 'Here is the code from the `rippleShader.frag` file in the `shaders` folder.
    You don''t need to code this as it was in the assets we added back in [Chapter
    12](ch12.html "Chapter 12. Abstraction and Code Management – Making Better Use
    of OOP"), *Abstraction and Code Management – Making Better Use of OOP*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`shaders`文件夹中`rippleShader.frag`文件中的代码。您不需要编写此代码，因为它在我们在[第12章](ch12.html "第12章。抽象和代码管理-更好地利用OOP")中添加的资产中已经存在，*抽象和代码管理-更好地利用OOP*：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first four lines (excluding comments) are the variables that the fragment
    shader will use. However, they are not ordinary variables. The first type we see
    is `varying`. These are variables which are in scope between both `shaders`. Next,
    we have the `uniform` variables. These variables can be manipulated directly from
    our C++ code. We will see how we do this soon.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行（不包括注释）是片段着色器将使用的变量。但它们不是普通的变量。我们看到的第一种类型是`varying`。这些是在两个`shaders`之间范围内的变量。接下来，我们有`uniform`变量。这些变量可以直接从我们的C++代码中操作。我们很快将看到我们如何做到这一点。
- en: 'In addition to the `varying` and `uniform` types, each of the variables also
    has a more conventional type, which defines the actual data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`varying`和`uniform`类型之外，每个变量还有一个更常规的类型，用于定义实际数据：
- en: '`vec4` is a vector with four values'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec4`是一个具有四个值的向量'
- en: '`vec2` is a vector with two values'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec2`是一个具有两个值的向量'
- en: '`sampler2d` will hold a texture'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampler2d`将保存一个纹理'
- en: '`float` is just like a `float` in C++'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`就像C++中的`float`'
- en: The code inside the `main` function is what is actually executed. If you look
    closely at the code in `main`, you will see each of the variables in use. Exactly
    what this code does is beyond the scope of this book. In summary, however, the
    texture coordinates (`vTexCoord`) and the color of the pixels/fragments (`glFragColor`)
    are manipulated by a number of mathematical functions and operations. Remember
    that this executes for each and every pixel involved in the draw call, on each
    and every frame of our game. Furthermore, be aware that `uTime` is passed in as
    a different value, each and every frame. The result, as we will soon see, will
    be a rippling effect.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数内部的代码才是实际执行的。如果你仔细看`main`中的代码，你会看到每个变量的使用。这段代码实际上做了什么超出了本书的范围。然而，总的来说，纹理坐标(`vTexCoord`)和像素/片段的颜色(`glFragColor`)被一系列数学函数和操作所操纵。请记住，这对我们游戏中每一帧的每一个像素都会执行，而且要知道`uTime`每一帧都会传入不同的值。结果，正如我们很快会看到的，将会产生一种波纹效果。'
- en: Coding a vertex shader
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写顶点着色器
- en: 'Here is the code from the `vertShader.vert` file. You don''t need to code this
    as it was in the assets we added back in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    – Making Better Use of OOP*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`vertShader.vert`文件中的代码。你不需要编写这个，因为它在我们在[第12章](ch12.html "第12章。抽象和代码管理-更好地利用OOP")中添加的资产中已经有了，*抽象和代码管理-更好地利用OOP*：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First of all, notice the two `varying` variables. These are the very same variables
    that we manipulated back in the fragment shader. In the `main` function, the code
    manipulates the position of each and every vertex. How the code works is beyond
    the scope of this book, but there is some quite in-depth math going on behind
    the scenes and if it interests you, then exploring GLSL will be fascinating (see
    the previous tip).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意两个`varying`变量。这些正是我们在片段着色器中操作的变量。在`main`函数中，代码操纵了每个顶点的位置。代码的工作原理超出了本书的范围，但在幕后进行了一些相当深入的数学运算，如果你对此感兴趣，那么探索GLSL将会是很有趣的（参见前面的提示）。
- en: Now we have two shaders (one fragment and one vertex). We can use them in our
    game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个着色器（一个片段着色器和一个顶点着色器）。我们可以在我们的游戏中使用它们。
- en: Adding shaders to the Engine class
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将着色器添加到Engine类
- en: 'Open the `Engine.h` file. Add the highlighted line of code, which adds an SFML
    `Shader` instance called `m_RippleShader` to the `Engine` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件。添加突出显示的代码行，将一个名为`m_RippleShader`的SFML `Shader`实例添加到`Engine`类中：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The engine object and all its functions now have access to `m_RippleShadder`.
    Note that an SFML `Shader` object will be comprised of both shader code files.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎对象及其所有函数现在都可以访问`m_RippleShadder`。请注意，一个SFML `Shader`对象将由两个着色器代码文件组成。
- en: Loading the shaders
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载着色器
- en: Add the following code, which checks whether the player's GPU can handle shaders.
    The game will quit if it can't.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，检查玩家的GPU是否能够处理着色器。如果不能，游戏将退出。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You will have to have an exceptionally old PC for this not to work. If you do
    have a GPU that doesn't handle shaders, please accept my apologies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电脑必须非常老旧才不能运行。如果你的GPU无法处理着色器，请接受我的道歉。
- en: 'Next we will add an else clause that actually loads the shaders if the system
    can handle them. Open the `Engine.cpp` file and add the following code to the
    constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个else子句，如果系统能够处理它们，它将实际加载着色器。打开`Engine.cpp`文件，并将以下代码添加到构造函数中：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we are nearly ready to see our ripple effect in action.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎准备好看到我们的波纹效果了。
- en: Updating and drawing the shader in each frame
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每一帧更新和绘制着色器
- en: Open the `Draw.cpp` file. As we discussed when we coded the shaders, we will
    update the uTime variable directly from our C++ code each frame. We do so with
    the `Uniform` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Draw.cpp`文件。正如我们在编写着色器时讨论的那样，我们将在每一帧直接从我们的C++代码中更新`uTime`变量。我们使用`Uniform`函数来实现这一点。
- en: 'Add the highlighted code to update the shader''s `uTime` variable and change
    the call to `draw` for `m_BackgroundSprite` in each of the possible drawing scenarios:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 添加突出显示的代码以更新着色器的`uTime`变量，并在每种可能的绘制场景中为`m_BackgroundSprite`的`draw`调用更改：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It would be best to actually delete the lines of code that I have shown commented
    out. I just did it this way to make it clear which lines of code are being replaced.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最好实际上删除我所展示的注释掉的代码行。我只是这样做是为了清楚地表明哪些代码行正在被替换。
- en: 'Run the game, and you get an eerie kind of molten-rock effect. Experiment with
    changing the background image if you want to have some fun:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你会得到一种怪异的熔岩效果。如果你想玩得开心，可以尝试更改背景图像：
- en: '![Updating and drawing the shader in each frame](img/image_16_003.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![在每一帧更新和绘制着色器](img/image_16_003.jpg)'
- en: That's it! Our third and final game is done.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的第三个也是最后一个游戏完成了。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the grand finale, we explored the concepts of particle systems and shaders.
    Although we looked at probably the simplest possible case for each, we still managed
    to create a simple explosion and an eerie molten-rock effect.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在大结局中，我们探讨了粒子系统和着色器的概念。虽然我们可能只看到了每种情况的最简单的情况，但我们仍然成功地创建了一个简单的爆炸和一种怪异的熔岩效果。
- en: Please take a look at the final, short chapter, which discusses what to do next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请看一下最后的简短章节，讨论接下来要做什么。
