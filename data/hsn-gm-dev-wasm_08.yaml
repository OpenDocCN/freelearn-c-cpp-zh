- en: Basic Particle System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本粒子系统
- en: A *particle syste**m* is a graphics technique where we emit a large number of
    sprites from an *emitter* and have those sprites go through a life cycle where
    they change in a variety of ways. We build some randomness into our sprite life
    cycle to create a wide range of interesting effects such as explosions, sparks,
    snow, dust, fire, engine exhaust, and so on. Some particle effects can interact
    with their environment. In our game, we are going to use particle effects to create
    nice-looking engine exhaust and ship explosion effects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*粒子系统*是一种图形技术，我们从*发射器*中发射大量精灵，并使这些精灵经历一个生命周期，在这个过程中它们以各种方式改变。我们在精灵的生命周期中加入了一些随机性，以创建各种有趣的效果，如爆炸、火花、雪、灰尘、火、发动机排气等。一些粒子效果可以与它们的环境互动。在我们的游戏中，我们将使用粒子效果来创建漂亮的发动机排气和飞船爆炸效果。'
- en: 'For this chapter, you will need to include several images in your build to
    make this project work. Make sure you include the `/Chapter08/sprites/` folder
    from the project''s GitHub. If you haven''t yet downloaded the GitHub project,
    you can get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要在构建中包含几个图像，以使该项目正常工作。确保您从项目的GitHub中包含`/Chapter08/sprites/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: This chapter and the beginning of the next one are going to feel like a digression
    at first. We will be spending a lot of time in the following two chapters working
    on something other than our game. If you are interested in particle systems, I
    promise it will be worth it. When you create a particle system, you spend a lot
    of time tweaking them and playing with them to get them to look right. To do this
    directly within the game will result in a lot of compiling and testing. What we
    need is a tool where we can configure and test a particle system before we add
    it to our game. This chapter and half of the next chapter are dedicated to building
    this tool. If you are not interested in learning how to build the tool, you can
    skim the text in this chapter, and download and compile the tool from GitHub.
    If you are as interested in learning how JavaScript, HTML, and WebAssembly can
    interact in an application, this chapter and the first half of [Chapter 9](b602b8b6-5bec-435f-8b9e-1ad4e4a5f18a.xhtml),
    *Improved Particle Systems*, are a good tutorial for learning how to write an
    application and not just a game with WebAssembly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章和下一章的开始起初会感觉像是一个离题。在接下来的两章中，我们将花费大量时间来处理游戏之外的内容。如果您对粒子系统感兴趣，我保证这将是值得的。当您创建一个粒子系统时，您会花费大量时间来调整它们，并玩耍以使它们看起来正确。在游戏中直接进行这样的操作将导致大量的编译和测试。我们需要的是一个工具，可以在将粒子系统添加到游戏之前配置和测试粒子系统。这一章和下一章的前半部分致力于构建这个工具。如果您对学习如何构建这个工具不感兴趣，您可以略过本章的文本，并从GitHub下载并编译该工具。如果您对学习JavaScript、HTML和WebAssembly如何在应用程序中交互感兴趣，本章和[第9章](b602b8b6-5bec-435f-8b9e-1ad4e4a5f18a.xhtml)
    *改进的粒子系统*的前半部分是一个很好的教程，可以教您如何编写一个应用程序，而不仅仅是一个带有WebAssembly的游戏。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A brief introduction to SVG
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG简介
- en: Trigonometry again?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次三角函数？
- en: Adding the JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加JavaScript
- en: The simple particle emitter tool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的粒子发射器工具
- en: The Point class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Point类
- en: The Particle Class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子类
- en: The Emitter Class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射器类
- en: WebAssembly interface functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly接口函数
- en: Compiling and testing the particle emitter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和测试粒子发射器
- en: Adding to the virtual file system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到虚拟文件系统
- en: This section is going to be a brief digression from *particle systems* because
    I would like to take the time to create a *particle system design tool*, which
    will require that we add files to the WebAssembly virtual file system. We are
    going to add an input element with a type of file that we can use to load an image
    into the virtual file system. We will need to check the file we are loading to
    verify it is a `.png` file, and if it is, we will draw and move the image around
    on the canvas using WebAssembly and SDL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '这一部分将是一个简短的离题，因为我想花时间创建一个*粒子系统设计工具*，这将需要我们向WebAssembly虚拟文件系统添加文件。我们将添加一个类型为文件的输入元素，我们可以使用它将图像加载到虚拟文件系统中。我们需要检查正在加载的文件，以验证它是否是`.png`文件，如果是，我们将使用WebAssembly和SDL在画布上绘制和移动图像。 '
- en: 'Emscripten does not create a virtual file system by default. Because we will
    need to use a virtual file system that will not initially have anything inside
    of it, we will need to pass the following flag to em++ to force Emscripten to
    build a virtual filesystem: `-s FORCE_FILESYSTEM=1`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten默认不会创建虚拟文件系统。因为我们需要使用一个最初没有任何内容的虚拟文件系统，我们需要向em++传递以下标志，以强制Emscripten构建虚拟文件系统：`-s
    FORCE_FILESYSTEM=1`。
- en: 'The first thing we will do is copy `canvas_shell.html` from [Chapter 2](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml),
    *HTML5 and WebAssembly*, and use it to create a new shell file we will call `upload_shell.html`.
    We will need to add some code into the JavaScript that will handle file loads
    and insert that file into the WebAssembly virtual file system. We also need to
    add an HTML `input` element of `file` type that will not display until the `Module`
    object has finished loading. In the following code, we have the new shell file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从[第2章](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml) *HTML5和WebAssembly*中复制`canvas_shell.html`，并使用它创建一个名为`upload_shell.html`的新shell文件。我们需要在处理文件加载的JavaScript中添加一些代码，并将该文件插入到WebAssembly虚拟文件系统中。我们还需要添加一个HTML
    `input`元素，类型为`file`，直到`Module`对象加载完成才会显示。在下面的代码中，我们有新的shell文件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the header, the only changes we are making are to the title, and the style
    sheet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部，我们唯一做的更改是标题和样式表：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `body` tag, we are leaving the `canvas` and `textarea` elements alone,
    but there are significant changes to the JavaScript. The first thing we will do
    to the JavaScript is to add a `ShowFileInput` function to display the `file_input_label`
    element, which starts as hidden by our CSS. You can see it in the following code
    snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`body`标签中，我们不会对`canvas`和`textarea`元素进行更改，但是JavaScript部分有显著的变化。我们将要做的第一件事是向JavaScript添加一个`ShowFileInput`函数，以显示`file_input_label`元素，该元素在我们的CSS中是隐藏的。您可以在以下代码片段中看到它：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that we have added a call to this function in our `postRun` array so
    that it runs after the module is loaded. That is to make sure no one loads an
    image file before the `Module` object has loaded and our page can handle it. Aside
    from the addition of `ShowFileInput` to the `postRun` array, the `Module` object
    is unchanged. After our `Module` object code, we added a `handleFiles` function
    that is called by our file input element when the user picks a new file to load.
    Here is the code for that function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经在`postRun`数组中添加了对此函数的调用，以便在模块加载后运行。这是为了确保在`Module`对象加载之前没有人加载图像文件，而我们的页面可以处理它。除了将`ShowFileInput`添加到`postRun`数组中，`Module`对象保持不变。在`Module`对象代码之后，我们添加了一个`handleFiles`函数，当用户选择要加载的新文件时，文件输入元素将调用该函数。以下是该函数的代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that the function is designed to handle multiple files at once
    by looping over the `files` parameter passed into `handleFiles`. The first thing
    we will do is check to see if the image file type is PNG. When we compile the
    WebAssembly, we need to tell it what image file types SDL will handle. The PNG
    format should be all you need, but it is not difficult to add other types here.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，该函数设计为通过循环遍历传入`handleFiles`的`files`参数来处理多个文件。我们将首先检查图像文件类型是否为PNG。在编译WebAssembly时，我们需要告诉它SDL将处理哪些图像文件类型。PNG格式应该就足够了，但是在这里添加其他类型并不困难。
- en: 'If you do not want to check for PNG files specifically, you can leave out the
    `.png` part of the match string and later add additional file types into the compile
    command-line parameters. If the file is an `image/png` type, we put the filename
    into its variable, `file_name`, and create a `FileReader` object. We then define
    the function that runs when the `FileReader` loads the file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想专门检查PNG文件，可以省略匹配字符串的`.png`部分，然后在编译命令行参数中添加其他文件类型。如果文件是`image/png`类型，我们将文件名放入其变量`file_name`中，并创建一个`FileReader`对象。然后我们定义了`FileReader`加载文件时运行的函数：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function takes in the data as an 8-bit unsigned integer array and then
    passes it into the `Module` function, `FS_createDataFile`. This function takes
    as its parameters a string that is the parent directory `''/''` of our file, the
    filename, `file_name`, the data we read from our file, followed by `canRead`,
    `canWrite`, and `canOwn`, which should all be set to `true` because we would like
    to be able to have our WebAssembly read, write, and own this file. We then use
    `Module.ccall` to call a function defined in our WebAssembly called `add_image`
    that will take the filename so that our WebAssembly can render this image to the
    HTML canvas using SDL. After we define the function that tells the `FileReader`
    what to do when a file is loaded, we have to instruct the `FileReader` to go ahead
    and read in the loaded file as an `ArrayBuffer`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将数据作为8位无符号整数数组输入，然后将其传递到`Module`函数`FS_createDataFile`中。此函数的参数是一个字符串，表示我们文件的父目录'/'，文件名`file_name`，我们从文件中读取的数据，以及`canRead`，`canWrite`和`canOwn`，这些都应设置为`true`，因为我们希望我们的WebAssembly能够读取、写入和拥有此文件。然后，我们使用`Module.ccall`调用在我们的WebAssembly中定义的名为`add_image`的函数，该函数将获取文件名，以便我们的WebAssembly可以使用SDL将此图像呈现到HTML画布上。在定义告诉`FileReader`在加载文件时要执行的函数之后，我们必须指示`FileReader`继续读取已加载的文件作为`ArrayBuffer`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the JavaScript, we added a file `input` element and a label to go along
    with it, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript之后，我们添加了一个文件`input`元素和一个相应的标签，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The label is purely for styling. Styling an input file element is not a straightforward
    thing in CSS. We will go over how to do that in a little bit. Before discussing
    the CSS, I would like to go over the WebAssembly C code that we will use to load
    and render this image using SDL. The following code will go inside of a file we
    have named `upload.c`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标签纯粹是为了样式。在CSS中，样式化输入文件元素并不是一件简单的事情。我们稍后会讨论如何做到这一点。在讨论CSS之前，我想先讨论一下我们将使用的WebAssembly
    C代码，以使用SDL加载和呈现此图像。以下代码将放在我们命名为`upload.c`的文件中：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are three functions we have defined inside of our new `upload.c` file.
    The first function is the `add_image` function. This function takes in a `char*`
    string that represents the file we have just loaded into the WebAssembly virtual
    file system. We use SDL to load the image into a surface, and then we use that
    surface to create a texture we will use to render the image we loaded. The second
    function is `show_animation`, which we use to move the image around the canvas.
    The third is the `main` function, which always gets run when the module is loaded,
    so we use it to initialize our SDL.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新的`upload.c`文件中，我们定义了三个函数。第一个函数是`add_image`函数。此函数接受一个代表我们刚刚加载到WebAssembly虚拟文件系统中的文件的`char*`字符串。我们使用SDL将图像加载到表面中，然后使用该表面创建一个纹理，我们将使用它来呈现我们加载的图像。第二个函数是`show_animation`，我们用它来移动画布上的图像。第三个是`main`函数，它在模块加载时始终运行，因此我们用它来初始化我们的SDL。
- en: 'Let''s take a quick look at the `add_image` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下`add_image`函数：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing we do in the `add_image` function is use the `file_name` parameter
    we passed in to load an image into an `SDL_Surface` object pointer, using the
    `IMG_Load` function that is a part of the `SDL_image` library:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add_image`函数中，我们首先使用传入的`file_name`参数将图像加载到`SDL_Surface`对象指针中，使用`IMG_Load`函数，该函数是`SDL_image`库的一部分：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the load fails, we print an error message and return from the function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载失败，我们会打印错误消息并从函数中返回：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If it does not fail, we use the surface to create a texture that we will be
    able to render in the frame animation. Then, we free the surface because we no
    longer need it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有失败，我们使用表面创建一个纹理，我们将能够在帧动画中渲染它。然后，我们释放表面，因为我们不再需要它：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The final thing we do is use the `SDL_QueryTexture` function to get the image''s
    width and height, and load those values into the `dest` rectangle:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的是使用`SDL_QueryTexture`函数获取图像的宽度和高度，并将这些值加载到`dest`矩形中：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `show_animation` function is similar to other game loops we have written
    in the past. It should run every frame, and as long as a sprite texture is loaded,
    it should clear the canvas, increment the sprite''s `x` and `y` values, and then
    render the sprite to the canvas:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_animation`函数类似于我们过去编写的其他游戏循环。它应该在每一帧中运行，只要加载了精灵纹理，它应该清除画布，增加精灵的`x`和`y`值，然后将精灵渲染到画布上：'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first thing we do in `show_animation` is to check if the `sprite_texture`
    is still `NULL`. If it is, the user has not loaded a PNG file yet so we can not
    render anything:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`show_animation`中我们要做的第一件事是检查`sprite_texture`是否仍然为`NULL`。如果是，用户尚未加载PNG文件，因此我们无法渲染任何内容：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next thing we will do is clear the canvas with the color black:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是用黑色清除画布：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we will increment the sprite''s `x` and `y` coordinates and use those
    values to set the `dest` (destination) rectangle:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将增加精灵的`x`和`y`坐标，并使用这些值来设置`dest`（目标）矩形：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we render the sprite to the back buffer, and then move the back buffer
    to the canvas:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将精灵渲染到后备缓冲区，然后将后备缓冲区移动到画布上：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final function in `upload.c` is the `main` function, which gets called
    when the module is loaded. This function is used for initialization purposes and
    looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload.c`中的最后一个函数是`main`函数，当模块加载时调用。此函数用于初始化目的，如下所示：'
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It calls a few SDL functions to initialize our SDL renderer:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用了一些SDL函数来初始化我们的SDL渲染器：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, it sets up the `show_animation` function to run every time we render
    a frame:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它设置`show_animation`函数在每次渲染帧时运行：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final thing we will do is set up a CSS file to display the HTML in our
    shell file correctly. Here are the contents of the new `upload.css` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的是设置一个CSS文件，以正确显示我们外壳文件中的HTML。以下是新的`upload.css`文件的内容：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first few classes, `body`, `#output`, and `#canvas`, are not much different
    from the version of those classes we had in previous CSS files, so we do not need
    to go into any detail on those. After those classes is a CSS class that looks
    a little different:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个类，`body`、`#output`和`#canvas`，与以前的CSS文件中的那些类并没有太大不同，所以我们不需要详细介绍。在这些类之后是一个看起来有点不同的CSS类：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That defines the look of an `input` element that has a type of `file`. For
    some reason, using CSS to style a file input element is not very straightforward.
    Instead of styling the element directly, we will hide the element with the `display:
    none;` attribute and then create a styled label, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '这定义了具有`file`类型的`input`元素的外观。由于使用CSS直接为文件输入元素设置样式并不是非常直接。我们将使用`display: none;`属性隐藏元素，然后创建一个样式化的标签，如下所示：'
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That is why, in the HTML, we have a label element immediately after our input
    file element. You may notice that our label also has set the `display` to `none`.
    That is so that the user can not use the element to upload a PNG file until after
    the `Module` object is loaded. If you look back to the JavaScript inside of our
    HTML shell file, we called the following code on `postRun` so that the label becomes
    visible after our `Module` is loaded:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在HTML中，我们在输入文件元素之后立即添加了一个标签元素。您可能会注意到，我们的标签也将`display`设置为`none`。这样用户就无法在`Module`对象加载之前使用该元素上传PNG文件。如果您回顾一下我们HTML外壳文件中的JavaScript，我们在`postRun`上调用了以下代码，以便在`Module`加载后使标签可见：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we should have an app that can load an image into the WebAssembly virtual
    file system. In the next several sections, we will expand this app to configure
    and test a simple particle emitter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该有一个可以将图像加载到WebAssembly虚拟文件系统中的应用程序。在接下来的几节中，我们将扩展此应用程序以配置和测试一个简单的粒子发射器。
- en: A brief introduction to SVG
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对SVG的简要介绍
- en: SVG stands for *Scalable Vector Graphics* and is an alternative to the immediate-mode
    raster graphics rendering that takes place in the HTML canvas. SVG is an XML-based
    graphics rendering language and should look at least somewhat familiar to anyone
    familiar with HTML. An SVG tag can be placed right inside of the HTML and accessed
    like any other DOM node. Because we are writing a tool for configuring particle
    emitter data, we will be adding SVG into our app for data visualization purposes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SVG代表*可缩放矢量图形*，是HTML画布中进行即时模式栅格图形渲染的一种替代方案。SVG是一种基于XML的图形渲染语言，对于熟悉HTML的人来说应该至少有些熟悉。SVG标记可以直接放在HTML中，并像任何其他DOM节点一样访问。因为我们正在编写一个用于配置粒子发射器数据的工具，我们将在我们的应用程序中添加SVG以进行数据可视化。
- en: Vector versus raster graphics
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矢量与栅格图形
- en: 'As a game developer, you may not be familiar with *vector graphics*. When we
    render computer graphics, no matter what format we use, they will need to be *rasterized*
    into a grid of pixels before the game displays them on a computer screen. Working
    with raster graphics is working with our images on the pixel level. Vector graphics,
    on the other hand, involves dealing with graphics at a different level of abstraction
    where we are working with lines, points, and curves. In the end, a vector-based
    graphics engine still must figure out how the lines, points, and curves it is
    dealing with are converted to pixels, but working with vector graphics is not
    without its benefits. They are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，您可能不熟悉*矢量图形*。当我们渲染计算机图形时，无论我们使用什么格式，它们都需要在游戏在计算机屏幕上显示之前被*栅格化*为像素网格。使用栅格图形意味着在像素级别处理我们的图像。另一方面，矢量图形涉及以不同的抽象级别处理图形，我们处理线条、点和曲线。最终，基于矢量的图形引擎仍然必须弄清楚它正在处理的线条、点和曲线如何转换为像素，但处理矢量图形并非没有好处。它们如下：
- en: Vector graphics can be cleanly scaled
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矢量图形可以被清晰地缩放
- en: Vector graphics allow for smaller downloads
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矢量图形允许更小的下载
- en: Vector graphics can easily be modified at runtime
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矢量图形可以在运行时轻松修改
- en: One of the sweet spots for using vector graphics on the web is for *data visualization*.
    This book is not about SVG or data visualization, and SVG is not currently fast
    enough to be used for game rendering for most applications. It is, however, a
    useful tool when you want to render graphical aids to go along with data on a
    website. We will be adding a little SVG into our particle emitter configuration
    tool as a visual aid to help the user see the direction the emitter is configured
    to emit particles. Because we are using this as a visual aid, it is not strictly
    necessary to have it inside of our app.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上使用矢量图形的一个甜蜜点是*数据可视化*。这本书不是关于SVG或数据可视化的，而且SVG目前还不够快，不能用于大多数应用程序的游戏渲染。然而，当你想要在网站上呈现数据时，它是一个有用的工具。我们将在我们的粒子发射器配置工具中添加一些SVG作为视觉辅助，帮助用户看到发射器配置为发射粒子的方向。因为我们将使用它作为视觉辅助，所以没有必要将其放在我们的应用程序中。
- en: 'The first thing we will do is add a few tags to our HTML. We need an SVG tag
    to set up an area we can use to draw our vector circle graphic. We also need a
    couple of input values that allow us to enter two angles with values in degrees.
    These two input fields will take the minimum and maximum angles to emit a particle.
    When we have this working, it will give some direction to our particle emission.
    Here is the HTML code we need to add to our `body` tag:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是在我们的HTML中添加一些标签。我们需要一个SVG标签来设置一个可以用来绘制矢量圆形图形的区域。我们还需要一些输入值，允许我们输入两个角度，角度的值以度为单位。这两个输入字段将取最小和最大角度来发射粒子。当这个工作起来时，它将给我们的粒子发射一些方向。这是我们需要添加到`body`标签的HTML代码：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have set the `id` to pie in the `svg` tag. That will allow us to modify the
    values inside of this tag with lines and arcs later. We have given it a height
    and width of `200` pixels.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`svg`标签中将`id`设置为pie。这将允许我们稍后用线和弧修改这个标签内的值。我们给它设置了高度和宽度为`200`像素。
- en: The `viewbox` is set to `-1 -1 2 2`. This says that the top-left coordinate
    of our SVG drawing area is set to coordinate `-1, -1`. The second two numbers,
    `2 2`, are the width and height in the drawing space of the SVG drawing area.
    That means that our drawing space will go from coordinates `-1, -1` in the top-left
    corner to `1, 1` in the bottom right. That will make it easy to deal with sine
    and cosine values when we need to calculate our angles.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewbox`设置为`-1 -1 2 2`。这表示我们的SVG绘图区域的左上坐标设置为坐标`-1，-1`。接下来的两个数字`2 2`是SVG绘图区域中的宽度和高度。这意味着我们的绘图空间将从左上角的坐标`-1，-1`到右下角的坐标`1，1`。这将使我们在需要计算角度时更容易处理正弦和余弦值。'
- en: Trigonometry again?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角学又来了？
- en: 'OMG yes, there is more *trigonometry*. I have already covered basic trigonometry
    in, [Chapter 7](71d18599-d302-4d52-9e7c-343a94835b27.xhtml), *Collision Detection*,
    but believe it or not, trigonometry is really useful in game development. Trigonometry
    happens to be very useful for particle systems and we will be using SVG and some
    trig to build a little pie chart we can use to visualize the direction of our
    particle emitter. So, let''s take a second to quickly review things one more time:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊，是的，还有更多的*三角学*。我已经在[第7章](71d18599-d302-4d52-9e7c-343a94835b27.xhtml)中介绍了基本的三角学，*碰撞检测*，但信不信由你，三角学在游戏开发中真的很有用。三角学碰巧对粒子系统非常有用，我们将使用SVG和一些三角函数来构建一个小的饼图，以便可视化我们的粒子发射器的方向。所以，让我们花点时间快速复习一下：
- en: '*Sine = Opposite/Hypotenuse (SOH)*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正弦=对边/斜边（SOH）*'
- en: '*Cosine = Adjacent/Hypotenuse (CAH)*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*余弦=邻边/斜边（CAH）*'
- en: '*Tangent = Opposite/Adjacent (TOA)*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正切=对边/邻边（TOA）*'
- en: Remember the word SOHCAHTOA?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得SOHCAHTOA这个词吗？
- en: 'If we are using a 2D Cartesian coordinate system (spoiler alert, we are) the
    *opposite* edge in our scenario is just the *Y* coordinate, and the *adjacent*
    edge is the *X* coordinate. So, in terms of a 2D Cartesian coordinate system,
    our ratios look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是2D笛卡尔坐标系（剧透警告，我们是），在我们的情况中*对边*就是*Y*坐标，*邻边*就是*X*坐标。因此，在2D笛卡尔坐标系中，我们的比率如下：
- en: '*Sine = Y/Circle Radius*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正弦=Y/圆半径*'
- en: '*Cosine = X/Circle Radius*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*余弦=X/圆半径*'
- en: '*Tangent = Y/X*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正切=Y/X*'
- en: 'If you are calling a function in the JavaScript math library such as `cos`
    (for cosine) or `sin` (for sine), you usually pass in an angle measured in radians.
    You would get back the ratio, which if you are dealing with a *unit circle* (circle
    with a radius of 1), gives you the *X* value for cosine and the *Y* value for
    sine. So most of the time, all you need to remember is this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在JavaScript数学库中调用`cos`（余弦）或`sin`（正弦）等函数，通常传入的是以弧度为单位的角度。你将得到一个比值，如果你处理的是*单位圆*（半径为1的圆），那么这个比值就是余弦的*X*值和正弦的*Y*值。所以大多数时候，你只需要记住这个：
- en: If you want the *Y* coordinate, use sine
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要*Y*坐标，使用正弦
- en: If you want the *X* coordinate, use cosine
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要*X*坐标，使用余弦
- en: We used this earlier to figure out the direction and velocity of our ship. We
    will use it later to get the direction and velocity of our particles given an
    angle. And, we are going to use it right now to figure out how to draw the SVG
    chart that shows us at what angle we will emit our particles.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用它来计算飞船的方向和速度。我们将在以后使用它来获得给定角度的粒子的方向和速度。而且，我们现在将使用它来找出如何绘制SVG图表，显示我们将发射粒子的角度。
- en: We are taking in two different angles to get a range of angles to emit particles.
    Because we want our angles to overlap the angle 0 degrees, we have to allow the
    `min_angle` to go negative. Our minimum angle can go from -90 degrees to 359 degrees,
    and the max angle can go from 0 degrees to 360 degrees.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用两个不同的角度来获得一系列角度来发射粒子。因为我们希望我们的角度与0度的角度重叠，我们必须允许`min_angle`为负数。我们的最小角度可以从-90度到359度，最大角度可以从0度到360度。
- en: I prefer to measure angles in degrees instead of radians. Math functions typically
    use radians, so if you are more comfortable in using radians in your interface,
    you can save yourself the trouble of running the conversion. Radians is a measurement
    of angle based on a *unit circle*. A *unit circle* has a circumference of *2π*.
    If you measure an angle in radians, you are determining your angle based on how
    far around the *unit circle* you would have to walk to get to that point. So,
    if you walked from one side of your *unit circle* to the opposite side, you would
    have to walk a distance of π. Therefore *π* (in radians) = 180 degrees. If you
    wanted an angle one-quarter of the circle, you would have to walk a distance of
    *π / 2* around your circle, so *π / 2 = 90 degrees*. I still find a 360-degree
    circle more intuitive because we spent a lot more time learning about degrees
    when I was in school. Radians were mentioned as an afterthought. If this had not
    been the case, I am sure I would find measuring my angle in terms of a *unit circle*
    to make a lot more sense.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢用度量角度而不是弧度。数学函数通常使用弧度，所以如果您更喜欢在界面中使用弧度，您可以省去转换的麻烦。弧度是基于*单位圆*的角度测量。*单位圆*的周长为*2π*。如果您用弧度测量角度，您是根据绕*单位圆*走多远来确定您的角度的。因此，如果您从*单位圆*的一侧走到另一侧，您需要走π的距离。因此*π*（以弧度表示）=
    180度。如果您想要一个圆的四分之一角度，您需要绕您的圆走*π / 2*的距离，所以*π / 2 = 90度*。我仍然觉得360度的圆更直观，因为在学校时我们花了更多的时间学习度数。弧度只是提及而已。如果情况不是这样，我肯定会觉得用*单位圆*来测量我的角度更有意义。
- en: The idea of a 360-degree circle is only intuitive because they drilled it into
    us when we were in school. The only reason we have this model of a circle is that
    we inherited it from the ancient Babylonians who used a base 60 mathematical system,
    which is also the reason we have 60 seconds in a minute and 60 minutes in an hour.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 360度圆的概念只是直观的，因为当我们在学校时他们把它灌输给我们。我们之所以有这个圆的模型，只是因为我们从古巴比伦人那里继承了一个60进制的数学系统，这也是我们一分钟有60秒，一小时有60分钟的原因。
- en: 'Later, we will be using SVG and some trig to draw a little pie chart that represents
    the direction particles will be emitted from our particle system. We need this
    directionality to create our engine exhaust particle emitter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将使用SVG和一些三角函数来绘制一个小的饼图，代表粒子将从我们的粒子系统中发射的方向。我们需要这种方向性来创建我们的引擎排气粒子发射器：
- en: '![](img/47c00130-a4f0-451c-847c-bf530e50b17b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47c00130-a4f0-451c-847c-bf530e50b17b.png)'
- en: 'Figure 8.1: Our SVG pie chart'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：我们的SVG饼图
- en: In the next section, we will be implementing our SVG pie chart using JavaScript.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用JavaScript实现我们的SVG饼图。
- en: Adding the JavaScript
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加JavaScript
- en: 'Now that we have discussed a little of the trigonometry necessary to draw our
    SVG chart, let me step through the JavaScript we need to add to make our code
    work:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些绘制SVG图表所需的三角学知识，让我逐步介绍我们需要添加的JavaScript代码，使我们的代码能够运行：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Even though it is the last function in this code, I would like to begin by explaining
    the `SetPie` function, which is used to set the SVG pie chart that shows the emission
    angle range in red that the user has entered. Way back when we set up the SVG
    tag, we set the `viewport` to go from `x` and `y` values of `-1` to `1`. That
    is great, because using `Math.cos` and `Math.sin` will give us the values of the
    *X* and *Y* coordinates for the *unit circle*, which has a radius of `1` and so
    those values will also run from `-1` to `1`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是代码中的最后一个函数，但我想首先解释`SetPie`函数，该函数用于设置显示用户输入的红色发射角范围的SVG饼图。很久以前，当我们设置SVG标签时，我们将`viewport`设置为从`x`和`y`值为`-1`到`1`。这很好，因为使用`Math.cos`和`Math.sin`将给我们*单位圆*的*X*和*Y*坐标的值，*单位圆*的半径为`1`，所以这些值也将从`-1`到`1`运行。
- en: 'We use `document.getElementById(''pie'')` to grab the `svg` element from the
    DOM so we can modify it based on a change to the angle values. Next, we get the
    `x` and `y` coordinates on a unit circle with the `Math.cos` and `Math.sin` functions,
    respectively. We then do the same thing to get the ending `x` and `y` coordinates
    using the `end_angle`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`document.getElementById('pie')`从DOM中获取`svg`元素，以便根据角度值的变化对其进行修改。接下来，我们使用`Math.cos`和`Math.sin`函数分别获取*单位圆*上的`x`和`y`坐标。然后，我们使用`end_angle`来获取结束的`x`和`y`坐标：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What we need to do in SVG is draw two paths. The first path will be drawn in
    red and will represent the angle where the particle system emitter will emit particles.
    The second path will be drawn in blue and will represent the part of our emission
    circle where we will not emit particles. When we draw an SVG arc, we give the
    arc two points and tell it with a flag if we need to take the long way (obtuse
    angle) or the short way (acute angle) around the circle. We do this by checking
    to see if the emission angle is less than π and set a flag that will go into our
    SVG based on this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在SVG中，我们需要绘制两条路径。第一条路径将以红色绘制，表示粒子系统发射器发射粒子的角度。第二条路径将以蓝色绘制，表示我们不会发射粒子的发射圆的部分。当我们绘制SVG弧线时，我们给弧线两个点，并告诉它一个标志，如果我们需要绕圆走远的方式（钝角）或者走近的方式（锐角）。我们通过检查发射角是否小于π，并设置一个标志，将根据这个标志进入我们的SVG中：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we need to define the path data and put it into the SVG path object. The
    following code sets the path data for the portion of our emitter in which we emit
    our particles:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义路径数据并将其放入SVG路径对象中。以下代码设置了我们发射粒子的发射器部分的路径数据：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A series of commands define path data in SVG. If you look at the definition
    of `path_data_1`, it begins with `M 0 0`, which tells SVG to move the cursor to
    position `0, 0` without drawing. The next command is `L ${start_x} ${start_y}`.
    Because we are using a string template literal, `${start_x}` and `${start_y}`
    are replaced with the values in the `start_x` and `start_y` variables. This command
    draws a line from the current location we have moved to in the previous step `(0,0)`
    to the coordinates `start_x` and `start_y`. The next command in our path is the
    `Arc` command and begins with `A`: `A 1 1 0 ${arc_flag_1} 1 ${end_x} ${end_y}`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列命令在SVG中定义路径数据。如果您查看`path_data_1`的定义，它以`M 0 0`开头，告诉SVG将光标移动到位置`0, 0`而不绘制。下一个命令是`L
    ${start_x} ${start_y}`。因为我们使用了字符串模板文字，`${start_x}`和`${start_y}`会被`start_x`和`start_y`变量中的值替换。这个命令从我们在上一步移动到的当前位置`(0,0)`画一条线到坐标`start_x`和`start_y`。我们路径中的下一个命令是`Arc`命令，以`A`开头：`A
    1 1 0 ${arc_flag_1} 1 ${end_x} ${end_y}`。
- en: The first two parameters, `1 1`, are the `x` and `y` radius of an ellipse. Because
    we want a unit circle, both of these values are `1`. The `0` that follows is an
    *X*-axis rotation that SVG uses when drawing an ellipse. Because we are drawing
    a circle, we set this to `0`. The value after that is `${arc_flag_1}`. That is
    used to set the *large arc flag*, which tells SVG if we are drawing the obtuse
    arc (we set the value to 1) or the acute arc (we set the value to 0). The value
    after this is the *sweep flag*. This flag determines if we are drawing in the
    clockwise (value is 1) or counter-clockwise (value is 0) direction. We always
    want to draw in the clockwise direction, so this value is going to be 1\. The
    last two parameters in our *arc* command are `${end_x} ${end_y}`. These values
    are the end position of our arc, which we had determined earlier by getting the
    cosine and sine of our ending angle. After we have completed our arc, we finish
    our shape by drawing a line back to the `0,0` coordinate using the `L 0 0` line
    command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数`1 1`是椭圆的`x`和`y`半径。因为我们想要一个单位圆，这两个值都是`1`。之后的`0`是SVG在绘制椭圆时使用的*X*轴旋转。因为我们正在绘制一个圆，所以将其设置为`0`。之后的值是`${arc_flag_1}`。这用于设置*大弧标志*，告诉SVG我们是在绘制钝角弧（我们将值设置为1）还是锐角弧（我们将值设置为0）。之后的值是*扫描标志*。此标志确定我们是以顺时针（值为1）还是逆时针（值为0）方向绘制。我们总是希望以顺时针方向绘制，因此这个值将是1。我们*arc*命令中的最后两个参数是`${end_x}
    ${end_y}`。这些值是我们弧的结束位置，我们之前通过获取结束角的余弦和正弦来确定这些值。完成弧后，我们通过使用`L 0 0`线命令画一条线回到`0,0`坐标来完成我们的形状。
- en: After we have drawn the emission angle in red, we cover the remainder of the
    circle in blue with a second path by drawing from the ending position to the starting
    position.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用红色绘制了发射角之后，我们通过从结束位置到起始位置绘制第二条路径，用蓝色覆盖了圆的其余部分。
- en: In the next section, we are going to build a simple particle emitter configuration
    tool.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将构建一个简单的粒子发射器配置工具。
- en: The simple particle emitter tool
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的粒子发射器工具
- en: 'Now that we have created a simple web app that can upload a PNG image file
    to the WebAssembly *virtual file system*, and an SVG chart to display the emission
    direction of the particles, we are going to add a simple particle system configuration
    tool. For this first version of our particle system configuration tool, we are
    going to keep the number of configurable values small. Later, we will add more
    features to our particle system tool, but for the moment this is the list of parameters
    we will be able to use to configure a particle emitter:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个简单的Web应用程序，可以将PNG图像文件上传到WebAssembly *虚拟文件系统*，并且使用SVG图表显示粒子的发射方向，我们将添加一个简单的粒子系统配置工具。对于我们粒子系统配置工具的第一个版本，我们将保持可配置值的数量较少。稍后，我们将为我们的粒子系统工具添加更多功能，但目前这是我们将用来配置粒子发射器的参数列表：
- en: Image file
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像文件
- en: Minimum emission angle
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小发射角度
- en: Maximum emission angle
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大发射角度
- en: Maximum particles
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大粒子
- en: Particle lifetime in milliseconds
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子寿命（毫秒）
- en: Particle acceleration (or deceleration)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子加速（或减速）
- en: Alpha fade (will the particles fade out over time?)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha淡出（粒子是否会随时间淡出？）
- en: Emission rate (number of particles to emit per second)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射速率（每秒发射的粒子数）
- en: X position (emitter x coordinate)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X位置（发射器x坐标）
- en: Y position (emitter y coordinate)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y位置（发射器y坐标）
- en: Radius (how far from the emitter's position can we create a particle?)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半径（离发射器位置有多远可以创建一个粒子？）
- en: Minimum starting velocity
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小起始速度
- en: Maximum starting velocity
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大起始速度
- en: That will let us create a very basic particle emitter. We will improve this
    emitter in the next section, but we need to start somewhere. I do not plan on
    discussing any of the CSS we have added to enhance the look of this tool. The
    first thing I want to do is cover the HTML that will go into the new shell file,
    which we are calling `basic_particle_shell.html`. We need to add some HTML `input`
    fields to take in all of the configurable values we discussed previously. We will
    also need a button to update the emitter once we have written in our changes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们创建一个非常基本的粒子发射器。我们将在下一节改进这个发射器，但我们需要从某个地方开始。我不打算讨论我们添加的任何CSS来增强这个工具的外观。我想要做的第一件事是覆盖将放入新外壳文件中的HTML，我们称之为`basic_particle_shell.html`。我们需要添加一些HTML
    `input`字段来接收我们之前讨论的所有可配置值。我们还需要一个按钮，在我们写入更改后更新发射器。
- en: 'Add the following code into the `<body>` tag in our new shell file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们新外壳文件的`<body>`标签中：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The CSS file styles this container to appear on the left side of the web page.
    The user can load an image into the virtual file system as they could previously,
    but this time all of the values in these input fields are used to create a particle
    emitter. The user can modify these settings and click the Update Emitter button
    to update the values used by the emitter. That will allow the user to test some
    basic emitter settings.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: CSS文件将此容器样式设置为出现在网页的左侧。用户可以像以前一样将图像加载到虚拟文件系统中，但是这次所有这些输入字段中的值都用于创建一个粒子发射器。用户可以修改这些设置并单击“更新发射器”按钮以更新发射器使用的值。这将允许用户测试一些基本的发射器设置。
- en: The code inside of the main function will need to be added to prevent the SDL
    Event handler from intercepting the keyboard events and preventing the default
    behavior inside of these input elements. We will cover that code a little later.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数中的代码需要添加以防止SDL事件处理程序拦截键盘事件并阻止这些输入元素内部的默认行为。我们稍后会介绍这段代码。
- en: 'Now that I have shown you the HTML elements that must be added to allow us
    to configure a particle system, let''s step through the JavaScript code that will
    enable us to pass these values into the WebAssembly module. Here is what that
    JavaScript code looks like:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经向您展示了必须添加的HTML元素，以便我们能够配置一个粒子系统，让我们逐步了解一下能够将这些值传递到WebAssembly模块的JavaScript代码。以下是JavaScript代码的样子：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Most of the `Module` code is unmodified, but we have added several functions
    and some new variables. We have added a global `ready` variable that is set to
    `false` when initialized. This flag will be set to `true` when the `Module` is
    loaded. As it was in the previous section, `ShowFileInput` runs after the `Module`
    is loaded using the `postRun` array. We have tweaked this code to set the `ready`
    flag that we mentioned earlier:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分`Module`代码未经修改，但我们添加了几个函数和一些新变量。我们添加了一个全局的`ready`变量，当初始化时设置为`false`。当`Module`加载时，此标志将设置为`true`。与前一节一样，`ShowFileInput`在使用`postRun`数组之后运行。我们已调整此代码以设置我们之前提到的`ready`标志：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In an earlier section, we created a `handleFiles` function that loaded a file
    into our WebAssembly virtual file system. We now need to modify that function
    to call a function, `add_emitter`, that we will need to define inside of our C++
    code. We will call this function, passing in all of the values we have defined
    in the HTML input elements. Here is what that function looks like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早的部分，我们创建了一个`handleFiles`函数，将文件加载到我们的WebAssembly虚拟文件系统中。现在我们需要修改该函数，以调用一个名为`add_emitter`的函数，我们需要在我们的C++代码中定义该函数。我们将调用此函数，传入我们在HTML输入元素中定义的所有值。以下是该函数的样子：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `FileReader` code, and the call to `Module.FS_createDataFile` from the
    previous iteration of this function, is still here. In addition to that, we use
    `document.getElementById` to grab the HTML elements and store the value of those
    elements into a set of variables:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader`代码和从此函数的先前迭代中调用`Module.FS_createDataFile`仍然存在。除此之外，我们使用`document.getElementById`来获取HTML元素，并将这些元素的值存储到一组变量中：'
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Many of these values need to be explicitly coerced into numbers using the `Number`
    coercion function. The `alpha_fade` variable must be coerced into a `Boolean`
    value. Now that we have all of these values inside of variables, we can use `Module.ccall`
    to call the C++ function, `add_emitter`, passing in all of these values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些值需要使用`Number`强制转换函数明确转换为数字。`alpha_fade`变量必须被强制转换为`Boolean`值。现在我们已经将所有这些值放入变量中，我们可以使用`Module.ccall`调用C++函数`add_emitter`，传入所有这些值：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At the very end of this, we set the `image_added` flag to `true`. We will not
    allow the user to update an emitter unless a call to `add_emitter` has created
    it. We have also added a new function, `UpdateClick`, that we will call whenever
    someone clicks the Update Emitter button, assuming that they have already created
    an emitter. Here is what the code in that function looks like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后，我们将`image_added`标志设置为`true`。除非调用`add_emitter`已创建发射器，否则我们将不允许用户更新发射器。我们还添加了一个新函数`UpdateClick`，每当有人点击“更新发射器”按钮时，我们将调用该函数，假设他们已经创建了一个发射器。以下是该函数中的代码样子：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first thing we do is make sure that the `Module` object is loaded, and
    that we created the emitter. If either of these has not happened, we do not want
    to run this code, so we must return:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是确保`Module`对象已加载，并且我们已创建了发射器。如果这两者中的任何一个尚未发生，我们不希望运行此代码，因此我们必须返回：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The remainder of this code is similar to the code we added to `handleFiles`.
    First, we grab all of the HTML elements and coerce the values in them into the
    appropriate data types to pass into our call to the C++ function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的其余部分与我们添加到`handleFiles`的代码类似。首先，我们获取所有HTML元素，并将它们中的值强制转换为适当的数据类型，以传递给我们对C++函数的调用：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After getting all of the values from the input elements, we use those values
    to call the `update_emitter` C++ function, passing in those values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入元素中获取所有值后，我们使用这些值调用`update_emitter` C++函数，传入这些值：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next section, we will be implementing a `Point` class to track game object
    positions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个`Point`类来跟踪游戏对象的位置。
- en: The Point class
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Point类
- en: 'In previous chapters, we have dealt with the 2D *X* and *Y* coordinates directly
    in our classes. I want to add a little bit of functionality that deals with our
    *X* and *Y* coordinates. For this, we are going to need to define a new class
    called `Point`. Eventually, `Point` will do more than what we are using it for
    here. But for right now, I would like to be able to create a `Point` object and
    be able to `Rotate` that point by an angle. Here is the class definition for `Point`
    that we have added to the `game.hpp` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，我们直接处理了类中的2D *X*和*Y*坐标。我想添加一些处理我们的*X*和*Y*坐标的功能。为此，我们需要定义一个名为`Point`的新类。最终，`Point`将做的不仅仅是我们在这里使用它。但是现在，我想能够创建一个`Point`对象并能够通过角度`Rotate`该点。以下是我们添加到`game.hpp`文件中的`Point`类定义：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first several functions and the `operator=` are pretty straightforward.
    They set the x and y attributes either through a constructor or by using a line
    of code such as `point_1 = point_2;`. The last function, `Rotate`, is the entire
    reason we created this class. Its job is to take the *X* and *Y* coordinates and
    rotate them around the point `0,0`. Here is the code that gets that done:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个函数和`operator=`都很简单。它们通过构造函数或使用诸如`point_1 = point_2;`这样的代码行来设置x和y属性。最后一个函数`Rotate`是我们创建这个类的整个原因。它的工作是将*X*和*Y*坐标围绕点`0,0`旋转。以下是完成这项工作的代码：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This `Rotate` function will eventually be used all over the game. For right
    now, we will use it to define the velocities of our particles based on the emission
    angles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Rotate`函数最终将在整个游戏中使用。目前，我们将使用它来根据发射角度定义粒子的速度。
- en: The Particle class
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子类
- en: 'The `Particle` class is the class we will use to represent the individual particles
    that are emitted by our particle system. The `Particles` class will need to be
    created with a constructor and later updated with an `Update` function used to
    modify the defining attributes of the particle. There will be a `Spawn` function
    used to activate the `Particle`, a `Move` function to move the particle through
    its life cycle eventually deactivating it, and a `Render` function that will perform
    the SDL rendering tasks required to draw the particle to the canvas. Here is what
    the `Particle` class looks like in our `game.hpp` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle`类是我们将用来表示粒子系统发射的单个粒子的类。`Particles`类将需要通过构造函数进行创建，并且稍后通过`Update`函数进行更新，用于修改粒子的定义属性。将会有一个`Spawn`函数用于激活`Particle`，一个`Move`函数用于移动粒子通过其生命周期最终使其停用，以及一个`Render`函数，用于执行绘制粒子到画布所需的SDL渲染任务。以下是我们在`game.hpp`文件中`Particle`类的样子：'
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will define the functions associated with the `Particle` class inside of
    the `particle.cpp` file. At the top of this file, we have defined a constructor
    and an `Update` function. We call the `Update` function whenever the user clicks
    the Update Emitter button on the web page. That will update all of the particles
    to use the new values for their lifetime, acceleration, and alpha fade. Here is
    what the code to these first two functions looks like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`particle.cpp`文件中定义与`Particle`类相关的函数。在该文件的顶部，我们已经定义了一个构造函数和一个`Update`函数。当用户在网页上点击更新发射器按钮时，我们将调用`Update`函数。这将更新所有粒子以使用它们的寿命、加速度和透明度衰减的新值。以下是这两个函数的代码样子：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Spawn` function is called by the `Emitter` whenever it needs to emit a
    particle. The `Emitter` checks that the particle it is emitting has an active
    flag set to `false`. The values passed into `Spawn`, such as the *X* and *Y* coordinates,
    the velocity `x` and `y` values, and the starting alpha value, are all calculated
    by the `Emitter` when it emits a new particle. Here is what the code looks like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawn`函数在`Emitter`需要发射粒子时被调用。`Emitter`检查其正在发射的粒子是否具有设置为`false`的活动标志。传递给`Spawn`的值，如*X*和*Y*坐标、速度`x`和`y`值以及起始透明度值，都是由`Emitter`在发射新粒子时计算的。以下是代码的样子：'
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Move` function of every active particle is called once per frame by the
    emitter, and is where the particle calculates its new position, alpha, and determines
    if it is still active based on how long it has been alive. Here is what the code
    looks like:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动粒子的`Move`函数由发射器每帧调用一次，粒子在其中计算其新位置、透明度，并根据其存在时间确定其是否仍处于活动状态。以下是代码的样子：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, the `Render` function makes calls to the SDL functions that set the
    alpha value for the particle and then copies that particle to the renderer:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Render`函数调用SDL函数设置粒子的透明度值，然后将该粒子复制到渲染器：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the next section, we will discuss the `Emitter` class and the code we will
    need to make that class work.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论`Emitter`类以及我们需要使该类工作的代码。
- en: The Emitter class
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射器类
- en: 'The `Emitter` class manages a pool of particles and is where the loaded sprite
    texture that the particles use to render themselves resides. Our emitters will
    only be circular. It is possible to define emitters with many different possible
    shapes, but for our game, a circle-shaped emitter will work fine. Right now, our
    `Emitter` class is going to be pretty basic. In later sections, we will add some
    new features, but right now I want to create a very basic particle system. Here
    is what the class definition looks like in the `game.hpp` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`类管理一个粒子池，并且粒子用于渲染自身的加载的精灵纹理位于其中。我们的发射器只会是圆形的。可以定义具有许多不同形状的发射器，但对于我们的游戏，圆形的发射器就可以了。目前，我们的`Emitter`类将会非常基础。在后面的部分，我们将添加一些新功能，但现在我想创建一个非常基本的粒子系统。以下是在`game.hpp`文件中类定义的样子：'
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The attributes inside this class mirror the HTML input elements we created earlier
    in this chapter. These values get set either when the `Emitter` is created using
    the constructor, or when the user clicks the update button, which calls the `Update`
    function. The `Move` function will be called once per frame, and will move then
    render all of the particles that are active inside the particle pool. It will
    also determine if a new particle should be emitted by calling the `Spawn` function
    on a free particle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该类内部的属性与本章前面创建的HTML输入元素相对应。这些值在`Emitter`使用构造函数创建时设置，或者当用户点击更新按钮时设置，该按钮调用`Update`函数。`Move`函数将每帧调用一次，并且将移动并渲染粒子池中所有活动的粒子。它还将通过调用`Spawn`函数确定是否应该发射新粒子。
- en: 'We will define all of these functions within the `emitter.cpp` file. Here is
    what the `Emitter` constructor and `Update` functions look like inside of the
    `emitter.cpp` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`emitter.cpp`文件中定义所有这些函数。以下是`emitter.cpp`文件中`Emitter`构造函数和`Update`函数的样子：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Both of these functions set the attributes of the `Emitter` class and set up
    the particle pool based on the `max_particles` value passed into these functions.
    The `GetFreeParticle` function is called by the `Move` function to get a particle
    from the particle pool that is not currently active. The `Move` function first
    figures out if it needs to emit a new particle, and if it does, calls the `GetFreeParticle`
    function to grab an inactive particle, and then uses the attributes of the `Emitter`
    to set the values to use when spawning a particle. It will loop over all of the
    particles in the pool, and if the particle is active, it will `Move` and then
    `Render` that particle:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都设置了`Emitter`类的属性，并根据传入这些函数的`max_particles`值设置了粒子池。`GetFreeParticle`函数被`Move`函数调用，以从当前未激活的粒子池中获取一个粒子。`Move`函数首先确定是否需要发射新的粒子，如果需要，就调用`GetFreeParticle`函数来获取一个未激活的粒子，然后使用`Emitter`的属性来设置生成粒子时要使用的值。它将循环遍历池中的所有粒子，如果粒子是活动的，它将`Move`然后`Render`该粒子：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will compile these classes into our WebAssembly module, but they will not
    be used to interact directly with the JavaScript we defined earlier. For that,
    we are going to need to define some functions in a new file that we will discuss
    in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些类编译成我们的WebAssembly模块，但它们不会直接与我们之前定义的JavaScript进行交互。为此，我们需要在一个新文件中定义一些函数，我们将在下一节中讨论。
- en: WebAssembly interface functions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly接口函数
- en: 'We need to define the functions that will interact with our JavaScript. We
    also need to define some global variables that will be used by several of our
    classes. Here is the code from the new `basic_particle.cpp` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义将与我们的JavaScript进行交互的函数。我们还需要定义一些将被我们的几个类使用的全局变量。以下是新的`basic_particle.cpp`文件中的代码：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first two global variables are `SDL_Window` and `SDL_Renderer`. We need
    these as global objects (particularly the renderer) so that they can be used to
    render our textures to the canvas:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个全局变量是`SDL_Window`和`SDL_Renderer`。我们需要这些作为全局对象（特别是渲染器），以便它们可以用来将我们的纹理渲染到画布上：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After that, we have our emitter. Right now, we are only supporting a single
    emitter. In later versions, we will want to have several emitters that we have
    configured:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有我们的发射器。现在，我们只支持单个发射器。在以后的版本中，我们将希望配置多个发射器。
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The remaining global variables are all related to keeping track of time between
    frames in both milliseconds (`diff_time`) and terms of fractions of a second (`delta_time`).
    The `last_time` and `current_time` variables are primarily used to calculate those
    other two time-related variables. Here is what the definitions look like in the
    code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的全局变量都与在毫秒（`diff_time`）和秒的分数（`delta_time`）之间跟踪时间有关。`last_time`和`current_time`变量主要用于计算这两个与时间相关的变量。以下是代码中这些定义的样子：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After we define our global variables, it is time to define the functions that
    will interact with our JavaScript. The first one of these functions is `add_emitter`.
    That is a simple function that looks to see if an emitter has been defined and,
    if it has, delete it. Then, it creates a new emitter with the values that were
    passed into this function from the JavaScript using the values that were inside
    of the HTML input elements at the time. Here is what the function looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了全局变量之后，是时候定义将与我们的JavaScript进行交互的函数了。其中的第一个函数是`add_emitter`。这是一个简单的函数，它查看是否已定义了一个发射器，如果有，就删除它。然后，它使用从JavaScript传入此函数的值创建一个新的发射器，使用此时HTML输入元素中的值。以下是函数的样子：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You may have noticed these two lines that precede the definition of the `add_emitter`
    function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在`add_emitter`函数定义之前的这两行：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We need those lines to prevent *name mangling* and *dead code elimination*.
    If you've never heard those terms before, let me explain.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些行来防止*名称混编*和*死代码消除*。如果你以前从未听说过这些术语，让我来解释一下。
- en: C++ name mangling
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++名称混编
- en: 'The first of these lines, `extern "C"`, tells the compiler that this is a C
    function and instructs it not to use C++ *name mangling* on that function. If
    you are not familiar with C++ name mangling, the basics of it are this: C++ supports
    function overloading. In other words, you can have multiple functions with the
    same name that have different parameters. C++ will call the correct function based
    on the parameters that are getting passed into that function. Because of this
    functionality, C++ will *mangle* the names as it compiles them, giving each function
    a different name during the compilation process. Because I am now using C++ and
    I am no longer using C, these functions I would like to be called from JavaScript
    are subject to this name mangling process. The `extern "C"` directive tells the
    C++ compiler that these are C functions, and to please not mangle the names so
    that I can call them externally from my JavaScript.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行中的第一行`extern "C"`告诉编译器这是一个C函数，并指示它不要在该函数上使用C++ *名称混编*。如果你不熟悉C++名称混编，它的基本原理是：C++支持函数重载。换句话说，你可以有多个具有不同参数的相同名称的函数。C++将根据传递给该函数的参数调用正确的函数。由于这个功能，C++在编译时会对名称进行*混编*，在编译过程中为每个函数赋予不同的名称。因为我现在正在使用C++，而不是使用C，这些函数我希望从JavaScript中调用都会受到这个名称混编过程的影响。`extern
    "C"`指令告诉C++编译器这些是C函数，并请不要混编名称，以便我可以从我的JavaScript中外部调用它们。
- en: Dead code elimination
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死代码消除
- en: By default, Emscripten uses *dead code elimination* to remove any function that
    you are not calling from somewhere inside of your C++ code. In most instances,
    this is a good thing. You do not want unused code taking up space inside of your
    WebAssembly module. That creates a problem when there is a function that exists
    to be called from the JavaScript, but not from inside of the C++ code. The Emscripten
    compiler sees that nothing is calling this function, and eliminates it. `EMSCRIPTEN_KEEPALIVE`
    tells the Emscripten compiler not to remove this code because you would like to
    call it from an external source.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Emscripten使用*死代码消除*来删除您在C++代码内部没有调用的任何函数。在大多数情况下，这是一件好事。您不希望未使用的代码占据WebAssembly模块中的空间。当存在一个函数可供从JavaScript调用，但无法从C++代码内部调用时，就会出现问题。Emscripten编译器会看到没有任何东西调用此函数，并将其删除。`EMSCRIPTEN_KEEPALIVE`告诉Emscripten编译器不要删除此代码，因为您希望从外部源调用它。
- en: Updating the emitter
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新发射器
- en: 'After the `add_emitter` code, the next function that is set up for an external
    call is `update_emitter`. This function first checks to see if there is a defined
    emitter, and if so, calls an update function that updates all of the attributes
    on the emitter to the values passed in from the HTML input elements. Here is what
    the code looks like:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add_emitter`代码之后，为外部调用设置的下一个函数是`update_emitter`。此函数首先检查是否定义了发射器，如果是，则调用更新函数，该函数将更新发射器上的所有属性，以便与从HTML输入元素传入的值相匹配。代码如下：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The looping function
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环函数
- en: 'The next function, `show_emission`, is the function that would be our game
    loop if this app were a game. This function gets called for every frame rendered
    and is responsible for the setting of timer values, preparing our SDL to render,
    and calling the emitter `Move` function, which will move and render all of the
    particles in our particle system:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`show_emission`是如果此应用程序是游戏，则将成为我们的游戏循环的函数。此函数在每个渲染的帧上调用，并负责设置计时器值，准备我们的SDL进行渲染，并调用发射器的`Move`函数，该函数将移动和渲染粒子系统中的所有粒子：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first few lines calculate the `delta_time` and `diff_time` global variables,
    which are used by the particles to adjust the movement of the particles based
    on the frame rate:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行计算了`delta_time`和`diff_time`全局变量，这些变量由粒子根据帧速率调整粒子的移动：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the emitter has not been set, we do not want to render anything, so we return:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发射器尚未设置，我们不希望渲染任何内容，因此我们返回：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the emitter exists, we need to clear out the renderer using a black color:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发射器存在，我们需要使用黑色清除渲染器：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After that, we call the emitter `Move` function, which both moves all the particles
    and copies the sprite texture to the appropriate position in the renderer. Then,
    we call the `SDL_RenderPresent` function, to render to the HTML canvas element:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用发射器的`Move`函数，该函数既移动所有粒子，又将精灵纹理复制到渲染器中的适当位置。然后，我们调用`SDL_RenderPresent`函数，将其渲染到HTML画布元素上：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Initialization
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: 'The final function is the `main` function, which is called automatically when
    the WebAssembly module is loaded:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是`main`函数，当加载WebAssembly模块时会自动调用：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first couple of lines initialize our SDL:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行初始化了我们的SDL：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After that, the next several lines are used to disable the SDL text input and
    keyboard events. These lines prevent SDL from capturing the keyboard input we
    need to set the input values inside of our HTML elements. In most games, we would
    not want these lines, because we would prefer these events to be captured so that
    we could manage our game input from within our WebAssembly module. But, if we
    want our app to work, and we want our users to be able to change our HTML input,
    we must have these lines in our code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，接下来的几行用于禁用SDL文本输入和键盘事件。这些行防止SDL捕获我们需要在HTML元素内设置输入值的键盘输入。在大多数游戏中，我们不希望这些行存在，因为我们希望捕获这些事件，以便我们可以从我们的WebAssembly模块内管理游戏输入。但是，如果我们希望我们的应用程序正常工作，并且我们希望用户能够更改我们的HTML输入，我们必须在我们的代码中包含这些行：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The next line gets the starting clock value for the `last_time` global variable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行获取`last_time`全局变量的起始时钟值：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last line in this function prior to the return is used to set up our loop
    function. Our loop function will be called every time a frame is rendered:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前，此函数中的最后一行用于设置我们的循环函数。我们的循环函数将在每次渲染帧时调用：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the next section, we will compile and test an early version of our emitter
    configuration tool.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编译和测试发射器配置工具的早期版本。
- en: Compiling and testing the particle emitter
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试粒子发射器
- en: Wow, that was a lot of code. Okay, now that we have everything that we need
    in our particle emitter config tool, we need to take the time to compile and test
    it. After we test this version, we can use this same call to em++ to test the
    advanced version we will start building in the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是很多代码。好的，现在我们在粒子发射器配置工具中拥有了所有需要的东西，我们需要花时间编译和测试它。在测试此版本之后，我们可以使用相同的em++调用来测试我们将在下一节开始构建的高级版本。
- en: 'Run this command at the command line:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上运行此命令：
- en: '[PRE67]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Your particle emitter configuration tool should look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您的粒子发射器配置工具应如下所示：
- en: '![](img/c029c870-aef9-443f-8eb4-257c5e87a519.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c029c870-aef9-443f-8eb4-257c5e87a519.png)'
- en: 'Figure 8.2: Screenshot of the particle system configuration tool'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：粒子系统配置工具的屏幕截图
- en: Do not forget that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the We1bAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，则必须使用`--emrun`标志进行编译。Web浏览器需要Web服务器来流式传输We1bAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么该WebAssembly模块将无法加载。
- en: Use this interface to upload a `.png` image file and play around with the numbers
    we have in the fields on the left. We do not yet have enough values to make an
    excellent particle emitter, but you can get a feel for the basics with what we
    currently have.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个界面上传一个`.png`图像文件，并在左侧的字段中玩一下。我们还没有足够的数值来制作一个出色的粒子发射器，但你可以通过目前的内容对基础知识有所了解。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to create a basic particle emitter configuration
    tool. We covered how to force Emscripten to create a virtual file system when
    there are no files loaded into it at application startup. We learned how we could
    load an image from our user's computer into the browser's virtual file system,
    and added functionality to allow us to upload a `.png` image file. We covered
    some basics of SVG, discussed the differences between vector and raster graphics,
    and learned how we would use SVG to draw pie charts for our configuration tool.
    We covered some basic trigonometry that was useful in this chapter, and will only
    become more useful in later chapters. We created a new HTML shell file that interacts
    with our WebAssembly, to help us configure a new particle system for our game.
    We created a `Point`, `Particle`, and `Emitter` class in a WebAssembly module
    that we are using for the emitter, which we will eventually use inside of our
    game. Finally, we learned about C++ name mangling, dead code elimination, and
    the circumstances where we must avoid them when writing Emscripten code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建一个基本的粒子发射器配置工具。我们讨论了如何强制Emscripten在应用程序启动时没有加载文件时创建虚拟文件系统。我们学习了如何从用户的计算机加载图像到浏览器的虚拟文件系统，并添加了允许我们上传`.png`图像文件的功能。我们介绍了一些SVG的基础知识，讨论了矢量图形和光栅图形之间的区别，并学习了如何使用SVG来为我们的配置工具绘制饼状图。我们介绍了一些在本章中有用的基本三角学知识，在后面的章节中将变得更加有用。我们创建了一个新的HTML外壳文件，与我们的WebAssembly进行交互，帮助我们为游戏配置一个新的粒子系统。我们在一个WebAssembly模块中创建了`Point`、`Particle`和`Emitter`类，我们将最终在游戏中使用它们。最后，我们了解了C++的名称修饰、死代码消除以及在编写Emscripten代码时必须避免它们的情况。
- en: In the next chapter, we will improve our *particle emitter configuration tool*.
    By the end of the chapter, we will use it to configure effects in our game such
    as explosions, solar flares, and spaceship exhaust plumes. The tool can be used
    to play around with different effects, and get a feeling for how they look before
    we add that effect into our game. Finally, we will take the values we used in
    our configuration tool and use them as a starting point for configuring the particle
    effects in our game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改进我们的*粒子发射器配置工具*。在本章结束时，我们将使用它来配置游戏中的效果，如爆炸、太阳耀斑和飞船排气。这个工具可以用来尝试不同的效果，并在将该效果添加到游戏之前感受一下它们的外观。最后，我们将使用配置工具中使用的数值作为配置游戏中粒子效果的起点。
