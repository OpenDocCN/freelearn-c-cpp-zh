- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating the User Interface
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: 'To start this chapter, let’s begin by asking a simple question: what was the
    first multiplayer game you played?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个章节的开始，先提出一个简单的问题：你第一次玩的多玩家游戏是什么？
- en: If you are thinking of a PC or a console game, try thinking another way. Imagine
    a bunch of kids holding their arms out, pretending to shoot and take down the
    bad guys invading their neighborhood. Perhaps there was an evocative action movie
    the night before on TV. Now, these kids are bringing to life what they think is
    possible within the realm of physics, mixed with a bit of fantasy and what they
    remember from the movie. Some kids will even pretend they have been harmed along
    the way. Fallen comrades will be avenged in the end, and good will once again
    prevail against evil. Who’s keeping the score here – that is, who has how many
    hit points?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑玩个人电脑或控制台游戏，试着换一种思维方式。想象一群孩子伸出双臂，假装射击并击倒入侵他们社区的坏人。或许前一天晚上电视上播放了一部引人入胜的动作电影。现在，这些孩子正在将他们认为在物理领域内可能的事情变成现实，混合了一点幻想和他们对电影的记忆。有些孩子甚至会假装自己在过程中受伤。最终，阵亡的战友将得到报复，善良将再次战胜邪恶。这里谁在记分——也就是说，谁有多少生命值？
- en: How about the servers, internet speed, and likewise? Did the kids even need
    a **user interface** (**UI**) to play their game? No, because it was still easy
    for them to keep track of what was happening. But when the number of things people
    need to pay attention to gets beyond a certain point, it gets overwhelming. In
    other words, a UI is needed when using a system without one becomes impractical.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么服务器、互联网速度以及类似的事情呢？孩子们甚至需要**用户界面**（**UI**）来玩游戏吗？不，因为对他们来说，跟踪发生的事情仍然很容易。但是当人们需要关注的事情数量超过某个点时，就会变得难以应对。换句话说，当使用没有UI的系统变得不切实际时，就需要一个UI。
- en: This is not unique to video games. In the real world, you use an ATM to access
    your bank accounts. The information and functions you need will be presented in
    a clear, concise manner; checking your accounts, sending e-transfers, and accessing
    the current interest rates are quick and easy to do all from one place, thanks
    to a well-designed UI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅局限于视频游戏。在现实世界中，你使用ATM来访问你的银行账户。所需的信息和功能将以清晰、简洁的方式呈现；检查账户、发送电子转账和查看当前利率都很容易，多亏了精心设计的UI。
- en: In our game, despite what Clara expected, her uncle was not there but had left
    a note on the pier. We need a way for the player to access this information. Thus,
    in this chapter, we’ll present a few of the UI components Godot has in its arsenal
    to convey this message. We’ll start with a simple **Button** node, followed by
    a **Panel** component. In this panel, we will display some text via the **Label**
    component.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，尽管克拉拉有所期待，但她叔叔并没有在那里，而是在码头留下了一张便条。我们需要一种方式让玩家获取这些信息。因此，在本章中，我们将介绍Godot在它的工具箱中的一些UI组件来传达这个信息。我们将从一个简单的**按钮**节点开始，然后是**面板**组件。在这个面板中，我们将通过**标签**组件显示一些文本。
- en: While you are adding more and more UI elements to the game, you’ll also learn
    how to apply styles to these so that they look more like they belong to the game
    world. After all, the default ones have that default gray look, which might be
    better suited for prototyping.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在游戏中添加越来越多的用户界面元素时，你也会学习如何将这些元素应用样式，使它们看起来更像是游戏世界的一部分。毕竟，默认的样式看起来都是那种默认的灰色，可能更适合原型设计。
- en: Styling Godot nodes may feel tiresome after you do it more than a few times,
    especially if you are doing it for the same kind of button with different text.
    As a solution, we’ll demonstrate how to take advantage of themes, which is a powerful
    tool that will help you in your styling efforts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在多次对Godot节点进行样式化操作后，可能会感到疲倦，尤其是如果你正在为具有不同文本的相同类型的按钮进行样式化。作为一个解决方案，我们将演示如何利用主题，这是一个强大的工具，将帮助你进行样式化工作。
- en: 'As usual, we’ll be discussing a few relevant side topics that are pertinent
    to the creation of UIs. With that in mind, in this chapter, we will cover the
    following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将讨论一些与创建UI相关的相关话题。考虑到这一点，在本章中，我们将涵盖以下主题：
- en: Creating a simple button
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的按钮
- en: Wrapping in a panel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包裹在面板中
- en: Filling the panel with more control nodes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面板中填充更多控件节点
- en: Taking advantage of themes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用主题
- en: By the end of this chapter, you’ll have learned how to exploit UI nodes to help
    the player read the note that Clara’s uncle had left for her.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何利用UI节点帮助玩家阅读克拉拉叔叔为她留下的便条。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'If you think you don’t have enough artistic talent to create UIs, then rest
    assured for two reasons. First, we’ll mainly focus on utilizing the UI components
    in Godot. Therefore, the graphic design aspect won’t be our concern. Second, we
    are providing you with the necessary assets in the `Resources` folder in `Chapter
    11` of this book’s GitHub repository. Inside it, you’ll find two folders: `Fonts`
    and `UI`. Simply merge these two folders into your Godot project folder.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为您没有足够的艺术天赋来创建UI，那么请放心，有两个原因。首先，我们将主要关注在Godot中利用UI组件。因此，图形设计方面不会是我们的关注点。其次，我们在本书GitHub仓库的第11章的“资源”文件夹中为您提供必要的资源。在里面，您会找到两个文件夹：“Fonts”和“UI”。只需将这些两个文件夹合并到您的Godot项目文件夹中。
- en: This book’s GitHub repository, [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot),
    contains all the assets you need. Lastly, you can either continue your work from
    the previous chapter or utilize the `Finish` folder from `Chapter 10`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的GitHub仓库，[https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot)，包含了您需要的所有资源。最后，您可以从上一章继续您的作品，或者使用第10章的“完成”文件夹。
- en: Creating a simple button
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的按钮
- en: A UI is a collection of components you lay out in a coherent manner around the
    core visuals of your game. The most essential UI component to start with may have
    been a **Label** node if we wanted it to be similar to printing “Hello, world!”
    when we are learning a new programming language. However, we’ll start with a **Button**
    node since the former case is so trivial, and we can also learn how to style a
    **Button** during this effort.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: UI是围绕您游戏核心视觉元素以连贯方式排列的组件集合。最基础的UI组件可能是**Label**节点，如果我们想让它类似于在学习一门新编程语言时打印“Hello,
    world!”。然而，我们将从**Button**节点开始，因为前者非常简单，我们也可以在这个过程中学习如何样式化**Button**。
- en: Before we start throwing around a bunch of UI nodes willy-nilly, we should first
    mention the right kind of structure to hold our UI nodes. We can use **CanvasLayer**
    similar to using a **Spatial** node to nest other nodes such as **MeshInstance**,
    **AnimationPlayer**, and others.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们随意抛出一堆UI节点之前，我们应该首先提到正确的结构来容纳我们的UI节点。我们可以使用**CanvasLayer**，类似于使用**Spatial**节点来嵌套其他节点，例如**MeshInstance**、**AnimationPlayer**等。
- en: 'We’ve already been creating scenes mainly to display 3D models. Let’s follow
    similar steps for the sake of creating the UI:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经一直在创建场景主要是为了显示3D模型。让我们遵循类似的步骤来创建UI：
- en: Create a blank scene and save it as `UI.tscn` in the `Scenes` folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空白场景，并将其保存为“UI.tscn”，位于“Scenes”文件夹中。
- en: Choose `UI`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“UI”。
- en: Attach a `Close`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“Close”。
- en: Type `Close` for its **Text** value in the **Inspector** panel.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**面板中为其**Text**值输入“Close”。
- en: There’s nothing fancy going on so far, but we now have a button aligned, by
    default, to the top left of the viewport. The width of this button also expanded
    when you were typing the text it displays.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有什么特别之处，但我们现在有一个按钮默认对齐到视口的左上角。当您输入显示的文本时，这个按钮的宽度也扩展了。
- en: Control versus CanvasLayer
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 控制与CanvasLayer
- en: We mentioned that a **Spatial** node would be the root node for 3D nodes. So,
    for the sake of keeping things familiar, we could have used a **Control** node
    to hold the **Button** node. Rest assured, you could still inject a **Control**
    node inside a **CanvasLayer**. The real reason we used a **CanvasLayer** as the
    root is for its **Layer** property in the **Inspector** panel. By changing the
    value of this, you can change the draw order, which means you can decide which
    **CanvasLayer** will render first. This is a useful mechanism when you have multiple
    UI structures that need to be layered on top of each other in a precise order.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到**Spatial**节点将是3D节点的根节点。所以，为了保持熟悉，我们可以使用**Control**节点来容纳**Button**节点。请放心，您仍然可以在**CanvasLayer**内部注入**Control**节点。我们使用**CanvasLayer**作为根节点的真正原因是其在**Inspector**面板中的**Layer**属性。通过更改此值，您可以更改绘制顺序，这意味着您可以决定哪个**CanvasLayer**将首先渲染。当您有多个需要以精确顺序堆叠在彼此之上的UI结构时，这是一个有用的机制。
- en: 'The button we have just added looks boring. It doesn’t quite fit the world
    we are creating. Now, let’s use a custom graphic asset to style our button:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的按钮看起来很无聊。它并不完全适合我们正在创建的世界。现在，让我们使用自定义图形资源来样式化我们的按钮：
- en: Expand the **Styles** subsection in the **Theme Overrides** section of the **Inspector**
    panel.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**面板的**Theme Overrides**部分的**Styles**子部分中展开。
- en: Using the dropdown for the **Normal** property, select the **New StyleBoxTexture**
    option.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**正常**属性的下拉菜单，选择**新样式盒纹理**选项。
- en: Click the **StyleBoxTexture** title as it will populate the **Inspector** panel
    with its properties.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**样式盒纹理**标题，这将填充**检查器**面板并显示其属性。
- en: Drag `button_normal.png` from `UI` into the **FileSystem** panel and drop it
    in the **Texture** property.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`button_normal.png`从`UI`拖到**文件系统**面板，并将其放入**纹理**属性中。
- en: Expand the `8` for all the margin values.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有边距值中的`8`展开。
- en: Press *F6* to launch the `UI.tscn` scene and try to interact with the button.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F6*启动`UI.tscn`场景并尝试与按钮交互。
- en: You have taken quite a few steps to style a simple button, so let’s break down
    what’s happened.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为简单的按钮进行了很多样式设置，所以让我们分析一下发生了什么。
- en: In *step 1*, you told Godot that you wanted to override the default theme, which
    was giving that gray look to the button. Without user interaction, the button
    will be in its normal state; so, that’s what you intend to change in *step 2*.
    We’ll discover how to change the other states very soon.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，你告诉Godot你想覆盖默认主题，该主题为按钮提供了灰色外观。在没有用户交互的情况下，按钮将处于其正常状态；所以，这就是你在*步骤2*中打算改变的内容。我们很快就会发现如何更改其他状态。
- en: '*Step 3* was about defining the properties of this `Lorem ipsum dolor sit amet`.
    Notice how the button is getting wider without looking stretched and keeping the
    rounded corners intact. This needs a proper explanation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*是关于定义这个`Lorem ipsum dolor sit amet`的属性。注意按钮是如何在不显得拉伸的情况下变宽，同时保持圆角完整。这需要适当的解释。'
- en: 'Setting margins involves doing more than just accommodating text. Carefully
    selected values will make sure the texture will enlarge or shrink as needed without
    losing some of its qualities, such as rounded corners. When the asset has rounded
    corners, if the texture is stretched, you will end up with a distorted look. The
    practice of conserving the core features of a texture and allowing it to be resized
    properly without distortion is called 9-slice scaling. You can learn more about
    it here: [https://en.wikipedia.org/wiki/9-slice_scaling](https://en.wikipedia.org/wiki/9-slice_scaling).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设置边距不仅涉及容纳文本。精心选择的值将确保纹理可以根据需要放大或缩小，而不会失去其某些特性，如圆角。当资产具有圆角时，如果纹理被拉伸，你最终会得到一个扭曲的外观。保留纹理的核心特性并允许其正确缩放而不失真的做法称为9切片缩放。你可以在这里了解更多信息：[https://en.wikipedia.org/wiki/9-slice_scaling](https://en.wikipedia.org/wiki/9-slice_scaling)。
- en: 'When you launched the `UI.tscn` scene in *step 6*, the button must have shown
    its normal state as a brown texture. If you move your mouse over it, you’ll see
    that the button will show the default look again because you haven’t set the hover
    state yet. This can be seen in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中启动`UI.tscn`场景时，按钮必须显示其正常状态，即棕色纹理。如果你将鼠标移到它上面，你会看到按钮将再次显示默认的外观，因为你还没有设置悬停状态。这可以在下面的屏幕截图中看到：
- en: '![Figure 11.1 – The button only has its normal state styled ](img/Figure_11.1_B17473.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 按钮仅对其正常状态进行了样式设置](img/Figure_11.1_B17473.jpg)'
- en: Figure 11.1 – The button only has its normal state styled
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 按钮仅对其正常状态进行了样式设置
- en: 'Similar to the way you assigned a texture to the normal state of the button,
    you can do so for the other states. Let’s do this for the hover state:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与你为按钮的正常状态分配纹理的方式类似，你也可以为其他状态这样做。让我们为悬停状态做这个操作：
- en: Select the **Close** button in the **Scene** tree.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**树中选择**关闭**按钮。
- en: Assign a **New StyleBoxTexture** to the **Hover** state in the **Styles** subsection
    under **Theme Overrides** and click this **StyleBoxTexture** to set its properties.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主题覆盖**下的**样式**子部分中，将**新样式盒纹理**分配给**悬停**状态，并点击这个**样式盒纹理**来设置其属性。
- en: Drag `button_hover.png` from the `UI` folder and set the margins to `8`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`button_hover.png`从`UI`文件夹拖出，并将边距设置为`8`。
- en: Press *F6* and move your mouse over the button.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F6*并将鼠标移到按钮上。
- en: 'We’ll repeat this effort for the pressed and disabled states as well. We won’t
    use disabled buttons in our game, but why not be thorough? Also, in most scenarios,
    you can repurpose the pressed state for the focus state. The different results
    are shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将重复这一过程来设置按下和禁用状态。在我们的游戏中，我们不会使用禁用按钮，但为什么不做彻底呢？此外，在大多数情况下，你可以将按下状态用于焦点状态。不同的结果在下面的屏幕截图中显示：
- en: '![Figure 11.2 – The normal, hover, pressed, and disabled states of a button
    with a custom texture ](img/Figure_11.2_B17473.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 带有自定义纹理的按钮的正常、悬停、按下和禁用状态](img/Figure_11.2_B17473.jpg)'
- en: Figure 11.2 – The normal, hover, pressed, and disabled states of a button with
    a custom texture
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 带有自定义纹理的按钮的正常、悬停、按下和禁用状态
- en: Before we move on to introducing more UI nodes, we suggest that you change the
    text of that button back to `Close` since we’ll use this button to close a panel
    that will simulate a note from Clara’s uncle. Speaking of which, it’s time to
    learn what was written in that note.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍更多UI节点之前，我们建议你将那个按钮的文本改回`关闭`，因为我们将使用这个按钮来关闭一个模拟克拉拉叔叔笔记的面板。说到这个，是时候学习笔记中写了什么了。
- en: Wrapping in a panel
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在面板中包裹
- en: So far, we have created a button and styled it. However, it would be nice if
    it served some purpose, especially since we gave it a meaningful label. We’ll
    write some code so that this button can close a panel near the end of the *Filling
    the panel with more control nodes* section. Before we get to that point, though,
    we need the panel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个按钮并为其设置了样式。然而，如果它能够发挥作用，那就更好了，尤其是考虑到我们给它赋予了有意义的标签。我们将编写一些代码，以便这个按钮可以在“在面板中添加更多控制节点”部分的末尾关闭一个面板。不过，在我们到达那个点之前，我们需要面板。
- en: 'As we are introducing more UI nodes, let’s remember why we are doing this within
    the game’s context. Clara’s uncle had left a note. We’ll simulate that note with
    a combination of UI nodes in Godot so that it looks as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们介绍更多的UI节点，让我们记住我们为什么在游戏上下文中做这件事。克拉拉的叔叔留下了一封笔记。我们将使用Godot中的UI节点组合来模拟这封笔记，使其看起来如下：
- en: '![Figure 11.3 – Clara’s note ](img/Figure_11.3_B17473.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 克拉拉的笔记](img/Figure_11.3_B17473.jpg)'
- en: Figure 11.3 – Clara’s note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 克拉拉的笔记
- en: We’ve already taken care of the button, but it is currently sitting in the middle
    of nowhere. We’ll wrap it in a **Panel** node in this section after we give a
    short disclaimer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了按钮，但它目前正坐在一个无处可去的地方。在给出简短声明后，我们将在这个部分用**面板**节点包裹它。
- en: A **Panel** node is just another **Control** node in Godot that usually holds
    other components. There is a similarly named node, **PanelContainer**, which might
    be confusing for beginners. The **Panel** node derives from the **Control** class,
    whereas the **PanelContainer** node inherits from the **Container** class. Also,
    the **Container** class inherits from the **Control** class. This kind of technical
    detail might be important when you are doing more advanced work. We won’t, so
    either one would work fine for our intents and purposes in this book. Therefore,
    we’ll stick with the **Panel** node.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**面板**节点是Godot中的另一个**控制**节点，通常用于包含其他组件。还有一个同名节点，**面板容器**，可能会让初学者感到困惑。**面板**节点从**控制**类派生，而**面板容器**节点从**容器**类继承。此外，**容器**类从**控制**类继承。这类技术细节在执行更高级的工作时可能很重要。我们不会这么做，所以在这个书中，为了我们的目的，两者都可以正常工作。因此，我们将坚持使用**面板**节点。'
- en: 'At this point, we are ready to add a **Panel** node and style it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们准备好添加一个**面板**节点并为其设置样式：
- en: Add a **Panel** node under the root **UI** node in the **Scene** tree.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**树中，在根**UI**节点下添加一个**面板**节点。
- en: Expand the **Rect** section in the **Inspector** panel.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中展开**矩形**部分。
- en: For the `600` for **X**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**X**输入`600`。
- en: Type `400` for **Y**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**Y**输入`400`。
- en: Assign a **New StyleBoxTexture** to the **Panel** property in the **Styles**
    subsection under **Theme Overrides**.*   Drag the **Close** button over the **Panel**
    node in the **Scene** panel so that the **Close** button is nested.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“主题覆盖”下的“样式”子部分中，将**新样式框纹理**分配给**面板**属性。*   将**关闭**按钮拖动到**场景**面板中的**面板**节点上，以便**关闭**按钮嵌套。
- en: 'At this point, you should have the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有以下的输出：
- en: '![Figure 11.4 – The paper texture has been simulated with the help of a Panel
    node ](img/Figure_11.4_B17473.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 使用面板节点模拟的纸张纹理](img/Figure_11.4_B17473.jpg)'
- en: Figure 11.4 – The paper texture has been simulated with the help of a Panel
    node
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 使用面板节点模拟的纸张纹理
- en: We are getting closer and closer to the desired design we imagined for the note.
    The button in the panel is still aligned to the top left. You can drag it to a
    position that makes sense, but it might be easier to decide on that if you have
    some text within the panel. That’s what we’ll take care of next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近我们想象中的笔记设计。面板中的按钮仍然对齐到左上角。你可以将它拖动到一个有意义的位子，但如果面板内有文本，可能会更容易决定。这就是我们接下来要处理的。
- en: Filling the panel with more control nodes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在面板中添加更多控制节点
- en: The uncle’s note is slowly taking shape. We’ll introduce a **Label** node in
    this section for the text portion. Additionally, we’ll have to figure out how
    to position all these elements so that the note resembles the layout we’d like
    to have. Lastly, we’ll discuss a few complementary **Control** nodes you may want
    to use in some other scenarios.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 叔叔的笔记正在慢慢成形。在本节中，我们将介绍一个**标签**节点用于文本部分。此外，我们还需要想出如何定位所有这些元素，以便笔记看起来像我们想要的布局。最后，我们将讨论一些可能在某些场景下想要使用的辅助**控制**节点。
- en: 'After all, we will still employ the most basic UI node: **Label**. If we had
    used it at the beginning, it would have looked unimpressive with its default style
    and color. Since we now have a proper texture over which this **Label** node can
    go, things will look more interesting. Follow these steps to do this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们仍然会使用最基本的UI节点：**标签**。如果我们一开始就使用它，它将因其默认样式和颜色而显得不起眼。由于我们现在有一个合适的纹理，这个**标签**节点可以放在上面，所以事情会看起来更有趣。按照以下步骤进行操作：
- en: Select the **Panel** node in the **Scene** panel.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**面板中选择**面板**节点。
- en: Add a **Label** node and turn its **Autowrap** property on in the **Inspector**
    panel.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中添加一个**标签**节点并将其**自动换行**属性打开。
- en: 'Set its **Text** to the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**文本**设置为以下内容：
- en: '`My dear Clara,`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`我亲爱的克拉拉，`'
- en: '`A close friend of mine is in dire need of help. I must leave immediately.`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`我的一个好朋友急需帮助。我必须立即离开。`'
- en: '`Check out the backpack by the decrepit cart. Inside, you will find a key to
    upstairs. Make yourself at home.`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`检查破旧的购物车旁的背包。里面，你会找到通往楼上的钥匙。请随意。`'
- en: '`Your uncle, Bert`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`你的叔叔，伯特`'
- en: 'Our last effort will result in an awkwardly tall text block. To remedy this,
    we could manually give some width and height to the **Label** node we have just
    inserted. While we are doing that, we could also change its position to make it
    look centered and have some margins off each edge. However, we can do something
    smarter: we can wrap this **Label** inside a **MarginContainer** that will set
    margins and automatically resize the text for us.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的努力将导致一个不协调的高文本块。为了解决这个问题，我们可以手动给刚刚插入的**标签**节点设置一些宽度和高度。当我们这样做的时候，我们也可以改变它的位置，使其看起来居中，并在每个边缘有一些边距。然而，我们可以做得更聪明：我们可以将这个**标签**包裹在一个会设置边距并自动调整文本大小的**边距容器**内。
- en: Adding a MarginContainer
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加边距容器
- en: At this point, adding new nodes to the **Scene** panel must be a common task
    for you. Nevertheless, there are times, such as now, when deciding where to add
    a new node and what to nest in it might not be obvious. The question is, where
    can we add **MarginContainer**? Outside the **Panel** node or inside?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，向**场景**面板添加新节点对你来说可能是一个常见的任务。然而，有时，例如现在，决定在哪里添加新节点以及将其嵌套在何处可能并不明显。问题是，我们可以在哪里添加**边距容器**？在**面板**节点外部还是内部？
- en: 'A **MarginContainer** is a specialized container that’s responsible for introducing
    margins so that its children look like they have padding. If we wrap the **Panel**
    node inside a **MarginContainer**, since the **Panel** node is holding the text,
    the whole structure, including the button, will be padded. That’s not good since
    we would like the text to have some space between its edges and the borders of
    the texture that constitutes the **Panel** node. Thus, this is what you need to
    do to only pad the text:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**边距容器**是一个专门的容器，负责引入边距，使其子元素看起来像有填充。如果我们将**面板**节点包裹在一个**边距容器**中，由于**面板**节点包含文本，整个结构，包括按钮，都将有填充。这并不好，因为我们希望文本的边缘和构成**面板**节点的纹理的边缘之间有一些空间。因此，你需要这样做，只为文本添加填充：'
- en: Add a **MarginContainer** node inside the **Panel** node and nest **Label**
    inside this **MarginContainer** node.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**面板**节点内添加一个**边距容器**节点，并将**标签**嵌套在这个**边距容器**节点内。
- en: Set the following values in the `0` and both `1`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0`和`1`处设置以下值。
- en: In the `0`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0`处。
- en: In the `60`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`60`处。
- en: We touched on a lot of terms in the preceding operation. The first two sets
    of actions, where we alter the values of anchor and margin, are not specific to
    a **MarginContainer**. They exist for every type of **Control** node. You can
    also see this fact as these properties were listed under the **Control** header
    in the **Inspector** panel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的操作中，我们提到了很多术语。前两组操作，即我们改变锚点和边距的值，并不特定于**边距容器**。它们适用于每种类型的**控制**节点。你还可以将这一事实视为这些属性在**检查器**面板下的**控制**标题下列出。
- en: The anchor and margin values we chose are such special values that we could
    have used a shortcut to achieve the same result. It would be selecting the **Full
    Rect** option in the expanded menu after you click the **Layout** button in the
    header section of the 3D viewport. This **Layout** button is visible in the following
    screenshot, just above the top-right corner of the paper texture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的锚点和边距值是如此特殊的值，以至于我们可以使用快捷方式达到相同的结果。这需要在3D视口标题部分的**布局**按钮点击后，在展开菜单中选择**全矩形**选项。这个**布局**按钮在以下截图中的可见，位于纸张纹理的右上角。
- en: 'We’ll use another option under that menu when we adjust the location of the
    **Close** button later. For now, compare your work to what you can see in the
    following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后调整**关闭**按钮的位置时，我们将在该菜单下使用另一个选项。现在，将你的工作与以下截图中的内容进行比较：
- en: '![Figure 11.5 – The text now has padding, although it’s hard to read ](img/Figure_11.5_B17473.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 文本现在有填充，尽管很难阅读](img/Figure_11.5_B17473.jpg)'
- en: Figure 11.5 – The text now has padding, although it’s hard to read
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 文本现在有填充，尽管很难阅读
- en: What was essential in the properties of that **MarginContainer** was adjusting
    its content margin values in the **Constants** subsection. That gave the text
    some room and positioned it correctly over the paper texture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个**边距容器**的属性中，最重要的是调整其在**常量**子部分中的内容边距值。这给了文本一些空间，并正确地将其定位在纸张纹理上。
- en: It’s a bit difficult to read the text, though. So, let’s see how we can make
    it legible and, even better, make it look like *Figure 11.3*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文本有点难以阅读。那么，让我们看看我们如何使其可读，甚至更好地使其看起来像**图11.3**。
- en: Styling the Label node
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签节点的样式化
- en: Although **MarginContainer** is now occupying as much space as the **Panel**
    node, and it’s providing margins to the text it’s holding, the text itself is
    hardly legible since it’s small and white over a lightly colored surface. Also,
    the font choice is wrong because it’s using the default font provided by Godot
    Engine. We’ll learn how we can fix all these issues in this section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在**边距容器**占据的空间与**面板**节点一样多，并且它为其所持有的文本提供边距，但文本本身几乎难以辨认，因为它很小且为白色，覆盖在浅色表面上。此外，字体选择是错误的，因为它使用了Godot引擎提供的默认字体。在本节中，我们将学习如何解决所有这些问题。
- en: 'Let’s start by selecting the **Label** node in the **Scene** panel so that
    we can make some changes under **Theme Overrides**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在**场景**面板中选择**标签**节点，以便我们可以在**主题覆盖**下进行一些更改：
- en: Turn on the **Font Color** option in the **Colors** subsection. The color can
    be left black.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**颜色**子部分中打开**字体颜色**选项。颜色可以保持黑色。
- en: Choose the `Kefario.otf` from **FileSystem** to the **Font Data** property in
    the **Font** subsection.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**字体**子部分中，从**文件系统**中选择`Kefario.otf`到**字体数据**属性。
- en: Change `28` in the **Settings** subsection.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**子部分中将`28`进行更改。
- en: 'We’ll discuss what’s happened shortly, but here is what we have done so far:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论发生了什么，但到目前为止我们已经做了以下操作：
- en: '![Figure 11.6 – The Label node now looks more like handwritten text ](img/Figure_11.6_B17473.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 标签节点现在看起来更像手写文本](img/Figure_11.6_B17473.jpg)'
- en: Figure 11.6 – The Label node now looks more like handwritten text
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 标签节点现在看起来更像手写文本
- en: The default black color for the text seems to be fine, but you could pick a
    different color if you wish. A much more drastic change happened when we introduced
    a font type. We did this in two steps. First, we picked a **DynamicFont** type,
    which is slower than the other option, **BitmapFont**, but it lets you change
    the properties of the font at runtime. However, this is not enough to render a
    font since it works like a wrapper. So, you need to assign the font you would
    like to render. That’s what we did when we assigned a font file to the **FontData**
    property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的默认黑色颜色看起来似乎不错，但如果你愿意，可以选择不同的颜色。当我们引入字体类型时，发生了一个更加剧烈的变化。我们分两步进行。首先，我们选择了一个**动态字体**类型，它比另一个选项**位图字体**慢，但它允许你在运行时更改字体的属性。然而，由于它像一个包装器，这不足以渲染字体。因此，你需要分配你想要渲染的字体。这就是我们为什么将字体文件分配给**FontData**属性的原因。
- en: There is an important caveat we think you should be aware of with fonts since
    they are made of individual elements called glyphs. You can think of them as the
    letters in an alphabet. Not every font supports the full spectrum of an alphabet.
    For example, in the note UI that we designed, if you replace the text `you will`
    with its shortened form, `you’ll`, the apostrophe won’t render because it doesn’t
    exist as a glyph in the font. Usually, paid fonts come with a bigger set of glyphs.
    Otherwise, keep searching for free options with a more complete set.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为你需要注意的一个重要注意事项是字体，因为它们由称为符号的独立元素组成。你可以把它们想象成字母表中的字母。并不是每个字体都支持字母表的完整范围。例如，在我们设计的笔记
    UI 中，如果你将文本 `you will` 替换为其缩写形式 `you’ll`，撇号将无法渲染，因为它在该字体中不是一个符号。通常，付费字体包含一个更大的符号集。否则，继续寻找具有更完整集合的免费选项。
- en: Pixels versus points
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像素与点
- en: When we chose 28 as the font size, that number was measured in pixels. In some
    graphics or text editors, you’ll often find fonts measured in points. This is
    something you have to be cautious about because if you transfer the numbers verbatim
    to Godot, your font will be rendered quite differently. So, mind your units.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择 28 作为字体大小时，这个数字是以像素为单位的。在一些图形或文本编辑器中，你经常会发现字体是以点来衡量的。这一点你必须小心，因为如果你直接将这些数字转移到
    Godot 中，你的字体渲染效果将会完全不同。所以，注意你的单位。
- en: In the real world, a note from Clara’s uncle would only contain the text portion.
    Thus, it would be absurd to expect a close button on top of an actual piece of
    paper. However, this is a game, and we’ve already discussed how UIs mix reality
    with functionality. To complete the UI for the note, it’s time we positioned that
    button.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，克拉拉的叔叔的便条只会包含文本部分。因此，期望在一张实际的纸张上有一个关闭按钮是荒谬的。然而，这是一个游戏，我们已经讨论了 UI 如何将现实与功能混合。为了完成笔记的
    UI，是时候定位那个按钮了。
- en: Positioning the Close button
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位关闭按钮
- en: We used a nice trick to position the text concerning the piece of paper it’s
    on. Can we replicate this for the **Close** button? Since a button can’t be considered
    a wide structure, we can’t stick it inside **MarginContainer**. However, we can
    still position it relative to the **Panel** node.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个巧妙的技巧来定位文本，关于它所在的纸张。我们能复制这个技巧用于 **关闭** 按钮吗？由于按钮不能被视为一个宽结构，我们不能将它放在 **MarginContainer**
    内。然而，我们仍然可以将其相对于 **Panel** 节点进行定位。
- en: 'In the *Adding a MarginContainer* section, we used a longer method to adjust
    the dimensions of that component. We also mentioned that we would use a shortcut.
    This is how you can use it after selecting the **Close** button in the **Scene**
    panel:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *添加 MarginContainer* 部分，我们使用了一种更长的方法来调整该组件的尺寸。我们还提到我们会使用一个快捷键。这是在 **场景** 面板中选择
    **关闭** 按钮后如何使用它的方法：
- en: Expand the **Layout** menu and select the **Bottom Right** option.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开布局菜单并选择 **右下角** 选项。
- en: Hold down *Shift* and press the left and up arrow keys on your keyboard four
    times for each.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住 *Shift* 键，然后按键盘上的左箭头键和上箭头键各四次。
- en: This will position the **Close** button at the bottom right corner, then pull
    it up and move it left just enough that it stays there. We mean it when we claim
    that it’ll be staying there. For example, select the **Panel** node, then try
    to resize it using the handles in the viewport. Does the button stay nicely tucked
    in that bottom right corner? Good! How about the **Label** node? Does the text
    flow to occupy the extra space? Neat!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 **关闭** 按钮位于右下角，然后向上拉并向左移动，使其保持在原地。当我们说它将保持在原地时，我们是认真的。例如，选择 **Panel** 节点，然后尝试使用视口中的手柄来调整其大小。按钮是否仍然很好地藏在那个右下角？很好！至于
    **Label** 节点呢？文本是否流动以填充额外的空间？整洁！
- en: 'Our efforts to develop what you saw in *Figure 11.3* are coming to fruition,
    as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发你在 *图 11.3* 中看到的内容的努力正在取得成果，如下所示：
- en: '![Figure 11.7 – Everything in the UI is positioned carefully ](img/Figure_11.7_B17473.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – UI 中的所有元素都经过精心定位](img/Figure_11.7_B17473.jpg)'
- en: Figure 11.7 – Everything in the UI is positioned carefully
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – UI 中的所有元素都经过精心定位
- en: If you want to test your scene, go ahead and press *F6*. Depending on your setup,
    you may notice that the **Close** button will not be functional since it’s behind
    **MarginContainer**. So, try to resort the nodes in the **Scene** panel by dragging
    the nodes up and down. When you have the **Close** button after **MarginContainer**,
    everything should be functional.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试你的场景，请按*F6*。根据您的设置，您可能会注意到**关闭**按钮可能无法正常工作，因为它在**边距容器**后面。所以，尝试通过在**场景**面板中上下拖动节点来调整节点的顺序。当**关闭**按钮在**边距容器**之后时，一切应该都能正常工作。
- en: Speaking of functionality, we haven’t wired anything up for the **Close** button.
    Ideally, that button should turn the visibility of the **Panel** off so that the
    note looks as if it’s been closed. Let’s do that next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 说到功能，我们还没有为**关闭**按钮设置任何连接。理想情况下，该按钮应该关闭**面板**的可见性，这样注释看起来就像已经关闭了。让我们接下来这么做。
- en: Adding the close functionality
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加关闭功能
- en: There are multiple ways we can attack this problem. We are going to show you
    one for brevity’s sake so that you can see what’s involved. You may have to apply
    similar principles differently in your future projects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种方法可以解决这个问题。为了简洁起见，我们将向您展示一种方法，以便您可以看到涉及的内容。您可能需要在未来的项目中以不同的方式应用类似的原则。
- en: For example, the way we are treating the `UI.tscn` scene so far is to have one
    big **Panel** node as a direct child. Your games may need a lot more UIs with
    elements permanently visible on the screen, more notes to open and close, inventory
    screens with expanding parts to reveal more details, and likewise. There are many
    possibilities, which is why there are different types of architectures you can
    construct. There will always be a tradeoff between these different options, so
    we suggest you experiment with the benefits of different UI structures if you
    have some spare time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，到目前为止我们处理`UI.tscn`场景的方式是将其作为直接子节点的一个大**面板**节点。你的游戏可能需要更多带有永久可见元素的UI，更多可打开和关闭的注释，带有展开部分以显示更多细节的库存屏幕，等等。有许多可能性，这就是为什么你可以构建不同类型的架构。在这些不同选项之间总会有权衡，所以我们建议如果你有空闲时间，可以尝试实验不同UI结构的优点。
- en: 'Without further ado, our suggestion for implementing the closing functionality
    is to add a small script to the **Close** button. Select it and do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，我们建议实现关闭功能的方法是在**关闭**按钮中添加一个小脚本。选择它并执行以下操作：
- en: Attach a script to the `ButtonClose.gd` in the `Scripts` folder.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本附加到`Scripts`文件夹中的`ButtonClose.gd`。
- en: 'Make this script file look as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让这个脚本文件看起来如下：
- en: '[PRE0]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This architecture assumes that the button will always be the direct child of
    a node, so once it’s pressed, it will make its parent invisible. Ouch!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构假设按钮始终是节点的直接子节点，所以一旦按下，它将使父节点不可见。哎呀！
- en: The benefit of this kind of simple structure is the convenience that the button
    doesn’t need to know the node structure it’s in. There is also a more conventional
    way of attaching the *pressed* behavior by using the **Node** panel and binding
    a signal. Either way is fine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单结构的优点是方便，按钮不需要知道它所在的节点结构。还有另一种更传统的方法，通过使用**节点**面板和绑定信号来附加**按下**行为。两种方法都行。
- en: Constructing and improving UI elements may easily turn into a project by itself.
    You might be tempted to create that perfect setup for all future possible scenarios
    but keep in mind that overoptimization is a thing. Later, you may realize that
    you didn’t need all that preparation in the first place. We’ll talk about a similar
    situation next, where the note might be longer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和改进UI元素可能很容易变成一个独立的项目。您可能会被诱惑为所有可能的情况创建一个完美的设置，但请记住，过度优化是存在的。稍后，您可能会意识到您一开始根本不需要所有这些准备。我们将在下一个类似的情况中讨论，其中注释可能更长。
- en: Wrapping up
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We now have a fully functional UI for displaying the note from Clara’s uncle,
    Bert. What if Bert had more to say? For example, let’s say the message had an
    extra line after his name, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的UI来显示克拉拉的叔叔伯特的注释。如果伯特有更多话要说呢？例如，假设信息在他的名字后面有一行额外的文本，如下所示：
- en: '`Your uncle, Bert`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`你的叔叔，伯特`'
- en: '`P.S. I think I might have left my pet snake unattended. It might be wandering
    around, so be careful!`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`P.S. 我想我可能把我的宠物蛇忘在一边了。它可能正在四处游荡，所以小心！`'
- en: If you were to add this extra text to the end of the **Label** node, the text
    would get uncomfortably close to the top and bottom of the paper texture. Similarly,
    imagine that this text block needed to be even longer, which is the case in some
    types of games where exposition is important. For instance, it is very common
    when displaying the details of a quest or an item in role-playing games.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段额外文本添加到**标签**节点的末尾，文本就会不舒服地靠近纸张纹理的顶部和底部。同样，想象一下，如果这个文本块需要更长，这在一些类型游戏中很重要，比如在展示角色扮演游戏中的任务或物品详情时。例如，在显示角色扮演游戏中的任务或物品详情时，这种情况非常常见。
- en: Currently, we can make do by adjusting the font size of the text or making the
    margins narrower to allow more room for the new text. However, in more extreme
    situations, it might be better to use a **ScrollContainer** node. Just like you
    wrapped the **Label** node inside **MarginContainer**, you can wrap a **ScrollContainer**
    around the **Label** node, and tweak a few things to have a scrollable text block.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以通过调整文本的字体大小或使边距更窄来适应更多的新文本。然而，在更极端的情况下，使用**滚动容器**节点可能更好。就像你将**标签**节点包裹在**边距容器**中一样，你可以在**标签**节点周围包裹一个**滚动容器**，并对一些东西进行调整，以获得可滚动的文本块。
- en: Coming up with the correct level of *nestedness* and deciding on the type and
    order of UI components is sometimes an effort of trial and error. Consequently,
    there aren’t any set formulas. Therefore, you may find yourself practicing and
    seeing what works best in your use case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 确定合适的*嵌套层级*和决定UI组件的类型及顺序有时需要反复尝试和错误。因此，并没有任何固定的公式。因此，你可能会发现自己正在实践中，看看在你的用例中什么最有效。
- en: That being said, generalizing your efforts to maintain a consistent look and
    feel across your many UI nodes might be helpful. We’ll tackle themes next to accomplish
    this.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，将你的努力推广到保持许多UI节点的一致外观和感觉可能是有帮助的。我们将接下来处理主题以实现这一点。
- en: Taking advantage of themes
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用主题的优势
- en: Using or, more specifically, creating themes in your projects is smart on many
    accounts. First, we’ll discuss their usefulness, show you a few visual examples,
    and then create one for practicing. Let’s start with the reasons why you should
    use themes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中使用或更具体地说，创建主题在很多方面都是明智的。首先，我们将讨论它们的有用性，展示一些视觉示例，然后创建一个用于练习的示例。让我们从为什么你应该使用主题的原因开始。
- en: Firstly, using themes will save you from manually applying overrides to the
    components the way you’ve done so far. It’s still possible to keep adding manual
    touches here and there, but what would happen if you wanted to change a button’s
    artistic direction completely? This would trigger a chain reaction to change the
    look of other components too. So, you’d have to restart the manual editing. Furthermore,
    the ultimate worst-case scenario would be to revert your changes because, you
    know, we are human and we kind of tend to stick with our first choices more often
    than not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用主题将帮助你避免像迄今为止那样手动应用覆盖。当然，你仍然可以在这里和那里添加一些手动修饰，但如果你想完全改变按钮的艺术方向会怎样？这将触发一系列反应来改变其他组件的外观。所以，你将不得不重新开始手动编辑。此外，最糟糕的情况可能是撤销你的更改，因为你知道，我们都是人类，我们往往更倾向于坚持我们的第一个选择。
- en: Secondly, you could have multiple themes at the ready in your game. Although
    a button is still just a button, you could assign it one theme out of many. This
    will make that button look like it belongs to a family of components. Thus, your
    UI elements will have a consistent style.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以在游戏中准备多个主题。尽管按钮仍然只是一个按钮，但你可以给它分配多个主题中的一个。这将使该按钮看起来像属于一组组件。因此，你的UI元素将具有一致的风格。
- en: Lastly, changing themes at runtime is a possibility. This means that if, in
    your game or the application you are building with Godot, you would like to swap
    themes for special occasions such as Christmas, this is entirely possible. Also,
    more and more desktop applications are being built with Godot. These could also
    benefit from theme swapping to offer their user the best choice. Godot Engine
    itself allows you to change themes. You can access the existing themes by opening
    **Editor Settings** and trying out a few themes. For example, try out the **Solarized
    (Light)** theme. Are you getting Unity vibes?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行时更改主题也是可能的。这意味着，如果您在游戏或您用Godot构建的应用程序中想要在特殊场合（如圣诞节）交换主题，这是完全可能的。此外，越来越多的桌面应用程序正在使用Godot构建。这些也可以通过主题交换来为用户提供最佳选择。Godot引擎本身允许您更改主题。您可以通过打开**编辑器设置**并尝试一些主题来访问现有主题。例如，尝试**Solarized
    (Light)**主题。您是否感受到了Unity的感觉？
- en: 'Changing a theme is not always about changing the colors of buttons or font
    sizes. For example, [https://365psd.com/psd/ui-kit-54589](https://365psd.com/psd/ui-kit-54589)
    and [https://365psd.com/day/3-180](https://365psd.com/day/3-180) are two UI kits
    we picked to show how drastically different your Godot UI nodes could look. *Figure
    11.8* presents these two UI kits side by side:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更改主题并不总是关于更改按钮的颜色或字体大小。例如，[https://365psd.com/psd/ui-kit-54589](https://365psd.com/psd/ui-kit-54589)
    和 [https://365psd.com/day/3-180](https://365psd.com/day/3-180) 是我们挑选的两个UI套件，以展示您的Godot
    UI节点可能看起来有多么不同。*图11.8*展示了这两个UI套件并排：
- en: '![Figure 11.8 – Two distinct UI kits that are good candidates for themes ](img/Figure_11.8_B17473.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 两个适合作为主题的独立UI套件](img/Figure_11.8_B17473.jpg)'
- en: Figure 11.8 – Two distinct UI kits that are good candidates for themes
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 两个适合作为主题的独立UI套件
- en: Since we have already seen how to change the look and feel of three types of
    nodes, **Button**, **Panel**, and **Label**, we’ll focus on other types of **Control**
    nodes. We’ll accomplish this in the context of creating a new theme.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了如何更改三种类型节点的外观和感觉，即**按钮**、**面板**和**标签**，我们将专注于其他类型的**控件**节点。我们将在创建新主题的上下文中完成此操作。
- en: Creating a new theme
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的主题
- en: Since game development is an iterative process, planning every single thing
    ahead of time may not always be possible, and even be fruitless. That’s why it’s
    typical if you start by changing the UI nodes manually. Still, starting with a
    new theme and changing the properties of this theme may also be a good idea. Why?
    Because if your experiments for individually modifying the components yield a
    successful result, you won’t have to repeat what you have done in the theme. By
    creating a theme at the beginning, you’re building up as you go.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏开发是一个迭代的过程，提前规划每一件事可能并不总是可能的，甚至可能是徒劳的。这就是为什么您首先手动更改UI节点是典型的。然而，从一个新主题开始并更改此主题的属性也可能是一个好主意。为什么？因为如果您的单独修改组件的实验取得了成功的结果，您就不必在主题中重复您所做的工作。通过在开始时创建主题，您在前进的过程中构建起来。
- en: 'Also, creating a theme is like creating any other type of resource in Godot.
    We can do this by following a few simple steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建主题就像在Godot中创建任何其他类型的资源一样。我们可以通过遵循几个简单的步骤来完成此操作：
- en: Right-click the `UI` folder in the `Themes` as its name.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“主题”中的“UI”文件夹上右键单击，并更改其名称。
- en: Right-click `Themes` in **FileSystem** and select the **New Resource** option.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**FileSystem**中右键单击`Themes`并选择**新建资源**选项。
- en: Choose `Dark.tres`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Dark.tres`。
- en: This will create a **Theme** resource in your project. It should also enable
    a new panel in the bottom area that will show the preview of this new theme. As
    you make changes to your theme, updates can be previewed in this area since it
    might be faster to monitor your progress this way rather than adding and removing
    test components to/from your scene.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的项目中创建一个**主题**资源。它还应该在下侧区域启用一个新面板，该面板将显示此新主题的预览。当您对主题进行更改时，可以在该区域预览更新，因为这种方式可能比在场景中添加和删除测试组件更快地监控您的进度。
- en: 'If the preview area looks small, it’s possible to enlarge it by clicking an
    icon next to Godot’s version number. This icon will look like two upward-facing
    arrows with a horizontal line above them. Press that and the theme preview will
    occupy the viewport. In the end, your editor will look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预览区域看起来很小，可以通过点击Godot版本号旁边的图标来将其放大。这个图标看起来像两个向上的箭头，上面有一条水平线。按下它，主题预览将占据视口。最后，您的编辑器将看起来如下：
- en: '![Figure 11.9 – The theme preview has been expanded ](img/Figure_11.9_B17473.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 主题预览已展开](img/Figure_11.9_B17473.jpg)'
- en: Figure 11.9 – The theme preview has been expanded
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 主题预览已扩展
- en: By the way, the preview area is not static. You can interact with those UI components.
    It’s like a Godot scene running inside Godot. Now, we will modify the theme for
    the **CheckButton**, **CheckBox**, and **VSlider** components. We’ll also show
    a special state of the **CheckBox** node, also known as a radio button, in web
    development. However, our first candidate is **CheckButton**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，预览区域不是静态的。您可以与这些 UI 组件进行交互。就像一个在 Godot 中运行的 Godot 场景。现在，我们将修改 **CheckButton**、**CheckBox**
    和 **VSlider** 组件的主题。我们还将展示 **CheckBox** 节点的特殊状态，在网页开发中也称为单选按钮。然而，我们的首选候选者是 **CheckButton**。
- en: Styling a CheckButton
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 CheckButton 的样式
- en: The graphics assets we’ll be using to construct the new theme is the *Dark UI
    Kit*, which you can find at [https://365psd.com/psd/dark-ui-kit-psd-54778](https://365psd.com/psd/dark-ui-kit-psd-54778).
    We’ve already exported the necessary parts into the `UI` folder for you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来构建新主题的图形资源是 *Dark UI Kit*，您可以在 [https://365psd.com/psd/dark-ui-kit-psd-54778](https://365psd.com/psd/dark-ui-kit-psd-54778)
    找到。我们已经将必要的部分导出到 `UI` 文件夹中供您使用。
- en: 'The theme we created is still the default theme, so it still shows the default
    components. We’ll have to pick the one we would like to change. This is how we
    do it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的主题仍然是默认主题，因此它仍然显示默认组件。我们将选择我们想要更改的一个。这是如何操作的：
- en: Press the button with the plus (**+**) icon in it. This is in between the **Manage
    Items** and **Override All** buttons in the top-right corner of the **Theme**
    preview area.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下带有 **+** 图标的按钮。这个按钮位于 **主题** 预览区域右上角的 **管理项目** 和 **覆盖所有** 按钮之间。
- en: Select **CheckButton** in the upcoming pop-up menu. By doing this, you will
    see a list of this component’s relevant properties separated by tabs on the right-hand
    side of the theme preview.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在即将出现的弹出菜单中选择 **CheckButton**。通过这样做，您将在主题预览的右侧看到通过选项卡分隔的此组件的相关属性列表。
- en: Switch to the fourth tab, which looks like a polaroid icon with a mountain in
    it. Press the plus (**+**) icons for the **off** and **on** properties.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到第四个标签页，它看起来像带有山形的宝丽来图标。按下 **+** 图标为 **关闭** 和 **开启** 属性。
- en: From the `dark-ui-checkbutton-off.png` to the *off* slot and, similarly, drag
    `dark-ui-checkbutton-on.png` to the *on* slot.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `dark-ui-checkbutton-off.png` 到 **关闭** 插槽，以及类似地，将 `dark-ui-checkbutton-on.png`
    拖动到 **开启** 插槽。
- en: Interact with **CheckButton** in the theme’s preview.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主题预览中与 **CheckButton** 进行交互。
- en: 'This will effectively change the look of **CheckButton**. Your **Theme** panel
    will look as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效地改变 **CheckButton** 的外观。您的 **主题** 面板将如下所示：
- en: '![Figure 11.10 – We have changed the look of the CheckButton component with
    custom assets ](img/Figure_11.10_B17473.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 我们已使用自定义资源更改了 CheckButton 组件的外观](img/Figure_11.10_B17473.jpg)'
- en: Figure 11.10 – We have changed the look of the CheckButton component with custom
    assets
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 我们已使用自定义资源更改了 CheckButton 组件的外观
- en: '**CheckButton** is a simple component with two main states: on and off. We
    were not interested in altering the disabled versions of its two states, simply
    because the UI kit does not have the assets for that permutation. If you think
    you’ll never have this component in a disabled state, then you don’t have to create
    and assign art either.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**CheckButton** 是一个具有两个主要状态的简单组件：开启和关闭。我们对其两种状态的禁用版本不感兴趣，仅仅是因为 UI 套件没有为这种排列提供资源。如果您认为您永远不会在这个组件处于禁用状态，那么您也不必创建和分配艺术作品。'
- en: Let’s attack a different component this time. Although its name is similar,
    and it comes with states similar to **CheckButton**, a somewhat disguised property
    of this node makes it function as two distinct components. Enter **CheckBox**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这次让我们攻击一个不同的组件。尽管它的名字相似，并且它具有与 **CheckButton** 相似的状态，但这个节点的一个隐蔽属性使其作为两个不同的组件工作。进入
    **CheckBox**。
- en: Changing a CheckBox and discovering radio buttons
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改 CheckBox 并发现单选按钮
- en: 'This is going to be a similar effort, but we’ll utilize more assets and fill
    out more properties. Let’s keep the momentum going and add a new item to the theme:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个类似的工作，但我们将利用更多的资源并填写更多的属性。让我们保持势头，并为主题添加一个新项目：
- en: Using the plus (**+**) icon button again, choose **CheckBox** from the upcoming
    item list.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用带有 **+** 图标按钮，从即将出现的项目列表中选择 **CheckBox**。
- en: 'The fourth tab may still be active. If not, switch to it and do the following:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个标签页可能仍然处于活动状态。如果不是，切换到它并执行以下操作：
- en: Assign `dark-ui-checkbox-off.png` to the **unchecked** property.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dark-ui-checkbox-off.png` 分配给 **未选中** 属性。
- en: Assign `dark-ui-checkbox-on.png` to the **checked** property.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dark-ui-checkbox-on.png` 分配给 **选中** 属性。
- en: Assign `dark-ui-radio-off.png` to the **radio_unchecked** property.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dark-ui-radio-off.png` 分配给 **radio_unchecked** 属性。
- en: Assign `dark-ui-radio-on.png` to the **radio_checked** property.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dark-ui-radio-on.png` 分配给 **radio_checked** 属性。
- en: 'When you prepare your assets, pick filenames that are close enough to the state
    the assets will be assigned to. So, associating these files between the **FileSystem**
    and **Theme** panels would feel easy. After making these changes, this is what
    we have:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备你的资产时，选择与资产将被分配到的状态足够接近的文件名。因此，在 **文件系统** 和 **主题** 面板之间关联这些文件会感觉很容易。在做出这些更改后，这就是我们得到的结果：
- en: '![Figure 11.11 – CheckBox is the latest item we have customized for our Dark
    theme ](img/Figure_11.11_B17473.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – CheckBox 是我们为暗色主题定制的最新项目](img/Figure_11.11_B17473.jpg)'
- en: Figure 11.11 – CheckBox is the latest item we have customized for our Dark theme
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – CheckBox 是我们为暗色主题定制的最新项目
- en: The preview area has the **CheckBox** component for you to test, but no radio
    button. There is no **RadioButton** component in Godot. Despite adding the assets
    for it, we can’t simulate it yet. Nevertheless, we can tweak a **CheckBox** component
    so that it acts like a radio button.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 预览区域有 **CheckBox** 组件供你测试，但没有单选按钮。Godot 中没有 **RadioButton** 组件。尽管我们添加了它的资产，但我们还不能模拟它。尽管如此，我们可以调整一个
    **CheckBox** 组件，使其表现得像单选按钮。
- en: 'Since we need to physically place a `UI.tscn` scene:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要物理放置一个 `UI.tscn` 场景：
- en: Turn the visibility off for the **Panel** node by clicking its eye icon in the
    **Scene** panel.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **场景** 面板中点击其眼睛图标来关闭 **面板** 节点的可见性。
- en: 'Select the root node, then add an **HBoxContainer** node. Select this new node
    right away so that you can do the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择根节点，然后添加一个 **HBoxContainer** 节点。立即选择这个新节点，以便你可以执行以下操作：
- en: Add a **VBoxContainer**, **VSeparator**, and another **VBoxContainer** to it.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向它添加一个 **VBoxContainer**、**VSeparator** 和另一个 **VBoxContainer**。
- en: Add two **CheckBox** nodes inside these two **VBoxContainer** nodes.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个 **VBoxContainer** 节点内部添加两个 **CheckBox** 节点。
- en: For the first two `Multiple Choice 1` and `Multiple Choice 2`, respectively.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个两个 `Multiple Choice 1` 和 `Multiple Choice 2`。
- en: For the last two `Single Choice 1` and `Single Choice 2`, respectively.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后的两个 `Single Choice 1` 和 `Single Choice 2`。
- en: 'We’re not done yet, but the following screenshot shows what’s happened so far:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，但下面的截图显示了到目前为止发生的情况：
- en: '![Figure 11.12 – Four checkboxes organized in a questionnaire fashion ](img/Figure_11.12_B17473.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 以问卷形式组织的四个复选框](img/Figure_11.12_B17473.jpg)'
- en: Figure 11.12 – Four checkboxes organized in a questionnaire fashion
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 以问卷形式组织的四个复选框
- en: 'We are a few steps closer to turning two of those checkboxes into radio buttons
    – specifically, the last two since we gave them some text that mentions a single
    choice. Thus, while you have **CheckBox2** in the **VboxContainer2** node selected,
    do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离将两个复选框转换为单选按钮又近了一步 - 特别是最后两个，因为我们给了它们一些提到单选的文本。因此，当你在 **VboxContainer2**
    节点中选择 **CheckBox2** 时，请执行以下操作：
- en: Assign a **New ButtonGroup** to its **Group** property in the **Inspector**
    panel.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 面板中将一个新的 **ButtonGroup** 分配给其 **Group** 属性。
- en: Click the down arrow in that **Group** slot to expand a dropdown menu and select
    **Copy**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击那个 **Group** 槽中的向下箭头以展开下拉菜单并选择 **复制**。
- en: Select the **Checkbox** node in **VBoxContainer2** and choose the **Paste**
    option by expanding its **Group** options. This will link the two checkboxes because
    they will be sharing the same button group.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **VBoxContainer2** 中选择 **Checkbox** 节点，并通过展开其 **Group** 选项选择 **粘贴** 选项。这将链接两个复选框，因为它们将共享相同的按钮组。
- en: 'You should notice a drastic change between the two sets of checkboxes. Whereas
    the first two still look like checkboxes, the last two have circular icons next
    to them, as shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会注意到两组复选框之间的巨大变化。前两个仍然看起来像复选框，而最后两个旁边有圆形图标，如下面的截图所示：
- en: '![Figure 11.13 – Two checkboxes have been converted into radio buttons ](img/Figure_11.13_B17473.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 两个复选框已被转换为单选按钮](img/Figure_11.13_B17473.jpg)'
- en: Figure 11.13 – Two checkboxes have been converted into radio buttons
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 两个复选框已被转换为单选按钮
- en: By sharing the same button group, checkboxes turn into radio buttons. In this
    exercise, it was sufficient to create and assign a generic **ButtonGroup** object.
    However, if you want to have a group of radio buttons in one area of your application,
    then another collection somewhere else that governs a different set of radio buttons,
    you may have to create named **ButtonGroup** objects and assign them accordingly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过共享相同的按钮组，复选框变成了单选按钮。在这个练习中，创建并分配一个通用的**ButtonGroup**对象就足够了。然而，如果你想在应用程序的一个区域创建一组单选按钮，而在另一个区域创建另一个控制不同单选按钮集合的集合，你可能需要创建命名的**ButtonGroup**对象并相应分配它们。
- en: We won’t cover that kind of scenario since we seem to be missing something more
    important that we have wanted for a while. Neither the checkboxes nor the radio
    buttons we worked so hard for are reflecting the artistic direction we defined
    in our theme. Let’s see how we can utilize our theme.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍这种场景，因为我们似乎遗漏了一些我们一直想要的重要东西。我们辛苦工作的复选框和单选按钮都没有反映出我们在主题中定义的艺术方向。让我们看看我们如何利用我们的主题。
- en: Attaching a theme
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加主题
- en: 'Previously, we mentioned that using themes would help you style components
    faster. It’s true, but we haven’t tested this claim yet. Since we’ve already prepared
    the styles for the checkboxes and radio buttons, all there is left to do is assign
    the theme to these components:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，使用主题可以帮助你更快地设计组件。这是真的，但我们还没有测试这个说法。因为我们已经为复选框和单选按钮准备了样式，所以剩下的只是将这些主题分配给这些组件：
- en: Select the **HBoxContainer** node in the **Scene** panel and expand the **Theme**
    section in the **Inspector** panel.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Scene**面板中选择**HBoxContainer**节点，并在**Inspector**面板中展开**Theme**部分。
- en: Drag `Dark.tres` from **FileSystem** to fill the empty **Theme** slot.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Dark.tres`从**FileSystem**拖动到空的**Theme**槽中。
- en: There you have it! We didn’t even have to select each component and assign the
    themes one by one. A higher-level structure such as **HBoxContainer** was enough
    to assign the theme to so that its children could use the relevant parts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们甚至不需要逐个选择每个组件并逐个分配主题。一个更高层次的结构，如**HBoxContainer**，就足够分配主题，以便其子组件可以使用相关部分。
- en: Do you see the real potential here? Assigning a theme to a root element will
    be enough most of the time. That being said, since each component can be assigned
    its own theme, but it doesn’t have to, you can have all sorts of permutations.
    In its simplest form, assigning a theme to a root node will be enough in most
    scenarios.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这里的真正潜力了吗？将主题分配给根元素在大多数情况下就足够了。话虽如此，由于每个组件都可以分配自己的主题，但不必这样做，你可以有各种各样的排列组合。在最简单的情况下，将主题分配给根节点在大多数场景中就足够了。
- en: So far, we’ve been styling relatively simple UI nodes, such as **CheckButton**
    and **CheckBox**. Maybe we could tackle another node that has a few moving parts,
    such as a **VSlider**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在设计相对简单的UI节点，例如**CheckButton**和**CheckBox**。也许我们可以处理具有一些移动部分的另一个节点，例如**VSlider**。
- en: Altering a vertical slider component
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改垂直滑动组件
- en: A vertical slider component, **VSlider**, is useful when you want to give your
    players an easy way to adjust the ratio or quantity of things, such as tradeable
    items during a game session, music volume, or the brightness level in the game’s
    settings. Likewise, you can use an **HSlider** node, which is the horizontal version,
    but both accomplish similar tasks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要为玩家提供一个简单的方式来调整比率或数量时，例如游戏会话中的可交易物品、音乐音量或游戏设置中的亮度级别时，垂直滑动组件**VSlider**非常有用。同样，你也可以使用水平版本的**HSlider**节点，但两者都完成类似的任务。
- en: 'Since we only have the graphic assets for a **VSlider**, we’ll only cover this
    styling. If you desire, it’s possible to convert the existing assets that are
    compatible with an **HSlider**. You’ll have to rotate each part 90 degrees and
    save them accordingly. To do so, you must follow these steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有**VSlider**的图形资产，所以我们只介绍这种样式的使用。如果你需要，可以将与**HSlider**兼容的现有资产转换过来。你需要将每个部分旋转90度并相应保存。为此，你必须遵循以下步骤：
- en: Add **VSeparator** and **VSlider** nodes to **HBoxContainer** in the **Scene**
    panel.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Scene**面板中将**VSeparator**和**VSlider**节点添加到**HBoxContainer**中。
- en: Using the `75` for the **Value** property for **VSlider**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**VSlider**的**Value**属性使用`75`。
- en: Double-click `Dark.tres` in **FileSystem** to bring up its details. Add **VSlider**
    as a new type using the good old button with the plus (**+**) icon.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**FileSystem**中双击`Dark.tres`以显示其详细信息。使用带有加号（**+**）图标的老式按钮将**VSlider**添加为新类型。
- en: Activate the fourth tab in this new type’s custom properties and assign `dark-ui-vslider-grabber.png`
    to both **grabber** and **grabber_highlight**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种新类型的自定义属性中激活第四个标签，并将 `dark-ui-vslider-grabber.png` 分配给 **grabber** 和 **grabber_highlight**。
- en: Switch to the fifth tab, which looks like a square rainbow.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到第五个标签，它看起来像一条彩虹方块。
- en: Attach a `dark-ui-vslider-grabber-area.png` to the **Texture** property.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dark-ui-vslider-grabber-area.png` 添加到 **Texture** 属性。
- en: Expand the `6` for the **Bottom** property.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Bottom** 属性的 `6` 展开。
- en: Bring up the theme preview again by double-clicking `Dark.tres` or switching
    to the **Theme** panel at the bottom.*   Instead of repeating the same effort
    for the **grabber_area_highlight** property, click the plus (**+**) button near
    its slot, then grab and drop the **grabber_area** property’s style onto the **grabber_area_highlight**
    slot. Alternatively, you can copy the slot from **grabber_area** and paste it
    into **grabber_area_highlight** using the dropdown menus.*   Attach a `dark-ui-vslider-slider.png`
    to the **Texture** property.*   Expand the `6` for the **Bottom** and **Top**
    properties.*   Make the `1` for all its properties.*   Press *F6* and admire your
    hard work.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过双击 `Dark.tres` 或切换到底部的 **Theme** 面板来再次打开主题预览。*   为了避免对 **grabber_area_highlight**
    属性重复同样的努力，点击其槽附近的加号（**+**），然后抓取并放下 **grabber_area** 属性的样式到 **grabber_area_highlight**
    槽。或者，你可以使用下拉菜单从 **grabber_area** 复制槽并将其粘贴到 **grabber_area_highlight**。*   将 `dark-ui-vslider-slider.png`
    添加到 **Texture** 属性。*   将 **Bottom** 和 **Top** 属性的 `6` 展开。*   将所有属性的 `1` 设置为 `1`。*   按
    *F6* 并欣赏你的辛勤工作。
- en: We took many steps here, but there were only one or two new things. First, we
    repurposed one of the styles to be used for a different property by dragging and
    dropping it. This is a shortcut method instead of copying and pasting between
    slots. It’s useful when both slots are near each other. If you are copying elements
    where the slots are on different panels, then you still have to resort to the
    copy and paste method in dropdown menus.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们走了很多步，但只有一两个新事物。首先，我们通过拖放将一种样式重新用于不同的属性。这是一个快捷方法，而不是在槽之间复制和粘贴。当两个槽都靠近时很有用。如果你正在复制槽在不同面板上的元素，那么你仍然必须求助于下拉菜单中的复制和粘贴方法。
- en: 'Secondly, we adjusted a different type of margin, **Expand Margin**. The slider
    has two separate parts that constitute its track where the scrolling occurs, so
    we had to adjust this special margin so that it fits the blue part inside the
    outer part. Take a look at the following screenshot; you will see that there is
    a blue filler under the grabber inside the track of **VSlider**:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们调整了不同类型的边距，**Expand Margin**。滑块有两个独立的组成部分构成了其轨道，滚动就发生在这里，因此我们必须调整这个特殊的边距，使其适合外部的蓝色部分。看看下面的截图，你将看到在
    **VSlider** 的轨道内有一个蓝色填充物：
- en: '![Figure 11.14 – It took a few more steps but the VSlider component has been
    thematized ](img/Figure_11.14_B17473.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 经过几步之后，VSlider 组件已经主题化](img/Figure_11.14_B17473.jpg)'
- en: Figure 11.14 – It took a few more steps but the VSlider component has been thematized
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 经过几步之后，VSlider 组件已经主题化
- en: It’s easier to see the effect live than reading it. So, when you launch the
    `UI.tscn` scene, try to interact with the grabber and see how the component fills
    its track with blue, depending on the position of the grabber.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 活动地看到效果比阅读它更容易。所以，当你启动 `UI.tscn` 场景时，尝试与抓取器交互，看看组件如何根据抓取器的位置用蓝色填充其轨道。
- en: Wrapping up
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This concludes our work in setting up a theme. Although we have styled only
    a handful of nodes, feel free to practice with the rest of the same UI kit or
    pick another one from the website to try it on other **Control** nodes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们设置主题的工作。尽管我们只对少数节点进行了样式化，但你可以自由地使用相同的 UI 套件的其他部分，或者从网站上选择另一个来尝试其他 **Control**
    节点。
- en: All in all, working with themes or individually styling components entails two
    things. Primarily, you can either assign textures directly to some of the properties
    or indirectly into the appropriate slot by creating a **StyleBoxTexture**. Secondly,
    there are some numerical properties you can tweak. We haven’t covered this latter
    case. For example, you can adjust the line height of components that deal with
    text rendering. These cases are easy to comprehend and test. So, we opted to show
    you more head-scratching cases.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，使用主题或单独设计组件涉及两个方面。首先，你可以直接将纹理分配给某些属性，或者通过创建**StyleBoxTexture**间接分配到适当的槽位。其次，还有一些数值属性你可以调整。我们还没有涵盖这个后者。例如，你可以调整处理文本渲染的组件的行高。这些情况容易理解并测试。因此，我们选择展示更多令人头疼的情况。
- en: Hopefully, by practicing what we have shown so far and discovering more on your
    own, you will be able to apply beautiful graphic designs to your game.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过实践我们迄今为止所展示的内容，并自己发现更多，你将能够将美丽的图形设计应用到你的游戏中。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by debating what UIs are. We did this via a brief philosophical
    and theoretical explanation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以辩论UI是什么开始本章。我们通过简短的哲学和理论解释来完成这项工作。
- en: Assuming your games will require UIs, we investigated a practical use case such
    as constructing a note left by Clara’s uncle. This work necessitated us to work
    with multiple **Control** nodes – that is, the **Button**, **Panel**, and **Label**
    nodes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的游戏需要UI，我们研究了构建Clara叔叔留下的笔记这样的实际用例。这项工作需要我们与多个**Control**节点一起工作——即**按钮**、**面板**和**标签**节点。
- en: During this effort, not only did we employ the components we needed, but we
    also styled them to match a specific artistic style.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们不仅使用了所需的组件，还根据特定的艺术风格对它们进行了设计。
- en: For the sake of not repeating ourselves and taking the styling to the next level,
    we presented how using themes might be a time saver. To that end, we showed you
    how to utilize UI kits you could find online by assigning these kits’ individually
    exported graphics assets to the properties of **Control** nodes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复并提升设计的层次，我们展示了如何使用主题可能是一个节省时间的方法。为此，我们展示了如何通过将这些工具包单独导出的图形资产分配给**Control**节点的属性来利用你可以在网上找到的UI工具包。
- en: UIs are, in a way, a tool for the player to interact with the game. That being
    said, in the next chapter, we’ll discover a more direct way to interact with the
    game world without the help of UIs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: UI在某种程度上是玩家与游戏互动的工具。话虽如此，在下一章中，我们将发现一种无需UI帮助即可更直接地与游戏世界互动的方法。
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In the introduction, we talked about when a UI is necessary. However, there
    are situations when the best interface is no interface at all. There is an app
    – sorry, a book – for that by *Golden Krishna*: *The Best Interface Is No Interface:
    The simple path to brilliant technology*. He talks about how introducing more
    steps and elements disguised as a UI is nothing but interference.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们讨论了何时需要UI。然而，有些情况下，最好的界面根本不是界面。有一个应用——抱歉，是一本书——由*Golden Krishna*所著：*《最佳界面无界面：通往卓越技术的简单路径*》。他谈论了引入更多步骤和元素作为UI伪装的干扰。
- en: 'We’ve already discussed the possibility of having games without a UI, but we’ll
    rest that argument for now. It might be better for you to be exposed to as much
    information and examples as possible at this point. So, the following are a few
    technical and practical resources:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了没有UI的游戏的可能性，但现在我们将暂停这个论点。在这个阶段，让你尽可能多地接触信息和示例可能更好。因此，以下是一些技术和实际资源：
- en: '[https://www.toptal.com/designers/gui/game-ui](https://www.toptal.com/designers/gui/game-ui)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[游戏UI设计资源](https://www.toptal.com/designers/gui/game-ui)'
- en: '[https://webdesign.tutsplus.com/articles/figma-ui-kits-for-designers--cms-35706](https://webdesign.tutsplus.com/articles/figma-ui-kits-for-designers--cms-35706)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Figma UI工具包设计者指南](https://webdesign.tutsplus.com/articles/figma-ui-kits-for-designers--cms-35706)'
- en: '[https://ilikeinterfaces.com/](https://ilikeinterfaces.com/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[界面设计灵感](https://ilikeinterfaces.com/)'
- en: '[https://www.gameuidatabase.com/](https://www.gameuidatabase.com/)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[游戏UI数据库](https://www.gameuidatabase.com/)'
- en: This chapter also showed you how to assign fonts to components. There are a
    lot of freely available fonts out there but be careful and read their licenses.
    They might be downloadable but some of them can’t be used in commercial work.
    The same kind of warning goes for anything else too, especially graphics assets.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向您展示了如何为组件分配字体。市面上有很多免费字体可供选择，但请注意仔细阅读它们的许可协议。虽然它们可能可以下载，但其中一些不能用于商业作品。对于其他任何东西也是如此，尤其是图形资产。
