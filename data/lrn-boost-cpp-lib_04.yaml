- en: Chapter 4. Working with Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。处理字符串
- en: Text data is the most important and pervasive form of data that modern applications
    deal with. The ability to process text data efficiently through intuitive abstractions
    is a key marker of effectiveness in dealing with text data. Boost has a number
    of libraries dedicated toward effective text processing that enhance and extend
    the capabilities provided by the C++ Standard Library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文本数据是现代应用程序处理的最重要和普遍的数据形式。通过直观的抽象有效地处理文本数据的能力是处理文本数据有效性的关键标志。Boost有许多专门用于有效文本处理的库，增强和扩展了C++标准库提供的功能。
- en: 'In this chapter, we will look at three key Boost libraries for processing text
    data. We will start with the Boost String Algorithms library, a library of general-purpose
    algorithms for text data that provides a host of easy text operations, often missed
    in the Standard Library. We will then look at the Boost Tokenizer library, an
    extensible framework for tokenizing string data based on various criteria. Thereafter,
    we will examine a regular expression library for searching and parsing strings,
    Boost.Regex, which has been included in the C++11 standard as well. The following
    topics appear in the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍三个用于处理文本数据的关键Boost库。我们将从Boost String Algorithms库开始，这是一个通用文本数据算法库，提供了大量易于使用的文本操作，通常在标准库中被忽略。然后我们将介绍Boost
    Tokenizer库，这是一个基于各种标准对字符串数据进行标记的可扩展框架。之后，我们将研究一个用于搜索和解析字符串的正则表达式库Boost.Regex，它也已经包含在C++11标准中。以下主题将出现在以下各节中：
- en: Text processing with Boost String Algorithms library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost String Algorithms库进行文本处理
- en: Splitting text using the Boost Tokenizer library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost Tokenizer库拆分文本
- en: Regular expressions with Boost.Regex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost.Regex进行正则表达式
- en: This chapter should help you get a good grasp of text processing techniques
    available in the Boost libraries. We do not deal with internationalization issues
    in this book, but most of the concepts discussed in this chapter will apply to
    text in languages with writing systems based on non-Latin character sets.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应该帮助您充分掌握Boost库中可用的文本处理技术。本书不涉及国际化问题，但本章讨论的大部分概念将适用于基于非拉丁字符集的书写系统的语言中的文本。
- en: Text processing with Boost String Algorithms library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost String Algorithms库进行文本处理
- en: 'Text data is commonly represented as a sequence or *string* of characters laid
    out contiguously in memory and terminated by a special marker (the null terminator).
    While the actual data type used to represent a character can vary case by case,
    the C++ Standard Library abstracts the string concept in the class template `std::basic_string`,
    which takes the character data type as a parameter. The `std::basic_string` template
    takes three type parameters:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文本数据通常表示为内存中连续布置的字符序列或*字符串*，并以特殊标记（空终止符）终止。虽然用于表示字符的实际数据类型可能因情况而异，但C++标准库在类模板`std::basic_string`中抽象了字符串概念，该模板将字符数据类型作为参数。`std::basic_string`模板有三个类型参数：
- en: The character type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类型
- en: Some of the intrinsic properties and behaviors of the character type encapsulated
    in a traits class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装在特征类中的字符类型的一些固有属性和行为
- en: An allocator type that is used to allocate the internal data structures for
    `std::basic_string`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于为`std::basic_string`分配内部数据结构的分配器类型
- en: 'The traits and allocator parameters are defaulted, as shown in the following
    snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 特征和分配器参数被默认设置，如下面的片段所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The C++03 Standard Library also provides two specializations of `std::basic_string`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++03标准库还提供了`std::basic_string`的两个特化：
- en: '`std::string` for narrow characters (8-bit `char`)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string` 用于窄字符（8位 `char`）'
- en: '`std::wstring` for wide characters (16- or 32-bit `wchar_t`)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::wstring` 用于宽字符（16位或32位 `wchar_t`）'
- en: 'In C++11, we have two more:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，我们还有两个：
- en: '`std::u16string` (for `u16char_t`)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::u16string`（用于`u16char_t`）'
- en: '`std::u32string` (for `u32char_t`)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::u32string`（用于`u32char_t`）'
- en: In addition to these classes, plain old C-style strings, which are just arrays
    of `char` or `wchar_t` terminated by a null character, are also quite commonly
    used, especially in legacy C++ code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些类，纯旧的C风格字符串，即由空字符终止的`char`或`wchar_t`数组，也是相当常用的，特别是在传统的C++代码中。
- en: There are two major shortcomings in the Standard Library, which makes dealing
    with text data types overly tedious at times. For one, there is only a limited
    set of readily available algorithms that can be applied to `string` and `wstring`.
    Moreover, most of these algorithms are member functions of `std::basic_string`
    and are not applicable to other string representations like character arrays.
    Even the algorithms available as non-member function templates deal in iterators
    rather than containers, making the code tedious and less flexible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中存在两个主要缺陷，使得处理文本数据类型有时过于繁琐。首先，只有一组有限的可用算法可以应用于`string`和`wstring`。此外，大多数这些算法都是`std::basic_string`的成员函数，不适用于其他字符串表示形式，如字符数组。即使作为非成员函数模板可用的算法也处理迭代器而不是容器，使得代码繁琐且不够灵活。
- en: 'Consider how you would convert a string to its uppercase using the C++ Standard
    library:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下如何使用C++标准库将字符串转换为大写：
- en: '**Listing 4.1: Changing a string to uppercase using std::transform**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.1：使用std::transform将字符串更改为大写**'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the `std::transform` algorithm to convert a sequence of characters to
    their uppercase forms, using the `toupper` function from the Standard Library
    applied to each character (lines 8-9). The sequence of characters to transform
    is specified by a pair of iterators to the first character of the string `song`
    (`song.begin()`) and one past its last character (`song.end()`)—passed as the
    first two arguments to `std::transform`. The transformed sequence is written back
    in-place starting at `song.begin()`, which is the third argument to `std::transform`.
    You may not see a lot amiss if you have programmed in C++ for a while, but the
    generality of the `transform` function somewhat obscures the expression of intent.
    This is where Boost String Algorithms library helps by providing a slew of useful
    string algorithm function templates that are intuitively named and work effectively,
    sometimes even on different string abstractions. Consider the following alternative
    to the preceding code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`std::transform`算法将一系列字符转换为它们的大写形式，使用标准库中的`toupper`函数应用于每个字符（第8-9行）。要转换的字符序列由一对迭代器指定，指向字符串“song”的第一个字符（`song.begin()`）和最后一个字符的下一个位置（`song.end()`）——作为`std::transform`的前两个参数传递。转换后的序列被就地写回，从`song.begin()`开始，这是`std::transform`的第三个参数。如果您已经在C++中编程了一段时间，可能不会看到太多问题，但是`transform`函数的普遍性有些掩盖了意图的表达。这就是Boost
    String Algorithms库的作用，它通过提供一系列有用的字符串算法函数模板来帮助，这些函数模板具有直观的命名并且有效地工作，有时甚至可以在不同的字符串抽象上使用。考虑以下替代前面代码的方法：
- en: '**Listing 4.2: Changing a string to uppercase using boost::to_upper**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4.2：使用boost::to_upper将字符串转换为大写
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To convert the string `song` to uppercase, you call `boost::to_upper(song)`
    (line 8). We include the header `boost/algorithm/string.hpp` (line 2) to access
    `boost::to_upper`, which is an algorithm function template from Boost String Algorithms
    library. It is named `to_upper`, not `transform`, and takes just one argument
    instead of four and no iterators—what''s not to like? Also, you can run the same
    code on bare arrays:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串“song”转换为大写，可以调用`boost::to_upper(song)`（第8行）。我们包含头文件`boost/algorithm/string.hpp`（第2行）来访问`boost::to_upper`，它是来自Boost
    String Algorithms库的算法函数模板。它被命名为`to_upper`，而不是`transform`，只需要一个参数而不是四个，也没有迭代器——有什么不喜欢的呢？此外，您可以在裸数组上运行相同的代码：
- en: '**Listing 4.3: Changing a character array to uppercase using boost::to_upper**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4.3：使用boost::to_upper将字符数组转换为大写
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But iterators let you choose the range you want to transform to uppercase and
    here, we only seem to be able to apply anything to the whole string. Actually,
    that's not a problem either as we shall see.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是迭代器让您选择要转换为大写的范围，而在这里，我们似乎只能将任何东西应用于整个字符串。实际上，这也不是问题，我们将会看到。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Boost.Range**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost.Range**'
- en: The algorithms from Boost String Algorithms library actually work on abstractions
    called ranges, not containers or iterators. A **range** is just a sequence of
    elements that can be completely traversed in some order. Loosely speaking, a container
    like `std::string` is a sequence of contiguous single-byte characters and a container
    like `std::list<Foo>` is a sequence of elements of type `Foo`. Thus, they qualify
    as valid ranges.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Boost String Algorithms库中的算法实际上是在称为范围的抽象上工作，而不是在容器或迭代器上工作。一个**范围**只是一系列元素，可以以某种顺序完全遍历。粗略地说，像`std::string`这样的容器是一系列连续的单字节字符，而像`std::list<Foo>`这样的容器是类型为`Foo`的元素序列。因此，它们都符合有效的范围。
- en: A simple range can be represented by a pair of iterators—one pointing to the
    first element in the range, and the other pointing to one past the last element
    in the range. A range can represent the entire sequence of elements in a container.
    Generalizing further, a range can be described as a subsequence of a container,
    that is, a subset of the elements in the container with their relative ordering
    preserved. For example, the subsequence of elements of a container with odd-numbered
    indexes is a valid range. A single iterator pair may not be sufficient to represent
    such a range; we need more constructs to represent them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的范围可以由一对迭代器表示——一个指向范围中的第一个元素，另一个指向范围中最后一个元素的下一个元素。一个范围可以表示容器中所有元素的序列。进一步概括，范围可以被描述为容器的子序列，即容器中元素的子集，它们的相对顺序被保留。例如，容器中奇数索引的元素子序列是一个有效的范围。单个迭代器对可能不足以表示这样的范围；我们需要更多的构造来表示它们。
- en: The Boost.Range library provides the necessary abstractions and functions needed
    to generate and deal with all kinds of ranges. The class template `boost::iterator_range`
    is used to represent different kinds of ranges using a pair of iterators. The
    algorithms in Boost String Algorithms take parameters that are ranges and also
    return them, enabling chaining of calls, something that is not possible with most
    STL algorithms. We will not venture into too many details of Boost.Range in this
    chapter but will develop an intuitive understanding needed to use ranges with
    the String Algorithms library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Range库提供了生成和处理各种范围所需的必要抽象和函数。类模板`boost::iterator_range`用于使用一对迭代器表示不同类型的范围。Boost
    String Algorithms中的算法接受范围作为参数，并返回范围，从而实现调用的链接，这是大多数STL算法无法实现的。在本章中，我们不会深入讨论Boost.Range的细节，但会发展对使用String
    Algorithms库的范围所需的直观理解。
- en: 'If we want to transform the case of only a part of a string, we will need to
    construct a range representing that section. We can use the `boost::iterator_range`
    class template to generate arbitrary ranges. Here is how we do it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想转换字符串的一部分大小写，我们需要构造表示该部分的范围。我们可以使用`boost::iterator_range`类模板生成任意范围。下面是我们如何做到的：
- en: '**Listing 4.4: Changing a section of a string to uppercase using to_upper**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4.4：使用to_upper将字符串的一部分转换为大写
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Specifically, we want to construct the range using two iterators to a string.
    So, the type of the range will be `boost::iterator_range<std::string::iterator>`.
    We create a typedef for this rather long type name (lines 8-9). We wish to change
    the word `"sixties"` in the string `"Green-tinted sixties mind"` to uppercase.
    This word starts at index 13 of the string `song` and is seven characters long.
    So, the iterators that define the range containing `"sixties"` are `song.begin()
    + 13` and `song.begin() + 13 + 7`, that is, `song.begin() + 20`. The actual range
    (`range`) is constructed by passing these two iterators to the function template
    `boost::make_iterator_range` (lines 10-11). We pass this range to the `boost::to_upper`
    algorithm, which changes the case of the substring `"sixties"` (line 12), and
    we assert on the expected change (line 13).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们希望使用两个迭代器来构造字符串的范围。因此，范围的类型将是`boost::iterator_range<std::string::iterator>`。我们为这个相当长的类型名称创建了一个typedef（第8-9行）。我们希望将字符串`"Green-tinted
    sixties mind"`中的单词`"sixties"`更改为大写。这个单词从字符串`song`的索引13开始，长度为7个字符。因此，定义包含`"sixties"`的范围的迭代器是`song.begin()
    + 13`和`song.begin() + 13 + 7`，即`song.begin() + 20`。通过将这两个迭代器传递给函数模板`boost::make_iterator_range`（第10-11行）来构造实际范围（`range`）。我们将这个范围传递给`boost::to_upper`算法，它更改了子字符串`"sixties"`的大小写（第12行），并且我们断言预期的更改（第13行）。
- en: 'This may look like a lot of code but remember that you don''t have to construct
    an explicit range when you apply an algorithm to the whole string or container.
    Also, if you are using C++11, the `auto` keyword can help reduce verbosity; thus
    you can replace the highlighted lines (8-11) like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是很多代码，但请记住，当您将算法应用于整个字符串或容器时，您不必构造显式范围。此外，如果您使用C++11，`auto`关键字可以帮助减少冗长；因此，您可以像这样替换突出显示的行（8-11行）：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can learn more about the `auto` keyword in [Appendix](apa.html "Appendix A. C++11
    Language Features Emulation"), *C++11 Language Features Emulation*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[附录](apa.html "附录 A. C++11语言特性模拟")中了解有关`auto`关键字的更多信息，*C++11语言特性模拟*。
- en: 'Constructing iterator ranges from arrays is not all that different either:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组构造迭代器范围也并不完全不同：
- en: '**Listing 4.5: Changing a section of a char array to uppercase using to_upper**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.5：使用to_upper将char数组的一部分更改为大写**'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The range is defined to be of type `boost::iterator_range<char*>`, the type
    of the iterator for the array being `char*` (line 9). Once again, we can use `auto`
    to eliminate all the syntactic pain if we are on C++11\. We create the iterator
    range using the appropriate offsets (8 and 16), bounding the word `"Taliesyn"`
    (lines 10-11) and transform the range using `boost::to_upper` (line 12).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 范围被定义为`boost::iterator_range<char*>`类型，数组的迭代器类型为`char*`（第9行）。再次，如果我们使用C++11，我们可以使用`auto`来消除所有的语法痛苦。我们使用适当的偏移量（8和16）创建迭代器范围，限定单词`"Taliesyn"`（第10-11行），并使用`boost::to_upper`转换范围（第12行）。
- en: Using Boost String Algorithms
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost字符串算法
- en: In this section, we explore the various string algorithms available to us and
    understand the conditions under which they can be applied. Before we look at specific
    algorithms though, we will try to understand the general scheme of things first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨可用的各种字符串算法，并了解它们可以应用的条件。不过，在我们查看具体算法之前，我们将首先尝试了解事情的一般方案。
- en: 'Consider the algorithm `boost::contains`. It checks whether the string passed,
    as its second argument, is a substring of the string passed as its first argument:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑算法`boost::contains`。它检查作为第二个参数传递的字符串是否是作为第一个参数传递的字符串的子字符串：
- en: '**Listing 4.6: Using boost::contains**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.6：使用boost::contains**'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The algorithm `boost::contains` should return true because `"linearize"` contains
    the substring `"near"` (line 8). While this call to `boost::contains` returns
    true, had we set `test` to `"Near"` instead of `"near"`, it would return false.
    If we want to check for substrings without caring about the case, we have to use
    `boost::icontains` instead as a drop-in replacement for `boost::contains`. Like
    `boost::contains`, most algorithms from Boost String Algorithms have a case insensitive
    version with an `i-` prefix.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 算法`boost::contains`应该返回true，因为`"linearize"`包含子字符串`"near"`（第8行）。虽然调用`boost::contains`返回true，但如果我们将`test`设置为`"Near"`而不是`"near"`，它将返回false。如果我们想要检查子字符串而不关心大小写，我们必须使用`boost::icontains`作为`boost::contains`的替代品。与`boost::contains`一样，来自Boost字符串算法的大多数算法都有一个不区分大小写的版本，带有`i-`前缀。
- en: 'Unlike `boost::contains`, some string algorithms generate a modified string
    content based on the string passed to it. For example, `boost::to_lower` converts
    the string content passed to it to lowercase. It does so by changing the string
    in-place thus, modifying its argument. A non-mutating version of the algorithm
    called `boost::to_lower_copy` copies the passed string, transforms the case of
    the copied string, and returns it, without modifying the original string. Such
    non-mutating variants have the `_copy` suffix in their names. Here is a short
    example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与`boost::contains`不同，一些字符串算法根据传递给它的字符串生成修改后的字符串内容。例如，`boost::to_lower`将传递给它的字符串内容转换为小写。它通过就地更改字符串来实现这一点，从而修改其参数。算法的非变异版本称为`boost::to_lower_copy`，它复制传递的字符串，转换复制的字符串的大小写，并返回它，而不修改原始字符串。这样的非变异变体在其名称中具有`_copy`后缀。这里是一个简短的例子：
- en: '**Listing 4.7: Using _copy versions of Boost String Algorithms**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.7：使用_boost字符串算法的_copy版本**'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The string `str1` is first copied and converted to lowercase using the non-mutating
    variant `boost::to_lower_copy`, and the result is assigned to `str2` (line 7).
    At this point, `str1` remains unchanged. Next, `str1` is converted to lowercase
    in-place, using `boost::to_lower` (line 9). At this point, both `str1` and `str2`
    have the same content (line 10). In most of what follows, we will work with case-sensitive
    variants and mutating variants where applicable, with the understanding that the
    case-insensitive and non-mutating (copy) versions of the algorithms also exist.
    We now start look at specific algorithms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`str1`首先被复制并转换为小写，使用非变异变体`boost::to_lower_copy`，结果被赋给`str2`（第7行）。此时，`str1`保持不变。接下来，`str1`被就地转换为小写，使用`boost::to_lower`（第9行）。此时，`str1`和`str2`都具有相同的内容（第10行）。在接下来的大部分内容中，我们将使用区分大小写的变体和适用的变异变体，理解到算法的不区分大小写和非变异（复制）版本也存在。我们现在开始查看特定的算法。
- en: Find algorithms
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找算法
- en: There are several variants of *find algorithm* available from the Boost String
    Algorithms library, all of which search for a string or pattern in another input
    string. Each algorithm takes the input string and the search string as parameters,
    converts them to ranges, and then performs the search. Each find-variant returns
    the contiguous subsequence in the input, which matches the search string or pattern,
    as a range. An empty range is returned if no match was found.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从Boost String Algorithms库中有几种*find算法*的变体可用，所有这些算法都在另一个输入字符串中搜索字符串或模式。每个算法都将输入字符串和搜索字符串作为参数，将它们转换为范围，然后执行搜索。每个find变体都返回与搜索字符串或模式匹配的输入中的连续子序列作为范围。如果没有找到匹配项，则返回一个空范围。
- en: find_first
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find_first
- en: 'We start by looking at `boost::find_first`, which looks for a string in another
    string:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下`boost::find_first`，它在另一个字符串中查找一个字符串：
- en: '**Listing 4.8: Using boost::find_first**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.8：使用boost::find_first**'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have an array of strings we want to search for, called `needles` (line 8).
    We also have a C-style string called `haystack`, in which we want to look for
    the search strings which contains the text we want to search for (line 7). We
    loop through each string in `needles` and call the `boost::find_first` algorithm
    to look for it in `haystack` (line 11). We check whether the search failed to
    find a match (line 13). If a match was found, then we compute the offset in `haystack`
    where the match was found (line 18). The range `ret` defines a range of the input
    string `haystack`; hence, we can always perform offset computations like `ret.begin()
    – haystack`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个我们想要搜索的字符串数组，称为`needles`（第8行）。我们还有一个名为`haystack`的C风格字符串，在其中我们想要查找包含我们想要搜索的文本的搜索字符串（第7行）。我们循环遍历`needles`中的每个字符串，并调用`boost::find_first`算法在`haystack`中查找它（第11行）。我们检查搜索是否未能找到匹配项（第13行）。如果找到了匹配项，那么我们计算在`haystack`中找到匹配项的偏移量（第18行）。范围`ret`定义了输入字符串`haystack`的范围；因此，我们总是可以执行偏移计算，比如`ret.begin()
    - haystack`。
- en: The first iteration would be able to find `"little"`, while the second iteration
    would fail to find `"Little"` because `boost::find_first` is case-sensitive. If
    we used `boost::ifind_first` which performs case-insensitive search, then both
    would match.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次迭代将能够找到`"little"`，而第二次迭代将无法找到`"Little"`，因为`boost::find_first`是区分大小写的。如果我们使用`boost::ifind_first`执行不区分大小写的搜索，那么两者都会匹配。
- en: We use the C++11 `auto` keyword to escape writing an ungainly type for `ret`
    (line 11), but if we had to write, it would be `boost::iterator_range<char*>`.
    Note that we can actually stream the range `ret` returned from the algorithm to
    an output stream (line 22).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C++11的`auto`关键字来避免编写一个笨拙的`ret`类型（第11行），但如果我们不得不写，它将是`boost::iterator_range<char*>`。请注意，我们实际上可以将从算法返回的范围`ret`流式传输到输出流（第22行）。
- en: 'This example illustrates the technique on C-style character arrays but to apply
    it to `std::string` would require surprisingly little change. If `haystack` was
    a `std::string` instance, then the only change will be in the way we calculate
    offsets (line 18):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了在C风格字符数组上的技术，但将其应用到`std::string`将需要惊人地少的更改。如果`haystack`是一个`std::string`实例，那么唯一的变化将在我们计算偏移量的方式上（第18行）：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since `haystack` is not a character array but an `std::string`, the iterator
    to its start is obtained via a call to its `begin()` member function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`haystack`不是字符数组而是一个`std::string`，所以通过调用其`begin()`成员函数来获得其开始的迭代器。
- en: If we want to find the last instance of the search string in `haystack` instead
    of the first, we can replace `boost::find_first` with `boost::find_last`. If there
    are potentially multiple matching tokens, we may ask for a specific match by index.
    For this, we would need to call `boost::find_nth`, passing it a third argument,
    which would be a zero-based index of the match. We may pass a negative index to
    ask for matches from the end. Thus, passing `-1` would give us the last match,
    `-2` the second-last match, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到`haystack`中搜索字符串的最后一个实例，而不是第一个实例，我们可以用`boost::find_last`替换`boost::find_first`。如果可能有多个匹配的标记，我们可以通过索引要求特定的匹配。为此，我们需要调用`boost::find_nth`，传递第三个参数，这将是匹配的基于零的索引。我们可以传递负索引来要求从末尾匹配。因此，传递`-1`会给我们最后一个匹配，`-2`会给我们倒数第二个匹配，依此类推。
- en: find_all
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find_all
- en: 'To find all matching substrings in an input string, we must use `boost::find_all`
    and pass it a sequence container to put all the matched substrings into. Here
    is a short example of how to do it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要在输入字符串中找到所有匹配的子字符串，我们必须使用`boost::find_all`并将其传递给一个序列容器，以便将所有匹配的子字符串放入其中。以下是如何做的一个简短示例：
- en: '**Listing 4.9: Using boost::find_all to find all matching substrings**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.9：使用boost::find_all查找所有匹配的子字符串**'
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We first create a typedef `string_range` for the appropriate range type (lines
    8-9). The `boost::find_all` algorithm copies all the matching ranges into the
    vector of ranges, `matches` (line 14). We iterate over the vector `matches` using
    C++11's new **range-based for-loop** syntax (line 15), and print the offsets at
    which each match was found (line 17). The nifty range-based for-loop declares
    a loop variable `match` to iterate over successive elements of the container `matches`.
    Using the `auto` keyword, the type of `match` is automatically deduced based on
    the type of values contained in `matches`. Using a vector of ranges rather than
    a vector of strings, we are able to calculate the exact offsets in `str` at which
    the matches occur.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们为适当的范围类型创建一个typedef `string_range`（第8-9行）。`boost::find_all`算法将所有匹配的范围复制到范围的向量`matches`中（第14行）。我们使用C++11的新**基于范围的for循环**语法（第15行）遍历向量`matches`，并打印每个匹配被找到的偏移量（第17行）。巧妙的基于范围的for循环声明了一个循环变量`match`，用于迭代容器`matches`中的连续元素。使用`auto`关键字，`match`的类型会根据`matches`中包含的值的类型自动推断。使用范围的向量而不是字符串的向量，我们能够计算出匹配发生在`str`中的确切偏移量。
- en: find_token
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find_token
- en: One more interesting find algorithm is the `boost::find_token` algorithm. Using
    this algorithm, we can find substrings whose characters satisfy some predicate
    we specify. We can use a set of predefined predicates or define our own, although
    the latter approach requires a fair bit of work, and we will not attempt it in
    this book. In the next example, we search for hexadecimal numbers with four or
    more digits in a string. This will also illustrate how you can use functions to
    perform repeated searches.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的查找算法是`boost::find_token`算法。使用这个算法，我们可以找到满足我们指定的某些谓词的字符的子字符串。我们可以使用一组预定义的谓词或定义自己的谓词，尽管后一种方法需要相当多的工作，我们在本书中不会尝试这种方法。在下一个示例中，我们在字符串中搜索具有四个或更多位数的十六进制数字。这也将说明如何使用函数执行重复搜索。
- en: 'For this purpose, we use the `boost::is_xdigit` predicate, which returns true
    if a particular character passed to it is a valid hexadecimal character. Here
    is the sample code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用`boost::is_xdigit`谓词，如果传递给它的特定字符是有效的十六进制字符，则返回true。以下是示例代码：
- en: '**Listing 4.10: Finding substrings using boost::find_token and predicates**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.10：使用boost::find_token和谓词查找子字符串**'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The string `str` contains an interesting hexadecimal token (`0xbeeffed`). We
    pass `str` to `boost::find_token` along with an instance of the predicate `boost::is_xdigit`,
    which identifies valid hexadecimal digits (line 10). We indicate, using `boost::token_compress_on`,
    that contiguous matching characters should be concatenated (line 11); this option
    is turned off by default. The returned range `token` represents the currently
    matched substring. We loop as long as the returned range `token` is not empty,
    that is, `token.begin() != token.end()` (line 12), and print its contents if it
    is longer than 3 in length (line 13). Note the use of the function `boost::size`
    on `token`. This is one of several functions that can be used to compute properties
    of a range like its beginning and end iterators, size, and so on. Also, note that
    we can directly stream a range object like a token to an `ostream` object, such
    as `std::cout`, to print all the characters in the range (line 14).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`str`包含一个有趣的十六进制标记（`0xbeeffed`）。我们将`str`与谓词`boost::is_xdigit`的实例一起传递给`boost::find_token`，该谓词标识有效的十六进制数字（第10行）。我们使用`boost::token_compress_on`指示应该连接连续匹配的字符（第11行）；默认情况下，此选项是关闭的。返回的范围`token`表示当前匹配的子字符串。只要返回的范围`token`不为空，即`token.begin()
    != token.end()`（第12行），我们就循环并在其长度大于3时打印其内容（第13行）。请注意在`token`上使用`boost::size`函数。这是可以用于计算范围属性的几个函数之一，比如它的开始和结束迭代器、大小等等。另外，请注意我们可以直接将像标记这样的范围对象流式传输到`ostream`对象，比如`std::cout`，以打印范围中的所有字符（第14行）。
- en: In each iteration, we search the remaining string after the match using `find_token`.
    The remaining string is constructed as a range called `remnant` (lines 17-18).
    The beginning of `remnant` is `token.end()`, which is the first position after
    the last matching token. The end of remnant is simply the end of the string `str.end()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们使用`find_token`搜索匹配后的剩余字符串。剩余字符串被构造为一个名为`remnant`的范围（第17-18行）。`remnant`的开始是`token.end()`，即最后一个匹配标记之后的第一个位置。剩余部分的结束只是字符串`str.end()`的结束。
- en: iter_find
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iter_find
- en: 'Iterating through a string and finding all substrings matching some criterion
    is a common enough use case, and Boost provides an easier way to do this. By using
    `boost::iter_find` algorithm, passing it the input string, a finder functor, and
    a sequence container to hold the matched ranges, we can get the matching substrings
    back in the container passed. Here is the above example rewritten using `boost::iter_find`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字符串并找到所有满足某些条件的子字符串是一个常见的用例，Boost提供了一个更简单的方法来实现这一点。通过使用`boost::iter_find`算法，将输入字符串、查找器函数对象和一个序列容器传递给它以保存匹配的范围，我们可以在传递的容器中获取匹配的子字符串。以下是使用`boost::iter_find`重写的上面的示例：
- en: '**Listing 4.11: Using boost::iter_find with boost::token_finder**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.11：使用boost::iter_find和boost::token_finder**'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `boost::find_regex` algorithm can search a string for substrings that match
    a regular expression pattern. We will cover this algorithm when we deal with regular
    expressions using Boost.Regex, later in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::find_regex`算法可以搜索字符串中与正则表达式模式匹配的子字符串。我们将在本章后面处理使用Boost.Regex处理正则表达式时涵盖这个算法。'
- en: find
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find
- en: 'There is a generic `boost::find` algorithm in terms of which most of the other
    find algorithms are implemented. Using the available finder-functor templates,
    as part of the string algorithms library, or writing our own, we can make the
    generic `boost::find` string algorithm do a variety of search tasks for us. Here
    is an example of using the `boost::last_finder` functor with `boost::find` algorithm
    to find the last matching substring—exactly what `boost::ifind_last` does. The
    `boost::last_finder` functor and others like it take an optional predicate and
    can be used to influence how character comparisons are done. To simulate the case-insensitive
    comparisons that `ifind_last` does, we need to pass a predicate that compares
    two characters in a case-insensitive way. For this, we use the `boost::is_iequal`
    predicate:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个通用的`boost::find`算法，大多数其他查找算法都是基于它实现的。使用可用的查找器-函数对象模板，作为字符串算法库的一部分，或编写我们自己的模板，我们可以让通用的`boost::find`字符串算法为我们执行各种搜索任务。以下是使用`boost::last_finder`函数对象与`boost::find`算法来查找最后一个匹配子字符串的示例——这正是`boost::ifind_last`所做的。`boost::last_finder`函数对象和类似它的其他函数对象接受一个可选的谓词，并且可以用于影响字符比较的方式。为了模拟`ifind_last`所做的不区分大小写的比较，我们需要传递一个以不区分大小写方式比较两个字符的谓词。为此，我们使用`boost::is_iequal`谓词：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We call `boost::find` on `haystack` passing it the `boost::last_finder` functor.
    Since we want `last_finder` to perform case insensitive comparisons, we pass it
    an instance of the `boost::is_iequal` predicate. This works like `boost::ifind_last`
    and is essentially the way it is implemented. You can even pass your own predicates
    for character comparisons. Say you received an encoded message, where each character
    is shifted by 4, and it wraps around so that `a` is `e` and `z` is `d`. You can
    use the `equalsShift` functor in the following code to check whether a particular
    real word exists in the encoded text:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`haystack`上调用`boost::find`，传递`boost::last_finder`函数对象。由于我们希望`last_finder`执行不区分大小写的比较，因此我们传递了`boost::is_iequal`谓词的实例。这类似于`boost::ifind_last`，实际上就是它的实现方式。您甚至可以传递自己的字符比较谓词。假设您收到了一个编码消息，其中每个字符都向后移动了4个位置，并且环绕，因此`a`是`e`，`z`是`d`。您可以使用以下代码中的`equalsShift`函数对象来检查编码文本中是否存在特定的真实单词：
- en: '**Listing 4.12: Using custom predicates with Boost substring finders**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.12：使用Boost子字符串查找器的自定义谓词**'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Without decoding the whole string contained in the variable `encoded`, we want
    to find a substring of `encoded` that, when decoded would match the string contained
    in the variable `realWord`. In order to do this, we call `boost::find` with two
    arguments, the encoded input string called `encoded` and a predicate that returns
    `true` only if a matching substring is found (line 17-19).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在不解码变量`encoded`中包含的整个字符串的情况下，我们希望找到一个`encoded`的子字符串，解码后与变量`realWord`中包含的字符串匹配。为了做到这一点，我们调用`boost::find`，传递两个参数，编码输入字符串称为`encoded`，以及一个谓词，只有在找到匹配的子字符串时才返回`true`（第17-19行）。
- en: 'For the predicate, we construct a temporary class of type `boost::first_finder`,
    passing two arguments to its constructor: the word to look for is `realWord` and
    a binary predicate `EqualShift(4)`. The `EqualsShift` functor performs a case-insensitive
    comparison of two characters: one from the encoded input and one from the word
    to look up. It returns true if the first character is an encoding of the second
    character, according to the scheme of shifting by a fixed integer N, as described
    earlier (N=4 in our case).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于谓词，我们构造了一个临时类，类型为`boost::first_finder`，将两个参数传递给它的构造函数：要查找的单词是`realWord`，二进制谓词`EqualShift(4)`。`EqualsShift`函数对象执行两个字符的不区分大小写比较：一个来自编码输入，一个来自要查找的单词。如果第一个字符是根据固定整数N进行的编码的第二个字符，则返回true，如前面描述的（在我们的例子中N=4）。
- en: find_head and find_tail
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find_head和find_tail
- en: 'There are a few more *find* algorithms like `boost::find_head` and `boost::find_tail`,
    which could well have been named `prefix` and `suffix` for that is exactly what
    they do—carve out a prefix or suffix of a specified length from a string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些*find*算法，比如`boost::find_head`和`boost::find_tail`，它们本来可以被命名为`prefix`和`suffix`，因为它们确实是这样做的——从字符串中切出指定长度的前缀或后缀：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You call `find_head` with the input string and an offset. If the offset is a
    positive number `N`, `find_head` returns the first `N` characters in the input
    string or the whole string if `N` is larger than the size of the string. If the
    offset is a negative number `-N`, `find_head` returns the first `size - N` characters,
    where `size` represents the total number of characters in the string `run`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用输入字符串和偏移量调用`find_head`。如果偏移量是正数`N`，`find_head`返回输入字符串的前`N`个字符，如果`N`大于字符串的大小，则返回整个字符串。如果偏移量是负数`-N`，`find_head`返回前`size
    - N`个字符，其中`size`表示字符串`run`中的字符总数。
- en: You call `find_tail` with a string and an integer. When a positive integer `N`
    is passed, `find_tail` returns the last `N` characters of the input string or
    the whole string if `N` is larger than the size of the string. When a negative
    integer `-N` is passed, `find_tail` returns the last `size - N` characters in
    the string, where `size` represents the total number of characters in the string,
    an empty string if `N > size`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用字符串和整数调用`find_tail`。当传递正整数`N`时，`find_tail`返回输入字符串的最后`N`个字符，如果`N`大于字符串的大小，则返回整个字符串。当传递负整数`-N`时，`find_tail`返回字符串中的最后`size
    - N`个字符，其中`size`表示字符串中的字符总数，如果`N > size`，则返回空字符串。
- en: Other algorithms for testing string properties
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用于测试字符串属性的其他算法
- en: There exist several convenience functions, which make certain common operations
    very easy to code. Algorithms like `boost::starts_with` and `boost::ends_with`
    (and their case-insensitive variants), test whether a particular string is a prefix
    or suffix of another. To determine the dictionary order of two strings, you can
    use `boost::lexicographical_compare`. You can check for equality using `boost::equals`,
    and check whether a string is a substring of another using `boost::contains`.
    Corresponding case-insensitive variants exist for each of these functions, and
    the case-sensitive variants take an optional predicate for comparing characters.
    The Boost online documentation provides an adequately detailed listing of these
    functions and their behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些方便的函数，使得某些常见操作非常容易编码。像`boost::starts_with`和`boost::ends_with`（以及它们的不区分大小写的变体）这样的算法，测试特定字符串是否是另一个字符串的前缀或后缀。要确定两个字符串的字典顺序，可以使用`boost::lexicographical_compare`。您可以使用`boost::equals`检查相等性，并使用`boost::contains`检查一个字符串是否是另一个字符串的子字符串。每个函数都有相应的不区分大小写的变体，而区分大小写的变体则采用一个可选的谓词来比较字符。Boost在线文档提供了这些函数及其行为的充分详细的列表。
- en: Case-conversion and trimming algorithms
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小写转换和修剪算法
- en: Changing the case of a string or some part of it and trimming extra whitespace
    that is preceding or trailing a string are very common tasks, which take a bit
    of effort to be done using only the Standard Library. We have already seen `boost::to_upper`,
    `boost::to_lower`, and their copying versions for performing case changes in action.
    In this section, we will apply these algorithms to more interesting ranges and
    also look at trimming algorithms.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更改字符串或其部分的大小写，并修剪前导或尾随的额外空格是非常常见的任务，但仅使用标准库需要一些努力。我们已经看到了`boost::to_upper`、`boost::to_lower`以及它们的复制版本来执行大小写更改的操作。在本节中，我们将把这些算法应用于更有趣的范围，并且还将看看修剪算法。
- en: Case-conversion algorithms
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小写转换算法
- en: 'How does one convert alternate characters in a string to uppercase leaving
    the rest untouched? Since the `boost::to_upper` function takes a range, we need
    to somehow generate the range that contains alternate elements from the string.
    The way to do this is to use **range adaptors**. Boost Range library provides
    a number of adaptors that allow the generation of newer patterns of ranges from
    existing ones. The adaptor that we are looking for is the `strided` adaptor that
    allows traversing the range by skipping a fixed number of elements at each step.
    We need to skip just one element per step:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将字符串中的交替字符转换为大写，而其余部分保持不变？由于`boost::to_upper`函数接受一个范围，我们需要以某种方式生成包含字符串中交替元素的范围。这样做的方法是使用**范围适配器**。Boost
    Range库提供了许多适配器，允许从现有范围生成新的范围模式。我们正在寻找的适配器是`strided`适配器，它允许通过在每一步跳过固定数量的元素来遍历范围。我们只需要每步跳过一个元素：
- en: '**Listing 4.13: Generating non-contiguous ranges with Boost.Range adaptors**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.13：使用Boost.Range适配器生成非连续范围**'
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order to apply the `boost::to_upper` algorithm to the even-indexed characters,
    we first generate the correct range. The pipe operator (`operator |`) is overloaded
    to create an intuitive chaining syntax for adaptors, such as `strided`. Using
    the expression `str | strided(2)`, we are essentially applying the `strided` adaptor
    with an argument of `2` to the string `str` to get a range containing the even-indexed
    elements of `str` (line 11). Note that the `strided` adaptor always starts from
    the first character of the input.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`boost::to_upper`算法应用于偶数索引的字符，我们首先生成正确的范围。管道运算符(`operator |`)被重载以创建一个直观的链接语法，用于适配器，比如`strided`。使用表达式`str
    | strided(2)`，我们实质上是将`strided`适配器应用于字符串`str`，并使用参数`2`来获得包含`str`的偶数索引元素的范围（第11行）。注意，`strided`适配器总是从输入的第一个字符开始。
- en: 'The same effect can be achieved by writing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过编写以下内容来实现相同的效果：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I prefer the piped notation, as it seems a lot more expressive, especially when
    more adaptors need to be chained. Following the generation of this `range`, we
    apply `to_upper` to it (line 12) and expectedly, the even-index characters of
    `str` are transformed to uppercase (line 13).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用管道符号，因为它似乎更具表现力，特别是当需要链接更多的适配器时。在生成这个`range`之后，我们将`to_upper`应用于它（第12行），预期地，`str`的偶数索引字符被转换为大写（第13行）。
- en: If we want to perform the same operation, but on all the odd indexes, there
    is one problem we need to solve. The `strided` adaptor takes the number to skip
    between two elements as an argument but always starts from the first character
    of the input. To start from the element at index 1 instead of 0, we have to take
    a slice of the container starting at the element we intend to start from (index
    1 in this case), and then apply `strided` with an argument of `2`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对所有奇数索引执行相同的操作，那么我们需要解决一个问题。`strided`适配器以跳过两个元素之间的数字作为参数，但总是从输入的第一个字符开始。为了从索引1处开始而不是从0开始，我们必须从容器的元素（在这种情况下是索引1）开始取一个片段，然后应用参数为`2`的`strided`。
- en: 'To take the slice first, we use another adaptor, called `boost::adaptors::sliced`.
    It takes the indexes to the starting location and one past the ending location
    as arguments. In this case, we would like to start from index 1 and slice the
    rest of the container. So, we can write the entire expression like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先取片段，我们使用另一个适配器，称为`boost::adaptors::sliced`。它以起始位置和结束位置的索引作为参数。在这种情况下，我们想从索引1开始并切片容器的其余部分。因此，我们可以像这样写整个表达式：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Chaining adaptors in this way is a powerful way to generate ranges on the fly
    with a very readable syntax. The same techniques apply to C-style character arrays
    also.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式链接适配器是一种强大的方式，可以使用非常可读的语法即时生成范围。相同的技术也适用于C风格的字符数组。
- en: Trimming algorithms
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修剪算法
- en: 'For trimming strings, there are three main algorithms: `boost::trim_left` for
    trimming leading whitespace in a string, `boost::trim_right` for trimming trailing
    whitespace in a string, and `boost::trim` for trimming both. Trimming algorithms
    potentially change the length of the output. Each algorithm has an `_if` variant
    that takes a predicate, which is used to identify what characters to trim. For
    example, if you want to drop only trailing newlines from a string read from the
    console (a frequent chore), you may write an appropriate predicate to identify
    only newlines. Finally, there are copy variants of all these algorithms. If we
    wrote an expanded list of the available algorithms, there would be twelve of them;
    four for `trim_left`: `trim_left`, `trim_left_copy`, `trim_left_if`, and `trim_left_if_copy`;
    and similarly four for `trim_right` and `trim` each. Here is an example of performing
    trims on strings:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于修剪字符串，有三种主要的算法：`boost::trim_left`用于修剪字符串中的前导空白，`boost::trim_right`用于修剪字符串中的尾随空白，`boost::trim`用于修剪两者。修剪算法可能会改变输出的长度。每个算法都有一个带有谓词的`_if`变体，该谓词用于识别要修剪的字符。例如，如果您只想从从控制台读取的字符串中删除尾随换行符（经常需要这样做），您可以编写一个适当的谓词来仅识别换行符。最后，所有这些算法都有复制变体。如果我们列出可用算法的扩展列表，将会有十二种算法；`trim_left`有四种：`trim_left`、`trim_left_copy`、`trim_left_if`和`trim_left_if_copy`；`trim_right`和`trim`各有四种。以下是在字符串上执行修剪的示例：
- en: '**Listing 4.14: Using boost::trim and its variants**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.14：使用boost::trim及其变体**'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In listing 4.14, we have two strings: `input` with leading and trailing spaces
    (line 12), and `input2` with trailing spaces and a newline at the end (line 13).
    By applying `boost::trim` on the `input`, the leading and trailing spaces are
    trimmed (line 15). If we had applied `boost::trim_right` on `input2`, it would
    have removed all trailing whitespaces, including the spaces and the newline. We
    only wanted to drop the newline, not the spaces; so we wrote a predicate `isNewline`
    to help choose what needs to be trimmed. This technique can be used for non-whitespace
    characters too.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单4.14中，我们有两个字符串：`input`具有前导和尾随空格（第12行），`input2`具有尾随空格和末尾的换行符（第13行）。通过在`input`上应用`boost::trim`，前导和尾随空格被修剪（第15行）。如果我们在`input2`上应用`boost::trim_right`，它将删除所有尾随空格，包括空格和换行符。我们只想删除换行符，而不是空格；因此，我们编写了一个谓词`isNewline`来帮助选择需要修剪的内容。这种技术也可以用于非空白字符。
- en: These functions do not work on C-style arrays and the non-copy versions expect
    a member function called `erase`. They work with the `basic_string` specializations
    in the Standard Library, and other classes that provide an `erase` member function
    with similar interface and semantics.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数不适用于C风格数组，非复制版本期望一个名为`erase`的成员函数。它们适用于标准库中的`basic_string`特化，以及提供具有类似接口和语义的`erase`成员函数的其他类。
- en: The replace and erase algorithms
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换和删除算法
- en: The replace and erase algorithms are handy functions to perform search and replace
    operations on strings. The basic idea is to find one or more matches for a search
    string and replace the matches with a different string. Erase is a special case
    of replace, when we replace the matches with a null string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 替换和删除算法是在字符串上执行搜索和替换操作的便捷函数。基本思想是查找一个或多个与搜索字符串匹配的内容，并用不同的字符串替换匹配项。擦除是替换的一种特殊情况，当我们用空字符串替换匹配项时。
- en: 'These operations may change the length of the input when performed in-place
    because the matched content and its replacement may have different lengths. The
    core algorithm in the library is `boost::find_format` in terms of which all other
    algorithms are implemented. The algorithms `boost::replace_first`, `boost::replace_last`,
    `boost::replace_nth`, and `boost::replace_all` respectively replace the first,
    last, nth, or all matching occurrences of a search string in the input with an
    alternative string. The corresponding erase algorithms simply erase the matched
    sections. These algorithms do not work on C-style arrays:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可能会在原地执行时改变输入的长度，因为匹配的内容及其替换可能具有不同的长度。库中的核心算法是`boost::find_format`，所有其他算法都是基于它实现的。算法`boost::replace_first`、`boost::replace_last`、`boost::replace_nth`和`boost::replace_all`分别用替换字符串替换输入中搜索字符串的第一个、最后一个、第n个或所有匹配的出现。相应的擦除算法简单地擦除匹配的部分。这些算法不适用于C风格数组：
- en: '**Listing 4.15: Using boost::replace and boost::erase variants**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.15：使用boost::replace和boost::erase变体**'
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In listing 4.15, we first use the `boost::replace_first` algorithm to replace
    the first instance of the string `"Hello"` with `"Hola"` (line 9). Had we used
    `boost::replace_all` instead, both instances of `"Hello"` would be replaced, and
    we would get `"Hola, World! Hola folks!"`. We then call `boost::erase_first` to
    remove the remaining `"Hello"` in the string (line 11). Each of these algorithms
    has a case-insensitive variant, which matches in a case-insensitive way. Predictably,
    they are named with an `i-` prefix: `ireplace_first`, `ierase_first`, and so on.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单4.15中，我们首先使用`boost::replace_first`算法来将字符串`"Hello"`的第一个实例替换为`"Hola"`（第9行）。如果我们使用`boost::replace_all`，则会替换两个实例的`"Hello"`，并且我们将得到`"Hola,
    World! Hola folks!"`。然后我们调用`boost::erase_first`来删除字符串中剩余的`"Hello"`（第11行）。这些算法中的每一个都有一个不区分大小写的变体，以不区分大小写的方式进行匹配。可以预见地，它们以`i-`前缀命名：`ireplace_first`、`ierase_first`等等。
- en: 'There is a `_copy` variant of each algorithm returning too, a new string rather
    than changing in place. Here is a short illustration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个算法都有一个返回新字符串的`_copy`变体，而不是原地更改。以下是一个简短的示例：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note how the `boost::ireplace_last_copy` variant worked here, matching `"hello"`
    in a case-insensitive manner and performing the replacement in a copy of the input.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`boost::ireplace_last_copy`变体是如何工作的，以不区分大小写的方式匹配`"hello"`，并在输入的副本中执行替换。
- en: You can replace or erase a prefix or suffix of a string using `boost::replace_head`
    or `boost::replace_tail` (and their erase variants). The `boost::replace_regex`
    and `boost::replace_regex_all` algorithms take a regular expression for finding
    matches, and replace them with a replacement string. The replacement string may
    contain a special syntax to refer back to parts of the matched string, the details
    of which we will defer till the section on Boost.Regex, later in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`boost::replace_head`或`boost::replace_tail`（以及它们的擦除变体）来替换或擦除字符串的前缀或后缀。`boost::replace_regex`和`boost::replace_regex_all`算法使用正则表达式来查找匹配项，并用替换字符串替换它们。替换字符串可能包含特殊语法来引用匹配字符串的部分，有关详细信息，我们将在本章后面的Boost.Regex部分中详细介绍。
- en: The split and join algorithms
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分和连接算法
- en: 'Boost provides an algorithm called `boost::split`, which is essentially used
    to split an input string into tokens based on some separators. The algorithm is
    passed an input string, a predicate for identifying separators, and a sequence
    container to store the parsed tokens. Here is an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Boost提供了一个名为`boost::split`的算法，它基本上用于根据一些分隔符将输入字符串分割成标记。该算法接受输入字符串、用于识别分隔符的谓词和用于存储解析标记的序列容器。以下是一个示例：
- en: '**Listing 4.16: Splitting a string on simple tokens using boost::split**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.16：使用boost::split在简单标记上拆分字符串**'
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The listing 4.16 will list out the four types of dogs that appear in the string
    `dogtypes` separated by commas and spaces (line 9). It uses the `boost::split`
    algorithm to do so. The `dogtypes` string is tokenized using the predicate `boost::is_any_of("
    ,")`, which identifies any space or comma as a separator (line 11).The `boost::token_compress_on`
    option ensures that the `boost::split` algorithm does not return an empty string
    for each adjacent pair of separator characters but clubs them together, treating
    it as a single separator (line 12). If we want to split a string at any punctuation
    mark, we will use `boost::is_punct()` instead of `boost::is_any_of(…)`. However,
    it is a somewhat inflexible scheme of tokenizing with only a limited set of predicates
    available.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4.16将列出出现在字符串`dogtypes`中的四种狗的类型，用逗号和空格分隔（第9行）。它使用`boost::split`算法来实现。`dogtypes`字符串使用谓词`boost::is_any_of("
    ,")`进行标记化，该谓词将任何空格或逗号识别为分隔符（第11行）。`boost::token_compress_on`选项确保`boost::split`算法不会对每个相邻的分隔符字符返回空字符串，而是将它们组合在一起，将其视为单个分隔符（第12行）。如果我们想要在任何标点符号处拆分字符串，我们将使用`boost::is_punct()`而不是`boost::is_any_of(…)`。但是，这是一种相对不太灵活的标记化方案，只能使用有限的谓词集。
- en: 'If you simply want to split a string using another string as a separator, you
    may use `boost::iter_split` instead:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想使用另一个字符串作为分隔符拆分字符串，可以使用`boost::iter_split`：
- en: '**Listing 4.17: Using boost::iter_split to tokenize strings**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.17：使用boost::iter_split标记化字符串**'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main difference between `boost::split` and `boost::iter_split` is that in
    the latter, you use a finder to identify a separator, which can thus be a specific
    string. Both `boost::iter_split` and `boost::iter_find` take the same kind of
    arguments and use a finder to search for a matching substring, but `boost::iter_split`
    returns tokens that lie between two matching substrings, while its complement
    `boost::iter_find` returns the matching substring.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::split`和`boost::iter_split`之间的主要区别在于，在后者中，您使用查找器来识别分隔符，因此可以是特定的字符串。`boost::iter_split`和`boost::iter_find`都使用相同类型的参数，并使用查找器来搜索匹配的子字符串，但`boost::iter_split`返回位于两个匹配子字符串之间的标记，而它的补充`boost::iter_find`返回匹配的子字符串。'
- en: 'Finally, the `boost::join` and `boost::join_if` algorithms are pretty useful
    when you are trying to string together a sequence of values with some separator
    between successive values. While `boost::join` concatenates all the values in
    the sequence, `boost::join_if` concatenates only those values from the sequence
    that satisfy a passed predicate. Here is `boost::join` in action taking a vector
    of strings and a separator, and returning the joined string:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您尝试使用一些分隔符将一系列值串在一起时，`boost::join`和`boost::join_if`算法非常有用。`boost::join`连接序列中的所有值，而`boost::join_if`只连接满足传递的谓词的序列中的值。以下是`boost::join`的示例，它接受一个字符串向量和一个分隔符，并返回连接的字符串：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, we see yet another useful C++11 feature in action:
    uniform initialization. We initialize the vector `vec` with a sequence of four
    strings enclosed in braces and separated by a comma. This initialization syntax
    works for all STL containers and can be used with regular classes with specific
    types of constructors. Now, if we wanted to pick and choose which strings were
    concatenated and which were not, we would use `boost::join_if` like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到另一个有用的C++11特性：统一初始化。我们使用大括号括起来并用逗号分隔的四个字符串序列来初始化向量`vec`。这种初始化语法适用于所有STL容器，并且可以用于具有特定类型构造函数的常规类。现在，如果我们想要挑选哪些字符串被连接，哪些不被连接，我们将使用`boost::join_if`，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `fiveOrLessChars` predicate checks whether the string passed to it is of
    length five or less. Thus, the string `"mongrel"` does not feature in the joined
    string as its length is more than five.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`fiveOrLessChars`谓词检查传递给它的字符串是否长度为五或更少。因此，字符串`"mongrel"`由于长度超过五而不出现在连接的字符串中。'
- en: Splitting text using the Boost Tokenizer library
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost Tokenizer库拆分文本
- en: The `boost::split` algorithm, we saw in the last section, splits a string using
    a predicate and puts the tokens into a sequence container. It requires extra storage
    for storing all the tokens, and the user has limited choices for the tokenizing
    criteria used. Splitting a string into a series of tokens based on various criteria
    is a frequent programming requirement, and the Boost.Tokenizer library provides
    an extensible framework for accomplishing this. Also, this does not require extra
    storage for storing tokens. It provides a generic interface to retrieve successive
    tokens from a string. The criterion to split the string into successive tokens
    is passed as a parameter. The Tokenizer library itself provides a few reusable,
    commonly used tokenizing policies for splitting, but, most importantly, it defines
    an interface using which we can write our own splitting policies. It treats the
    input string like a container of tokens from which successive tokens may be parsed
    out.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中看到的`boost::split`算法使用谓词拆分字符串，并将标记放入序列容器中。它需要额外的存储空间来存储所有标记，并且用户对使用的标记化标准选择有限。根据各种标准将字符串拆分为一系列标记是一个常见的编程需求，Boost.Tokenizer库提供了一个可扩展的框架来实现这一点。此外，这不需要额外的存储空间来存储标记。它提供了一个通用接口来从字符串中检索连续的标记。将字符串拆分为连续标记的标准作为参数传递。Tokenizer库本身提供了一些可重用的常用标记策略进行拆分，但更重要的是，它定义了一个接口，使用该接口可以编写我们自己的拆分策略。它将输入字符串视为一系列标记的容器，可以从中解析出连续的标记。
- en: Tokenizing based on separators
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于分隔符的标记
- en: 'To begin with, let''s see how we can split a string into its constituent words:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何将字符串拆分为其组成单词：
- en: '**Listing 4.19: Using Boost Tokenizer to tokenize strings into words**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.19：使用Boost Tokenizer将字符串标记为单词**'
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `boost::tokenizer` class template abstracts the tokenization process. We
    create an instance of the default specialization of `boost::tokenizer`, passing
    it our input string `input` (line 10). Next, using the iterator interface of `boost::tokenizer`,
    we split `input` into successive tokens (lines 12-14). In general, you can customize
    how strings are split by passing appropriate tokenizing policies. As we did not
    pass one explicitly to the `boost::tokenizer` template, the default tokenizing
    policy splits the string using whitespace and punctuation as token delimiters
    or separators. The preceding code will print the following output to the standard
    output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::tokenizer`类模板抽象了标记化过程。我们创建`boost::tokenizer`的默认特化的实例，将输入字符串`input`传递给它（第10行）。接下来，使用`boost::tokenizer`的迭代器接口，我们将`input`拆分为连续的标记（第12-14行）。通常，您可以通过传递适当的标记策略来自定义字符串的拆分方式。由于我们没有显式地将其传递给`boost::tokenizer`模板，因此默认的标记策略将使用空格和标点符号作为标记的分隔符。上述代码将将以下输出打印到标准输出：'
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thus, it splits not only on spaces but also commas and apostrophes; `"I've"`
    is split into `"I"` and `"ve"` due to the apostrophe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它不仅在空格上分割，还在逗号和撇号上分割；由于撇号，`"I've"`被分割成`"I"`和`"ve"`。
- en: 'If we wanted to split the input based on spaces and punctuation but not split
    on an apostrophe, we would need to do more. Boost provides a few reusable templates
    for commonly used splitting policies. The `boost::char_delimiter` template splits
    the string using specified characters as delimiters. Here is the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据空格和标点符号拆分输入，但不要在撇号上拆分，我们需要做更多工作。Boost提供了一些可重用的模板，用于常用的拆分策略。`boost::char_delimiter`模板使用指定的字符作为分隔符拆分字符串。以下是代码：
- en: '**Listing 4.20: Using Boost Tokenizer with boost::char_separator**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.20：使用boost::char_separator的Boost Tokenizer**'
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, we first construct the splitting policy `sep` using the `boost::char_separator`
    template (line 10). Since we are splitting text of type `std::string` whose character
    type is `char`, we must pass `char` as argument to `boost::char_separator` to
    specify that the delimiters are of type `char`. We can also write `boost::char_separator<std::string::value_type>`
    instead of `boost::char_separator<char>` to better express the relationship. We
    construct the list of punctuation marks and whitespace characters we would like
    to use as delimiters and pass it as the constructor argument of `sep`. Finally,
    we construct the tokenizer, passing it the input string `input` and the splitting
    policy `sep`. We iterate through the successive tokens using a range-based for-loop,
    which makes for less verbose code than when using a token iterator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先使用`boost::char_separator`模板（第10行）构造拆分策略`sep`。由于我们正在拆分`std::string`类型的文本，其字符类型为`char`，因此必须将`char`作为参数传递给`boost::char_separator`，以指定分隔符的类型为`char`。我们还可以写`boost::char_separator<std::string::value_type>`，而不是`boost::char_separator<char>`，以更好地表达关系。我们构造要用作分隔符的标点符号和空白字符列表，并将其作为`sep`的构造函数参数传递。最后，我们构造分词器，将输入字符串`input`和拆分策略`sep`传递给它。我们使用基于范围的for循环迭代连续的标记，这比使用标记迭代器时的代码更简洁。
- en: Tokenizing records with fields containing metacharacters
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包含元字符的字段标记记录
- en: 'The `boost::char_delimiter` policy is not the only available splitting policy.
    Consider a comma-separated data format, as shown in the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::char_delimiter`策略并不是唯一可用的拆分策略。考虑一个以逗号分隔的数据格式，如下所示：'
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have one record per line and three fields per record: the name, age, and
    city of residence of a person. We can parse such records with the `boost::char_separator`
    policy, passing it a comma as a separator character. Now, if we want to make the
    format a little richer, we may include full addresses of people instead of their
    current city. But addresses are longer fields, sometimes with embedded commas,
    and such addresses would break the parsing, which is based on using a comma as
    a separator. So, we decide to quote strings that may have embedded commas:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每行一个记录，每个记录有三个字段：一个人的姓名、年龄和居住城市。我们可以使用`boost::char_separator`策略解析这样的记录，将逗号作为分隔符传递给它。现在，如果我们想要使格式更丰富一些，我们可以包括人们的完整地址而不是他们目前的城市。但是地址是更长的字段，有时带有嵌入的逗号，这样的地址会破坏基于逗号作为分隔符的解析。因此，我们决定引用可能带有嵌入逗号的字符串：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Quoting itself may not be enough. Some addresses might have quoted strings,
    and we would like to preserve those. To fix this, we decide on using backslash
    (`\`) as an escape character. Here is a fourth record with quoted strings in the
    address:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 引用本身可能不够。有些地址可能有引号字符串，我们希望保留这些。为了解决这个问题，我们决定使用反斜杠（\）作为转义字符。以下是一个地址中带有引号字符串的第四条记录：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The trouble now is that it is no longer possible to parse the preceding records
    using the `boost::char_separator` policy. For such records, we should instead
    use `boost::escaped_list_char`. The `boost::escaped_list_char` policy is tailor-made
    for this kind of use. By default, it uses comma (,) as a field separator, double
    quotes (") as the quoting character, and backslash (\) as the escape character.
    To include commas in fields, quote the fields. To include quotes in the fields,
    escape the embedded quotes. We can now attempt to parse the most complex of the
    four persons'' records, as discussed earlier:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，不再可能使用`boost::char_separator`策略来解析前述记录。对于这样的记录，我们应该使用`boost::escaped_list_char`。`boost::escaped_list_char`策略是专门为这种用途量身定制的。默认情况下，它使用逗号（，）作为字段分隔符，双引号（"）作为引号字符，反斜杠（\）作为转义字符。要在字段中包含逗号，请引用字段。要在字段中包含引号，请转义嵌入的引号。现在我们可以尝试解析前面讨论过的四个人中最复杂的记录：
- en: '**Listing 4.21: Using boost::tokenizer with boost::escaped_list_separator**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.21：使用boost::tokenizer和boost::escaped_list_separator**'
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: An instance of `boost::tokenizer<boost::escaped_list_separator<char> >` is created
    (line 12) using the typedef (lines 10-11). This is really the only operative change
    to take care of for this new format. The record, hardcoded in the variable `input`,
    needs some extra level of escaping to be made into a valid C++ string literal
    (lines 7-8).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12行创建了`boost::tokenizer<boost::escaped_list_separator<char>>`的一个实例，使用了typedef（第10-11行）。这实际上是唯一需要处理的操作变化，以适应这种新格式。变量`input`中硬编码的记录需要一些额外级别的转义，以使其成为有效的C++字符串文字（第7-8行）。
- en: 'If the record had a different set of metacharacters, say hyphen (-) for field
    separator, forward slash (/) for quotes, and tilde (~) for escaping, we would
    need to specify these explicitly, as the default options for `boost::escaped_list_separator<<char>
    >` would no longer work. Consider a person named Alon Ben-Ari, aged 35, who lives
    at 11/5 Zamenhoff St., Tel Aviv. Using the specified quote, field separators,
    and escape characters, this could be represented as:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录具有不同的元字符集合，例如连字符（-）作为字段分隔符，斜杠（/）作为引号，波浪号（~）作为转义字符，我们需要明确指定这些选项，因为`boost::escaped_list_separator<<char>>`的默认选项将不再起作用。考虑一个名为Alon
    Ben-Ari的人，年龄为35岁，住在特拉维夫Zamenhoff St. 11/5号。使用指定的引号、字段分隔符和转义字符，这可以表示为：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The name field has a hyphen in the last name Ben-Ari. As hyphen is also a field
    separator, the name field must be quoted using forward slashes. The address field
    has a forward slash and since a forward slash is the quote character, the address
    field must be escaped with the escape character (~). Now it is our turn to tokenize
    it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 姓氏字段中的Ben-Ari有一个连字符。由于连字符也是字段分隔符，因此名字字段必须使用斜杠引起来。地址字段有一个斜杠，由于斜杠是引号字符，所以地址字段必须用转义字符（~）转义。现在轮到我们对其进行标记化了：
- en: '**Listing 4.22: Using boost::escaped_list_separator with funky delimiters**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.22：使用boost::escaped_list_separator和奇特的分隔符**'
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tokenizing records with fixed-length fields
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定长度字段标记化记录
- en: 'One class of data formats that frequently occurs in financial transactions
    and several other domains consists of records at fixed offsets. Consider the following
    record format representing a payment instruction:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融交易和其他几个领域经常出现的一类数据格式是固定偏移量的记录。考虑以下代表支付指令的记录格式：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, the record is barely human readable and is meant for consumption only
    by a program. It has fields at fixed offsets whose meanings must be known by the
    parsing program. The individual fields are described here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，记录几乎不可读，只能由程序使用。它具有固定偏移量的字段，解析程序必须知道其含义。这里描述了各个字段：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In order to parse records like these, we use the `boost::offset_separator` splitting
    policy. This class (note that it isn't a template) takes lengths of successive
    tokens to parse in the form of a pair of iterators, bounding the sequence of lengths.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析这样的记录，我们使用`boost::offset_separator`分割策略。这个类（注意它不是一个模板）以一对迭代器的形式接受连续标记的长度，用于解析。
- en: 'A code example to parse the preceding payment instruction should help illustrate
    the idea:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解析前述支付指令的代码示例应该有助于说明这个想法：
- en: '**Listing 4.23: Tokenizing records with fixed-length fields**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.23：使用固定长度字段标记化记录**'
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We first define an array containing the lengths of successive fields (line 10),
    and use it to initialize an object `ofs` of type `boost::offset_separator` (line
    12). We could have also used a vector instead of an array and passed its `begin()`
    and `end()` iterators to the `offset_separator` constructor. We then create a
    tokenizer, which tokenizes a string based on offsets specified in `ofs` (lines
    13-14), and print the successive tokens using a range-based for-loop (lines 16-18).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个包含连续字段长度的数组（第10行），并使用它来初始化类型为`boost::offset_separator`的对象`ofs`（第12行）。我们也可以使用向量而不是数组，并将其`begin()`和`end()`迭代器传递给`offset_separator`构造函数。然后创建一个标记化器，它根据`ofs`中指定的偏移量对字符串进行标记化（第13-14行），并使用基于范围的for循环打印连续的标记（第16-18行）。
- en: 'This program produces the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序产生以下输出：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We see listed on successive lines, we see listed the values of the date, time,
    ID, sender SWIFT bank code (an identifier for the sender bank), receiver SWIFT
    bank code, amount, and currency of the transaction.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到连续的行上列出了日期、时间、ID、发送者SWIFT银行代码（发送者银行的标识符）、接收者SWIFT银行代码、金额和交易货币的值。
- en: 'Now, what happens if all the fields have been parsed and there is still some
    input left? The default behavior is to start parsing afresh the remaining text,
    applying the length offsets to it from the start. This may make sense for some
    formats and may not make sense for some. If you want to turn this behavior off
    so that the parsing stops once all the length offsets have been used, you should
    pass a third argument to the constructor of `boost::offset_separator`, and its
    value should be `false`, as shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果所有字段都已解析并且仍有一些输入剩下会发生什么？默认行为是重新开始解析剩余的文本，并从开头应用长度偏移。这对某些格式可能有意义，对某些格式可能没有意义。如果要关闭此行为，以便在使用所有长度偏移后停止解析，应将第三个参数传递给`boost::offset_separator`的构造函数，并且其值应为`false`，如下所示：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `lengths` is the array of length offsets and `nfields` is the number of
    fields we expect to parse.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`lengths`是长度偏移的数组，`nfields`是我们希望解析的字段数。
- en: 'Conversely, what happens if the input is shorter than the sum of the lengths?
    The default behavior is to return the last partially parsed field and stop. Suppose
    you have a format in which the payer''s comments are appended to each transaction
    record. A comment is optional and need not be there. If it is there, it may or
    may not have a maximum size limit. The first behavior can be used to parse the
    last comment field by specifying the maximum size, or an arbitrarily large size
    that you don''t expect the comments to reach, and thus leverage the partial parse
    of the last record. Again, if you want to turn this behavior off so that the first
    partial field encountered stops the parsing, you should pass a fourth argument
    of type `bool` to the `boost::offset_separator` constructor and its value should
    be `false`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果输入短于长度之和会发生什么？默认行为是返回最后部分解析的字段并停止。假设您有一个格式，其中付款人的评论附加到每个交易记录中。评论是可选的，不一定存在。如果存在，可能有最大大小限制，也可能没有。第一种行为可以通过指定最大大小来解析最后一个评论字段，或者指定一个您不希望评论达到的任意大的大小，从而利用最后记录的部分解析。同样，如果要关闭此行为，以便遇到第一个部分字段时停止解析，应将第四个参数传递给`boost::offset_separator`构造函数，并且其值应为`false`：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Writing your own tokenizer functions
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自己的标记函数
- en: There are many instances when you will need to parse a string according to some
    criteria that are not available in a reusable class or template in Boost. While
    you could use alternative libraries like `boost::split`, you can use the `boost::tokenizer`
    facility by plugging in a custom **token generator**. A token generator class
    encapsulates the tokenizing strategy and is passed as a template argument to `boost::tokenizer`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，您需要根据一些在Boost中不可重用的标准来解析字符串。虽然您可以使用`boost::split`等替代库，但是您可以通过插入自定义**标记生成器**来使用`boost::tokenizer`工具。标记生成器类封装了标记策略，并作为模板参数传递给`boost::tokenizer`。
- en: 'A token generator can be defined as a functor that conforms to the following
    requirements:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 标记生成器可以定义为符合以下要求的函数对象：
- en: Is copy-assignable.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可复制分配。
- en: Is copy-constructible.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可复制构造。
- en: 'Has an overloaded public function call operator (`operator()`) with the following
    signature:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有重载的公共函数调用运算符（`operator()`）具有以下签名：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This operator is passed two iterators that define a section of a string in which
    it looks for the next token it is passed. If and only if a new token is found,
    it returns true. In such case, it sets its third parameter to the token and its
    first parameter to the first position in the string after the end of the token,
    from where parsing may continue. It returns false if no token is found. We must
    write the logic to identify successive tokens in this function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符传递两个迭代器，定义了它在其中查找下一个标记的字符串部分。仅当找到新标记时，它才返回true。在这种情况下，它将其第三个参数设置为标记，并将其第一个参数设置为字符串中标记结束后的第一个位置，从那里可以继续解析。如果未找到标记，则返回false。我们必须在此函数中编写逻辑以识别连续的标记。
- en: Has a public member function `void reset()`. This can be used to clear any member
    variables used to keep parsing state for a string. Then, the same instance of
    the object may be used to parse multiple inputs.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有公共成员函数`void reset()`。这可以用于清除用于保持字符串解析状态的任何成员变量。然后，可以使用对象的相同实例来解析多个输入。
- en: These functions are called by the `boost::tokenizer` implementation, never directly
    by the programmer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数由`boost::tokenizer`实现调用，而不是直接由程序员调用。
- en: 'We now write a token generator class to pick from some text, strings that are
    quoted or bracketed. For example, given the string `"I''m taking a train from
    Frankfurt (am Main) to Frankfurt (an der Oder)"`, we want to pick out the tokens
    `"am Main"` and `"an der Oder"`. To simplify our implementation, given strings
    with nested brackets or quotes, only the content of innermost quotes need be retrieved.
    Thus, given the string `"tokenizer<char_separator<char> >"`, it should return
    `"char"`, the innermost bracketed entity. Here is the code for such a class, named
    `qstring_token_generator`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们编写一个标记生成器类，以从一些文本中选择带引号或括号的字符串。例如，给定字符串`"我要从法兰克福（am Main）乘火车去法兰克福（an der
    Oder）"`, 我们想要提取出标记`"am Main"`和`"an der Oder"`。为了简化我们的实现，给定具有嵌套括号或引号的字符串，只需要检索最内部引号的内容。因此，给定字符串`"tokenizer<char_separator<char>>"`,
    它应该返回`"char"`, 最内部的括号实体。以下是这样一个名为`qstring_token_generator`的类的代码：
- en: '**Listing 4.24a: The qstring_token_generator interface**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.24a：qstring_token_generator接口**'
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `qstring_token_generator` class has a constructor that takes the necessary
    inputs:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`qstring_token_generator`类具有一个接受必要输入的构造函数：'
- en: The start and end marker characters, which are by default both double quotes
    (")
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束标记字符，默认都是双引号（"）
- en: The escape character, which is by default the backslash (\)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义字符，默认为反斜杠（\）
- en: A Boolean indicating whether to skip empty tokens, which is by default true
    (lines 6-8)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，指示是否跳过空令牌，默认为true（第6-8行）
- en: 'The corresponding private variables for storing these values are defined (lines
    18-21). The class uses two additional state variables to keep track of parsing
    state: the `in_token` variable (line 22) which is true while parsing content inside
    quotes and false otherwise, and the `in_escape` variable (line 23) which is true
    if the current character is part of an escape sequence and false otherwise. Here
    is the implementation of the constructor:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储这些值的相应私有变量被定义（第18-21行）。该类使用两个额外的状态变量来跟踪解析状态：`in_token`变量（第22行），在解析引号内的内容时为true，否则为false，以及`in_escape`变量（第23行），如果当前字符是转义序列的一部分则为true，否则为false。这是构造函数的实现：
- en: '**Listing 4.24b: The qstring_token_generator constructor**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.24b：qstring_token_generator构造函数**'
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that `in_token` and `in_escape` are initialized to false. Each time we
    iterate through the successive tokens in the input using the tokenizer interface,
    the tokenizer implementation calls the token generator to parse the input again.
    To start parsing afresh, any internal parsing state must be reset. The `reset`
    function encapsulates these actions and is called by the tokenizer when new token
    iterators are created.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`in_token`和`in_escape`被初始化为false。每次我们使用标记生成器接口迭代输入的连续标记时，标记生成器实现都会调用标记生成器重新解析输入。为了重新开始解析，必须重置任何内部解析状态。`reset`函数封装了这些操作，并在创建新的标记迭代器时由标记生成器调用。
- en: 'Here is the implementation of the reset function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重置函数的实现：
- en: '**Listing 4.24c: The qstring_token_generator reset function**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.24c：qstring_token_generator重置函数**'
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The reset function makes sure that the internal variables used to maintain parsing
    state are reset appropriately for the parsing to restart.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重置函数确保用于维护解析状态的内部变量被适当地重置以重新开始解析。
- en: Finally, the parsing algorithm is implemented in the overloaded function call
    operator member (`operator()`). To parse the string, we look for start and end
    markers to identify the start and end of tokens and count-escaped start and end
    markers as part of the tokens, and handle the case where the start and end markers
    are the same characters. We also handle cases where quoted tokens are nested.
    We will write the algorithms in terms of a few helper private functions in `qstring_token_generator`
    class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，解析算法是在重载的函数调用操作员成员（`operator()`）中实现的。为了解析字符串，我们寻找开始和结束标记来识别标记的开始和结束，并将转义的开始和结束标记计为标记的一部分，并处理开始和结束标记是相同字符的情况。我们还处理引号标记嵌套的情况。我们将用`qstring_token_generator`类中的一些辅助私有函数来编写算法。
- en: '**Listing 4.24d: The parsing algorithm helpers**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.24d：解析算法辅助函数**'
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `start_token` function is meant to be called each time we identify the beginning
    of a new token (line 1). It sets the `in_token` flag to true, increments the iterator
    `next`, and returns its value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_token`函数的意思是每次我们识别出一个新标记的开始时调用它（第1行）。它将`in_token`标志设置为true，增加迭代器`next`，并返回它的值。'
- en: The `end_token` function is meant to be called each time we identify the end
    of a token (line 7). It sets the `in_token` flag to false, increments the iterator
    `next`, and returns the complete token as a string.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`end_token`函数的意思是每次我们识别出一个标记的结束时调用它（第7行）。它将`in_token`标志设置为false，增加迭代器`next`，并将完整的标记作为字符串返回。'
- en: 'We now need to write the logic to identify the start and end of tokens and
    call the preceding function appropriately. We do this directly in the overloaded
    `operator()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写逻辑来识别标记的开始和结束，并适当地调用前面的函数。我们直接在重载的`operator()`中执行这个操作：
- en: '**Listing 4.24e: The parsing algorithm**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.24e：解析算法**'
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We loop through the successive characters of the input using a while loop (line
    6). For each character, we check whether it is preceded by the escape character
    (line 7), or if it is the start marker (line 10), end marker (line 29), or the
    escape character (line 37).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用while循环遍历输入的连续字符（第6行）。对于每个字符，我们检查它是否是转义字符（第7行），或者它是否是开始标记（第10行），结束标记（第29行）或转义字符（第37行）的前导字符。
- en: If an unescaped start marker is found, and we are not already in the middle
    of parsing a token (line 11), then it potentially represents the start of a new
    token. So, we call `start_token`, note the starting position of the token, and
    continue to the next iteration (lines 12-13). But if we are already in the middle
    of parsing a token, and we find the start marker, then there are two possibilities.
    If the start and end markers happen to be the same, then this represents the end
    of the token (line 15). In this case, we call `end_token` to get the complete
    token and return it unless it is empty and `skip_empty_tokens` is set (lines 16-20).
    If start and end markers are not the same, then a second start marker represents
    a nested token. Since we want to only extract the most nested token, we discard
    the previous token and call `start_token` to indicate that we have the start of
    a new token (lines 25-26).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到未转义的开始标记，并且我们还没有在解析标记中（第11行），那么它可能代表一个新标记的开始。因此，我们调用`start_token`，记录标记的起始位置，并继续到下一个迭代（第12-13行）。但是，如果我们已经在解析标记中，并且找到了开始标记，那么有两种可能性。如果开始和结束标记恰好相同，那么这表示标记的结束（第15行）。在这种情况下，我们调用`end_token`来获取完整的标记并返回它，除非它为空并且设置了`skip_empty_tokens`（第16-20行）。如果开始和结束标记不相同，那么第二个开始标记表示嵌套标记。由于我们只想提取最嵌套的标记，我们丢弃先前的标记并调用`start_token`来指示我们有一个新标记的开始（第25-26行）。
- en: If the end marker is distinct from the start marker, and we find it (line 29),
    then we call `end_token` generating and returning the complete token found, unless
    it is empty and `skip_empty_tokens` is set. Finally, if we find the escape character,
    we set the `in_escape` flag (lines 37-38).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结束标记与开始标记不同，并且我们找到它（第29行），那么我们调用`end_token`生成并返回找到的完整标记，除非它为空并且设置了`skip_empty_tokens`。最后，如果我们找到转义字符，我们设置`in_escape`标志（第37-38行）。
- en: 'We use the `qstring_token_generator` class to tokenize our input string:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`qstring_token_generator`类来对我们的输入字符串进行标记化：
- en: '**Listing 4.25: Extracting bracketed strings using the custom tokenizer**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.25：使用自定义标记生成器提取括号字符串**'
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding highlighted code shows the key changes in our code. We define
    a `qstring_token_generator` object that takes a left and right quote character
    (in this case, left and right parentheses) and skips empty tokens (line 4). We
    then create a typedef for `boost::tokenizer<qstring_token_generator>` (line 4),
    create a tokenizer of that type to parse input (line 6), and print successive
    tokens (line 10).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面突出显示的代码显示了我们代码中的关键更改。我们定义了一个`qstring_token_generator`对象，它接受左引号和右引号字符（在本例中是左括号和右括号），并跳过空标记（第4行）。然后我们为`boost::tokenizer<qstring_token_generator>`（第4行）创建了一个typedef，创建了一个该类型的标记生成器来解析输入（第6行），并打印连续的标记（第10行）。
- en: Regular expressions using Boost.Regex
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Regex的正则表达式
- en: When we write a line of code like `boost::find_first("Where have all the flowers
    gone?", "flowers")`, we are asking for the string `"flowers"` (call it the **needle**)
    to be found in the larger string `"Where have all the flowers gone?"` (call it
    the **haystack**). The needle is the pattern; seven specific characters in a particular
    order whose presence must be looked up in the haystack. Sometimes, however, we
    don't know the exact string we are looking for; we only have an abstract idea
    or a pattern in mind. Regular expressions is a powerful language to express this
    abstract pattern.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写像`boost::find_first("Where have all the flowers gone?", "flowers")`这样的代码行时，我们是在要求在较大的字符串`"Where
    have all the flowers gone?"`（称为**大海草堆**）中找到字符串`"flowers"`（称为**针）的存在。针是模式；一个特定顺序中的七个特定字符，其存在必须在大海草堆中查找。然而，有时我们并不知道我们要找的确切字符串；我们只有一个抽象的想法或一个模式。正则表达式是一种表达这种抽象模式的强大语言。
- en: Regular expression syntax
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式语法
- en: Regular expressions are strings that encode a pattern of text using a mix of
    regular characters and some characters with special interpretation, collectively
    called *metacharacters*. The Boost.Regex library provides functions that consume
    regular expression strings and generate the logic to search and verify text conforming
    to particular patterns. For example, to define the pattern, "a followed by zero
    or more b's", we use the regular expression `ab*`. This pattern will match text
    like `a`, `ab`, `abb`, `abbb`, and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种字符串，它使用常规字符和一些具有特殊解释的字符的混合来编码文本的模式，这些字符统称为*元字符*。 Boost.Regex库提供了消耗正则表达式字符串并生成搜索和验证符合特定模式的文本的逻辑的函数。例如，要定义模式“a后面跟零个或多个b”，我们使用正则表达式`ab*`。这个模式将匹配文本`a`，`ab`，`abb`，`abbb`等。
- en: Atoms
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子
- en: At a very basic level, regular expressions consist of groups of one or more
    characters called **atoms**, each with an associated **quantifier** that trails
    the atom and optionally, **anchors** that define how some text is located relative
    to the surrounding text. The quantifier may be implicit. An atom can be a single
    character (or an escaped metacharacter), a **character class**, a string, or a
    **wildcard**. If it is a string, it must be enclosed in parentheses to indicate
    that it is an atom. A wildcard matches any character (other than a newline) and
    is written using the dot (.) metacharacter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常基本的层面上，正则表达式由称为**原子**的一个或多个字符组成，每个原子都有一个关联的**量词**，跟在原子后面，还可以选择地有**锚点**，定义了如何相对于周围文本定位一些文本。量词可能是隐式的。原子可以是单个字符（或转义的元字符）、**字符类**、字符串或**通配符**。如果是字符串，必须将其括在括号中以指示它是一个原子。通配符匹配任何字符（除了换行符），并使用句点（.）元字符编写。
- en: Quantifiers
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量词
- en: 'A single atom without a trailing quantifier just matches a single occurrence
    of itself. When present, the trailing quantifier determines the minimum and maximum
    allowed occurrences of the preceding atom. The general quantifier looks like `{m,
    M}`, where `m` denotes minimum and `M` denotes maximum occurrence frequency. Omitting
    the maximum as in `{m,}` indicates that the maximum number of times the atom may
    be present is unbounded. One may also use a single number as `{n}` to match a
    fixed number of instances. More often, we use the following shortcut quantifiers:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 没有尾随量词的单个原子只匹配自身的单个出现。当存在时，尾随量词确定了前面原子的最小和最大允许出现次数。一般的量词看起来像`{m, M}`，其中`m`表示最小出现次数，`M`表示最大出现频率。省略最大值，如`{m,}`表示原子可以出现的最大次数是无限的。也可以使用一个数字作为`{n}`来匹配固定数量的实例。更常见的是，我们使用以下快捷量词：
- en: '`*`: Equivalent to `{0,}`, called the **Kleene star**. Represents an atom that
    may not occur, or may occur any number of times.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：等同于`{0,}`，称为**Kleene星**。表示可能不会发生的原子，或者可能发生任意次数。'
- en: '`+`: Equivalent to `{1,}`. Represents an atom that must occur at least once.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：等同于`{1,}`。表示必须至少出现一次的原子。'
- en: '`?`: Equivalent to `{0,1}`. Represents an optional atom.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`：等同于`{0,1}`。表示可选原子。'
- en: 'Using the above syntax rules, we construct summary examples in the following
    table:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述语法规则，我们在下表中构造摘要示例：
- en: '| Regular Expression | Atoms | Quantifier | Equivalent quantifier | Matching
    text |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | 原子 | 量词 | 等效量词 | 匹配文本 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| W | w | None (implicit) | `{1}` | w |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| W | w | None（隐式） | `{1}` | w |'
- en: '| a* | a | * | `{0,}` | (blank), a, aa, aaa, aaaa, … |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| a* | a | * | `{0,}` | （空白），a，aa，aaa，aaaa，… |'
- en: '| (abba)+ | abba | + | `{1,}` | abba, abbaabba, abbaabbaabba, … |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| (abba)+ | abba | + | `{1,}` | abba, abbaabba, abbaabbaabba, … |'
- en: '| a?b | a, b | ? | `{0,1}` | b, ab |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| a?b | a，b | ? | `{0,1}` | b，ab |'
- en: '| (ab){2,4} | (ab) | {2,4} | `{2,4}` | abab, ababab, abababab |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| (ab){2,4} | (ab) | {2,4} | `{2,4}` | abab, ababab, abababab |'
- en: '| .*x | . and x | * and None | `{0,}` and `{1}` | x and any string ending in
    x |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| .*x | . 和 x | * 和 None | `{0,}` 和 `{1}` | x 和以x结尾的任何字符串 |'
- en: By default, quantifiers are *greedy* and match as many characters as possible.
    Thus, given the string `"abracadabra"`, the regular expression `"a.*a"` will match
    the entire string instead of the smaller substrings `"abra"`, `"abraca"`, or `"abracada"`,
    all of which also start and end in `'a'`. If we want to match only the smallest
    matching substring, we need to override the greedy semantics. To do this, we put
    the question mark (?) metacharacter after the quantifier `"a.*?a"`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，量词是*贪婪*的，会匹配尽可能多的字符。因此，对于字符串`"abracadabra"`，正则表达式`"a.*a"`将匹配整个字符串，而不是更小的子字符串`"abra"`、`"abraca"`或`"abracada"`，它们也都以`'a'`开头和结尾。如果我们只想匹配最小的匹配子字符串，我们需要覆盖贪婪的语义。为此，我们在量词`"a.*?a"`后面加上问号（?）元字符。
- en: Character classes
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类
- en: 'Characters can also be matched against character classes, which are shorthand
    representations of a group of functionally related characters. The following is
    a partial list of predefined character classes in the Boost libraries:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 字符也可以与字符类匹配，字符类是一组功能相关字符的简写表示。以下是Boost库中预定义的字符类的部分列表：
- en: '| Character class | Short form | Meaning | Complement |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 字符类 | 简写形式 | 含义 | 补集 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| [[:digit:]] | `\d` | Any decimal digit (0-9) | \D |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| [[:digit:]] | `\d` | 任何十进制数字（0-9） | \D |'
- en: '| [[:space:]] | `\s` | Any whitespace character | \S |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| [[:space:]] | `\s` | 任何空白字符 | \S |'
- en: '| [[:word:]] | `\w` | Any word character: letter, number, and underscore |
    \W |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| [[:word:]] | `\w` | 任何单词字符：字母、数字和下划线 | \W |'
- en: '| [[:lower:]] | `\l` | Any lowercase character |   |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| [[:lower:]] | `\l` | 任何小写字符 |   |'
- en: '| [[:upper:]] | `\u` | Any uppercase character |   |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| [[:upper:]] | `\u` | 任何大写字符 |   |'
- en: '| [[:punct:]] | None | Any punctuation character |   |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| [[:punct:]] | 无 | 任何标点字符 |   |'
- en: For example, `\d` is a character class that matches a single decimal digit.
    Its complement \`D` matches any single character, except decimal digits. `\s`
    matches a whitespace character and `\S` matches a non-whitespace character. Ad
    hoc character classes can be created with square brackets; `[aeiouAEIOU]` matches
    any character that is an English vowel, `[1-5]` matches a digit between 1 and
    5 both inclusive. The expression `[^2-4]` matches any character except 2, 3, and
    4, and the leading caret inside the square brackets having the effect of negating
    the characters following it. We can combine multiple character classes something
    like—[[:digit:][:lower:]]—to indicate the set of lowercase letters and decimal
    digits.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`\d`是一个字符类，匹配一个十进制数字。它的补集\`D`匹配任何单个字符，除了十进制数字。`\s`匹配空白字符，`\S`匹配非空白字符。可以用方括号创建临时字符类；`[aeiouAEIOU]`匹配任何英语元音字母，`[1-5]`匹配1到5之间的数字（包括1和5）。表达式`[^2-4]`匹配除了2、3和4之外的任何字符，并且方括号内的前导插入符号具有否定其后字符的作用。我们可以组合多个字符类，比如—[[:digit:][:lower:]]—来表示小写字母和十进制数字的集合。
- en: Anchors
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锚点
- en: Certain metacharacters, referred to as **anchors**, do not match characters
    but can be used to match specific locations in text. For example, a caret (`^`)
    in a regular expression (outside a character class) matches text at the start
    of a line (just after a newline). A dollar(`$`) matches text before the end of
    a line (just before a newline). Also, `\b` represents a word boundary, while `\B`
    matches any location other than a word boundary.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 某些元字符，称为**锚点**，不匹配字符，但可以用于匹配文本中的特定位置。例如，正则表达式中的插入符（`^`）匹配行的开头（换行符后面）。美元符（`$`）匹配行的结尾（换行符前面）。此外，`\b`表示单词边界，而`\B`匹配除了单词边界之外的任何位置。
- en: Sub-expressions
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子表达式
- en: 'In general, each character in a string of characters is interpreted as a distinct
    atom. In order to treat a string of characters as a single atom, we must parenthesize
    it. Parenthesized substrings of a regular expression are called **sub-expressions**.
    A quantifier following a sub-expression applies to the entire sub-expression:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，字符中的每个字符都被解释为一个独立的原子。为了将一串字符视为一个单独的原子，我们必须将其括在括号中。正则表达式中括号内的子字符串称为**子表达式**。跟在子表达式后面的量词适用于整个子表达式：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding expression represents a number (`[1-9][0-9]*`) followed by zero
    or more words (`\w+`) separated from it and from each other by one or more whitespace
    characters (`\s+`). The second Kleene star applies to the entire sub-expression
    `\s+\w+` due to the parentheses.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式表示一个数字（`[1-9][0-9]*`）后面跟着零个或多个单词（`\w+`），它们之间和彼此之间由一个或多个空白字符（`\s+`）分隔。第二个Kleene星号由于括号的存在应用于整个子表达式`\s+\w+`。
- en: Regular expression libraries, including Boost.Regex keep track of substrings
    of a string that match the parenthesized sub-expressions. Matched sub-expressions
    can be referred back from within the regular expression using back-references,
    such as `\1`, `\2`, `\3`, and so on. For example, in the previous regular expression,
    the term `\1` matches the leading number, while `\2` matches the last matched
    word with leading spaces. It matches nothing if there are no trailing words. Sub-expressions
    can be nested and are numbered incrementally starting at 1 in the order that their
    left parentheses appear in the string from left to right.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式库，包括Boost.Regex，跟踪字符串的子字符串，这些子字符串与括号内的子表达式匹配。匹配的子表达式可以在正则表达式内部使用反向引用，如`\1`、`\2`、`\3`等。例如，在前面的正则表达式中，术语`\1`匹配前导数字，而`\2`匹配带有前导空格的最后匹配的单词。如果没有尾随单词，则不匹配任何内容。子表达式可以嵌套，并且按照它们在字符串中从左到右出现的左括号的顺序从1开始递增编号。
- en: If you want to use sub-expressions to be able to apply quantifiers and anchors
    to groups of characters, but do not need to capture them for later reference,
    you can use **non-capturing sub-expressions** of the form `(?:expr)`, where the
    leading metacharacter sequence `?:` inside the parentheses indicates that it is
    a non-capturing sub-expression, and `expr` is some valid regular expression. This
    will treat expr as an atom, but will not capture it. Sub-expressions without the
    leading `?:` inside parentheses are thus called **capture groups** or **capturing
    sub-expressions**.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用子表达式来能够对字符组应用量词和锚定，但不需要捕获它们以供以后引用，您可以使用形式为`(?:expr)`的**非捕获子表达式**，其中括号内的前导元字符序列`?:`表示它是一个非捕获子表达式，`expr`是一些有效的正则表达式。这将把expr视为一个原子，但不会捕获它。括号内没有前导`?:`的子表达式因此被称为**捕获组**或**捕获子表达式**。
- en: Disjunctions
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离
- en: You can create a regular expression that is a logical-or of one or more regular
    expressions. To do this, you use the |**disjunction operator**. For example, to
    match a word that contains a mix of lowercase and uppercase characters, you can
    use the expression `(\l|\u)+`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个正则表达式，它是一个或多个正则表达式的逻辑或。为此，您可以使用|**分离运算符**。例如，要匹配包含小写和大写字符混合的单词，您可以使用表达式`(\l|\u)+`。
- en: You can use the disjunction operator to combine regular expressions and form
    more complex expressions. For example, to match either a word containing upper
    or lowercase characters, or a positive integer, we can use the expression `(\l|\u)+|\d+`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用分离运算符来组合正则表达式并形成更复杂的表达式。例如，要匹配包含大写或小写字符的单词，或正整数，我们可以使用表达式`(\l|\u)+|\d+`。
- en: Using Boost.Regex to parse regular expressions
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost.Regex来解析正则表达式
- en: Regular expressions are a rich topic that we have barely scratched the surface
    of in the preceding paragraphs. But this basic familiarity is sufficient for us
    to start using the Boost.Regex library. The Boost.Regex library was one of the
    libraries that was accepted into the C++ 11 Standard and is now part of the C++
    11 Standard Library, minus its ability to handle Unicode characters.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个丰富的主题，在前面的段落中我们只是浅尝辄止。但这种基本的熟悉已经足够让我们开始使用Boost.Regex库。Boost.Regex库是C++
    11标准中被接受的库之一，现在是C++ 11标准库的一部分，减去了处理Unicode字符的能力。
- en: 'The Boost Regular Expressions library is *not* header-only and requires linking
    against the Boost.Regex shared or static library. It is available from the header
    file `boost/regex.hpp`. On my Linux desktop with Boost libraries installed via
    the native package manager, I use the following command line to build regex programs:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Boost正则表达式库*不是*仅包含头文件，需要链接到Boost.Regex共享或静态库。它可以从头文件`boost/regex.hpp`中获得。在我使用本机包管理器安装Boost库的Linux桌面上，我使用以下命令行来构建正则表达式程序：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'On Linux systems, where Boost has been installed from source, the header files
    could be under a nonstandard location like `/opt/boost/include` and libraries
    under `/opt/boost/lib`. On such systems, I have to use the following command line
    to build my programs:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在从源代码安装Boost的Linux系统上，头文件可能位于非标准位置，如`/opt/boost/include`，库位于`/opt/boost/lib`下。在这样的系统上，我必须使用以下命令行来构建我的程序：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `-Wl`, `-rpath`, `/opt/boost/lib` directive tells the linker to hard-code
    the path from where shared libraries, like `libboost_regex-mt`, are loaded, and
    helps our program to run without additional settings. On Windows using Visual
    Studio, linking is automatic.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Wl`，`-rpath`，`/opt/boost/lib`指令告诉链接器硬编码路径，从中加载共享库，如`libboost_regex-mt`，并帮助我们的程序在没有额外设置的情况下运行。在使用Visual
    Studio的Windows上，链接是自动的。'
- en: It uses the `boost::basic_regex` template to model regular expressions and provides
    its specializations `boost::regex` for type `char` and `boost::wregex` for type
    `wchar_t` as typedefs. Using this library, we can check whether a string conforms
    to a pattern or contains a substring conforming to a pattern, extract all substrings
    of a string conforming to a pattern, replace a substring matching a pattern with
    another formatted string, and split a string based on a matching expression to
    name the few most commonly used operations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`boost::basic_regex`模板来建模正则表达式，并为`char`类型提供其特化`boost::regex`和`wchar_t`类型的`boost::wregex`作为typedef。使用这个库，我们可以检查一个字符串是否符合某种模式或包含符合某种模式的子字符串，提取符合某种模式的字符串的所有子字符串，用另一个格式化的字符串替换与模式匹配的子字符串，并根据匹配表达式拆分字符串，这是最常用的几种操作。
- en: Matching text
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配文本
- en: 'Consider the string `"Alaska area"`. We want to match this against the regular
    expression `a.*a` to see whether the string fits the pattern. To do this, we need
    to call the `boost::regex_match` function, which returns a Boolean true to indicate
    a successful match and false otherwise. Here is the code for it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑字符串`"Alaska area"`。我们想要将其与正则表达式`a.*a`匹配，以查看字符串是否符合模式。为此，我们需要调用`boost::regex_match`函数，该函数返回一个布尔值true，表示成功匹配，否则返回false。以下是代码：
- en: '**Listing 4.26: Matching a string with a regular expression**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.26：使用正则表达式匹配字符串**'
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The regular expression `"a.*a"` is encapsulated in an instance of `boost::regex`.
    When we match the string against this expression, the match fails (line 8) because
    the string starts with an uppercase `''A''`, while the regular expression expects
    a lowercase `''a''` at the start. We could have asked for a case insensitive regular
    expression by constructing and passing `boost::regex::icase` as a flag to the
    `boost::regex` constructor:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式`"a.*a"`封装在`boost::regex`的实例中。当我们将字符串与此表达式匹配时，匹配失败（第8行），因为字符串以大写`'A'`开头，而正则表达式期望在开头是小写`'a'`。我们可以通过构造并将`boost::regex::icase`作为标志传递给`boost::regex`构造函数来要求不区分大小写的正则表达式：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that we called a different overload of `boost::regex_match`, which takes
    two iterators to a `std::string` (line 8) just to illustrate an alternative signature.
    You can also call `boost::regex_match` with a `const char*` or a `std::string`
    like in listing 4.25\. The outcome of the function is not dependent on the variant.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们调用了`boost::regex_match`的不同重载，它接受两个`std::string`的迭代器（第8行），只是为了说明另一种签名。您也可以像在清单4.25中那样使用`const
    char*`或`std::string`调用`boost::regex_match`。函数的结果不依赖于变体。
- en: Searching text
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索文本
- en: 'If we want to search for substrings of a string that matches a particular regular
    expression, we should use the `boost::regex_search` function instead of `boost::regex_match`.
    Consider the string `"An array of papers from the academia on Alaska area''s fauna"`.
    We want to find all substrings that are part of the same word in this phrase and
    start and end with `''a''`. The regular expression to use would be `a\w*a`. Let
    us see how we can do this using `boost::regex_search`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要搜索与特定正则表达式匹配的字符串的子字符串，我们应该使用`boost::regex_search`函数，而不是`boost::regex_match`。考虑字符串`"An
    array of papers from the academia on Alaska area's fauna"`。我们想要找到这个短语中属于同一个单词并以`'a'`开头和结尾的所有子字符串。要使用的正则表达式将是`a\w*a`。让我们看看如何使用`boost::regex_search`来做到这一点：
- en: '**Listing 4.27: Searching for substrings matching a regular expression**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.27：搜索匹配正则表达式的子字符串**'
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This prints the following lines, each with a word or part of the word that
    begins and ends in `''a''`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印了以下行，每行都有一个以`'a'`开头和结尾的单词或单词的一部分：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the code example, we construct the string (line 6), the regular expression
    (line 8), and an instance of `boost::smatch` (line 9), which is a specialization
    of the template `boost::match_results` to be used when the input is of type `std::string`.
    We search for successive matching substrings in a loop, calling `boost::regex_search`.
    We pass to `boost::regex_search` two iterators to the input string, the `smatch`
    instance called `matches`, and the regular expression `r2` (line 13). You must
    pass `const` iterators to `boost::regex_search` (lines 10, 11), or the compilation
    will fail to resolve the function call with a ton of gratuitous messages.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们构造了字符串（第6行），正则表达式（第8行），以及`boost::smatch`的实例（第9行），它是`boost::match_results`模板的特化，用于输入类型为`std::string`时使用。我们在循环中搜索连续匹配的子字符串，调用`boost::regex_search`。我们将两个迭代器传递给`boost::regex_search`，`smatch`实例称为`matches`，以及正则表达式`r2`（第13行）。您必须向`boost::regex_search`传递`const`迭代器（第10、11行），否则编译将无法解析函数调用，并显示大量不必要的消息。
- en: The object `matches` of type `boost::smatch` stores information about the substring
    that matches a regular expression after a call to `regex_search`. Its `str` member
    returns the substring that was matched by the regular expression. `boost::smatch`
    is a sequence collection of `boost::ssub_match` objects. When a regular expression
    matches a substring, the pair of iterators to the start and one part to the end
    of that substring is stored in an object of type `boost::ssub_match`. This is
    stored at index 0 of `matches` and accessed as `matches[0]`. The members `first`
    and `second` of `ssub_match` are iterators to the start of the match (line 15)
    and one past the end of the match. The member function `length()` returns the
    length of the match (line 16). At the end of each iteration, we set the `start`
    iterator to the first location past the end of the last match (line 17) to begin
    looking for the next match. The `boost::ssub_match` is a specialization of the
    template `boost::sub_match` to be used when the input string is of type `std::string`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`boost::smatch`的对象`matches`在调用`regex_search`后存储有关与正则表达式匹配的子字符串的信息。它的`str`成员返回由正则表达式匹配的子字符串。`boost::smatch`是`boost::ssub_match`对象的序列集合。当正则表达式匹配子字符串时，迭代器对的一部分存储在类型为`boost::ssub_match`的对象中。这存储在`matches`的索引0处，并作为`matches[0]`访问。`ssub_match`的`first`和`second`成员是匹配的开始（第15行）和匹配结束的迭代器。成员函数`length()`返回匹配的长度（第16行）。在每次迭代结束时，我们将`start`迭代器设置为上一个匹配结束位置之后的第一个位置（第17行），以开始寻找下一个匹配。`boost::ssub_match`是模板`boost::sub_match`的特化，用于当输入字符串的类型为`std::string`时使用。
- en: Suppose that, for each match, we want to extract what lies between the two a's
    at the two ends. To do this, we can use capturing sub-expressions. The regular
    expression would be modified slightly to `a(\\w*)a`. To access what matches the
    parenthesized sub-expression, we again use the `boost::smatch` object. An additional
    `boost::ssub_match` object is constructed for each such sub-expression in the
    regular expression and added to successive indexes of the `boost::smatch` object
    passed. If the sub-expression matched anything in the string, then the start and
    end of the substring matching that sub-expression are stored in the `ssub_match`
    object.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于每个匹配，我们想要提取两个`a`之间的内容。为此，我们可以使用捕获子表达式。正则表达式会稍微修改为`a(\\w*)a`。要访问与括号子表达式匹配的内容，我们再次使用`boost::smatch`对象。对于正则表达式中的每个这样的子表达式，都会构造一个额外的`boost::ssub_match`对象，并将其添加到传递的`boost::smatch`对象的连续索引中。如果子表达式在字符串中匹配了任何内容，那么匹配该子表达式的子字符串的开始和结束将存储在`ssub_match`对象中。
- en: 'This is how we would use it with the modified regular expression:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用修改后的正则表达式：
- en: '**Listing 4.28: Parsing matching substrings and sub-expressions**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.28：解析匹配的子字符串和子表达式**'
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the inner loop (line 18), we iterate through all sub-expressions and for
    the ones that match any substring (line 19), we print that matching substring
    using the `str` member function of `boost::ssub_match` (line 20), the offset of
    the substring (line 21), and its length (line 22). The `prefix` and `suffix` methods
    of the `matches` object return respectively, the parts preceding and following
    the matched substring as `boost::ssub_match` objects (lines 15, 16).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部循环（第18行）中，我们遍历所有子表达式，对于匹配任何子字符串的子表达式（第19行），我们使用`boost::ssub_match`的`str`成员函数（第20行）打印匹配的子字符串，以及子字符串的偏移量（第21行）和长度（第22行）。`matches`对象的`prefix`和`suffix`方法分别返回匹配的子字符串之前和之后的部分，作为`boost::ssub_match`对象（第15、16行）。
- en: The `boost::match_results` and `boost::sub_match` templates have different available
    specializations appropriate for different types of inputs, like an array of narrow
    or wide characters, or a specialization of `std::basic_string` (`std::string`
    or `std::wstring`).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::match_results`和`boost::sub_match`模板有不同的可用特化，适用于不同类型的输入，比如窄字符或宽字符数组，或者`std::basic_string`（`std::string`或`std::wstring`）的特化。'
- en: 'The following table summarizes these specializations:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了这些特化：
- en: '| Input type | std::match_results specialization | std::sub_match specialization
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 输入类型 | std::match_results特化 | std::sub_match特化 |'
- en: '| --- | --- | --- |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `std::string` | `std::smatch` | `std::ssub_match` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `std::string` | `std::smatch` | `std::ssub_match` |'
- en: '| `std::wstring` | `std::wmatch` | `std::wsub_match` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `std::wstring` | `std::wmatch` | `std::wsub_match` |'
- en: '| `const char*` | `std::cmatch` | `std::csub_match` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `const char*` | `std::cmatch` | `std::csub_match` |'
- en: '| `const wchar_t*` | `std::wcmatch` | `std::wcsub_match` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `const wchar_t*` | `std::wcmatch` | `std::wcsub_match` |'
- en: Tokenizing text using regex
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正则表达式对文本进行标记化
- en: 'This is a lot of work to parse an input using a regular expression, and there
    ought to be better abstractions available for the application programmer. Indeed,
    this is the kind of job you can simplify using a `boost::regex_iterator` and `boost::regex_token_iterator`.
    Let us suppose we want to pick all words in the string that start and end in `''a''`.
    Here is a relatively painless way to do it:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式解析输入是很多工作，应该有更好的抽象可用于应用程序员。事实上，您可以使用`boost::regex_iterator`和`boost::regex_token_iterator`来简化这种工作。假设我们想要挑选出字符串中以`'a'`开头和结尾的所有单词。以下是一个相对轻松的方法：
- en: '**Listing 4.29: Parsing strings using boost::regex_iterator**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.29：使用boost::regex_iterator解析字符串**'
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This program prints the following text to the output, consisting of the three
    words that begin and end in `''a''`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将以下文本打印到输出，由以`'a'`开头和结尾的三个单词组成：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `boost::sregex_iterator` is a specialization of the template `boost::regex_iterator`
    to be used when the input string is of type `std::string`. Its instance `rit`
    is initialized with the string iterators, defining the input string and the regular
    expression used to look for successive tokens (line 10). It is then used to iterate
    through successive tokens like any other iterator (line 12).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::sregex_iterator`是模板`boost::regex_iterator`的特化，用于当输入字符串的类型为`std::string`时使用。它的实例`rit`使用字符串迭代器初始化，定义了用于查找连续标记的输入字符串和正则表达式（第10行）。然后，它用于像任何其他迭代器一样迭代连续的标记（第12行）。'
- en: In the previous example, we didn't deal with sub-expressions. So, let us look
    at an example with sub-expressions. Consider a string `"animal=Llama lives_in=Llama
    and is related_to=vicuna"`. It consists of some key-value pairs separated by the
    equals sign, among other content. If we want to extract all such key-value pairs,
    we can use a regular expression like `\w+=\w+`. We assume that the keys and values
    are single words without embedded punctuation or spaces. If we also want to pick
    out the key and value separately, we can use capture-groups like `(\w+)=(\w+)`
    for sub-expression matching:.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们没有处理子表达式。因此，让我们看一个带有子表达式的示例。考虑一个字符串`"animal=Llama lives_in=Llama and
    is related_to=vicuna"`。它由一些由等号分隔的键值对组成，还有其他内容。如果我们想要提取所有这样的键值对，我们可以使用正则表达式`\w+=\w+`。我们假设键和值是不带嵌入标点或空格的单词。如果我们还想要分别挑选出键和值，我们可以使用捕获组，如`(\w+)=(\w+)`用于子表达式匹配。
- en: 'By using the `boost::sregex_token_iterator`, we can actually pick out substrings
    matching individual sub-expressions relatively easily. The `boost::sregex_token_iterator`
    is a specialization of the template `boost::regex_token_iterator` for use with
    input string of type `std::string`. It takes the iterators to the input string,
    regular expression, and optional arguments specifying which sub-expressions to
    iterator over. Here is the code to boot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`boost::sregex_token_iterator`，我们实际上可以相对容易地挑选出与单个子表达式匹配的子字符串。`boost::sregex_token_iterator`是模板`boost::regex_token_iterator`的特化，用于处理类型为`std::string`的输入字符串。它接受输入字符串、正则表达式和可选参数的迭代器，指定要迭代的子表达式。以下是引导代码：
- en: '**Listing 4.30: Parsing input strings with boost::regex_token_iterator**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.30：使用boost::regex_token_iterator解析输入字符串**'
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code prints the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码打印以下输出：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You may have noticed that we print the values followed by the keys. We initialize
    a `boost::sregex_token_iterator` using the iterators defining the input string,
    the regular expression, and the array `subindx` specifying the sub-expressions
    we are interested in (line 11). As `subindx` has value `{2, 1}` (line 10), the
    second field is printed before the first. Besides an array, we could have also
    passed a vector of integers identifying the sub-expression indexes, or a single
    integer identifying the index of the only sub-expression we are interested in.
    If we omit this argument, the behavior of `boost::regex_token_iterator` is identical
    to that of `boost::regex_iterator`. The size of the array does not need to be
    passed and is automatically deduced via template argument deduction.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们打印的值后面跟着键。我们使用定义输入字符串的迭代器、正则表达式和数组`subindx`来初始化`boost::sregex_token_iterator`，该数组指定我们感兴趣的子表达式（第11行）。由于`subindx`的值为`{2,
    1}`（第10行），第二个字段在第一个字段之前打印。除了数组，我们还可以传递标识子表达式索引的整数向量，或者标识我们感兴趣的唯一子表达式的单个整数。如果省略此参数，`boost::regex_token_iterator`的行为与`boost::regex_iterator`相同。数组的大小不需要传递，并且通过模板参数推导自动推断。
- en: 'Some algorithms in the Boost String Algorithms library provide convenient wrappers
    around the functionality in Boost.Regex. The `boost::find_all_regex` algorithm
    takes a sequence container, an input string, and a regular expression, and puts
    all substrings of the input string that match the regular expression into the
    sequence container with a single function call. The `boost::split_regex` container
    splits a string into tokens separated by text that matches some regular expression
    and puts the tokens into a sequence container. Here are both in action; `find_all_regex`
    splitting a sentence into words, and `split_regex` splitting a record with pipe
    character separators into fields:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Boost String Algorithms库中的一些算法提供了对Boost.Regex功能的便捷包装。`boost::find_all_regex`
    算法接受一个序列容器、一个输入字符串和一个正则表达式，并通过单个函数调用将匹配正则表达式的输入字符串的所有子字符串放入序列容器中。`boost::split_regex`
    容器将一个字符串分割成由匹配某个正则表达式的文本分隔的标记，并将这些标记放入序列容器中。以下是两者的示例；`find_all_regex` 将一个句子分割成单词，而
    `split_regex` 将使用管道字符分隔的记录分割成字段：
- en: '**Listing 4.31: Using find_all_regex and split_regex**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.31：使用find_all_regex和split_regex**'
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This prints the following output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印出以下输出：
- en: '[PRE63]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that the first line prints all possible substrings that match the regular
    expression `\w+` (line 11), not just the largest disjoint matching substrings.
    This is because `find_all_regex` finds every matching substring in the input.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行打印出了与正则表达式 `\w+` 匹配的所有可能子字符串（第11行），而不仅仅是最大的不相交匹配子字符串。这是因为 `find_all_regex`
    在输入中找到了每个匹配的子字符串。
- en: Replacing text
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换文本
- en: One frequent use of regular expressions is to search for text and replace matching
    text by other text. For example, we may want to scan a particular paragraph for
    possessive phrases (England's Queen, India's culture, people's choice, and so
    on.) and convert them to an alternative form (Queen of England, culture of India,
    choice of people, and so on). The `boost::regex_replace` function template can
    come in handy for the purpose.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的一个常见用途是搜索文本，并用其他文本替换匹配的文本。例如，我们可能想要扫描特定段落以寻找所有所有格短语（英国的女王，印度的文化，人们的选择等），并将它们转换为另一种形式（英国的女王，印度的文化，人们的选择等）。`boost::regex_replace`
    函数模板可以很方便地实现这一目的。
- en: 'To begin with, we define the regular expression `\w+''s\s+\w+`. Since we have
    to reorder the phrase, we must capture parts of the match using sub-expressions.
    We use the regular expression `(\w+)''s\s+(\w+)` to match. We can use numbered
    back-references in the replacement string to refer to the submatches, so the replacement
    string is `"\2 of \1"`. We pass these along with the input string to `boost::regex_replace`,
    which returns a string with the matched sections replaced appropriately. Here
    is the code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义正则表达式 `\w+'s\s+\w+`。由于我们必须重新排列短语，我们必须使用子表达式来捕获匹配的部分。我们使用正则表达式 `(\w+)'s\s+(\w+)`
    进行匹配。我们可以在替换字符串中使用编号的反向引用来引用子匹配，因此替换字符串是 `"\2 of \1"`。我们将这些与输入字符串一起传递给 `boost::regex_replace`，它将返回一个字符串，其中匹配的部分已适当替换。以下是代码：
- en: '**Listing 4.32: Finding/Replacing strings with regular expressions**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单4.32：使用正则表达式查找/替换字符串**'
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'By default, `regex_replace` replaces all matching substrings. If we want to
    replace only the first matching substring instead, then we need to pass `boost::regex_constants::
    format_first_only` as a fourth argument to `regex_replace`.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`regex_replace` 会替换所有匹配的子字符串。如果我们只想替换第一个匹配的子字符串，那么我们需要将 `boost::regex_constants::format_first_only`
    作为第四个参数传递给 `regex_replace`。
- en: Self-test questions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all options that apply:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: How does Boost Range help Boost Algorithms provide a better interface?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boost Range如何帮助Boost Algorithms提供更好的接口？
- en: a. Any character range expressed as a single argument, not iterator pair
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: a. 任何以单个参数表示的字符范围，而不是迭代器对
- en: b. It is faster than iterator pairs
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它比迭代器对更快
- en: c. It supports C-style arrays, and is extensible to other abstractions
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它支持C风格数组，并可扩展到其他抽象
- en: d. It provides better exception safety
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: d. 它提供更好的异常安全性
- en: Which algorithm produces the shortest code for searching all substrings matching
    a search string or pattern?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个算法生成了搜索所有匹配搜索字符串或模式的子字符串的最短代码？
- en: a. `boost::find_all`
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: a. `boost::find_all`
- en: b. `boost::find_all_regex`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: b. `boost::find_all_regex`
- en: c. `boost::find_first`
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: c. `boost::find_first`
- en: d. `boost::regex_iterator`
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: d. `boost::regex_iterator`
- en: Which of these are tokenizer functions provided by the Boost Tokenizer library?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boost Tokenizer库提供了哪些标记化函数？
- en: a. `boost::char_separator`
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: a. `boost::char_separator`
- en: b. `boost::split`
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: b. `boost::split`
- en: c. `boost::escaped_list_separator`
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: c. `boost::escaped_list_separator`
- en: d. `boost::tokenizer`
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: d. `boost::tokenizer`
- en: The regular expression `"\ba.*a"` matches which part of the string `"two giant
    anacondas creeping around"`?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式 `"\ba.*a"` 匹配字符串 `"two giant anacondas creeping around"` 的哪一部分？
- en: a. `"ant anacondas creeping a"`
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: a. `"ant anacondas creeping a"`
- en: b. `"anacondas creeping a"`
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: b. `"anacondas creeping a"`
- en: c. `"ant anaconda"`
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: c. `"ant anaconda"`
- en: d. `"anaconda"`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: d. `"anaconda"`
- en: Which of the following is true of `boost::smatch`?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于 `boost::smatch` 的哪个说法是正确的？
- en: 'a. It is a specialization of `boost:: match_results`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: a. 它是 `boost::match_results` 的一个特化
- en: b. It stores only matched sub-expressions
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它仅存储匹配的子表达式
- en: c. It stores a `boost::ssub_match` object for each sub-expression
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它为每个子表达式存储一个 `boost::ssub_match` 对象
- en: d. Its `str` member returns the matched substring
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: d. 其 `str` 成员返回匹配的子字符串
- en: Summary
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the use of miscellaneous functions from the Boost
    String Algorithms library for performing various operations on string data types.
    We then looked at the generic Boost String Tokenizer framework that provides an
    efficient and extensible way to tokenize strings based on criteria that the user
    can define. We finally looked at regular expressions, and the Boost.Regex library
    that provides the ability to match character data against regular expressions,
    search for patterns, tokenize, and replace patterns using regular expressions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用Boost String Algorithms库中的各种杂项函数来执行对字符串数据类型的各种操作。然后我们看了一下通用的Boost
    String Tokenizer框架，它提供了一种高效和可扩展的方式来根据用户定义的条件对字符串进行标记化。最后，我们看了一下正则表达式，以及Boost.Regex库，它提供了匹配字符数据与正则表达式、搜索模式、标记化和使用正则表达式替换模式的能力。
- en: This chapter should have given you a broad perspective of basic text handling
    facilities available from the Boost libraries. Along the way, we also picked up
    some useful techniques from the Boost Range abstraction. In the next chapter,
    we turn our attention to various data structures available from the Boost libraries.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应该为您提供了从Boost库中提供的基本文本处理工具的广泛视角。在这个过程中，我们还从Boost Range抽象中学到了一些有用的技巧。在下一章中，我们将转向Boost库中提供的各种数据结构。
