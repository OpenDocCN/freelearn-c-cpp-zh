- en: 8\. User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 用户界面
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will continue our work on the Dodgeball-based game that
    we have been working on in the last few chapters. We will continue this project
    by learning about game UIs (short for user interfaces) and some of their forms,
    namely menus and HUDs. By the end of this chapter, you will be able to use UMG,
    UE4's game UI system, to make a menu with interactable buttons, as well as a HUD
    that displays the player character's current health points through a progress
    bar.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续我们在过去几章中一直在进行的基于躲避球的游戏的工作。我们将通过学习游戏UI（用户界面）及其形式之一，即菜单和HUD，来继续这个项目。到本章结束时，您将能够使用UE4的游戏UI系统UMG来制作一个带有可交互按钮的菜单，以及通过进度条显示玩家角色当前生命值的HUD。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned about general-purpose utilities that allow
    you to properly structure and organize the code and assets in your project by
    using Blueprint Function Libraries, Actor Components, and Interfaces.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了通用工具，这些工具允许您通过使用蓝图函数库、角色组件和接口来正确结构化和组织项目中的代码和资产。
- en: In this chapter, we will dive into the topic of game UIs, which is something
    that's present in almost every video game. The game UI is one of the main ways
    to show information to the player, such as how many lives they have left, how
    many bullets are in their weapon, which weapon they are carrying, and so on, and
    to allow the player to interact with the game by choosing whether to continue
    the game, create a new game, choose which level they want to play in, and so on.
    This is shown to the player mostly in the form of images and text.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨游戏UI的主题，这是几乎每个视频游戏中都存在的东西。游戏UI是向玩家展示信息的主要方式之一，例如他们还剩下多少条命，他们的武器里有多少子弹，他们携带的武器是什么等等，并且允许玩家通过选择是否继续游戏、创建新游戏、选择要在哪个级别中玩等方式与游戏进行交互。这通常以图像和文本的形式展示给玩家。
- en: '**User Interfaces** or **UIs** are usually added on top of the rendering of
    the game, which means that they are in front of everything else you see in the
    game and behave as layers (you can add them on top of one another just like in
    Photoshop). However, there is an exception to this: *diegetic UI*. This type of
    UI isn''t layered onto the game''s screen, but rather exists inside of the game
    itself. A great example of this can be found in the game *Dead Space*, where you
    control a character in a third-person view and can see their health points by
    looking at the contraption attached to their back, inside the game world.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面**或**UI**通常添加在游戏的渲染之上，这意味着它们位于游戏中您看到的所有其他内容的前面，并且行为类似于图层（您可以像在Photoshop中一样将它们叠加在彼此之上）。但是，也有一个例外：*直接UI*。这种类型的UI不是分层到游戏的屏幕上，而是存在于游戏本身之内。一个很好的例子可以在游戏*死亡空间*中找到，在这个游戏中，您以第三人称视角控制一个角色，并且可以通过观察连接到他们背部的装置来看到他们的生命值，这是在游戏世界内部。'
- en: Game UI
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏UI
- en: 'There are usually two different types of game UI: **menus** and **HUDs**.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种不同类型的游戏UI：**菜单**和**HUD**。
- en: Menus are UI panels that allow the player to interact with them, either by pressing
    a button or a key on their input device.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单是允许玩家与之交互的UI面板，可以通过按下输入设备上的按钮或键来实现。
- en: 'This can be done in the form of many different menus, including the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过许多不同的菜单形式来实现，包括以下内容：
- en: Main menus, where the player can choose whether to continue the game, create
    a new game, exit the game, and so on
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单，玩家可以选择是否继续游戏、创建新游戏、退出游戏等等
- en: Level select menus, where the player can choose which level to play
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别选择菜单，玩家可以选择要玩的级别
- en: And many other options
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及其他许多选项
- en: HUDs are UI panels that are present during gameplay that give the player information
    that they should always know, such as how many lives they have left, which special
    abilities they can use, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HUD是游戏过程中存在的UI面板，向玩家提供他们应该始终知道的信息，例如他们还剩下多少条命，他们可以使用哪些特殊能力等等。
- en: We will be covering game UI and making both a menu and a HUD for our game in
    this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖游戏UI，并为我们的游戏制作菜单和HUD。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We won't be covering diegetic UI here, as it is beyond the scope of this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里涵盖直接UI，因为它超出了本书的范围。
- en: So how do we go about creating a game UI in UE4? The main way to do that is
    by using **Unreal Motion Graphics** (**UMG**), which is the tool that allows you
    to make a game UI (also called Widgets in UE4 terms) featuring menus and HUDs,
    and add them to the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何在UE4中创建游戏UI呢？这样做的主要方式是使用**虚幻运动图形**（**UMG**），这是一种工具，允许您制作游戏UI（在UE4术语中也称为小部件），包括菜单和HUD，并将它们添加到屏幕上。
- en: Let's jump into this topic in the following section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中深入探讨这个主题。
- en: UMG Basics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG基础知识
- en: In UE4, the main way to create a game UI is by using the UMG tool. This tool
    will allow you to make a game UI in the form of `Designer` tab, while also allowing
    you to add functionality to your game UI through UMG's `Graph` tab.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，创建游戏UI的主要方式是使用UMG工具。这个工具将允许您以`设计师`选项卡的形式制作游戏UI，同时还可以通过UMG的`图表`选项卡为您的游戏UI添加功能。
- en: Widgets are the way UE4 allows you to represent a game UI. Widgets can be basic
    UI elements such as `Buttons`, `Text` elements, and `Images`, but they can also
    be combined to create more complex and complete Widgets, such as menus and HUDs,
    which is exactly what we will be doing in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是UE4允许您表示游戏UI的方式。小部件可以是基本的UI元素，如`按钮`、`文本`元素和`图像`，但它们也可以组合在一起创建更复杂和完整的小部件，如菜单和HUD，这正是我们将在本章中要做的。
- en: Let's create our first Widget in UE4 using the UMG tool in the next exercise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个练习中使用UMG工具在UE4中创建我们的第一个小部件。
- en: 'Exercise 8.01: Creating a Widget Blueprint'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：创建小部件蓝图
- en: In this exercise, we will be creating our first Widget Blueprint, as well as
    learning the basic elements of UMG and how we can use them to create a game UI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的第一个小部件蓝图，并学习UMG的基本元素以及如何使用它们来创建游戏UI。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: In order to create our first Widget, open the editor, go to the `ThirdPersonCPP
    -> Blueprints` folder inside the `Content Browser`, and *right-click*.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建我们的第一个小部件，打开编辑器，转到`Content Browser`中的`ThirdPersonCPP -> Blueprints`文件夹，然后*右键单击*。
- en: Go to the very last section, `User Interface`, and select `Widget Blueprint`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到最后一节，`用户界面`，然后选择`小部件蓝图`。
- en: Selecting this option will create a new `Widget Blueprint`, which is the name
    for a Widget asset in UE4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项将创建一个新的`小部件蓝图`，这是UE4中小部件资产的名称。
- en: 'Name this Widget `TestWidget` and open it. You will see the interface for editing
    a Widget Blueprint, where you''ll be creating your own Widgets and UI. Here''s
    a breakdown of all the tabs present in this window:![Figure 8.1: The Widget Blueprint
    editor broken down into six windows'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此小部件命名为`TestWidget`并打开它。您将看到用于编辑小部件蓝图的界面，在那里您将创建自己的小部件和UI。以下是此窗口中所有选项卡的详细信息：![图8.1：小部件蓝图编辑器分解为六个窗口
- en: '](img/B16183_08_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_01.jpg)'
- en: 'Figure 8.1: The Widget Blueprint editor broken down into six windows'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：小部件蓝图编辑器分解为六个窗口
- en: 'The details about the tabs in the preceding figure are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中选项卡的详细信息如下：
- en: '`Palette` – This tab shows you all the individual UI elements that you can
    add to your Widget. This includes `Buttons`, `Text Boxes`, `Images`, `Sliders`,
    `Check Boxes`, and many more.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调色板` - 此选项卡显示您可以添加到小部件的所有单独的UI元素。这包括`按钮`，`文本框`，`图像`，`滑块`，`复选框`等等。'
- en: '`Hierarchy` – This tab shows you all the UI elements currently present in your
    Widget. As you can see, currently we only have a `Canvas Panel` element in our
    hierarchy.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`层次结构` - 此选项卡显示当前在您的小部件中存在的所有UI元素。正如您所看到的，目前我们的层次结构中只有一个`画布面板`元素。'
- en: '`Designer` – This tab shows you how your Widget looks visually, according to
    the elements present in the hierarchy and how they''re laid out. Because the only
    element we currently have in our Widget doesn''t have a visual representation,
    this tab is currently empty.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`设计师` - 此选项卡显示您的小部件在视觉上的外观，根据层次结构中存在的元素以及它们的布局方式。因为我们当前小部件中唯一的元素没有视觉表示，所以此选项卡目前为空。'
- en: '`Details` – This tab shows you the properties of the UI element you have currently
    selected. If you select the existing `Canvas Panel` element, all the options in
    the preceding screenshot should appear.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`详细信息` - 此选项卡显示当前所选UI元素的属性。如果选择现有的`画布面板`元素，则应出现前面截图中的所有选项。'
- en: Because this asset is a `Widget Blueprint`, these two buttons allow you to switch
    between the `Designer view`, which is the one presented in the screenshot, and
    the `Graph view`, which looks exactly like the window of a normal Blueprint class.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为此资产是`小部件蓝图`，这两个按钮允许您在`设计师视图`和`图形视图`之间切换，后者看起来与普通蓝图类的窗口完全相同。
- en: '`Animation` – Both these tabs are related to Widget animations. Widget Blueprints
    allow you to animate the properties of UI elements, including their `position`,
    `scale`, `color`, and so on, over time. The tab on the left allows you to create
    and select animations to edit in the right tab, where you''ll be able to edit
    what properties they affect over time.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`动画` - 这两个选项卡都与小部件动画相关。小部件蓝图允许您随时间动画UI元素的属性，包括它们的`位置`，`比例`，`颜色`等等。左侧选项卡允许您创建和选择要在右侧选项卡中编辑的动画，您将能够编辑它们随时间影响的属性。'
- en: Let's now look at some of the available UI elements in our `Widget`, starting
    with the existing `Canvas Panel`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看一下我们的`小部件`中一些可用的UI元素，首先是现有的`画布面板`。
- en: '`Canvas Panels` are usually added to the root of Widget Blueprints because
    they allow you to drag a UI element to any position you want in the `Designer`
    tab. This way, you can lay out these elements as you wish: at the center of the
    screen, at the top-left corner, at the bottom center of the screen, and so on.
    Let''s now drag another very important UI element into our Widget: a `Button`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`画布面板`通常添加到小部件蓝图的根部，因为它们允许您将UI元素拖动到`设计师`选项卡中的任何位置。这样，您可以按照自己的意愿布置这些元素：在屏幕中心，左上角，屏幕底部中心等等。现在让我们将另一个非常重要的UI元素拖到我们的小部件中：一个`按钮`。'
- en: 'In the `Palette` tab, find the `Button` element and drag it into our `Designer`
    tab (hold the left mouse button while you drag):![Figure 8.2: A Button element
    being dragged from the Palette window'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`调色板`选项卡中，找到`按钮`元素并将其拖到我们的`设计师`选项卡中（按住鼠标左键拖动）：![图8.2：从调色板窗口拖动按钮元素
- en: into the Designer window
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 进入设计师窗口
- en: '](img/B16183_08_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_02.jpg)'
- en: 'Figure 8.2: A Button element being dragged from the Palette window into the
    Designer window'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：从调色板窗口将按钮元素拖到设计师窗口中
- en: 'Once you do this, you''ll be able to resize the button to the size you want
    by dragging the little white dots around it (keep in mind that you''ll only be
    able to do this to an element that is inside a Canvas Panel):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您这样做，您就可以通过拖动周围的小白点调整按钮的大小（请记住，您只能对位于画布面板内的元素执行此操作）：
- en: '![Figure 8.3: The result of resizing a UI element using the white dots around
    it'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：使用周围的白点调整UI元素大小的结果'
- en: '](img/B16183_08_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_03.jpg)'
- en: 'Figure 8.3: The result of resizing a UI element using the white dots around
    it'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：使用周围的白点调整UI元素大小的结果
- en: Another way for you to drag elements inside each other in a `Widget` is to drag
    them inside the `Hierarchy` tab, instead of the `Designer` tab.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`小部件`中将元素拖入彼此的另一种方法是将它们拖入`层次结构`选项卡，而不是`设计师`选项卡。
- en: 'Now drag a `Text` element inside our `Button`, but this time, use the `Hierarchy`
    tab:![Figure 8.4: Dragging a Text element from the Palette window into the Hierarchy
    window'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`文本`元素拖到我们的`按钮`中，但这次使用`层次结构`选项卡：![图8.4：将文本元素从调色板窗口拖到层次结构窗口中
- en: '](img/B16183_08_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_04.jpg)'
- en: 'Figure 8.4: Dragging a Text element from the Palette window into the Hierarchy
    window'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：将文本元素从调色板窗口拖到层次结构窗口中
- en: '`Text` elements can contain text specified by you with a certain size and font
    that you can modify in the `Details` panel. After you''ve dragged the `Text` element
    inside the `Button` using the `Hierarchy` tab, this is what the `Designer` tab
    should look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “文本”元素可以包含您指定的文本，具有您可以在“详细信息”面板中修改的特定大小和字体。在使用“层次结构”选项卡将“文本”元素拖动到“按钮”内之后，设计师选项卡应该如下所示：
- en: '![Figure 8.5: The Button element in the Designer tab, after we add a Text element
    as its child'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：在我们添加文本元素作为其子级后的设计师选项卡中的按钮元素'
- en: '](img/B16183_08_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_05.jpg)'
- en: 'Figure 8.5: The Button element in the Designer tab, after we add a Text element
    as its child'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：在设计师选项卡中的按钮元素，在我们添加文本元素作为其子级后
- en: Let's change a few properties of this `Text` block.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改此“文本”块的一些属性。
- en: 'Select it either in the `Hierarchy` tab or the `Designer` tab and take a look
    at the `Details` panel:![Figure 8.6: The Details panel, showing the properties
    of the Text element we added'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“层次结构”选项卡或“设计师”选项卡中选择它，并查看“详细信息”面板：![图8.6：显示我们添加的文本元素的属性的详细信息面板
- en: '](img/B16183_08_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_06.jpg)'
- en: 'Figure 8.6: The Details panel, showing the properties of the Text element we
    added'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：显示我们添加的文本元素的属性的详细信息面板
- en: 'Here you''ll find several properties that you can edit to your liking. For
    now, we just want to focus on two of them: the `Content` of the text and its `Color
    and Opacity`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会发现一些属性，您可以根据自己的喜好进行编辑。现在，我们只想专注于其中的两个：文本的“内容”和其“颜色和不透明度”。
- en: 'Update the `Content` of the `Text` element from `Text Block` to `Button 1`:![Figure
    8.7: Changing the Text property of the Text element to Button 1'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“文本”元素的“内容”从“文本块”更新为“按钮1”：![图8.7：将文本元素的文本属性更改为按钮1
- en: '](img/B16183_08_07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_07.jpg)'
- en: 'Figure 8.7: Changing the Text property of the Text element to Button 1'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：将文本元素的文本属性更改为按钮1
- en: Next, let's change its `Color and Opacity` from `White` to `Black`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将其“颜色和不透明度”从“白色”更改为“黑色”。
- en: Click the `Color and Opacity` property and take a look at the window that pops
    up, the `Color Picker`. This window pops up whenever you edit a `Color` property
    in UE4\. It allows you to input colors in many different ways, including a color
    wheel, a `Saturation` and `Value` bar, `RGB` and `HSV` value sliders, and a couple
    more options.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“颜色和不透明度”属性，看看弹出的窗口，“颜色选择器”。每当您在UE4中编辑“颜色”属性时，此窗口都会弹出。它允许您以许多不同的方式输入颜色，包括颜色轮、饱和度和值条、RGB和HSV值滑块，以及其他几个选项。
- en: 'For now, change the color from white to black by dragging the `Value` bar (the
    one that goes from white to black from top to bottom) all the way to the bottom
    and then pressing `OK`:![Figure 8.8: Selecting the color black in the Color Picker
    window'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将“值”条（从上到下从白色到黑色的条）拖动到底部，然后按“确定”，将颜色从白色更改为黑色：![图8.8：在颜色选择器窗口中选择黑色
- en: '](img/B16183_08_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_08.jpg)'
- en: 'Figure 8.8: Selecting the color black in the Color Picker window'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：在颜色选择器窗口中选择黑色
- en: 'After these changes, this is what the button should look like:![Figure 8.9:
    The Button element after we change the Text element''s Text'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这些更改后，按钮应该看起来像这样：![图8.9：更改文本元素的文本后的按钮元素
- en: property and its color
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 属性及其颜色
- en: '](img/B16183_08_09.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_09.jpg)'
- en: 'Figure 8.9: The Button element after we change the Text element''s Text property
    and its color'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：更改文本元素的文本属性和颜色后的按钮元素
- en: And with that, we conclude our first exercise for this chapter. You now know
    some of the essential basics of UMG, such as how to add `Button` and `Text` elements
    to your Widgets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们结束了本章的第一个练习。您现在已经了解了UMG的一些基本知识，比如如何向您的小部件添加“按钮”和“文本”元素。
- en: Before we jump into our next exercise, let's first learn about Anchors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行下一个练习之前，让我们先了解一下锚点。
- en: Anchors
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点
- en: As you might be aware, video games are played on many different screen sizes
    with many different resolutions. Because of that, it is important to make sure
    that the menus you create can adapt to all these different resolutions effectively.
    This is the main purpose of **Anchors**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到，视频游戏在许多不同的屏幕尺寸和许多不同的分辨率上进行播放。因此，确保您创建的菜单可以有效地适应所有这些不同的分辨率非常重要。这就是**锚点**的主要目的。
- en: Anchors allow you to specify how you want a UI element's size to adapt as the
    screen resolution changes by specifying the proportion of the screen you want
    it to occupy. Using Anchors, you can have a UI element always at the top left
    of the screen, or always occupying half of the screen, no matter the size and
    resolution of that screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点允许您指定UI元素的大小在屏幕分辨率更改时如何适应，通过指定您希望其占据屏幕比例。使用锚点，您可以始终将UI元素放在屏幕的左上角，或始终占据屏幕的一半，无论屏幕的大小和分辨率如何。
- en: 'As the size of the screen or resolution changes, your Widget will scale and
    move relative to its Anchor. Only elements that are direct children of a `Canvas
    Panel` can have an Anchor, which you can visualize through the `Anchor Medallion`,
    a white flower-like shape in the `Designer` tab, when you select said element:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕大小或分辨率发生变化时，您的小部件将相对于其锚点进行缩放和移动。只有直接作为“画布面板”的子级的元素才能有锚点，您可以通过“锚点奖章”来可视化它，当您选择所述元素时，在“设计师”选项卡中会显示一个白色的花瓣形状：
- en: '![Figure 8.10: The Anchor Medallion at the top left of the outline shown'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：显示轮廓左上方的锚点奖章'
- en: in the Designer window
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计师窗口中
- en: '](img/B16183_08_10.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_10.jpg)'
- en: 'Figure 8.10: The Anchor Medallion at the top left of the outline shown in the
    Designer window'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：在设计师窗口中显示的轮廓的左上方的锚点奖章
- en: By default, the Anchor is collapsed into the top-left corner, which means that
    you won't have much control over how the button is scaled as the resolution changes,
    so let's change that in the next exercise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，锚点折叠到左上角，这意味着您无法控制按钮在分辨率更改时的缩放程度，因此让我们在下一个练习中更改它。
- en: 'Exercise 8.02: Editing UMG Anchors'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：编辑UMG锚点
- en: In this exercise, we will be changing the Anchors in our Widget in order to
    have our Button's size and shape adapt to a wide range of screen resolutions and
    sizes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将改变小部件中的锚点，以便我们的按钮大小和形状能够适应各种屏幕分辨率和尺寸。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Select the Button we created in the previous exercise, then head to the `Details`
    panel and press the very first property you see, the `Anchors` property. Here
    you'll be able to see the `Anchor` presets, which will align the UI element according
    to the pivots shown.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们在上一个练习中创建的按钮，然后转到`Details`面板，点击您看到的第一个属性，即`Anchors`属性。在这里，您将能够看到`Anchor`预设，这将根据所示的枢轴对齐UI元素。
- en: We'll want to have our button centered on the screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将按钮居中显示在屏幕上。
- en: 'Click on the pivot that''s at the center of the screen:![Figure 8.11: The Button''s
    Anchors property, with the center Anchor outlined in a box'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕中心的中心枢轴：![图8.11：按钮的锚点属性，中心锚点用方框标出
- en: '](img/B16183_08_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_11.jpg)'
- en: 'Figure 8.11: The Button''s Anchors property, with the center Anchor outlined
    in a box'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：按钮的锚点属性，中心锚点用方框标出
- en: 'You''ll see that our `Anchor Medallion` has now changed places:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到我们的`Anchor Medallion`现在已经改变了位置：
- en: '![Figure 8.12: The Anchor Medallion after we change the Button''s Anchor to
    the center'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：将按钮的锚点更改为中心后的锚点奖章'
- en: '](img/B16183_08_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_12.jpg)'
- en: 'Figure 8.12: The Anchor Medallion after we change the Button''s Anchor to the
    center'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：将按钮的锚点更改为中心后的锚点奖章
- en: Now that the `Anchor Medallion` is at the center of the screen, we still won't
    have much control over how the Button will scale across different resolutions,
    but at least we know that it'll scale relative to the center of the screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Anchor Medallion`位于屏幕中心，我们仍然无法控制按钮在不同分辨率下的缩放，但至少我们知道它会相对于屏幕中心进行缩放。
- en: In order to have our Button centered on the screen, we'll have to change the
    Button's position to be at the center of the screen as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的按钮居中显示在屏幕上，我们还需要将按钮的位置更改为屏幕中心。
- en: 'Repeat the previous step of picking the center Anchor, but this time, before
    you select it, hold the *Ctrl* key in order to snap the Button''s position to
    this Anchor. After you click it, release the *Ctrl* key. This should be the result:![Figure
    8.13: The Button element being moved near its selected Anchor in the center'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复选择中心锚点的上一步，但这次，在选择它之前，按住*Ctrl*键以将按钮的位置捕捉到此锚点。点击后释放*Ctrl*键。这应该是结果：![图8.13：按钮元素被移动到其选定的中心锚点附近
- en: '](img/B16183_08_13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_13.jpg)'
- en: 'Figure 8.13: The Button element being moved near its selected Anchor in the
    center'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：按钮元素被移动到其选定的中心锚点附近
- en: As you can see from the preceding screenshot, our Button has changed position,
    but it isn't properly centered on the screen yet. This is because of its `Alignment`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看到，我们的按钮位置已经改变，但它还没有正确居中在屏幕上。这是因为它的`Alignment`。
- en: 'The `Alignment` property is of type `Vector2D` (a tuple with two `float` properties:
    `X` and `Y`) and dictates the center of the UI element relative to its total size.
    By default it''s set to `(0,0)`, meaning the center of the element is its top-left
    corner, which explains the result in the preceding screenshot. It can go all the
    way to `(1,1)`, the bottom-right corner. In this case, given that we want the
    alignment to center the button, we want it to be `(0.5, 0.5)`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alignment`属性是`Vector2D`类型（具有两个`float`属性的元组：`X`和`Y`），它决定了UI元素相对于其总大小的中心。默认情况下设置为`(0,0)`，意味着元素的中心是其左上角，这解释了前面截图中的结果。它可以一直到`(1,1)`，即右下角。在这种情况下，考虑到我们希望对齐按钮，我们希望它是`(0.5,
    0.5)`。'
- en: 'In order to update a UI element''s alignment when picking an `Anchor` point,
    you have to hold the *Shift* key and repeat the previous step. Alternately, to
    update both the position and the alignment of the button, picking the center `Anchor`
    point while holding both the *Ctrl* and *Shift* keys will do the job. This should
    then be the result:![Figure 8.14: The Button element being centered relative to
    its selected'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`Anchor`点时更新UI元素的对齐方式，您必须按住*Shift*键并重复上一步。或者，为了同时更新按钮的位置和对齐方式，选择中心`Anchor`点时同时按住*Ctrl*和*Shift*键将完成任务。然后应该是这个结果：![图8.14：按钮元素相对于其选定的中心位置居中
- en: Anchor in the center
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 居中的锚点
- en: '](img/B16183_08_14.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_14.jpg)'
- en: 'Figure 8.14: The Button element being centered relative to its selected Anchor
    in the center'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：按钮元素相对于其选定的锚点在中心位置
- en: At this point, when changing the resolution of the screen, we know that this
    button will always remain at the center of the screen. However, in order to maintain
    the Button's size relative to the resolution, we'll need to make a few more modifications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当改变屏幕的分辨率时，我们知道这个按钮将始终保持在屏幕中心。然而，为了保持按钮相对于分辨率的大小，我们需要进行一些修改。
- en: 'Drag the bottom-right *petal* of the `Anchor Medallion` all the way to the
    bottom-right corner of the button:![Figure 8.15: Dragging the lower-right petal
    of the Anchor Medallion'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Anchor Medallion`的右下角*花瓣*拖动到按钮的右下角：![图8.15：拖动锚点奖章的右下角花瓣
- en: to update the Button element's Anchor
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更新按钮元素的锚点
- en: '](img/B16183_08_15.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_15.jpg)'
- en: 'Figure 8.15: Dragging the lower-right petal of the Anchor Medallion to update
    the Button element''s Anchor'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：拖动锚点奖章的右下角花瓣以更新按钮元素的锚点
- en: 'Drag the top-left *petal* of the `Anchor Medallion` all the way to the top-left
    corner of the button:![Figure 8.16: Dragging the upper-left petal of the Anchor
    Medallion'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Anchor Medallion`的左上角*花瓣*拖动到按钮的左上角：![图8.16：拖动锚点奖章的左上角花瓣
- en: to update the Button element's Anchor
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更新按钮元素的锚点
- en: '](img/B16183_08_16.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_16.jpg)'
- en: 'Figure 8.16: Dragging the upper-left petal of the Anchor Medallion to update
    the Button element''s Anchor'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：拖动锚点奖章的左上角花瓣以更新按钮元素的锚点
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The percentages you see around the button when changing the `Anchor` are the
    space the element is occupying on the screen as a percentage. For instance, looking
    at the last screenshot, we can see that the button is occupying `11.9%` of the
    Widget's space on the *X* coordinate and `8.4%` of the Widget's space on the *Y*
    coordinate.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改“锚点”时，您在按钮周围看到的百分比是元素在屏幕上所占空间的百分比。例如，看最后一个截图，我们可以看到按钮在*X*坐标上占小部件空间的“11.9%”，在*Y*坐标上占小部件空间的“8.4%”。
- en: You can set the size of a UI element to the size of its Anchor by holding the
    *Ctrl* key while moving the Anchor Medallion *petals*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按住*Ctrl*键移动“锚点勋章”的*花瓣*，可以将UI元素的大小设置为其锚点的大小。
- en: Now our button will finally adapt to varying screen sizes and resolutions due
    to these changes to its Anchor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于这些对锚点的更改，我们的按钮最终将适应不同的屏幕尺寸和分辨率。
- en: 'You can also use the `Details` panel to manually edit all of the properties
    we just edited by using the `Anchor Medallion` and moving the button:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用“详细”面板手动编辑我们刚刚使用“锚点勋章”和移动按钮编辑的所有属性：
- en: '![Figure 8.17: The properties we changed using the Anchor Medallion, shown'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：我们使用锚点勋章更改的属性，显示'
- en: in the Details window
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细窗口中
- en: '](img/B16183_08_17.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_17.jpg)'
- en: 'Figure 8.17: The properties we changed using the Anchor Medallion, shown in
    the Details window'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：我们使用锚点勋章更改的属性，显示在详细窗口中
- en: Lastly, we need to know how we can visualize our Widget with different resolutions
    in the `Designer` tab.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要知道如何在“设计师”选项卡中使用不同的分辨率来可视化我们的小部件。
- en: 'Drag the double arrow at the bottom right of the outlined box inside the `Designer`
    tab:![Figure 8.18: The double arrow at the bottom right of the outlined'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动设计师选项卡内部轮廓框的右下方的双箭头：![图8.18：设计师选项卡内部轮廓框的右下方的双箭头
- en: box inside the Designer tab
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师选项卡内部轮廓框的右下方
- en: '](img/B16183_08_18.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_18.jpg)'
- en: 'Figure 8.18: The double arrow at the bottom right of the outlined box inside
    the Designer tab'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：在设计师选项卡内部轮廓框的右下方有双箭头
- en: 'By dragging the double arrow you can resize the `Canvas` to any screen resolution
    you want. In the following screenshot, you''ll see the most used resolutions for
    a variety of devices, and you can preview your Widget in each of them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拖动双箭头，您可以将“画布”调整到任何屏幕分辨率。在下面的截图中，您将看到各种设备的最常用分辨率，并且您可以在每个分辨率下预览您的小部件：
- en: '![Figure 8.19: The resolutions we can choose to preview in the Designer window'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：我们可以选择在设计师窗口中预览的分辨率'
- en: '](img/B16183_08_19.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_19.jpg)'
- en: 'Figure 8.19: The resolutions we can choose to preview in the Designer window'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：我们可以选择在设计师窗口中预览的分辨率
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a full reference to UMG's Anchors at [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors)找到UMG锚点的完整参考。
- en: And that concludes our exercise. You've learned about Anchors and adapting your
    Widgets to varying screen sizes and resolutions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的练习。您已经了解了锚点和如何使您的小部件适应不同的屏幕尺寸和分辨率。
- en: Now that we've learned about some of the basics of UMG, let's see how we can
    create a Widget C++ class for this Widget Blueprint, which is what we're going
    to do in the next exercise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些UMG的基础知识，让我们看看如何为这个小部件蓝图创建一个小部件C++类，这是我们将在下一个练习中要做的事情。
- en: 'Exercise 8.03: Creating the RestartWidget C++ Class'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：创建RestartWidget C++类
- en: In this exercise, we will learn how to create a Widget C++ class, from which
    the Widget Blueprint that we created will inherit from. It will get added to the
    screen when the player dies in our `Dodgeball` game so that the player can have
    the option to restart the level. This Widget will have a button that will restart
    the level when the player clicks it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何创建一个小部件C++类，从中我们创建的小部件蓝图将继承。在我们的“躲避球”游戏中，当玩家死亡时，它将被添加到屏幕上，以便玩家可以选择重新开始级别。这个小部件将有一个按钮，当玩家点击它时，将重新开始级别。
- en: The first step of this exercise will be adding the UMG-related modules to our
    project. Unreal Engine comprises several different modules, and in each project,
    you have to specify which ones you're going to use. Our project came with a few
    general modules when the source code files were generated, but we'll need to add
    a few more.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的第一步将是向我们的项目添加与UMG相关的模块。虚幻引擎包括几个不同的模块，在每个项目中，您都必须指定您要使用哪些模块。当源代码文件生成时，我们的项目已经带有一些通用模块，但我们需要添加一些更多的模块。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Open the `Dodgeball.build.cs` file, which is a C# file and not a C++ file, located
    inside your project's `Source` folder.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于项目“Source”文件夹内的C#文件而不是C++文件的“Dodgeball.build.cs”文件。
- en: 'Open the file, and you''ll find the `AddRange` function from the `PublicDependencyModuleNames`
    property being called. This is the function that tells the engine which modules
    this project intends to use. As a parameter, an array of strings is sent, with
    the names of all the intended modules for the project. Given that we intend on
    using UMG, we''ll need to add the UMG-related modules: `UMG`, `Slate`, and `SlateCore`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件，您会发现从“PublicDependencyModuleNames”属性调用的“AddRange”函数。这个函数告诉引擎这个项目打算使用哪些模块。作为参数，发送了一个字符串数组，其中包含项目的所有预期模块的名称。鉴于我们打算使用UMG，我们需要添加与UMG相关的模块：“UMG”，“Slate”和“SlateCore”：
- en: '[PRE0]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we notified the engine that we''ll be using the UMG modules, let''s
    create our Widget C++ class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通知引擎我们将使用UMG模块，让我们创建我们的小部件C++类：
- en: Open the Unreal editor.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开虚幻编辑器。
- en: Right-click on the Content Browser and select `New C++ Class`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击内容浏览器，然后选择“新的C++类”。
- en: Set the `Show All Classes` checkbox to `true`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“显示所有类”复选框设置为“true”。
- en: Search for the `UserWidget` class and choose that as the new class's parent class.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索“UserWidget”类，并将其选择为新类的父类。
- en: Name the new C++ class `RestartWidget`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的C++类命名为“RestartWidget”。
- en: 'After the files have been opened in Visual Studio, start making modifications
    to our Widget C++ class as mentioned in the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件在Visual Studio中打开后，按照以下步骤对我们的Widget C++类进行修改：
- en: 'The first thing we''ll add to this class is a `public` `class UButton*` property
    called `RestartButton`, which represents the Button the player will press in order
    to restart the level. You will want it to be bound to a Button in the Blueprint
    class that inherits from this class, by using the `UPROPERTY` macro with the `BindWidget`
    meta tag. This will force that Widget Blueprint to have a `Button` called `RestartButton`
    that we can access in C++ through this property and then freely edit its properties,
    such as the size and position, in the Blueprint:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要添加到这个类的第一件事是一个名为`RestartButton`的`public` `class UButton*`属性，它代表玩家将按下以重新启动级别的按钮。您将希望它通过使用`UPROPERTY`宏和`BindWidget`元标记绑定到从该类继承的蓝图类中的按钮。这将强制Widget蓝图具有一个名为`RestartButton`的`Button`，我们可以通过此属性在C++中访问它，然后自由编辑其属性，例如在蓝图中的大小和位置：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using the `BindWidget` meta tag will cause a compilation error if the Widget
    Blueprint that inherits from this C++ class doesn''t have an element with the
    same type and name. If you don''t want this to happen, you will have to mark `UPROPERTY`
    as an optional `BindWidget` like so:`UPROPERTY(meta = (BindWidget, OptionalWidget
    = true))`     This will make it so that binding this property is optional and doesn''t cause
    a compilation error when compiling the Widget Blueprint.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BindWidget`元标记将导致编译错误，如果从该C++类继承的Widget蓝图没有具有相同类型和名称的元素。如果您不希望发生这种情况，您将不得不将`UPROPERTY`标记为可选的`BindWidget`，如下所示：`UPROPERTY(meta
    = (BindWidget, OptionalWidget = true))`这将使绑定此属性变为可选，并且在编译Widget蓝图时不会导致编译错误。
- en: Next, we're going to add the function that will be called when the player clicks
    the `RestartButton`, which will restart the level. We will be doing this using
    the `GameplayStatics` object's `OpenLevel` function and then sending the name
    of the current level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个函数，当玩家点击`RestartButton`时将被调用，这将重新启动级别。我们将使用`GameplayStatics`对象的`OpenLevel`函数来实现这一点，然后发送当前级别的名称。
- en: 'In the Widget class''s header file, add a declaration for a `protected` function
    called `OnRestartClicked` that returns nothing and receives no parameters. This
    function must be marked as `UFUNCTION`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Widget类的头文件中，添加一个名为`OnRestartClicked`的`protected`函数的声明，它不返回任何内容并且不接收任何参数。此函数必须标记为`UFUNCTION`：
- en: '[PRE2]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the class''s source file, add an `include` for the `GameplayStatics` object:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，添加一个`GameplayStatics`对象的`include`：
- en: '[PRE3]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add an implementation for our `OnRestartClicked` function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为我们的`OnRestartClicked`函数添加一个实现：
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside its implementation, call the `GameplayStatics` object''s `OpenLevel`
    function. This function receives as parameters a world context object, which will
    be the `this` pointer, and the name of the level, which we''ll have to fetch using
    the `GameplayStatics` object''s `GetCurrentLevelName` function. This last function
    must also receive a world context object, which will also be the `this` pointer:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其实现中，调用`GameplayStatics`对象的`OpenLevel`函数。此函数接收世界上下文对象作为参数，这将是`this`指针，并且级别的名称，我们将不得不使用`GameplayStatics`对象的`GetCurrentLevelName`函数来获取。这个最后的函数也必须接收一个世界上下文对象，这也将是`this`指针：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The call to the `GameplayStatics` object's `GetCurrentLevelName` function must
    be preceded with `*` because it returns an `FString`, UE4's string type, and must
    be dereferenced in order to be passed to the `FName` constructor.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对`GameplayStatics`对象的`GetCurrentLevelName`函数的调用必须在前面加上`*`，因为它返回一个`FString`，UE4的字符串类型，并且必须被解引用才能传递给`FName`构造函数。
- en: 'The next step will be binding this function in such a way that it is called
    when the player presses the `RestartButton`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是以一种方式绑定此函数，以便在玩家按下`RestartButton`时调用它：
- en: 'In order to do this, we''ll have to override a function that belongs to the
    `UserWidget` class, called `NativeOnInitialized`. This function is called only
    once, similarly to the Actor''s `BeginPlay` function, which makes it appropriate
    to do our setup. Add a declaration for the `public` `NativeOnInitialized` function
    with both the `virtual` and `override` keyword in our Widget class''s header file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将不得不重写属于`UserWidget`类的一个函数，名为`NativeOnInitialized`。这个函数只被调用一次，类似于Actor的`BeginPlay`函数，这使得它适合进行我们的设置。在我们的Widget类的头文件中，使用`virtual`和`override`关键字添加一个`public`
    `NativeOnInitialized`函数的声明：
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, in the class''s source file, add the implementation of this function.
    Inside it, call its `Super` function and add an `if` statement that checks whether
    our `RestartButton` is different than `nullptr`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在类的源文件中，添加此函数的实现。在其中，调用其`Super`函数并添加一个`if`语句，检查我们的`RestartButton`是否与`nullptr`不同：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the `if` statement is true, we''ll want to bind our `OnRestartClicked` function
    to the button''s `OnClicked` event. We can do this by accessing the button''s
    `OnClicked` property and calling its `AddDynamic` function, sending as parameters
    the object we want to call that function on, the `this` pointer, and a pointer
    to the function to be called, the `OnRestartClicked` function:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if`语句为真，我们将希望将我们的`OnRestartClicked`函数绑定到按钮的`OnClicked`事件。我们可以通过访问按钮的`OnClicked`属性并调用其`AddDynamic`函数来实现这一点，将我们想要调用该函数的对象（即`this`指针）和要调用的函数的指针（即`OnRestartClicked`函数）作为参数发送：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because we''re accessing functions related to the `Button` class, we''ll also
    have to include it:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们正在访问与`Button`类相关的函数，所以我们还必须包含它：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A Button's `OnClicked` event will be called when the player presses and releases
    that button with the mouse. There are other events related to the button, including
    the `OnPressed` event (when the player presses the button), the `OnReleased` event
    (when the player releases the button), and the `OnHover` and `OnUnhover` events
    (when the player respectively starts and stops hovering the mouse over that button).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下并释放按钮时，按钮的`OnClicked`事件将被调用。还有其他与按钮相关的事件，包括`OnPressed`事件（当玩家按下按钮时），`OnReleased`事件（当玩家释放按钮时），以及`OnHover`和`OnUnhover`事件（当玩家分别开始和停止悬停在按钮上时）。
- en: The `AddDynamic` function must receive as a parameter a pointer to a function
    marked with the `UFUNCTION` macro. If it doesn't, you will get an error when calling
    that function. This is why we marked the `OnRestartClicked` function with the
    `UFUNCTION` macro.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDynamic`函数必须接收一个标记有`UFUNCTION`宏的函数的指针作为参数。如果没有，当调用该函数时会出现错误。这就是为什么我们用`UFUNCTION`宏标记了`OnRestartClicked`函数的原因。'
- en: After you've done these steps, compile your changes and open the editor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，编译您的更改并打开编辑器。
- en: Open the `TestWidget` Widget Blueprint that you created earlier. We'll want
    to associate this Widget Blueprint with the `RestartWidget` class we just created,
    so we need to reparent it.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您之前创建的`TestWidget` Widget Blueprint。我们希望将这个Widget Blueprint与我们刚刚创建的`RestartWidget`类关联起来，所以我们需要重新设置其父类。
- en: 'From the Widget Blueprint''s `File` tab, select the `Reparent Blueprint` option
    and choose the `RestartWidget` C++ class as its new parent class:![Figure 8.20:
    Reparenting the TestWidget''s class to RestartWidget'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Widget Blueprint的`File`选项卡中，选择`Reparent Blueprint`选项，并选择`RestartWidget` C++类作为其新的父类：![图8.20：将TestWidget的类重新设置为RestartWidget
- en: '](img/B16183_08_20.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_20.jpg)'
- en: 'Figure 8.20: Reparenting the TestWidget''s class to RestartWidget'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：将TestWidget的类重新设置为RestartWidget
- en: 'You''ll notice that the Widget Blueprint now has a compilation error related
    to the `BindWidget` meta tag that we created in the C++ class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到Widget Blueprint现在有一个与我们在C++类中创建的`BindWidget`元标记相关的编译错误：
- en: '![Figure 8.21: Compiler errors after setting the parent class to the RestartWidget
    class'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21：设置父类为RestartWidget类后的编译错误'
- en: '](img/B16183_08_21.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_21.jpg)'
- en: 'Figure 8.21: Compiler errors after setting the parent class to the RestartWidget
    class'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：设置父类为RestartWidget类后的编译错误
- en: This is caused by the fact that the C++ class couldn't find any `Button` property
    called `RestartButton`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于C++类找不到名为`RestartButton`的`Button`属性造成的。
- en: 'In order to fix this, we''ll need to rename our `Button` element inside the
    Widget Blueprint to `RestartButton`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将Widget Blueprint中的`Button`元素重命名为`RestartButton`：
- en: '![Figure 8.22: Renaming the Button element to RestartButton'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22：将按钮元素重命名为RestartButton'
- en: '](img/B16183_08_22.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_22.jpg)'
- en: 'Figure 8.22: Renaming the Button element to RestartButton'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：将按钮元素重命名为RestartButton
- en: After you've done this, close the Widget Blueprint and change its name from
    `TestWidget` to `BP_RestartWidget`, the same way you just did in the previous step.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，关闭Widget Blueprint，并将其名称从`TestWidget`更改为`BP_RestartWidget`，就像你在上一步中所做的那样。
- en: That concludes the creation of our Widget class. You now know how to connect
    a Widget C++ class to a Widget Blueprint, a very important step toward handling
    Game UI in UE4.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的Widget类的创建。您现在知道如何将Widget C++类连接到Widget Blueprint，这是处理UE4中游戏UI的一个非常重要的步骤。
- en: The next thing we need to do is create our `Player Controller` C++ class, which
    will be responsible for instantiating our `RestartWidget` and adding it to the
    screen. We will be doing this in the following exercise.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是创建我们的`Player Controller` C++类，它将负责实例化我们的`RestartWidget`并将其添加到屏幕上。我们将在接下来的练习中完成这个任务。
- en: 'Exercise 8.04: Creating the Logic for Adding the RestartWidget to the Screen'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.04：创建将RestartWidget添加到屏幕的逻辑
- en: In this exercise, we will create the logic responsible for adding our newly
    created `RestartWidget` to the screen. It will appear on screen when the player
    dies so that they have the option to restart the level.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建负责将我们新创建的`RestartWidget`添加到屏幕上的逻辑。当玩家死亡时，它将出现在屏幕上，以便他们有重新开始关卡的选项。
- en: 'In order to do this, we''ll have to create a new `Player Controller` C++ class,
    which you can do by following these steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要创建一个新的`Player Controller` C++类，您可以按照以下步骤进行：
- en: Open the Unreal editor.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开虚幻编辑器。
- en: '*Right-click* on the `Content Browser` and select `New C++ Class`.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`上*右键单击*，选择`New C++ Class`。
- en: Search for the `Player Controller` class and choose that as the new class's
    parent class.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`Player Controller`类并选择它作为新类的父类。
- en: Name the new C++ class `DodgeballPlayerController`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的C++类命名为`DodgeballPlayerController`。
- en: Open the class's files in Visual Studio.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开类的文件。
- en: When our player runs out of health points, the `DodgeballCharacter` class will
    access this `Player Controller` class and call a function that will add the `RestartWidget`
    to the screen. Follow these steps ahead in order to make this happen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的玩家耗尽生命值时，`DodgeballCharacter`类将访问这个`Player Controller`类，并调用一个函数，该函数将在屏幕上添加`RestartWidget`。请按照以下步骤继续进行。
- en: In order to know the class of the Widget to add to the screen (which will be
    a Widget Blueprint and not a Widget C++ class), we'll need to use the `TSubclassOf`
    type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道要添加到屏幕上的Widget的类（它将是一个Widget Blueprint而不是Widget C++类），我们需要使用`TSubclassOf`类型。
- en: 'In the class''s header file, add a `public` `TSubclassOf<class URestartWidget>`
    property called `BP_RestartWidget`. Be sure to make it a `UPROPERTY` with the
    `EditDefaultsOnly` tag so that we can edit it in the Blueprint class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的头文件中，添加一个名为`BP_RestartWidget`的`public` `TSubclassOf<class URestartWidget>`属性。确保将其设置为`UPROPERTY`，并使用`EditDefaultsOnly`标记，以便我们可以在蓝图类中编辑它：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to instantiate this Widget and add it to the screen, we'll need to
    save a reference to it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实例化这个Widget并将其添加到屏幕上，我们需要保存一个对它的引用。
- en: 'Add a new `private` variable of type `class URestartWidget*` and call it `RestartWidget`.
    Be sure to make it a `UPROPERTY` function with no tags:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`private`类型为`class URestartWidget*`的新变量，并将其命名为`RestartWidget`。确保将其设置为没有标签的`UPROPERTY`函数：
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although this property isn't supposed to be editable in a Blueprint class, we
    have to make this reference a `UPROPERTY`, otherwise the garbage collector will
    destroy the contents of this variable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个属性不应该在蓝图类中可编辑，但我们必须将这个引用设置为`UPROPERTY`，否则垃圾收集器将销毁这个变量的内容。
- en: The next thing we need is a function responsible for adding our Widget to the screen.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一步是一个负责将我们的小部件添加到屏幕上的函数。
- en: 'Add a declaration for a `public` function that returns nothing and receives
    no parameters called `ShowRestartWidget`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个声明为返回无内容并且不接收参数的`public`函数，名为`ShowRestartWidget`：
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, head to our class''s source file. First, add an include to the `RestartWidget`
    class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到我们类的源文件。首先，添加一个包含到`RestartWidget`类的包含：
- en: '[PRE13]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, add the implementation of our `ShowRestartWidget` function, where we''ll
    start by checking whether our `BP_RestartWidget` variable is not a `nullptr`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加我们的`ShowRestartWidget`函数的实现，我们将首先检查我们的`BP_RestartWidget`变量是否不是`nullptr`：
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If that variable is valid (different than `nullptr`), we want to pause the
    game using the `SetPause` function of `Player Controller`. This will make sure
    that the game stops until the player decides to do something (which in our case
    will be pressing the button that restarts the level):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该变量有效（不同于`nullptr`），我们希望使用`Player Controller`的`SetPause`函数暂停游戏。这将确保游戏停止，直到玩家决定做些什么（在我们的情况下，将按下重新开始关卡的按钮）：
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next thing we''ll do is change the input mode. In UE4, there are three
    input modes: `Game Only`, `Game and UI`, and `UI Only`. If your `Input` Mode includes
    `Game`, that means that the player character and player controller will receive
    inputs through the `Input Actions`. If your `Input` Mode includes `UI`, that means
    that the Widgets that are on the screen will receive inputs from the player. When
    we show this Widget on the screen, we won''t want the player character to receive
    any input.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是改变输入模式。在UE4中，有三种输入模式：`仅游戏`，`游戏和UI`和`仅UI`。如果您的`输入`模式包括`游戏`，这意味着玩家角色和玩家控制器将通过`输入操作`接收输入。如果您的`输入`模式包括`UI`，这意味着屏幕上的小部件将接收玩家的输入。当我们在屏幕上显示此小部件时，我们不希望玩家角色接收任何输入。
- en: 'Hence, update to the `UI Only` `Input` Mode. You can do this by calling the
    `Player Controller` `SetInputMode` function and passing the `FInputModeUIOnly`
    type as a parameter:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，更新为`仅UI` `输入`模式。您可以通过调用`Player Controller`的`SetInputMode`函数，并将`FInputModeUIOnly`类型作为参数传递来实现这一点：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this, we want to show the mouse cursor, so that the player can see which
    button they are hovering the mouse on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们希望显示鼠标光标，以便玩家可以看到他们悬停在哪个按钮上。
- en: 'We will do this by setting the `Player Controller`''s `bShowMouseCursor` property
    to `true`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过将`Player Controller`的`bShowMouseCursor`属性设置为`true`来实现这一点：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can actually instantiate our Widget using the `Player Controller`''s
    `CreateWidget` function, passing as a template parameter the C++ Widget class,
    which in our case is `RestartWidget`, and then as normal parameters the `Owning
    Player`, which is the `Player Controller` that owns this Widget and that we''ll
    send using the `this` pointer, and the Widget class, which will be our `BP_RestartWidget`
    property:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以实例化我们的小部件，使用`Player Controller`的`CreateWidget`函数，将C++小部件类作为模板参数传递，这在我们的情况下是`RestartWidget`，然后作为正常参数传递`Owning
    Player`，这是拥有此小部件的`Player Controller`，我们将使用`this`指针发送，以及小部件类，这将是我们的`BP_RestartWidget`属性：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After we instantiate the Widget, we''ll want to add it to the screen, using
    the Widget''s `AddToViewport` function:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实例化小部件之后，我们将使用小部件的`AddToViewport`函数将其添加到屏幕上：
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That concludes our `ShowRestartWidget` function. However, we also need to create
    the function that will remove the `RestartWidget` from the screen. In the class''s
    header file, add a declaration for a function just like the `ShowRestartWidget`
    function, but this time called `HideRestartWidget`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了我们的`ShowRestartWidget`函数。但是，我们还需要创建一个函数，用于从屏幕上移除`RestartWidget`。在类的头文件中，添加一个声明为与`ShowRestartWidget`函数类似的函数，但这次名为`HideRestartWidget`：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the class''s source file, add the implementation for the `HideRestartWidget` function:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，添加`HideRestartWidget`函数的实现：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first thing we should do in this function is remove the Widget from the
    screen by calling its `RemoveFromParent` function, and destroy it using the `Destruct`
    function:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们应该首先通过调用其`RemoveFromParent`函数将小部件从屏幕上移除，并使用`Destruct`函数将其销毁：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we want to unpause the game using the `SetPause` function we used in
    the previous function:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们希望使用前一个函数中使用的`SetPause`函数取消暂停游戏：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally, set the `Input` Mode to `Game Only` and hide the mouse cursor
    the same way we did in the previous function (this time we pass the `FInputModeGameOnly`
    type instead):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`输入`模式设置为`仅游戏`，并以与前一个函数相同的方式隐藏鼠标光标（这次我们传递`FInputModeGameOnly`类型）：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And that concludes the logic for our `Player Controller` C++ class. The next
    thing we should do is call the function that will add our Widget to the screen.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的`Player Controller` C++类的逻辑。我们接下来应该调用一个函数，将我们的小部件添加到屏幕上。
- en: 'Go to the `DodgeballCharacter` class''s source file and add the `include` keyword
    to our newly created `DodgeballPlayerController`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`DodgeballCharacter`类的源文件，并向我们新创建的`DodgeballPlayerController`添加`include`关键字：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the `DodgeballCharacter` class''s implementation of the `OnDeath_Implementation`
    function, replace the call to the `QuitGame` function with the following:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballCharacter`类的`OnDeath_Implementation`函数的实现中，用以下内容替换对`QuitGame`函数的调用：
- en: 'Get the character''s player controller using the `GetController` function.
    You''ll want to save the result in a variable of type `DodgeballPlayerController*`
    called `PlayerController`. Because the function will return a variable of type
    `Controller`, you''ll also need to cast it to our `PlayerController` class:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GetController`函数获取角色的玩家控制器。您将希望将结果保存在名为`PlayerController`的`DodgeballPlayerController*`类型的变量中。因为该函数将返回一个`Controller`类型的变量，您还需要将其转换为我们的`PlayerController`类：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check whether the `PlayerController` variable is valid. If it is, call its
    `ShowRestartWidget` function:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`PlayerController`变量是否有效。如果是，调用其`ShowRestartWidget`函数：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After these modifications, the last thing left for us to do is to call the function
    that will hide our Widget from the screen. Open the `RestartWidget` class's source
    file and implement the following modifications.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了这些修改之后，我们唯一剩下的事情就是调用将我们的小部件从屏幕上隐藏的函数。打开`RestartWidget`类的源文件并实现以下修改。
- en: 'Add an `include` to the `DodgeballPlayerController`, which contains the function
    that we will be calling:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DodgeballPlayerController`添加一个`include`，其中包含我们将要调用的函数：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the `OnRestartClicked` function implementation, before the call to the
    `OpenLevel` function, we must fetch the Widget''s `OwningPlayer`, which is of
    type `PlayerController`, using the `GetOwningPlayer` function, and cast it to
    the `DodgeballPlayerController` class:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnRestartClicked`函数实现中，在调用`OpenLevel`函数之前，我们必须使用`GetOwningPlayer`函数获取小部件的`OwningPlayer`，它是`PlayerController`类型的，并将其转换为`DodgeballPlayerController`类：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, if the `PlayerController` variable is valid, we call its `HideRestartWidget`
    function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果`PlayerController`变量有效，我们调用其`HideRestartWidget`函数：
- en: '[PRE30]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After you've followed all these steps, close the editor, compile your changes
    and open the editor.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成所有这些步骤之后，关闭编辑器，编译您的更改并打开编辑器。
- en: You have now concluded this exercise. We have added all the necessary logic
    to add our `RestartWidget` to the screen, and the only thing left for us to do
    is creating the Blueprint class of our newly created `DodgeballPlayerController`,
    which we'll be doing in the next exercise.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了这个练习。我们已经添加了所有必要的逻辑，将我们的`RestartWidget`添加到屏幕上，我们唯一剩下的事情就是创建我们新创建的`DodgeballPlayerController`的蓝图类，这将在下一个练习中完成。
- en: 'Exercise 8.05: Setting up the DodgeballPlayerController Blueprint Class'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.05：设置DodgeballPlayerController蓝图类
- en: In this exercise, we will be creating the Blueprint class of our `DodgeballPlayerController`
    in order to specify which Widget we want to add to the screen, and tell UE4 to
    use this Blueprint class when the game starts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的`DodgeballPlayerController`的蓝图类，以指定我们要添加到屏幕上的小部件，并告诉UE4在游戏开始时使用这个蓝图类。
- en: 'In order to do that, follow these steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤进行：
- en: Go to the `ThirdPersonCPP` -> `Blueprints` directory in the Content Browser,
    right-click on it, and create a new Blueprint class.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content Browser`中的`ThirdPersonCPP` -> `Blueprints`目录，在其中右键单击，并创建一个新的蓝图类。
- en: Search for the `DodgeballPlayerController` class and select it as the parent
    class.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`DodgeballPlayerController`类并将其选择为父类。
- en: Rename this Blueprint class to `BP_DodgeballPlayerController`. After that, open
    this Blueprint asset.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此蓝图类重命名为`BP_DodgeballPlayerController`。之后，打开此蓝图资源。
- en: Go to its `Class Defaults` tab and set the class's `BP_RestartWidget` property
    to the `BP_RestartWidget` Widget Blueprint we created.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到其`Class Defaults`选项卡，并将类的`BP_RestartWidget`属性设置为我们创建的`BP_RestartWidget`小部件蓝图。
- en: Now, the only thing left for us to do is to make sure that this `Player Controller`
    Blueprint class is being used in the game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们唯一剩下的事情就是确保这个`Player Controller`蓝图类在游戏中被使用。
- en: In order to do this, we'll have to follow a few more steps.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们还需要遵循一些步骤。
- en: Go to the `ThirdPersonCPP` -> `Blueprints` directory in the `Content Browser`,
    *right-click* on it and create a new Blueprint class. Search for the `DodgeballGameMode`
    class and select it as the parent class, then rename this `Blueprint` class to
    `BP_DodgeballGameMode`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content Browser`中的`ThirdPersonCPP` -> `Blueprints`目录，在其中*右键单击*，创建一个新的蓝图类。搜索`DodgeballGameMode`类并将其选择为父类，然后将此`Blueprint`类重命名为`BP_DodgeballGameMode`。
- en: This class is responsible for telling the game which classes to use for each
    element of the game, such as which `Player Controller` class to use, among other
    things.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责告诉游戏使用哪些类来处理游戏的每个元素，比如使用哪个`Player Controller`类等。
- en: 'Open the asset, go to its `Class Defaults` tab, and set the class''s `PlayerControllerClass`
    property to the `BP_DodgeballPlayerController` class we created:![Figure 8.23:
    Setting the PlayerControllerClass property to BP_DodgeballPlayerController'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开资源，转到其`Class Defaults`选项卡，并将类的`PlayerControllerClass`属性设置为我们创建的`BP_DodgeballPlayerController`类：![图8.23：将PlayerControllerClass属性设置为BP_DodgeballPlayerController
- en: '](img/B16183_08_23.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_23.jpg)'
- en: 'Figure 8.23: Setting the PlayerControllerClass property to BP_DodgeballPlayerController'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：将PlayerControllerClass属性设置为BP_DodgeballPlayerController
- en: Close the asset and select the `Blueprints` drop-down option inside the editor
    toolbar that is at the top of the `Level Viewport` window. From there, select
    `Game Mode` (which should currently be set to `DodgeballGameMode`) `-> Select
    GameModeBase Class -> BP_DodgeballGameMode`. This will tell the editor to use
    this new `Game Mode` in all levels.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭资源并在位于`Level Viewport`窗口顶部的编辑器工具栏内选择`Blueprints`下拉选项。从那里，选择`Game Mode`（当前应设置为`DodgeballGameMode`）`->
    选择GameModeBase Class -> BP_DodgeballGameMode`。这将告诉编辑器在所有关卡中使用这个新的`Game Mode`。
- en: 'Now, play the game and let your character get hit by a Dodgeball `3` times.
    After the third time, you should see the game get paused and show `BP_RestartWidget`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩游戏，让您的角色被Dodgeball击中`3`次。第三次之后，您应该看到游戏被暂停，并显示`BP_RestartWidget`：
- en: '![Figure 8.24: Our BP_RestartWidget being added to the screen after the player'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：在玩家耗尽生命值后将我们的BP_RestartWidget添加到屏幕上'
- en: runs out of health points
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 耗尽生命值
- en: '](img/B16183_08_24.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_24.jpg)'
- en: 'Figure 8.24: Our BP_RestartWidget being added to the screen after the player
    runs out of health points'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：在玩家耗尽生命值后将我们的BP_RestartWidget添加到屏幕上
- en: 'And when you click `Button 1` using your mouse, you should see the level reset
    to its initial state:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用鼠标点击“按钮1”时，您应该看到关卡重置为初始状态：
- en: '![Figure 8.25: The level restarts after the player presses the button'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：玩家按下按钮后关卡重新开始'
- en: shown in the previous screenshot
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个截图中显示
- en: '](img/B16183_08_25.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_25.jpg)'
- en: 'Figure 8.25: The level restarts after the player presses the button shown in
    the previous screenshot'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：玩家按下前一个截图中显示的按钮后，关卡重新开始
- en: And that concludes our exercise. You now know how to create Widgets and show
    them in your game. This is another crucial step in your journey toward becoming
    a skilled game developer.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的练习。您现在知道如何创建小部件并在游戏中显示它们。这是成为一名熟练游戏开发者的旅程中的又一个关键步骤。
- en: Before we move on to the next exercise, let's take a look at Progress Bars in
    the next section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个练习之前，让我们在下一节中看一下进度条。
- en: Progress Bars
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进度条
- en: One of the ways that video games can represent character stats such as health,
    stamina, and so on is through **Progress Bars**, which are what we'll use to communicate
    to the player how much health their character has. Progress Bars are essentially
    a shape, usually rectangular, that can be filled and emptied in order to show
    the player how a specific stat is progressing. If you want to show the player
    that their character's health is only half its maximum value, you could do this
    by showing the Progress Bar as half full. This is exactly what we'll be doing
    in this section. This Progress Bar will be the only element in our Dodgeball game's
    HUD.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏表示角色状态（如生命值、耐力等）的一种方式是通过**进度条**，这是我们将用来向玩家传达他们的角色有多少生命值的方式。进度条本质上是一个形状，通常是矩形，可以填充和清空，以显示玩家特定状态的进展。如果您想向玩家显示他们的角色生命值只有最大值的一半，您可以通过显示进度条为一半来实现。这正是我们将在本节中要做的。这个进度条将是我们躲避球游戏HUD中唯一的元素。
- en: In order to create this `Health Bar`, we'll first need to create our HUD Widget.
    Open the editor, go to the `ThirdPersonCPP` -> `Blueprints` directory inside the
    Content Browser, and right-click and create a new `Widget Blueprint` class of
    the `User Interface` category. Name this new Widget Blueprint `BP_HUDWidget`.
    After that, open this new Widget Blueprint.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个“生命值条”，我们首先需要创建我们的HUD小部件。打开编辑器，转到内容浏览器内的“ThirdPersonCPP” -> “蓝图”目录，右键单击并创建一个新的“小部件蓝图”类别的“用户界面”类别。将这个新的小部件蓝图命名为“BP_HUDWidget”。然后打开这个新的小部件蓝图。
- en: 'Progress Bars in UE4 are just another UI element, like `Buttons` and `Text`
    elements, which means we can drag it from the `Palette` tab into our `Designer`
    tab. Have a look at the following example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: UE4中的进度条只是另一个UI元素，就像`按钮`和`文本`元素一样，这意味着我们可以将它从`调色板`选项卡拖到我们的`设计师`选项卡中。看下面的例子：
- en: '![Figure 8.26: Dragging a Progress Bar element into the Designer window'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26：将进度条元素拖入设计师窗口'
- en: '](img/B16183_08_26.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_26.jpg)'
- en: 'Figure 8.26: Dragging a Progress Bar element into the Designer window'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：将进度条元素拖入设计师窗口
- en: 'At first, this Progress Bar might look similar to a button; however, it contains
    two specific properties that are important for a Progress Bar:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个进度条可能看起来类似于一个按钮；然而，它包含两个对于进度条很重要的特定属性：
- en: '`Percent` – allows you to specify this Progress Bar''s progress, from `0` to
    `1`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`百分比` - 允许您指定此进度条的进度，从`0`到`1`'
- en: '`Bar Fill Type` – allows you to specify how you want this Progress Bar to fill
    (from left to right, top to bottom, and so on):'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`填充类型` - 允许您指定您希望此进度条如何填充（从左到右，从上到下等）：'
- en: '![Figure 8.27: The Progress Bar''s Percent and Bar Fill Type properties'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27：进度条的百分比和填充类型属性'
- en: '](img/B16183_08_27.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_27.jpg)'
- en: 'Figure 8.27: The Progress Bar''s Percent and Bar Fill Type properties'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：进度条的百分比和填充类型属性
- en: 'If you set the `Percent` property to `0.5`, you should see the Progress Bar
    be updated accordingly to fill half of its length:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将“百分比”属性设置为“0.5”，则应该看到进度条相应地更新以填充其长度的一半：
- en: '![Figure 8.28: The Progress Bar filled halfway to the right'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28：进度条向右填充一半'
- en: '](img/B16183_08_28.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_28.jpg)'
- en: 'Figure 8.28: The Progress Bar filled halfway to the right'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28：进度条向右填充一半
- en: Before you continue, set the `Percent` property to `1`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，将“百分比”属性设置为“1”。
- en: 'Let''s now change the Progress Bar''s color from blue (its default color) to
    red. In order to do this, go to the `Details` tab and, inside the `Appearance`
    category, set the `Fill Color and Opacity` property to red (`RGB(1,0,0)`):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将进度条的颜色从蓝色（默认颜色）改为红色。为了做到这一点，转到“详细信息”选项卡，在“外观”类别内，将“填充颜色和不透明度”属性设置为红色（`RGB(1,0,0)`）：
- en: '![Figure 8.29: The Progress Bar''s Color being changed to red'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29：进度条的颜色被更改为红色'
- en: '](img/B16183_08_29.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_29.jpg)'
- en: 'Figure 8.29: The Progress Bar''s Color being changed to red'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：进度条的颜色被更改为红色
- en: After you've done this, your Progress Bar should now use red as its fill color.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，您的进度条现在应该使用红色作为填充颜色。
- en: 'To conclude our Progress Bar''s setup, let''s update its position, size, and
    Anchors. Follow these steps to achieve this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的进度条设置，让我们更新它的位置、大小和锚点。按照以下步骤来实现这一点：
- en: 'In the Slot `(Canvas Panel Slot)` category, expand the `Anchors` property and
    set its properties to these values:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`槽（Canvas Panel Slot）`类别中，展开`锚点`属性并将其属性设置为以下值：
- en: '`Minimum`: `0.052` on the `X` axis and `0.083` on the `Y` axis'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小值`：`X`轴上的`0.052`和`Y`轴上的`0.083`'
- en: '`Maximum`: `0.208` on the `X` axis and `0.116` on the `Y` axis'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大值`：`X`轴上的`0.208`和`Y`轴上的`0.116`'
- en: Set the `Offset Left`, `Offset Top`, `Offset Right`, and `Offset Bottom` properties
    to `0`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“左偏移”、“顶部偏移”、“右偏移”和“底部偏移”属性设置为“0”。
- en: 'Your Progress Bar should now look like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您的进度条现在应该是这样的：
- en: '![Figure 8.30: The Progress Bar after all the modifications in this section
    have been completed'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.30：在本节中所有修改完成后的进度条'
- en: '](img/B16183_08_30.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_30.jpg)'
- en: 'Figure 8.30: The Progress Bar after all the modifications in this section have
    been completed'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30：在本节完成所有修改后的进度条
- en: And with that, we can conclude the topic of Progress Bars. Our next step is
    going to be adding all the logic necessary to use this Progress Bar as a health
    bar, by updating its `Percent` property alongside the player character's health.
    We'll do exactly this in the next exercise.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以结束进度条的话题了。我们的下一步是添加所有必要的逻辑，以将这个进度条作为健康条使用，通过更新玩家角色的健康状况来更新其`Percent`属性。我们将在下一个练习中做到这一点。
- en: 'Exercise 8.06: Creating the Health Bar C++ Logic'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.06：创建健康条C++逻辑
- en: In this exercise, we will be adding all the necessary C++ logic to update the
    Progress Bar inside our HUD as the player character's health changes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将添加所有必要的C++逻辑，以更新HUD中的进度条，因为玩家角色的健康状况会发生变化。
- en: 'In order to do this, follow these steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤进行操作：
- en: Open the editor and create a new C++ class that inherits from `UserWidget`,
    similar to how we did in *Exercise 8.03*, *Creating the RestartWidget C++ Class*,
    but this time call it `HUDWidget`. This will be the C++ class that will be used
    for our HUD Widget.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器，并创建一个新的C++类，该类继承自`UserWidget`，类似于我们在*练习8.03*中所做的*创建RestartWidget C++类*，但这次将其命名为`HUDWidget`。这将是我们的HUD
    Widget所使用的C++类。
- en: 'In the `HUDWidget` class''s header file, add a new `public` property of type
    `class UProgressBar*` called `HealthBar`. This type is used to represent a Progress
    Bar, like the one we created in the previous section, in C++. Be sure to declare
    this property as a `UPROPERTY` function with the `BindWidget` tag:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HUDWidget`类的头文件中，添加一个新的`public`属性，类型为`class UProgressBar*`，名为`HealthBar`。这种类型用于在C++中表示进度条，就像我们在上一节中创建的那样。确保将此属性声明为带有`BindWidget`标记的`UPROPERTY`函数：
- en: '[PRE31]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a declaration for a `public` function called `UpdateHealthPercent`, which
    returns nothing and receives a `float HealthPercent` property as a parameter.
    This function will be called in order to update the `Percent` property of our
    Progress Bar:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`UpdateHealthPercent`的`public`函数声明，它不返回任何内容，并接收一个`float HealthPercent`属性作为参数。这个函数将被调用以更新我们的进度条的`Percent`属性：
- en: '[PRE32]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `HUDWidget` class''s source file, add the implementation for the `UpdateHealthPercent`
    function, which will call the `HealthBar` property''s `SetPercent` function, passing
    the `HealthPercent` property as a parameter:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HUDWidget`类的源文件中，添加`UpdateHealthPercent`函数的实现，该函数将调用`HealthBar`属性的`SetPercent`函数，并将`HealthPercent`属性作为参数传递：
- en: '[PRE33]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because we''ll be using the `ProgressBar` C++ class, we''ll need to add an
    `include` to it at the top of the class''s source file:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用`ProgressBar` C++类，所以我们需要在类的源文件顶部添加一个`include`：
- en: '[PRE34]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step will be adding all the necessary logic to our `Player Controller`
    responsible for adding the `HUDWidget` to the screen. Implement the following
    steps in order to achieve this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是为我们的`Player Controller`添加负责将`HUDWidget`添加到屏幕的所有必要逻辑。按照以下步骤实现这一点：
- en: Inside the `DodgeballPlayerController` class's header file, add a `public` property
    of type `TSubclassOf<class UHUDWidget>` called `BP_HUDWidget`. Make sure to mark
    it as a `UPROPERTY` function with the `EditDefaultsOnly` tag.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballPlayerController`类的头文件中，添加一个`public`属性，类型为`TSubclassOf<class UHUDWidget>`，名为`BP_HUDWidget`。确保将其标记为`UPROPERTY`函数，并使用`EditDefaultsOnly`标记。
- en: 'This property will allow us to specify, in the `DodgeballPlayerController`
    Blueprint class, which Widget we want to use as our HUD:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将允许我们在`DodgeballPlayerController`蓝图类中指定我们想要用作HUD的Widget：
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add another property, this time `private`, of type `class UHUDWidget*` called
    `HUDWidget`. Mark it as a `UPROPERTY`, but without any tags:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个属性，这次是`private`类型为`class UHUDWidget*`，名为`HUDWidget`。将其标记为`UPROPERTY`，但不带任何标记：
- en: '[PRE36]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a `protected` declaration for the `BeginPlay` function, and mark it as
    both `virtual` and `override`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`protected`声明，名为`BeginPlay`函数，并将其标记为`virtual`和`override`：
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add a declaration for a new `public` function, called `UpdateHealthPercent`,
    which returns nothing and receives a `float HealthPercent` as a parameter.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`public`函数声明，名为`UpdateHealthPercent`，它不返回任何内容，并接收一个`float HealthPercent`作为参数。
- en: 'This function will be called by our player character class in order to update
    the Health Bar in our HUD:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将被我们的玩家角色类调用，以更新HUD中的健康条：
- en: '[PRE38]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now head over to the `DodgeballPlayerController` class''s source file. Start
    by adding an `include` to our `HUDWidget` class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`DodgeballPlayerController`类的源文件。首先添加一个`include`到我们的`HUDWidget`类：
- en: '[PRE39]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, add the implementation for the `BeginPlay` function, where we''ll start
    by calling the `Super` object''s `BeginPlay` function:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加`BeginPlay`函数的实现，我们将首先调用`Super`对象的`BeginPlay`函数：
- en: '[PRE40]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that function call, check whether the `BP_HUDWidget` property is valid.
    If it is, call the `CreateWidget` function with the `UHUDWidget` template parameter
    and passing the `Owning Player`, `this`, and the Widget class, `BP_HUDWidget`,
    as parameters. Be sure to set the `HUDWidget` property to the return value of
    this function call:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用该函数后，检查`BP_HUDWidget`属性是否有效。如果有效，调用`CreateWidget`函数，使用`UHUDWidget`模板参数，并将`Owning
    Player`、`this`和Widget类`BP_HUDWidget`作为参数传递。确保将`HUDWidget`属性设置为此函数调用的返回值：
- en: '[PRE41]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After setting the `HUDWidget` property, call its `AddToViewport` function:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置完`HUDWidget`属性后，调用其`AddToViewport`函数：
- en: '[PRE42]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Lastly, add the implementation for the `UpdateHealthPercent` function, where
    we''ll check if the `HUDWidget` property is valid and, if it is, call its `UpdateHealthPercent`
    function and pass the `HealthPercent` property as a parameter:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加`UpdateHealthPercent`函数的实现，在这里我们将检查`HUDWidget`属性是否有效，如果有效，调用其`UpdateHealthPercent`函数，并将`HealthPercent`属性作为参数传递：
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we've added the logic responsible for adding the HUD to the screen
    and allowing it to be updated, we'll need to make some modifications to other
    classes. Follow these steps in order to do so.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了负责将HUD添加到屏幕并允许其更新的逻辑，我们需要对其他类进行一些修改。按照以下步骤进行修改。
- en: Currently, our `Health` interface, which we created in the previous chapter,
    only has the `OnDeath` event, which is called whenever an object runs out of health
    points. In order to update our Health Bar every time the player takes damage,
    we'll need to allow our `HealthInterface` class to notify an object whenever that
    happens.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在上一章创建的`Health`接口只有`OnDeath`事件，当一个对象耗尽生命值时会调用该事件。为了在玩家受到伤害时每次更新我们的生命条，我们需要允许我们的`HealthInterface`类在发生这种情况时通知一个对象。
- en: 'Open the `HealthInterface` class''s header file and add a declaration similar
    to the one we did for the `OnDeath` event in *Exercise 7.04*, *Creating the HealthInterface
    Class*, but this time for the `OnTakeDamage` event. This event will be called
    whenever an object takes damage:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`HealthInterface`类的头文件，并添加一个类似于我们在*练习7.04*中为`OnDeath`事件所做的声明的声明，但这次是为`OnTakeDamage`事件。每当一个对象受到伤害时，将调用此事件：
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have added this event to our `Interface` class, let''s add the
    logic that calls that event: open the `HealthComponent` class''s source file and,
    inside its implementation of the `LoseHealth` function, after subtracting the
    `Amount` property from the `Health` property, check whether the `Owner` implements
    the `Health` interface and, if it does, call its `OnTakeDamage` event. Do this
    the same way we already did later in that same function for our `OnDeath` event,
    but this time simply change the name of the event to `OnTakeDamage`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的`Interface`类中添加了这个事件，让我们添加调用该事件的逻辑：打开`HealthComponent`类的源文件，在`LoseHealth`函数的实现中，在从`Health`属性中减去`Amount`属性之后，检查`Owner`是否实现了`Health`接口，如果是，调用它的`OnTakeDamage`事件。这与我们在同一函数中为我们的`OnDeath`事件所做的方式相同，但这次只需将事件的名称更改为`OnTakeDamage`：
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Because our Health Bar will require the player character''s health points as
    a percentage, we need to do the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的生命条需要玩家角色的生命值作为百分比，我们需要做以下事情：
- en: 'Add a `public` function to our `HealthComponent` that returns just that: in
    the `HealthComponent` class''s header file, add a declaration for a `FORCEINLINE`
    function that returns a `float`. This function should be called `GetHealthPercent`
    and be a `const` function. Its implementation will simply consist of returning
    the `Health` property divided by `100`, which we will assume is the maximum amount
    of health points an object can have in our game:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`HealthComponent`中添加一个`public`函数，该函数返回`HealthComponent`类的头文件中的声明，添加一个`FORCEINLINE`函数的声明，该函数返回一个`float`。这个函数应该被称为`GetHealthPercent`，并且是一个`const`函数。它的实现将简单地返回`Health`属性除以`100`，我们将假设这是游戏中一个对象可以拥有的最大生命值的百分比：
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now go to the `DodgeballCharacter` class''s header file and add a declaration
    for a `public` `virtual` function called `OnTakeDamage_Implementation`, which
    returns nothing and receives no parameters. Mark it as `virtual` and `override`:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`DodgeballCharacter`类的头文件，并添加一个名为`OnTakeDamage_Implementation`的`public`
    `virtual`函数的声明，该函数不返回任何内容，也不接收任何参数。将其标记为`virtual`和`override`：
- en: '[PRE47]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `DodgeballCharacter` class''s source file, add an implementation for
    the `OnTakeDamage_Implementation` function we just declared. Copy the content
    of the `OnDeath_Implementation` function to this new function''s implementation,
    but do this change: instead of calling the `ShowRestartWidget` function of `PlayerController`,
    call its `UpdateHealthPercent` function, and pass the return value of the `HealthComponent`
    property''s `GetHealthPercent` function as a parameter:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballCharacter`类的源文件中，添加我们刚刚声明的`OnTakeDamage_Implementation`函数的实现。将`OnDeath_Implementation`函数的内容复制到这个新函数的实现中，但做出这个改变：不要调用`PlayerController`的`ShowRestartWidget`函数，而是调用它的`UpdateHealthPercent`函数，并将`HealthComponent`属性的`GetHealthPercent`函数的返回值作为参数传递：
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This concludes this exercise''s code setup. After you''ve done these changes,
    compile your code, open the editor and do the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了这个练习的代码设置。在你做完这些改变之后，编译你的代码，打开编辑器，然后做以下操作：
- en: Open the `BP_HUDWidget` Widget Blueprint and reparent it to the `HUDWidget`
    class, the same way you did in *Exercise 8.03*, *Creating the RestartWidget C++
    Class*.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_HUDWidget`小部件蓝图，并将其重新设置为`HUDWidget`类，就像你在*练习8.03*中所做的那样，创建`RestartWidget
    C++ Class`。
- en: This should cause a compilation error, which you'll be able to fix by renaming
    our Progress Bar element to `HealthBar`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会导致编译错误，你可以通过将我们的进度条元素重命名为`HealthBar`来修复它。
- en: 'Close this Widget Blueprint, open the `BP_DodgeballPlayerController` Blueprint
    class and set its `BP_HUDWidget` property to the `BP_HUDWidget` Widget Blueprint:![Figure
    8.31: Setting the BP_HUDWidget property to BP_HUDWidget'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭这个小部件蓝图，打开`BP_DodgeballPlayerController`蓝图类，并将其`BP_HUDWidget`属性设置为`BP_HUDWidget`小部件蓝图：![图8.31：将BP_HUDWidget属性设置为BP_HUDWidget
- en: '](img/B16183_08_31.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_31.jpg)'
- en: 'Figure 8.31: Setting the BP_HUDWidget property to BP_HUDWidget'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31：将BP_HUDWidget属性设置为BP_HUDWidget
- en: 'After you''ve done these changes, play the level. You should notice the `Health
    Bar` at the top left of the screen:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在你做完这些改变之后，播放关卡。你应该注意到屏幕左上角的`生命条`：
- en: '![Figure 8.32: The Progress Bar shown at the top left of the screen'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32：在屏幕左上角显示的进度条'
- en: '](img/B16183_08_32.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_32.jpg)'
- en: 'Figure 8.32: The Progress Bar shown at the top left of the screen'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32：在屏幕左上角显示的进度条
- en: 'When the player character gets hit by a Dodgeball, you should notice the `Health
    Bar` being emptied:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色被躲避球击中时，你应该注意到`生命条`被清空：
- en: '![Figure 8.33: The Progress Bar being emptied as the Player Character loses
    health points'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33：随着玩家角色失去生命值，进度条被清空'
- en: '](img/B16183_08_33.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_33.jpg)'
- en: 'Figure 8.33: The Progress Bar being emptied as the Player Character loses health
    points'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33：随着玩家角色失去生命值，进度条被清空
- en: And with that, we conclude this exercise, in which you've learned all the necessary
    steps in order to add a HUD to the screen and to update it during the game.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们结束了这个练习，你已经学会了在屏幕上添加HUD并在游戏过程中更新它的所有必要步骤。
- en: 'Activity 8.01: Improving the RestartWidget'
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：改进RestartWidget
- en: In this activity, we will be adding a `Text` element to our `RestartWidget`
    reading `Game Over` in order for the player to know that they just lost the game;
    adding an `Exit` button, which will allow the player to exit the game; and also
    updating the text of our existing button to `Restart` so that the players know
    what should happen when they click that button.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次活动中，我们将向我们的`RestartWidget`添加一个`Text`元素，显示`Game Over`，以便玩家知道他们刚刚输掉了游戏；添加一个`Exit`按钮，允许玩家退出游戏；还更新现有按钮的文本为`Restart`，以便玩家知道点击该按钮时会发生什么。
- en: 'The following steps will help you complete this activity:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Open the `BP_RestartWidget` Widget Blueprint.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_RestartWidget` Widget蓝图。
- en: Drag a new `Text` element into the existing `Canvas Panel` element.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的`Text`元素拖放到现有的`Canvas Panel`元素中。
- en: 'Modify the `Text` element''s properties:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Text`元素的属性：
- en: Expand the `Anchors` property and set its `Minimum` to `0.291` on the `X` axis
    and `0.115` on the `Y` axis, and its `Maximum` to `0.708` on the `X` axis and
    `0.255` on the `Y` axis.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开`Anchors`属性，并在`X`轴上将其`Minimum`设置为`0.291`，在`Y`轴上设置为`0.115`，将其`Maximum`设置为`0.708`，在`X`轴上设置为`0.255`，在`Y`轴上设置为`0.708`。
- en: Set the `Offset Left`, `Offset Top`, `Offset Right`, and `Offset Bottom` properties
    to `0`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Offset Left`，`Offset Top`，`Offset Right`和`Offset Bottom`属性设置为`0`。
- en: Set the `Text` property to `GAME OVER`.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Text`属性设置为`GAME OVER`。
- en: 'Set the `Color and Opacity` property to red: `RGBA(1.0, 0.082, 0.082, 1.0)`.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Color and Opacity`属性设置为红色：`RGBA(1.0, 0.082, 0.082, 1.0)`。
- en: Expand the `Font` property and set its `Size` to `100`.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开`Font`属性并将其`Size`设置为`100`。
- en: Set the `Justification` property to `Align Text Center`.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Justification`属性设置为`Align Text Center`。
- en: Select the other `Text` element inside the `RestartButton` property, and change
    its `Text` property to `Restart`.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`RestartButton`属性内的另一个`Text`元素，并将其`Text`属性更改为`Restart`。
- en: Duplicate the `RestartButton` property and change the copy's name to `ExitButton`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`RestartButton`属性并将副本的名称更改为`ExitButton`。
- en: Change the `Text` property of the `Text` element inside the `ExitButton` property
    to `Exit`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ExitButton`属性中`Text`元素的`Text`属性更改为`Exit`。
- en: Expand the `Anchor` property of the `ExitButton` property and set its `Minimum`
    to `0.44` on the *X* axis and `0.615` on the *Y* axis, and its `Maximum` to `0.558`
    on the *X* axis and `0.692` on the *Y* axis.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`ExitButton`属性的`Anchor`属性，并将其`Minimum`设置为`X`轴上的`0.44`，`Y`轴上的`0.615`，将其`Maximum`设置为`X`轴上的`0.558`，`Y`轴上的`0.692`。
- en: Set the `ExitButton` properties of `Offset Left`, `Offset Top`, `Offset Right`,
    and `Offset Bottom` to `0`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ExitButton`属性的`Offset Left`，`Offset Top`，`Offset Right`和`Offset Bottom`设置为`0`。
- en: 'After you''ve done these changes, we''ll need to add the logic responsible
    for handling the `ExitButton` property click, which will exit the game:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，我们需要添加处理`ExitButton`属性点击的逻辑，这将退出游戏：
- en: Save the changes made to the `BP_RestartWidget` Widget Blueprint and open the
    `RestartWidget` class's header file in Visual Studio. In this file, add a declaration
    for a `protected` function called `OnExitClicked` that returns nothing and receives
    no parameters. Be sure to mark it as a `UFUNCTION`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对`BP_RestartWidget` Widget蓝图所做的更改，并在Visual Studio中打开`RestartWidget`类的头文件。在该文件中，添加一个名为`OnExitClicked`的`protected`函数的声明，返回`void`，不接收任何参数。确保将其标记为`UFUNCTION`。
- en: Duplicate the existing `RestartButton` property, but call it `ExitButton` instead.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制现有的`RestartButton`属性，但将其命名为`ExitButton`。
- en: Inside the `RestartWidget` class's source file, add an implementation for the
    `OnExitClicked` function. Copy the contents of the `OnBeginOverlap` function from
    inside the `VictoryBox` class's source file into the `OnExitClicked` function,
    but remove the cast being done to the `DodgeballCharacter` class.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestartWidget`类的源文件中，为`OnExitClicked`函数添加一个实现。将`VictoryBox`类的源文件中`OnBeginOverlap`函数的内容复制到`OnExitClicked`函数中，但删除对`DodgeballCharacter`类的转换。
- en: In the `NativeOnInitialized` function implementation, bind the `OnExitClicked`
    function we created to the `OnClicked` event of the `ExitButton` property, the
    same way we did for the `RestartButton` property in *Exercise 8.03*, *Creating
    the RestartWidget C++ Class*.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeOnInitialized`函数的实现中，将我们创建的`OnExitClicked`函数绑定到`ExitButton`属性的`OnClicked`事件，就像我们在*Exercise
    8.03*，*Creating the RestartWidget C++ Class*中为`RestartButton`属性所做的那样。
- en: And that concludes our code setup for this activity. Compile your changes, open
    the editor, then open the `BP_RestartWidget` and compile it just to make sure
    there are no compilation errors due to the `BindWidget` tags.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本次活动的代码设置。编译您的更改，打开编辑器，然后打开`BP_RestartWidget`并编译它，以确保由于`BindWidget`标签而没有编译错误。
- en: 'Once you''ve done so, play the level again, let the player character be hit
    by three Dodgeballs, and notice the `Restart` Widget appear with our new modifications:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，再次玩游戏，让玩家角色被三个Dodgeball击中，并注意`Restart` Widget出现了我们的新修改：
- en: '![Figure 8.34: The updated BP_RestartWidget being shown after the player'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34：玩家耗尽生命值后显示的更新后的BP_RestartWidget'
- en: runs out of health points
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 耗尽生命值
- en: '](img/B16183_08_34.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_08_34.jpg)'
- en: 'Figure 8.34: The updated BP_RestartWidget being shown after the player runs
    out of health points'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34：玩家耗尽生命值后显示的更新后的BP_RestartWidget
- en: If you press the `Restart` button, you should be able to replay the level, and
    if you press the `Exit` button, the game should end.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下`Restart`按钮，您应该能够重新开始游戏，如果按下`Exit`按钮，游戏应该结束。
- en: And that concludes our activity. You've consolidated the basics of using a `Widget`
    Blueprint and changing its element's properties and are now ready to start making
    your own menus.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的活动。您已经巩固了使用`Widget`蓝图和更改其元素属性的基础知识，现在可以开始制作自己的菜单了。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter concluded, you have now learned how to make a game UI in UE4,
    understanding things such as menus and HUDs. You've seen how to manipulate a Widget
    Blueprint's UI elements, including `Buttons`, `Text` elements, and `Progress Bars`;
    work with Anchors effectively, which is instrumental in allowing your game UI
    to adapt elegantly to multiple screens; listen to mouse events in C++, such as
    the `OnClick` event, and use that to create your own game logic; as well as how
    to add the Widgets you create to the screen, either at specific events or have
    them present at all times.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您已经学会了如何在UE4中制作游戏UI，了解了诸如菜单和HUD等内容。您已经了解了如何操作Widget Blueprint的UI元素，包括“按钮”、“文本”元素和“进度条”；有效地使用锚点，这对于使游戏UI优雅地适应多个屏幕至关重要；在C++中监听鼠标事件，如“OnClick”事件，并利用它来创建自己的游戏逻辑；以及如何将您创建的小部件添加到屏幕上，无论是在特定事件发生时还是始终存在。
- en: In the next chapter, we'll be taking a look at polishing our Dodgeball game
    by adding audiovisual elements such as sound and particle effects, as well as
    making a new level.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加声音和粒子效果来完善我们的躲避球游戏，同时制作一个新的关卡。
