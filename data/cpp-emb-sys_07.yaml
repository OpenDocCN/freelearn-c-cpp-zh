- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Classes – Building Blocks of C++ Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类 – C++应用程序的构建块
- en: '**Classes** in C++ are means of organizing code into logical units. They allow
    us to structure data and functions that perform operations on that data in blueprints.
    These blueprints can be used to build instances of the classes, known as **objects**.
    We can initialize objects with data, manipulate them by calling functions or methods
    on them, store them in containers, or pass their references to objects of other
    classes to make the interaction between different parts of a system.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**在C++中是组织代码成逻辑单元的手段。它们允许我们将数据以及对这些数据进行操作的函数按照蓝图进行结构化。这些蓝图可以用来构建类的实例，即所谓的**对象**。我们可以通过初始化对象来赋予它们数据，通过调用它们上的函数或方法来操作它们，将它们存储在容器中，或者将它们的引用传递给其他类的对象，以实现系统不同部分之间的交互。'
- en: Classes are the basic building blocks of C++ applications. They help us organize
    code in units with isolated responsibility reflecting dependencies and interactions
    with other parts of the system. They can be combined or extended, allowing us
    to reuse their functionality and add additional capabilities. We use them to make
    abstractions of different parts of an embedded system, including low-level components
    such as **Universal Asynchronous Receiver/Transmitter** (**UART**) drivers and
    libraries or business logic components such as a cellular modem library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类是C++应用程序的基本构建块。它们帮助我们以具有独立责任、反映与其他系统部分依赖和交互的单元组织代码。它们可以组合或扩展，使我们能够重用其功能并添加额外的功能。我们使用它们来抽象嵌入式系统不同部分，包括低级组件，如**通用异步收发传输器**（**UART**）驱动程序和库，或业务逻辑组件，如蜂窝调制解调器库。
- en: 'The goal of this chapter is to delve into C++ classes and learn how we can
    use them to write better code. In this chapter, we’re going to cover the following
    main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是深入探讨C++类，并学习我们如何使用它们来编写更好的代码。在本章中，我们将涵盖以下主要主题：
- en: Encapsulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Storage duration and initialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储持续时间和初始化
- en: Inheritance and dynamic polymorphism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承和动态多态
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features make sure to select C++23 standard,
    by adding `-std=c++23` in compiler options box.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议在阅读示例时使用编译器探索器（[https://godbolt.org/](https://godbolt.org/))。选择GCC作为您的编译器，并针对x86架构。这将允许您看到标准输出（stdio）结果，并更好地观察代码的行为。由于我们使用了大量的现代C++特性，请确保在编译器选项框中添加`-std=c++23`以选择C++23标准。
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05))。
- en: Encapsulation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: '**Encapsulation** is a programming concept that organizes code into units that
    contain both data and functions that operate on that data. It is not strictly
    related to **Object-Oriented Programming** (**OOP**) and is often used in other
    programming paradigms. Encapsulation allows us to decouple code into units with
    single responsibilities, making the code easier to reason about, improving readability,
    and facilitating maintenance.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**是一种编程概念，它将代码组织成包含数据和操作这些数据的函数的单元。它与**面向对象编程**（**OOP**）并不严格相关，并且常用于其他编程范式。封装允许我们将代码解耦成具有单一职责的单元，使得代码更容易推理，提高可读性，并便于维护。'
- en: 'In terms of OOP, encapsulation can also refer to hiding an object’s members
    or restricting access to these members from the outside. In C++, this can be achieved
    using access specifiers. C++ has the following specifiers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的术语中，封装还可以指隐藏对象成员或限制外部对这些成员的访问。在C++中，这可以通过使用访问说明符来实现。C++有以下说明符：
- en: Public
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共
- en: Private
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有
- en: Protected
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的
- en: '**Public** and **private** are the most commonly used specifiers. They give
    us the ability to control the interface of the class, that is, to control which
    class members are available to the users of a class. The following example demonstrates
    how to define a class with public and private access sections, demonstrating the
    concept of encapsulation:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共**和**私有**是最常用的修饰符。它们赋予我们控制类接口的能力，即控制哪些类成员对类的用户可用。以下示例演示了如何定义具有公共和私有访问部分的类，展示了封装的概念：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, the `uart` class has public and private access sections. Let’s
    go through the code step by step:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`uart` 类有公共和私有访问部分。让我们一步一步地分析代码：
- en: The `public` section includes a constructor that initializes the `baudrate_`
    private member variable
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 部分包括一个构造函数，用于初始化 `baudrate_` 私有成员变量'
- en: We also have an `init` method in the public section, in which we write a value
    to a **Bit Rate Register** (**BRR**), which is specific to the STM32 platform,
    using the `write_brr` private method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在公共部分还有一个 `init` 方法，在其中我们使用 `write_brr` 私有方法将一个值写入一个**波特率寄存器**（**BRR**），这是
    STM32 平台特有的
- en: The value written to the BRR register is calculated in the `calculate_uartdiv`
    private method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入到 BRR 寄存器的值是在 `calculate_uartdiv` 私有方法中计算的
- en: As we can see, methods with a public access specifier within the `uart` class
    can use private member variables and methods. However, if we tried to use `write_brr`
    on the `uart1` object, as in `uart1.write_brr(5)`, the compilation of the program
    would fail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`uart` 类中具有公共访问修饰符的方法可以使用私有成员变量和方法。然而，如果我们尝试在 `uart1` 对象上使用 `write_brr`，如
    `uart1.write_brr(5)`，则程序的编译将失败。
- en: The private access specifier allows us to hide methods and data from the user
    of our class (in this case, the `main` function). This helps us define a clear
    interface for our classes in C++. By controlling which methods a user of the class
    can use, we are not only protecting the class but also the user from unwanted
    behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 私有访问修饰符允许我们隐藏类（在这种情况下，`main` 函数）用户的方法和数据。这有助于我们在 C++ 中为类定义一个清晰的接口。通过控制用户可以使用的哪些方法，我们不仅保护了类，也保护了用户免受不受欢迎的行为。
- en: This example serves the purpose of explaining access specifiers in C++, but
    let’s also use it to explain the `init` method. Why do we need it if we have a
    constructor?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子旨在解释 C++ 中的访问修饰符，但让我们也用它来解释 `init` 方法。如果我们已经有了构造函数，为什么还需要它？
- en: The purpose of `init` is to allow us to fully control the initialization of
    hardware. The object may also be constructed as a global or static variable. The
    initialization of static and global objects is done before reaching the `main`
    function and initializing hardware. That is why some kind of `init` method is
    common in classes in embedded projects. Using it, we can ensure that all hardware
    peripherals are initialized in the correct order.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 的目的是允许我们完全控制硬件的初始化。对象也可以作为全局或静态变量构造。静态和全局对象的初始化是在到达 `main` 函数并初始化硬件之前完成的。这就是为什么在嵌入式项目中常见的
    `init` 方法。使用它，我们可以确保所有硬件外设都按正确的顺序初始化。'
- en: 'The default access specifier for classes in C++ is private, so we could write
    the definition of the `uart` class from the previous example as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中类的默认访问修饰符是私有，因此我们可以将上一个示例中的 `uart` 类定义写为以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We chose to explicitly define the private access section. We put it after the
    `public` section, as publicly accessible members are the interface for our class,
    and when you read code and a class definition, the first thing you want to see
    is the interface. You want to see how to interact with the class and which methods
    are part of the public interface that you can use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择明确定义私有访问部分。我们将其放在 `public` 部分之后，因为公开可访问的成员是类的接口，当你阅读代码和类定义时，你首先想看到的是接口。你想要看到如何与类交互，以及哪些方法是公共接口的一部分，你可以使用它们。
- en: The only data member we have in this example is `baudrate_`. It is private,
    and the only option for a user of the `uart` class to set it up is through the
    constructor. It is a common practice for data members that we want to expose to
    the public to define setter and getter methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只有一个数据成员 `baudrate_`。它是私有的，`uart` 类的用户设置它的唯一选项是通过构造函数。对于我们要公开的数据成员，定义设置器和获取器是一种常见的做法。
- en: Setters and getters
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置器和获取器
- en: 'In the `uart` class, we could define setters and getters for `baudrate_` members
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uart` 类中，我们可以为 `baudrate_` 成员定义如下设置器和获取器：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, this would allow us to set and get the `baudrate` value from the public
    interface, but these trivial setters and getters do not add any value to our interface.
    They are just exposing the `baudrate_` member. It would be the same as if we put
    it under the public access specifier. Setters and getters should serve a clear
    purpose. For example, a setter can include validation logic, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这使我们能够通过公共接口设置和获取 `baudrate` 值，但这些简单的设置器和获取器并没有为我们的接口增加任何价值。它们只是暴露了 `baudrate_`
    成员。如果我们将它放在公共访问指定符下，效果是一样的。设置器和获取器应该有一个明确的目的。例如，设置器可以包含验证逻辑，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the modified setter, we are making a sanity check of the value to be set
    and setting the private member only if it makes sense to do so, else setting it
    to the maximum baudrate (`c_max_baudrate`) supported in our system. This is just
    an example; it probably doesn’t make sense to change the baudrate after the UART
    initialization.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的设置器中，我们对要设置的值进行合理性检查，并且只有在这样做有意义的情况下才设置私有成员，否则将其设置为系统支持的最高波特率 (`c_max_baudrate`)。这只是一个例子；在
    UART 初始化后更改波特率可能没有意义。
- en: Exposing data members through setters and getters in some sense breaks encapsulation.
    The idea of encapsulation is to hide the implementation details, and data members
    are implementation details. Therefore, setters and especially getters should be
    used sparingly and only when they serve a meaningful purpose.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置器和获取器暴露数据成员在一定程度上破坏了封装。封装的想法是隐藏实现细节，而数据成员是实现细节。因此，设置器和特别是获取器应该谨慎使用，并且只有在它们有明确意义时才使用。
- en: We can use classes in C++ to encapsulate only functionality, without data, or
    data that is commonly shared with all users of a class. For that, we can use static
    methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 C++ 中的类来封装仅有的功能，而不包含数据，或者数据是类中所有用户共同拥有的。为此，我们可以使用静态方法。
- en: Static methods
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: '**Static methods** are C++ methods declared with static keywords, and they
    are accessible without object instantiation. In the `uart` class example, besides
    the constructor, we have the `init` method, which is part of the public interface.
    We use it by calling this method on an object we previously created using a single
    argument constructor by providing it with the baudrate. We could also design the
    `uart` class as a type that has all static methods and use it as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态方法** 是使用 `static` 关键字声明的 C++ 方法，它们可以在不实例化对象的情况下访问。在 `uart` 类示例中，除了构造函数外，我们还有
    `init` 方法，它是公共接口的一部分。我们通过调用之前使用单参数构造函数创建的对象上的此方法来使用它，并提供波特率。我们也可以设计 `uart` 类为具有所有静态方法的类型，并如下使用它：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we removed the single argument constructor and declared all
    methods as static. We also removed the `baudrate_` private data member and passed
    it directly from the `init` method to the `calculate_uartdiv` method. We now have
    a type that we can use without object instantiation. We call the `init` method
    by using the class name followed by a double colon and the method name, as shown
    in the `main` function. It is worth noting that static methods can only use static
    data members and other static functions from a class as non-static members require
    the instantiation of an object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们移除了单参数构造函数，并将所有方法声明为静态。我们还移除了 `baudrate_` 私有数据成员，并直接从 `init` 方法传递给 `calculate_uartdiv`
    方法。现在我们有一个可以在不创建对象实例的情况下使用的类型。我们通过在类名后跟一个双冒号和方法名来调用 `init` 方法，如 `main` 函数中所示。值得注意的是，静态方法只能使用类中的静态数据成员和其他静态函数，因为非静态成员需要对象实例化。
- en: We can group functions in C++ in a common *unit* by using namespaces. However,
    grouping them into a type is useful as we can pass types as template arguments.
    We will discuss namespaces and templates later in this book to better understand
    the benefits of this approach. Namespaces will be discussed in [*Chapter 6*](Chapter_06.xhtml)
    and templates in [*Chapter 8*](Chapter_08.xhtml).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命名空间在 C++ 中将函数分组到一个共同的 *单元* 中。然而，将它们分组到类型中是有用的，因为我们可以将类型作为模板参数传递。我们将在本书的后面讨论命名空间和模板，以更好地理解这种方法的优点。命名空间将在
    [*第 6 章*](Chapter_06.xhtml) 中讨论，模板将在 [*第 8 章*](Chapter_08.xhtml) 中讨论。
- en: In C++, we can also use the struct keyword to define a type. The default access
    for struct members is public. Historically, structs were used for compatibility
    with C, so one could write a header file for a library that is used in both C
    and C++ programs. In this case, the struct we would share between C and C++ programs
    could only have common data types and couldn’t have methods as members.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们还可以使用 struct 关键字来定义一个类型。结构体成员的默认访问级别是公共的。从历史上看，结构体用于与 C 兼容，因此可以为在
    C 和 C++ 程序中使用的库编写头文件。在这种情况下，我们将在 C 和 C++ 程序之间共享的结构体只能包含公共数据类型，不能有作为成员的方法。
- en: Structs
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: '**Structs** are commonly used in C++ for types that only have data members
    that we want to make publicly available to users. They are mostly identical to
    classes, with a difference being in the default access level, which is public
    for structs.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**在 C++ 中通常用于只包含我们希望公开提供给用户的具有数据成员的类型。它们与类大致相同，区别在于默认访问级别，结构体的默认访问级别是公共的。'
- en: 'Here is an example of a struct that only has data members:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个只包含数据成员的结构体示例：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`accelerometer_data` could be produced by a `sensor` class, stored in a `ring_buffer`
    class, and consumed by a `sensor_fusion` class. The members of the `accelerometer_data`
    class are values from the `x`, `y`, and `z` axes, and they are publicly available
    to users of this class.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`accelerometer_data` 可以由一个 `sensor` 类生成，存储在一个 `ring_buffer` 类中，并由一个 `sensor_fusion`
    类使用。`accelerometer_data` 类的成员是从 `x`、`y` 和 `z` 轴的值，并且它们对该类的用户是公开的。'
- en: In this case, we use the `accelerometer_data` struct only as a data holder,
    and we implement the behavior related to this data in other places. This is just
    an example. Structuring data in simple structs versus using classes with data
    and complex behavior is a design choice and it depends on the exact application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只使用 `accelerometer_data` 结构体作为数据持有者，并将与此数据相关的行为实现在其他地方。这只是一个示例。在简单结构体中结构化数据与使用具有数据和复杂行为的类之间的设计选择取决于具体的应用。
- en: Structs are also used to group functions into types. They are usually all declared
    as static and made publicly available to users. Using a struct instead of a class
    is convenient in this use case as the default access specifier is public and it
    also reflects our intent as a struct is usually used when all members are made
    public.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体也用于将函数分组为类型。它们通常都被声明为静态，并公开提供给用户。在这种情况下，使用结构体而不是类是方便的，因为默认访问指定符是公共的，这也反映了我们的意图，因为结构体通常用于所有成员都是公开的情况下。
- en: Besides the public and private access specifiers, there is also the **protected
    specifier** in C++. The protected specifier is related to inheritance and will
    be explained later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了公共和私有访问指定符之外，C++ 中还有一个**受保护的指定符**。受保护的指定符与继承有关，将在本章后面解释。
- en: Let us now move on to constructors and the initialization of variables and objects
    in C++. Object initialization is an important task and failing to do it properly
    can cause problems in programs. We will discuss different options for object initialization
    and analyze potential pitfalls and how to avoid them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论构造函数和 C++ 中变量和对象的初始化。对象初始化是一个重要的任务，未能正确执行可能会在程序中引起问题。我们将讨论对象初始化的不同选项，并分析潜在的问题以及如何避免它们。
- en: Storage duration and initialization
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储持续时间和初始化
- en: C++ objects with automatic storage duration are initialized upon declaration
    and destroyed when exiting the variable scope. Objects can also have a static
    storage duration. Data members of objects can also have static storage specifiers,
    and there are rules for the initialization of such members. We will first go through
    non-static member initialization.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中具有自动存储期的对象在声明时初始化，在退出变量作用域时销毁。对象也可以具有静态存储期。对象的成员数据也可以有静态存储指定符，并且对这些成员的初始化有一些规则。我们将首先介绍非静态成员的初始化。
- en: Non-static member initialization
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非静态成员初始化
- en: There are different ways to initialize non-static class members. The first thing
    that comes to mind when we discuss initialization and C++ is constructors. While
    constructors are powerful C++ features that allow us to have great control over
    the initialization, let us start with **default member initializers**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化非静态类成员有不同的方法。当我们讨论初始化和 C++ 时，首先想到的是构造函数。虽然构造函数是强大的 C++ 功能，允许我们对初始化有很好的控制，但让我们从**默认成员初始化器**开始。
- en: Default member initializers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认成员初始化
- en: 'As of C++11, it is possible to set a default value for a member directly in
    a class definition, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，我们可以在类定义中直接为成员设置默认值，如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple code snippet would fail to compile if we were to compile it with
    any pre-C++11 standard. The default member initializers allow us to set a default
    value for class members in a class definition, which improves readability and
    saves us from setting the same member variable if we have multiple constructors.
    This is particularly useful for setting default values for pointers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用任何预 C++11 标准编译此代码片段，它将无法编译。默认成员初始化器允许我们在类定义中为类成员设置默认值，这提高了可读性，并使我们免于在多个构造函数中设置相同的成员变量。这对于设置指针的默认值尤其有用。
- en: If we didn’t use the default initializer for `ptr`, it would be loaded with
    some random value from memory. Dereferencing such a pointer would result in reading
    from or writing to a random location, potentially leading to a serious fault.
    This hypothetical situation would be detected by a compiler or a static analyzer
    as they would report the usage of an uninitialized value, which is undefined behavior.
    Still, this shows the importance of initializing member variables with default
    values, and a default member initializer is an option for this task.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有为 `ptr` 使用默认初始化器，它将加载内存中的某个随机值。解引用这样的指针会导致从随机位置读取或写入，可能引发严重故障。这种假设情况会被编译器或静态分析器检测到，因为它们会报告使用未初始化的值，这是未定义的行为。尽管如此，这显示了使用默认值初始化成员变量的重要性，而默认成员初始化器是完成此任务的选项之一。
- en: Constructors and member initializer lists
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和成员初始化列表
- en: 'Constructors are nameless methods in class definition that can’t be called
    explicitly. They are invoked upon the object initialization. A constructor that
    can be invoked with no arguments is called the default constructor. We already
    saw one in the `uart` class example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是类定义中的无名称方法，不能被显式调用。它们在对象初始化时被调用。一个可以无参数调用的构造函数被称为默认构造函数。我们在 `uart` 类的示例中已经看到了一个：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even though this constructor has a parameter, we used the default argument that
    will be provided to the constructor if it is called with no arguments. If no argument
    is provided at the call site, the default value of `9600` will be used for the
    `baud` argument.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个构造函数有一个参数，但我们使用了默认参数，如果它无参数被调用，这个参数将被提供给构造函数。如果在调用点没有提供参数，`baud` 参数将使用默认值
    `9600`。
- en: 'We use the following syntax when we want to use the default constructor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用默认构造函数时，我们使用以下语法：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is also called **default initialization**, and it is performed when the
    object is declared with no initializer. Please note that there are no parentheses
    as this would cause syntax ambiguity and would be interpreted by the compiler
    as a function declaration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为**默认初始化**，当对象声明时没有初始化器时执行。请注意，这里没有括号，因为这会导致语法歧义，并且编译器会将其解释为函数声明。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding line would be interpreted by the compiler as the declaration of
    a function named `uart1` that returns the object of the `uart` class and accepts
    no arguments. This is the reason we are not using parentheses when using the default
    constructor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行会被编译器解释为声明一个名为 `uart1` 的函数，该函数返回 `uart` 类的对象，并且不接受任何参数。这就是为什么我们在使用默认构造函数时没有使用括号的原因。
- en: 'As our `uart` class constructor can also accept an argument, we can use direct
    initialization syntax and provide the constructor with an argument, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `uart` 类构造函数也可以接受参数，我们可以使用直接初始化语法，并为构造函数提供一个参数，如下所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will call the `uart` class constructor and provide it with a value of
    `115200` for the `baud` argument. While we have explained nuances related to the
    syntax of the default constructor, we still need to explain the initialization
    of the `baudrate_` member variable. In this case, we are using the member initializer
    list. It is specified after the colon character and before the opening brace of
    the compound statement as `baudrate_(baud)`. In our case, we have only one item
    in the member initializer list; if there are more, they are delimited with a comma,
    as in the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 `uart` 类构造函数，并为 `baud` 参数提供一个 `115200` 的值。虽然我们已经解释了与默认构造函数语法相关的细微差别，但我们仍然需要解释
    `baudrate_` 成员变量的初始化。在这种情况下，我们使用成员初始化列表。它指定在冒号字符之后和复合语句的开括号之前，作为 `baudrate_(baud)`。在我们的例子中，成员初始化列表中只有一个条目；如果有更多，它们用逗号分隔，如下例所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we are initializing a reference to `uart` and the `read_interval_`
    unsigned integer in the member initializer list in the `sensor` constructor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`sensor`构造函数的成员初始化列表中初始化了对`uart`的引用和`read_interval_`无符号整数。
- en: The important thing to notice is the reference to an object of the `uart` class.
    References in C++ are similar to pointers in C; that is, they point to an already-created
    object. However, they need to be initialized when declared and they can’t be reassigned
    to point to another object. References and `const`-qualified members must be initialized
    using a member initializer list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是`uart`类对象的引用。在C++中，引用类似于C中的指针；也就是说，它们指向一个已经创建的对象。然而，它们在声明时需要初始化，并且不能重新赋值以指向另一个对象。引用和`const`限定成员必须使用成员初始化列表进行初始化。
- en: Constructors can have no or many parameters. If a constructor has one parameter
    and is declared without the **explicit specifier**, it is called a converting
    constructor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以有零个或多个参数。如果一个构造函数有一个参数并且没有使用**显式指定符**声明，它被称为转换构造函数。
- en: Converting constructors and explicit specifiers
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换构造函数和显式指定符
- en: '**Converting constructors** allow the compiler to make an implicit conversion
    from the type of its argument to the type of its class. To better understand this,
    let’s take a look at the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换构造函数**允许编译器将其参数的类型隐式转换为类的类型。为了更好地理解这一点，让我们看一下以下示例：'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The interesting part of this example is the call to the `uart_consumer` function
    with the `115200` argument. The `uart_consumer` function expects the object of
    the `uart` class as an argument, but due to rules of implicit conversion and the
    existing converting constructor, the compiler constructs an object of the `uart`
    class using `115200` as an argument, resulting in the following output of the
    program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中有趣的部分是使用`115200`参数调用`uart_consumer`函数。`uart_consumer`函数期望以`uart`类的对象作为参数，但由于隐式转换规则和现有的转换构造函数，编译器使用`115200`作为参数构造了一个`uart`类的对象，导致程序输出以下内容：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implicit conversion can be unsafe, and it is often unwanted. To prevent it,
    we can declare a constructor using an explicit specifier, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换可能是不安全的，并且通常是不希望的。为了防止这种情况，我们可以使用显式指定符声明一个构造函数，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compiling the preceding example with an explicit constructor will result in
    a compiler error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式构造函数编译前面的示例将导致编译错误：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By declaring a constructor as explicit, we can be sure that no user of our class
    will create a situation with potential implicit conversion, which may lead to
    unwanted behavior in our program. But what if we want to prevent calls to our
    constructor using the float type? It may not be a good example, but you can imagine
    a constructor expecting a `uint8_t` type and someone calling it with a `uint32_t`
    argument.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将构造函数声明为显式，我们可以确保我们的类的用户不会创建可能导致程序中不希望的行为的潜在隐式转换的情况。但如果我们想防止使用浮点类型调用我们的构造函数呢？这可能不是一个很好的例子，但你可以想象一个期望`uint8_t`类型的构造函数，有人用`uint32_t`参数调用它。
- en: 'We can delete specific constructors, which will result in failed compilation.
    We can do it using the following syntax in the class declaration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除特定的构造函数，这将导致编译失败。我们可以在类声明中使用以下语法来完成此操作：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Calling the constructor with a float type will result in the following compile
    error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮点类型调用构造函数将导致以下编译错误：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also use brace list initialization, which narrows down the conversion
    and prevents the float-to-integer conversion. We can use it as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用花括号列表初始化，这限制了转换并防止了浮点数到整数的转换。我们可以如下使用它：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This call would result in the following compile error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用将导致以下编译错误：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The list initialization limits the implicit conversion and helps with detecting
    problems at compile time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表初始化限制了隐式转换，并有助于在编译时检测问题。
- en: Class data members can be declared using the `static` keyword, and there are
    special rules for initializing them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类数据成员可以使用`static`关键字声明，并且对它们的初始化有一些特殊规则。
- en: Static member initialization
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员初始化
- en: 'Static members are not tied to the objects of a class or struct. They are variables
    with static storage duration, and they can be accessed by any object of a class.
    Let’s go through a simple example to better understand static members and how
    we initialize them:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员与类或结构体的对象无关。它们是具有静态存储期的变量，可以由类的任何对象访问。让我们通过一个简单的例子来更好地理解静态成员以及我们如何初始化它们：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we have a simple `object_counter` struct. The struct has one
    static data member, the `cnt` integer. In the constructor, we are incrementing
    this counter variable, and in the destructor, we are decrementing it. In the `main`
    function, we are creating three `object_counter` objects in an unnamed scope.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个简单的 `object_counter` 结构体。该结构体有一个静态数据成员，即 `cnt` 整数。在构造函数中，我们增加这个计数器变量，在析构函数中，我们减少它。在
    `main` 函数中，我们在一个未命名的范围内创建了三个 `object_counter` 对象。
- en: 'When the program flow exits the unnamed scope, destructors will be called.
    We are printing the number of existing objects both inside the scope and after
    leaving it. Inside the unnamed scope, the `cnt` value should be equal to `3`,
    as we created three objects, and when we exit it, and destructors decrement the
    `cnt` variable, it should be `0`. The following is the output of the example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序流程退出未命名的范围时，将调用析构函数。我们在范围内部和离开它之后打印现有对象的数量。在未命名的范围内，`cnt` 的值应该等于 `3`，因为我们创建了三个对象，当我们退出它，并且析构函数减少
    `cnt` 变量时，它应该为 `0`。以下示例的输出如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output shows that the behavior of the `cnt` static variable is as we predicted.
    In this case, we declared a static variable in the class declaration, but we defined
    it using the following line:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 `cnt` 静态变量的行为正如我们所预测的那样。在这种情况下，我们在类声明中声明了一个静态变量，但使用以下行定义它：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the C++17 standard, it is possible to declare a static variable using
    an `inline` specifier inside the struct (or class) definition and provide it with
    the initializer, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 C++17 标准，可以在结构体（或类）定义中使用 `inline` 说明符声明静态变量，并提供初始化器，如下所示：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This makes the code more concise, easier to use as we don’t need to define the
    variable outside the class definition, and easier to read.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更加简洁，更容易使用，因为我们不需要在类定义外部定义变量，并且更容易阅读。
- en: We covered the basics of classes in C++, including access specifiers, initializing
    methods, and constructors. Now, we will see how we can reuse classes using inheritance
    and dynamic polymorphism.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 C++ 中类的基础知识，包括访问说明符、初始化方法和构造函数。现在，我们将看到如何通过继承和动态多态来重用类。
- en: Inheritance and dynamic polymorphism
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和动态多态
- en: 'In C++, we can expand the functionality of a class without modifying it with
    inheritance. Inheritance is an example of establishing a hierarchical relationship
    between classes; for example, `ADXL345` is an accelerometer. Let us go through
    a trivial example that demonstrates inheritance in C++:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们可以通过继承来扩展类的功能，而无需修改它。继承是建立类之间层次关系的例子；例如，`ADXL345` 是一个加速度计。让我们通过一个简单的例子来演示
    C++ 中的继承：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, `class B` inherits private and protected members from `class
    A`. `class A` is the base class, and `class B` is derived from it. The derived
    class has access to public and protected members of the base class. In the `main`
    function, we create an object of `class B`, and we call the `method_1`, `method_2`,
    and `method_3` methods. The output of this part of the code is shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`class B` 从 `class A` 继承了私有和受保护的成员。`class A` 是基类，`class B` 从它派生。派生类可以访问基类的公共和受保护成员。在
    `main` 函数中，我们创建了一个 `class B` 的对象，并调用了 `method_1`、`method_2` 和 `method_3` 方法。这部分代码的输出如下所示：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the first line of the `main` function, we see that the call to the `method_1`
    function on object `b` executes `method_1` defined in `class B` even though it
    is derived from `class A`, and `class A` has also defined `method_1`. This is
    called **static binding** as the decision to call `method_1` is defined in `class
    A` and is made by the compiler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数的第一行，我们看到对对象 `b` 的 `method_1` 函数的调用执行了 `class B` 中定义的 `method_1`，尽管它继承自
    `class A`，而 `class A` 也定义了 `method_1`。这被称为 **静态绑定**，因为调用 `method_1` 的决定是在 `class
    A` 中定义的，并且由编译器做出。
- en: An object of the derived `class B` contains an object of the base `class A`.
    If we call `method_2` on object `b`, the compiler will find no definition in `class
    B`, but as class `B` inherits from class `A`, the compiler will call `method_2`
    on object `a`, which is a part of object `b`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类 `class B` 的对象包含基类 `class A` 的对象。如果我们对对象 `b` 调用 `method_2` 方法，编译器将在 `class
    B` 中找不到定义，但由于类 `B` 继承自类 `A`，编译器将调用对象 `a` 的 `method_2` 方法，而对象 `a` 是对象 `b` 的一部分。
- en: In `method_3`, we see that we can call methods of the base class from the derived
    class. We can also see that we can call protected methods of the base class. This
    is one of the use cases of private access specifiers; it allows access to derived
    classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `method_3` 中，我们看到我们可以从派生类中调用基类的函数。我们还可以看到我们可以调用基类的受保护方法。这是私有访问说明符的一个用例；它允许对派生类进行访问。
- en: 'We can assign the object of the derived class to a reference of the base class.
    We could also do the same for a pointer. Here is the result of calls of methods
    made on the reference:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将派生类的对象赋值给基类引用。我们也可以对指针做同样的事情。以下是方法调用结果：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Calling `method_1` on a reference of the base class will result in a call to
    `method_1` defined in `class A`. This is another instance of static binding in
    action. But what if we wanted that a call on a base class reference or pointer
    to result in executing a function on the derived class? And why would we want
    this? Let’s first address the *how*. C++ provides a mechanism of dynamic binding
    through virtual functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对基类引用调用 `method_1` 将导致调用 `class A` 中定义的 `method_1`。这是静态绑定作用的一个例子。但如果我们想让对基类引用或指针的调用在派生类中执行函数呢？我们为什么要这样做？让我们首先解决“如何做”的问题。C++
    通过虚函数提供了一种动态绑定的机制。
- en: Virtual functions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数
- en: 'In our example, we assign a reference of type `A&` to an object of `class B`.
    If we want calls to `method_1` on this reference (`A& a`) to execute the `method_1`
    function defined in `class B`, we can declare `method_1` as a virtual function
    in `class A`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将类型为 `A&` 的引用赋值给 `class B` 的对象。如果我们想让对这个引用（`A& a`）的 `method_1` 调用执行
    `class B` 中定义的 `method_1` 函数，我们可以在 `class A` 中将 `method_1` 声明为虚函数，如下所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the call to `method_1` on the reference of `class A`, bound to the object
    of `class B`, will result in a call to `method_1` defined in `class B`, as we
    can see in the output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对绑定到 `class B` 对象的 `class A` 引用上的 `method_1` 调用将导致调用 `class B` 中定义的 `method_1`，正如我们在输出中看到的那样：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we see the output of the `method_1` call matches the definition of this
    method from `class B`. We say that `class B` is overriding `method_1` from `class
    A`, and there is a special notion for this, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到 `method_1` 调用的输出与 `class B` 中此方法的定义相匹配。我们说 `class B` 覆盖了 `class A` 中的
    `method_1`，对此有一个特殊的术语，如下所示：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The **override** keyword makes the compiler aware of our intention of overriding
    a virtual method from the base class. If the method we are overriding is not declared
    virtual, the compiler will raise an error.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**override** 关键字让编译器知道我们有意覆盖基类中的虚方法。如果我们覆盖的方法没有被声明为虚方法，编译器将引发错误。'
- en: Virtual functions in C++ are usually implemented using virtual tables. This
    is the work that a compiler does for us. It creates a virtual table that stores
    pointers for every virtual function, which points to the overridden implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的虚函数通常使用虚表来实现。这是编译器为我们完成的工作。它创建一个虚表，存储每个虚函数的指针，这些指针指向覆盖的实现。
- en: Virtual function implementation
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚函数实现
- en: 'Every class that overrides a virtual function has a virtual table. You can
    think of it as a hidden table of function pointers. Every object of a class has
    a pointer to this table. This pointer is used at runtime to access a table and
    find the correct function to be called on the object. Let us slightly modify our
    `class A` and `class B` to better understand this. The following is the code of
    the modified `class A` and `class B`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个覆盖虚函数的类都有一个虚表。你可以把它想象成一个隐藏的功能指针表。类的每个对象都有一个指向这个表的指针。这个指针在运行时用于访问表并找到在对象上要调用的正确函数。让我们稍微修改一下
    `class A` 和 `class B`，以便更好地理解这一点。以下是被修改的 `class A` 和 `class B` 的代码：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We modified `class A` and `class B` so that `class A` has two virtual methods,
    `method_1` and `method_2`. `class B` only overrides `method_2`. The compiler will
    generate a virtual table for `class B` and a pointer that every object of `class
    B` will hold. The virtual pointer points to the generated virtual table.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了 `class A` 和 `class B`，使得 `class A` 有两个虚方法，`method_1` 和 `method_2`。`class
    B` 只覆盖 `method_2`。编译器将为 `class B` 生成一个虚表和一个指针，每个 `class B` 的对象都将持有这个指针。虚指针指向生成的虚表。
- en: 'This can be visualized as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如下可视化：
- en: '![Figure 5.1 – Virtual table](img/B22402_05_01.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 虚表](img/B22402_05_01.png)'
- en: Figure 5.1 – Virtual table
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 虚表
- en: '*Figure 5**.1* depicts a possible implementation of virtual functions in C++
    using virtual tables and virtual pointers. If we call `method_2` on a reference
    to an object of `class B`, it will follow the virtual pointer to the virtual table
    and select the function pointer that points to the implementation of `method_2`
    in `class B`, that is, the overridden virtual function. This mechanism happens
    at runtime. There is a layer of indirection to get to the overridden function,
    which results in space and time overhead.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1* 展示了在 C++ 中使用虚表和虚指针实现虚函数的可能实现。如果我们对一个 `类 B` 对象的引用调用 `method_2`，它将跟随虚指针到虚表，并选择指向
    `类 B` 中 `method_2` 实现的函数指针，即重写的虚函数。这种机制发生在运行时。有一个间接层来获取重写的函数，这导致了空间和时间开销。'
- en: 'In C++, we can define a virtual function to be a pure virtual function. If
    a class has a pure virtual function, it is called an **abstract class**, and it
    can’t be instantiated. Derived classes must override pure virtual functions, or
    they are also abstract classes. Let’s go through the following code example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们可以定义一个虚函数为纯虚函数。如果一个类有一个纯虚函数，它被称为 **抽象类**，并且不能被实例化。派生类必须重写纯虚函数，否则它们也是抽象类。让我们通过以下代码示例来了解：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This program will fail to compile as `class B` didn’t override the `method_1`
    virtual method from `class A`. Abstract classes shift the responsibility of the
    implementation of certain behaviors (methods) to derived classes. Classes that
    have all virtual methods are called interfaces.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将无法编译，因为 `类 B` 没有重写从 `类 A` 继承来的 `method_1` 虚函数。抽象类将某些行为（方法）的实现责任转移到派生类。所有方法都是虚方法的类被称为接口。
- en: Inheritance defines a hierarchical relationship between classes, and we can
    say that `class B` is `class A,` just as a cat is an animal. We can represent
    this relationship in a **Unified Modeling Language** (**UML**) diagram.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继承定义了类之间的层次关系，我们可以说 `类 B` 是 `类 A` 的子类，就像猫是动物一样。我们可以在 **统一建模语言**（**UML**）图中表示这种关系。
- en: UML class diagrams
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UML 类图
- en: 'UML diagrams are used to describe software components. If they describe the
    relationship between classes, they are called UML class diagrams. One such diagram
    is shown in the following figure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: UML 图用于描述软件组件。如果它们描述了类之间的关系，它们被称为 UML 类图。以下图示展示了这样一个图：
- en: '![Figure 5.2 – UML diagram of class A and class B’s relationship](img/B22402_05_02.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 类 A 和类 B 关系的 UML 图](img/B22402_05_02.png)'
- en: Figure 5.2 – UML diagram of class A and class B’s relationship
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 类 A 和类 B 关系的 UML 图
- en: '*Figure 5**.2* depicts a UML class diagram visualizing the hierarchical relationship
    between `A` and `B`. The line connecting `B` and `A` with a hollow, unfilled triangular
    arrowhead pointing to `A` means `B` is `A`. This UML diagram also shows methods
    available in both classes.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 展示了一个 UML 类图，可视化 `A` 和 `B` 之间的层次关系。连接 `B` 和 `A` 的空心、未填充的三角形箭头指向 `A`
    表示 `B` 是 `A` 的子类。这个 UML 图还显示了两个类中都有的方法。'
- en: UML diagrams are useful for describing design patterns, and we will use them
    in this book to help us visualize the relationship between software components
    in code examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: UML 图对于描述设计模式很有用，我们将在本书中使用它们来帮助我们可视化代码示例中软件组件之间的关系。
- en: We have learned what inheritance is and how we can use it with virtual functions
    to achieve dynamic binding. Let’s get back to the question of why we need these
    mechanisms and how we can use them to create better software. The mechanisms we
    learned in this chapter provide the means for dynamic (runtime) polymorphism.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了继承是什么以及我们如何使用虚函数来实现动态绑定。让我们回到为什么我们需要这些机制以及我们如何使用它们来创建更好的软件的问题。本章我们学习的机制提供了动态（运行时）多态性的手段。
- en: Dynamic polymorphism
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态多态性
- en: '**Polymorphism** is a mechanism that enables a single interface for different
    types. It can be static or dynamic. Dynamic polymorphism in C++ is achieved through
    inheritance and virtual functions. This type of polymorphism is also called **subtyping**,
    as it treats subtypes or derived classes through the interface based on the base
    class.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态性** 是一种机制，它使不同类型具有单一接口。它可以是静态的或动态的。C++ 中的动态多态性是通过继承和虚函数实现的。这种多态性也称为 **子类型化**，因为它基于基类的接口处理子类型或派生类。'
- en: Polymorphism allows us to use a single interface for different implementations.
    Let us go through an example of the library for GSM modems. GSM modems usually
    communicate with the host microcontroller through the UART interface. A microcontroller
    may have multiple UART peripherals, such as UART and **Low-Power Universal Asynchronous
    Receiver/Transmitter** (**LPUART**) on STM32\. We may also want to use the library
    on different microcontrollers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多态允许我们使用单个接口来实现不同的功能。让我们通过一个 GSM 库的例子来了解一下。GSM 模拟器通常通过 UART 接口与主机微控制器通信。一个微控制器可能有多个
    UART 外设，例如 STM32 上的 UART 和 **低功耗通用异步收发传输器** (**LPUART**)。我们可能还希望在不同的微控制器上使用此库。
- en: 'We can define a common interface for different UART implementations on different
    platforms and use this interface in our GSM library. An implementation of UART
    will be provided by the platform on which we use the GSM library, and it will
    implement the common UART interface. We can use a UML class diagram to visualize
    our library design, as in the following figure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为不同平台上的不同 UART 实现定义一个通用接口，并在我们的 GSM 库中使用此接口。UART 的实现将由我们使用 GSM 库的平台提供，并且它将实现通用
    UART 接口。我们可以使用 UML 类图来可视化我们的库设计，如下图所示：
- en: '![Figure 5.3 – UML diagram of GSM library and UART interface](img/B22402_05_03.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – GSM 库和 UART 接口的 UML 图](img/B22402_05_03.png)'
- en: Figure 5.3 – UML diagram of GSM library and UART interface
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – GSM 库和 UART 接口的 UML 图
- en: 'In *Figure 5**.3*, we see the relationship between the `gsm_lib`, `uart`, and
    `uart_stm32` classes. GSM library functionality is implemented in the `gsm_lib`
    class, which uses the `uart` interface. The `uart` interface is implemented by
    the `uart_stm32` class. The functionality of the GSM library is complex, but let’s
    go through a very simplified code example just to demonstrate the relationship
    between these three classes and how they work together. The following is a simplified
    example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5**.3 中，我们看到 `gsm_lib`、`uart` 和 `uart_stm32` 类之间的关系。GSM 库的功能在 `gsm_lib`
    类中实现，它使用 `uart` 接口。`uart` 接口由 `uart_stm32` 类实现。GSM 库的功能很复杂，但让我们通过一个非常简化的代码示例来展示这三个类之间的关系以及它们是如何协同工作的。以下是一个简化的示例：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code example, we see that the `uart` class has two pure virtual functions,
    which makes it an interface class. This interface is inherited and implemented
    by the `uart_stm32` class. In the `main` function, we create an object of the
    `uart_stm32` class, whose reference is passed to the constructor of the `gsm_lib`
    class, where it is used to initialize a private member reference to the `uart`
    interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们看到 `uart` 类有两个纯虚函数，这使得它成为一个接口类。这个接口被 `uart_stm32` 类继承并实现。在 `main`
    函数中，我们创建了一个 `uart_stm32` 类的对象，其引用被传递到 `gsm_lib` 类的构造函数中，在那里它被用来初始化一个指向 `uart`
    接口的私有成员引用。
- en: You can also run this program in a simulator environment, which we covered in
    the previous chapter. It is available in the `Chapter05/gsm_lib` folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在上一章中提到的模拟器环境中运行此程序。它位于 `Chapter05/gsm_lib` 文件夹中。
- en: The design of the GSM library using the UART interface allows us to have a flexible
    library that we can use on different platforms. This design also allows us to
    debug the communication between the library and GSM modem by providing it with
    a UART implementation that will serve as a tap, redirecting reads and writes and
    simultaneously logging them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UART 接口设计的 GSM 库使我们能够拥有一个灵活的库，我们可以在不同的平台上使用。这种设计还允许我们通过提供用作夹具的 UART 实现来调试库与
    GSM 模拟器之间的通信，该实现将重定向读取和写入操作，并同时记录它们。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of classes in C++. We learned about member
    access specifiers, different ways of initializing objects, and inheritance. We
    also got to know virtual functions in more detail and learned how to use them
    for dynamic polymorphism.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 C++ 中类的基础知识。我们学习了成员访问说明符、初始化对象的不同方式以及继承。我们还更详细地了解了虚函数，并学习了如何使用它们来实现动态多态。
- en: In the next chapter, we will talk more about other basic concepts in C++, such
    as namespaces, function overloading, and the standard library.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地讨论 C++ 中的其他基本概念，例如命名空间、函数重载和标准库。
- en: Join our community on Discord
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord1.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_code_Discord1.png)'
