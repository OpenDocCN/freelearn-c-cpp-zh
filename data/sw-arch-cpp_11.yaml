- en: Writing Testable Code
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可测试的代码
- en: The ability to test code is the most important quality of any software product.
    Without proper testing, it is prohibitively expensive to refactor the code or
    to improve any other part of it, such as its security, scalability, or performance.
    In this chapter, we'll learn how to design and manage automated tests and how
    to correctly use fakes and mocks when it is necessary to do so.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试的能力是任何软件产品最重要的质量。没有适当的测试，重构代码或改进其安全性、可扩展性或性能等其他部分将成本高昂。在本章中，我们将学习如何设计和管理自动化测试，以及在必要时如何正确使用伪造和模拟。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why do you test code?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要测试代码？
- en: Introducing testing frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入测试框架
- en: Understanding mocks and fakes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模拟和伪造
- en: Test-driven class design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动的类设计
- en: Automating tests for continuous integration/continuous deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试以实现持续集成/持续部署
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter08](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter08).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter08](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter08)找到。
- en: 'The software that we will be using in this chapter''s examples is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例中将使用的软件如下：
- en: GTest 1.10+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GTest 1.10+
- en: Catch2 2.10+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Catch2 2.10+
- en: CppUnit 1.14+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CppUnit 1.14+
- en: Doctest 2.3+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Doctest 2.3+
- en: Serverspec 2.41+
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serverspec 2.41+
- en: Testinfra 3.2+
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Testinfra 3.2+
- en: Goss 0.3+
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goss 0.3+
- en: CMake 3.15+
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.15+
- en: Autoconf
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autoconf
- en: Automake
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Automake
- en: Libtool
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Libtool
- en: Why do you test code?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要测试代码？
- en: Software engineering and software architecture is a very complex matter, and
    the natural way to deal with uncertainties is to insure yourself against potential
    risks. We do it all the time with life insurance, health insurance, and car insurance.
    Yet when it comes to software development, we tend to forget about all the safety
    precautions and just hope for an optimistic outcome.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程和软件架构是非常复杂的问题，应对不确定性的自然方式是对潜在风险进行保险。我们一直在做人寿保险、健康保险和汽车保险。然而，当涉及软件开发时，我们往往忘记了所有的安全预防措施，只是希望有一个乐观的结果。
- en: Knowing that things not only may but *will* go wrong, it is unbelievable that
    the topic of testing software is still a controversial one. Whether it's from
    having a lack of skill or from a lack of budget, there are still projects that
    lack even some of the most basic tests. And when the client decides to change
    the requirements, a simple correction may result in endless reworks and firefights.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 知道事情不仅可能而且*一定*会出错，测试软件的话题仍然是一个有争议的话题，这是令人难以置信的。无论是因为缺乏技能还是缺乏预算，仍然有一些项目甚至缺乏一些最基本的测试。当客户决定更改需求时，简单的更正可能导致无休止的重做和火拼。
- en: The time that's saved from not implementing proper testing is lost when the
    first rework happens. If you think this rework will not happen very soon, you
    are most probably very mistaken. In the agile environment we live in nowadays,
    reworks are a part of our daily life. Our knowledge about the world and our customers'
    changes means that the requirements change, and with that comes making changes
    to our code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有实施适当的测试而节省的时间将在第一次重做时丢失。如果您认为这次重做不会很快发生，那么您很可能是大错特错。在我们现在生活的敏捷环境中，重做是我们日常生活的一部分。我们对世界和客户的了解意味着需求会发生变化，随之而来的是对我们代码的更改。
- en: Therefore, testing's main purpose is to protect your precious time later in
    the project. Sure, it's an investment early on when you have to implement various
    tests instead of focusing solely on the features, but it's an investment you won't
    regret. Like an insurance policy, testing takes a little from your budget when
    things go according to plan, but when things go bad, you'll get a generous payout.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试的主要目的是在项目后期保护您宝贵的时间。当您不得不实施各种测试而不是仅专注于功能时，这当然是一个早期的投资，但这是一个您不会后悔的投资。就像保险政策一样，当事情按计划进行时，测试会从您的预算中少扣一点，但当事情变糟时，您将获得丰厚的回报。
- en: The testing pyramid
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: 'There are different types of testing you may encounter when designing or implementing
    a software system. Each of the classes serves a slightly different purpose. They
    can be categorized as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计或实施软件系统时，您可能会遇到不同类型的测试。每个类别都有稍微不同的目的。它们可以归类如下：
- en: 'Unit testing: Code'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：代码
- en: 'Integration testing: Design'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试：设计
- en: 'System testing: Requirements'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试：需求
- en: 'Acceptance testing (**end-to-end** or **E2E**): Client needs'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试（端到端或E2E）：客户需求
- en: 'This distinction is arbitrary and you may often see other layers of the pyramid,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区分是任意的，您可能经常看到金字塔的其他层，如下所示：
- en: Unit testing
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Service testing
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务测试
- en: UI testing (**end-to-end** or **E2E**)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI测试（端到端或E2E）
- en: 'Here, unit testing refers to the same layer as in the previous example. Service
    testing refers to a combination of integration testing and system testing. On
    the other hand, UI testing refers to acceptance testing. The following diagram
    shows the testing pyramid:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单元测试指的是与前面示例中相同的层。服务测试指的是集成测试和系统测试的组合。另一方面，UI测试指的是验收测试。以下图显示了测试金字塔：
- en: '![](img/38151759-9e75-4e63-a745-4364c71a9eaf.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38151759-9e75-4e63-a745-4364c71a9eaf.png)'
- en: Figure 8.1 – Testing pyramid
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 测试金字塔
- en: It's worth noting that unit tests are not only the cheapest to build but that
    they also execute pretty quickly and can often run in parallel. This means they
    make for a great continuous integration gating mechanism. Not only that, but they
    also often provide the best feedback about the health of your system. Higher-level
    tests are not only harder to write properly, but they also may be less robust.
    This can lead to flickering test results, with one in every few test runs failing.
    If the failure in the higher-level test is not correlated with any failure at
    the unit test level, chances are that the problem may be with the test itself
    and not in the system under test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，单元测试不仅是最便宜的构建方式，而且执行速度相当快，通常可以并行运行。这意味着它们非常适合作为持续集成的门控机制。不仅如此，它们通常也提供有关系统健康状况的最佳反馈。高级别测试不仅更难正确编写，而且可能不够健壮。这可能导致测试结果闪烁，每隔一段时间就会有一次测试运行失败。如果高级别测试的失败与单元测试级别的任何失败都没有关联，那么问题很可能出在测试本身而不是被测试系统上。
- en: We don't want to say that the higher-level tests are entirely useless and that
    you should only focus on writing unit tests. That's not the case. The pyramid
    has its shape because there should be a solid base covered by unit tests. On that
    base, however, you should also have all the higher-level tests in an appropriate
    proportion. After all, it is not very hard to imagine a system where all the unit
    tests are passing, but the system itself doesn't provide any value to the customer.
    An extreme example would be a perfectly working backend without any user interface
    (be it graphical or in the form of an API) present. Sure, it passes all the unit
    tests, but that's no excuse!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想说高级别测试完全没有用，也不是说您应该只专注于编写单元测试。情况并非如此。金字塔之所以呈现这种形状，是因为应该有由单元测试覆盖的坚实基础。然而，在这个基础上，您还应该以适当的比例拥有所有高级别测试。毕竟，很容易想象出一个系统，其中所有单元测试都通过了，但系统本身对客户没有任何价值。一个极端的例子是一个完全正常工作的后端，没有任何用户界面（无论是图形界面还是API形式）。当然，它通过了所有的单元测试，但这并不是借口！
- en: As you may imagine, the opposite of the testing pyramid is known as an ice cone,
    and it is an antipattern. Violating the testing pyramid often leads to fragile
    code and hard to trace bugs. This makes debugging much more expensive and doesn't
    introduce savings in test development either.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所想象的那样，测试金字塔的相反称为冰锥，这是一种反模式。违反测试金字塔通常会导致脆弱的代码和难以追踪的错误。这使得调试成本更高，也不会在测试开发中节省成本。
- en: Non-functional testing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性测试
- en: 'What we''ve already covered are so-called functional tests. Their aim is to
    check whether the system under test fulfills the functional requirements. But
    there are also other types of requirements besides functional ones that we may
    want to control. Some of them are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖的是所谓的功能测试。它们的目的是检查被测试系统是否满足功能要求。但除了功能要求之外，还有其他类型的要求我们可能想要控制。其中一些如下：
- en: '**Performance**: Your application may behave according to requirements in terms
    of functionality but still be unusable for end users due to weak performance.
    We will focus more on improving performance in [Chapter 11](9d4b9eb1-c0cc-4fdb-b0e2-db0a401405ac.xhtml),
    *Performance.*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：您的应用程序可能在功能方面符合要求，但由于性能不佳，对最终用户来说仍然无法使用。我们将在[第11章](9d4b9eb1-c0cc-4fdb-b0e2-db0a401405ac.xhtml)中更多关注性能改进。'
- en: '**Endurance**: Even if your system can be really performant, it doesn''t mean
    it can survive a continuously high workload. And when it does, can it survive
    some of the malfunctionings of the components? When we embrace the idea that every
    piece of software is vulnerable and may break at any given moment, we start designing
    systems that can be failure-resistant. This is a concept that the Erlang ecosystem
    embraces, but the concept itself is not limited to that environment alone. In
    [Chapter 13](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml), *Designing Microservices,*
    and [Chapter 15](27377621-3532-4513-8045-caa00285fdda.xhtml), *Cloud-Native Design*,
    we will mention a bit more about designing systems that are fault-tolerant and
    the role of chaos engineering.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耐久性**：即使您的系统可能表现得非常出色，也并不意味着它能够承受持续的高负载。即使能够承受，它能够承受组件的一些故障吗？当我们接受这样一个观念，即每一款软件都是脆弱的，可能在任何时刻都会出现故障，我们开始设计可以抵御故障的系统。这是艾林生态系统所采纳的概念，但这个概念本身并不局限于该环境。在[第13章](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml)中，*设计微服务*，以及[第15章](27377621-3532-4513-8045-caa00285fdda.xhtml)中，*云原生设计*，我们将更多地提到设计具有容错能力的系统以及混沌工程的作用。'
- en: '**Security**: Nowadays, there should be no need to repeat that security is
    crucial. But since it still isn''t treated with all the seriousness the matter
    requires, we will bore you with saying this yet again. Every system that is connected
    to the network can – and most probably will – be broken. Performing security tests
    early on during development gives the same benefits as other kinds of tests: you
    can catch problems before they are too expensive to fix.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：现在，应该没有必要重复强调安全性的重要性。但由于安全性仍未得到应有的重视，我们将再次强调这一点。与网络连接的每个系统都可能被破解。在开发早期进行安全性测试可以带来与其他类型测试相同的好处：您可以在问题变得过于昂贵之前发现问题。'
- en: '**Availability**: Whereas poor performance may discourage your end users from
    using your product, poor availability may prevent them from even accessing said
    product. While availability problems may arise due to performance overload, there
    are also other causes of lost availability.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：性能不佳可能会阻止最终用户使用您的产品，而可用性不佳可能会阻止他们甚至访问该产品。虽然可用性问题可能是由于性能过载引起的，但也有其他导致可用性丧失的原因。'
- en: '**Integrity**: Your customers'' data should not only be safe from outside attackers.
    It should also be safe from any alterations or losses due to software malfunction.
    Protection against bit rot, snapshotting, and backups are ways to prevent integrity
    loss. By comparing the current version with previously recorded snapshots, you
    can make sure if the difference resulted only from the action that was taken or
    whether it was caused by errors.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：您的客户数据不仅应该受到外部攻击者的保护，还应该免受由于软件故障而导致的任何更改或损失。防止完整性损失的方法包括防止位腐败、快照和备份。通过将当前版本与先前记录的快照进行比较，您可以确保差异仅由采取的操作引起，还是由错误引起。'
- en: '**Usability**: Even a product that ticks all of the previous boxes may still
    be unsatisfactory for the users if it has a clunky interface and unintuitive interaction.
    Usability tests are mostly performed manually. It''s important to perform a usability
    assessment each time the UI or the workflow of the system changes.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：即使产品符合以前提到的所有要求，如果它具有笨拙的界面和不直观的交互，对用户来说仍然可能不尽人意。可用性测试大多是手动执行的。每次UI或系统工作流程发生变化时，执行可用性评估非常重要。'
- en: Regression testing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression tests are usually end-to-end tests that should prevent you from making
    the same mistake twice. When you (or your QA team or customers) discover a bug
    in a production system, it is not sufficient to apply a hotfix and forget all
    about it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试通常是端到端测试，应该防止您再次犯同样的错误。当您（或您的质量保证团队或客户）在生产系统中发现错误时，仅仅应用热修复并忘记所有这些是不够的。
- en: One of the things you need to do is write a regression test that should prevent
    the same error from ever entering the production system again. Good regression
    tests can even prevent the same *class* of errors from entering production. After
    all, once you know what you did wrong, you can imagine other ways to mess things
    up. Another thing you can do is perform root cause analysis.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的一件事是编写一个回归测试，以防止相同的错误再次进入生产系统。良好的回归测试甚至可以防止相同的错误*类*再次进入生产。毕竟，一旦您知道自己做错了什么，您就可以想象其他搞砸事情的方式。另一件事是执行根本原因分析。
- en: Root cause analysis
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根本原因分析
- en: Root cause analysis is a process that helps you uncover what the original source
    of the problem was, not only its manifestation. The most common way to perform
    root cause analysis is to use the method of *5 Whys*, which was made famous by
    the Toyota company. This method consists of peeling off all the superficial layers
    of the problem's manifestation to uncover the root cause hidden underneath. You
    do this by asking "why" at each layer until you find the root cause you are looking
    for.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因分析是一个过程，它帮助您发现问题的根本原因，而不仅仅是其表现形式。执行根本原因分析的最常见方法是使用“5个为什么”的方法，这一方法是由丰田公司所著名的。这种方法包括剥离问题表现的所有表面层，以揭示隐藏在其下的根本原因。您可以通过在每一层询问“为什么”来做到这一点，直到找到您正在寻找的根本原因。
- en: Let's look at an example of this method in action.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个这种方法在实际中的例子。
- en: 'The problem: We didn''t get payments for some of the transactions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：我们没有收到一些交易的付款：
- en: '*Why?* The system didn''t send the appropriate emails to the customers.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么？系统没有向客户发送适当的电子邮件。
- en: '*Why?* The email sending system doesn''t support special characters in customers''
    names.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么？邮件发送系统不支持客户姓名中的特殊字符。
- en: '*Why?* The email sending system wasn''t tested properly.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么？邮件发送系统没有得到适当测试。
- en: '*Why?* There was no time for proper testing due to a need to develop new features.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么？由于需要开发新功能，没有时间进行适当的测试。
- en: '*Why?* Our time estimates for the features were incorrect.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么？我们对功能的时间估计不正确。
- en: In this example, the problem with time estimates may be the root cause of the
    bug that was found in the production system. But it may as well be another layer
    to peel. The framework gives you a heuristic that should work most of the time,
    but if you don't feel entirely sure that what you got is what you are looking
    for, you can keep on peeling additional layers until you find what caused all
    the trouble.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对功能的时间估计问题可能是在生产系统中发现的错误的根本原因。但它也可能是另一个需要剥离的层。该框架为您提供了一个应该在大多数情况下有效的启发式方法，但如果您并不完全确定您得到的是否就是您要找的，您可以继续剥离额外的层，直到找到导致所有麻烦的原因。
- en: Given that many bugs result from the exact same and often repeatable root causes,
    finding the root cause is extremely beneficial because you can protect yourself
    from making the same mistake in the future *on several different levels*. This
    is the principle of defense in depth when it's applied to software testing and
    problem-solving.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于许多错误都是由完全相同且经常可重复的根本原因导致的，找到根本原因是非常有益的，因为您可以在未来*多个不同的层面*上保护自己免受相同错误的影响。这是深度防御原则在软件测试和问题解决中的应用。
- en: The groundwork for further improvement
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步改进的基础
- en: Having your code tested protects you from making accidental errors. But it also
    opens up different possibilities. When your code is covered by test cases, you
    don't have to fear refactoring. Refactoring is the process of transforming code
    that does its job into code that is functionally similar, except it has better
    internal organization. You may be wondering why you need to change the code's
    organization. There are several reasons for this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码进行测试可以保护您免受意外错误的影响。但它也开启了不同的可能性。当您的代码由测试用例覆盖时，您就不必担心重构。重构是将完成其工作的代码转换为功能上类似但内部组织更好的代码的过程。您可能会想知道为什么需要更改代码的组织。这样做有几个原因。
- en: First of all, your code may no longer be readable, which means every modification
    takes too much time. Second, fixing a bug you are about to fix will make some
    other features behave incorrectly as the code gathered too many workarounds and
    special cases over time. Both of those reasons can be summed up as productivity
    improvements. They will make maintenance cheaper in the long run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的代码可能已经不再可读，这意味着每次修改都需要太多时间。其次，修复一个你即将修复的错误会导致一些其他功能表现不正确，因为随着时间的推移，代码中积累了太多的变通和特殊情况。这两个原因都可以归结为提高生产力。它们将使维护成本长期更加便宜。
- en: But apart from productivity, you may also want to improve performance. This
    can mean either runtime performance (how the application behaves in production)
    or compile-time performance (which is basically another form of productivity improvement).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了生产力之外，您可能还希望提高性能。这可能意味着运行时性能（应用程序在生产中的行为）或编译时性能（基本上是另一种形式的生产力改进）。
- en: You can refactor for runtime performance by replacing the current suboptimal
    algorithms with more efficient ones or by changing the data structures that are
    used through the module you are refactoring.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过用更高效的算法替换当前的次优算法或通过更改正在重构的模块中使用的数据结构来进行运行时性能重构。
- en: Refactoring for compile-time performance usually consists of moving parts of
    code to different compilation units, reorganizing headers, or reducing dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时性能重构通常包括将代码的部分移动到不同的编译单元，重新组织头文件或减少依赖关系。
- en: No matter what your end goal is, refactoring is generally a risky business.
    You take something that mostly works correctly and can end up either with a better
    version or a worse one. How would you know which case is yours? Here, testing
    comes to the rescue.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的最终目标是什么，重构通常是一项风险很大的工作。您拿到的是大部分正确工作的东西，最终可能会得到一个更好的版本，也可能会得到一个更糟糕的版本。您怎么知道哪种情况是您的？在这里，测试就派上了用场。
- en: If the current feature set is thoroughly covered and you want to fix the recently
    uncovered bug, all you need to do is add another test case that will fail at that
    time. The moment your entire test suite starts passing again means your refactoring
    efforts were successful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前的功能集已经得到充分覆盖，并且您想修复最近发现的错误，您需要做的就是添加另一个在那时会失败的测试用例。当您的整个测试套件再次开始通过时，意味着您的重构工作是成功的。
- en: The worst-case scenario is that you have to abort the refactoring process in
    case you cannot satisfy all the test cases in a specified timeframe. You would
    undertake a similar procedure if you wanted to improve performance, but instead
    of unit tests (or end-to-end tests), you would focus on performance testing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况是，如果您无法在指定的时间范围内满足所有测试用例，您将不得不中止重构过程。如果您想要提高性能，您将进行类似的过程，但是不是针对单元测试（或端到端测试），而是专注于性能测试。
- en: 'With the recent rise of automated tools that aid in refactoring (such as ReSharper
    C++: [https://www.jetbrains.com/resharper-cpp/features/ReSharper C++:](https://www.jetbrains.com/resharper-cpp/features/)
    ) and code maintenance, you can even go as far as outsourcing a part of coding
    solely to the external software services. Services such as Renovate ([https://renovatebot.com/](https://renovatebot.com/)),
    Dependabot ([https://dependabot.com](https://dependabot.com)), and Greenkeeper
    ([https://greenkeeper.io/](https://greenkeeper.io/)) may soon support C++ dependencies.
    Having solid test coverage will let you use them without the fear of breaking
    your application during dependency updates.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着自动化工具的崛起，这些工具可以帮助重构（例如ReSharper C++：[https://www.jetbrains.com/resharper-cpp/features/](https://www.jetbrains.com/resharper-cpp/features/)）和代码维护，您甚至可以将部分编码外包给外部软件服务。像Renovate（[https://renovatebot.com/](https://renovatebot.com/)）、Dependabot（[https://dependabot.com](https://dependabot.com)）和Greenkeeper（[https://greenkeeper.io/](https://greenkeeper.io/)）这样的服务可能很快就会支持C++依赖项。拥有坚实的测试覆盖率将使您能够在依赖项更新期间使用它们，而不用担心破坏应用程序。
- en: Since keeping your dependencies up to date in terms of security vulnerabilities
    is something you should always consider, such services can reduce the burden significantly.
    Therefore, testing not only protects you from making mistakes, but it reduces
    the effort necessary to introduce new features. It can also help you improve your
    code base and keep it stable and secure!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于始终要考虑保持依赖项的安全漏洞最新状态，这样的服务可以显著减轻负担。因此，测试不仅可以保护您免受错误，还可以减少引入新功能所需的工作量。它还可以帮助您改进代码库并保持其稳定和安全！
- en: Now that we understand the need for testing, we want to start writing our own
    tests. It is possible to write tests without any external dependencies. However,
    we'd like to focus just on the testing logic. We're not interested in the details
    of managing test results and reporting. Therefore, we will select a testing framework
    to handle this tedious job for us. In the next section, we will introduce some
    of the most popular testing frameworks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了测试的必要性，我们想要开始编写我们自己的测试。可以在没有任何外部依赖项的情况下编写测试。但是，我们只想专注于测试逻辑。我们对管理测试结果和报告的细节不感兴趣。因此，我们将选择一个测试框架来为我们处理这项繁琐的工作。在下一节中，我们将介绍一些最受欢迎的测试框架。
- en: Introducing testing frameworks
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入测试框架
- en: As for the frameworks, the current de facto standard is Google's GTest. Together
    with its counterpart GMock, they form a small suite of tools that allow you to
    follow the best practices of testing in C++.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 至于框架，当前的事实标准是Google的GTest。与其配对的GMock一起，它们形成了一套小型工具，使您能够遵循C++中的最佳测试实践。
- en: Other popular alternatives to GTest/GMock duo are Catch2, CppUnit, and Doctest.
    CppUnit has been available for a long time, but its lack of recent releases means
    we don't recommend it for fresh projects. Both Catch2 and Doctest support the
    modern C++ standards – in particular, C++14, C++17, and C++20.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: GTest/GMock二人组的其他热门替代方案包括Catch2、CppUnit和Doctest。CppUnit已经存在很长时间了，但由于缺乏最近的发布，我们不建议将其用于新项目。Catch2和Doctest都支持现代C++标准-特别是C++14、C++17和C++20。
- en: To compare these testing frameworks, we will use the same codebase that we want
    to test. Using it as a basis, we will then implement tests in each of the frameworks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较这些测试框架，我们将使用相同的代码库来进行测试。基于此，我们将在每个框架中实现测试。
- en: GTest examples
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GTest示例
- en: 'Here is an example test for our customer library written in GTest:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用GTest编写的客户库的示例测试：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of the tasks that are commonly done during testing have been abstracted.
    We're mostly focused on providing the action we want to test (`prepare_response`)
    and the desired behavior (both `ASSERT_EQ` lines).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在测试期间通常完成的任务已经被抽象化了。我们主要关注提供我们想要测试的操作（`prepare_response`）和期望的行为（两个`ASSERT_EQ`行）。
- en: Catch2 examples
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Catch2示例
- en: 'Here is an example test for our customer library written in Catch2:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Catch2编写的客户库的示例测试：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It looks pretty similar to the previous one. Some keywords differ (`TEST` and
    `TEST_CASE`) and there's a slightly different way to check the results (`REQUIRE(a
    == b)` instead of `ASSERT_EQ(a,b)`). Both are pretty compact and readable anyway.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与前一个非常相似。一些关键字不同（`TEST`和`TEST_CASE`），并且检查结果的方式略有不同（`REQUIRE(a == b)`而不是`ASSERT_EQ(a,b)`）。无论如何，两者都非常简洁和易读。
- en: CppUnit examples
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CppUnit示例
- en: Here is an example test for our customer library written in CppUnit. We will
    split it into several snippets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用CppUnit编写的客户库的示例测试。我们将其拆分为几个片段。
- en: 'The following code block prepares us to use the constructs from the CppUnit
    library:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块准备我们使用CppUnit库中的构造：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we must define the test class and implement the method that will execute
    our test case. After that, we must register the class so that we can use it in
    our test runner:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义测试类并实现将执行我们的测试用例的方法。之后，我们必须注册类，以便我们可以在我们的测试运行器中使用它：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we must provide the behavior of our test runner:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须提供我们测试运行器的行为：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compared to the previous two examples, there's a lot of boilerplate in here.
    The test itself, however, looks pretty similar to the previous example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个示例相比，这里有很多样板代码。然而，测试本身看起来与前一个示例非常相似。
- en: Doctest examples
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest示例
- en: 'Here is an example test for our customer library written in Doctest:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Doctest编写的客户库的示例测试：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, it's quite clean and easy to understand. The main selling point
    of Doctest is that it's the fastest both at compile-time and at runtime compared
    to the other similarly-featured alternatives.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，它非常干净且易于理解。Doctest的主要卖点是，与其他类似功能的替代品相比，它在编译时和运行时都是最快的。
- en: Testing compile-time code
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试编译时代码
- en: Template metaprogramming allows us to write C++ code that is executed during
    compile-time as opposed to the usual execution time. The `constexpr` keyword,
    which was added in C++11, allows us to use even more compile-time code, and `consteval`
    keyword from C++20 aims to give us greater control over the way the code is evaluated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程允许我们编写在编译时执行的C++代码，而不是通常的执行时间。在C++11中添加的`constexpr`关键字允许我们使用更多的编译时代码，而C++20中的`consteval`关键字旨在让我们更好地控制代码的评估方式。
- en: One of the problems with compile-time programming is that there is no easy way
    to test it. While unit testing frameworks for execution time code are abundant
    (as we just saw), there are not that many resources regarding compile-time programming.
    Part of this may stem from the fact that compile-time programming is still considered
    complicated and only aimed at experts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时编程的问题之一是没有简单的方法来测试它。虽然执行时间代码的单元测试框架很丰富（正如我们刚才看到的），但关于编译时编程的资源并不那么丰富。部分原因可能是编译时编程仍然被认为是复杂的，只针对专家。
- en: Just because something isn't easy doesn't mean it is impossible, though. Just
    like execution time tests rely on assertions being checked during runtime, you
    can check your compile-time code for correct behavior using `static_assert`, which
    was introduced alongside `constexpr` in C++11.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为某些事情不容易并不意味着它是不可能的。就像执行时间测试依赖于运行时检查断言一样，您可以使用`static_assert`来检查您的编译时代码的正确行为，这是在C++11中与`constexpr`一起引入的。
- en: 'The following is a simple example of using `static_assert`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`static_assert`的一个简单示例：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we can compute each value tested here during compile time, we can effectively
    use the compiler as our testing framework.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在编译时计算这里测试的每个值，我们可以有效地使用编译器作为我们的测试框架。
- en: Understanding mocks and fakes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模拟对象和伪造对象
- en: As long as you are testing functions that do not interact too much with the
    outside world, things are pretty easy. The problems start when the units you are
    testing interface with third-party components such as databases, HTTP connections,
    and specific files.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您测试的函数与外部世界的交互不太多，事情就会变得相当容易。当您测试的单元与数据库、HTTP连接和特定文件等第三方组件进行接口时，问题就开始了。
- en: On one hand, you want to see how your code behaves due to various circumstances.
    On the other hand, you don't want to wait for the database to boot, and you definitely
    don't want to have several databases containing different versions of data so
    that you can check all the necessary conditions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，您希望看到您的代码在各种情况下的行为。另一方面，您不希望等待数据库启动，而且您绝对不希望有几个包含不同数据版本的数据库，以便您可以检查所有必要的条件。
- en: How can we deal with such cases? The idea is not to execute the actual code
    that triggers all those side effects but instead use test doubles. Test doubles
    are constructions in code that mimic the actual API, except they don't perform
    actions of the mimicked functions or objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这种情况？这个想法不是执行触发所有这些副作用的实际代码，而是使用测试替身。测试替身是代码中模仿实际API的构造，除了它们不执行模仿函数或对象的操作。
- en: The most common test doubles are mocks, fakes, and stubs. Many people tend to
    mistake one for another as they are similar, though not the same.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的测试替身是模拟对象、伪造对象和存根。许多人往往会将它们误认为是相同的，尽管它们并不相同。
- en: Different test doubles
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的测试替身
- en: Mocks are test doubles that register all the received calls but do nothing more
    than that. They do not return any value and they do not change state in any way.
    They are useful when we have a third-party framework that is supposed to call
    our code. By using mocks, we can observe all the calls and are thus able to verify
    that the framework behaves as expected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是注册所有接收到的调用但不做其他任何事情的测试替身。它们不返回任何值，也不以任何方式改变状态。当我们有一个应该调用我们代码的第三方框架时，使用模拟是有用的。通过使用模拟，我们可以观察所有调用，因此能够验证框架的行为是否符合预期。
- en: Stubs are a bit more complicated when it comes to their implementation. They
    return values, but those values are predefined. It may seem surprising that the
    `StubRandom.randomInteger()` method always returns the same value (for example,
    `3`), but it may be a sufficient stub implementation when we are testing the type
    of the returned value or the fact that it does return a value at all. The exact
    value may not be that important.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到存根的实现时，它们会更加复杂。它们返回值，但这些值是预定义的。也许令人惊讶的是，`StubRandom.randomInteger()`方法总是返回相同的值（例如`3`），但当我们测试返回值的类型或者它是否返回值时，这可能是一个足够的存根实现。确切的值可能并不那么重要。
- en: Finally, fakes are objects that have a working implementation and behave mostly
    like the actual production implementation. The main difference is that fakes may
    take various shortcuts, such as avoiding calling the production database or filesystem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，伪装是具有工作实现并且行为大部分像实际生产实现的对象。主要区别在于伪装可能采取各种捷径，比如避免调用生产数据库或文件系统。
- en: When implementing the **Command Query Separation** (**CQS**) design pattern,
    you will usually want to double queries with stubs and commands with mocks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现**命令查询分离**（**CQS**）设计模式时，通常会使用存根来替代查询，使用模拟来替代命令。
- en: Other uses for test doubles
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试替身的其他用途
- en: Fakes can also be used, to a limited extent, outside of testing. In-memory processing
    data without resorting to database access can also be great for prototyping or
    when you're hitting performance bottlenecks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 伪装也可以在测试之外的有限范围内使用。在内存中处理数据而不依赖数据库访问也可以用于原型设计或者当您遇到性能瓶颈时。
- en: Writing test doubles
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试替身
- en: 'To write test doubles, we typically use an external library, just as we do
    with unit tests. Some of the most popular solutions are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试替身时，我们通常会使用外部库，就像我们在单元测试中所做的那样。一些最受欢迎的解决方案如下：
- en: 'GoogleMock (also known as gMock), which is now a part of the GoogleTest library:
    [https://github.com/google/googletest](https://github.com/google/googletest).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoogleMock（也称为gMock），现在是GoogleTest库的一部分：[https://github.com/google/googletest](https://github.com/google/googletest)。
- en: 'Trompeloeil, which focuses on C++14, integrates well with many testing libraries,
    such as Catch2, doctest, and GTest: [https://github.com/rollbear/trompeloeil](https://github.com/rollbear/trompeloeil).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trompeloeil专注于C++14，与许多测试库（如Catch2、doctest和GTest）集成得很好：[https://github.com/rollbear/trompeloeil](https://github.com/rollbear/trompeloeil)。
- en: The code in the following sections will show you how to use both GoogleMock
    and Trompeloeil.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分的代码将向您展示如何同时使用GoogleMock和Trompeloeil。
- en: GoogleMock example
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GoogleMock示例
- en: 'Since GoogleMock is part of GoogleTest, we will present them together:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GoogleMock是GoogleTest的一部分，我们将它们一起介绍：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: GTest is the most popular C++ testing framework at the time of writing this
    book. Its integration with GMock means that GMock is probably already available
    for you in your project. This combination is intuitive to use and fully-featured,
    so there's no reason to look for alternatives if you're already invested in GTest.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，GTest是最受欢迎的C++测试框架。它与GMock的集成意味着GMock可能已经在您的项目中可用。如果您已经在使用GTest，这种组合使用起来直观且功能齐全，因此没有理由寻找其他替代方案。
- en: Trompeloeil example
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Trompeloeil示例
- en: 'To contrast this example with the previous one, this time, we are using Trompeloeil
    for test doubles and Catch2 as a testing framework:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，这次我们使用Trompeloeil作为测试替身，Catch2作为测试框架：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One of the great features of Catch2 is that it makes it easy to write behavior-driven
    development-style tests, such as the one shown here. If you prefer this style,
    then Catch2 with Trompeloeil would be a good choice as they integrate very well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2的一个很棒的特性是它可以轻松编写行为驱动开发风格的测试，就像这里展示的一样。如果您喜欢这种风格，那么Catch2与Trompeloeil将是一个很好的选择，因为它们集成得非常好。
- en: Test-driven class design
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动的类设计
- en: It's not enough to distinguish between different types of tests and learn a
    particular testing framework (or several). When you start testing your actual
    code, you will soon notice that not all classes can be tested easily. Sometimes,
    you may feel the need to access private attributes or methods. Resist this urge
    if you want to maintain the principles of good architecture! Instead, consider
    either testing the business requirements that are available through the type's
    public API or refactoring the type so that there's another unit of code you can
    test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 区分不同类型的测试并学习特定的测试框架（或多个框架）是不够的。当您开始测试实际代码时，很快就会注意到并非所有类都能轻松测试。有时，您可能需要访问私有属性或方法。如果您想保持良好架构原则，请抵制这种冲动！相反，考虑测试通过类型的公共API可用的业务需求，或者重构类型，以便有另一个可以测试的代码单元。
- en: When tests and class design clash
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当测试和类设计发生冲突时
- en: The problem you may be facing is not that the testing frameworks are inadequate.
    Usually, what you encounter is inappropriately designed classes. Even though your
    classes may behave correctly and may look correct unless they allow for testing,
    they are not designed correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能面临的问题并不是测试框架不足够。通常，您遇到的问题是类设计不当。即使您的类可能行为正确并且看起来正确，除非它们允许测试，否则它们并没有正确设计。
- en: However, this is good news. It means that you can repair the problem before
    it's inconvenient to do so. The class design will probably haunt you later on
    when you start building a class hierarchy based on it. Fixing the design during
    test implementation will simply reduce the possible technological debt.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是个好消息。这意味着你可以在问题变得不方便之前修复它。当你开始基于它构建类层次结构时，类设计可能会在以后困扰你。在测试实现过程中修复设计将简单地减少可能的技术债务。
- en: Defensive programming
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御性编程
- en: Unlike its name may suggest, defensive programming is not a security feature.
    Its name comes from defending your classes and functions from being used contrary
    to their original intention. It's not directly related to testing, but it's a
    great design pattern to use since it improves your code's quality, making your
    project future-proof.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与其名字可能暗示的不同，防御性编程并不是一个安全功能。它的名字来自于保护你的类和函数不被用于与它们最初意图相反的方式。它与测试没有直接关系，但是它是一个很好的设计模式，因为它提高了你代码的质量，使你的项目具有未来的可靠性。
- en: Defensive programming starts with static typing. If you create a function that
    handles a custom-defined type as a parameter, you must make sure nobody will call
    it with some accidental value. A user will have to consciously check what the
    function expects and prepare the input accordingly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程始于静态类型。如果你创建一个处理自定义定义类型的函数作为参数，你必须确保没有人会用一些意外的值来调用它。用户将不得不有意识地检查函数的期望并相应地准备输入。
- en: 'In C++, we can also leverage type-safety features when we''re writing template
    code. When we''re creating a container for our customers'' reviews, we could accept
    a list of any type and copy from it. To get nicer errors and well-crafted checks,
    we could write the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当我们编写模板代码时，我们也可以利用类型安全特性。当我们为我们客户的评论创建一个容器时，我们可以接受任何类型的列表并从中复制。为了得到更好的错误和精心设计的检查，我们可以编写以下内容：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `explicit` keyword protects us from unwanted implicit casts. By specifying
    that our input parameter satisfies the `range` concept, we ensure that we''re
    only going to compile with a valid container. Thanks to using concepts, we can
    get clearer error messages from our defense against invalid use. Using `static_assert`
    in our code is also a great defensive measure as it allows us to provide a nice
    error message if needed. Our `is_range_of_reviews` check could be implemented
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`explicit`关键字保护我们免受不必要的隐式转换。通过指定我们的输入参数满足`range`概念，我们确保只会与有效的容器一起编译。通过使用概念，我们可以从我们对无效使用的防御中获得更清晰的错误消息。在我们的代码中使用`static_assert`也是一个很好的防御措施，因为它允许我们在需要时提供一个好的错误消息。我们的`is_range_of_reviews`检查可以实现如下：'
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This way, we ensure that the range we got actually contains reviews of the type
    we desire.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们确保得到的范围实际上包含我们想要的类型的评论。
- en: 'Static typing will not prevent invalid runtime values from being passed to
    the function. That''s why the next form of defensive programming is checking preconditions.
    This way, your code will fail as soon as the first sign of a problem arises, which
    is always better than returning an invalid value that propagates to other parts
    of the system. Until we have contracts in C++, we can use the GSL library we mentioned
    in earlier chapters to check the pre- and post-conditions of our code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型不会阻止无效的运行时值被传递给函数。这就是防御性编程的下一个形式，检查前置条件。这样，你的代码将在问题的第一个迹象出现时失败，这总是比返回一个无效值传播到系统的其他部分要好。在C++中，直到我们有合同，我们可以使用我们在前几章中提到的GSL库来检查我们代码的前置条件和后置条件：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, by using the `Expects` macro, we're checking that our incoming review
    actually has the IDs of the merchant and reviewer set. Aside from the cases where
    it doesn't, we are also defending ourselves against cases where adding a review
    to our storage failed when we use the `Ensures` post-condition macro.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过使用`Expects`宏，我们检查我们传入的评论实际上是否设置了商家和评论者的ID。除了它不设置的情况，我们还在使用`Ensures`后置条件宏时防范了将评论添加到我们的存储失败的情况。
- en: 'When it comes to runtime checks, one of the first things that comes to mind
    is checking whether one or more attributes is not a `nullptr`. The best way to
    guard yourself against this problem is to distinguish nullable resources (those
    that can take `nullptr` as value) from non-nullable ones. There''s a great tool
    you can use for this, and is available in the standard library from C++17: `std::optional`.
    If you can, use it in all the APIs that you design.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到运行时检查时，首先想到的是检查一个或多个属性是否不是`nullptr`。防范自己免受这个问题的最佳方法是区分可空资源（可以取`nullptr`作为值的资源）和不可空资源。有一个很好的工具可以用于这个问题，并且在C++17的标准库中可用：`std::optional`。如果可以的话，在你设计的所有API中都要使用它。
- en: The boring refrain – write your tests first
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无聊的重复——先写你的测试
- en: This has been said many times, yet many people tend to "forget" this rule. When
    you actually write your tests, the first thing you must do is reduce the risk
    of creating classes that are hard to test. You start with API usage and need to
    bend the implementation to best serve the API. This way, you usually end up with
    APIs that are both more pleasant to use and easier to test. When you're implementing
    **test-driven development** (**TDD**) or writing tests before code, you'll also
    end up implementing dependency injection, which means your classes can be more
    loosely coupled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经说了很多次，但很多人倾向于“忘记”这个规则。当你实际编写你的测试时，你必须做的第一件事是减少创建难以测试的类的风险。你从API的使用开始，需要调整实现以最好地服务API。这样，你通常会得到更愉快使用和更容易测试的API。当你实施**测试驱动开发**（**TDD**）或在编写代码之前编写测试时，你也会实施依赖注入，这意味着你的类可以更松散地耦合。
- en: Doing this the other way around (writing your classes first and only then adding
    unit tests to them) may mean that you up with code that is easier to write but
    harder to test. And when testing gets harder, you may feel the temptation to skip
    it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来做（先编写你的类，然后再为它们添加单元测试）可能意味着你会得到更容易编写但更难测试的代码。当测试变得更难时，你可能会感到诱惑跳过它。
- en: Automating tests for continuous integration/continuous deployment
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化持续集成/持续部署的测试
- en: In the next chapter, we will focus on **continuous integration** and **continuous
    deployment** (**CI**/**CD**). For a CI/CD pipeline to work properly, you need
    to have a set of tests that catch the bugs before they enter production. It is
    up to you and your team to make sure all the business requirements are properly
    expressed as tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于持续集成和持续部署（CI/CD）。要使CI/CD流水线正常工作，您需要一组测试来捕捉错误，以防它们进入生产环境。要确保所有业务需求都被适当地表达为测试，这取决于您和您的团队。
- en: Tests are useful on several levels. With behavior-driven development, which
    we mentioned in the previous section, business requirements form a basis for automated
    tests. But the system you are building doesn't consist solely of business requirements.
    You want to make sure all the third-party integrations are working as expected.
    You want to make sure all your subcomponents (such as microservices) can actually
    interface with each other. Finally, you want to make sure that the functions and
    classes you are building are free of any bugs you could have imagined.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在几个层面上都很有用。在行为驱动开发中，我们在前一节中提到，业务需求是自动化测试的基础。但是您正在构建的系统不仅仅由业务需求组成。您希望确保所有第三方集成都按预期工作。您希望确保所有子组件（如微服务）实际上可以相互接口。最后，您希望确保您构建的函数和类没有您可以想象到的任何错误。
- en: Each test that you can automate is a candidate for a CI/CD pipeline. Each of
    them also has its place somewhere in this pipeline. For example, end-to-end tests
    make the most sense after the deployment as acceptance tests. On the other hand,
    unit tests make the most sense when they're executed directly after compilation.
    After all, our aim is to break the circuit as soon as we find any possible divergence
    from the specification.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自动化的每个测试都是CI/CD流水线的候选项。它们每一个也都在这个流水线的某个地方有其位置。例如，端到端测试在部署后作为验收测试是最有意义的。另一方面，单元测试在编译后直接执行时是最有意义的。毕竟，我们的目标是一旦发现与规范可能有任何分歧，就尽快中断电路。
- en: You don't have to run all the tests that you have automated each time you run
    a CI/CD pipeline. It's better if the runtime of each pipeline is relatively short.
    Ideally, it should finish within a couple of minutes from the commit. How can
    we make sure everything is properly tested, then, if we want to keep the runtime
    minimal?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行CI/CD流水线时，您不必运行所有自动化的测试。最好是每个流水线的运行时间相对较短。理想情况下，应该在提交后的几分钟内完成。如果我们希望保持运行时间最短，那么如何确保一切都经过了适当的测试呢？
- en: One answer is to prepare different suites of tests for different purposes. For
    example, you can have minimal tests for commits to a feature branch. With many
    commits coming to feature branches every day, this means they will only be tested
    briefly and that the answer will be available fast. Merging feature branches to
    the shared development branch then requires a slightly larger set of test cases.
    This way, we make sure we haven't broken anything that other team members will
    be using. Finally, a more extensive set of cases will be run for merges to production
    branches. After all, we want the production branches to be tested thoroughly,
    even if the testing takes quite a long time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个答案是为不同目的准备不同套件的测试。例如，您可以为提交到功能分支的最小测试。由于每天有许多提交到功能分支，这意味着它们只会被简要测试，并且答案将很快可用。然后，将功能分支合并到共享开发分支需要稍大一些的测试用例集。这样，我们可以确保我们没有破坏其他团队成员将使用的任何内容。最后，对于合并到生产分支的测试将运行更广泛的用例。毕竟，我们希望对生产分支进行彻底测试，即使测试需要很长时间。
- en: Another answer is to use the trimmed-down set of test cases for CI/CD purposes
    and have an additional continuous testing process. This process runs regularly
    and performs in-depth checks on the current state of a particular environment.
    The tests can go as far as security tests and performance tests and may thus assess
    the eligibility of the environment to be promoted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个答案是为CI/CD目的使用精简的测试用例集，并进行额外的持续测试过程。此过程定期运行，并对特定环境的当前状态进行深入检查。测试可以进行到安全测试和性能测试，因此可能评估环境是否有资格进行推广。
- en: Promotion occurs when we select an environment and acknowledge that this environment
    has all the qualities to become a more mature environment. For example, that development
    environment can become the next staging environment, or that staging environment
    can become the next production environment. If this promotion happens automatically,
    it is also a good practice to provide automatic rollback in case the subtle differences
    (such as in terms of domain name or traffic) make the freshly promoted environment
    no longer pass the tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择一个环境并确认该环境具备成为更成熟环境的所有特质时，就会发生推广。例如，开发环境可以成为下一个暂存环境，或者暂存环境可以成为下一个生产环境。如果此推广是自动进行的，还有一个好的做法是在新推广的环境不再通过测试（例如域名或流量方面的微小差异）时提供自动回滚。
- en: 'This also presents another important practice: to always run tests on the production
    environment. Such tests have to be the least intrusive, of course, but they should
    tell you that your system is performing correctly at any given time.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这也提出了另一个重要的做法：始终在生产环境上运行测试。当然，这些测试必须是最不具侵入性的，但它们应该告诉您系统在任何给定时间都在正确执行。
- en: Testing the infrastructure
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试基础设施
- en: If you want to incorporate the concepts of configuration management, Infrastructure
    as Code, or immutable deployments into the software architecture of your application,
    you should also consider testing the infrastructure itself. There are several
    tools you can use to do this, including Serverspec, Testinfra, Goss, and Terratest,
    which are among some of the more popular ones.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将配置管理、基础设施即代码或不可变部署的概念纳入应用程序的软件架构中，您还应该考虑测试基础设施本身。有几种工具可以用来做到这一点，包括Serverspec、Testinfra、Goss和Terratest，它们是一些比较流行的工具之一。
- en: 'These tools slightly differ in scope, as stated here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具在范围上略有不同，如下所述：
- en: Serverspec and Testinfra focus more on testing the actual state of the servers
    that are configured via configuration management, such as Salt, Ansible, Puppet,
    and Chef. They're written in Ruby and Python, respectively, and they plug into
    the languages' testing engines. This means RSPec for Serverspec and Pytest for
    Testinfra.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serverspec和Testinfra更专注于测试通过配置管理（如Salt、Ansible、Puppet和Chef）配置的服务器的实际状态。它们分别用Ruby和Python编写，并插入到这些语言的测试引擎中。这意味着Serverspec使用RSPec，而Testinfra使用Pytest。
- en: Goss is a bit different both in terms of scope and form. Besides testing the
    servers, you can also use Goss to test the containers you use in your project
    with the dgoss wrapper. As for its form, it doesn't use the imperative code you
    would see in Serverspec or Testinfra. Rather, similar to Ansible or Salt, it uses
    a YAML file to describe the desired state we want to check for. If you're already
    using a declarative approach to configuration management (such as the aforementioned
    Ansible or Salt), Goss may be more intuitive and thus a much better fit for testing.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goss在范围和形式上都有些不同。除了测试服务器，您还可以使用Goss通过dgoss包装器来测试项目中使用的容器。至于其形式，它不使用您在Serverspec或Testinfra中看到的命令式代码。与Ansible或Salt类似，它使用YAML文件来描述我们要检查的期望状态。如果您已经使用声明性的配置管理方法（如前面提到的Ansible或Salt），Goss可能更直观，因此更适合测试。
- en: Finally, Terratest is a tool that allows you to test the output of Infrastructure
    as Code tools such as Packer and Terraform (hence the name). Just like Serverspec
    and Testinfra use their language testing engines to write tests for servers, Terratest
    leverages Go's testing package to write the appropriate test cases.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Terratest是一种工具，允许您测试基础设施即代码工具（如Packer和Terraform）的输出（因此得名）。就像Serverspec和Testinfra使用它们的语言测试引擎为服务器编写测试一样，Terratest利用Go的测试包来编写适当的测试用例。
- en: Let's see how can we use each of these tools to validate that the deployment
    went on according to plan (at least from the infrastructure's point of view).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些工具来验证部署是否按计划进行（至少从基础设施的角度来看）。
- en: Testing with Serverspec
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Serverspec进行测试
- en: 'The following is an example of a test for Serverspec that checks the availability
    of Git in a specific version and the Let''s Encrypt configuration file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个检查特定版本中Git的可用性和Let's Encrypt配置文件的Serverspec测试的示例：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Ruby DSL syntax should be readable even by those who do not use Ruby daily.
    You may need to get used to writing the code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的DSL语法应该即使对于不经常使用Ruby的人来说也是可读的。您可能需要习惯编写代码。
- en: Testing with Testinfra
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Testinfra进行测试
- en: 'The following is an example of a test for Testinfra that checks the availability
    of Git in a specific version and the Let''s Encrypt configuration file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个检查特定版本中Git的可用性和Let's Encrypt配置文件的Testinfra测试的示例：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Testinfra uses plain Python syntax. It should be readable, but just like Serverspec,
    you may need some training to confidently write tests in it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Testinfra使用纯Python语法。它应该是可读的，但就像Serverspec一样，您可能需要一些训练来自信地编写测试。
- en: Testing with Goss
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Goss进行测试
- en: 'The following is an example of a YAML file for Goss that checks the availability
    of Git in a specific version and the Let''s Encrypt configuration file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个检查特定版本中Git的可用性和Let's Encrypt配置文件的Goss YAML文件的示例：
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: YAML's syntax will probably require the least preparation both to read it and
    write it. However, if your project already uses Ruby or Python, you may want to
    stick to Serverspec or Testinfra when it comes to writing more complicated tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: YAML的语法可能需要最少的准备来阅读和编写。但是，如果您的项目已经使用Ruby或Python，当涉及编写更复杂的测试时，您可能希望坚持使用Serverspec或Testinfra。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused both on the architectural and technical aspects of testing
    different parts of the software. We looked at the testing pyramid to understand
    how different kinds of tests contribute to the overall health and stability of
    a software project. Since testing can be both functional and non-functional, we
    saw some examples of both these types.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章既关注软件不同部分的架构和技术方面的测试。我们查看了测试金字塔，以了解不同类型的测试如何对软件项目的整体健康和稳定性做出贡献。由于测试既可以是功能性的，也可以是非功能性的，我们看到了这两种类型的一些示例。
- en: One of the most important things to remember from this chapter is that tests
    are not the end stage. We want to have them not because they bring immediate value,
    but because we can use them to check for known regressions, when refactoring,
    or when we're changing the behavior of existing parts of the system. Tests can
    also prove useful when we want to perform root cause analysis as they can quickly
    verify different hypotheses.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中最重要的事情之一是要记住测试不是最终阶段。我们希望进行测试不是因为它们带来了即时价值，而是因为我们可以使用它们来检查已知的回归、重构或更改系统现有部分的行为时。当我们想要进行根本原因分析时，测试也可以证明有用，因为它们可以快速验证不同的假设。
- en: Having established the theoretical requirements, we showed examples of the different
    testing frameworks and libraries we can use to write test doubles. Even though
    writing tests first and their implementation later requires some practice, it
    has an important benefit. This benefit is a better class design.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了理论要求之后，我们展示了可以用来编写测试替身的不同测试框架和库的示例。尽管先编写测试，后实现它们需要一些实践，但它有一个重要的好处。这个好处就是更好的类设计。
- en: Finally, to highlight that modern architecture is something more than just software
    code, we also looked at a few tools for testing infrastructure and deployment.
    In the next chapter, we will see how continuous integration and continuous deployment
    bring better service quality and robustness to the applications you will architect.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了突出现代架构不仅仅是软件代码，我们还看了一些用于测试基础设施和部署的工具。在下一章中，我们将看到持续集成和持续部署如何为您设计的应用程序带来更好的服务质量和稳健性。
- en: Questions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the base layer of the testing pyramid?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔的基础层是什么？
- en: What kinds of non-functional tests are there?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非功能性测试有哪些类型？
- en: What is the name of the famous method for root cause analysis?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 著名的根本原因分析方法的名称是什么？
- en: Is it possible to test the compile-time code in C++?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中是否可能测试编译时代码？
- en: What should you use when you're writing unit tests for code with external dependencies?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写具有外部依赖的代码的单元测试时应该使用什么？
- en: What is the role of unit tests in continuous integration/continuous deployment?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试在持续集成/持续部署中的作用是什么？
- en: What are some tools that allow you to test infrastructure code?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些工具可以让您测试基础架构代码？
- en: Is it a good idea to access the class's private attributes and methods in a
    unit test?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单元测试中访问类的私有属性和方法是一个好主意吗？
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Testing C++ Code: [https://www.packtpub.com/application-development/modern-c-programming-cookbook](https://www.packtpub.com/application-development/modern-c-programming-cookbook)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试C++代码：[https://www.packtpub.com/application-development/modern-c-programming-cookbook](https://www.packtpub.com/application-development/modern-c-programming-cookbook)
- en: 'Test Doubles: [https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身：[https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html)
- en: 'Continuous Integration/Continuous Deployment: [https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery)
    and [https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成/持续部署：[https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery)
    和 [https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery)
