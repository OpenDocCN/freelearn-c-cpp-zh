["```cpp\nint main()\n{\n   unsigned int limit = 0;\n   std::cout << \"Upper limit:\";\n   std::cin >> limit;\n\n   unsigned long long sum = 0;\n   for (unsigned int i = 3; i < limit; ++i)\n   {\n     if (i % 3 == 0 || i % 5 == 0)\n        sum += i;\n   }\n\n   std::cout << \"sum=\" << sum << std::endl;\n}\n```", "```cpp\ngcd(a,0) = a\ngcd(a,b) = gcd(b, a mod b)\n```", "```cpp\nunsigned int gcd(unsigned int const a, unsigned int const b)\n{\n   return b == 0 ? a : gcd(b, a % b);\n}\n```", "```cpp\nunsigned int gcd(unsigned int a, unsigned int b)\n{\n   while (b != 0) {\n      unsigned int r = a % b;\n      a = b;\n      b = r;\n   }\n   return a;\n}\n```", "```cpp\nlcm(a, b) = abs(a, b) / gcd(a, b)\n```", "```cpp\nint lcm(int const a, int const b)\n{\n   int h = gcd(a, b);\n   return h ? (a * (b / h)) : 0;\n}\n```", "```cpp\ntemplate<class InputIt>\nint lcmr(InputIt first, InputIt last)\n{\n   return std::accumulate(first, last, 1, lcm);\n}\n```", "```cpp\nbool is_prime(int const num) \n{\n   if (num <= 3) { return num > 1; }\n   else if (num % 2 == 0 || num % 3 == 0) \n   { \n      return false; \n   }\n   else \n   {\n      for (int i = 5; i * i <= num; i += 6) \n      {\n         if (num % i == 0 || num % (i + 2) == 0) \n         {\n            return false;\n         }\n      }\n      return true;\n   }\n}\n```", "```cpp\nint main()\n{\n   int limit = 0;\n   std::cout << \"Upper limit:\";\n   std::cin >> limit;\n\n   for (int i = limit; i > 1; i--)\n   {\n      if (is_prime(i))\n      {\n         std::cout << \"Largest prime:\" << i << std::endl;\n         return 0;\n      }\n   }\n}\n```", "```cpp\nint main()\n{\n   int limit = 0;\n   std::cout << \"Upper limit:\";\n   std::cin >> limit;\n\n   for (int n = 2; n <= limit; n++)\n   {\n      if (is_prime(n) && is_prime(n+6))\n      {\n         std::cout << n << \",\" << n+6 << std::endl;\n      }\n   }\n}\n```", "```cpp\nint sum_proper_divisors(int const number)\n{\n   int result = 1;\n   for (int i = 2; i <= std::sqrt(number); i++)\n   {\n      if (number%i == 0)\n      {\n         result += (i == (number / i)) ? i : (i + number / i);\n      }\n   }\n   return result;\n}\n```", "```cpp\nvoid print_abundant(int const limit)\n{\n   for (int number = 10; number <= limit; ++number)\n   {\n      auto sum = sum_proper_divisors(number);\n      if (sum > number)\n      {\n         std::cout << number << \", abundance=\" \n                   << sum - number << std::endl;\n      }\n   }\n}\n\nint main()\n{\n   int limit = 0;\n   std::cout << \"Upper limit:\";\n   std::cin >> limit;\n\n   print_abundant(limit);\n}\n```", "```cpp\nvoid print_amicables(int const limit)\n{\n   for (int number = 4; number < limit; ++number)\n   {\n      auto sum1 = sum_proper_divisors(number);\n      if (sum1 < limit)\n      {\n         auto sum2 = sum_proper_divisors(sum1);\n         if (sum2 == number && number != sum1)\n         {\n            std::cout << number << \",\" << sum1 << std::endl;\n         }\n      }\n   }\n}\n```", "```cpp\nvoid print_narcissistics()\n{\n   for (int a = 1; a <= 9; a++)\n   {\n      for (int b = 0; b <= 9; b++)\n      {\n         for (int c = 0; c <= 9; c++)\n         {\n            auto abc = a * 100 + b * 10 + c;\n            auto arm = a * a * a + b * b * b + c * c * c;\n            if (abc == arm)\n            {\n               std::cout << arm << std::endl;\n            }\n         }\n      }\n   }\n}\n```", "```cpp\nstd::vector<unsigned long long> prime_factors(unsigned long long n)\n{\n   std::vector<unsigned long long> factors;\n   while (n % 2 == 0) {\n      factors.push_back(2);\n      n = n / 2;\n   }\n   for (unsigned long long i = 3; i <= std::sqrt(n); i += 2)\n   {\n      while (n%i == 0) {\n         factors.push_back(i);\n         n = n / i;\n      }\n   }\n\n   if (n > 2) \n      factors.push_back(n);\n   return factors;\n}\n\nint main()\n{\n   unsigned long long number = 0;\n   std::cout << \"number:\";\n   std::cin >> number;\n\n   auto factors = prime_factors(number);\n   std::copy(std::begin(factors), std::end(factors),\n        std::ostream_iterator<unsigned long long>(std::cout, \" \"));\n}\n```", "```cpp\nif b[i-1] = 1 then g[i] = not b[i]\nelse g[i] = b[i]\n```", "```cpp\ng = b xor (b logically right shifted 1 time)\n```", "```cpp\nb[0] = g[0]\nb[i] = g[i] xor b[i-1]\n```", "```cpp\nunsigned int gray_encode(unsigned int const num)\n{\n   return num ^ (num >> 1);\n}\n\nunsigned int gray_decode(unsigned int gray)\n{\n   for (unsigned int bit = 1U << 31; bit > 1; bit >>= 1)\n   {\n      if (gray & bit) gray ^= bit >> 1;\n   }\n   return gray;\n}\n```", "```cpp\nstd::string to_binary(unsigned int value, int const digits)\n{\n   return std::bitset<32>(value).to_string().substr(32-digits, digits);\n}\n\nint main()\n{\n   std::cout << \"Number\\tBinary\\tGray\\tDecoded\\n\";\n   std::cout << \"------\\t------\\t----\\t-------\\n\";\n\n   for (unsigned int n = 0; n < 32; ++n)\n   {\n      auto encg = gray_encode(n);\n      auto decg = gray_decode(encg);\n\n      std::cout \n         << n << \"\\t\" << to_binary(n, 5) << \"\\t\" \n         << to_binary(encg, 5) << \"\\t\" << decg << \"\\n\";\n   }\n}\n```", "```cpp\nstd::string to_roman(unsigned int value)\n{\n   std::vector<std::pair<unsigned int, char const*>> roman {\n      { 1000, \"M\" },{ 900, \"CM\" }, { 500, \"D\" },{ 400, \"CD\" }, \n      { 100, \"C\" },{ 90, \"XC\" }, { 50, \"L\" },{ 40, \"XL\" },\n      { 10, \"X\" },{ 9, \"IX\" }, { 5, \"V\" },{ 4, \"IV\" }, { 1, \"I\" }};\n\n   std::string result;\n   for (auto const & kvp : roman) {\n      while (value >= kvp.first) {\n         result += kvp.second;\n         value -= kvp.first;\n      }\n   }\n   return result;\n}\n```", "```cpp\nint main()\n{\n   for(int i = 1; i <= 100; ++i) \n   {\n      std::cout << i << \"\\t\" << to_roman(i) << std::endl; \n   }\n\n   int number = 0;\n   std::cout << \"number:\";\n   std::cin >> number;\n   std::cout << to_roman(number) << std::endl;\n}\n```", "```cpp\nstd::pair<unsigned long long, long> longest_collatz(\n   unsigned long long const limit)\n{\n   long length = 0;\n   unsigned long long number = 0;\n   std::vector<int> cache(limit + 1, 0);\n\n   for (unsigned long long i = 2; i <= limit; i++) \n   {\n      auto n = i;\n      long steps = 0;\n      while (n != 1 && n >= i) \n      {\n         if ((n % 2) == 0) n = n / 2;\n         else n = n * 3 + 1;\n         steps++;\n      }\n      cache[i] = steps + cache[n];\n\n      if (cache[i] > length) \n      {\n         length = cache[i];\n         number = i;\n```", "```cpp\n      }\n   }\n\n   return std::make_pair(number, length);\n}\n```", "```cpp\ntemplate <typename E = std::mt19937, \n          typename D = std::uniform_real_distribution<>>\ndouble compute_pi(E& engine, D& dist, int const samples = 1000000)\n{\n   auto hit = 0;\n   for (auto i = 0; i < samples; i++)\n   {\n      auto x = dist(engine);\n      auto y = dist(engine);\n      if (y <= std::sqrt(1 - std::pow(x, 2))) hit += 1;\n   }\n   return 4.0 * hit / samples;\n}\n\nint main()\n{\n   std::random_device rd;\n   auto seed_data = std::array<int, std::mt19937::state_size> {};\n   std::generate(std::begin(seed_data), std::end(seed_data), \n                 std::ref(rd));\n   std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n   auto eng = std::mt19937{ seq };\n   auto dist = std::uniform_real_distribution<>{ 0, 1 };\n\n   for (auto j = 0; j < 10; j++)\n      std::cout << compute_pi(eng, dist) << std::endl;\n}\n```", "```cpp\nbool validate_isbn_10(std::string_view isbn)\n{\n   auto valid = false;\n   if (isbn.size() == 10 &&\n       std::count_if(std::begin(isbn), std::end(isbn), isdigit) == 10)\n   {\n      auto w = 10;\n      auto sum = std::accumulate(\n         std::begin(isbn), std::end(isbn), 0,\n         [&w](int const total, char const c) {\n            return total + w-- * (c - '0'); });\n\n     valid = !(sum % 11);\n   }\n   return valid;\n}\n```"]