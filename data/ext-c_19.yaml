- en: Chapter 19
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章
- en: Single-Host IPC and Sockets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单主机IPC和套接字
- en: In the previous chapter, we discussed the techniques by which two processes
    could operate on the same shared resource concurrently and in a synchronized fashion.
    In this chapter, we are going to expand these techniques and introduce a new category
    of methods that allow two processes to transmit data. These techniques, both those
    introduced in the previous chapter and the ones we are going to discuss in this
    chapter, are together referred to as **Inter-Process Communication** (**IPC**)
    techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了两个进程如何能够同时以同步方式操作同一共享资源的技术。在本章中，我们将扩展这些技术，并介绍一种新的方法类别，允许两个进程传输数据。这些技术，包括上一章中介绍的技术和本章将要讨论的技术，统称为**进程间通信（IPC**）技术。
- en: In this and the following chapter, we are going to talk about the IPC techniques
    that, despite the methods we discussed in the previous chapter, involve a kind
    of *message passing* or *signaling* between two processes. The transmitting messages
    are not stored in any shared place like a file or a shared memory, rather they
    are emitted and received by the processes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的章节中，我们将讨论IPC技术，尽管我们在上一章讨论了方法，但这些方法涉及两个进程之间的一种*消息传递*或*信号*。传输的消息不会存储在任何共享位置，如文件或共享内存，而是由进程发出和接收。
- en: In this chapter we cover two major topics. Firstly, we underpin the IPC techniques
    and we discuss single-host IPC and the POSIX API. Secondly, we begin to introduce
    socket programming and the surrounding topics. These topics include computer networks,
    the listener-connector model, and the sequences that exist for two processes to
    establish a connection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖两个主要主题。首先，我们巩固IPC技术，并讨论单主机IPC和POSIX API。其次，我们开始介绍套接字编程及其相关主题。这些主题包括计算机网络、监听器-连接器模型以及两个进程建立连接时存在的序列。
- en: 'As part of this chapter, we are going to discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将讨论以下主题：
- en: Various IPC techniques. We introduce push-based and pull-based IPC techniques
    and as part of this section, we define the techniques discussed in the previous
    chapter to be pull-based IPC techniques.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种IPC技术。我们介绍了基于推送和基于拉取的IPC技术，并将上一章中讨论的技术定义为基于拉取的IPC技术。
- en: Communication protocols and the characteristics that a protocol usually has.
    We introduce what serialization and deserialization mean and how they contribute
    to a fully operational IPC.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议以及协议通常具有的特性。我们介绍序列化和反序列化的含义以及它们如何有助于实现完全操作的进程间通信（IPC）。
- en: File descriptors and how they play a key role in establishing an IPC channel.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符及其在建立IPC通道中的关键作用。
- en: The exposed API for POSIX signals, POSIX pipes, and POSIX message queues are
    discussed as part of this chapter. For each technique, an example is provided
    to demonstrate the basic usage.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了POSIX信号、POSIX管道和POSIX消息队列的公开API。对于每种技术，都提供了一个示例来演示基本用法。
- en: Computer networks and how two processes can communicate over an existing network.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机网络以及两个进程如何通过现有网络进行通信。
- en: The listener-connector model and how two processes can establish a transport
    connection over a number of networks. This is the basis for our future discussions
    regarding socket programming.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听器-连接器模型以及两个进程如何在多个网络上建立传输连接。这是我们未来关于套接字编程讨论的基础。
- en: What socket programming is and what socket objects are.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字编程是什么以及套接字对象是什么。
- en: The sequences that exist for each of the processes participating in a listener-connector
    connection, and the API that they have to use from the POSIX socket library.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与监听器-连接器连接的每个进程存在的序列，以及它们必须从POSIX套接字库中使用的API。
- en: In the first section, we are going to revisit IPC techniques.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将回顾IPC技术。
- en: IPC techniques
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPC技术
- en: 'An IPC technique generally refers to any means that is used by processes to
    communicate and transmit data. In the previous chapter, we discussed filesystems
    and shared memory as our beginning approach to share data between two processes.
    We didn''t use the term ''IPC'' for these techniques at that point, but this is
    in fact what they are! In this chapter, we will add a few more IPC techniques
    to the ones that we have encountered already, but we should remember that they
    are different in a number of ways. Before jumping to the differences and trying
    to categorize them, let''s list some IPC techniques:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IPC技术通常指的是进程用来通信和传输数据的方法。在上一章中，我们讨论了文件系统和共享内存作为我们在两个进程之间共享数据的起点。在那个阶段，我们没有使用“IPC”这个术语，但实际上这正是它们所代表的！在本章中，我们将添加一些我们已遇到的IPC技术，但我们应该记住，它们在许多方面是不同的。在尝试比较差异并尝试对它们进行分类之前，让我们列出一些IPC技术：
- en: Shared memory
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存
- en: Filesystem (both on disk and in memory)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统（包括磁盘和内存中的）
- en: POSIX signals
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX信号
- en: POSIX pipes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX管道
- en: POSIX message queues
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX消息队列
- en: Unix domain sockets
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix域套接字
- en: Internet (or network) sockets
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网（或网络）套接字
- en: From the programming point of view, the shared memory and filesystem techniques
    are similar in certain ways and because of that they can be put into the same
    group, known as *pull-based* IPC techniques. The rest of the techniques stand
    out and they have their own category. We refer to them as *push-based* IPC techniques.
    This chapter together with the next chapter are dedicated to push-based IPC, and
    various techniques are discussed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度来看，共享内存和文件系统技术在某些方面是相似的，因此它们可以被归入同一个组，称为*基于拉取*的IPC技术。其余的技术突出，并且它们有自己的类别。我们将它们称为*基于推送*的IPC技术。本章以及下一章将致力于基于推送的IPC，并讨论各种技术。
- en: Note that the IPC techniques all are responsible for transmitting a number of
    messages between two processes. Since we are going to use the term *message* heavily
    in the upcoming paragraphs, it is worth defining it first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有的IPC技术都负责在两个进程之间传输多条消息。由于我们将在接下来的段落中大量使用术语*消息*，因此首先定义它是有意义的。
- en: Every message contains a series of bytes that are put together according to
    a well-defined interface, protocol, or standard. The structure of a message should
    be known by both processes dealing with that message, and it is usually covered
    as part of a communication protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都包含一系列字节，这些字节根据一个定义良好的接口、协议或标准组合在一起。消息的结构应该为处理该消息的两个进程所知晓，并且它通常作为通信协议的一部分来处理。
- en: 'A list of differences between pull-based and push-based techniques can be seen
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以看到基于拉取和基于推送技术之间差异的列表：
- en: In pull-based techniques, we have a shared resource or *medium* external to
    both processes and available in the user space. Files, shared memories, and even
    a network service like an **Network Filesystem** (**NFS**) server can be the shared
    resource. These mediums are the main place holders for the messages created and
    consumed by the processes. While in push-based techniques, there is no such a
    shared resource or medium and instead, there is a *channel*. Processes send and
    receive messages through this channel, and these messages are not stored in any
    intermediate medium.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于拉取的技术中，我们有一个共享资源或*介质*，它位于两个进程外部，并在用户空间中可用。文件、共享内存，甚至像**网络文件系统**（**NFS**）服务器这样的网络服务都可以是共享资源。这些介质是进程创建和消费消息的主要占位符。而在基于推送的技术中，没有这样的共享资源或介质，而是有一个*通道*。进程通过这个通道发送和接收消息，而这些消息不会存储在任何中间介质中。
- en: In pull-based techniques, each process must *pull* the available messages from
    the medium. In push-based techniques, the incoming messages are *pushed* (*delivered*)
    to the receiver end.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于拉取的技术中，每个进程必须从介质中*拉取*可用的消息。在基于推送的技术中，传入的消息被*推送*（*交付*）到接收端。
- en: In pull-based techniques, because of having a shared resource or medium, concurrent
    access to the medium must be synchronized. That's why we explored the various
    synchronization techniques for such IPC techniques in the previous chapter. Note
    that this is not the case regarding push-based techniques and there is no synchronization
    needed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于拉取的技术中，由于存在共享资源或介质，对介质的并发访问必须同步。这就是为什么我们在上一章中探讨了各种同步技术，用于此类IPC技术。请注意，这与基于推送的技术不同，并且不需要同步。
- en: In pull-based techniques, the processes can operate independently. That's because
    the messages can be stored in a shared resource and it can be fetched later. In
    other words, the processes can operate in an *async* fashion. Conversely, in a
    push-based IPC technique, both processes should be up and running at the same
    time, and because the messages are pushed instantly, the receiver process may
    lose some of the incoming messages if it's down. In other words, the processes
    operate in a *sync* fashion.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于拉的技术中，进程可以独立操作。这是因为消息可以存储在共享资源中，稍后可以检索。换句话说，进程可以以*异步*方式操作。相反，在基于推的IPC技术中，两个进程应该同时运行，并且由于消息是即时推送的，如果接收进程处于关闭状态，它可能会丢失一些传入的消息。换句话说，进程以*同步*方式操作。
- en: '**Note**:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In push-based techniques, we have a temporary message buffer for each process
    that holds the incoming pushed messages. This message buffer resides in the kernel
    and lives as long as the process is running. This message buffer might be accessed
    concurrently, but the synchronization must be guaranteed by the kernel itself.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在基于推的技术中，我们为每个进程都有一个临时消息缓冲区，用于存储传入的推送消息。这个消息缓冲区位于内核中，只要进程在运行，它就会存在。这个消息缓冲区可能被并发访问，但同步必须由内核本身来保证。
- en: Messages being either transmitted in an IPC channel when using a push-based
    technique, or stored in an IPC medium when using a pull-based technique, should
    have a content that is understandable by the receiving process. This means that
    both processes – the sender end and the receiver end – must know how to create
    and parse the messages. Since messages are made up of bytes, this implies that
    both processes must know how to translate an object (a text or video) into a series
    of bytes, and how to resurrect the same object from the received bytes. We'll
    see shortly that the inter-operability of the processes is covered by a common
    *communication protocol* adapted by both of them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于推的技术时，消息要么在IPC通道中传输，要么在基于拉的技术中使用IPC介质存储，其内容应该是接收进程可理解的。这意味着两个进程——发送端和接收端——都必须知道如何创建和解析消息。由于消息由字节组成，这意味着两个进程都必须知道如何将对象（文本或视频）转换为一系列字节，以及如何从接收到的字节中恢复相同的对象。我们将很快看到，进程之间的互操作性是由它们共同采用的*通信协议*所覆盖的。
- en: In the following section, we'll discuss communication protocols in greater depth.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地讨论通信协议。
- en: Communication protocols
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议
- en: Having just a communication channel or medium is not enough. Two parties willing
    to communicate over a shared channel need to understand one another, too! A very
    simple example is when two people want to talk to each other using the same language,
    such as English or Japanese. Here, the language can be considered as the protocol
    used by two parties in order to communicate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有一个通信通道或介质是不够的。愿意通过共享通道进行通信的两个当事人还需要相互理解！一个非常简单的例子是当两个人想用同一种语言（如英语或日语）相互交谈时。在这里，语言可以被认为是两个当事人用来进行通信的协议。
- en: In the context of IPC, processes are no exception; they need a common language
    so they can communicate. Technically, we use the term *protocol* to refer to this
    common language between any two parties. As part of this section, we are going
    to discuss communication protocols and their various characteristics such as the
    *message length* and the *message content*. Before being able to talk about these
    characteristics, we need to describe a communication protocol in a deeper sense.
    Note that our main focus in this chapter is IPC techniques; therefore, we only
    talk about communication protocols between two processes. Any kind of communication
    happening between parties other than processes cannot be covered as part of this
    chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程间通信（IPC）的背景下，进程也不例外；它们需要一个共同的语言以便进行通信。技术上，我们使用术语*协议*来指代任何两个当事人之间的这种共同语言。作为本节的一部分，我们将讨论通信协议及其各种特性，如*消息长度*和*消息内容*。在能够讨论这些特性之前，我们需要更深入地描述一个通信协议。请注意，本章的主要重点是IPC技术；因此，我们只讨论两个进程之间的通信协议。本章不涵盖除进程之外的其他当事人之间的任何类型的通信。
- en: Processes can only transmit bytes. This effectively means that every piece of
    information must be translated into a series of bytes before being transmitted
    by one of the IPC techniques. This is called *serialization* or *marshalling*.
    A paragraph of text, a piece of audio, a music track, or any other kind of object
    must be serialized before being sent over an IPC channel, or being stored in an
    IPC medium. Hence, regarding the IPC communication protocols, this means that
    the messages transmitted between processes are a series of bytes in a very specific
    and well-defined order.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 进程只能传输字节。这实际上意味着在通过任何IPC技术传输之前，每条信息都必须被转换为一组字节。这被称为*序列化*或*打包*。一段文本、一段音频、一首音乐或任何其他类型的对象在通过IPC通道发送或存储在IPC介质之前都必须进行序列化。因此，关于IPC通信协议，这意味着进程之间传输的消息是一系列字节，它们按照非常具体和明确的顺序排列。
- en: Conversely, when a process receives a series of bytes from an IPC channel, it should
    be able to reconstruct the original object out of the incoming bytes. This is
    called *deserialization* or *unmarshaling*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当进程从一个IPC通道接收一系列字节时，它应该能够从传入的字节中重建原始对象。这被称为*反序列化*或*反序列化*。
- en: To explain serialization and deserialization in the same flow, when a process
    wants to send an object to another process over any already established IPC channel,
    the sender process first serializes the object into a byte array. Then it transmits
    the byte array to the other party. On the receiver side, the process deserializes
    the incoming bytes and it resurrects the sent object. As you can see, these operations
    are the inverse of each other, and they are used by both ends in order to use
    a byte-oriented IPC channel to transmit information. This is something you can't
    escape from, and every IPC-based technology (RPC, RMI, and so on) relies heavily
    on the serialization and deserialization of various objects. From now on, we use
    the term serialization to refer to both serialization and deserialization operations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在同一个流程中解释序列化和反序列化，当进程想要通过任何已经建立的IPC通道向另一个进程发送对象时，发送进程首先将对象序列化为字节数组。然后它将字节数组传输给另一方。在接收端，进程将传入的字节反序列化，并恢复发送的对象。正如你所看到的，这些操作是彼此的逆操作，并且它们被双方使用，以便使用面向字节的IPC通道传输信息。这是你无法避免的，并且每种基于IPC的技术（RPC、RMI等）都严重依赖于各种对象的序列化和反序列化。从现在开始，我们使用术语序列化来指代序列化和反序列化操作。
- en: Note that serialization is not limited to push-based IPC techniques that we
    have discussed so far. In pull-based IPC techniques such as filesystem or shared
    memory, we still need serialization. That's because the underlying mediums in these
    techniques can store a series of bytes and if a process wants to store an object
    in a shared file, for instance, it has to serialize it before being able to store
    it there. Therefore, serialization is universal to all IPC techniques; no matter
    which IPC method you are using, you have to deal with a great amount of serialization
    and deserialization while using the underlying channel or medium.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，序列化并不仅限于我们之前讨论的基于推的IPC技术。在基于拉的IPC技术（如文件系统或共享内存）中，我们仍然需要序列化。这是因为这些技术中的底层介质可以存储一系列字节，如果进程想要将对象存储在共享文件中，例如，它必须在存储之前将其序列化。因此，序列化对所有IPC技术都是通用的；无论你使用哪种IPC方法，在使用底层通道或介质时，你都必须处理大量的序列化和反序列化操作。
- en: Choosing a communication protocol implicitly dictates the serialization because,
    as part of a protocol, we define the order of bytes very carefully. This is crucial
    because a serialized object must be deserialized back to the same object on the
    receiver side. Therefore, both the serializer and deserializer must obey the same
    rules dictated by the protocol. Having an incompatible serializer and deserializer
    at both ends effectively means no communication at all, simply because the receiver
    end cannot reconstruct the transmitted object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个通信协议隐式地决定了序列化，因为作为协议的一部分，我们非常仔细地定义了字节顺序。这一点至关重要，因为序列化的对象必须在接收端反序列化回相同的对象。因此，序列化和反序列化都必须遵守协议规定的相同规则。两端都使用不兼容的序列化和反序列化工具实际上意味着根本无法通信，仅仅因为接收端无法重建传输的对象。
- en: '**Note**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Sometimes, we use the term *parsing* as a synonym for *deserialization*, but
    they are in fact fundamentally different.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们将术语*parsing*用作*反序列化*的同义词，但它们实际上在本质上是有区别的。
- en: To make the discussion more tangible, let's talk about some real examples. A
    web server and a web client communicate using **Hyper Text Transfer Protocol**
    (**HTTP**). Therefore, both sides are required to use compatible HTTP serializers
    and deserializers to speak to each other. As another example, let's talk about
    the **Domain Name Service** (**DNS**) protocol. Both the DNS client and server
    must use compatible serializers and deserializers so that they can communicate.
    Note that unlike HTTP, which has textual content, DNS is a binary protocol. We
    discuss this shortly in the upcoming sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使讨论更加具体，让我们来谈谈一些真实例子。一个网络服务器和一个网络客户端使用**超文本传输协议**（**HTTP**）进行通信。因此，双方都需要使用兼容的HTTP序列化和反序列化器来相互交流。作为另一个例子，让我们来谈谈**域名系统**（**DNS**）协议。DNS客户端和服务器必须使用兼容的序列化和反序列化器，以便它们能够通信。请注意，与具有文本内容的HTTP不同，DNS是一个二进制协议。我们将在接下来的部分中简要讨论这一点。
- en: Since serialization operations can be used in various components in a software
    project, they are usually provided as some libraries that can be added to any
    component wishing to use them. For famous protocol such as HTTP, DNS, and FTP,
    there are well-known third-party libraries that can be used without hassle. But
    for custom protocols specially designed for a project, the serialization libraries
    must be written by the team itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于序列化操作可以在软件项目的各种组件中使用，因此它们通常作为一些库提供，这些库可以添加到任何希望使用它们的组件中。对于像HTTP、DNS和FTP这样的著名协议，有众所周知的第三方库可以无障碍地使用。但对于专门为项目设计的自定义协议，序列化库必须由团队自己编写。
- en: '**Note:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: Well-known protocols such as HTTP, FTP, and DNS are standards and they are described
    in some official open documents called **request for comments** (**RFC**). For
    example, the HTTP/1.1 protocol is described in RFC-2616\. A simple Google search
    will take you to the RFC page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如HTTP、FTP和DNS这样的知名协议是标准，它们在称为**请求评论**（**RFC**）的官方公开文档中进行了描述。例如，HTTP/1.1协议在RFC-2616中进行了描述。通过简单的谷歌搜索就可以找到RFC页面。
- en: As a further note regarding *serialization libraries*, they can be provided
    in various programming languages. Note that a specific serialization itself is
    not dependent on any programming language because it only talks about the order
    of bytes and how they should be interpreted. Therefore, the serialization and
    deserialization algorithms can be developed using any programming language. That's
    a crucial requirement. In a big software project, we can have multiple components
    written in various programming languages, and there are situations in which these
    components must transmit information. Hence, we need the same serialization algorithms
    written in various languages. For instance, we have HTTP serializers written in
    C, C++, Java, Python, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '作为关于*序列化库*的进一步说明，它们可以以各种编程语言提供。请注意，特定的序列化本身并不依赖于任何编程语言，因为它只涉及字节的顺序以及它们应该如何被解释。因此，序列化和反序列化算法可以使用任何编程语言来开发。这是一个关键要求。在一个大型软件项目中，我们可以有多个用各种编程语言编写的组件，并且在这些组件之间必须传输信息的情况。因此，我们需要用各种语言编写的相同的序列化算法。例如，我们有用C、C++、Java、Python等语言编写的HTTP序列化器。 '
- en: To sum up the main point of this section, we need a well-defined protocol between
    two parties in order for them to talk to each other. An IPC protocol is a standard
    that dictates how the overall communication must take place and what details must
    be obeyed regarding the byte order and their meaning in various messages. We have
    to use some serialization algorithms in order to consume a byte-oriented IPC channel
    to transmit objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节的主要观点，我们需要在双方之间建立一个定义良好的协议，以便它们能够相互交流。IPC协议是一种标准，它规定了整体通信必须如何进行，以及关于字节顺序和它们在各个消息中的含义必须遵守哪些细节。我们必须使用一些序列化算法来消费面向字节的IPC通道以传输对象。
- en: In the following section, we describe the characteristics of IPC protocols.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述IPC协议的特点。
- en: Protocol characteristics
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议特点
- en: IPC protocols have various characteristics. Briefly, every protocol can specify
    a different content type for the messages transmitted over an IPC channel. In
    another protocol, the messages can have a fixed length or a variable length. Some
    protocols dictate that the provided operations must be consumed in a synchronous
    fashion, while there are protocols that allow asynchronous usage. In the following
    sections, we will be covering these distinguishing factors. Note that the existing
    protocols can be categorized based on these characteristics.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: IPC 协议具有各种特性。简而言之，每个协议都可以为通过 IPC 通道传输的消息指定不同的内容类型。在另一个协议中，消息可以具有固定长度或可变长度。一些协议规定提供的操作必须以同步方式消费，而有些协议允许异步使用。在接下来的章节中，我们将介绍这些区分因素。请注意，现有的协议可以根据这些特性进行分类。
- en: Content type
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容类型
- en: Messages sent over IPC channels can have *textual* content or *binary* content
    or a combination of both of them. Binary content has bytes with values ranging
    over all possible numerical values between 0 to 255\. But textual content has
    only characters that are used in text. In other words, only alphanumerical characters
    together with some symbols are allowed in textual content.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 IPC 通道发送的消息可以是*文本*内容或*二进制*内容，或者两者的组合。二进制内容具有值在 0 到 255 之间所有可能数值的字节。但文本内容只有用于文本的字符。换句话说，只有字母数字字符和一些符号允许在文本内容中使用。
- en: While textual content can be considered as a special case of binary content,
    we try to keep them separate and treat them differently. For instance, textual
    messages are good candidates to be compressed before sending, while binary messages
    suffer from a poor *compression ratio* (the actual size divided by the compressed
    size). It is good to know that some protocols are purely textual, such as JSON,
    and some others are fully binary, such as DNS. There are also protocols such as
    BSON and HTTP that allow message contents to be a combination of both textual
    and binary data. In these protocols, raw bytes can be mixed with text to form
    the final message.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文本内容可以被视为二进制内容的特例，但我们尽量将它们分开，并分别对待。例如，文本消息在发送前进行压缩是很好的候选，而二进制消息则受制于较差的*压缩比*（实际大小除以压缩大小）。了解一些协议完全是文本的，如
    JSON，而另一些则是完全二进制的，如 DNS，是有益的。还有一些协议，如 BSON 和 HTTP，允许消息内容是文本和二进制数据的组合。在这些协议中，原始字节可以与文本混合，形成最终的消息。
- en: Note that binary content can be sent as text. There are various encodings that
    allow you to represent binary content using textual characters. *Base64* is one
    of the most famous *binary-to-text encoding* algorithms that allows such a transformation.
    These encoding algorithms are widely used in purely textual protocols such as
    JSON to send binary data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，二进制内容可以作为文本发送。有多种编码方式允许您使用文本字符来表示二进制内容。*Base64* 是最著名的*二进制到文本编码*算法之一，它允许这种转换。这些编码算法在纯文本协议（如
    JSON）中广泛用于发送二进制数据。
- en: Length of messages
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息长度
- en: The messages produced according to an IPC protocol can be either *fixed-length*
    or *variable-length*. By fixed-length, we mean that all messages have the same
    length. Conversely, by variable-length, we mean that the produced messages can
    have different lengths. Receiving either fixed-length messages or variable-length
    messages have an immediate impact on the receiver side while deserializing the
    content of a message. Using a protocol that always produces fixed-length messages
    can reduce the burden of parsing receiving messages because the receiver already
    knows the number of bytes that it should read from the channel, and messages with
    the same size usually (not always) have the same structure. When reading fixed-length
    messages from an IPC channel, if all of them follow the same structure, we have
    a nice opportunity to use C structures to refer to those bytes through some already-defined
    fields, similar to what we did for objects placed in shared memories in the previous
    chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 IPC 协议产生的消息可以是*固定长度*或*可变长度*。固定长度意味着所有消息都具有相同的长度。相反，可变长度意味着产生的消息可以有不同的长度。接收固定长度或可变长度的消息在反序列化消息内容时对接收方有直接影响。使用总是产生固定长度消息的协议可以减少解析接收消息的负担，因为接收方已经知道它应该从通道中读取的字节数，并且通常（但不总是）具有相同大小的消息具有相同的结构。当从
    IPC 通道读取固定长度消息时，如果所有消息都遵循相同的结构，我们就有机会使用 C 结构通过一些已定义的字段来引用这些字节，类似于我们在上一章中为放置在共享内存中的对象所做的那样。
- en: With protocols that produce variable-length messages, finding where an individual
    message ends is not that easy, and the receiver side somehow (which we explain
    shortly) should decide whether it has read a complete message or more bytes must
    be read from the channel. Note that the receiver might read multiple chunks from
    the channel before reading a complete message, and a single chunk may contain
    data from two adjacent messages. We will see an example of this in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于产生可变长度消息的协议，找到单个消息的结束并不容易，接收方（我们将在稍后解释）应决定它是否已经读取了一个完整的消息或还需要从通道中读取更多字节。请注意，接收方在读取一个完整的消息之前可能会从通道中读取多个数据块，并且一个数据块可能包含两个相邻消息的数据。我们将在下一章中看到一个例子。
- en: 'Since most protocols are variable-length and you usually don''t have the luxury
    of dealing with fixed-length messages, it is worth discussing the methods that
    various protocols adopt to make their variable-length messages distinguishable
    or separable. In other words, these protocols use a mechanism to mark the end
    of a message and, this way, the receiver can use those marks to indicate that
    it has read a complete message. Next, you can see some of these methods:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数协议都是可变长度的，而且通常没有处理固定长度消息的便利，因此讨论各种协议采用的方法来使它们的可变长度消息可区分或可分离是值得的。换句话说，这些协议使用一种机制来标记消息的结束，这样接收者就可以使用这些标记来指示它已经读取了一个完整的消息。接下来，你可以看到一些这些方法：
- en: '**Using a delimiter or a separator**: A delimiter or separator is a series
    of bytes (in binary messages) or characters (in textual messages) that indicates
    the end of a message. The delimiter should be chosen depending on the content
    of the messages, because it should be easily distinguishable from the actual content.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用分隔符或分隔符**：分隔符或分隔符是一系列字节（在二进制消息中）或字符（在文本消息中），它指示消息的结束。应根据消息的内容选择分隔符，因为它应该很容易与实际内容区分开来。'
- en: '**Length-prefix framing**: In these protocols, each message has a fixed-length
    prefix (usually 4 bytes or even more) that carries the number of bytes that should
    be read by the receiver in order to have a complete message. Various protocols
    such as all **Tag-Value-Length** (**TLV**) protocols, with **Abstract Syntax Notation**
    (**ASN**) as an example, use this technique.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度前缀帧定界**：在这些协议中，每个消息都有一个固定长度的前缀（通常是4个字节或更多），它携带接收者应该读取的字节数，以便获得一个完整的消息。各种协议，如所有**标签-值-长度**（**TLV**）协议，以**抽象语法表示**（**ASN**）为例，都使用这种技术。'
- en: '**Using a finite-state machine**: These protocols follow a *regular grammar*
    that can be modeled by a *finite-state machine*. The receiver side should be aware
    of the grammar of the protocol, and it should use a proper deserializer that works
    based on a finite-state machine to read a complete message from the IPC channel.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用有限状态机**：这些协议遵循一种*正规文法*，可以用*有限状态机*来建模。接收方应了解协议的文法，并应使用基于有限状态机的适当反序列化器来从IPC通道中读取一个完整的消息。'
- en: Sequentiality
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序性
- en: In most protocols, we have a *conversation* happening between two processes
    that follows a *request-response* scheme. One of the parties sends a request and
    the other side replies. This scheme is usually used in client-server scenarios.
    The listener process, often the server process, waits for a message, and when
    the message is received, it replies accordingly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数协议中，两个进程之间发生的是一种遵循*请求-响应*方案的*对话*。一方发送请求，另一方回复。这种方案通常用于客户端-服务器场景。监听器进程，通常是服务器进程，等待消息，并在收到消息后相应地回复。
- en: If the protocol is synchronous or sequential, the sender (client) will wait
    until the listener (server) completes the request and sends back the reply. In
    other words, the sender stays in a *blocking* state until the listener replies.
    In an asynchronous protocol, the sender process isn't blocked, and it can continue
    with another task while the request is being processed by the listener. That is,
    the sender won't get blocked while the reply is being prepared.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果协议是同步或顺序的，发送者（客户端）将等待监听器（服务器）完成请求并发送回响应。换句话说，发送者将保持在*阻塞*状态，直到监听器回复。在异步协议中，发送者进程不会被阻塞，它可以在监听器处理请求的同时继续执行其他任务。也就是说，发送者在准备回复时不会被阻塞。
- en: In an asynchronous protocol, there should be a *pulling* or *pushing* mechanism
    in place, which allows the sender to check for the reply. In a pulling scenario,
    the sender will regularly ask the listener about the result. In a pushing scenario,
    the listener will push back the reply to the sender via the same or a different
    communication channel.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步协议中，应该有一个*拉取*或*推送*机制，这允许发送者检查回复。在拉取场景中，发送者将定期询问监听者的结果。在推送场景中，监听者将通过相同的或不同的通信通道将回复推送给发送者。
- en: The sequentiality of a protocol is not limited to request-response scenarios.
    Messaging applications usually use this technique to have the maximum responsiveness
    both on the server-side and on the client-side.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的顺序性不仅限于请求-响应场景。消息应用通常使用这种技术以在服务器端和客户端都实现最大的响应性。
- en: Single-host communication
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单主机通信
- en: 'In this section, we are going to talk about single-host IPC. Multiple-host
    IPC will be the subject of our discussion in the next chapter. There are four
    main techniques that can be used by processes to communicate when they reside
    on the same machine:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论单主机进程间通信（IPC）。多主机IPC将是下一章讨论的主题。当进程位于同一台机器上时，可以使用以下四种主要技术进行通信：
- en: POSIX signals
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX信号
- en: POSIX pipes
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX管道
- en: POSIX message queues
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX消息队列
- en: Unix domain sockets
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix域套接字
- en: POSIX signals, unlike the other preceding techniques, don't create a communication
    channel between the processes, but can be used as a way to notify a process about
    an event. In certain scenarios, such signals can be used by processes to notify
    each other about specific events in the system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他前述技术不同，POSIX信号不会在进程之间创建通信通道，但可以用作通知进程有关事件的方式。在某些情况下，这些信号可以被进程用来通知彼此关于系统中特定事件的详细信息。
- en: Before jumping to the first IPC technique, POSIX signals, let's discuss file
    descriptors. Other than POSIX signals, no matter which IPC technique you use,
    you will be dealing with file descriptors of some sort. Therefore, we'll now dedicate
    a separate section to them and discuss them further.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到第一种IPC技术POSIX信号之前，让我们先讨论文件描述符。除了POSIX信号之外，无论你使用哪种IPC技术，你都将处理某种类型的文件描述符。因此，我们现在将专门为它们设立一个单独的部分，并进一步讨论它们。
- en: File descriptors
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件描述符
- en: Two communicating processes can be running either on the same machine or on
    two different machines connected by a computer network. In this section and much
    of this chapter, our focus is on the first case, in which processes reside on
    the same machine. That's where file descriptors become immensely important. Note
    that in multiple-host IPC we will still be dealing with file descriptors, but
    they are called *sockets* there. We will discuss them thoroughly in the upcoming chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两个通信进程可以运行在同一台机器上，也可以运行在通过计算机网络连接的两个不同的机器上。在本节以及本章的大部分内容中，我们的重点是第一种情况，即进程位于同一台机器上。这就是文件描述符变得极其重要的地方。请注意，在多主机IPC中，我们仍然会处理文件描述符，但它们在那里被称为*套接字*。我们将在下一章中详细讨论它们。
- en: A file descriptor is an abstract handle to an object within the system that
    can be used to read and write data. As you can see, despite the name, file descriptors
    can refer to a wide range of available mechanisms that deal with reading and modifying
    byte streams.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是对系统内对象的抽象句柄，可以用来读写数据。正如你所见，尽管名称如此，文件描述符可以引用一系列处理读写字节流的机制。
- en: Regular files are certainly among the objects that can be referred to by file
    descriptors. Such files are located on filesystems, either on a hard disk or in
    memory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正规文件当然是可以由文件描述符引用的对象之一。这些文件位于文件系统上，无论是在硬盘上还是在内存中。
- en: Other things that can be referred to and accessed via file descriptors are devices.
    As we saw in *Chapter 10*, *Unix - History and Architecture*, each device can
    be accessed using a device file, which is usually found in the `/dev` directory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过文件描述符引用和访问的其他事物包括设备。正如我们在第10章“Unix - 历史 和 架构”中看到的，每个设备都可以通过设备文件来访问，该文件通常位于`/dev`目录中。
- en: Regarding push-based IPC techniques, a file descriptor can represent an IPC
    channel. In this case, the file descriptor can be used to read and write data
    from and to the represented channel. That's why the first step in setting up an
    IPC channel is to define a number of file descriptors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基于推送的IPC技术，文件描述符可以表示一个IPC通道。在这种情况下，文件描述符可以用来从表示的通道中读取和写入数据。这就是为什么设置IPC通道的第一步是定义一定数量的文件描述符。
- en: Now that you know more about file descriptors and what they represent, we can
    move on and discuss the first IPC technique that can be used in single-host multi-process
    system; however, POSIX signals don't use file descriptors. You are going to hear
    more about file descriptors in the future sections dedicated to POSIX pipes and
    POSIX message queues. Let's begin with POSIX signals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了文件描述符及其代表的含义，我们可以继续讨论在单主机多进程系统中可以使用的第一个 IPC 技术；然而，POSIX 信号不使用文件描述符。你将在未来关于
    POSIX 管道和 POSIX 消息队列的章节中了解更多关于文件描述符的内容。让我们从 POSIX 信号开始。
- en: POSIX signals
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX 信号
- en: In POSIX systems, processes and threads can send and receive a number of predefined
    signals. A signal can be sent either by a process, or a thread, or by the kernel
    itself. Signals are actually meant to notify a process or a thread about an event
    or error. For example, when the system is going to be rebooted, the system sends
    a `SIGTERM` signal to all processes to let them know that a rebooting is in progress
    and they must immediately quit. Once a process receives this signal, it should
    react accordingly. In some cases, nothing should be done, but in some cases, the
    current state of the process should be persisted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX 系统中，进程和线程可以发送和接收许多预定义的信号。信号可以由进程、线程或内核本身发送。信号实际上是为了通知进程或线程有关事件或错误。例如，当系统即将重启时，系统向所有进程发送
    `SIGTERM` 信号，让它们知道正在重启，它们必须立即退出。一旦进程收到这个信号，它应该做出相应的反应。在某些情况下，可能不需要做任何事情，但在某些情况下，进程的当前状态应该被保存。
- en: 'The following table shows the available signals in a Linux system. The table
    is extracted from the Linux signals [manual page that can be found at http://www.man7.org/](http://www.man7.org/linux/man-pages/man7/signal.7.html)linux/man-pages/man7/signal.7.html:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 Linux 系统中可用的信号。该表格是从 Linux 信号 [手册页](http://www.man7.org/linux/man-pages/man7/signal.7.html)
    提取的：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Table 19-1: List of all available signals in a Linux system'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19-1：Linux 系统中所有可用的信号列表
- en: 'As you can see in the preceding table, not all of the signals are POSIX, and
    Linux has got its own signals. While most of the signals correspond to well-known
    events, there are two POSIX signals that can be defined by the user. This is mostly
    used in scenarios when you want to invoke a certain functionality in your program
    while the process is running. *Example 19.1* demonstrates how to use signals and
    how they can be handled in a C program. Next, you can find the code for *example
    19.1*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，并非所有信号都是 POSIX 信号，Linux 有自己的信号。虽然大多数信号对应于已知事件，但有两个 POSIX 信号可以被用户定义。这通常用于当你想在程序运行时调用某些功能时。*示例
    19.1* 展示了如何在 C 程序中使用信号以及如何处理它们。接下来，你可以找到 *示例 19.1* 的代码：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 19-1 [ExtremeC_examples_chapter19_1.c]: Handling POSIX signals'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 19-1 [ExtremeC_examples_chapter19_1.c]: 处理 POSIX 信号'
- en: In the preceding example, we have used the `signal` function to assign various
    signal handlers to some specific signals. As you can see, we have one signal handler
    for the user-defined signals, one handler for the `SIGINT` signal, and one for
    the `SIGKILL` signal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `signal` 函数将各种信号处理程序分配给一些特定的信号。正如你所见，我们有一个用于用户定义信号的信号处理程序，一个用于
    `SIGINT` 信号的信号处理程序，以及一个用于 `SIGKILL` 信号的信号处理程序。
- en: 'The program is merely a never-ending loop, and all we want to do is to handle
    some signals. The following commands show how to compile and run the example in
    the background:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 程序只是一个永无止境的循环，我们只想处理一些信号。以下命令显示了如何在后台编译和运行示例：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 19-1: Compiling and running example 19.1'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 19-1：编译和运行示例 19.1
- en: 'Now that we know the PID of the program, we can send it some signals. The PID
    is 4598 and the program is running in the background. Note that the PID will be
    different for you. You can use the `kill` command to send a signal to a process.
    The following command is used to examine the preceding example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了程序的 PID，我们可以向它发送一些信号。PID 是 4598，程序正在后台运行。请注意，对于你来说，PID 可能是不同的。你可以使用 `kill`
    命令向进程发送信号。以下命令用于检查前面的示例：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 19-2: Sending different signals to the background process'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 19-2：向后台进程发送不同的信号
- en: As you can see, the program handles all signals except the `SIGKILL` signal.
    `SIGKILL` cannot be handled by any process and, usually, a parent process that
    has spawned the process can be notified about its child being killed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序处理了除 `SIGKILL` 信号之外的所有信号。`SIGKILL` 不能被任何进程处理，通常，创建进程的父进程可以收到其子进程被杀的通知。
- en: Note that the `SIGINT` signal, or the interrupt signal, can be sent to a foreground
    program by pressing `Ctrl` + `C`. Therefore, whenever you press this combination
    of keys, you are actually sending an interrupt signal to the running program.
    The default handler just stops the program, but as you can see in the preceding
    example, we can handle the `SIGINT` signal and ignore it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以通过按下 `Ctrl` + `C` 发送 `SIGINT` 信号，或中断信号，到前台程序。因此，每次你按下这个键组合时，实际上是在向正在运行的程序发送中断信号。默认的处理程序只是停止程序，但正如你在前面的示例中看到的，我们可以处理
    `SIGINT` 信号并忽略它。
- en: 'In addition to the ability to send a signal to a process using shell commands,
    a process also can send a signal to another process if it knows the target process''s
    PID. You can use the `kill` function (declared in `signal.h`), which does exactly
    the same as its command-line version. It accepts two parameters: the first is
    the target PID and the second is the signal number. It is also possible for a
    process or a thread to use the `kill` or `raise` functions to send a signal to
    itself. Note that the `raise` function sends the signal to the current thread.
    These functions can be quite useful in scenarios in which you want to notify another
    part of your program about an event.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以使用 shell 命令向进程发送信号的能力之外，如果知道目标进程的 PID，进程还可以向另一个进程发送信号。你可以使用 `kill` 函数（在
    `signal.h` 中声明），它与它的命令行版本完全一样。它接受两个参数：第一个是目标 PID，第二个是信号号。进程或线程也可以使用 `kill` 或 `raise`
    函数向自身发送信号。请注意，`raise` 函数向当前线程发送信号。这些函数在你想通知程序的其他部分有关事件的情况下非常有用。
- en: The last note about the preceding example is that, as you saw in *Shell Box
    19-2*, it doesn't matter that the main thread is busy with the never-ending loop,
    the signals are delivered asynchronously. Therefore, you can be sure that you
    always receive the incoming signals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面示例的最后一点是，正如你在*Shell Box 19-2*中看到的，主线程忙于无限循环并不重要，信号是异步传递的。因此，你可以确信你总是能接收到传入的信号。
- en: Now it's time to talk about POSIX pipes as another single-host IPC technique
    that can be useful in certain circumstances.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论 POSIX 管道作为另一种单主机 IPC 技术的时候了，在某些情况下这可能很有用。
- en: POSIX pipes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX 管道
- en: 'POSIX Pipes in Unix are unidirectional channels that can be used between two
    processes that need to exchange messages. Upon creating a POSIX pipe, you will
    get two file descriptors. One file descriptor is used to write to the pipe, and
    the other one is used to read from the pipe. The following example shows the basic
    usage of a POSIX pipe:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 中，POSIX 管道是单向通道，可以在需要交换消息的两个进程之间使用。创建 POSIX 管道时，你会得到两个文件描述符。一个文件描述符用于向管道写入，另一个用于从管道读取。以下示例展示了
    POSIX 管道的基本用法：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 19-2 [ExtremeC_examples_chapter19_2.c]: Example 19.2 on using a POSIX
    pipe'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 19-2 [ExtremeC_examples_chapter19_2.c]: 使用 POSIX 管道的示例 19.2'
- en: As you can see, in the second line of the `main` function, we have used the
    `pipe` function. As we've already said, it accepts an array of two file descriptors
    and opens two file descriptors, one for reading from the pipe and the other one
    for writing to it. The first file descriptor, found at index 0, should be used
    for reading; and the second file descriptor, located at index 1, should be used
    for writing to the pipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 `main` 函数的第二行，我们使用了 `pipe` 函数。正如我们之前所说的，它接受一个包含两个文件描述符的数组，并打开两个文件描述符，一个用于从管道读取，另一个用于向管道写入。第一个文件描述符位于索引
    0，应用于读取；第二个文件描述符位于索引 1，应用于向管道写入。
- en: In order to have two processes, we have used the fork API. As we've explained
    in *Chapter 17*, *Process Execution*, the fork API clones the parent process and
    creates a new child process. Therefore, the opened file descriptors are available
    to the child process after calling the `fork` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有两个进程，我们使用了 `fork` API。正如我们在*第 17 章*，*进程执行*中解释的，`fork` API 会克隆父进程并创建一个新的子进程。因此，在调用
    `fork` 函数后，打开的文件描述符对子进程也是可用的。
- en: When the child process is spawned, the parent process enters the `else` block
    and the child process enters the `if` block. Firstly, each process should close
    the file descriptor that it is not going to use. In this example, the parent wants
    to read from the pipe and the child wants to write to the pipe. That's why the
    parent process closes the second file descriptor (the write file descriptor) and
    the child process closes the first file descriptor (the read file descriptor).
    Note that a pipe is unidirectional and reverse communication is not possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当子进程被创建时，父进程进入`else`块，而子进程进入`if`块。首先，每个进程都应该关闭它不打算使用的文件描述符。在这个例子中，父进程想要从管道读取，而子进程想要向管道写入。这就是为什么父进程关闭第二个文件描述符（写入文件描述符），而子进程关闭第一个文件描述符（读取文件描述符）。请注意，管道是单向的，反向通信是不可能的。
- en: 'The following shell box shows the output of the preceding example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 shell box 展示了前面示例的输出：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 19-3: Output of running example 19.2'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 19-3：运行示例 19.2 的输出
- en: As you can see in *Code Box 19-2*, for reading and writing operations we use
    the `read` and `write` functions. As we mentioned before, in push-based IPC, a
    file descriptor refers to a byte channel, and when you have a file descriptor
    pointing to a channel, you can use the file descriptor's related functions. The
    `read` and `write` functions accept a file descriptor and no matter what kind
    of IPC channel is behind, they operate on the underlying channel the same way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*Code Box 19-2*中看到的，对于读写操作，我们使用`read`和`write`函数。正如我们之前提到的，在基于推的 IPC 中，文件描述符指向一个字节通道，当你有一个指向通道的文件描述符时，你可以使用文件描述符的相关函数。`read`和`write`函数接受一个文件描述符，无论背后的
    IPC 通道是什么类型，它们都以相同的方式操作底层的通道。
- en: 'In the previous example, we used the fork API to spawn a new process. If a
    situation arises in which we have two different processes spawned separately,
    the question is, how can they communicate through a shared pipe? If a process
    demands access to a pipe object within the system, it should have the corresponding
    file descriptor. There are two options available:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了 fork API 来创建一个新的进程。如果出现这样的情况，即我们分别创建了两个不同的进程，问题是如何通过共享管道进行通信？如果一个进程需要在系统中访问管道对象，它应该有相应的文件描述符。有两种选择可用：
- en: One of the processes should set up the pipe and transfer the corresponding file
    descriptors to the other process.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个进程应该设置管道并将相应的文件描述符传输给另一个进程。
- en: The processes should use a named pipe.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程应该使用命名管道。
- en: In the first scenario, the processes must use a Unix domain socket channel in
    order to exchange file descriptors. The problem is that if such a channel exists
    between the two processes, they could use it for further communication and there
    would be no need to set up another channel (POSIX pipe) that has a less friendly
    API than Unix domain sockets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种场景中，进程必须使用 Unix 域套接字通道来交换文件描述符。问题是，如果两个进程之间存在这样的通道，它们可以使用它进行进一步的通信，并且不需要设置另一个通道（POSIX
    管道），该通道的 API 比Unix 域套接字不友好。
- en: The second scenario seems to be more promising. One of the processes could use
    the `mkfifo` function and create a queue file by providing a path. Then, the second
    process could use the path to the already created file and open it for further
    communication. Note that the channel is still unidirectional and, depending on
    the scenario, one of the processes should open the file in read-only mode and
    the other should open it in write-only mode.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种场景似乎更有前景。其中一个进程可以使用`mkfifo`函数，通过提供路径来创建一个队列文件。然后，第二个进程可以使用已创建文件的路径并打开它以进行进一步的通信。请注意，通道仍然是单向的，并且根据场景的不同，其中一个进程应该以只读模式打开文件，而另一个进程应该以只写模式打开文件。
- en: One more point should be discussed about the previous example. As you can see,
    the child process waits for 2 seconds before writing to the pipe. In the meantime,
    the parent process is blocked on the `read` function. So, while there is no message
    written to the pipe, the process reading from the pipe becomes blocked.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的示例，还有一点需要讨论。正如你所看到的，子进程在写入管道之前会等待 2 秒。在此期间，父进程在`read`函数上被阻塞。因此，在没有消息写入管道的情况下，从管道读取的进程会变得阻塞。
- en: As the final note in this section, we know that POSIX pipes are push-based.
    As we've explained this before, push-based IPC techniques have a corresponding
    temporary kernel buffer for holding the incoming pushed messages. POSIX pipes
    are no exception and the kernel holds the written messages until they are read.
    Note that if the owner process quits, the pipe object and its corresponding kernel
    buffer are destroyed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一点，我们知道 POSIX 管道是基于推送的。正如我们之前所解释的，基于推送的 IPC 技术都有一个相应的临时内核缓冲区来存储传入的推送消息。POSIX
    管道也不例外，内核会保留写入的消息，直到它们被读取。请注意，如果所有者进程退出，管道对象及其对应的内核缓冲区将被销毁。
- en: In the following section, we will discuss POSIX message queues.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 POSIX 消息队列。
- en: POSIX message queues
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX 消息队列
- en: 'Kernel-hosted message queues are part of the POSIX standard. They differ significantly
    from POSIX pipes in a number of ways. Here, we examine the fundamental differences:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 内核托管的消息队列是 POSIX 标准的一部分。它们在许多方面与 POSIX 管道有显著的不同。在这里，我们考察这些基本的不同点：
- en: 'The elements inside a pipe are bytes. Instead, message queues hold messages.
    Pipes are not aware of any existing structure in the written bytes, while message
    queues keep actual messages and each call to the `write` function results in a
    new message being added to the queue. Message queues preserve the boundaries between
    written messages. To elaborate more on this, suppose that we have three messages:
    the first one has 10 bytes, the second one has 20 bytes, and the third one has
    30 bytes. We write these messages both to a POSIX pipe and to a POSIX message
    queue. The pipe only knows that it has 60 bytes inside, and it allows a program
    to read 15 bytes. But the message queue only knows that it has 3 messages and
    it doesn''t allow a program to read 15 bytes because we don''t have any messages
    with 15 bytes.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道内部是字节。相反，消息队列持有消息。管道对写入的字节中存在的任何结构都不知情，而消息队列则保留实际的消息，每次调用 `write` 函数都会在队列中添加一条新消息。消息队列保留了写入消息之间的边界。为了更详细地说明这一点，假设我们有三个消息：第一个消息有
    10 个字节，第二个消息有 20 个字节，第三个消息有 30 个字节。我们将这些消息同时写入 POSIX 管道和 POSIX 消息队列。管道只知道它内部有
    60 个字节，并允许程序读取 15 个字节。但消息队列只知道它有 3 条消息，并且不允许程序读取 15 个字节，因为我们没有 15 个字节的任何消息。
- en: Pipes have a maximum size, the unit of which is the number of bytes. Message
    queues instead have a maximum number of messages. In message queues, every message
    has a maximum size in terms of bytes.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道有一个最大大小，单位是字节数。而消息队列则有一个最大消息数。在消息队列中，每个消息都有一个以字节为单位的最大大小。
- en: Every message queue, like a named shared memory or a named semaphore, opens
    a file. While these files are not regular files, they can be used by future processes
    to access the same message queue instance.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个消息队列，就像一个命名共享内存或命名信号量，都会打开一个文件。虽然这些文件不是常规文件，但未来的进程可以使用它们来访问相同的消息队列实例。
- en: Message queues can be prioritized, while pipes don't care about the priority
    of bytes.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列可以被赋予优先级，而管道对字节优先级并不关心。
- en: 'And they have the following properties in common:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还具有以下共同属性：
- en: Both are unidirectional. In order to have bidirectional communication, you need
    to create two instances of pipes or queues.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都是单向的。为了实现双向通信，你需要创建两个管道或队列的实例。
- en: Both have limited capacity; you cannot write any number of bytes or messages
    that you want.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都有有限的容量；你不能写入任何你想要的字节数或消息数。
- en: Both are represented using file descriptors in most POSIX systems; therefore,
    I/O functions such as `read` and `write` can be used.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数 POSIX 系统中，它们都使用文件描述符来表示；因此，可以使用 `read` 和 `write` 等I/O函数。
- en: Both techniques are *connection-less*. In other words, if two different processes
    write two different messages, it is possible for one of them to read the other
    process's message. In other words, there is no ownership defined for the messages
    and any process can read them. This would be a problem, especially when there
    is more than one process operating on the same pipe or message queue concurrently.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两种技术都是**无连接的**。换句话说，如果两个不同的进程写入两条不同的消息，其中一条消息有可能被另一个进程读取。换句话说，没有为消息定义所有权，任何进程都可以读取它们。这可能会成为一个问题，尤其是在有多个进程同时操作同一个管道或消息队列的情况下。
- en: '**Note**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: POSIX message queues explained in this chapter should not be confused with message
    queue brokers being used in the **Message Queue Middleware** (**MQM**) architecture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的 POSIX 消息队列不应与在 **消息队列中间件** (**MQM**) 架构中使用的消息队列代理混淆。
- en: 'There are various resources on the internet that explain POSIX message queues.
    The following link explains POSIX message queues specifically for the QNX operating
    system, but most of the content is still applicable to other POSIX systems: https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有各种资源解释 POSIX 消息队列。以下链接专门解释了 QNX 操作系统上的 POSIX 消息队列，但大部分内容仍然适用于其他 POSIX 系统：https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html。
- en: Now it is time to have an example. *Example 16.3* has the same scenario as we
    had in *example 16.2*, but it uses a POSIX message queue instead of a POSIX pipe.
    All the functions related to POSIX message queues are declared in the `mqueue.h`
    header file. We will explain some of them shortly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候举一个例子了。*示例 16.3* 与我们之前在 *示例 16.2* 中的场景相同，但它使用 POSIX 消息队列而不是 POSIX 管道。与
    POSIX 管道和 POSIX 消息队列相比，与 POSIX 消息队列相关的所有函数都声明在 `mqueue.h` 头文件中。我们将在稍后解释其中的一些。
- en: 'Note that the following code doesn''t compile on macOS because OS/X doesn''t
    support POSIX message queues:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下代码在 macOS 上无法编译，因为 OS/X 不支持 POSIX 消息队列：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 19-3 [ExtremeC_examples_chapter19_3.c]: Example 19.3 on using a POSIX
    message queues'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 19-3 [ExtremeC_examples_chapter19_3.c]: 使用 POSIX 消息队列的示例 19.3'
- en: 'In order to compile the preceding code, run the following commands. Note that
    the preceding code should be linked with the `rt` library on Linux:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译前面的代码，请运行以下命令。请注意，前面的代码应在 Linux 上与 `rt` 库链接：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 19-4: Building example 19.3 on Linux'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 19-4: 在 Linux 上构建示例 19.3'
- en: 'The following shell box demonstrates the output of *example 19.3*. As you can
    see, the output is exactly the same as we had for *example 19.2* but it uses POSIX
    message queues to perform the same logic that we wrote in *example 19.2*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Shell 框演示了 *示例 19.3* 的输出。正如您所看到的，输出与我们之前在 *示例 19.2* 中得到的结果完全相同，但它使用 POSIX
    消息队列来执行我们在 *示例 19.2* 中编写的相同逻辑：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 19-5: Running example 19.3 on Linux'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 19-5: 在 Linux 上运行示例 19.3'
- en: Note that both POSIX pipes and message queues have a limited buffer in the kernel.
    Therefore, writing to pipes and message queues without having a consumer that
    reads their content can lead to all write operations being blocked. In other words,
    any `write` function call would remain blocked until a consumer reads a message
    from the message queue or some bytes from the pipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，POSIX 管道和消息队列在内核中都有一个有限的缓冲区。因此，在没有消费者读取其内容的情况下向管道和消息队列写入可能会导致所有写入操作被阻塞。换句话说，任何
    `write` 函数调用都会保持阻塞，直到消费者从消息队列中读取消息或从管道中读取一些字节。
- en: In the following section, we will briefly explain Unix domain sockets. They
    are usually the first choice when connecting two local processes in a single-host
    setup.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将简要解释 Unix 域套接字。在单主机设置中连接两个本地进程时，它们通常是首选。
- en: Unix domain sockets
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix 域套接字
- en: Another technique that can be used by a number of processes to communicate in
    a single-host deployment is using Unix domain sockets. They are special kind of
    sockets that only operate within the same machine. Therefore, they are different
    from network sockets, which allow two processes from two different machines to
    talk to each other over an existing network. Unix domain sockets have various
    characteristics that make them important and sophisticated in comparison to POSIX
    pipes and POSIX message queues. The most important characteristic is the fact
    that Unix domain sockets are bidirectional. Therefore, a single socket object
    is enough to read from and write to the underlying channel. In other words, the
    channels operated by Unix domain sockets are full-duplex. In addition, Unix domain
    sockets can be both *session-aware* and *message-aware*. This makes them even
    more flexible. We will discuss session-awareness and message-awareness in the
    following sections.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以在单主机部署中由多个进程使用的通信技术是使用 Unix 域套接字。它们是一种仅在相同机器上操作的特定类型的套接字。因此，它们与允许两个不同机器上的两个进程通过现有网络相互通信的网络套接字不同。Unix
    域套接字具有各种特性，使它们与 POSIX 管道和 POSIX 消息队列相比显得重要且复杂。最重要的特性是 Unix 域套接字是双向的。因此，单个套接字对象就足够从底层通道读取和写入。换句话说，Unix
    域套接字操作的通道是全双工的。此外，Unix 域套接字可以是 *会话感知* 和 *消息感知* 的。这使得它们更加灵活。我们将在以下章节中讨论会话感知性和消息感知性。
- en: Since Unix domain sockets cannot be discussed without knowing the basics of
    socket programming, we won't go any further than this in this chapter. Instead,
    in the following sections, we introduce socket programming and the concepts around
    it. A full discussion regarding Unix domain sockets will be given in the following
    chapter. Let's begin with socket programming.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有了解套接字编程的基础，Unix域套接字无法讨论，所以我们不会在本章中走得更远。相反，在接下来的几节中，我们将介绍套接字编程及其相关概念。关于Unix域套接字的全面讨论将在下一章中给出。让我们从套接字编程开始。
- en: Introduction to socket programming
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字编程简介
- en: As part of this chapter, we decided to discuss socket programming before going
    through the real C code examples as part of the next chapter. That's because there
    are some fundamental concepts that you need to know before jumping to the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们决定在下一章通过实际的C代码示例之前讨论套接字编程。这是因为有一些基本概念在你跳到代码之前需要了解。
- en: Socket programming can be done both on single-host and multi-host deployments.
    As you might have guessed, the socket programming in a single-host system is done
    through Unix domain sockets. In a multi-host setup, socket programming is about
    creating and using network sockets. Both Unix sockets and network sockets more
    or less use the same API and share the same concepts, so it would make sense to
    cover them together in the next chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字编程可以在单主机和多主机部署上执行。正如你可能已经猜到的，单主机系统中的套接字编程是通过Unix域套接字完成的。在多主机设置中，套接字编程是关于创建和使用网络套接字。Unix套接字和网络套接字在某种程度上使用相同的API并共享相同的概念，因此在下一章中一起介绍它们是有意义的。
- en: One of the key concepts before using network sockets is how computer networks
    work. In the following section, we are going to talk about this and introduce
    you to computer networks. There are many terms and concepts that you should know
    before being able to write your first socket programming example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用网络套接字之前的一个关键概念是计算机网络是如何工作的。在接下来的部分，我们将讨论这个问题，并介绍计算机网络。在能够编写你的第一个套接字编程示例之前，你应该了解许多术语和概念。
- en: Computer networks
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算机网络
- en: The approach we take to explain the networking concepts in this section is different
    from the usual texts you might find about this topic. Our goal is to create a
    basic understanding of how things work in a computer network, especially between
    two processes. We want to look at this concept from a programmer's point of view.
    And the main actors in our discussion are processes, not computers. Therefore,
    you might find the order of sections a bit odd at first, but it will help you
    to get the idea of how IPC works over a computer network.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中解释网络概念的方法与你在其他关于这个主题的文本中可能找到的方法不同。我们的目标是创建对计算机网络中事物如何工作的基本理解，特别是在两个进程之间。我们希望从程序员的视角来看待这个概念。我们讨论中的主要角色是进程，而不是计算机。因此，你可能会觉得章节的顺序一开始有点奇怪，但它将帮助你理解在计算机网络上IPC是如何工作的。
- en: Note that this section shouldn't be considered a complete description of computer
    networks and, of course, it cannot be done in a few pages and in just one section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节不应被视为计算机网络的一个完整描述，当然，它不可能在几页纸和仅一个章节中完成。
- en: Physical layer
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理层
- en: First, let's forget about processes and just consider the computers, or simply
    the machines. Before moving forward, note that we use various terms to refer to
    a computer in a network. We can call it a computer, machine, host, node, or even
    a system. Of course, the context helps you to find out the true meaning behind
    a given term.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们忘记进程，只考虑计算机，或者简单地说是机器。在继续前进之前，请注意我们使用各种术语来指代网络中的计算机。我们可以称之为计算机、机器、主机、节点，甚至系统。当然，上下文有助于你找出给定术语背后的真正含义。
- en: The first step toward having multi-host software is a number of computers that
    are connected together through a network or, more precisely, a computer network.
    For now, let's focus on two computers that we want to connect. In order to connect
    these two physical machines to one other, we certainly need some sort of physical
    medium such as a piece of wire or a wireless setup.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多主机软件的第一步是连接在一起的一组计算机，或者更精确地说，是一个计算机网络。现在，让我们专注于我们想要连接的两台计算机。为了将这两台物理机器连接起来，我们当然需要某种物理介质，比如一根电线或无线设置。
- en: Of course, without such a physical medium (which doesn't need to be visible,
    like in a wireless network), the connection would not be possible. These physical
    connections are analogous to roads between cities. We will stick to this analogy
    because it can explain what is happening inside a computer network very closely.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有这样的物理介质（它不需要是可见的，例如在无线网络中），连接将无法实现。这些物理连接类似于城市之间的道路。我们将坚持这个类比，因为它可以非常接近地解释计算机网络内部发生的事情。
- en: All the hardware equipment required to connect two machines physically are considered
    to be part of the *physical layer*. This is the first and the most basic layer
    that we explore. Without having this layer, it is impossible to transmit data
    between two computers and assume them to be connected. Everything above this layer
    is not physical and all you find is a set of various standards regarding how the
    data should be transmitted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的所有硬件设备，用于在物理上连接两台机器，都被认为是*物理层*的一部分。这是我们探索的第一个也是最基本的一层。没有这一层，就无法在两台计算机之间传输数据并假定它们已连接。这一层之上的一切都不是物理的，你所能找到的只是一系列关于数据如何传输的各种标准。
- en: Let's talk about the next layer, the link layer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈下一层，即链路层。
- en: Link layer
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链路层
- en: While merely having roads is not sufficient for traffic to move along them,
    the same is true for the physical connections between computers. In order to use
    roads, we need laws and regulations about the vehicles, signs, materials, borders,
    speed, lanes, directions, and so on, and without them, traveling along the roads
    would be chaotic and problematic. Similar rules are needed for direct physical
    connections between two computers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仅有道路不足以让交通在其上移动，但计算机之间的物理连接也是如此。为了使用道路，我们需要有关车辆、标志、材料、边界、速度、车道、方向等的法律和法规，没有它们，沿道路行驶将会混乱且有问题。在两个计算机之间的直接物理连接中也需要类似的规则。
- en: While the physical components and devices required to connect a number of computers
    all belong to the physical layer, the mandatory regulations and protocols that
    govern the way data is transmitted along the physical layer all belong to an upper
    layer called the *link layer*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然连接多个计算机所需的物理组件和设备都属于物理层，但管理物理层上数据传输方式的强制规定和协议都属于一个称为*链路层*的上层。
- en: As part of the regulations enforced by the link protocols, messages should be
    broken into pieces called *frames*. This is analogous to the regulations in a
    road system that defines a maximum length of the vehicles traveling on a certain
    road. You cannot drive a 1 km-long trailer (presuming that it is physically possible)
    on a road. You have to break it down into smaller segments, or into smaller vehicles.
    Similarly, a long piece of data should be broken into multiple frames, and each
    frame must be traveling along the network freely, independent of the other frames.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为链路协议实施的规则的一部分，消息应该被分成称为*帧*的部分。这类似于道路系统中定义的车辆在特定道路上行驶的最大长度的规定。你不能在道路上驾驶1公里长的拖车（假设在物理上可能），你必须将其分解成更小的部分，或者更小的车辆。同样，长数据块应该被分解成多个帧，并且每个帧都必须在网络中自由传输，独立于其他帧。
- en: It is worth mentioning that networks can exist between any two computational
    devices. They don't necessarily need to be computers. There are many devices and
    machines in industry that can be connected to each other to form a network. Industrial
    networks have their own standards for their physical wiring, connectors, terminators,
    and so on, and they have their own link protocols and standards.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，网络可以存在于任何两个计算设备之间。它们不一定是计算机。在工业界有许多设备和机器可以相互连接以形成一个网络。工业网络有自己的物理布线、连接器、终端等标准，它们有自己的链路协议和标准。
- en: Many standards describe such link connections, for instance, how a desktop computer
    can get connected to an industrial machine. One of the most prominent link protocols
    that is designed to connect a number of computers via a wire is *Ethernet*. Ethernet
    describes all the rules and regulations governing data transmission over computer
    networks. We have another widely used link protocol called IEEE 802.11, which
    governs wireless networks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准描述了这样的链路连接，例如，如何将台式计算机连接到工业机器。设计用于通过有线方式连接多个计算机的最突出的链路协议之一是*以太网*。以太网描述了管理计算机网络上数据传输的所有规则和规定。我们还有另一个广泛使用的链路协议，称为IEEE
    802.11，它管理无线网络。
- en: A network consisting of computers (or any other groups of homogenous computing
    machines or devices) connected by a physical connection via a specific link protocol
    is called a **Local Area Network** (**LAN**). Note that any device willing to
    join a LAN must use a physical component called a *network adapter* or a **Network
    Interface Controller** (**NIC**) attached to it. For instance, the computers wanting
    to join an Ethernet network must have an *Ethernet NIC*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由通过特定链路协议通过物理连接连接的计算机（或任何其他同质计算机器或设备组）组成的网络称为**局域网**（**LAN**）。请注意，任何希望加入局域网的设备都必须使用一个称为*网络适配器*或**网络接口控制器**（**NIC**）的物理组件。例如，想要加入以太网网络的计算机必须有一个*以太网NIC*。
- en: A computer can have multiple NICs attached. Each NIC can connect to a specific
    LAN, therefore a computer with three NICs is able to connect to three different
    LANs simultaneously.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一台计算机可以连接多个NIC。每个NIC可以连接到特定的局域网，因此具有三个NIC的计算机能够同时连接到三个不同的局域网。
- en: It is also possible that it uses all its three NICs to connect to the same LAN.
    The way that you configure NICs and how you connect computers to various LANs
    should be designed beforehand and a precise plan should be in place.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能它使用其所有三个NIC连接到同一个局域网。配置NIC的方式以及将计算机连接到各种局域网的方式应该在事先设计，并且应该有一个精确的计划。
- en: Every NIC has a specific and unique address defined by the governing link protocol.
    This address will be used for data transmission between the nodes inside a LAN.
    The Ethernet and IEEE 802.11 protocols define a **media access control** (**MAC**)
    address for every compatible NIC. Therefore, any Ethernet NIC or IEEE 802.11 Wi-Fi
    adapter should have a unique MAC address in order to join a compatible LAN. Inside
    a LAN, the assigned MAC addresses should be unique. Note that ideally, any MAC
    address should be unique universally and unchangeable. However, this is not the
    case, and you can even set the MAC address of a NIC.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个NIC都有一个由治理链路协议定义的特定且唯一的地址。这个地址将用于局域网内节点之间的数据传输。以太网和IEEE 802.11协议为每个兼容的NIC定义了一个**媒体访问控制**（**MAC**）地址。因此，任何以太网NIC或IEEE
    802.11 Wi-Fi适配器都应该有一个唯一的MAC地址，以便加入一个兼容的局域网。在局域网内，分配的MAC地址应该是唯一的。请注意，理想情况下，任何MAC地址应该是全球唯一且不可更改的。然而，情况并非如此，你甚至可以设置NIC的MAC地址。
- en: To summarize what we have explained so far, we have a stack of two layers, the
    physical layer beneath and the link layer above. This is enough to connect a number
    of computers on a single LAN. But it doesn't end here. We need another layer on
    top of these two layers to be able to connect computers from various LANs with
    or without any intermediate LANs in between.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 总结到目前为止我们所解释的内容，我们有一个两层堆栈，下面是物理层，上面是链路层。这足以连接单个局域网上的多个计算机。但这并没有结束。我们需要在这些两层之上再添加一层，以便能够连接来自不同局域网的计算机，无论是否有中间局域网。
- en: Network layer
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络层
- en: So far, we've seen that MAC addresses are used in Ethernet LANs in order to
    connect a number of nodes. But what happens if two computers from two different
    LANs need to connect to each other? Note that these LAN networks are not necessarily
    compatible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到MAC地址在以太网局域网中用于连接多个节点。但如果来自两个不同局域网的计算机需要相互连接会发生什么？请注意，这些局域网网络不一定兼容。
- en: For instance, one of the LANs could be a wired Ethernet network, while the other
    one could be a **fiber distributed data interface** (**FDDI**) network mainly
    using fiber optic as the physical layer. Another example is industrial machines
    connected to an **Industrial Ethernet** (**IE**) LAN that need to connect to operators'
    computers, which are on an ordinary Ethernet LAN. These examples and many more
    show that we need another layer on top of the aforementioned protocols in order
    to connect various nodes from different LANs. Note that we even need this third
    layer in order to connect compatible LANs. This would be even more crucial if
    we are going to transmit data from one LAN to another (compatible or heterogeneous)
    through a number of intermediate LANs. We explain this further in the upcoming
    paragraphs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，其中一个局域网可能是有线以太网网络，而另一个局域网可能是主要使用光纤作为物理层的**光纤分布式数据接口**（**FDDI**）网络。另一个例子是连接到普通以太网局域网的**工业以太网**（**IE**）局域网上的工业机器，需要连接到操作员计算机。这些例子以及更多例子表明，我们需要在上述协议之上添加另一层，以便连接来自不同局域网的各个节点。请注意，我们甚至需要这个第三层来连接兼容的局域网。如果我们打算通过多个中间局域网将数据从一个局域网传输到另一个局域网（兼容或异构），这将更加关键。我们将在接下来的段落中进一步解释这一点。
- en: Just like the frames in the link layer, we have *packets* in the *network layer*.
    Long messages are broken into smaller pieces called packets. While frames and
    packets are referring to two different concepts in two different layers, for simplicity,
    we consider them the same and we stick to the term *packet* for the rest of this
    chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像链路层中的帧一样，我们在网络层中有**数据包**。长消息被分成更小的部分，称为数据包。虽然帧和数据包在不同的层中指的是两个不同的概念，但为了简单起见，我们考虑它们是相同的，并在本章的其余部分使用术语**数据包**。
- en: As a key difference, you should know that frames encapsulate packets, in other
    words, a frame contains a packet. We won't go any deeper regarding frames and
    packets, but you can find numerous sources on the internet that describe various
    aspects of these concepts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为关键的区别，你应该知道帧封装数据包，换句话说，一个帧包含一个数据包。我们不会深入探讨帧和数据包，但你可以在互联网上找到许多描述这些概念各个方面的资源。
- en: 'The *network protocol* fills the gap between various LANs in order to connect
    them to each other. While each LAN can have its own specific physical layer and
    its own specific link layer standards and protocols, the governing network protocol
    should be the same for all of them. Otherwise, heterogeneous (not compatible)
    LANs cannot connect to each other. The most famous network protocol at the moment
    is the **Internet Protocol** (**IP**). It is extensively used in large computer
    networks that usually consist of smaller Ethernet or Wi-Fi LANs. IP has two versions
    based on the length of its addresses: IPv4 and IPv6.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议用于填补各种局域网之间的差距，以便将它们相互连接。虽然每个局域网都可以有自己的特定物理层、自己的特定链路层标准和协议，但所有这些局域网应遵循相同的网络协议。否则，异构（不兼容）的局域网无法相互连接。目前最著名的网络协议是**互联网协议**（**IP**）。它在通常由较小的以太网或Wi-Fi局域网组成的大型计算机网络中得到广泛使用。IP根据其地址长度分为两个版本：IPv4和IPv6。
- en: 'But how can two computers from two different LANs be connected? The answer
    lies in the *routing* mechanism. In order to receive data from an external LAN,
    there should be a *router* node. Suppose that we are going to connect two different
    LANs: LAN1 and LAN2\. A router is simply another node that resides in both networks
    by having two NICs. One NIC is in LAN1 and the other one is in LAN2\. Then, a
    special routing algorithm decides which packets to transfer and how they should
    be transferred between networks.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何将来自两个不同局域网的计算机连接起来呢？答案在于**路由**机制。为了接收来自外部局域网的数据，应该有一个**路由器**节点。假设我们要连接两个不同的局域网：LAN1和LAN2。路由器就是一个节点，它通过拥有两个网络接口卡（NICs）同时存在于两个网络中。一个NIC位于LAN1，另一个位于LAN2。然后，一个特殊的路由算法决定哪些数据包需要传输以及如何在网络之间传输。
- en: With the routing mechanism, multiple networks can have a bidirectional flow
    of data through the router nodes. For this to happen, within every LAN there should
    be a router node. Therefore, when you want to send data to a computer located
    in a different geographical zone, it could be that your data is being transmitted
    through tens of routers before hitting its target. I'm not going to go any further
    than this into the routing concept, but there are tons of great information about
    this mechanism on the web.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过路由机制，多个网络可以通过路由器节点进行双向数据流动。为了实现这一点，每个局域网内都应该有一个路由器节点。因此，当你想要向位于不同地理区域的计算机发送数据时，你的数据可能需要通过数十个路由器才能到达目标。我不会深入探讨路由概念，但在网络上可以找到大量关于这一机制的优秀信息。
- en: '**Note**:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: There is a utility program called *traceroute* that allows you to see the routers
    between your computer and the target computer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**traceroute**的实用程序，它允许你查看你的计算机和目标计算机之间的路由器。
- en: 'At this point, two hosts from two different LANs can be connected to each other,
    with or without having intermediate LANs in between. Any further effort to make
    more specific connections should be done on top of this layer. Therefore, any
    communication happening between two programs, residing on two different nodes,
    must take place on top of a stack of three layers of protocols: the physical layer,
    the link layer, and finally the network layer. But what does it exactly mean when
    we say that two computers are connected to each other?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，来自两个不同局域网的两个主机可以相互连接，无论是否有中间局域网。任何进一步的具体连接尝试都应该在这个层次之上进行。因此，两个不同节点上的两个程序之间的任何通信都必须在三个协议层（物理层、链路层和最终的网络层）之上进行。但当我们说两台计算机连接在一起时，这究竟意味着什么呢？
- en: It is a bit vague to say that two nodes are connected, at least for programmers.
    To be more precise, the operating systems of these nodes are connected to each
    other, and they are the actors who transmit data. The ability to join a network
    and talk to other nodes in the same LAN or in a different LAN is intrinsically
    encoded in most current operating systems. Unix-based operating systems, which
    are our main focus in this book, are all operating systems that support networking,
    and they can be installed on the nodes participating in a network.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 说两个节点是连接的，至少对于程序员来说有点模糊。为了更精确，这些节点的操作系统是相互连接的，它们是传输数据的执行者。加入网络并与同一局域网或不同局域网中的其他节点通信的能力，在大多数当前操作系统中是固有的。基于Unix的操作系统能够成为我们本书的主要焦点，它们都是支持网络的操作系统能够安装在参与网络的节点上。
- en: Linux, Microsoft Windows, and almost any modern operating system supports networking.
    Indeed, it is unlikely that an operating system could survive if it could not
    operate in a network. Note that it is the kernel, or to be precise a unit within
    the kernel, that manages network connections and, therefore, it is more exact
    to say that the actual networking functionality is provided by the kernel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Linux、Microsoft Windows和几乎任何现代操作系统都支持网络。实际上，一个操作系统如果不能在网络中运行，可能无法生存。请注意，是内核，或者更准确地说，内核中的一个单元，管理网络连接，因此更确切地说，实际的网络功能是由内核提供的。
- en: Since the networking functionality is provided by the kernel, any process in
    the user space can benefit from that, and it can get connected to another process
    residing on a different node within the network. As a programmer, you don't need
    to worry about the layers (physical, link, and network layers) operated by the
    kernel, and you can focus on the layers above them, those that relate to your
    code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络功能由内核提供，用户空间中的任何进程都可以从中受益，并且它可以连接到网络中不同节点上的另一个进程。作为一个程序员，你不需要担心内核操作（物理层、链路层和网络层）的层级，你可以专注于它们之上的层级，那些与你的代码相关的层级。
- en: 'Every node in an IP network has an IP address. Like we said before, we have
    two versions of IP addresses: **IP version 4** (**IPv4**) and **IP version 6**
    (**IPv6**). An IPv4 address consists of four segments, each of which can hold
    a numerical value between 0 and 255\. Therefore, IPv4 addresses start from `0.0.0.0`
    and go up to `255.255.255.255`. As you can see, we only need 4 bytes (or 32 bits)
    in order to store an IPv4 address. For IPv6 addresses, this goes up to 16 bytes
    (or 128 bits). Also, we have private and public IP addresses, but the details
    are way beyond the subject of this chapter. It''s sufficient for us to know that
    every node in an IP network has a unique IP address.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: IP网络中的每个节点都有一个IP地址。正如我们之前所说的，我们有两种IP地址版本：**IP版本4**（**IPv4**）和**IP版本6**（**IPv6**）。IPv4地址由四个段组成，每个段可以存储介于0到255之间的数值。因此，IPv4地址从`0.0.0.0`开始，到`255.255.255.255`结束。正如你所见，我们只需要4个字节（或32位）来存储一个IPv4地址。对于IPv6地址，这增加到16个字节（或128位）。此外，我们还有私有和公共IP地址，但详细内容远远超出了本章的主题。我们只需要知道，IP网络中的每个节点都有一个唯一的IP地址。
- en: Building on the previous section, in a single LAN, every node has a link layer
    address together with an IP address, but we will use the IP address to make connections
    to that node and not the link layer address. As an example, in an Ethernet LAN,
    every node has two addresses; one is a MAC address and the other one is an IP
    address. The MAC address is used by the link layer protocols to transmit data
    within the LAN, and the IP address is used by the programs residing on various
    nodes to make network connections either within the same LAN or over a number
    of LANs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的基础上，在单个局域网中，每个节点都有一个链路层地址和一个IP地址，但我们将使用IP地址来连接该节点，而不是链路层地址。例如，在一个以太网局域网中，每个节点有两个地址；一个是MAC地址，另一个是IP地址。MAC地址由链路层协议用于在局域网内传输数据，而IP地址由驻留在各个节点上的程序用于在同一局域网内或多个局域网之间建立网络连接。
- en: The main functionality of the network layer is to connect two or more LANs.
    This will eventually lead to a big mesh of networks that are connected to each
    other, and they form a giant network with many individual LAN networks within
    it. In fact, such a network exists, and we know it as the internet.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层的主要功能是连接两个或更多局域网。这最终会导致一个庞大的网络网状结构，这些网络相互连接，形成一个包含许多独立局域网的大型网络。实际上，这样的网络是存在的，我们称之为互联网。
- en: Like any other network, every node that is accessible on the internet must have
    an IP address. But the main difference between a node that is accessible on the
    internet and a node that is not is that an internet node must have a public IP
    address, while a node that is not accessible through the internet usually has
    a private address.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他网络一样，每个可访问互联网的节点都必须有一个IP地址。但可访问互联网的节点和不可访问的节点的主要区别在于，互联网节点必须有一个公网IP地址，而通常不可通过互联网访问的节点有一个私有地址。
- en: To give an example, your home network might be connected to the internet, but
    an external node on the internet cannot get connected to your laptop because your
    laptop has a private IP address and not a public IP address. While your laptop
    is still accessible inside your home network, it is not available on the internet.
    Therefore, if your software is going to be available on the internet, it should
    be run on a machine that has a public IP address.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，你的家庭网络可能连接到互联网，但互联网上的外部节点无法连接到你的笔记本电脑，因为你的笔记本电脑有一个私有IP地址而没有公网IP地址。虽然你的笔记本电脑仍然可以在家庭网络内部访问，但它不在互联网上。因此，如果你的软件要在互联网上可用，它应该在具有公网IP地址的机器上运行。
- en: There is a tremendous amount of information about IP networking, and we are not
    going to cover all of it, but as a programmer it is important to know the difference
    between private and public addresses.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于IP网络的信息量巨大，我们不会涵盖所有内容，但作为一个程序员，了解私有地址和公网地址之间的区别是非常重要的。
- en: While in a network, ensuring the connectivity between the nodes is not the programmer's
    responsibility; it is considered part of your skillset to be able to detect network
    defects. This is very important because it can let you know whether a bug or misbehavior
    has roots in your code, or it is an infrastructure (or network) issue. That's
    why we have to touch on some more concepts and tools here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，确保节点之间的连接不是程序员的职责；能够检测网络缺陷被认为是你的技能的一部分。这一点非常重要，因为它可以让你知道一个错误或不正常行为是否根植于你的代码，或者它是一个基础设施（或网络）问题。这就是为什么我们必须在这里涉及一些更多概念和工具。
- en: The basic tool that guarantees that two hosts (nodes), either in the same LAN
    or located on different LANs, are capable of transmitting data, or that they can
    "see" each other, is the *ping* tool. You may already know of it. It sends a number
    of **Internet Control Message Protocol** (**ICMP**) packets that, if a reply is
    sent back, means that the other host is up, connected, and responding.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 确保两个主机（节点），无论是在同一局域网内还是在不同的局域网中，能够传输数据，或者它们能够“看到”对方的基本工具是*ping*工具。你可能已经知道了它。它发送一系列**互联网控制消息协议**（**ICMP**）数据包，如果收到回复，则表示另一台主机正在运行、已连接并响应。
- en: '**Note**:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: ICMP is another network layer protocol that is mainly used for monitoring and
    management of IP-based networks in case of connectivity or quality of service
    issues and failures.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP是另一种网络层协议，主要用于在出现连接性或服务质量问题及故障时，对基于IP的网络进行监控和管理。
- en: 'Suppose you are going to check whether your computer can see the public IP
    address `8.8.8.8` (which it should if it is connected to the internet). The following
    commands will help you to check the connectivity:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你要检查你的电脑是否可以看到公网IP地址`8.8.8.8`（如果它连接到互联网，它应该可以看到）。以下命令将帮助你检查连接性：
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 19-6: Using the ping utility to check the connectivity to the internet'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 19-6：使用ping实用程序检查互联网连接性
- en: As you can see in the output, it says that it has sent 7 ICMP ping packets and
    none of them have been lost during transmission. This means that the operating
    system behind the IP address `8.8.8.8` is up and responsive.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在输出中看到的那样，它表示已经发送了7个ICMP ping数据包，在传输过程中没有丢失任何一个。这意味着IP地址`8.8.8.8`背后的操作系统正在运行并响应。
- en: '**Note**:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'The public IP address `8.8.8.8` refers to the Google Public DNS service. More
    can be read here: https://en.wikipedia.org/wiki/Google_Public_DNS.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 公网IP地址`8.8.8.8`指的是谷歌公共DNS服务。更多信息请参阅：https://en.wikipedia.org/wiki/Google_Public_DNS。
- en: In this section, we explained how two computers can get connected via a network.
    Now, we are getting close to the point where two processes can actually get connected
    to each other and transmit data over a number of LANs. For this purpose, we need
    another layer on top of the network layer. That's where network programming begins.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了如何通过网络将两台计算机连接起来。现在，我们正接近这样一个点，即两个进程实际上可以相互连接并跨越多个局域网传输数据。为此，我们需要在网络层之上添加另一个层。这就是网络编程开始的地方。
- en: Transport layer
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: 'So far, we have seen that two computers can get connected to each other via
    a stack of three layers: the physical layer, the link layer, and the network layer.
    For inter-process communication, we actually need two processes to be connected
    and talking to each other. But with two computers connected through these three
    layers, we can have many processes running on each of them, and any process running
    on the first machine might want to establish a connection with another process
    located on the second machine. Therefore, having a connection just based on the
    network layer is too general to support several distinct connections initiated
    by various processes.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，两台计算机可以通过三层堆栈相互连接：物理层、链路层和网络层。对于进程间通信，我们实际上需要两个进程连接并相互交谈。但是，通过这三层连接的两台计算机上可以运行许多进程，并且运行在第一台机器上的任何进程都可能想要与位于第二台机器上的另一个进程建立连接。因此，仅基于网络层的连接过于通用，无法支持由各种进程发起的多个不同的连接。
- en: That's why we need another layer on top of the network layer. The *transport
    layer* is there to address this need. While hosts are connected through the network
    layer, the processes running on those hosts can get connected through the transport
    layer established on top of the network layer. Like any other layer that has its
    own unique identifiers or unique addresses, this layer has a new concept as its
    unique identifier, usually known as a *port*. We will elaborate more on this in
    the upcoming sections, but before that, we have to explain the *listener-connector*
    model, which allows two parties to communicate over a channel. In the next section,
    we start to explain this model by giving an analogy between computer networks
    and telephone networks.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们才需要在网络层之上再添加一层。*传输层*就是为了满足这一需求而存在的。虽然主机通过网络层连接，但运行在这些主机上的进程可以通过在网络层之上建立的传输层进行连接。像任何其他具有自己独特标识符或地址的层一样，这一层也有一个新概念作为其唯一标识符，通常被称为*端口*。我们将在接下来的章节中对此进行详细阐述，但在那之前，我们必须解释*监听器-连接器*模型，该模型允许双方通过一个通道进行通信。在下一节中，我们将通过将计算机网络与电话网络进行类比来解释这一模型。
- en: Analogy of telephone networks
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电话网络的类比
- en: The best example to start with is the **Public Switched Telephone Network**
    (or **PSTN**). While the similarity between computer networks and telephone networks
    might not seem very promising, there are strong similarities that allow us to
    explain the transport layer in a sensible fashion.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的例子就是**公共交换电话网络**（或**PSTN**）。虽然计算机网络与电话网络之间的相似性可能看起来并不很有希望，但它们之间存在着强烈的相似性，这使我们能够以合理的方式解释传输层。
- en: In our analogy, the people using the telephone network are like processes in
    a computer network. Therefore, a telephone call is equivalent to a *transport
    connection*. The people are able to make calls only if the necessary infrastructure
    has been installed. This is analogous to the networking infrastructure that should
    be in place in order to enable processes to communicate.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类比中，使用电话网络的人就像计算机网络中的进程。因此，电话通话相当于*传输连接*。人们只有当必要的基础设施已经安装时才能进行通话。这类似于应该存在的网络基础设施，以便使进程能够进行通信。
- en: We suppose that the required underlying infrastructure is in place and it works
    perfectly and, based on that, we want to have two entities residing in these systems
    to make a channel and transmit data. This is analogous to two people in the PSTN
    and two processes residing on two different hosts in a computer network.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设所需的底层基础设施已经到位并且运行完美，基于这一点，我们希望在这两个系统中存在两个实体来建立一个通道并传输数据。这类似于PSTN中的两个人和计算机网络中两个不同主机上的两个进程。
- en: Anyone who wants to use PSTN needs to have a telephone device. This is analogous
    to the requirement of having a NIC for a computer node. On top of these devices,
    there are multiple layers consisting of various protocols. These layers building
    up the underlying infrastructure make the creation of a transport channel possible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 任何想要使用PSTN的人都需要一部电话设备。这类似于计算机节点需要网络接口卡（NIC）的要求。在这些设备之上，有多个由各种协议组成的层。这些构建底层基础设施的层使得创建传输通道成为可能。
- en: Now, in PSTN, one of the telephone devices that is connected to the PSTN waits
    until it receives a call. We call this the *listener* side. Note that a telephone
    device plugged into the PSTN always waits for a call signal from the network and,
    as soon as it receives the signal, it rings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在PSTN中，连接到PSTN的其中一个电话设备会等待接收到电话。我们称之为**听者**一方。请注意，连接到PSTN的电话设备总是等待来自网络的呼叫信号，并且一旦接收到信号，就会响起铃声。
- en: Now, let's talk about the other side, which makes the call. Note that making
    a call is equivalent to creating a transport channel. The other side also has
    a telephone device that is used to make a call. The listener is accessible through
    a telephone number, which can be thought of as the address of the listener. The
    *connector* side must know this telephone number in order to make the call. Therefore,
    the connector dials the listener's telephone number and the underlying infrastructure
    lets the listener know that there is an incoming call.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈另一方，它是发起通话的一方。请注意，发起通话相当于创建一个传输通道。另一方也有一个用于发起通话的电话设备。听者可以通过电话号码访问，这可以被视为听者的地址。**连接者**一方必须知道这个电话号码才能发起通话。因此，连接者拨打听者的电话号码，底层基础设施会让听者知道有一个来电。
- en: When the listener side answers the telephone, it accepts the incoming connection
    and a channel is established between the listener and the connector. From now
    on, it is up to the people sitting at each end to talk and continue the discussion
    over the created PSTN channel. Note that if one of the parties cannot understand
    the language of the other party, the communication cannot continue and one of
    the parties hangs up the phone, and the channel would be destroyed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当听者一方接听电话时，它接受传入的连接，并在听者和连接者之间建立一条通道。从现在起，两端坐着的人就可以通过创建的PSTN通道进行交谈和继续讨论。请注意，如果一方无法理解另一方的语言，通信将无法继续，并且一方会挂断电话，通道将被销毁。
- en: Connection-less versus connection-oriented transport communication
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面向连接与无连接的传输通信
- en: 'The preceding analogy tries to explain the transport communication in a computer
    network but, in fact, it describes *connection-oriented communication*. Here,
    we are going to introduce and describe another type of communication: *connection-less
    communication*. But before that, let''s have a deeper look at connection-oriented
    communication.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类比试图解释计算机网络中的传输通信，但实际上它描述的是**面向连接的通信**。在这里，我们将介绍并描述另一种类型的通信：**无连接通信**。但在那之前，让我们更深入地了解面向连接的通信。
- en: In connection-oriented communication, a specific and dedicated channel is created
    for a connector. Therefore, if we have one listener communicating with three connectors,
    we have three dedicated channels. It doesn't matter how big the transmitting message
    is, the message will reach the other party in the correct form without any loss
    inside the channel. If multiple messages are sent to the same location, the order
    of the sent messages is preserved, and the receiving process won't notice any
    disturbances in the underlying infrastructure.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向连接的通信中，为连接者创建了一个特定的专用通道。因此，如果我们有一个听者与三个连接者通信，我们就有了三个专用通道。无论传输的消息有多大，消息都会以正确的形式到达另一方，而不会在通道内丢失。如果向同一位置发送多个消息，发送消息的顺序将被保留，接收进程不会注意到底层基础设施中的任何干扰。
- en: As we've explained in the previous sections, any message is always broken into
    smaller chunks called packets while being transmitted over a computer network.
    In a connection-oriented scheme however, none of the parties, neither the listener
    nor the connector, will notice anything about the underlying *packet switching*.
    Even if the sent packets are received in a different order, the receiver's operating
    system will rearrange the packets in order to reconstruct the message in its true
    form, and the receiver process won't notice anything.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前几节中解释的那样，任何消息在通过计算机网络传输时，总是被分解成更小的块，称为数据包。然而，在面向连接的方案中，无论是听者还是连接者，都不会注意到底层**数据包交换**的任何情况。即使发送的数据包接收到的顺序不同，接收者的操作系统也会重新排列数据包，以便以正确的形式重建消息，接收进程不会注意到任何异常。
- en: More than that, if one of the packets gets lost while being transmitted, the
    receiver's operating system will request it again in order to revive the full
    message. As an example, **Transport Control Protocol** (**TCP**) is a transport
    layer protocol that behaves exactly as we have explained above. Therefore, TCP channels
    are connection-oriented.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，如果在传输过程中某个数据包丢失，接收方的操作系统将请求重新发送，以恢复完整消息。例如，**传输控制协议**（**TCP**）是一种传输层协议，其行为与我们上面解释的完全一致。因此，TCP通道是面向连接的。
- en: 'Along with connection-oriented channels, we also have connection-less communication.
    In connection-oriented communication, we guarantee two factors: the *delivery*
    of the individual packets, and the *sequence* of the packets. A connection-oriented
    transport protocol such as TCP preserves these factors at the same time. Conversely,
    a connection-less transport protocol doesn''t guarantee them.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面向连接的通道外，我们还有无连接通信。在面向连接的通信中，我们保证两个因素：单个数据包的*交付*和数据包的*顺序*。例如，TCP这样的面向连接的传输协议同时保持这些因素。相反，无连接传输协议不保证它们。
- en: In other words, you might have no guarantee for the delivery of the individual
    packets that the message is broken into, or you might not have a guarantee that
    all the packets will be in the correct order. Or you might not have both! For
    instance, the **User Datagram Protocol** (**UDP**) doesn't guarantee packet delivery
    or the order of the packets. Note that the guarantee of the correctness of contents
    of an individual packet is provided by the protocol in the network layer and the
    link layer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可能无法保证消息被分割成单独的数据包的交付，或者你可能无法保证所有数据包都将按正确的顺序排列。或者你可能两者都没有保证！例如，**用户数据报协议**（**UDP**）不保证数据包的交付或数据包的顺序。请注意，单个数据包内容的正确性保证由网络层和链路层的协议提供。
- en: Now it's time to explain two terms that are commonly used in network programming.
    The *stream* is the sequence of bytes that is transmitted over a connection-oriented
    channel. This means that connection-less transmission effectively doesn't offer
    a stream of data. We have a specific term for a unit of data being transmitted
    over a connection-less channel. We call it a *datagram*. A datagram is a piece
    of data that can be delivered as a whole in a connection-less channel. Any piece
    of data bigger than the maximum datagram size cannot be surely delivered or the
    final sequence might be wrong. Datagram is a concept defined in the transport
    layer, and it is the counterpart concept to packet in the network layer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解释两个在网络编程中常用的术语了。*流*是通过面向连接的通道传输的字节序列。这意味着无连接传输实际上不提供数据流。我们有一个特定的术语来描述通过无连接通道传输的数据单元。我们称之为*数据报*。数据报是在无连接通道中可以整体交付的数据块。任何大于最大数据报大小的数据块都无法确保交付，或者最终的顺序可能错误。数据报是在传输层定义的概念，它是网络层中数据包的对立概念。
- en: For instance, regarding UDP packets, it is guaranteed that every individual
    UDP datagram (packet) is transmitted correctly, but nothing more can be said about
    the correlation between two adjacent datagrams (packets). It is accepted that
    no integrity should exist beyond a UDP datagram, but this is not true of TCP.
    In TCP, because of the guarantee of delivery and preserving the sequence of the
    sent packets, we can put individual packets aside and look at it as a stream of
    bytes being transmitted between two processes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，关于UDP数据包，可以保证每个单独的UDP数据报（数据包）被正确传输，但关于两个相邻数据报（数据包）之间的相关性，则无话可说。人们普遍认为，UDP数据报之外不应存在完整性，但TCP并非如此。在TCP中，由于交付保证和发送数据包顺序的保持，我们可以将单个数据包放在一边，将其视为两个进程之间传输的字节流。
- en: Transport initialization sequences
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传输初始化序列
- en: In this subsection, we are going to talk about the steps that each process takes
    in order to establish a transport communication. We have different sequences for
    connection-oriented and connection-less schemes, so we are going to talk about
    them in two following subsections separately. Note that the difference appears
    only in the initialization of the channel, and after that, both sides will use
    more or less the same API in order to read from and write to the created channel.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将讨论每个进程为了建立传输通信所采取的步骤。我们为面向连接和无连接方案有不同的序列，因此我们将分别在接下来的两个小节中分别讨论它们。请注意，差异仅出现在通道的初始化过程中，之后，双方将使用更多或更少的相同API来读取和写入创建的通道。
- en: The listener process always *binds* an endpoint (usually an IP address together
    with a port) and the connector process always *connects* to that endpoint. This
    is regardless of being a connection-oriented or a connection-less channel.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器过程始终*绑定*一个端点（通常是IP地址与端口号的组合），而连接器过程始终*连接*到该端点。这无论是有连接还是无连接的通道都是如此。
- en: Note that in the following sequences, we have assumed that there is an IP network
    established between the computers hosting the listener and connector processes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在以下序列中，我们假设监听器和连接器过程所在的主机之间已经建立了IP网络。
- en: Connection-less initialization sequences
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无连接的初始化序列
- en: 'In order to establish a connection-less communication channel, the listener
    process will do the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立无连接的通信通道，监听器过程将执行以下操作：
- en: The listener process binds a port on one of existing NICs, or even all of them.
    This means that the listener process asks its host operating system to redirect
    the incoming data to that port and, hence, to the listener process. The port is
    simply a number between 0 and 65535 (2 bytes) and must not be already bound by
    another listener process. Trying to bind a port that's already in use results
    in an error. Note that in the case of binding a port on a specific NIC, the operating
    system will redirect all incoming packets that are targeted at that bound port
    and received on that specific NIC to the listener process.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听器过程将在现有的一个或所有网络接口卡（NIC）上绑定一个端口。这意味着监听器过程请求其宿主操作系统将传入数据重定向到该端口，从而重定向到监听器过程。端口是一个介于0到65535（2字节）之间的数字，并且不能被另一个监听器过程绑定。尝试绑定一个已使用的端口将导致错误。请注意，在绑定特定NIC上的端口时，操作系统将重定向所有针对该绑定端口且在该特定NIC上接收到的目标数据包到监听器过程。
- en: The process waits and reads the messages that become available on the created
    channel and responds to them by writing back to the channel.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程等待并读取在创建的通道上可用的消息，并通过将响应写回通道来对这些消息进行响应。
- en: 'And the connector process will do the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器过程将执行以下操作：
- en: It must know the IP address and the port number of the listener process. Therefore,
    it tries to connect to the listener side by providing the IP address and the port
    number to its host operating system. If the target process is not listening on
    the specified port, or the IP address points to an invalid or the wrong host,
    the connection will fail.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须知道监听器过程的IP地址和端口号。因此，它尝试通过向其宿主操作系统提供IP地址和端口号来连接监听器端。如果目标过程没有在指定的端口上监听，或者IP地址指向无效或错误的主机，连接将失败。
- en: When the connection is successfully established, the connector process can write
    to the channel and read from it in almost the same way, meaning the same API that
    the listener process uses.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当连接成功建立后，连接器过程可以几乎以相同的方式写入通道并从中读取，这意味着与监听器过程使用的相同API。
- en: Note that beside taking the preceding steps, the listener and connector processes
    should both be using the same transport protocol, otherwise the messages cannot
    be read and understood by their host operating systems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了执行上述步骤之外，监听器和连接器过程都应该使用相同的传输协议，否则消息不能被它们的宿主操作系统读取和理解。
- en: Connection-oriented initialization sequences
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面向连接的初始化序列
- en: 'In a connection-oriented scenario, the listener process will follow the following
    sequence in order to get initialized:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向连接的场景中，监听器过程将按照以下顺序进行初始化：
- en: Bind a port, just like the connection-less scenario explained previously. The
    port is exactly the same as explained in the previous section and it follows the
    same constraints.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定端口，就像之前解释的无连接场景一样。端口与之前章节中解释的完全相同，并遵循相同的约束。
- en: The listener process continues by configuring the size of its *backlog*. The
    backlog is a queue of pending connections that are not accepted yet by the listener
    process. In connection-oriented communication, the listener side should accept
    incoming connections before being able to transmit any data. After configuring
    the backlog, the listener process enters *listening mode*.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听器过程继续通过配置其*后备队列*的大小来进行配置。后备队列是尚未被监听器过程接受的挂起连接的队列。在面向连接的通信中，监听器端应在能够传输任何数据之前接受传入的连接。配置后备队列后，监听器过程进入*监听模式*。
- en: Now, the listener process begins to *accept* incoming connections. This is an
    essential step in establishing a transport channel. Only after accepting an incoming
    connection can they transmit data. Note that if the connector process sends a
    connection to the listener process, but the listener process cannot accept that
    connection, it will remain in the backlog until it gets either accepted or *timed
    out*. This can happen when the listener process is too busy with other connections
    and it cannot accept any further new connection. Then, the incoming connections
    will pile up in the backlog and when the backlog becomes full, new connections
    will be rejected immediately by the host operating system.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，监听器进程开始*接受*传入的连接。这是建立传输通道的一个基本步骤。只有在接受传入连接之后，它们才能传输数据。请注意，如果连接器进程向监听器进程发送一个连接，但监听器进程无法接受该连接，它将保留在队列中，直到被接受或*超时*。这可能会发生在监听器进程忙于处理其他连接，无法接受任何新的连接时。然后，传入的连接将堆积在队列中，当队列满时，主机操作系统将立即拒绝新的连接。
- en: The sequence of the connector process is very similar to what we explained for
    the connection-less communication in the previous section. The connector connects
    to a certain endpoint by providing the IP address and the port, and after being
    accepted by the listener process, it can use the same API to read from and write
    to the connection-oriented channel.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器进程的顺序与我们之前章节中解释的无连接通信非常相似。连接器通过提供IP地址和端口号连接到某个端点，并在被监听器进程接受后，可以使用相同的API从连接导向的通道中读取和写入。
- en: Since the established channel is connection-oriented, the listener process has
    a dedicated channel to the connector side; therefore, they can exchange a stream
    of bytes that doesn't have an upper limit in terms of the number of bytes. Therefore,
    the two processes can transmit a huge amount of data, and its correctness is guaranteed
    by the governing transport and network protocols.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于建立的通道是面向连接的，监听器进程有专门连接到连接器侧的通道；因此，它们可以交换一个没有字节数量上限的字节流。因此，两个进程可以传输大量数据，其正确性由管理和网络传输协议保证。
- en: As the last note about the transport layer, we mentioned that the listener processes
    (regardless of the underlying channel being connection-oriented and connection-less)
    are required to bind an endpoint. Regarding UDP and TCP specifically, this endpoint
    is made up of an IP address and a port number.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为关于传输层的最后一项说明，我们提到监听器进程（无论底层通道是面向连接的还是无连接的）都需要绑定一个端点。具体到UDP和TCP，这个端点由一个IP地址和一个端口号组成。
- en: Application layer
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用层
- en: When a transport channel is established between two processes residing on two
    different ends, they should be able to talk to each other. By talking, we mean
    transmitting a series of bytes that can be understood by both ends. As we explained
    in the earlier sections in this chapter, a communication protocol is required
    here. Since this protocol resides in the *application layer* and it is used by
    the processes (or the applications running as processes), it is called an *application
    protocol*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个位于不同端点的进程之间建立传输通道时，它们应该能够相互通信。我们在这里所说的“通信”是指传输一系列双方都能理解的字节。正如我们在本章前面的部分所解释的，这里需要一个通信协议。由于该协议位于*应用层*，并且由进程（或作为进程运行的应用程序）使用，因此它被称为*应用协议*。
- en: While there aren't many protocols used in link, network, and transport layers
    and they are mostly well-known, we have numerous application protocols that are
    used in the application layer. This is again analogous to telecommunication networks.
    While there aren't many standards for telephone networks, the number of languages
    that people use to communicate is large, and they differ greatly. In computer
    networks, every application run as a process needs to use an application protocol
    in order to communicate with another process.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在链路、网络和传输层使用的协议并不多，它们大多是众所周知的，但我们有大量的应用协议在应用层使用。这又类似于电信网络。虽然电话网络没有多少标准，但人们用来通信的语言数量庞大，差异很大。在计算机网络中，每个作为进程运行的应用都需要使用一个应用协议才能与其他进程通信。
- en: Therefore, the programmers either use a well-known application protocol such
    as HTTP or FTP or they have to use a custom application protocol that is designed
    and built locally within a team.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序员要么使用一个众所周知的应用协议，如HTTP或FTP，要么必须使用一个本地设计和构建的定制应用协议。
- en: So far, we have discussed five layers; physical, link, network, transport, and
    application. Now it's time to put all of them into a single body and use it as
    a reference to design and deploy computer networks. In the following section,
    we talk about the internet protocol suite.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了五层；物理层、链路层、网络层、传输层和应用层。现在是我们将它们全部放入一个单一体系并用作设计部署计算机网络的参考的时候了。在接下来的部分，我们将讨论互联网协议套件。
- en: Internet protocol suite
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互联网协议套件
- en: 'The network model that we see every day and that is widely applied is the **Internet
    Protocol Suite** (**IPS**). IPS is mainly used on the internet, and since pretty
    much all computers want to have access to the internet, they have universally
    adapted to use IPS, which is not officially the standard approved by ISO. The
    standard model for computer networks is **Open System Interconnections** (**OSI**)
    model, which is more a theoretical model and is almost never publicly deployed
    and used. IPS has the following layers. Note that the prominent protocols in each
    layer are mentioned in the following list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天看到的并且广泛应用的网络安全模型是**互联网协议套件**（**IPS**）。IPS主要在互联网上使用，由于几乎所有的计算机都想访问互联网，它们普遍采用了IPS，尽管IPS并不是由ISO正式批准的标准。计算机网络的标准模型是**开放系统互联**（**OSI**）模型，它更多的是一个理论模型，几乎从未公开部署和使用。IPS具有以下层。请注意，以下列表中提到了每一层的突出协议：
- en: Physical layer
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层
- en: 'Link layer: Ethernet, IEEE 802.11 Wi-Fi'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链路层：以太网，IEEE 802.11 Wi-Fi
- en: 'Internet layer: IPv4, IPv6, and ICMP'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网层：IPv4，IPv6和ICMP
- en: 'Transport layer: TCP, UDP'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层：TCP，UDP
- en: 'Application layer: Numerous protocols such as HTTP, FTP, DNS, and DHCP, and
    so on.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层：包括HTTP、FTP、DNS和DHCP等众多协议。
- en: As you can see, the layers have a nice correspondence to the layers that we
    discussed in this chapter, but with only one exception; the network layer is renamed
    the internet layer. This is because as part of IPS, the network protocols that
    are prominent in this layer are only IPv4 and IPv6\. The rest of the explanations
    can be applied to IPS layers. IPS is the main model that we will be dealing with
    throughout this book and in the actual work environment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些层与我们在本章中讨论的层有很好的对应关系，但只有一个例外；网络层被重命名为互联网层。这是因为作为IPS的一部分，在这个层中突出的网络协议只有IPv4和IPv6。其余的解释可以应用于IPS层。IPS是我们将在整本书和实际工作环境中处理的主要模型。
- en: Now that we know how computer networks work, we are in a good position to proceed
    and see what *socket programming* is. As part of the rest of this chapter and
    the upcoming chapter, you will see that there is a deep correspondence between
    the concepts discussed in the transport layer and the concepts we have in socket
    programming.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了计算机网络的工作原理，我们处于一个很好的位置继续前进，看看什么是*套接字编程*。作为本章剩余部分和即将到来的章节的一部分，你将看到传输层中讨论的概念与套接字编程中的概念之间存在深刻的对应关系。
- en: What is socket programming?
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是套接字编程？
- en: Now that we know about the IPS model and the various network layers, it is much
    easier to explain what socket programming is. Before delving into the technical
    discussions regarding the socket programming, we should define it as an IPC technique
    that allows us to connect two processes residing on either the same node or two
    different nodes having a network connectivity between them. If we put the single-host
    socket programming aside, the other form requires us to have an operational network
    between the two nodes. This very fact ties socket programming with computer networks
    and all we have explained so far.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了IPS模型和不同的网络层，解释什么是套接字编程就变得容易多了。在深入讨论套接字编程的技术细节之前，我们应该将其定义为一个IPC技术，它允许我们连接位于同一节点或两个不同节点上的两个进程，这两个节点之间有网络连接。如果我们不考虑单主机套接字编程，另一种形式要求我们在两个节点之间有一个可操作的网络安全环境。正是这个事实将套接字编程与计算机网络以及我们迄今为止所解释的一切联系在一起。
- en: To make it more technical, we should say that socket programming mainly happens
    in the transport layer. As we have already said, the transport layer is responsible
    for connecting two processes over an existing internet layer (network layer).
    Therefore, the transport layer is the key layer for establishing a socket programming
    context. Basically, that's why you as a programmer should know more about the
    transport layer and its various protocols. Some socket programming-related bugs
    have their origins in the underlying transport channel.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其更加技术化，我们应该说套接字编程主要发生在传输层。正如我们之前所说的，传输层负责在现有的网络层（网络层）上连接两个进程。因此，传输层是建立套接字编程上下文的关键层。基本上，这就是为什么作为程序员，你应该更多地了解传输层及其各种协议。一些与套接字编程相关的错误其根源在于底层的传输通道。
- en: In socket programming, sockets are the main tools for establishing a transport
    channel. Note that despite what we have discussed so far, socket programming can
    go beyond transport layer or *process-to-process communications* and it can include
    internet layer (network layer) or *host-to-host communications* as well. This
    means that we can have internet-layer-specific sockets as well as transport layer
    sockets. With this in mind, most of the sockets that we see and work with are
    transport sockets and for the rest of this chapter and the next chapter, we will
    mainly be talking about transport sockets.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字编程中，套接字是建立传输通道的主要工具。请注意，尽管我们迄今为止已经讨论了，套接字编程可以超越传输层或**进程间通信**，它还可以包括网络层（网络层）或**主机间通信**。这意味着我们可以有网络层特定的套接字以及传输层套接字。考虑到这一点，我们看到的并与之交互的大多数套接字都是传输套接字，在本章的剩余部分和下一章中，我们将主要讨论传输套接字。
- en: What is a socket?
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是套接字？
- en: As we have explained in the previous section, the transport layer is where the
    actual socket programming is taking place. Everything above it just makes the
    socket programming more specific; however, the actual underlying channel has been
    established in the transport layer.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中解释的那样，传输层是实际套接字编程发生的地方。其上的一切只是使套接字编程更加具体；然而，实际的底层通道已经在传输层建立。
- en: We also discussed that the internet connection (network connection) on which
    the transport channel has been established is actually the connection between
    the operating systems, or more specifically the kernels of those operating systems.
    Therefore, there should be a concept in the kernel that resembles a connection.
    More than that, there could be many established connections initiated or accepted
    by the same kernel simply because there can be several processes running and hosted
    in that operating system and willing to have network connections.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了，在传输通道已建立的互联网连接（网络连接）实际上是操作系统之间的连接，或者更具体地说，是那些操作系统的内核之间的连接。因此，内核中应该有一个类似于连接的概念。不仅如此，同一个内核可以发起或接受许多已建立的连接，仅仅是因为可能有多个进程在该操作系统中运行并托管，并且愿意建立网络连接。
- en: The concept that we are looking for is the *socket*. For any established or
    soon-to-be-established connection in a system, there is a dedicated socket that
    identifies that connection. For a single connection made between two processes,
    there is exactly one socket on each side that addresses the same connection. As
    we explained before, one of these sockets belongs to the connector side and the
    other one belongs to the listener side. The API that allows us to define and manage
    a socket object is described by the *socket library* exposed by the operating
    system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找的概念是 *套接字*。对于系统中已建立或即将建立的任何连接，都有一个专门的套接字来标识该连接。对于两个进程之间建立的单一连接，每一边恰好有一个套接字指向相同的连接。正如我们之前解释的那样，其中一个套接字属于连接器端，另一个套接字属于监听器端。允许我们定义和管理套接字对象的
    API 由操作系统公开的 *套接字库* 描述。
- en: Since we are mainly talking about POSIX systems, we expect to have such a socket
    library as part of the POSIX API and, in fact, we do have such a library. In the
    rest of this chapter, we discuss the *POSIX socket library* and we explain how
    it can be used to establish a connection between two processes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要讨论的是 POSIX 系统，我们期望有一个这样的套接字库作为 POSIX API 的一部分，实际上我们确实有这样的库。在本章的剩余部分，我们将讨论
    *POSIX 套接字库*，并解释如何使用它来在两个进程之间建立连接。
- en: POSIX socket library
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX 套接字库
- en: 'Every socket object has three attributes: *domain*, *type*, and *protocol*.
    While the manual pages of an operating system explain these attributes very well,
    we want to talk about some of the values that are commonly used for these attributes.
    We start with the domain attribute, which is also known as **address family**
    (**AF**) or **protocol family** (**PF**). Some of the values that are widely used
    can be seen in the following list. Note that these address families support both
    connection-oriented and connection-less transport connections.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每个套接字对象都有三个属性：*域*、*类型*和*协议*。虽然操作系统的手册页对这些属性解释得很好，但我们想讨论一些这些属性常用的值。我们首先从域属性开始，它也被称为**地址族**（**AF**）或**协议族**（**PF**）。以下列表中可以看到一些广泛使用的值。请注意，这些地址族支持面向连接和无连接的传输连接。
- en: '`AF_LOCAL` or `AF_UNIX`: These are local sockets, which work only when both
    connector and listener processes are located on the same host.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_LOCAL` 或 `AF_UNIX`：这些是本地套接字，仅在连接器和监听器进程都位于同一主机上时才工作。'
- en: '`AF_INET`: These sockets allow two processes to connect to each other over
    an IPv4 connection.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_INET`：这些套接字允许两个进程通过IPv4连接相互连接。'
- en: '`AF_INET6`: These sockets allow two processes to connect to each other over
    an IPv6 connection.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_INET6`：这些套接字允许两个进程通过IPv6连接相互连接。'
- en: '**Note**:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In some POSIX systems, in the constants used for the domain attribute, you might
    find the prefix `PF_` instead of `AF_`. It is often the case that `AF_` constants
    have the same values as `PF_` constants, so they can be used interchangeably.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些POSIX系统中，您可能会在用于域属性的常量中找到前缀`PF_`而不是`AF_`。通常情况下，`AF_`常量与`PF_`常量具有相同的值，因此它们可以互换使用。
- en: In the next chapter, we will demonstrate the usage of the `AF_UNIX` and `AF_INET`
    domains, but it should be easy to find examples that use the `AF_INET6` domain.
    Also, there could be address families that are specific to a certain operating
    system and cannot be found on other systems.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将演示`AF_UNIX`和`AF_INET`域的使用，但应该很容易找到使用`AF_INET6`域的示例。此外，可能存在特定于某些操作系统的地址族，在其他系统上找不到。
- en: 'The most well-known values for the type attribute of a socket object are as
    follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字对象类型属性的已知值如下：
- en: '`SOCK_STREAM`: This means that the socket will represent a connection-oriented
    transport communication that guarantees delivery, correctness, and the order of
    the sent content. As we''ve explained streams in the previous sections, the term
    `STREAM` also suggests this. Note that, at this point, you cannot predict that
    the actual underlying transport protocol is TCP because this is not true regarding
    local sockets that belong to the `AF_UNIX` address family.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_STREAM`：这意味着套接字将表示面向连接的传输通信，保证发送内容的交付、正确性和顺序。正如我们在前面的章节中解释的流，术语`STREAM`也暗示了这一点。请注意，在此阶段，您无法预测实际底层的传输协议是TCP，因为这与属于`AF_UNIX`地址族的本地区套接字不符。'
- en: '`SOCK_DGRAM`: This means that the socket will represent a connection-less transport
    communication. Note that the term datagram, abbreviated as `DGRAM`, like we explained
    in the previous sections, refers to a series of bytes that cannot be seen as a
    stream. Instead, they can be seen as some individual chunks of data that are called
    datagrams. In a more technical context, a datagram represents a packet of data
    transmitted over a network.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_DGRAM`：这意味着套接字将表示无连接的传输通信。请注意，术语数据报（datagram），缩写为`DGRAM`，正如我们在前面的章节中解释的那样，指的是一系列无法被视为流的字节。相反，它们可以被视为一些称为数据报的独立数据块。在更技术性的背景下，数据报表示通过网络传输的数据包。'
- en: '`SOCK_RAW`: A raw socket can represent both connection-oriented and connection-less
    channels. The main difference between `SOCK_RAW` and `SOCK_DGRAM` or `SOCK_STREAM`
    is that the kernel actually knows about the underlying used transport protocol
    (UDP or TCP) and it can parse a packet and extract the header and the content.
    But with a raw socket, it doesn''t do so, and it is up to the program that has
    opened the socket to read and extract various sections.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_RAW`：原始套接字可以表示面向连接和无连接的通道。`SOCK_RAW`与`SOCK_DGRAM`或`SOCK_STREAM`之间的主要区别在于内核实际上知道底层使用的传输协议（UDP或TCP），并且它可以解析数据包并提取头部和内容。但是，对于原始套接字，内核并不这样做，而是由打开套接字的程序负责读取和提取各个部分。'
- en: In other words, when using `SOCK_RAW`, the packets are delivered directly to
    the program and it should extract and understand the packet structure itself.
    Note that if the underlying channel is a stream channel (connection-oriented),
    the recovery of lost packets and packet reordering are not done by the kernel,
    and the program should do them itself. This implies that recovery and packet reordering
    are actually done by the kernel when you select TCP as your transport protocol.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，当使用`SOCK_RAW`时，数据包会直接传递给程序，程序应该自行提取和理解数据包结构。请注意，如果底层通道是流通道（面向连接的），丢失的数据包恢复和数据包重排序不是由内核完成的，程序应该自行完成这些操作。这意味着，当您选择TCP作为传输协议时，恢复和数据包重排序实际上是由内核完成的。
- en: The third attribute, protocol, identifies the protocol that should be used for
    the socket object. Since most address families, together with the type, determine
    a certain protocol, this attribute can be chosen by the operating system upon
    the socket creation. In circumstances when we have multiple possible protocols,
    this attribute should be defined.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个属性，协议，标识了应该用于套接字对象的协议。由于大多数地址族与类型一起确定了一个特定的协议，因此该属性可以在套接字创建时由操作系统选择。在存在多个可能协议的情况下，应该定义此属性。
- en: Socket programming offers solutions for both single-host and multiple-host IPC.
    In other words, while it is quite possible to connect two processes located on
    two different hosts and in two different LANs using internet (network) sockets,
    it is totally possible to connect two processes residing on the same host using
    Unix domain sockets.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字编程为单主机和多主机IPC提供了解决方案。换句话说，虽然使用互联网（网络）套接字连接位于两个不同主机和两个不同局域网上的两个进程是完全可能的，但使用Unix域套接字连接同一主机上的两个进程也是完全可能的。
- en: As the last note in this section, we should add that socket connections are
    bidirectional and full-duplex. This means that both parties can read from and
    write to the underlying channel without interfering with the other end. This is
    a desired feature because it is usually a requirement in most IPC-related scenarios.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一项注意，我们应该补充说明，套接字连接是双向和全双工的。这意味着双方都可以从底层通道读取和写入，而不会干扰对方。这是一个期望的特性，因为在大多数与进程间通信（IPC）相关的场景中，通常都有这样的要求。
- en: Now that you have been introduced to the concept of sockets, we have to revisit
    the sequences that we explained in the previous sections regarding listener and
    connector processes. But this time, we dive into more detail and describe how
    sockets can be used to perform these sequences.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了套接字的概念，我们必须回顾之前章节中关于监听器和连接器进程的序列。但这次，我们将更深入地探讨，并描述如何使用套接字来执行这些序列。
- en: Revisiting listener-connector sequences
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回顾监听器-连接器序列
- en: As we mentioned before, as part of computer networks, in almost every connection
    one of the ends is always listening for incoming connections, and the other end
    tries to connect to the listener side. We also discussed an example regarding
    a telephone network, explaining how a telephone is used to listen to an incoming
    call, and how it can be used to make calls and connect to other listening devices.
    A similar situation exists in socket programming. Here, we want to explore the
    sequences that should be followed by the processes at two different ends in order
    to establish a successful transport connection.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，作为计算机网络的一部分，几乎在每一次连接中，一端总是处于监听状态，等待传入的连接，而另一端则尝试连接到监听端。我们也讨论了一个关于电话网络的例子，解释了电话是如何用来监听传入的呼叫，以及它是如何用来发起呼叫并连接到其他监听设备的。在套接字编程中，也存在类似的情况。在这里，我们想要探讨两个不同端点的进程应该遵循的序列，以便建立成功的传输连接。
- en: In the following subsections, we will go deeper into the details of socket creation
    and the various operations that should be performed by both processes that want
    to engage in a connection. The sequences explained in the following subsections
    for the listener and connector processes are infrastructure agnostic and benefit
    from the generalization that socket programming provides over the various underlying
    transport connections.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将更深入地探讨套接字创建的细节以及想要建立连接的两个进程应该执行的各种操作。以下小节中解释的监听器和连接器进程的序列是基础设施无关的，并得益于套接字编程在底层传输连接上提供的通用化。
- en: As you should remember, we discussed the listener and connector sequences regarding
    connection-oriented and connection-less communications separately. We take the
    same approach here, and we firstly start with the stream (connection-oriented)
    listener sequence.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你应该记得的，我们分别就面向连接和无连接通信讨论了监听器和连接器序列。我们在这里采取同样的方法，首先从流（面向连接）监听序列开始。
- en: Stream listener sequence
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流监听序列
- en: 'The following steps should be followed by a process that wants to listen for
    new stream connections. You have been introduced to the binding, listening, and
    accepting phases in the previous sections, but here we will talk about them from
    a socket programming perspective. Note that most of the actual functionality is
    provided by the kernel and the process only needs to call the right functions
    from the socket library in order to put itself into listening mode:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 想要监听新的流连接的过程应遵循以下步骤。您已经在之前的章节中介绍了绑定、监听和接受阶段，但在这里我们将从套接字编程的角度来讨论它们。请注意，大部分实际功能都是由内核提供的，进程只需从套接字库中调用正确的函数，以便将自己置于监听模式：
- en: The process should create a socket object using the `socket` function. This
    socket object is usually called a *listener socket*. The socket object represents
    the whole listener process, and it will be used to accept new connections. Depending
    on the underlying channel, the arguments sent to the `socket` function can vary.
    We could pass either `AF_UNIX` or `AF_INET` as the address family of the socket,
    but we have to use `SOCK_STREAM` as the type of the socket because we are going
    to have a stream channel. The protocol attribute of the socket object can be determined
    by the operating system. For example, if you choose `AF_INET` and `SOCK_STREAM`
    for a socket object, TCP will be selected by default for the protocol attribute.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程应使用 `socket` 函数创建一个套接字对象。这个套接字对象通常被称为 *监听套接字*。套接字对象代表整个监听进程，它将被用来接受新的连接。根据底层通道的不同，发送给
    `socket` 函数的参数可能会有所不同。我们可以传递 `AF_UNIX` 或 `AF_INET` 作为套接字的地址族，但我们必须使用 `SOCK_STREAM`
    作为套接字类型，因为我们将要有一个流通道。套接字对象协议属性可以由操作系统确定。例如，如果你为套接字对象选择了 `AF_INET` 和 `SOCK_STREAM`，则默认选择
    TCP 作为协议属性。
- en: Now, the socket must be bound to an *endpoint* that is reachable by the connector
    processes using the `bind` function. The details of the chosen endpoint heavily
    depend on the chosen address family. For example, for an internet channel, the
    endpoint should be a combination of an IP address and a port. For a Unix domain
    socket, the endpoint should be the path to a *socket file* located on the filesystem.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，套接字必须使用 `bind` 函数绑定到一个 *端点*，该端点可以通过连接器进程访问。所选端点的详细信息严重依赖于所选的地址族。例如，对于互联网通道，端点应该是
    IP 地址和端口的组合。对于 Unix 域套接字，端点应该是文件系统上 *套接字文件* 的路径。
- en: The socket must be configured for listening. Here, we use the `listen` function.
    As we have explained before, it simply creates a backlog for the listener socket.
    The backlog is a list of awaiting connections that have not yet been accepted
    by the listener process. While the listener process cannot accept new incoming
    connections, the kernel will keep the incoming connections in the corresponding
    backlog until the listener process becomes free and starts to accept them. Once
    the backlog is full, any further incoming connections will be rejected by the
    kernel. Choosing a low size for the backlog can lead to many connections being
    rejected when the listener process is congested and choosing a large size can
    lead to a pile of awaiting connections that will eventually get timed out and
    disconnected. The backlog size should be chosen according to the dynamics of the
    listener program.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套接字必须配置为监听。在这里，我们使用 `listen` 函数。正如我们之前所解释的，它只是为监听套接字创建一个队列。队列是一系列尚未被监听进程接受的等待连接。当监听进程无法接受新的传入连接时，内核将保留在相应队列中的传入连接，直到监听进程变得空闲并开始接受它们。一旦队列满，内核将拒绝任何进一步的传入连接。选择较小的队列大小可能导致在监听进程拥塞时许多连接被拒绝，而选择较大的队列大小可能导致大量等待连接最终超时并断开。队列大小应根据监听程序的动态性来选择。
- en: After configuring the backlog, it is time to accept the incoming connections.
    For every incoming connection, the `accept` function should be called. Therefore,
    it is a widely used pattern to have the `accept` called in a never-ending loop.
    Whenever the listener process stops accepting new connections, the connector processes
    are put into the backlog and once the backlog is full, they get rejected. Note
    that every call to the `accept` function simply picks up the next connection waiting
    in the socket's backlog. If the backlog is empty and if the listener socket is
    configured to be blocking, then any call to the `accept` function will be blocked
    until a new connection comes in.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置了backlog之后，是时候接受传入的连接了。对于每一个传入的连接，都应该调用`accept`函数。因此，将`accept`函数放在一个永不结束的循环中是一个广泛使用的模式。当监听器进程停止接受新的连接时，连接器进程将被放入backlog中，一旦backlog满了，它们将被拒绝。请注意，每次对`accept`函数的调用只是简单地从套接字的backlog中取出下一个等待的连接。如果backlog为空，并且监听套接字被配置为阻塞模式，那么对`accept`函数的任何调用都将被阻塞，直到有新的连接到来。
- en: 'Note that the `accept` function returns a new socket object. This means that
    the kernel dedicates a new unique socket object to every accepted connection.
    In other words, a listener process that has accepted 100 clients is using at least
    101 sockets: 1 for the listener socket and 100 sockets for its incoming connections.
    The returned socket from the `accept` function should be used for further communication
    with the client sitting at the other end of the channel.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`accept`函数返回一个新的套接字对象。这意味着内核为每个接受的连接分配了一个新的唯一套接字对象。换句话说，一个已经接受100个客户端的监听器进程至少使用了101个套接字：1个用于监听套接字，100个用于其传入的连接。从`accept`函数返回的套接字应用于与通道另一端的客户端进行进一步的通信。
- en: Note that this sequence of function calls remains the same for all types of
    the stream (connection-oriented) socket-based IPC. In the next chapter, we show
    real examples of how these steps should be programmed using C. In the next subsection,
    we deal with the stream connector sequence.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数调用序列对所有类型的流（面向连接的）基于套接字的IPC都保持一致。在下一章中，我们将展示如何使用C语言编程实现这些步骤的实例。在下一小节中，我们将处理流连接器序列。
- en: Stream connector sequence
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流连接器序列
- en: 'When the connector process wants to connect to a listener process that is already
    in listening mode, it should follow the following sequence. Note that the listener
    process should be in listening mode, otherwise the connection will get refused
    by the kernel of the target host:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接器进程想要连接到一个已经处于监听模式的监听器进程时，它应该遵循以下序列。请注意，监听器进程应该处于监听模式，否则连接将被目标主机的内核拒绝：
- en: The connector process should create a socket by calling the `socket` function.
    This socket will be used to connect to the target process. The characteristics
    of this socket should be similar or at least compatible with those we set for
    the listener socket, otherwise, we cannot establish a connection. Therefore, we
    need to set the same address family that we set for the listener socket. And the
    type should remain `SOCK_STREAM`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接器进程应该通过调用`socket`函数来创建一个套接字。这个套接字将用于连接到目标进程。这个套接字的特征应该与为监听套接字设置的相似，或者至少是兼容的，否则我们无法建立连接。因此，我们需要设置与监听套接字相同的地址族。并且类型应保持为`SOCK_STREAM`。
- en: Then it should use the `connect` function by passing the arguments that uniquely
    identify the listener endpoint. The listener endpoint should be reachable by the
    connector process and it should have been made available by the target process.
    If the `connect` function succeeds, it means that the connection has been accepted
    by the target process. Before this point, the connection might be waiting in the
    backlog of the target process. If the specified target endpoint is not available
    for any reason, the connection will fail, and the connector process will receive
    an error.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它应该通过传递唯一标识监听端点的参数来使用`connect`函数。监听端点应该可以被连接器进程访问，并且它应该已经被目标进程提供。如果`connect`函数成功，这意味着连接已经被目标进程接受。在此之前，连接可能已经在目标进程的backlog中等待。如果指定的目标端点由于任何原因不可用，连接将失败，并且连接器进程将收到一个错误。
- en: Just like `accept` function call in the listener process, the `connect` function
    returns a socket object. This socket identifies the connection and should be used
    for further communication with the listener process. In the upcoming chapter,
    we will give a demonstration of the preceding sequences in the calculator example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就像监听进程中的 `accept` 函数调用一样，`connect` 函数返回一个套接字对象。这个套接字标识了连接，并且应该用于与监听进程的进一步通信。在下一章中，我们将通过计算器示例演示前面的序列。
- en: Datagram listener sequence
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据报监听器序列
- en: 'A datagram listener process will do the following in order to get initialized:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化，数据报监听进程将按以下顺序执行：
- en: Like the stream listener, the datagram listener process creates a socket object
    by calling the `socket` function. But this time, it must set the socket's type
    attribute as `SOCK_DGRAM`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与流监听器一样，数据报监听器进程通过调用 `socket` 函数创建一个套接字对象。但这次，它必须将套接字类型属性设置为 `SOCK_DGRAM`。
- en: Now that the listener socket has been created, the listener process should bind
    it to an endpoint. The endpoint and its constraints are very similar to the stream
    listener end. Note that there won't be a listening mode or an accepting phase
    for a datagram listener socket because the underlying channel is connection-less,
    and we can't have a dedicated session for each incoming connection.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在监听套接字已经创建，监听进程应该将其绑定到一个端点。端点和其约束与流监听端类似。请注意，对于数据报监听套接字，不会有监听模式或接受阶段，因为底层通道是无连接的，我们无法为每个传入连接分配一个专用会话。
- en: As explained, there is no listening mode or accepting phase with a datagram
    server socket. Also, the datagram listeners should use the `recvfrom` and `sendto`
    functions in order to read from and write back to a connector process. Reads can
    still be done using the `read` function, but writing the responses cannot be done
    just using a simple `write` function call. You will see why when we look at the
    datagram listener example as part of the upcoming chapter.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如解释的那样，数据报服务器套接字没有监听模式或接受阶段。此外，数据报监听器应该使用 `recvfrom` 和 `sendto` 函数来从连接进程读取和写入。读取仍然可以使用
    `read` 函数完成，但仅使用简单的 `write` 函数调用无法写入响应。当我们查看下一章中的数据报监听器示例时，您将看到原因。
- en: Datagram connector sequence
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据报连接序列
- en: A datagram connector has almost the same sequence as a stream connector. The
    only difference is the socket type, which must be `SOCK_DGRAM` for the datagram
    connector. One special case for datagram Unix domain connector sockets is that
    they have to bind to a Unix domain socket file in order to receive the responses
    from the server. We will elaborate on this in the upcoming chapter as part of
    the datagram calculator example when using Unix domain sockets.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报连接器几乎与流连接器有相同的序列。唯一的区别是套接字类型，对于数据报连接器必须是 `SOCK_DGRAM`。对于数据报Unix域连接套接字有一个特殊情况，它们必须绑定到一个Unix域套接字文件，以便接收来自服务器的响应。我们将在下一章中，作为使用Unix域套接字的数据报计算器示例的一部分，对此进行详细说明。
- en: Now that we have gone through all the possible sequences, it's time to explain
    how sockets and *socket descriptors* are related. This is last section in this
    chapter, and by starting the next chapter, we will be giving real C examples that
    cover all the sequences.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了所有可能的序列，是时候解释套接字和 *套接字描述符* 之间的关系了。这是本章的最后一节，通过开始下一章，我们将给出涵盖所有序列的真实C语言示例。
- en: Sockets have their own descriptors!
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 套接字有自己的描述符！
- en: Unlike other push-based IPC techniques that work with file descriptors, socket-based
    techniques deal with socket objects. Every socket object is referred to by an
    integer value, which is a socket descriptor inside the kernel. This socket descriptor
    can be used to refer to the underlying channel.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他使用文件描述符工作的基于推的IPC技术不同，基于套接字的技术处理套接字对象。每个套接字对象都由一个整数值引用，这是内核中的套接字描述符。这个套接字描述符可以用来引用底层通道。
- en: Note that file descriptors and socket descriptors are different. File descriptors
    refer to a regular file or a device file while socket descriptors refer to socket
    objects created by `socket`, `accept`, and `connect` function calls.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件描述符和套接字描述符是不同的。文件描述符指的是常规文件或设备文件，而套接字描述符指的是由 `socket`、`accept` 和 `connect`
    函数调用创建的套接字对象。
- en: While the file descriptors and socket descriptors are different, we still can
    use the same API or set of functions to read from and write to them. Therefore,
    it is possible to use `read` and `write` functions to work with sockets just like
    files.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件描述符和套接字描述符不同，但我们仍然可以使用相同的API或函数集来读取和写入它们。因此，可以使用`read`和`write`函数来处理套接字，就像处理文件一样。
- en: These descriptors have another similarity; both of them can be configured to
    be non-blocking via the same API. Non-blocking descriptors can be used to work
    with the behind file or socket in a non-blocking fashion.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些描述符还有一个相似之处；它们都可以通过相同的API配置为非阻塞。非阻塞描述符可以用于以非阻塞方式处理背后的文件或套接字。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to talk about IPC techniques that allow two processes
    to communicate and transmit data. Our discussion in this chapter will be complete
    in the upcoming chapter where we talk specifically about socket programming, and
    we will give various real C examples.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始讨论允许两个进程进行通信和传输数据的IPC技术。本章的讨论将在下一章中完成，我们将具体讨论套接字编程，并提供各种真实的C语言示例。
- en: 'As part of this chapter, we covered the following topics:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们涵盖了以下主题：
- en: Pull-based and push-based IPC techniques and how they are different and similar.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉模型和推模型的IPC技术以及它们的不同和相似之处。
- en: We compared single-host IPC techniques versus multiple-host IPC techniques.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们比较了单主机IPC技术与多主机IPC技术。
- en: You learned about communication protocols and their various characteristics.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了关于通信协议及其各种特性的内容。
- en: We went over the serialization and deserialization concepts and how they operate
    to fulfill a certain communication protocol.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了序列化和反序列化概念以及它们如何操作以满足特定的通信协议。
- en: We explained how the content, length, and the sequentiality features of protocols
    can affect receiver processes.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了协议的内容、长度和顺序特性如何影响接收器进程。
- en: We explained POSIX pipes and demonstrated how to use them with an example.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了POSIX管道，并通过示例演示了如何使用它们。
- en: You saw what a POSIX message queue is and how it can be used to enable two processes
    to communicate.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你看到了POSIX消息队列是什么以及它如何被用来使两个进程能够通信。
- en: We briefly explained Unix domain sockets and their basic properties.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要介绍了Unix域套接字及其基本特性。
- en: We explained what computer networks are and how the stack of various network
    layers can lead to a transport connection.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了计算机网络是什么以及各种网络层堆栈如何导致传输连接。
- en: We explained what socket programming is.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了套接字编程是什么。
- en: We explained the initialization sequences of listener and connector processes
    and the steps they take to become initialized.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了监听器和连接器进程的初始化序列以及它们成为初始化状态所采取的步骤。
- en: We compared file descriptors and socket descriptors.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们比较了文件描述符和套接字描述符。
- en: In the next chapter, we continue our discussion about socket programming with
    a focus on providing real C examples. We will define an example of a calculator
    client and a calculator server. After that, we will use both Unix domain sockets
    and internet sockets to establish a fully functional client-server communication
    between the calculator client and its server.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论套接字编程，重点提供真实的C语言示例。我们将定义一个计算器客户端和一个计算器服务器的示例。之后，我们将使用Unix域套接字和互联网套接字在计算器客户端和其服务器之间建立完全功能化的客户端-服务器通信。
