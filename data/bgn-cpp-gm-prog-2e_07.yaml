- en: '*Chapter 6*: Object-Oriented Programming – Starting the Pong Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：面向对象编程 – 开始Pong游戏'
- en: In this chapter, there's quite a large amount of theory, but the theory will
    give us the knowledge that we need to start using **object-oriented programming**
    (**OOP**) with some expertise. Furthermore, we will not waste any time in putting
    that theory to good use as we will use it to code the next project, a Pong game.
    We will get to look behind the scenes at how we can create new types that we can
    use as objects by coding a class. First, we will look at a simplified Pong scenario
    so that we can learn about some class basics, and then we will start again and
    code a Pong game for real using the principles we have learned.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，有相当多的理论，但理论将为我们提供我们开始使用**面向对象编程**（**OOP**）所需的专业知识。此外，我们不会浪费时间将理论付诸实践，因为我们将在编写下一个项目，即Pong游戏时使用它。我们将深入了解如何通过编写类来创建我们可以用作对象的新类型。首先，我们将查看一个简化的Pong场景，以便了解一些类的基本知识，然后我们将重新开始，并使用我们学到的原则编写一个真正的Pong游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learn about OOP and classes using a hypothetical `Bat` class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个假设的`Bat`类来了解面向对象编程和类
- en: Start working on the Pong game and code a real class to represent the player's
    bat
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始制作Pong游戏，并编写一个代表玩家球拍的真正类
- en: OOP
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Object-oriented programming is a programming paradigm that we could consider
    to be almost the standard way to code. It is true there are non-OOP ways to code
    and there are even some non-OOP game coding languages/libraries. However, since
    we are starting from scratch, there is no reason to do things in any other way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种编程范式，我们可以将其视为几乎标准的编程方式。确实存在非面向对象编程的方式，甚至还有一些非面向对象的游戏编程语言/库。然而，由于我们是从头开始的，没有理由以任何其他方式做事。
- en: 'OOP will do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程将做到以下几件事：
- en: Make our code easier to manage, change, or update
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的代码更容易管理、更改或更新
- en: Make our code quicker and more reliable to write
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的代码编写更快、更可靠
- en: Make it possible to easily use other people's code (like we have with SFML)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其他人的代码（如我们使用SFML）易于使用
- en: We have already seen the third benefit in action. Let's discuss exactly what
    OOP is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了第三个好处。让我们讨论一下面向对象编程的确切含义。
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole. Each chunk is self-contained yet
    potentially reusable by other programs, while working together as a whole with
    the other chunks. These chunks are what we have been referring to as objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种编程方式，它涉及将我们的需求分解成比整体更易于管理的块。每个块都是自包含的，并且可以被其他程序潜在地重用，同时与其他块作为一个整体一起工作。这些块就是我们所说的对象。
- en: When we plan and code an object, we do so with a **class**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计划和编写一个对象时，我们使用**类**来这样做。
- en: Tip
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A class can be thought of as the blueprint of an object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以被看作是对象的蓝图。
- en: We implement an object *of* a class. This is called an **instance** of a class.
    Think about a house blueprint. You can't live in it, but you can build a house
    from it. You build an instance of the house. Often, when we design classes for
    our games, we write them to represent real-world *things*. In the next project,
    we will write classes for a bat that the player controls and a ball that the player
    can bounce around the screen with the bat. However, OOP is more than this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个类的**对象**。这被称为类的**实例**。想想房子的蓝图。你不能住在里面，但你可以用它来建造房子。你建造了一个房子的实例。通常，当我们为游戏设计类时，我们会编写它们来代表现实世界中的**事物**。在下一个项目中，我们将编写代表玩家控制的蝙蝠和玩家可以用球拍在屏幕上弹跳的球的类。然而，面向对象编程不仅仅是这些。
- en: Tip
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: OOP is a *way* of doing things, a methodology that defines best practices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种做事的方式，一种定义最佳实践的方法论。
- en: The three core principles of OOP are **encapsulation**, **polymorphism**, and
    **inheritance**. This might sound complex but, taken a step at a time, this is
    reasonably straightforward.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的三个核心原则是**封装**、**多态**和**继承**。这听起来可能很复杂，但一步一步来，这实际上是相当直接的。
- en: Encapsulation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: '**Encapsulation** means keeping the internal workings of your code safe from
    interference from the code that uses it. You can achieve this by allowing only
    the variables and functions you choose to be accessed. This means your code can
    always be updated, extended, or improved without affecting the programs that use
    it, provided the exposed parts are still accessed in the same way.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**意味着保护你的代码的内部工作不被使用它的代码干扰。你可以通过只允许你选择的变量和函数被访问来实现这一点。这意味着你的代码总是可以更新、扩展或改进，而不会影响使用它的程序，前提是暴露的部分仍然以相同的方式被访问。'
- en: As an example, with proper encapsulation, it wouldn't matter whether the SFML
    team needed to update the way their `Sprite` class works. If the function signatures
    remain the same, they don't have to worry about what goes on inside. The code
    that we wrote before the update will still work after the update.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果SFML团队需要更新他们的`Sprite`类的工作方式，只要函数签名保持不变，他们就不必担心内部发生了什么。我们在更新之前编写的代码在更新后仍然可以工作。
- en: Polymorphism
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: '**Polymorphism** allows us to write code that is less dependent on the *types*
    we are trying to manipulate. This will make our code clearer and more efficient.
    Polymorphism means *different forms*. If the objects that we code can be more
    than one type of thing, then we can take advantage of this. Polymorphism might
    sound a little bit like black magic at this point. We will use polymorphism in
    the fourth project, which we will start in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292),
    *Abstraction and Code Management – Making Better Use of OOP*. Everything will
    become clearer.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态性**允许我们编写不那么依赖于我们试图操作的*类型*的代码。这将使我们的代码更清晰、更高效。多态性意味着*不同的形式*。如果我们编写的对象可以是多种类型，那么我们可以利用这一点。在这个阶段，多态性可能听起来有点像黑魔法。我们将在第四个项目中使用多态性，该项目将在[*第14章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)“抽象和代码管理——更好地利用面向对象编程”中开始，一切都将变得清晰。'
- en: Inheritance
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Just like it sounds, **inheritance** means we can harness all the features and
    benefits of other peoples' classes, including encapsulation and polymorphism,
    while further refining their code specifically to our situation. We will use inheritance
    for the first time at the same time as we use polymorphism.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，**继承**意味着我们可以利用其他人的类的所有功能和好处，包括封装和多态，同时进一步改进它们的代码以适应我们的特定情况。我们将首次在同时使用多态性时使用继承。
- en: Why use OOP?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用面向对象编程（OOP）？
- en: When written properly, OOP allows you to add new features without worrying about
    how they interact with existing features. When you do have to change a class,
    its self-contained (encapsulated) nature means less or perhaps even zero consequences
    for other parts of the program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确编写时，面向对象编程（OOP）允许你添加新功能而不必担心它们如何与现有功能交互。当你确实需要更改一个类时，它自包含（封装）的特性意味着对程序的其他部分的影响更小或甚至为零。
- en: You can use other people's code (like the SFML classes) without knowing or perhaps
    even caring for how it works inside.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用别人的代码（如SFML类），而不必知道或者甚至关心它是如何工作的。
- en: OOP and, by extension, SFML, allows you to write games that use complicated
    concepts such as multiple cameras, multiplayer, OpenGL, directional sound, and
    more besides—all of this without breaking a sweat.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）以及SFML，允许你编写使用复杂概念的游戏，如多个摄像头、多人游戏、OpenGL、方向性声音等——所有这些都不需要费太多力气。
- en: You can create multiple, similar, yet different versions of a class without
    starting the class from scratch by using inheritance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用继承，你可以创建多个类似但不同的类的版本，而无需从头开始创建类。
- en: You can still use the functions intended for the original type of object with
    your new object because of polymorphism.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多态性，你仍然可以使用为原始类型的对象设计的函数来使用你的新对象。
- en: All this makes sense really. And as we know, C++ was designed from the start
    with all this OOP in mind.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些确实很有道理。正如我们所知，C++从一开始就是为了实现所有这些面向对象编程（OOP）而设计的。
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The ultimate key to success with OOP and making games (or any other type of
    app), other than the determination to succeed, is planning and design. It is not
    so much just "knowing" all the C++, SFML, and OOP topics that will help you to
    write great code, but rather applying all that knowledge to write code that is
    well-structured/designed. The code in this book is presented in an order and manner
    that's appropriate for learning about the various C++ topics in a gaming context.
    The art and science of structuring your code is called **design patterns**. As
    your code gets longer and more complex, effective use of design patterns will
    become more important. The good news is that we don't need to invent these design
    patterns ourselves. We will need to learn about them as our projects get more
    complex. As our projects become more complex, our design patterns will evolve
    too.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程和制作游戏（或任何其他类型的应用程序）中取得成功的最终关键，除了成功的决心之外，是规划和设计。这不仅仅是“知道”所有C++、SFML和面向对象编程主题将帮助你编写优秀的代码，而是将所有这些知识应用于编写结构良好/设计良好的代码。本书中的代码以适合在游戏环境中学习各种C++主题的顺序和方式呈现。结构代码的艺术和科学被称为**设计模式**。随着代码变得越来越长和复杂，有效使用设计模式将变得更加重要。好消息是，我们不需要自己发明这些设计模式。随着项目的复杂化，我们需要学习它们。随着项目的复杂化，我们的设计模式也会发展。
- en: In this project, we will learn about and use basic classes and encapsulation.
    As this book progresses, we will get a bit more daring and use inheritance, polymorphism,
    and other OOP-related C++ features too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将学习并使用基本的类和封装。随着本书的深入，我们将变得更加大胆，并使用继承、多态和其他与面向对象编程相关的C++特性。
- en: What exactly is a class?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 究竟什么是类？
- en: A class is a bunch of code that can contains functions, variables, loops, and
    all the other C++ syntax we have already learned about. Each new class will be
    declared in its own `.h` code file with the same name as the class, while its
    functions will be defined in their own `.cpp` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一组代码，可以包含函数、变量、循环以及我们已经学习过的所有其他C++语法。每个新的类都将声明在其自己的`.h`代码文件中，文件名与类名相同，而其函数将在它们自己的`.cpp`文件中定义。
- en: Once we have written a class, we can use it to make as many objects from it
    as we want. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the blueprint, just like the object isn't the class.
    It is an object made *from* the class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了一个类，我们就可以用它来创建尽可能多的对象。记住，类是蓝图，我们根据蓝图来创建对象。房子不是蓝图，就像对象不是类一样。它是由类*制作*的对象。
- en: Tip
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can think of an object as a variable and the class as a type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把一个对象想象成一个变量，把类想象成一个类型。
- en: Of course, with all this talk of OOP and classes, we haven't actually seen any
    code. Let's fix that now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在所有关于面向对象编程和类的讨论中，我们实际上还没有看到任何代码。现在让我们来解决这个问题。
- en: The theory of a Pong Bat
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pong蝙蝠的理论
- en: What follows is a hypothetical discussion of how we might use OOP to get started
    with the Pong project by coding a Bat class. Don't add any code to the project
    just yet as what follows is over-simplified in order to explain the theory. Later
    in this chapter, we will code it for real. When we get to coding the class for
    real, it will actually be quite different, but the principles we will learn about
    here will prepare us for success.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对如何使用面向对象编程来通过编写蝙蝠类开始Pong项目的假设性讨论。现在请不要向项目中添加任何代码，因为以下内容过于简化，只是为了解释理论。在本章的后面部分，我们将真正编写它。当我们真正编写类时，它实际上会非常不同，但在这里我们将学习的原则将为我们成功做好准备。
- en: We will begin by exploring variables and functions as part of a class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从类的一部分开始探索变量和函数。
- en: The class variable and function declarations
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类变量和函数声明
- en: A bat that bounces a ball would be an excellent first candidate for a class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个能够反弹球的蝙蝠是一个作为类的绝佳候选者。
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you don''t know what Pong is, then take a look at this link: [https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道什么是Pong，那么请查看这个链接：[https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong)。
- en: 'Let''s take a look at a hypothetical `Bat.h` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个假设的`Bat.h`文件：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At first glance, the code might appear a little complex, but when it has been
    explained, we will see there are very few concepts we haven't already covered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，代码可能看起来有点复杂，但当我们解释它时，我们会看到我们还没有覆盖的非常少的概念。
- en: 'The first thing to notice is that a new class is declared using the `class`
    keyword, followed by the name of the class and that the entire declaration is
    enclosed in curly braces, followed by a closing semicolon:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意的是，使用 `class` 关键字声明一个新的类，后跟类名，整个声明被大括号包围，最后以分号结尾：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s take a look at the variable declarations and their names:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看变量声明及其名称：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the names are prefixed with `m_`. This `m_` prefix is not compulsory, but
    it is a good convention. Variables that are declared as part of the class are
    called `m_` makes it plain when we are dealing with a member variable. When we
    write functions for our classes, we will start to see local (non-member) variables
    and parameters as well. The `m_` convention will then prove itself useful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有名称都以前缀 `m_` 开头。这个 `m_` 前缀不是强制性的，但这是一个好的约定。作为类一部分声明的变量被称为 `m_`，这使得当我们处理成员变量时非常明确。当我们为我们的类编写函数时，我们还将开始看到局部（非成员）变量和参数。`m_`
    约定将证明其有用性。
- en: 'Also, notice that all the variables are in a section of the code headed with
    the `private:` keyword. Scan your eyes over the previous code and note that the
    body of the class code is separated into two sections:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，所有变量都位于以 `private:` 关键字开头的代码部分中。扫描一下之前的代码，并注意类代码的主体被分为两个部分：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `public` and `private` keywords control the encapsulation of our class.
    Anything that is private cannot be accessed directly by the user of an instance/object
    of the class. If you are designing a class for others to use, you don't want them
    to be able to alter anything at will. Note that member variables do not have to
    be private, but good encapsulation is achieved by making them private whenever
    possible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 和 `private` 关键字控制了我们类的封装。任何私有内容都不能直接由类的实例/对象的用户访问。如果你正在为他人设计一个类，你不想让他们随意更改任何内容。请注意，成员变量不必是私有的，但通过尽可能使它们私有，我们可以实现良好的封装。'
- en: This means that our four member variables (`m_Length`, `m_Height`, `m_XPosition`,
    and `m_YPosition`) cannot be accessed directly by our game engine from the `main`
    function. They can only be accessed indirectly by the code of the class. This
    is encapsulation in action. For the `m_Length` and `m_Height` variables, this
    is fairly easy to accept as long as we don't need to change the size of the bat.
    The `m_XPosition` and `m_YPosition` member variables, however, need to be accessed,
    or how on earth will we move the bat?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的四个成员变量（`m_Length`、`m_Height`、`m_XPosition` 和 `m_YPosition`）不能直接从 `main`
    函数中由我们的游戏引擎访问。它们只能通过类的代码间接访问。这就是封装的作用。对于 `m_Length` 和 `m_Height` 变量来说，只要我们不需要改变球拍的大小，这很容易接受。然而，对于
    `m_XPosition` 和 `m_YPosition` 成员变量，它们需要被访问，否则我们如何移动球拍呢？
- en: 'This problem is solved in the `public:` section of the code, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在代码的 `public:` 部分得到解决，如下所示：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The class provides two functions that are public and will be usable with an
    object of the `Bat` type. When we look at the definitions of these functions,
    we will see how exactly these functions manipulate the private variables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供了两个公共函数，可以用 `Bat` 类型的对象使用。当我们查看这些函数的定义时，我们将看到这些函数是如何精确地操作私有变量的。
- en: In summary, we have a bunch of inaccessible (private) variables that cannot
    be used from the `main` function. This is good because encapsulation makes our
    code less error-prone and more maintainable. We then solve the problem of moving
    the bat by providing indirect access to the `m_XPosition` and `m_YPosition` variables
    by providing two public functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们有一系列不可访问（私有）的变量，不能从 `main` 函数中使用。这是好的，因为封装使我们的代码更少出错，更易于维护。然后我们通过提供两个公共函数来间接访问
    `m_XPosition` 和 `m_YPosition` 变量，从而解决了移动球拍的问题。
- en: The code in the `main` function can call these functions using an instance of
    the class, but the code inside the functions control exactly how the variables
    are used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数中的代码可以使用类的实例调用这些函数，但函数内部的代码控制着变量的具体使用方式。'
- en: Let's take a look at the function definitions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看函数的定义。
- en: The class function definitions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类函数定义
- en: 'The function definitions we will write in this book will all go in a separate
    file to the class and function declarations. We will use files with the same name
    as the class and the `.cpp` file extension. So, for example, the following code
    would go in a file called `Bat.cpp`. Look at the following code, which has just
    one new concept:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中编写的函数定义都将放在与类和函数声明分开的文件中。我们将使用与类同名的文件，并具有`.cpp`文件扩展名。例如，以下代码将放在名为`Bat.cpp`的文件中。看看以下代码，它只有一个新概念：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing to note is that we must use an include directive to include
    the class and function declarations from the `Bat.h` file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们必须使用包含指令来包含`Bat.h`文件中的类和函数声明。
- en: The new concept we can see here is the use of the `::`. Since the functions
    belong to a class, we must write the signature part by prefixing the function
    name with the class name, as well as `::`. `void Bat::moveLeft()` and `void Bat::moveRight`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到的新概念是使用`::`。由于函数属于一个类，我们必须通过在函数名前加上类名以及`::`来编写签名部分。例如，`void Bat::moveLeft()`和`void
    Bat::moveRight`。
- en: Important note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Actually, we have briefly seen the scope resolution operator before, that is,
    whenever we declare an object of a class, and we have not previously used `using
    namespace..`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们之前已经简要地见过作用域解析运算符，即每次我们声明一个类的对象，并且我们没有之前使用`using namespace..`。
- en: 'Note that we could have put the function definitions and declarations in one
    file, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以将函数定义和声明放在一个文件中，如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, when our classes get longer (as they will with our first Zombie Arena
    class), it is more organized to separate the function definitions into their own
    file. Furthermore, header files are considered "public", and are often used for
    documentation purposes if other people will be using the code that we write.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们的类变得更长（就像我们的第一个Zombie Arena类那样），将函数定义分离到它们自己的文件中会更加有序。此外，头文件被认为是“公共的”，如果其他人将使用我们编写的代码，它们通常用于文档目的。
- en: But how do we use a class once we have coded it?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦我们编写了类，我们该如何使用它呢？
- en: Using an instance of a class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类的实例
- en: Despite all the code we have seen related to classes, we haven't actually used
    the class. We already know how to do this as we have used the SFML classes many
    times already.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经看到了与类相关的所有代码，但我们实际上并没有使用类。我们已经知道如何做到这一点，因为我们已经多次使用了SFML类。
- en: 'First, we would create an instance of the `Bat` class, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会创建一个`Bat`类的实例，如下所示：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `bat` object has all the variables we declared in `Bat.h`. We just can''t
    access them directly. We can, however, move our bat using its public functions,
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`bat`对象拥有我们在`Bat.h`中声明的所有变量。我们无法直接访问它们。然而，我们可以通过其公共函数移动我们的蝙蝠，如下所示：'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or we can move it like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样移动它：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that `bat` *is a* `Bat`, and as such it has all the member variables
    and has all of the functions available to it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`bat`是一个`Bat`，因此它具有所有成员变量，并且可以使用所有可用的函数。
- en: 'Later, we may decide to make our Pong game multiplayer. In the `main` function,
    we could change the code so that the game has two bats, perhaps like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可能会决定将我们的Pong游戏改为多人游戏。在`main`函数中，我们可以更改代码，使游戏有两个蝙蝠，可能如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is vitally important to realize that each of these instances of `Bat` are
    separate objects with their very own set of variables. There are more ways to
    initialize an instance of a class, and we will see an example of this when we
    code the `Bat` class for real, next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，这些`Bat`实例中的每一个都是独立的对象，拥有它们自己的变量集。初始化一个类实例的方法有很多种，当我们真正为`Bat`类编写代码时，我们会看到这个例子。
- en: Now, we can start the project for real.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以真正开始项目了。
- en: Creating the Pong project
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Pong项目
- en: 'Since setting up a project is a fiddly process, we will go through it a step
    by step, like we did for the Timber!!! project. I won''t show you the same screenshots
    that I did for the Timber!!! project, but the process is the same, so flip back
    to [*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017), *C++, SFML,
    Visual Studio, and Starting the First Game* if you want a reminder of the locations
    of the various project properties:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置项目是一个繁琐的过程，我们将一步一步地进行，就像我们在Timber!!!项目中做的那样。我不会展示与Timber!!!项目相同的截图，但过程是相同的，所以如果你想提醒各种项目属性的地点，请翻回[*第1章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)，*C++，SFML，Visual
    Studio和开始第一个游戏*：
- en: Start Visual Studio and click on the **Create New Project** button. Or, if you
    still have the Timber!!! project open, you can select **File** | **New project**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio并点击**创建新项目**按钮。或者，如果你仍然打开了Timber!!!项目，你可以选择**文件** | **新项目**。
- en: In the window shown next, choose **Console app** and click the **Next** button.
    You will then see the **Configure your new project** window.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后显示的窗口中，选择**控制台应用程序**并点击**下一步**按钮。然后你会看到**配置你的新项目**窗口。
- en: In the `Pong` in the **Project** **name** field. Note that this causes Visual
    Studio to automatically configure the **Solution name** field so that it has the
    same name.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目名称**字段中的`Pong`。请注意，这会导致Visual Studio自动配置**解决方案名称**字段，使其具有相同的名称。
- en: In the `VS Projects` folder that we created in Chapter 1\. Like the Timber!!!
    project, this will be the location that all our project files will be kept.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在第一章中创建的`VS Projects`文件夹中。就像Timber!!!项目一样，这将是所有项目文件存放的位置。
- en: Check the option to **Place solution and project in the same directory**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**将解决方案和项目放在同一目录下**的选项。
- en: When you have completed these steps, click `main.cpp` file, like it was previously.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些步骤后，点击`main.cpp`文件，就像之前做的那样。
- en: We will now configure the project to use the SFML files that we put in the `SFML`
    folder. From the main menu, select **Project** | **Pong properties…**. At this
    stage, you should have the **Pong Property Pages** window open.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置项目以使用我们放在`SFML`文件夹中的SFML文件。从主菜单中选择**项目** | **Pong属性…**。在这个阶段，你应该已经打开了**Pong属性页**窗口。
- en: In the **Pong Property Pages** window, select **All Configurations** from the
    **Configuration:** drop-down.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Pong属性页**窗口中，从**配置：**下拉菜单中选择**所有配置**。
- en: Now, select **C/C++** and then **General** from the left-hand menu.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从左侧菜单中选择**C/C++**然后选择**常规**。
- en: After, locate the `\SFML\include`. The full path to type, if you located your
    `SFML` folder on your D drive, is `D:\SFML\include`. Change your path if you installed
    SFML on a different drive.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定位到`\SFML\include`。如果你将`SFML`文件夹放在D驱动器上，需要输入的完整路径是`D:\SFML\include`。如果你在另一个驱动器上安装了SFML，请更改路径。
- en: Click **Apply** to save your configurations so far.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**应用**以保存到目前为止的配置。
- en: Now, still in the same window, perform these steps. From the left-hand menu,
    select **Linker** and then **General**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在这个窗口中，执行以下步骤。从左侧菜单中选择**链接器**然后选择**常规**。
- en: Now, find the `SFML` folder is, followed by `\SFML\lib`. So, the full path to
    type if you located your `SFML` folder on your D drive is `D:\SFML\lib`. Change
    your path if you installed SFML on a different drive.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，找到`SFML`文件夹的位置，然后是`\SFML\lib`。所以，如果你将`SFML`文件夹放在D驱动器上，需要输入的完整路径是`D:\SFML\lib`。如果你在另一个驱动器上安装了SFML，请更改路径。
- en: Click **Apply** to save your configurations so far.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Next, still in the same window, perform these steps. Switch the **Configuration:**
    drop-down to **Debug** as we will be running and testing Pong in debug mode.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，仍然在这个窗口中，执行以下步骤。将**配置：**下拉菜单切换到**调试**，因为我们将在调试模式下运行和测试Pong。
- en: Select **Linker** and then **Input**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**链接器**然后选择**输入**。
- en: Find the `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`.
    Be extra careful to place the cursor exactly at the start of the edit box's current
    content so that you don't overwrite any of the text that is already there.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`。请格外小心地将光标放在编辑框当前内容的起始位置，以免覆盖任何已经存在的文本。
- en: Click **OK**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: Click **Apply** and then **OK**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**然后**确定**。
- en: Now, we need to copy the SFML `.dll` files into the main project directory.
    My main project directory is `D:\VS Projects\Pong`. It was created by Visual Studio
    in the previous steps. If you put your `VS Projects` folder somewhere else, then
    perform this step there instead. The files we need to copy into the project folder
    are located in our `SFML\bin` folder. Open a window for each of the two locations
    and highlight all the files in the `SFML\bin` folder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将SFML `.dll`文件复制到主项目目录中。我的主项目目录是`D:\VS Projects\Pong`。这是在之前的步骤中由Visual
    Studio创建的。如果你将`VS Projects`文件夹放在了其他位置，那么请在此处执行此步骤。我们需要复制到项目文件夹中的文件位于我们的`SFML\bin`文件夹中。为这两个位置打开一个窗口，并突出显示`SFML\bin`文件夹中的所有文件。
- en: Now, copy and paste the highlighted files into the project folder, that is,
    `D:\VS Projects\Pong`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将突出显示的文件复制并粘贴到项目文件夹中，即`D:\VS Projects\Pong`。
- en: We now have the project properties configured and ready to go.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经配置好了项目属性，并准备就绪。
- en: We will be displaying some text for a HUD (Heads Up Display) in this game that
    will show the player's score and remaining lives. For this, we need a font.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将显示一些文本用于 HUD（抬头显示），以显示玩家的得分和剩余生命。为此，我们需要一个字体。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Download this free-for-personal-use font from [http://www.dafont.com/theme.php?cat=302](http://www.dafont.com/theme.php?cat=302)
    and unzip the download. Or feel free to use a font of your choice. You will just
    need to make some minor changes to the code when we load the font.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://www.dafont.com/theme.php?cat=302](http://www.dafont.com/theme.php?cat=302)
    下载这个免费个人使用的字体并解压下载。或者你也可以自由选择你喜欢的字体。在我们加载字体时，你只需要对代码做一些小的修改。
- en: Create a new folder called `fonts` in the `VS Projects\Pong` folder and add
    the `DS-DIGIT.ttf` file into the `VS Projects\Pong\fonts` folder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `VS Projects\Pong` 文件夹中创建一个名为 `fonts` 的新文件夹，并将 `DS-DIGIT.ttf` 文件添加到 `VS Projects\Pong\fonts`
    文件夹中。
- en: We are now ready to code our first C++ class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好编写我们的第一个 C++ 类。
- en: Coding the Bat class
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Bat 类
- en: The simple Pong bat example was a good way of introducing the basics of classes.
    Classes can be simple and short, like the preceding `Bat` class, but they can
    also be longer and more complicated and contain other objects made from other
    classes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 Pong 球棒示例是介绍类的基本原理的好方法。类可以很简单且简短，就像前面的 `Bat` 类一样，但它们也可以更长更复杂，并包含由其他类创建的其他对象。
- en: When it comes to making games, there is a few vital things missing from the
    hypothetical `Bat` class. It might be fine for all these private member variables
    and public functions, but how will we draw anything? Our Pong bat needs a sprite,
    and in some games, they will also need a texture. Furthermore, we need a way to
    control the rate of animation of all our game objects, just like we did with the
    bee and the clouds in the previous project. We can include other objects in our
    class in exactly the same way that we included them in the `main.cpp` file. Let's
    code our `Bat` class for real so that we can see how we can solve all these issues.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到制作游戏时，假设的 `Bat` 类缺少一些至关重要的东西。对于所有这些私有成员变量和公共函数来说可能没问题，但我们如何绘制任何东西呢？我们的 Pong
    球棒需要一个精灵，在某些游戏中，它们还需要一个纹理。此外，我们需要一种方法来控制所有游戏对象的动画速率，就像我们在上一个项目中处理蜜蜂和云朵时做的那样。我们可以以与我们在
    `main.cpp` 文件中包含它们完全相同的方式在我们的类中包含其他对象。让我们真正编写我们的 `Bat` 类，以便我们可以看到如何解决所有这些问题。
- en: Coding Bat.h
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coding Bat.h
- en: To get started, we will code the header file. Right-click on `Bat.h`. Click
    the **Add** button. We are now ready to code the file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将编写头文件。右键点击 `Bat.h`。点击 **添加** 按钮。我们现在准备好编写文件了。
- en: 'Add the following code to `Bat.h`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Bat.h` 中：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, note the `#pragma once` declaration at the top of the file. This prevents
    the file from being processed by the compiler more than once. As our games get
    more complicated with perhaps dozens of classes, this will speed up compilation
    time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意文件顶部的 `#pragma once` 声明。这可以防止文件被编译器多次处理。随着我们的游戏变得越来越复杂，可能有几十个类，这将加快编译时间。
- en: Note the names of the member variables and the parameters and return types of
    the functions. We have a `Vector2f` called `m_Position`, which will hold the horizontal
    and vertical position of the player's bat. We also have an SFML `RectangleShape`,
    which will be the actual bat that appears on the screen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意成员变量的名称和函数的参数以及返回类型。我们有一个名为 `m_Position` 的 `Vector2f`，它将保存玩家球棒的水平和垂直位置。我们还有一个
    SFML 的 `RectangleShape`，它将是实际出现在屏幕上的球棒。
- en: There are two Boolean members that will track which direction, if any, the bat
    is currently moving in, and we have a `float` called `m_Speed` that tells us the
    number of pixels per second that the bat can move at when the player decides to
    move it left or right.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个布尔成员变量将跟踪球棒当前正在移动的方向（如果有的话），我们还有一个名为 `m_Speed` 的 `float`，它告诉我们当玩家决定将球棒向左或向右移动时，球棒每秒可以移动多少像素。
- en: The next part of the code needs some explanation since we have a function called
    `Bat`; this is the exact same name as the class. This is called a constructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分需要一些解释，因为我们有一个名为 `Bat` 的函数；这个名字与类的名字完全相同。这被称为构造函数。
- en: Constructor functions
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: When a class is coded, a special function is created by the compiler. We don't
    see this function in our code, but it is there. It is called a constructor. It
    is the function that would have been called if we used our hypothetical `Bat`
    class example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被编写时，编译器会创建一个特殊函数。我们在代码中看不到这个函数，但它确实存在。它被称为构造函数。如果使用了假设的 `Bat` 类示例，这将是一个会被调用的函数。
- en: When we need to write some code to prepare an object for use, often a good place
    to do this is in the constructor. When we want the constructor to do anything
    other than simply create an instance, we must replace the default (unseen) constructor
    provided by the compiler. This is what we will do with the `Bat` constructor function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要编写一些代码来准备一个对象以供使用时，通常一个好的地方是在构造函数中做这件事。当我们想让构造函数执行除了简单地创建实例之外的其他操作时，我们必须替换编译器提供的默认（未看到的）构造函数。这就是我们将要做的`Bat`构造函数。
- en: Notice that the `Bat` constructor takes two `float` parameters. This is perfect
    for initializing the position on the screen when we first create a `Bat` object.
    Also note that constructors have no return type, not even `void`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Bat`构造函数接受两个`float`参数。这非常适合在第一次创建`Bat`对象时初始化屏幕上的位置。另外，请注意构造函数没有返回类型，甚至不是`void`。
- en: We will soon use the constructor function, `Bat`, to put this game object into
    its starting position. Remember that this function is called at the time that
    an object of the `Bat` type is declared.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将使用构造函数`Bat`将这个游戏对象放置到起始位置。记住，这个函数是在声明`Bat`类型的对象时调用的。
- en: Continuing with the Bat.h explanation
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续解释Bat.h
- en: Next is the `getPosition` function, which returns a `FloatRect`, the four points
    that define a rectangle. Then, we have `getShape`, which returns a `RectangleShape`.
    This will be used so that we can return to the main game loop,  `m_Shape`, so
    that it can be drawn.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`getPosition`函数，它返回一个`FloatRect`，定义矩形的四个点。然后，我们有`getShape`，它返回一个`RectangleShape`。这将用于返回到主游戏循环`m_Shape`，以便它可以被绘制。
- en: We also have the `moveLeft`, `moveRight`, `stopLeft`, and `stopRight` functions,
    which are for controlling if, when, and in which direction the bat will be in
    motion.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`moveLeft`、`moveRight`、`stopLeft`和`stopRight`函数，这些函数用于控制蝙蝠何时以及朝哪个方向移动。
- en: Finally, we have the `update` function, which takes a `Time` parameter. This
    function will be used to calculate how to move the bat each frame. As a bat and
    a ball will both move quite differently to each other, it makes sense to encapsulate
    the movement code inside the class. We will call the `update` function once each
    frame of the game from the `main` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`update`函数，它接受一个`Time`参数。这个函数将用于计算每一帧如何移动蝙蝠。由于蝙蝠和球将彼此移动得相当不同，因此将移动代码封装在类中是有意义的。我们将从`main`函数中每帧调用一次`update`函数。
- en: Tip
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can probably guess that the `Ball` class will also have an `update` function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能猜到`Ball`类也将有一个`update`函数。
- en: Now, we can code `Bat.cpp`, which will implement all the definitions and use
    the member variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写`Bat.cpp`，它将实现所有定义并使用成员变量。
- en: Coding Bat.cpp
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Bat.cpp
- en: Let's create the file, and then we can start discussing the code. Right-click
    the `Bat.cpp` in the **Name:** field. Click the **Add** button and our new file
    will be created for us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建文件，然后我们可以开始讨论代码。在**名称**字段中右键点击`Bat.cpp`。点击**添加**按钮，我们的新文件就会为我们创建。
- en: We will divide the code for this file into two parts to make discussing it simpler.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个文件的代码分成两部分，以便更容易讨论。
- en: 'First, code the `Bat` constructor function, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写`Bat`构造函数，如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we can see that we include the `bat.h` file. This makes
    all the functions and variables that were declared previously in `bat.h` available
    to us.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们包含了`bat.h`文件。这使得之前在`bat.h`中声明的所有函数和变量都对我们可用。
- en: We implement the constructor because we need to do some work to get the instance
    set up, and the default unseen empty constructor provided by the compiler is not
    sufficient. Remember that the constructor is the code that runs when we initialize
    an instance of `Bat`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现构造函数是因为我们需要做一些工作来设置实例，而编译器提供的默认未看到的空构造函数是不够的。记住，构造函数是在我们初始化`Bat`实例时运行的代码。
- en: Notice that we use the `Bat::Bat` syntax as the function name to make it clear
    we are using the `Bat` function from the `Bat` class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Bat::Bat`语法作为函数名，以使其清楚我们正在使用`Bat`类中的`Bat`函数。
- en: This constructor receives two `float` values, `startX` and `startY`. The next
    thing that happens is we assign these values to `m_Position.x` and `m_Position.y`.
    The `Vector2f` named `m_Position` now holds the values that were passed in, and
    because `m_Position` is a member variable, these values are accessible throughout
    the class. Note, however, that `m_Position` was declared as `private` and will
    not accessible in our `main` function file—not directly, anyway. We will see how
    we can resolve this issue soon.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数接收两个 `float` 值，`startX` 和 `startY`。接下来发生的事情是我们将这些值分配给 `m_Position.x` 和
    `m_Position.y`。名为 `m_Position` 的 `Vector2f` 现在持有传递的值，因为 `m_Position` 是成员变量，所以这些值在整个类中都是可访问的。然而，请注意，`m_Position`
    被声明为 `private`，因此在我们的 `main` 函数文件中不可访问——至少不是直接访问。我们很快就会看到如何解决这个问题。
- en: Finally, in the constructor, we initialize the `RectangleShape` called `m_Shape`
    by setting its size and position. This is different to how we coded the hypothetical
    `Bat` class in the *The theory of a Pong Bat* section. The SFML `Sprite` class
    has convenient variables for size and position that we can access using the `setSize`
    and `setPosition` functions, so we don't need the hypothetical `m_Length` and
    `m_Height` anymore.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在构造函数中，我们通过设置其大小和位置来初始化名为 `m_Shape` 的 `RectangleShape`。这与我们在 *《乒乓球拍理论》* 部分中编写的假设
    `Bat` 类的方式不同。SFML 的 `Sprite` 类提供了方便的大小和位置变量，我们可以使用 `setSize` 和 `setPosition` 函数来访问它们，因此我们不再需要假设的
    `m_Length` 和 `m_Height`。
- en: Furthermore, note that we will need to vary how we initialize the `Bat` class
    (compared to the hypothetical `Bat` class) to suit our custom constructor.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们需要调整初始化 `Bat` 类的方式（与假设的 `Bat` 类相比），以适应我们的自定义构造函数。
- en: 'We need to implement the remaining five functions of the `Bat` class. Add the
    following code to `Bat.cpp` after the constructor we just discussed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现 `Bat` 类剩余的五个函数。在我们刚刚讨论的构造函数之后，将以下代码添加到 `Bat.cpp` 中：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's go through the code we have just added.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们刚刚添加的代码。
- en: First, we have the `getPosition` function. All it does is return a `FloatRect`
    to the code that called it. The `m_Shape.getGlobalBounds` line of code returns
    a `FloatRect` that is initialized with the coordinates of the four corners of
    the `RectangleShape`, that is, `m_Shape`. We will call this function from the
    `main` function when we are determining whether the ball has hit the bat.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `getPosition` 函数。它所做的只是返回一个 `FloatRect` 给调用它的代码。代码行 `m_Shape.getGlobalBounds`
    返回一个 `FloatRect`，该 `FloatRect` 使用 `RectangleShape`（即 `m_Shape`）四个角坐标进行初始化。当我们确定球是否击中球拍时，我们将从这个函数中调用
    `main` 函数。
- en: Next, we have the `getShape` function. All this function does is pass a copy
    of `m_Shape` to the calling code. This is necessary so that we can draw the bat
    in the `main` function. When we code a public function with the sole purpose of
    passing back private data from a class, we call it a getter function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `getShape` 函数。这个函数所做的只是将 `m_Shape` 的副本传递给调用代码。这是必要的，这样我们就可以在 `main`
    函数中绘制球拍。当我们编写一个仅用于从类中返回私有数据的公共函数时，我们称之为getter函数。
- en: Now, we can look at the `moveLeft`, `moveRight`, `stopLeft`, and `stopRight`
    functions. All they do is set the `m_MovingLeft` and `m_MovingRight` Boolean variables
    appropriately so that they keep track of the player's current intentions. Note,
    however, that they don't do anything to the `RectangleShape` instance or the `FloatRect`
    instance that determine the position. This is just what we need.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看 `moveLeft`、`moveRight`、`stopLeft` 和 `stopRight` 函数。它们所做的只是适当地设置 `m_MovingLeft`
    和 `m_MovingRight` 布尔变量，以便跟踪玩家的当前意图。然而，请注意，它们对确定位置的 `RectangleShape` 实例或 `FloatRect`
    实例没有任何操作。这正是我们所需要的。
- en: The last function in the `Bat` class is `update`. We will call this function
    once per frame of the game. The `update` function will grow in complexity as our
    game projects get more complicated. For now, all we need to do is tweak `m_Position`,
    depending on whether the player is moving left or right. Note that the formula
    that's used to do this tweak is the same one that we used for updating the bee
    and the clouds in the Timber!!! project. The code multiplies the speed by the
    delta time and then adds or subtracts it from the position. This causes the bat
    to move relative to how long the frame took to update. Next, the code sets the
    position of `m_Shape` with whatever the latest values held in `m_Position` happen
    to be.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bat`类中的最后一个函数是`update`。我们将每帧调用这个函数一次。随着我们的游戏项目变得更加复杂，`update`函数的复杂度将增加。目前，我们只需要根据玩家是否向左或向右移动来调整`m_Position`。请注意，用于此调整的公式与我们用于Timber!!!项目中更新蜜蜂和云的公式相同。代码将速度乘以delta时间，然后从位置中添加或减去它，这使得蝙蝠相对于帧更新所需的时间移动。接下来，代码使用`m_Position`中保存的最新值设置`m_Shape`的位置。'
- en: Having an `update` function in our `Bat` class rather than the `main` function
    is encapsulation. Rather than updating the positions of all the game objects in
    the `main` function like we did in the Timber!!! project, each object will be
    responsible for updating themselves. As we will do next, however, we will call
    this `update` function from the `main` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Bat`类中有一个`update`函数，而不是在`main`函数中，这是一种封装。我们不像在Timber!!!项目中那样在`main`函数中更新所有游戏对象的位置，每个对象将负责更新自己。然而，接下来我们将从`main`函数中调用这个`update`函数。
- en: Using the Bat class and coding the main function
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Bat`类和编写主函数
- en: Switch to the `main.cpp` file that was automatically generated when we created
    the project. Delete all its auto-generated code and add the code that follows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到当我们创建项目时自动生成的`main.cpp`文件。删除所有自动生成的代码，并添加以下代码。
- en: 'Code the `Pong.cpp` file as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编写`Pong.cpp`文件：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, the structure is similar to the one we used in the Timber!!!
    project. The first exception, however, is when we create an instance of the `Bat`
    class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，结构与我们用于Timber!!!项目的结构相似。然而，第一个例外是我们创建`Bat`类的实例时：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code calls the constructor function to create a new instance of
    the `Bat` class. The code passes in the required arguments and allows the `Bat`
    class to initialize its position in the center of the screen near the bottom.
    This is the perfect position for our bat to start.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用构造函数来创建`Bat`类的新实例。代码传递所需的参数并允许`Bat`类将其位置初始化在屏幕中央靠近底部。这是我们球拍开始的最佳位置。
- en: 'Also note that I have used comments to indicate where the rest of the code
    will eventually be placed. It is all within the game loop, just like it was in
    the Timber!!! project. Here is where the rest of the code will go again, just
    to remind you:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我已经使用注释来指示其余代码最终将被放置的位置。所有这些都在游戏循环中，就像在Timber!!!项目中一样。以下是将放置其余代码的位置，仅供参考：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the code to the `Handle the player input` section, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到`处理玩家输入`部分：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code handles the player quitting the game by pressing the *Escape*
    key, exactly like it did in the Timber!!! project. Next, there are two `if` –
    `else` structures that handle the player moving the bat. Let''s analyze the first
    of these two structures:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码通过按下*Escape*键处理玩家退出游戏的情况，这与Timber!!!项目中的做法完全一样。接下来，有两个`if` – `else`结构来处理玩家移动球拍。让我们分析这两个结构中的第一个：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code will detect whether the player is holding down the left arrow
    cursor key on the keyboard. If they are, then the `moveLeft` function is called
    on the `Bat` instance. When this function is called, the `true` value is set to
    the `m_MovingLeft` private Boolean variable. If, however, the left arrow key is
    not being held down, then the `stopLeft` function is called and the `m_MovingLeft`
    is set to `false`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将检测玩家是否按下了键盘上的左箭头光标键。如果是，则对`Bat`实例调用`moveLeft`函数。当这个函数被调用时，`true`值被设置为`m_MovingLeft`私有布尔变量。如果左箭头键没有被按下，则调用`stopLeft`函数并将`m_MovingLeft`设置为`false`。
- en: The exact same process is then repeated in the next `if` – `else` block of code
    to handle the player pressing (or not pressing) the right arrow key.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在下一个`if` – `else`代码块中重复上述过程来处理玩家按下（或未按下）右箭头键。
- en: 'Next, add the following code to the `Update the bat the ball and the HUD` section,
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到“更新蝙蝠、球和HUD”部分，如下所示：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we use the exact same timing technique that we used for
    the Timber!!! project, only this time, we call `update` on the `Bat` instance
    and pass in the delta time. Remember that, when the `Bat` class receives the delta
    time, it will use the value to move the bat based on the previously received movement
    instructions from the player and the desired speed of the bat.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了与Timber!!!项目相同的精确计时技术，但这次我们在`Bat`实例上调用`update`并传入delta时间。记住，当`Bat`类接收到delta时间时，它将使用该值根据之前从玩家接收到的移动指令和蝙蝠的期望速度来移动蝙蝠。
- en: 'Next, add the following code to the `Draw the bat, the ball and the HUD` section,
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到“绘制蝙蝠、球和HUD”部分，如下所示：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we clear the screen, draw the text for the HUD, and use
    the `bat.getShape` function to grab the `RectangleShape` instance from the `Bat`
    instance and draw it to the screen. Finally, we call `window.display`, just like
    we did in the previous project, to draw the bat in its current position.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们清空了屏幕，绘制了HUD的文本，并使用`bat.getShape`函数从`Bat`实例中获取`RectangleShape`实例并将其绘制到屏幕上。最后，我们调用`window.display`，就像我们在上一个项目中做的那样，以在当前位置绘制蝙蝠。
- en: 'At this stage, you can run the game and you will see the HUD and a bat. The
    bat can be moved smoothly left and right using the arrow/cursor keys:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以运行游戏，你会看到HUD和一只蝙蝠。你可以使用箭头/光标键平滑地左右移动蝙蝠：
- en: '![](img/Image86209.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image86209.jpg)'
- en: Congratulations! That is the first class, all coded and deployed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是第一个类，已经全部编写并部署。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered the basics of OOP, such as how to code and use
    a class, including making use of encapsulation to control how code outside of
    our classes can access the member variables, but only to the extent and in the
    manner that we want it to. This is just like SFML classes, which allow us to create
    and use `Sprite` and `Text` instances, but only in the way they were designed
    to be used.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了OOP的基础知识，例如如何编码和使用类，包括利用封装来控制外部代码如何访问我们的成员变量，但仅限于我们希望的方式和程度。这就像SFML类一样，允许我们创建和使用`Sprite`和`Text`实例，但只能按照它们设计的方式使用。
- en: Don't concern yourself too much if some of the details around OOP and classes
    are not entirely clear. The reason I say this is because we will spend the rest
    of this book coding classes and the more we use them, the clearer they will become.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关于OOP和类的一些细节不是很清楚，请不要过于担心。我之所以这么说，是因为我们将在这本书的剩余部分编写类，并且我们使用得越多，它们就会变得越清晰。
- en: Furthermore, we have a working bat and a HUD for our Pong game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一个正在工作的蝙蝠和我们的Pong游戏的HUD。
- en: In the next chapter, we will code the `Ball` class and get it bouncing around
    the screen. We will then be able to add collision detection and finish the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写`Ball`类并使其在屏幕上弹跳。然后我们可以添加碰撞检测并完成游戏。
- en: FAQ
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) I have learned other languages and OOP seems much simpler in C++. Is this
    a correct assessment?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我已经学习了其他语言，并且感觉C++中的OOP要简单得多。这种评估是正确的吗？
- en: A) This was an introduction to OOP and its basic fundamentals. There is more
    to it than this. We will learn about more OOP concepts and details throughout
    this book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: A) 这是对OOP及其基本原理的介绍。这只是一个开始。在这本书中，我们将学习更多关于OOP的概念和细节。
