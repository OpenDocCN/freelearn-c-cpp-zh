- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Modern Vulkan
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现代 Vulkan
- en: The goal of this chapter is to show you how to render a scene that accepts input
    information, such as textures and uniform data, from the application side. This
    chapter will cover advanced topics in the Vulkan API that build upon the core
    concepts discussed in the previous chapter and present all the information you
    need to render complex scenes, along with newer features of the API. Additionally,
    the chapter will demonstrate techniques to enhance the rendering speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您展示如何渲染从应用程序端接受输入信息（如纹理和统一数据）的场景。本章将涵盖 Vulkan API 的高级主题，这些主题基于上一章讨论的核心概念，并提供了渲染复杂场景所需的所有信息，以及
    API 的新功能。此外，本章还将演示提高渲染速度的技术。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding Vulkan’s memory model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Vulkan 的内存模型
- en: Instantiating the VMA library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化 VMA 库
- en: Creating buffers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建缓冲区
- en: Uploading data to buffers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据上传到缓冲区
- en: Creating a staging buffer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建阶段缓冲区
- en: How to avoid data races using ring buffers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用环形缓冲区避免数据竞争
- en: Setting up pipeline barriers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置管道屏障
- en: Creating images (textures)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像（纹理）
- en: Creating an image view
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像视图
- en: Creating a sampler
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建采样器
- en: Providing shader data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供着色器数据
- en: Customizing shader behavior with specialization constants
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用常量自定义着色器行为
- en: Implementing MDI and PVP
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MDI 和 PVP
- en: Adding flexibility to the rendering pipeline using dynamic rendering
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态渲染增强渲染管道的灵活性
- en: Transferring resources between queue families
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在队列家族之间传输资源
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Basic familiarity with the C++ programming language and an
    understanding of OpenGL or any other graphics API will be useful. Please revisit
    [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan Core Concepts*, under
    the *Technical requirements* section for details on setting up and building executables
    for this chapter. The recipe for this chapter can be run by launching `Chapter02_MultiDrawIndirect.exe`
    executable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要确保已安装 VS 2022 以及 Vulkan SDK。对 C++ 编程语言的基本熟悉程度以及对 OpenGL 或任何其他图形 API
    的理解将很有用。请查阅 *技术要求* 部分的 [*第 1 章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan 核心概念*，以获取有关设置和构建本章可执行文件的详细信息。可以通过启动
    `Chapter02_MultiDrawIndirect.exe` 可执行文件来运行本章的食谱。
- en: Understanding Vulkan’s memory model
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Vulkan 的内存模型
- en: Memory allocation and management are crucial in Vulkan, as almost none of the
    details of memory usage are managed by Vulkan. Except for deciding the exact memory
    address where memory should be allocated, all other details are the responsibility
    of the application. This means the programmer must manage memory types, their
    sizes, and alignments, as well as any sub-allocations. This approach gives applications
    more control over memory management and allows developers to optimize their programs
    for specific uses. This recipe will provide some fundamental information about
    the types of memory provided by the API as well as a summary of how to allocate
    and bind that memory to resources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，内存分配和管理至关重要，因为几乎所有的内存使用细节都不由 Vulkan 管理。除了决定内存分配的确切内存地址外，所有其他细节都是应用程序的责任。这意味着程序员必须管理内存类型、它们的大小和对齐方式，以及任何子分配。这种方法使应用程序对内存管理有更多的控制权，并允许开发者为特定用途优化他们的程序。本食谱将提供一些关于
    API 提供的内存类型的基本信息，以及如何分配和绑定该内存到资源的摘要。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Graphics cards come in two variants, integrated and discrete. Integrated graphics
    cards share the same memory as the CPU, as shown in *Figure 2**.1*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图形卡有两种类型，集成和独立。集成显卡与 CPU 共享相同的内存，如图 *图 2.1* 所示：
- en: "![\uFEFFFigure 2.1 – Typical memory architecture for discrete graphics cards](img/B18491_02_01.jpg)"
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 独立显卡的典型内存架构](img/B18491_02_01.jpg)'
- en: Figure 2.1 – Typical memory architecture for discrete graphics cards
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 独立显卡的典型内存架构
- en: 'Discrete graphics cards have their own memory (device memory) separate from
    the main memory (host memory), as shown in *Figure 2**.2*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 独立显卡有自己的内存（设备内存），与主内存（主机内存）分开，如图 *图 2.2* 所示：
- en: "![F\uFEFFigure 2.2 – Typical memory architecture for integrated graphics cards](img/B18491_02_02.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 集成显卡的典型内存架构](img/B18491_02_02.jpg)'
- en: Figure 2.2 – Typical memory architecture for integrated graphics cards
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 集成显卡的典型内存架构
- en: 'Vulkan provides different types of memory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan提供了不同类型的内存：
- en: '**Device-local memory**: This type of memory is optimized for use by the GPU
    and is local to the device. It is typically faster than host-visible memory but
    is not accessible from the CPU. Usually, resources such as render targets, storage
    images, and buffers are stored in this memory.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备本地内存**：这种类型的内存针对GPU使用进行了优化，并且是设备本地的。它通常比主机可见内存要快，但不能从CPU访问。通常，资源如渲染目标、存储图像和缓冲区都存储在这种内存中。'
- en: '**Host-visible memory**: This type of memory is accessible from both the GPU
    and the CPU. It is typically slower than device-local memory but allows for efficient
    data transfer between the GPU and CPU. Reads from GPU to CPU happen across **Peripheral
    Component Interconnect Express** (**PCI-E**) lanes in the case of non-integrated
    GPU. It’s typically used to set up staging buffers, where data is stored before
    being transferred to device-local memory, and uniform buffers, which are constantly
    updated from the application.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机可见内存**：这种类型的内存可以从GPU和CPU访问。它通常比设备本地内存要慢，但允许在GPU和CPU之间进行高效的数据传输。在非集成GPU的情况下，从GPU到CPU的读取发生在**外围组件互连扩展**（**PCI-E**）通道上。它通常用于设置暂存缓冲区，其中数据在传输到设备本地内存之前被存储，以及统一缓冲区，这些缓冲区由应用程序不断更新。'
- en: '**Host-coherent memory**: This type of memory is like host-visible memory but
    provides guaranteed memory consistency between the GPU and CPU. This type of memory
    is typically slower than both device-local and host-visible memory but is useful
    for storing data that needs to be frequently updated by both the GPU and CPU.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机一致内存**：这种类型的内存类似于主机可见内存，但提供了GPU和CPU之间保证的内存一致性。这种类型的内存通常比设备本地和主机可见内存都要慢，但对于需要GPU和CPU频繁更新的数据存储很有用。'
- en: '*Figure 2**.3* summarizes the three aforementioned types of memory. Device-local
    memory is not visible from the host, while host-coherent and host-visible are.
    Copying data from the CPU to the GPU can be done using mapped memory for those
    two types of memory allocations. For device-local memory, it’s necessary to copy
    the data from the CPU to host-visible memory first using mapped memory (the staging
    buffer), and then perform a copy of the data from the staging buffer to the destination,
    the device-local memory, using a Vulkan function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.3*总结了上述三种内存类型。设备本地内存对主机不可见，而主机一致和主机可见的内存是可见的。对于这两种类型的内存分配，可以使用映射内存从CPU到GPU复制数据。对于设备本地内存，有必要首先使用映射内存（暂存缓冲区）将数据从CPU复制到主机可见内存，然后使用Vulkan函数从暂存缓冲区到目标（设备本地内存）复制数据：'
- en: '![Figure 2.3 – Types of memory and their visibility from the application in
    Vulkan](img/B18491_02_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – Vulkan中内存类型及其从应用中的可见性](img/B18491_02_03.jpg)'
- en: Figure 2.3 – Types of memory and their visibility from the application in Vulkan
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Vulkan中内存类型及其从应用中的可见性
- en: Images are usually device-local memory, as they have their own layout that isn’t
    readily interpretable by the application. Buffers can be of any one of the aforementioned
    types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图像通常是设备本地内存，因为它们有自己的布局，该布局不容易被应用程序解释。缓冲区可以是上述任何一种类型。
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'A typical workflow for creating and uploading data to a buffer includes the
    following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并上传数据到缓冲区的典型工作流程包括以下步骤：
- en: Create a buffer object of type `VkBuffer` by using the `VkBufferCreateInfo`
    structure and calling `vkCreateBuffer`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`VkBufferCreateInfo`结构体并调用`vkCreateBuffer`来创建一个类型为`VkBuffer`的缓冲区对象。
- en: Retrieve the memory requirements based on the buffer’s properties by calling
    `vkGetBufferMemoryRequirements`. The device may require a certain alignment, which
    could affect the necessary size of the allocation to accommodate the buffer’s
    contents.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`vkGetBufferMemoryRequirements`根据缓冲区的属性检索内存需求。设备可能需要特定的对齐方式，这可能会影响分配所需的大小以容纳缓冲区的内容。
- en: Create a structure of type `VkMemoryAllocateInfo`, specify the size of the allocation
    and the type of memory, and call `vkAllocateMemory`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`VkMemoryAllocateInfo`的结构体，指定分配的大小和内存类型，并调用`vkAllocateMemory`。
- en: Call `vkBindBufferMemory` to bind the allocation with the buffer object.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`vkBindBufferMemory`将分配与缓冲区对象绑定。
- en: If the buffer is visible from the host, map a pointer to the destination with
    `vkMapMemory`, copy the data, and unmap the memory with `vkUnmapMemory`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果缓冲区对主机可见，使用`vkMapMemory`将指针映射到目标，复制数据，然后使用`vkUnmapMemory`取消映射内存。
- en: If the buffer is a device-local buffer, copy the data to a staging buffer first,
    then perform the final copy from the staging buffer to the device-local memory
    using the `vkCmdCopyBuffer` function.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果缓冲区是设备本地缓冲区，首先将数据复制到阶段缓冲区，然后使用`vkCmdCopyBuffer`函数从阶段缓冲区到设备本地内存执行最终复制。
- en: As you can see, that’s a complex procedure that can be simplified by using the
    VMA library, an open source library that provides a convenient and efficient way
    to manage memory in Vulkan. It offers a high-level interface that abstracts the
    complex details of memory allocation, freeing you from the burden of manual memory
    management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个可以通过使用VMA库来简化的复杂过程，VMA库是一个开源库，它提供了一个方便且高效的方式来管理Vulkan中的内存。它提供了一个高级接口，抽象了内存分配的复杂细节，让您免于手动内存管理的负担。
- en: Instantiating the VMA library
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化VMA库
- en: To use VMA, you first need to create an instance of the library and store a
    handle in a variable of type `VmaAllocator`. To create one, you need a Vulkan
    physical device and a device.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用VMA，您首先需要创建库的实例，并将句柄存储在类型为`VmaAllocator`的变量中。要创建一个实例，您需要一个Vulkan物理设备和设备。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Creating a VMA library instance requires instancing two different structures.
    One stores pointers to API functions that VMA needs to find other function pointers
    and another structure that provides a physical device, a device, and an instance
    for creating an allocator:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建VMA库实例需要实例化两个不同的结构。一个存储VMA需要找到的其他函数指针的API函数指针，另一个结构提供物理设备、设备和实例以创建分配器：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The allocator needs pointers to a few Vulkan functions so that it can work based
    on the features you would like to use. In the preceding case, we provide only
    the bare minimum for allocating and deallocating memory. The allocator needs to
    be freed once the context is destroyed with `vmaDestroyAllocator`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器需要指向几个Vulkan函数的指针，以便它可以根据您希望使用的功能进行工作。在前面的例子中，我们只为分配和释放内存提供了最基本的内容。在上下文被销毁后，需要使用`vmaDestroyAllocator`释放分配器。
- en: Creating buffers
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建缓冲区
- en: A buffer in Vulkan is simply a contiguous block of memory that holds some data.
    The data can be vertex, index, uniform, and more. A buffer object is just metadata
    and does not directly contain data. The memory associated with a buffer is allocated
    after a buffer has been created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，缓冲区只是一个连续的内存块，用于存储一些数据。数据可以是顶点、索引、均匀的，等等。缓冲区对象只是元数据，并不直接包含数据。与缓冲区关联的内存是在创建缓冲区之后分配的。
- en: '*Table 2.1* summarizes the most important usage types of buffers and their
    access type:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*表2.1* 总结了缓冲区最重要的使用类型及其访问类型：'
- en: '| **Buffer Type** | **Access Type** | **Uses** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **缓冲区类型** | **访问类型** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Vertex or Index | Read-only |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 顶点或索引 | 只读 |  |'
- en: '| Uniform | Read-only | Uniform data storage |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 均匀 | 只读 | 均匀数据存储 |'
- en: '| Storage | Read/write | Generic data storage |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | 读写 | 通用数据存储 |'
- en: '| Uniform texel | Read/write | Data is interpreted as texels |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 均匀纹理 | 读写 | 数据被解释为纹理元素 |'
- en: '| Storage texel | Read/write | Data is interpreted as texels |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 存储纹理 | 读写 | 数据被解释为纹理元素 |'
- en: Table 2.1 – Buffer types
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 缓冲区类型
- en: Creating buffers is easy, but it helps to know what types of buffers exist and
    what their requirements are before setting out to create them. In this chapter,
    we will provide a template for creating buffers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建缓冲区很容易，但在开始创建它们之前了解存在哪些类型的缓冲区及其要求是有帮助的。在本章中，我们将提供一个创建缓冲区的模板。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, Vulkan buffers are managed by the `VulkanCore::Buffer` class,
    which provides functions to create and upload data to the device, as well as a
    utility function to use a staging buffer to upload data to device-only heaps.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，Vulkan缓冲区由`VulkanCore::Buffer`类管理，该类提供了创建和上传数据到设备的功能，以及一个使用阶段缓冲区将数据上传到设备专用堆的实用函数。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Creating a buffer using VMA is simple:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VMA创建缓冲区很简单：
- en: 'All you need are buffer creation flags ( –a value of `0` for the flags is correct
    for most cases), the size of the buffer in bytes, its usage (this is how you define
    how the buffer will be used), and assign those values to an instance of the `VkBufferCreateInfo`
    structure:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您所需的所有内容是缓冲区创建标志（对于大多数情况，标志的值为`0`是正确的），缓冲区的大小（以字节为单位），其用途（这是您定义缓冲区如何使用的方式），并将这些值分配给`VkBufferCreateInfo`结构的实例：
- en: '[PRE1]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will also need a set of VmaAllocationCreateFlagBits values:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还需要一组VmaAllocationCreateFlagBits值：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, call `vmaCreateBuffer` to obtain the buffer handle and its allocation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`vmaCreateBuffer`以获取缓冲区句柄及其分配：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next step is optional but useful for debugging and optimization:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是可选的，但有助于调试和优化：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Some creation flags affect how the buffer can be used, so you might need to
    make adjustments to the preceding code depending on how you intend to use the
    buffers you create in your application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些创建标志会影响缓冲区的使用方式，因此您可能需要根据您打算在应用程序中使用的缓冲区进行调整：
- en: Uploading data to buffers
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据上传到缓冲区
- en: Uploading data from the application to the GPU depends on the type of buffer.
    For host-visible buffers, it’s a direct copy using `memcpy`. For device-local
    buffers, we need a staging buffer, which is a buffer that is visible both by the
    CPU and the GPU. In this recipe, we will demonstrate how to upload data from your
    application to the device-visible memory (into a buffer’s memory region on the
    device).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序上传数据到GPU取决于缓冲区的类型。对于主机可见缓冲区，它是一个使用`memcpy`的直接复制。对于设备本地缓冲区，我们需要一个阶段缓冲区，这是一个既对CPU又对GPU可见的缓冲区。在这个配方中，我们将演示如何将数据从您的应用程序上传到设备可见内存（到设备上缓冲区的内存区域）。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven’t already, please refer to the *Understanding Vulkan’s memory*
    *model* recipe.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有，请参考*理解Vulkan内存* *模型*配方。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The upload process depends on the type of buffer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上传过程取决于缓冲区的类型：
- en: For host-visible memory, it’s enough to retrieve a pointer to the destination
    using `vmaMapMemory` and copy the data using `memcpy`. The operation is synchronous,
    so the mapped pointer can be unmapped as soon as `memcpy` returns.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于主机可见内存，只需使用`vmaMapMemory`检索目标指针，并使用`memcpy`复制数据即可。该操作是同步的，因此一旦`memcpy`返回，就可以取消映射映射的指针。
- en: 'It’s fine to map a host-visible buffer as soon as it is created and leave it
    mapped until its destruction. That is the recommended approach, as you don’t incur
    the overhead of mapping the memory every time it needs to be updated:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建后立即映射主机可见缓冲区并在其销毁前保持映射是完全可以接受的。这是推荐的方法，因为您不需要每次更新内存时都映射内存的开销：
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Uploading data to a device-local memory needs to be (1) copied to a buffer
    that is visible from the host first (called a staging buffer) and then (2) copied
    from the staging buffer to the device-local memory using `vkCmdCopyBuffer`, as
    depicted in *Figure 2**.4*. Note that this requires a command buffer:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据上传到设备本地内存需要先（1）将其复制到一个主机可见的缓冲区（称为阶段缓冲区），然后（2）使用`vkCmdCopyBuffer`从阶段缓冲区复制到设备本地内存，如图*图2**.4*所示。请注意，这需要一个命令缓冲区：
- en: '![Figure 2.4 – Staging buffers](img/B18491_02_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 阶段缓冲区](img/B18491_02_04.jpg)'
- en: Figure 2.4 – Staging buffers
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 阶段缓冲区
- en: 'Once the data is residing on the device (on the host-visible buffer), copying
    it to the device-only buffer is simple:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据驻留在设备上（在主机可见缓冲区上），将其复制到设备专用缓冲区就很简单了：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Uploading data from your application to a buffer is accomplished either by a
    direct `memcpy` operation or by means of a staging buffer. We showed how to perform
    both uploads in this recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的应用程序到缓冲区的数据上传可以通过直接`memcpy`操作或通过阶段缓冲区完成。我们在本配方中展示了如何执行这两种上传。
- en: Creating a staging buffer
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建阶段缓冲区
- en: Creating a staging buffer is like creating a regular buffer but requires flags
    that specify that the buffer is host-visible. In this recipe, we will show how
    to create a buffer that can be used as a staging buffer – one that can be used
    as an intermediary destination of the data being uploaded from your application
    on its way to a device-local memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建阶段缓冲区就像创建常规缓冲区一样，但需要指定缓冲区是主机可见的标志。在本配方中，我们将展示如何创建一个可以作为阶段缓冲区使用的缓冲区——一个可以作为从您的应用程序上传到设备本地内存的数据的中间目标。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The *Creating buffers* recipe explains how to create buffers in general, while
    this recipe shows which flags and parameters you need to create a staging buffer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建缓冲区*配方解释了如何一般地创建缓冲区，而本配方展示了您需要哪些标志和参数来创建阶段缓冲区。'
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '`VkBufferCreateInfo::usage` needs to contain `VK_BUFFER_USAGE_TRANSFER_SRC_BIT`
    as it will be the source operation for a `vkCmdCopyBuffer` command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`VkBufferCreateInfo::usage`需要包含`VK_BUFFER_USAGE_TRANSFER_SRC_BIT`，因为它将是`vkCmdCopyBuffer`命令的源操作：'
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A staging buffer may be better implemented using a wrapper in your application.
    A wrapper can increase or decrease the size of the buffer as needed, for example.
    One staging buffer may be enough for your application, but you need to watch the
    requirements imposed by some architectures.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用应用程序中的包装器更好地实现阶段缓冲区。例如，包装器可以根据需要增加或减少缓冲区的大小。一个阶段缓冲区可能足以满足你的应用程序，但你需要关注某些架构提出的要求。
- en: How to avoid data races using ring buffers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用环形缓冲区避免数据竞争
- en: 'When a buffer needs to be updated every frame, we run the risk of creating
    a data race, as shown in *Figure 2**.5*. A data race is a situation where multiple
    threads within a program concurrently access a shared data point, with at least
    one thread performing a write operation. This concurrent access can result in
    unforeseen behavior due to the unpredictable order of operations. Take the example
    of a uniform buffer that stores the view, model, and viewport matrices and needs
    to be updated every frame. The buffer is updated while the first command buffer
    is being recorded, initializing it (version 1). Once the command buffer starts
    processing on the GPU, the buffer contains the correct data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个缓冲区需要每帧更新时，我们面临创建数据竞争的风险，如图*图2.5*所示。数据竞争是一种情况，其中程序内的多个线程同时访问一个共享数据点，至少有一个线程执行写操作。这种并发访问可能会由于操作顺序不可预测而导致不可预见的行为。以一个存储视图、模型和视口矩阵并需要每帧更新的统一缓冲区为例。当第一个命令缓冲区正在记录并初始化（版本1）时，缓冲区正在更新。一旦命令缓冲区开始在GPU上处理，缓冲区将包含正确的数据：
- en: '![Figure 2.5 – Data race when using one buffer](img/B18491_02_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 使用一个缓冲区时的数据竞争](img/B18491_02_05.jpg)'
- en: Figure 2.5 – Data race when using one buffer
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 使用一个缓冲区时的数据竞争
- en: After the first command buffer starts processing in the GPU, the application
    may try to update the buffer’s contents to version 2 while the GPU is accessing
    that data for rendering!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令缓冲区开始在GPU上处理之后，应用程序可能会尝试在GPU访问该数据用于渲染时更新缓冲区的内容到版本2！
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Synchronization is by far the hardest aspect of Vulkan. If synchronization elements
    such as semaphores, fences, and barriers are used too greedily, then your application
    becomes a series and won’t use the full power of the parallelism between the CPU
    and the GPU.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 同步无疑是Vulkan中最困难的部分。如果过度贪婪地使用同步元素，如信号量、栅栏和屏障，那么你的应用程序将变成一个序列，无法充分利用CPU和GPU之间的并行性。
- en: Make sure you also read the *Understanding synchronization in the swapchain
    – fences and semaphores* recipe in [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*,
    Vulkan Core Concepts*. That recipe and this one only scratch the surface of how
    to tackle synchronization, but are very good starting points.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你阅读了[*第1章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan核心概念*中的*理解swapchain中的同步
    – 栅栏和信号量*配方。这个配方和这个配方只是触及了如何处理同步的表面，但都是很好的起点。
- en: A ring-buffer implementation is provided in the `EngineCore::RingBuffer` repository,
    which has a configurable number of sub-buffers. Its sub-buffers are all host-visible,
    persistent buffers; that is, they are persistently mapped after creation for ease
    of access.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EngineCore::RingBuffer`存储库中提供了一个环形缓冲区实现，它具有可配置的子缓冲区数量。其子缓冲区都是主机可见的持久缓冲区；也就是说，它们在创建后持续映射，以便于访问。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'There are a few ways to avoid this problem, but the easiest one is to create
    a ring buffer that contains several buffers (or any other resource) equal to the
    number of frames in flight. *Figure 2**.6* shows events when there are two buffers
    available. Once the first command buffer is submitted and is being processed in
    the GPU, the application is free to process copy 1 of the buffer, as it’s not
    being accessed by the device:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以避免这个问题，但最简单的一种是创建一个包含多个缓冲区（或任何其他资源）的环形缓冲区，数量等于正在飞行的帧数。*图2.6*显示了有两个缓冲区可用的事件。一旦第一个命令缓冲区提交并在GPU上处理，应用程序就可以自由处理缓冲区的副本1，因为它没有被设备访问：
- en: '![Figure 2.6 – A data race is avoided with multiple copies of a resource](img/B18491_02_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 通过多个资源副本避免数据竞争](img/B18491_02_06.jpg)'
- en: Figure 2.6 – A data race is avoided with multiple copies of a resource
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 通过多个资源副本避免数据竞争
- en: 'Even though this is a simple solution, it has a caveat: if partial updates
    are allowed, care must be taken when the buffer is updated. Consider *Figure 2**.7*,
    in which a ring buffer that contains three sub-allocations is partially updated.
    The buffer stores the view, model, and viewport matrices. During initialization,
    all three sub-allocations are initialized to three identity matrices. On `(10,
    10, 0)`. On the next frame, **Frame 1**, **Buffer 1** becomes active, and the
    viewport matrix is updated. Because **Buffer 1** was initialized to three identity
    matrices, updating only the viewport matrix makes buffers **0** and **1** out
    of sync (as well as **Buffer 3**). To guarantee that partial updates work, we
    need to copy the last active buffer, **Buffer 0**, into **Buffer 1** first, and
    then update the viewport matrix:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的解决方案，但它有一个注意事项：如果允许部分更新，则在更新缓冲区时必须小心。考虑*图2**.7*，其中包含三个子分配的环形缓冲区被部分更新。该缓冲区存储视图、模型和视口矩阵。在初始化期间，所有三个子分配都被初始化为三个单位矩阵。在`(10,
    10, 0)`。在下一次帧中，**帧1**，**缓冲区1**变为活动状态，并且视口矩阵被更新。因为**缓冲区1**被初始化为三个单位矩阵，只更新视口矩阵会使**缓冲区0**和**缓冲区1**（以及**缓冲区3**）不同步。为了保证部分更新能够正常工作，我们需要首先将最后一个活动缓冲区**缓冲区0**复制到**缓冲区1**中，然后更新视口矩阵：
- en: '![Figure 2.7 – Partial update of a ring buffer makes all sub-allocations out
    of sync if they are not replicated](img/B18491_02_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 如果不复制，环形缓冲区的部分更新会使所有子分配不同步](img/B18491_02_07.jpg)'
- en: Figure 2.7 – Partial update of a ring buffer makes all sub-allocations out of
    sync if they are not replicated
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 如果不复制，环形缓冲区的部分更新会使所有子分配不同步
- en: Synchronization is a delicate topic, and guaranteeing your application behaves
    correctly with so many moving parts is tricky. Hopefully, a ring-buffer implementation
    that is simple may help you focus on other areas of the code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同步是一个微妙的话题，确保您的应用程序在这么多动态部分中表现正确是棘手的。希望一个简单的环形缓冲区实现可以帮助您专注于代码的其他区域。
- en: Setting up pipeline barriers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置管道屏障
- en: In Vulkan, commands may be reordered when a command buffer is being processed,
    subject to certain restrictions. This is known as command buffer reordering, and
    it can help to improve performance by allowing the driver to optimize the order
    in which commands are executed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，当命令缓冲区正在处理时，命令可能会被重新排序，但受到某些限制。这被称为命令缓冲区重新排序，它可以通过允许驱动程序优化命令执行的顺序来提高性能。
- en: The good news is that Vulkan provides a mechanism called pipeline barriers to
    ensure that dependent commands are executed in the correct order. They are used
    to explicitly specify dependencies between commands, preventing them from being
    reordered, and at what stages they might overlap. This recipe will explain what
    pipeline barriers are and what their properties mean. It will also show you how
    to create and install pipeline barriers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Vulkan提供了一个称为管道屏障的机制，以确保依赖命令按正确的顺序执行。它们用于显式指定命令之间的依赖关系，防止它们被重新排序，以及它们可能在哪些阶段重叠。本食谱将解释管道屏障是什么以及它们的属性意味着什么。它还将向您展示如何创建和安装管道屏障。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Consider two draw calls issued in sequence. The first one writes to a color
    attachment, while the second draw call samples from that attachment in the fragment
    shader:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑连续发出的两个绘制调用。第一个调用写入一个颜色附件，而第二个绘制调用在片段着色器中从该附件采样：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Figure 2**.8* helps visualize how those two commands may be processed by the
    device. In the diagram, commands are processed from top to bottom and progress
    on the pipeline from left to right. Clock cycles are a loose term, because processing
    may take multiple clock cycles, but are used to indicate that – in general – some
    tasks must happen after others.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.8*有助于可视化设备如何处理这两个命令。在图中，命令从上到下处理，并在管道中从左到右前进。时钟周期是一个宽泛的术语，因为处理可能需要多个时钟周期，但用来表示在一般情况下，某些任务必须在其他任务之后发生。'
- en: 'In the example, the second `vkCmdDraw` call starts executing at **C2**, after
    the first draw call. This offset is not enough, as the second draw call needs
    to read the color attachment at the **Fragment Shader** stage, which is not produced
    by the first draw call until it reaches the **Color Attach Output** stage. Without
    synchronization, this setup may cause data races:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，第二个`vkCmdDraw`调用在**C2**处开始执行，在第一个绘制调用之后。这个偏移量不足以满足第二个绘制调用在**片段着色器**阶段读取颜色附件的需求，这需要第一个绘制调用直到达到**颜色附件输出**阶段才能生成。如果没有同步，这种设置可能会导致数据竞争：
- en: '![Figure 2.8 – Two consecutive commands recorded on the same command buffer
    being processed without synchronization](img/B18491_02_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 同一个命令缓冲区上记录的两个连续命令，未进行同步处理](img/B18491_02_08.jpg)'
- en: Figure 2.8 – Two consecutive commands recorded on the same command buffer being
    processed without synchronization
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 同一个命令缓冲区上记录的两个连续命令，未进行同步处理
- en: A pipeline barrier is a feature that is recorded into the command buffer and
    that specifies the pipeline stages that need to have been completed for all commands
    that appear before the barrier and before the command buffer continues processing.
    Commands recorded before the barrier are said to be in the *first synchronization
    scope* or first scope. Commands recorded after the barrier are said to be part
    of the *second synchronization scope* or second scope.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 管道屏障是一个记录到命令缓冲区中的功能，它指定了需要在屏障之前和命令缓冲区继续处理之前完成所有命令的管道阶段。在屏障之前记录的命令被称为处于*第一个同步作用域*或第一个作用域。在屏障之后记录的命令被称为是*第二个同步作用域*或第二个作用域的一部分。
- en: The barrier also allows fine-grained control to specify at which stage commands
    after the barrier must wait until commands in the first scope finish processing.
    That’s because commands in the second scope don’t need to wait until commands
    in the first scope are done. They can start processing as soon as possible, as
    long as the conditions specified in the barrier are met.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该屏障还允许细粒度控制，以指定屏障之后的命令必须在哪个阶段等待，直到第一个作用域中的命令完成处理。这是因为第二个作用域中的命令不需要等待第一个作用域中的命令完成。只要满足屏障中指定的条件，它们就可以尽可能快地开始处理。
- en: 'In the example in *Figure 2**.8*, the first draw call, in the first scope,
    needs to write to the attachment before the second draw call can access it. The
    second draw call does not need to wait until the first draw call finishes processing
    the **Color Attach Output** stage. It can start right away, as long as its fragment
    stage happens after the first draw call is done with its **Color Attach Output**
    stage, as shown in *Figure 2**.9*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.8*的例子中，第一个绘制调用，在第一个作用域中，需要在第二个绘制调用可以访问它之前写入附件。第二个绘制调用不需要等待第一个绘制调用完成处理**颜色附件输出**阶段。它可以立即开始，只要它的片段阶段发生在第一个绘制调用完成其**颜色附件输出**阶段之后，如*图2.9*所示：
- en: '![Figure 2.9 – Two consecutive commands recorded on the same command buffer
    being processed with synchronization](img/B18491_02_09.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 同一个命令缓冲区上记录的两个连续命令，带有同步处理](img/B18491_02_09.jpg)'
- en: Figure 2.9 – Two consecutive commands recorded on the same command buffer being
    processed with synchronization
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 同一个命令缓冲区上记录的两个连续命令，带有同步处理
- en: 'There are three types of barriers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的屏障：
- en: '**Memory barriers** are global barriers and apply to all commands in the first
    and second scopes.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内存屏障**是全局屏障，适用于第一个和第二个作用域中的所有命令。'
- en: '**Buffer memory barriers** are barriers that apply only to commands that access
    a portion of the buffer, as it’s possible to specify to which portion of the buffer
    the barrier applies (offset + range).'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缓冲区内存屏障**是仅应用于访问缓冲区一部分的命令的屏障，因为可以指定屏障应用于缓冲区的哪一部分（偏移量 + 范围）。'
- en: '`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` layout, as it will be read from, while
    the next mip level needs to be in the `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` layout,
    as it will be written to.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`布局，因为它将被读取，而下一个mip级别需要处于`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`布局，因为它将被写入。'
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Pipeline barriers are recorded with the `vkCmdPipelineBarrier` command, in
    which you can provide several barriers of multiple types at the same time. The
    following code snippet shows how to create a barrier used to create a dependency
    between the two draw calls in *Figure 2**.9*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 管道屏障使用`vkCmdPipelineBarrier`命令进行记录，在该命令中，你可以同时提供多种类型的多个屏障。以下代码片段显示了如何创建用于在*图2.9*中的两个绘制调用之间创建依赖关系的屏障：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The barrier needs to be recorded between the two draw calls:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在两个绘制调用之间记录屏障：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pipeline barriers are tricky but absolutely fundamental in Vulkan. Make sure
    you understand what they offer and how they operate before continuing to read
    the other recipes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 管道屏障在Vulkan中很棘手，但绝对是基础性的。在继续阅读其他食谱之前，请确保你理解它们提供了什么以及它们是如何工作的。
- en: Creating images (textures)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像（纹理）
- en: Images are used for storing 1D, 2D, or 3D data, although they are mostly used
    for 2D data. Different than buffers, images have the advantage of being optimized
    for locality in memory layout. This is because most GPUs have a fixed-function
    texture unit or sampler that reads texel data from an image and applies filtering
    and other operations to produce a final color value. Images can have different
    formats, such as RGB, RGBA, BGRA, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图像用于存储 1D、2D 或 3D 数据，尽管它们主要用于 2D 数据。与缓冲区不同，图像在内存布局中具有优化局部性的优势。这是因为大多数 GPU 都有一个固定功能的纹理单元或采样器，它从图像中读取纹理数据，并应用过滤和其他操作以产生最终的色彩值。图像可以有不同的格式，例如
    RGB、RGBA、BGRA 等。
- en: 'An image object is only metadata in Vulkan. Its data is stored separately and
    is created in a similar manner to buffers (*Figure 2**.10*):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，图像对象仅是元数据。其数据是单独存储的，并且以类似于缓冲区的方式创建（*图 2**.10*）：
- en: '![Figure 2.10 – Images](img/B18491_02_10.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 图片](img/B18491_02_10.jpg)'
- en: Figure 2.10 – Images
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 图片
- en: Images in Vulkan cannot be accessed directly and need to be accessed only by
    means of an image view. An image view is a way to access a subset of the image
    data by specifying the subresource range, which includes the aspect (such as color
    or depth), the mip level, and the array layer range.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 中的图像不能直接访问，只能通过图像视图来访问。图像视图是通过指定子资源范围来访问图像数据子集的一种方式，该范围包括方面（如颜色或深度）、米柏级别和数组层范围。
- en: Another *very important* aspect of images is their layout. It is used to specify
    the intended usage of an image resource in Vulkan, such as whether it should be
    used as a source or destination for a transfer operation, a color or depth attachment
    for rendering, or as a shader read or write resource. The correct image layout
    is important because it ensures that the GPU can efficiently access and manipulate
    the image data in accordance with the intended usage. Using the wrong image layout
    can lead to performance issues or rendering artifacts and can result in undefined
    behavior. Therefore, it’s essential to correctly specify the image layout for
    each usage of an image in a Vulkan application. Common image layouts are undefined
    (`VK_IMAGE_LAYOUT_UNDEFINED`) color attachment (`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`),
    depth/stencil attachment (`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`),
    and shader read(`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`). Image layout transitions
    are done as part of the `vkCmdPipelineBarrier` command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的另一个**非常重要**的方面是它们的布局。它用于指定 Vulkan 中图像资源的预期用途，例如是否应将其用作传输操作的数据源或目标，渲染的颜色或深度附件，或作为着色器读取或写入资源。正确的图像布局非常重要，因为它确保
    GPU 可以根据预期用途高效地访问和操作图像数据。使用错误的图像布局可能导致性能问题或渲染伪影，并可能导致未定义的行为。因此，在 Vulkan 应用程序中为每个图像的使用正确指定图像布局是至关重要的。常见的图像布局包括未定义（`VK_IMAGE_LAYOUT_UNDEFINED`）、颜色附件（`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`）、深度/模板附件（`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`）和着色器读取（`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`）。图像布局转换作为
    `vkCmdPipelineBarrier` 命令的一部分进行。
- en: In this recipe, you will learn how to create images on a device.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何在设备上创建图像。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the `VulkanCore::Texture` class within our repository, we’ve encapsulated
    the intricate management of images and image views, offering a comprehensive solution
    for handling Vulkan textures. From facilitating efficient data uploads to handling
    transitions between image layouts and generating mipmaps, the `Texture` class
    equips us with the means to seamlessly integrate textures in the Vulkan examples.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仓库中的 `VulkanCore::Texture` 类中，我们封装了图像和图像视图的复杂管理，为处理 Vulkan 纹理提供了一个全面的解决方案。从促进高效的数据上传到处理图像布局之间的转换以及生成米柏（mipmap），`Texture`
    类为我们提供了在 Vulkan 示例中无缝集成纹理的手段。
- en: How to do it…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating an image requires some basic information about it, such as type (1D,
    2D, 3D), size, format (RGBA, BGRA, and so on), number of mip levels, number of
    layers (faces for cubemaps), and a few others:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像需要一些关于它的基本信息，例如类型（1D、2D、3D）、大小、格式（RGBA、BGRA 等）、米柏级别数量、层数（立方体贴图的表面）、以及其他一些信息：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following structure tells VMA that the image will be a device-only image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结构告诉 VMA，该图像将是一个仅设备的图像：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting image’s handle will be stored in `image`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像的句柄将存储在 `image` 中：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step is optional but useful for debugging or optimizing the code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是可选的，但有助于调试或优化代码：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This recipe only showed you how to create an image in Vulkan, not how to upload
    data to it. Uploading data to an image is just like uploading data to a buffer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱仅向您展示了如何在 Vulkan 中创建图像，但没有展示如何将其数据上传。将数据上传到图像就像上传到缓冲区一样。
- en: Creating an image view
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像视图
- en: Image views provide a way to interpret images in terms of size, location, and
    format, except in terms of their layout, which needs to be transformed explicitly
    and transitioned using image barriers. In this recipe, you will learn how to create
    an image view object in Vulkan.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图提供了一种以大小、位置和格式解释图像的方法，除了它们的布局之外，布局需要显式转换并使用图像屏障进行转换。在本食谱中，您将学习如何在 Vulkan
    中创建图像视图对象。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Image views are stored and managed by the `VulkanCore::Texture` class in the
    repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，图像视图由 `VulkanCore::Texture` 类存储和管理。
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Creating an image view is easy; all you need is the handle of the image it
    is associated with and the region of the image that you would like to represent:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像视图很简单；您只需要该图像的句柄以及您想要表示的图像区域：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Without an image view, a texture cannot be used by shaders. Even when used as
    color attachments, images need image views.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 没有图像视图，着色器无法使用纹理。即使用作颜色附件，图像也需要图像视图。
- en: Creating a sampler
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建采样器
- en: A sampler in Vulkan transcends a simple object; it’s a crucial bridge between
    shader execution and image data. Beyond interpolation, it governs filtering, addressing
    modes, and mipmapping. Filters dictate interpolation between texels, while addressing
    modes control how coordinates map to image extents. Anisotropic filtering further
    enhances sampling fidelity. Mipmapping, a pyramid of downsampled image levels,
    is another facet managed by samplers. In essence, creating a sampler involves
    orchestrating these attributes to seamlessly harmonize image data and shader intricacies.
    In this recipe, you will learn how to create a sampler object in Vulkan.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 中的采样器超越了简单对象；它是着色器执行和图像数据之间的重要桥梁。除了插值之外，它还控制过滤、寻址模式和米级映射。过滤器指定了纹理元素之间的插值，而寻址模式控制坐标如何映射到图像范围。各向异性过滤进一步增强了采样精度。米级映射，即下采样图像级别的金字塔，是采样器管理的另一个方面。本质上，创建采样器涉及协调这些属性，以无缝地协调图像数据和着色器的复杂性。在本食谱中，您将学习如何在
    Vulkan 中创建采样器对象。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Samplers are implemented by the `VulkanCore::Sampler` class in the repository.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器由仓库中的 `VulkanCore::Sampler` 类实现。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The properties of a sampler define how an image is interpreted in the pipeline,
    usually in a shader. The process is simple – instantiate a `VkSamplerCreateInfo`
    structure and call `vkCreateSampler`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器的属性定义了图像在管道中的解释方式，通常在着色器中。过程很简单 - 实例化一个 `VkSamplerCreateInfo` 结构，并调用 `vkCreateSampler`：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A sampler is one of the simplest objects to create in Vulkan and one of the
    easiest to understand, as it describes very common computer graphics concepts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器是 Vulkan 中创建的最简单的对象之一，也是最容易理解的，因为它描述了非常常见的计算机图形概念。
- en: Providing shader data
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供着色器数据
- en: Providing data from your application that will be used in shaders is one of
    the most convoluted aspects of Vulkan and requires several steps that need to
    be accomplished in the right order (and with the right parameters). In this recipe,
    with many smaller recipes, you will learn how to provide data used in shaders,
    such as textures, buffers, and samplers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的应用程序提供将在着色器中使用的数据是 Vulkan 最复杂的部分之一，需要完成多个步骤，这些步骤需要按正确的顺序（以及正确的参数）完成。在本食谱中，通过许多较小的食谱，您将学习如何提供用于着色器的数据，例如纹理、缓冲区和采样器。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Resources consumed by shaders are specified using the `layout` keyword, along
    with `set` and `binding` qualifiers:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `layout` 关键字以及 `set` 和 `binding` 限定符指定着色器消耗的资源：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each resource is represented by a binding. A set is a collection of bindings.
    One binding doesn’t necessarily represent just one resource; it can also represent
    an array of resources of the same type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都由一个绑定表示。一组是一组绑定的集合。一个绑定不一定只代表一个资源；它也可以代表同一类型的资源数组。
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Providing a resource as input to shaders is a multi-step process that involves
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将资源作为着色器的输入是一个多步骤的过程，涉及以下步骤：
- en: Specifying sets and their bindings using descriptor set layouts. This step doesn’t
    associate real resources with sets/bindings. It just specifies the number and
    types of bindings in a set.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用描述符集布局指定集合及其绑定。此步骤不会将实际资源与集合/绑定关联。它只是指定了集合中绑定数量和类型。
- en: Building a pipeline layout, which describes which sets will be used in a pipeline.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建管道布局，它描述了在管道中将使用哪些集合。
- en: Creating a descriptor pool that will provide instances of descriptor sets. A
    descriptor pool contains a list of how many bindings it can provide grouped by
    binding type (texture, sampler, **shader storage buffer** (**SSBO**), uniform
    buffers).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符池，它将提供描述符集的实例。描述符池包含一个列表，列出了它可以按绑定类型（纹理、采样器、**着色器存储缓冲区（SSBO**）、统一缓冲区）提供的绑定数量。
- en: Allocate descriptor sets from the pool with `vkAllocateDescriptorSets`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `vkAllocateDescriptorSets` 从池中分配描述符集。
- en: Bind resources to bindings using `vkUpdateDescriptorSets`. In this step, we
    associate a real resource (a buffer, a texture, and so on) with a binding.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `vkUpdateDescriptorSets` 将资源绑定到绑定。在这一步中，我们将一个实际资源（一个缓冲区、一个纹理等）与一个绑定关联。
- en: Bind descriptor sets and their bindings to a pipeline during rendering using
    `vkCmdBindDescriptorSet`. This step makes resources bound to their set/bindings
    in the previous step available to shaders in the current pipeline.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染期间使用 `vkCmdBindDescriptorSet` 将描述符集及其绑定绑定到管道。这一步使得在前面步骤中绑定到其集/绑定的资源对当前管道中的着色器可用。
- en: The next recipes will show you how to perform each one of those steps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个教程将展示如何执行这些步骤中的每一个。
- en: Specifying descriptor sets with descriptor set layouts
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用描述符集布局指定描述符集
- en: 'Consider the following GLSL code, which specifies several resources:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下GLSL代码，它指定了几个资源：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code requires three sets (0, 1, and 2), so we need to create three descriptor
    set layouts. In this recipe, you will learn how to create a descriptor set layout
    for the preceding code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要三个集合（0、1和2），因此我们需要创建三个描述符集布局。在本教程中，你将学习如何为前面的代码创建一个描述符集布局。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Descriptor sets and bindings are created, stored, and managed by the `VulkanCore::Pipeline`
    class in the repository. A descriptor set in Vulkan acts as a container that holds
    resources, such as buffers, textures, and samplers, for use by shaders. Binding
    refers to the process of associating these descriptor sets with specific shader
    stages, enabling seamless interaction between shaders and resources during rendering.
    These descriptor sets serve as gateways through which resources are seamlessly
    bound to shader stages, orchestrating harmony between data and shader execution.
    To facilitate this synergy, the class simplifies descriptor set creation and management,
    complemented by methods for efficient resource binding within the Vulkan rendering
    pipeline.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集和绑定由存储库中的 `VulkanCore::Pipeline` 类创建、存储和管理。在Vulkan中，描述符集充当一个容器，用于存储资源，如缓冲区、纹理和采样器，以便由着色器使用。绑定指的是将这些描述符集与特定着色器阶段关联起来的过程，在渲染过程中实现着色器和资源之间的无缝交互。这些描述符集作为资源无缝绑定到着色器阶段的网关，协调数据和着色器执行之间的和谐。为了促进这种协同作用，该类简化了描述符集的创建和管理，并辅以在Vulkan渲染管道中高效绑定资源的方法。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'A descriptor set layout states its bindings (number and types) with the `vkDescriptorSetLayout`
    structure. Each binding is described using an instance of the `vkDescriptorSetLayoutBinding`
    structure. The relationship between the Vulkan structures needed to create a descriptor
    set layout for the preceding code is shown in *Figure 2**.11*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集布局使用 `vkDescriptorSetLayout` 结构声明其绑定（数量和类型）。每个绑定使用 `vkDescriptorSetLayoutBinding`
    结构的实例进行描述。创建前面代码所需的描述符集布局的Vulkan结构之间的关系在 *图2**.11* 中显示：
- en: '![Figure 2.11 – Illustrating the configuration of descriptor set layouts for
    GLSL shaders](img/B18491_02_11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 展示GLSL着色器的描述符集布局配置](img/B18491_02_11.jpg)'
- en: Figure 2.11 – Illustrating the configuration of descriptor set layouts for GLSL
    shaders
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 展示GLSL着色器的描述符集布局配置
- en: 'The following code shows how to specify two bindings for set 1, which are stored
    in a vector of bindings:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何为集合1指定两个绑定，这些绑定存储在一个绑定向量中：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since each binding describes a vector, and the `VkDescriptorSetLayoutBinding`
    structure requires the number of descriptors, we are using a large number that
    hopefully will accommodate all elements we need in the array. The vector of bindings
    is stored in a structure that describes a set with its number and all its bindings.
    This vector will be used to create a descriptor set layout:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个绑定描述一个向量，而 `VkDescriptorSetLayoutBinding` 结构需要描述符的数量，所以我们使用了一个较大的数字，希望它能容纳数组中所有需要的元素。绑定向量存储在一个结构中，该结构描述了一个带有其编号和所有绑定的集。这个向量将用于创建描述符集布局：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each set requires its own descriptor set layout, and the preceding process needs
    to be repeated for each one. The descriptor set layout needs to be stored so that
    it can be referred to in the future.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都需要自己的描述符集布局，并且前一个过程需要为每个集合重复进行。描述符集布局需要被存储起来，以便将来可以引用。
- en: Passing data to shaders using push constants
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用推送常量将数据传递给着色器
- en: Push constants are another way to pass data to shaders. Although a very performant
    and easy way to do so, push constants are very limited in size, 128 bytes being
    the only guaranteed amount by the Vulkan specification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量是向着色器传递数据的另一种方式。虽然这是一种非常高效且简单的方法，但推送常量在大小上非常有限，Vulkan规范只保证有128字节。
- en: This recipe will show you how to pass a small amount of data from your application
    to shaders, using push constants for a simple shader.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示如何通过推送常量将少量数据从你的应用程序传递到着色器，用于一个简单的着色器。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Push constants are stored and managed by the `VulkanCore::Pipeline` class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量由`VulkanCore::Pipeline`类存储和管理。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Push constants are recorded directly onto the command buffer and aren’t prone
    to the same synchronization issues that exist with other resources. They are declared
    in the shader as follows, with one maximum block per shader:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量直接记录在命令缓冲区上，并且不会受到其他资源存在的相同同步问题的困扰。它们在着色器中如下声明，每个着色器有一个最大块：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The pushed data must be split into the shader stages. Parts of it can be assigned
    to different shader stages or assigned to one single stage. The important part
    is that the data cannot be greater than the total amount available for push constants.
    The limit is provided in `VkPhysicalDeviceLimits::maxPushConstantsSize`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 推送的数据必须分割成着色器阶段。其中一部分可以被分配到不同的着色器阶段，或者分配到单个阶段。重要的是，数据量不能超过可用于推送常量的总数量。这个限制在`VkPhysicalDeviceLimits::maxPushConstantsSize`中提供。
- en: 'Before using push constants, we need to specify how many bytes we are using
    in each shader stage:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用推送常量之前，我们需要指定每个着色器阶段使用多少字节：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code states that the first (`offset == 0`) `64` bytes of the push constant
    data recorded in the command buffer (the size of a 4x4 matrix of floats) will
    be used by the vertex shader. This structure will be used in the next recipe to
    create a pipeline layout object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码表明，命令缓冲区中记录的推送常量数据的前64个字节（一个4x4浮点矩阵的大小）将被顶点着色器使用。这个结构将在下一个菜谱中用于创建管道布局对象。
- en: Creating a pipeline layout
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管道布局
- en: A pipeline layout is an object in Vulkan that needs to be created and destroyed
    by the application. The layout is specified using structures that define the layout
    of bindings and sets. In this recipe, you will learn how to create a pipeline
    layout.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 管道布局是Vulkan中的一个对象，需要由应用程序创建和销毁。布局是通过定义绑定和集合的结构的结构体来指定的。在这个菜谱中，你将学习如何创建管道布局。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A `VkPipelineLayoutCreateInfo` instance is created automatically by the `VulkanCore::Pipeline`
    class in the repository based on information provided by the application using
    a vector of `VulkanCore::Pipeline::SetDescriptor` structures.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，`VulkanCore::Pipeline`类会根据应用程序使用`VulkanCore::Pipeline::SetDescriptor`结构体提供的信息自动创建一个`VkPipelineLayoutCreateInfo`实例。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'With all descriptor set layouts for all sets and the push constant information
    in hand, the next step consists of creating a pipeline layout:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有了所有集合的描述符集布局和推送常量信息后，下一步是创建管道布局：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you have the descriptor set layout in hand and know how to use the push
    constants in your application, creating a pipeline layout is straightforward.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你手头有了描述符集布局并且知道如何在你的应用程序中使用推送常量，创建管道布局就很简单了。
- en: Creating a descriptor pool
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建描述符池
- en: A descriptor pool contains a maximum number of descriptors it can provide (be
    allocated from), grouped by binding type. For instance, if two bindings of the
    same set require one image each, the descriptor pool would have to provide at
    least two descriptors. In this recipe, you will learn how to create a descriptor
    pool.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符池包含它可以提供的最大描述符数量（从其中分配），按绑定类型分组。例如，如果同一集合的两个绑定每个都需要一个图像，描述符池就必须提供至少两个描述符。在这个菜谱中，你将学习如何创建描述符池。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Descriptor pools are allocated in the `VulkanCore::Pipeline::` `initDescriptorPool()`
    method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符池是在`VulkanCore::Pipeline::initDescriptorPool()`方法中分配的。
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Creating a descriptor pool is straightforward. All we need is a list of binding
    types and the maximum number of resources we’ll allocate for each one:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建描述符池很简单。我们需要的只是一个绑定类型的列表和为每个类型分配的最大资源数量：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we duplicate the resources based on the number of swapchain images to
    avoid data races between the CPU and the GPU, we multiply the number of bindings
    we requested before (`kMaxBindings = 1000`) by the number of swapchain images:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们根据交换链图像的数量复制资源以避免CPU和GPU之间的数据竞争，我们将请求的绑定数量（`kMaxBindings = 1000`）乘以交换链图像的数量：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Be careful not to create pools that are too large. Achieving a high-performing
    application means not allocating more resources than you need.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要创建过大的池。实现高性能应用程序意味着不要分配比您需要的更多的资源。
- en: Allocating descriptor sets
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配描述符集
- en: Once a descriptor layout and a descriptor pool have been created, before you
    can use it, you need to allocate a descriptor set, which is an instance of a set
    with the layout described by the descriptor layout. In this recipe, you will learn
    how to allocate a descriptor set.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了描述符布局和描述符池，在您可以使用它们之前，您需要分配一个描述符集，这是一个由描述符布局描述的布局的集合实例。在本教程中，您将学习如何分配描述符集。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Descriptor set allocations are done in the `VulkanCore::Pipeline:: allocateDescriptors()`
    method. Here, developers define the count of descriptor sets required, coupled
    with binding counts per set. The subsequent `bindDescriptorSets()` method weaves
    the descriptors into command buffers, preparing them for shader execution.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集的分配是在 `VulkanCore::Pipeline::allocateDescriptors()` 方法中完成的。在这里，开发者定义了所需的描述符集数量，以及每个集合的绑定计数。随后的
    `bindDescriptorSets()` 方法将描述符编织到命令缓冲区中，为着色器执行做准备。
- en: How to do it…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'Allocating a descriptor set (or a number of them) is easy. You need to fill
    the `VkDescriptorSetAllocateInfo` structure and call `vkAllocateDescriptorSets`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 分配描述符集（或多个描述符集）很容易。您需要填充 `VkDescriptorSetAllocateInfo` 结构并调用 `vkAllocateDescriptorSets`：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When using multiple copies of a resource to avoid race conditions, there are
    two approaches:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个资源副本以避免竞争条件时，有两种方法：
- en: Allocate one descriptor set for each resource. In other words, call the preceding
    code once for each copy of the resource.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个资源分配一个描述符集。换句话说，为资源的每个副本调用前面的代码一次。
- en: Create one descriptor set and update it every time you need to render.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符集，并在需要渲染时更新它。
- en: Updating descriptor sets during rendering
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在渲染期间更新描述符集
- en: Once a descriptor set has been allocated, it is not associated with any resources.
    This association must happen once (if your descriptor sets are immutable) or every
    time you need to bind a different resource to a descriptor set. In this recipe,
    you will learn how to update descriptor sets during rendering and after you have
    set up the pipeline and its layout.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配了描述符集，它就不会与任何资源相关联。这种关联必须发生一次（如果您的描述符集是不可变的）或者每次您需要将不同的资源绑定到描述符集时。在本教程中，您将学习如何在渲染期间和设置管道及其布局之后更新描述符集。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the repository, `VulkanCore::Pipeline` provides methods to update different
    types of resources, as each binding can only be associated with one type of resource
    (image, sampler, or buffer): `updateSamplersDescriptorSets()`, `updateTexturesDescriptorSets()`,
    and `updateBuffersDescriptorSets``()`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，`VulkanCore::Pipeline` 提供了更新不同类型资源的方法，因为每个绑定只能与一种类型的资源（图像、采样器或缓冲区）相关联：`updateSamplersDescriptorSets()`、`updateTexturesDescriptorSets()`
    和 `updateBuffersDescriptorSets()`。
- en: How to do it…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: Associating a resource with a descriptor set is done with the `vkUpdateDescriptorSets`
    function. Each call to `vkUpdateDescriptorSets` can update one or more bindings
    of one or more sets. Before updating a descriptor set, let’s look at how to update
    *one* binding.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vkUpdateDescriptorSets` 函数将资源与描述符集相关联。每个对 `vkUpdateDescriptorSets` 的调用可以更新一个或多个集合的一个或多个绑定。在更新描述符集之前，让我们看看如何更新一个绑定。
- en: You can associate either a texture, a texture array, a sampler, a sampler array,
    a buffer, or a buffer array with one binding. To associate images or samplers,
    use the `VkDescriptorImageInfo` structure. To associate buffers, use the `VkDescriptorBufferInfo`
    structure. Once one or more of those structures have been instantiated, use the
    `VkWriteDescriptorSet` structure to bind them all with a binding. Bindings that
    represent an array are updated with a vector of `VkDescriptor*Info`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将纹理、纹理数组、采样器、采样器数组、缓冲区或缓冲区数组与一个绑定关联。要关联图像或采样器，使用`VkDescriptorImageInfo`结构。要关联缓冲区，使用`VkDescriptorBufferInfo`结构。一旦实例化了一个或多个这些结构，使用`VkWriteDescriptorSet`结构将它们全部绑定到一个绑定上。表示数组的绑定使用`VkDescriptor*Info`的向量更新。
- en: 'Consider the bindings declared in the shader code presented next:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下展示的着色器代码中声明的绑定：
- en: '[PRE27]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To update the `textures[]` array, we need to create two instances of `VkDescriptorImageInfo`
    and record them in the first `VkWriteDescriptorSet` structure:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更新`textures[]`数组，我们需要创建两个`VkDescriptorImageInfo`实例并将它们记录在第一个`VkWriteDescriptorSet`结构中：
- en: '[PRE28]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The two image views will be bound to set 1 (`.dstSet = 1`) and binding 0 (`.dstBinding
    = 0`) as elements 0 and 1 of the array. If you need to bind more objects to the
    array, all you need are more instances of `VkDescriptorImageInfo`. The number
    of objects bound to the current binding is specified by the `descriptorCount`
    member of the structure.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个图像视图将被绑定到集合1（`.dstSet = 1`）和绑定0（`.dstBinding = 0`）作为数组的元素0和1。如果你需要将更多对象绑定到数组，你只需要更多的`VkDescriptorImageInfo`实例。当前绑定中绑定的对象数量由结构的`descriptorCount`成员指定。
- en: 'The process is similar for sampler objects:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于采样器对象的过程类似：
- en: '[PRE29]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, we are binding the sampler objects to set 1, binding 1\. Buffers
    are bound using the `VkDescriptorBufferInfo` structure:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们将采样器对象绑定到集合1，绑定1。缓冲区使用`VkDescriptorBufferInfo`结构绑定：
- en: '[PRE30]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Besides storing the address of the `bufferInfo` variable to the `.pBufferInfo`
    member of `VkWriteDescriptorSet`, we are binding one buffer (`.descriptorCount
    = 1`) to set 2 (`.dstSet = 2`) and binding `0` (`.dstBinding =` `0`).
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了将`bufferInfo`变量的地址存储到`VkWriteDescriptorSet`的`.pBufferInfo`成员外，我们还将一个缓冲区（`.descriptorCount
    = 1`）绑定到集合2（`.dstSet = 2`）并将`0`（`.dstBinding = 0`）绑定。
- en: 'The last step consists of storing all `VkWriteDescriptorSet` instances in a
    vector and calling `vkUpdateDescriptorSets`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将所有`VkWriteDescriptorSet`实例存储在一个向量中并调用`vkUpdateDescriptorSets`：
- en: '[PRE31]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Encapsulating this task is the best way to avoid repetition and bugs introduced
    by forgetting a step in the update procedure.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将这项任务封装起来是避免重复和忘记更新过程中某个步骤引入的错误的最佳方式。
- en: Passing resources to shaders (binding descriptor sets)
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将资源传递给着色器（绑定描述符集）
- en: While rendering, we need to bind the descriptor sets we’d like to use during
    a draw call.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染过程中，我们需要绑定在绘制调用期间希望使用的描述符集。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Binding sets is done with the `VulkanCore::Pipeline::` `bindDescriptorSets()`
    method.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VulkanCore::Pipeline::bindDescriptorSets()`方法绑定集合。
- en: How to do it…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To bind a descriptor set for rendering, we need to call `vkCmdBindDescriptorSets`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绑定用于渲染的描述符集，我们需要调用`vkCmdBindDescriptorSets`：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we’ve successfully bound a descriptor set for rendering, let’s turn
    our attention to another crucial aspect of our graphics pipeline: updating push
    constants.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功绑定了用于渲染的描述符集，让我们将注意力转向图形管线另一个关键方面：更新推送常量。
- en: Updating push constants during rendering
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在渲染过程中更新推送常量
- en: Push constants are updated during rendering by recording their values directly
    into the command buffer being recorded.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染过程中通过直接将它们的值记录到正在记录的命令缓冲区中来更新推送常量。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Updating push constants is done with the `VulkanCore::Pipeline::` `udpatePushConstants()`
    method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VulkanCore::Pipeline::updatePushConstants()`方法更新推送常量。
- en: How to do it…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once rendered, updating push constants is straightforward. All you need to
    do is call `vkCmdPushConstants`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染完成，更新推送常量就很简单。你只需要调用`vkCmdPushConstants`：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This call records the contents of `mat` into the command buffer, starting at
    offset 0 and signaling that this data will be used by the vertex shader.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将`mat`的内容记录到命令缓冲区中，从偏移量0开始，并指示这些数据将由顶点着色器使用。
- en: Customizing shader behavior with specialization constants
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专用常量自定义着色器行为
- en: The process of compiling shader code results in immutability once completed.
    The compilation procedure carries a substantial time overhead and is generally
    circumvented during runtime. Even minor adjustments to a shader necessitate recompilation,
    leading to the creation of a fresh shader module and potentially a new pipeline
    as well – all entailing significant resource-intensive operations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器代码编译的过程一旦完成就会变得不可变。编译过程具有相当大的时间开销，通常在运行时被规避。即使是着色器的小幅调整也需要重新编译，从而导致创建新的着色器模块，甚至可能是一个新的管道——所有这些都涉及大量的资源密集型操作。
- en: In Vulkan, specialization constants allow you to specify constant values for
    shader parameters at pipeline creation time, instead of having to recompile the
    shader with new values every time you want to change them. This can be particularly
    useful when you want to reuse the same shader with different constant values multiple
    times. In this recipe, we will delve deeper into the practical application of
    specialization constants in Vulkan to create more efficient and flexible shader
    programs, allowing you to adjust without the need for resource-intensive recompilations.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，特殊化常量允许你在管道创建时指定着色器参数的常量值，而不是每次更改它们时都必须重新编译着色器。当你想多次重用相同的着色器并使用不同的常量值时，这特别有用。在本食谱中，我们将深入了解
    Vulkan 中特殊化常量的实际应用，以创建更高效和灵活的着色器程序，允许你在无需资源密集型重新编译的情况下进行调整。
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Specialization constants are available in the repository through the `VulkanCore::Pipeline::GraphicsPipelineDescriptor`
    structure. You need to provide a vector of `VkSpecializationMapEntry` structures
    for each shader type you’d like to apply specialization constants to.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊化常量可通过 `VulkanCore::Pipeline::GraphicsPipelineDescriptor` 结构在存储库中访问。你需要为每个希望应用特殊化常量的着色器类型提供一个
    `VkSpecializationMapEntry` 结构的向量。
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Specialization constants are declared in GLSL using the `constant_id` qualifier
    along with an integer that specifies the constant’s ID:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊化常量使用 `constant_id` 标识符和指定常量 ID 的整数在 GLSL 中声明：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: const bool kUseShaderDebug = false;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: const bool kUseShaderDebug = false;
- en: const VkSpecializationMapEntry useShaderDebug = {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: const VkSpecializationMapEntry useShaderDebug = {
- en: .constantID = 0, // matches the constant_id qualifier
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: .constantID = 0, // 与 constant_id 标识符匹配
- en: .offset = 0,
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: .offset = 0,
- en: .size = sizeof(bool),
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: .size = sizeof(bool),
- en: '};'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: const VkSpecializationInfo vertexSpecializationInfo = {
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: const VkSpecializationInfo vertexSpecializationInfo = {
- en: .mapEntryCount = 1,
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: .mapEntryCount = 1,
- en: .pMapEntries = &useShaderDebug,
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: .pMapEntries = &useShaderDebug,
- en: .dataSize = sizeof(bool),
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: .dataSize = sizeof(bool),
- en: .pData = &kUseShaderDebug,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: .pData = &kUseShaderDebug,
- en: '};'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: const VkPipelineShaderStageCreateInfo shaderStageInfo = {
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: const VkPipelineShaderStageCreateInfo shaderStageInfo = {
- en: '...'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: .pSpecializationInfo = &vertexSpecializationInfo,
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: .pSpecializationInfo = &vertexSpecializationInfo,
- en: '};'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: typedef struct VkDrawIndexedIndirectCommand {
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: typedef struct VkDrawIndexedIndirectCommand {
- en: uint32_t    indexCount;
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t    indexCount;
- en: uint32_t    instanceCount;
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t    instanceCount;
- en: uint32_t    firstIndex;
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t    firstIndex;
- en: int32_t     vertexOffset;
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: int32_t     vertexOffset;
- en: uint32_t    firstInstance;
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t    firstInstance;
- en: '} VkDrawIndexedIndirectCommand;'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '} VkDrawIndexedIndirectCommand;'
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: VkCommandBuffer commandBuffer;  // Valid Command Bufer
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: VkCommandBuffer commandBuffer;  // 有效的命令缓冲区
- en: VkBuffer indirectCmdBuffer;     // Valid buffer w/
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: VkBuffer indirectCmdBuffer;     // 有效的缓冲区
- en: // indirect commands
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: // 间接命令
- en: uint32_t meshCount;  // Number of indirect commands in
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t meshCount;  // 间接命令的数量
- en: // the buffer
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: // 缓冲区
- en: uint32_t offset = 0; // Offset into the indirect commands
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t offset = 0; // 间接命令中的偏移量
- en: // buffer
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: // 缓冲区
- en: vkCmdDrawIndexedIndirect(
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: vkCmdDrawIndexedIndirect(
- en: commandBuffer, indirectCmdBuffer, offset,
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: commandBuffer, indirectCmdBuffer, offset,
- en: meshCount,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: meshCount,
- en: sizeof(VkDrawIndexedIndirectDrawCommand));
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: sizeof(VkDrawIndexedIndirectDrawCommand));
- en: '[PRE37]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: struct Vertex {
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: struct Vertex {
- en: vec3 pos;
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 pos;
- en: vec3 normal;
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 normal;
- en: vec2 uv;
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: vec2 uv;
- en: int material;
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: int material;
- en: '};'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE38]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: layout(set = 2, binding = 0) readonly buffer VertexBuffer
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: layout(set = 2, binding = 0) readonly buffer VertexBuffer
- en: '{'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Vertex vertices[];
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Vertex vertices[];
- en: '} vertexBuffer;'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '} vertexBuffer;'
- en: '[PRE39]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: void main() {
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: Vertex vertex = vertexBuffer.vertices[gl_VertexIndex];
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Vertex vertex = vertexBuffer.vertices[gl_VertexIndex];
- en: '}'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE40]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: const VkPhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatures = {
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: const VkPhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatures = {
- en: .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
- en: .dynamicRendering = VK_TRUE,
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: .dynamicRendering = VK_TRUE,
- en: '};'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE41]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: const VkDeviceCreateInfo dci = {
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: const VkDeviceCreateInfo dci = {
- en: .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
- en: .pNext = &dynamicRenderingFeatures,
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: .pNext = &dynamicRenderingFeatures,
- en: '...'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '};'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE42]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: void Texture::addAcquireBarrier(
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void Texture::addAcquireBarrier(
- en: VkCommandBuffer cmdBuffer,
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkCommandBuffer cmdBuffer,
- en: uint32_t srcQueueFamilyIndex,
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: uint32_t srcQueueFamilyIndex,
- en: uint32_t dstQueueFamilyIndex) {
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: uint32_t dstQueueFamilyIndex) {
- en: VkImageMemoryBarrier2 acquireBarrier = {
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkImageMemoryBarrier2 acquireBarrier = {
- en: .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
- en: .dstStageMask =
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .dstStageMask =
- en: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
- en: .dstAccessMask = VK_ACCESS_2_MEMORY_READ_BIT,
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .dstAccessMask = VK_ACCESS_2_MEMORY_READ_BIT,
- en: .srcQueueFamilyIndex = srcQueueFamilyIndex,
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .srcQueueFamilyIndex = srcQueueFamilyIndex,
- en: .dstQueueFamilyIndex = dstQueueFamilyIndex,
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .dstQueueFamilyIndex = dstQueueFamilyIndex,
- en: .image = image_,
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .image = image_,
- en: .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
- en: 0, mipLevels_, 0, 1},
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0, mipLevels_, 0, 1},
- en: '};'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: VkDependencyInfo dependency_info{
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkDependencyInfo dependency_info{
- en: .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
- en: .imageMemoryBarrierCount = 1,
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .imageMemoryBarrierCount = 1,
- en: .pImageMemoryBarriers = &acquireBarrier,
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .pImageMemoryBarriers = &acquireBarrier,
- en: '};'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: vkCmdPipelineBarrier2(cmdBuffer, &dependency_info);
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vkCmdPipelineBarrier2(cmdBuffer, &dependency_info);
- en: '}'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE43]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: void Texture::addReleaseBarrier(
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void Texture::addReleaseBarrier(
- en: VkCommandBuffer cmdBuffer,
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkCommandBuffer cmdBuffer,
- en: uint32_t srcQueueFamilyIndex,
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: uint32_t srcQueueFamilyIndex,
- en: uint32_t dstQueueFamilyIndex) {
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: uint32_t dstQueueFamilyIndex) {
- en: VkImageMemoryBarrier2 releaseBarrier = {
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkImageMemoryBarrier2 releaseBarrier = {
- en: .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
- en: .srcStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .srcStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
- en: .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
- en: .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
- en: .srcQueueFamilyIndex = srcQueueFamilyIndex,
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .srcQueueFamilyIndex = srcQueueFamilyIndex,
- en: .dstQueueFamilyIndex = dstQueueFamilyIndex,
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .dstQueueFamilyIndex = dstQueueFamilyIndex,
- en: .image = image_,
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .image = image_,
- en: .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
- en: 0, mipLevels_, 0, 1},
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0, mipLevels_, 0, 1},
- en: '};'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: VkDependencyInfo dependency_info{
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkDependencyInfo dependency_info{
- en: .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
- en: .imageMemoryBarrierCount = 1,
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .imageMemoryBarrierCount = 1,
- en: .pImageMemoryBarriers = &releaseBarrier,
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .pImageMemoryBarriers = &releaseBarrier,
- en: '};'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: vkCmdPipelineBarrier2(cmdBuffer, &dependency_info);
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vkCmdPipelineBarrier2(cmdBuffer, &dependency_info);
- en: '}'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE44]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: auto transferQueueMgr =
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto transferQueueMgr =
- en: context.createTransferCommandQueue(
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.createTransferCommandQueue(
- en: 1, 1, "transfer queue");
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1, 1, "transfer queue");
- en: auto graphicsQueueMgr =
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto graphicsQueueMgr =
- en: context.createGraphicsCommandQueue(
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.createGraphicsCommandQueue(
- en: 1, 1, "graphics queue");
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1, 1, "graphics queue");
- en: '[PRE45]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: VulkanCore::Context context;  // Valid Context
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VulkanCore::Context context;  // Valid Context
- en: std::shared_ptr<VulkanCore::Texture>
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: std::shared_ptr<VulkanCore::Texture>
- en: texture;        // Valid Texture
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: texture;        // Valid Texture
- en: void* textureData;  // Valid texture data
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void* textureData;  // Valid texture data
- en: // Upload texture
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // Upload texture
- en: auto textureUploadStagingBuffer =
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto textureUploadStagingBuffer =
- en: context.createStagingBuffer(
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.createStagingBuffer(
- en: texture->vkDeviceSize(),
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: texture->vkDeviceSize(),
- en: VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
- en: '"texture upload staging buffer");'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"texture upload staging buffer");'
- en: const auto commandBuffer =
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const auto commandBuffer =
- en: transferQueueMgr.getCmdBufferToBegin();
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: transferQueueMgr.getCmdBufferToBegin();
- en: texture->uploadOnly(commandBuffer,
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: texture->uploadOnly(commandBuffer,
- en: textureUploadStagingBuffer.get(),
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: textureUploadStagingBuffer.get(),
- en: textureData);
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: textureData);
- en: texture->addReleaseBarrier(
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: texture->addReleaseBarrier(
- en: commandBuffer,
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: commandBuffer,
- en: transferQueueMgr.queueFamilyIndex(),
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: transferQueueMgr.queueFamilyIndex(),
- en: graphicsQueueMgr.queueFamilyIndex());
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: graphicsQueueMgr.queueFamilyIndex());
- en: transferQueueMgr.endCmdBuffer(commandBuffer);
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: transferQueueMgr.endCmdBuffer(commandBuffer);
- en: transferQueueMgr.disposeWhenSubmitCompletes(
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: transferQueueMgr.disposeWhenSubmitCompletes(
- en: std::move(textureUploadStagingBuffer));
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: std::move(textureUploadStagingBuffer));
- en: '[PRE46]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: VkSemaphore graphicsSemaphore;
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkSemaphore graphicsSemaphore;
- en: const VkSemaphoreCreateInfo semaphoreInfo{
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const VkSemaphoreCreateInfo semaphoreInfo{
- en: .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
- en: '};'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: VK_CHECK(vkCreateSemaphore(context.device(),
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VK_CHECK(vkCreateSemaphore(context.device(),
- en: '&semaphoreInfo, nullptr,'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&semaphoreInfo, nullptr,'
- en: '&graphicsSemaphore));'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&graphicsSemaphore));'
- en: VkPipelineStageFlags flags =
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkPipelineStageFlags flags =
- en: VK_PIPELINE_STAGE_TRANSFER_BIT;
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VK_PIPELINE_STAGE_TRANSFER_BIT;
- en: auto submitInfo =
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto submitInfo =
- en: context.swapchain()->createSubmitInfo(
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: context.swapchain()->createSubmitInfo(
- en: '&commandBuffer, &flags, false, false);'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&commandBuffer, &flags, false, false);'
- en: submitInfo.signalSemaphoreCount = 1;
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: submitInfo.signalSemaphoreCount = 1;
- en: submitInfo.pSignalSemaphores = &graphicsSemaphore;
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: submitInfo.pSignalSemaphores = &graphicsSemaphore;
- en: transferQueueMgr.submit(&submitInfo);
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: transferQueueMgr.submit(&submitInfo);
- en: '[PRE47]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: // Generate mip levels
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // Generate mip levels
- en: auto commandBuffer =
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto commandBuffer =
- en: graphicsQueueMgr.getCmdBufferToBegin();
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: graphicsQueueMgr.getCmdBufferToBegin();
- en: texture->addAcquireBarrier(
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: texture->addAcquireBarrier(
- en: commandBuffer,
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: commandBuffer,
- en: transferCommandQueueMgr_.queueFamilyIndex(),
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: transferCommandQueueMgr_.queueFamilyIndex(),
- en: graphicsQueueMgr.queueFamilyIndex());
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: graphicsQueueMgr.queueFamilyIndex());
- en: texture->generateMips(commandBuffer);
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: texture->generateMips(commandBuffer);
- en: graphicsQueueMgr.endCmdBuffer(commandBuffer);
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: graphicsQueueMgr.endCmdBuffer(commandBuffer);
- en: VkPipelineStageFlags flags =
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VkPipelineStageFlags flags =
- en: VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
- en: auto submitInfo =
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto submitInfo =
- en: context_.swapchain()->createSubmitInfo(
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: context_.swapchain()->createSubmitInfo(
- en: '&commandBuffer, &flags, false, false);'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&commandBuffer, &flags, false, false);'
- en: submitInfo.pWaitSemaphores = &graphicsSemaphore;
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: submitInfo.pWaitSemaphores = &graphicsSemaphore;
- en: submitInfo.waitSemaphoreCount = 1;
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: submitInfo.waitSemaphoreCount = 1;
- en: '[PRE48]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
