- en: Effects of lighting , Materials and Lightmaps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照、材质和光照贴图的效果
- en: In the previous chapter, we discussed how to apply transformations and projections
    to objects. We also created multiple cubes and a `Camera` class to clearly view
    and navigate around those objects. In this chapter, we're going to look at lighting.
    Firstly, we're going to discuss the basics of colors with respect to our objects
    and the source of light. We'll also discuss creating a vertex shader and a fragment
    shader, like we had in the previous chapters for our object box. We'll be creating
    a shader for an actual light source such as a lamp. You'll also learn how to apply
    materials to your object cube and you will observe the effect light has on those
    materials.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何将变换和投影应用于对象。我们还创建了多个立方体和一个`Camera`类，以便清晰地查看并导航这些对象。在本章中，我们将探讨光照。首先，我们将讨论与我们的对象和光源相关的颜色基础知识。我们还将讨论创建顶点着色器和片段着色器，就像我们在上一章为对象箱所做的那样。我们将为实际的光源，如灯具，创建着色器。你还将学习如何将材质应用于你的对象立方体，并观察光照对这些材质的影响。
- en: 'In this chapter we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of colors in lighting and lighting effects on objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照中颜色的基础知识以及光照对对象的影响
- en: Effect of light on a type of material
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光对某类材料的影响
- en: Exploring lightmaps to implement the real-world effects of light on different
    materials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索光照贴图以实现不同材料上光照的真实世界效果
- en: Lights... camera...action!!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 光……摄像机……开拍！！
- en: You can refer to all the code files for this chapter in the `Chapter04` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考GitHub上`Chapter04`文件夹中的所有本章代码文件。GitHub链接可以在书的序言中找到。
- en: Adding an object and a light source
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对象和光源
- en: In this section, will discuss how to apply colors to your cube object. We'll
    also learn how to create shader files for light and for a source of light such
    as a lamp. And then we'll learn how to add the cube and the light source to our
    game world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何将颜色应用于你的立方体对象。我们还将学习如何为光和灯具等光源创建着色器文件。然后我们将学习如何将立方体和光源添加到我们的游戏世界中。
- en: So, let's begin by creating new shader files for the light and the lamp.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建光和灯具的新着色器文件。
- en: Creating lighting and lamp shader files
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建光照和灯具着色器文件
- en: 'Here we''ll learn how to create shader files for a light source and a lamp
    and explore the code that will go into the vertex shaders and the fragment shaders.
    Perform the following steps to learn how create these shader files:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习如何为光源和灯具创建着色器文件，并探索将进入顶点着色器和片段着色器的代码。执行以下步骤以学习如何创建这些着色器文件：
- en: First of all, for rename `core.vs` and `core.frag` from the previous chapters
    to `lighting.vs` and `lighting.core`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将上一章中的`core.vs`和`core.frag`重命名为`lighting.vs`和`lighting.core`。
- en: 'Now let''s begin with the modifications to the code of these newly renamed
    files. First of all, we''ll modify `lighting.vs`. What we''re going to do here
    is get rid of the texture coordinate because we''re not going to render a texture
    in here, and we''ll also get rid of the `out texture` variable. Take a look at
    the following code to understand the changes made in the vertex shader for lighting:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始修改这些新命名的文件的代码。首先，我们将修改`lighting.vs`。我们在这里要做的就是移除纹理坐标，因为我们在这里不会渲染纹理，我们还将移除`out
    texture`变量。查看以下代码以了解对光照顶点着色器所做的更改：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll go to `lighting.frag` and carry out the modifications as in the
    following code:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转到`lighting.frag`并按照以下代码进行修改：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, `objectColor`, the variable that we have added, will
    contain the color of the object itself, which is the cube in our example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加的变量`objectColor`将包含对象本身的颜色，在我们的例子中是立方体。
- en: Save both the files, and now we'll create shader files for our lamp.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这两个文件，现在我们将为我们的灯具创建着色器文件。
- en: Creating shader files for the lamp
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为灯具创建着色器文件
- en: 'Take a look at the following steps to see how to create lamp shaders:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤，了解如何创建灯具着色器：
- en: Duplicate the files that we've updated in the preceding steps and rename them
    `lamp.vs` and `lamp.frag`, and we'll need to modify some code in these new files
    to create our light source.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制我们在前面步骤中更新的文件，并将它们重命名为`lamp.vs`和`lamp.frag`，我们还需要在这些新文件中修改一些代码以创建我们的光源。
- en: We won't be making any modifications to `lamp.vs` as we need the updated code
    as it is.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会对`lamp.vs`进行任何修改，因为我们需要当前的更新代码。
- en: 'We need to make some modifications to `lamp.frag`, so take a look at the highlighted
    terms in the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对`lamp.frag`进行一些修改，所以请查看以下代码中突出显示的术语：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason we have passed the value to `vec4` as `1.0f` is so that all the vector
    values should be set to `1.0f`, which is red, green, blue, and alpha at high intensity.
    So, it'll be fully on. If you have full red, full green, and full blue, you get
    white. Thus, our lamp will emit white light.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值传递给`vec4`作为`1.0f`的原因是，所有矢量值都应该设置为`1.0f`，这是高强度的红色、绿色、蓝色和alpha。所以，它将完全开启。如果你有全红、全绿和全蓝，你得到白色。因此，我们的灯将发出白光。
- en: You might have done an experiment in high school where you get all the different
    colors of the rainbow on a circle, and if you spin it fast enough, the combined
    color looks white. It's a pretty cool experiment, and you probably could do that
    at home. It's worth checking that out, just in general, it's a fun thing to do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在高中做过一个实验，将彩虹的所有不同颜色放在一个圆圈上，如果你足够快地旋转它，组合的颜色看起来是白色的。这是一个相当酷的实验，你很可能在家里也能做到。总的来说，这是一件有趣的事情，值得尝试。
- en: So, now that we've got our shader files all set up for lighting and lamp we'll
    move on to our main code in the `main.cpp` file to add an object and light source
    to our game world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经为光照和灯设置了所有着色器文件，我们将继续在`main.cpp`文件中的主代码，向游戏世界中添加一个对象和光源。
- en: Modifying the main code to implement a cube and a light source
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主代码以实现立方体和光源
- en: 'Now that we have created new shader files for our project we''ll next work
    on our main code and add a colored cube and a light source to our game world.
    In this section, we''ll also take a look at how to reference our newly created
    shader files in the code. Here, we''ll work on the code from the previous chapter
    and make modifications to it. Perform the following steps to understand the changes
    made to the code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的项目创建了新的着色器文件，接下来我们将着手于我们的主代码，并在游戏世界中添加一个彩色立方体和光源。在本节中，我们还将查看如何在代码中引用我们新创建的着色器文件。在这里，我们将对上一章的代码进行修改。执行以下步骤以了解对代码所做的更改：
- en: 'The first thing that we''re going to do, before our `int main()`, is add `glm::vec3
    lightPos();`. So, this is going to be the position of the source of light in our
    world. We''ll pass following coordinates to the function `lightpos()`: `1.2f`,
    `1.0f`, and `2.0f`. The way this works is you have light emitting from a particular
    location, for example, if you load in a light bulb as a source and you place it
    at the defined location. The light bulb itself is a light source for our world.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`int main()`之前，我们将首先添加`glm::vec3 lightPos();`。所以，这将是我们世界中光源的位置。我们将向`lightpos()`函数传递以下坐标：`1.2f`、`1.0f`和`2.0f`。这样工作的方式是，你有一个从特定位置发出的光源，例如，如果你加载一个灯泡作为光源并将其放置在定义的位置。灯泡本身是我们世界中的光源。
- en: Next, we'll go to the section where we've defined our shader. As we've added
    new shaders to our project, we'll have to reference them in the code.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进入定义了我们的着色器的部分。随着我们向项目中添加新的着色器，我们将在代码中引用它们。
- en: 'Now that we''ve got a couple of shaders, what we''re going to do is duplicate
    the `Shader ourShader( );` function present in our code and rename it `lightingShader`
    and `lampShader`. Obviously, we''ll need to update the path mentioned so as to
    reference our lighting and lamp shader files. Have a look at the following highlighted
    code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些着色器，我们将复制我们代码中现有的`Shader ourShader( );`函数，并将其重命名为`lightingShader`和`lampShader`。显然，我们需要更新提到的路径，以便引用我们的光照和灯着色器文件。请查看以下突出显示的代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, for the vertices, what we're going to do is remove all the texture coordinates
    present in our array. As we're not rendering any texture in this code and we only
    need the x, y, and z coordinates to describe our cube. You can refer to the updated
    vertices in the `main.cpp` file present in the `colours` folder in the `Chapter04`
    folder.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，对于顶点，我们将做的是移除我们数组中存在的所有纹理坐标。因为我们在这个代码中不会渲染任何纹理，我们只需要x、y和z坐标来描述我们的立方体。你可以参考位于`Chapter04`文件夹中`colours`文件夹内的`main.cpp`文件中更新的顶点。
- en: Then we'll get rid of the `cubePositions []` array as we're going to be rendering
    a single cube in our world. This will make it easier for us to understand the
    effect of light on our object.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将移除`cubePositions []`数组，因为我们将在我们的世界中渲染单个立方体。这将使我们更容易理解光线对我们对象的影响。
- en: 'Next, in the code, where we''ve defined our vertex buffer objects and vertex
    array objects, we''ll make the following modifications to it:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在代码中，我们定义了顶点缓冲对象和顶点数组对象的地方，我们将对其进行以下修改：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason we made this modification is we're going to have a vertex buffer
    object that we'll just reuse, but for the vertex array object, there'll be a different
    one for each individual shader and the box.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行这次修改的原因是我们将有一个要重复使用的顶点缓冲对象，但对于顶点数组对象，每个单独的着色器和盒子将会有一个不同的对象。
- en: 'Now, in the position attribute, we''ll update the `5 * sizeof()` to `3 * size
    of()` as we no longer have five pieces of information in a row in the vertex array,
    which were the 3: *x*, *y*, and *z* coordinates and the two texture coordinates.
    Now, as we are no longer using texture cooordinates we only have *x*, *y*, and
    *z* coordinates in the array.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在位置属性中，我们将更新`5 * sizeof()`到`3 * size of()`，因为我们不再在顶点数组中有一行五条信息，这些信息是3个坐标：*x*、*y*和*z*以及两个纹理坐标。现在，由于我们不再使用纹理坐标，数组中只有*x*、*y*和*z*坐标。
- en: Next, we'll get rid of the texture coordinate attribute because we're no longer
    loading textures in our code.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将删除纹理坐标属性，因为我们不再在代码中加载纹理。
- en: 'Then what we''re going to do is duplicate the vertex defining code, vertex
    binding code, and the position attribute code and paste in below the position
    attribute code. And in these duplicated lines of code we''ll make the following
    highlighted changes to add the light vertex array object to our main code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制顶点定义代码、顶点绑定代码和位置属性代码，并将其粘贴在位置属性代码下方。在这些复制的代码行中，我们将进行以下突出显示的更改，以将光顶点数组对象添加到我们的主代码中：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next thing that we're going to do is get rid of the entire create and load
    texture code.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，我们将删除整个创建和加载纹理的代码。
- en: In the previous chapter, we had added the projection matrix within the loop
    and it was declared every single time the loop ran. Now, because we're getting
    the field of view using GetZoom we can't place the projection matrix in the loop.
    So, as a result, we might as well just get the projection matrix code out of the
    loop and paste it at start of the while loop.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中，我们在循环内添加了投影矩阵，并且每次循环运行时都会声明。现在，由于我们使用GetZoom获取视场，我们不能在循环中放置投影矩阵。因此，我们最好将投影矩阵代码从循环中提取出来，并将其粘贴在while循环的开始处。
- en: Modifications to the while loop
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对while循环的修改
- en: 'There''s a few things that we need to change inside the while loop, so let''s
    take a look:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在while循环内部，我们需要更改一些内容，让我们看看：
- en: 'First of all, we''re going to change the background color so we have a darker
    background so that the lighting that we are trying to implement will have more
    of effect on our object. So, we''ll make the following modifications to the `glClearColor
    ()` function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将更改背景颜色，使其更暗，这样我们尝试实现的照明将对我们的对象有更大的影响。因此，我们将对`glClearColor()`函数进行以下修改：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What we're going to do next is get rid of all the code from the point where
    we defined our bind texture code to the point where we define our draw container
    code and add the fresh code.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从定义我们的绑定纹理代码的位置开始，删除所有代码，直到定义我们的绘制容器代码的位置，并添加新的代码。
- en: So, what we're going to do is use the corresponding shader to set the uniform
    objects and draw the object's code. First of all, what we're going to add `lightingShader.Use();`
    as we're handling the lighting shader of the box. Then we're going to create a
    `GLuint` variable, `objectColorLoc`, and to this we'll assign the value of function
    `glGetUniformLocation ()`, which will consists of parameter such as `lightingShader.Program`
    and `"objectColor"`
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将使用相应的着色器设置统一对象并绘制对象的代码。首先，我们将添加`lightingShader.Use();`，因为我们正在处理盒子的照明着色器。然后我们将创建一个`GLuint`变量`objectColorLoc`，并将函数`glGetUniformLocation()`的值分配给它，该函数将包含参数，如`lightingShader.Program`和`"objectColor"`。
- en: As usual, if you would like to know more details about what we're discussing,
    you can check out [learnopengl.com](http://learnopengl.com) and [open.gl](http://open.gl).
    They've got some well-written tutorials on there and they've got images to accompany
    those tutorials, and it's a great way of learning on top of these chapters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，如果您想了解更多关于我们讨论的细节，可以查看[learnopengl.com](http://learnopengl.com)和[open.gl](http://open.gl)。那里有一些写得很好的教程，并且有图像伴随这些教程，这是在这些章节之上学习的好方法。
- en: 'Next, we''re going to duplicate the preceding line of code and make the highlighted
    modifications to it:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制前面的一行代码，并对它进行以下高亮修改：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we're going to add function `glUniform3f()`and to that we're uniforming
    the object color location. So, we'll pass the parameters as `objectColorLoc` and
    `1.0f`, `0.5f`, `0.31f`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加函数`glUniform3f()`，并为其设置对象颜色位置。因此，我们将参数传递为`objectColorLoc`和`1.0f`、`0.5f`、`0.31f`。
- en: 'These are obviously just arbitrary values that we have been determined, and
    they actually work well. Obviously in your future projects, when you''re not following
    the chapter, you can try experimenting with the values. We''ll just duplicate
    the preceding line of code and make the following highlighted changes to it:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些显然只是我们确定的任意值，并且它们实际上工作得很好。显然，在你未来的项目中，当你不遵循本章内容时，你可以尝试对这些值进行实验。我们只需复制前面的一行代码，并对它进行以下高亮修改：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And now we're going to create a camera transformation. So, we'll add the view
    matrix`glm::mat4 view;` to our code and then type `view = camera.GetViewMatrix`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个相机变换。因此，我们将视图矩阵`glm::mat4 view;`添加到我们的代码中，然后输入`view = camera.GetViewMatrix`。
- en: Next, we're going to get the uniform location for the model, view, and projection
    matrix. So, we're going to type `GLint modelLoc = glGetUniformLocation();` . And
    in there, we are going to pass `lightingShader.Program` and `model`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将获取模型、视图和投影矩阵的统一位置。因此，我们将输入`GLint modelLoc = glGetUniformLocation();`。在那里，我们将传递`lightingShader.Program`和`model`。
- en: 'We''ll just duplicate this preceding code a couple of times and make the highlighted
    changes to it, as follows:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将复制前面的一小部分代码，并对它进行以下高亮修改，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And now we're going to pass the matrices to the shader. So now, we just need
    to add `glUniformMatrix4fv();`. And to this function, we'll pass `viewLoc`, `1`,
    `GL_FALSE`, `glm::value_ptr()` and for the value pointer function, you just specify
    our 4x4 view matrix.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将传递矩阵到着色器中。所以现在，我们只需要添加`glUniformMatrix4fv();`。我们将向这个函数传递`viewLoc`、`1`、`GL_FALSE`、`glm::value_ptr()`，而对于值指针函数，你只需指定我们的4x4视图矩阵。
- en: 'Duplicate the preceding line of code, as we need to do the same for projection
    matrix. Check out the following code and the highlighted terms in it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制前面的一行代码，因为我们还需要对投影矩阵做同样的操作。查看以下代码及其中的高亮部分：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now what we''re going to do is draw the container using the container''s vertex
    attributes, simple stuff, we''ve covered this in previous chapters. If you want
    to review them, feel free. Take a look at the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用容器的顶点属性来绘制容器，这是简单的事情，我们已经在之前的章节中讨论过。如果你想复习，请随意。查看以下代码：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we put 36\. The reason for this is, as there are a total
    of 36 vertices, 6 per side, and there are 6 sides to a cube, so we passed 36 in
    the function `glDrawArrays()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们输入了36。这样做的原因是，总共有36个顶点，每边6个，一个立方体有6个面，所以我们在`glDrawArrays()`函数中传递了36。
- en: 'Next, what we''ll do is duplicate the code that we have described in the previous
    steps and paste it below the preceding code. Then we''ll carry out the following
    highlighted changes for the lamp shader:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制我们在上一步中描述的代码，并将其粘贴在前面代码的下方。然后，我们将对灯的着色器执行以下高亮修改：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, in `glm::vec3( 0.2f )` we added 0.2f as we wanted to
    scale it by `0.2f` on every axis. The reason we're scaling it is because we don't
    want our light source, our lamp, to be the same size as our cube. It's just the
    way we perceive the world. Generally speaking, a bulb is smaller than most things
    in the room that we perceive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`glm::vec3( 0.2f )`中，我们添加了0.2f，因为我们想要在每个轴向上以`0.2f`的比例缩放它。我们这样做的原因是我们不希望我们的光源，我们的灯，与我们的立方体大小相同。这只是我们感知世界的方式。一般来说，灯泡比我们感知的房间里的大多数东西都要小。
- en: 'And now, the only thing we need to do is update `glDeleteVertexArrays()`. We''ll
    update that as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们唯一需要做的就是更新`glDeleteVertexArrays()`。我们将按以下方式更新：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''re now ready to run and see our masterpiece. Check the output on your window:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行并查看我们的杰作了。检查你窗口上的输出：
- en: '![](img/5d15334a-f35e-41fa-8437-e5ee6ce04d6f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d15334a-f35e-41fa-8437-e5ee6ce04d6f.png)'
- en: We've got this sort of red-looking box and we've got our white light source.
    It doesn't look like it's really emitting any light, but this is just the basics.
    But this is a nice precursor to future sections, and just the future of creating
    really cool lighting effects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似红色的盒子，并且我们有我们的白色光源。它看起来并没有真正发出任何光，但这只是基础。但这是一个很好的前奏，为未来的章节和创建真正酷炫的光照效果的未来。
- en: 'In the next section, we''re going to look at some really cool basic lighting
    that will make this look a lot better. So, we recommend you do an extra task in
    the code: figure out where you can change the color of our object and the light
    emitting object. So, that''s it for just basic colors in lighting within modern
    OpenGL.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些非常酷的基本光照，这将使效果看起来好得多。因此，我们建议你在代码中额外完成一个任务：找出你可以改变我们的物体和发射光源颜色的地方。这就是现代OpenGL中光照的基本颜色所涉及的全部内容。
- en: Lighting up objects
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照明物体
- en: In this section, we'll be looking at basics of lighting because so far, if you
    look at the results from our previous section, which just discussed colors, what
    we've got is the cube and the light source. At the moment, the entire color in
    the cube output just looks uniform. It almost doesn't look like a cube, a six-sided
    shape figure, and the lighting doesn't look very realistic too. Because realistically,
    in our example, the light source doesn't emit light onto our cube and there is
    no effect of light and shadow on the cube. So, in this section we'll discuss the
    basics of lighting and effect on the cube. We'll focus on improving the lighting
    system so we can have a more realistic effect.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨光照的基础知识，因为到目前为止，如果你查看我们上一节的结果，该节仅讨论了颜色，我们所得到的是立方体和光源。目前，立方体输出的整个颜色看起来非常均匀。它几乎不像一个立方体，一个六边形的形状，而且光照看起来也不太真实。因为在现实中，在我们的例子中，光源并没有向我们的立方体发射光线，立方体上也没有光和影的效果。所以，在本节中，我们将讨论光照的基础知识及其对立方体的影响。我们将专注于改进光照系统，以便我们可以获得更真实的效果。
- en: So, let's get started. As usual, we'll begin making modifications to our shader
    files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。像往常一样，我们将开始修改我们的着色器文件。
- en: Updating the shaders
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新着色器
- en: 'Check out the following steps to understand the changes made to the shaders:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤以了解对着色器所做的更改：
- en: We're not going to be changing anything in the lamp shader files because we're
    happy with the actual light that's being emitted.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会在灯具着色器文件中进行任何更改，因为我们对于实际发出的光线感到满意。
- en: 'Next, what you want to do is go to your lighting vertex shader and, essentially,
    change the way our cube perceives the light, and that will make the object look
    different. So, if you go to our lighting vertex shader, this doesn''t require
    many changes. Take a look at the following highlighted code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你想要做的是进入你的光照顶点着色器，本质上改变我们的立方体感知光线的方式，这将使物体看起来不同。所以，如果你进入我们的光照顶点着色器，这不需要很多更改。看看以下突出显示的代码：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What are normals ?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是法线？
- en: 'So, let''s first understand what normals are. So, normals are basically a direction.
    They''re perpendicular to a particular surface:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解什么是法线。法线基本上是一个方向，它们垂直于特定的表面：
- en: '![](img/7d405d0c-d251-4523-a882-b91bc7c8613e.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d405d0c-d251-4523-a882-b91bc7c8613e.png)'
- en: So, as you can see in the preceding diagram, the normals are at 90 degrees to
    the surface, and this is useful when calculating lighting because it determines
    the way light bounces off the surface, the way the surface reacts to light, and
    as a result, it looks a certain way. A powerful technique is to change the direction
    of the normals, which you can do (we'll be covering that in later sections) and
    that allows you to change the way that the light reacts to it, which makes the
    object look different. And what we can even do is have, let's say, a flat object,
    or a relatively flat object with a very low polygon count and by changing the
    normals, we can add the illusion of depth to it. That's the reason why when you
    play a game sometimes and you see some sort of object, especially when it's on
    a wall, it's relatively flat, but it looks like it has a bit of depth to it. If
    you're quite far away from it, it looks like it's got depth. When you go close,
    and especially when you look at it from an angle, it doesn't have depth anymore,
    or it has very little depth. And that's the limitation of this system. Obviously,
    if you want to get around that, you need to use some sort of tessellation technique
    that actually has real geometry. That's obviously a lot more expensive in terms
    of processing power. This is a lot cheaper in terms of processing power, so this
    is really preferred in the gaming industry, simply because you're not just drawing
    one sort of simple shape. You're drawing a whole heap of polygons, which this
    technique will allow you to reserve some processing power.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你可以在前面的图中看到的，法线与表面成90度角，这在计算光照时很有用，因为它决定了光线如何从表面反射，表面如何对光线做出反应，因此，它看起来是某种特定的样子。一种强大的技术是改变法线的方向，你可以在后面的章节中了解到这一点）并允许你改变光线对它的反应方式，这使得物体看起来不同。我们甚至可以做到，比如说，一个平面物体，或者一个相对平面的物体，具有非常低的多边形计数，通过改变法线，我们可以给它添加深度错觉。这就是为什么当你玩游戏时，有时你会看到某种物体，尤其是在墙上时，它相对平坦，但它看起来有点深度。如果你离它很远，它看起来有深度。当你靠近，尤其是当你从某个角度观察它时，它不再有深度，或者深度非常小。这就是这个系统的局限性。显然，如果你想克服这一点，你需要使用某种类型的细分技术，它实际上具有真实的几何形状。这显然在处理能力方面要昂贵得多。这在处理能力方面要便宜得多，所以在游戏行业中，这真的是首选，因为你不仅仅是在画一个简单的形状。你是在画一大堆多边形，这种技术将允许你保留一些处理能力。
- en: Updating the lighting.frag shader
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 lighting.frag 着色器
- en: 'Let''s follow the below mentioned steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤进行：
- en: 'So now that we''ve done this, we go to the lighting fragment shader and make
    the following highlighted changes to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个步骤，接下来我们进入光照片段着色器，并对它进行以下高亮显示的修改：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we added `FragPos`, as those are going to be the fragment
    positions that we were sending out from the vertex shader.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了 `FragPos`，因为那些是我们从顶点着色器发送出去的片段位置。
- en: 'Then we created uniform vector variables as follow:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建了如下所示的统一向量变量：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we added `lightPos` as we needed a vector for the light
    position because we are factoring the light position and the lighting will vary
    depending on what part of the surface you're looking at.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了 `lightPos`，因为我们需要一个表示光位置的向量，因为我们正在考虑光的位置，光照将根据你所看的表面部分而变化。
- en: And in our main function there are three types of lighting techniques that we'll
    be using as shading techniques, and they will be ambient, diffuse, and specular.
    We'll discuss them in detail and also understand how to define them in our code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们将使用三种光照技术作为着色技术，它们将是环境光、漫反射光和镜面光。我们将详细讨论它们，并了解如何在我们的代码中定义它们。
- en: Ambient lighting
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境光照
- en: The first one, which is ambient lighting, is just like the general lighting
    that's in a scene. It's not like the light from the sun, but it's general light
    that is always bouncing around the room. It doesn't have a particular origin or
    a position or direction. So that allows it to provide some basic sort of color,
    some basic property to your object. On top of that, you add diffuse lighting and
    specular lighting to make the object a unique and interesting object to make it
    look more like what it would in the real world.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种，即环境光照，就像场景中的普通光照一样。它不像太阳光，而是一直在房间中反弹的普通光。它没有特定的起源、位置或方向。因此，它可以为你的物体提供一些基本的颜色，一些基本属性。在此基础上，你还可以添加漫反射光照和镜面光照，使物体成为一个独特且有趣的物体，使其看起来更接近现实世界。
- en: 'We''ll begin by adding `float ambientStrength`, and to that we will add value
    of `0.1f`. Feel free to change that value and see what happens, see the limitations
    of the variables as well. And then we''re going to add `vec3` for the ambient
    lighting. That variable is going to equal to `ambientStrength * lightColor`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加`float ambientStrength`，并将其设置为`0.1f`。您可以随意更改该值并观察结果，同时也要了解变量的限制。然后我们将添加`vec3`用于环境照明。该变量将等于`ambientStrength
    * lightColor`：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Diffuse lighting
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫反射照明
- en: 'Now we''re going to do diffuse lighting. Diffuse lighting takes into account
    the direction and the normal of the light. For example, imagine our cube, the
    corner which is nearer to the light source will be brighter compared to the corner
    that is furthest away. Essentially, what is diffuse lighting? It adjusts the actual
    position and the angle as well. It''s to do with the angle as well, so if you
    were to have a light source at 90 degrees, that would emit more light than, let''s
    say, one at 5 degrees, and 90 degrees would be shinier. That''s essentially what
    diffuse is. You don''t generally just have ambient, diffuse, or specular lighting.
    You have all three combined, at different intensities and different strengths,
    and that allows you to create a realistic effect called combined lighting, and
    this effect is very often known as Phong shading. You can read about it on the
    internet. Take a look at the following code for diffuse light:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进行漫反射照明。漫反射照明考虑了光的方向和法线。例如，想象我们的立方体，靠近光源的角会比远离光源的角更亮。本质上，漫反射照明是什么？它调整了实际的位置和角度。这也与角度有关，所以如果你有一个90度的光源，它发出的光会比5度的光源多，90度的光源会更亮。这就是漫反射的本质。你通常不会只有环境、漫反射或镜面反射照明。你会有这三种光结合在一起，以不同的强度和强度，这允许你创建一个称为组合照明的真实效果，这种效果通常被称为Phong着色。你可以在互联网上了解它。看看以下关于漫反射照明的代码：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we added `lightPos - FragPos`. The difference between
    these will tell you the direction in which the light is pointing. At the end of
    code we're always going to be factoring in the `lightColor` because at the end
    of the day, if we have a white light shining on something, we don't want it to
    be blue or red. It has to be what the light is. Obviously, it will vary depending
    on the actual material that is applied and the sort of properties of that object,
    but the actual light itself should be a light color.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了`lightPos - FragPos`。这两个值之间的差异将告诉你光线指向的方向。在代码的末尾，我们总是要考虑`lightColor`，因为最终，如果我们有一种白光照射在某个物体上，我们不想它变成蓝色或红色。它必须保持光的本色。显然，这会根据实际应用的材料和该物体的性质而变化，但实际的光本身应该是光的颜色。
- en: Now that we've done diffuse lighting, we can go on to specular lighting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了漫反射照明，我们可以继续进行镜面反射照明。
- en: Specular lighting
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜面反射照明
- en: 'To talk about specular lighting, imagine a snooker ball or a pool ball, for
    example, which has a little circle of light shining on it, it''s always that little
    shiny light on an object. Let''s take a look at the code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要谈论镜面反射照明，想象一个斯诺克球或台球，例如，它上面有一个小圆圈的光照在上面，它总是那个小亮光在物体上。让我们看看以下代码：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we're done updating the shader files, we need to make a minor change
    in our `Camera.h` file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了着色器文件，我们需要在`Camera.h`文件中进行细微的更改。
- en: Minor change in Camera.h
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`Camera.h`文件中进行了细微的更改
- en: 'In the `Camera.h` file, we don''t have any sort of method to get the position
    of the camera. So, what we''ll do is, below `glfloat GetZoom()`, we''ll add the
    `glm::vec3 GetPosition ()` method and its simply going to return the position.
    Have a look at the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Camera.h`文件中，我们没有获取相机位置的方法。所以，我们将做的是，在`glfloat GetZoom()`下面添加`glm::vec3 GetPosition
    ()`方法，它将简单地返回位置。看看以下代码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Making changes to the main code
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主代码
- en: 'Now we just need to go to our `main.cpp` file and make modifications to our
    code. Take a look at the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要去我们的`main.cpp`文件，并修改我们的代码。看看以下步骤：
- en: 'In there, the first thing that we need to modify is this vertices array. At
    the moment, we have x, y, and z values for each of the vertices, and what we also
    need to include is the normal. You can refer to the updated vertices in the `main.cpp`
    file present in the `Basic Lighting` folder. For reference, just take a look at
    the vertices of one side of cube:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里，我们需要修改的第一件事是顶点数组。目前，我们为每个顶点都有x、y和z值，我们还需要包含法线。你可以参考`Basic Lighting`文件夹中`main.cpp`文件中更新的顶点。为了参考，只需看看立方体一面的顶点：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The three extra values that we have got in the preceding array are the direction
    of the normals. The normals will stay the same for every single face.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面数组中我们得到的三个额外值是法线的方向。每个面的法线都将保持不变。
- en: 'Extra task: Try figuring out which face each one of these normals applies to,
    and what is the direction once you''ve rendered it. Modify them, see what happens.
    Change some of these values, but keep some of them the same. See what happens.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 额外任务：试着找出这些法线中的每一个适用于哪个面，一旦你渲染了它，方向是什么。修改它们，看看会发生什么。更改一些这些值，但保留一些不变。看看会发生什么。
- en: 'Once we''ve got all of that sorted, we just need to change a few things where
    we have defined our `VBO` and `boxVAO`. Wherever we have mentioned `boxVAO` we''ll
    replace it with `containerVAO`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们整理好所有这些，我们只需要更改我们在定义我们的`VBO`和`boxVAO`时的一些地方。无论我们提到`boxVAO`的地方，我们都会将其替换为`containerVAO`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the position attribute we will make the following highlighted changes, and
    similarly, we''ll also create our normal attribute. Take a look at the following
    highlighted code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位置属性中，我们将进行以下突出显示的更改，并且类似地，我们还将创建我们的法线属性。看看以下突出显示的代码：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we've got six different pieces of value on each row of the vertices array,
    which is the reason why we updated 6 in our code. You will updated the similar
    value of `6` in the `lightVAO` position attribute too.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顶点数组的每一行都有六个不同的值，这就是我们在代码中更新6的原因。你还需要在`lightVAO`的位置属性中更新类似的`6`值。
- en: 'Where we are defining our lighting shader in the code, we''re using the object
    color location and the light color location. Now, what we also need to do is add
    the lighting position location and assign that to our shader program, and also
    add the view position location. So, what we''re going to do is duplicate the whole
    `GLint lightColorLoc` code twice and make the following updates to add the light
    position location and the view position location. We need to do a similar thing
    for `gluniform3f();` too. Take a look at the following highlighted code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中定义我们的光照着色器时，我们使用对象颜色位置和光照颜色位置。现在，我们还需要做的是添加光照位置位置并将其分配给我们的着色器程序，并添加视图位置位置。所以，我们将复制整个`GLint
    lightColorLoc`代码两次，并添加以下更新以添加光照位置位置和视图位置位置。我们还需要为`gluniform3f();`做类似的事情。看看以下突出显示的代码：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once we have got all of this updated, we'll leave rest of the code as it. As
    we don't have to make any modifications to it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更新了所有这些内容，我们就会保留其余的代码不变。因为我们不需要对其进行任何修改。
- en: 'We should actually be ready to run the code, but remember what it looked like
    in the previous section. The output that you got on your screen should look some
    what similar to this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上应该准备好运行代码了，但记住上一节中的样子。你屏幕上得到的输出应该看起来有些类似于此：
- en: '![](img/eda92d9c-4f80-46b6-bf1d-34621f6429c9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eda92d9c-4f80-46b6-bf1d-34621f6429c9.png)'
- en: 'As you may have noticed in the preceding image, the top-left side, by the top-left
    corner, looks a little brighter than the bottom left, and that''s because that''s
    where the light source is. And it''s definitely evident on the other sides of
    the cube and on the top. Just take a look at the top compared to other sides.
    Those sides are darker as they have hardly any light on their surfaces. You can
    check that out in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能在前面图像中注意到的，左上角，靠近左上角，看起来比左下角亮一些，这是因为那里是光源所在。在其他立方体的侧面和顶部上这一点非常明显。只需比较顶部与其他侧面。这些侧面较暗，因为它们的表面上几乎没有光照。你可以在以下屏幕截图中查看：
- en: '![](img/7f22e1fe-fc8f-4de7-8686-f660c811c153.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f22e1fe-fc8f-4de7-8686-f660c811c153.png)'
- en: It's just, it's a lot more realistic than it was before. You'll also notice
    as you move across it, you will get to see the beautiful dynamic shading on our
    cube.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只是，它比以前更真实。你也会注意到，当你移动到它上面时，你将看到我们立方体上的美丽动态着色。
- en: 'So what we''re going to do now is go to the lighting fragment shader and change
    the `specularStrength` to `2.0f`. Just modify this stuff up, and just observe
    the output that will have, take a look at the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在要做的就是进入光照片段着色器，将`specularStrength`改为`2.0f`。只需修改这些内容，并观察将产生的输出，看看下面的截图：
- en: '![](img/97f65da2-3a9e-497b-831a-e3425a5c72ec.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97f65da2-3a9e-497b-831a-e3425a5c72ec.png)'
- en: 'You can already see the sort of impact that change of value in the code had
    on the intensity of light. Look at that shine. That''s the sort of shine that
    you get on a pool ball. Try experimenting with the value. If you change the value
    of `ambientStrength` to `0.5f` you''ll see a brighter cube:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到代码中值的变化对光强度的影响了。看看那个光泽。那是在台球上得到的那种光泽。尝试调整这个值。如果你将`ambientStrength`的值改为`0.5f`，你会看到一个更亮的立方体：
- en: '![](img/277ac086-96de-454a-9f26-3d2003c91835.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/277ac086-96de-454a-9f26-3d2003c91835.png)'
- en: This is almost looking more like a uniform color now, but it looks quite cool
    as well. Try experimenting by changing the values in your shader files and the
    main code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来几乎像是一种均匀的颜色了，但看起来也很酷。尝试通过更改着色器文件和主代码中的值来实验。
- en: 'One last thing that we''ll try doing is to move the light position so you can
    actually sort of see what effect it has on our object. So, in our main code, at
    the start of while loop, we''ll add `lightPos.x -= 0.01f`, and we''re going to
    do the same for the z position:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要尝试的事情是移动光源的位置，这样你就可以看到它对我们物体的影响。所以，在我们的主代码中，while循环的开始处，我们将添加`lightPos.x
    -= 0.01f`，并且我们也将对z位置做同样的操作：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''re not going to modify the y position because we sort of only want the
    light source to move along the horizon. You could make it move along the y axis
    as well; we recommend you do that. Try and make a circle around it. Save the changes
    and run the code. You''ll observe the following output on your screen:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会修改y位置，因为我们只希望光源沿着地平线移动。你也可以让它沿着y轴移动；我们建议你这样做。尝试围绕它画一个圆。保存更改并运行代码。你会在屏幕上观察到以下输出：
- en: '![](img/ebea6b88-3895-4fbb-a98d-d842141e63f4.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebea6b88-3895-4fbb-a98d-d842141e63f4.png)'
- en: 'As you can see, we''ve got a light and as it''s getting further away, the top
    side is getting dark because it''s at a really obscure angle. As it''s getting
    further and further away, you will observe that the top side gets darker and darker:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个光源，并且随着它越来越远，顶部变得越来越暗，因为它处于一个非常隐蔽的角度。随着它越来越远，你会观察到顶部变得越来越暗：
- en: '![](img/95c803f5-cbf7-4e45-acc2-1c05c3425228.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95c803f5-cbf7-4e45-acc2-1c05c3425228.png)'
- en: As an extra task, we recommend trying to move the light as far as you can and
    observe the effect. It would be fantastic if you could get it to rotate around
    the object itself and try adding multiple lights. That will create an awesome
    effect.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外任务，我们建议你尝试将光源移动到尽可能远的位置，并观察效果。如果能让它围绕物体本身旋转，并尝试添加多个光源，那将会产生一个很棒的效果。
- en: Materials
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料信息
- en: We're going to discuss materials in this section. So, let's first understand
    what a material is and why would you use it. In the real world, you have objects
    that are made out of different materials. You have objects that are made out of
    metals, wood, plastic, and other stuff. As a result, these materials, these objects,
    react differently to light depending on what they're made out of. Generally speaking,
    something that's made out of metal will be shinier than something that's made
    out of wood. Wood generally isn't shiny. Obviously, it is if you apply some sort
    of varnish to it, but again, that would be an additional layer to the object that's
    not wood. It'd be something more than wood that is applied on top of it that provides
    some sort of shine to it. You have glossy materials, and you have some more matte
    materials. Simply put, materials in OpenGL will allow us to create objects that
    react differently to light, and as a result, create more realistic and varied
    effects in our game or application. And that's why you would use it, to get a
    more varied and realistic representation of the objects you are trying to create.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中讨论材质。因此，让我们首先了解什么是材质以及为什么你会使用它。在现实世界中，你有一些由不同材质制成的物体。有些物体是由金属、木材、塑料和其他材料制成的。因此，这些材质、这些物体根据它们的材质对光有不同的反应。一般来说，由金属制成的物体会比由木材制成的物体更亮。木材通常不发光。显然，如果你在上面涂上某种清漆，它就会发光，但再次强调，那将是物体上除木材之外的一个额外层。它将是某种比木材更多，并施加在其上以提供某种光泽的东西。你有光泽材料，还有一些更哑光的材料。简单来说，OpenGL中的材质将允许我们创建对光有不同的反应的物体，从而在我们的游戏或应用程序中创建更真实和多样的效果。这就是你为什么要使用它的原因，以获得你试图创建的物体的更多样化和真实的表现。
- en: So, let's get started...
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧...
- en: As few prerequisites. This section is using the source code from the previous
    section, which was covering basic lighting. If you haven't got the code for that,
    feel free to check out the GitHub link in the preface for the code files. The
    other thing we want to mention is that these chapters are based on the work of
    learnopengl.com and open.gl. They're using a fantastic illustrations to explain
    what we're doing. Also, feel free to check out their pages because they've got
    some great information. They go into really great depth into the code that we
    have discussed in all the chapters. So, it's just a great way of enhancing the
    knowledge you already know.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有先决条件。本节使用上一节中的源代码，该节介绍了基本光照。如果你没有那个代码，请随意查看前言中的GitHub链接以获取代码文件。我们还想提到的是，这些章节基于learnopengl.com和open.gl的工作。他们使用精彩的插图来解释我们在做什么。你也可以随意查看他们的页面，因为那里有大量信息。他们深入探讨了我们在所有章节中讨论的代码。所以，这是一种增强你已知知识的好方法。
- en: What we're going to do in this section is make the cube cycle through various
    different materials. We'll begin by updating the shader files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使立方体循环通过各种不同的材质。我们将首先更新着色器文件。
- en: Updating shader files for Materials
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新材质的着色器文件
- en: Take a look at the following steps
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下步骤
- en: We won't make any changes to the vertex shader, that is, `lighting.vs`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会对顶点着色器进行任何修改，即`lighting.vs`。
- en: 'Next, we''ll move onto the lighting fragment shader and in here, right at the
    top, we''re going to create a data type `struct` called `Material`. In there,
    we''re going to have three varibles `vec3`, which are going to be the `ambient`,
    the `diffuse`, the `specular`, and the `shininess` float, so we can easily change
    the intensity of the specular light. Take a look at the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转向光照片段着色器，在这里，在最上面，我们将创建一个名为`Material`的数据类型`struct`。在那里，我们将有三个变量`vec3`，它们将是`ambient`、`diffuse`、`specular`，以及一个`shininess`浮点数，这样我们就可以轻松地改变镜面光的强度。请看以下代码：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we''re going to create a datatype struct for Light. This is going to
    have a `vec3` of position and it''s going to have three more `vec3` for ambient,
    diffuse, and specular:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为光创建一个数据类型`struct`。这将有一个位置`vec3`，还将有三个额外的`vec3`用于环境光、漫反射和镜面光：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you want to know a bit more about what ambient, diffuse, and specular are,
    feel free to check out the previous the sections. Or, feel free to go to learnopengl.com
    and open.gl. These sites provide a lot of information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道更多关于环境光、漫反射和镜面光是什么的信息，请随意查看前面的章节。或者，你也可以去learnopengl.com和open.gl。这些网站提供了大量信息。
- en: 'Then, we''ll get rid of the `lightPos` because we have it within the preceding
    struct. We don''t want `objectColor`, and also we don''t want `lightColor` as
    well, because again, we''ve got it all within our struct. Then we''ll add `uniform
    Material material` and we also add `uniform Light light`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将去掉`lightPos`，因为我们已经在前面的结构体中有它。我们不需要`objectColor`，也不需要`lightColor`，因为我们再次在结构体中拥有它们。然后我们将添加`uniform
    Material material`和`uniform Light light`：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And now, in `void main()`, what are we going to do ? For the ambient light,
    we'll get rid of the `ambientStrength` and we'll modify it as `Vec3 ambient =
    light.ambient * material.ambient`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`void main()`中，我们将做什么？对于环境光，我们将去掉`ambientStrength`，并将其修改为`Vec3 ambient =
    light.ambient * material.ambient`。
- en: 'And for the diffuse light, `vec3 lightDir`, we need to change that up a bit.
    Take a look at the highlighted terms:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于漫反射光，`vec3 lightDir`，我们需要稍作修改。看看下面高亮显示的术语：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And for the final diffuse calculation, all we need to do is change it up slightly.
    We need to add `light.diffuse` multiplied by `diff`, which was calculated here
    in the float variable, and `diff` multiplied by `material.diffuse`. We are factoring
    in material in every single part of our lighting, our shading, simply because
    that's what's important. That's the way that our actual object will look, or that
    part of the object, because we have different materials applied.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最终的漫反射计算，我们只需要稍作修改。我们需要添加`light.diffuse`乘以`diff`，这是在这里用浮点变量计算的，以及`diff`乘以`material.diffuse`。我们在我们的光照、着色中的每一个部分都考虑了材质，因为这很重要。这就是我们的实际物体或物体的一部分将呈现的样子，因为我们应用了不同的材质。
- en: 'In specular, we can get rid of `specularStrength` because we''ve got that in
    the previous code. Then we''ll update `float spec` for the shininess; we''ll add
    `material.shininess`. For `vec3 specular`, we are changing that up slightly. We''re
    going to add `light.specular * (spec * material.specular)`. And for the result,
    we''ll modify that as highlighted in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在镜面反射中，我们可以去掉`specularStrength`，因为我们已经在前面的代码中有它。然后我们将更新`float spec`用于光泽度；我们将添加`material.shininess`。对于`vec3
    specular`，我们稍作修改。我们将添加`light.specular * (spec * material.specular)`。对于结果，我们将按照以下代码中的高亮显示进行修改：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save these changes, and now we are done updating the fragment shader.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改，现在我们已经完成了片段着色器的更新。
- en: Making changes to the main code to add materials to our object
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主代码以添加材质到我们的物体
- en: 'Follow the below mentioned steps to add materials to our object and observe
    the effects of light on it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤添加材质到我们的物体并观察光照对其的影响：
- en: If you go to `main.cpp`, what you want to do is actually go straight to the
    while loop, because everything outside of that should is fine and doesn't need
    any modification.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打开`main.cpp`，你实际上想要做的是直接进入while循环，因为循环之外的所有内容都应该保持原样，不需要任何修改。
- en: So, in lines of code below `lightingShader.Use();`, we'll get rid of `objectColorLoc`
    and `lightColorLoc`. We want `lightPosLoc`, but a parameter in it needs to be
    changed to `light.position` because we've updated that in our fragment shader.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在`lightingShader.Use();`下面的代码行中，我们将去掉`objectColorLoc`和`lightColorLoc`。我们想要`lightPosLoc`，但其中的一个参数需要更改为`light.position`，因为我们已经在片段着色器中更新了它。
- en: In `gluniform3f` you can get rid of `objectColorLoc` and `lightColorLoc`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gluniform3f`中，你可以去掉`objectColorLoc`和`lightColorLoc`。
- en: 'Now we need to also set the light''s properties. For that, we''ll add `glm::vec3
    lightColor;` and we''ll add `lightColor.r = sin();`, and for `sin()`, this is
    where we''re going to have some framework-specific code. We''re just going to
    be pass `glfwGetTime()`, which just gets the amount of time that has passed since
    GLFW was initialized. We''ll just multiply `glfwGetTime()` by `2.0f`. We''ll duplicate
    this line of code, paste it below, and make the following highlighted modification
    to it:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们还需要设置光源的属性。为此，我们将添加`glm::vec3 lightColor;`，并添加`lightColor.r = sin();`，对于`sin()`，这是我们将在框架特定的代码中处理的地方。我们只需传递`glfwGetTime()`，这会获取自GLFW初始化以来经过的时间量。我们将将其乘以`2.0f`。我们将复制这一行代码，将其粘贴在下面，并对其进行以下高亮显示的修改：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So now that we've set the light's properties, we need to actually do the diffuse
    color and the ambient color. So, we're going to add `glm::vec3 diffuseColor =
    lightColor * glm::vec3();`. And for `ver3()`, we're just going to provide a value
    of `0.5f`. This is just going to decrease the influence of the diffuse color.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们已经设置了光源的属性，我们需要实际设置漫反射颜色和环境颜色。所以，我们将添加`glm::vec3 diffuseColor = lightColor
    * glm::vec3();`。对于`ver3()`，我们只需提供一个值为`0.5f`的值。这将减少漫反射颜色的影响。
- en: Next, we're going to add `glm::vec3 ambientColor = diffuseColor * glm::vec3();`
    and over here, `vec3` is going to be `0.2f`, as this is just a low-intensity one.
    So try some experimenting by modifying these values and see what you come up.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `glm::vec3 ambientColor = diffuseColor * glm::vec3();` 并且在这里，`vec3`
    将会是 `0.2f`，因为这只是一个低强度的。所以尝试通过修改这些值进行一些实验，看看你得到什么结果。
- en: Then, what we need to add is `glUniform3f()` function and to that, we'll pass
    `glGetUniformLocation()` function and for this function now we're going to specify
    `lightingShader.Program` and `"light.ambient"`. Then we're going to pass `ambientColor.r`
    and similarly, we'll pass `ambientColor.g` and `ambientColor.b`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加的是 `glUniform3f()` 函数，我们将传递 `glGetUniformLocation()` 函数，对于这个函数，我们现在将指定
    `lightingShader.Program` 和 `"light.ambient"`。然后我们将传递 `ambientColor.r`，同样地，我们将传递
    `ambientColor.g` 和 `ambientColor.b`。
- en: 'Next, what we''ll do is just duplicate the previously described code and make
    the following highlighted changes to it:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将重复之前描述的代码，并对其进行以下突出显示的更改：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we're going to set the material properties, and to do that, we're going
    to do the ambient, the diffuse, the specular, and the shininess of the material.
    So, you want to add `glUniform3f();` and to that, we'll pass `glGetUniformLocation()`,
    and to this function, we'll specify `lightingShader.Program` and the selected
    `material.ambient`. Then we'll pass some values. We're going to just put some
    explicit values as `1.0f`, `0.5f`, and `0.31f`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将设置材质属性，为此，我们将进行环境光、漫反射、镜面反射和光泽度的设置。所以，你想要添加 `glUniform3f();` 并将 `glGetUniformLocation()`
    传递给它，然后我们将指定 `lightingShader.Program` 和选定的 `material.ambient`。然后我们将传递一些值。我们将只放入一些显式的值，如
    `1.0f`、`0.5f` 和 `0.31f`。
- en: 'Just copy and paste the previous code several times and make the following
    modifications as highlighted in the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需将前面的代码复制粘贴几次，并按照以下代码中突出显示的进行修改：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, while defining shininess we have added just 1 float value
    in `glUniform1f()` because the shininess wasn't a vector or an array, or anything
    like that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们定义光泽度时，我们在 `glUniform1f()` 中只添加了一个浮点值，因为光泽度不是一个向量或数组，或其他类似的东西。
- en: 'Now we are all set with the code. So let''s run this code and check the output
    that we get on our screen. You might get a similar output on your window:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了代码。所以让我们运行这段代码，并检查我们在屏幕上得到的输出。你可能在你的窗口中得到一个类似的结果：
- en: '![](img/79a6f756-ddd5-49dd-8106-7c41159bf02c.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79a6f756-ddd5-49dd-8106-7c41159bf02c.png)'
- en: 'You''ll observe a color changing cube on your screen. It looks exactly the
    way we want, just beautiful. Try moving the light and observe the shadow effect
    on the surface of the cube:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在屏幕上观察到颜色变化的立方体。它看起来正好是我们想要的，非常漂亮。尝试移动光源，并观察立方体表面的阴影效果：
- en: '![](img/857c756f-b5d4-4227-b71b-9928afee774b.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/857c756f-b5d4-4227-b71b-9928afee774b.png)'
- en: So that it's for using materials in OpenGL to add effects to our object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以在OpenGL中使用材质为我们的对象添加效果。
- en: Lightmaps
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照贴图
- en: 'Let''s discuss lightmaps in this section. But first, let''s try to understand
    what a lighting map is. Well, in the real world, if you have, let''s say, a crate
    that is partly metal and partly wood, similar to the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本节中讨论光照贴图。但首先，让我们尝试理解什么是光照贴图。好吧，在现实世界中，如果你有一个，比如说，部分是金属部分是木材的箱子，类似于以下截图：
- en: '![](img/95dea043-fbfc-4160-a359-6d21283a2528.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95dea043-fbfc-4160-a359-6d21283a2528.png)'
- en: The wooden parts of it will react differently to the light compared to the metal
    parts. It might sound obvious, but OpenGL (or any other sort of 3D graphics API)
    doesn't have a concept of wood or metal or plastic, or anything else and as a
    result, we need to program that in. We need to use other techniques to help illustrate
    that visually as the wood should be less shiny than the metal parts of the crate.
    If you search on lighting maps, you'll get a bunch of information. You can create
    them in various tools. You can use Maya or Photoshop to create them. So, without
    further ado, let's get down to the coding.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与金属部分相比，它的木质部分对光线的反应将不同。这听起来可能很明显，但OpenGL（或任何其他类型的3D图形API）没有木材、金属、塑料或其他任何概念，因此我们需要在程序中实现它。我们需要使用其他技术来帮助在视觉上说明这一点，因为木材应该比箱子的金属部分更不反光。如果你搜索光照贴图，你会得到很多信息。你可以在各种工具中创建它们。你可以使用Maya或Photoshop来创建它们。所以，不再拖延，让我们开始编码。
- en: Making modifications to shader files
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改着色器文件
- en: 'Follow the below mentioned steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: 'So, what you want to do is go to the lighting vertex shader. We need to make
    a few modifications to this because we removed the ability to apply textures,
    and we didn''t do that in the last couple of sections. So, we need to add that
    again. Take a look at the following modification to understand the changes made
    to the code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，您需要做的是转到光照顶点着色器。我们需要对其进行一些修改，因为我们移除了应用纹理的能力，而且在之前的几个部分中我们没有这样做。所以，我们需要再次添加它。查看以下修改以了解代码的更改：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Save these changes, and now we need to do a modification to the fragment shader.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改，现在我们需要对片段着色器进行修改。
- en: 'In `lighting. frag`, we''ll make the following changes to the code: We''ll
    get rid of all the code from the struct material and add fresh code to it. We''ll
    add `sampler2D diffuse` and `sampler2D specular`, and this is that specular lightmap
    that had the light part and the dark part on it. Then we''ll add `float shininess`.
    Shininess is always important:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `lighting. frag` 中，我们将对代码进行以下修改：我们将从结构体 material 中移除所有代码并添加新的代码。我们将添加 `sampler2D
    diffuse` 和 `sampler2D specular`，这就是那个带有亮部和暗部的镜面光图。然后我们将添加 `float shininess`。光泽度始终很重要：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the input, we also need the texture coordinate. So we''ll add `in vec2
    TexCoords`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于输入，我们还需要纹理坐标。因此，我们将添加 `in vec2 TexCoords`:'
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, `void main ()` in vec3 ambient needs to change slightly because we are
    using a texture. So, what we need to do is just get rid of `material.ambient`
    and add `vec3()` and inside that, we want to specify `texture()`. Inside this
    method, we're going to pass `material.diffuse` and `TexCoords`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`void main ()` 中的 `vec3 ambient` 需要稍作修改，因为我们正在使用纹理。所以，我们需要做的就是移除 `material.ambient`
    并添加 `vec3()`，在其中，我们想要指定 `texture()`。在这个方法中，我们将传递 `material.diffuse` 和 `TexCoords`。
- en: 'Now, for the diffuse light in the final calculation, `(diff * material.diffuse)`
    needs to change slightly, as we are using textures now. So, what we''re going
    to do is just get rid of the preceding term and add `light.diffuse * diff * vec3()`.
    To that, we''ll pass `texture()`, and in that, we''ll specify `material.diffuse`
    and `TexCoords`. The rest all is good. Let''s go down to specular now. In the
    final step, we just need to change it in a similar way to the previous one because
    we are using a texture now. Take a look at the following code to understand the
    description:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于最终计算中的漫反射光，`(diff * material.diffuse)` 需要稍作修改，因为我们现在正在使用纹理。所以，我们将移除前面的项并添加
    `light.diffuse * diff * vec3()`。我们将传递 `texture()`，并在其中指定 `material.diffuse` 和
    `TexCoords`。其余的都是好的。现在让我们转到镜面光。在最后一步，我们只需要以类似的方式修改它，因为我们现在正在使用纹理。查看以下代码以了解描述：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, we're all done with the shaders now. We can actually get to main.cpp.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经完成了着色器的所有工作。我们可以实际上转到 `main.cpp`。
- en: Changes to the main code to implement lightmaps
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现光照图的代码更改
- en: 'Let''s follow the below mentioned steps to implement the lightmaps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤实现光照图：
- en: In the main code, the first thing you'll need to change is the vertices, because
    at the moment we've got position and we've got the normals as well. We also need
    to specify the texture coordinates because we now are using a texture. You can
    refer to the updated vertices in the `main.cpp` file inside the `Lighting Maps`
    folder. Copy and paste the updated vertices to our main code.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主代码中，您需要更改的第一件事是顶点，因为我们目前有位置和法线。我们还需要指定纹理坐标，因为我们现在正在使用纹理。您可以参考 `Lighting Maps`
    文件夹中的 `main.cpp` 文件中的更新后的顶点。将更新后的顶点复制并粘贴到我们的主代码中。
- en: 'Next, go to the location where we''re binding the vertex and creating the vertex
    pointers. As we have added a texture system to our code, we need to modify the
    vertex pointer and the normal attribute slightly. As we''ve got eight pieces of
    information in our vertices array, we''ll replace the 6 with 8\. We also need
    to duplicate the Normal attribute code, paste it, and modify it for the texture
    attribute. Take a look at the following code to understand the modifications made:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到我们绑定顶点和创建顶点指针的位置。由于我们向代码中添加了纹理系统，我们需要稍微修改顶点指针和法线属性。由于我们的顶点数组中有八个信息，我们将用
    8 替换 6。我们还需要复制法线属性代码，粘贴它，并修改它以用于纹理属性。查看以下代码以了解所做的修改：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now let's take a look at the lighting array. In the position attribute, change
    the 6 to 8 for a similar reason as mentioned in the previous code.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看光照数组。在位置属性中，将 6 改为 8，原因与之前代码中提到的类似。
- en: 'You don''t have to necessarily do this before we do the projection, but we
    are going to. We''re just going to load the textures before we define our projection
    matrix. We''re going to create the diffuse and the specular maps as well, since
    you just load in two different textures. We''ve covered this before. So, we''ll
    add `GLuint`, `diffuseMap`, and `specularMap`. Then we''re adding `glGenTextures();`.
    And to that, we''ll pass the parameters for the `size` as `1`, and for the `pointer`
    we''re going to add `&diffuseMap` and copy and paste this code to save some time.
    We''ll make the following changes to the copied code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不必在我们进行投影之前做这件事，但我们会的。我们只是在定义投影矩阵之前加载纹理。我们还将创建漫反射和镜面反射图，因为你只加载了两个不同的纹理。我们之前已经讨论过这个问题。所以，我们将添加
    `GLuint`，`diffuseMap` 和 `specularMap`。然后我们添加 `glGenTextures();`。我们将传递参数 `size`
    为 `1`，对于 `pointer`，我们将添加 `&diffuseMap` 并复制粘贴此代码以节省时间。我们将对复制的代码进行以下更改：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we need to create an int for the texture width and height.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个用于纹理宽度和高度的整型变量。
- en: 'Then we are going to add `unsigned char *image`. This is essentially going
    to be the data of our image, because if you ever try to open up an image in some
    sort of text editor, you just get a bunch of characters. This is essentially what
    this is going to be storing:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加 `unsigned char *image`。这本质上将是我们的图像数据，因为如果你尝试在某种文本编辑器中打开图像，你只会得到一串字符。这正是它将要存储的内容：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, now we're going to add the diffuse map. We'll begin by adding `image = SOIL_LOAD_IMAGE();`.
    To this, first of all, we need to specify the file path of the image, which is
    `res/images/container2.png`. For the width and the height parameters, we just
    specify the `&textureWidth` and `&textureHeight` that we created before, because
    this is passing it in a reference, and it'll actually modify the original variable
    right here. For channels, put 0\. For `force_channels`, just put `SOIL_LOAD_RGB`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们将添加漫反射图。我们首先添加 `image = SOIL_LOAD_IMAGE();`。对于这个，首先我们需要指定图像的文件路径，它是 `res/images/container2.png`。对于宽度和高度参数，我们只需指定我们之前创建的
    `&textureWidth` 和 `&textureHeight`，因为这是以引用的形式传递的，它实际上会修改这里的原始变量。对于通道，输入 0。对于 `force_channels`，只需输入
    `SOIL_LOAD_RGB`。
- en: And in the next line, we need to add `glBindTexture();`. The parameter we'll
    pass for the target is just `GL_TEXTURE_2D` and for the texture, we just specify
    `diffuseMap`, because that's the one we're using at the moment.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，我们需要添加 `glBindTexture();`。我们将传递的目标参数是 `GL_TEXTURE_2D`，对于纹理，我们只需指定 `diffuseMap`，因为我们目前正在使用它。
- en: Now, on the next line we need to add `glTexImage2D();`. The parameter we'll
    pass for the target is just `GL_TEXTURE_2D`. For the level, put `0`. For the internal
    format, this is just `Gl_RGB` because it's got no alpha. For the width, you just
    put `textureWidth` then `textureHeight`. For the border, put `0`. For the format,
    put `GL_RGB`. For the type, we're going to put `GL_UNSIGNED_BYTE`. For the `pixels`,
    just specify the image data, which is `image`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在下一行我们需要添加 `glTexImage2D();`。我们将传递的目标参数是 `GL_TEXTURE_2D`。对于级别，输入 `0`。对于内部格式，这是
    `Gl_RGB`，因为它没有 alpha 通道。对于宽度，你只需输入 `textureWidth` 然后输入 `textureHeight`。对于边框，输入
    `0`。对于格式，输入 `GL_RGB`。对于类型，我们将输入 `GL_UNSIGNED_BYTE`。对于 `pixels`，只需指定图像数据，即 `image`。
- en: Next, we're just going to generate the mipmap, so add `glGenerateMipmap();`,
    and to that, we're going to pass `GL_TEXTURE_2D`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需生成米普图，所以添加 `glGenerateMipmap();`，并且我们将传递 `GL_TEXTURE_2D`。
- en: Then add `SOIL_free_image_data()`. Here, we'll just specify the image that we
    want to free.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加 `SOIL_free_image_data()`。在这里，我们将指定我们想要释放的图像。
- en: Next, we just need to specify the texture parameters in terms of the wrapping
    and the filtering. So, we'll add `glTextParameteri();`. For this, we'll pass the
    target parameter as `GL_TEXTURE_2D`. For the `name`, for what we're modifying,
    it is the wrap for now, so pass `GL_TEXTURE_WRAP_S a` and then pass `GL_REPEAT`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需指定纹理参数，包括包装和过滤。因此，我们将添加 `glTextParameteri();`。为此，我们将传递目标参数为 `GL_TEXTURE_2D`。对于
    `name`，我们现在修改的是包装，所以传递 `GL_TEXTURE_WRAP_S a` 然后传递 `GL_REPEAT`。
- en: 'Let''s just duplicate this code and paste it below. Check out the following
    code to understand the modifications we need to make:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制这段代码并将其粘贴在下面。查看以下代码以了解我们需要进行的修改：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And now we''re done with defining the diffuse map. What we''re going to do
    next is actually just duplicate all this code for the specular map because it''ll
    be a lot easier and because a lot of it''s going to stay the same. Take look at
    the following highlighted terms to understand the changes:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了漫反射图的定义。接下来我们要做的是实际上复制所有这些代码用于镜面图，因为它会容易得多，而且其中很多都将保持不变。看看以下突出显示的术语，以了解变化：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, at the end we unbound texture by defining`glBindTexture(
    GL_TEXTURE_2D, 0 );`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在最后通过定义`glBindTexture( GL_TEXTURE_2D, 0 );`来解绑纹理。
- en: 'And now, we just need to set the texture units for the lighting shader. So,
    we''re going to add `lightingShader.Use();`and on the next line we are going to
    add `glUniform1i`, and we''re going to specify `glGetUniformLocation lightingShader.Program`.
    And we just need to pass `material.diffuse` and `o` This is all stuff that we
    did in the shader, so feel free to look at that again if you just need a quick
    reminder. We''re all good now:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要设置光照着色器的纹理单元。所以，我们将添加`lightingShader.Use();`并在下一行添加`glUniform1i`，我们将指定`glGetUniformLocation
    lightingShader.Program`。我们只需要传递`material.diffuse`和`o`。这些都是我们在着色器中做的，所以如果你只是需要快速提醒，可以再次查看。我们现在一切都准备好了：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Modifying while loop
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改while循环
- en: 'We can actually start coding stuff within the while loop:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以在while循环中开始编写代码：
- en: 'We''re going to set the light''s properties. So, what we''re going to do is
    just get rid of all of the `lightColor` code and we''re going to add `glUniform3f();`.
    To that, we''ll pass `glGetUniformLocation()`, and to this, we''ll specify `lightingShader.Program`
    and we just need to specify the first aspect that we''re modifying, which is `light.
    ambient`, and we''re just going to put some hardcoded values in here: `0.2f`,
    `0.2f`, and `0.2f`.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置光源的属性。所以，我们要做的是删除所有的`lightColor`代码，并添加`glUniform3f();`。我们将传递`glGetUniformLocation()`，并指定`lightingShader.Program`，我们只需要指定我们正在修改的第一个方面，即`light.
    ambient`，我们只是在这里放入一些硬编码的值：`0.2f`、`0.2f`和`0.2f`。
- en: 'Let''s duplicate this so we''ve got three instances of it and make following
    modifications to it:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制这个，这样我们就有了三个实例，并对它进行以下修改：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So now, let''s set the material properties as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以现在，让我们按照以下方式设置材质属性：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we need to actually activate our textures, and bind them. So below `glUniformMatrix4fv();`
    we''ll add following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要真正激活我们的纹理，并将它们绑定。所以，在`glUniformMatrix4fv();`下面，我们将添加以下代码：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And you can copy and paste this for the binding of the specular texture map:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以复制并粘贴以下内容用于绑定镜面纹理图：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And now we are now ready to run it. You might observe the following output
    on your screen:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行它了。你可能会在屏幕上观察到以下输出：
- en: '![](img/81ddc49a-458e-435e-90ed-e656ad019ca9.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81ddc49a-458e-435e-90ed-e656ad019ca9.png)'
- en: 'Move around the cube; you will see that as we''re moving, the lighting affects
    the shape in a different way because when we were looking at it head on, there
    wasn''t much of a shine. There''s a bit towards the top right; that''s when we''re
    moving. It''s realistically affecting our object. As you move the light around
    you can see that only the metal part of it is shining:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 移动立方体；你会看到，当我们移动时，光照以不同的方式影响形状，因为我们正面看它时，几乎没有光泽。在右上角有一点；那就是我们移动的时候。它以逼真的方式影响我们的物体。当你移动光源时，你可以看到，只有金属部分在发光：
- en: '![](img/937b2fdf-d5c8-4934-8c62-653474d0363c.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/937b2fdf-d5c8-4934-8c62-653474d0363c.png)'
- en: Obviously, it depends on what sort of angle you're looking at the object from,
    because that's how it is in real life. So, that's it for lighting maps.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这取决于你从哪个角度观察这个物体，因为在现实生活中就是这样。所以，这就是灯光图的全部内容。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned to apply colors to our objects and create a light
    source such as a lamp in our game world. We then looked at the effects of light
    on the materials. We also understood the different types of lighting techniques:
    ambient, diffused, specular lighting. We explored the various materials and observed
    the effects of light on the materials. We concluded by learning about lightmaps
    in this chapter.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何给我们的物体着色，并在游戏世界中创建一个光源，比如灯。然后我们研究了光线对材料的影响。我们还了解了不同的光照技术：环境光、漫反射、镜面光照。我们探讨了各种材料，并观察了光线对材料的影响。我们通过学习本章中的光照图来结束。
- en: In the next chapter, we'll discuss about the different sources of light such
    as directional light, point light and spot light and how to combine those in our
    game world.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论不同光源的种类，例如方向光、点光源和聚光灯，以及如何在我们的游戏世界中将这些光源结合起来。
