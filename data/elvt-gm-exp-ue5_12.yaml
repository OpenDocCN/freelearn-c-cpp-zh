- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Animation Blending and Montages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画混合和蒙太奇
- en: In the previous chapter, you were able to bring the player character to life
    by implementing movement animations in a Blend Space and using that Blend Space
    in an Animation Blueprint to drive the animations based on the player’s speed.
    You were then able to implement functionality in C++ based on player input to
    allow the character to sprint. Lastly, you took advantage of the Animation State
    Machine built-in Animation Blueprints to drive the character’s movement state
    and jumping states to allow fluid transitions between walking and jumping.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您能够通过在混合空间中实现移动动画并使用该混合空间在动画蓝图中根据玩家的速度驱动动画，使玩家角色栩栩如生。然后，您能够根据玩家输入在C++中实现功能，使角色能够冲刺。最后，您利用内置的动画蓝图驱动角色的移动状态和跳跃状态，以允许在行走和跳跃之间实现流畅的过渡。
- en: With the player character’s Animation Blueprint and State Machine working, it’s
    time to introduce Animation Montages and Anim Slots by implementing the character’s
    `Throw` animation. In this chapter, you will learn more about animation blending,
    see how Unreal Engine handles the blending of multiple animations by creating
    an Animation Montage, and work with a new Anim Slot for the player’s throwing
    animation. From there, you will use the Anim Slot in the player’s Animation Blueprint
    by implementing new functions such as `Save Cached Pose` and `Layered blend per
    bone` so that the player can correctly blend the movement animations you handled
    in the previous chapter with the new throwing animation you will implement in
    this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色的动画蓝图和状态机运行正常时，是时候通过实现角色的`投掷`动画来介绍动画蒙太奇和动画槽位了。在本章中，您将了解更多关于动画混合的知识，通过创建动画蒙太奇来了解Unreal
    Engine如何处理多个动画的混合，并使用一个新的动画槽位来处理玩家投掷动画。从那里，您将通过实现新的功能，如`保存缓存的姿态`和`按骨骼分层混合`，在玩家的动画蓝图中使用动画槽位，以便玩家能够正确混合上一章中处理的移动动画和本章将实现的新投掷动画。
- en: 'In this chapter, you’ll learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: How to use Anim Slots to create layered animation blending for the player character
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用动画槽位为玩家角色创建分层动画混合
- en: Creating an Animation Montage for the character’s `Throw` animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为角色的`投掷`动画创建动画蒙太奇
- en: Using the `Layered blend per bone node` within the Animation Blueprint to blend
    together the upper body `Throw` animation and the lower body movement animations
    of the character
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动画蓝图内使用`按骨骼节点分层混合`来混合角色的上半身`投掷`动画和下半身动作动画
- en: By the end of this chapter, you will be able to use the `Animation Montage`
    tool to create a unique throwing animation using the `Throw` animation sequence
    you imported in [*Chapter 10*](B18531_10.xhtml#_idTextAnchor199), *Creating the
    SuperSideScroller Game*. With this montage, you will create and use Anim Slots
    that will allow you to blend animations in the Animation Blueprint for the player
    character. You will also get to know how to use blending nodes to effectively
    blend the movement and throwing animations of the character.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用`动画蒙太奇`工具，利用您在[*第10章*](B18531_10.xhtml#_idTextAnchor199)中导入的`投掷`动画序列创建一个独特的投掷动画。通过这个蒙太奇，您将创建并使用动画槽位，以便在玩家角色的动画蓝图中混合动画。您还将了解如何使用混合节点有效地混合角色的移动和投掷动画。
- en: After finalizing the player character animation, you will create the required
    class and assets for the enemy AI and learn more about Materials and Material
    Instances, which will give this enemy a unique visual color so that it can be
    differentiated in-game. Finally, the enemy will be ready for [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268),
    *Creating and Adding the Enemy Artificial Intelligence*, where you will begin
    to create the AI behavior logic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终确定玩家角色动画后，您将创建所需的类和资产用于敌人AI，并了解更多关于材质和材质实例的知识，这将给这个敌人一个独特的视觉颜色，以便在游戏中区分。最后，敌人将准备好进入[*第13章*](B18531_13.xhtml#_idTextAnchor268)，*创建和添加敌人人工智能*，在那里您将开始创建AI行为逻辑。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need Unreal Engine 5 installed
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要安装 Unreal Engine 5
- en: Let’s start by learning about what Animation Montages and Anim Slots are and
    how they can be used for character animation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解动画蒙太奇和动画槽位是什么以及它们如何用于角色动画开始。
- en: 'The project for this chapter can be found in the Chapter12 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的Chapter12文件夹中找到，该代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Animation blending, Anim Slots, and Animation Montages
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画混合、动画槽和动画蒙太奇
- en: Animation blending is the process of transitioning between multiple animations
    on a skeletal mesh as seamlessly as possible. You are already familiar with the
    techniques of animation blending because you created a `Blend` `Spaces` asset
    for the player character in [*Chapter 11*](B18531_11.xhtml#_idTextAnchor222),
    *Working with Blend Space 1D, Key Bindings, and State Machines*. In this Blend
    Space, the character smoothly blends between the `Idle`, `Walking`, and `Running`
    animations. You will now extend this knowledge by exploring and implementing new
    additive techniques to combine the movement animations of the character with a
    throwing animation. Through the use of an Anim Slot, you will send the throwing
    animation to a set of upper body bones, and its children’s bones, to allow movement
    and throwing animations to apply at the same time without negatively impacting
    the other. But first, let’s talk more about Animation Montages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 动画混合是将多个动画在骨骼网格上尽可能无缝地过渡的过程。你已经熟悉了动画混合的技术，因为你为玩家角色在[*第11章*](B18531_11.xhtml#_idTextAnchor222)，*使用一维混合空间、按键绑定和状态机*中创建了一个`Blend`
    `Spaces`资产。在这个混合空间中，角色可以在`Idle`、`Walking`和`Running`动画之间平滑过渡。现在，你将通过探索和实现新的加法技术来扩展这一知识，将这些动画与投掷动画结合起来。通过使用动画槽（Anim
    Slot），你将投掷动画发送到一组上半身骨骼及其子骨骼，以便在同时应用移动和投掷动画时不会对其他动画产生负面影响。但在开始之前，让我们更多地讨论一下动画蒙太奇。
- en: Animation Montages are very powerful assets that allow you to combine multiple
    animations and split these combined animations into what are called **Sections**.
    Sections can then be played back individually, in a specific sequence, or even
    looped.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蒙太奇是非常强大的资产，允许你将多个动画组合起来，并将这些组合动画分割成所谓的**部分**。然后，这些部分可以单独播放，按照特定的顺序播放，甚至循环播放。
- en: Animation Montages are also useful because you can control animations through
    montages from Blueprints or C++; this means you can call logic, update variables,
    replicate data, and so on, based on the animation section being played, or if
    any Notifies are called within the montage. In C++, there is the `UAnimInstance`
    object, which you can use to call functions such as `UAnimInstance::Montage_Play`,
    which allows you to access and play montages from C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蒙太奇也很有用，因为你可以通过蓝图或C++从蒙太奇中控制动画；这意味着你可以根据正在播放的动画部分或蒙太奇中是否调用了任何Notifies来调用逻辑、更新变量、复制数据等。在C++中，有一个`UAnimInstance`对象，你可以用它来调用如`UAnimInstance::Montage_Play`之类的函数，这允许你从C++访问和播放蒙太奇。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method will be used in [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298),
    *Spawning the Player Projectile*, when you will begin to add polish to the game.
    More information about how animations and Notifies are handled by Unreal Engine
    5 in C++ can be found at [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.xhtml).
    You will learn more about Notifies in the first exercise of this chapter, and
    you will code your own notify state in [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298),
    *Spawning the Player Projectile*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将在[*第14章*](B18531_14.xhtml#_idTextAnchor298)，*生成玩家投射物*中使用，届时你将开始为游戏添加细节。有关Unreal
    Engine 5在C++中如何处理动画和Notifies的更多信息，请参阅[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.xhtml)。你将在本章的第一个练习中了解更多关于Notifies的信息，并在[*第14章*](B18531_14.xhtml#_idTextAnchor298)，*生成玩家投射物*中编写你自己的通知状态。
- en: 'The following figure shows the Persona editor for Animation Montages. However,
    this will be broken down even further in *Exercise 12.01*, *Setting up the Animation
    Montage*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了动画蒙太奇的Persona编辑器。然而，在*练习12.01*，*设置动画蒙太奇*中，这将进一步分解：
- en: '![Figure 12.1 – The Persona editor, which opens when editing an Animation Montage
    ](img/Figure_12.01_B18531.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 当编辑动画蒙太奇时打开的Persona编辑器](img/Figure_12.01_B18531.jpg)'
- en: Figure 12.1 – The Persona editor, which opens when editing an Animation Montage
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 当编辑动画蒙太奇时打开的Persona编辑器
- en: Just like in Animation Sequences, Animation Montages allow Notifies to be triggered
    along the timeline of a section of an animation, which can then trigger sounds,
    particle effects, and events. Event Notifies will allow us to call logic from
    Blueprint or C++. Epic Games provides an example in their documentation of a weapon
    reload Animation Montage that is split between animations for `reload start`,
    `reload loop`, and `reload complete`. By splitting these animations and applying
    Notifies for sounds and events, developers have complete control over how long
    the `reload loop` animation will play based on internal variables, and control
    over any additional sounds or effects to play during the course of the animation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在动画序列中一样，动画蒙太奇允许在动画某个部分的时间线上触发通知，然后可以触发声音、粒子效果和事件。事件通知将允许我们从蓝图或C++中调用逻辑。Epic
    Games在其文档中提供了一个示例，即一个武器装填动画蒙太奇，它被分为`reload start`、`reload loop`和`reload complete`的动画。通过将这些动画拆分并应用声音和事件的通知，开发者可以完全控制`reload
    loop`动画的播放时长，基于内部变量，并控制动画过程中播放的任何附加声音或效果。
- en: Lastly, Animation Montages support **Anim Slots**. Anim Slots allow you to categorize
    an animation, or a set of animations, that can later be referenced in Animation
    Blueprints to allow unique blending behavior based on the slot. This means that
    you can define an Anim Slot that can later be used in Animation Blueprints to
    allow animations using this slot to blend on top of the base movement animations
    in any way you want; in our case, only affecting the upper body of the player
    character and not the lower body.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，动画蒙太奇支持**动画槽**。动画槽允许你分类一个动画或一组动画，以后可以在动画蓝图中引用，以允许基于槽的独特混合行为。这意味着你可以定义一个动画槽，以后可以在动画蓝图中使用，以允许使用此槽的动画以任何你想要的方式在基本移动动画之上混合；在我们的案例中，仅影响玩家角色的上半身，而不影响下半身。
- en: Let’s begin by creating the Animation Montage for the player character’s `Throw`
    animation in the first exercise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建玩家角色在第一个练习中的`Throw`动画蒙太奇开始。
- en: Exercise 12.01 – Setting up the Animation Montage
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01 – 设置动画蒙太奇
- en: One of the first things you need to do for the player character is to set up
    the Anim Slot that will separately categorize this animation as an upper-body
    animation. You will use this Anim Slot in conjunction with blending functions
    in the Animation Blueprint to allow the player character to throw a projectile,
    while still correctly animating the lower body while moving and jumping.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家角色，你需要做的第一件事是为这个动画设置一个动画槽，以便将其单独分类为上半身动画。你将使用这个动画槽与动画蓝图中的混合函数一起使用，以便玩家角色在投掷投射物的同时，还能正确地动画化移动和跳跃时的下半身。
- en: By the end of this exercise, the player character will be able to play the `Throw`
    animation only with their upper body, while their lower body will still use the
    movement animation that you defined in the previous chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习结束时，玩家角色将只能用上半身播放`Throw`动画，而下半身仍将使用你在上一章中定义的移动动画。
- en: 'Let’s begin by creating the Animation Montage for the character, throwing and
    setting up the Anim Slot there:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为角色创建动画蒙太奇，将动画槽设置在那里：
- en: First, navigate to the `/MainCharacter/Animation` directory, which is where
    all of the animation assets are located.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到`/MainCharacter/Animation`目录，这是所有动画资产所在的位置。
- en: Now, right-click in the content drawer and hover over the **Animation** option
    from the available drop-down menu.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在内容抽屉中右键单击，并将鼠标悬停在可用的下拉菜单中的**动画**选项上。
- en: Then, left-click to select the **Animation Montage** option from the additional
    drop-down menu that appears.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，左键单击以从出现的附加下拉菜单中选择**动画蒙太奇**选项。
- en: Just as with creating other animation-based assets, such as `Blend Spaces` or
    `Animation Blueprints`, Unreal Engine will ask you to assign a `Skeleton` object
    for this Animation Montage. In this case, select `MainCharacter_Skeleton`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像创建其他基于动画的资产一样，例如`Blend Spaces`或`Animation Blueprints`，Unreal Engine将要求你为这个动画蒙太奇分配一个`Skeleton`对象。在这种情况下，选择`MainCharacter_Skeleton`。
- en: Name the new Animation Montage `AM_Throw`. Now, double-left-click to open the
    montage.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的动画蒙太奇命名为`AM_Throw`。现在，双击左键打开蒙太奇。
- en: When you open the `Animation Montage` asset, you are presented with a similar
    editor layout as you would when opening an Animation Sequence. There is a **Preview**
    window that shows the main character skeleton in the default T pose, but once
    you add animations to this montage, the skeleton will update to reflect those
    changes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开`动画蒙太奇`资产时，您会看到一个类似于打开动画序列时的编辑器布局。有一个**预览**窗口显示默认的 T 形的的主要角色骨骼，但一旦您向这个蒙太奇添加动画，骨骼将更新以反映这些变化。
- en: With this exercise complete, you have successfully created an `Throw` animation
    and Anim Slot you need in order to blend the `Throw` animation with the existing
    character movement animations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经成功创建了一个`投掷`动画和动画槽，这是您将`投掷`动画与现有的角色移动动画混合所需的。
- en: Animation Montages
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画蒙太奇
- en: 'Have a look at the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图：
- en: '![Figure 12.2 – The Preview window alongside the Montage and Sections areas
    ](img/Figure_12.02_B18531.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 预览窗口与蒙太奇和部分区域并排](img/Figure_12.02_B18531.jpg)'
- en: Figure 12.2 – The Preview window alongside the Montage and Sections areas
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 预览窗口与蒙太奇和部分区域并排
- en: 'Underneath the **Preview** window, you have the main montage timeline, in addition
    to other sections. Let’s evaluate these sections from top to bottom:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在**预览**窗口下方，您可以看到主要的时间线蒙太奇，以及其他部分。让我们从上到下评估这些部分：
- en: '**Montage**: The **Montage** section is a collection of animations that can
    have one or more animations. You can also right-click on any point in the timeline
    to create a section.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蒙太奇**：**蒙太奇**部分是一系列可以包含一个或多个动画的动画集合。您还可以在时间线上的任何位置右键单击以创建一个部分。'
- en: '**Montage Sections**: Sections allow you to compartmentalize the different
    parts of the montage into their own self-contained section, which allows you to
    set the order of how the individual animation sequences are played and whether
    a section should loop.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蒙太奇部分**：部分允许您将蒙太奇的不同部分划分到各自的独立部分中，这使得您可以设置单个动画序列的播放顺序以及是否应该循环播放。'
- en: 'For the purposes of the `Throw` montage, you do not need to use this feature
    since you will only be using one animation in this montage:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`投掷`蒙太奇，您不需要使用此功能，因为您在这个蒙太奇中只会使用一个动画：
- en: '**Timing**: The **Timing** section gives you a preview of the montage and the
    sequential order of the varied aspects of the montage. The playback order of **Notifies**,
    the **Montage** section, and other elements will be visually displayed here to
    give you a quick preview of how the montage will work.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间控制**：**时间控制**部分为您提供了蒙太奇的预览以及蒙太奇各变化方面的顺序。**通知**、**蒙太奇**部分和其他元素的播放顺序将在这里以视觉方式显示，以便您快速预览蒙太奇的工作方式。'
- en: '`Play Sound` or `Play Particle Effect`, allow you to play a sound or particle
    at a specific time in the animation. You will use these Notifies later on in this
    project when you implement the throwing projectile:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`播放声音`或`播放粒子效果`，允许您在动画的特定时间播放声音或粒子。您将在本项目的后续部分使用这些通知来实现投掷投射物：'
- en: '![Figure 12.3 – The Timing and Notifies areas ](img/Figure_12.03_B18531.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 时间和通知区域](img/Figure_12.03_B18531.jpg)'
- en: Figure 12.3 – The Timing and Notifies areas
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 时间和通知区域
- en: Now that you are familiar with the interface for Animation Montages, you can
    add the `Throw` animation to the montage by following the next exercise.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了动画蒙太奇的界面，您可以通过以下练习将`投掷`动画添加到蒙太奇中。
- en: Exercise 12.02 – Adding the Throw animation to the montage
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.02 – 向蒙太奇添加投掷动画
- en: 'Now that you have a better understanding of what Animation Montages are and
    how these assets work, it is time to add the `Throw` animation to the montage
    you created in *Exercise 12.01*, *Setting up the Animation Montage*. Although
    you will only be adding one animation to this montage, it is important to emphasize
    that you can add multiple unique animations to a montage that you can then play
    back. Now, let’s start by adding the `Throw` animation you imported into the project
    in [*Chapter 10*](B18531_10.xhtml#_idTextAnchor199), *Creating the SuperSideScroller
    Game*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经更好地理解了动画蒙太奇是什么以及这些资产是如何工作的，是时候将`投掷`动画添加到您在*练习 12.01*，*设置动画蒙太奇*中创建的蒙太奇中了。尽管您只会向这个蒙太奇添加一个动画，但重要的是要强调，您可以将多个独特的动画添加到蒙太奇中，然后播放它们。现在，让我们首先添加您在[*第
    10 章*](B18531_10.xhtml#_idTextAnchor199)，*创建 SuperSideScroller 游戏*中导入到项目中的`投掷`动画：
- en: 'In `Throw` animation asset. Then, left-click and drag it onto the timeline
    in the **Montage** section:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`投掷`动画资产中。然后，左键单击并拖动它到**蒙太奇**部分的时序线上：
- en: '![Figure 12.4 – The Asset Browser window with animation-based assets ](img/Figure_12.04_B18531.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 带有基于动画资产的资产浏览器窗口](img/Figure_12.04_B18531.jpg)'
- en: Figure 12.4 – The Asset Browser window with animation-based assets
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 带有基于动画资产的资产浏览器窗口
- en: 'Once an animation is added to the Animation Montage, the character skeleton
    in the **Preview** window will update to reflect this change and begin playing
    the animation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦动画被添加到动画蒙太奇中，**预览**窗口中的角色骨骼将更新以反映这一变化并开始播放动画：
- en: '![Figure 12.5 – The player character begins to animate ](img/Figure_12.05_B18531.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 玩家角色开始动画](img/Figure_12.05_B18531.jpg)'
- en: Figure 12.5 – The player character begins to animate
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 玩家角色开始动画
- en: Now that the `Throw` animation has been added to the Animation Montage, you
    can move on to create the Anim Slot.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`投掷`动画已经被添加到动画蒙太奇中，你可以继续创建动画槽。
- en: The **Anim Slot Manager** tab should be docked next to the **Asset Browser**
    tab on the right-hand side. If you don’t see the **Anim Slot Manager** tab, you
    can access it by navigating to the **Window** tab in the toolbar at the top of
    the **Animation Montage** editor window. There, left-click to select the option
    for **Anim Slot Manager**, and the window will appear.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画槽管理器**标签应停靠在右侧的**资产浏览器**标签旁边。如果你看不到**动画槽管理器**标签，可以通过导航到**动画蒙太奇**编辑器窗口顶部的工具栏中的**窗口**标签来访问它。在那里，左键单击以选择**动画槽管理器**选项，窗口将出现。'
- en: By completing this exercise, you have added the `Throw` animation to your new
    Animation Montage and you were able to play back the animation to preview how
    it looks in the editor through **Persona**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经将`投掷`动画添加到了你的新动画蒙太奇中，并且能够通过**角色**预览编辑器中动画的外观。
- en: Now, you can move on to learn more about Anim Slots and Anim Slot Manager before
    adding your own unique Anim Slot to use for animation blending later in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在添加你自己的独特动画槽到本章后面用于动画混合之前，学习更多关于动画槽和动画槽管理器的知识。
- en: Anim Slot Manager
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画槽管理器
- en: '`Face` to articulate to others that the slots within this group affect the
    face of the character. By default, Unreal Engine provides you with a group called
    `DefaultGroup` and an Anim Slot called `DefaultSlot`, which is in that group.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Face`来向他人表明此组中的槽位会影响角色的面部。默认情况下，虚幻引擎为你提供了一个名为`DefaultGroup`的组和一个名为`DefaultSlot`的动画槽，它在该组中。'
- en: In the following exercise, we will create a new Anim Slot specifically for the
    upper body of the player character.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将为玩家角色的上半身创建一个新的动画槽。
- en: Exercise 12.03 – Adding a new Anim Slot
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03 – 添加新的动画槽
- en: Now that you have a better understanding of Anim Slots and `Upper Body`. Once
    you have this new slot created, it can then be used and referenced in your Animation
    Blueprint to handle animation blending, which you will do in a later exercise.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对动画槽和`上半身`有了更好的理解。一旦创建了新的槽位，它就可以在动画蓝图中被使用和引用来处理动画混合，你将在后面的练习中这样做。
- en: 'Let’s create the Anim Slot by doing the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建动画槽：
- en: In **Anim Slot Manager**, left-click on the **Add Slot** option.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画槽管理器**中，左键单击**添加槽位**选项。
- en: When adding a new slot, Unreal will ask you to give this Anim Slot a name. Name
    this slot `Upper Body`. Anim Slot naming is important, much like naming any other
    assets and parameters, as you will be referencing this slot in the Animation Blueprint
    later.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当添加新的槽位时，虚幻引擎会要求你为此动画槽命名。将此槽命名为`Upper Body`。动画槽命名很重要，就像命名任何其他资产和参数一样，因为你将在动画蓝图稍后引用此槽位。
- en: With the Anim Slot created, you can now update the slot used for the Throw montage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了动画槽后，你现在可以更新用于`投掷`蒙太奇的槽位。
- en: 'In the `DefaultGroup.DefaultSlot`. Left-click, and from the drop-down menu,
    select `DefaultGroup.Upper Body`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DefaultGroup.DefaultSlot`中。左键单击，并从下拉菜单中选择`DefaultGroup.Upper Body`：
- en: '![Figure 12.6 – The new Anim Slot will appear in the drop-down list ](img/Figure_12.06_B18531.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 新的动画槽将出现在下拉列表中](img/Figure_12.06_B18531.jpg)'
- en: Figure 12.6 – The new Anim Slot will appear in the drop-down list
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 新的动画槽将出现在下拉列表中
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After changing the Anim Slot, you may notice that the player character stops
    animating and returns to the T pose. Don’t worry – if this happens, just close
    the Animation Montage and reopen it. Once reopened, the character will play the
    `Throw` animation again.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改动画槽后，你可能注意到玩家角色停止了动画并回到了T姿态。别担心——如果发生这种情况，只需关闭动画蒙太奇并重新打开它。一旦重新打开，角色将再次播放`投掷`动画。
- en: With your Anim Slot created and in place in the `Throw` montage, it is now time
    for you to update the Animation Blueprint so that the player character is aware
    of this slot and animates correctly based on it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的动画槽在`投掷`蒙太奇中创建并放置好后，现在是你更新动画蓝图的时候了，以便玩家角色能够意识到这个槽并根据它正确地动画化。
- en: With this exercise complete, you have created your first Anim Slot using Anim
    Slot Manager, available in the Animation Montage. With this slot in place, it
    can now be used and referenced in the player character Animation Blueprint to
    handle the animation blending required to blend the `Throw` animation and the
    movement animations you implemented in the previous chapter. Before you do this,
    you need to learn more about the `Save Cached Pose` node in Animation Blueprints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已使用动画蒙太奇中的动画槽管理器创建了你的第一个动画槽。有了这个槽，现在它可以在玩家角色动画蓝图中使用和引用，以处理混合`投掷`动画和你在上一章中实现的移动动画所需的动画混合。在你这样做之前，你需要更多地了解动画蓝图中的`保存缓存姿态`节点。
- en: Save Cached Pose
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存缓存姿态
- en: There are cases when working with complex animations and characters requires
    you to reference a pose that is outputted by a State Machine in more than one
    place. If you hadn’t noticed already, the output pose from your `Movement` State
    Machine cannot be connected to more than one other node. This is where the `Save
    Cached Pose` node comes in handy; it allows you to cache (or store) a pose that
    can then be referenced in multiple places at once. You will need to use this to
    set up the new Anim Slot for the upper body animation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复杂动画和角色时，有时需要你在多个地方引用由状态机输出的姿态。如果你还没有注意到，你的`移动`状态机的输出姿态不能连接到多个其他节点。这就是`保存缓存姿态`节点派上用场的地方；它允许你缓存（或存储）一个姿态，然后可以同时引用多个地方。你需要使用这个来设置新的上半身动画槽。
- en: In the next exercise, you will implement the `Save Cached Pose` node to cache
    the `Movement` State Machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将实现`保存缓存姿态`节点以缓存`移动`状态机。
- en: Exercise 12.04 – Save Cached Pose of the Movement State Machine
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04 – 保存移动状态机的缓存姿态
- en: 'To effectively blend the `Throw` animation, which uses the `Upper Body` Anim
    Slot you created in the previous exercise with the movement animations already
    in place for the player character, you need to be able to reference the `Movement`
    State Machine in the Animation Blueprint. To do this, do the following to implement
    the `Save Cached Pose` node in the Animation Blueprint:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地混合使用你之前练习中创建的`Upper Body`动画槽的`投掷`动画，你需要能够在动画蓝图中引用`移动`状态机。为此，你需要在动画蓝图中执行以下操作以实现`保存缓存姿态`节点：
- en: 'In the Anim Graph of `AnimBP_SuperSideScroller_MainCharacter`, right-click
    and search for `New Save Cached Pose`. Name this `Movement Cache`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AnimBP_SuperSideScroller_MainCharacter`的动画图中，右键单击并搜索`新建保存缓存姿态`。将此命名为`移动缓存`：
- en: '![Figure 12.7 – The pose will be evaluated once per frame and then cached ](img/Figure_12.07_B18531.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 每帧将评估一次姿态，然后进行缓存](img/Figure_12.07_B18531.jpg)'
- en: Figure 12.7 – The pose will be evaluated once per frame and then cached
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 每帧将评估一次姿态，然后进行缓存
- en: 'Now, instead of connecting your `Movement` state machine directly to the output
    pose, connect it to the cache node:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你不需要直接将`移动`状态机连接到输出姿态，而是将其连接到缓存节点：
- en: '![Figure 12.8 – The Movement State Machine is being cached ](img/Figure_12.08_B18531.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 移动状态机正在被缓存](img/Figure_12.08_B18531.jpg)'
- en: Figure 12.8 – The Movement State Machine is being cached
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 移动状态机正在被缓存
- en: With the `Movement` State Machine pose being cached, all you have to do now
    is reference it. This can be done by searching for the `Use Cached Pose` node.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`移动`状态机的姿态被缓存后，你现在只需引用它。这可以通过搜索`使用缓存姿态`节点来完成。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All cached poses will show in the context-sensitive menu. Just make sure you
    select the cached pose with the name you gave it in *step 1*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有缓存的姿态都会显示在上下文相关菜单中。只需确保你选择你根据*步骤1*给出的名称的缓存姿态。
- en: 'With the cached pose node available, connect it to `Output Pose` of the Anim
    Graph:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在缓存的姿态节点可用的情况下，将其连接到动画图的`输出姿态`：
- en: '![Figure 12.9 – The cached pose is now feeding directly to Output Pose ](img/Figure_12.09_B18531.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 缓存的姿态现在直接输入到输出姿态](img/Figure_12.09_B18531.jpg)'
- en: Figure 12.9 – The cached pose is now feeding directly to Output Pose
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 缓存的姿态现在直接输入到输出姿态
- en: 'You will notice now, after *step 4*, that the main character will animate correctly
    and move as you expect after the last chapter. This proves that the caching of
    the `Movement` State Machine is working. The following figure shows the player
    character back in his `Idle` animation in the **Preview** window of the Animation
    Blueprint:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在完成*步骤4*之后，你会发现主角将按照你的预期正确动画并移动。这证明了`移动`状态机的缓存正在工作。以下图显示了玩家角色在动画蓝图**预览**窗口中的`空闲`动画：
- en: '![Figure 12.10 – The main character is animating as expected ](img/Figure_12.10_B18531.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 主角按照预期进行动画](img/Figure_12.10_B18531.jpg)'
- en: Figure 12.10 – The main character is animating as expected
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 主角按照预期进行动画
- en: 'Now that you have the caching of the `Movement` State Machine working, you
    will use this cache to blend animations through the skeleton based on the Anim
    Slot you created:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经让`移动`状态机的缓存工作正常，你将使用这个缓存通过你创建的动画槽基于骨骼混合动画：
- en: With this exercise complete, you now have the ability to reference the cached
    `Movement` State Machine pose anywhere you would like within the Animation Blueprint.
    With this accessibility in place, you can now use the cached pose to begin the
    blending between the cached movement pose and the `Upper Body` Anim Slot using
    a function called `Layered blend per bone`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在可以在动画蓝图中的任何位置引用缓存的`移动`状态机姿态。有了这种可访问性，你现在可以使用缓存的姿态通过一个名为`Layered
    blend per bone`的函数开始缓存的移动姿态和`上半身`动画槽之间的混合。
- en: Layered blend per bone
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层级混合每骨
- en: The node that you will use to blend animations here is called `Layered blend
    per bone`. This node masks out a set of bones on the character’s skeleton for
    an animation to ignore those bones.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这里用于混合动画的节点被称为`Layered blend per bone`。这个节点遮罩掉角色骨骼上的一组骨骼，使动画忽略这些骨骼。
- en: In the case of our player character and the `Throw` animation, you will mask
    out the lower body so that only the upper body animates. The goal is to be able
    to perform the `Throw` and movement animations at the same time and have these
    animations blend together; otherwise, when you perform the throw, the movement
    animations would completely break.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们玩家角色的`投掷`动画情况下，你需要将下半身遮罩掉，这样只有上半身会进行动画。目标是能够同时执行`投掷`和移动动画，并且让这些动画能够混合在一起；否则，当你执行投掷时，移动动画将会完全中断。
- en: In the following exercise, you will use `Layered blend per bone` to mask out
    the lower half of the player character so that the `Throw` animation only affects
    the upper body of the character.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将使用`Layered blend per bone`遮罩掉玩家角色的下半身，这样`投掷`动画只会影响角色的上半身。
- en: Exercise 12.05 – Blending animation with the Upper Body Anim Slot
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05 – 使用上半身动画槽混合动画
- en: The `Layered blend per bone` function allows us to blend the `Throw` animation
    with the movement animations you implemented in the previous chapter, and give
    you control over how much influence the `Throw` animation will have on the player
    character’s skeleton.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layered blend per bone`函数允许我们将`投掷`动画与你在上一章中实现的移动动画混合，并让你控制`投掷`动画对玩家角色骨骼的影响程度。'
- en: In this exercise, you will use the `Layered blend per bone` function to completely
    mask out the lower body of the character when playing the `Throw` animation so
    that it does not influence the character movement animation of the lower body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`Layered blend per bone`函数在播放`投掷`动画时完全遮罩掉角色的下半身，这样它就不会影响角色的下半身移动动画。
- en: 'Let’s begin by adding the `Layered blend per bone` node and discussing its
    input parameters and its settings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加`Layered blend per bone`节点并讨论其输入参数及其设置开始：
- en: 'Inside the Animation Blueprint, right-click and search for `Layered blend per
    bone` in the `Layered blend per bone` node and its parameters:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画蓝图内部，右键点击并搜索`Layered blend per bone`节点及其参数：
- en: The first parameter, `Base Pose`, is for the base pose of the character; in
    this case, the cached pose of the `Movement` State Machine will be the base pose.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数`基础姿态`是角色的基础姿态；在这种情况下，`运动`状态机的缓存姿态将是基础姿态。
- en: The second parameter is the `Blend Poses 0` node that you want to layer on top
    of `Base Pose`; keep in mind that selecting `Blend Poses` and `Blend Weights`
    parameters. For now, you will only be working with one `Blend Poses` node.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是`混合姿态 0`节点，您希望将其叠加到`基础姿态`之上；请注意选择`混合姿态`和`混合权重`参数。目前，您将只使用一个`混合姿态`节点。
- en: 'The last parameter is `Blend Weights`, which is how much `Blend Poses` will
    affect `Base Pose` on a scale from `0.0` to `1.0` as an alpha:'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是`混合权重`，它表示`混合姿态`对`基础姿态`的影响程度，范围从`0.0`到`1.0`，作为一个alpha值：
- en: '![Figure 12.11 – The Layered blend per bone node ](img/Figure_12.11_B18531.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 每个骨骼节点的分层混合](img/Figure_12.11_B18531.jpg)'
- en: Figure 12.11 – The Layered blend per bone node
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 每个骨骼节点的分层混合节点
- en: Before you connect anything to this node, you will need to add a layer to its
    properties.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将任何内容连接到该节点之前，您需要为其属性添加一个层级。
- en: Left-click to select the node and navigate to `0`, of this setup. Left-click
    on **+** next to **Branch Filters** to create a new filter.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击选择节点并导航到此设置中的`0`。左键单击`分支过滤器`旁边的**+**以创建一个新过滤器。
- en: 'There are again two parameters here, namely the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里又有两个参数，即以下内容：
- en: '`Bone Name`: The bone to specify where the blending will take place and determine
    the child hierarchy of bones masked out. In the case of the main character skeleton
    for this project, set `Bone Name` to `Spine`. *Figure 12.12* shows how the `Spine`
    bone and its children are unassociated with the lower body of the main character.
    This can be seen in the `Skeleton` asset, `MainCharacter_Skeleton`:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`骨骼名称`：指定混合将发生的位置，并确定被遮罩的骨骼的子节点层次结构。对于本项目的主体角色骨骼，将`骨骼名称`设置为`Spine`。*图12.12*显示了`Spine`骨骼及其子节点与主要角色的下半身无关联。这可以在`骨骼`资产`MainCharacter_Skeleton`中看到：'
- en: '![Figure 12.12 – The Spine bone and its children are associated with the upper
    body of the main character ](img/Figure_12.12_B18531.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 脊椎骨及其子节点与主要角色的上半身相关联](img/Figure_12.12_B18531.jpg)'
- en: Figure 12.12 – The Spine bone and its children are associated with the upper
    body of the main character
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 脊椎骨及其子节点与主要角色的上半身相关联
- en: '`Blend Depth`: The depth in which bones and their children will be affected
    by the animation. A value of `0` will not affect the rooted children of the selected
    bone.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`混合深度`：骨骼及其子节点受动画影响的深度。值为`0`将不会影响所选骨骼的根节点子节点。'
- en: '`Mesh Space Rotation Blend`: Determines whether or not to blend bone rotations
    in mesh space or local space. Mesh space rotation refers to the skeletal mesh’s
    bounding box as its base rotation, while local space rotation refers to the local
    rotation of the bone name in question. In this case, we want the rotation blend
    to occur in mesh space, so we will set this parameter to `true`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网格空间旋转混合`：确定是否在网格空间或局部空间中混合骨骼旋转。网格空间旋转指的是骨骼网格的边界框作为其基础旋转，而局部空间旋转指的是所讨论骨骼名称的局部旋转。在这种情况下，我们希望旋转混合在网格空间中发生，因此我们将此参数设置为`true`。'
- en: 'Blending is propagated to all the children of a bone to stop blending on particular
    bones, add them to the array, and make their blend depth value `0`. The final
    result is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 混合会传播到骨骼的所有子节点，以停止特定骨骼的混合，将它们添加到数组中，并使它们的混合深度值为`0`。最终结果如下：
- en: '![Figure 12.13 – You can set up multiple layers with one blend node ](img/Figure_12.13_B18531.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 您可以使用一个混合节点设置多个层级](img/Figure_12.13_B18531.jpg)'
- en: Figure 12.13 – You can set up multiple layers with one blend node
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 您可以使用一个混合节点设置多个层级
- en: 'With the settings in place on the `Layered blend per bone` node, you can connect
    the `Movement Cache` cached pose into the `Base Pose` node of the layered blend.
    Make sure you connect the output of the `Layered blend per bone` node to `Output
    Pose` of the Animation Blueprint:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`分层混合每个骨骼`节点上设置好设置后，您可以将`运动缓存`缓存的姿态连接到分层混合的`基础姿态`节点。确保将`分层混合每个骨骼`节点的输出连接到动画蓝图中的`输出姿态`：
- en: '![Figure 12.14 – Add the cached pose for the Movement State Machine to the
    Layered blend per bone node ](img/Figure_12.14_B18531.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 将运动状态机的缓存姿态添加到分层混合每个骨骼节点](img/Figure_12.14_B18531.jpg)'
- en: Figure 12.14 – Add the cached pose for the Movement State Machine to the Layered
    blend per bone node
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 将运动状态机的缓存姿态添加到分层混合每个骨骼节点
- en: Now, it’s time to use the Anim Slot you created earlier to filter only the animations
    using this slot through the `Layered blend per bone` node.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用你之前创建的动画槽来通过`Layered blend per bone`节点过滤仅使用此槽的动画了。
- en: Right-click in the Anim Graph and search for `DefaultSlot`. Left-click to select
    the `Slot` node and navigate to `Slot Name` property. Left-click on this dropdown
    to find and select the `DefaultGroup.Upper Body` slot.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画图中右键单击并搜索`DefaultSlot`。左键单击选择`Slot`节点，并导航到`Slot Name`属性。左键单击此下拉菜单以查找并选择`DefaultGroup.Upper
    Body`槽。
- en: When changing the `Slot Name` property, the `Slot` node will update to represent
    this new name. The `Slot` node requires a source pose, which will again be a reference
    to the `Movement` State Machine. This means that you need to create another `Use
    Cached Pose` node for the `Movement Cache` pose.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改`Slot Name`属性时，`Slot`节点将更新以表示这个新名称。`Slot`节点需要一个源姿态，这又将是一个对`Movement`状态机的引用。这意味着你需要为`Movement
    Cache`姿态创建另一个`Use Cached Pose`节点。
- en: 'Connect the cached pose to the source of the `Slot` node:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓存的姿态连接到`Slot`节点的源：
- en: '![Figure 12.15 – Filtering the cached movement pose through the Anim Slot ](img/Figure_12.15_B18531.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15 – 通过动画槽过滤缓存的移动姿态](img/Figure_12.15_B18531.jpg)'
- en: Figure 12.15 – Filtering the cached movement pose through the Anim Slot
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 通过动画槽过滤缓存的移动姿态
- en: 'All that is left to do now is to connect the `Upper Body` slot node to the
    `Blend Poses 0` input. Then, connect the final pose of the `Layered blend per
    bone` to the result of the `Output Pose` Animation Blueprint:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是将`Upper Body`槽节点连接到`Blend Poses 0`输入。然后，将`Layered blend per bone`的最终姿态连接到`Output
    Pose`动画蓝图的结果：
- en: '![Figure 12.16 – The final setup of the main character’s Animation Blueprint
    ](img/Figure_12.16_B18531.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16 – 主角动画蓝图的最终设置](img/Figure_12.16_B18531.jpg)'
- en: Figure 12.16 – The final setup of the main character’s Animation Blueprint
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 主角动画蓝图最终设置
- en: With the Anim Slot and the `Layered blend per bone` node in place within the
    main character’s Animation Blueprint, you are finally done with the animation
    side of the main character.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在主角色的动画蓝图中设置了动画槽和`Layered blend per bone`节点后，你终于完成了主角的动画部分。
- en: With the Animation Blueprint updated, we can now move on to the next exercise,
    where we can finally preview the `Throw` animation in action.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了动画蓝图后，我们现在可以继续进行下一个练习，在那里我们最终可以预览`Throw`动画的实际效果。
- en: Exercise 12.06 – Previewing the Throw animation
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.06 – 预览投掷动画
- en: 'In the previous exercise, you did a lot of work to allow animation blending
    between the player character’s `Movement` animations and the `Throw` animation
    by using the `Save Cached Pose` and `Layered blend per bone` nodes. Perform the
    following steps to preview the `Throw` animation in-game and see the fruits of
    your labor:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你做了很多工作，通过使用`Save Cached Pose`和`Layered blend per bone`节点，实现了玩家角色`Movement`动画和`Throw`动画之间的动画混合。执行以下步骤以在游戏中预览`Throw`动画，并看到你的劳动成果：
- en: Navigate to the `/MainCharacter/Blueprints/` directory and open the character’s
    `BP_SuperSideScroller_MainCharacter` Blueprint.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/MainCharacter/Blueprints/`目录并打开角色的`BP_SuperSideScroller_MainCharacter`蓝图。
- en: If you recall, in the last chapter, you created `Enhanced Input Action` for
    throwing with `IA_Throw` .
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还记得，在上一个章节中，你为投掷创建了`Enhanced Input Action`，名为`IA_Throw`。
- en: Inside `Event Graph` of the character’s Blueprint, right-click and search for
    `EnhancedInputAction IA_Throw` in the **Context Sensitive** drop-down search.
    Select it with a left-click to create the event node in the graph.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的蓝图`Event Graph`中，右键单击并搜索**上下文相关**下拉搜索中的`EnhancedInputAction IA_Throw`。用左键单击选择它，在图中创建事件节点。
- en: With this event in place, you need a function that allows you to play an Animation
    Montage when the player uses the left mouse button to throw.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件设置完成后，你需要一个函数，允许你在玩家使用左鼠标按钮投掷时播放动画剪辑。
- en: Right-click in `Event Graph` and search for `Play Montage`. Make sure not to
    confuse this with a similar function, `Play Anim Montage`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Event Graph`中右键单击并搜索`Play Montage`。确保不要与类似的功能`Play Anim Montage`混淆。
- en: 'The `Play Montage` function requires two important inputs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play Montage`函数需要两个重要的输入：'
- en: '`Montage to Play`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`要播放的蒙太奇`'
- en: '`In Skeletal Mesh Component`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`在骨骼网格组件`'
- en: Let’s first handle the `Skeletal Mesh` component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理`Skeletal Mesh`组件。
- en: 'The player character has a `Skeletal Mesh` component that can be found in the
    `Mesh`. Left-click and drag out a `Get` reference to this variable and connect
    it to the `In Skeletal Mesh Component` input of this function:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家角色有一个 `Skeletal Mesh` 组件，可以在 `Mesh` 中找到。左键单击并拖动以创建对这个变量的 `Get` 引用，并将其连接到该函数的
    `In Skeletal Mesh Component` 输入：
- en: '![Figure 12.17 – The mesh of the player character connected to the In Skeletal
    Mesh Component input ](img/Figure_12.17_B18531.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – 玩家角色网格连接到 In Skeletal Mesh Component 输入](img/Figure_12.17_B18531.jpg)'
- en: Figure 12.17 – The mesh of the player character connected to the In Skeletal
    Mesh Component input
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 玩家角色网格连接到 In Skeletal Mesh Component 输入
- en: 'The last thing to do now is to tell this function which montage to play. Luckily
    for you, there is only one montage that exists in this project: `AM_Throw`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后要做的就是告诉这个函数要播放哪个蒙太奇。幸运的是，在这个项目中只有一个蒙太奇：`AM_Throw`。
- en: Left-click on the drop-down menu under the `Montage to Play` input and left-click
    to select `AM_Throw`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Montage to Play` 输入下的下拉菜单中左键单击，然后左键单击以选择 `AM_Throw`。
- en: 'Finally, connect the `Triggered` execution output of the `EnhancedInputAction
    IA_Throw` event to the execution input pin of the `Play Montage` function:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `EnhancedInputAction IA_Throw` 事件的 `Triggered` 执行输出连接到 `Play Montage` 函数的执行输入引脚：
- en: '![Figure 12.18 – Now the AM_Throw montage plays when the ThrowProjectile input
    is pressed ](img/Figure_12.18_B18531.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.18 – 现在当按下 `ThrowProjectile` 输入时播放 AM_Throw 蒙太奇](img/Figure_12.18_B18531.jpg)'
- en: Figure 12.18 – Now the AM_Throw montage plays when the ThrowProjectile input
    is pressed
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – 现在当按下 `ThrowProjectile` 输入时播放 AM_Throw 蒙太奇
- en: Now, when you click your left mouse button, the player character will play the
    throwing Animation Montage.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你点击左鼠标按钮时，玩家角色将播放投掷动画蒙太奇。
- en: 'Notice now how you can walk and run at the same time as throwing, and each
    animation blends together so as not to interfere with one another:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在你可以边走边跑同时投掷，每个动画都融合在一起，不会相互干扰：
- en: '![Figure 12.19 – The player character can now move and throw ](img/Figure_12.19_B18531.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.19 – 玩家角色现在可以移动并投掷](img/Figure_12.19_B18531.jpg)'
- en: Figure 12.19 – The player character can now move and throw
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 – 玩家角色现在可以移动并投掷
- en: Don’t worry about any bugs you might see when using the left mouse button action
    repeatedly to play the `Throw` montage; these issues will be addressed when you
    implement the projectile that will be thrown in a later chapter for this project.
    For now, you just want to know that the work done on the Anim Slot and the Animation
    Blueprint give the desired result for animation blending.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心在使用左鼠标按钮动作重复播放 `Throw` 蒙太奇时可能看到的任何错误；这些问题将在你实现项目后续章节中将要投掷的投射物时得到解决。现在，你只需要知道，在
    Anim Slot 和动画蓝图上所做的工能够实现动画融合的预期结果。
- en: Let’s continue with the **SuperSideScroller** project by now creating the C++
    class, the Blueprints, and the materials necessary to set up the enemy for use
    in the next chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续 **SuperSideScroller** 项目，现在创建 C++ 类、蓝图和必要的材料，为下一章中敌人使用做准备。
- en: The SuperSideScroller game enemy
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SuperSideScroller 游戏的敌人
- en: With the player character animating correctly when moving and performing the
    `Throw` animation, it is time to talk about the enemy type that the **SuperSideScroller**
    game will feature.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色在移动和执行 `Throw` 动画时动画正确，现在是时候讨论 **SuperSideScroller** 游戏将采用的敌人类型了。
- en: This enemy will have a basic back-and-forth movement pattern and will not support
    any attacks; only by colliding with the player character will it be able to inflict
    damage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个敌人将有一个基本的来回移动模式，并且不支持任何攻击；只有通过碰撞玩家角色，它才能造成伤害。
- en: In the next exercise, you will set up the base enemy class in C++ for the first
    enemy type and configure the enemy’s Blueprint and Animation Blueprint in preparation
    for [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268), *Creating and Adding the
    Enemy Artificial Intelligence*, where you will implement the AI of this enemy.
    For the sake of efficiency and time, you will use the assets already provided
    by Unreal Engine 5 in the **SideScroller** template for the enemy. This means
    you will be using the skeleton, skeletal mesh, animations, and the Animation Blueprint
    of the default mannequin asset. Let’s begin by creating the first enemy class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将设置第一个敌人类型的基类，并配置敌人的蓝图和动画蓝图，为 [*第 13 章*](B18531_13.xhtml#_idTextAnchor268)
    *创建和添加敌人人工智能* 准备，在那里您将实现这个敌人的 AI。为了提高效率和节省时间，您将使用 Unreal Engine 5 在 **SideScroller**
    模板中提供的敌人资产。这意味着您将使用默认的骨架、骨骼网格、动画和动画蓝图。让我们开始创建第一个敌人类。
- en: Exercise 12.07 – Creating the enemy base C++ class
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.07 – 创建敌人基 C++ 类
- en: 'The goal of this exercise is to create a new enemy class from scratch and to
    have the enemy ready to use in [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268),
    *Creating and Adding the Enemy Artificial Intelligence*, when you will develop
    the AI. To start, create a new enemy class in C++ by following these steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是从头开始创建一个新的敌人类，并在您开发 AI 时，使敌人准备好在 [*第 13 章*](B18531_13.xhtml#_idTextAnchor268)
    *创建和添加敌人人工智能* 中使用。首先，按照以下步骤在 C++ 中创建一个新的敌人类：
- en: In the editor, navigate to `SuperSideScrollreCharacter` parent class.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，导航到 `SuperSideScrollreCharacter` 父类。
- en: Give this class a name and select a directory. Name this class `EnemyBase` and
    do not change the directory path. When ready, left-click on the **Create Class**
    button to have Unreal Engine create the new class for you.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给这个类起一个名字并选择一个目录。将此类命名为 `EnemyBase` 并不要更改目录路径。准备好后，左键单击 **Create Class** 按钮让
    Unreal Engine 为您创建新类。
- en: Let’s create the folder structure in the content drawer for the enemy assets
    next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在内容抽屉中为敌人资产创建文件夹结构。
- en: 'Head back to the Unreal Engine 5 editor, navigate to the content drawer, and
    create a new folder called `Enemy`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unreal Engine 5 编辑器，导航到内容抽屉，并创建一个名为 `Enemy` 的新文件夹：
- en: '![Figure 12.20 – The new Enemy folder ](img/Figure_12.20_B18531.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.20 – 新的 Enemy 文件夹](img/Figure_12.20_B18531.jpg)'
- en: Figure 12.20 – The new Enemy folder
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.20 – 新的 Enemy 文件夹
- en: 'In the `Enemy` folder, create another folder called `Blueprints`, where you
    will create and save the Blueprint assets for the enemy. Right-click and select
    `EnemyBase`, as shown here:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Enemy` 文件夹中，创建另一个名为 `Blueprints` 的文件夹，您将在其中创建和保存敌人的蓝图资产。右键单击并选择 `EnemyBase`，如图所示：
- en: '![Figure 12.21 – Now, the new EnemyBase class is available for you to create
    a Blueprint from ](img/Figure_12.21_B18531.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.21 – 现在，新的 EnemyBase 类可供您创建蓝图](img/Figure_12.21_B18531.jpg)'
- en: Figure 12.21 – Now, the new EnemyBase class is available for you to create a
    Blueprint from
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.21 – 现在，新的 EnemyBase 类可供您创建蓝图
- en: Name this `BP_Enemy`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此命名为 `BP_Enemy`。
- en: Now that you have the Blueprint for the first enemy using the `EnemyBase` class
    as the parent class, it is time to handle the Animation Blueprint. You will use
    the default Animation Blueprint that is provided to you by Unreal Engine in the
    `/Enemy/Blueprints` directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用 `EnemyBase` 类作为父类创建了第一个敌人的蓝图，是时候处理动画蓝图了。您将使用 Unreal Engine 在 `/Enemy/Blueprints`
    目录中提供的默认动画蓝图。
- en: Exercise 12.08 – Creating and applying the enemy Animation Blueprint
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.08 – 创建并应用敌人动画蓝图
- en: In the previous exercise, you created a Blueprint for the first enemy using
    the `EnemyBase` class as the parent class. In this exercise, you will be working
    with the Animation Blueprint.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您使用 `EnemyBase` 类作为父类创建了一个敌人的蓝图。在这个练习中，您将使用动画蓝图。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Navigate to the `/Mannequin/Animations` directory and find the `ThirdPerson_AnimBP`
    asset.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/Mannequin/Animations` 目录，找到 `ThirdPerson_AnimBP` 资产。
- en: 'Now, duplicate the `ThirdPerson_AnimBP` asset. There are two ways to duplicate
    an asset:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制 `ThirdPerson_AnimBP` 资产。复制资产有两种方法：
- en: Select the desired asset in the content drawer and press *Ctrl* + *W*.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容抽屉中选择所需的资产，并按 *Ctrl* + *W*。
- en: Right-click on the desired asset in the content drawer and select `Duplicate`
    from the drop-down menu.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容抽屉中右键单击所需的资产，从下拉菜单中选择 `Duplicate`。
- en: Now, left-click and drag this duplicate asset into the `/Enemy/Blueprints` directory
    and select the option to move when you release the left-click mouse button.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，左键单击并拖动这个副本资产到 `/Enemy/Blueprints` 目录，并在释放左键鼠标按钮时选择移动选项。
- en: Name this duplicate asset `AnimBP_Enemy`. It is best to create a duplicate of
    an asset that you can later modify if you so desire without risking the functionality
    of the original.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个副本资产命名为 `AnimBP_Enemy`。最好创建一个资产副本，这样你可以在以后修改它，而不会影响原始资产的功能。
- en: With the enemy Blueprint and Animation Blueprint created, it’s time to update
    the enemy Blueprint to use the default `Skeletal Mesh` mannequin and the new Animation
    Blueprint duplicate.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了敌人蓝图和动画蓝图之后，现在是时候更新敌人蓝图以使用默认的 `骨骼网格` 模特和新的动画蓝图副本了。
- en: Navigate to `/Enemy/Blueprints` and open `BP_Enemy`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/Enemy/Blueprints` 并打开 `BP_Enemy`。
- en: 'Next, navigate to the `Mesh` component and select it to access its **Details**
    panel. First, assign **SK_Mannequin** to the **Skeletal Mesh** parameter, as shown
    here:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到 `Mesh` 组件并选择它以访问其 **详细信息** 面板。首先，将 **SK_Mannequin** 分配给 **骨骼网格** 参数，如图所示：
- en: '![Figure 12.22 – You will use the default SK_Mannequin skeletal mesh for the
    new enemy ](img/Figure_12.22_B18531.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图12.22 – 您将为新敌人使用默认的 SK_Mannequin 骨骼网格](img/Figure_12.22_B18531.jpg)'
- en: Figure 12.22 – You will use the default SK_Mannequin skeletal mesh for the new
    enemy
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 – 您将为新敌人使用默认的 SK_Mannequin 骨骼网格
- en: 'Now, you need to apply the `AnimBP_Enemy` Animation Blueprint to the `Mesh`
    component. Navigate to the `Animation` category of the `Mesh` component’s `AnimBP_Enemy`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将 `AnimBP_Enemy` 动画蓝图应用到 `Mesh` 组件上。导航到 `Mesh` 组件的 `Animation` 类别的 `AnimBP_Enemy`：
- en: '![Figure 12.23 – Assign the new AnimBP_Enemy as the Anim class  ](img/Figure_12.23_B18531.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图12.23 – 将新的 AnimBP_Enemy 分配为 Anim 类](img/Figure_12.23_B18531.jpg)'
- en: Figure 12.23 – Assign the new AnimBP_Enemy as the Anim class
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 – 将新的 AnimBP_Enemy 分配为 Anim 类
- en: Lastly, you will notice that the character mesh is positioned and rotated incorrectly
    when previewing the character in the `X` = `0.000000`, `Y` = `0.000000`, `Z` =
    `-90.000000`)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您会发现当在 `X` = `0.000000`, `Y` = `0.000000`, `Z` = `-90.000000` 预览角色时，角色网格的位置和旋转不正确。
- en: '`0.000000`, Pitch= `0`, Yaw= `-90.000000`)'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0.000000`, Pitch= `0`, Yaw= `-90.000000`)'
- en: '`X` = `1.000000`, `Y` = `1.000000`, `Z` = `1.000000`)'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X` = `1.000000`, `Y` = `1.000000`, `Z` = `1.000000`)'
- en: 'The `Transform` settings will appear as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`变换` 设置将如下所示：'
- en: '![Figure 12.24 – The final Transform settings for the enemy character ](img/Figure_12.24_B18531.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图12.24 – 敌人角色的最终变换设置](img/Figure_12.24_B18531.jpg)'
- en: Figure 12.24 – The final Transform settings for the enemy character
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – 敌人角色的最终变换设置
- en: 'The following figure shows the settings of the **Mesh** component so far. Please
    make sure your settings match what is displayed in *Figure 12.25*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了到目前为止的 **网格** 组件设置。请确保您的设置与 *图12.25* 中显示的相匹配：
- en: '![Figure 12.25 – The settings for the Mesh component of your enemy character
    ](img/Figure_12.25_B18531.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25 – 敌人角色网格组件的设置](img/Figure_12.25_B18531.jpg)'
- en: Figure 12.25 – The settings for the Mesh component of your enemy character
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – 敌人角色网格组件的设置
- en: The last thing to do here is to create a Material Instance of the mannequin’s
    primary material so that this enemy can have a unique color that helps differentiate
    it from the other enemy type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要做的最后一件事是创建一个模特主要材质的材质实例，这样这个敌人就可以有一个独特的颜色，帮助它与其他敌人类型区分开来。
- en: Let’s begin by first learning more about Materials and Material Instances.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从首先了解更多关于材质和材质实例开始。
- en: Materials and Material Instances
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质和材质实例
- en: Before moving on to the next exercise, we need to first briefly discuss what
    Material Instances are before you can work with these assets and apply them to
    the new enemy character. Although this book is more focused on the technical aspects
    of game development using Unreal Engine 5, it is still important that you know,
    on a surface level, what Material Instances are and how they are used in video
    games. A Material Instance is an extension of a Material, where you do not have
    access or control over the base Material from which the Material Instance derives,
    but you do have control over the parameters that the creator of the Material exposes
    to you. Many parameters can be exposed to you to work with from inside Material
    Instances.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，我们需要先简要讨论一下材质实例是什么，这样你才能使用这些资产并将它们应用到新的敌人角色上。尽管这本书更侧重于使用 Unreal Engine
    5 进行游戏开发的技术方面，但了解材质实例是什么以及它们在视频游戏中的应用仍然非常重要。材质实例是材质的扩展，你无法访问或控制材质实例派生的基本材质，但你确实可以控制材质创建者向你暴露的参数。许多参数可以暴露给你，以便在材质实例内部进行操作。
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about Materials and Material Instances, please refer to
    the following Epic Games documentation pages: [https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.xhtml)
    and [https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Materials/UMaterialInstanceDynamic/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Materials/UMaterialInstanceDynamic/).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有关材质和材质实例的更多信息，请参阅以下 Epic Games 文档页面：[https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.xhtml)
    和 [https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Materials/UMaterialInstanceDynamic/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Materials/UMaterialInstanceDynamic/)。
- en: 'Unreal Engine provides us with an example of a Material Instance in the Side
    Scroller template project called `M_UE4Man_ChestLogo`, found in the `/Mannequin/Character/Materials/`
    directory. The following figure shows the set of exposed parameters given to the
    Material Instance based on the parent material, `M_Male_Body`. The most important
    parameter to focus on is the `Vector` parameter, called `BodyColor`. You will
    use this parameter in the Material Instance you create in the next exercise to
    give the enemy a unique color:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 提供了一个名为 `M_UE4Man_ChestLogo` 的材质实例示例，该实例位于 `/Mannequin/Character/Materials/`
    目录下的 Side Scroller 模板项目中。以下图示显示了基于父材质 `M_Male_Body` 给出的材质实例的参数集。最重要的参数是名为 `BodyColor`
    的 `Vector` 参数。你将在下一个练习中创建的材质实例中使用此参数，为敌人赋予独特的颜色：
- en: '![Figure 12.26 – The list of parameters for the M_UE4Man_ChestLogo Material
    Instance asset ](img/Figure_12.26_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.26 – M_UE4Man_ChestLogo 材质实例资产的参数列表](img/Figure_12.26_B18531.jpg)'
- en: Figure 12.26 – The list of parameters for the M_UE4Man_ChestLogo Material Instance
    asset
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.26 – M_UE4Man_ChestLogo 材质实例资产的参数列表
- en: In the following exercise, you will take this knowledge of Material Instances
    and apply them to create a unique Material Instance to be used for the enemy character
    you created earlier.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将利用对材质实例的了解，为之前创建的敌人角色创建一个独特的材质实例。
- en: Exercise 12.09 – Creating and applying the enemy Material Instance
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.09 – 创建和应用敌人材质实例
- en: Now that you have a basic understanding of what Material Instances are, it is
    time to create your own Material Instance from the `M_MannequinUE4_Body` asset.
    With this Material Instance, you will adjust the `BodyColor` parameter to give
    the enemy character a unique visual representation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对材质实例有了基本的了解，是时候从 `M_MannequinUE4_Body` 资产创建自己的材质实例了。使用这个材质实例，你将调整 `BodyColor`
    参数，为敌人角色赋予独特的视觉表现。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Navigate to the `Characters/Mannequin_UE4/Materials` directory to find the Material
    used by the default mannequin character, `M_MannequinUE4_Body`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Characters/Mannequin_UE4/Materials` 目录以找到默认人体模型使用的材质 `M_MannequinUE4_Body`。
- en: A Material Instance can be created by right-clicking on the `Material` asset,
    `M_MannequinUE4_Body`, and left-clicking on the `MI_Enemy01`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过在 `Material` 资产 `M_MannequinUE4_Body` 上右键单击，然后左键单击 `MI_Enemy01` 来创建材质实例。
- en: '![Figure 12.27 – Any material can be used to create a Material Instance ](img/Figure_12.27_B18531.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.27 – 任何材质都可以用来创建材质实例](img/Figure_12.27_B18531.jpg)'
- en: Figure 12.27 – Any material can be used to create a Material Instance
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 – 任何材质都可以用来创建材质实例
- en: 'Create a new folder called `Materials` in the `Enemy` folder. Left-click and
    drag the Material Instance into the `/Enemy/Materials` directory to move the asset
    to this new folder:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Enemy`文件夹中创建一个名为`Materials`的新文件夹。左键单击并拖动材质实例到`/Enemy/Materials`目录以将资产移动到这个新文件夹：
- en: '![Figure 12.28 – Rename the Material Instance MI_Enemy ](img/Figure_12.28_B18531.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图12.28 – 重命名材质实例MI_Enemy](img/Figure_12.28_B18531.jpg)'
- en: Figure 12.28 – Rename the Material Instance MI_Enemy
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 – 重命名材质实例MI_Enemy
- en: 'Double-left-click the Material Instance and find the **Details** panel on the
    left-hand side. There, you will find a **Vector Parameter** property called **BodyColor**.
    Make sure the checkbox is checked to enable this parameter, and then change its
    value to a red color. Now, the Material Instance should be colored red, as shown
    here:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击材质实例，并在左侧找到**细节**面板。在那里，你会找到一个名为**BodyColor**的**向量参数**属性。确保复选框被勾选以启用此参数，然后将其值更改为红色。现在，材质实例应该呈现红色，如图所示：
- en: '![Figure 12.29 – Now, the enemy material is red ](img/Figure_12.29_B18531.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图12.29 – 现在，敌人材质是红色](img/Figure_12.29_B18531.jpg)'
- en: Figure 12.29 – Now, the enemy material is red
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29 – 现在，敌人材质是红色
- en: 'Save the`BP_Enemy01` Blueprint. Select the `MI_Enemy`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`BP_Enemy01`蓝图。选择`MI_Enemy`：
- en: '![Figure 12.30 – Assign the MI_Enemy material instance to the enemy character
    Mesh ](img/Figure_12.30_B18531.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图12.30 – 将MI_Enemy材质实例分配给敌人角色网格](img/Figure_12.30_B18531.jpg)'
- en: Figure 12.30 – Assign the MI_Enemy material instance to the enemy character
    Mesh
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30 – 将MI_Enemy材质实例分配给敌人角色网格
- en: 'Now, the first enemy type is visually ready and has the appropriate Blueprint
    and Animation Blueprint assets prepared for the next chapter, where you will develop
    its AI:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，第一个敌人类型在视觉上已经准备就绪，并为下一章的开发其AI准备了适当的蓝图和动画蓝图资产：
- en: '![Figure 12.31 – The final enemy character set up ](img/Figure_12.31_B18531.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图12.31 – 最终的敌人角色设置](img/Figure_12.31_B18531.jpg)'
- en: Figure 12.31 – The final enemy character set up
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 – 最终的敌人角色设置
- en: With this exercise complete, you have now created a Material Instance and applied
    it to the enemy character so that it has a unique visual representation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在已经创建了一个材质实例并将其应用于敌人角色，使其具有独特的视觉表现。
- en: Let’s conclude this chapter by moving on to a short activity that will help
    you better understand the blending of animations using the `Layered blend per
    bone` node that was used in the earlier exercises.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简短的活动来结束本章，这个活动将帮助你更好地理解使用`Layered blend per bone`节点（在之前的练习中使用过）进行动画混合。
- en: Activity 12.01 – Updating Blend Weights
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01 – 更新混合权重
- en: At the end of *Exercise 12.06*, *Previewing the Throw animation*, you were able
    to blend the movement animations and the `Throw` animation so that they could
    be played in tandem without negatively influencing each other. The result is the
    player character animating correctly when walking or running, while also performing
    the `Throw` animation on the upper body.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习12.06*的末尾，*预览投掷动画*，你能够混合移动动画和`投掷`动画，使它们可以同时播放而不相互负面影响。结果是玩家角色在行走或奔跑时正确地动画化，同时在上半身执行`投掷`动画。
- en: In this activity, you will experiment with the blend bias values and parameters
    of the `Layered blend per bone` node to have a better understanding of how animation
    blending works.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将实验`Layered blend per bone`节点的混合偏差值和参数，以更好地理解动画混合的工作原理。
- en: 'The following steps will help you complete the activity:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成活动：
- en: Update the `Blend Weights` input parameter of the `Layered blend per bone` node
    so that there is absolutely no blending of the `Throw` animation additive pose
    with the base movement pose. Try using values here such as `0.0f` and `0.5f` to
    compare the differences in the animation.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Layered blend per bone`节点的`Blend Weights`输入参数，以确保`投掷`动画附加姿态与基本移动姿态之间没有混合。在此处尝试使用`0.0f`和`0.5f`等值来比较动画的差异。
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to return this value to `1.0f` after you are done so as not to affect
    the blending you set up in the previous exercise.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，请确保将此值恢复到`1.0f`，以免影响你在之前练习中设置的混合。
- en: Update the settings of the `Layered blend per bone` node to change which bone
    is affected by the blend so that the whole character’s body is affected by the
    blend. It’s a good idea to start with the root bone in the skeleton hierarchy
    of the `MainCharacter_Skeleton` asset.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`层叠混合每骨`节点的设置以改变受混合影响的骨骼，使整个角色的身体都受到混合的影响。从`MainCharacter_Skeleton`资产骨骼层次结构中的根骨骼开始是一个好主意。
- en: Keeping the settings from the previous step in place, add a new array element
    to the branch filters and, in this new array element, add the bone name and a
    blend depth value of `–1.0f`, which allows only the character’s left leg to continue
    to animate the movement correctly when blending the `Throw` animation.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持上一步的设置不变，向分支过滤器中添加一个新的数组元素，在这个新的数组元素中，添加骨骼名称和一个`-1.0f`的混合深度值，这允许只有角色的左腿在混合`投掷`动画时继续正确地动画化运动。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After this activity, make sure to return the settings of the `Layered blend
    per bone` node to the values you set at the end of the first exercise to ensure
    no progress is lost in the character’s animation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动之后，请确保将`层叠混合每骨`节点的设置恢复到第一次练习结束时的值，以确保不会在角色的动画中丢失任何进度。
- en: 'The expected output for the first part of the activity is shown here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 活动第一部分的预期输出如下所示：
- en: '![Figure 12.32 – Output showing the entire character’s body affected ](img/Figure_12.32_B18531.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图12.32 – 显示整个角色身体受影响的输出](img/Figure_12.32_B18531.jpg)'
- en: Figure 12.32 – Output showing the entire character’s body affected
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 – 显示整个角色身体受影响的输出
- en: 'The expected output for the last part of the activity is shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 活动最后一部分的预期输出如下所示：
- en: '![Figure 12.33 – The left leg continues to animate the movement correctly when
    blending the Throw animation ](img/Figure_12.33_B18531.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图12.33 – 在混合投掷动画时，左腿继续正确地动画化运动](img/Figure_12.33_B18531.jpg)'
- en: Figure 12.33 – The left leg continues to animate the movement correctly when
    blending the Throw animation
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33 – 在混合投掷动画时，左腿继续正确地动画化运动
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: 'Before concluding this activity, please return the `Layered blend per bone`
    settings to the values you set at the end of *Exercise 12.05*, *Blending animation
    with the Upper Body Anim Slot*. If you do not return these values back to their
    original settings, the animation results in upcoming exercises and activities
    in the next chapters will not be the same. You can either set the original values
    manually or refer to the file with these settings at the following link: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter12/Exercise12.05](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter12/Exercise12.05).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束此活动之前，请将`层叠混合每骨`的设置恢复到*练习12.05*，*使用上半身动画槽混合动画*结束时的值。如果您不将这些值恢复到原始设置，那么在下一章的后续练习和活动中，动画结果将不会相同。您可以选择手动设置原始值或参考以下链接中的文件：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter12/Exercise12.05](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter12/Exercise12.05)。
- en: With this activity complete, you now have a stronger understanding of how animation
    blending works and how blending weighting can affect the influence of additive
    poses on base poses using the `Layered blend per bone` node.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你现在对动画混合的工作原理以及如何通过`层叠混合每骨`节点影响基础姿态的加姿态有了更深入的理解。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot of techniques for animation blending that you haven’t used in
    this project, and it’s strongly recommended that you research these techniques,
    starting with the documentation at [https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.xhtml).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你还没有使用许多动画混合技术，强烈建议你研究这些技术，从[https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.xhtml)的文档开始。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With the enemy set up with the C++ class, Blueprint, and Material, you are ready
    to move on to the next chapter, where you will create the AI for this enemy by
    taking advantage of systems such as behavior trees in Unreal Engine 5.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用C++类、蓝图和材质设置好敌人之后，你就可以进入下一章了，在那里你将通过利用Unreal Engine 5中的行为树等系统来创建这个敌人的AI。
- en: From the exercises and activities of this chapter, you learned how to create
    an Animation Montage that allows the playing of animations. You also learned how
    to set up an Anim Slot within this montage to categorize it for the player character’s
    upper body.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的练习和活动，你学习了如何创建一个动画蒙太奇，允许播放动画。你还学习了如何在蒙太奇中设置一个Anim槽，以便为玩家角色的上半身分类。
- en: Next, you learned how to cache the output pose of a State Machine by using the
    `Use Cached Pose` node so that this pose can be referenced in multiple instances
    for more complex Animation Blueprints. Then, by learning about the `Layered blend
    per bone` function, you were able to blend the base movement pose with the additive
    layer of the `Throw` animation by using the Anim Slot.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何通过使用`Use Cached Pose`节点来缓存状态机的输出姿态，这样这个姿态就可以在多个实例中引用，以便在更复杂的动画蓝图中使用。然后，通过了解`Layered
    blend per bone`功能，你能够使用Anim槽将基本动作姿态与`Throw`动画的叠加层混合。
- en: Lastly, you put together the base of the enemy by creating the C++ class, Blueprint,
    and other assets so that they will be ready for the next chapter. With the enemy
    ready, let’s move on to creating the AI of the enemy so that it can interact with
    the player.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过创建C++类、蓝图和其他资产来构建敌人的基础，以便为下一章做好准备。敌人准备就绪后，让我们继续创建敌人的AI，以便它能与玩家互动。
