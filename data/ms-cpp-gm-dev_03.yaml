- en: Building a Strong Foundation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立坚实的基础
- en: While building your own libraries from scratch can be a rewarding process, it
    can also quickly become a time consuming one. This is why most professional game
    developers rely on some common libraries to speed up development times, and more
    importantly, provide a specialized, performant implementation. By connecting these
    common libraries and building helper and manager classes that abstract these libraries,
    you are in fact building the structure that will ultimately power your tools and
    gameplay engine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从头开始构建自己的库可能是一个有益的过程，但也很快会变得耗时。这就是为什么大多数专业游戏开发者依赖一些常见的库来加快开发时间，更重要的是提供专业的实现。通过连接这些常见的库并构建辅助和管理类来抽象这些库，实际上是在构建最终将驱动您的工具和游戏引擎的结构。
- en: In the next few sections, we will cover how these libraries can work together
    and build some of the libraries needed to round out the structure and give us
    a strong foundation to expand on the demos throughout the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将介绍这些库如何协同工作，并构建一些需要补充结构的库，为我们提供一个坚实的基础，以扩展本书其余部分的演示。
- en: To get started, we will focus on, arguably one of the most important aspects
    of any game project, the rendering system. Proper, performant implementations
    not only takes a significant amount of time, but it also takes specialized knowledge
    of video driver implementations and mathematics for computer graphics. Having
    said that, it is not, in fact, impossible to create a custom low-level graphics
    library yourself, it's just not overly recommended if your end goal is just to
    make video games. So instead of creating a low-level implementation themselves,
    most developers turn to a few different libraries to provide them abstracted access
    to the bare metal of the graphics device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将专注于任何游戏项目中可能是最重要的方面之一，即渲染系统。适当的、高效的实现不仅需要大量的时间，还需要对视频驱动程序实现和计算机图形学的专业知识。话虽如此，事实上，自己创建一个自定义的低级图形库并不是不可能的，只是如果您的最终目标只是制作视频游戏，这并不是特别推荐的。因此，大多数开发人员不会自己创建低级实现，而是转向一些不同的库，以提供对图形设备底层的抽象访问。
- en: 'For the examples found throughout this book, we will be using a few different
    graphic APIs to help speed up the process and help provide coherence across platforms.
    These APIs include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中的示例中，我们将使用几种不同的图形API来帮助加快进程并在各个平台上提供一致性。这些API包括以下内容：
- en: '**OpenGL** ([https://www.opengl.org/](https://www.opengl.org/)): The **Open
    Graphics Library** (**OGL**) is an open cross-language, cross-platform application
    programming interface, or API, used for rendering 2D and 3D graphics. The API
    provides low-level access to the **Graphics Processing Unit** (**GPU**).'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL** ([https://www.opengl.org/](https://www.opengl.org/))：**开放图形库**（**OGL**）是一个开放的跨语言、跨平台的应用程序编程接口，用于渲染2D和3D图形。该API提供对**图形处理单元**（**GPU**）的低级访问。'
- en: '**SDL** ([https://www.libsdl.org/](https://www.libsdl.org/)): The **Simple
    DirectMedia Layer** (**SDL**) is a cross-platform software development library
    designed to deliver a low-level hardware abstraction layer to multimedia hardware
    components. While it does provide its own mechanism for rendering, SDL can use
    OGL to provide full 3D rendering support.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDL** ([https://www.libsdl.org/](https://www.libsdl.org/))：**简单直接媒体层**（**SDL**）是一个跨平台的软件开发库，旨在为多媒体硬件组件提供低级硬件抽象层。虽然它提供了自己的渲染机制，但SDL可以使用OGL来提供完整的3D渲染支持。'
- en: While these APIs save us time and effort by providing us some abstraction when
    working with the graphics hardware, it will quickly become apparent that the level
    of abstraction will not be high enough.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些API通过在处理图形硬件时提供一些抽象来节省我们的时间和精力，但很快就会显而易见，抽象的级别还不够高。
- en: You will need another layer of abstraction to create an efficient way of reusing
    these APIs in multiple projects. This is where the helper and manager classes
    come in. These classes will provide the needed structure and abstraction for us
    and other coders. They will wrap all the common code needed to set up and initialize
    the libraries and hardware. The code that is required by any project regardless
    of gameplay or genre can be encapsulated in these classes and will become part
    of the engine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要另一层抽象来创建一种有效的方式在多个项目中重用这些API。这就是辅助和管理类的作用。这些类将为我们和其他编码人员提供所需的结构和抽象。它们将包装设置和初始化库和硬件所需的所有通用代码。无论游戏玩法或类型如何，任何项目所需的代码都可以封装在这些类中，并成为引擎的一部分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building helper classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建辅助类
- en: Encapsulation with managers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管理器进行封装
- en: Creating interfaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建接口
- en: Building helper classes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建辅助类
- en: In object-oriented programming, a helper class is used to assist in providing
    some functionality, which is not, directly the main goal of the application in
    which it is used. Helper classes come in many forms and are often a catch-all
    term for classes that provide functionality outside of the current scope of a
    method or class. Many different programming patterns make use of helper classes.
    In our examples, we too will make heavy use of helper classes. Here is just one
    example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，辅助类用于辅助提供一些功能，这些功能不是直接是应用程序的主要目标。辅助类有许多形式，通常是一个为方法或类的当前范围之外提供功能的总称。许多不同的编程模式使用辅助类。在我们的示例中，我们也将大量使用辅助类。这里只是一个例子。
- en: Let's take a look at the very common set of steps used to create a Window. It's
    safe to say that most of the games you will create will have some sort of display
    and will generally be typical across different targets, in our case Windows and
    the macOS. Having to retype the same instructions constantly over and over for
    each new project seems like kind of a waste. That sort of situation is perfect
    for abstracting away in a helper class that will eventually become part of the
    engine itself. The following code is the header for the `Window` class included
    in the demo code examples, you can find the full source under the `Chapter03`
    folder of the GitHub repository.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看用于创建窗口的非常常见的一组步骤。可以说，你将创建的大多数游戏都会有某种显示，并且通常会在不同的目标上是典型的，比如在我们的情况下是Windows和macOS。不得不为每个新项目不断重复输入相同的指令似乎有点浪费。这种情况非常适合在一个帮助类中进行抽象，最终将成为引擎本身的一部分。以下代码是演示代码示例中包含的`Window`类的头文件，你可以在GitHub代码库的`Chapter03`文件夹中找到完整的源代码。
- en: 'To start, we have a few necessary includes, `SDL`, `glew` which is a window
    creation helper library, and lastly, the standard `string` class is included:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些必要的包含，`SDL`，`glew`是一个窗口创建辅助库，最后，标准的`string`类也被包含进来：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we have an `enum WindowFlags`. We use this for setting some bitwise operations
    to change the way the window will be displayed; invisible, full screen, or borderless.
    You will notice that I have wrapped the code in the namespace `BookEngine`, as
    I mentioned in the previous chapter this is essential for keeping naming conflicts
    from happening and will be very helpful once we start importing our engine into
    projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`enum WindowFlags`。我们使用它来设置一些位操作，以改变窗口的显示方式；不可见、全屏或无边框。你会注意到我已经将代码放入了`BookEngine`命名空间中，正如我在前一章中提到的，这对于避免发生命名冲突是必不可少的，并且一旦我们开始将我们的引擎导入项目中，这将非常有帮助：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have the `Window` class itself. We have a few `public` methods in this
    class. First the default constructor and destructor. It is a good idea to include
    a default constructor and destructor even if they are empty, as shown here, despite
    the compiler, including its own, these specified ones are needed if you plan on
    creating intelligent or managed pointers, such as `unique_ptr`, of the class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Window`类本身。在这个类中有一些`public`方法。首先是默认构造函数和析构函数。即使它们是空的，包括一个默认构造函数和析构函数也是一个好主意，尽管编译器包括自己的，但如果你打算创建智能或托管指针，比如`unique_ptr`，这些指定的构造函数和析构函数是必需的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next we have the `Create` function, this function will be the one that builds
    or creates the window. It takes a few arguments for the creation of the window
    such as the name of the window, screen width and height, and any flags we want
    to set, see the previously mentioned `enum`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Create`函数，这个函数将是构建或创建窗口的函数。它需要一些参数来创建窗口，比如窗口的名称、屏幕宽度和高度，以及我们想设置的任何标志，参见前面提到的`enum`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we have two `Get` functions. These functions will just return the width
    and height respectively:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有两个`Get`函数。这些函数将分别返回宽度和高度：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last public function is the `SwapBuffer` function; this is an important
    function that we will take a look at in more depth shortly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个公共函数是`SwapBuffer`函数；这是一个重要的函数，我们将很快深入研究它。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To close out the class definition, we have a few private variables. The first
    is a pointer to a `SDL_Window*` type, named appropriate enough `m_SDL_Window`.
    Then we have two holder variables to store the width and height of our screen.
    This takes care of the definition of the new `Window` class, and as you can see
    it is pretty simple on face value. It provides easy access to the creation of
    the Window without the developer calling it having to know the exact details of
    the implementation, which is one aspect that makes object-orientated programming
    and this method is so powerful:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束类定义，我们有一些私有变量。首先是指向`SDL_Window*`类型的指针，适当命名为`m_SDL_Window`。然后我们有两个持有者变量来存储屏幕的宽度和高度。这就完成了新的`Window`类的定义，正如你所看到的，它在表面上非常简单。它提供了对窗口的创建的简单访问，而开发人员不需要知道实现的确切细节，这是面向对象编程和这种方法如此强大的一个方面：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To get a real sense of the abstraction, let''s walk through the implementation
    of the `Window` class and really see all the pieces it takes to create the window
    itself:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解抽象，让我们走一遍`Window`类的实现，并真正看到创建窗口本身所需的所有部分：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Window.cpp` files starts out with the need includes, of course, we need
    to include `Window.h`, but you will also note we need to include the `Exception.h`
    and `Logger.h` header files also. These are two other helper files created to
    abstract their own processes. The `Exception.h` file is a helper class that provides
    an easy-to-use exception handling system. The `Logger.h` file is a helper class
    that as its name says, provides an easy-to-use logging system. Feel free to dig
    through each one; the code is located in the `Chapter03` folder of the GitHub
    code repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window.cpp`文件以需要的包含开始，当然，我们需要包含`Window.h`，但你还会注意到我们还需要包含`Exception.h`和`Logger.h`头文件。这是另外两个帮助文件，用于抽象它们自己的过程。`Exception.h`文件是一个帮助类，提供了一个易于使用的异常处理系统。`Logger.h`文件是一个帮助类，正如其名称所示，提供了一个易于使用的日志记录系统。随意查看每一个；代码位于GitHub代码库的`Chapter03`文件夹中。'
- en: After the includes, we again wrap the code in the `BookEngine` namespace and
    provide the empty constructor and destructor for the class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含文件之后，我们再次将代码放入`BookEngine`命名空间中，并为类提供空构造函数和析构函数。
- en: The `Create` function is the first to be implemented. In this function are the
    steps needed to create the actual window. It starts out setting the window display
    `flags` using a series of `if` statements to create a bitwise representation of
    the options for the window. We use the `enum` we created before to make this easier
    to read for us humans.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Create`函数是第一个要实现的函数。在这个函数中，需要创建实际窗口的步骤。它开始设置窗口显示`flags`，使用一系列`if`语句来创建窗口选项的位表示。我们使用之前创建的`enum`使得这对我们人类来说更容易阅读。'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After we set the window''s display options, we move on to using the SDL library
    to create the window. As I mentioned before, we use libraries such as SDL to help
    us ease the creation of such structures. We start out wrapping these function
    calls in a `try` statement; this will allow us to catch any issues and pass it
    along to our `Exception` class as we will see soon:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 设置窗口的显示选项后，我们继续使用SDL库创建窗口。正如我之前提到的，我们使用诸如SDL之类的库来帮助我们简化这些结构的创建。我们开始将这些函数调用包装在`try`语句中；这将允许我们捕获任何问题并将其传递给我们的`Exception`类，正如我们很快将看到的那样：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first line sets the private member variable `m_SDL_Window` to a newly created
    window using the passed in variables, for the name, width, height, and any flags.
    We also set the default window''s spawn point to the screen center by passing
    the `SDL_WINDOWPOS_CENTERED` define to the function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将私有成员变量`m_SDL_Window`设置为使用传入的变量创建的新窗口，用于名称、宽度、高度和任何标志。我们还通过将`SDL_WINDOWPOS_CENTERED`定义传递给函数，将默认窗口的生成点设置为屏幕中心：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we have attempted to create the window, it is a good idea to check and
    see if the process did succeed. We do this with a simple if statement and check
    to see if the variable `m_SDL_Window` is set to a `nullptr`; if it is, we throw
    an `Exception`. We pass the `Exception` the string `""SDL Window could not be
    created!""`. This is the error message that we can then print out in a catch statement.
    Later on, we will see an example of this. Using this method, we provide ourselves
    some simple error checking.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试创建窗口之后，检查并查看进程是否成功是一个好主意。我们使用一个简单的if语句来检查变量`m_SDL_Window`是否设置为`nullptr`；如果是，我们抛出一个`Exception`。我们向`Exception`传递字符串`""SDL
    Window could not be created!""`。这是我们可以在catch语句中打印出的错误消息。稍后，我们将看到这方面的一个例子。使用这种方法，我们提供了一些简单的错误检查。
- en: Once we have created our window and have done some error checking, we can move
    on to setting up a few other components. One of these components is the OGL library
    which requires what is referred to as a context to be set. An OGL context can
    be thought of as a set of states that describes all the details related to the
    rendering of the application. The OGL context must be set before any drawing can
    be done.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建窗口并进行一些错误检查后，我们可以继续设置其他一些组件。其中之一是需要设置的OGL库，它需要所谓的上下文。OGL上下文可以被视为描述应用程序渲染相关细节的一组状态。在进行任何绘图之前，必须设置OGL上下文。
- en: 'One problem is that creating a window and an OGL context is not part of the
    OGL specification itself. What this means is that every platform can handle this
    differently. Luckily for us, the SDL API again abstracts the heavy lifting for
    us and allows us to do this all in one line of code. We create a `SDL_GLContext`
    variable named `glContext`. We then assign `glContext` to the return value of
    the `SDL_GL_CreateContext` function that takes one argument, the `SDL_Window`
    we created earlier. After this we, of course, do a simple check to make sure everything
    worked as intended, just like we did earlier with the window creation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，创建窗口和OGL上下文并不是OGL规范本身的一部分。这意味着每个平台都可以以不同的方式处理这个问题。幸运的是，SDL API再次为我们抽象了繁重的工作，并允许我们在一行代码中完成所有这些工作。我们创建了一个名为`glContext`的`SDL_GLContext`变量。然后，我们将`glContext`分配给`SDL_GL_CreateContext`函数的返回值，该函数接受一个参数，即我们之前创建的`SDL_Window`。之后，我们当然要进行简单的检查，以确保一切都按预期工作，就像我们之前创建窗口时所做的那样：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next component we need to initialize is `GLEW`. Again this is abstracted
    for us to one simple command, `glewInit()`. This function takes no arguments but
    does return an error status code. We can use this status code to perform a similar
    error check like we did with the window and OGL. This time instead checking it
    against the defined `GLEW_OK`. If it evaluates to anything other than `GLEW_OK`,
    we throw an `Exception` to be caught later on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要初始化的下一个组件是`GLEW`。同样，这对我们来说是一个简单的命令，`glewInit()`。这个函数不带参数，但会返回一个错误状态码。我们可以使用这个状态码来执行类似于我们之前对窗口和OGL进行的错误检查。这次，我们不是检查它是否等于定义的`GLEW_OK`。如果它的值不是`GLEW_OK`，我们会抛出一个`Exception`，以便稍后捕获。
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that the needed components are initialized, now is a good time to log some
    information about the device running the application. You can log all kinds of
    data about the device which can provide valuable insights when trying to track
    down obscure issues. In this case, I am polling the system for the version of
    OGL that is running the application and then using the `Logger` helper class printing
    this out to a runtime text file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要初始化的组件已经初始化，现在是记录有关运行应用程序的设备的一些信息的好时机。您可以记录有关设备的各种数据，这些数据在尝试跟踪晦涩问题时可以提供有价值的见解。在这种情况下，我正在轮询系统以获取运行应用程序的OGL版本，然后使用`Logger`辅助类将其打印到运行时文本文件中：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we set the clear color or the color that will be used to refresh the graphics
    card. In this case, it will be the background color of our application. The `glClearColor`
    function takes four float values that represent the red, green, blue, and alpha
    values in a range of `0.0` to `1.0`. Alpha is the transparency value where `1.0f`
    is opaque, and `0.0f` is completely transparent:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置清除颜色或用于刷新图形卡的颜色。在这种情况下，它将是我们应用程序的背景颜色。`glClearColor`函数接受四个浮点值，表示范围为`0.0`到`1.0`的红色、绿色、蓝色和alpha值。Alpha是透明度值，其中`1.0f`是不透明的，`0.0f`是完全透明的：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next line sets the `VSYNC` value, which is a mechanism that will attempt
    to match the application''s framerate to that of the physical display. The `SDL_GL_SetSwapInterval`
    function takes one argument, an integer that can be `1` for on or `0` for off:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行设置`VSYNC`值，这是一种机制，它将尝试将应用程序的帧速率与物理显示器的帧速率匹配。`SDL_GL_SetSwapInterval`函数接受一个参数，一个整数，可以是`1`表示开启，`0`表示关闭：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last two lines that make up the `try` statement block, enable blending
    and set the method used when performing alpha blending. For more information on
    these specific functions, check out the OGL development documents:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 组成`try`语句块的最后两行，启用混合并设置执行alpha混合时使用的方法。有关这些特定函数的更多信息，请查看OGL开发文档：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After our `try` block, we now have to include the `catch` block or blocks.
    This is where we will capture any of the thrown errors that have occurred. In
    our case, we are just going to grab all the exceptions. We use the `WriteLog`
    function from the `Logger` helper class to add the exception message, `e.reason` to
    the error log text file. This is a very basic case, but of course, we could do
    more here, possibly even recover from an error if possible:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`try`块之后，我们现在必须包括`catch`块。这是我们将捕获发生的任何抛出错误的地方。在我们的情况下，我们只会捕获所有的异常。我们使用`Logger`辅助类的`WriteLog`函数将异常消息`e.reason`添加到错误日志文本文件中。这是一个非常基本的情况，但当然，我们在这里可以做更多的事情，可能甚至可以在可能的情况下从错误中恢复：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the last function in the `Window.cpp` file is the `SwapBuffer` function.
    Without going too deep on the implementation, what swapping buffers does is exchange
    the front and back buffers of the GPU. This in a nutshell allows smoother drawing
    to the screen. It is a complicated process that again has been abstracted by the
    SDL library. Our `SwapBuffer` function, abstracts this process again so that when
    we want to swap the buffers we simply call `SwapBuffer` instead of having to call
    the SDL function and specify the window, which is what is exactly done in the
    function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Window.cpp`文件中的最后一个函数是`SwapBuffer`函数。不深入实现，交换缓冲区的作用是交换GPU的前后缓冲区。简而言之，这允许更流畅地绘制到屏幕上。这是一个复杂的过程，再次被SDL库抽象出来。我们的`SwapBuffer`函数再次将这个过程抽象出来，这样当我们想要交换缓冲区时，我们只需调用`SwapBuffer`而不必调用SDL函数并指定窗口，这正是函数中所做的：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So as you can see, building up these helper functions can go a long way in making
    the process of development and iteration much quicker and simpler. Next, we will
    look at another programming method that again abstracts the heavy lifting from
    the developer's hands and provides a form of control over the process, a management
    system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所看到的，构建这些辅助函数可以在开发和迭代过程中大大加快和简化。接下来，我们将看一种再次将繁重的工作抽象出来并为开发者提供对过程的控制的编程方法，即管理系统。
- en: Encapsulation with managers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理器封装
- en: When working with complex systems such as input and audio systems, it can easily
    become tedious and unwieldy to control and check each state and other internals
    of the system directly. This is where the idea of the manager programming pattern
    comes in. Using abstraction and polymorphism we can create classes that allow
    us to modularize and simplify the interaction with these systems. Manager classes
    can be found in many different use cases. Essentially if you see a need to have
    structured control over a certain system, this could be a candidate for a manager
    class. Next is an example of a manager class I have created for the example code
    in this book. You will see much more as we continue throughout.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理诸如输入和音频系统之类的复杂系统时，直接控制和检查系统的每个状态和其他内部状态很容易变得乏味和笨拙。这就是管理器编程模式的概念所在。使用抽象和多态性，我们可以创建类，使我们能够模块化和简化与这些系统的交互。管理器类可以在许多不同的用例中找到。基本上，如果您发现需要对某个系统进行结构化控制，这可能是管理器类的候选对象。接下来是我为本书示例代码创建的管理器类的示例。随着我们的继续，您将看到更多。
- en: 'Stepping away from the rendering system for a second, let''s take a look at
    a very common task that any game will need to perform, handling input. Since every
    game needs some form of input, it only makes sense to move the code that handles
    this to a class that we can use over and over again. Let''s take a look at the
    `InputManager` class, starting with the header file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时远离渲染系统，让我们看看任何游戏都需要执行的一个非常常见的任务，处理输入。由于每个游戏都需要某种形式的输入，将处理输入的代码移动到一个我们可以一遍又一遍使用的类中是很有意义的。让我们来看看`InputManager`类，从头文件开始：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `InputManager` class starts just like the others, we have the includes needed
    and again we wrap the class in the `BookEngine` namespace for convince and safety.
    The standard constructor and destructor are also defined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputManager`类的开始就像其他类一样，我们需要的包括和再次将类包装在`BookEngine`命名空间中以方便和安全。标准构造函数和析构函数也被定义。'
- en: 'Next, we have a few more public functions. First the `Update` function, which
    will not surprisingly update the input system. Then we have the `KeyPress` and
    `KeyReleased` functions, these functions both take an integer value corresponding
    to a keyboard key. The following functions fire off when the `key` is pressed
    or released respectively:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有几个公共函数。首先是`Update`函数，这将不奇怪地更新输入系统。然后我们有`KeyPress`和`KeyReleased`函数，这些函数都接受与键盘键对应的整数值。以下函数分别在按下或释放`key`时触发：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the `KeyPress` and `KeyRelease` functions, we have two more key related
    functions the `isKeyDown` and `isKeyPressed`. Like the `KeyPress` and `KeyRelease`
    functions the `isKeyDown` and `isKeyPressed` functions take integer values that
    correspond to keyboard keys. The noticeable difference is that these functions
    return a Boolean value based on the status of the key. We will see more about
    this in the implementation file coming up:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KeyPress`和`KeyRelease`函数之后，我们还有两个与键相关的函数`isKeyDown`和`isKeyPressed`。与`KeyPress`和`KeyRelease`函数一样，`isKeyDown`和`isKeyPressed`函数接受与键盘键对应的整数值。显着的区别是这些函数根据键的状态返回布尔值。我们将在接下来的实现文件中看到更多关于这一点的内容。
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last two public functions in the `InputManager` class are `SetMouseCoords`
    and `GetMouseCoords` which do exactly as the names suggest and set or get the
    mouse coordinates respectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputManager`类中的最后两个公共函数是`SetMouseCoords`和`GetMouseCoords`，它们确实如其名称所示，分别设置或获取鼠标坐标。'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Moving on to the private members and functions, we have a few variables declared
    to store some information about the keys and mouse. First, we have a Boolean value
    that stores the state of the key being pressed down or not. Next, we have two
    unordered maps that will store the current `keymap` and previous key maps. The
    last value we store is the mouse coordinates. We us a `vec2` construct from another
    helper library the **OpenGL Mathematics** (**GLM**). We use this `vec2`, which
    is just a two-dimensional vector, to store the *x* and *y* coordinate values of
    the mouse cursor since it is on a 2D plane, the screen. If you are looking for
    a refresher on vectors and the Cartesian coordinate system, I highly recommend
    the *Beginning Math Concepts for Game Developers book* by *Dr. John P Flynt*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是私有成员和函数，我们声明了一些变量来存储有关键和鼠标的一些信息。首先，我们有一个布尔值，用于存储按下键的状态。接下来，我们有两个无序映射，它们将存储当前的`keymap`和先前的键映射。我们存储的最后一个值是鼠标坐标。我们使用另一个辅助库**OpenGL
    Mathematics**（**GLM**）中的`vec2`构造。我们使用这个`vec2`，它只是一个二维向量，来存储鼠标光标的*x*和*y*坐标值，因为它在一个二维平面上，即屏幕上。如果你想要复习向量和笛卡尔坐标系，我强烈推荐*Dr.
    John P Flynt*的*Beginning Math Concepts for Game Developers*一书：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now let's look at the implementation, the `InputManager.cpp` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下实现，`InputManager.cpp`文件。
- en: 'Again we start out with the includes and the namespace wrapper. Then we have
    the constructor and destructor. The highlight to note here is the setting of the
    `m_mouseCoords` to `0.0f` in the constructor:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从包含和命名空间包装器开始。然后我们有构造函数和析构函数。这里需要注意的亮点是在构造函数中将`m_mouseCoords`设置为`0.0f`：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next is the `Update` function. This is a simple update where we are stepping
    through each key in the `keyMap` and copying it over to the previous `keyMap`
    holder
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Update`函数。这是一个简单的更新，我们正在遍历`keyMap`中的每个键，并将其复制到先前的`keyMap`持有者中。
- en: '`m_previousKeyMap`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_previousKeyMap`：'
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next function is the `KeyPress` function. In this function, we use the
    trick of an associative array to test and insert the key pressed which matches
    the ID passed in. The trick is that if the item located at the index of the `keyID`
    index does not exist, it will automatically be created:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`KeyPress`函数。在这个函数中，我们使用关联数组的技巧来测试和插入与传入ID匹配的按下的键。技巧在于，如果位于`keyID`索引处的项目不存在，它将自动创建：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `KeyRelease` function is the same setup as the `KeyPressed` function, except
    that we are setting the `keyMap` item at the `keyID` index to false:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyRelease`函数与`KeyPressed`函数的设置相同，只是我们将`keyMap`中的项目在`keyID`索引处设置为false：'
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After the `KeyPress` and `KeyRelease` functions, we implement the `isKeyDown`
    and `isKeyPressed` functions. First the `isKeydown` function; here we want to
    test if a key is already pressed down. In this case, we take a different approach
    to testing the key than in the `KeyPress` and `KeyRelease` functions and avoid
    the associative array trick. This is because we don''t want to create a key if
    it does not already exist, so instead, we do it manually:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KeyPress`和`KeyRelease`函数之后，我们实现了`isKeyDown`和`isKeyPressed`函数。首先是`isKeydown`函数；在这里，我们想测试键是否已经按下。在这种情况下，我们采用了与`KeyPress`和`KeyRelease`函数中不同的方法来测试键，并避免了关联数组的技巧。这是因为我们不想在键不存在时创建一个键，所以我们手动进行：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `isKeyPressed` function is quite simple. Here we test to see if the key
    that matches the passed in ID is pressed down, by using the `isKeyDown` function,
    and that it was not already pressed down by also passing the ID to `m_wasKeyDown`.
    If both of these conditions are met, we return true, or else we return false.
    Next, we have the `WasKeyDown` function, much like the `isKeyDown` function, we
    do a manual lookup to avoid accidentally creating the object using the associative
    array trick:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`isKeyPressed`函数非常简单。在这里，我们测试与传入ID匹配的键是否被按下，通过使用`isKeyDown`函数，并且它还没有被`m_wasKeyDown`按下。如果这两个条件都满足，我们返回true，否则返回false。接下来是`WasKeyDown`函数，与`isKeyDown`函数类似，我们进行手动查找，以避免意外创建对象使用关联数组的技巧：'
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final function in the `InputManager` is `SetMouseCoords`. This is a very
    simple `Set` function that takes the passed in floats and assigns them to the
    `x` and `y` members of the two-dimensional vector, `m_mouseCoords`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputManager`中的最后一个函数是`SetMouseCoords`。这是一个非常简单的`Set`函数，它接受传入的浮点数并将它们分配给二维向量`m_mouseCoords`的*x*和*y*成员：'
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Creating interfaces
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建接口
- en: Sometimes you are faced with a situation where you need to describe capabilities
    and provide access to general behaviors of a class without committing to a particular
    implementation. This is where the idea of interfaces or abstract classes comes
    into play. Using interfaces provides a simple base class that other classes can
    then inherit from without having to worry about the intrinsic details. Building
    strong interfaces can enable rapid development by providing a standard class to
    interact with. While interfaces could, in theory, be created of any class, it
    is more common to see them used in situations where the code is commonly being
    reused. The following is an example interface created for the book's example code
    that creates an interface to the main class for the game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会面临这样一种情况，你需要描述一个类的能力并提供对一般行为的访问，而不承诺特定的实现。这就是接口或抽象类的概念发挥作用的地方。使用接口提供了一个简单的基类，其他类可以继承而不必担心内在的细节。构建强大的接口可以通过提供一个标准的类来与之交互来实现快速开发。虽然理论上接口可以创建任何类，但更常见的是在代码经常被重用的情况下使用它们。以下是书中示例代码创建的一个接口，用于创建游戏的主类的接口。
- en: Let's take a look at an interface from the example code in the repository. This
    interface will provide access to the core components of the game. I have named
    this class `IGame`, using the prefix `I` to identify this class as an interface.
    The following is the implementation beginning with the definition file `IGame.h`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下存储库中示例代码的接口。这个接口将提供对游戏的核心组件的访问。我将这个类命名为`IGame`，使用前缀`I`来标识这个类是一个接口。以下是从定义文件`IGame.h`开始的实现。
- en: 'To begin with, we have the needed includes and the namespace wrapper. You will
    notice that the files we are including are some of the ones we just created. This
    is a prime example of the continuation of the abstraction. We use these building
    blocks to continue to build the structure that will allow this seamless abstraction:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有所需的包含和命名空间包装器。您会注意到，我们包含的文件是我们刚刚创建的一些文件。这是抽象的延续的一个典型例子。我们使用这些构建模块来继续构建结构，以便实现无缝的抽象：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we have a forward declaration. This declaration is for another interface
    that has been created for screens. The full source code to this interface and
    its supporting helper classes are available in the code repository. Class `IScreen`;
    using forward declarations like this is a common practice in C++.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个前向声明。这个声明是为另一个为屏幕创建的接口。这个接口及其支持的辅助类的完整源代码都可以在代码存储库中找到。类`IScreen`；在C++中使用这样的前向声明是一种常见的做法。
- en: If the definition file only requires the simple definition of a class, not adding
    the header for that class will speed up compile times.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义文件只需要简单定义一个类，而不添加该类的头文件，将加快编译时间。
- en: 'Moving onto the public members and functions, we start off the constructor
    and destructor. You will notice that this destructor in this case is virtual.
    We are setting the destructor as virtual to allow us to call delete on the instance
    of the derived class through a pointer. This is handy when we want our interface
    to handle some of the cleanup directly as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是公共成员和函数，我们从构造函数和析构函数开始。您会注意到，在这种情况下，这个析构函数是虚拟的。我们将析构函数设置为虚拟的，以便通过指针调用派生类的实例上的delete。当我们希望接口直接处理一些清理工作时，这很方便：
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next we have declarations for the `Run` function and the `ExitGame` function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有`Run`函数和`ExitGame`函数的声明。
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We then have some pure virtual functions, `OnInit`, `OnExit`, and `AddScreens`.
    Pure virtual functions are functions that must be overridden by the inheriting
    class. By adding the `=0;` to the end of the definition, we are telling the compiler
    that these functions are purely virtual.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一些纯虚函数，`OnInit`，`OnExit`和`AddScreens`。纯虚函数是必须由继承类重写的函数。通过在定义的末尾添加`=0;`，我们告诉编译器这些函数是纯虚的。
- en: 'When designing your interfaces, it is important to be cautious when defining
    what functions must be overridden. It''s also very important to note that having
    pure virtual function implicitly makes the class it is defined for abstract. Abstract
    classes cannot be instantiated directly because of this and any derived classes
    need to implement all inherited pure virtual functions. If they do not, they too
    will become abstract:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口时，定义必须被重写的函数时要谨慎。还要注意，拥有纯虚函数会使其所定义的类成为抽象类。抽象类不能直接实例化，因此任何派生类都需要实现所有继承的纯虚函数。如果不这样做，它们也会变成抽象类：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After our pure virtual function declarations, we have a function `OnSDLEvent`
    which we use to hook into the SDL event system. This provides us support for our
    input and other event-driven systems:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯虚函数声明之后，我们有一个名为`OnSDLEvent`的函数，我们用它来连接到SDL事件系统。这为我们提供了对输入和其他事件驱动系统的支持：
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The public function in the `IGame` interface class is a simple helper function
    `GetFPS` that returns the current `fps`. Notice the `const` modifiers, they identify
    quickly that this function will not modify the variable''s value in any way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGame`接口类中的公共函数是一个简单的辅助函数`GetFPS`，它返回当前的`fps`。注意`const`修饰符，它们快速标识出这个函数不会以任何方式修改变量的值：'
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In our protected space, we start with a few function declarations. First is
    the `Init` or initialization function. This will be the function that handles
    a good portion of the setup. Then we have two virtual functions `Update` and `Draw`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的受保护空间中，我们首先有一些函数声明。首先是`Init`或初始化函数。这将是处理大部分设置的函数。然后我们有两个虚函数`Update`和`Draw`。
- en: 'Like pure virtual functions, a virtual function is a function that can be overridden
    by a derived class''s implementation. Unlike a pure virtual function, the virtual
    function does not make the class abstract by default and does not have to be overridden.
    Virtual and pure virtual functions are keystones of polymorphic design. You will
    quickly see their benefits as you continue your development journey:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 像纯虚函数一样，虚函数是可以被派生类实现的函数。与纯虚函数不同，虚函数默认不会使类成为抽象类，也不必被重写。虚函数和纯虚函数是多态设计的基石。随着开发的继续，您将很快看到它们的好处：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To close out the `IGame` definition file, we have a few members to house different
    objects and values. I am not going to go through these line by line since I feel
    they are pretty self-explanatory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IGame`定义文件中，我们有一些成员来存放不同的对象和值。我不打算逐行讨论这些成员，因为我觉得它们相当容易理解：
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have taken a look at the definition of our interface class, let''s
    quickly walk through the implementation. The following is the `IGame.cpp` file.
    To save time and space, I am going to highlight the key points. For the most part,
    the code is self-explanatory, and the source located in the repository is well
    commented for more clarity:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了接口类的定义，让我们快速浏览一下实现。以下是`IGame.cpp`文件。为了节省时间和空间，我将重点介绍关键点。在大多数情况下，代码是不言自明的，存储库中的源代码有更多的注释以提供更清晰的解释：
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our implementation starts out with the constructor and destructor. The constructor
    is simple, its only job is to add a unique pointer of a new screen using this
    `IGame` object as the argument to pass in. See the `IScreen` class for more information
    on screen creation. Next, we have the implementation of the `Run` function. This
    function, when called will set the engine in motion. Inside the function, we do
    a quick check to make sure we have already initialized our object. We then use
    yet another helper class, `fpsLimiter`, to `SetMaxFPS` that our game can run.
    After that, we set the `isRunning` Boolean value to `true`, which we then use
    to control the game loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现从构造函数和析构函数开始。构造函数很简单，它的唯一工作是使用这个`IGame`对象作为参数添加一个新屏幕的唯一指针。有关屏幕创建的更多信息，请参阅`IScreen`类。接下来，我们实现了`Run`函数。当调用这个函数时，将启动引擎。在函数内部，我们快速检查以确保我们已经初始化了对象。然后，我们再次使用另一个助手类`fpsLimiter`来`SetMaxFPS`，让我们的游戏可以运行。之后，我们将`isRunning`布尔值设置为`true`，然后用它来控制游戏循环：
- en: '[PRE40]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next is the game loop. In the game loop, we do a few simple calls. First, we
    start the `fpsLimiter`. We then call the update function on our `InputManager`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是游戏循环。在游戏循环中，我们进行了一些简单的调用。首先，我们启动了`fpsLimiter`。然后，我们在我们的`InputManager`上调用更新函数。
- en: It is a good idea always to check input before doing other updates or drawing
    since their calculations are sure to use the new input values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行其他更新或绘图之前，始终检查输入是一个好主意，因为它们的计算肯定会使用新的输入值。
- en: 'After we update the `InputManager`, we recursively call our `Update` and `Draw`
    class, which we will see shortly. We close out the loop by ending the `fpsLimiter`
    function and calling `SwapBuffer` on the `Window` object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`InputManager`之后，我们递归调用我们的`Update`和`Draw`类，我们很快就会看到。我们通过结束`fpsLimiter`函数并在`Window`对象上调用`SwapBuffer`来结束循环：
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next function we implement is the `ExitGame` function. Ultimately, this
    will be the function that will be called on the final exit of the game. We close
    out, destroy, and free up any memory that the screen list has created and set
    the `isRunning` Boolean to `false`, which will put an end to the loop:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的下一个函数是`ExitGame`函数。最终，这将是在游戏最终退出时调用的函数。我们关闭，销毁，并释放屏幕列表创建的任何内存，并将`isRunning`布尔值设置为`false`，这将结束循环：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next up is the `Init` function. This function will initialize all the internal
    object settings and call the initialization on the connected systems. Again, this
    is an excellent example of OOP or object-orientated programming and polymorphism.
    Handling initialization in this manner allows the cascading effect, keeping the
    code modular, and easier to modify:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Init`函数。这个函数将初始化所有内部对象设置，并调用连接系统的初始化。同样，这是面向对象编程和多态性的一个很好的例子。以这种方式处理初始化允许级联效应，使代码模块化，并更容易修改：
- en: '[PRE43]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we have the `Update` function. In this `Update` function, we create a
    structure to allow us to execute certain code based on a state that the current
    screen is in. We accomplish this using a simple switch case method with the enumerated
    elements of the `ScreenState` type as the cases. This setup is considered a simple
    finite state machine and is a very powerful design method used throughout game
    development. You can be certain to see this pop up again throughout the book''s
    examples:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Update`函数。在这个`Update`函数中，我们创建一个结构，允许我们根据当前屏幕所处的状态执行特定的代码。我们使用一个简单的switch
    case方法和`ScreenState`类型的枚举元素作为case来实现这一点。这种设置被认为是一个简单的有限状态机，是游戏开发中使用的一种非常强大的设计方法。你可以肯定会在整本书的示例中再次看到它：
- en: '[PRE44]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After our `Update`, we implement the `Draw` function. In our function, we only
    do a couple of things. First, we reset `Viewport` as a simple safety check, then
    if the current screen''s state matches the enumerated value `RUNNING`, we again
    use polymorphism to pass the `Draw` call down the object line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Update`之后，我们实现了`Draw`函数。在我们的函数中，我们只做了一些事情。首先，我们将`Viewport`重置为一个简单的安全检查，然后如果当前屏幕的状态与枚举值`RUNNING`匹配，我们再次使用多态性将`Draw`调用传递到对象行：
- en: '[PRE45]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The last function we need to implement is the `OnSDLEvent` function. Like I
    mention in the definition section of this class, we will use this function to
    connect our `InputManager` system to the SDL built in event system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个函数是`OnSDLEvent`函数。就像我在这个类的定义部分提到的那样，我们将使用这个函数将我们的`InputManager`系统连接到SDL内置的事件系统。
- en: Every key press or mouse movement is handled as an event. Based on the type
    of event that has occurred, we again use a switch case statement to create a simple
    finite state machine. Refer to the manager pattern discussion section preceding
    for how each function was implemented.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次按键或鼠标移动都被视为一个事件。根据发生的事件类型，我们再次使用switch case语句创建一个简单的有限状态机。请参考前面的管理模式讨论部分，了解每个函数是如何实现的。
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Well, that takes care of the `IGame` interface. With this created, we can now
    create a new project that can utilize this and other interfaces in the example
    engine to create a game and initialize it all with just a few lines of code. Here
    is the `App` class of the example project located in the `Chapter03` folder of
    the code repository:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就完成了`IGame`接口。有了这个创建，我们现在可以创建一个新的项目，利用这个和其他接口在示例引擎中创建一个游戏，并只需几行代码就可以初始化它。这是位于代码存储库的`Chapter03`文件夹中示例项目的`App`类：
- en: '[PRE47]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The highlights to note here are that, one, the `App` class inherits from the
    `BookEngine::IGame` interface and two, we have all the necessary overrides that
    the inherited class requires. Next, if we take a look at the `main.cpp` file,
    the entry point for our application, you will see the simple commands to set up
    and kick off all the amazing things our interfaces, managers, and helpers abstract
    for us:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的亮点是，一，`App`类继承自`BookEngine::IGame`接口，二，我们拥有继承类所需的所有必要覆盖。接下来，如果我们看一下`main.cpp`文件，我们的应用程序的入口点，你会看到设置和启动所有我们接口、管理器和助手抽象的简单命令：
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, this is far simpler to type out every time we want to create
    a new project than having to recreate the framework constantly from scratch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这比每次创建新项目时不断从头开始重新创建框架要简单得多。
- en: To see the output of the framework described throughout this chapter, build
    the `BookEngine` project, then build and run the example project. The XCode and
    Visual Studio projects can be found in the `Chapter03` folder of the GitHub code
    repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章描述的框架的输出，请构建`BookEngine`项目，然后构建并运行示例项目。XCode和Visual Studio项目可以在GitHub代码存储库的`Chapter03`文件夹中找到。
- en: 'On Windows, the example project when run will look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，运行示例项目将如下所示：
- en: '>![](img/83deb1cf-51a2-4f66-b3dd-72b7204a62c0.png)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/83deb1cf-51a2-4f66-b3dd-72b7204a62c0.png)'
- en: 'On macOS, the example project when run will look like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，运行示例项目将如下所示：
- en: '![](img/657f1f45-5315-4e53-88dc-22a2d014fa73.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/657f1f45-5315-4e53-88dc-22a2d014fa73.png)'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered quite a bit. We took a look at the different methods
    of using object-oriented programming and polymorphism to create a reusable structure
    for all your game projects. We walked through the differences in helper, managers,
    and interfaces classes with examples from real code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了相当多的内容。我们看了一下使用面向对象编程和多态性创建可重用结构的不同方法。我们通过真实代码示例详细介绍了辅助、管理器和接口类之间的区别。
- en: In the rest of chapters, we will see this structure reused and built upon to
    create the demos. In fact, in the next chapter, we will build even more managers
    and helper classes to create an asset management pipeline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到这种结构被重复使用并不断完善以创建演示。事实上，在下一章中，我们将构建更多的管理器和辅助类，以创建资产管理流水线。
