["```cpp\n    struct Transform {\n    \u00a0\u00a0\u00a0\u00a0vec3 position;\n    \u00a0\u00a0\u00a0\u00a0quat rotation;\n    \u00a0\u00a0\u00a0\u00a0vec3 scale;\n    ```", "```cpp\n    Transform(const vec3& p, const quat& r, const vec3& s) :\n    \u00a0\u00a0\u00a0\u00a0position(p), rotation(r), scale(s) {}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Transform() :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0position(vec3(0, 0, 0)),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rotation(quat(0, 0, 0, 1)),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scale(vec3(1, 1, 1))\n    \u00a0\u00a0\u00a0\u00a0{}\n    }; // End of transform struct\n    ```", "```cpp\nTransform combine(const Transform& a, const Transform& b) {\n\u00a0\u00a0\u00a0\u00a0Transform out;\n\u00a0\u00a0\u00a0\u00a0out.scale = a.scale * b.scale;\n\u00a0\u00a0\u00a0\u00a0out.rotation = b.rotation * a.rotation;\n\u00a0\u00a0\u00a0\u00a0out.position = a.rotation * (a.scale * b.position);\n\u00a0\u00a0\u00a0\u00a0out.position = a.position + out.position;\n\u00a0\u00a0\u00a0\u00a0return out;\n}\n```", "```cpp\nTransform inverse(const Transform& t) {\n\u00a0\u00a0\u00a0\u00a0Transform inv;\n\u00a0\u00a0\u00a0\u00a0inv.rotation = inverse(t.rotation);\n\u00a0\u00a0\u00a0\u00a0inv.scale.x = fabs(t.scale.x) < VEC3_EPSILON ? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0f : 1.0f / t.scale.x;\n\u00a0\u00a0\u00a0\u00a0inv.scale.y = fabs(t.scale.y) < VEC3_EPSILON ? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0f : 1.0f / t.scale.y;\n\u00a0\u00a0\u00a0\u00a0inv.scale.z = fabs(t.scale.z) < VEC3_EPSILON ? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0f : 1.0f / t.scale.z;\n\u00a0\u00a0\u00a0\u00a0vec3 invTrans = t.position * -1.0f;\n\u00a0\u00a0\u00a0\u00a0inv.position = inv.rotation * (inv.scale * invTrans);\n\u00a0\u00a0\u00a0\u00a0return inv;\n}\n```", "```cpp\nTransform mix(const Transform& a,const Transform& b,float t){\n\u00a0\u00a0\u00a0\u00a0quat bRot = b.rotation;\n\u00a0\u00a0\u00a0\u00a0if (dot(a.rotation, bRot) < 0.0f) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bRot = -bRot;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return Transform(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lerp(a.position, b.position, t),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nlerp(a.rotation, bRot, t),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lerp(a.scale, b.scale, t));\n}\n```", "```cpp\nmat4 transformToMat4(const Transform& t) {\n\u00a0\u00a0\u00a0\u00a0// First, extract the rotation basis of the transform\n\u00a0\u00a0\u00a0\u00a0vec3 x = t.rotation * vec3(1, 0, 0);\n\u00a0\u00a0\u00a0\u00a0vec3 y = t.rotation * vec3(0, 1, 0);\n\u00a0\u00a0\u00a0\u00a0vec3 z = t.rotation * vec3(0, 0, 1);\n\u00a0\u00a0\u00a0\u00a0// Next, scale the basis vectors\n\u00a0\u00a0\u00a0\u00a0x = x * t.scale.x;\n\u00a0\u00a0\u00a0\u00a0y = y * t.scale.y;\n\u00a0\u00a0\u00a0\u00a0z = z * t.scale.z;\n\u00a0\u00a0\u00a0\u00a0// Extract the position of the transform\n\u00a0\u00a0\u00a0\u00a0vec3 p = t.position;\n\u00a0\u00a0\u00a0\u00a0// Create matrix\n\u00a0\u00a0\u00a0\u00a0return mat4(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x.x, x.y, x.z, 0, // X basis (& Scale)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y.x, y.y, y.z, 0, // Y basis (& scale)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0z.x, z.y, z.z, 0, // Z basis (& scale)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p.x, p.y, p.z, 1\u00a0\u00a0// Position\n\u00a0\u00a0\u00a0\u00a0);\n}\n```", "```cpp\nTransform mat4ToTransform(const mat4& m) {\n\u00a0\u00a0\u00a0\u00a0Transform out;\n\u00a0\u00a0\u00a0\u00a0out.position = vec3(m.v[12], m.v[13], m.v[14]);\n\u00a0\u00a0\u00a0\u00a0out.rotation = mat4ToQuat(m);\n\u00a0\u00a0\u00a0\u00a0mat4 rotScaleMat(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m.v[0], m.v[1], m.v[2], 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m.v[4], m.v[5], m.v[6], 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m.v[8], m.v[9], m.v[10], 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, 0, 0, 1\n\u00a0\u00a0\u00a0\u00a0);\n\u00a0\u00a0\u00a0\u00a0mat4 invRotMat = quatToMat4(inverse(out.rotation));\n\u00a0\u00a0\u00a0\u00a0mat4 scaleSkewMat = rotScaleMat * invRotMat;\n\u00a0\u00a0\u00a0\u00a0out.scale = vec3(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scaleSkewMat.v[0], \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scaleSkewMat.v[5], \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scaleSkewMat.v[10]\n\u00a0\u00a0\u00a0\u00a0);\n\u00a0\u00a0\u00a0\u00a0return out;\n}\n```", "```cpp\n    vec3 transformPoint(const Transform& a, const vec3& b) {\n    \u00a0\u00a0\u00a0\u00a0vec3 out;\n    \u00a0\u00a0\u00a0\u00a0out = a.rotation * (a.scale * b);\n    \u00a0\u00a0\u00a0\u00a0out = a.position + out;\n    \u00a0\u00a0\u00a0\u00a0return out;\n    }\n    ```", "```cpp\n    vec3 transformVector(const Transform& a, const vec3& b) {\n    \u00a0\u00a0\u00a0\u00a0vec3 out;\n    \u00a0\u00a0\u00a0\u00a0out = a.rotation * (a.scale * b);\n    \u00a0\u00a0\u00a0\u00a0return out;\n    }\n    ```"]