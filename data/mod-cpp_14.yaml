- en: Strings and Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和正则表达式
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的问题解决部分。
- en: 23\. Binary to string conversion
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23\. 二进制转字符串
- en: 'Write a function that, given a range of 8-bit integers (such as an array or
    vector), returns a string that contains a hexadecimal representation of the input
    data. The function should be able to produce both uppercase and lowercase content.
    Here are some input and output examples:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个8位整数范围（例如数组或向量），返回一个包含输入数据十六进制表示的字符串。该函数应能够产生大写和小写内容。以下是一些输入和输出示例：
- en: 'Input: `{ 0xBA, 0xAD, 0xF0, 0x0D }`, output: `"BAADF00D"` or `"baadf00d"`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：`{ 0xBA, 0xAD, 0xF0, 0x0D }`，输出：`"BAADF00D"`或`"baadf00d"`
- en: 'Input: `{ 1,2,3,4,5,6 }`, output: `"010203040506"`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：`{ 1,2,3,4,5,6 }`，输出：`"010203040506"`
- en: 24\. String to binary conversion
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 24\. 字符串转二进制
- en: 'Write a function that, given a string containing hexadecimal digits as the
    input argument, returns a vector of 8-bit integers that represent the numerical
    deserialization of the string content. The following are examples:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个包含十六进制数字的字符串作为输入参数，返回表示字符串内容的数值反序列化的8位整数向量。以下是示例：
- en: 'Input: `"BAADF00D"` or `"baadF00D"`, output: `{0xBA, 0xAD, 0xF0, 0x0D}`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：`"BAADF00D"`或`"baadF00D"`，输出：`{0xBA, 0xAD, 0xF0, 0x0D}`
- en: 'Input `"010203040506"`, output: `{1, 2, 3, 4, 5, 6}`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`"010203040506"`，输出：`{1, 2, 3, 4, 5, 6}`
- en: 25\. Capitalizing an article title
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25\. 文章标题大写
- en: Write a function that transforms an input text into a capitalized version, where
    every word starts with an uppercase letter and has all the other letters in lowercase.
    For instance, the text `"the c++ challenger"` should be transformed to `"The C++
    Challenger"`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，将输入文本转换为大写版本，其中每个单词以大写字母开头，其他所有字母都是小写。例如，文本`"the c++ challenger"`应转换为`"The
    C++ Challenger"`。
- en: 26\. Joining strings together separated by a delimiter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 26\. 用分隔符连接字符串
- en: Write a function that, given a list of strings and a delimiter, creates a new
    string by concatenating all the input strings separated with the specified delimiter.
    The delimiter must not appear after the last string, and when no input string
    is provided, the function must return an empty string.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个字符串列表和一个分隔符，通过连接所有输入字符串并用指定的分隔符分隔，创建一个新字符串。分隔符不得出现在最后一个字符串之后，当没有提供输入字符串时，函数必须返回一个空字符串。
- en: 'Example: input `{ "this","is","an","example" }` and delimiter `'' ''` (space),
    output: `"this is an example"`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：输入`{ "this","is","an","example" }`和分隔符`' '`（空格），输出：`"this is an example"`。
- en: 27\. Splitting a string into tokens with a list of possible delimiters
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 27\. 使用可能的分隔符将字符串拆分为标记
- en: Write a function that, given a string and a list of possible delimiter characters,
    splits the string into tokens separated by any of the delimiters and returns them
    in an `std::vector`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个字符串和可能的分隔符字符列表，将字符串分割成由任何分隔符分隔的标记，并将它们返回到一个`std::vector`中。
- en: 'Example: input: `"this,is.a sample!!"` with delimiters `",.! "`, output: `{"this",
    "is", "a", "sample"}`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：输入：`"this,is.a sample!!"`，使用分隔符`",.! "`，输出：`{"this", "is", "a", "sample"}`。
- en: 28\. Longest palindromic substring
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 28\. 最长回文子串
- en: Write a function that, given an input string, locates and returns the longest
    sequence in the string that is a palindrome. If multiple palindromes of the same
    length exist, the first one should be returned.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定输入字符串，找到并返回字符串中最长的回文序列。如果存在相同长度的多个回文序列，则应返回第一个。
- en: 29\. License plate validation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 29\. 车牌验证
- en: 'Considering license plates with the format `LLL-LL DDD` or `LLL-LL DDDD` (where
    `L` is an uppercase letter from *A* to *Z* and `D` is a digit), write:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑格式为`LLL-LL DDD`或`LLL-LL DDDD`（其中`L`是从*A*到*Z*的大写字母，`D`是数字）的车牌，编写：
- en: One function that validates that a license plate number is of the correct format
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个验证车牌号是否为正确格式的函数
- en: One function that, given an input text, extracts and returns all the license
    plate numbers found in the text
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，给定输入文本，提取并返回文本中找到的所有车牌号
- en: 30\. Extracting URL parts
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 30\. 提取URL部分
- en: Write a function that, given a string that represents a URL, parses and extracts
    the parts of the URL (protocol, domain, port, path, query, and fragment).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定表示URL的字符串，解析并提取URL的各个部分（协议、域名、端口、路径、查询和片段）。
- en: 31\. Transforming dates in strings
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 31\. 转换字符串中的日期
- en: Write a function that, given a text containing dates in the format `dd.mm.yyyy`
    or `dd-mm-yyyy`, transforms the text so that it contains dates in the format `yyyy-mm-dd`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个包含格式为`dd.mm.yyyy`或`dd-mm-yyyy`的日期的文本，将文本转换为包含格式为`yyyy-mm-dd`的日期。
- en: Solutions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述问题解决部分的解决方案。
- en: 23\. Binary to string conversion
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23\. 二进制转字符串
- en: 'In order to write a general-purpose function that can handle various sorts
    of ranges, such as an `std::array`, `std::vector`, a C-like array, or others,
    we should write a function template. In the following, there are two overloads;
    one that takes a container as an argument and a flag indicating the casing style,
    and one that takes a pair of iterators (to mark the first and then one past the
    end element of the range) and the flag to indicate casing. The content of the
    range is written to an `std::ostringstream` object, with the appropriate I/O manipulators,
    such as width, filling character, or case flag:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个通用的函数，可以处理各种范围，如`std::array`、`std::vector`、类C数组或其他范围，我们应该编写一个函数模板。在下面，有两个重载；一个接受一个容器作为参数和一个标志，指示大小写风格，另一个接受一对迭代器（标记范围的第一个元素和最后一个元素的后一个元素）和指示大小写的标志。范围的内容被写入一个`std::ostringstream`对象，使用适当的I/O操纵器，如宽度、填充字符或大小写标志：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These functions can be used as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以如下使用：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 24\. String to binary conversion
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 24\. 字符串转二进制
- en: 'The operation requested here is the opposite of the one implemented in the
    previous problem. This time, however, we could write a function and not a function
    template. The input is an `std::string_view`, which is a lightweight wrapper for
    a sequence of characters. The output is a vector of 8-bit unsigned integers. The
    following `hexstr_to_bytes` function transforms every two text characters into
    an `unsigned char` value (`"A0"` becomes `0xA0`), puts them into an `std::vector`,
    and returns the vector:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里请求的操作与前一个问题中实现的相反。然而，这一次，我们可以编写一个函数而不是一个函数模板。输入是一个`std::string_view`，它是一个字符序列的轻量级包装器。输出是一个8位无符号整数的向量。下面的`hexstr_to_bytes`函数将每两个文本字符转换为一个`unsigned
    char`值（`"A0"`变成`0xA0`），将它们放入一个`std::vector`中，并返回该向量：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function assumes the input string contains an even number of hexadecimal
    digits. In cases where the input string contains an odd number of hexadecimal
    digits, the last one is discarded (so that `"BAD"` becomes `{0xBA}`). As a further
    exercise, modify the preceding function so that, instead of discarding the last
    odd digit, it considers a leading zero so that `"BAD"` becomes `{0x0B, 0xAD}`.
    Also, as yet another exercise, you can write a version of the function that deserializes
    content that has the hexadecimal digits separated by a delimiter, such as space
    (for example `"BA AD F0 0D"`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数假设输入字符串包含偶数个十六进制数字。在输入字符串包含奇数个十六进制数字的情况下，最后一个将被丢弃（所以`"BAD"`变成了`{0xBA}`）。作为进一步的练习，修改前面的函数，使得它不是丢弃最后一个奇数位，而是考虑一个前导零，这样`"BAD"`就变成了`{0x0B,
    0xAD}`。另外，作为另一个练习，您可以编写一个函数的版本，它可以反序列化内容，其中十六进制数字由分隔符分隔，比如空格（例如`"BA AD F0 0D"`）。
- en: 'The next code sample shows how this function can be used:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码示例显示了如何使用这个函数：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 25\. Capitalizing an article title
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25\. 将文章标题大写
- en: 'The function template `capitalize()`, implemented as follows, works with strings
    of any type of characters. It does not modify the input string but creates a new
    string. To do so, it uses an `std::stringstream`. It iterates through all the
    characters in the input string and sets a flag indicating a new word to `true`
    every time a space or punctuation is encountered. Input characters are transformed
    to uppercase when they represent the first character in a word and to lowercase
    otherwise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板`capitalize()`，实现如下，可以处理任何类型字符的字符串。它不修改输入字符串，而是创建一个新的字符串。为此，它使用一个`std::stringstream`。它遍历输入字符串中的所有字符，并在遇到空格或标点符号时将指示新单词的标志设置为`true`。当它们表示一个单词中的第一个字符时，输入字符被转换为大写，否则转换为小写：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following program you can see how this function is used to capitalize
    texts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的程序中，您可以看到如何使用这个函数来大写文本：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 26\. Joining strings together separated by a delimiter
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 26\. 用分隔符连接字符串
- en: 'Two overloads called `join_strings()` are listed in the following code. One
    takes a container of strings and a pointer to a sequence of characters representing
    a separator, while the other takes two random access iterators, representing the
    first and one past the last element of a range, and a separator. They both return
    a new string created by concatenating all the input strings, using an output string
    stream and the `std::copy` function. This general-purpose function copies all
    the elements in the specified range to an output range, represented by an output
    iterator. We are using here an `std::ostream_iterator` that uses `operator<<`
    to write the assigned value to the specified output stream each time the iterator
    is assigned a value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码中列出了两个名为`join_strings()`的重载。一个接受一个字符串容器和一个表示分隔符的字符序列的指针，而另一个接受两个随机访问迭代器，表示范围的第一个和最后一个元素，以及一个分隔符。它们都返回一个通过连接所有输入字符串创建的新字符串，使用输出字符串流和`std::copy`函数。这个通用函数将指定范围中的所有元素复制到一个输出范围中，由输出迭代器表示。我们在这里使用了一个`std::ostream_iterator`，它使用`operator<<`每次迭代器被赋予一个值时将指定的值写入指定的输出流： '
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a further exercise, you should modify the overload that takes iterators as
    arguments so that it works with other types of iterators, such as bidirectional
    iterators, thereby enabling the use of this function with lists or other containers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的练习，您应该修改接受迭代器作为参数的重载，以便它可以与其他类型的迭代器一起工作，比如双向迭代器，从而使得可以使用这个函数与列表或其他容器一起使用。
- en: 27\. Splitting a string into tokens with a list of possible delimiters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 27\. 使用可能的分隔符列表将字符串拆分为标记
- en: 'Two different versions of a splitting function are listed as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同版本的拆分函数如下所示：
- en: The first one uses a single character as the delimiter. To split the input string
    it uses a string stream initialized with the content of the input string, using `std::getline()` to
    read chunks from it until the next delimiter or an end-of-line character is encountered.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个使用单个字符作为分隔符。为了拆分输入字符串，它使用一个字符串流，该字符串流初始化为输入字符串的内容，使用`std::getline()`从中读取块，直到遇到下一个分隔符或行尾字符。
- en: 'The second one uses a list of possible character delimiters, specified in an `std::string`.
    It uses `std:string::find_first_of()` to locate the first position of any of the
    delimiter characters, starting from a given position. It does so in a loop until
    the entire input string is being processed. The extracted substrings are added
    to the result vector:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个版本使用了一个可能的字符分隔符列表，指定在`std::string`中。它使用`std:string::find_first_of()`来定位从给定位置开始的任何分隔符字符的第一个位置。它在循环中这样做，直到整个输入字符串被处理。提取的子字符串被添加到结果向量中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following sample code shows two examples of how different strings can be
    split using either one delimiter character or multiple delimiters:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例代码显示了如何使用一个分隔符字符或多个分隔符来拆分不同的字符串的两个示例：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 28\. Longest palindromic substring
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 28\. 最长回文子字符串
- en: The simplest solution to this problem is to try a brute-force approach, checking
    if each substring is a palindrome. However, this means we need to check *C(N,
    2)* substrings (where *N* is the number of characters in the string), and the
    time complexity would be *![](img/76505ab6-7d29-4aab-9955-744ed0bcd1b6.png)*. 
    The complexity could be reduced to ![](img/2f7e78fe-014a-40b2-9524-bc0f479781a1.png)
    by storing results of sub problems. To do so we need a table of Boolean values,
    of size ![](img/a4173824-4963-42ca-b9ab-fd97affe7750.png), where the element at
    `[i, j]` indicates whether the substring from position `i` to `j` is a palindrome.
    We start by initializing all elements `[i,i]` with `true` (one-character palindromes)
    and all the elements `[i,i+i]` with `true` for all consecutive two identical characters
    (for two-character palindromes). We then go on to inspect substrings greater than
    two characters, setting the element at `[i,j]` to `true` if the element at `[i+i,j-1]`
    is `true` and the characters on the positions `i` and `j` in the string are also
    equal. Along the way, we retain the start position and length of the longest palindromic
    substring in order to extract it after finishing computing the table.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是尝试蛮力方法，检查每个子字符串是否为回文。然而，这意味着我们需要检查*C(N, 2)*个子字符串（其中*N*是字符串中的字符数），时间复杂度将是*![](img/76505ab6-7d29-4aab-9955-744ed0bcd1b6.png)*。通过存储子问题的结果，复杂度可以降低到*![](img/2f7e78fe-014a-40b2-9524-bc0f479781a1.png)*。为此，我们需要一个大小为![](img/a4173824-4963-42ca-b9ab-fd97affe7750.png)的布尔值表，其中`[i,
    j]`处的元素指示位置`i`到`j`的子字符串是否为回文。我们首先通过将所有`[i,i]`处的元素初始化为`true`（单字符回文）和所有`[i,i+i]`处的元素初始化为`true`（所有连续两个相同字符的两字符回文）来开始。然后，我们继续检查大于两个字符的子字符串，如果`[i+i,j-1]`处的元素为`true`且字符串中位置`i`和`j`的字符也相等，则将`[i,j]`处的元素设置为`true`。在此过程中，我们保留最长回文子字符串的起始位置和长度，以便在完成计算表后提取它。
- en: 'In code, this solution appears as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这个解决方案如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are some test cases for the `longest_palindrome()` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`longest_palindrome()`函数的一些测试用例：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 29\. License plate validation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 29\. 验证车牌
- en: The simplest way to solve this problem is by using regular expressions. The
    regular expression that meets the described format is `"[A-Z]{3}-[A-Z]{2} \d{3,4}"`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是使用正则表达式。符合描述格式的正则表达式是`"[A-Z]{3}-[A-Z]{2} \d{3,4}"`。
- en: 'The first function only has to validate that an input string contains only
    text that matches this regular expression. For that, we can use `std::regex_match()`,
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数只需验证输入字符串是否只包含与此正则表达式匹配的文本。为此，我们可以使用`std::regex_match()`，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second function is slightly different. Instead of matching the input string,
    it must identify all occurrences of the regular expression within the string.
    The regular expression would therefore change to `"([A-Z]{3}-[A-Z]{2} \d{3,4})*"`.
    To iterate through all matches we have to use `std::sregex_iterator`, which is
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数略有不同。它不是匹配输入字符串，而是必须识别字符串中正则表达式的所有出现。因此，正则表达式将更改为`"([A-Z]{3}-[A-Z]{2} \d{3,4})*"`。要遍历所有匹配项，我们必须使用`std::sregex_iterator`，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 30\. Extracting URL parts
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 30\. 提取URL部分
- en: This problem is also suited to being solved using regular expressions. Finding
    a regular expression that could match any URL is, however, a difficult task. The
    purpose of this exercise is to help you practice your skills with the regex library,
    and not to find the ultimate regular expression for this particular purpose. Therefore,
    the regular expression used here is provided only for didactic purposes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题也适合使用正则表达式来解决。然而，找到一个可以匹配任何URL的正则表达式是一个困难的任务。这个练习的目的是帮助您练习正则表达式库的技能，而不是找到特定目的的终极正则表达式。因此，这里使用的正则表达式仅供教学目的。
- en: You can try regular expressions using online testers and debuggers, such as
    [https://regex101.com/](https://regex101.com/). This can be useful in order to
    work out your regular expressions and try them against various datasets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用在线测试器和调试器，如[https://regex101.com/](https://regex101.com/)，尝试正则表达式。这可以帮助您解决正则表达式并针对各种数据集尝试它们。
- en: 'For this task we will consider that a URL has the following parts: `protocol`
    and `domain` are mandatory, and `port`, `path`, `query`, and `fragment` are all
    optional. The following structure is used to return results from parsing an URL
    (alternatively, you could return a tuple and use structured binding to bind variables
    to the various sub parts of the tuple):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此任务，我们将认为URL具有以下部分：`protocol`和`domain`是必需的，而`port`、`path`、`query`和`fragment`都是可选的。以下结构用于从解析URL返回结果（或者，您可以返回一个元组，并使用结构化绑定将变量绑定到元组的各个子部分）：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A function that can parse a URL and extract and return its parts could have
    the following implementation. Note that the return type is an `std::optional<uri_parts>`
    because the function might fail in matching the input string to the regular expression;
    in this case, the return value is `std::nullopt`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解析URL并提取并返回其部分的函数可能具有以下实现。请注意，返回类型是`std::optional<uri_parts>`，因为该函数可能无法将输入字符串与正则表达式匹配；在这种情况下，返回值为`std::nullopt`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following program tests the `parse_uri()` function with two URLs that contain
    different parts:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用包含不同部分的两个URL测试`parse_uri()`函数：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 31\. Transforming dates in strings
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 31\. 将字符串中的日期转换
- en: Text transformation can be performed with regular expressions using `std::regex_replace()`.
    A regular expression that can match dates with the specified formats is `(\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4})`.
    This regex defines five capture groups; the 1^(st) is for the day, the 2^(nd)
    is for the separator (`.` or `-`), the 3^(rd) is for the month, the 4^(th) is
    again for the separator (`.` or `-`), and the 5^(th) is for the year.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`std::regex_replace()`和正则表达式执行文本转换。可以匹配指定格式日期的正则表达式是`(\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4})`。这个正则表达式定义了五个捕获组；第一个是日期，第二个是分隔符（`.`或`-`），第三个是月份，第四个再次是分隔符（`.`或`-`），第五个是年份。
- en: 'Since we want to transform dates from the format `dd.mm.yyyy` or `dd-mm-yyyy` to
    `yyyy-mm-dd`, the regex replacement format string for `std::regex_replace()` should
    be `"($5-$3-$1)"`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将日期从格式 `dd.mm.yyyy` 或 `dd-mm-yyyy` 转换为 `yyyy-mm-dd`，因此 `std::regex_replace()`
    的正则表达式替换格式字符串应该是 `"($5-$3-$1)"`：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
