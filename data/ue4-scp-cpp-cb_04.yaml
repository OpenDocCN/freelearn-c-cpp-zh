- en: Chapter 4. Actors and Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Actor和组件
- en: 'In this chapter, we will cover following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Creating a custom `Actor` in C++
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中创建自定义`Actor`
- en: Instantiating an `Actor` using `SpawnActor`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SpawnActor`实例化`Actor`
- en: Destroying an `Actor` using `Destroy` and a Timer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Destroy`和定时器销毁`Actor`
- en: Destroying an `Actor` after a delay using `SetLifeSpan`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SetLifeSpan`在延迟后销毁`Actor`
- en: Implementing the `Actor` functionality by composition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合实现`Actor`功能
- en: Loading assets into components using `FObjectFinder`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FObjectFinder`将资产加载到组件中
- en: Implementing the `Actor` functionality by inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过继承实现`Actor`功能
- en: Attaching components to create a hierarchy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加组件以创建层次结构
- en: Creating a custom `Actor` Component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义`Actor`组件
- en: Creating a custom `Scene` Component
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义`Scene`组件
- en: Creating a custom `Primitive` Component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义`Primitive`组件
- en: Creating an `InventoryComponent` for an RPG
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为RPG创建`InventoryComponent`
- en: Creating an `OrbitingMovement` Component
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`OrbitingMovement`组件
- en: Creating a building that spawns units
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建生成单位的建筑物
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Actors are classes which have some presence in the game world. Actors gain their
    specialized functionality by incorporating Components. This chapter deals with
    creating custom Actors and Components, the purpose that they serve, and how they
    work together.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Actor是在游戏世界中具有一定存在的类。Actor通过合并组件获得其专门功能。本章涉及创建自定义Actor和组件，它们的作用以及它们如何一起工作。
- en: Creating a custom Actor in C++
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建自定义Actor
- en: While there are a number of different types of Actors that ship with Unreal
    as part of the default installation, you will find yourself needing to create
    custom Actors at some point during your project's development. This might happen
    when you need to add functionality to an existing class, combine Components in
    a combination not present in the default subclasses, or add additional member
    variables to a class. The next two recipes demonstrate how to use either composition
    or inheritance to customize Actors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal默认安装的一些不同类型的Actor中，您可能会发现自己在项目开发过程中需要创建自定义的Actor。这可能发生在您需要向现有类添加功能时，将组件组合成默认子类中不存在的组合，或者向类添加额外的成员变量时。接下来的两个示例演示了如何使用组合或继承来自定义Actor。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have installed Visual Studio and Unreal 4 as per the recipe in
    [Chapter 1](part0015_split_000.html#E9OE1-c0ca69a0411046888a488e5085138121 "Chapter 1. UE4
    Development Tools"), *UE4 Development Tools.* You'll also need to have either
    an existing project, or create a new one using the Unreal-provided wizard.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经按照[第1章](part0015_split_000.html#E9OE1-c0ca69a0411046888a488e5085138121
    "第1章。UE4开发工具")中的示例安装了Visual Studio和Unreal 4，*UE4开发工具*。您还需要有一个现有项目，或者使用Unreal提供的向导创建一个新项目。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open up your project within the Unreal Editor, then click on the **Add New**
    button in **Content Browser**:![How to do it...](img/00072.jpeg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unreal Editor中打开您的项目，然后单击**Content Browser**中的**Add New**按钮：![如何做...](img/00072.jpeg)
- en: Select **New C++ Class...**![How to do it...](img/00073.jpeg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**New C++ Class...**![如何做...](img/00073.jpeg)
- en: In the dialog that opens, select **Actor** from the list:![How to do it...](img/00074.jpeg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的对话框中，从列表中选择**Actor**：![如何做...](img/00074.jpeg)
- en: Give your Actor a name, such as `MyFirstActor`, then click on **OK** to launch
    Visual Studio.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的Actor一个名称，比如`MyFirstActor`，然后单击**OK**启动Visual Studio。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By convention, class names for `Actor` subclasses begin with an `A`. When using
    this class creation wizard, make sure you don't prefix your class with `A`, as
    the engine automatically adds the prefix for you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`Actor`子类的类名以`A`开头。在使用此类创建向导时，请确保不要为您的类添加`A`前缀，因为引擎会自动为您添加前缀。
- en: '![How to do it...](img/00075.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00075.jpeg)'
- en: 'When Visual Studio loads, you should see something very similar to the following
    listing:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Visual Studio加载时，您应该看到与以下列表非常相似的内容：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In time, you'll become familiar enough with the standard code, so you will be
    able to just create new classes from Visual Studio without using the Unreal wizard.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，您将熟悉标准代码，因此您将能够在不使用Unreal向导的情况下直接从Visual Studio创建新类。
- en: '`#pragma once`: This preprocessor statement, or `pragma`, is Unreal''s expected
    method of implementing include guards—pieces of code that prevent an `include`
    file from causing errors by being referenced multiple times.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#pragma once`: 这个预处理器语句，或者`pragma`，是Unreal预期的实现包含保护的方法——防止多次引用`include`文件导致错误。'
- en: '`#include "GameFramework/Actor.h"`: We''re going to create an `Actor` subclass,
    so naturally, we need to include the `header` file for the class we are inheriting
    from.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "GameFramework/Actor.h"`: 我们将创建一个`Actor`子类，因此自然需要包含我们从中继承的类的`header`文件。'
- en: '`#include "MyFirstActor.generated.h"`: All actor classes need to include their
    `generated.h` file. This file is automatically created by **Unreal Header Tool**
    (**UHT**) based on the macros that it detects in your files.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "MyFirstActor.generated.h"`: 所有actor类都需要包含它们的`generated.h`文件。这个文件是根据它在您的文件中检测到的宏自动由**Unreal
    Header Tool** (**UHT**)创建的。'
- en: '`UCLASS()`: `UCLASS` is one such macro, which allows us to indicate that a
    class will be exposed to Unreal''s reflection system. Reflection allows us to
    inspect and iterate object properties during runtime as well as manage references
    to our objects for garbage collection.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UCLASS()`: `UCLASS`是这样一个宏，它允许我们指示一个类将暴露给Unreal的反射系统。反射允许我们在运行时检查和迭代对象属性，以及管理对我们对象的引用以进行垃圾回收。'
- en: '`class UE4COOKBOOK_API AMyFirstActor : public AActor`: This is the actual declaration
    of our class. The `UE4COOKBOOK_API` macro is created by UHT, and is necessary
    to help our project compile properly on Windows by ensuring that our project module''s
    classes are exported correctly in the DLL. You will also notice that both `MyFirstActor`
    and `Actor` have the prefix `A`—this is the naming convention that Unreal requires
    for native classes that are inherited from `Actor`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class UE4COOKBOOK_API AMyFirstActor : public AActor`：这是我们类的实际声明。`UE4COOKBOOK_API`宏是由UHT创建的，通过确保项目模块的类在DLL中正确导出，可以帮助我们的项目在Windows上正确编译。你还会注意到`MyFirstActor`和`Actor`都有前缀`A`——这是虚幻要求的从`Actor`继承的本地类的命名约定。'
- en: '`GENERATED_BODY()`: `GENERATED_BODY` is another UHT macro that has been expanded
    to include the automatically generated functions that the underlying UE type system
    requires.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GENERATED_BODY()`: `GENERATED_BODY`是另一个UHT宏，已经扩展到包括底层UE类型系统所需的自动生成函数。'
- en: '`PrimaryActorTick.bCanEverTick = true;`: Inside the constructor implementation,
    this line enables ticking for this `Actor`. All Actors have a function called
    `Tick`, and this Boolean variable means that the `Actor` will have that function
    called once per frame enabling the actor to perform actions in every frame as
    necessary. As a performance optimization, this is disabled by default.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryActorTick.bCanEverTick = true;`：在构造函数实现中，这一行启用了这个`Actor`的tick。所有的Actor都有一个名为`Tick`的函数，这个布尔变量意味着`Actor`将每帧调用一次该函数，使得`Actor`能够在每帧执行必要的操作。作为性能优化，默认情况下是禁用的。'
- en: Instantiating an Actor using SpawnActor
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SpawnActor实例化一个Actor
- en: For this recipe, you'll need to have an `Actor` subclass ready to instantiate.
    You can use a built-in class such as `StaticMeshActor`, but it would help to practice
    with the custom `Actor` you made in the previous recipe.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要准备一个`Actor`子类来实例化。你可以使用内置类，比如`StaticMeshActor`，但最好练习使用上一个配方中创建的自定义`Actor`。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new C++ class, like in the previous recipe. This time, select `GameMode`
    as your base class, giving it a name such as `UE4CookbookGameMode`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++类，就像在上一个配方中一样。这次，选择`GameMode`作为基类，给它起一个名字，比如`UE4CookbookGameMode`。
- en: 'Declare a function override in your new `GameMode` class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新`GameMode`类中声明一个函数重写：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement `BeginPlay` in the `.cpp` file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现`BeginPlay`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile your code, either through Visual Studio or by clicking on the **Compile**
    button in Unreal Editor.![How to do it...](img/00076.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码，可以通过Visual Studio或者在虚幻编辑器中点击**编译**按钮来进行。![如何操作...](img/00076.jpeg)
- en: Open the **World Settings** panel for the current level by clicking on the **Settings**
    toolbar icon, then pick **World Settings** from the drop-down menu. In the **GameMode
    Override** section, change the game mode to the `GameMode` subclass you just created
    as shown in the following two screenshots:![How to do it...](img/00077.jpeg)![How
    to do it...](img/00078.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**设置**工具栏图标，然后从下拉菜单中选择**World Settings**，打开当前级别的**World Settings**面板。在**GameMode
    Override**部分，将游戏模式更改为你刚刚创建的`GameMode`子类，如下两个截图所示:![如何操作...](img/00077.jpeg)![如何操作...](img/00078.jpeg)
- en: Start the level, and verify that `GameMode` spawns a copy of your `Actor` in
    the world by looking at the **World Outliner** panel. You can verify that the
    `BeginPlay` function is being run by viewing the **Actor Spawning** text being
    displayed on screen. If it doesn't spawn, make sure there are no obstructions
    at the world origin to prevent the `Actor` from being spawned. You can search
    the list of objects in the world by typing in the search bar at the top of the
    **World Outliner** panel to filter the entities shown.![How to do it...](img/00079.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动关卡，并通过查看**World Outliner**面板来验证`GameMode`是否在世界中生成了你的`Actor`的副本。你可以通过查看屏幕上显示的**Actor
    Spawning**文本来验证`BeginPlay`函数是否正在运行。如果没有生成，请确保世界原点没有障碍物阻止`Actor`生成。你可以通过在**World
    Outliner**面板顶部的搜索栏中输入来搜索世界中的对象列表，以过滤显示的实体。![如何操作...](img/00079.jpeg)
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`GameMode` is a special type of actor which is part of the Unreal Game Framework.
    Your map''s `GameMode` is instantiated by the engine automatically when the game
    starts.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameMode`是一种特殊类型的Actor，它是虚幻游戏框架的一部分。地图的`GameMode`在游戏启动时由引擎自动实例化。'
- en: By placing some code into the `BeginPlay` method of our custom `GameMode`, we
    can run it automatically when the game begins.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将一些代码放入自定义`GameMode`的`BeginPlay`方法中，我们可以在游戏开始时自动运行它。
- en: Inside `BeginPlay`, we create an `FTransform` to be used by the `SpawnActor`
    function. By default, `FTransform` is constructed to have zero rotation and a
    location at the origin.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，我们创建一个`FTransform`，用于`SpawnActor`函数。默认情况下，`FTransform`被构造为零旋转，并且位置在原点。
- en: We then get a reference to the current level's `UWorld` instance using `GetWorld`,
    then call its `SpawnActor` function. We pass in `FTransform,` which we created
    earlier, to specify that the object should be created at its location, that is,
    the origin.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`GetWorld`获取当前级别的`UWorld`实例，然后调用它的`SpawnActor`函数。我们传入之前创建的`FTransform`，以指定对象应该在其位置即原点处创建。
- en: Destroying an Actor using Destroy and a Timer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Destroy和定时器销毁一个Actor
- en: This recipe will reuse the `GameMode` from the previous recipe, so you should
    complete it first.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将重用上一个配方中的`GameMode`，所以你应该先完成它。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Make the following changes to the `GameMode` declaration:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`GameMode`声明进行以下更改：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add `#include "MyFirstActor.h"` to the implementation file's includes.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件的包含中添加`#include "MyFirstActor.h"`。
- en: 'Assign the results of `SpawnActor` to the new `SpawnedActor` variable:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SpawnActor`的结果分配给新的`SpawnedActor`变量：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following to the end of the `BeginPlay` function:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`函数的末尾添加以下内容：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, implement `DestroyActorFunction`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`DestroyActorFunction`：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Load the level you created in the previous recipe, which had the game mode set
    to your custom class.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载你在上一个配方中创建的具有自定义类游戏模式的关卡。
- en: Play your level, and use the Outliner to verify that your `SpawnedActor` gets
    deleted after 10 seconds.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的关卡，并使用Outliner验证你的`SpawnedActor`在10秒后被删除。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'We declare a `UPROPERTY` to store our spawned `Actor` instance, and a custom
    function to call so that we can call `Destroy()` on a timer:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明一个`UPROPERTY`来存储我们生成的`Actor`实例，并创建一个自定义函数来调用，以便我们可以在计时器上调用`Destroy()`：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `BeginPlay`, we assign the spawned `Actor` to our new `UPROPERTY`:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，我们将生成的`Actor`分配给我们的新`UPROPERTY`：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then declare a `TimerHandle` object, and pass it to `GetWorldTimerManager::SetTimer`.
    `SetTimer` calls `DestroyActorFunction` on the object pointed to by this pointer
    after 10 seconds. `SetTimer` returns an object—a handle—to allow us to cancel
    the timer if necessary. The `SetTimer` function takes the `TimerHandle` object
    in as a reference parameter, hence, we declare it in advance so that we can pass
    it into the function properly:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们声明一个`TimerHandle`对象，并将其传递给`GetWorldTimerManager::SetTimer`。`SetTimer`在10秒后调用`DestroyActorFunction`指向的对象。`SetTimer`返回一个对象，一个句柄，允许我们在必要时取消计时器。`SetTimer`函数将`TimerHandle`对象作为引用参数传入，因此我们提前声明它，以便正确地将其传递给函数：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `DestroyActorFunction` checks if we have a valid reference to a spawned
    `Actor`:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DestroyActorFunction`检查我们是否有一个有效的生成`Actor`的引用：'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we do, it calls `Destroy` on the instance, so it will be destroyed, and
    eventually, garbage collected:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这样做，它会调用实例上的`Destroy`，因此它将被销毁，并最终被垃圾回收：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Destroying an Actor after a delay using SetLifeSpan
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SetLifeSpan延迟销毁Actor
- en: Let's look at how we can destroy an `Actor`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何销毁一个`Actor`。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new C++ class using the wizard. Select `Actor` as your base class.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用向导创建一个新的C++类。选择`Actor`作为你的基类。
- en: 'In the implementation of `Actor`, add the following code to the `BeginPlay`
    function:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Actor`的实现中，将以下代码添加到`BeginPlay`函数中：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Drag a copy of your custom `Actor` into the viewport within the Editor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的自定义`Actor`的一个副本拖到编辑器中的视口中。
- en: Play your level, and look at the Outliner to verify that your `Actor` instance
    disappears after 10 seconds, having destroyed itself.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的关卡，并查看Outliner，以验证你的`Actor`实例在10秒后消失，自行销毁。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: We insert our code into the `BeginPlay` function so that it executes when the
    game starts.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码插入到`BeginPlay`函数中，以便在游戏启动时执行。
- en: '`SetLifeSpan(10);`: The `SetLifeSpan` function allows us to specify a duration
    in seconds, after which the `Actor` calls its own `Destroy()` method.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetLifeSpan(10);`：`SetLifeSpan`函数允许我们指定持续时间（以秒为单位），之后`Actor`调用自己的`Destroy()`方法。'
- en: Implementing the Actor functionality by composition
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组合实现Actor功能
- en: Custom Actors without components don't have a location, and can't be attached
    to other Actors. Without a root Component, an Actor doesn't have a base transform,
    and so it has no location. Most Actors, therefore, require at least one Component
    to be useful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 没有组件的自定义Actor没有位置，也不能附加到其他Actor。没有根组件，Actor没有基本变换，因此它没有位置。因此，大多数Actor至少需要一个组件才能有用。
- en: We can create custom Actors through composition—adding a number of components
    to our `Actor`, where each component provides some of the functionality required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合创建自定义Actor-向我们的`Actor`添加多个组件，其中每个组件提供所需的一些功能。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will use the `Actor` class created in the *Creating a custom Actor
    in C++* recipe.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将使用*在C++中创建自定义Actor*中创建的`Actor`类。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add a new member to your custom class in C++ by making the following changes
    in the `public` section:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`public`部分进行以下更改，在你的自定义类中添加一个新成员：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following line to the constructor inside the cpp file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在cpp文件的构造函数中添加以下行：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Verify your code looks like the following snippet, and compile it by using
    the **Compile** button in the editor, or building the project in Visual Studio:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证你的代码看起来像以下片段，并通过编辑器中的**Compile**按钮编译它，或者在Visual Studio中构建项目：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once you've compiled this code, drag an instance of your class from the **Content
    Browser** out into the game environment, and you will be able to verify that it
    now has a transform and other properties, such as a Static Mesh, which comes from
    the `StaticMeshComponent` that we added.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译此代码后，将类的一个实例从**Content Browser**拖到游戏环境中，您将能够验证它现在具有变换和其他属性，例如来自我们添加的`StaticMeshComponent`的Static
    Mesh。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The `UPROPERTY macro` we added to the class declaration is a pointer to hold
    the component we are using as a subobject of our `Actor`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在类声明中添加的`UPROPERTY宏`是一个指针，用于保存我们作为`Actor`子对象的组件。
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the `UPROPERTY()` macro ensures that the object declared in the pointer
    is considered to be referenced, and won't be garbage-collected (that is, deleted)
    out from under us, leaving the pointer dangling.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`UPROPERTY()`宏确保指针中声明的对象被视为引用，并且不会被垃圾回收（即删除），从而使指针悬空。
- en: We're using a Static Mesh component, but any of the `Actor` Component subclasses
    would work. Note the asterisk is connected to the variable type in accordance
    with Epic's style guide.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了一个Static Mesh组件，但任何`Actor`组件子类都可以工作。请注意，星号与变量类型连接在一起，符合Epic的样式指南。
- en: In the constructor, we initialize the pointer to a known valid value by using
    a `template` function, `template<class TReturnType> TReturnType* CreateDefaultSubobject(FName
    SubobjectName, bool bTransient = false)`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用`template`函数将指针初始化为已知的有效值，`template<class TReturnType> TReturnType*
    CreateDefaultSubobject(FName SubobjectName, bool bTransient = false)`。
- en: This function is responsible for calling the engine code to appropriately initialize
    the component, and return a pointer to the newly constructed object so that we
    can give our component pointer a default value. This is important, obviously,
    to ensure that the pointer has a valid value at all times, minimizing the risk
    of dereferencing uninitialized memory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数负责调用引擎代码来适当初始化组件，并返回一个指向新构造对象的指针，以便我们可以给我们的组件指针一个默认值。这很重要，显然，以确保指针始终具有有效值，最大程度地减少对未初始化内存的引用风险。
- en: The function is templated based on the type of object to create, but also takes
    two parameters—the first one is the name of the subobject, which ideally should
    be human-readable, and the second is whether the object should be transient (that
    is—not saved along with the parent object).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数是基于要创建的对象类型进行模板化的，但还接受两个参数——第一个是子对象的名称，理想情况下应该是可读的，第二个是对象是否应该是瞬态的（即不保存在父对象中）。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The following recipe shows you how to reference a mesh asset in your Static
    Mesh Component so that it can be displayed without requiring a user to specify
    a mesh in the Editor
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下食谱向您展示如何在静态网格组件中引用网格资产，以便可以在不需要用户在编辑器中指定网格的情况下显示它
- en: Loading assets into components using FObjectFinder
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FObjectFinder将资产加载到组件中
- en: In the last recipe, we created a Static Mesh Component, but we didn't try to
    load a mesh for the Component to display. While it's possible to do this in the
    Editor, sometimes it is helpful to specify a default in C++.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们创建了一个静态网格组件，但我们没有尝试加载一个网格来显示组件。虽然在编辑器中可以做到这一点，但有时在C++中指定默认值会更有帮助。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the previous recipe so you have a custom `Actor` subclass with a Static
    Mesh Component ready.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一个食谱，这样您就有了一个准备好的自定义`Actor`子类，其中包含一个静态网格组件。
- en: 'In your **Content Browser**, click on the **View Options** button, and select
    **Show Engine Content**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的**内容浏览器**中，单击**查看选项**按钮，然后选择**显示引擎内容**：
- en: '![Getting ready](img/00080.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00080.jpeg)'
- en: Browse to **Engine Content**, then **BasicShapes** to see the **Cube** we will
    be using in this recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到**引擎内容**，然后到**基本形状**，看看我们将在这个食谱中使用的**立方体**。
- en: '![Getting ready](img/00081.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00081.jpeg)'
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the following code to the constructor of your class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的类的构造函数中：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Compile, and verify in the Editor that an instance of your class now has a mesh
    as its visual representation.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译，并在编辑器中验证您的类的实例现在具有网格作为其视觉表示。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create an instance of the `FObjectFinder` class, passing in the type of asset
    that we are trying to load as a template parameter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`FObjectFinder`类的一个实例，将要加载的资产类型作为模板参数传递进去。
- en: '`FObjectFinder` is a class template that helps us to load assets. When we construct
    it, we pass in a string that contains a path to the asset that we are trying to
    load.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FObjectFinder`是一个类模板，帮助我们加载资产。当我们构造它时，我们传入一个包含我们要加载的资产路径的字符串。'
- en: The string is of the format `"{ObjectType}'/Path/To/Asset.Asset'"`. Note the
    use of single quotes in the string.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的格式为`"{ObjectType}'/Path/To/Asset.Asset'"`。请注意字符串中使用了单引号。
- en: In order to get the string for an asset that already exists in the editor, you
    can right-click on the asset in the **Content Browser** and select **Copy Reference**.
    This gives you the string so you can paste it into your code.![How it works...](img/00082.jpeg)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获取已经存在于编辑器中的资产的字符串，您可以在**内容浏览器**中右键单击资产，然后选择**复制引用**。这会给您一个字符串，这样您就可以将其粘贴到您的代码中。![工作原理...](img/00082.jpeg)
- en: 'We use the `auto` keyword, from C++11, to avoid typing out our whole object
    type in its declaration; the compiler deduces it for us. Without `auto`, we would
    have to use the following code instead:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了C++11中的`auto`关键字，以避免在声明中输入整个对象类型；编译器会为我们推断出类型。如果没有`auto`，我们将不得不使用以下代码：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `FObjectFinder` class has a property called `Object` that will either have
    a pointer to the desired asset, or will be `NU``LL` if the asset could not be
    found.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FObjectFinder`类有一个名为`Object`的属性，它要么有指向所需资产的指针，要么是`NULL`，如果找不到资产。'
- en: This means that we can check it against `nullptr`, and if it isn't null, assign
    it to `Mesh` using `SetStaticMesh`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着我们可以将其与`nullptr`进行比较，如果它不是空的，就使用`SetStaticMesh`将其分配给`Mesh`。
- en: Implementing the Actor functionality by inheritance
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过继承实现Actor功能
- en: Inheritance is the second way to implement a custom `Actor`. This is commonly
    done to make a new subclass, which adds member variables, functions, or a Component
    to an existing `Actor` class. In this recipe, we are going to add a variable to
    a custom `GameState` subclass.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是实现自定义`Actor`的第二种方法。这通常是为了创建一个新的子类，它添加成员变量、函数或组件到现有的`Actor`类中。在这个食谱中，我们将向自定义的`GameState`子类添加一个变量。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the Unreal Editor, click on **Add New** in the **Content Browser,** and then
    on **New C++ Class...** then select **GameState** as the base class, then give
    your new class a name.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻编辑器中，单击**内容浏览器**中的**添加新内容**，然后单击**新建C++类...**，然后选择**GameState**作为基类，然后给您的新类起一个名字。
- en: 'Add the following code to the new class header:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到新类头文件中：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code to the cpp file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到cpp文件中：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Confirm that your code looks like the following listing, and compile using
    the **Compile** button in the Unreal Editor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您的代码看起来像以下清单，并使用虚幻编辑器中的**编译**按钮进行编译：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Firstly, we add the declaration of a default constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了默认构造函数的声明：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This allows us to set our new member variable to a safe default value of `0`
    on object initialization:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使我们能够在对象初始化时将我们的新成员变量设置为安全的默认值`0`：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use the `int32` type when declaring our new variable to ensure portability
    between the various compilers that Unreal Engine supports. This variable is going
    to be responsible for storing the current game score while it is running. As always,
    we will be marking our variable with `UPROPERTY` so that it is garbage collected
    appropriately. This variable is marked `private` so that the only way to change
    the value is through our functions:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明新变量时，我们使用`int32`类型，以确保在虚幻引擎支持的各种编译器之间具有可移植性。这个变量将负责在游戏运行时存储当前游戏分数。与往常一样，我们将使用`UPROPERTY`标记我们的变量，以便它能够得到适当的垃圾回收。这个变量被标记为`private`，所以改变值的唯一方式是通过我们的函数：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `GetScore` function will retrieve the current score, and return it to the
    caller. It is implemented as a simple accessor, which simply returns the underlying
    member variable.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetScore`函数将检索当前分数，并将其返回给调用者。它被实现为一个简单的访问器，只是返回基础成员变量。'
- en: The second function, `SetScore`, sets the value of the member variable allowing
    external objects to request a change to the score. Placing this request as a function
    ensures that the `GameState` can vet such requests, and only allow them when valid
    to prevent cheating. The specifics of such a check are beyond the scope of this
    recipe, but the `SetScore` function is the appropriate place to make it.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数`SetScore`设置成员变量的值，允许外部对象请求更改分数。将此请求作为函数确保`GameState`可以审核此类请求，并且仅在有效时才允许它们，以防止作弊。此类检查的具体内容超出了本配方的范围，但`SetScore`函数是进行此类检查的适当位置。
- en: Our score functions are declared using the `UFUNCTION` macro for a number of
    reasons. Firstly, `UFUNCTION`, with some additional code, can be called or overridden
    by Blueprint. Secondly, `UFUNCTION` can be marked as `exec—`this means that they
    can be run as console commands by a player or developer during a play session,
    which enables debugging.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的分数函数使用`UFUNCTION`宏声明有多种原因。首先，`UFUNCTION`可以通过一些额外的代码被蓝图调用或重写。其次，`UFUNCTION`可以标记为`exec`—这意味着它们可以在游戏会话期间由玩家或开发人员作为控制台命令运行，这样可以进行调试。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* has a recipe, *Creating new console commands*, that you can refer
    to for more information regarding `exec` and the console command functionality'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121 "第8章。集成C++和虚幻编辑器"),
    *集成C++和虚幻编辑器,* 有一个名为*创建新控制台命令*的配方，您可以参考有关`exec`和控制台命令功能的更多信息'
- en: Attaching components to create a hierarchy
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将组件附加到创建层次结构
- en: When creating custom Actors from components, it is important to consider the
    concept of **Attaching**. Attaching components together creates a relationship
    where transformations applied to the parent component will also affect the components
    that are attached to it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在从组件创建自定义Actor时，考虑“附加”的概念非常重要。将组件附加在一起会创建一个关系，其中应用于父组件的变换也会影响附加到它的组件。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new class based on `Actor` using the editor, and call it `HierarchyActor`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器基于`Actor`创建一个新类，并将其命名为`HierarchyActor`。
- en: 'Add the following properties to your new class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到您的新类中：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code to the class constructor:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类构造函数中：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Verify that your code looks like the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的代码是否如下所示：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compile and launch the editor. Drag a copy of HierarchyActor into the scene.![How
    to do it...](img/00083.jpeg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器。将HierarchyActor的副本拖入场景中。！[如何做...](img/00083.jpeg)
- en: Verify that `Actor` has components in a hierarchy, and that the second box has
    a smaller size.![How to do it...](img/00084.jpeg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证“Actor”在层次结构中是否有组件，并且第二个框的大小较小。！[如何做...](img/00084.jpeg)
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As usual, we create some `UPROPERTY`-tagged Components for our actor. We create
    two Scene Components, and two Static Mesh components.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们为我们的Actor创建一些带有`UPROPERTY`标记的组件。我们创建了两个场景组件和两个静态网格组件。
- en: In the constructor, we create default subobjects for each component, as usual.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们像往常一样为每个组件创建默认子对象。
- en: We then load the static mesh, and if loading is successful, assign it to the
    two static mesh components so that they have a visual representation.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们加载静态网格，如果加载成功，将其分配给两个静态网格组件，以便它们具有视觉表示。
- en: We then construct a hierarchy within our `Actor` by attaching components.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过附加组件在我们的`Actor`中构建了一个层次结构。
- en: We set the first Scene Component as the `Actor` root. This component will determine
    the transformations applied to all other components in the hierarchy.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将第一个场景组件设置为`Actor`根。此组件将确定应用于层次结构中所有其他组件的变换。
- en: We then attach the first box to our new root component, and parent the second
    scene component to the first one.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将第一个框附加到我们的新根组件，并将第二个场景组件作为第一个组件的父级。
- en: We attach the second box to our child scene component so as to demonstrate how
    changing the transform on that scene component affects its children, but no other
    components in the object.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将第二个框附加到我们的子场景组件，以演示更改该场景组件上的变换如何影响其子组件，但不影响对象中的其他组件。
- en: Lastly, we set the relative transform of that scene component so that it moves
    a certain distance away from the origin, and is one-tenth of the scale.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置场景组件的相对变换，使其从原点移动一定距离，并且是比例的十分之一。
- en: This means that in the Editor, you can see that the `BoxTwo` component has inherited
    the translation and scaling of its parent component, `ChildSceneComponent`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着在编辑器中，您可以看到`BoxTwo`组件继承了其父组件`ChildSceneComponent`的平移和缩放。
- en: Creating a custom Actor Component
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义Actor组件
- en: Actor components are an easy way to implement common functionality that should
    be shared between Actors. Actor components aren't rendered, but can still perform
    actions such as subscribing to events, or communicating with other components
    of the Actor that they are present within.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Actor组件是实现应该在Actor之间共享的常见功能的简单方法。Actor组件不会被渲染，但仍然可以执行操作，比如订阅事件或与包含它们的Actor的其他组件进行通信。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an `ActorComponent` named `RandomMovementComponent` using the Editor
    wizard. Add the following class specifiers to the `UCLASS` macro:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个名为`RandomMovementComponent`的`ActorComponent`。将以下类说明符添加到`UCLASS`宏中：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following `UPROPERTY` to the class header:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类头文件中添加以下`UPROPERTY`：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following to the constructor''s implementation:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到构造函数的实现中：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, add this to the implementation of `TickComponent( )`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下内容添加到`TickComponent()`的实现中：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Verify that your code looks like the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的代码是否如下所示：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compile your project. In the editor, create an empty `Actor`, and add your **Random
    Movement** Component to it. To do this, drag an **Empty Actor** from the **Placement**
    tab out into the level, then click on **Add Component** in the **Details** panel,
    and select **Random Movement**. Do the same thing to add a **Cube** Component
    so that you have something to visualize your actor's position with.![How to do
    it...](img/00085.jpeg)![How to do it...](img/00086.jpeg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。在编辑器中，创建一个空的`Actor`，并将**Random Movement**组件添加到其中。要做到这一点，从**放置**选项卡中将**空Actor**拖到级别中，然后在**详细信息**面板中单击**添加组件**，并选择**Random
    Movement**。再次执行相同的操作以添加**Cube**组件，以便您有东西来可视化actor的位置。![如何做...](img/00085.jpeg)![如何做...](img/00086.jpeg)
- en: Play your level, and observe the actor randomly moving around as its location
    changes every time the `TickComponent` function is called.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的关卡，并观察actor在每次调用`TickComponent`函数时随机移动的位置改变。
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Firstly, we add a few specifiers to the `UCLASS` macro used in our component''s
    declaration. Adding `BlueprintSpawnableComponent` to the class'' meta values means
    that instances of the component can be added to blueprint classes in the editor.
    The `ClassGroup` specifier allows us to indicate what category of class our Component
    belongs to in the list of classes:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在组件声明中使用的`UCLASS`宏中添加一些说明符。将`BlueprintSpawnableComponent`添加到类的元值中意味着可以在编辑器中将组件的实例添加到蓝图类中。`ClassGroup`说明符允许我们指示组件在类列表中属于哪个类别：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Adding `MovementRadius` as a property to the new component allows us to specify
    how far the component will be allowed to wander in a single frame:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MovementRadius`作为新组件的属性添加，允许我们指定组件在单个帧中允许漫游的距离：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the constructor, we initialize this property to a safe default value:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将此属性初始化为安全的默认值：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`TickComponent` is a function that is called every frame by the engine, just
    like `Tick` is for Actors. In its implementation, we retrieve the current location
    of the component''s owner, that is, the `Actor` that contains our component, and
    we generate an offset in the world space:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TickComponent`是引擎每帧调用的函数，就像`Tick`对于Actors一样。在其实现中，我们检索组件所有者的当前位置，即包含我们组件的`Actor`，并在世界空间中生成一个偏移量：'
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We add the random offset to the current location to determine a new location,
    and move the owning actor to it. This causes the actor's location to randomly
    change from frame to frame and dance about.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将随机偏移添加到当前位置以确定新位置，并将拥有的actor移动到该位置。这会导致actor的位置在每一帧随机改变并且跳动。
- en: Creating a custom Scene Component
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义Scene Component
- en: '`Scene` Components are a subclass of `Actor` Components that have a transform,
    that is, a relative location, rotation, and scale. Just like `Actor` Components,
    `Scene` Components aren''t rendered themselves, but can use their transform for
    various things, such as spawning other objects at a fixed offset from an `Actor`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`组件是`Actor`组件的子类，具有变换，即相对位置、旋转和缩放。就像`Actor`组件一样，`Scene`组件本身不会被渲染，但可以使用它们的变换进行各种操作，比如在`Actor`的固定偏移处生成其他对象。'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a custom `SceneComponent` called `ActorSpawnerComponent`. Make the following
    changes to the header:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ActorSpawnerComponent`的自定义`SceneComponent`。对头文件进行以下更改：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following function implementation to the cpp file:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数实现添加到cpp文件中：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Verify your code against this snippet:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据此片段验证您的代码：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Compile and open your project. Drag an empty `Actor` into the scene and add
    your `ActorSpawnerComponent` to it. Select your new Component in the `Details`
    panel, and assign a value to `ActorToSpawn`. Now whenever `Spawn()` is called
    on an instance of your component, it will instantiate a copy of the `Actor` class
    specified in `ActorToSpawn`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并打开您的项目。将一个空的`Actor`拖到场景中，并将`ActorSpawnerComponent`添加到其中。在`详细信息`面板中选择您的新组件，并为`ActorToSpawn`分配一个值。现在，每当在组件的实例上调用`Spawn()`时，它将实例化`ActorToSpawn`中指定的`Actor`类的副本。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create the `Spawn UFUNCTION` and a variable called `ActorToSpawn`. The `ActorToSpawn`
    `UPROPERTY` is of type `TSubclassOf< >`, a template type that allows us to restrict
    a pointer to either a base class or subclasses thereof. This also means that within
    the editor, we will get a pre-filtered list of classes to pick from, preventing
    us from accidentally assigning an invalid value.![How it works...](img/00087.jpeg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建`Spawn UFUNCTION`和一个名为`ActorToSpawn`的变量。`ActorToSpawn`的`UPROPERTY`类型是`TSubclassOf<>`，这是一个模板类型，允许我们将指针限制为基类或其子类。这也意味着在编辑器中，我们将获得一个经过预过滤的类列表可供选择，防止我们意外分配无效值。![它是如何工作的...](img/00087.jpeg)
- en: Inside the `Spawn` function's implementation, we get access to our world, and
    check it for validity.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Spawn`函数的实现中，我们可以访问我们的世界，并检查其有效性。
- en: '`SpawnActor` wants an `FTransform*` to specify the location to spawn the new
    actor, so we create a new stack variable to contain a copy of the current component''s
    transform.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpawnActor`需要一个`FTransform*`来指定生成新Actor的位置，因此我们创建一个新的堆栈变量来包含当前组件变换的副本。'
- en: If `TheWorld` is valid, we request it to spawn an instance of the `ActorToSpawn`-specified
    subclass, passing in the address of the `FTransform` we just created, and which
    now contains the desired location for the new actor.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`TheWorld`有效，我们请求它生成一个`ActorToSpawn`指定的子类的实例，传入我们刚刚创建的`FTransform`的地址，其中现在包含了新`Actor`所需的位置。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* contains a much more detailed investigation into how you can make
    things Blueprint-accessible.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第8章，“集成C++和虚幻编辑器”，包含了对如何使蓝图可访问的更详细的调查。
- en: Creating a custom Primitive Component
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义基本组件
- en: '`Primitive` components are the most complex type of `Actor` Component because
    they not only have a transform, but are also rendered on screen.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Primitive`组件是最复杂的`Actor`组件类型，因为它们不仅有一个变换，而且还在屏幕上呈现。'
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a custom C++ class based on `MeshComponent`. When Visual Studio loads,
    add the following to your class header file:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`MeshComponent`创建一个自定义的C++类。当Visual Studio加载时，将以下内容添加到你的类头文件中：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need to create an implementation for our overridden `CreateSceneProxy` function
    in our cpp file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在cpp文件中为我们重写的`CreateSceneProxy`函数创建一个实现：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This function returns an instance of `FMySceneProxy`, which we need to implement.
    Do so by adding the following code above the `CreateSceneProxy` function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数返回一个`FMySceneProxy`的实例，我们需要实现它。通过在`CreateSceneProxy`函数上方添加以下代码来实现：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our scene proxy requires a vertex buffer and an index buffer. The following
    subclasses should be placed above the Scene Proxy''s implementation:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的场景代理需要一个顶点缓冲区和一个索引缓冲区。以下子类应该放在场景代理的实现之上：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following constructor implementation:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下构造函数实现：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Verify that your code looks like the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证你的代码是否如下所示：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Create an empty `Actor` in the editor and add the new mesh component to it to
    see that your triangle is rendered. Experiment by changing the values added with
    Vertices. Add and see how the geometry changes after a recompile.![How to do it...](img/00088.jpeg)
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个空的`Actor`，并将新的网格组件添加到其中，以查看你的三角形是否被渲染。尝试通过更改添加到顶点的值来进行实验。添加并查看在重新编译后几何图形如何改变。![操作步骤](img/00088.jpeg)
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order for an `Actor` to be rendered, the data describing it needs to be made
    accessible to the rendering thread.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了渲染一个`Actor`，描述它的数据需要被传递给渲染线程。
- en: The easiest way to do this is with a Scene Proxy—a proxy object that is created
    on the render thread, and is designed to provide thread safety to the data transfer.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的方法是使用场景代理-在渲染线程上创建的代理对象，旨在为数据传输提供线程安全性。
- en: The `PrimitiveComponent` class defines a `CreateSceneProxy` function that returns
    `FPrimitiveSceneProxy*`. This function allows custom components like ours to return
    an object based on `FPrimitiveSceneProxy`, leveraging polymorphism.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrimitiveComponent`类定义了一个`CreateSceneProxy`函数，返回`FPrimitiveSceneProxy*`。这个函数允许像我们这样的自定义组件返回一个基于`FPrimitiveSceneProxy`的对象，利用多态性。'
- en: We define the constructor of the `SceneProxy` object to take in an instance
    of our component so that each `SceneProxy` created knows about the component instance
    it is associated with.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`SceneProxy`对象的构造函数，以便每个创建的`SceneProxy`都知道与其关联的组件实例。
- en: That data is then cached in the Scene Proxy, and passed to the renderer using
    `GetDynamicMeshElements`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后这些数据被缓存在场景代理中，并使用`GetDynamicMeshElements`传递给渲染器。
- en: We create an `IndexBuffer` and a `VertexBuffer`. Each of the buffer classes
    we create are helpers that assist the Scene Proxy with allocating platform-specific
    memory for the two buffers. They do so in the `InitRHI` (also known as Initialize
    Render Hardware Interface) function, wherein they use functions from the RHI API
    to create a vertex buffer, lock it, copy the required data, and then unlock it.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`IndexBuffer`和一个`VertexBuffer`。我们创建的每个缓冲区类都是辅助类，帮助场景代理为这两个缓冲区分配特定于平台的内存。它们在`InitRHI`（也称为初始化渲染硬件接口）函数中这样做，在这个函数中，它们使用RHI
    API的函数来创建一个顶点缓冲区，锁定它，复制所需的数据，然后解锁它。
- en: Inside the component's constructor, we look for a material asset that is built
    into the engine with the `ObjectFinder` template so that our mesh will have a
    material.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的构造函数中，我们使用`ObjectFinder`模板查找内置在引擎中的材质资源，以便我们的网格有一个材质。
- en: We then add some vertices and indexes to our buffers so that the mesh can be
    drawn when the renderer requests a Scene Proxy.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们向我们的缓冲区添加一些顶点和索引，以便在渲染器请求场景代理时可以绘制网格。
- en: Creating an InventoryComponent for an RPG
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为RPG创建一个InventoryComponent
- en: An `InventoryComponent` enables its containing `Actor` to store `InventoryActors`
    in its inventory, and place them back into the game world.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`InventoryComponent`使其包含的`Actor`能够在其库存中存储`InventoryActors`，并将它们放回游戏世界中。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you've followed the *Axis Mappings – keyboard, mouse and gamepad directional
    input for an FPS character* recipe in [Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* before continuing with
    this recipe, as it shows you how to create a simple character.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本教程之前，请确保你已经按照第6章，“输入和碰撞”，中的*轴映射-键盘、鼠标和游戏手柄方向输入用于FPS角色*教程中的步骤进行操作，因为它向你展示了如何创建一个简单的角色。
- en: Also, the recipe *Instantiating an Actor using SpawnActor* in this chapter shows
    you how to create a custom `GameMode`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中的*使用SpawnActor实例化Actor*教程向你展示了如何创建一个自定义的`GameMode`。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create an `ActorComponent` subclass using the engine called `InventoryComponent`,
    then add the following code to it:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引擎创建一个`ActorComponent`子类，名为`InventoryComponent`，然后将以下代码添加到其中：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following function implementation to the source file:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数实现添加到源文件中：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, create a new `StaticMeshActor` subclass called `InventoryActor`. Add
    the following to its declaration:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`InventoryActor`的新`StaticMeshActor`子类。将以下内容添加到其声明中：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the new functions in the implementation file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中实现新函数：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, change the constructor to look like the following:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要更改构造函数如下：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need to add an `InventoryComponent` to our character so that we have an
    inventory that we can store items in. Create a new `SimpleCharacter` subclass
    using the editor, and add the following to its declaration:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向角色添加`InventoryComponent`，以便我们有一个可以存储物品的库存。使用编辑器创建一个新的`SimpleCharacter`子类，并将以下内容添加到其声明中：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add this line to the character''s constructor implementation:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此行添加到角色的构造函数实现中：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add this code to the overriden `SetupPlayerInputComponent`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到重写的`SetupPlayerInputComponent`中：
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, add the following function implementations:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下函数实现：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Compile your code and test it in the Editor. Create a new level and drag a few
    instances of `InventoryActor` out into your scene.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码并在编辑器中进行测试。创建一个新级别，并将几个`InventoryActor`实例拖到场景中。
- en: 'Refer to the *Instantiating an Actor using SpawnActor* recipe if you need a
    reminder of how to override the current game mode. Add the following line to the
    constructor of your Game Mode from that recipe, then set your level''s `GameMode`
    to the one you created in that recipe:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要提醒如何重写当前游戏模式，请参考*使用SpawnActor实例化Actor*配方。将以下行添加到该配方中的游戏模式构造函数中，然后将您的级别的`GameMode`设置为您在该配方中创建的游戏模式：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Verify your code against the listing here before compiling and launching your
    project.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译和启动项目之前，请对照此处的清单验证您的代码。
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Lastly, we need to add our `InputAction` to the bindings in the editor. To do
    this, bring up the **Project Settings...** window by selecting **Edit** | **Project
    Settings...**:![How to do it...](img/00089.jpeg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在编辑器中的绑定中添加我们的`InputAction`。为此，通过选择**Edit** | **Project Settings...**来打开**Project
    Settings...**窗口：![如何做...](img/00089.jpeg)
- en: 'Then, select **Input** on the left-hand side. Select the plus symbol beside
    **Action Mappings**, and type `DropItem` into the text box that appears. Underneath
    it is a list of all the potential keys you can bind to this action. Select the
    one labelled `E`. Your settings should now look like the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在左侧选择**Input**。选择**Action Mappings**旁边的加号符号，并在出现的文本框中键入`DropItem`。在其下是您可以绑定到此操作的所有潜在按键的列表。选择标记为`E`的按键。您的设置现在应如下所示：
- en: '![How to do it...](img/00090.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00090.jpeg)'
- en: Then we can hit play, walk over to our inventory actor, and it will be picked
    up. Press *E* to place the actor in a new location! Test this with multiple inventory
    actors to see that they all get collected and placed correctly.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以点击播放，走到我们的库存角色旁边，它将被拾起。按*E*键将角色放置在新位置！通过多个库存角色测试，看它们是否都被正确收集和放置。
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our new component contains an array of actors, storing them by pointer as well
    as declaring functions that add or remove items to the array. These functions
    are simple wrappers around the `TArray` add/remove functionality, but allow us
    to optionally do things such as checking if the array is within a specified size
    limit before going ahead with storing the item.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新组件包含一个存储指针的角色数组，以及声明添加或移除项目到数组的函数。这些函数是围绕`TArray`的添加/移除功能的简单包装器，但允许我们选择性地执行诸如在继续存储项目之前检查数组是否在指定大小限制内等操作。
- en: '`InventoryActor` is a base class that can be used for all items that can be
    taken by a player.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InventoryActor`是一个基类，可用于玩家拿走的所有物品。'
- en: 'In the `PickUp` function, we need to disable the actor when it is picked up.
    To do that, we have to do the following:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickUp`函数中，我们需要在拾起时禁用角色。为此，我们必须执行以下操作：
- en: Disable actor ticking
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用角色打勾
- en: Hide the actor
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏角色
- en: Disable collision
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用碰撞
- en: We do this with the functions `SetActorTickEnabled`, `SetActorHiddenInGame`,
    and `SetActorEnableCollision`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`SetActorTickEnabled`、`SetActorHiddenInGame`和`SetActorEnableCollision`函数来实现这一点。
- en: The `PutDown` function is the reverse. We enable actor ticking, unhide the actor,
    and then turn its collision back on, and we transport the actor to the desired
    location.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PutDown`函数是相反的。我们启用角色打勾，取消隐藏角色，然后重新打开其碰撞，并将角色传送到所需位置。'
- en: We add an `InventoryComponent` to our new character as well as a function to
    take items.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在新角色中添加了`InventoryComponent`以及一个用于获取物品的函数。
- en: In the constructor for our character, we create a default subobject for our
    `InventoryComponent`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们角色的构造函数中，我们为我们的`InventoryComponent`创建了一个默认子对象。
- en: We also add a `NotifyHit` override so that we are notified when the character
    hits other Actors.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个`NotifyHit`覆盖，以便在角色撞到其他角色时得到通知。
- en: Inside this function, we cast the other actor to an `InventoryActor`. If the
    cast is successful, then we know our `Actor` was an `InventoryActor`, and so we
    can call the `TakeItem` function to take it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此函数中，我们将其他角色转换为`InventoryActor`。如果转换成功，那么我们知道我们的`Actor`是一个`InventoryActor`，因此我们可以调用`TakeItem`函数来拿起它。
- en: In the `TakeItem` function, we notify the Inventory item actor that we want
    to pick it up, then we add it to our inventory.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TakeItem`函数中，我们通知库存物品角色我们要拿起它，然后将其添加到我们的库存中。
- en: The last piece of functionality in the `InventoryCharacter` is the `DropItem`
    function. This function checks if we have any items in our inventory. If it has
    any items, we remove it from our inventory, then we calculate a safe distance
    in front of our player character to drop the item using the Item Bounds to get
    its maximum bounding box dimension.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InventoryCharacter`中的最后一个功能是`DropItem`函数。此函数检查我们的库存中是否有任何物品。如果有任何物品，我们将其从库存中移除，然后使用物品边界计算我们的玩家角色前方的安全距离，以便放下物品。'
- en: We then inform the item that we are placing it in the world at the desired location.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通知物品我们正在将其放置在所需位置的世界中。
- en: See also
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    has a detailed explanation of how events and input handling work together within
    the Engine, as well as a recipe for the `SimpleCharacter` class mentioned in this
    recipe'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121 "第5章。处理事件和委托"),
    *处理事件和委托*，详细解释了事件和输入处理在引擎中如何一起工作，以及本教程中提到的`SimpleCharacter`类的用法。'
- en: '[Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* also has recipes concerning
    the binding of input actions and axes'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121 "第6章。输入和碰撞"),
    *输入和碰撞*，还有关于绑定输入动作和轴的教程'
- en: Creating an OrbitingMovement Component
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个OrbitingMovement组件
- en: This component is similar to `RotatingMovementComponent` in that it is designed
    to make the components parented to it move in a particular way. In this instance,
    it will move any attached components in an orbit around a fixed point at a fixed
    distance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件类似于`RotatingMovementComponent`，它旨在使附加到它的组件以特定方式移动。在这种情况下，它将以固定距离围绕固定点移动任何附加的组件。
- en: This could be used, for example, for a shield that orbits around a character
    in an **Action RPG**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这可以用于**动作RPG**中围绕角色旋转的护盾。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new `SceneComponent` subclass and add the following properties to
    the class declaration:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`SceneComponent`子类，并将以下属性添加到类声明中：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the following to the constructor:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到构造函数中：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add the following code to the `TickComponent` function:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TickComponent`函数中：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Verify your work against the following listing:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下清单验证你的工作：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can test this component by creating a simple `Actor` Blueprint.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过创建一个简单的`Actor`蓝图来测试这个组件。
- en: Add an `OrbitingMovement` Component to your `Actor`, then add a few meshes using
    the `Cube` component. Parent them to the `OrbitingMovement` component by dragging
    them on to it in the **Components** panel. The resulting hierarchy should look
    like the following:![How to do it...](img/00091.jpeg)
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`OrbitingMovement`组件添加到你的`Actor`中，然后使用`Cube`组件添加一些网格。通过将它们拖放到**Components**面板中的`OrbitingMovement`组件上，将它们作为子组件。最终的层次结构应该如下所示：![How
    to do it...](img/00091.jpeg)
- en: Refer to the *Creating a custom Actor Component* recipe if you're unsure of
    the process.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你对这个过程不确定，可以参考*创建自定义Actor组件*教程。
- en: Hit play to see the meshes moving around in a circular pattern around the center
    of the `Actor`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放，看看网格是否围绕`Actor`中心以圆周运动。
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The properties that are added to the component are the basic parameters that
    we use to customize the circular motion of the component.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到组件的属性是我们用来自定义组件的圆周运动的基本参数。
- en: '`RotateToFaceOutwards` specifies whether the component will orient to face
    away from the center of rotation on every update. `RotationSpeed` is the number
    of degrees the component rotates every second.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RotateToFaceOutwards`指定组件是否在每次更新时朝向远离旋转中心。`RotationSpeed`是组件每秒旋转的度数。'
- en: '`OrbitDistance` indicates the distance that the components that rotate must
    be moved from the origin. `CurrentValue` is the current rotation position in degrees.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrbitDistance`表示旋转的组件必须从原点移动的距离。`CurrentValue`是当前的旋转位置（以度为单位）。'
- en: Inside our constructor, we establish some sane defaults for our new component.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们为我们的新组件建立了一些合理的默认值。
- en: In the `TickComponent` function, we calculate the location and rotation of our
    component.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TickComponent`函数中，我们计算我们组件的位置和旋转。
- en: The formula in the next step requires our angles to be expressed in radians
    rather than degrees. Radians describe an angle in terms of *π*. We first use the
    `DegreesToRadians` function to convert our current value in degrees to radians.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步的公式要求我们的角度用弧度而不是度来表示。弧度用 *π* 来描述角度。我们首先使用`DegreesToRadians`函数将我们当前的度数值转换为弧度。
- en: The `SetRelativeLocation` function uses the general equation for circular motion,
    that is—*Pos(θ) = cos(θ in radians), sin(θ in radians)*. We preserve the Z axis
    position of each object.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetRelativeLocation`函数使用了圆周运动的一般方程，即 *Pos(θ) = cos(θ in radians), sin(θ in
    radians)*。我们保留每个对象的Z轴位置。'
- en: The next step is to rotate the object back towards the origin (or else, directly
    away from it). This is only calculated if `RotateToFaceOutwards` is `true`, and
    involves getting the relative offset of the component to its parent, and creating
    a rotator based on a vector pointing from the parent to the current relative offset.
    We then set the relative rotation to the resulting rotator.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将对象旋转回原点（或者直接远离原点）。只有当`RotateToFaceOutwards`为`true`时才会计算这一步，它涉及到获取组件相对于其父级的相对偏移，并创建一个基于从父级指向当前相对偏移的向量的旋转器。然后我们将相对旋转设置为结果旋转器。
- en: Lastly, we increment the current value in degrees so that it moves `RotationSpeed`
    units per second, clamping the resulting value between 0 and 360 to allow the
    rotation to loop.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们增加当前的度数值，使其每秒移动`RotationSpeed`单位，将结果值夹在0和360之间，以允许旋转循环。
- en: Creating a building that spawns units
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成单位的建筑
- en: For this recipe, we will create a building that spawns units at a fixed time
    interval at a particular location.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将创建一个在特定位置定时生成单位的建筑。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new `Actor` subclass in the editor, as always, and then add the following
    implementation to the class:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个新的`Actor`子类，然后将以下实现添加到类中：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add the following to the constructor:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到构造函数中：
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the following to the `BeginPlay` function:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`BeginPlay`函数中：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create the implementation for the `SpawnUnit` function:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SpawnUnit`函数创建实现：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Implement the overridden `EndPlay` function:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写的`EndPlay`函数：
- en: '[PRE65]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, create a new character subclass, and add one property:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的角色子类，并添加一个属性：
- en: '[PRE66]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Initialize the component in the constructor implementation:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化组件：
- en: '[PRE67]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Attach the visual representation to the root component:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将可视化表示附加到根组件：
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Lastly, add the following to the `Tick` function to get the spawned actor moving:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下内容添加到 `Tick` 函数中以使生成的角色移动：
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Verify against the following snippet, then compile your project. Place a copy
    of the barracks actor into the level. You can then observe it spawning the character
    at fixed intervals:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下片段进行验证，然后编译您的项目。将兵营角色的副本放入级别中。然后您可以观察它以固定间隔生成角色：
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, we create the barracks actor. We add a particle system component to
    indicate where the new units will be spawning, and a static mesh for the visual
    representation of the building.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建兵营角色。我们添加一个粒子系统组件来指示新单位将生成的位置，以及一个静态网格用于建筑的可视表示。
- en: In the constructor, we initialize the components, and then set their values
    using `FObjectFinder`. We also set the class to spawn using the `StaticClass`
    function to retrieve a `UClass*` instance from a class type.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化组件，然后使用 `FObjectFinder` 设置它们的值。我们还使用 `StaticClass` 函数设置要生成的类，以从类类型中检索
    `UClass*` 实例。
- en: In the `BeginPlay` function of the barracks, we create a timer that calls our
    `SpawnUnit` function at fixed intervals. We store the timer handle in a member
    variable in the class so that when our instance is being destroyed, we can halt
    the timer; otherwise, when the timer triggers again, we'll encounter a crash where
    the object pointer is dereferenced.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在兵营的 `BeginPlay` 函数中，我们创建一个定时器，以固定间隔调用我们的 `SpawnUnit` 函数。我们将定时器句柄存储在类的成员变量中，这样当我们的实例被销毁时，我们可以停止定时器；否则，当定时器再次触发时，我们将遇到对象指针被取消引用的崩溃。
- en: The `SpawnUnit` function gets the world space location of the `SpawnPoint` object,
    then asks the world to spawn an instance of our unit class at that location.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpawnUnit` 函数获取了 `SpawnPoint` 对象的世界空间位置，然后请求世界在该位置生成一个我们单位类的实例。'
- en: '`BarracksUnit` has code in its `Tick()` function to move forward by 10 units
    every frame so that each spawned unit will move to make room for the next one.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BarracksUnit` 在其 `Tick()` 函数中有代码，每帧向前移动 10 个单位，以便每个生成的单位都会移动以为下一个单位腾出空间。'
- en: The `EndPlay` function override calls the parent class implementation of the
    function, which is important if there are timers to cancel or deinitialization
    performed in the parent class. It then uses the timer handle stored in `BeginPlay`
    in order to cancel the timer.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EndPlay` 函数重写调用父类函数的实现，如果父类中有要取消的定时器或要执行的去初始化操作，这一点很重要。然后使用存储在 `BeginPlay`
    中的定时器句柄来取消定时器。'
