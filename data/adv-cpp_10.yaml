- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: About
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在帮助学生执行本书中的活动。它包括详细的步骤，学生需要执行这些步骤以实现活动的目标。
- en: Chapter 1 - Anatomy of Portable C++ Software
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章 - 可移植C++软件的解剖
- en: 'Activity 1: Adding a New Source-Header File Pair to the Project'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：向项目添加新的源文件-头文件对
- en: 'In this activity, we will create a new source-header file pair that contains
    a new function named `sum`. It takes two parameters and returns their sum. This
    file pair will be added to the existing project. Follow these steps to implement
    this activity:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个包含名为`sum`的新函数的新源文件-头文件对。它接受两个参数并返回它们的和。这个文件对将被添加到现有项目中。按照以下步骤来实现这个活动：
- en: First, open the Eclipse IDE with the existing project that we created in *Exercise
    3*, *Adding New Source Files to CMake and Eclipse CDT*. Right-click on the `.cpp`
    and `.h` files separately or use the new class wizard and later remove the class
    code. Using the new class wizard is handy since it also creates useful boilerplate
    code.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开Eclipse IDE，并打开我们在*练习3*中创建的现有项目，*向CMake和Eclipse CDT添加新源文件*。分别右键单击`.cpp`和`.h`文件，或使用新类向导，然后删除类代码。使用新类向导很方便，因为它还会创建有用的样板代码。
- en: Select `SumFunc` and click on the **Finish** button.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`SumFunc`，然后点击**完成**按钮。
- en: 'Next, edit the `SumFunc.h` file to look like the following code:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑`SumFunc.h`文件，使其看起来像以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we will actually delete the class and provide a single function instead.
    We could have created these two files separately. However, the `add class` function
    creates them both and adds some boilerplate code that we will make use of. Here,
    our file starts and ends with an `include` guard, which is a common strategy to
    prevent the double-inclusion problem. We have the forward declaration of our function,
    which lets other files call the function after including this header file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们实际上将删除类并提供一个单一函数。我们本可以分别创建这两个文件。但是，`add class`函数会同时创建它们并添加一些我们将利用的样板代码。在这里，我们的文件以`include`保护开始和结束，这是一种常见的策略，用于防止双重包含问题。我们有我们函数的前向声明，这样其他文件在包含这个头文件后就可以调用这个函数。
- en: 'Next, edit the `SumFunc.cpp` file as illustrated here:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑`SumFunc.cpp`文件，如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this file, we include header files and provide the body of our function,
    which adds and returns two given integers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们包括头文件并提供我们函数的主体，它会添加并返回给定的两个整数。
- en: 'Edit the `CMakeFiles.txt` file so that its `add_executable` section reflects
    the following code:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`CMakeFiles.txt`文件，使其`add_executable`部分反映以下代码：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we added the `src/SumFunc.cpp` file to the list of executable source files
    so that it is linked into the executable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`src/SumFunc.cpp`文件添加到可执行源文件列表中，以便将其链接到可执行文件中。
- en: 'Make the following changes in `CxxTemplate.cpp`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CxxTemplate.cpp`中进行以下更改：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete code of this file can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Activity01/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Activity01/src/CxxTemplate.cpp).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的完整代码可以在这里找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Activity01/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Activity01/src/CxxTemplate.cpp)。
- en: Here, we added a line in which we call the `sum` function with `3` and `4` and
    print the result to the console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一行，其中我们调用`sum`函数，传入`3`和`4`，并将结果打印到控制台。
- en: 'Build and run the project (**Project** | **Build All** | **Run** | **Run**).
    The output you see should be as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和运行项目（**项目** | **构建全部** | **运行** | **运行**）。您看到的输出应该如下所示：
- en: '![Figure 1.57: The output'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.57：输出'
- en: '](img/C14583_01_57.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_57.jpg)'
- en: 'Figure 1.57: The output'
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.57：输出
- en: With this activity, you practiced adding a new source-header file pair to your
    project. These file pairs are a very common pattern in C++ development. They can
    host global functions such as the ones we had in this activity. More commonly,
    they host classes and their definitions. Throughout your development effort, you
    will be adding many more source-header file pairs to your application. Therefore,
    it is important to get used to adding them and not dragging your feet, which would
    result in large monolithic files that are difficult to maintain and test.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动，您练习了向项目添加新的源文件-头文件对。这些文件对在C++开发中是非常常见的模式。它们可以承载全局函数，比如我们在这个活动中所做的那样。更常见的是，它们承载类及其定义。在开发过程中，您将向应用程序添加更多的源文件-头文件对。因此，习惯于添加它们并不拖延是很重要的，否则会导致难以维护和测试的大型单片文件。
- en: 'Activity 2: Adding a New Class and Its Test'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：添加新类及其测试
- en: 'In this activity, we will add a new class that simulates `1D` linear motion.
    The class will have double fields for `position` and `velocity`. It will also
    have a `advanceTimeBy()` method, which receives a double `dt` parameter, which
    modifies `position` based on the value of `velocity`. Use `EXPECT_DOUBLE_EQ` instead
    of `EXPECT_EQ` for double values. In this activity, we will add a new class and
    its test to the project. Follow these steps to perform this activity:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将添加一个模拟`1D`线性运动的新类。该类将具有`position`和`velocity`的双字段。它还将有一个`advanceTimeBy()`方法，该方法接收一个双`dt`参数，根据`velocity`的值修改`position`。对于双值，请使用`EXPECT_DOUBLE_EQ`而不是`EXPECT_EQ`。在这个活动中，我们将向项目添加一个新类及其测试。按照以下步骤执行这个活动：
- en: Open the Eclipse IDE with our existing project. To create a new class, right-click
    the `LinearMotion1D` as the name and create the class.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们现有的项目的Eclipse IDE。要创建一个新类，右键单击`LinearMotion1D`，然后创建类。
- en: 'Open the `LinearMotion1D.h` file that we created in the previous step. Add
    the `position` and `velocity` `double` fields into it. Also, add the forward reference
    to the `advanceTimeBy` method, which takes a `double dt` variable as a parameter.
    The constructors and destructors were already in the class. The following is the
    end result of these changes in `LinearMotion1D.h`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在上一步中创建的`LinearMotion1D.h`文件。将`position`和`velocity`的`double`字段添加到其中。还要添加对`advanceTimeBy`方法的前向引用，该方法以`double
    dt`变量作为参数。构造函数和析构函数已经在类中。以下是在`LinearMotion1D.h`中进行这些更改的最终结果：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now open `LinearMotion1D.cpp` and add the implementation for the `advanceTimeBy`
    method. Our `velocity` is a field in our class and the time difference is a parameter
    to this method. A change in `position` is equal to the `velocity` multiplied by
    the time change, so we calculate the result and add it to the `position` variable.
    We also use the existing constructor code to initialize `position` and `velocity`
    to 0\. The following is the end result of these changes in `LinearMotion1D.cpp`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`LinearMotion1D.cpp`，并为`advanceTimeBy`方法添加实现。我们的`velocity`是类中的一个字段，时间差是这个方法的一个参数。位置的变化等于速度乘以时间变化，所以我们计算结果并将其添加到位置变量中。我们还使用现有的构造函数代码将`position`和`velocity`初始化为0。以下是在`LinearMotion1D.cpp`中进行这些更改的最终结果：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create a test for this class. Right-click the `LinearMotion1DTest.cpp` as the
    name and create it.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个类创建一个测试。右键单击`LinearMotion1DTest.cpp`，并创建它。
- en: 'Now open `LinearMotion1DTest.cpp`. Create two tests for motions in two different
    directions, left and right. For each of them, create a `LinearMotion1D` object,
    initialize its position and velocity, and call `advanceTimeBy` to actually have
    the motion happen. Then, check whether it moved to the same location that we expected.
    The following is the end result of these changes in `LinearMotion1DTest.cpp`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`LinearMotion1DTest.cpp`。为两个不同方向的运动创建两个测试，左和右。对于每一个，创建一个`LinearMotion1D`对象，初始化其位置和速度，并调用`advanceTimeBy`来实际进行运动。然后，检查它是否移动到我们期望的相同位置。以下是在`LinearMotion1DTest.cpp`中进行这些更改的最终结果：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now modify our CMake configuration files so that these source files that we
    generated are also used. For the `LinearMotion1D` class, add its `.cpp` file as
    an executable so that it is compiled and linked together with the other source
    files. Here is what the `add_executable` section of `CMakeLists.txt` becomes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在修改我们的CMake配置文件，以便这些生成的源文件也被使用。对于`LinearMotion1D`类，将其`.cpp`文件添加为可执行文件，以便它与其他源文件一起编译和链接。以下是`CMakeLists.txt`中`add_executable`部分的变化：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the tests that we just created, edit `LinearMotion1DTest.cpp`, and the
    source file of the class that it uses, `LinearMotion1D.cpp`. Since they are in
    different directories, access them as `../src/LinearMotion1D.cpp`. Here is what
    the `add_executable` section of `tests/CMakeLists.txt` becomes:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们刚刚创建的测试，编辑`LinearMotion1DTest.cpp`，以及它使用的类的源文件`LinearMotion1D.cpp`。由于它们位于不同的目录中，以`../src/LinearMotion1D.cpp`的方式访问它们。以下是`tests/CMakeLists.txt`中`add_executable`部分的变化：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build the project and run the tests. We will see that all the tests are successful:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行测试。我们将看到所有测试都成功：
- en: '![Figure 1.58: All tests are successful'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.58：所有测试都成功'
- en: '](img/C14583_01_58.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_58.jpg)'
- en: 'Figure 1.58: All tests are successful'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.58：所有测试都成功
- en: With this activity, you performed the task of adding a new class and its test
    to the project. You created a class that simulates one-dimensional motion and
    you wrote unit tests to ensure that it is working properly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动，您完成了向项目添加新类及其测试的任务。您创建了一个模拟一维运动的类，并编写了单元测试以确保其正常工作。
- en: 'Activity 3: Making Code More Readable'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：使代码更易读
- en: 'In this activity, you will practice improving the quality of a given code.
    Follow these steps to implement this activity:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将练习提高给定代码的质量。按照以下步骤执行此活动：
- en: Open Eclipse CDT and create a class in a source-header file pair in Eclipse.
    To do this, right-click the **src** folder in **Project Explorer**. Select **New**
    | **Class** from the pop-up menu.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse CDT，并在Eclipse中的源文件-头文件对中创建一个类。要做到这一点，请在**项目资源管理器**中右键单击**src**文件夹。从弹出菜单中选择**新建**
    | **类**。
- en: 'Type `SpeedCalculator` as the header filename and click **Finish**. It will
    create two files: **SpeedCalculator.h** and **SpeedCalculator.cpp**. We provided
    the code for both files above. Add the code that was provided for each file.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SpeedCalculator`作为头文件名，并单击**完成**。它将创建两个文件：**SpeedCalculator.h**和**SpeedCalculator.cpp**。我们提供了上述两个文件的代码。添加为每个文件提供的代码。
- en: 'Now we need to add the class to the CMake project. Open the **CMakeLists.txt**
    file in the root of your project (outside the **src** folder) and make the following
    change in the file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将这个类添加到CMake项目中。打开项目根目录（**src**文件夹之外）中的**CMakeLists.txt**文件，并对文件进行以下更改：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now select **File** | **Save All** to save all the files and build the project
    by selecting **Project** | **Build All**. Make sure there are no errors.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择**文件** | **全部保存**以保存所有文件，并通过选择**项目** | **全部构建**来构建项目。确保没有错误。
- en: 'Create an instance of the `SpeedCalculator` class in our `main()` function
    and call its `run()` method. Open `main` function by adding the following code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中创建`SpeedCalculator`类的实例，并调用其`run()`方法。通过添加以下代码打开`main`函数：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To fix the style, simply use **Source** | **Format** and choose to format the
    entire file. Luckily, the variable names do not have any problems.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修复样式，只需使用**源代码** | **格式化**，并选择格式化整个文件。幸运的是，变量名没有任何问题。
- en: 'Simplify the code to make it more understandable. The loop in `calculateAndPrintSpeedData`
    is doing a couple of things at the same time. It''s calculating the speed, finding
    the minimum and maximum values of it, checking whether we crossed a threshold,
    and storing the speed. If the speed was a transient value, taking it apart would
    mean storing it somewhere to loop on it one more time. However, since we are storing
    it in the speeds array anyway, we can loop one more time on it for clarity of
    code. Here is the updated version of the loop:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化代码以使其更易理解。`calculateAndPrintSpeedData`中的循环同时执行了几件事。它计算速度，找到了最小和最大值，检查我们是否越过了阈值，并存储了速度。如果速度是一个瞬态值，将其拆分意味着将其存储在某个地方以再次循环。但是，由于我们无论如何都将其存储在速度数组中，我们可以在其上再循环一次以提高代码的清晰度。以下是循环的更新版本：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is somewhat a matter of taste, but making the big `for` loop lighter helps
    with the readability. In addition, it separates the tasks and removes the possibility
    of them interacting with each other during a loop iteration. The first loop creates
    and saves the speed values. The second loop finds the minimum and maximum speed
    values. The third loop determines how long the speed limit was crossed for. Note
    that this is a slightly less efficient implementation; however, it clearly separates
    the actions taken and we do not have to mentally separate the discrete actions
    in the long iteration of a loop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上是品味的问题，但是使大`for`循环更轻松有助于提高可读性。此外，它分离了任务并消除了它们在循环迭代期间相互影响的可能性。第一个循环创建并保存速度值。第二个循环找到最小和最大速度值。第三个循环确定超速限的时间。请注意，这是一个稍微不那么高效的实现；但是，它清楚地分离了采取的行动，我们不必在循环的长迭代中精神分离离散的行动。
- en: 'Run the preceding code and observe the problem at runtime. While the code is
    better in terms of style now, it suffers from several mistakes, some of which
    will create runtime errors. First, when we run the application, we see the following
    output in Eclipse:![Figure 1.59: Program output in Eclipse CDT'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前述代码并观察运行时的问题。虽然代码现在在风格上更好，但它存在几个错误，其中一些将创建运行时错误。首先，当我们运行应用程序时，在Eclipse中看到以下输出：![图1.59：Eclipse
    CDT中的程序输出
- en: '](img/C14583_01_59.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_59.jpg)'
- en: 'Figure 1.59: Program output in Eclipse CDT'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.59：Eclipse CDT中的程序输出
- en: Note `0`, it means there was a problem with our code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`0`，这意味着我们的代码出了问题。
- en: 'Execute the program manually in the console. Here''s the output we get:![Figure
    1.60: Program output in the terminal with the error'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台手动执行程序。这是我们得到的输出：![图1.60：带有错误的终端程序输出
- en: '](img/C14583_01_60.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_60.jpg)'
- en: 'Figure 1.60: Program output in the terminal with the error'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.60：带有错误的终端程序输出
- en: Unfortunately, we do not get the segmentation fault error output in Eclipse,
    therefore you have to check the exit value in the Eclipse console view. To find
    the problem, we will use the debugger in the next step.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们在Eclipse中没有得到分段错误输出，因此您必须在Eclipse控制台视图中检查退出值。为了找到问题，我们将在下一步中使用调试器。
- en: 'Press the debug toolbar button in Eclipse to start the application in debug
    mode. Press the resume button to continue execution. It will stop at line 40 of
    `SpeedCalculator.cpp`, right when an error is about to happen. If you hover over
    `speeds`, you realize that it is an invalid memory reference:![Figure 1.61: Invalid
    memory reference'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中按下调试工具栏按钮以启动调试模式下的应用程序。按下继续按钮以继续执行。它将在`SpeedCalculator.cpp`的第40行停止，就在错误即将发生时。如果您将鼠标悬停在`speeds`上，您会意识到它是一个无效的内存引用：![图1.61：无效的内存引用
- en: '](img/C14583_01_61.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_61.jpg)'
- en: 'Figure 1.61: Invalid memory reference'
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.61：无效的内存引用
- en: 'Upon further examination, we realize that we never initialized the `speeds`
    pointer to anything. Allocate memory for it in our speed calculator function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过进一步检查，我们意识到我们从未将`speeds`指针初始化为任何值。在我们的速度计算器函数中为它分配内存：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run it again. We get the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行。我们得到以下输出：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that this was an assertion that the code had to make sure that the calculated
    `dt` was always larger than zero. This is something that we are sure of, and we
    would like it to help us catch errors during development. Assert statements are
    ignored in the production builds, so you can place them liberally in your code
    as safeguards to catch errors during development. Especially since C++ lacks many
    safety checks compared to higher-level languages, placing `assert` statements
    in potentially unsafe code helps catch errors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个断言，代码必须确保计算出的`dt`始终大于零。这是我们确信的事情，我们希望它在开发过程中帮助我们捕捉错误。断言语句在生产构建中被忽略，因此您可以在代码中自由地放置它们作为开发过程中捕捉错误的保障。特别是由于C++缺乏与高级语言相比的许多安全检查，将`assert`语句放置在潜在不安全的代码中有助于捕捉错误。
- en: 'Let''s investigate why our `dt` ended up not larger than zero. For this, we
    fire up the debugger again. It stops at this strange place:![Figure 1.62: Debugger
    stopped at a library without source code'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调查一下为什么我们的`dt`最终没有大于零。为此，我们再次启动调试器。它停在了一个奇怪的地方：![图1.62：调试器停在没有源代码的库
- en: '](img/C14583_01_62.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_62.jpg)'
- en: 'Figure 1.62: Debugger stopped at a library without source code'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.62：调试器停在没有源代码的库
- en: The actual error is raised deep inside a library. However, our own functions
    are still on the stack and we can investigate their state at that time. Click
    on `dt` becomes `i` is `timesInSeconds[10]`, which is the non-existent eleventh
    element of the array. Thinking further, we realize that we can only have 9 position-pair
    subtractions, thus 9 speeds, when we have 10 positions. This is a very common
    and hard-to-catch mistake as C++ does not enforce you to stay within the array.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际错误是在库的深处引发的。但是，我们自己的函数仍然在堆栈上，我们可以调查它们在那个时候的状态。单击`dt`变为`i`是`timesInSeconds[10]`，这是数组的不存在的第十一个元素。进一步思考，我们意识到当我们有10个位置时，我们只能有9个位置对的减法，因此有9个速度。这是一个非常常见且难以捕捉的错误，因为C++不强制您留在数组内。
- en: 'Rework our whole code for this problem:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新设计我们的整个代码以解决这个问题：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, our code seems to run without any errors as we can see in the following
    output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的代码似乎可以在没有任何错误的情况下运行，如下面的输出所示：
- en: '![Figure 1.65: Program output'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.65：程序输出'
- en: '](img/C14583_01_65.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_65.jpg)'
- en: 'Figure 1.65: Program output'
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.65：程序输出
- en: 'However, there is a curious point here: `0`, no matter how many times you run
    it. To investigate, let''s put a breakpoint at the following line:![Figure 1.66:
    Placing a breakpoint'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，这里有一个奇怪的地方：`0`，无论你运行多少次。为了调查，让我们在以下行放一个断点：![图1.66：设置断点
- en: '](img/C14583_01_66.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_66.jpg)'
- en: 'Figure 1.66: Placing a breakpoint'
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.66：设置断点
- en: 'When we debug our code, we see that it never stops here. This is obviously
    wrong. Upon further investigation, we realize that `minSpeed` is initially 0,
    and every other speed value is larger than that. We should initialize it to either
    something very large, or we need to get the very first element as the minimum
    value. Here, we choose the second approach:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调试代码时，我们看到它从未停在这里。这显然是错误的。经过进一步调查，我们意识到`minSpeed`最初是0，而且每个速度值都大于它。我们应该将其初始化为非常大的值，或者我们需要将第一个元素作为最小值。在这里，我们选择第二种方法：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While `maxSpeed` did not need this, it''s good to be consistent. Now when we
    run the code, we see that we do not get `0` as our minimum speed anymore:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`maxSpeed`不需要这样做，但保持一致是好的。现在当我们运行代码时，我们看到我们不再得到`0`作为我们的最小速度：
- en: '![Figure 1.67: Program output'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.67：程序输出'
- en: '](img/C14583_01_67.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_67.jpg)'
- en: 'Figure 1.67: Program output'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.67：程序输出
- en: 'Our code seems to be running fine. However, there is another mistake that we
    have made. When we debug our code, we see that our first elements are not zero:![Figure
    1.68: Values of variables'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码似乎运行正常。但是，我们又犯了另一个错误。当我们调试代码时，我们发现我们的第一个元素不是零：![图1.68：变量的值
- en: '](img/C14583_01_68.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_68.jpg)'
- en: 'Figure 1.68: Values of variables'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.68：变量的值
- en: 'The pointer dereferenced the first element in the array. We had initialized
    elements to zero here, but they do not seem to be zero. Here is the updated code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指针解引用了数组中的第一个元素。我们在这里将元素初始化为零，但它们似乎不是零。这是更新后的代码：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we investigate, we realize that we start the loop at zero and overwrite
    the first items. Furthermore, we try to access `positions[0 - 1]`, which is a
    mistake and another example of C++ not enforcing array boundaries. When we let
    the loop start from 1, all these problems are gone:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调查时，我们意识到我们从零开始循环并覆盖了第一个项目。此外，我们尝试访问`positions[0 - 1]`，这是一个错误，也是C++不强制执行数组边界的另一个例子。当我们让循环从1开始时，所有这些问题都消失了：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the output generated with the updated code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用更新后的代码生成的输出：
- en: '![Figure 1.69: Program output'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.69：程序输出'
- en: '](img/C14583_01_69.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_01_69.jpg)'
- en: 'Figure 1.69: Program output'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.69：程序输出
- en: Just by looking at this code, we cannot tell the difference. It's all random
    values that do not look very different than before. Such bugs are very hard to
    find and can cause random behavior, leaving us with hard-to-track errors. Things
    that you can do to avoid such errors include being extra careful when dereferencing
    pointers, especially in loops; separating code into functions and writing unit
    tests for them; and using `assert` statements liberally to enforce things that
    the compiler or the runtime does not.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过查看这段代码，我们无法看出区别。这些都是随机值，看起来与以前没有太大不同。这样的错误很难找到，并且可能导致随机行为，使我们难以跟踪错误。您可以避免此类错误的方法包括在解引用指针时特别小心，特别是在循环中；将代码分离为函数并为其编写单元测试；并且在强制执行编译器或运行时不支持的事物时大量使用`assert`语句。
- en: Chapter 2A - No Ducks Allowed – Types and Deduction
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2A章 - 不允许鸭子 - 类型和推断
- en: 'Activity 1: Graphics Processing'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：图形处理
- en: 'In this activity, we will implement two classes (`Point3d` and `Matrix3d`),
    along with the multiplication operators so that we can translate, scale, and rotate
    points. We will also implement some helper methods that create the necessary matrices
    for the transformations. Follow these steps to implement this activity:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现两个类（`Point3d`和`Matrix3d`），以及乘法运算符，以便我们可以转换、缩放和旋转点。我们还将实现一些帮助方法，用于创建所需的转换矩阵。按照以下步骤实现此活动：
- en: Load the prepared project from the `CMake Build (Portable)`. Build and configure
    the launcher and run the unit tests (which fail). Recommend that the name that's
    used for the test runner is `L2AA1graphicstests`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CMake Build（便携式）`中加载准备好的项目。构建和配置启动器并运行单元测试（失败）。建议用于测试运行程序的名称为`L2AA1graphicstests`。
- en: CMake Configuration
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CMake配置
- en: Follow *step 9* of *Exercise 1*, *Declaring Variables and Exploring Sizes*,
    to configure the project as a CMake project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照*练习1*的*步骤9*，*声明变量和探索大小*，将项目配置为CMake项目。
- en: Add a test for the `Point3d` class to verify that the default constructor creates
    an `origin point [0, 0, 0, 1]`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Point3d`类的测试，以验证默认构造函数创建一个`原点[0, 0, 0, 1]`。
- en: Open the **point3dTests.cpp** file and add the following line at the top.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**point3dTests.cpp**文件并在顶部添加以下行。
- en: 'Replace the failing existing test with the following test:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下测试替换失败的现有测试：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This test requires us to write an access operator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试要求我们编写一个访问操作符。
- en: 'Replace the current class definition in **point3d.hpp** file with the following
    code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换**point3d.hpp**文件中的当前类定义：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The test now builds and runs but fails.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试可以构建和运行，但是失败了。
- en: 'Add the declaration for the default constructor to the `Point3d` declaration:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Point3d`声明中添加默认构造函数的声明：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the implementation to the **point3d.cpp** file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现添加到**point3d.cpp**文件中：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The test now builds, runs, and passes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试可以构建、运行并通过。
- en: 'Add the next test:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个测试：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This test fails to compile. Therefore, we need to implement another constructor
    – the one that takes `std::initializer_list<>` as an argument.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试无法编译。因此，我们需要实现另一个构造函数 - 接受`std::initializer_list<>`作为参数的构造函数。
- en: 'Add the following include to the header file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下包含添加到头文件中：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following constructor declaration to the Point3d class in the header
    file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中的`Point3d`类中添加以下构造函数声明：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code to the implementation file. This code ignores error
    handling, which will be added in *Lesson 3*, *The Distance Between Can and Should
    – Objects, Pointers, and Inheritance*:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到实现文件中。这段代码忽略了错误处理，这将在*第3课*，*Can和Should之间的距离-对象、指针和继承*中添加：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The tests should now build, run, and pass.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试应该构建、运行并通过。
- en: 'Add the following test:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The tests should still build, run, and pass.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该仍然构建、运行并通过。
- en: 'It is now time to refactor the test cases by moving the verification loop into
    a templated function in the `Point3dTest` class. Add the following template inside
    this class:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候通过将验证循环移动到`Point3dTest`类中的模板函数来重构测试用例了。在这个类中添加以下模板：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This now means that the last test can be rewritten as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着最后一个测试现在可以重写如下：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is just as important to keep your tests readable in the same way as your
    production code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与生产代码一样，保持测试的可读性同样重要。
- en: 'Next, add support for the equality and inequality operators through the following
    tests:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过以下测试添加相等和不相等运算符的支持：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To implement these, add the following declarations/definition in the header
    file:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这些，添加以下声明/定义到头文件中：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, add the equality implementation in the .cpp file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在.cpp文件中添加相等性的实现：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we first added `Point3d`, we implemented a constant accessor. Add the
    following test, where we need a non-constant accessor so that we can assign it
    to the member:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们首次添加`Point3d`时，我们实现了一个常量访问器。添加以下测试，我们需要一个非常量访问器，以便我们可以将其分配给成员：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To get this test to build, add the following accessor to the header:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试能够构建，添加以下访问器到头文件中：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that it returns a reference. Thus, we can assign it to a member value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它返回一个引用。因此，我们可以将其分配给一个成员值。
- en: 'To finish off `Point3d`, add lines to the class declaration for the default
    copy constructor and copy assignment:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成`Point3d`，在类声明中添加默认复制构造函数和复制赋值：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, add the `Matrix3d` classes. First, create two empty files, `matrix3d.hpp`
    and `matrix3d.cpp`, in the top-level folder of the current project and then add
    an empty file in the tests folder called `matrix3dTests.cpp`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`Matrix3d`类。首先，在当前项目的顶层文件夹中创建两个空文件，`matrix3d.hpp`和`matrix3d.cpp`，然后在tests文件夹中添加一个名为`matrix3dTests.cpp`的空文件。
- en: 'Open the CmakeLists.txt file in the top folder and add **matrix3d.cpp** to
    the following line:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开顶层文件夹中的CmakeLists.txt文件，并将**matrix3d.cpp**添加到以下行：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open the `../matrix3d.cpp` to the definition of `SRC_FILES`, and add `TEST_FILES`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`../matrix3d.cpp`到`SRC_FILES`的定义，并添加`TEST_FILES`：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The existing `point3d` tests should still build, run, and pass if you made those
    changes correctly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地进行了这些更改，现有的`point3d`测试应该仍然能够构建、运行和通过。
- en: 'Add the following test plumbing to `matrix3dTests.cpp`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`matrix3dTests.cpp`中添加以下测试管道：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Build and run the tests. The test that we just added should fail.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行测试。我们刚刚添加的测试应该失败。
- en: Replace DummyTest with the following test in `Matrix3d` class. We will do this
    now in **matrix3d.hpp**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Matrix3d`类中用以下测试替换DummyTest。我们现在将在**matrix3d.hpp**中进行此操作。
- en: 'Add the following definition to **matrix3d.hpp**:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**matrix3d.hpp**中添加以下定义：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The tests will now build but still fail because we haven't created a default
    constructor that creates an identity matrix.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试将构建，但仍然失败，因为我们还没有创建一个创建单位矩阵的默认构造函数。
- en: 'Add the declaration of the default constructor to the header file in the public
    section of `Matrix3d`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Matrix3d`的公共部分的头文件中添加默认构造函数的声明：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add this definition to **matrix3d.cpp**:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此定义添加到**matrix3d.cpp**中：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The tests now build and pass.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经构建并通过。
- en: 'Refactor the code slightly to make it more readable. Modify the header to read
    like so:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍微重构代码以使其更易读。修改头文件如下：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Update the **matrix3d.cpp** file to use the constants:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新**matrix3d.cpp**文件以使用常量：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Rebuild the tests and make sure that they still pass.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建测试并确保它们仍然通过。
- en: 'Now, we need to add the initializer list constructor. To do that, add the following
    test:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加初始化程序列表构造函数。为此，添加以下测试：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the include file for the initializer list support and declare the constructor
    in **matrix3d.hpp**:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为初始化程序列表支持添加包含文件并在**matrix3d.hpp**中声明构造函数：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, add the implementation of the constructor to the .cpp file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在.cpp文件中添加构造函数的实现：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To improve the readability of our tests, add a helper method to the test framework.
    In the `Matrix3dTest` class, declare the following:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了改善我们测试的可读性，在测试框架中添加一个辅助方法。在`Matrix3dTest`类中声明以下内容：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the definition of the helper method:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加辅助方法的定义：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Write a test to multiply two matrices and get a new matrix (expected will be
    calculated by hand):'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试，将两个矩阵相乘并得到一个新的矩阵（预期将手动计算）：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the header file, define `operator*=`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中定义`operator*=`：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, implement the inline version of `operator*` (outside the class declaration):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在类声明之外实现`operator*`的内联版本：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And the implementation to the **matrix3d.cpp** file:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及在**matrix3d.cpp**文件中的实现：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Build and run the tests – again, they should pass.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行测试-再次，它们应该通过。
- en: 'Introduce a second helper function to the test class by declaring it in the
    `Matrix3dTest` class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Matrix3dTest`类中声明第二个辅助函数来引入测试类的辅助函数：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, declare it so that we can use it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明它以便我们可以使用它：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Update the one test to use it:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新一个测试以使用它：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Write one sanity check test:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个健全性检查测试：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Build and run the tests – they should still pass.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行测试-它们应该仍然通过。
- en: 'Now, we need to be able to multiply points and matrices. Add the following
    test:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要能够将点和矩阵相乘。添加以下测试：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In `Matrix3d` class declaration:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Matrix3d`类声明中：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the definition of the operator to the **matrix3d.cpp** file:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**matrix3d.cpp**文件中添加运算符的定义：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Build and run the tests. They should all be passing again.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行测试。它们应该再次全部通过。
- en: 'At the top of **matrix3dtests.cpp**, add the include file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**matrix3dtests.cpp**的顶部，添加包含文件：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Start adding the transformation matrix factory methods. Using the following
    tests, we will develop the various factory methods (the tests should be added
    one at a time):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始添加转换矩阵工厂方法。使用以下测试，我们将开发各种工厂方法（测试应逐个添加）：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add the following declarations to the matrix3d header file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下声明添加到matrix3d头文件中：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: At the top of the matrix3d implementation file, add `#include <cmath>`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在matrix3d实现文件的顶部添加`#include <cmath>`。
- en: 'Finally, add the following implementations to the `matrix3d` implementation
    file:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下实现添加到`matrix3d`实现文件中：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To get this to compile and pass the test, we need to add one more accessor
    to the declaration of `matrix3d`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其编译并通过测试，我们需要在`matrix3d`的声明中添加一个访问器：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Build and run all the tests again to show that they all pass.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建并运行所有测试，以显示它们都通过了。
- en: 'In `point3d.hpp`, add the include for `<ostream>` and add the following friend
    declaration to the Point3d class at the end:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`point3d.hpp`中，添加`<ostream>`的包含，并在Point3d类末尾添加以下友元声明：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Write the inline implementation of the operator after the class:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类之后编写操作符的内联实现：
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open the **main.cpp** file and remove the comment delimiters, //, from the
    line:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**main.cpp**文件，并从以下行中删除注释分隔符，//：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Build and run the application called `graphics` – you will need to create a
    new Run Configuration. If your implementations of `Point3d` and `Matrix3d` are
    correct, then the program will display the following output:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行名为`graphics`的应用程序 - 您需要创建一个新的运行配置。如果您的`Point3d`和`Matrix3d`的实现正确，那么程序将显示以下输出：
- en: '![](img/C14583_02A_53.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_02A_53.jpg)'
- en: 'Figure 2A.53: Successfully running the activity program'
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2A.53：成功运行活动程序
- en: In this activity, we implemented two classes that form the basis of all the
    operations that are required to implement 3D graphics rendering. We used operator
    overloading to achieve this so that Matrix3d and Point3d can be used as if they
    were native types. This can be easily extended to deal with vectors of points,
    which is required if we wish to manipulate whole objects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们实现了两个类，这两个类是实现3D图形渲染所需的所有操作的基础。我们使用运算符重载来实现这一点，以便Matrix3d和Point3d可以像本机类型一样使用。如果我们希望操作整个对象，这可以很容易地扩展到处理点的向量。
- en: Chapter – 2B - No Ducks Allowed – Templates and Deduction
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2B章 - 不允许鸭子 - 模板和推断
- en: 'Activity 1: Developing a Generic "contains" Template Function'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：开发通用的“contains”模板函数
- en: 'In this activity, we will implement several helper classes that will be used
    to detect the `std::string` class case and the `std::set` case and then use them
    to tailor the contains function to the particular container. Follow these steps
    to implement this activity:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现几个辅助类，用于检测`std::string`类情况和`std::set`情况，然后使用它们来调整包含函数以适应特定容器。按照以下步骤实现此活动：
- en: Load the prepared project from the `L2BA1tests`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`L2BA1tests`加载准备好的项目。
- en: 'Open the **containsTests.cpp** file and replace the existing test with the
    following:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**containsTests.cpp**文件，并用以下内容替换现有测试：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This test requires us to write a set of helper templates to detect if the container
    class supports a static member variable called npos.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试要求我们编写一组辅助模板，以检测容器类是否支持名为npos的静态成员变量。
- en: 'Add the following code to the **contains.hpp** file:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到**contains.hpp**文件中：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The tests now run and pass.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试运行并通过。
- en: Add the following tests to the `find()` method that takes one argument.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到接受一个参数的`find()`方法中。
- en: 'Add the following code to the **contains.hpp** file:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到**contains.hpp**文件中：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The tests now run and pass.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试运行并通过。
- en: 'Add the implementation for the generic container; in this case, the vector.
    Write the following tests in the **containsTest.cpp** file:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加通用容器的实现；在这种情况下，是向量。在**containsTest.cpp**文件中编写以下测试：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the basic implementation of `contains` to the **contains.hpp** file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`contains`的基本实现添加到**contains.hpp**文件中：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The tests now run and pass.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试运行并通过。
- en: 'The next step is to add the tests for the `set` special case to **containsTest.cpp**:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为`set`特殊情况添加测试到**containsTest.cpp**：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The implementation of `contains` is updated to test for the built-in `set::find()`
    method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`contains`的实现以测试内置的`set::find()`方法：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The tests now run and pass.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试运行并通过。
- en: 'Add the tests for the `string` special case to the **containsTest.cpp** file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`string`特殊情况的测试添加到**containsTest.cpp**文件中：
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the following implementation of `contains` to test for the presence of
    `npos` and tailor the use of the `find()` method:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`contains`的实现以测试`npos`的存在并调整`find()`方法的使用：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The tests now run and pass.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试运行并通过。
- en: 'Build and run the application called `contains`. Create a new Run Configuration.
    If your implementation of the contains template is correct, then the program will
    display the following output:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行名为`contains`的应用程序。创建一个新的运行配置。如果您的contains模板实现正确，那么程序将显示以下输出：
- en: '![Figure 2B.36: Output from the successful implementation of contains'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.36：包含成功实现的输出'
- en: '](img/C14583_02B_36.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_36.jpg)'
- en: 'Figure 2B.36: Output from the successful implementation of contains'
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.36：包含成功实现的输出
- en: In this activity, we used various templating techniques in conjunction with
    SFINAE to select the appropriate implementation of a `contains()` function based
    upon the capability of the containing class. We could have achieved the same result
    using a generic template function and some specialized templates, but we took
    the path less travelled and flexed our newly found template skills.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们使用各种模板技术与SFINAE结合使用，根据包含类的能力选择`contains()`函数的适当实现。我们可以使用通用模板函数和一些专门的模板来实现相同的结果，但我们选择了不太常见的路径，并展示了我们新发现的模板技能。
- en: Chapter 3 - The Distance between Can and Should – Objects, Pointers and Inheritance
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章 - 能与应该之间的距离 - 对象，指针和继承
- en: 'Activity 1: Implementing Graphics Processing with RAII and Move'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：使用RAII和Move实现图形处理
- en: 'In this activity, we will develop our previous `Matrix3d` and `Point3d` classes
    to use a `unique_ptr<>` to manage the memory associated with the data structures
    that are required to implement these graphics classes. Let''s get started:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将开发我们之前的`Matrix3d`和`Point3d`类，以使用`unique_ptr<>`来管理与实现这些图形类所需的数据结构相关联的内存。让我们开始吧：
- en: Load the prepared project from the **Lesson3/Activity01** folder and configure
    the Current Builder for the project to be **CMake Build (Portable)**. Build and
    configure the launcher and run the unit tests. We recommend that the name that's
    used for the tests runner is **L3A1graphicstests**.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Lesson3/Activity01**文件夹加载准备好的项目，并为项目配置当前构建器为**CMake Build (Portable)**。构建和配置启动器并运行单元测试。我们建议为测试运行器使用的名称是**L3A1graphicstests**。
- en: Open `acpp::gfx`, is a new feature of C++17\. Previously, it would have required
    the explicit use of the `namespace` keyword twice. Also, beware that, in trying
    to be helpful, your friendly neighborhood IDE may insert the closing brace just
    after the line that you put the namespace declaration.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`acpp::gfx`，这是C++17的一个新特性。以前，它需要显式使用`namespace`关键字两次。另外，请注意，为了提供帮助，您友好的邻里IDE可能会在您放置命名空间声明的那一行后面立即插入闭括号。
- en: Repeat the same treatment for **matrix3d.hpp**, **matrix3d.cpp**, and **point3d.cpp**
    – ensure that the include files are not included in the scope of the namespace.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**matrix3d.hpp**、**matrix3d.cpp**和**point3d.cpp**执行相同的处理-确保包含文件不包含在命名空间的范围内。
- en: 'In the respective files (**main.cpp**, **matrix3dTests.cpp**, and **point3dTests.cpp**),
    just after completing the #include directives, insert the following line:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在各自的文件（**main.cpp**、**matrix3dTests.cpp**和**point3dTests.cpp**）中，在完成#include指令后，插入以下行：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, run all the tests. All **18** existing tests should pass again. We have
    successfully put our classes into a namespace.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行所有测试。所有**18**个现有测试应该再次通过。我们已经成功地将我们的类放入了一个命名空间。
- en: Now we will move onto converting the `Matrix3d` class to use heap allocated
    memory. In the `#include <memory>` line to give us access to the `unique_ptr<>`
    template.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将转而将`Matrix3d`类转换为使用堆分配的内存。在`#include <memory>`行中，以便我们可以访问`unique_ptr<>`模板。
- en: 'Next, change the type of the declaration for `m_data`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更改声明`m_data`的类型：
- en: '[PRE77]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: From this point forward, we will use the compiler and its errors to give us
    hints as to what needs fixing. Attempting to build the tests now reveals that
    we have a problem with the following two methods in the header file
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这一点开始，我们将使用编译器及其错误来提示我们需要修复的问题。尝试构建测试现在会显示我们在头文件中有以下两个方法存在问题。
- en: '[PRE78]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The problem here is that `unique_ptr` holds a pointer to a single dimension
    array and not a two- dimensional array. So, we need to convert the row and column
    into a single index.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`unique_ptr`保存了一个指向单维数组而不是二维数组的指针。因此，我们需要将行和列转换为一个单一的索引。
- en: 'Add a new method called `get_index()` to get the one-dimensional index from
    the row and column and update the preceding functions to use it:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`get_index()`的新方法，以从行和列获取一维索引，并更新前面的函数以使用它：
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'After recompiling, the next error from the compiler refers to the following
    inline function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译后，编译器给出的下一个错误是关于以下内联函数：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Whereas before, the default copy constructor was sufficient for our purposes,
    it just did a shallow copy of all the elements of the array and that was correct.
    We now have indirection to the data we need to copy and so we need to implement
    a deep copy constructor and copy assignment. We will also need to address the
    existing constructors. For now, just add the constructor declarations to the class
    (adjacent to the other constructors):'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前，默认的复制构造函数对我们的目的已经足够了，它只是对数组的所有元素进行了浅复制，这是正确的。现在我们需要复制的数据有了间接引用，因此我们需要实现一个深复制构造函数和复制赋值。我们还需要处理现有的构造函数。现在，只需将构造函数声明添加到类中（与其他构造函数相邻）：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Attempting to build the tests will now show that we have resolved all the issues
    in the header file, and that we can move onto the implementation file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试构建测试现在将显示我们已解决头文件中的所有问题，并且可以继续进行实现文件。
- en: 'Modify the two constructors to initialize `unique_ptr` as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改两个构造函数以初始化`unique_ptr`如下：
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We now need to address the single-dimensional array look-up. We need to change
    the statements of the `m_data[i][j]` type with `m_data[get_index(i,j)]`. Change
    the default constructor to read like so:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要解决单维数组查找的问题。我们需要将`m_data[i][j]`类型的语句更改为`m_data[get_index(i,j)]`。将默认构造函数更改为以下内容：
- en: '[PRE83]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Change the initializer list constructor to be the following:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改初始化列表构造函数如下：
- en: '[PRE84]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Change the multiplication operator, being careful with the indices:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改乘法运算符，注意索引：
- en: '[PRE85]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With these changes in place, we have fixed all the compiler errors, but now
    we have a linker error to deal with – the copy constructor that we only declared
    back in step 11.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，我们已经修复了所有的编译错误，但现在我们有一个链接器错误要处理-我们只在第11步中声明了复制构造函数。
- en: 'In the **matrix3d.cpp** file add the following definitions:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**matrix3d.cpp**文件中添加以下定义：
- en: '[PRE86]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The tests will now build and all of them will pass. The next step is to force
    a move constructor. Locate the `createTranslationMatrix()` method in **matrix3d.cpp**
    and change the return statement as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试将会构建，并且所有测试都会通过。下一步是强制移动构造函数。在**matrix3d.cpp**中找到`createTranslationMatrix()`方法，并将返回语句更改如下：
- en: '[PRE87]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In `move` constructor.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`move`构造函数中。
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Rebuild the tests. Now, we get an error related to the move constructor not
    being present.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建测试。现在，我们得到了一个与移动构造函数不存在相关的错误。
- en: Add the implementation of the constructor into **matrix3d.cpp** and rebuild
    the tests.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数的实现添加到**matrix3d.cpp**中，并重新构建测试。
- en: '[PRE89]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Rebuild and run the tests. They all pass again.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建并运行测试。它们都会再次通过。
- en: Just to confirm that the move constructor is being called, add `#include <iostream>`
    to `cerr`). After the check, make the line a comment again.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认移动构造函数是否被调用，将`#include <iostream>`添加到`cerr`中。检查后，再将该行注释掉。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Just a quick note about the move constructor – we did not explicitly initialize
    `m_data` like we did for the other constructors. This means that it will be initialized
    as empty and then swapped with the parameter that is passed in, which is a temporary
    and so it is acceptable for it to not hold an array after the transaction – it
    removes one allocation and deallocation of memory.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动构造函数的一个快速说明-我们没有像其他构造函数那样显式初始化`m_data`。这意味着它将被初始化为空，然后与传入的参数交换，这是一个临时的，所以它可以不保存数组在事务之后-它删除了一次内存的分配和释放。
- en: Now let's convert the `Point3d` class so that it can use heap allocated memory.
    In the `#include <memory>` line so that we have access to the `unique_ptr<>` template.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们转换`Point3d`类，以便它可以使用堆分配的内存。在`#include <memory>`行中添加，以便我们可以访问`unique_ptr<>`模板。
- en: 'Next, change the type of the declaration for `m_data` to be like so:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更改`m_data`的声明类型如下：
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The compiler now tells us that we have a problem with the insertion operator
    (<<) in `unique_ptr`: Replace the implementation with the following:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器现在告诉我们，在`unique_ptr`的插入运算符（<<）中存在问题：用以下内容替换实现：
- en: '[PRE91]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Open `unique_ptr` and change the initialization loop since a ranged for cannot
    be used on the `unique_ptr`:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`unique_ptr`并更改初始化循环，因为`unique_ptr`不能使用范围for：
- en: '[PRE92]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Modify the other constructor by initializing the `unique_ptr`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过初始化`unique_ptr`修改另一个构造函数：
- en: '[PRE93]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now all the tests run and pass, like they did previously.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有的测试都运行并通过，就像以前一样。
- en: Now, if we run the original application, **L3graphics**, then the output will
    be identical to the original, but the implementation uses RAII to allocate and
    manage the memory that's used for the matrices and points.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行原始应用程序**L3graphics**，那么输出将与原始输出相同，但是该实现使用RAII来分配和管理用于矩阵和点的内存。
- en: '![](img/C14583_03_52.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_03_52.jpg)'
- en: 'Figure 3.52: Activity 1 output after successful conversion to use RAII'
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.52：成功转换为使用RAII后的活动1输出
- en: 'Activity 2: Implementing classes for Date Calculations'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2：实现日期计算的类
- en: 'In this activity, we will implement two classes, `Date` and `Days` that will
    make it very easy for us to work with dates and the time differences between them.
    Let''s get started:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现两个类，`Date`和`Days`，这将使我们非常容易处理日期和它们之间的时间差异。让我们开始吧：
- en: Load the prepared project from the **Lesson3/Activity02** folder and configure
    the Current Builder for the project to be **CMake Build (Portable)**. Build and
    configure the launcher and run the unit tests. We recommend that the name that's
    used for the tests runner is **L3A2datetests**. The project has dummy files and
    one failing test.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Lesson3/Activity02**文件夹加载准备好的项目，并配置项目的当前构建器为**CMake Build (Portable)**。构建和配置启动器并运行单元测试。我们建议为测试运行器使用的名称是**L3A2datetests**。该项目有虚拟文件和一个失败的测试。
- en: 'Open the `Date` class to allow access to the stored values:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Date`类以允许访问存储的值：
- en: '[PRE94]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Open the `DateTest` class:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DateTest`类：
- en: '[PRE95]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Normally, you would refactor this test as the tests develop, but we will pull
    it out up front.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，随着测试的发展，您会重构这个测试，但我们将它提前拉出来。
- en: 'Replace `ASSERT_FALSE()` in the existing test with the following test:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下测试替换现有测试中的`ASSERT_FALSE()`：
- en: '[PRE96]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Rebuild and run the tests – they should now all pass.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建并运行测试-现在它们应该全部通过。
- en: 'Add the following test:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE97]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To make this test we need to add the following two constructors to the `Date`
    class:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行这个测试，我们需要向`Date`类添加以下两个构造函数：
- en: '[PRE98]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We now need to introduce the functions to convert to/from the `date_t` type.
    Add the following alias to the **date.hpp** file inside our namespace:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要引入函数来转换`date_t`类型。在我们的命名空间内的**date.hpp**文件中添加以下别名：
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To the `Date` class, add the declaration of the following method:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Date`类中，添加以下方法的声明：
- en: '[PRE100]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, add the following test:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下测试：
- en: '[PRE101]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As we are doing (`TDD`), we add the minimal implementation of the method to
    pass the test.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在进行（`TDD`），我们添加方法的最小实现以通过测试。
- en: '[PRE102]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, we add the next test:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加下一个测试：
- en: '[PRE103]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We continue to add one more test and then another, all the time refining the
    algorithm in `ToDateT()` firstly to deal with dates in `1970`, then `1-Jan-1971`,
    and then a date in `1973`, which means we span one leap year, and so on. The full
    set of tests that are used to develop the `ToDateT()` method are as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续添加一个测试，然后另一个，一直在不断完善`ToDateT()`中的算法，首先处理`1970`年的日期，然后是`1971年1月1日`，然后是`1973`年的日期，这意味着我们跨越了一个闰年，依此类推。用于开发`ToDateT()`方法的完整测试集如下：
- en: '[PRE104]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To pass all of these tests, we add the following items to the declaration of
    the `Date` class:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过所有这些测试，我们向`Date`类的声明中添加以下内容：
- en: '[PRE105]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The implementation of `ToDateT()` and the supporting methods in **date.cpp**
    is as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**date.cpp**中`ToDateT()`的实现和支持方法如下：'
- en: '[PRE106]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now that `ToDateT()` is working, we turn to its inverse, that is, `FromDateT()`.
    Again, we build up the tests one at a time to develop the algorithm over a range
    of dates. The following tests were used:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`ToDateT()`正在工作，我们转向它的反向，即`FromDateT()`。同样，我们逐个构建测试，以开发一系列日期的算法。使用了以下测试：
- en: '[PRE107]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Add the following declarations to the header file:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加以下声明：
- en: '[PRE108]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Use the following implementation since the preceding tests are added one at
    a time:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下实现，因为之前的测试是逐个添加的：
- en: '[PRE109]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Now that we have the supporting routines ready, we can implement the real feature
    of the `Date` class difference between two dates and determine the new date by
    adding a number of days. Both of these operations need a new type (class) `Days`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好支持例程，我们可以实现`Date`类的真正特性，即两个日期之间的差异，并通过添加一定数量的天来确定新日期。这两个操作都需要一个新类型（类）`Days`。
- en: 'Add the following implementation of `Days` to the header (above `Date`):'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`Days`的实现添加到头文件（在`Date`之前）：
- en: '[PRE110]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The first operator will be an addition of `Days` to `Date`. Add the following
    method declaration (inside the public section of the `Date` class) :'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个运算符将是将`Days`添加到`Date`的加法。添加以下方法声明（在`Date`类的公共部分内）：
- en: '[PRE111]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then, add the inline implementation (outside the `Date` class) to the header
    file:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在头文件中（在`Date`类之外）添加内联实现：
- en: '[PRE112]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Write the following tests to verify the `sum` operation:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下测试来验证`sum`操作：
- en: '[PRE113]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The actual implementation of the `sum` operation is simply based on the two
    support methods
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sum`操作的实际实现仅基于两个支持方法'
- en: '[PRE114]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Add the following test:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE115]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'When we run the tests, they all build and this test passes. But this is not
    the desired outcome. We do not want them to be able to add naked integers to our
    dates. (A future version may add months and years, so what does adding an integer
    mean?). To make this fail by causing the build to fail, we change the Days constructor
    to be `explicit`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它们都构建了，并且这个测试通过了。但这不是期望的结果。我们不希望它们能够将裸整数添加到我们的日期中。（将来的版本可能会添加月份和年份，那么添加整数意味着什么？）。为了使其失败并导致构建失败，我们将Days构造函数更改为`explicit`：
- en: '[PRE116]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now the build fails, so we need to fix the test by changing the addition line
    to cast to `Days` as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建失败了，所以我们需要通过将添加行转换为`Days`来修复测试，如下所示：
- en: '[PRE117]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: All tests should pass again.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试应该再次通过。
- en: 'The final functionality we want is the difference between two dates. Here are
    the tests that were used to verify the implementation:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要的最终功能是两个日期之间的差异。以下是用于验证实现的测试：
- en: '[PRE118]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Add the following declaration of the function to the public section of the
    `Date` class in the header file:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中的`Date`类的公共部分中添加以下函数声明：
- en: '[PRE119]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Add the following code after the Date class in the header file:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中的Date类之后添加以下代码：
- en: '[PRE120]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Because we made the `Days` constructor explicit, we must call it in the return
    statement. With all these changes in place, all the tests should pass.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使`Days`构造函数显式，所以必须在返回语句中调用它。在所有这些更改都就位后，所有测试应该都通过。
- en: 'Configure `L3A2date` as a `datetools` binary and open main.cpp in the editor.
    Remove the comment from the definition of `ACTIVITY2`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`L3A2date`配置为`datetools`二进制文件，并在编辑器中打开main.cpp。从`ACTIVITY2`的定义中删除注释：
- en: '[PRE121]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Build and then run the sample application. This will produce the following
    output:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建然后运行示例应用程序。这将产生以下输出：
- en: '![Figure 3.53: Output of successful Date sample application'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.53：成功的Date示例应用程序的输出'
- en: '](img/C14583_03_53.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_03_53.jpg)'
- en: 'Figure 3.53: Output of successful Date sample application'
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.53：成功的Date示例应用程序的输出
- en: We have implemented all of the requirements of the Date and Days classes and
    delivered them all with unit tests. The unit tests allowed us to implement incremental
    functionality to build up the two complicated algorithms, `ToDateT` and `FromDateT`
    which form the underlying support for the functionality that we wanted to deliver.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了Date和Days类的所有要求，并通过单元测试交付了它们。单元测试使我们能够实现增量功能，以构建两个复杂算法`ToDateT`和`FromDateT`，它们构成了我们想要交付的功能的基础支持。
- en: Chapter 4 - Separation of Concerns - Software Architecture, Functions, Variadic
    Templates
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章 - 关注点分离 - 软件架构，函数，可变模板
- en: 'Activity 1: Implement a multicast event handler'
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：实现多播事件处理程序
- en: Load the prepared project from the **Lesson4/Activity01** folder and configure
    the Current Builder for the project to be CMake Build (Portable). Build the project,
    configure the launcher and run the unit tests (which fail the one dummy test).
    Recommend that the name used for the tests runner is *L4delegateTests*.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Lesson4/Activity01**文件夹加载准备好的项目，并将项目的当前构建器配置为CMake Build（Portable）。构建项目，配置启动器并运行单元测试（其中一个虚拟测试失败）。建议为测试运行器使用*L4delegateTests*。
- en: 'In **delegateTests.cpp**, replace the failing dummy test with the following
    test:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**delegateTests.cpp**中，用以下测试替换失败的虚拟测试：
- en: '[PRE122]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This now fails to build, so we need to add a new method to `Delegate`. As this
    will evolve into a template, we will do all of this development in the header
    file. In **delegate.hpp**, and the following definition:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建失败了，所以我们需要向`Delegate`添加一个新方法。由于这将演变为一个模板，我们将在头文件中进行所有这些开发。在**delegate.hpp**中，添加以下定义：
- en: '[PRE123]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The test now runs and passes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试运行并通过。
- en: 'Add the following line to the existing test:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有测试中添加以下行：
- en: '[PRE124]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Again, the build fails, so we update the `Delegate` definition as follows (we
    could have had Notify call `operator()`, but this is easier to read):'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建失败，所以我们更新`Delegate`的定义如下（我们可以让`Notify`调用`operator()`，但这样更容易阅读）：
- en: '[PRE125]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The test again runs and passes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 测试再次运行并通过。
- en: 'Before we add the next test, we are going to add some infrastructure to help
    us develop our tests. The easiest thing to do with handlers is have them write
    to `std::cout`, and to be able to verify that they were called, we need to capture
    the output. To do this, re-route the standard output stream to a different buffer
    by changing the `DelegateTest` class as follows:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加下一个测试之前，我们将添加一些基础设施来帮助我们开发测试。处理程序最容易的方法是让它们写入`std::cout`，为了能够验证它们是否被调用，我们需要捕获输出。为此，通过更改`DelegateTest`类将标准输出流重定向到不同的缓冲区：
- en: '[PRE126]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Also add the include statements for `<iostream>`, `<sstream>` and `<string>`
    to the top of the file.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要在文件顶部添加`<iostream>`、`<sstream>`和`<string>`的包含语句。
- en: 'With this support framework in place, add the following test:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支持框架的基础上，添加以下测试：
- en: '[PRE127]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'To make the tests build and run again, add the following code in the **delegate.h**
    class:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试再次构建和运行，添加以下代码到**delegate.h**类中：
- en: '[PRE128]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Along with the following code:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 随着以下代码：
- en: '[PRE129]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The tests now build, but our new test fails.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试构建了，但我们的新测试失败了。
- en: 'Update the `Notify()` method to be:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Notify()`方法为：
- en: '[PRE130]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The tests now build and our new test passes, but the original test now fails.
    The call to the delegate is throwing an exception, so we need to check that the
    delegate is not empty before calling it. Write the following code to do this:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试构建并且我们的新测试通过了，但原始测试现在失败了。调用委托时抛出了异常，所以在调用之前我们需要检查委托是否为空。编写以下代码来实现这一点：
- en: '[PRE131]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: All the tests now run and pass.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试现在都运行并通过。
- en: 'We now need to add multicast support to the `Delegate` class. Add the new test:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要为`Delegate`类添加多播支持。添加新的测试：
- en: '[PRE132]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Of course, this test now fails because the `operator+=()` only assigns to the
    member variable. We need to add a list to store our delegates. We choose vector
    so we can add to the end of the list as we want to call the delegates in the order
    that they are added. Add `#include <vector>` to the top of **delegate.hpp** and
    update Delegate replace **m_delegate** with **m_delegates** vector of the callbacks:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，这个测试现在失败了，因为`operator+=()`只分配给成员变量。我们需要添加一个列表来存储我们的委托。我们选择vector，这样我们可以按照添加的顺序调用委托。在**delegate.hpp**的顶部添加`#include
    <vector>`，并更新Delegate将**m_delegate**替换为**m_delegates**回调的vector：
- en: '[PRE133]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The tests all run and pass again.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试现在再次运行并通过。
- en: We now have the basic multicast `delegate` class implemented. We now need to
    convert it to a template- based class. Update the existing tests, by changing
    all of the declarations of `Delegate` to `Delegate<int>` in the three tests.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经实现了基本的多播`delegate`类。现在我们需要将其转换为基于模板的类。通过在三个测试中将所有`Delegate`的声明更改为`Delegate<int>`来更新现有的测试。
- en: 'Now update the Delegate class by adding `template<class Arg>` before the class
    to convert it to a template, and substituting the four occurrences of `int` with
    `Arg`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过在类之前添加`template<class Arg>`来更新Delegate类，将其转换为模板，并将四个`int`的出现替换为`Arg`：
- en: '[PRE134]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: All the tests now run and pass as previously, so it stills works for `int` arguments
    for the handlers.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有测试现在都运行并通过，因此它仍然适用于处理程序的`int`参数。
- en: 'Add the following test and re-run the tests to confirm that the template conversion
    is correct:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试并重新运行测试以确认模板转换是正确的：
- en: '[PRE135]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now it operates as a template that takes one argument. We need to convert it
    into a variadic template that takes zero or more arguments. Using the information
    from the last topic, update the template to the following:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它作为一个接受一个参数的模板运行。我们需要将其转换为接受零个或多个参数的可变模板。使用上一个主题的信息，将模板更新为以下内容：
- en: '[PRE136]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The tests should still run and pass.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该仍然运行并通过。
- en: 'Add two more tests – zero argument test, and a mutliple argument test:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个更多的测试 - 零参数测试和多参数测试：
- en: '[PRE137]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: All the tests run and pass showing that we have now implemented the desired
    `Delegate` class.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都运行并通过，显示我们现在已经实现了期望的`Delegate`类。
- en: 'Now, change the Run configuration to execute the program `L4delegate`. Open
    the **main.cpp** file in the editor and change the definition at the top of the
    file to the following and run the program:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将运行配置更改为执行程序`L4delegate`。在编辑器中打开**main.cpp**文件，并更改文件顶部的定义为以下内容，然后运行程序：
- en: '[PRE138]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'We get the following output:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![Figure 4.35: Output from the successful implementation of Delegate'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35：委托成功实现的输出'
- en: '](img/C14583_04_35.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_35.jpg)'
- en: 'Figure 4.35: Output from the successful implementation of Delegate'
  id: totrans-446
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.35：委托成功实现的输出
- en: In this activity, we started by implementing a class that provides the basic
    single delegate functionality and then added multicast capability. With that implemented,
    and unit tests in place, we were quickly able to convert to a template with one
    argument and then to a variadic template version. Depending on the functionality
    that you are developing, the approach of the specific implementation transitioning
    to a general form and then to an even more general form is the correct one. Development
    of variadic templates is not always obvious.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们首先实现了一个提供基本单一委托功能的类，然后添加了多播功能。有了这个实现，并且有了单元测试，我们很快就能够转换为一个带有一个参数的模板，然后转换为一个可变模板版本。根据您正在开发的功能，特定实现过渡到一般形式，然后再到更一般形式的方法是正确的。可变模板的开发并不总是显而易见的。
- en: Chapter 5 - The Philosophers' Dinner – Threads and Concurrency
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章 - 哲学家的晚餐 - 线程和并发
- en: 'Activity 1: Creating a Simulator to Model the Work of the Art Gallery'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：创建模拟器来模拟艺术画廊的工作
- en: The Art Gallery work simulator is an application that simulates how the visitors
    and the watchman behave. There is a quantity limit for visitors, that is, only
    50 people can be inside the gallery simultaneously. Visitors constantly come to
    the gallery. The watchman checks if the limit of visitors has been exceeded. If
    so, it asks new visitors to wait and puts them on a waiting list. If not, it allows
    them to enter the gallery. Visitors can leave the gallery at any time. If somebody
    leaves the gallery, the watchman lets somebody from the waiting list enter the
    gallery.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术画廊工作模拟器是一个模拟访客和看门人行为的应用程序。访客数量有限，即画廊内同时只能容纳50人。访客不断前来画廊。看门人检查是否超过了访客限制。如果是，它会要求新的访客等待并将他们放在等待列表上。如果没有，它允许他们进入画廊。访客可以随时离开画廊。如果有人离开画廊，看门人会让等待列表中的人进入画廊。
- en: 'Follow these steps to implement this activity:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行此活动：
- en: Create a file that will contain all the constants that we need for this project
    – `Common.hpp`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件，其中包含我们项目所需的所有常量 - `Common.hpp`。
- en: 'Add the include guards and the first variable, `CountPeopleInside`, which represents
    that the limit for visitors is 50 people:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包含保护和第一个变量`CountPeopleInside`，它表示访客限制为50人：
- en: '[PRE139]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now, create a header and the source files for the `Person` class, that is,
    `Person.hpp` and `Person.cpp`. Also, add the include guards. Define the `Person`
    class and delete the copy constructor and copy assignment operator; we will only
    use the user-defined default constructor, move constructor, and move assignment
    operator and default destructor. Add a private variable called `m_Id`; we will
    use it for logging. Also, add a private static variable called `m_NextId`; it
    will be used for generating unique IDs:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`Person`类的头文件和源文件，即`Person.hpp`和`Person.cpp`。还要添加包含保护。定义`Person`类并删除复制构造函数和复制赋值运算符；我们只会使用用户定义的默认构造函数、移动构造函数和移动赋值运算符以及默认析构函数。添加一个名为`m_Id`的私有变量；我们将用它来记录。还要添加一个名为`m_NextId`的私有静态变量；它将用于生成唯一的ID：
- en: '[PRE140]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In the source file, define our static variable, `m_NextId`. Then, in the constructor,
    initialize the `m_Id` variable with the value of `m_NextId`. Print the log in
    the constructor. Implement the move copy constructor and the move assignment operator.
    Now, implement thread-safe storage for our `Person` objects. Create the required
    header and source files, that is, `Persons.hpp` and `Persons.cpp`. Also, add the
    include guards. Include "`Person.hpp`" and the `<mutex>` and `<vector>` headers.
    Define the `Persons` class with a user-defined default constructor and default
    destructor. Declare the `add()` function for adding the Person and `get()` for
    getting the Person and removing it from the list. Define the `size()` function
    to get the count of Person elements, as well as `removePerson()`, which removes
    any person from the storage. In the private section, declare a variable of the
    mutex type, namely `m_Mutex`, and the vector to store Persons, namely `m_Persons`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件中，定义我们的静态变量`m_NextId`。然后，在构造函数中，使用`m_NextId`的值初始化`m_Id`变量。在构造函数中打印日志。实现移动复制构造函数和移动赋值运算符。现在，为我们的`Person`对象实现线程安全存储。创建所需的头文件和源文件，即`Persons.hpp`和`Persons.cpp`。还要添加包含保护。包括"`Person.hpp`"和`<mutex>`和`<vector>`头文件。定义具有用户定义默认构造函数和默认析构函数的`Persons`类。声明`add()`函数以添加`Person`和`get()`以获取`Person`并从列表中删除它。定义`size()`函数以获取`Person`元素的计数，以及`removePerson()`，它从存储中删除任何人。在私有部分中，声明互斥类型的变量`m_Mutex`，即`m_Persons`来存储Persons的向量：
- en: '[PRE141]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In the source file, declare the user-defined constructor where we reserve the
    size of the vector to be 50 elements (to avoid resizing during growth):'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件中，声明用户定义的构造函数，我们将向量的大小保留为50个元素（以避免在增长过程中重新调整大小）：
- en: '[PRE142]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Declare the `add()` function, which takes an rvalue parameter of the `Person`
    type, locks the mutex, and adds `Person` to the vector using the `std::move()`
    function:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`add()`函数，它接受`Person`类型的rvalue参数，锁定互斥锁，并使用`std::move()`函数将`Person`添加到向量中：
- en: '[PRE143]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Declare the `get()` function, which locks the mutex and returns the last element
    and then removes it from the vector. If the vector is empty, it will throw an
    exception:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`get()`函数，锁定互斥锁并返回最后一个元素，然后从向量中删除它。如果向量为空，它将抛出异常：
- en: '[PRE144]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Declare the `size()` function, which returns the size of the vector:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`size()`函数，返回向量的大小：
- en: '[PRE145]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Finally, declare the `removePerson()` function, which locks the mutex and removes
    the last item from the vector:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明`removePerson()`函数，该函数锁定互斥锁并从向量中删除最后一个项目：
- en: '[PRE146]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now, implement the PersonGenerator class, which is responsible for creating
    and removing Person items. Create the respective header and source files, that
    is, `PersonGenerator.hpp` and `PersonGenerator.cpp`. Also, add the include guards.
    Include the "`Person.hpp`", `<thread>`, and `<condition_variable>` headers. Define
    the `PersonGenerator` class. In the private section, define two `std::thread`
    variables, namely `m_CreateThread` and `m_RemoveThread`. In one thread, we will
    create new `Person` objects and will notify the user about removing `Person` objects
    in the other thread asynchronously. Define a reference to a shared variable of
    the `Persons` type, namely `m_CreatedPersons`. We will place every new person
    in it. `m_CreatedPersons` will be shared between several threads. Define two references
    to `std::condition_variable`, namely `m_CondVarAddPerson` and `m_CondVarRemovePerson`.
    They will be used for communication between threads. Define two references to
    the `std::mutex` variables, namely `m_AddLock` and `m_RemoveLock`. They will be
    used for receiving access to condition variables. Finally, define two references
    to a `bool` value, namely `m_AddNotified` and `m_RemoveNotified`. They will be
    used for checking whether the notification is true or false. Also, in the private
    section, define two functions that will be start functions for our threads – `runCreating()`
    and `runRemoving()`. Next, define two functions that will trigger condition variables,
    namely `notifyCreated()` and `notifyRemoved()`. In the public section, define
    a constructor that takes all the references that we defined in the private section
    as a parameter. Finally, define a destructor. This will ensure that the other
    default generated functions are deleted:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现`PersonGenerator`类，负责创建和删除`Person`项。创建相应的头文件和源文件，即`PersonGenerator.hpp`和`PersonGenerator.cpp`。还要添加包含保护。包括"`Person.hpp`"，`<thread>`和`<condition_variable>`头文件。定义`PersonGenerator`类。在私有部分中，定义两个`std::thread`变量，即`m_CreateThread`和`m_RemoveThread`。在一个线程中，我们将创建新的`Person`对象，并在另一个线程中异步通知用户删除`Person`对象。定义对`Persons`类型的共享变量的引用，即`m_CreatedPersons`。我们将把每个新人放在其中。`m_CreatedPersons`将在多个线程之间共享。定义两个`std::condition_variable`的引用，即`m_CondVarAddPerson`和`m_CondVarRemovePerson`。它们将用于线程之间的通信。定义两个`std::mutex`变量的引用，即`m_AddLock`和`m_RemoveLock`。它们将用于接收对条件变量的访问。最后，在私有部分中，定义两个函数，它们将是我们线程的启动函数
    - `runCreating()`和`runRemoving()`。接下来，定义两个将触发条件变量的函数，即`notifyCreated()`和`notifyRemoved()`。在公共部分中，定义一个构造函数，它将所有在私有部分中定义的引用作为参数。最后，定义一个析构函数。这将确保其他默认生成的函数被删除：
- en: '[PRE147]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, move on to the source file. Include the `<stdlib.h>` file so that we can
    access the `srand()` and `rand()` functions, which are used for random number
    generation. Include the `<time.h>` header so that we can access the `time()` function,
    as well as the `std::chrono` namespace. They are used for when we work with time.
    Include the `<ratio>` file, which used for typedefs so that we can work with the
    time library:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到源文件。包括`<stdlib.h>`文件，以便我们可以访问`rand()`和`srand()`函数，这些函数用于生成随机数。包括`<time.h>`头文件，以便我们可以访问`time()`函数，以及`std::chrono`命名空间。它们用于处理时间。包括`<ratio>`文件，用于typedefs，以便我们可以使用时间库：
- en: '[PRE148]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Declare the constructor and initialize all the parameters except the threads
    in the initializer list. Initialize the threads with the appropriate functions
    in the constructor body:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明构造函数并在初始化程序列表中初始化除线程之外的所有参数。在构造函数体中使用适当的函数初始化线程：
- en: '[PRE149]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Declare a destructor and check if the threads are joinable. Join them if not:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个析构函数，并检查线程是否可连接。如果不可连接，则加入它们：
- en: '[PRE150]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Declare the `runCreating()` function, which is the start function for the `m_CreateThread`
    thread. In this function, in an infinite loop, we will generate a random number
    from 1 to 10 and make the current thread sleep for this time. After this, create
    a Person value, add it to the shared container, and notify other threads about
    it:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`runCreating()`函数，这是`m_CreateThread`线程的启动函数。在这个函数中，我们将在一个无限循环中生成一个从1到10的随机数，并使当前线程休眠这段时间。之后，创建一个Person值，将其添加到共享容器，并通知其他线程：
- en: '[PRE151]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Declare the `runRemoving()` function, which is the start function for the `m_RemoveThread`
    thread. In this function, in an infinite loop, we will generate a random number
    from 20 to 30 and make the current thread sleep for this time. After this, notify
    the other threads that some of the visitors should be removed:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`runRemoving()`函数，这是`m_RemoveThread`线程的启动函数。在这个函数中，我们将在一个无限循环中生成一个从20到30的随机数，并使当前线程休眠这段时间。之后，通知其他线程应该移除一些访问者：
- en: '[PRE152]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Declare the `notifyCreated()` and `notifyRemoved()` functions. In their bodies,
    lock the appropriate mutex, set the appropriate bool variable to true, and call
    the `notify_all()` functions on the appropriate condition variables:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`notifyCreated()`和`notifyRemoved()`函数。在它们的主体中，锁定适当的互斥锁，将适当的布尔变量设置为true，并在适当的条件变量上调用`notify_all()`函数：
- en: '[PRE153]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Finally, we need to create the files for our last class, Watchman, namely `Watchman.hpp`
    and `Watchman.cpp`. As usual, add the include guards. Include the "`Persons.hpp`",
    `<thread>`, <mutex>, and `<condition_variable>` headers. Define the `Watchman`
    class. In the private section, define two `std::thread` variables, namely `m_ThreadAdd`
    and `m_ThreadRemove`. In one of the threads, we will move new `Person` objects
    to the appropriate queue and will remove `Person` objects in the other thread
    asynchronously. Define the references to the shared `Persons` variables, namely
    `m_CreatedPeople`, `m_PeopleInside`, and `m_PeopleInQueue`. We will take every
    new person from the `m_CreatedPeople` list and move them to the `m_PeopleInside`
    list if the limit is not exceeded. We will move them to the `m_PeopleInQueue`
    list otherwise. They will be shared between several threads. Define two references
    to `std::condition_variable`, namely `m_CondVarAddPerson` and `m_CondVarRemovePerson`.
    They will be used for communication between threads. Define two references to
    the `std::mutex` variables, namely `m_AddMux` and `m_RemoveMux`. They will be
    used for receiving access to condition variables. Finally, define two references
    to a `bool` value, namely `m_AddNotified` and `m_RemoveNotified`. They will be
    used for checking if the notification is true or false. Also, in the private section,
    define two functions that will be start functions for our threads – `runAdd()`
    and `runRemove()`. In the public section, define a constructor that takes all
    the references that we defined in the private section as parameters. Now, define
    a destructor. Make sure that all the other default generated functions are deleted:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为我们的最后一个类Watchman创建文件，即`Watchman.hpp`和`Watchman.cpp`。像往常一样，添加包含保护。包括"`Persons.hpp`"、`<thread>`、`<mutex>`和`<condition_variable>`头文件。定义`Watchman`类。在私有部分，定义两个`std::thread`变量，即`m_ThreadAdd`和`m_ThreadRemove`。在一个线程中，我们将新的`Person`对象移动到适当的队列中，并在另一个线程中异步移除`Person`对象。定义对共享`Persons`变量的引用，即`m_CreatedPeople`、`m_PeopleInside`和`m_PeopleInQueue`。如果限制未超出，我们将从`m_CreatedPeople`列表中获取每个新人，并将其移动到`m_PeopleInside`列表中。否则，我们将把它们移动到`m_PeopleInQueue`列表中。它们将在多个线程之间共享。定义两个对`std::condition_variable`的引用，即`m_CondVarAddPerson`和`m_CondVarRemovePerson`。它们将用于线程之间的通信。定义两个对`std::mutex`变量的引用，即`m_AddMux`和`m_RemoveMux`。它们将用于接收对条件变量的访问。最后，在私有部分中，定义两个函数，它们将成为我们线程的启动函数——`runAdd()`和`runRemove()`。在公共部分中，定义一个构造函数，它将所有在私有部分中定义的引用作为参数。现在，定义一个析构函数。确保删除所有其他默认生成的函数：
- en: '[PRE154]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now, move on to the source file. Include the "`Common.hpp`" header so that
    we can access the `m_CountPeopleInside` variable and the other necessary headers:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到源文件。包括"`Common.hpp`"头文件，以便我们可以访问`m_CountPeopleInside`变量和其他必要的头文件：
- en: '[PRE155]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Declare the constructor and initialize all the parameters except for the threads
    in the initializer list. Initialize the threads with the appropriate functions
    in the constructor''s body:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明构造函数，并在初始化列表中初始化除线程之外的所有参数。在构造函数的主体中使用适当的函数初始化线程：
- en: '[PRE156]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Declare a destructor and check if the threads are joinable. Join them if not:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个析构函数，并检查线程是否可连接。如果不可连接，则加入它们：
- en: '[PRE157]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Declare the `runAdd()` function. Here, we create an infinite loop. In the loop,
    we are waiting for a condition variable. When the condition variable notifies,
    we take people from the `m_CreatedPeople` list and move them to the appropriate
    list, that is, `m_PeopleInside`, or `m_PeopleInQueue` if the limit has been exceeded.
    Then, we check if there are any people in the `m_PeopleInQueue` list and if `m_PeopleInside`
    is not full, we move them into this list:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`runAdd()`函数。在这里，我们创建一个无限循环。在循环中，我们正在等待条件变量。当条件变量通知时，我们从`m_CreatedPeople`列表中取出人员，并将其移动到适当的列表，即`m_PeopleInside`，或者如果超出限制，则移动到`m_PeopleInQueue`。然后，我们检查`m_PeopleInQueue`列表中是否有人，以及`m_PeopleInside`是否已满，如果是，则将它们移动到这个列表中：
- en: '[PRE158]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Next, declare the `runRemove()` function, where we will remove visitors from
    `m_PeopleInside`. Here, also in the infinite loop, we are waiting for the `m_CondVarRemovePerson`
    condition variable. When it notifies the thread, we remove people from the list
    of visitors. Next, we will check if there''s anybody in the `m_PeopleInQueue`
    list and if the limit is not exceeded, we add them to `m_PeopleInside`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`runRemove()`函数，我们将从`m_PeopleInside`中移除访问者。同样，在无限循环中，我们正在等待`m_CondVarRemovePerson`条件变量。当它通知线程时，我们从访问者列表中移除人员。接下来，我们将检查`m_PeopleInQueue`列表中是否有人，以及是否未超出限制，如果是，则将它们添加到`m_PeopleInside`中：
- en: '[PRE159]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Finally, move to the `main()` function. First, create all the shared variables
    that we used in the `Watchman` and `PersonGenerator` classes. Next, create the
    `Watchman` and `PersonGenerator` variables and pass those shared variables to
    the constructors. At the end of the main function read the character to avoid
    closing the application:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，转到`main()`函数。首先，创建我们在`Watchman`和`PersonGenerator`类中使用的所有共享变量。接下来，创建`Watchman`和`PersonGenerator`变量，并将这些共享变量传递给构造函数。在主函数的末尾，读取字符以避免关闭应用程序：
- en: '[PRE160]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Compile and run the application. In the terminal, you will see logs from different
    threads about creating and moving people from one list to another. Your output
    will be similar to the following screenshot:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。在终端中，您将看到来自不同线程的日志，说明创建和移动人员从一个列表到另一个列表。您的输出将类似于以下屏幕截图：
- en: '![Figure 5.27: The result of the application''s execution'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.27：应用程序执行的结果'
- en: '](img/C14583_05_27.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_05_27.jpg)'
- en: 'Figure 5.27: The result of the application''s execution'
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.27：应用程序执行的结果
- en: As you can see, all the threads communicate with each other in a very easy and
    clean way. We protected our shared data by using mutexes so that we can avoid
    race conditions. Here, we used an exception to warn about the empty lists and
    caught them in the thread's functions so that our threads handle exceptions on
    their own. We also checked if the thread is joinable before joining it in the
    destructor. This allowed us to avoid the unexpected termination of the program.
    Thus, this small project demonstrates our skills when it comes to working with
    threads.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有线程之间都以非常简单和清晰的方式进行通信。我们通过使用互斥锁来保护我们的共享数据，以避免竞争条件。在这里，我们使用异常来警告空列表，并在线程函数中捕获它们，以便我们的线程自行处理异常。我们还在析构函数中检查线程是否可连接之前加入它。这使我们能够避免程序意外终止。因此，这个小项目展示了我们在处理线程时的技能。
- en: Chapter 6 – Streams and I/O
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章-流和I/O
- en: Activity 1 The Logging System for The Art Gallery Simulator
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1 艺术画廊模拟器的记录系统
- en: 'The thread-safe logger allows us to output data to the Terminal simultaneously.
    We implement this logger by inheriting from the `std::ostringstream` class and
    using a mutex for synchronization. We will implement a class that provides an
    interface for the formatted output and our logger will use it to extend the basic
    output. We define macro definitions for different logging levels to provide an
    interface that will be easy and clear to use. Follow these steps to complete this
    activity:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全的记录器允许我们同时将数据输出到终端。我们通过从`std::ostringstream`类继承并使用互斥锁进行同步来实现此记录器。我们将实现一个提供格式化输出接口的类，我们的记录器将使用它来扩展基本输出。我们定义了不同日志级别的宏定义，以提供易于使用和清晰的接口。按照以下步骤完成此活动：
- en: Open the project from Lesson6\.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Lesson6\中打开项目。
- en: 'Create a new directory called logger inside the **src/** directory. You will
    get the following hierarchy:![Figure 6.25: The hierarchy of the project'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**src/**目录中创建一个名为logger的新目录。您将获得以下层次结构：![图6.25：项目的层次结构
- en: '](img/C14583_06_25.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_06_25.jpg)'
- en: 'Figure 6.25: The hierarchy of the project'
  id: totrans-508
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.25：项目的层次结构
- en: Create a header and source file called `LoggerUtils`. In `LoggerUtils.hpp`,
    add include guards. Include the <string> header to add support for working with
    strings. Define a namespace called logger and then define a nesting namespace
    called `utils`. In the `utils` namespace, declare the `LoggerUtils` class.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`LoggerUtils`的头文件和源文件。在`LoggerUtils.hpp`中，添加包括保护。包括`<string>`头文件以添加对字符串的支持。定义一个名为logger的命名空间，然后定义一个嵌套命名空间叫做`utils`。在`utils`命名空间中，声明`LoggerUtils`类。
- en: 'In the public section, declare the following static functions: `getDateTime`,
    `getThreadId`, `getLoggingLevel`, `getFileAndLine`, `getFuncName`, `getInFuncName`,
    and `getOutFuncName`. Your class should look as follows:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共部分，声明以下静态函数：`getDateTime`、`getThreadId`、`getLoggingLevel`、`getFileAndLine`、`getFuncName`、`getInFuncName`和`getOutFuncName`。您的类应如下所示：
- en: '[PRE161]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In `LoggerUtils.cpp`, add the required includes: the "`LoggerUtils.hpp`" header,
    `<sstream>` for `std::stringstream` support, and `<ctime>` for date and time support:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LoggerUtils.cpp`中，添加所需的包括："`LoggerUtils.hpp`"头文件，`<sstream>`用于`std::stringstream`支持，`<ctime>`用于日期和时间支持：
- en: '[PRE162]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Enter the `logger` and `utils` namespaces. Write the required function definitions.
    In the `getDateTime()` function, get the local time using the `localtime()` function.
    Format it into a string using the `strftime()` function. Convert it into the desired
    format using `std::stringstream`:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`logger`和`utils`命名空间。编写所需的函数定义。在`getDateTime()`函数中，使用`localtime()`函数获取本地时间。使用`strftime()`函数将其格式化为字符串。使用`std::stringstream`将其转换为所需格式：
- en: '[PRE163]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'In the `getThreadId()` function, get the current thread ID and convert it into
    the desired format using `std::stringstream`:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getThreadId()`函数中，获取当前线程ID并使用`std::stringstream`将其转换为所需格式：
- en: '[PRE164]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'In the `getLoggingLevel()` function, convert the given string into the desired
    format using `std::stringstream`:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getLoggingLevel()`函数中，使用`std::stringstream`将给定的字符串转换为所需格式：
- en: '[PRE165]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'In the `getFileAndLine()` function, convert the given file and line into the
    desired format using `std::stringstream`:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getFileAndLine()`函数中，使用`std::stringstream`将给定的文件和行转换为所需格式：
- en: '[PRE166]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'In the `getFuncName()` function, convert the function name into the desired
    format using `std::stringstream`:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getFuncName()`函数中，使用`std::stringstream`将函数名转换为所需格式：
- en: '[PRE167]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: In the `getInFuncName()` function convert the function name to the desired format
    using `std::stringstream`.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getInFuncName()`函数中，使用`std::stringstream`将函数名转换为所需格式。
- en: '[PRE168]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'In the `getOutFuncName()` function, convert the function name into the desired
    format using `std::stringstream`:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getOutFuncName()`函数中，使用`std::stringstream`将函数名转换为所需格式：
- en: '[PRE169]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Create a header file called `LoggerMacroses.hpp`. Add include guards. Create
    macro definitions for each `LoggerUtils` function: `DATETIME` for the `getDateTime()`
    function, `THREAD_ID` for the `getThreadId()` function, `LOG_LEVEL` for the `getLoggingLevel()`
    function, `FILE_LINE` for the `getFileAndLine()` function, `FUNC_NAME` for the
    `getFuncName()` function, `FUNC_ENTRY_NAME` for the `getInFuncName()` function,
    and `FUNC_EXIT_NAME` for the `getOutFuncName()` function. As a result, the header
    file should look as follows:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`LoggerMacroses.hpp`的头文件。添加包含保护。为每个`LoggerUtils`函数创建宏定义：`DATETIME`用于`getDateTime()`函数，`THREAD_ID`用于`getThreadId()`函数，`LOG_LEVEL`用于`getLoggingLevel()`函数，`FILE_LINE`用于`getFileAndLine()`函数，`FUNC_NAME`用于`getFuncName()`函数，`FUNC_ENTRY_NAME`用于`getInFuncName()`函数，`FUNC_EXIT_NAME`用于`getOutFuncName()`函数。结果，头文件应如下所示：
- en: '[PRE170]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Create a header and source file called `StreamLogger`. In `StreamLogger.hpp`,
    add the required include guards. Include the `LoggerMacroses.hpp` and `LoggerUtils.hpp`
    header files. Then, include the `<sstream>` header for `std::ostringstream` support,
    the `<thread>` header for `std::thread` support, and the `<mutex>` header for
    `std::mutex` support:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StreamLogger`的头文件和源文件。在`StreamLogger.hpp`中，添加所需的包含保护。包含`LoggerMacroses.hpp`和`LoggerUtils.hpp`头文件。然后，包含`<sstream>`头文件以支持`std::ostringstream`，包含`<thread>`头文件以支持`std::thread`，以及包含`<mutex>`头文件以支持`std::mutex`：
- en: '[PRE171]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Enter the `namespace` logger. Declare the `StreamLogger` class, which inherits
    from the `std::ostringstream` class. This inheritance allows us to use an overloaded
    left shift operator, <<, for logging. We don''t set the output device, so the
    output will not be performed – just stored in the internal buffer. In the private
    section, declare a static `std::mutex` variable called `m_mux`. Declare constant
    strings so that you can store the logging level, file and line, and function name.
    In the public section, declare a constructor that takes the logging level, file
    and line, and function name as parameters. Declare a class destructor. The class
    declaration should look like as follows:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`namespace` logger。声明`StreamLogger`类，它继承自`std::ostringstream`类。这种继承允许我们使用重载的左移操作符<<进行记录。我们不设置输出设备，因此输出不会执行
    - 只是存储在内部缓冲区中。在私有部分，声明一个名为`m_mux`的静态`std::mutex`变量。声明常量字符串，以便存储日志级别、文件和行以及函数名。在公共部分，声明一个以日志级别、文件和行以及函数名为参数的构造函数。声明一个类析构函数。类声明应如下所示：
- en: '[PRE172]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'In `StreamLogger.cpp`, include the `StreamLogger.hpp` and `<iostream>` headers
    for `std::cout` support. Enter the `logger` namespace. Define the constructor
    and initialize all the members in the initializer list. Then, define the destructor
    and enter its scope. Lock the `m_mux` mutex. If the internal buffer is empty,
    output only the date and time, thread ID, logging level, file and line, and the
    function name. As a result, we will get the line in the following format: `[dateTtime][threadId][logLevel][file:line:
    ][name() --- ]`. If the internal buffer contains any data, output the same string
    with the buffer at the end. As a result, we will get the line in the following
    format: `[dateTtime][threadId][logLevel][file:line: ][name() --- ] | message`.
    The complete source file should look as follows:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`StreamLogger.cpp`中，包含`StreamLogger.hpp`和`<iostream>`头文件以支持`std::cout`。进入`logger`命名空间。定义构造函数并在初始化列表中初始化所有成员。然后，定义析构函数并进入其作用域。锁定`m_mux`互斥体。如果内部缓冲区为空，则仅输出日期和时间、线程ID、日志级别、文件和行以及函数名。结果，我们将得到以下格式的行：`[dateTtime][threadId][logLevel][file:line:
    ][name() --- ]`。如果内部缓冲区包含任何数据，则在末尾输出相同的字符串与缓冲区。结果，我们将得到以下格式的行：`[dateTtime][threadId][logLevel][file:line:
    ][name() --- ] | message`。完整的源文件应如下所示：'
- en: '[PRE173]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Create a header file called `Logger.hpp` and add the required include guards.
    Include the `StreamLogger.hpp` and `LoggerMacroses.hpp` headers. Next, create
    the macro definitions for the different logging levels: `LOG_TRACE()`, `LOG_DEBUG()`,
    `LOG_WARN()`, `LOG_TRACE()`, `LOG_INFO()`, `LOG_ERROR()`, `LOG_TRACE_ENTRY()`,
    and `LOG_TRACE_EXIT()`.The complete header file should look as follows:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Logger.hpp`的头文件并添加所需的包含保护。包含`StreamLogger.hpp`和`LoggerMacroses.hpp`头文件。接下来，为不同的日志级别创建宏定义：`LOG_TRACE()`、`LOG_DEBUG()`、`LOG_WARN()`、`LOG_TRACE()`、`LOG_INFO()`、`LOG_ERROR()`、`LOG_TRACE_ENTRY()`和`LOG_TRACE_EXIT()`。完整的头文件应如下所示：
- en: '[PRE174]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Replace all the `std::cout` calls with the appropriate macro definition call.
    Include the `logger/Logger.hpp` header in the `Watchman.cpp` source file. In the
    `runAdd()` function, replace all instances of `std::cout` with macro definitions
    for different logging levels. The `runAdd()` function should look as follows:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用适当的宏定义调用替换所有`std::cout`调用。在`Watchman.cpp`源文件中包含`logger/Logger.hpp`头文件。在`runAdd()`函数中，用不同日志级别的宏定义替换所有`std::cout`的实例。`runAdd()`函数应如下所示：
- en: '[PRE175]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Notice how we use our new logger. We invoke the macro definition with parentheses
    and use the left shift operator:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们如何使用我们的新记录器。我们用括号调用宏定义，并使用左移操作符：
- en: '[PRE176]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Do the same replacement for the rest of code.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码的其余部分进行相同的替换。
- en: 'Build and run the application. In the Terminal, you will see that log messages
    appear from the different threads with different logging levels and with useful
    information. After some time has passed, you will get some output similar to the
    following:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。在终端中，您将看到来自不同线程的不同日志级别的日志消息，并带有有用的信息。一段时间后，您将获得类似以下的输出：
- en: '![Figure 6.26: The execution result of the activity project'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.26：活动项目的执行结果'
- en: '](img/C14583_06_26.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_06_26.jpg)'
- en: 'Figure 6.26: The execution result of the activity project'
  id: totrans-546
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.26：活动项目的执行结果
- en: As you can see, it's really easy to read and understand logs. You can easily
    change the `StreamLogger` class to write logs to the file on the filesystem if
    your needs differ. You can add any other information that you may need to debug
    your application using logs, such as output function parameters. You can also
    override the left shift operator for your custom types to output debug information
    easily.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，阅读和理解日志非常容易。如果需要，您可以轻松地更改`StreamLogger`类以将日志写入文件系统中的文件。您可以添加任何其他您可能需要用于调试应用程序的信息，例如输出函数参数。您还可以轻松地重写自定义类型的左移操作符以输出调试信息。
- en: In this project, we employed many things that we have learned about during this
    chapter. We created an additional stream for thread-safe output, we formatted
    the output to the desired representation, we employed `std::stringstream` to perform
    formatting data, and we used macro definitions for convenient logger usage. Thus,
    this project demonstrates our skills in working with concurrent I/O.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们运用了本章学到的许多东西。我们为线程安全输出创建了一个额外的流，将输出格式化为所需的表示形式，使用`std::stringstream`来格式化数据，并使用宏定义方便地记录器使用。因此，这个项目展示了我们在处理并发I/O方面的技能。
- en: Chapter 7 - Everybody Falls, It's How You Get Back Up – Testing and Debugging
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章 - 每个人都会跌倒，重要的是如何重新站起来 - 测试和调试
- en: 'Activity 1: Checking the Accuracy of the Functions Using Test Cases and Understanding
    Test-Driven Development (TDD)'
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：使用测试用例检查函数的准确性并理解测试驱动开发（TDD）
- en: 'For this activity, we''ll develop the functions to parse the **RecordFile.txt**
    and **CurrencyConversion.txt** files and write test cases to check the accuracy
    of the functions. Follow these steps to implement this activity:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将开发函数来解析**RecordFile.txt**和**CurrencyConversion.txt**文件，并编写测试用例来检查函数的准确性。按照以下步骤实施此活动：
- en: Create a configuration file named **parse.conf** and write the configurations.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**parse.conf**的配置文件并编写配置。
- en: 'Note that only two variables are of interest here, that is, `currencyFile`
    and `recordFile`. The rest are meant for other environment variables:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，这里只有两个变量是感兴趣的，即`currencyFile`和`recordFile`。其余的是为其他环境变量准备的：
- en: '[PRE177]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Create a header file named `CommonHeader.h` and declare all the utility functions,
    that is, `isAllNumbers()`, `isDigit()`, `parseLine()`, `checkFile()`, `parseConfig()`,
    `parseCurrencyParameters()`, `fillCurrencyMap()`, `parseRecordFile()`, `checkRecord()`,
    `displayCurrencyMap()`, and `displayRecords()`.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CommonHeader.h`的头文件，并声明所有实用函数，即`isAllNumbers()`，`isDigit()`，`parseLine()`，`checkFile()`，`parseConfig()`，`parseCurrencyParameters()`，`fillCurrencyMap()`，`parseRecordFile()`，`checkRecord()`，`displayCurrencyMap()`和`displayRecords()`。
- en: '[PRE178]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Create a file named `trim()` function:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`trim()`函数的文件：
- en: '[PRE179]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Write the following code to define the `isAllNumbers()`, `isDigit()`, and `parseLine()`
    functions:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`isAllNumbers()`，`isDigit()`和`parseLine()`函数：
- en: '[PRE180]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Write the following code to define the `parseCurrencyParameters()` and `checkRecord()`
    functions:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`parseCurrencyParameters()`和`checkRecord()`函数：
- en: '[PRE181]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Write the following code to define the `checkFile()` function:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`checkFile()`函数：
- en: '[PRE182]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Write the following code to define `parseConfig()` function:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`parseConfig()`函数：
- en: '[PRE183]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Write the following code to define the `fillCurrencyMap()` function:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`fillCurrencyMap()`函数：
- en: '[PRE184]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Write the following code to define the `parseRecordFile()` function:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`parseRecordFile()`函数：
- en: '[PRE185]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Write the following code to define the `displayCurrencyMap()` function:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`displayCurrencyMap()`函数：
- en: '[PRE186]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Write the following code to define the `displayRecords()` function:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入以定义`displayRecords()`函数：
- en: '[PRE187]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Create a file named `parseConfig()`, `fillCurrencyMap()`, and `parseRecordFile()`
    functions:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`parseConfig()`，`fillCurrencyMap()`和`parseRecordFile()`函数的文件：
- en: '[PRE188]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Open the compiler. Compile and execute the `Util.o` and `ParseFiles` files
    have been generated:![Figure 7.25: New files generated'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编译器。编译并执行已生成的`Util.o`和`ParseFiles`文件：![图7.25：生成的新文件
- en: '](img/C14583_07_25.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_07_25.jpg)'
- en: 'Figure 7.25: New files generated'
  id: totrans-579
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.25：生成的新文件
- en: 'After running the `ParseFiles` executable, we''ll receive the following output:![Figure
    7.26: New files generated'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ParseFiles`可执行文件后，我们将收到以下输出：![图7.26：生成的新文件
- en: '](img/C14583_07_26.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_07_26.jpg)'
- en: 'Figure 7.26: New files generated'
  id: totrans-582
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.26：生成的新文件
- en: 'Create a file named `trim` function:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`trim`函数的文件：
- en: '[PRE189]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Write the following test cases for the `isAllNumbers` function:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`isAllNumbers`函数编写以下测试用例：
- en: '[PRE190]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Write the following test cases for the `isDigit` function:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`isDigit`函数编写以下测试用例：
- en: '[PRE191]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Write the following test cases for the `parseCurrencyParameters` function:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`parseCurrencyParameters`函数编写以下测试用例：
- en: '[PRE192]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Write the following test cases for the `checkFile` function:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`checkFile`函数编写以下测试用例：
- en: '[PRE193]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Note
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The **NoFile**, **emptyFile**, **noHeaderFile**, and **correctHeaderFile**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述函数中用作输入参数的**NoFile**，**emptyFile**，**noHeaderFile**和**correctHeaderFile**文件可以在此处找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01)。
- en: 'Write the following test cases for the `parseConfig` function:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`parseConfig`函数编写以下测试用例：
- en: '[PRE194]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Note
  id: totrans-597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The **parseMissingCurrency.conf**, **parseMissingRecord.conf**, and **parse.conf**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述函数中用作输入参数的**parseMissingCurrency.conf**，**parseMissingRecord.conf**和**parse.conf**文件可以在此处找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01)。
- en: 'Write the following test cases for the `fillCurrencyMap` function:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`fillCurrencyMap`函数编写以下测试用例：
- en: '[PRE195]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Note
  id: totrans-601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The **CurrencyWrongDelimiter.txt**, **CurrencyExtraColumn.txt**, and **CurrencyConversion.txt**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中用作输入参数的**CurrencyWrongDelimiter.txt**、**CurrencyExtraColumn.txt**和**CurrencyConversion.txt**文件可以在此处找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01)。
- en: 'Write the following test cases for the parseRecordFile function:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为parseRecordFile函数编写以下测试用例：
- en: '[PRE196]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The **RecordWrongDelimiter.txt**, **RecordExtraColumn.txt**, and **RecordFile.txt**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中用作输入参数的**RecordWrongDelimiter.txt**、**RecordExtraColumn.txt**和**RecordFile.txt**文件可以在此处找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01)。
- en: 'Open the compiler. Compile and execute the `Util.cpp` and `ParseFileTestCases.cpp`
    files by writing the following commands:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编译器。通过编写以下命令编译和执行`Util.cpp`和`ParseFileTestCases.cpp`文件：
- en: '[PRE197]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The following is a screenshot of this. You will see all the commands stored
    in `Test.make` script file. Once executed, it will create the binary program that
    was meant for unit testing called `ParseFileTestCases`. You will also notice that
    a directory has been created in Project called `unitTesting`. In this directory,
    all the unit testing-related code is written, and a binary file is created. Also,
    the dependent library of the project, `Util.o`, is also created by compiling the
    project in the `Util.cpp` file:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此的截图。您将看到所有命令都存储在`Test.make`脚本文件中。一旦执行，它将创建用于单元测试的二进制程序`ParseFileTestCases`。您还会注意到在Project中创建了一个名为`unitTesting`的目录。在此目录中，编写了所有与单元测试相关的代码，并创建了一个二进制文件。此外，还通过编译`Util.cpp`文件来创建项目的依赖库`Util.o`：
- en: '![](img/C14583_07_27.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_07_27.jpg)'
- en: 'Figure 7.27: Executing all commands present in the script file'
  id: totrans-610
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.27：执行脚本文件中的所有命令
- en: 'Type the following command to run all the test cases:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入以下命令以运行所有测试用例：
- en: '[PRE198]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The output on the screen will display the total tests running, that is, 31
    from 8 test suites. It will also display the statistics of individual test suites,
    along with pass/fail results:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的输出将显示总共31个测试运行，其中包括8个测试套件。它还将显示各个测试套件的统计信息，以及通过/失败的结果：
- en: '![Figure 7.28: All tests running properly'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.28：所有测试都正常运行'
- en: '](img/C14583_07_28.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_07_28.jpg)'
- en: 'Figure 7.28: All tests running properly'
  id: totrans-616
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.28：所有测试都正常运行
- en: 'Below is the screenshot of the next tests:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是下一个测试的截图：
- en: '![Figure 7.29: All tests running properly'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.29：所有测试都正常运行'
- en: '](img/C14583_07_29.jpg)'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_07_29.jpg)'
- en: 'Figure 7.29: All tests running properly'
  id: totrans-620
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.29：所有测试都正常运行
- en: Finally, we checked the accuracy of the functions that we developed by parsing
    two files with the help of our test cases. This will ensure that our project will
    be running fine when it's integrated with different functions/modules that have
    test cases.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过解析两个文件并使用我们的测试用例来检查我们开发的函数的准确性。这将确保我们的项目在与具有测试用例的不同函数/模块集成时能够正常运行。
- en: Chapter 8 - Need for Speed – Performance and Optimization
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章 - 需要速度 - 性能和优化
- en: 'Activity 1: Optimizing a Spell Check Algorithm'
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：优化拼写检查算法
- en: 'In this activity, we''ll be developing a simple spell check demonstration and
    try to make it faster incrementally. You can use the skeleton file, **Speller.cpp**,
    as a starting point. Perform the following steps to implement this activity:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将开发一个简单的拼写检查演示，并尝试逐步加快速度。您可以使用骨架文件**Speller.cpp**作为起点。执行以下步骤来实现此活动：
- en: 'For the first implementation of the spell check (the full code can be found
    in `getMisspelt()` function:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拼写检查的第一个实现（完整代码可以在`getMisspelt()`函数中找到：
- en: '[PRE199]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Loop over the text words and check for words not in the dictionary with the
    `set::count()` method. Add the misspelled words to the result vector:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历文本单词，并使用`set::count()`方法检查不在字典中的单词。将拼写错误的单词添加到结果向量中：
- en: '[PRE200]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Open the terminal. Compile the program and run it as follows:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。编译程序并按以下方式运行：
- en: '[PRE201]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The following output will be generated:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成以下输出：
- en: '![Figure 8.60: Example output of the solution for Step 1'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.60：第1步解决方案的示例输出'
- en: '](img/C14583_08_60.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_60.jpg)'
- en: 'Figure 8.60: Example output of the solution for Step 1'
  id: totrans-634
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.60：第1步解决方案的示例输出
- en: 'Open the `unordered_set` header file to the program:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开程序的`unordered_set`头文件：
- en: '[PRE202]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Next, change the set type that''s used for the dictionary to `unordered_set`:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将用于字典的集合类型更改为`unordered_set`：
- en: '[PRE203]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Open the Terminal. Compile the program and run it as follows:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。编译程序并按以下方式运行：
- en: '[PRE204]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The following output will be generated:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成以下输出：
- en: '![Figure 8.61: Example output of the solution for Step 2'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.61：第2步解决方案的示例输出'
- en: '](img/C14583_08_61.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_61.jpg)'
- en: 'Figure 8.61: Example output of the solution for Step 2'
  id: totrans-644
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.61：第2步解决方案的示例输出
- en: 'For the third and final version, that is, `BKDR` function. Add the following
    code to implement this:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第三个也是最终版本，即`BKDR`函数。添加以下代码来实现这一点：
- en: '[PRE205]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Here, we used an integer template parameter so that we can create any number
    of different hash functions with the same code. Notice the use of the `16777215`
    constant, which is equal to `2^24 – 1`. This lets us use the fast bitwise-and
    operator instead of the modulus operator to keep the hashed integer less than
    `SIZE`. If you want to change the size, keep it as one less than a power of two.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了整数模板参数，以便我们可以使用相同的代码创建任意数量的不同哈希函数。请注意使用`16777215`常量，它等于`2^24 - 1`。这使我们可以使用快速的按位与运算符，而不是模运算符，以使哈希整数小于`SIZE`。如果要更改大小，请将其保持为2的幂减一。
- en: 'Next, let''s declare a vector<bool> for a bloom filter in `getMisspelt()` and
    populate it with the words in the dictionary. Use three hash functions. The BKDR
    hash can be seeded with values such as `131`, `3131`, `31313`, and so on. Add
    the following code to implement this:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`getMisspelt()`中声明一个用于布隆过滤器的`vector<bool>`，并用字典中的单词填充它。使用三个哈希函数。BKDR哈希可以使用值如`131`、`3131`、`31313`等进行种子化。添加以下代码来实现这一点：
- en: '[PRE206]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Write the following code to create a loop that checks the words:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码创建一个检查单词的循环：
- en: '[PRE207]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The bloom filter is checked first and if it finds the word in the dictionary,
    we have to verify it, like we did previously.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查布隆过滤器，如果它在字典中找到了这个单词，我们必须像之前一样进行验证。
- en: 'Open the terminal. Compile the program and run it as follows:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。编译并运行程序如下：
- en: '[PRE208]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The following output will be generated:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成以下输出：
- en: '![Figure 8.62: Example output of the solution for Step 3'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.62：第3步解决方案的示例输出'
- en: '](img/C14583_08_62.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_62.jpg)'
- en: 'Figure 8.62: Example output of the solution for Step 3'
  id: totrans-658
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.62：第3步解决方案的示例输出
- en: 'In the preceding activity, we attempted to solve a real-world problem and make
    it more efficient. Let''s consider some points for each of the implementations
    in the three steps, as follows:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的活动中，我们试图解决一个现实世界的问题并使其更加高效。让我们考虑一下三个步骤中每个实现的一些要点，如下所示：
- en: For the first version, the most obvious solution with a `std::set` is used –
    however, the performance is likely to be low because the set data structure is
    based on a binary tree, which has `O(log N)` complexity for finding an element.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一个版本，使用`std::set`的最明显的解决方案是-但是，性能可能会较低，因为集合数据结构是基于二叉树的，查找元素的复杂度为`O(log N)`。
- en: For the second version, we can gain a large performance improvement simply by
    switching to `std::unordered_set`, which uses a hash table as the underlying data
    structure. If the hash function is good, the performance will be close to `O(1)`.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二个版本，我们可以通过切换到使用哈希表作为底层数据结构的`std::unordered_set`来获得很大的性能提升。如果哈希函数很好，性能将接近`O(1)`。
- en: The third version, based on the **Bloom filter** data structure, requires some
    consideration.-The primary performance benefit of a bloom filter is because it
    is a compact data structure that does not actually store the actual elements in
    it, thereby providing very good cache performance.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于**布隆过滤器**数据结构的第三个版本需要一些考虑。-布隆过滤器的主要性能优势在于它是一种紧凑的数据结构，实际上并不存储其中的实际元素，因此提供了非常好的缓存性能。
- en: 'From an implementation perspective, the following guidelines apply:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，以下准则适用：
- en: '`vector<bool>` can be used as the backing store as it is an efficient way to
    store and retrieve bits.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector<bool>`可以用作后备存储，因为这是一种高效存储和检索位的方式。'
- en: The false positive percentage of the bloom filter should be minimal – anything
    more than 5% will not be efficient.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布隆过滤器的假阳性百分比应该很小-超过5%将不高效。
- en: 'There are many string hashing algorithms – the **BKDR** hash algorithm is used
    in the reference implementation. A comprehensive of string hash algorithms with
    implementation can be found here: [http://www.partow.net/programming/hashfunctions/index.html](http://www.partow.net/programming/hashfunctions/index.html).'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多字符串哈希算法-参考实现中使用了**BKDR**哈希算法。可以在这里找到带有实现的字符串哈希算法的综合列表：[http://www.partow.net/programming/hashfunctions/index.html](http://www.partow.net/programming/hashfunctions/index.html)。
- en: The number of hash functions and the size for the bloom filter that's used are
    very critical to get the performance benefits.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所使用的哈希函数数量和布隆过滤器的大小对于获得性能优势非常关键。
- en: The nature of the dataset should be taken into account when deciding what parameters
    the bloom filter should use – consider that, in this example, there are very few
    words that are misspelled, and the majority of them are in the dictionary.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定布隆过滤器应该使用什么参数时，应考虑数据集的性质-请考虑，在这个例子中，拼写错误的单词很少，大部分都在字典中。
- en: 'There are some questions worth probing, given the results we received:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们收到的结果，有一些值得探讨的问题：
- en: Why is the improvement in performance so meager with the Bloom Filter?
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么布隆过滤器的性能改进如此微弱？
- en: What is the effect of using a larger or smaller capacity Bloom filter?
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更大或更小容量的布隆过滤器会有什么影响？
- en: What happens when fewer or more hash functions are used?
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用更少或更多的哈希函数时会发生什么？
- en: Under what conditions would this version be much faster than the one in **Speller2.cpp**?
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么条件下，这个版本比**Speller2.cpp**中的版本要快得多？
- en: 'Here are the answers to these questions:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些问题的答案：
- en: Why is the improvement in performance so meager with the Bloom Filter?
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么布隆过滤器的性能改进如此微弱？
- en: '`std::unordered_set` performs one hash operation and perhaps a couple of memory
    accesses before reaching the value that''s stored. The Bloom filter we use performs
    three hash operations and three memory accesses. So, in essence, the work that''s
    done by the bloom filter is more than the hash table. Since there are only 31,870
    words in our dictionary, the cache benefits of the Bloom filter are lost. This
    is another case where the traditional analysis of data structures does not correspond
    to real-life results because of caching.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set` 在达到存储的值之前执行一次哈希操作，可能还有几次内存访问。我们使用的布隆过滤器执行三次哈希操作和三次内存访问。因此，从本质上讲，布隆过滤器所做的工作比哈希表更多。由于我们的字典中只有31,870个单词，布隆过滤器的缓存优势就丧失了。这是另一个传统数据结构分析与现实结果不符的案例，因为缓存的原因。'
- en: What is the effect of using a larger or smaller capacity Bloom filter?
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更大或更小容量的布隆过滤器会有什么影响？
- en: When a larger capacity is used, the number of hash collisions reduce, along
    with false positives, but the caching behavior worsens. Conversely, when a smaller
    capacity is used, the hash collisions and the false positives increase, but the
    caching behavior improves.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用更大的容量时，哈希冲突的数量减少，假阳性也减少，但缓存行为变差。相反，当使用较小的容量时，哈希冲突和假阳性增加，但缓存行为改善。
- en: What happens when fewer or more hash functions are used?
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用更少或更多的哈希函数时会发生什么？
- en: The more hash functions are used, the fewer the false positives, and vice versa.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的哈希函数越多，误判就越少，反之亦然。
- en: Under what conditions would this version be much faster than the one in Speller2.cpp?
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么条件下，这个版本比Speller2.cpp中的版本快得多？
- en: Bloom filters work best when the cost of testing a few bits is less than the
    cost of accessing the value in the hash table. This only becomes true when the
    Bloom filter bits fit completely within the cache and the dictionary does not.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器在测试少量位的成本低于访问哈希表中的值的成本时效果最好。只有当布隆过滤器的位完全适合缓存而字典不适合时，这一点才成立。
