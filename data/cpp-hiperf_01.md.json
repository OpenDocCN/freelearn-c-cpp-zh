["```cpp\n// C version\nstruct string_elem_t { const char* str_; string_elem_t* next_; };\nint num_hamlet(string_elem_t* books) {\n  const char* hamlet = \"Hamlet\";\n  int n = 0;\n  string_elem_t* b; \n  for (b = books; b != 0; b = b->next_)\n    if (strcmp(b->str_, hamlet) == 0)\n      ++n;\n  return n;\n} \n```", "```cpp\n// C++ version\nint num_hamlet(const std::forward_list<std::string>& books) {\n  return std::count(books.begin(), books.end(), \"Hamlet\");\n} \n```", "```cpp\nclass Car {\npublic:\n  Car(int doors)\n      : doors_(doors) {}\nprivate:\n  int doors_{}; \n};\nauto some_func() {\n  auto num_doors = 2;\n  auto car1 = Car{num_doors};\n  auto car2 = Car{num_doors};\n  // ...\n} \n```", "```cpp\nclass Car {\n  public Car(int doors) { \n    doors_ = doors;\n  }\n  private int doors_;\n  static void some_func() {\n    int numDoors = 2;\n    Car car1 = new Car(numDoors);\n    Car car2 = new Car(numDoors);\n    // ...\n  }\n} \n```", "```cpp\nauto n = 4;\nauto cars = std::vector<Car>{};\ncars.reserve(n);\nfor (auto i=0; i<n;++i) {\n   cars.push_back(Car{2});\n} \n```", "```cpp\nint n = 4;\nArrayList<Car> cars = \n  new ArrayList<Car>();\nfor (int i=0; i<n; i++) {\n  cars.addElement(new Car(2));\n} \n```", "```cpp\n// C++\nclass Bagel {\npublic:\n  Bagel(std::set<std::string> ts) : toppings_(std::move(ts)) {}\nprivate:\n  std::set<std::string> toppings_;\n}; \n```", "```cpp\n// Java\nclass Bagel {\n  public Bagel(ArrayList<String> ts) { toppings_ = ts; }\n  private ArrayList<String> toppings_;\n} \n```", "```cpp\n// Note how the bagels do\n// not share toppings:\nauto t = std::set<std::string>{};\nt.insert(\"salt\");\nauto a = Bagel{t};\n// 'a' is not affected\n// when adding pepper\nt.insert(\"pepper\");\n// 'a' will have salt\n// 'b' will have salt & pepper \nauto b = Bagel{t};\n// No bagel is affected\nt.insert(\"oregano\"); \n```", "```cpp\n// Note how both the bagels\n// share toppings:\nTreeSet<String> t = \n  new TreeSet<String>();\nt.add(\"salt\");\nBagel a = new Bagel(t);\n// Now 'a' will subtly \n// also have pepper\nt.add(\"pepper\");\n// 'a' and 'b' share the\n// toppings in 't'\nBagel b = new Bagel(t);\n// Both bagels are affected\ntoppings.add(\"oregano\"); \n```", "```cpp\nclass Person {\npublic:\n  auto age() const { return age_; }\n  auto set_age(int age) { age_ = age; }\nprivate:\n  int age_{};\n}; \n```", "```cpp\nclass Team {\npublic:\n  auto& leader() const { return leader_; }\n  auto& leader() { return leader_; }\nprivate:\n  Person leader_{};\n}; \n```", "```cpp\nvoid nonmutating_func(const std::vector<Team>& teams) {\n  auto tot_age = 0;\n\n  // Compiles, both leader() and age() are declared const\n  for (const auto& team : teams) \n    tot_age += team.leader().age();\n  // Will not compile, set_age() requires a mutable object\n  for (auto& team : teams) \n    team.leader().set_age(20);\n} \n```", "```cpp\nvoid mutating_func(std::vector<Team>& teams) {\n  auto tot_age = 0;\n\n  // Compiles, const functions can be called on mutable objects\n  for (const auto& team : teams) \n    tot_age += team.leader().age();\n  // Compiles, teams is a mutable variable\n  for (auto& team : teams) \n    team.leader().set_age(20);\n} \n```", "```cpp\n// Java\nfloat getVolume1(Sphere s) {\n  float cube = Math.pow(s.radius(), 3);\n  return (Math.PI * 4 / 3) * cube; \n} \n```", "```cpp\n// Java\nfloat getVolume2(Sphere s) { \n  float rad = s == null ? 0.0f : s.radius();\n  float cube = Math.pow(rad, 3);\n  return (Math.PI * 4 / 3) * cube;\n} \n```", "```cpp\nauto get_volume1(const Sphere& s) {   \n  auto cube = std::pow(s.radius(), 3.f);\n  auto pi = 3.14f;\n  return (pi * 4.f / 3.f) * cube;\n} \n```", "```cpp\nauto get_volume2(const Sphere* s) {\n  auto rad = s ? s->radius() : 0.f;\n  auto cube = std::pow(rad, 3);\n  auto pi = 3.14f;\n  return (pi * 4.f / 3.f) * cube;\n} \n```"]