- en: Mixed-language Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合语言项目
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Building Fortran projects that use C/C++ libraries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建使用C/C++库的Fortran项目
- en: Building C/C++ projects that use Fortran libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建使用Fortran库的C/C++项目
- en: Building C++ and Python projects using Cython
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cython构建C++和Python项目
- en: Building C++ and Python projects using Boost.Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost.Python构建C++和Python项目
- en: Building C++ and Python projects using pybind11
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pybind11构建C++和Python项目
- en: Mixing C, C++, Fortran, and Python using Python CFFI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python CFFI混合C、C++、Fortran和Python
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'There are plenty of existing libraries that excel at very specific tasks. It''s
    generally a very good idea to reuse such libraries in our own codebases, because
    we can rely on years of experience from other groups of experts. As computer architectures
    and compilers evolve, so do programming languages. Whereas years ago most scientific
    software was written in Fortran, nowadays C, C++, and interpreted languages –
    first and foremost Python – are taking the center stage. It is indeed more and
    more common to integrate code written in a compiled language with bindings to
    an interpreted language, since it affords the following benefits:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多现有的库在特定任务上表现出色。通常，在我们的代码库中重用这些库是一个非常好的主意，因为我们可以依赖其他专家团队多年的经验。随着计算机架构和编译器的演变，编程语言也在发展。过去，大多数科学软件都是用Fortran编写的，而现在，C、C++和解释型语言——尤其是Python——正占据主导地位。将编译型语言编写的代码与解释型语言的绑定相结合变得越来越普遍，因为它提供了以下好处：
- en: End-users can customize and expand the capabilities offered by the code itself
    to fully suit their needs.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端用户可以自定义和扩展代码本身提供的能力，以完全满足他们的需求。
- en: One is able to combine the expressiveness of a language such as Python with
    the performance of a compiled language that is closer "to the metal" in terms
    of memory addressing, getting the best of both worlds.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们可以将Python等语言的表达力与编译型语言的性能相结合，这种编译型语言在内存寻址方面更接近“硬件层面”，从而获得两者的最佳效果。
- en: 'As we have consistently shown throughout the previous recipes, the `project`
    command can be used to set the languages used in the project *via* the `LANGUAGES`
    keyword. CMake has support for many – but not all – compiled programming languages.
    As of CMake 3.5, various flavors of assembly (such as ASM-ATT, ASM, ASM-MASM,
    and ASM-NASM), C, C++, Fortran, Java, RC (Windows Resource Compiler), and Swift
    are valid choices. CMake 3.8 added support for two more languages: C# and CUDA
    (see the release notes here: [https://cmake.org/cmake/help/v3.8/release/3.8.html#languages](https://cmake.org/cmake/help/v3.8/release/3.8.html#languages)).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的各个示例中一直展示的那样，`project`命令可以通过`LANGUAGES`关键字来设置项目中使用的语言。CMake支持多种编译型编程语言，但并非全部。截至CMake
    3.5版本，各种汇编语言（如ASM-ATT、ASM、ASM-MASM和ASM-NASM）、C、C++、Fortran、Java、RC（Windows资源编译器）和Swift都是有效选项。CMake
    3.8版本增加了对两种新语言的支持：C#和CUDA（详见此处发布说明：[https://cmake.org/cmake/help/v3.8/release/3.8.html#languages](https://cmake.org/cmake/help/v3.8/release/3.8.html#languages)）。
- en: In this chapter, we will show how to integrate codes written in different compiled
    (C, C++, and Fortran) and interpreted (Python) languages in a way that is portable
    and cross-platform. We will show how to leverage CMake and tools intrinsic to
    the different programming languages we aim to integrate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何将用不同编译型（C、C++和Fortran）和解释型（Python）语言编写的代码集成到一个可移植和跨平台的解决方案中。我们将展示如何利用CMake和不同编程语言固有的工具来实现集成。
- en: Building Fortran projects that use C/C++ libraries
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建使用C/C++库的Fortran项目
- en: 'The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-01) and
    has two examples: one mixing Fortran and C, and the other mixing Fortran and C++.
    The recipe is valid with CMake version 3.5 (and higher). Both versions of the
    recipe have been tested on GNU/Linux and macOS.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-01)找到，并包含两个示例：一个是混合Fortran和C，另一个是混合Fortran和C++。该示例适用于CMake
    3.5版本（及以上）。两个版本的示例都已在GNU/Linux和macOS上进行了测试。
- en: Fortran has a venerated history as the language of high-performance computing.
    Many numerical linear algebra libraries are still written primarily in Fortran,
    as are many big number-crunching packages that need to preserve compatibility
    with legacy code amassed in the past decades. Whereas Fortran presents a very
    natural syntax for handling numerical arrays, it is lacking when it comes to interaction
    with the operating system, primarily because an interoperability layer with C,
    the *de facto lingua franca* of computer programming, was not mandated until the
    release of the Fortran 2003 standard. This recipe will show how to interface a
    Fortran code with both C system libraries and custom C code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran作为高性能计算语言有着悠久的历史。许多数值线性代数库仍然主要用Fortran编写，许多需要与过去几十年积累的遗留代码保持兼容的大型数字处理软件包也是如此。虽然Fortran在处理数值数组时提供了非常自然的语法，但在与操作系统交互时却显得不足，主要是因为直到Fortran
    2003标准发布时，才强制要求与C语言（计算机编程的*事实上的通用语言*）的互操作层。本食谱将展示如何将Fortran代码与C系统库和自定义C代码接口。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As shown in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, we will structure our project as a tree. Each subdirectory has a `CMakeLists.txt`
    file with instructions pertaining to that directory. This allows us to confine
    as much information as possible within the leaf directories as in this example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)，*项目结构化*所示，我们将把项目结构化为树状。每个子目录都有一个`CMakeLists.txt`文件，其中包含与该目录相关的指令。这使我们能够尽可能地将信息限制在叶目录中，如下例所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our case, we have a `src` subdirectory containing the sources, including `bt-randomgen-example.f90`,
    our executable. Two further subdirectories, `interfaces` and `utils`, contain
    more source code that will be compiled into libraries.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有一个包含源代码的`src`子目录，包括我们的可执行文件`bt-randomgen-example.f90`。另外两个子目录，`interfaces`和`utils`，包含将被编译成库的更多源代码。
- en: 'The source code in the `interfaces` subdirectory shows how to wrap the backtrace
    C system library. For example, the `interface_backtrace.f90` contains:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`interfaces`子目录中的源代码展示了如何封装backtrace C系统库。例如，`interface_backtrace.f90`包含：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above example shows the use of the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了以下用法：
- en: The intrinsic `iso_c_binding` module, which ensures interoperability of Fortran
    and C types and functions.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`iso_c_binding`模块，确保了Fortran和C类型及函数的互操作性。
- en: The `interface` declaration, which binds the functions to symbols in a separate
    library.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface`声明，它将函数绑定到单独库中的符号。'
- en: The `bind(C)` attribute, which fixes name-mangling of the declared functions.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind(C)`属性，它固定了声明函数的名称混淆。'
- en: 'This subdirectory contains two more source files:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子目录包含另外两个源文件：
- en: '`randomgen.c`, which is a C source file that exposes a function, using the
    C standard `rand` function, to generate random integers within an interval.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randomgen.c`，这是一个C源文件，它使用C标准的`rand`函数公开一个函数，用于在区间内生成随机整数。'
- en: '`interface_randomgen.f90`, which wraps the C functions for use within a Fortran
    executable.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface_randomgen.f90`，它封装了用于Fortran可执行文件中的C函数。'
- en: How to do it
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We have four `CMakeLists.txt` instances to look at: one root and tree leaves.
    Let us start with the root `CMakeLists.txt`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个`CMakeLists.txt`实例需要查看：一个根目录和三个叶目录。让我们从根目录的`CMakeLists.txt`开始：
- en: 'We declare a mixed-language Fortran and C project:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个混合语言的Fortran和C项目：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We direct CMake to save static and shared libraries under the `lib` subdirectory
    of the build directory. Executables will be saved under `bin`, while Fortran compiled
    module files will be saved under `modules`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指示CMake在构建目录的`lib`子目录下保存静态和共享库。可执行文件将保存在`bin`下，而Fortran编译模块文件将保存在`modules`下：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we move on to the first leaf, `CMakeLists.txt`, by adding the `src` subdirectory:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们转到第一个叶目录，通过添加`src`子目录来编辑`CMakeLists.txt`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `src/CMakeLists.txt` file adds two more subdirectories:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`src/CMakeLists.txt`文件添加了另外两个子目录：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `interfaces` subdirectory, we do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`interfaces`子目录中，我们执行以下操作：
- en: 'We include the `FortranCInterface.cmake` module and verify that the C and Fortran
    compilers can talk properly to each other:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含了`FortranCInterface.cmake`模块，并验证C和Fortran编译器可以正确地相互通信：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we find the backtrace system library, since we want to use it within
    our Fortran code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们找到backtrace系统库，因为我们想在Fortran代码中使用它：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then create a shared library target with the source files for the backtrace
    wrapper, the random number generator, and its Fortran wrapper:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用回溯包装器、随机数生成器及其Fortran包装器的源文件创建一个共享库目标：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also set the link libraries for the newly generated library target. We use
    the `PUBLIC` attribute, so that additional targets linking to our libraries will
    see dependencies properly:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为新生成的库目标设置了链接库。我们使用`PUBLIC`属性，以便链接我们的库的其他目标能够正确看到依赖关系：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `utils` subdirectory, we have one more `CMakeLists.txt`. This is a one-liner:
    we create a new library target into which the source file in this subdirectory
    will be compiled. There are no dependencies for this target:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`子目录中，我们还有一个`CMakeLists.txt`。这是一个一行代码：我们创建一个新的库目标，该子目录中的源文件将被编译到这个目标中。这个目标没有依赖关系：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us return to `src/CMakeLists.txt`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`src/CMakeLists.txt`：
- en: 'We add an executable target, with `bt-randomgen-example.f90` as source file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个可执行目标，使用`bt-randomgen-example.f90`作为源文件：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we link the library targets, generated in the `CMakeLists.txt` leaf,
    into our executable target:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`CMakeLists.txt`叶中生成的库目标链接到我们的可执行目标：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**它是如何工作的**'
- en: 'Having identified the correct libraries to link to, we need to make sure that
    our program can correctly call the functions they define. Every compiler performs
    name mangling when generating machine code and, unfortunately, conventions for
    this operation are not universal, but compiler-dependent. `FortranCInterface`,
    which we have already encountered in [Chapter 3](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml),
    *Detecting External Libraries and Programs*, Recipe 4, *Detecting the BLAS and
    LAPACK math libraries*, checks the compatibility of the selected C compiler with
    the Fortran compiler. For our current purposes, name mangling is not really an
    issue. The Fortran 2003 standard defines a `bind` attribute for functions and
    subroutines that accepts an optional `name` argument. If this argument is provided,
    the compiler will generate symbols for those subroutines and functions using the
    name fixed by the programmers. For example, the backtrace function can be exposed
    to Fortran from C, preserving the name, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了要链接的正确库之后，我们需要确保我们的程序能够正确调用它们定义的函数。每个编译器在生成机器代码时都会执行名称重整，不幸的是，这项操作的约定并不是通用的，而是依赖于编译器。我们已经在《第3章》（c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml），*检测外部库和程序*，第4个配方，*检测BLAS和LAPACK数学库*中遇到的`FortranCInterface`，检查所选C编译器与Fortran编译器的兼容性。对于我们当前的目的，名称重整并不是真正的问题。Fortran
    2003标准为函数和子程序定义了一个`bind`属性，它接受一个可选的`name`参数。如果提供了这个参数，编译器将使用程序员固定的名称为这些子程序和函数生成符号。例如，回溯函数可以从C暴露给Fortran，保留名称，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is more
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**还有更多**'
- en: 'The CMake code in `interfaces/CMakeLists.txt` also showed that it is possible
    to create a library from source files in different languages. CMake is evidently
    able to do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`interfaces/CMakeLists.txt`中的CMake代码也表明，可以从不同语言的源文件创建库。显然，CMake能够执行以下操作：
- en: Discern which compiler to use to get object files from the listed source files.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定使用哪个编译器从列出的源文件获取目标文件。
- en: Select the linker appropriately to build a library (or executable) from these
    object files.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择适当的链接器来从这些目标文件构建库（或可执行文件）。
- en: 'How does CMake determine which compiler to use? Specifying the `LANGUAGES`
    option to the `project` command will let CMake check for working compilers for
    the given languages on your system. When a target is added with lists of source
    files, CMake will appropriately determine the compiler based on the file extension.
    Hence, files terminating with `.c` will be compiled to object files using the
    C compiler already determined, whereas files terminating with `.f90` (or `.F90`
    if they need preprocessing) will be compiled using the working Fortran compiler.
    Similarly for C++, the `.cpp` or `.cxx` extensions will trigger usage of the C++
    compiler. We have only listed some of the possible, valid file extensions for
    the C, C++, and Fortran languages, but CMake can recognize many more. What if
    the file extensions in your project are, for any reason, not among the ones that
    are recognized? The `LANGUAGE` source file property can be used to tell CMake
    which compiler to use on specific source files, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CMake如何确定使用哪个编译器？通过在`project`命令中指定`LANGUAGES`选项，CMake将检查您的系统上是否存在适用于给定语言的工作编译器。当添加目标并列出源文件时，CMake将根据文件扩展名适当地确定编译器。因此，以`.c`结尾的文件将使用已确定的C编译器编译为对象文件，而以`.f90`（或需要预处理的`.F90`）结尾的文件将使用工作的Fortran编译器进行编译。同样，对于C++，`.cpp`或`.cxx`扩展名将触发使用C++编译器。我们仅列出了C、C++和Fortran语言的一些可能的有效文件扩展名，但CMake可以识别更多。如果项目中的文件扩展名由于任何原因不在识别的扩展名之列，该怎么办？可以使用`LANGUAGE`源文件属性来告诉CMake在特定源文件上使用哪个编译器，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, what about the linker? How does CMake determine the linker language
    for targets? For targets that **do not mix** programming languages, the choice
    is straightforward: invoke the linker *via* the compiler command that was used
    to generate the object files. If the targets **do mix** programming languages,
    as in our example, the linker language is chosen based on that whose preference
    value is highest among the ones available in the language mix. With our example
    mixing Fortran and C, the Fortran language has higher preference than the C language
    and is hence used as linker language. When mixing Fortran and C++, it is the latter
    to have higher preference and is hence used as the linker language. Much as with
    the compiler language, we can force CMake to use a specific linker language for
    our target *via* the corresponding `LINKER_LANGUAGE` property on targets:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链接器呢？CMake如何确定目标的链接器语言？对于**不混合**编程语言的目标，选择很简单：通过用于生成对象文件的编译器命令调用链接器。如果目标**确实混合**了编程语言，如我们的示例，链接器语言的选择基于在语言混合中偏好值最高的那个。在我们的示例中混合了Fortran和C，Fortran语言的偏好高于C语言，因此被用作链接器语言。当混合Fortran和C++时，后者具有更高的偏好，因此被用作链接器语言。与编译器语言一样，我们可以通过在目标上设置相应的`LINKER_LANGUAGE`属性来强制CMake为我们的目标使用特定的链接器语言：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Building C/C++ projects that use Fortran libraries
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建使用Fortran库的C/C++项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-02) and
    has an example mixing C++, C, and Fortran. The recipe is valid with CMake version
    3.5 (and higher) and has been tested on GNU/Linux and macOS.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-02)找到，并提供了一个混合C++、C和Fortran的示例。该配方适用于CMake版本3.5（及以上），并在GNU/Linux和macOS上进行了测试。
- en: 'Recipe 4, *Detecting the BLAS and LAPACK math libraries,* in [Chapter 3](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml), *Detecting
    External Libraries and Programs*, showed how to detect BLAS and LAPACK linear
    algebra libraries, written in Fortran, and how to use them in C++ code. Here we
    will revisit this recipe, but this time from a different angle: focusing less
    on detecting the external libraries but rather discussing the aspect of mixing
    C++ and Fortran and the name mangling in more depth.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章的配方4，*检测BLAS和LAPACK数学库*，在[第3章](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml)，*检测外部库和程序*，展示了如何检测用Fortran编写的BLAS和LAPACK线性代数库，以及如何在C++代码中使用它们。在这里，我们将重新审视这个配方，但这次从不同的角度出发：更少关注检测外部库，而是更深入地讨论混合C++和Fortran以及名称修饰的方面。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will reuse the sources from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries*. Although we will not modify the actual implementation sources or header
    files, we will modify the project tree structure following the recommendations
    discussed in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, and arrive at the following source code structure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将重用来自[第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，食谱4，*检测BLAS和LAPACK数学库*的源代码。尽管我们不会修改实际的实现源文件或头文件，但我们将根据[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)，*项目结构*中讨论的建议修改项目树结构，并得出以下源代码结构：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we have collected all the wrappers to BLAS and LAPACK, which provide the
    `math` library under `src/math`. The main program is `linear-algebra.cpp`. All
    sources are thus organized under the `src` subdirectory. To localize the scope,
    we have also split the CMake code over three `CMakeLists.txt` files, which we
    will discuss now.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们收集了所有BLAS和LAPACK的包装器，它们在`src/math`下提供了`math`库。主程序是`linear-algebra.cpp`。所有源文件都组织在`src`子目录下。为了限定范围，我们将CMake代码拆分到三个`CMakeLists.txt`文件中，现在我们将讨论这些文件。
- en: How to do it
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'This project mixes C++, which is the language of the main program, Fortran,
    because this is the language the libraries are written in, and C, which is needed
    to wrap the Fortran subroutines. In the root `CMakeLists.txt` file, we need to
    do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目混合了C++（主程序的语言）、Fortran（因为这是库所写的语言）和C（需要用来包装Fortran子例程）。在根`CMakeLists.txt`文件中，我们需要执行以下操作：
- en: 'Declare the project as mixed-language and set the C++ standard:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目声明为混合语言并设置C++标准：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We use the `GNUInstallDirs` module to direct CMake to save static and shared
    libraries and the executable into standard directories. We also instruct CMake
    to place Fortran compiled module files under `modules`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`GNUInstallDirs`模块来指导CMake将静态和共享库以及可执行文件保存到标准目录中。我们还指示CMake将Fortran编译的模块文件放置在`modules`下：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then move on to the next leaf subdirectory:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们转到下一个叶子子目录：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The leaf file `src/CMakeLists.txt` adds yet another subdirectory, `math`, which
    contains the linear algebra wrappers. In  `src/math/CMakeLists.txt`, we need to
    do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/CMakeLists.txt`文件中，我们添加了另一个子目录`math`，其中包含了线性代数包装器。在`src/math/CMakeLists.txt`中，我们需要执行以下操作：
- en: 'We invoke `find_package` to get the location of the  BLAS and LAPACK libraries:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`find_package`来获取BLAS和LAPACK库的位置：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We include the `FortranCInterface.cmake` module and verify that the Fortran,
    C and, C++ compilers are compatible:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含`FortranCInterface.cmake`模块，并验证Fortran、C和C++编译器是否兼容：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need to generate preprocessor macros to take care of the name mangling
    of the BLAS and LAPACK subroutines. Once again, `FortranCInterface` comes to the
    rescue by generating a header file called `fc_mangle.h` in the current build directory:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要生成预处理器宏来处理BLAS和LAPACK子例程的名称修饰。再次，`FortranCInterface`通过在当前构建目录中生成一个名为`fc_mangle.h`的头文件来提供帮助：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we add a library with our sources for the BLAS and LAPACK wrappers. We
    also specify the directories where the header files and libraries are to be found.
    Notice the `PUBLIC` attribute, which will allow other targets depending on `math`
    to properly get their dependencies:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为BLAS和LAPACK包装器添加一个库，并指定头文件和库所在的目录。注意`PUBLIC`属性，它将允许依赖于`math`的其他目标正确获取其依赖项：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Stepping back to `src/CMakeLists.txt`, we finally add an executable target
    and link it to our `math` library of BLAS/LAPACK wrappers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`src/CMakeLists.txt`，我们最终添加了一个可执行目标，并将其链接到我们的BLAS/LAPACK包装器的`math`库：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Using `find_package`, we have identified the correct libraries to link to.
    As in the previous recipe, we need to make sure that our program can correctly
    call the functions they define. As in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries, *we face the problem of compiler-dependent name mangling of symbols.
    We use the `FortranCInterface` CMake module to check the compatibility of the
    selected C and C++ compilers with the Fortran compiler. We also use the `FortranCInterface_HEADER`
    function to generate a header file with macros to take care of name mangling of
    Fortran subroutines. This was achieved with the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`find_package`，我们已经确定了要链接的正确库。与之前的食谱一样，我们需要确保我们的程序能够正确调用它们定义的函数。在[第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，第4个食谱，*检测BLAS和LAPACK数学库*，我们面临编译器依赖的符号修饰问题。我们使用`FortranCInterface`
    CMake模块来检查所选C和C++编译器与Fortran编译器的兼容性。我们还使用`FortranCInterface_HEADER`函数来生成包含宏的头文件，以处理Fortran子程序的符号修饰。这是通过以下代码实现的：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This command will generate the `fc_mangle.h` header file with name-mangling
    macros, as inferred from the Fortran compiler, and save it into the current binary
    directory, `CMAKE_CURRENT_BINARY_DIR`. We were careful to set `CMAKE_CURRENT_BINARY_DIR` as
    an include path for our `math` target. Consider the following generated `fc_mangle.h`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成包含符号修饰宏的`fc_mangle.h`头文件，如Fortran编译器所推断，并将其保存到当前二进制目录`CMAKE_CURRENT_BINARY_DIR`。我们小心地将`CMAKE_CURRENT_BINARY_DIR`设置为`math`目标的包含路径。考虑以下生成的`fc_mangle.h`：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The compiler in this example uses underscores for mangling. Since Fortran is
    case-insensitive, the subroutine might appear in either lowercase or uppercase,
    justifying the need to pass both cases to the macro. Notice that CMake will also
    generate macros for mangling symbols hidden behind Fortran modules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的编译器使用下划线进行符号修饰。由于Fortran不区分大小写，子程序可能以小写或大写形式出现，因此需要将两种情况都传递给宏。请注意，CMake还将为隐藏在Fortran模块后面的符号生成修饰宏。
- en: Nowadays, many implementations of BLAS and LAPACK ship with a thin C layer wrapper
    around the Fortran subroutines. These wrappers have been standardized over the
    years and are called CBLAS and LAPACKE, respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多BLAS和LAPACK的实现都附带了一个围绕Fortran子程序的薄C层包装器。这些包装器多年来已经标准化，并分别称为CBLAS和LAPACKE。
- en: 'Since we have carefully organized the sources into a library target and an
    executable target, we should comment on the use of the `PUBLIC`, `INTERFACE`,
    and `PRIVATE` visibility attributes for the targets. These are essential for a
    clean CMake project structure. As with sources, include directories, compile definitions,
    and options, the meaning of these attributes remains the same when used in conjunction
    with `target_link_libraries`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将源文件仔细组织成一个库目标和一个可执行目标，我们应该对目标的`PUBLIC`、`INTERFACE`和`PRIVATE`可见性属性进行注释。这些对于清晰的CMake项目结构至关重要。与源文件一样，包含目录、编译定义和选项，当与`target_link_libraries`一起使用时，这些属性的含义保持不变：
- en: With the `PRIVATE` attribute, libraries will only be linked to the current target,
    but not to any other targets consuming it.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PRIVATE`属性，库将仅被链接到当前目标，而不会被链接到以它作为依赖的其他目标。
- en: With the `INTERFACE` attribute, libraries will only be linked to targets consuming
    the current target as a dependency.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`INTERFACE`属性，库将仅被链接到以当前目标作为依赖的目标。
- en: With the `PUBLIC` attribute, libraries will be linked to the current target
    and to any other target consuming it as a dependency.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PUBLIC`属性，库将被链接到当前目标以及任何以它作为依赖的其他目标。
- en: Building C++ and Python projects using Cython
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cython构建C++和Python项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-03) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-03)找到，并包含一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Cython is an optimizing static compiler that allows to write C extensions for
    Python. Cython is a very powerful tool and uses the extended Cython programming
    language (based on Pyrex). A typical use case for Cython is speeding up Python
    code, but it can also be used to interface C/C++ with Python *via* a Cython layer.
    In this recipe, we will focus on the latter use case and demonstrate how to interface C/C++
    and Python using Cython with the help of CMake.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Cython是一个优化的静态编译器，允许为Python编写C扩展。Cython是一个非常强大的工具，使用基于Pyrex的扩展Cython编程语言。Cython的一个典型用例是加速Python代码，但它也可以用于通过Cython层将C/C++与Python接口。在本食谱中，我们将专注于后一种用例，并演示如何使用CMake帮助下的Cython将C/C++和Python接口。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As an example, we will use the following C++ code (`account.cpp`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，我们将使用以下C++代码（`account.cpp`）：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code provides the following interface (`account.hpp`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码提供了以下接口（`account.hpp`）：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using this example code, we can create bank accounts that start with a balance
    of zero. We can deposit to and withdraw from an account and also query the account
    balance using `get_balance()`. The balance itself is a private member of the `Account`
    class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段示例代码，我们可以创建起始余额为零的银行账户。我们可以向账户存款和取款，也可以使用`get_balance()`查询账户余额。余额本身是`Account`类的私有成员。
- en: 'Our goal is to be able to interact with this C++ class directly from Python
    – in other words, on the Python side, we wish to be able to do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是能够直接从Python与这个C++类交互——换句话说，在Python方面，我们希望能够这样做：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To achieve this, we will need a Cython interface file (we will call this file `account.pyx`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一个Cython接口文件（我们将称这个文件为`account.pyx`）：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us look at how to generate the Python interface:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何生成Python接口：
- en: 'Our `CMakeLists.txt` starts out defining the CMake dependency, project name,
    and language:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`CMakeLists.txt`开始定义CMake依赖项、项目名称和语言：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On Windows, it is best not to keep the build type undefined, so that we can
    match the build type of this project with the build type of the Python environment.
    Here we default to the `Release` build type:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，最好不要让构建类型未定义，这样我们就可以使此项目的构建类型与Python环境的构建类型相匹配。这里我们默认使用`Release`构建类型：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this recipe, we will also require the Python interpreter:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本食谱中，我们还将需要Python解释器：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following CMake code will allow us to build the Python module:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下CMake代码将允许我们构建Python模块：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we define a test:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个测试：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`python_test` executes `test.py`, where we make a couple of deposits and withdrawals
    and verify the balances:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python_test`执行`test.py`，在其中我们进行了几次存款和取款，并验证了余额：'
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this, we are ready to configure, build, and test the code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，我们就可以配置、构建和测试代码了：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'In this recipe, we have interfaced Python and C++ using a relatively compact
    `CMakeLists.txt` file, but we have achieved this by using the `FindCython.cmake`
    and `UseCython.cmake` modules, which have been placed under `cmake-cython`. These
    modules are included using the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们通过一个相对紧凑的`CMakeLists.txt`文件实现了Python与C++的接口，但我们通过使用`FindCython.cmake`和`UseCython.cmake`模块实现了这一点，这些模块被放置在`cmake-cython`下。这些模块通过以下代码包含：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`FindCython.cmake` is included in `UseCython.cmake` and locates and defines `${CYTHON_EXECUTABLE}`.
    The latter module defines the `cython_add_module` and `cython_add_standalone_executable` functions,
    which can be used to create Python modules and standalone executables, respectively.
    Both modules have been downloaded from [https://github.com/thewtex/cython-cmake-example/tree/master/cmake](https://github.com/thewtex/cython-cmake-example/tree/master/cmake).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindCython.cmake`包含在`UseCython.cmake`中，并定位和定义`${CYTHON_EXECUTABLE}`。后一个模块定义了`cython_add_module`和`cython_add_standalone_executable`函数，这些函数可用于创建Python模块和独立可执行文件。这两个模块都已从[https://github.com/thewtex/cython-cmake-example/tree/master/cmake](https://github.com/thewtex/cython-cmake-example/tree/master/cmake)下载。'
- en: 'In this recipe, we use `cython_add_module` to create a Python module library.
    Note how we set the non-standard `CYTHON_IS_CXX` source file property to `TRUE`,
    so that the `cython_add_module` function will know to compile `pyx` as a C++ file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用`cython_add_module`来创建一个Python模块库。请注意，我们将非标准的`CYTHON_IS_CXX`源文件属性设置为`TRUE`，这样`cython_add_module`函数就会知道将`pyx`文件编译为C++文件：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The Python module is created inside `${CMAKE_CURRENT_BINARY_DIR}`, and in order
    for the Python `test.py` script to locate it, we pass the relevant path with a
    custom environment variable, which is used inside `test.py` to set the `PATH`
    variable. Note how the `COMMAND` is set to call the CMake executable itself to
    set the local environment right before executing the Python script. This affords
    us platform-independence and avoids polluting the environment with spurious variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块在`${CMAKE_CURRENT_BINARY_DIR}`内部创建，为了让Python `test.py`脚本能够找到它，我们通过自定义环境变量传递相关路径，该变量在`test.py`内部用于设置`PATH`变量。注意`COMMAND`是如何设置为调用CMake可执行文件本身以在执行Python脚本之前正确设置本地环境的。这为我们提供了平台独立性，并避免了用无关变量污染环境：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We should also take a look at the `account.pyx` file, which is the interface
    file between Python and C++ and describes the C++ interface:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该查看`account.pyx`文件，它是Python和C++之间的接口文件，描述了C++接口：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can see `except +` in the `Account` class constructor. This directive allows
    Cython to handle exceptions raised by the C++ code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Account`类构造函数中可以看到`except +`。这个指令允许Cython处理由C++代码引发的异常。
- en: 'The `account.pyx` interface file also describes the Python interface:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`account.pyx`接口文件还描述了Python接口：'
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see how the `cinit` constructor, the `__dealloc__` destructor, and the `deposit`
    and `withdraw` methods, are matched with the corresponding C++ implementation
    counterparts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`cinit`构造函数、`__dealloc__`析构函数以及`deposit`和`withdraw`方法是如何与相应的C++实现对应部分匹配的。
- en: To summarize, we have found a mechanism to couple Python and C++ by introducing
    a dependency on the Cython module. This module can preferably be installed by
    `pip` into a virtual environment or Pipenv, or by using Anaconda.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们找到了一种通过引入对Cython模块的依赖来结合Python和C++的机制。这个模块可以通过`pip`安装到虚拟环境或Pipenv中，或者使用Anaconda安装。
- en: There is more
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: C could be coupled analogously. If we wish to take advantage of constructors
    and destructors, we could write a thin C++ layer around the C interface.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C也可以类似地耦合。如果我们希望利用构造函数和析构函数，我们可以围绕C接口编写一个薄的C++层。
- en: 'Typed Memoryviews offer the interesting functionality to map and access memory
    buffers allocated by C/C++ directly in Python, without creating any overhead:
    [http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html](http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html).
    They make it possible to map NumPy arrays directly to C++ arrays.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Typed Memoryviews提供了有趣的功能，可以直接在Python中映射和访问由C/C++分配的内存缓冲区，而不会产生任何开销：[http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html](http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html)。它们使得可以直接将NumPy数组映射到C++数组。
- en: Building C++ and Python projects using Boost.Python
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Python构建C++和Python项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-04) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-04)找到，并包含一个C++示例。本节适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: The Boost libraries offer another popular alternative to interface C++ code
    with Python. This recipe will show how to use CMake for C++ projects that rely
    on Boost.Python to expose their functionality as a Python module. We will reuse
    the example from the previous recipe and attempt to interact with the same C++
    implementation (`account.cpp`) as in the Cython example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Boost库提供了另一种流行的选择，用于将C++代码与Python接口。本节将展示如何使用CMake为依赖于Boost.Python的C++项目构建，以便将它们的功能作为Python模块暴露出来。我们将重用前一节的示例，并尝试与Cython示例中的相同C++实现(`account.cpp`)进行交互。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'While we keep `account.cpp` unchanged, we modify the interface file from the
    previous recipe (`account.hpp`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们保持`account.cpp`不变，但我们修改了前一节的接口文件(`account.hpp`)：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How to do it
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'These are the required steps to use Boost.Python with your C++ project:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Boost.Python与您的C++项目所需的步骤：
- en: 'As in the previous recipe, we start by defining the minimum version, the project
    name, supported language, and the default build type:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前一节一样，我们首先定义最小版本、项目名称、支持的语言和默认构建类型：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this recipe, we depend on the Python and Boost libraries as well as the
    Python interpreter for testing. The name of the Boost.Python component depends
    on the Boost version and the Python version, so we probe a couple of possible
    component names:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本配方中，我们依赖于Python和Boost库以及Python解释器进行测试。Boost.Python组件的名称取决于Boost版本和Python版本，因此我们探测几个可能的组件名称：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With the following commands, we define the Python module and its dependencies:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令，我们定义了Python模块及其依赖项：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we define a test for this implementation:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为这个实现定义了一个测试：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The code can now be configured, compiled, and tested:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以配置、编译和测试代码：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Instead of depending on the Cython module, this recipe now depends on locating
    the Boost libraries on the system, in combination with the Python development
    headers and library.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖Cython模块不同，本配方现在依赖于在系统上定位Boost库，以及Python开发头文件和库。
- en: 'The Python development headers and library are searched for with the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令搜索Python开发头文件和库：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note how we first searched for the interpreter and then for the development
    headers and libraries. Moreover, the search for `PythonLibs` asks for the exact
    same major and minor versions for the development headers and libraries as were
    found for the interpreter. This is necessary for ensuring that consistent versions
    of interpreter and libraries are used throughout the project. However, this command
    combination will not guarantee that an exactly matching version of the two will
    be found.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们首先搜索解释器，然后搜索开发头文件和库。此外，对`PythonLibs`的搜索要求开发头文件和库的相同主要和次要版本与解释器发现的版本相同。这是为了确保在整个项目中使用一致的解释器和库版本。然而，这种命令组合并不能保证会找到完全匹配的两个版本。
- en: 'When locating the Boost.Python component, we have met the difficulty that the
    name of the component that we try to locate depends both on the Boost version
    and our Python environment. Depending on the Boost version, the component can
    be called `python`, `python2`, `python3`, `python27`, `python36`, `python37`,
    and so on. We have solved this problem by searching from specific to more generic
    names and only failing if no match can be located:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在定位Boost.Python组件时，我们遇到了一个难题，即我们尝试定位的组件名称取决于Boost版本和我们的Python环境。根据Boost版本，组件可以称为`python`、`python2`、`python3`、`python27`、`python36`、`python37`等。我们通过从特定到更通用的名称进行搜索，并且只有在找不到匹配项时才失败来解决这个问题：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Discovery and usage of the Boost libraries can be tweaked by setting additional
    CMake variables. For example, CMake offers the following options:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置额外的CMake变量来调整Boost库的发现和使用。例如，CMake提供以下选项：
- en: '`Boost_USE_STATIC_LIBS` can be set to `ON` to force the use of the static version
    of the Boost libraries.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost_USE_STATIC_LIBS`可以设置为`ON`以强制使用Boost库的静态版本。'
- en: '`Boost_USE_MULTITHREADED` can be set to `ON` to ensure that the multithreaded
    version is picked up and used.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost_USE_MULTITHREADED`可以设置为`ON`以确保选择并使用多线程版本。'
- en: '`Boost_USE_STATIC_RUNTIME` can be set to `ON` such that our targets will use
    the variant of Boost that links the C++ runtime statically.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost_USE_STATIC_RUNTIME`可以设置为`ON`，以便我们的目标将使用链接C++运行时静态的Boost变体。'
- en: 'Another new aspect introduced by this recipe is the use of the `MODULE` option
    to the `add_library` command. We already know from Recipe 3, *Building and linking
    shared and static libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From
    a Simple Executable to Libraries*, that CMake accepts the following options as
    valid second argument to `add_library`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方引入的另一个新方面是在`add_library`命令中使用`MODULE`选项。我们从第3个配方，*构建和链接共享和静态库*，在[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单可执行文件到库*中已经知道，CMake接受以下选项作为`add_library`的第二个有效参数：
- en: '`STATIC`, to create static libraries; that is, archives of object files for
    use when linking other targets, such as executables'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATIC`，用于创建静态库；即，用于链接其他目标（如可执行文件）的对象文件的档案'
- en: '`SHARED`, to create shared libraries; that is, libraries that can be linked
    dynamically and loaded at runtime'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHARED`，用于创建共享库；即，可以在运行时动态链接和加载的库'
- en: '`OBJECT`, to create object libraries; that is, object files without archiving
    them into a static library, nor linking them into a shared object'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJECT`，用于创建对象库；即，不将对象文件归档到静态库中，也不将它们链接成共享对象'
- en: 'The `MODULE` option introduced here will generate a *plugin library;* that
    is, a Dynamic Shared Object (DSO) that is not linked dynamically into any executable,
    but can still be loaded at runtime. Since we are extending Python with our own
    functionality written in C++, the Python interpreter will need to be able to load
    our library at runtime. This can be achieved by using the `MODULE` option to `add_library`
    and by preventing the addition of any prefix (for example, `lib` on Unix systems)
    to the name of our library target. The latter operation is carried out by setting
    the appropriate target property, like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入的`MODULE`选项将生成一个*插件库*；也就是说，一个动态共享对象（DSO），它不会被动态链接到任何可执行文件中，但仍然可以在运行时加载。由于我们正在用自己编写的C++功能扩展Python，Python解释器将需要在运行时能够加载我们的库。这可以通过使用`add_library`的`MODULE`选项并阻止在我们的库目标名称中添加任何前缀（例如，Unix系统上的`lib`）来实现。后者操作是通过设置适当的target属性来完成的，如下所示：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'One aspect of all recipes that demonstrate the interfacing of Python and C++
    is that we need to describe to the Python code how to hook up to the C++ layer
    and to list the symbols which should be visible to Python. We also have the possibility
    to (re)name these symbols. In the previous recipe, we did this in a separate `account.pyx`
    file. When using `Boost.Python`, we describe the interface directly in the C++
    code, ideally close to the definition of the class or function we wish to interface:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有展示Python和C++接口的示例都有一个共同点，那就是我们需要向Python代码描述如何与C++层连接，并列出应该对Python可见的符号。我们还可以（重新）命名这些符号。在前面的示例中，我们在一个单独的`account.pyx`文件中完成了这一点。当使用`Boost.Python`时，我们直接在C++代码中描述接口，最好靠近我们希望接口的类或函数的定义：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `BOOST_PYTHON_MODULE` template is included from `<boost/python.hpp>` and
    is responsible for creating the Python interface. The module will expose an `Account`
    Python class that maps to the C++ class. In this case, we do not have to explicitly
    declare a constructor and destructor – these are created for us and called automatically
    when the Python object is created:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_PYTHON_MODULE`模板包含在`<boost/python.hpp>`中，负责创建Python接口。该模块将暴露一个`Account`
    Python类，该类映射到C++类。在这种情况下，我们不必显式声明构造函数和析构函数——这些会为我们自动创建，并在Python对象创建时自动调用：'
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The destructor is called when the object goes out of scope and is collected
    by the Python garbage collection. Also, observe how `BOOST_PYTHON_MODULE` exposes
    the `deposit`, `withdraw`, and `get_balance` functions, and maps them to the corresponding
    C++ class methods.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象超出作用域并被Python垃圾回收机制收集时，析构函数会被调用。同时，注意`BOOST_PYTHON_MODULE`是如何暴露`deposit`、`withdraw`和`get_balance`这些函数，并将它们映射到相应的C++类方法上的。
- en: 'This way, the compiled module can be found by Python when placed in `PYTHONPATH`.
    In this recipe, we have achieved a relatively clean separation between the Python
    and C++ layers. The Python code is not restricted in functionality, does not require
    type annotation or rewriting of names, and remains *pythonic*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，编译后的模块可以在`PYTHONPATH`中找到。在本示例中，我们实现了Python和C++层之间相对干净的分离。Python代码在功能上不受限制，不需要类型注释或重命名，并且保持了*pythonic*：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There is more
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'In this recipe, we rely on Boost being installed on the system and so the CMake
    code tries to detect the corresponding library. Alternatively, we could have shipped
    the Boost sources together with our project and build this dependency as part
    of the project. Boost is a portable way to interface Python with C(++). The portability
    with respect to compiler support and C++ standard however comes at a price: Boost.Python
    is not a lightweight dependency. In the following recipe, we will discuss a lightweight
    alternative to Boost.Python.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们依赖于系统上已安装的Boost，因此CMake代码尝试检测相应的库。或者，我们可以将Boost源代码与我们的项目一起打包，并将此依赖项作为项目的一部分进行构建。Boost是一种便携式的方式，用于将Python与C++接口。然而，考虑到编译器支持和C++标准的可移植性，Boost.Python并不是一个轻量级的依赖。在下面的示例中，我们将讨论Boost.Python的一个轻量级替代方案。
- en: Building C++ and Python projects using pybind11
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pybind11构建C++和Python项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-05) and
    has a C++ example. The recipe is valid with CMake version 3.11 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-05)找到，并包含一个C++示例。该示例适用于CMake版本3.11（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'In the previous recipe, we have used Boost.Python to interface Python with
    C(++). In this recipe, we will try to interface Python with C++ using pybind11
    as a lightweight alternative that makes use of C++11 features and therefore requires
    a compiler with C++11 support. As an additional variation to the previous recipe
    we will demonstrate how to fetch the pybind11 dependency at configure time and
    build our project including a Python interface using the FetchContent approach,
    which we met in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, Recipe 3, *Define a unit test and linking against Google Test,*
    and discussed in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The
    Superbuild Pattern*, Recipe 4, *Managing dependencies with a superbuild: III.
    The Google Test framework*. In [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging
    Projects*, Recipe 2, *Distributing a C++/Python project built with CMake/pybind11
    via PyPI*, we will revisit this example and show how to package it and make it
    installable with pip.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们使用了Boost.Python来实现Python与C(++)的接口。在这个示例中，我们将尝试使用pybind11作为轻量级替代方案，该方案利用了C++11特性，因此需要支持C++11的编译器。与前一个示例相比，我们将展示如何在配置时获取pybind11依赖项，并使用我们在[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*，示例3，*定义单元测试并与Google
    Test链接*中遇到的FetchContent方法构建我们的项目，包括Python接口，并在[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*，示例4，*使用超级构建管理依赖项：III.
    Google Test框架*中进行了讨论。在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*，示例2，*通过PyPI分发使用CMake/pybind11构建的C++/Python项目*中，我们将重新访问此示例，并展示如何打包它并通过pip安装。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will keep `account.cpp` unchanged with respect to the previous two recipes
    and only modify `account.hpp`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持`account.cpp`相对于前两个示例不变，只修改`account.hpp`：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We will follow the pybind11 documentation "Building with CMake" ([https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake](https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake))
    and introduce the pybind11 CMake code using `add_subdirectory`. However, we will
    not place the pybind11 source code explicitly into our project directory, but
    rather demonstrate how to fetch pybind11 sources at configure time using `FetchContent`
    ([https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循pybind11文档中的“使用CMake构建”指南（[https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake](https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake)），并介绍使用`add_subdirectory`添加pybind11的CMake代码。然而，我们不会将pybind11源代码明确放入我们的项目目录中，而是演示如何在配置时使用`FetchContent`（[https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)）获取pybind11源代码。
- en: 'For better code reuse in the next recipe, we will also place all sources into
    a subdirectory and use the following project layout:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在下一个示例中更好地重用代码，我们还将所有源代码放入子目录中，并使用以下项目布局：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us analyze in detail the contents of the various `CMakeLists.txt` files
    in this project:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析这个项目中各个`CMakeLists.txt`文件的内容：
- en: 'The root `CMakeLists.txt` file contains the familiar header:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根目录的`CMakeLists.txt`文件包含熟悉的头部信息：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this file, we also query the Python interpreter that will be used for testing:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，我们还查询将用于测试的Python解释器：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We then include the account subdirectory:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们包含账户子目录：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After that, we define the unit test:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义单元测试：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inside `account/CMakeLists.txt`, we fetch pybind11 sources at configure time:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`account/CMakeLists.txt`文件中，我们在配置时获取pybind11源代码：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we define the Python module. Once again we use the `MODULE` option
    to `add_library`. We also set the prefix and suffix properties for our library
    target to the values `PYTHON_MODULE_PREFIX` and `PYTHON_MODULE_EXTENSION`, which
    are appropriately inferred by pybind11:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义Python模块。再次使用`add_library`的`MODULE`选项。我们还为我们的库目标设置前缀和后缀属性为`PYTHON_MODULE_PREFIX`和`PYTHON_MODULE_EXTENSION`，这些属性由pybind11适当地推断出来：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let us test it out:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The functionality and use of pybind11 is very similar to Boost.Python, the
    bonus being that pybind11 is a more lightweight dependency – although we will
    require C++11 support from the compiler. The interface definition in `account.hpp`
    is rather similar to that in the previous recipe:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: pybind11的功能和使用与Boost.Python非常相似，不同的是pybind11是一个更轻量级的依赖项——尽管我们需要编译器的C++11支持。在`account.hpp`中的接口定义与前一个示例中的定义相当相似：
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Again, we can clearly recognize how Python methods are mapped to C++ functions.
    The library that interprets `PYBIND11_MODULE` is defined in the imported target
    `pybind11::module`, which we have included using the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以清楚地看到Python方法是如何映射到C++函数的。解释`PYBIND11_MODULE`的库在导入的目标`pybind11::module`中定义，我们使用以下方式包含它：
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There are two differences with respect to the previous recipe:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方相比，有两个不同之处：
- en: We do not require pybind11 to be installed on the system and therefore do not
    try to locate it.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不要求系统上安装了pybind11，因此不会尝试定位它。
- en: The `${pybind11_sources_SOURCE_DIR}` subdirectory, which contains pybind11 `CMakeLists.txt`,
    does not exist when we start building our project.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目开始构建时，包含pybind11 `CMakeLists.txt`的`${pybind11_sources_SOURCE_DIR}`子目录并不存在。
- en: 'One solution for this challenge is to use the `FetchContent` module, which
    fetches the pybind11 sources and CMake infrastructure at configure time so that
    we can reference it using `add_subdirectory`. Using the `FetchContent` pattern,
    we can now assume that pybind11 is available within the build tree, which allows
    us to build and link the Python module:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此挑战的一种方法是使用`FetchContent`模块，该模块在配置时获取pybind11源代码和CMake基础设施，以便我们可以使用`add_subdirectory`引用它。采用`FetchContent`模式，我们现在可以假设pybind11在构建树中可用，这使得我们能够构建并链接Python模块。
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We use the following command to make sure that the Python module library gets
    a well-defined prefix and suffix, compatible with the Python environment:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令确保Python模块库获得一个与Python环境兼容的定义良好的前缀和后缀：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The rest of the top-level `CMakeLists.txt` file is testing (we use the same `test.py` as
    in the previous recipe).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级`CMakeLists.txt`文件的其余部分用于测试（我们使用与前一个配方相同的`test.py`）。
- en: There is more
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: We could have included the pybind11 sources as part of our project source code
    repository, which would simplify the CMake structure and remove the requirement to
    have network access to the pybind11 sources at compile time. Alternatively, we
    could have defined the pybind11 source path as a Git submodule ([https://git-scm.com/book/en/v2/Git-Tools-Submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules))
    to simplify the updating of the pybind11 source dependency.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将pybind11源代码作为项目源代码仓库的一部分，这将简化CMake结构并消除在编译时需要网络访问pybind11源代码的要求。或者，我们可以将pybind11源路径定义为Git子模块（[https://git-scm.com/book/en/v2/Git-Tools-Submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules)），以简化更新pybind11源依赖关系。
- en: In our example, we have solved this using `FetchContent`, which provides a very
    compact approach to referencing a CMake subproject without explicitly tracking
    its sources. Also, we could have solved this recipe using the so-called superbuild
    approach (see [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The Superbuild
    Pattern*).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用`FetchContent`解决了这个问题，它提供了一种非常紧凑的方法来引用CMake子项目，而无需显式跟踪其源代码。此外，我们还可以使用所谓的超级构建方法来解决这个问题（参见[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*The
    Superbuild Pattern*）。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To see how you can expose simple functions, define docstrings, map memory buffers,
    and find further reading, we refer to the pybind11 documentation: [https://pybind11.readthedocs.io](https://pybind11.readthedocs.io).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解如何暴露简单函数、定义文档字符串、映射内存缓冲区以及获取更多阅读材料，请参考pybind11文档：[https://pybind11.readthedocs.io](https://pybind11.readthedocs.io)。
- en: Mixing C, C++, Fortran, and Python using Python CFFI
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python CFFI混合C、C++、Fortran和Python
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06) and
    has C++ and Fortran examples. The recipes are valid with CMake version 3.5 (and
    higher). Both versions of the recipe have been tested on GNU/Linux, macOS, and
    Windows.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06)找到，并包含C++和Fortran示例。这些配方适用于CMake版本3.5（及更高版本）。这两个版本的配方已在GNU/Linux、macOS和Windows上进行了测试。
- en: In the previous three recipes, we have discussed Cython, Boost.Python, and pybind11
    as tools to interface Python and C++ providing a modern and clean approach. The
    main interface in the previous recipes was a C++ interface. However, we may be
    in a situation where we do not have a C++ interface to hook on to and where we
    would like to interface Python with Fortran or other languages.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个菜谱中，我们讨论了Cython、Boost.Python和pybind11作为连接Python和C++的工具，提供了一种现代且清晰的方法。在前面的菜谱中，主要接口是C++接口。然而，我们可能会遇到没有C++接口可供连接的情况，这时我们可能希望将Python与Fortran或其他语言连接起来。
- en: In this recipe, we will demonstrate an alternative approach for interfacing
    Python using the Python C Foreign Function Interface (CFFI; see also [https://cffi.readthedocs.io](https://cffi.readthedocs.io)).
    Since C is the *lingua franca* of programming languages and most programming languages
    (including Fortran) are able to talk to a C interface, Python CFFI is a tool to
    couple Python with a large number of languages. A very nice feature of Python
    CFFI is that the resulting interface is thin and non-intrusive, meaning that it
    neither restricts the Python layer in language features, nor does it impose any
    restrictions on the code below the C layer, apart from requiring a C interface.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将展示一种使用Python C Foreign Function Interface（CFFI；另见[https://cffi.readthedocs.io](https://cffi.readthedocs.io)）的替代方法来连接Python。由于C是编程语言的*通用语*，大多数编程语言（包括Fortran）都能够与C接口通信，Python
    CFFI是一种将Python与大量语言连接的工具。Python CFFI的一个非常好的特点是，生成的接口是薄的且不侵入的，这意味着它既不限制Python层的语言特性，也不对C层以下的代码施加任何限制，除了需要一个C接口。
- en: In this recipe, we will apply Python CFFI to couple Python and C++ *via* a C
    interface using the bank account example introduced in preceding recipe. Our goal
    is to arrive at a context-aware interface where we can instantiate several bank
    accounts, each carrying its internal state. We will conclude this recipe by commenting
    on how to couple Python and Fortran using Python CFFI. In [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging
    Projects*, Recipe 3, *Distributing a C/Fortran/Python project built with CMake/CFFI
    via PyPI*, we will revisit this example and show how to package it and make it
    installable with pip.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将应用Python CFFI通过C接口将Python和C++连接起来，使用在前述菜谱中介绍的银行账户示例。我们的目标是实现一个上下文感知的接口，可以实例化多个银行账户，每个账户都携带其内部状态。我们将通过本菜谱结束时对如何使用Python
    CFFI将Python与Fortran连接进行评论。在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*，菜谱3，*通过CMake/CFFI构建的C/Fortran/Python项目通过PyPI分发*，我们将重新审视这个示例，并展示如何打包它，使其可以通过pip安装。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will require a couple of files for this recipe. Let us start with the C++
    implementation and interface. We will place these in a subdirectory called `account/implementation`.
    The implementation file (`cpp_implementation.cpp`) is similar to that in previous
    recipes but contains additional `assert` statements, since we will keep the state
    of the object in an opaque handle and we will have to make sure that the object
    is created before we try to access it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要几个文件来完成这个菜谱。让我们从C++实现和接口开始。我们将把这些文件放在一个名为`account/implementation`的子目录中。实现文件（`cpp_implementation.cpp`）与之前的菜谱类似，但包含了额外的`assert`语句，因为我们将在一个不透明的句柄中保持对象的状态，并且我们必须确保在尝试访问它之前创建了对象：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The interface file (`cpp_implementation.hpp`) contains the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接口文件（`cpp_implementation.hpp`）包含以下内容：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In addition, we isolate a C—C++ interface (`c_cpp_interface.cpp`). This will
    be the interface we will try to hook into with Python CFFI:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们隔离了一个C—C++接口（`c_cpp_interface.cpp`）。这将是我们尝试使用Python CFFI连接的接口：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'One directory up, under `account`, we describe the C interface (`account.h`):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`account`目录下，我们描述了C接口（`account.h`）：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We also describe the Python interface, which we will comment on below (`__init__.py`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还描述了Python接口，我们将在下面进行评论（`__init__.py`）：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is a handful of files, but, as we will see, most of this interface work
    is generic and reusable and the actual interface is rather thin. To summarize,
    this is the layout of our project:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一堆文件，但是，正如我们将看到的，大部分接口工作是通用的和可重用的，实际的接口相当薄。总之，这是我们项目的布局：
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How to do it
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us now use CMake to combine these files to form a Python module:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用CMake将这些文件组合成一个Python模块：
- en: 'The top-level `CMakeLists.txt` file contains a familiar header. In addition,
    we also set the location of our compiled library according to GNU standards:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶层`CMakeLists.txt`文件包含一个熟悉的标题。此外，我们还根据GNU标准设置了编译库的位置：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The second step is to include definitions for interfaces and implementation
    sources under the `account` subdirectory, which we will detail further down:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是在 `account` 子目录下包含接口定义和实现源代码，我们将在下面详细介绍：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The top-level `CMakeLists.txt` file concludes with the definition of a test
    (which requires the Python interpreter):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶层的 `CMakeLists.txt` 文件以定义测试（需要 Python 解释器）结束：
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The included `account/CMakeLists.txt` defines the shared library:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含的 `account/CMakeLists.txt` 定义了共享库：
- en: '[PRE80]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then we generate a portable export header:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们生成一个可移植的导出头文件：
- en: '[PRE81]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we are ready to take the Python—C interface for a spin:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好了对 Python—C 接口进行测试：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'While the previous recipes required us to explicitly declare the Python—C interface
    and to map Python names to C(++) symbols, Python CFFI infers this mapping on its
    own from the C header file (in our case, `account.h`). The only thing we need
    to provide to our Python CFFI layer is the header file describing the C interface
    and a shared library containing the symbols. We have done this using environment
    variable set in the main `CMakeLists.txt` file, and these environment variables
    are queried in `__init__.py`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例要求我们显式声明 Python—C 接口并将 Python 名称映射到 C(++) 符号，但 Python CFFI 会根据 C 头文件（在我们的例子中是
    `account.h`）自动推断此映射。我们只需要向 Python CFFI 层提供描述 C 接口的头文件和包含符号的共享库。我们已经在主 `CMakeLists.txt`
    文件中使用环境变量完成了此操作，并在 `__init__.py` 中查询了这些环境变量：
- en: '[PRE83]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `get_lib_handle` function opens and parses the header file (using `ffi.cdef`),
    loads the library (using `ffi.dlopen`), and returns the library object. The preceding
    file is in principle generic, and can be reused without modification for other
    projects interfacing Python and C or other languages using Python CFFI.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_lib_handle` 函数打开并解析头文件（使用 `ffi.cdef`），加载库（使用 `ffi.dlopen`），并返回库对象。前面的文件原则上具有通用性，可以不经修改地重用于其他连接
    Python 和 C 或其他使用 Python CFFI 语言的项目。'
- en: 'The `_lib` library object could be exported directly, but we do one additional
    step so that the Python interface feels more *pythonic* when used Python-side:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`_lib` 库对象可以直接导出，但我们又多做了一步，以便在 Python 端使用时 Python 接口感觉更 *pythonic*：'
- en: '[PRE84]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With this change, we can write the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个改动，我们可以这样写：
- en: '[PRE85]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The alternative would be less intuitive:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法则不那么直观：
- en: '[PRE86]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note how we are able to instantiate and track isolated contexts with our context-aware
    API:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们能够使用上下文感知的 API 实例化和跟踪隔离的上下文：
- en: '[PRE87]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In order to import the `account` Python module, we need to provide the `ACCOUNT_HEADER_FILE` and `ACCOUNT_LIBRARY_FILE` environment
    variables, as we do for the test:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导入 `account` Python 模块，我们需要提供 `ACCOUNT_HEADER_FILE` 和 `ACCOUNT_LIBRARY_FILE`
    环境变量，就像我们为测试所做的那样：
- en: '[PRE88]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging Projects*,
    we will discuss how to create a Python package that can be installed with pip
    where the header and library files will be installed in well-defined locations
    so that we do not have to define any environment variables to use the Python module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)《打包项目》中，我们将讨论如何创建一个可以使用
    pip 安装的 Python 包，其中头文件和库文件将安装在定义良好的位置，这样我们就不必定义任何环境变量来使用 Python 模块。
- en: 'Having discussed the Python aspect of the interface, let us now consider the
    C-side of the interface. The essence of `account.h` is this section:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了接口的 Python 方面之后，现在让我们考虑接口的 C 方面。`account.h` 的本质是这一部分：
- en: '[PRE89]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The opaque handle, `account_context`, holds the state of the object. `ACCOUNT_API`
    is defined in `account_export.h`, which is generated by CMake in `account/interface/CMakeLists.txt`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 不透明的句柄 `account_context` 保存对象的状态。`ACCOUNT_API` 在 `account_export.h` 中定义，该文件由
    CMake 在 `account/interface/CMakeLists.txt` 中生成：
- en: '[PRE90]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `account_export.h` export header defines the visibility of the interface
    functions and makes sure this is done in a portable way. We will discuss this
    point in further detail in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*. The actual implementation can be found in `cpp_implementation.cpp`.
    It contains the `is_initialized` boolean, which we can check to make sure that
    API functions are called in the expected order: the context should not be accessed
    before it is created or after it is freed.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`account_export.h` 导出头文件定义了接口函数的可见性，并确保以可移植的方式完成。我们将在 [第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)《编写安装程序》中更详细地讨论这一点。实际的实现可以在
    `cpp_implementation.cpp` 中找到。它包含 `is_initialized` 布尔值，我们可以检查该值以确保 API 函数按预期顺序调用：上下文不应在创建之前或释放之后被访问。'
- en: There is more
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'When designing a Python—C interface, it is important to carefully consider
    on which side to allocate arrays: arrays can be allocated either on the Python
    side and passed to the C(++) implementation, or they can be allocated on the C(++)
    implementation that returns a pointer. The latter approach is convenient for situations
    where the buffer sizes are *a priori* not known. However, returning pointers to
    arrays allocated C(++)-side can be problematic since it can lead to memory leaks
    due to Python garbage collection, which does not "see" the allocated arrays. We
    recommend to design the C API such that arrays can be allocated outside and passed
    to the C implementation. These arrays can then be allocated within `__init__.py`,
    as in this example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Python-C接口时，重要的是要仔细考虑在哪一侧分配数组：数组可以在Python侧分配并传递给C(++)实现，或者可以在C(++)实现中分配并返回一个指针。后一种方法在缓冲区大小*事先*未知的情况下很方便。然而，从C(++)-侧返回分配的数组指针可能会导致内存泄漏，因为Python的垃圾回收不会“看到”已分配的数组。我们建议设计C
    API，使得数组可以在外部分配并传递给C实现。然后，这些数组可以在`__init__.py`内部分配，如本例所示：
- en: '[PRE91]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `return_array` function returns a Python list. Since we have done all the
    allocation work on the Python side, we do not have to worry about memory leaks
    and can leave the cleanup to the garbage collection.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`return_array`函数返回一个Python列表。由于我们已经在Python侧完成了所有的分配工作，因此我们不必担心内存泄漏，可以将清理工作留给垃圾回收。'
- en: 'For a Fortran example, we refer the reader to the following recipe repository: [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06/fortran-example](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06/fortran-example).
    The main difference compared to the C++ implementation is that the account library
    is compiled from a Fortran 90 source file that we account for in `account/CMakeLists.txt`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fortran示例，我们建议读者参考以下配方仓库：[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06/fortran-example](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06/fortran-example)。与C++实现的主要区别在于，账户库是由Fortran
    90源文件编译而成，我们在`account/CMakeLists.txt`中对此进行了考虑：
- en: '[PRE92]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The context is kept in a user-defined type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文保存在用户定义的类型中：
- en: '[PRE93]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The Fortran implementation is able to resolve symbols and methods defined in
    the unchanged `account.h` by using the `iso_c_binding` module:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran实现能够通过使用`iso_c_binding`模块解析未更改的`account.h`中定义的符号和方法：
- en: '[PRE94]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: See also
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe and solution has been inspired by Armin Ronacher's post, "Beautiful
    Native Libraries", [http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/](http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方和解决方案的灵感来源于Armin Ronacher的帖子“Beautiful Native Libraries”，[http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/](http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/)。
