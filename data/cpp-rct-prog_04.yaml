- en: Asynchronous and Lock-Free Programming in C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的异步和无锁编程
- en: In the previous chapter, we looked at the threading library introduced by Modern
    C++ and various ways to create, manage, and synchronize threads. The way of writing
    code with threads is a rather low level and is prone to potential errors associated
    with concurrent code (deadlock, live-lock, and so on). Even though it is not noticed
    by many programmers, the Modern C++ language provides a standard memory model
    that helps to write concurrent code better. To be a concurrent programming language
    from the ground up, a language has to provide certain guarantees to the developer
    regarding memory access and the order in which things will be executed during
    runtime. If we are using constructs such as mutexes, condition variables, and
    futures to signal events, one doesn't need to be aware of the memory model. But
    awareness of the memory model and its guarantees will help us write faster concurrent
    code using lock-free programming techniques. Locks can be simulated using something
    called atomic operations, and we will look at this technique in depth.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了现代C++引入的线程库以及创建、管理和同步线程的各种方法。使用线程编写代码的方式是相当低级的，并且容易出现与并发代码相关的潜在错误(死锁、活锁等)。尽管许多程序员没有注意到，但现代C++语言提供了一个标准的内存模型，有助于更好地编写并发代码。作为一种并发编程语言，语言必须向开发人员提供有关内存访问和运行时执行顺序的某些保证。如果我们使用诸如互斥锁、条件变量和futures来发出信号事件，就不需要了解内存模型。但是了解内存模型及其保证将有助于我们使用无锁编程技术编写更快的并发代码。锁可以使用称为原子操作的东西来模拟，我们将深入研究这种技术。
- en: As we discussed in [Chapter 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml),
    *A Tour of Modern C++ and its Key Idioms*, zero-cost abstraction remains one of
    the most fundamental principles of the C++ programming language. C++ is always
    a system programmer's language, and the standard committee managed to strike a
    good balance between higher-level abstraction mechanisms supported by the language
    and the ability to access lower-level resources to write system programs. C++
    exposes atomic types and a set of associated operations to have fine-grained control
    over the execution of programs. The standard committee has published detailed
    semantics of the memory model, and the language has a set of libraries that help
    programmers to exploit them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml)中讨论的，零成本抽象仍然是C++编程语言最基本的原则之一。C++始终是系统程序员的语言，标准委员会设法在语言支持的高级抽象机制和访问低级资源以编写系统程序的能力之间取得良好的平衡。C++公开了原子类型和一组相关操作，以对程序的执行进行细粒度控制。标准委员会已经发布了内存模型的详细语义，语言还有一组库，帮助程序员利用它们。
- en: 'In the previous chapter, we learned how to synchronize actions in separate
    threads using condition variables. This chapter discusses the facilities provided
    by the standard library to perform task-based parallelism using *futures*. In
    this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用条件变量在单独的线程中同步操作。本章讨论了标准库提供的设施，使用*futures*执行基于任务的并行性。在本章中，我们将涵盖：
- en: Task-based parallelism in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的基于任务的并行性
- en: The C++ memory model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++内存模型
- en: Atomic types and atomic operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子类型和原子操作
- en: Synchronizing operations and memory ordering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步操作和内存排序
- en: How to write a lock-free data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写无锁数据结构
- en: Task-based parallelism in C++
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的基于任务的并行性
- en: 'A *task* is a computation that can be potentially executed concurrently with
    other computations. A thread is a system-level representation of a task. In the
    previous chapter, we learned how to execute a task concurrently with other tasks
    launched by constructing an `std::thread` object with the task as its argument
    to the constructor. A task can be any callable object such as a function, Lambda,
    or a functor. But this approach of executing a function concurrently using `std::thread`
    is called a *thread-based approach*. The preferred choice for concurrent execution
    is a *task-based approach*, and this will be discussed in this chapter. The advantage
    of a task-based approach over a thread-based approach is to operate at the (higher)
    conceptual level of tasks rather than directly at the lower level of threads and
    locks. Task-based parallelism is achieved by following standard library features:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是一种计算，可以与其他计算同时执行。线程是任务的系统级表示。在上一章中，我们学习了如何通过构造一个`std::thread`对象并将任务作为其构造函数的参数来并发执行任务，同时还可以启动其他任务。任务可以是任何可调用对象，如函数、Lambda或仿函数。但是使用`std::thread`并发执行函数的方法称为*基于线程的方法*。并发执行的首选选择是*基于任务的方法*，本章将讨论这一点。基于任务的方法优于基于线程的方法的优势在于在任务的(更高)概念级别上操作，而不是直接在线程和锁的较低级别上操作。通过遵循标准库特性实现了基于任务的并行性：
- en: Future and promise for returning a value from a task associated with a separate
    thread
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于从与单独线程相关联的任务返回值的future和promise
- en: '`packaged_task` to help launch tasks and provide a mechanism for returning
    a result'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packaged_task`用于帮助启动任务并提供返回结果的机制'
- en: '`async()` for launching a task similar to a function call'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async()`用于启动类似函数调用的任务'
- en: Future and promise
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Future和promise
- en: The C++ tasks often behave like a data channel of sorts. The sending end, often
    called promise, sends data to a receiving end, often called the **future**. The
    important notion about futures and promises is that they enable a transfer of
    values between two tasks without the explicit use of a lock. The transfer of values
    is handled by the system (runtime) itself. The basic concept behind **future** and
    **promise** is simple; when a task wants to pass a value into another, it puts
    the value into a **promise**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++任务通常表现得像一种数据通道。发送端通常称为promise，将数据发送到接收端，通常称为**future**。关于future和promise的重要概念是它们使两个任务之间的值传输无需显式使用锁。值的传输由系统(运行时)本身处理。**future**和**promise**背后的基本概念很简单；当一个任务想要将一个值传递到另一个任务时，它将该值放入一个**promise**中。
- en: 'A standard library makes sure that the future associated with this promise
    gets this value. The other task can read this value from this **future** (the
    following diagram has to be read from the right to the left):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库确保与此承诺相关联的未来获得此值。另一个任务可以从这个**future**中读取这个值（下面的图表必须从右向左阅读）：
- en: '![](img/8fe6fd77-da39-41be-9e63-f72a5e88eb24.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fe6fd77-da39-41be-9e63-f72a5e88eb24.png)'
- en: The future comes in handy if a calling thread needs to wait for a specific *one-off
    event*. The future representing this event makes itself available to the calling
    thread, and the calling thread can access the value once the future is ready (when
    a value is set to a corresponding promise). During its execution, a future may
    have data associated with it or not. Once the event occurs, data will be available
    in the future and it can't be reset.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用线程需要等待特定的*一次性事件*，则future非常方便。代表此事件的future使自身对调用线程可用，并且一旦future准备就绪（当值设置为相应的promise时），调用线程就可以访问该值。在执行期间，future可能具有与之关联的数据，也可能没有。一旦事件发生，future中将可用数据，并且无法重置。
- en: 'The template classes associated with task-based parallelism are declared inside
    the library header `<future>`. There are two sorts of futures available in the
    standard library: unique futures (`std::future<>`) and shared futures (`std::shared_future<>`).
    You can correlate these with the smart pointers `std::unique_ptr<>` and `std::shared_ptr<>`*,*
    respectively. The `std::future` instance refers to the one and only instance of
    the associated event. On the contrary, multiple instances of `std::shared_future`
    may point to the same event. In the case of `shared_future`, all the instances
    associated with a common event will become ready at the same time and they may
    access the data associated with the event. The template parameter is the associated
    data, and the `std::future<void>` and `std::shared_future<void>` template specifications
    should be used if there is no data associated with it. Even though data communication
    between threads is managed internally by futures, the future objects themselves
    don''t provide synchronized access. If multiple threads need to access a single
    `std::future` object, they must be protected with mutexes or other synchronization
    mechanisms.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于任务的并行性相关的模板类在库头文件`<future>`中声明。标准库中有两种类型的future：独占future（`std::future<>`）和共享future（`std::shared_future<>`）。您可以将这些与智能指针`std::unique_ptr<>`和`std::shared_ptr<>`*相对应。`std::future`实例指的是与关联事件的唯一实例。相反，多个`std::shared_future`实例可能指向同一事件。在`shared_future`的情况下，与共同事件关联的所有实例将同时准备就绪，并且它们可以访问与事件关联的数据。模板参数是关联数据，如果没有与之关联的数据，则应使用`std::future<void>`和`std::shared_future<void>`模板规范。尽管线程之间的数据通信由future在内部管理，但future对象本身不提供同步访问。如果多个线程需要访问单个`std::future`对象，则必须使用互斥锁或其他同步机制进行保护。
- en: 'The classes `std::future` and `std::promise` work in pairs to separate task
    invocation and wait for results. For an `std::future<T>` object `f`, we can access
    the value `T` associated with it using the `std::future` class function `get()`.
    Similarly for an `std::promise<T>`, there are two put operation functions available
    with it (`set_value()` and `set_exception()`) to match the future''s `get()`.
    For a promise object, you can either give it a value by using `set_value()` or
    pass an exception to it using `set_exception()`. For example, the following pseudo
    code helps you see how the values are set in the promise (in `func1`) and how
    things are consumed in the function where invocation to `future<T>:: get()` is
    invoked (`func2`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::future`和`std::promise`类成对工作，分别用于任务调用和等待结果。对于`std::future<T>`对象`f`，我们可以使用`std::future`类的`get()`函数访问与之关联的值`T`。类似地，对于`std::promise<T>`，它有两个可用的放置操作函数（`set_value()`和`set_exception()`）与之匹配future的`get()`。对于promise对象，您可以使用`set_value()`给它一个值，或者使用`set_exception()`传递异常给它。例如，以下伪代码帮助您看到如何在promise中设置值（在`func1`中），以及在调用`future<T>::
    get()`的函数中如何消耗这些值（`func2`）：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding case, the *val* of type `T` is set to promise *pr* after processing
    and obtaining a result. If any exception happens during the execution, the exception
    is also set to promise. Now, let''s see how to access the value you set:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，处理和获取结果后，类型为`T`的*val*被设置为promise *pr*。如果执行期间发生任何异常，异常也将被设置为promise。现在，让我们看看如何访问您设置的值：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the value set in the corresponding promise is accessed using the future
    passed as an argument. The `get()` function associated with `std::future()` retrieves
    the value stored during the execution of the task. The call to `get()` must be
    prepared to catch the exception transmitted through the future and handle it.
    After explaining `std::packaged_task`, we will show a complete example where futures
    and promises work together in action.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用作为参数传递的future来访问相应承诺中设置的值。与`std::future()`相关联的`get()`函数在任务执行期间检索存储的值。调用`get()`必须准备捕获通过future传递的异常并处理它。在解释完`std::packaged_task`之后，我们将展示一个完整的示例，其中future和promise共同发挥作用。
- en: std::packaged_task
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::packaged_task
- en: 'Now, let''s discuss how we get a return value associated with a future into
    your code that needs results. The `std::packaged_task` is a template class that
    is available in the standard library to achieve task-based parallelism with the
    help of futures and promises. By setting up futures and promises in threads, it
    simplifies setting up a task without any explicit locks for sharing the result.
    A `packaged_task` instance provides a wrapper over `std::thread` to put the return
    value or exception caught into a promise. The member function `get_future()` in
    `std::packaged_task` will give you the future instance associated with the corresponding
    promise. Let''s look at an example that uses a packaged task to find the sum of
    all elements in a vector (the working of promise is deep inside the implementation
    of `packaged_task`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何将与future关联的返回值引入到需要结果的代码中。`std::packaged_task`是标准库中提供的一个模板类，用于通过future和promise实现基于任务的并行处理。通过在线程中设置future和promise，它简化了设置任务而无需为共享结果设置显式锁。`packaged_task`实例提供了一个包装器，用于将返回值或捕获的异常放入promise中。`std::packaged_task`中的成员函数`get_future()`将为您提供与相应promise关联的future实例。让我们看一个示例，该示例使用packaged
    task来找到向量中所有元素的总和（promise的工作深入到`packaged_task`的实现中）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `packaged_task` object takes the type of task as its template argument and
    the function pointer (`calc_sum`) as a constructor argument. The future instance
    is obtained through the call to the `get_future()` function of the task object.
    The explicit `std::move()` is used since the `packaged_task` instances cannot
    be copied. This is because it is a resource handle and is responsible for whatever
    resources its task may own. Then, a call to the `get()` function picks up the
    result from the task and prints it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`packaged_task`对象以任务类型作为其模板参数，并以函数指针（`calc_sum`）作为构造函数参数。通过调用任务对象的`get_future()`函数获得future实例。由于`packaged_task`实例无法复制，因此使用显式的`std::move()`。这是因为它是一个资源句柄，并负责其任务可能拥有的任何资源。然后，调用`get()`函数从任务中获取结果并打印它。'
- en: 'Now, let''s see how `packaged_task` can be used along with Lambdas:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`packaged_task`如何与Lambda一起使用：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, instead of a function pointer, a Lambda is passed into the constructor
    of `packaged_task`. As you have already seen in previous chapters, for a small
    block of code to run concurrently, Lambdas come in handy. The primary notion behind
    futures is to be able to get results without having any concern for the mechanisms
    for managing communication. Also, these two operations are running in two different
    threads and thus are parallel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`packaged_task`的构造函数中传递了一个Lambda，而不是函数指针。正如您在之前的章节中已经看到的，对于并发运行的小代码块，Lambda非常方便。future的主要概念是能够获得结果，而不必担心通信管理的机制。此外，这两个操作在两个不同的线程中运行，因此是并行的。
- en: std::async
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::async`'
- en: 'Modern C++ provides a mechanism to execute a task like a function that might
    or might not execute in parallel. Here, we are referring to `std::async`*,* which
    manages the threading detail internally. `std::async` takes a callable object
    as its argument and returns an `std::future` that will store the result or exception
    from the task that has been launched. Let''s rewrite our previous example to calculate
    the sum of all elements from a vector using `std::async`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++提供了一种执行任务的机制，就像执行可能或可能不会并行执行的函数一样。在这里，我们指的是`std::async`，它在内部管理线程细节。`std::async`以可调用对象作为其参数，并返回一个`std::future`，该对象将存储已启动任务的结果或异常。让我们重新编写我们之前的示例，使用`std::async`计算向量中所有元素的总和：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Primarily, when using `std::async` for task-based parallelism, the launch of
    a task and fetching result from the task are following straightforward syntax and
    well-separated with task execution. In the preceding code, `std::async` is taking
    three arguments:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是，当使用`std::async`进行基于任务的并行处理时，任务的启动和从任务中获取结果遵循直观的语法，并且与任务执行分开。在前面的代码中，`std::async`接受三个参数：
- en: The `async` flag determines the launch policy of the `async` task and `std::launch::async`,
    meaning that `async` executes the task on a new thread of execution. The `std::launch::deferred` flag
    doesn't spawn a new thread, but *lazy evaluation* is performed. If both the flags
    are set as in `std::launch::async` and `std::launch::deferred`, it is up to the
    implementation as to whether to perform an asynchronous execution or lazy evaluation.
    If you explicitly don't pass any launch policy into `std::async`, it is again
    up to the implementation to choose the method of execution.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`标志确定了`async`任务的启动策略，`std::launch::async`表示`async`在新的执行线程上执行任务。`std::launch::deferred`标志不会生成新线程，但会执行*延迟评估*。如果两个标志都设置为`std::launch::async`和`std::launch::deferred`，则由实现决定是执行异步执行还是延迟评估。如果您没有显式地传递任何启动策略到`std::async`中，那么再次由实现选择执行方法。'
- en: The second argument to the `std::async` is a callable object, and it can be
    a function pointer, function object, or a Lambda. In this example, the `calc_sum` function
    is the task that gets executed in a separate thread.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::async`的第二个参数是可调用对象，可以是函数指针、函数对象或Lambda。在这个例子中，`calc_sum`函数是在单独的线程中执行的任务。'
- en: The third argument is the input parameter to the task. Generally, that is a
    variadic argument and it can pass the number of parameters required for a task
    callable object.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是任务的输入参数。通常，这是一个可变参数，可以传递任务可调用对象所需的参数数量。
- en: 'Now, let''s see how `async` and Lambda go together for the same example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`async`和Lambda如何一起用于相同的示例：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the callable object argument has a Lambda function inside it,
    which returns the result of `std::accumulate()`. As always, simple operations
    along with the Lambda beautify the code's overall appearance and improve readability.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可调用对象参数中包含一个Lambda函数，该函数返回`std::accumulate()`的结果。与往常一样，Lambda与简单操作一起美化了代码的整体外观并提高了可读性。
- en: Using `async`, you don't have to think about threads and locks. But just think
    in terms of tasks that do the computations asynchronously, and that you don't
    know how many threads will be used because that's up to the internal implementation
    to decide based on the system resources available at the time of calling. It checks
    for the idle cores (processors) that are available before deciding how many threads
    to use. This points to the obvious limitation with `async` in that it needs to
    be employed for tasks that share resources needing locks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async`，你不必考虑线程和锁。只需考虑异步执行计算的任务，你不知道会使用多少线程，因为这取决于内部实现根据调用时可用的系统资源来决定。它在决定使用多少线程之前会检查可用的空闲核心（处理器）。这指出了`async`的明显局限性，即需要用于共享资源并需要锁的任务。
- en: C++ memory model
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++内存模型
- en: 'The classic C++ was essentially a single threaded language. Even though people
    were writing multithread programs in C++, they were using respective platform
    threading facilities to write them. Modern C++ can be considered a concurrent
    programming language. The language standard provides a standard thread and task
    mechanism (as we have already seen) with the help of standard libraries. Since
    it is a part of the standard library, the language specification has defined how
    things should behave across the platform in a precise manner. Having a consistent
    platform-agnostic behavior for threads, tasks, and so on is a massive challenge
    that the standard committee handled really well. The committee designed and specified
    a standard memory model for achieving consistent behavior while the program is
    running. The memory model consists of two aspects:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的C++本质上是一种单线程语言。即使人们在C++中编写多线程程序，他们也是使用各自平台的线程设施来编写它们。现代C++可以被认为是一种并发编程语言。语言标准提供了一个标准的线程和任务机制（正如我们已经看到的），借助于标准库。由于它是标准库的一部分，语言规范已经定义了在平台上如何精确地行为。在程序运行时实现一致的平台无关行为对于线程、任务等是一个巨大的挑战，标准委员会处理得非常好。委员会设计并指定了一个标准内存模型，以实现一致的行为。内存模型包括两个方面：
- en: '**Structural** aspects, which relate to how data is laid out in memory'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**方面，涉及数据在内存中的布局。'
- en: '**Concurrency** aspects, which deal with the concurrent access of memory'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**方面，涉及内存的并发访问'
- en: For a C++ program, all data is made up of *objects*. The language defines an
    object as a *region of storage*, which is defined with its type and lifetime.
    Objects can be an instance of a fundamental type such as an int or double, or
    instances of user-defined types. Some objects may have sub objects, but others
    don't. The key point is that every variable is an object, including the members'
    objects of other objects, and every object occupies at least some memory location.
    Now, let's take a look at what this has to do with concurrency.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++程序，所有数据都由*对象*组成。语言将对象定义为*存储区域*，它以其类型和生命周期进行定义。对象可以是基本类型的实例，如int或double，也可以是用户定义类型的实例。一些对象可能有子对象，但其他对象则没有。关键点是每个变量都是一个对象，包括其他对象的成员对象，每个对象都至少占用一些内存位置。现在，让我们看看这与并发有什么关系。
- en: Memory access and concurrency
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存访问和并发
- en: For multithread applications, everything hangs on those memory locations. If
    multiple threads access different memory locations, everything works fine. But
    if two threads access the same memory location, then you must be very careful.
    As you have seen in [Chapter 3](16bbadb9-c545-44b1-8edb-82ab82a83394.xhtml), *Language-Level
    Concurrency and Parallelism in C++*, multiple threads trying to read from the
    same memory location introduce no trouble, but as soon as any thread tries to
    modify data in a common memory location, chances for *race conditions* to occur
    come into the frame.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多线程应用程序，一切都取决于那些内存位置。如果多个线程访问不同的内存位置，一切都正常。但如果两个线程访问相同的内存位置，那么你必须非常小心。正如你在[第3章](16bbadb9-c545-44b1-8edb-82ab82a83394.xhtml)中看到的那样，*C++中的语言级并发和并行性*，多个线程尝试从相同的内存位置读取不会引起问题，但只要任何一个线程尝试修改共同的内存位置中的数据，就会出现*竞争条件*的可能性。
- en: The problematic race conditions can only be avoided by enforced ordering between
    the access in multiple threads. As discussed in [Chapter 3](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40), *Language-Level
    Concurrency and Parallelism in C++*, lock-based memory access using mutexes is
    a popular option. The other way is to leverage the synchronization properties
    of *atomic operations* by enforcing ordering between the access in two threads.
    In later sections of this chapter, you will see the use of atomic operations to
    enforce ordering.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 问题性的竞争条件只能通过在多个线程之间强制排序访问来避免。如[第3章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40)中所讨论的，*C++中的语言级并发和并行性*，使用互斥锁进行基于锁的内存访问是一种流行的选择。另一种方法是利用*原子操作*的同步属性，通过在两个线程之间强制排序访问。在本章的后面部分，你将看到使用原子操作来强制排序的示例。
- en: Atomic operation appears to the rest of the system and occurs at once without
    being interrupted (no task switch happens during atomic operation) in concurrent
    programming. Atomicity is a guarantee of isolation from interrupts, signals, concurrent
    processes, and threads. More can be read on this topic at the Wikipedia article
    at [https://en.wikipedia.org/wiki/Linearizability](https://en.wikipedia.org/wiki/Linearizability).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作在并发编程中对系统的其余部分是立即发生的，不会被中断（在原子操作期间不会发生任务切换）。原子性是对中断、信号、并发进程和线程的隔离的保证。关于这个主题可以在维基百科的文章[https://en.wikipedia.org/wiki/Linearizability](https://en.wikipedia.org/wiki/Linearizability)中阅读更多内容。
- en: If there is no enforced ordering between multiple accesses to a single memory
    location from different threads, one or both accesses are not atomic. If there
    is a write involved, then it can cause a data race and could lead to an undefined
    behavior. The data race is a serious bug, and it must be avoided at all costs.
    The undefined behavior can be avoided by atomic operations, but it doesn't prevent
    the race situation. The atomic operation makes sure that thread switching never
    happens when the operation is going on. This is a guarantee against interleaved
    access to memory. The atomic operations guarantee the preclusion of the interleaved
    memory access (serial ordering), but cannot prevent race conditions (as there
    is potential to overwrite updates).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有强制规定从不同线程对单个内存位置进行多次访问之间的顺序，其中一个或两个访问都不是原子的。如果涉及写操作，那么它可能会导致数据竞争，并可能导致未定义的行为。数据竞争是一个严重的错误，必须尽一切努力避免。原子操作可以避免未定义的行为，但不能防止竞争情况。原子操作确保在操作进行时不会发生线程切换。这是对内存交错访问的保证。原子操作保证了交错内存访问的排除（串行顺序），但不能防止竞争条件（因为有可能覆盖更新）。
- en: The modification contract
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改合同
- en: While a program or process is in execution, all the threads in the system should
    agree on the modification order (for the memory). Every program is executed in
    an environment, which involves the instruction stream, memory, registers, heap,
    stack, caches, virtual memory, and so on. This modification order is a contract,
    between the programmer and system, that is defined by the memory model. The system
    consists of the compiler (and linker), which morphs the program into executable
    code, the processor, which executes the instruction set specified in the stream,
    the cache, and associated states of the program. The contract requires mandating
    the programmer to obey certain rules, which enables the system to generate a fully
    optimized program. This set of rules (or heuristics) that a programmer has to
    conform to while writing code to access memory is achieved with the help of atomic
    types and atomic operations that were introduced in the standard library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序或进程执行时，系统中的所有线程都应同意修改顺序（对于内存）。每个程序都在一个环境中执行，其中包括指令流、内存、寄存器、堆、栈、缓存、虚拟内存等等。这种修改顺序是程序员和系统之间的合同，由内存模型定义。系统由将程序转换为可执行代码的编译器（和链接器）、执行指定流中指定的指令集的处理器、缓存和程序的相关状态组成。合同要求程序员遵守某些规则，这些规则使系统能够生成一个完全优化的程序。程序员在编写访问内存的代码时必须遵守的一组规则（或启发式）是通过标准库中引入的原子类型和原子操作来实现的。
- en: 'These operations are not only atomic, but they create synchronization and order
    constraints on the program''s execution. Compared to higher-level lock-based synchronization
    primitives (mutexes and condition variables), discussed in [Chapter 3](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40), *Language-Level
    Concurrency and Parallelism in C++*, you can tailor synchronizations and order
    constraints to your needs. The important take away from the C++ memory model is
    this: even though the language has adopted a lot of modern programming idioms
    and language features, C++, as a system programmer''s language, has given more
    low-level control to your memory resources to optimize the code as you desire.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作不仅是原子的，而且会在程序执行中创建同步和顺序约束。与[第3章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40)中讨论的更高级别的基于锁的同步原语（互斥锁和条件变量）相比，《C++中的语言级并发和并行性》，您可以根据自己的需要定制同步和顺序约束。从C++内存模型中重要的收获是：尽管语言采用了许多现代编程习惯和语言特性，但作为系统程序员的语言，C++为您的内存资源提供了更低级别的控制，以便根据您的需求优化代码。
- en: Atomic operations and types in C++
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的原子操作和类型
- en: Generally, a non-atomic operation might be seen as half-done by other threads.
    As discussed in [Chapter 3](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40), *Language-Level
    Concurrency and Parallelism in C++*, in such cases, the invariance associated
    with the shared data structure will be broken. This happens when the modification
    to a shared data structure requires modification of more than one value. The best
    example of this is a partially removed node of a binary tree. If another thread
    tries to read from this data structure at the same time, the invariant will be
    broken and could result in undefined behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，非原子操作可能被其他线程视为半成品。正如在[第3章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40)中所讨论的那样，《C++中的语言级并发和并行性》，在这种情况下，与共享数据结构相关的不变性将被破坏。当修改共享数据结构需要修改多个值时，就会发生这种情况。最好的例子是二叉树的部分移除节点。如果另一个线程同时尝试从这个数据结构中读取，不变性将被破坏，并可能导致未定义的行为。
- en: Using an *atomic operation*, you can't observe an operation that's half-done
    from any thread in the system, because atomic operations are indivisible. If any
    operation (such as read) associated with an object is atomic, then all of the
    modifications to the object are also atomic. C++ has provided atomic types so
    that you can use atomicity as you require.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*原子操作*，您无法从系统中的任何线程观察到半成品的操作，因为原子操作是不可分割的。如果与对象相关联的任何操作（例如读取）是原子的，那么对对象的所有修改也是原子的。C++提供了原子类型，以便您可以根据需要使用原子性。
- en: Atomic types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子类型
- en: All atomic types defined by the standard library can be found in the `<atomic>`
    header library. The system guarantees the atomicity to these types and all the
    related operations with these types. Some operations may not be atomic, but the
    system creates the illusion of atomicity in such cases. The standard atomic types
    use a member function, `is_lock_free()`, that allows the user to determine whether
    operations on a given type are done directly with atomic instructions (`is_lock_free()`
    returns `true`) or done using internal locks by the compiler and library (`is_lock_free()`
    returns `false`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库定义的所有原子类型都可以在`<atomic>`头文件库中找到。系统保证这些类型的原子性以及与这些类型相关的所有操作。某些操作可能不是原子的，但在这种情况下，系统会产生原子性的幻觉。标准原子类型使用一个成员函数`is_lock_free()`，允许用户确定给定类型的操作是直接使用原子指令进行的（`is_lock_free()`返回`true`），还是使用编译器和库内部锁进行的（`is_lock_free()`返回`false`）。
- en: '`std::atomic_flag` is different among all atomic types. The operations on this
    type are required to be atomic as per the standard. Hence, this doesn''t provide
    the `is_lock_free()` member function. This is a very simple type with a minimal
    set of allowed operations such as `test_and_set()` (they can be either queried
    or set) or `clear()` (clears the value).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic_flag`在所有原子类型中是不同的。这种类型上的操作需要按照标准是原子的。因此，它不提供`is_lock_free()`成员函数。这是一种非常简单的类型，具有一组允许的最小操作，例如`test_and_set()`（可以查询或设置）或`clear()`（清除值）。'
- en: The remaining atomic types follow a similar signature as per the specifications
    of the `std::atomic<>` class template. These types, compared to `std::atomic_flag`,
    are a bit more fully featured, but not all operations are always atomic. The atomicity
    of *operations* highly depends on the platform as well. On popular platforms,
    the atomic variants of built-in types are indeed lock-free, but this is not guaranteed
    everywhere.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的原子类型遵循`std::atomic<>`类模板的规范。与`std::atomic_flag`相比，这些类型更加全面，但并非所有操作都是原子的。操作的原子性也高度取决于平台。在流行的平台上，内置类型的原子变体确实是无锁的，但这并不是在所有地方都能保证的。
- en: 'Instead of using `std::atomic<>` template classes, you can use the direct types
    supplied by the implementation, as given in the following table:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`std::atomic<>`模板类，可以使用实现提供的直接类型，如下表所示：
- en: '| **Atomic type** | **Corresponding specialization** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **原子类型** | **对应的特化** |'
- en: '| `atomic_bool` | `std::atomic<bool>` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_bool` | `std::atomic<bool>` |'
- en: '| `atomic_char` | `std::atomic<char>` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_char` | `std::atomic<char>` |'
- en: '| `atomic_schar` | `std::atomic<signed char>` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_schar` | `std::atomic<signed char>` |'
- en: '| `atomic_uchar` | `std::atomic<unsigned char>` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uchar` | `std::atomic<unsigned char>` |'
- en: '| `atomic_int` | `std::atomic<int>` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int` | `std::atomic<int>` |'
- en: '| `atomic_uint` | `std::atomic<unsigned>` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint` | `std::atomic<unsigned>` |'
- en: '| `atomic_short` | `std::atomic<short>` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_short` | `std::atomic<short>` |'
- en: '| `atomic_ushort` | `std::atomic<unsigned short>` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ushort` | `std::atomic<unsigned short>` |'
- en: '| `atomic_long` | `std::atomic<long>` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_long` | `std::atomic<long>` |'
- en: '| `atomic_ulong` | `std::atomic<unsigned long>` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ulong` | `std::atomic<unsigned long>` |'
- en: '| `atomic_llong` | `std::atomic<long long>` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_llong` | `std::atomic<long long>` |'
- en: '| `atomic_ullong` | `std::atomic<unsigned long long>` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ullong` | `std::atomic<unsigned long long>` |'
- en: '| `atomic_char16_t` | `std::atomic<char16_t>` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_char16_t` | `std::atomic<char16_t>` |'
- en: '| `atomic_char32_t` | `std::atomic<char32_t>` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_char32_t` | `std::atomic<char32_t>` |'
- en: '| `atomic_wchar_t` | `std::atomic<wchar_t>` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_wchar_t` | `std::atomic<wchar_t>` |'
- en: 'Along with all of these basic atomic types, the C++ standard library has also
    provided a set of `typedefs` for atomic types compared to the `typedefs` available
    in the standard library such as `std::size_t`. There is a simple pattern to identify
    the corresponding atomic version of `typedefs`: for any standard `typedef T`,
    use the `atomic_ prefix`: `atomic_T`. The following table lists the standard atomic
    `typedefs` and their corresponding built-in `typedefs`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些基本的原子类型之外，C++标准库还提供了一组与标准库中的`typedefs`相比的原子类型的`typedefs`。有一个简单的模式来识别`typedefs`的对应原子版本：对于任何标准`typedef
    T`，使用`atomic_`前缀：`atomic_T`。以下表格列出了标准原子`typedefs`及其对应的内置`typedefs`：
- en: '| **Atomic** `typedef` | **Standard library** `typedef` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **原子** `typedef` | **标准库** `typedef` |'
- en: '| `atomic_size_t` | `size_t` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_size_t` | `size_t` |'
- en: '| `atomic_intptr_t` | `intptr_t` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_intptr_t` | `intptr_t` |'
- en: '| `atomic_uintptr_t` | `uintptr_t` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uintptr_t` | `uintptr_t` |'
- en: '| `atomic_ptrdiff_t` | `ptrdiff_t` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ptrdiff_t` | `ptrdiff_t` |'
- en: '| `atomic_intmax_t` | `intmax_t` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_intmax_t` | `intmax_t` |'
- en: '| `atomic_uintmax_t` | `uintmax_t` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uintmax_t` | `uintmax_t` |'
- en: '| `atomic_int_least8_t` | `int_least8_t` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_least8_t` | `int_least8_t` |'
- en: '| `atomic_uint_least8_t` | `uint_least8_t` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_least8_t` | `uint_least8_t` |'
- en: '| `atomic_int_least16_t` | `int_least16_t` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_least16_t` | `int_least16_t` |'
- en: '| `atomic_uint_least16_t` | `uint_least16_t` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_least16_t` | `uint_least16_t` |'
- en: '| `atomic_int_least32_t` | `int_least32_t` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_least32_t` | `int_least32_t` |'
- en: '| `atomic_uint_least32_t` | `uint_least32_t` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_least32_t` | `uint_least32_t` |'
- en: '| `atomic_int_least64_t` | `int_least64_t` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_least64_t` | `int_least64_t` |'
- en: '| `atomic_uint_least64_t` | `uint_least64_t` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_least64_t` | `uint_least64_t` |'
- en: '| `atomic_int_fast8_t` | `int_fast8_t` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_fast8_t` | `int_fast8_t` |'
- en: '| `atomic_uint_fast8_t` | `uint_fast8_t` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_fast8_t` | `uint_fast8_t` |'
- en: '| `atomic_int_fast16_t` | `int_fast16_t` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_fast16_t` | `int_fast16_t` |'
- en: '| `atomic_uint_fast16_t` | `uint_fast16_t` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_fast16_t` | `uint_fast16_t` |'
- en: '| `atomic_int_fast32_t` | `int_fast32_t` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_fast32_t` | `int_fast32_t` |'
- en: '| `atomic_uint_fast32_t` | `uint_fast32_t` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_fast32_t` | `uint_fast32_t` |'
- en: '| `atomic_int_fast64_t` | `int_fast64_t` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int_fast64_t` | `int_fast64_t` |'
- en: '| `atomic_uint_fast64_t` | `uint_fast64_t` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint_fast64_t` | `uint_fast64_t` |'
- en: 'The `std::atomic<>` class templates are not just a set of specializations;
    they have a primary template to expand and an atomic variant of the user-defined
    type. Being a generic template class, the operations supported are limited to
    `load()`, `store()`, `exchange()`, `compare_exchange_weak()`, and `compare_exchange_strong()`.
    Each of the operations on atomic types has an optional argument to specify the
    memory-ordering semantics that are required. The concepts of memory ordering will
    be covered in detail in a later section of this chapter. For now, just keep in
    mind that all atomic operations can be divided into three categories:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic<>`类模板不仅仅是一组特化；它们有一个主模板来扩展用户定义类型的原子变体。作为一个通用模板类，支持的操作仅限于`load()`、`store()`、`exchange()`、`compare_exchange_weak()`和`compare_exchange_strong()`。原子类型的每个操作都有一个可选参数，用于指定所需的内存排序语义。内存排序的概念将在本章的后面部分详细介绍。现在，只需记住所有原子操作可以分为三类：'
- en: '**Store operations:** These operations can have `memory_order_relaxed`, `memory_order_release`,
    or `memory_order_seq_cst` ordering'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储操作：**这些操作可以具有`memory_order_relaxed`、`memory_order_release`或`memory_order_seq_cst`排序'
- en: '**Load operations:** These can have `memory_order_relaxed`, `memory_order_consume`,
    `memory_order_acquire`, or `memory_order_seq_cst` ordering'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载操作：**这些可以具有`memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`或`memory_order_seq_cst`排序'
- en: '**Read-modify-write operations:** These operations can have `memory_order_relaxed`,
    `memory_order_consume`, `memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`,
    or `memory_order_seq_cst` ordering'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读-修改-写操作：**这些操作可以具有`memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`、`memory_order_release`、`memory_order_acq_rel`或`memory_order_seq_cst`排序'
- en: The default memory ordering for all atomic operations is `memory_order_seq_cst`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原子操作的默认内存排序都是`memory_order_seq_cst`。
- en: Compared to conventional standard C++ types, standard atomic types are not *copiable*
    or *assignable*. This means that they have no copy constructors or copy assignment
    operators. Apart from direct member functions, they support from and implicit
    conversions to the corresponding built-in types. All operations on atomic types
    are defined as atomic, and assignment and copy-construction involve two objects.
    An operation involving two distinct objects cannot be atomic. In both operations,
    the value must read from one object and be written to the other. Therefore, these
    operations cannot be considered atomic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的标准C++类型相比，标准原子类型不可*复制*或*赋值*。这意味着它们没有复制构造函数或复制赋值运算符。除了直接成员函数外，它们还支持从和到相应的内置类型的隐式转换。原子类型的所有操作都被定义为原子操作，赋值和复制构造涉及两个对象。涉及两个不同对象的操作不能是原子的。在这两个操作中，值必须从一个对象读取并写入另一个对象。因此，这些操作不能被视为原子操作。
- en: Now, let's look at the operations that you can actually perform on each of the
    standard atomic types, beginning with `std::atomic_flag`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您可以在每种标准原子类型上执行的操作，从`std::atomic_flag`开始。
- en: std::atomic_flag
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::atomic_flag
- en: '`std::atomic_flag` represents a Boolean flag, and it is the simplest among
    all the atomic types in the standard library. This is the only type where all
    operations on it are required to be *lock-free* in every platform. This type is
    very basic, hence it is intended as a building block only.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic_flag`表示一个布尔标志，它是标准库中所有原子类型中最简单的。这是唯一一个在每个平台上所有操作都需要是*无锁*的类型。这种类型非常基础，因此只用作构建块。'
- en: 'A `std::atomic_flag` object must always be initialized with `ATOMIC_FLAG_INIT`
    to set the state to *clear*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic_flag`对象必须始终使用`ATOMIC_FLAG_INIT`进行初始化，以将状态设置为*clear*：'
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the only atomic type that requires such initialization, irrespective
    of the scope of its declaration. Once it is initialized, there are only three
    operations permissible with this type: destroy it, clear it, or set a query for
    the previous value. These correspond to the destructor, the `clear()` member function,
    and the `test_and_set()` member function, respectively. `clear()` is a *store*
    operation, whereas `test_and_set()` is a read-modify-write operation, as discussed
    in the previous section:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一需要这种初始化的原子类型，无论其声明的范围如何。一旦初始化，只有三种操作可以使用这种类型：销毁它，清除它，或者设置一个查询以获取先前的值。这分别对应于析构函数、`clear()`成员函数和`test_and_set()`成员函数。`clear()`是一个*存储*操作，而`test_and_set()`是一个读-修改-写操作，正如前一节中所讨论的：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code snippet, the `clear()` function call requests that the
    flag is cleared with default memory order, which is `std:: memory_order_seq_cst`,
    while the call to `test_and set()` uses the relaxed semantics (more on this in
    the *Relaxed ordering*), which are explicitly used for setting the flag and retrieving
    the old value.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`clear()`函数调用请求使用默认内存顺序清除标志，即`std::memory_order_seq_cst`，而`test_and_set()`的调用使用了松散的语义（更多信息请参阅*松散排序*），这些语义明确用于设置标志和检索旧值。
- en: 'The primitive implementation of `std::atomic_flag` makes it ideal for the spin-lock
    mutex. Let''s see an example spin-lock:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic_flag`的原始实现使其成为自旋锁互斥量的理想选择。让我们看一个自旋锁的例子：'
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, the instance variable `flg` (of the `std::atomic_flag`
    type) is cleared initially. In the lock method, it tries to set the flag by testing
    the `flg` to see whether the value is cleared.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，实例变量`flg`（类型为`std::atomic_flag`）最初被清除。在锁定方法中，它尝试通过测试`flg`来设置标志，以查看值是否被清除。
- en: If the value is cleared, the value will be set and we will exit  the loop. The
    value in the flag will only be reset when the flag is cleared by the `unlock()`
    method. In other words, this implementation achieves mutual exclusion with a busy
    wait in `lock()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值被清除，值将被设置，我们将退出循环。只有当`unlock()`方法清除标志时，标志中的值才会被重置。换句话说，这种实现通过在`lock()`中进行忙等待来实现互斥排他。
- en: Because of its limitation, `std::atomic_ flag` cannot be used as a Boolean atomic
    type, and it doesn't support any *non-modifying query* operations. So, let's look
    into `std::atomic<bool>` to compensate the requirement of atomic Boolean flags.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其限制，`std::atomic_flag`不能用作布尔原子类型，并且不支持任何*非修改查询*操作。因此，让我们研究`std::atomic<bool>`来弥补原子布尔标志的要求。
- en: std::atomic<bool>
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::atomic<bool>
- en: '`std::atomic<bool>` is a full-featured atomic Boolean type compared to `std::atomic_flag`.
    But neither copy-construction nor assignment is possible with this type. The value
    of an `std::atomic<bool>` object can initially be either `true` or `false`. The
    objects of this type can be constructed or assigned values from a non-atomic `bool`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::atomic_flag`相比，`std::atomic<bool>`是一个功能齐全的原子布尔类型。但是，这种类型既不能进行复制构造，也不能进行赋值。`std::atomic<bool>`对象的值最初可以是`true`或`false`。此类型的对象可以从非原子`bool`构造或赋值：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One thing needs to be noted about the assignment operator of atomic types, which
    is that the operator returns the value of non-atomic types rather than the conventional
    scheme of returning references. If a reference is returned instead of a value,
    it would create a situation where the result of assignment gets the result of
    a modification by another thread, that is, if it depends on the result of the
    assignment operator. While returning the result of the assignment operator as
    a non-atomic value, this additional load can be avoided, and you can infer that
    the value obtained is the value that has actually been stored.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于原子类型的赋值运算符需要注意一点，即该运算符返回非原子类型的值，而不是返回引用，这与传统方案不同。如果返回引用而不是值，那么会出现这样一种情况，即赋值的结果会得到另一个线程的修改结果，即如果它依赖于赋值运算符的结果。通过将赋值运算符的结果作为非原子值返回，可以避免这种额外的加载，并且您可以推断得到的值是实际存储的值。
- en: 'Now, let''s move on to the operations supported by `std::atomic<bool>`. First
    and foremost, the `store()` member function, which is available in `std::atomic<bool>`,
    is used for write operations (either `true` or `false`), and it replaces the corresponding
    restrictive `clear()` function of `std::atomic_flag`. Also, the `store()` function
    is an atomic store operation. Similarly, the `test_and_set()` function has been
    effectively replaced with a more generic `exchange()` member function that allows
    you to replace the stored value with a chosen new one and retrieves the original
    value. This is an atomic *read-modify-write* operation. Then, `std::atomic<bool>`
    supports a simple non-modifying query of the value with an explicit call to `load()`,
    which is an atomic load operation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论`std::atomic<bool>`支持的操作。首先，`store()`成员函数可用于`std::atomic<bool>`的写操作（`true`或`false`），它取代了`std::atomic_flag`的相应的限制性`clear()`函数。此外，`store()`函数是一个原子存储操作。类似地，`test_and_set()`函数已经被更通用的`exchange()`成员函数有效地取代，它允许您用选择的新值替换存储的值并检索原始值。这是一个原子的*读-修改-写*操作。然后，`std::atomic<bool>`支持通过显式调用`load()`进行简单的非修改查询值的操作，这是一个原子加载操作：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Apart from `exchange()`, `std::atomic<bool>` introduces an operation to perform
    a read-modify-write operation, which executes the popular atomic **compare-and-swap**
    (**CAS**) instructions. This operation stores a new value if the current value
    is equal to an expected value. This is called a compare/exchange operation. There
    are two implementations of this operation that are available in standard library
    atomic types: `compare_exchange_weak()` and `compare_exchange_strong()`. This
    operation compares the value of the atomic variable with a supplied expected value
    and stores the supplied value if they are equal. If these values are not equal,
    the expected value is updated with the actual value of the atomic variable. The
    return type of the compare/exchange function is a *bool*, which is `true` if the
    store was performed; otherwise, it is `false`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`exchange()`之外，`std::atomic<bool>`还引入了一个执行流行的原子**比较和交换**（**CAS**）指令的操作来执行*读-修改-写*操作。此操作在当前值等于期望值时存储新值。这称为比较/交换操作。标准库原子类型中有两种实现此操作的方式：`compare_exchange_weak()`和`compare_exchange_strong()`。此操作将原子变量的值与提供的期望值进行比较，并在它们相等时存储提供的值。如果这些值不相等，则更新期望值为原子变量的实际值。比较/交换函数的返回类型是*bool*，如果执行了存储，则为`true`；否则为`false`。
- en: For `compare_exchange_weak()`, the store might not be successful, even if the
    expected value and original value are equal. In such cases, the exchange of value
    will not happen and the function will return `false`. This most often happens
    on a platform that lacks single compare-and-swap instructions, which means that
    the processor cannot guarantee that the operation will be executed atomically.
    In such machines, the thread performing the operation might get switched out halfway
    through executing the sequence of instructions associated with the operation,
    and another thread will be scheduled in its place by the operating system with
    a given condition of more threads running than the number of available processors.
    This condition is called **spurious failure**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`compare_exchange_weak()`，即使期望值和原始值相等，存储也可能不成功。在这种情况下，值的交换不会发生，函数将返回`false`。这在缺乏单个比较和交换指令的平台上最常见，这意味着处理器无法保证操作将被原子执行。在这样的机器上，执行操作的线程可能在执行与操作相关的指令序列的一半时被切换出去，并且操作系统会以更多线程运行而不是可用处理器数量的条件安排另一个线程代替它。这种情况被称为**虚假失败**。
- en: 'Since `compare_exchange_weak()` can cause spurious failure, it should be used
    in a loop:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`compare_exchange_weak()`可能导致虚假失败，应该在循环中使用：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the loop continues to iterate as long as expected is
    `false`, and it denotes that spurious failure is happening to the `compare_exchange_weak()`
    call. On the contrary, `compare_exchange_strong()` is guaranteed to return `false`
    if the actual value isn't equal to the expected value. This can avoid the need
    for loops as in the previous situations where you want to know the status of variables
    with respect to running threads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，只要expected为`false`，循环就会继续迭代，并且它表示`compare_exchange_weak()`调用发生了虚假失败。相反，如果实际值不等于期望值，`compare_exchange_strong()`保证返回`false`。这可以避免在以前的情况下需要循环来了解变量状态与运行线程的情况。
- en: 'The compare/exchange functions can take two memory-ordering parameters in order
    to allow the memory-ordering semantics to differ in success and failure cases.
    Those memory-ordering semantics are only valid for store operations and cannot
    be used for failure cases, since a store operation won''t occur:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 比较/交换函数可以接受两个内存排序参数，以允许在成功和失败的情况下内存排序语义不同。这些内存排序语义仅对存储操作有效，不能用于失败情况，因为存储操作不会发生：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you won't specify any memory-ordering semantics, the default `memory_order_seq_cst`
    will be taken for both success and failure cases. If you don't specify any ordering
    for failure, then it's assumed to be the same as for success, except that the
    release part of the ordering is omitted. `memory_order_acq_rel` becomes `memory_order_acquire`
    and `memory_order_release` becomes `memory_order_relaxed`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不指定任何内存排序语义，对于成功和失败的情况都将采用默认的`memory_order_seq_cst`。如果您不为失败指定任何排序，那么假定与成功的排序相同，只是省略了排序的释放部分。`memory_order_acq_rel`变为`memory_order_acquire`，`memory_order_release`变为`memory_order_relaxed`。
- en: The specifications and consequences of memory ordering will be discussed in
    detail in the *Memory ordering* section of this chapter. Now, let's see the use
    of atomic integral types as a group.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内存排序的规范和后果将在本章的*内存排序*部分详细讨论。现在，让我们看看原子整数类型作为一组的用法。
- en: Standard atomic integral types
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准原子整数类型
- en: Similar to `std::atomic<bool>`, standard atomic integral types can be neither
    copy-constructible nor copy-assignable. However, they can be constructed and assigned
    from the corresponding non-atomic standard variant. Apart from the mandatory `is_lock_free()`
    member function, the standard atomic integral types, such as `std::atomic<int>`
    or `std::atomic<unsigned long long>`, also have `load()`, `store()`, `exchange()`,
    `compare_exchange_weak()`, and `compare_exchange_strong()` member functions, with
    similar semantics to those of `std::atomic<bool>`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::atomic<bool>`类似，标准原子整数类型既不能进行复制构造，也不能进行复制赋值。但是，它们可以从相应的非原子标准变体构造和赋值。除了强制的`is_lock_free()`成员函数之外，标准原子整数类型，比如`std::atomic<int>`或`std::atomic<unsigned
    long long>`，还有`load()`、`store()`、`exchange()`、`compare_exchange_weak()`和`compare_exchange_strong()`成员函数，其语义与`std::atomic<bool>`的类似。
- en: The integral variants of atomic types do support mathematical operations such
    as `fetch_add()`, `fetch_sub()`, `fetch_and()`, `fetch_or()` and `fetch_xor()`,
    compound-assignment operators (`+=`, `-=`, `&=`, `|=` and `^=`), and both post-
    and pre-increment and decrement operators with `++` and `--`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 原子类型的整数变体支持数学运算，比如`fetch_add()`、`fetch_sub()`、`fetch_and()`、`fetch_or()`和`fetch_xor()`，复合赋值运算符(`+=`、`-=`、`&=`、`|=`和`^=`)，以及`++`和`--`的前置和后置递增和递减运算符。
- en: 'The named functions, such as `fetch_add()` and `fetch_sub()`, atomically perform
    their operations and return the old value, but the compound-assignment operators
    return the new value. Pre- and post-increment/decrement work as per usual C/C++
    conventions: the post-increment/decrement performs the operation, but returns
    the old value, and pre-increment/decrement operators perform the operation and
    return the new value. The following simple example can easily demonstrate the
    specifications of these operations:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数，比如`fetch_add()`和`fetch_sub()`，会原子地执行它们的操作并返回旧值，但复合赋值运算符会返回新值。前置和后置递增/递减按照通常的C/C++约定工作：后置递增/递减执行操作，但返回旧值，而前置递增/递减运算符执行操作并返回新值。下面的简单示例可以很容易地演示这些操作的规范：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for this code should look as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出应如下所示：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Except for `std::atomic_flag` and `std::atomic<bool>`, all of the other listed
    atomic types in the first table are atomic integral types. Now, let's look into
    the atomic pointer specialization, `std::atomic<T*>`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::atomic_flag`和`std::atomic<bool>`之外，第一张表中列出的所有其他原子类型都是原子整数类型。现在，让我们来看一下原子指针特化，`std::atomic<T*>`。
- en: std::atomic<T*> – pointer arithmetic
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::atomic<T*> – 指针算术
- en: Along with the usual set of operations such as `load()`, `store()`, `exchange()`,
    `compare_exchange_weak()`, and `compare_exchange_strong()`, the atomic pointer
    type is loaded with the pointer arithmetic operations. The member functions `fetch_add()`
    and `fetch_sub()` provide operation support for the type to do atomic addition
    and subtraction on the stored address, and the operators `+=` and `-=`, and both
    pre- and post-increment/decrement, use the `++` and `--` operators.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通常的操作，比如`load()`、`store()`、`exchange()`、`compare_exchange_weak()`和`compare_exchange_strong()`之外，原子指针类型还加载了指针算术操作。成员函数`fetch_add()`和`fetch_sub()`提供了对类型进行原子加法和减法的操作支持，运算符`+=`和`-=`，以及前置和后置递增/递减，使用`++`和`--`运算符。
- en: The operators work in the same way as standard non-atomic pointer arithmetic
    works. If `obj` is an `std::atomic<some_class*>`, an object points to the first
    entry of an array of `some_class` objects. The `obj+=2` changes it to point to
    the third element in the array and returns a raw pointer to `some_class*` that
    points to the third element in the array. As discussed in the *Standard atomic
    integral types* section, the named functions such as `fetch_add()` and `fetch_sub`
    execute the operation on atomic types, but return the pointer to the first element
    in the array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的工作方式与标准的非原子指针算术运算相同。如果`obj`是`std::atomic<some_class*>`，则对象指向`some_class`对象数组的第一个条目。`obj+=2`将其更改为指向数组中的第三个元素，并返回一个指向数组中第三个元素的`some_class*`的原始指针。如*标准原子整数类型*部分所讨论的，诸如`fetch_add()`和`fetch_sub`之类的命名函数在原子类型上执行操作，但返回数组中第一个元素的指针。
- en: 'The function forms of atomic operations also allow the memory-ordering semantics
    to be specified in an additional argument to the function call:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作的函数形式还允许在函数调用的附加参数中指定内存排序语义：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since both `fetch_add()` and `fetch_sub` are read-modify-write operations, they
    can use any memory ordering semantics in a standard atomic library. But, for the
    operator forms, memory ordering cannot be specified, so these operators will always
    have `memory_order_seq_cst` semantics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fetch_add()`和`fetch_sub`都是读取-修改-写操作，它们可以在标准原子库中使用任何内存排序语义。但是，对于操作符形式，无法指定内存排序，因此这些操作符将始终具有`memory_order_seq_cst`语义。
- en: std::atomic<> primary class template
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::atomic<>主类模板
- en: The primary class template in the standard library allows the user to create
    an atomic variant of a **user-defined type** (**UDT**). To use a user-defined
    type as an atomic type, you have to follow some criteria before implementing the
    class. For a user-defined class UDT, `std::atomic<UDT>` is possible if this type
    has a trivial copy-assignment operator. This means that the user-defined class
    should not contain any virtual functions or virtual base classes and must use
    the compiler-generated default copy-assignment operator. Also, every base class
    and non-static data member of the user-defined class must have a trivial copy-assignment
    operator. This allows the compiler to execute `memcpy()`or an equivalent operation
    for assignment operations, since there is no user-written code to execute.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的主要类模板允许用户创建**用户定义类型**（**UDT**）的原子变体。要将用户定义类型用作原子类型，您必须在实现类之前遵循一些标准。对于用户定义类UDT，如果该类型具有平凡的复制赋值运算符，则`std::atomic<UDT>`是可能的。这意味着用户定义类不应包含任何虚函数或虚基类，并且必须使用编译器生成的默认复制赋值运算符。此外，用户定义类的每个基类和非静态数据成员必须具有平凡的复制赋值运算符。这使得编译器可以执行`memcpy()`或等效的操作以进行赋值操作，因为没有用户编写的代码需要执行。
- en: Along with the requirements on assignment operators, the user-defined types
    must be *bitwise equality comparable*. This means that you must be able to compare
    the instances for equality using `memcmp()`. This guarantee is required to ensure
    that the compare/exchange operation will work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了赋值运算符的要求之外，用户定义类型必须是*位相等可比*的。这意味着您必须能够使用`memcmp()`比较实例是否相等。这个保证是必需的，以确保比较/交换操作能够正常工作。
- en: 'For an instance of the standard atomic type with the user-defined type `T`,
    that is, `std::atomic<T>`, the interface is limited to the operations available
    for `std::atomic<bool>`: `load()`, `store()`, `exchange()`, `compare_exchange_weak()`,
    `compare_exchange_strong()`, and the assignment from and conversion to an instance
    of type `T`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有用户定义类型`T`的标准原子类型的实例，即`std::atomic<T>`，接口仅限于`std::atomic<bool>`可用的操作：`load()`，`store()`，`exchange()`，`compare_exchange_weak()`，`compare_exchange_strong()`和对类型`T`的实例的赋值和转换。
- en: Memory ordering
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存排序
- en: 'We have already learned about the atomic types and atomic operators available
    in the standard library. While performing operations on atomic types, we need
    to specify memory ordering for certain operations. Now, we will talk about the
    significance and use cases for the different memory-ordering semantics. The key
    idea behind atomic operations is to provide synchronization in data access across
    multiple threads, and this is achieved by enforcing the order of execution. For
    example, if writing to the data happens before the read from the data, things
    will be fine. Otherwise, you are in trouble! There are six memory-ordering options
    available with the standard library that can be applied to operations on atomic
    types: `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`,
    `memory_order_release`, `memory_order_acq_rel`, and `memory_order_seq_cst`. For
    all atomic operations on atomic types, `memory_order_seq_cst` is the memory order
    by default unless you specify something else.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了标准库中可用的原子类型和原子操作。在对原子类型执行操作时，我们需要为某些操作指定内存排序。现在，我们将讨论不同内存排序语义的重要性和用例。原子操作背后的关键思想是在多个线程之间提供数据访问的同步，并通过强制执行执行顺序来实现这一点。例如，如果写入数据发生在读取数据之前，那么一切都会很好。否则，你就麻烦了！标准库提供了六种内存排序选项，可应用于原子类型的操作：`memory_order_relaxed`，`memory_order_consume`，`memory_order_acquire`，`memory_order_release`，`memory_order_acq_rel`和`memory_order_seq_cst`。对于所有原子类型的原子操作，`memory_order_seq_cst`是默认的内存顺序，除非您指定其他内容。
- en: 'These six options can be classified into three categories:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个选项可以分为三类：
- en: '**Sequentially consistent ordering**: `memory_order_seq_cst`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序一致排序：`memory_order_seq_cst`
- en: '**Acquire-release ordering**: `memory_order_consume`, `memory_order_release`,
    `memory_order_acquire`, and `memory_order_acq_rel`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取-释放排序**：`memory_order_consume`，`memory_order_release`，`memory_order_acquire`和`memory_order_acq_rel`'
- en: '**Relaxed ordering**: `memory_order_relaxed`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散排序**：`memory_order_relaxed`'
- en: The cost of execution varies with different CPUs for different memory-ordering
    models. The availability of distinct memory-ordering models allows an expert to
    take advantage of the increased performance of more fine-grained ordering relationships
    compared to blocking sequentially consistent ordering, but to choose the appropriate
    memory model as required, one should understand how these options affect the behavior
    of the program. Let's look into the sequentially consistent model first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 执行成本因不同的CPU和不同的内存排序模型而异。不同的内存排序模型的可用性允许专家利用比阻塞顺序一致排序更精细的排序关系来提高性能，但是要选择适当的内存模型，就应该了解这些选项如何影响程序的行为。让我们首先看看顺序一致性模型。
- en: Sequential consistency
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序一致性
- en: The concept of sequential consistency was defined by Leslie Lamport in 1979\.
    Sequential consistency provides two guarantees in the execution of a program.
    First and foremost, memory ordering the instructions of a program are executed
    in source code order, or an illusion of source code order will be guaranteed by
    the compiler. Then, there is a global order of all atomic operations in all threads.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序一致性的概念是由Leslie Lamport在1979年定义的。顺序一致性在程序执行中提供了两个保证。首先，程序的指令的内存排序按照源代码顺序执行，或者编译器将保证源代码顺序的幻觉。然后，所有线程中所有原子操作的全局顺序。
- en: For a programmer, the global ordering behavior of sequential consistency in
    which all operations in all threads take place in a global clock is an interesting
    high ground, but is also a disadvantage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，顺序一致性的全局排序行为，即所有线程中的所有操作都在全局时钟中发生，是一个有趣的高地，但也是一个缺点。
- en: 'The interesting thing about sequential consistency is that the code works as
    per our intuition of multiple concurrent threads, but with the cost of a lot of
    background work being done by the system. The following program is a simple example
    to give us an edge into sequential consistency:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于顺序一致性的有趣之处在于，代码按照我们对多个并发线程的直觉工作，但系统需要做大量的后台工作。以下程序是一个简单的示例，让我们了解顺序一致性：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding program synchronizes the threads `thread1` and `thread2` with
    the help of sequential consistency. Because of sequential consistency, the execution
    is totally *deterministic*, so the output of this program is always as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序使用顺序一致性来同步线程`thread1`和`thread2`。由于顺序一致性，执行是完全*确定*的，因此该程序的输出始终如下：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `thread1` waits in the while loop until the atomic variable `ready` is
    `true`. As soon as *ready* becomes `true` in `thread2`, `thread1` continues its
    execution, hence the result always gets updated with strings in the same order.
    The usage of sequential consistency allows both threads to see the operations
    in other threads in the same order, hence both threads follow the same global
    time clock. The loop statement also helps to hold the time clock for the synchronization
    of both threads.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`thread1`在while循环中等待，直到原子变量`ready`为`true`。一旦`thread2`中的*ready*变为`true`，`thread1`就会继续执行，因此结果总是以相同的顺序更新字符串。顺序一致性的使用允许两个线程以相同的顺序看到其他线程的操作，因此两个线程都遵循相同的全局时钟。循环语句还有助于保持两个线程的同步的时间时钟。
- en: The details of *acquire-release semantics* will follow in the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取-释放语义*的细节将在下一节中介绍。'
- en: Acquire-release ordering
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取-释放排序
- en: Now, let's dive deep into memory-ordering semantics provided by the C++ standard
    library. This is the area where the programmer's intuition about ordering in multithread
    code begins to fade, because there is no global synchronization between threads
    in acquire-release semantics of atomic operations. These semantics only allow
    synchronization between atomic operations on the same atomic variable. To elaborate,
    the load operation on an atomic variable performing in one thread can be synchronized
    with store operation happening on the same atomic variable in some other thread.
    A programmer must extract this feature that establishes a *happen-before* relationship
    between atomic variables to synchronize between threads. This makes working with
    an acquire-release model a bit difficult, but at the same time more thrilling.
    The acquire-release semantics shorten the journey towards lock-free programming,
    because you don't need to bother about synchronization of threads, but synchronization
    of the same atomic variables in different threads is the one we need to reason
    about.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入研究C++标准库提供的内存排序语义。这是程序员对多线程代码中排序的直觉开始消失的地方，因为在原子操作的获取-释放语义中，线程之间没有全局同步。这些语义只允许在同一原子变量上的原子操作之间进行同步。简而言之，一个线程上的原子变量的加载操作可以与另一个线程上同一原子变量的存储操作进行同步。程序员必须提取这个特性，建立原子变量之间的*happen-before*关系，以实现线程之间的同步。这使得使用获取-释放模型有点困难，但同时也更加刺激。获取-释放语义缩短了通向无锁编程的道路，因为你不需要担心线程的同步，但需要思考的是不同线程中相同原子变量的同步。
- en: As we explained previously, the key idea of acquire-release semantics is the
    synchronization between a release operation with an acquire operation on the same
    atomic variable and establishing an *ordering constant* in addition to this. Now,
    as the name implies, an acquire operation involves acquiring a lock, which includes
    the operations used to read an atomic variable, such as the `load()` and `test_and_set()`
    functions. Consequently, the releasing of a lock is a release operation, which
    consists of atomic operations such as `store()` and `clear()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，获取-释放语义的关键思想是在同一原子变量上的释放操作与获取操作之间的同步，并建立一个*ordering constant*。现在，顾名思义，获取操作涉及获取锁，其中包括用于读取原子变量的操作，如`load()`和`test_and_set()`函数。因此，释放锁是一个释放操作，其中包括`store()`和`clear()`等原子操作。
- en: 'In other words, the lock of a *mutex* is an acquire operation, whereas the
    unlock is a release operation. Thus, in a *critical-section*, the operation on
    a variable cannot be taken outside in either direction. However, a variable can
    be moved inside a critical-section, because the variable moves from an unprotected
    area to a protected area. This is represented in the following diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*mutex*的锁是一个获取操作，而解锁是一个释放操作。因此，在*临界区*中，对变量的操作不能在任何方向上进行。但是，变量可以从外部移入临界区，因为变量从一个未受保护的区域移动到了一个受保护的区域。这在下图中表示：
- en: '![](img/688c368f-57ff-42a4-b55c-54a8feabee4b.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/688c368f-57ff-42a4-b55c-54a8feabee4b.png)'
- en: 'The critical-section contains one-way barriers: an acquire barrier and a release
    barrier. The same reasoning can be applied for starting a thread and placing a
    join-call on a thread, and the operations related to all other synchronization
    primitives available with the standard library.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 临界区包含单向屏障：获取屏障和释放屏障。相同的推理也可以应用于启动线程和在线程上放置join调用，以及标准库中提供的所有其他同步原语相关的操作。
- en: 'Since synchronization takes place at atomic variable level rather than at thread
    level, let''s revisit the spin-lock that''s been implemented using `std::atomic_flag`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同步是在原子变量级别而不是线程级别进行的，让我们重新审视一下使用`std::atomic_flag`实现的自旋锁：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this code, the `lock()` function is an `acquire` operation. Instead of using
    the default sequentially consistent memory ordering that was used in the previous
    example, an explicit acquire memory ordering flag is used now. Also, the `unlock()`
    function, which is a release operation that was also using default memory order,
    has now been replaced with explicit release semantics. So, the heavyweight synchronization
    with sequential consistency of two threads is replaced by the lightweight and
    performant acquire-release semantics.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`lock()`函数是一个`acquire`操作。现在不再使用前一个示例中使用的默认顺序一致的内存排序，而是现在使用了显式的acquire内存排序标志。此外，`unlock()`函数，也是一个释放操作，之前也是使用默认的内存顺序，现在已经被替换为显式的释放语义。因此，两个线程的顺序一致的重量级同步被轻量级和高性能的acquire-release语义所取代。
- en: As the number of threads using the `spin_lock` increases more than two threads,
    the general acquire semantics using `std::memory_order_acquire` will not be sufficient,
    because the lock method becomes an acquire-release operation. Therefore, the memory
    model has to be changed to `std::memory_order_acq_rel`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`spin_lock`的线程数量超过两个时，使用`std::memory_order_acquire`的一般获取语义将不足够，因为锁方法变成了一个获取-释放操作。因此，内存模型必须更改为`std::memory_order_acq_rel`。
- en: So far, we have seen that sequentially consistent ordering ensures synchronization
    between threads, while acquire-release ordering establishes ordering between read
    and write operations on the same atomic variable on multiple threads. Now, let's
    see the specifications of relaxed memory ordering.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到顺序一致的排序确保了线程之间的同步，而获取-释放排序在多个线程上确立了对同一原子变量的读写操作的顺序。现在，让我们看一下松散内存排序的规范。
- en: Relaxed ordering
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散排序
- en: Operations on atomic types performed with relaxed memory ordering using the
    tag `std::memory_order_relaxed` are not synchronization operations. In contrast
    with other ordering options that are available in the standard library, they do
    not impose an order among concurrent memory access. The relaxed memory ordering
    semantics only guarantee that the operations on the same atomic type inside the
    same thread cannot be reordered, and this guarantee is called **modification order
    consistency**. In fact, relaxed ordering only guarantees atomicity and modification
    order consistency. Therefore, other threads can see these operations in different
    orders.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签`std::memory_order_relaxed`进行松散内存排序的原子类型的操作不是同步操作。与标准库中提供的其他排序选项相比，它们不会对并发内存访问施加顺序。松散内存排序语义只保证同一线程内相同原子类型的操作不能被重新排序，这个保证被称为**修改顺序一致性**。事实上，松散排序只保证了原子性和修改顺序一致性。因此，其他线程可以以不同的顺序看到这些操作。
- en: Relaxed memory ordering can be used effectively in places where synchronization
    or ordering is not required, and atomicity can be an added advantage for performance
    boosting. One typical example would be incrementing counters, such as reference
    counters of **std::shared_ptr**, where they only require atomicity. But decrementing
    the reference count needs acquire-release synchronization with the destructor
    of this template class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 松散内存排序可以有效地用于不需要同步或排序的地方，并且原子性可以成为性能提升的一个优势。一个典型的例子是增加计数器，比如**std::shared_ptr**的引用计数器，它们只需要原子性。但是减少引用计数需要与这个模板类的析构函数进行获取-释放同步。
- en: 'Let''s see a simple example to count the number of threads that were spawned
    with relaxed ordering:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子来计算使用松散排序生成的线程数量：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code, ten threads are spawned from the `main()` function with a thread
    function `func()`, where on each thread the atomic integer value is incremented
    by one using the atomic operation `fetch_add()`. In contrast to compound assignment
    operators and post- and pre-increment operators, available with `std::atomic<int>`,
    the `fetch_add()` function can accept the memory ordering argument and it is `std::memory_order_relaxed`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，从`main()`函数生成了十个线程，每个线程都使用线程函数`func()`，在每个线程上，使用原子操作`fetch_add()`将原子整数值增加一。与`std::atomic<int>`提供的复合赋值运算符和后置和前置递增运算符相反，`fetch_add()`函数可以接受内存排序参数，它是`std::memory_order_relaxed`。
- en: 'The program prints the number of threads spawned in the program as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 程序打印出程序中生成的线程数量如下：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of the program remains the same for any other relevant memory-ordering
    tags, but the relaxed memory ordering ensures atomicity and thus performance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出对于任何其他相关的内存排序标签都是相同的，但是松散的内存排序确保了原子性，从而提高了性能。
- en: Until now, we have discussed the levels of the different memory models, and
    their effect on atomic and non-atomic operations. Now, let's dive into an implementation
    of a lock-free data structure using atomic operations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了不同内存模型的级别，以及它们对原子和非原子操作的影响。现在，让我们深入研究使用原子操作实现无锁数据结构。
- en: A lock-free data structure  queue
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无锁数据结构队列
- en: 'As we already know, the data in an actual system is often represented in the
    form of a data structure, and when it comes to concurrent operations on a data
    structure, performance is a big deal. In [Chapter 3](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40), *Language-Level
    Concurrency and Parallelism in C++*, we learned how to write a thread-safe stack.
    However, we used locks and condition variables to implement it. To explain how
    to write a lock-free data structure, let''s write a very basic queue system using
    a producer/consumer paradigm without using locks or condition variables. This
    will improve the performance of the code for sure. Rather than using a wrapper
    over a standard data type, we will roll it out from scratch. We have made an assumption
    that there is a single producer and a single consumer in this case:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，实际系统中的数据通常以数据结构的形式表示，当涉及到数据结构的并发操作时，性能是一个大问题。在[第3章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=48&action=edit#post_40)中，*C++中的语言级并发和并行性*，我们学习了如何编写一个线程安全的栈。然而，我们使用了锁和条件变量来实现它。为了解释如何编写一个无锁数据结构，让我们使用生产者/消费者范式来编写一个非常基本的队列系统，而不使用锁或条件变量。这肯定会提高代码的性能。我们不使用标准数据类型的包装器，而是从头开始编写。我们假设在这种情况下有一个生产者和一个消费者：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Lock_free_stack` class contains a structure to represent a queue node
    (named `Node`) with data members to represent the data of a node (`my_data`) and
    a pointer to the next node. Then, the class contains two instances of an atomic
    pointer to the user-defined structure `Node`, which is already defined inside
    the class. One instance stores the pointer to the head node of the queue, while
    the other points to the tail node. Finally, a `private pop_head_node()` function
    is used to retrieve the head node of the queue by calling an atomic *store* operation,
    but only if the queue contains at least one element. Here, the atomic operation
    follows the default sequentially consistent memory-ordering semantics:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock_free_stack`类包含一个用于表示队列节点的结构（命名为`Node`），其中包含用于表示节点数据（`my_data`）和指向下一个节点的指针的数据成员。然后，该类包含两个原子指针实例，指向用户定义的结构`Node`，该结构已在类内部定义。一个实例存储队列头节点的指针，而另一个指向尾节点。最后，使用`private pop_head_node()`函数通过调用原子*store*操作来检索队列的头节点，但仅当队列包含至少一个元素时。在这里，原子操作遵循默认的顺序一致的内存排序语义：'
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The head node is instantiated and the tail points to that memory when the queue
    object is constructed. The copy constructor and copy assignment operators are
    marked as deleted to prevent them from being used. Inside the destructor, all
    of the elements in the queue are deleted iteratively:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 头节点在队列对象构造时被实例化，并且尾部指向该内存。复制构造函数和复制赋值运算符被标记为删除，以防止它们被使用。在析构函数内，队列中的所有元素都被迭代删除：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code snippet implements standard queue operations, which are Enqueue
    and Dequeue. Here, we have ensured that there is a *happens before* relationship
    between Enqueue and Dequeue using the swap and store atomic operations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段实现了标准队列操作，即Enqueue和Dequeue。在这里，我们使用了swap和store原子操作，确保Enqueue和Dequeue之间存在*happens
    before*关系。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed facilities provided by the standard library
    to write task-based parallelism. We saw how to use futures and promises with `std::packaged_task`
    and `std::async`. We discussed the new multi-threading-aware memory model that
    is available with the Modern C++ language. After that, we covered atomic types,
    and operations associated with them. The most important thing that we learned
    about are the various memory-ordering semantics of the language. In a nutshell,
    this particular chapter and the previous one will enable us to reason about the
    concurrency aspects of the reactive programming model.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了标准库提供的用于编写基于任务的并行性的工具。我们看到了如何使用`std::packaged_task`和`std::async`与futures和promises。我们讨论了现代C++语言提供的新的多线程感知内存模型。之后，我们讨论了原子类型及其相关操作。我们学到的最重要的事情是语言的各种内存排序语义。简而言之，这一章和前一章将使我们能够推理响应式编程模型的并发方面。
- en: In the following chapter, we will shift our attention from language and concurrency
    to the standard interface of the reactive programming model. We will be covering
    Observables!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将把注意力从语言和并发转移到响应式编程模型的标准接口。我们将介绍Observables！
