- en: Getting Started with OpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用OpenGL
- en: In the previous three chapters, we rendered 2D objects called sprites in our
    tiny Bazooka game using the **Simple and Fast Media Library** (**SFML**). At the
    core of SFML is OpenGL; this is used to render anything on screen, including 2D
    objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个章节中，我们在微小的Bazooka游戏中使用**简单快速媒体库**（**SFML**）渲染了名为sprite的2D对象。SFML的核心是OpenGL；这用于在屏幕上渲染任何内容，包括2D对象。
- en: SFML does a great job of putting everything in a nice little package, and this
    allows us to get a 3D game going very quickly. However, in order to understand
    how a graphics library actually works, we need to learn how OpenGL works by delving
    deeper into how to use it so that we can render anything on the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SFML非常擅长将所有内容打包成一个精美的小包，这使得我们能够快速开始3D游戏。然而，为了理解图形库实际上是如何工作的，我们需要通过深入了解如何使用它来学习OpenGL的工作原理，这样我们就可以在屏幕上渲染任何内容。
- en: 'In this chapter, we will discover how to use a graphics library, such as OpenGL,
    in order to render 3D objects in any scene. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何使用图形库，如OpenGL，来在任意场景中渲染3D对象。我们将涵盖以下主题：
- en: What is OpenGL?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是OpenGL？
- en: Creating our first OpenGL project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个OpenGL项目
- en: Creating a window and ClearScreen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建窗口和清屏
- en: Creating a `Mesh` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Mesh`类
- en: Creating a Camera class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个相机类
- en: The Shaderloader class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shaderloader类
- en: The Light Renderer class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照渲染器类
- en: Drawing the object
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制对象
- en: What is OpenGL?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是OpenGL？
- en: So, what is this OpenGL that we speak of? Well, OpenGL is a collection of graphics
    APIs; essentially, this is a collection of code that allows you to gain access
    to the features of your graphics hardware. The current version of OpenGL is 4.6,
    but any graphics hardware that is capable of running OpenGL 4.5 can run 4.6 as
    well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们所说的OpenGL是什么？嗯，OpenGL是一组图形API；本质上，这是一个允许你访问图形硬件功能的代码集合。当前OpenGL的版本是4.6，但任何能够运行OpenGL
    4.5的图形硬件也可以运行4.6。
- en: OpenGL is entirely hardware and operating system independent, so it doesn't
    matter if you have a NVIDIA or AMD GPU; it will work the same on both hardware.
    The way in which OpenGL's features work is defined by a specification that is
    used by graphics hardware manufacturers while they're developing the drivers for
    their hardware. This is why we sometimes have to update the graphics hardware
    drivers if something doesn't look right or if the game is not performing well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL完全独立于硬件和操作系统，所以无论你使用的是NVIDIA还是AMD GPU，它在这两种硬件上都会以相同的方式工作。OpenGL的功能工作方式是由一个规范定义的，该规范被图形硬件制造商在开发其硬件的驱动程序时使用。这就是为什么有时我们不得不更新图形硬件驱动程序，如果某些东西看起来不对或者游戏表现不佳。
- en: Furthermore, OpenGL runs the same, regardless of whether you are running a Windows
    or a Linux machine. It is, however, deprecated on macOS Mojave, but if you are
    running a macOS version earlier than Mojave, then it is still compatible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OpenGL在Windows或Linux机器上运行都是相同的。然而，在macOS Mojave上已被弃用，但如果你运行的macOS版本早于Mojave，则它仍然兼容。
- en: OpenGL is only responsible for rendering objects in the scene. Unlike SFML,
    which allows you to create a window and then gain access to the keyboard and mouse
    input, we will need to add a separate library that will handle all of this for
    us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL只负责在场景中渲染对象。与允许你创建窗口然后访问键盘和鼠标输入的SFML不同，我们需要添加一个单独的库来处理所有这些。
- en: So, let's start preparing our project by rendering a 3D OpenGL object in the
    scene.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过在场景中渲染一个3D OpenGL对象来开始准备我们的项目。
- en: Creating our first OpenGL project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个OpenGL项目
- en: 'Now that we have gained an understanding of what OpenGL is, let''s examine
    how to create our first OpenGL project, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了OpenGL是什么，让我们来检查如何创建我们的第一个OpenGL项目，如下所示：
- en: Create a new empty C++ project in Visual Studio and call it `OpenGLProject`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中创建一个新的空C++项目，并将其命名为`OpenGLProject`。
- en: Then, download GLEW; this is a C/C++ extension loader library. OpenGL supports
    extensions that various GPU vendors can use to write and extend the functionality
    of OpenGL. This library will determine what extensions are supported on the platform.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，下载GLEW；这是一个C/C++扩展加载库。OpenGL支持各种GPU供应商可以使用来编写和扩展OpenGL功能性的扩展。这个库将确定平台支持哪些扩展。
- en: 'Go to [http://glew.sourceforge.net/](http://glew.sourceforge.net/) and download
    the Windows 32-bit and 64-bit Binaries:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://glew.sourceforge.net/](http://glew.sourceforge.net/)下载Windows 32位和64位二进制文件：
- en: '![](img/0ce25f6f-52f8-4912-b6c2-83fcc5d6d88b.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ce25f6f-52f8-4912-b6c2-83fcc5d6d88b.png)'
- en: 'Next, we need to download GLFW; this is a platform-independent API that is
    used for creating a window, reading inputs, and handling events. Go to [https://www.glfw.org/download.html](https://www.glfw.org/download.html)
    and download the 64-bit Windows binary. In this book, we will be primarily looking
    at implementing it on the Windows platform:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载 GLFW；这是一个平台无关的 API，用于创建窗口、读取输入和处理事件。访问 [https://www.glfw.org/download.html](https://www.glfw.org/download.html)
    并下载 64 位 Windows 二进制文件。在这本书中，我们将主要关注在 Windows 平台上实现它：
- en: '![](img/f22aa0a8-f6d0-4268-8cc5-ff9c92012def.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f22aa0a8-f6d0-4268-8cc5-ff9c92012def.png)'
- en: Next, we need to download `glm`, which is used to do all the math for our graphics
    calculations. Go to [https://glm.g-truc.net/0.9.9/index.html](https://glm.g-truc.net/0.9.9/index.html)
    and download GLM from the site.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载 `glm`，它用于我们图形计算的数学运算。访问 [https://glm.g-truc.net/0.9.9/index.html](https://glm.g-truc.net/0.9.9/index.html)
    并从该网站下载 GLM。
- en: Now that we have downloaded all the required libraries and headers, we can start
    adding them to our project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经下载了所有必需的库和头文件，我们可以开始将它们添加到我们的项目中。
- en: In the root directory (where the Visual Studio project file is stored) of the
    project, create a new directory called `Dependencies`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件根目录（Visual Studio 项目文件存储的位置）中，创建一个名为 `Dependencies` 的新目录。
- en: 'From this directory, extract `glew`, `glfw`, and `glm`; the `Dependencies`
    directory should now look as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此目录中提取 `glew`、`glfw` 和 `glm`；`Dependencies` 目录现在应该如下所示：
- en: '![](img/ebf9e9ff-bd57-480d-befd-112fa32dbe8d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebf9e9ff-bd57-480d-befd-112fa32dbe8d.png)'
- en: Open the Visual Studio project. We need to set the location of the headers and
    library files. To do this, open the project properties of `OpenGLProject` and
    set Configuration to Release and Platform to x64.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 项目。我们需要设置头文件和库文件的位置。为此，打开 `OpenGLProject` 的项目属性，将配置设置为 Release，平台设置为
    x64。
- en: 'Under C/C++ | General, select Additional Include Directories and select the
    following directories for GLEW and GLFW:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C/C++ | 通用下，选择 Additional Include Directories 并选择以下目录用于 GLEW 和 GLFW：
- en: '![](img/1cc6ccbb-4723-4054-a044-cbbc56c15d22.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cc6ccbb-4723-4054-a044-cbbc56c15d22.png)'
- en: 'Next, under Linker |General, select Additional Library Directories, and then
    select the location of the `.lib` files in the `glew` and `glfw` directories,
    as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 Linker | General 下，选择 Additional Library Directories，然后选择 `glew` 和 `glfw`
    目录中 `.lib` 文件的位置，如下所示：
- en: '![](img/9d5322e4-665a-459d-91c9-b4b681fed335.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d5322e4-665a-459d-91c9-b4b681fed335.png)'
- en: Next, we have to go to Linker | Input and specify which `.lib` files we are
    using.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须转到 Linker | Input 并指定我们正在使用的 `.lib` 文件。
- en: 'Under Linker | Input, select Additional Dependencies and then add opengl32.lib,
    glfw3.lib, and glew32.lib, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Linker | Input 下，选择 Additional Dependencies 并添加 opengl32.lib、glfw3.lib 和 glew32.lib，如下所示：
- en: '![](img/e1bdafc5-3f98-4608-a86b-de19c87cccdc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1bdafc5-3f98-4608-a86b-de19c87cccdc.png)'
- en: Although we didn't specifically download `opengl32.lib`, it is included when
    you update the driver of the graphics hardware. Therefore, make sure that you
    are running the most recent drivers for your GPU; if not, download them from the
    manufacturer's website.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们没有特别下载 `opengl32.lib`，但在更新图形硬件的驱动程序时它会自动包含。因此，请确保您正在运行最新的 GPU 驱动程序；如果不是，请从制造商的网站下载它们。
- en: Finally, we have to add the `glew32.dll` and `glfw3.dll` files to the root directory
    of the project. `glew32.dll` is inside `glew-2.1.0/ bin/Release/64`, whereas `glfw3.dll`
    is inside `glfw-3.2.1/lib-vc2015`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须将 `glew32.dll` 和 `glfw3.dll` 文件添加到项目的根目录中。`glew32.dll` 在 `glew-2.1.0/bin/Release/64`
    中，而 `glfw3.dll` 在 `glfw-3.2.1/lib-vc2015` 中。
- en: 'The root directory of the project file should now look as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件根目录现在应该如下所示：
- en: '![](img/479c3905-64d5-430c-a95b-7fd2f332dd29.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/479c3905-64d5-430c-a95b-7fd2f332dd29.png)'
- en: With this out of the way, we can finally start working on the project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们终于可以开始着手项目了。
- en: Creating a window and ClearScreen
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口和清屏
- en: 'Now, let''s explore how we can work with the OpenGL project that we created:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何使用我们创建的 OpenGL 项目：
- en: The first thing we have to do is create a window so that we can start rendering
    the game objects to the screen.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个窗口，这样我们就可以开始将游戏对象渲染到屏幕上了。
- en: Create a new `.cpp` file; Visual Studio will automatically call this `source.cpp`,
    so keep it as it is.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `.cpp` 文件；Visual Studio 会自动将其命名为 `source.cpp`，所以保持原样即可。
- en: 'At the top of the file, include the `glew` and `glfw` headers. Make sure that
    you include `glew.h` first since it contains the correct OpenGL header files to
    be included:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，包含`glew`和`glfw`头文件。确保首先包含`glew.h`，因为它包含了需要包含的正确OpenGL头文件：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing we need to do here is initialize `glfw` by calling `glfwInit()`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们首先需要做的是通过调用`glfwInit()`来初始化`glfw`。
- en: Once initialized, we can create the window that our game scene will be rendered
    to. To create a window, we need to create a new instance of `GLFWWindow` called
    window and call `glfwCreateWindow`. This takes five parameters, including the
    width and height of the window, along with the name of the window. The final two
    parameters—`monitor` and `share`—are set to `NULL`. The `monitor` parameter takes
    a specific monitor on which the window will be created. If it is set to `null`,
    then the default monitor is chosen. The `share` parameter will let us share the
    window resource with our users. Here, we set it to `NULL` as we don't want to
    share the window resources.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦初始化完成，我们就可以创建一个窗口，我们的游戏场景将会在这个窗口上渲染。为了创建一个窗口，我们需要创建一个新的`GLFWWindow`实例，命名为`window`，并调用`glfwCreateWindow`函数。这个函数需要五个参数，包括窗口的宽度和高度，以及窗口的名称。最后的两个参数——`monitor`和`share`——被设置为`NULL`。`monitor`参数指定了窗口将要创建的特定显示器。如果设置为`null`，则选择默认显示器。`share`参数允许我们与用户共享窗口资源。在这里，我们将其设置为`NULL`，因为我们不想共享窗口资源。
- en: Now, run the project; you will see that a window briefly appears before the
    application closes.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目；你将看到在应用程序关闭之前，窗口会短暂出现。
- en: Well, that's not very fun. Let's add the rest of the code so that we can see
    something being rendered on the viewport.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嗯，这并不很有趣。让我们添加剩余的代码，这样我们就可以在视口中看到一些被渲染的内容。
- en: The first thing we need to do is initialize OpenGL Context. OpenGL Context is
    a collection of all the current states of OpenGL. We will discuss the different
    states in the upcoming sections.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要做的是初始化OpenGL上下文。OpenGL上下文是OpenGL所有当前状态的集合。我们将在接下来的章节中讨论不同的状态。
- en: 'To do this, call `glfwMakeCurrentContext` and pass in the window that we just
    created:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，调用`glfwMakeCurrentContext`并传入我们刚刚创建的窗口：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can now initialize GLEW by calling `glewInit()`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过调用`glewInit()`来初始化GLEW。
- en: 'Next, we will add the following code between `glewInit()` and `return 0` in
    the `main` function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`main`函数中的`glewInit()`和`return 0`之间添加以下代码：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating a `while` loop, calling `glfwWindowShouldClose`, and then
    passing it in the current window. While the window is open, the `glfwSwapBuffers(window);`
    and `glfwPollEvents();` commands will be executed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`while`循环，调用`glfwWindowShouldClose`，然后将其传递给当前窗口。当窗口打开时，将执行`glfwSwapBuffers(window);`和`glfwPollEvents();`命令。
- en: In the `while` loop, we will render our scene. Then, we will swap display buffers.
    The display buffer is where the current frame is rendered and stored. While the
    current frame is being shown, the next frame is actually being rendered in the
    background, which we don't get to see. When the next frame is ready, the current
    frame is swapped with the new frame. This swapping of frames is done by `glfwSwapBuffer`
    and is managed by OpenGL.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们将渲染我们的场景。然后，我们将交换显示缓冲区。显示缓冲区是当前帧被渲染和存储的地方。当当前帧正在显示时，下一帧实际上在后台被渲染，我们看不到。当下一帧准备好时，当前帧与新的帧进行交换。这种帧的交换是通过`glfwSwapBuffer`完成的，并由OpenGL管理。
- en: After we swap the display buffer, we need to check for any events that were
    triggered, such as the window being closed in `glfwPollEvents()`. Once the window
    is closed, `glfw` is terminated.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交换显示缓冲区之后，我们需要检查是否有任何触发的事件，例如在`glfwPollEvents()`中窗口被关闭。一旦窗口关闭，`glfw`将被终止。
- en: If you run the project now, you will see a black window; while it doesn't vanish,
    it is still not very impressive. We can use OpenGL to clear the viewport with
    a color of our choice, so let's do that next.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行项目，你将看到一个黑色的窗口；虽然它没有消失，但仍然不是很令人印象深刻。我们可以使用OpenGL以我们选择的颜色清除视口，所以让我们来做这件事。
- en: Create a new function called `void renderScene()`. Whatever we render to the
    scene from now on will also be added to this function. Add a new prototype for
    `void renderScene()` to the top of the `source.cpp` file.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`void renderScene()`的新函数。从现在开始，我们将把渲染到场景中的任何内容都添加到这个函数中。将`void renderScene()`的新原型添加到`source.cpp`文件的顶部。
- en: 'In the `renderScene` function, add the following lines of code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`renderScene`函数中，添加以下代码行：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first function, we call `glClear()`. All OpenGL functions start with
    the `gl` prefix; the `glClear` function clears the buffer. In this case, we are
    asking OpenGL to clear the color buffer and the depth buffer. The color buffer
    is where all the color information is stored for the scene. The depth buffer stores
    whichever pixel is in front; this means that if a pixel is behind another pixel,
    then that pixel will not be stored. This is especially important for 3D scenes,
    where some objects can be behind other objects and get occluded by the objects
    that are in front of it. We only require the pixel information regarding the objects
    that are in front as we will only get to see those objects and not the objects
    that are behind them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个函数中，我们调用 `glClear()`。所有 OpenGL 函数都以 `gl` 前缀开始；`glClear` 函数清除缓冲区。在这种情况下，我们要求
    OpenGL 清除颜色缓冲区和深度缓冲区。颜色缓冲区存储场景中所有的颜色信息。深度缓冲区存储哪个像素在前面；这意味着如果一个像素在另一个像素后面，那么那个像素将不会被存储。这对于
    3D 场景尤为重要，其中一些对象可能位于其他对象后面，并被前面的对象遮挡。我们只需要有关前面对象像素的信息，因为我们只会看到那些对象，而不会看到后面的对象。
- en: Next, we call the `glClearColor` function and pass in an RGBA value; in this
    case, red. The `glCearColor` function clears the color buffer with the specific
    color in every frame. The buffers need to be cleared in every frame; otherwise,
    the previous frame will be overwritten with the image in the current frame. Imagine
    this to be like clearing the blackboard before drawing anything on it in every
    frame.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `glClearColor` 函数并传入一个 RGBA 值；在这种情况下，是红色。`glClearColor` 函数在每一帧中用特定的颜色清除颜色缓冲区。缓冲区需要在每一帧中清除；否则，上一帧将被当前帧中的图像覆盖。想象一下，这就像在每一帧在画板上画任何东西之前清除黑板一样。
- en: The depth buffer is also cleared after every frame using a default white color.
    This means that we don't have to clear it manually as this will be done by default.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 深度缓冲区也在每一帧之后使用默认的白色颜色清除。这意味着我们不需要手动清除它，因为这将是默认操作的。
- en: 'Now, call `renderScene` before swapping the buffer and run the project again.
    You should see a nice yellow viewport, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在交换缓冲区之前调用 `renderScene` 并再次运行项目。你应该会看到一个漂亮的黄色视口，如下所示：
- en: '![](img/f1fccce8-99bb-4500-94d0-a0b3602ac427.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1fccce8-99bb-4500-94d0-a0b3602ac427.png)'
- en: Before drawing the objects, we have to create some additional classes that will
    help us define the shape that we want to draw. We also need to create a camera
    class in order to set up a virtual camera through which we can view the scene.
    Furthermore, we need to write a basic vertex, a `shader` fragment, and a `Shaderloader`
    class, which will create a `shader` program that we can use to render our shape.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制对象之前，我们必须创建一些额外的类，这些类将帮助我们定义想要绘制的形状。我们还需要创建一个相机类，以便设置一个虚拟相机，通过这个相机我们可以查看场景。此外，我们需要编写一个基本的顶点、一个
    `shader` 片段和一个 `Shaderloader` 类，这些类将创建一个 `shader` 程序，我们可以使用它来渲染我们的形状。
- en: First, let's create the `Mesh` class, which is where we will define the different
    shapes that we want to draw.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建 `Mesh` 类，这是我们定义想要绘制的不同形状的地方。
- en: Creating a Mesh class
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Mesh 类
- en: 'The following steps explain how to create a `Mesh` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了如何创建一个 `Mesh` 类：
- en: 'Create new `.h` and `.cpp` files called `Mesh.h` and `Mesh.cpp`, respectively.
    These will be used to create a new `Mesh` class. In the `Mesh.h` file, add the
    following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的 `.h` 和 `.cpp` 文件，分别命名为 `Mesh.h` 和 `Mesh.cpp`。这些文件将用于创建一个新的 `Mesh` 类。在 `Mesh.h`
    文件中，添加以下代码：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the top of the `Mesh.h` file, we include a vector so that we can store points
    in a vector and include `glm.hpp`. This will help us define points in the space
    using the `vec3` variable.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Mesh.h` 文件的顶部，我们包含一个向量，以便我们可以将点存储在向量中，并包含 `glm.hpp`。这将帮助我们使用 `vec3` 变量在空间中定义点。
- en: Then, we create a new `enum` type called `MeshType` and create four types: `Mesh
    Triangle`, `Quad`, `Cube`, and `Sphere`. We've done this so that we can specify
    the kind of mesh we are using and so the data will be populated accordingly.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的 `enum` 类型，称为 `MeshType`，并创建四种类型：`Mesh Triangle`、`Quad`、`Cube` 和
    `Sphere`。我们这样做是为了指定我们使用的网格类型，并且数据将相应地填充。
- en: Next, we create a new `struct` type called `Vertex`, which has `vec3` properties
    called `pos`, `Color`, and `Normal`, and a `vec2` property called `textCoords`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的 `struct` 类型，称为 `Vertex`，它有 `vec3` 属性，分别命名为 `pos`、`Color` 和 `Normal`，以及一个
    `vec2` 属性，称为 `textCoords`。
- en: Each vertex has certain properties, such as `Position`, `Color`, `Normal`, and
    `Texture Coordinate`. `Position` and `Color` store the position and color information
    for each vertex, respectively. `Normal` specifies which direction the normal attribute is
    pointing to while `Texture Coordinate` specifies how a texture needs to be laid
    out. We will cover the normal and texture coordinate attributes when we cover
    lighting and how to apply textures to our objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点都有某些属性，例如 `Position`、`Color`、`Normal` 和 `Texture Coordinate`。`Position`
    和 `Color` 分别存储每个顶点的位置和颜色信息。`Normal` 指定法线属性指向的方向，而 `Texture Coordinate` 指定纹理应该如何布局。当介绍光照和如何将纹理应用到我们的对象时，我们将介绍法线和纹理坐标属性。
- en: Then, the `Mesh` class is created. This has four functions, which are for setting
    the vertex and the index data per vertex.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 `Mesh` 类。这个类有四个函数，用于设置每个顶点的顶点和索引数据。
- en: 'In the `Mesh.cpp` file, we include the `Mesh.h` file and then set the data
    for the four shapes. Here is an example of how `setTriData` sets the values for
    the vertices and indices:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Mesh.cpp` 文件中，我们包含 `Mesh.h` 文件并设置四个形状的数据。以下是如何 `setTriData` 为顶点和索引设置值的示例：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For each of the three vertices of the triangle, we set the position, normal,
    color, and texture coordinate information in the `vertices` vector.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于三角形的三个顶点，我们在 `vertices` 向量中设置位置、法线、颜色和纹理坐标信息。
- en: Next, we set the indices in the `indices` vector. For definitions of the other
    functions, you can refer to the project that comes with this book. Then, we set
    the `_vertices` and `_indices` vectors to the reference vertices and indices,
    respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `indices` 向量中设置索引。关于其他函数的定义，您可以参考本书附带的项目。然后，我们将 `_vertices` 和 `_indices`
    向量分别设置为引用顶点和索引。
- en: Creating a Camera class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `Camera` 类
- en: 'The following steps will help you create a `Camera` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您创建 `Camera` 类：
- en: 'Create two files: `Camera.h` and `Camera.cpp`. In the `Camera.h` file, include
    the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个文件：`Camera.h` 和 `Camera.cpp`。在 `Camera.h` 文件中，包含以下代码：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, create the `Camera` class itself, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 `Camera` 类本身，如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the constructor and the public region of the `camera` class, we get the **field
    of view** (**FOV**), the width and height of the viewport, the distance to `nearPlane`,
    the distance to `farPlane`, and the position that we want to set the camera at.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `camera` 类的构造函数和公共区域中，我们获取**视野**（**FOV**）、视口的宽度和高度、到 `nearPlane` 的距离、到 `farPlane`
    的距离以及我们想要设置相机位置的坐标。
- en: We also add three getters to get the view matrix, projection matrix, and the
    camera position.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了三个获取器来获取视图矩阵、投影矩阵和相机位置。
- en: 'In the private section, we create three variables: two 4 x 4 matrices for setting
    the view and projection matrices and a `vec3` property to specify the camera position.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在私有部分，我们创建三个变量：两个用于设置视图和投影矩阵的 4x4 矩阵和一个 `vec3` 属性来指定相机位置。
- en: 'In the `Camera.cpp` file, we include the `Camera.h` file at the top and create
    the `camera` constructor, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Camera.cpp` 文件中，我们在顶部包含 `Camera.h` 文件并创建 `camera` 构造函数，如下所示：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the constructor, we set the camera position to the local variable and set
    up two `vec3` properties called `cameraFront` and `cameraUp`. Our camera is going
    to be a stationary camera that will always be looking toward the center of the
    world coordinates; the `up` vector will always be pointing toward the positive
    y-axis.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将相机位置设置为局部变量，并设置两个名为 `cameraFront` 和 `cameraUp` 的 `vec3` 属性。我们的相机将是一个静止的相机，始终朝向世界坐标的中心；`up`
    向量始终指向正 y 轴。
- en: To create `viewMatrix`, we call the `glm::lookAt` function and pass in the `cameraPos`,
    `cameraFront`, and `cameraUp` vectors.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 `viewMatrix`，我们调用 `glm::lookAt` 函数，并传入 `cameraPos`、`cameraFront` 和 `cameraUp`
    向量。
- en: We create the projection matrix by setting the `FOV` value of the `FOV`; this
    is an aspect ratio that is given by the `width` value over the `height`, `nearPlane`,
    and `farPlane` values.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过设置 `FOV` 的 `FOV` 值来创建投影矩阵；这是一个由 `width` 值除以 `height`、`nearPlane` 和 `farPlane`
    值给出的宽高比。
- en: 'With the view and projection matrices set, we can now create the getter functions,
    as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置视图和投影矩阵后，我们现在可以创建获取器函数，如下所示：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we'll create the `shaderLoader` class, which will let us create the `shader`
    program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `shaderLoader` 类，这将使我们能够创建 `shader` 程序。
- en: The ShaderLoader class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ShaderLoader` 类'
- en: 'The following steps will show you how to implement the `ShaderLoader` class
    in an OpenGL project:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何在 OpenGL 项目中实现 `ShaderLoader` 类：
- en: In the `ShaderLoader` class, create a public function called `createProgram`
    that takes a vertex and fragment `shader` file.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ShaderLoader` 类中，创建一个名为 `createProgram` 的公共函数，它接收顶点和片段 `shader` 文件。
- en: 'We''ll also create two private functions: `readShader`, which returns a string,
    and `createShader`, which returns an unsigned GL `int`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建两个私有函数：`readShader`，它返回一个字符串，以及 `createShader`，它返回一个无符号的 GL `int`：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `ShaderLoader.cpp` file, we include our `ShaderLoader.h` header file,
    the `iostream` system header file, and the `fstream` vector, as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ShaderLoader.cpp` 文件中，我们包含我们的 `ShaderLoader.h` 头文件、`iostream` 系统头文件和 `fstream`
    向量，如下所示：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`iostream` is used when you want to print something to the console; `fstream`
    is used for reading a file. We''ll need this as we will be passing in vertex and
    shader files for the `fstream` to read, as well as vectors for storing character
    strings.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostream` 用于当你想要将某些内容打印到控制台时；`fstream` 用于读取文件。我们将需要它，因为我们将会传递顶点和着色器文件给 `fstream`
    读取，以及用于存储字符字符串的向量。'
- en: 'First, we create the `readerShader` function; this will be used to read the
    `shader` file that we passed in:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建 `readerShader` 函数；这将用于读取我们传递的 `shader` 文件：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The contents of the `shader` file are then stored in a string and returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`shader` 文件的内容随后被存储在一个字符串中并返回。'
- en: 'Next, we create the `createShader` function, which will actually compile the
    shader, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `createShader` 函数，该函数将实际编译着色器，如下所示：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `CreateShader` function takes the following three parameters:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateShader` 函数接收以下三个参数：'
- en: The first parameter is the `enum` parameter, called `shaderType`, which specifies
    the type of `shader` being sent to be compiled. In this case, it could be a vertex
    shader or a fragment shader.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是 `enum` 参数，称为 `shaderType`，它指定了要编译的 `shader` 类型。在这种情况下，它可以是顶点着色器或片段着色器。
- en: The second parameter is the string that contains the shader code.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是包含着色器代码的字符串。
- en: The final parameter is a string with the `shader` type, which will be used to
    specify whether there is a problem compiling the `shader` type.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是包含 `shader` 类型的字符串，它将用于指定在编译 `shader` 类型时是否存在问题。
- en: In the `CreateShader` function, we call `glCreateShader` in order to specify
    the type of shader that is being created; then, `glCompileShader` is called to
    compile the shader. Afterward, we get the compiled result of the shader.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CreateShader` 函数中，我们调用 `glCreateShader` 以指定正在创建的着色器类型；然后，调用 `glCompileShader`
    编译着色器。之后，我们获取着色器的编译结果。
- en: If there is a problem with compiling the shader, then we send out a message
    stating that there is an error compiling the shader alongside `shaderLog`, which
    will detail the compilation error. If there are no errors during compilation,
    then the shader is returned.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编译着色器存在问题，那么我们将发送一条消息，说明存在编译着色器的错误，并附带 `shaderLog`，其中将详细说明编译错误。如果没有错误发生，则返回着色器。
- en: 'The final function is the `createProgram` function, which takes the `vertex`
    and `fragment` shaders:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数是 `createProgram` 函数，它接收 `vertex` 和 `fragment` 着色器：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function takes the vertex and fragment shader files, reads them, and then
    compiles both files.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数接收顶点和片段着色器文件，读取它们，然后编译这两个文件。
- en: Then, we create a new `shaderProgram` function by calling `glCreateProgram()` and
    assigned to program.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `glCreateProgram()` 创建一个新的 `shaderProgram` 函数并将其分配给程序。
- en: Now, we have to attach both shaders to the program by calling `glAttachShader`
    and passing the program and the shader.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须通过调用 `glAttachShader` 并传递程序和着色器来将两个着色器附加到程序上。
- en: Finally, we link the program by calling `glLinkProgram`. After, we pass in the
    program and check for any linking errors.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过调用 `glLinkProgram` 链接程序。之后，我们传递程序并检查是否有链接错误。
- en: If there are any linking errors, we send out an error message to the console,
    along with a program log that will detail the linking error. If not, then the
    program is returned.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在任何链接错误，我们将向控制台发送错误消息，并附带一个程序日志，其中将详细说明链接错误。如果没有错误，则返回程序。
- en: The Light Renderer class
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照渲染器类
- en: 'Now, it''s time to draw our first object; to do so, perform the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候绘制我们的第一个对象了；为此，执行以下步骤：
- en: We will draw a basic light source that will appear above the current scene so
    that we can visualize the location of the light source in the scene. We will use
    this location of the light source later to calculate the lighting on our object.
    Note that a flat-shaded object doesn't need to have lighting calculations made
    on it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在当前场景上方绘制一个基本的光源，以便我们可以可视化光源在场景中的位置。我们将使用这个光源的位置来计算我们对象上的光照。请注意，具有平面着色的对象不需要在其上进行光照计算。
- en: First, create a `LightRenderer.h` file and a `.cpp` file, and then create the
    `LightRenderer` class.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`LightRenderer.h`文件和一个`.cpp`文件，然后创建`LightRenderer`类。
- en: 'At the top of the `LightRenderer.h` file, include the following headers:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LightRenderer.h`文件的顶部，包含以下头文件：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will need `glew.h` to call the OpenGL commands, while we'll need the `glm`
    headers to define `vec3` and the matrices.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要`glew.h`来调用OpenGL命令，同时我们需要`glm`头文件来定义`vec3`和矩阵。
- en: We will also need `Mesh.h`, which allows us to define the shape of the light
    in the light source. You can use the `ShaderLoader` class to load in the shaders
    in order to render the object and `Camera.h` to get the camera's location, view,
    and projection matrices onto the scene.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`Mesh.h`，它允许我们在光源中定义光的形状。你可以使用`ShaderLoader`类来加载着色器以渲染对象，并使用`Camera.h`来获取相机在场景中的位置、视图和投影矩阵。
- en: 'We will create the `LightRenderer` class next:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来将创建`LightRenderer`类：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will add the following `public` section to this class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这个类添加以下`public`部分：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the public section, we create the constructor that we pass `MeshType` to;
    this will be used to set the shape of the object that we want to render. Then,
    we have the destructor. Here, we have a function called `draw`, which will be
    used to draw the mesh. Then, we have a couple of setters for setting the position,
    color, and shader program for the object.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共部分，我们创建一个构造函数，我们将传递`MeshType`给它；这将用于设置我们想要渲染的对象的形状。然后，我们有析构函数。在这里，我们有一个名为`draw`的函数，它将用于绘制网格。然后，我们有几个设置器用于设置对象的位置、颜色和着色器程序。
- en: 'After defining the public section, we set the `private` section, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义公共部分之后，我们设置`private`部分，如下所示：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the private section, we have a `private` variable so that we can store the
    camera locally. We create vectors to store the vertex and index data; we also
    create local variables to store the position and color information. Then, we have `GLuint`,
    which will store `vbo`, `ebo`, `vao`, and the program variable.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`private`部分，我们有一个`private`变量，以便我们可以局部存储相机。我们创建向量来存储顶点和索引数据；我们还创建局部变量来存储位置和颜色信息。然后，我们有`GLuint`，它将存储`vbo`、`ebo`、`vao`和程序变量。
- en: 'The program variable will have the shader program that we want to use to draw
    the object. Then, we have `vbo`, which stands for vertex buffer object; `ebo`,
    which stands for Element Buffer Object; and `vao`, which stands for Vertex Array
    Object. Let''s examine each of these buffer objects and find out what they do:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 程序变量将包含我们想要用于绘制对象的着色器程序。然后，我们有`vbo`，代表顶点缓冲对象；`ebo`，代表元素缓冲对象；以及`vao`，代表顶点数组对象。让我们检查这些缓冲对象并了解它们的作用：
- en: '**Vertex Buffer Object** (**VBO**): This is the geometrical information; it
    includes attributes such as position, color, normal, and texture coordinates.
    These are stored on a per vertex basis on the GPU.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点缓冲对象**（**VBO**）：这是几何信息；它包括位置、颜色、法线和纹理坐标等属性。这些属性在GPU上按顶点存储。'
- en: '**Element Buffer Object** (**EBO**): This is used to store the index of each
    vertex and will be used while drawing the mesh.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素缓冲对象**（**EBO**）：用于存储每个顶点的索引，并在绘制网格时使用。'
- en: '**Vertex Array Object** (**VAO**): This is a helper container object that stores
    all the VBOs and attributes. This is used as you may have more than one VBO per
    object, and it would be tedious to bind the VBOs all over again when you render
    each frame.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点数组对象**（**VAO**）：这是一个辅助容器对象，用于存储所有的VBOs和属性。当你为每个对象渲染每一帧时，你可能会有多个VBOs，因此再次绑定VBOs会变得繁琐。'
- en: Buffers are used to store information in the GPU memory for fast and efficient
    access to the data. Modern GPUs have a memory bandwidth of approximately 600 GB/s,
    which is enormous compared to the current high-end CPUs that only have approximately
    12 GB/s.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区用于在GPU内存中存储信息，以便快速高效地访问数据。现代GPU的内存带宽大约为600 GB/s，与当前高端CPU的约12 GB/s相比，这是一个巨大的差距。
- en: Buffer objects are used to store, retrieve, and move data. It is very easy to
    generate a buffer object in OpenGL. You can easily generate one by calling `glGenBuffers()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区对象用于存储、检索和移动数据。在OpenGL中生成缓冲区对象非常容易。你可以通过调用`glGenBuffers()`轻松地生成一个。
- en: 'That is all for `LightRender.h`; now, let''s move on to `LightRenderer.cpp`,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`LightRender.h`的全部内容；现在，让我们继续到`LightRenderer.cpp`，如下所示：
- en: 'At the top of `LightRenderer.cpp`, include `LightRenderer.h`. Then, add the
    constructor, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LightRenderer.cpp`的顶部，包含`LightRenderer.h`。然后，添加构造函数，如下所示：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `LightRenderer` constructor, we start adding the code. First, we initialize
    the local camera, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LightRenderer`构造函数中，我们开始添加代码。首先，我们初始化本地相机，如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we set the shape of the object that we want to draw, depending on the
    `MeshType` type. For this, we will create a `switch` statement and call the appropriate
    `setData` function, depending on the type, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们设置我们想要绘制的对象的形状，这取决于`MeshType`类型。为此，我们将创建一个`switch`语句并调用适当的`setData`函数，如下所示：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will generate and bind the `vao` buffer object, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将生成并绑定`vao`缓冲区对象，如下所示：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `glGenVertexArrays` function takes two parameters; the first parameter is
    the number of vertex array object names that we want to generate. In this case,
    we just want to create one, so it is specified as such. The second parameter takes
    in an array where the vertex array names are stored, so we pass in the `vao` buffer
    object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`glGenVertexArrays`函数需要两个参数；第一个参数是我们想要生成的顶点数组对象名称的数量。在这种情况下，我们只想创建一个，所以它被这样指定。第二个参数接受一个数组，其中存储了顶点数组名称，因此我们传递了`vao`缓冲区对象。'
- en: The `glBindVertexArray` function is called `next`, and `vao` is passed into
    it in order to bind the `vao` buffer object. The `vao` buffer object will be bound
    for the duration of the application. A buffer is an object that's managing a certain
    piece of memory; buffers can be of different types and, therefore, they need to
    be bound to a specific buffer target so that they can give meaning to the buffer.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用`glBindVertexArray`函数，并将`vao`传递给它以绑定`vao`缓冲区对象。`vao`缓冲区对象将在应用程序的整个运行期间被绑定。缓冲区是一个管理特定内存块的对象；缓冲区可以是不同类型的，因此它们需要绑定到特定的缓冲区目标，以便它们可以为缓冲区赋予意义。
- en: Once the `vao` buffer object has been bound, we can generate the vertex buffer
    object and store the vertex attributes.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`vao`缓冲区对象被绑定，我们就可以生成顶点缓冲区对象并存储顶点属性。
- en: 'To generate the vertex buffer object, we call `glGenBuffers()`; this also takes
    two parameters. The first parameter is the number of buffers that we want to generate,
    while the second is the array of VBOs. In this case, since we have one `vbo` buffer
    object, we will just pass in `1` for the first parameter and pass in the `vbo`
    as the second parameter:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成顶点缓冲区对象，我们调用`glGenBuffers()`；这也需要两个参数。第一个参数是我们想要生成的缓冲区数量，而第二个参数是VBO数组。在这种情况下，因为我们只有一个`vbo`缓冲区对象，所以我们将第一个参数设置为`1`，并将`vbo`作为第二个参数传递：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we have to specify the buffer type. This is done by using the `glBindBuffer()` function;
    this takes two parameters again. The first is the buffer type and, in this case,
    it is of the `GL_ARRAY_BUFFER` type, while the second parameter is the name of
    the buffer object, which is `vbo`. Now, add the following line of code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须指定缓冲区类型。这是通过使用`glBindBuffer()`函数完成的；它再次需要两个参数。第一个是缓冲区类型，在这种情况下，它是`GL_ARRAY_BUFFER`类型，而第二个参数是缓冲区对象的名称，即`vbo`。现在，添加以下代码行：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the next step, we actually pass in the data that we want to store in the
    buffer. This is done by calling `glBufferData`; the `glBufferData` function takes
    four parameters:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们实际上传递了我们要存储在缓冲区中的数据。这是通过调用`glBufferData`完成的；`glBufferData`函数需要四个参数：
- en: The first parameter is the buffer type, which, in this case, is `GL_ARRAY_BUFFER`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是缓冲区类型，在这种情况下，是`GL_ARRAY_BUFFER`。
- en: The second parameter is the size in bytes of the buffer data to store.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是要存储的缓冲区数据的字节数。
- en: The third parameter is the pointer to the data, which will be copied.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是指向数据的指针，该数据将被复制。
- en: The fourth parameter is the expected usage of the data being stored.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是存储数据的预期用途。
- en: In our case, we will just modify the data once and use it many times, so it
    will be called `GL_STATIC_DRAW`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只需修改一次数据并多次使用它，所以它将被称为`GL_STATIC_DRAW`。
- en: 'Now, add the `glBufferData` function for storing the data, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加用于存储数据的`glBufferData`函数，如下所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we have to set the vertex attributes that we are going to use. While creating
    the `struct` vertex, we have attributes such as position, color, normal, and texture
    coordinates; however, we may not need all of these attributes all of the time.
    Therefore, we only need to specify the ones that we need. In our case, since we
    are not using any lighting calculation or applying any textures to the object,
    we don't need to specify this – we will just need the position and color attributes
    for now. However, these attributes need to be enabled first.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须设置我们将要使用的顶点属性。在创建`struct`顶点时，我们有位置、颜色、法线和纹理坐标等属性；然而，我们可能并不总是需要所有这些属性。因此，我们只需要指定我们需要的属性。在我们的例子中，由于我们不使用任何光照计算或应用任何纹理到对象上，我们不需要指定这些属性——我们现在只需要位置和颜色属性。然而，这些属性需要首先启用。
- en: 'To enable these attributes, we''ll call `glEnableVertexAttribArray` and pass
    in the index that we want to enable. The position will be in the 0th index, so
    we will set the value as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用这些属性，我们将调用`glEnableVertexAttribArray`并传入我们想要启用的索引。位置将在0号索引，因此我们将值设置为如下：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we call `glVertexAttribPointer` so that we can set the attribute that
    we want to use. The first attribute will be positioned at the 0th index. This
    takes six parameters, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用`glVertexAttribPointer`以便我们可以设置我们想要使用的属性。第一个属性将位于0号索引。这需要六个参数，如下所示：
- en: The first parameter is the index of the vertex attribute, which, in this case,
    is 0.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是顶点属性的索引，在这个例子中，它是0。
- en: The second parameter is the size of the attribute. Essentially, this is the
    number of components that the vertex attribute has. In this case, it is the position
    of the *x*, *y*, and *z* components, so it is specified as `3`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是属性的大小。本质上，这是顶点属性拥有的组件数量。在这种情况下，它是*x*、*y*和*z*组件的位置，因此指定为`3`。
- en: The third parameter is for the variable types of the components; since they
    are specified in `GLfloat`, we specify `GL_FLOAT`.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数用于组件的变量类型；由于它们在`GLfloat`中指定，我们指定`GL_FLOAT`。
- en: The fourth parameter is a Boolean that specifies whether the values should be
    normalized or whether they should be converted into fixed-point values. Since
    we don't want the values to be normalized, we specify `GL_FALSE`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是一个布尔值，指定值是否应该被归一化或是否应该转换为定点值。由于我们不希望值被归一化，我们指定`GL_FALSE`。
- en: 'The fifth parameter is called the stride, which is the offset of consecutive
    vertex attributes. Imagine the vertices being laid out in the memory as follows.
    The stride refers to the blocks of memory that you will have to go through to
    get to the next set of vertex attributes; this is the size of the `struct` vertex:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数称为步长，它是连续顶点属性之间的偏移量。想象一下顶点在内存中的布局如下。步长指的是你将必须通过以到达下一组顶点属性；这是`struct`顶点的大小：
- en: '![](img/351fcc48-0f0d-46fe-871f-6123bdb95baf.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/351fcc48-0f0d-46fe-871f-6123bdb95baf.png)'
- en: 'The sixth parameter is the offset of the first component of the vertex attribute
    within the `struct` vertex. The attribute that we are looking at here is the position
    attribute, which is at the start of the `struct` vertex, so we will pass `0`:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六个参数是顶点属性在`struct`顶点中第一个组件的偏移量。我们正在查看的属性是位置属性，它在`struct`顶点的开始处，因此我们将传递`0`：
- en: '![](img/19796af6-4a67-44f2-827d-5abf7621efe9.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19796af6-4a67-44f2-827d-5abf7621efe9.png)'
- en: 'Set the `glVertexAttribute` pointer, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`glVertexAttribute`指针，如下所示：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s create one more attribute pointer so that we can color the object. Like
    we did previously, we need to enable the attribute and set the `attrib` pointer,
    as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再创建一个属性指针，以便我们可以为对象着色。像之前一样，我们需要启用属性并设置`attrib`指针，如下所示：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since the next attribute index is `1`, we enable the attribute array using `1`.
    While setting the attribute pointer, the first parameter is `1`, since this is
    the first index. `color` has three components – *r*, *g*, and *b –* so the next
    parameter is `3`. Colors are defined as floats, and so we specify `GL_FLOAT` for
    this parameter.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于下一个属性索引是`1`，我们使用`1`启用属性数组。在设置属性指针时，第一个参数是`1`，因为这是第一个索引。`color`有三个组件——*r*、*g*和*b*——所以下一个参数是`3`。颜色定义为浮点数，因此我们指定`GL_FLOAT`作为此参数。
- en: Since we don't want the fourth parameter to be normalized, we set the parameter
    to `GL_FALSE`. The fifth parameter is the stride and it is still equal to the
    size of the `struct` vertex. Finally, for the offset, we use the `offsetof` function
    to set the offset of `vertex::color` in the `struct` vertex.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不希望第四个参数被归一化，我们将参数设置为 `GL_FALSE`。第五个参数是步长，它仍然等于 `struct` 顶点的尺寸。最后，对于偏移量，我们使用
    `offsetof` 函数来设置 `struct` 顶点中 `vertex::color` 的偏移量。
- en: 'Next, we have to set the element buffer object. This is done in the same way
    as setting the vertex buffer object: we need to generate the element, set the
    binding, and then bind the data to the buffer, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置元素缓冲区对象。这是通过与设置顶点缓冲区对象相同的方式进行：我们需要生成元素，设置绑定，然后将数据绑定到缓冲区，如下所示：
- en: 'First, we generate the buffer by calling `glGenBuffers`. This is done by passing
    in the number of buffers that we want to create, which is `1`, and then passing
    in the name of the buffer object to generate it:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过调用 `glGenBuffers` 来生成缓冲区。这是通过传递我们想要创建的缓冲区数量，即 `1`，然后传递要生成的缓冲区对象的名称来完成的：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we bind the buffer type to the buffer object, which, in this case, is
    `GL_ELEMENT_ARRAY_BUFFER`. It will store the element or index data.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将缓冲区类型绑定到缓冲区对象上，在这个例子中，它是 `GL_ELEMENT_ARRAY_BUFFER`。它将存储元素或索引数据。
- en: Then, we set the index data itself by calling `glBufferData`. We pass in the
    buffer type first, set the size of the element data, and then pass in the data
    and the usage with `GL_STATIC_DRAW`, like we did previously.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `glBufferData` 来设置索引数据本身。我们首先传递缓冲区类型，设置元素数据的大小，然后传递数据和用法 `GL_STATIC_DRAW`，就像我们之前做的那样。
- en: 'At the end of the constructor, we unbind the buffer and the vertex array as
    a precaution:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的末尾，我们作为预防措施解绑缓冲区和顶点数组：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we will create the `draw` function; this will be used to draw the object
    itself. To do this, add the `draw` function, as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `draw` 的函数；这个函数将用于绘制对象本身。为此，添加以下 `draw` 函数：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will use this function to add the code for drawing the object. The first
    thing we will do is create a `glm::mat4` function called `model` and initialize
    it; then, we will use the `glm::translate` function to translate the object to
    the required position:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用这个函数来添加绘制对象的代码。我们首先要做的是创建一个名为 `model` 的 `glm::mat4` 函数并初始化它；然后，我们将使用 `glm::translate`
    函数将对象移动到所需的位置：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we will set the model, view, and projection matrices to transform the
    object from its local space. This was covered in [Chapter 2](ee788533-687d-4231-91a4-cb1de9ca01dd.xhtml),
    *Mathematics and Graphics Concepts,* so now is a good time for you to go and refresh
    your memory of graphics concepts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置模型、视图和投影矩阵来将对象从其局部空间转换。这已经在 [第 2 章](ee788533-687d-4231-91a4-cb1de9ca01dd.xhtml)
    中介绍过，即 *数学和图形概念*，所以现在是你去复习图形概念的好时机。
- en: 'The model, view, and projection matrices are set in the vertex shader. Information
    is sent to the shader by calling `glUseProgram`, which takes in a shader program:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、视图和投影矩阵在顶点着色器中设置。通过调用 `glUseProgram` 并传入一个着色器程序来将信息发送到着色器。
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we can send the required information through the uniform variables. We
    will create a uniform data type in the shader using a name. In the `draw` function,
    we need to get the location of this uniform variable by calling `glGetUniformLocation`,
    and then passing in the program and the variable string in the shader that we
    set, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过统一变量发送所需的信息。在着色器中，我们将使用一个名称创建一个统一数据类型。在 `draw` 函数中，我们需要通过调用 `glGetUniformLocation`
    来获取这个统一变量的位置，然后传递程序和我们在着色器中设置的变量字符串，如下所示：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will return a `GLuint` value with the location of the variable, which is
    the model matrix here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含变量位置的 `GLuint` 值，在这里是模型矩阵。
- en: Now, we can set the value of the model matrix using the `glUniform` function.
    Since we are setting a matrix uniform, we use the `glUniformMatrix3fv` function;
    this takes four parameters. The first parameter is the location that we obtained
    in the previous step, whereas the second parameter is the amount of data that
    we are passing in; in this case, we are just passing in one matrix, so we specify
    this as `1`. The third parameter is a Boolean value, which specifies whether the
    data needs to be transposed. We don't want the matrix to be transposed, so we
    specify it as `GL_FALSE`. The final parameter is the pointer to the data, `gl::ptr_value`;
    we pass this into the model matrix.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`glUniform`函数设置模型矩阵的值。由于我们正在设置一个矩阵统一变量，我们使用`glUniformMatrix3fv`函数；它接受四个参数。第一个参数是我们之前获得的定位，第二个参数是我们传递的数据量；在这种情况下，我们只传递一个矩阵，所以我们将其指定为`1`。第三个参数是一个布尔值，它指定数据是否需要转置。我们不希望矩阵被转置，所以我们将其指定为`GL_FALSE`。最后一个参数是数据的指针，`gl::ptr_value`；我们将其传递给模型矩阵。
- en: 'Now, add the function to set the model matrix, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加设置模型矩阵的函数，如下所示：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similar to the model matrix, we have to pass in the view and projection matrices
    to the shader as well. To do this, we get the view and projection matrices from
    the `camera` class. Then, we get the location of the uniform variable that we
    defined in the shader and set the value of the view and projection matrices using
    the `glUniformMatrix4fv` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型矩阵类似，我们必须将视图和投影矩阵传递给着色器。为此，我们从`camera`类中获取视图和投影矩阵。然后，我们获取在着色器中定义的统一变量的位置，并使用`glUniformMatrix4fv`函数设置视图和投影矩阵的值：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we have all the required data to draw the object, we can finally draw the
    object. At this point, we call `glBindVertexArray`, bind the `vao` buffer object,
    and then call the `glDrawElements` function to draw the object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了绘制对象所需的所有数据，我们就可以最终绘制对象了。在这个时候，我们调用`glBindVertexArray`，绑定`vao`缓冲区对象，然后调用`glDrawElements`函数来绘制对象。
- en: The `glDrawElements` function takes four parameters. The first parameter is
    the mode that we can use to draw the lines by calling `GL_LINES`. Alternatively,
    we can draw triangles by using `GL_TRIANGLES`. There are, in fact, many more types
    of modes that can be specified, but in our case, we will only specify `GL_TRIANGLES`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`glDrawElements`函数接受四个参数。第一个参数是我们可以通过调用`GL_LINES`来绘制的线条模式。或者，我们可以使用`GL_TRIANGLES`来绘制三角形。实际上，还有更多类型的模式可以指定，但在这个案例中，我们只会指定`GL_TRIANGLES`。'
- en: The second parameter is the number of elements or the number of indices that
    need to be drawn. This is specified when we created the object. The third parameter
    is the type of index data that we will be passing, which is of the `GL_UNSIGNED_INT` type.
    The final parameter is the location where the indices are stored – this is set
    to 0.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是需要绘制的元素数量或索引数量。这是在我们创建对象时指定的。第三个参数是我们将要传递的索引数据类型，它是`GL_UNSIGNED_INT`类型。最后一个参数是索引存储的位置——这被设置为0。
- en: 'Add the following lines of code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For safety purposes, we will unbind the vertex array and the program variable
    by setting their values to `0`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们将通过将它们的值设置为`0`来解绑顶点数组和程序变量：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This marks the end of the `draw` function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着`draw`函数的结束。
- en: 'Add the destructor and the rest of the setters and getters to finish the class,
    as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加析构函数以及其余的设置器和获取器以完成类的定义，如下所示：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Drawing the object
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制对象
- en: 'Let''s go back to the `source.cpp` file and render `LightRenderer`, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`source.cpp`文件，并按照以下方式渲染`LightRenderer`：
- en: 'At the top of the file, include `ShaderLoader.h`, `Camera.h`, and `LightRenderer.h`,
    and then create an instance of the `Camera` and `LightRenderer` classes called
    `camera` and `light`, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，包含`ShaderLoader.h`、`Camera.h`和`LightRenderer.h`，然后创建一个名为`camera`和`light`的`Camera`和`LightRenderer`类实例，如下所示：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create a new function called `initGame` and add the prototype for it to the
    top of the file. In the `gameInit` function, load the shader and initialize the
    camera and light.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`initGame`的新函数，并将其原型添加到文件顶部。在`gameInit`函数中，加载着色器并初始化相机和光源。
- en: 'Add the new function, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的函数，如下所示：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first thing we do is enable depth testing so that only the pixels in the
    front are drawn. This is done by calling the `glEnable()` function and passing
    in the `GL_DEPTH_TEST` variable; this will enable the following depth test:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是启用深度测试，以便只绘制前方的像素。这是通过调用`glEnable()`函数并传入`GL_DEPTH_TEST`变量来完成的；这将启用以下深度测试：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will create a new instance of `ShaderLoader` called `shader` in the
    `init` function. Then, we need to call the `createProgram` function and pass in
    the vertex and fragment shader files to shade in the light source. The program
    will return a `GLuint` value, which we store in a variable called `flatShaderProgram`,
    as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`init`函数中，我们将创建一个名为`shader`的新`ShaderLoader`实例。然后，我们需要调用`createProgram`函数并将顶点和片段着色器文件传递进去以着色光源。程序将返回一个`GLuint`值，我们将其存储在一个名为`flatShaderProgram`的变量中，如下所示：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The vertex and shader files are located in the `Assets` folder under `Shaders`;
    the `FlatModel.vs` file will look as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点和着色器文件位于`Shaders`文件夹下的`Assets`文件夹中；`FlatModel.vs`文件将如下所示：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`#version` specifies the version of GLSL that we are using, which is `450`.
    This stands for OpenGL version 4.50\. Next, `layout (location = 0)` and `layout
    (location = 1)` specify the location of the vertex attributes that are passed
    in; in this case, this is the position and color. The `0` and `1` indices correspond
    to the index numbers while setting `vertexAttribPointer`. In the variables that
    are specified, this data is placed in the shader and stored in shader-specific `vec3`
    data types called `Position` and `Color`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`#version`指定了我们使用的GLSL版本，即`450`。这代表OpenGL版本4.50。接下来，`layout (location = 0)`和`layout
    (location = 1)`指定了传入的顶点属性的位置；在这种情况下，这是位置和颜色。`0`和`1`索引对应于设置`vertexAttribPointer`时的索引号。在指定的变量中，这些数据被放置在着色器中，并存储在着色器特定的`vec3`数据类型中，称为`Position`和`Color`。'
- en: The three uniforms that we sent from the `draw` call for storing the model,
    view, and projection matrices are stored in a variable type called `uniform` and
    a `mat4` store data type, both of which are matrices. After this, we create another
    variable of the `out` type, which specifies that this will be sent out of the
    vertex shader; this is of the `vec3` type and is called `outColor`. Next, all
    the actual work is done inside the `main` function. For this, we transform the
    local coordinate system by multiplying the position by the model, view, and projection
    matrices. The result is stored in a GLSL intrinsic variable called `gl_Position`—this
    is the final position of the object. Then, we store the `Color` attribute in the
    `out vec3` variable that we created called `outColor`—that's it for the vertex
    shader!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`draw`调用中发送的用于存储模型、视图和投影矩阵的三个统一变量存储在一个名为`uniform`的变量类型和一个`mat4`存储数据类型中，两者都是矩阵类型。之后，我们创建另一个名为`out`类型的变量，指定这将从顶点着色器发送出去；这是`vec3`类型，称为`outColor`。接下来，所有实际工作都在`main`函数内部完成。为此，我们通过乘以模型、视图和投影矩阵来变换局部坐标系。结果是存储在名为`gl_Position`的GLSL内建变量中——这是物体的最终位置。然后，我们将`Color`属性存储在我们创建的名为`outColor`的`out
    vec3`变量中——这就是顶点着色器的工作内容！
- en: 'Next, let''s take a look at the fragment shader''s `FlatModel.fs` file:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下片段着色器的`FlatModel.fs`文件：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the fragment shader file, we also specify the version of GLSL that we are
    using.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器文件中，我们也指定了我们使用的GLSL版本。
- en: Next, we specify an `in vec3` variable called `outColor`, which will be the
    color that was sent out of the vertex shader. This can be used in the fragment
    shader. We also create an `out vec4` variable called `color`, which will be sent
    out of the fragment shader and will be used to color the object. The color that's
    being sent out of the fragment shader is expected to be a `vec4` variable. Then,
    in the main function, we convert `outColor` from a `vec3` variable into a `vec4` variable,
    and then set it to the `color` variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定一个名为`outColor`的`in vec3`变量，它将是从顶点着色器发送出的颜色。这可以在片段着色器中使用。我们还创建了一个名为`color`的`out
    vec4`变量，它将从片段着色器发送出去，并用于着色物体。从片段着色器发送出的颜色预期是一个`vec4`变量。然后，在主函数中，我们将`outColor`从`vec3`变量转换为`vec4`变量，并将其设置为`color`变量。
- en: In the shaders, we can convert a `vec3` variable into a `vec4` variable by simply
    performing the following operation. This may look a bit strange, but for the sake
    of convenience, this unique feature is available in shader programming to make
    our lives a little easier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中，我们可以通过执行以下操作将`vec3`变量转换为`vec4`变量。这看起来可能有点奇怪，但为了方便起见，这种独特功能在着色器编程中可用，使我们的生活变得稍微容易一些。
- en: 'Going back to the `source.cpp` file, when we pass in the vertex and fragment
    shader files, they will create `flatShaderProgram`. Next, in the `initGame` function,
    we create and initialize the camera, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`source.cpp`文件，当我们传递顶点和片段着色器文件时，它们将创建`flatShaderProgram`。接下来，在`initGame`函数中，我们创建并初始化相机，如下所示：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we create a new camera with an FOV of `45`, a width and height of `800`
    x `600`, a near and far plane of `0.1f` and `100.0f`, as well as a position of
    `0` along the *X*-axis, `4.0` along the Y-axis, and `6.0` along the Z-axis.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个具有`45`度视野、宽度和高度为`800` x `600`、近平面和远平面分别为`0.1f`和`100.0f`的新相机，以及沿*X*轴`0`的位置、沿Y轴`4.0`的位置和沿Z轴`6.0`的位置。
- en: 'Next, we create `light`, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`light`，如下所示：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is done with the shape of a triangle, which is then passed to the camera.
    Then, we set the shader to `flatShaderProgram` and set the position to the center
    of the world.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是通过三角形的形状实现的，然后将其传递给相机。然后，我们将着色器设置为`flatShaderProgram`并将位置设置为世界中心。
- en: 'Now, we call the `draw` function of the light in the `renderScene()` function,
    as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在`renderScene()`函数中调用光的`draw`函数，如下所示：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I changed the clear screen color to yellow so that the triangle can be seen
    clearly. Next, call the `initGame` function in the `main` function, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将清除屏幕颜色改为黄色，以便可以清楚地看到三角形。接下来，在`main`函数中调用`initGame`函数，如下所示：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Delete the camera and light at the end so that the system resource is released.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后删除相机和光源，以便释放系统资源。
- en: 'Now, run the project to see the glorious triangle that we set as the shape
    of the light source:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目以查看我们设置为光源形状的辉煌三角形：
- en: '![](img/7deb66c1-2c3c-4ca6-b00c-931c519ebb61.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7deb66c1-2c3c-4ca6-b00c-931c519ebb61.png)'
- en: 'Change the `MeshType` type to cube to see a cube being drawn instead:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MeshType`类型更改为`cube`以查看绘制的是立方体：
- en: '![](img/5dae76b6-4eac-495b-a865-a2d452a444b9.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dae76b6-4eac-495b-a865-a2d452a444b9.png)'
- en: If you get an error instead of the colored object as output, then this could
    either mean that you have done something incorrectly or that your drivers haven't
    been updated and that your GPU doesn't support OpenGL 4.5.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到错误而不是彩色对象作为输出，那么这可能意味着你做错了什么，或者你的驱动程序没有更新，你的GPU不支持OpenGL 4.5。
- en: 'To make sure GLFW supports the version of your driver, add the following code,
    which checks for any GLFW errors. Then, run the project and look at the console
    output for any errors:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保GLFW支持你的驱动程序版本，添加以下代码，该代码检查任何GLFW错误。然后，运行项目并查看控制台输出中的任何错误：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you get the following output, then this could mean that the OpenGL version
    you''re using is not supported:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到以下输出，那么这可能意味着你使用的OpenGL版本不受支持：
- en: '![](img/1a6a8556-ab34-460b-b184-429841ce741b.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a6a8556-ab34-460b-b184-429841ce741b.png)'
- en: 'This will be accompanied by the following error, suggesting that the GLSL version
    you''re using is not supported:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将伴随着以下错误，提示你使用的GLSL版本不受支持：
- en: '![](img/845bccb8-4844-4fee-a27e-fb487739520e.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/845bccb8-4844-4fee-a27e-fb487739520e.png)'
- en: In this case, change the version of the shader code at the top of the shader
    to `330` instead of `450`, and then try running the project again.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将着色器顶部代码的版本更改为`330`而不是`450`，然后再次尝试运行项目。
- en: This should give you the desired output.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给出你期望的输出。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a new OpenGL project and added the necessary libraries
    to get the project working. Then, we created a new window to work with using GLFW.
    After using a couple more lines of code, we were able to clear the viewport with
    the color of our choice.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个新的OpenGL项目并添加了必要的库以使项目工作。然后，我们使用GLFW创建了一个新窗口进行工作。在编写几行代码之后，我们能够使用我们选择的颜色清除视口。
- en: Next, we started preparing some classes that could help us draw objects such
    as the `Mesh` class, which defined the shape of the object, and the `Camera` class,
    which we use in order to view the object. Then, we created a `ShaderLoader` class,
    which helped us create the shader program that is used to draw the object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始准备一些可以帮助我们绘制对象（如`Mesh`类，它定义了对象的形状，以及我们用来查看对象的`Camera`类）的类。然后，我们创建了一个`ShaderLoader`类，它帮助我们创建用于绘制对象的着色器程序。
- en: With the necessary preparation done, we created a `LightRenderer` class. This
    is used to draw an object that represents a light position that's defined by a
    shape. We used this class to draw our first object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成必要的准备后，我们创建了一个`LightRenderer`类。这个类用于绘制一个代表由形状定义的光源位置的对象。我们使用这个类来绘制我们的第一个对象。
- en: In the next chapter, we will explore how to draw other objects by adding textures
    and physics to the rendering engine.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过向渲染引擎添加纹理和物理效果来绘制其他对象。
