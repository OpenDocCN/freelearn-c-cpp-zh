["```cpp\ntcpdump -x tcp port 80\n```", "```cpp\ntelnet amazon.com 80\n```", "```cpp\ntcpdump -i lo udp port 45998 -X\n```", "```cpp\necho -n \"welcome\" | nc -w 1 -u localhost 45998\n```", "```cpp\nb07d3ef41346:/# telnet amazon.com 443\n```", "```cpp\nb07d3ef41346:/# netstat -ntp\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <iostream>\n\nconstexpr unsigned int SERVER_PORT = 50544;\nconstexpr unsigned int MAX_BUFFER = 128;\n```", "```cpp\nint main(int argc, char *argv[])\n{\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) \n    {\n        std::cerr << \"socket error\" << std::endl;\n        return 1;\n    }\n    struct hostent* server = gethostbyname(argv[1]);\n    if (server == nullptr) \n    {\n        std::cerr << \"gethostbyname, no such host\" << std::endl;\n        return 2;\n    }\n```", "```cpp\n    struct sockaddr_in serv_addr;\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    bcopy((char *)server->h_addr, \n          (char *)&serv_addr.sin_addr.s_addr, \n          server->h_length);\n    serv_addr.sin_port = htons(SERVER_PORT);\n    if (connect(sockfd, (struct sockaddr *) &serv_addr, sizeof\n        (serv_addr)) < 0)\n    {\n        std::cerr << \"connect error\" << std::endl;\n        return 3;\n    }\n```", "```cpp\n    std::string readBuffer (MAX_BUFFER, 0);\n    if (read(sockfd, &readBuffer[0], MAX_BUFFER-1) < 0)\n    {\n        std::cerr << \"read from socket failed\" << std::endl;\n        return 5;\n    }\n    std::cout << readBuffer << std::endl;\n```", "```cpp\n    std::string writeBuffer (MAX_BUFFER, 0);\n    std::cout << \"What message for the server? : \";\n    getline(std::cin, writeBuffer);\n    if (write(sockfd, writeBuffer.c_str(), strlen(write\n        Buffer.c_str())) < 0) \n    {\n        std::cerr << \"write to socket\" << std::endl;\n        return 4;\n    }\n```", "```cpp\n    close(sockfd);\n    return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <iostream>\n#include <arpa/inet.h>\n\nconstexpr unsigned int SERVER_PORT = 50544;\nconstexpr unsigned int MAX_BUFFER = 128;\nconstexpr unsigned int MSG_REPLY_LENGTH = 18;\n```", "```cpp\nint main(int argc, char *argv[])\n{\n     int sockfd =  socket(AF_INET, SOCK_STREAM, 0);\n     if (sockfd < 0)\n     {\n          std::cerr << \"open socket error\" << std::endl;\n          return 1;\n     }\n\n     int optval = 1;\n     setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const\n       void *)&optval , sizeof(int));\n\n```", "```cpp\n     struct sockaddr_in serv_addr, cli_addr;\n     bzero((char *) &serv_addr, sizeof(serv_addr));\n     serv_addr.sin_family = AF_INET;\n     serv_addr.sin_addr.s_addr = INADDR_ANY;\n     serv_addr.sin_port = htons(SERVER_PORT);\n     if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof\n        (serv_addr)) < 0)\n     {\n          std::cerr << \"bind error\" << std::endl;\n          return 2;\n     }\n```", "```cpp\n     listen(sockfd, 5);\n     socklen_t clilen = sizeof(cli_addr);\n     int newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, \n         &clilen);\n     if (newsockfd < 0)\n     {\n          std::cerr << \"accept error\" << std::endl;\n          return 3;\n     }\n```", "```cpp\n     std::cout << \"server: got connection from = \"\n               << inet_ntoa(cli_addr.sin_addr)\n               << \" and port = \" << ntohs(cli_addr.sin_port)\n                  << std::endl;\n     write(incomingSock, \"You are connected!\", MSG_REPLY_LENGTH);\n```", "```cpp\n     std::string buffer (MAX_BUFFER, 0);\n     if (read(incomingSock, &buffer[0], MAX_BUFFER-1) < 0)\n     {\n          std::cerr << \"read from socket error\" << std::endl;\n          return 4;\n     }\n     std::cout << \"Got the message:\" << buffer << std::endl;\n```", "```cpp\n     close(incomingSock);\n     close(sockfd);\n     return 0;\n}\n```", "```cpp\nsocket() -> connect() -> send() -> receive()\n```", "```cpp\nsocket() -> bind() -> listen() -> accept() -> receive() -> send()\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <iostream>\n#include <arpa/inet.h>\n\n```", "```cpp\nconstexpr unsigned int SERVER_PORT = 50544;\nconstexpr unsigned int MAX_BUFFER = 128;\n```", "```cpp\nint main(int argc, char *argv[])\n{\n     int sockfd =  socket(AF_INET, SOCK_DGRAM, 0);\n     if (sockfd < 0) \n     {\n          std::cerr << \"open socket error\" << std::endl;\n          return 1;\n     }\n     int optval = 1;\n     setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void \n         *)&optval , sizeof(int));\n```", "```cpp\n     struct sockaddr_in serv_addr, cli_addr;\n     bzero((char *) &serv_addr, sizeof(serv_addr));\n     serv_addr.sin_family = AF_INET;  \n     serv_addr.sin_addr.s_addr = INADDR_ANY;  \n     serv_addr.sin_port = htons(SERVER_PORT);\n     if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof\n        (serv_addr)) < 0)\n     {\n          std::cerr << \"bind error\" << std::endl;\n          return 2;\n     }\n```", "```cpp\n     std::string buffer (MAX_BUFFER, 0);\n     unsigned int len;\n     if (recvfrom(sockfd, &buffer[0], \n                  MAX_BUFFER, 0, \n                  (struct sockaddr*)& cli_addr, &len) < 0)\n     {\n          std::cerr << \"recvfrom failed\" << std::endl;\n          return 3;\n     }\n     std::cout << \"Got the message:\" << buffer << std::endl;\n```", "```cpp\n     std::string outBuffer (\"Message received!\");\n     if (sendto(sockfd, outBuffer.c_str(), \n                outBuffer.length(), 0, \n                (struct sockaddr*)& cli_addr, len) < 0)\n     {\n          std::cerr << \"sendto failed\" << std::endl;\n          return 4;\n     }\n```", "```cpp\n     close(sockfd);\n     return 0; \n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <iostream>\n\nconstexpr unsigned int SERVER_PORT = 50544;\nconstexpr unsigned int MAX_BUFFER = 128;\n```", "```cpp\nint main(int argc, char *argv[])\n{\n    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd < 0) \n    {\n        std::cerr << \"socket error\" << std::endl;\n        return 1;\n    }\n```", "```cpp\n    struct hostent* server = gethostbyname(argv[1]);\n    if (server == NULL) \n    {\n        std::cerr << \"gethostbyname, no such host\" << std::endl;\n        return 2;\n    }\n\n```", "```cpp\n    struct sockaddr_in serv_addr, cli_addr;\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    bcopy((char *)server->h_addr, \n          (char *)&serv_addr.sin_addr.s_addr, \n          server->h_length);\n    serv_addr.sin_port = htons(SERVER_PORT);\n```", "```cpp\n    std::string outBuffer (MAX_BUFFER, 0);\n    std::cout << \"What message for the server? : \";\n    getline(std::cin, outBuffer);\n    unsigned int len = sizeof(serv_addr);\n    if (sendto(sockfd, outBuffer.c_str(), MAX_BUFFER, 0, \n               (struct sockaddr *) &serv_addr, len) < 0)\n    {\n        std::cerr << \"sendto failed\" << std::endl;\n        return 3;\n    }\n```", "```cpp\n    std::string inBuffer (MAX_BUFFER, 0);\n    unsigned int len_cli_add;\n    if (recvfrom(sockfd, &inBuffer[0], MAX_BUFFER, 0, \n                 (struct sockaddr *) &cli_addr, &len_cli_add) < 0)\n    {\n        std::cerr << \"recvfrom failed\" << std::endl;\n        return 4;\n    }\n    std::cout << inBuffer << std::endl;\n```", "```cpp\n    close(sockfd);\n    return 0;\n}\n```", "```cpp\nsocket() ->  sendto() -> recvfrom()\n```", "```cpp\nsocket() -> bind() ->  recvfrom() -> sendto()\n```", "```cpp\n#include <iostream>\n#include <bit>\n\nint main()\n{ \n    if (std::endian::native == std::endian::big)\n        // prepare the program to read/write \n        // in big endian ordering.\n        std::cout << \"big\" << std::endl;\n    else if (std::endian::native == std::endian::little)\n        // prepare the program to read/write \n        // in little endian ordering.\n        std::cout << \"little\" << std::endl; \n\n return 0;\n}\n```"]