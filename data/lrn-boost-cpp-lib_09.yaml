- en: Chapter 9. Files, Directories, and IOStreams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。文件、目录和IOStreams
- en: Programming for real-world systems requires interacting with various subsystems
    of the operating system to utilize their services. Starting with this chapter,
    we look at the various Boost libraries that provide programmatic access to OS
    subsystems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与操作系统的各种子系统进行交互以利用它们的服务，编写真实世界系统的程序需要。从本章开始，我们将看看各种Boost库，这些库提供对操作系统子系统的编程访问。
- en: 'In this chapter, we look at the Boost libraries for performing input and output,
    and interacting with filesystems. We cover these libraries in the following sections
    of the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍用于执行输入和输出以及与文件系统交互的Boost库。我们将在本章的以下部分中介绍这些库：
- en: Managing files and directories with Boost Filesystem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost文件系统管理文件和目录
- en: Extensible I/O with Boost IOStreams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost IOStreams进行可扩展I/O
- en: Using the libraries and techniques covered in this chapter, you will be able
    to write portable C++ programs that interact with filesystems and perform all
    kinds of I/O using a standard interface. We do not cover network I/O in this chapter,
    but devote [Chapter 10](ch10.html "Chapter 10. Concurrency with Boost"), *Concurrency
    with Boost*, to this topic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章涵盖的库和技术，您将能够编写可移植的C++程序，与文件系统交互，并使用标准接口执行各种I/O操作。本章不涵盖网络I/O，而是专门讨论[第10章](ch10.html
    "第10章。使用Boost进行并发")*使用Boost进行并发*。
- en: Managing files and directories with Boost Filesystem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost文件系统管理文件和目录
- en: Software written using the Boost libraries runs on multiple operating systems,
    including Linux, Microsoft Windows, Mac OS, and various other BSD variants. How
    these operating systems access paths to files and directories may differ in several
    ways; for example, MS Windows uses backward slashes as the directory separator
    while all Unix variants, including Linux, BSD, and Mac, use forward slashes. Non-English
    operating systems may use other characters as directory separators, and sometimes,
    multiple directory separators may be supported. The Boost Filesystem library hides
    these platform-specific peculiarities and lets you write code that is much more
    portable. Using the functions and types in the Boost Filesystem library, you can
    write OS-agnostic code to perform common operations on the filesystem that an
    application needs to run, like copying, renaming, and deleting files, traversing
    directories, creating directories and links, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boost库编写的软件可以在多个操作系统上运行，包括Linux、Microsoft Windows、Mac OS和各种其他BSD变体。这些操作系统访问文件和目录的路径的方式可能在多种方面有所不同；例如，MS
    Windows使用反斜杠作为目录分隔符，而所有Unix变体，包括Linux、BSD和Mac，使用正斜杠。非英语操作系统可能使用其他字符作为目录分隔符，有时还支持多个目录分隔符。Boost文件系统库隐藏了这些特定于平台的特性，并允许您编写更具可移植性的代码。使用Boost文件系统库中的函数和类型，您可以编写与操作系统无关的代码，执行应用程序运行所需的文件系统上的常见操作，如复制、重命名和删除文件，遍历目录，创建目录和链接等。
- en: Manipulating paths
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作路径
- en: Filesystem paths are represented using objects of type `boost::filesystem::path`.
    Given an object of type `boost::filesystem::path`, we can glean useful information
    from it and derive other `path` objects from it. A `path` object allows us to
    model a real filesystem path and derive information from it, but it need not represent
    a path that really exists in the system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统路径使用`boost::filesystem::path`类型的对象表示。给定`boost::filesystem::path`类型的对象，我们可以从中获取有用的信息，并从中派生其他`path`对象。`path`对象允许我们对真实的文件系统路径进行建模并从中获取信息，但它不一定代表系统中真正存在的路径。
- en: Printing paths
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印路径
- en: 'Let us look at our first example of using Boost Filesystem to print the current
    working directory of a process:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Boost文件系统打印进程的当前工作目录的第一个示例：
- en: '**Listing 9.1: The first example of using Boost Filesystem**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.1：使用Boost文件系统的第一个示例**'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the program determines its current working directory by calling
    the `current_path` (line 8), which is a namespace level function in the `boost::filesystem`
    namespace. It returns an object of type `boost::filesystem::path` representing
    the path to the current working directory. Most functions in `boost::filesystem`
    work on `boost::filesystem::path` objects rather than strings.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，程序通过调用`current_path`（第8行）确定其当前工作目录，这是`boost::filesystem`命名空间中的一个命名空间级函数。它返回一个表示当前工作目录的`boost::filesystem::path`类型的对象。`boost::filesystem`中的大多数函数都是在`boost::filesystem::path`对象上而不是字符串上工作。
- en: We print the path by calling the `generic_string` member function of `path`
    (line 11), by calling the `string` member function (line 12), and also by streaming
    `cwd`, the path object, to the output stream (line 13). The `generic_string` member
    returns the path in a **generic format** supported by Boost Filesytem with forward
    slashes as separators. The `string` member function returns the path in the **native
    format**, which is an implementation-defined format dependent on the operating
    system. On Windows, the native format uses backslashes as path separator, while
    on UNIX there is no difference between the generic and native formats. Boost Filesystem
    recognizes both forward and backward slashes as path separators on Windows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`path`的`generic_string`成员函数（第11行），通过调用`string`成员函数（第12行），以及通过将`cwd`，路径对象，流式传输到输出流（第13行）来打印路径。`generic_string`成员以**通用格式**返回路径，该格式由Boost文件系统支持，使用正斜杠作为分隔符。`string`成员函数以**本机格式**返回路径，这是一个依赖于操作系统的实现定义格式。在Windows上，本机格式使用反斜杠作为路径分隔符，而在UNIX上，通用格式和本机格式之间没有区别。Boost文件系统在Windows上识别正斜杠和反斜杠作为路径分隔符。
- en: Streaming the `path` object too writes the path in the native format but additionally
    puts double quotes around the path. Putting double quotes around paths with embedded
    spaces makes it easy to use the result as arguments to commands. If there be embedded
    double quote characters (`"`) in the path, those are escaped with an ampersand
    (`&`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输`path`对象也会以本机格式写入路径，但还会在路径周围加上双引号。在路径中有嵌入空格的情况下，加上双引号可以方便将结果用作命令的参数。如果路径中有嵌入的双引号字符（`"`），则会用和号（`&`）对其进行转义。
- en: On Windows, the full paths are stored as wide character (`wchar_t`) strings,
    so `generic_string` or `string` return the path as a `std::string` *after* performing
    conversion. Depending on the specific Unicode characters in the path, there may
    not be a meaningful conversion of the path to a single-byte character string.
    On such systems, it is only safe to call the `generic_wstring` or `wstring` member
    functions, which return the path as a `std::wstring` in generic or native formats.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，完整路径以宽字符（`wchar_t`）字符串存储，因此`generic_string`或`string`在执行转换*后*将路径作为`std::string`返回。根据路径中特定的Unicode字符，可能无法将路径有意义地转换为单字节字符字符串。在这种系统上，只能安全地调用`generic_wstring`或`wstring`成员函数，它们以通用或本机格式返回路径作为`std::wstring`。
- en: 'We print each directory component in the path, iterating through them using
    a range-based for-loop in C++11 (line 15). If range-based for-loop is not available,
    we should use the `begin` and `end` member functions in `path` to iterate through
    path elements. On my Windows box, this program prints the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C++11中的范围for循环迭代路径中的每个目录组件（第15行）。如果范围for循环不可用，我们应该使用`path`中的`begin`和`end`成员函数来迭代路径元素。在我的Windows系统上，该程序打印以下内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On my Ubuntu box, this is the output I get:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Ubuntu系统上，这是我得到的输出：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The program prints its current working directory in the generic and native formats.
    You can see that there is no difference between the two on Ubuntu (and generally
    on any Unix).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序以通用格式和本机格式打印其当前工作目录。您可以看到在Ubuntu上（以及通常在任何Unix系统上）两者之间没有区别。
- en: On Windows, the first component of the path is the drive letter, generally referred
    to as the **root name**. This is followed by / (the root folder) and each subdirectory
    in the path. On Unix, there is no root name (as is usually the case), so the listing
    starts with / (the root directory) followed by each subdirectory in the path.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，路径的第一个组件是驱动器号，通常称为**根名称**。然后是/（根文件夹）和路径中的每个子目录。在Unix上，没有根名称（通常情况下），因此清单以/（根目录）开头，然后是路径中的每个子目录。
- en: The `cwd` object of type `path` is streamable (line 19) and printing it to standard
    output prints it in the native format, enclosed in quotes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`path`的`cwd`对象是可流式传输的（第19行），将其打印到标准输出会以本机格式带引号打印出来。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Compiling and linking examples with Boost Filesystem**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Boost Filesystem编译和链接示例**'
- en: Boost Filesystem is not a header-only library. The Boost Filesystem shared libraries
    are installed as part of the Boost operating system packages, or built from source
    as described in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing
    Boost*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Filesystem不是一个仅包含头文件的库。Boost Filesystem共享库作为Boost操作系统包的一部分安装，或者根据[第1章](ch01.html
    "第1章。介绍Boost")中描述的方式从源代码构建，*介绍Boost*。
- en: '**On Linux**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Linux上**'
- en: If you installed Boost libraries using your native package manager, then you
    can use the following commands to build your programs. Note that the library names
    are in system layout.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用本机包管理器安装Boost库，则可以使用以下命令构建您的程序。请注意，库名称采用系统布局。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you built Boost from source as shown in [Chapter 1](ch01.html "Chapter 1. Introducing
    Boost"), *Introducing Boost*, and installed it under `/opt/boost`, you can use
    the following commands to compile and link your sources:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照[第1章](ch01.html "第1章。介绍Boost")中所示的方式从源代码构建Boost，并将其安装在`/opt/boost`下，您可以使用以下命令来编译和链接您的源代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since we built the libraries with names in tagged layout, we link against appropriately
    named versions of Boost Filesystem and Boost System. The `-Wl,-rpath,/opt/boost/lib`
    part embeds the path to the Boost shared libraries in the generated executable
    so that the runtime linker knows from where to pick the shared libraries for the
    executable to run.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用标记布局构建了库，因此我们链接到适当命名的Boost Filesystem和Boost System版本。`-Wl,-rpath,/opt/boost/lib`部分将Boost共享库的路径嵌入生成的可执行文件中，以便运行时链接器知道从哪里获取可执行文件运行所需的共享库。
- en: '**On Windows**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Windows上**'
- en: 'On Windows, under Visual Studio 2012 or later, you can enable auto-linking
    and need not explicitly specify the libraries to link. For this, you need to edit
    the **Configuration Properties** settings in the **Project Properties** dialog
    box (brought up using *Alt* + *F7* in the IDE):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，使用Visual Studio 2012或更高版本，您可以启用自动链接，无需显式指定要链接的库。为此，您需要在**项目属性**对话框中编辑**配置属性**设置（在IDE中使用*Alt*
    + *F7*打开）：
- en: 1\. Under **VC++ Directories**, append `<boost-install-path>\include` to the
    **Include Directories** property.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在**VC++目录**下，将`<boost-install-path>\include`追加到**包含目录**属性。
- en: 2\. Under **VC++ Directories**, append `<boost-install-path>\lib` to the **Library
    Directories** property.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 在**VC++目录**下，将`<boost-install-path>\lib`追加到**库目录**属性。
- en: 3\. Under **Debugging**, set the **Environment** property to `PATH=%PATH%;<boost-install-path>\lib`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在**调试**下，将**环境**属性设置为`PATH=%PATH%;<boost-install-path>\lib`。
- en: '4\. Under **C/C++ > Preprocessor**, define the following preprocessor symbols:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 在**C/C++ > 预处理器**下，定义以下预处理器符号：
- en: '`BOOST_ALL_DYN_LINK`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_ALL_DYN_LINK`'
- en: '`BOOST_AUTO_LINK_TAGGED` (only if you built using tagged layout)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_AUTO_LINK_TAGGED`（仅在使用标记布局构建时）'
- en: 5\. Build by hitting *F7* from the Visual Studio IDE and run your program by
    hitting *Ctrl* + *F5* from the IDE.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 通过从Visual Studio IDE中按下*F7*来构建，并通过从IDE中按下*Ctrl* + *F5*来运行程序。
- en: Constructing paths
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建路径
- en: 'You can construct instances of `boost::filesystem::path` using one of the `path`
    constructors or by combining existing paths in some way. Strings and string literals
    are implicitly convertible to `path` objects. You can construct relative as well
    as absolute paths, convert relative paths to absolute paths, append or strip elements
    from the path and "normalize" paths, as shown in listing 9.2:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`path`构造函数之一或以某种方式组合现有路径来构造`boost::filesystem::path`的实例。字符串和字符串字面值可以隐式转换为`path`对象。您可以构造相对路径和绝对路径，将相对路径转换为绝对路径，从路径中添加或删除元素，并“规范化”路径，如清单9.2所示：
- en: '**Listing 9.2a: Constructing empty path objects**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.2a：构造空路径对象**'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A default constructed path object represents an empty path, as illustrated by
    the preceding example. You can assign a path string to an empty `path` object
    (line 10) and it ceases to be empty (line 11). On calling the `clear` member function
    on the path (line 12), it once again turns empty (line 13). Over the years, some
    parts of the Boost Filesystem library have been deprecated and replaced by better
    alternatives. We define the macro `BOOST_FILESYSTEM_NO_DEPRECATED` (line 1) to
    ensure that such deprecated member functions and types are not accessible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个默认构造的路径对象表示一个空路径，就像前面的例子所示。你可以将一个路径字符串赋给一个空的`path`对象（第10行），它就不再是空的了（第11行）。在路径上调用`clear`成员函数（第12行）后，它再次变为空（第13行）。多年来，Boost文件系统库的一些部分已经被弃用，并被更好的替代品所取代。我们定义宏`BOOST_FILESYSTEM_NO_DEPRECATED`（第1行）以确保这些弃用的成员函数和类型不可访问。
- en: '**Listing 9.2b: Constructing relative paths**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.2b：构造相对路径**'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We construct a relative path by using `..` (double dot), which is a common way
    to refer to the parent directory relative to any directory on most filesystems
    (line 16). We then use `operator/=` to append an additional `..` path element
    to the relative path (line 17). We then print the relative path in its native
    format (line 18) and create absolute paths using this relative path.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`..`（双点）构造了一个相对路径，这是一种在大多数文件系统上引用父目录的常见方式（第16行）。然后我们使用`operator/=`来将额外的`..`路径元素附加到相对路径（第17行）。然后我们以其原生格式打印相对路径（第18行），并使用这个相对路径创建绝对路径。
- en: The `boost::filesystem::absolute` function constructs an absolute path given
    a relative path. You may pass it an absolute path to which the relative path must
    be appended to construct a new absolute path (line 21). Note that we pass a Windows
    absolute path and make sure to escape the backslashes. If you omit the second
    parameter to `absolute`, it constructs the absolute path from the relative path
    by using the current working directory of the process as the base path (line 23).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::filesystem::absolute`函数根据相对路径构造绝对路径。你可以将一个绝对路径传递给它，以便将相对路径附加到构造一个新的绝对路径（第21行）。请注意，我们传递了一个Windows绝对路径，并确保转义了反斜杠。如果省略`absolute`的第二个参数，它将使用进程的当前工作目录作为基本路径从相对路径构造绝对路径（第23行）。'
- en: 'A file path such as `/opt/boost/lib/../include` can be *normalized* to the
    equivalent form, `/opt/boost/include`. The function `boost::filesystem::canonical`
    generates a **normalized absolute path** from a given path (line 25), but requires
    that the path exist. Otherwise, it throws an exception that needs to be handled.
    It also reads and follows any symbolic links in the path. The preceding code prints
    the following output on my Windows box:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，文件路径`/opt/boost/lib/../include`可以被*规范化*为等效形式`/opt/boost/include`。函数`boost::filesystem::canonical`从给定路径生成一个**规范化的绝对路径**（第25行），但要求路径存在。否则，它会抛出一个需要处理的异常。它还会读取并遵循路径中的任何符号链接。前面的代码在我的Windows系统上打印了以下输出：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the output for the canonical path has the double dots collapsed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，规范路径的输出中双点已经被折叠。
- en: '**Listing 9.2c: Handling errors**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.2c：处理错误**'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example illustrates how `canonical` errors out when it is passed a path
    that does not exist. We create a path object, `p3`, for the absolute path `E:\DATA`
    on Windows (line 29). We then create a second path object `p4` by appending successive
    path elements (`boost` and `boost_1_56`) to `p3` using the overloaded `operator/`
    for `path` objects (line 30). This constructs a path that is equivalent of `E:\DATA\boost\boost_1_56`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了当`canonical`被传递一个不存在的路径时会出错。我们创建了一个路径对象`p3`，表示Windows上的绝对路径`E:\DATA`（第29行）。然后我们通过使用`operator/`为`path`对象（第30行）连续添加路径元素（`boost`和`boost_1_56`）来创建第二个路径对象`p4`。这构造了一个等同于`E:\DATA\boost\boost_1_56`的路径。
- en: Next, we append the relative path `../boost_1_100` to `p4` (line 35), which
    constructs a path that is equivalent of `E:\DATA\boost\boost_1_56\..\boost_1_100`.
    This path does not exist on my system so when I call `canonical` on this path,
    it errors out. Notice that we passed an object of type `boost::system::error_code`
    as a second argument to `canonical`, to capture any error. We check for a non-zero
    error code returned using the `value` member function of `error_code` (line 38).
    In case an error occurred, we can also retrieve a system-defined descriptive error
    message using the message `member` function (line 43). Alternatively, we can invoke
    another overload of `canonical`, which does not take an `error_code` reference
    as argument and instead throws an exception if the path passed does not exist.
    A throwing and a non-throwing overload is a common pattern seen in functions in
    the Filesystem library and other system programming libraries from Boost.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将相对路径`../boost_1_100`附加到`p4`（第35行），这构造了一个等同于`E:\DATA\boost\boost_1_56\..\boost_1_100`的路径。这个路径在我的系统上不存在，所以当我在这个路径上调用`canonical`时，它会出错。请注意，我们将`boost::system::error_code`类型的对象作为`canonical`的第二个参数传递，以捕获任何错误。我们使用`error_code`的`value`成员函数（第38行）来检查返回的非零错误代码。如果发生错误，我们还可以使用`message`成员函数（第43行）检索系统定义的描述性错误消息。或者，我们可以调用`canonical`的另一个重载，它不接受`error_code`引用作为参数，而是在路径不存在时抛出异常。抛出异常和不抛出异常的重载是在文件系统库和其他来自Boost的系统编程库中常见的模式。
- en: Breaking paths into components
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将路径分解为组件
- en: In the previous section, we saw how we can get the parent directory of a path
    by calling the `parent_path` member function. In fact, there is a whole slew of
    member functions in `boost::filesystem::path` to extract the components in a path.
    Let us first take a look at a path and its components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何通过调用`parent_path`成员函数来获取路径的父目录。实际上，在`boost::filesystem::path`中有一整套成员函数可以提取路径中的组件。让我们首先看一下路径及其组件。
- en: 'We will first understand the Boost Filesystem terminology for path components
    using the following path from a UNIX system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解Boost文件系统术语中关于路径组件的概念，使用来自UNIX系统的以下路径：
- en: '`/opt/boost/include/boost/filesystem/path.hpp`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`/opt/boost/include/boost/filesystem/path.hpp`'
- en: The leading `/` is called the **root directory**. The last component, `path.hpp`,
    is called the **filename**, even when the path represents a directory rather than
    a regular file. The path stripped of the filename (`/opt/boost/include/boost/filesystem`)
    is called the **parent path**. The part following the leading slash (`opt/boost/include/boost/filesystem/path.hpp`)
    is called the **relative path**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前导`/`称为**根目录**。最后一个组件`path.hpp`称为**文件名**，即使路径表示的是目录而不是常规文件。剥离了文件名的路径（`/opt/boost/include/boost/filesystem`）称为**父路径**。在前导斜杠之后的部分（`opt/boost/include/boost/filesystem/path.hpp`）称为**相对路径**。
- en: In the preceding example, `.hpp` is the **extension** (including the period
    or dot) and `path` is the **stem** of the filename. In case of a filename with
    multiple embedded dots (for example, `libboost_filesystem-mt.so.1.56.0`), the
    extension is considered to start from the last (right-most) dot.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`.hpp`是**扩展名**（包括句点或点），`path`是文件名的**主干**。对于具有多个嵌入点的文件名（例如，`libboost_filesystem-mt.so.1.56.0`），扩展名被认为从最后（最右边）的点开始。
- en: 'Now consider the following Windows path:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下Windows路径：
- en: '`E:\DATA\boost\include\boost\filesystem\path.hpp`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`E:\DATA\boost\include\boost\filesystem\path.hpp`'
- en: 'The component `E:` is called the **root name**. The leading backslash following
    `E:` is called the **root directory**. The concatenation of the root name with
    the root directory (`E:\`) is called the **root path**. The following is a short
    function that prints these different components of a path using member functions
    of `boost::filesystem::path`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 组件`E:`称为**根名称**。在`E:`后面的前导反斜杠称为**根目录**。根名称与根目录（`E:\`）的连接称为**根路径**。以下是一个打印路径的不同组件的简短函数，使用`boost::filesystem::path`的成员函数：
- en: '**Listing 9.3: Splitting a path into components**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.3：将路径拆分为组件**'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, the function `printPathParts`(line 6) prints as many
    components of a path as are available. To access a path component, it uses a corresponding
    member function of `path`. To check whether a component is available, it uses
    one of the `has_` member functions of `path`. It also checks whether a path is
    a relative path or an absolute path using the `is_relative` and `is_absolute`
    member functions of `path` (lines 10, 13).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，函数`printPathParts`（第6行）打印路径的尽可能多的组件。要访问路径组件，它使用`path`的相应成员函数。要检查组件是否可用，它使用`path`的`has_`成员函数之一。它还使用`path`的`is_relative`和`is_absolute`成员函数（第10行，第13行）检查路径是相对路径还是绝对路径。
- en: We call `printPathParts` with different relative and absolute paths. The results
    may vary across operating systems. For example, on Windows, a call to `has_root_name`
    (line 17) returns `false` for all the paths except the Windows path `E:\DATA\books.txt`
    (line 54), which is considered an absolute path. Calling `root_name` on this path
    returns `E:`. On UNIX however, the backslashes are not recognized as separators
    and considered part of the path components, so `E:\DATA\books.txt` will be interpreted
    as a relative path with the filename `E:\DATA\books.txt`, the stem `E:\DATA\books`,
    and the extension `.txt`. This, coupled with the fact that forward slashes are
    recognized on Windows as path separators, is a good reason to never use backslashes
    in path literals like we have done here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同的相对路径和绝对路径调用`printPathParts`。结果可能因操作系统而异。例如，在Windows上，对`has_root_name`（第17行）的调用对除了Windows路径`E:\DATA\books.txt`（第54行）之外的所有路径返回`false`，这被认为是绝对路径。对此路径调用`root_name`返回`E:`。然而，在UNIX上，反斜杠不被识别为分隔符，被认为是路径组件的一部分，因此`E:\DATA\books.txt`将被解释为具有文件名`E:\DATA\books.txt`的相对路径，主干`E:\DATA\books`和扩展名`.txt`。这，再加上在Windows上正斜杠被识别为路径分隔符的事实，是绝对不要像我们在这里所做的那样在路径文字中使用反斜杠的一个很好的理由。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For maximum portability, always use forward slashes in path literals or generate
    paths using the overloaded `operator/` and `operator/=`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大的可移植性，在路径文字中始终使用正斜杠，或者使用重载的`operator/`和`operator/=`生成路径。
- en: 'We can also compare two paths to see whether they are **equal** and **equivalent**.
    Two paths can be compared for equality using the overloaded `operator==`, which
    returns `true` only if the two paths are decomposable to the same components.
    Note that this means the paths `/opt` and `/opt/` are not equal; in the former,
    the filename component is `opt`, while in the latter, it is `.` (dot). Two paths
    that are not equal can still be equivalent if they represent the same underlying
    filesystem entry. For example, `/opt/boost` and `/opt/cmake/../boost/` are equivalent
    although they are not equal paths. To compute equivalence, we can use the `boost::filesystem::equivalent`
    function, which returns `true` if the two paths refer to the same entry in the
    filesystem:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以比较两个路径，看它们是否**相等**和**等效**。可以使用重载的`operator==`来比较两个路径是否相等，只有当两个路径可以分解为相同的组件时才返回`true`。请注意，这意味着路径`/opt`和`/opt/`不相等；在前者中，文件名组件是`opt`，而在后者中，它是`.`（点）。如果两个路径不相等，但仍然可以等效，如果它们表示相同的底层文件系统条目。例如，`/opt/boost`和`/opt/cmake/../boost/`虽然不是相等路径，但它们是等效的。要计算等效性，我们可以使用`boost::filesystem::equivalent`函数，如果两个路径引用文件系统中的相同条目，则返回`true`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with `boost::filesystem::canonical`, the `equivalent` function also actually
    checks for the existence of the paths and throws an exception if either path does
    not exist. There is also an overload that does not throw but sets a `boost::system::error_code`
    out-parameter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与`boost::filesystem::canonical`一样，`equivalent`函数实际上也检查路径的存在，并且如果任一路径不存在则抛出异常。还有一个不会抛出异常而是设置`boost::system::error_code`输出参数的重载。
- en: 'The `path` object can be looked upon as a sequence container of path elements
    and these elements can be iterated through using an iterator interface exposed
    by `path`. This allows easy application of several standard algorithms to `path`
    objects. To iterate through each path element, we can use the following snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`对象可以被视为路径元素的序列容器，这些元素可以通过`path`公开的迭代器接口进行迭代。这允许将几个标准算法轻松应用于`path`对象。要遍历每个路径元素，我们可以使用以下代码片段：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will print the components separated by a pair of spaces:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印由一对空格分隔的组件：
- en: '`/ optboost include boost thread.hpp`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ optboost include boost thread.hpp`'
- en: 'The `begin` and `end` member functions of `boost::filesystem::path` return
    a random-access iterator of type `boost::filesystem::path::iterator`, which you
    can use with Standard Library algorithms in interesting ways. For example, to
    find the number of components in a path, you can use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::filesystem::path`的`begin`和`end`成员函数返回类型为`boost::filesystem::path::iterator`的随机访问迭代器，您可以以有趣的方式与标准库算法一起使用。例如，要找到路径中的组件数，您可以使用：'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, consider two paths: `/opt/boost/include/boost/filesystem/path.hpp` and
    `/opt/boost/include/boost/thread/detail/thread.hpp`. We will now write a function
    that computes the common subdirectory under which both paths are located:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑两个路径：`/opt/boost/include/boost/filesystem/path.hpp`和`/opt/boost/include/boost/thread/detail/thread.hpp`。我们现在将编写一个函数，计算这两个路径所在的公共子目录：
- en: '**Listing 9.4: Finding the common prefix path**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.4节：查找公共前缀路径
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calling the `commonPrefix` function on the two paths correctly returns `/opt/boost/include/boost`.
    For this function to work correctly, we should pass paths that do not have `.`
    or `..` components, something that a more complete implementation can take care
    of. To compute the prefix, we first define a nested function called `prefix` using
    a lambda expression (lines 7-17), which performs the actual computation. We compute
    the element count of the two paths (lines 19, 20) and pass the shorter path as
    the first argument and the longer one as the second argument to the `prefix` function
    (lines 22-23). In the `prefix` function, we use the `std::mismatch` algorithm
    on the two paths to compute the first component where they do not match (line
    10). We then construct the common prefix as the path up to this first mismatch
    and return it (lines 12-15).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个路径上调用`commonPrefix`函数会正确返回`/opt/boost/include/boost`。为了使该函数正确工作，我们应该传递不包含`.`或`..`组件的路径，一个更完整的实现可以处理这个问题。为了计算前缀，我们首先使用lambda表达式定义了一个名为`prefix`的嵌套函数（第7-17行），它执行实际的计算。我们计算了两个路径的元素计数（第19、20行），并将较短的路径作为第一个参数，较长的路径作为第二个参数传递给`prefix`函数（第22-23行）。在`prefix`函数中，我们使用`std::mismatch`算法在两个路径上计算它们不匹配的第一个组件（第10行）。然后我们构造公共前缀作为直到第一个不匹配的路径，并返回它（第12-15行）。
- en: Traversing directories
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历目录
- en: 'Boost Filesystem provides two iterator classes, `directory_iterator` and `recursive_directory_iterator`,
    that make iterating through directories fairly simple. Both conform to the **input
    iterator** concept and provide an `operator++` for forward traversal. In the first
    example here, we see `directory_iterator` in action:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Filesystem提供了两个迭代器类，`directory_iterator`和`recursive_directory_iterator`，使得遍历目录变得相当简单。两者都符合**输入迭代器**概念，并提供了用于向前遍历的`operator++`。在这里的第一个例子中，我们看到了`directory_iterator`的使用：
- en: '**Listing 9.5: Iterating directories**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.5节：迭代目录
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `traverse` function takes a parameter `dirpath` of type `boost::filesystem::path`
    representing the directory to traverse. Using the namespace level functions, `exists`
    and `is_directory` (line 7), the function checks to see that `dirpath` actually
    exists and is a directory before proceeding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`traverse`函数接受一个类型为`boost::filesystem::path`的参数`dirpath`，表示要遍历的目录。使用命名空间级别的函数`exists`和`is_directory`（第7行），函数检查`dirpath`是否实际存在并且是一个目录，然后再继续。'
- en: To perform the iteration, we create an instance `dirit` of `boost::filesystem::directory_iterator`
    for the path and a second default-constructed `directory_iterator` instance called
    `end` (line 11). The default-constructed `directory_iterator` acts as the end-of-sequence
    marker. Dereferencing a valid iterator of type `directory_iterator` returns an
    object of type `boost::filesystem::directory_entry`. The sequence represented
    by the iterator range [`dirit`, `end`) is the list of entries in the directory.
    To iterate through them, we use the familiar `std::for_each` standard algorithm.
    We use a lambda to define the action to perform on each entry, which is to simply
    print it to the standard output (lines 13-14).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行迭代，我们为路径创建了一个`boost::filesystem::directory_iterator`的实例`dirit`，并创建了一个名为`end`的第二个默认构造的`directory_iterator`实例（第11行）。默认构造的`directory_iterator`充当了序列结束标记。对类型为`directory_iterator`的有效迭代器进行解引用会返回一个类型为`boost::filesystem::directory_entry`的对象。由迭代器范围[`dirit`，`end`)表示的序列是目录中的条目列表。为了遍历它们，我们使用熟悉的`std::for_each`标准算法。我们使用lambda来定义对每个条目执行的操作，即简单地将其打印到标准输出（第13-14行）。
- en: 'While we can write recursive logic around `boost::directory_iterator` to iterate
    through a directory tree recursively, `boost::recursive_directory_iterator` provides
    an easier alternative. We can replace `boost::directory_iterator` with `boost::recursive_directory_iterator`
    in listing 9.5 and it will still work, performing a depth-first traversal of the
    directory tree. But the `recursive_directory_iterator` interface provides additional
    capabilities like skipping descent into specific directories and keeping track
    of the depth of descent. A hand-written loop serves better to fully leverage these
    capabilities, as shown in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以围绕`boost::directory_iterator`编写递归逻辑来递归地遍历目录树，但`boost::recursive_directory_iterator`提供了一个更简单的替代方法。我们可以在第9.5节中用`boost::recursive_directory_iterator`替换`boost::directory_iterator`，它仍然可以工作，对目录树进行深度优先遍历。但是`recursive_directory_iterator`接口提供了额外的功能，比如跳过特定目录的下降和跟踪下降的深度。手写循环更好地利用了这些功能，如下例所示：
- en: '**Listing 9.6: Recursively iterating directories**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.6节：递归迭代目录
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create a `recursive_directory_iterator` and initialize it with a path (line
    8) just as we did for a `directory_iterator` in listing 9.5\. The `recursive_directory_iterator`
    constructor may throw an exception if the path does not exist or cannot be read
    by the program. To catch such exceptions, we put the code in the `try-catch` block.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`recursive_directory_iterator`并用一个路径初始化它（第8行），就像我们在第9.5节中为`directory_iterator`做的那样。如果路径不存在或程序无法读取，`recursive_directory_iterator`构造函数可能会抛出异常。为了捕获这种异常，我们将代码放在`try-catch`块中。
- en: We use a while-loop to iterate through entries (line 10) and advance the iterator
    by calling the `increment` member function (line 19). When the `increment` member
    function encounters a directory, it tries to descend into it in depth-first order.
    This can sometimes fail due to system issues, like when the program does not have
    sufficient permissions to look into the directory. In such cases, we want to continue
    on to the next available entry rather than abort the iteration. For this reason,
    we do not use `operator++` on the iterator because it throws an exception when
    it encounters an error and handling this makes the code more convoluted. The `increment`
    function takes a `boost::system::error_code` argument, and in case of an error,
    it sets the `error_code` *and* advances the iterator to the next entry. In such
    a case, we can get the system-defined error message associated with the error
    using the `message` member function of `error_code`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用while循环来遍历条目（第10行），并通过调用`increment`成员函数（第19行）来推进迭代器。当`increment`成员函数遇到目录时，它会尝试按深度优先顺序进入该目录。这有时可能会由于系统问题而失败，比如当程序没有足够的权限查看目录时。在这种情况下，我们希望继续到下一个可用的条目，而不是中止迭代。因此，我们不在迭代器上使用`operator++`，因为当它遇到错误时会抛出异常，处理这种情况会使代码变得更加复杂。`increment`函数接受一个`boost::system::error_code`参数，在出现错误时设置`error_code`并推进迭代器到下一个条目。在这种情况下，我们可以使用`error_code`的`message`成员函数获取与错误相关的系统定义的错误消息。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Behavior of boost::filesystem::recursive_directory_iterator**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**boost::filesystem::recursive_directory_iterator的行为**'
- en: Prior to Boost version 1.56, when the `operator++` and `increment` member functions
    encountered an error, they would only throw an exception or set an `error_code`,
    without advancing the iterator. This made writing a correct loop that skips on
    errors more complex. As of Boost 1.56, these functions also advance the iterator
    to the next entry making the loop code a lot simpler.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Boost版本1.56之前，当`operator++`和`increment`成员函数遇到错误时，它们只会抛出异常或设置`error_code`，而不会推进迭代器。这使得编写一个正确的循环以跳过错误变得更加复杂。从Boost
    1.56开始，这些函数还会将迭代器推进到下一个条目，使循环代码变得简单得多。
- en: We process each entry by a call to a fictitious function `printFileProperties`
    (line 11), which takes two arguments—the result of dereferencing the `recursive_directory_iterator`
    instance, and the depth of traversal obtained by a call to the `level` member
    function of the iterator. The `level` function returns zero for first-level directories
    and its return value is incremented by 1 for each additional level of descent.
    The `printFileProperties` function can use this to indent entries in subdirectories,
    for example. We will implement the `printFileProperties` function in the next
    section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用一个虚构的函数`printFileProperties`（第11行）来处理每个条目，该函数接受两个参数——解引用`recursive_directory_iterator`实例的结果，以及通过调用迭代器的`level`成员函数获得的遍历深度。`level`函数对于一级目录返回零，并且对于每个额外的下降级别，其返回值递增1。`printFileProperties`函数可以利用这一点来缩进子目录中的条目，例如。我们将在下一节中实现`printFileProperties`函数。
- en: To add dimension to the example, we decide not to descend into directories named
    `foo`. For this, we check for directories named `foo` (lines 13-15) and call the
    `no_push` member function on the `recursive_directory_iterator` to prevent descending
    into the directory (line 16). Likewise, we can call the `pop` member function
    on the iterator at any time to go up a level in the directory tree without necessarily
    completing iteration at the current level.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个例子增加维度，我们决定不进入名为`foo`的目录。为此，我们检查名为`foo`的目录（第13-15行），并在`recursive_directory_iterator`上调用`no_push`成员函数以防止进入该目录（第16行）。同样，我们可以随时调用迭代器的`pop`成员函数来在目录树中上升一级，而不一定要在当前级别完成迭代。
- en: On systems that support symbolic links, if the `recursive_directory_iterator`
    encounters a symbolic link pointing to a directory, it does not follow the link
    to descend into the directory. If we want to override this behavior, we should
    pass a second argument of the enum type `boost::filesystem::symlink_option` to
    the `recursive_directory_iterator` constructor. The `symlink_option` enum provides
    the values `none` (or `no_recurse`), which is the default, and `recurse`, which
    indicates that symbolic links should be followed to descend into directories.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持符号链接的系统上，如果`recursive_directory_iterator`遇到指向目录的符号链接，它不会跟随链接进入目录。如果我们想要覆盖这种行为，我们应该向`recursive_directory_iterator`构造函数传递`boost::filesystem::symlink_option`枚举类型的第二个参数。`symlink_option`枚举提供了`none`（或`no_recurse`）（默认值）和`recurse`两个值，表示应该跟随符号链接进入目录。
- en: Querying filesystem entries
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询文件系统条目
- en: 'Boost Filesystem provides a set of functions to perform useful operations on
    files and directories. Most of these are functions in the `boost::filesystem`
    namespace. Using these functions, we can check whether a file exists, its size
    in bytes, its last modification time, the file type, whether it is empty, and
    so on. We use this slew of functions to write the `printFileProperties` function
    we used in the preceding section:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Filesystem提供了一组函数来对文件和目录执行有用的操作。其中大多数是`boost::filesystem`命名空间中的函数。使用这些函数，我们可以检查文件是否存在、其大小（以字节为单位）、最后修改时间、文件类型、是否为空等等。我们使用这些函数来编写我们在前一节中使用的`printFileProperties`函数：
- en: '**Listing 9.7: Querying file system entries**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.7：查询文件系统条目**'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `printFileProperties` is used to print a short summary for a given file,
    including attributes like type, size, last modification time, name, and for symbolic
    links, the target file. The first argument to this function is of type `directory_entry`,
    the result of dereferencing a `directory_iterator` or `recursive_directory_iterator`.
    The second argument is the depth of traversal. We obtain the path to the file
    referenced by the `directory_entry` object by calling the `path` member function
    of `directory_entry` (line 9). We obtain a reference to a `file_status` object
    by calling the `symlink_status` member function of `directory_entry` (line 10).
    The `file_status` object contains additional details about a filesystem entry,
    which we use in our example to print the status of special files. The `symlink_status`
    function acts on all kinds of files not just symbolic links, but it returns the
    status of the symbolic link itself without following it to the target. If you
    need the status of the target each time you query the symbolic link, use the `status`
    member function instead of `symlink_status`. The `status` and `symlink_status`
    member functions are faster than the global functions of the same name because
    they keep the file stats cached instead of querying the filesystem on every call.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`printFileProperties`用于打印给定文件的简短摘要，包括类型、大小、最后修改时间、名称，以及对于符号链接，目标文件。这个函数的第一个参数是`directory_entry`类型，是对`directory_iterator`或`recursive_directory_iterator`的解引用的结果。我们通过调用`directory_entry`的`path`成员函数（第9行）获取到`directory_entry`对象引用的文件的路径。我们通过调用`directory_entry`的`symlink_status`成员函数（第10行）获取到`file_status`对象的引用。`file_status`对象包含有关文件系统条目的其他详细信息，我们在示例中使用它来打印特殊文件的状态。`symlink_status`函数作用于所有类型的文件，而不仅仅是符号链接，但它返回的是符号链接本身的状态，而不是跟随它到目标的状态。如果你需要每次查询符号链接时都需要目标的状态，使用`status`成员函数而不是`symlink_status`。`status`和`symlink_status`成员函数比同名的全局函数更快，因为它们会缓存文件状态，而不是在每次调用时查询文件系统。'
- en: We determine the type of each entry before printing information appropriate
    for the type. To do this, we use the convenience functions `is_symlink`, `is_regular_file`
    and `is_directory` (lines 14, 19, 24). On POSIX systems like Linux, there are
    other kinds of files like block and character devices, fifos, and Unix domain
    sockets. To identify such files, we use the `file_status` object we obtained earlier
    (line 10). We call the `type` member function on the `file_status` object to determine
    the exact type of special file (line 29). Note that we first check if the file
    is a symbolic link and then perform other tests. That is because `is_regular_file`
    or `is_directory` may also return true for a symbolic link, based on the type
    of the target file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印适合类型的信息之前，我们确定每个条目的类型。为此，我们使用方便的函数`is_symlink`、`is_regular_file`和`is_directory`（第14、19、24行）。在像Linux这样的POSIX系统上，还有其他类型的文件，如块和字符设备、管道和Unix域套接字。为了识别这些文件，我们使用之前获得的`file_status`对象（第10行）。我们调用`file_status`对象的`type`成员函数来确定特殊文件的确切类型（第29行）。请注意，我们首先检查文件是否是符号链接，然后进行其他测试。这是因为`is_regular_file`或`is_directory`对于目标文件的类型也可能返回true，基于目标文件的类型。
- en: 'This function prints each entry in the following format:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数以以下格式打印每个条目：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The file type is indicated by a single letter (`D`: directory, `F`: regular
    file, `L`: symbolic link, `C`: character device, `B`: block device, `P`: fifo,
    `S`: Unix domain socket). The size is printed in bytes, the last modification
    time is printed as a long integer, and the file name is printed without the full
    path. Only for symbolic links, a trailing arrow followed by the target path is
    appended after the name. Hyphens (`-`) appear for missing fields when file size
    or last write time are not available. For each level of descent, the entry is
    indented with an extra pair of spaces (line 11).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型由单个字母表示（`D`：目录，`F`：普通文件，`L`：符号链接，`C`：字符设备，`B`：块设备，`P`：管道，`S`：Unix域套接字）。大小以字节为单位打印，最后修改时间以长整数形式打印，文件名打印时不包含完整路径。只有对于符号链接，名称后面会附加一个指向目标路径的箭头。当文件大小或最后写入时间不可用时，缺少字段会显示为连字符（`-`）。对于每个下降级别，条目都会缩进两个额外的空格（第11行）。
- en: 'Here is a sample output from running this function on my Linux system:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我的Linux系统上运行此函数的示例输出：
- en: '![Querying filesystem entries](img/1217OT_09_04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![查询文件系统条目](img/1217OT_09_04.jpg)'
- en: You can also run this on the `/dev` directory on Linux to look at how device
    files are listed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在Linux的`/dev`目录上运行这个程序，看看设备文件是如何列出的。
- en: To get the target file pointed to by a symbolic link, we call the `read_symlink`
    function (line 15). To get the size of a file in bytes, we call the `file_size`
    function (line 21), and to get the last modification time of a file, we call the
    `last_write_time` function (lines 22, 26, and 46). The `last_write_time` function
    returns the **Unix time** at which the file was last modified. We print a meaningful
    representation of this time stamp by calling the `boost::posix_time::from_time_t`
    function to convert this numeric timestamp into a printable date time string (see
    [Chapter 7](ch07.html "Chapter 7. Higher Order and Compile-time Programming"),
    *Higher Order and Compile-time Programming*).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`read_symlink`函数（第15行）来获取符号链接指向的目标文件。调用`file_size`函数（第21行）获取文件的大小（以字节为单位），调用`last_write_time`函数（第22、26和46行）获取文件的最后修改时间。`last_write_time`函数返回文件最后修改的**Unix时间**。我们通过调用`boost::posix_time::from_time_t`函数将这个数字时间戳转换为可打印的日期时间字符串来打印这个时间戳的有意义的表示（参见[第7章](ch07.html
    "第7章。高阶和编译时编程")，“高阶和编译时编程”）。
- en: 'In order to build this program, you must additionally link against the Boost
    DateTime library, as shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个程序，你还必须链接Boost DateTime库，如下所示：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are several such functions for querying objects in the filesystem for
    different kinds of information—for example, finding the number of hard links to
    a file. We can query the `file_status` object (line 10) for file permissions.
    Notice that we do not qualify these namespace level functions with the namespace;
    they are correctly resolved using Argument Dependent Lookup based on the type
    of their arguments (`boost::filesystem::path`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统中有几个这样的函数，用于查询文件系统中对象的不同类型的信息，例如查找文件的硬链接数。我们可以查询`file_status`对象（第10行）以获取文件权限。请注意，我们不需要在命名空间级别函数中加上命名空间；它们会根据参数的类型正确解析，使用基于参数类型的参数相关查找（Argument
    Dependent Lookup）。
- en: Performing operations on files
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对文件执行操作
- en: In addition to querying filesystem entries for information, we can also use
    the Boost Filesystem library to perform operations on files like creating directories
    and links, copying files and moving them, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询文件系统条目的信息之外，我们还可以使用Boost文件系统库对文件执行操作，如创建目录和链接，复制文件和移动文件等。
- en: Creating directories
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建目录
- en: 'It is easy to create directories using the function `boost::filesystem::create_directory`.
    You pass it a path and it creates a directory at that path if one does not exist;
    it does nothing if the directory already exists. If the path exists but is not
    a directory, `create_directory` throws an exception. There is also a non-throwing
    version that takes a `boost::system::error_code` reference, which it sets on error.
    These functions returns `true` if they create the directory and `false` if they
    do not:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数`boost::filesystem::create_directory`很容易创建目录。传递一个路径给它，如果该路径上不存在目录，则会在该路径上创建一个目录；如果目录已经存在，则不会执行任何操作。如果路径存在但不是一个目录，`create_directory`会抛出一个异常。还有一个非抛出版本，它接受一个`boost::system::error_code`引用，在错误时设置错误代码。这些函数如果创建了目录则返回`true`，如果没有则返回`false`：
- en: '**Listing 9.8: Creating directories**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.8：创建目录**'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, calling `create_directory` on the path `notpresent/dirtest`
    relative to the current directory fails (line 10) either if there is no directory
    called `notpresent` already in your current directory, or if `notpresent/dirtest`
    exists. This is because `create_directory` expects the parent directory of the
    path passed to exist, and it does not create a path that already exists. If we
    did not pass the error code parameter, this call to `create_directory` would have
    thrown an exception that would need to be handled. If `notpresent/dirtest` already
    exists and is a directory, then `create_directory` fails, but does not set the
    error code (line 12).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，相对于当前目录在路径`notpresent/dirtest`上调用`create_directory`失败（第10行），如果当前目录中没有名为`notpresent`的目录，或者`notpresent/dirtest`已经存在。这是因为`create_directory`期望传递的路径的父目录存在，并且不会创建已经存在的路径。如果我们没有传递错误代码参数，这次对`create_directory`的调用将会抛出一个需要处理的异常。如果`notpresent/dirtest`已经存在并且是一个目录，那么`create_directory`会失败，但不会设置错误代码（第12行）。
- en: The function `boost::filesystem::create_directories` creates all path components
    needed, akin to `mkdir –p` on Unix systems. The call to it (line 17) succeeds
    unless there are permission issues or the path already exists. It creates the
    directory, including any missing directories along the path. Calls to `create_directory`
    and `create_directories` are idempotent; if the target directory exists, no error
    is returned or exception thrown, but the functions return `false` because no new
    directory was created.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`boost::filesystem::create_directories`创建所需的所有路径组件，类似于Unix系统上的`mkdir -p`。对它的调用（第17行）除非存在权限问题或路径已经存在，否则会成功。它创建目录，包括沿路径缺失的任何目录。对`create_directory`和`create_directories`的调用是幂等的；如果目标目录存在，不会返回错误或抛出异常，但函数会返回`false`，因为没有创建新目录。
- en: Creating symbolic links
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建符号链接
- en: Symbolic links, sometimes called soft links, are entries in the filesystem that
    act like aliases to other files. They can refer to files as well as directories
    and are often used to provide alternate, simplified names and paths for files
    and directories. Symbolic links have been around on UNIX systems for quite a while
    now and have been available in some form on Windows since Windows 2000\. We can
    use the function `boost::filesystem::create_symlink` to create symbolic links.
    For creating symbolic links to directories, the function `boost::filesystem::create_directory_symlink`
    is recommended for better portability.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接，有时被称为软链接，是文件系统中的条目，类似于其他文件的别名。它们可以引用文件以及目录，并经常用于为文件和目录提供替代的简化名称和路径。符号链接在UNIX系统上已经存在了相当长的时间，并且自Windows
    2000以来在Windows上以某种形式可用。我们可以使用函数`boost::filesystem::create_symlink`来创建符号链接。对于创建指向目录的符号链接，建议使用函数`boost::filesystem::create_directory_symlink`以获得更好的可移植性。
- en: '**Listing 9.9: Creating symbolic links**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.9：创建符号链接**'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This shows a function `makeSymLink` that creates a symbolic link to a given
    path. The first parameter to the function is the target path that the link must
    alias, and the second parameter is the path to the link itself. This order of
    arguments is reminiscent of the UNIX `ln` command. If the target is a directory,
    this function calls `create_directory_symlink` (line 8), while for all other cases
    it calls `create_symlink` (line 10). Note that the target path need not exist
    at the time of creation of the symbolic link and a dangling symbolic link will
    be created in such a case. Calling these functions has the same effect as the
    command `ln –s target link` on POSIX systems. On Windows, you get the same effect
    by running the command `mklink /D link target` when `target` is a directory, or
    by running the command `mklink link target` when `target` is not a directory.
    The function `makeSymLink` will throw if `create_directory_symlink` or `create_symlink`
    threw an exception.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个名为`makeSymLink`的函数，它创建指向给定路径的符号链接。函数的第一个参数是链接必须别名的目标路径，第二个参数是链接本身的路径。这种参数顺序让人联想到UNIX的`ln`命令。如果目标是目录，此函数调用`create_directory_symlink`（第8行），而对于所有其他情况，它调用`create_symlink`（第10行）。请注意，目标路径在创建符号链接时不需要存在，在这种情况下将创建悬空的符号链接。调用这些函数的效果与在POSIX系统上运行`ln
    -s target link`命令相同。在Windows上，当`target`是目录时，通过运行`mklink /D link target`命令可以获得相同的效果，当`target`不是目录时，通过运行`mklink
    link target`命令可以获得相同的效果。如果`create_directory_symlink`或`create_symlink`抛出异常，函数`makeSymLink`将抛出异常。
- en: Copying files
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制文件
- en: 'Copying files is another common chore that Boost Filesystem helps in. The `boost::filesystem::copy_file`
    function copies regular files from source to destination and fails if the file
    already exists at the destination. Using an appropriate override, it can be made
    to overwrite the file at the destination instead. The `boost::filesystem::copy_symlink`
    takes a source symbolic link and creates a second symbolic link at the destination
    that aliases the same file as the source. You cannot pass a directory as the destination
    to either function. There is also a `boost::copy_directory` function, which does
    not seem to do what its name suggests. It creates directories and copies attributes
    of the source directory to the target directory. So, we will roll out our own
    recursive directory-copying utility function instead:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件是Boost文件系统中的另一个常见任务。`boost::filesystem::copy_file`函数将常规文件从源复制到目标，并且如果目标处已存在该文件，则会失败。使用适当的覆盖，可以使其覆盖目标处的文件。`boost::filesystem::copy_symlink`接受源符号链接并在目标处创建第二个符号链接，它别名与源相同的文件。您不能将目录传递给任何一个函数作为目标。还有一个`boost::copy_directory`函数，似乎并不做其名称所示的事情。它创建目录并将源目录的属性复制到目标目录。因此，我们将推出我们自己的递归目录复制实用程序函数：
- en: '**Listing 9.10: Recursively copying directories**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.10节：递归复制目录
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9.10 defines the `copyDirectory` function, which recursively copies
    a source directory to a target directory. It performs basic validations and throws
    an exception if the requisite initial conditions are not met (line 6). If any
    of the following conditions hold true, then a necessary precondition is violated:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.10节定义了`copyDirectory`函数，该函数递归地将源目录复制到目标目录。它执行基本验证，并在不满足必要的初始条件时抛出异常（第6行）。如果以下任何条件为真，则违反了必要的前提条件：
- en: The source path is not a directory (line 2)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源路径不是目录（第2行）
- en: The target path exists, but is not a directory (line 3)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标路径存在，但不是目录（第3行）
- en: The parent of the target path is not a directory (line 4)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标路径的父目录不是目录（第4行）
- en: The target path is a subdirectory of the source path (line 5)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标路径是源路径的子目录（第5行）
- en: To detect violation 4, we reuse the `commonPrefix` function we defined in listing
    9.4\. If the target path already exists, a subdirectory with the same name as
    the source directory is created under it to hold the copied contents (lines 11-12,
    14). Otherwise, the target directory is created and the content is copied into
    it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测违反4，我们重用了第9.4节中定义的`commonPrefix`函数。如果目标路径已经存在，则在其下创建与源目录同名的子目录以容纳复制的内容（第11-12行，14行）。否则，将创建目标目录并将内容复制到其中。
- en: Beyond this, we iterate recursively through the source directory using `directory_iterator`
    instead of `recursive_directory_iterator` (line 17). We use `copy_file` to copy
    regular files, passing the `copy_option::overwrite_if_exists` option to make sure
    a destination file that already exists is overwritten (lines 23-24). We use `copy_symlink`
    to copy a symbolic link (line 26). Each time we encounter a subdirectory, we recursively
    call `copyDirectory` (line 28). If an exception is thrown from the Boost Filesystem
    functions called by `copyDirectory`, it terminates the copy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们使用`directory_iterator`而不是`recursive_directory_iterator`（第17行）来递归迭代源目录。我们使用`copy_file`来复制常规文件，传递`copy_option::overwrite_if_exists`选项以确保已存在的目标文件被覆盖（第23-24行）。我们使用`copy_symlink`来复制符号链接（第26行）。每次遇到子目录时，我们递归调用`copyDirectory`（第28行）。如果从`copyDirectory`调用的Boost文件系统函数抛出异常，它将终止复制。
- en: Moving and deleting files
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动和删除文件
- en: 'You can move or rename files and directories using the `boost::filesystem::rename`
    function, which takes the old and new paths as arguments. The two-argument overload
    throws an exception if it fails, while the three-argument overload sets an error
    code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`boost::filesystem::rename`函数移动或重命名文件和目录，该函数以旧路径和新路径作为参数。两个参数的重载如果失败会抛出异常，而三个参数的重载则设置错误代码：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If `new_path` does not exist, it is created provided its parent directory exists;
    otherwise, the call to rename fails. If `old_path` is not a directory, then `new_path`,
    if it exists, cannot be a directory either. If `old_path` is a directory, then
    `new_path`, if it exists, must be an empty directory or the function fails. When
    a directory is moved to another empty directory, the contents of the source directory
    are copied inside the target empty directory, and then the source directory is
    removed. Renaming symbolic links acts on the links, not on the files they refer
    to.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`new_path`不存在，且其父目录存在，则会创建它；否则，重命名调用失败。如果`old_path`不是目录，则`new_path`如果存在，也不能是目录。如果`old_path`是目录，则`new_path`如果存在，必须是一个空目录，否则函数失败。当一个目录被移动到另一个空目录时，源目录的内容被复制到目标空目录内，然后源目录被删除。重命名符号链接会影响链接本身，而不是它们所指向的文件。
- en: You can delete files and empty directories by calling `boost::filesystem::remove`
    passing it the path to the filesystem entry. To recursively remove a directory
    that is not empty, you must call `boost::filesystem::remove_all`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`boost::filesystem::remove`并传递文件系统条目的路径来删除文件和空目录。要递归删除一个非空目录，必须调用`boost::filesystem::remove_all`。
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `remove` function returns false if the file named by the path does not exist.
    This removes symbolic links without impacting the files they alias. The `remove_all`
    function returns the total number of entries it removes. On error, the single-argument
    overloads of `remove` and `remove_all` throw an exception, while the two-argument
    overloads set the error code reference passed to it without throwing an exception.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径指定的文件不存在，`remove`函数返回false。这会删除符号链接而不影响它们所指向的文件。`remove_all`函数返回它删除的条目总数。在错误情况下，`remove`和`remove_all`的单参数重载会抛出异常，而双参数重载会设置传递给它的错误代码引用，而不会抛出异常。
- en: Path-aware fstreams
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径感知的fstreams
- en: In addition, the header file `boost/filesystem/fstream.hpp` provides versions
    of Standard file stream classes that work with `boost::filesystem::path` objects.
    These are very handy when you are writing code that uses `boost::filesystem` and
    also needs to read and write files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，头文件`boost/filesystem/fstream.hpp`提供了与`boost::filesystem::path`对象一起工作的标准文件流类的版本。当您编写使用`boost::filesystem`并且需要读取和写入文件的代码时，这些非常方便。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A C++ Technical Specification based on the Boost Filesystem library has been
    recently approved by ISO. This makes way for its inclusion in a future revision
    of the C++ Standard Library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，基于Boost文件系统库的C++技术规范已被ISO批准。这为其包含在未来的C++标准库修订版中铺平了道路。
- en: Extensible I/O with Boost IOStreams
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost IOStreams进行可扩展I/O
- en: The Standard Library IOStreams facility is meant to provide a framework for
    operations of all kinds on all manner of devices, but it has not proven to be
    the easiest of frameworks to extend. The Boost IOStreams library supplements this
    framework with a simpler interface for extending I/O facilities to newer devices,
    and provides some pretty useful classes that address common needs while reading
    and writing data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库IOStreams设施旨在为各种设备上的各种操作提供一个框架，但它并没有被证明是最容易扩展的框架。Boost IOStreams库通过一个更简单的接口来补充这个框架，以便将I/O功能扩展到新设备，并提供一些非常有用的类来满足在读取和写入数据时的常见需求。
- en: Architecture of Boost IOStreams
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost IOStreams的架构
- en: The Standard Library IOStreams framework provides two basic abstractions, **streams**
    and **stream buffers**. Streams provide a uniform interface to the application
    for reading or writing a sequence of characters on an underlying device. Stream
    buffers provide a lower-level abstraction for the actual device, which is leveraged
    and further abstracted by streams.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库IOStreams框架提供了两个基本抽象，**流**和**流缓冲区**。流为应用程序提供了一个统一的接口，用于在底层设备上读取或写入一系列字符。流缓冲区为实际设备提供了一个更低级别的抽象，这些设备被流所利用和进一步抽象。
- en: 'The Boost IOStreams framework provides the `boost::iostreams::stream` and `boost::iostreams::stream_buffer`
    templates, which are generic implementations of the stream and stream buffer abstractions.
    These two templates implement their functionality in terms of a further set of
    concepts, which are described as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Boost IOStreams框架提供了`boost::iostreams::stream`和`boost::iostreams::stream_buffer`模板，这些是流和流缓冲区抽象的通用实现。这两个模板根据一组进一步的概念实现其功能，这些概念描述如下：
- en: A **source** is an abstraction for an object from which a sequence of characters
    can be read.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**是一个抽象，用于从中读取一系列字符的对象。'
- en: A **sink** is an abstraction for an object to which a sequence of characters
    can be written.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇**是一个抽象，用于向其写入一系列字符。'
- en: A **device** is a source, a sink, or both.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**是源、汇，或两者兼有。'
- en: An **input filter** modifies a sequence of characters read from a source, while
    an **output filter** modifies a sequence of characters before it is written to
    a sink.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入过滤器**修改从源读取的一系列字符，而**输出过滤器**修改写入到汇之前的一系列字符。'
- en: A **filter** is an input filter or an output filter. It is possible to write
    a filter that can be used either as an input filter or as an output filter; this
    is known as a **dual use filter**.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**是输入过滤器或输出过滤器。可以编写一个既可以用作输入过滤器又可以用作输出过滤器的过滤器；这被称为**双用过滤器**。'
- en: To perform I/O on a device, we associate a sequence of zero or more filters
    plus the device with an instance of `boost::iostreams::stream` or an instance
    of `boost::iostreams::stream_buffer`. A sequence of filters is called a **chain**
    and a sequence of filters with a device at the end is said to be a **complete
    chain**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在设备上执行I/O，我们将零个或多个过滤器序列与设备关联到`boost::iostreams::stream`的实例或`boost::iostreams::stream_buffer`的实例。一系列过滤器称为**链**，一系列过滤器以设备结尾称为**完整链**。
- en: 'The following diagram is a unified view of input and output operation, illustrating
    the I/O path between a stream object and the underlying device:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是输入和输出操作的统一视图，说明了流对象和底层设备之间的I/O路径：
- en: '![Architecture of Boost IOStreams](img/1217OT_09_01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Boost IOStreams的架构](img/1217OT_09_01.jpg)'
- en: The Boost IOStreams architecture
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Boost IOStreams架构
- en: Input is read from the device and passed through an optional stack of filters
    to reach the stream buffer from where it is accessible via the stream. Output
    is written from the stream via the stream buffer and passed through a stack of
    filters before reaching the device. The filters, if any, act on the data read
    from the device to present a transformed sequence to the reader of the stream.
    They also act on the data to be written to the device and transform it before
    it is written. The preceding diagram is meant for visualizing these interactions
    but is slightly inaccurate; in code, a filter cannot act both as an input filter
    and an output filter at the same time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输入从设备中读取，并通过一个可选的过滤器堆栈传递到流缓冲区，从那里可以通过流访问。输出从流通过流缓冲区写入，并通过一堆过滤器传递到设备。如果有的话，过滤器会对从设备读取的数据进行操作，以向流的读取者呈现一个转换后的序列。它们还会对要写入设备的数据进行操作，并在写入之前进行转换。上面的图表用于可视化这些交互，但略有不准确；在代码中，过滤器不能同时作为输入过滤器和输出过滤器。
- en: The Boost IOStreams library comes with several built-in device and filter classes,
    and it is easy to create our own too. In the following sections, we illustrate
    the use of different components of the Boost IOStreams library with code examples.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Boost IOStreams库配备了几个内置的设备和过滤器类，并且也很容易创建我们自己的设备和过滤器。在接下来的章节中，我们将通过代码示例来说明Boost
    IOStreams库的不同组件的使用。
- en: Using devices
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设备
- en: A device provides an interface to read and write characters to an underlying
    medium. It abstracts a real medium like a disk, memory, or network connection.
    In this book, we will focus on using the number of readily available devices shipped
    as part of the Boost IOStreams library. Methods of writing our own device classes
    are beyond the scope of this book, but you should have little difficulty in picking
    them up from the online documentation once you are familiar with the content we
    cover in this chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 设备提供了一个接口，用于向底层介质读写字符。它抽象了像磁盘、内存或网络连接这样的真实介质。在本书中，我们将专注于使用作为Boost IOStreams库一部分提供的许多现成的设备。编写我们自己的设备类的方法超出了本书的范围，但一旦您熟悉了本章内容，您应该很容易从在线文档中学习它们。
- en: Devices for file I/O
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件I/O的设备
- en: Boost defines a number of devices for performing I/O on files and the one we
    look at first is a device that abstracts platform-specific file descriptors. Each
    platform uses some native handle for open files, different from how standard C++
    represents open files using `fstream`s. These could be integer file descriptors
    on POSIX systems and HANDLEs on Windows, for example. The Boost IOStreams library
    provides the `boost::iostreams::file_descriptor_source`, `boost::iostreams::file_descriptor_sink`,
    and `boost::iostreams::file_descriptor` devices that adapt POSIX file descriptors
    and Windows file handles into devices for input and output. In the following example,
    we use a `file_descriptor_source` object to read successive lines from a file
    on a POSIX system using the stream interface. This is useful if you want to use
    a stream interface for I/O on a file that is opened using system calls that deal
    in file descriptors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Boost定义了许多用于在文件上执行I/O的设备，我们首先看的是一个抽象平台特定文件描述符的设备。每个平台都使用一些本机句柄来打开文件，与标准C++使用`fstream`表示打开文件的方式不同。例如，这些可以是POSIX系统上的整数文件描述符和Windows上的HANDLE。Boost
    IOStreams库提供了`boost::iostreams::file_descriptor_source`、`boost::iostreams::file_descriptor_sink`和`boost::iostreams::file_descriptor`设备，它们将POSIX文件描述符和Windows文件句柄转换为输入和输出的设备。在下面的示例中，我们使用`file_descriptor_source`对象使用流接口从POSIX系统上的文件中读取连续的行。如果您想要使用流接口来处理使用文件描述符进行文件打开的I/O，这将非常有用。
- en: '**Listing 9.11: Using the file_descriptor device**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.11：使用file_descriptor设备**'
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using this program, we open the first file named on the command line and read
    successive lines off it. We first open the file using the Unix system call, `open`
    (line 15), for which we include the Unix headers `sys/types.h` and `fcntl.h` (lines
    6-7). If the file is opened successfully (indicated by a positive value of the
    file descriptor returned by `open`), then we create an instance of `file_descriptor_source`
    passing it the open file descriptor and a flag `close_handle` to indicate that
    the descriptor should be appropriately closed when the device is destroyed (lines
    17-18).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个程序，我们打开命令行中命名的第一个文件，并从中读取连续的行。我们首先使用Unix系统调用`open`（第15行）打开文件，为此我们包括Unix头文件`sys/types.h`和`fcntl.h`（第6-7行）。如果文件成功打开（由`open`返回的文件描述符的正值表示），那么我们创建一个`file_descriptor_source`的实例，将打开的文件描述符和一个`close_handle`标志传递给它，以指示在设备被销毁时应适当关闭描述符（第17-18行）。
- en: If we did not want the device to manage the descriptor's lifetime, then we had
    to pass the flag `never_close_handle` instead. We then create an instance of `boost::iostreams::stream<file_descriptor_source>`
    (line 19) passing it the device object, and read successive lines from it using
    the `std::getline` function just as we would use any `std::istream` instance (line
    23). Note that we assert the device is open for reading using the `is_open` member
    function (line 19). This code is meant to compile on Unix and Unix-like systems.
    On Windows, the Visual Studio C Runtime library provides compatible interfaces
    so that you may be able to compile and run this on Windows as well by including
    one additional header file `io.h`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望设备管理描述符的生命周期，那么我们必须传递`never_close_handle`标志。然后我们创建一个`boost::iostreams::stream<file_descriptor_source>`的实例（第19行），将设备对象传递给它，并使用`std::getline`函数从中读取连续的行，就像我们使用任何`std::istream`实例一样（第23行）。请注意，我们使用`is_open`成员函数断言设备已经打开以供读取（第19行）。这段代码旨在在Unix和类Unix系统上编译。在Windows上，Visual
    Studio C运行时库提供了兼容的接口，因此您也可以通过包括一个额外的头文件`io.h`来在Windows上编译和运行它。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The types and functions in Boost IOStreams library are split into a set of fairly
    independent header files, and there is no single header file including which will
    give you all symbols. Device headers are available under `boost/iostreams/device`
    directory and filter headers are under `boost/iostreams/filter` directory. The
    rest of the interfaces are available under `boost/iostreams`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Boost IOStreams库中的类型和函数分为一组相当独立的头文件，并没有一个单一的头文件包含所有符号。设备头文件位于`boost/iostreams/device`目录下，过滤器头文件位于`boost/iostreams/filter`目录下。其余接口位于`boost/iostreams`目录下。
- en: 'To build this program, we must link it with the `libboost_iostreams` library.
    I use the following command line on my Ubuntu box to build the program using the
    Boost libraries installed under default paths via the native package manager:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建此程序，我们必须将其与`libboost_iostreams`库链接。我在我的Ubuntu系统上使用以下命令行，使用本机包管理器在默认路径下安装的Boost库来构建程序：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We may also want to build our program to use the Boost libraries we built from
    source in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing
    Boost*. For this, I use the following command line to build this program on my
    Ubuntu box, specifying the include path and the library path, as well as the `libboost_iostreams-mt`
    library to link against:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还希望构建我们的程序，以使用我们在[第1章](ch01.html "第1章。介绍Boost")中从源代码构建的Boost库，*介绍Boost*。为此，我在我的Ubuntu系统上使用以下命令行来构建此程序，指定包含路径和库路径，以及要链接的`libboost_iostreams-mt`库：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To write to a file via a file descriptor, we need to use a `file_descriptor_sink`
    object. We can also use a `file_descriptor` object to both read and write to the
    same device. There are other devices that allow writing to files—the `file_source`,
    `file_sink`, and `file` devices allow you to read and write named files. The `mapped_file_source`,
    `mapped_file_sink`, and `mapped_file` devices allow you to read and write to files
    via memory mappings.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过文件描述符写入文件，我们需要使用`file_descriptor_sink`对象。我们还可以使用`file_descriptor`对象来同时读取和写入同一设备。还有其他允许写入文件的设备——`file_source`，`file_sink`和`file`设备允许您读取和写入命名文件。`mapped_file_source`，`mapped_file_sink`和`mapped_file`设备允许您通过内存映射读取和写入文件。
- en: Devices for reading and writing to memory
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于读写内存的设备
- en: 'The Standard Library `std::stringstream` family of classes is commonly used
    for reading and writing formatted data to memory. If you want to read and write
    from any given contiguous memory area, like an array or byte buffer, the `array`
    family of devices (`array_source`, `array_sink`, and `array`) from Boost IOStreams
    library comes in handy:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库`std::stringstream`类系列通常用于将格式化数据读写到内存。如果要从任何给定的连续内存区域（如数组或字节缓冲区）中读取和写入，Boost
    IOStreams库中的`array`设备系列（`array_source`，`array_sink`和`array`）非常方便：
- en: '**Listing 9.12: Using array devices**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.12：使用数组设备**'
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This example follows the same pattern as Listing 9.11, but we use two devices,
    a sink and a source, instead of one. In each case, we do the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例遵循与清单9.11相同的模式，但我们使用了两个设备，一个汇和一个源，而不是一个。在每种情况下，我们都执行以下操作：
- en: We create an appropriately initialized device
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个适当初始化的设备
- en: We create a stream object and associate the device with it
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个流对象并将设备与其关联
- en: We perform input or output on the stream
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流上执行输入或输出
- en: We first define an `array_sink` device, which is used to write to a contiguous
    region of memory. The region of memory is passed to the device constructor as
    a pair of pointers to the first element of an array of `char`s and the one past
    the last element (line 10). We associate this device with a stream object `out`
    (line 11) and then write some content to the stream using insertion operators
    (`<<`). Note that this content can be of any streamable type, not just textual.
    Using the manipulator `std::ends` (line 13), we make sure that the array has a
    terminating null character after the text. Using the `std::flush` manipulator,
    we make sure that this content is not held in the device buffer but finds its
    way to the backing array `out_array` of the sink device before we call `strlen`
    on `out_array` (line 16).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`array_sink`设备，用于写入连续的内存区域。内存区域作为一对指针传递给设备构造函数，指向一个`char`数组的第一个元素和最后一个元素的下一个位置（第10行）。我们将这个设备与流对象`out`关联（第11行），然后使用插入操作符(`<<`)向流中写入一些内容。请注意，这些内容可以是任何可流化的类型，不仅仅是文本。使用操纵器`std::ends`（第13行），我们确保数组在文本之后有一个终止空字符。使用`std::flush`操纵器，我们确保这些内容不会保留在设备缓冲区中，而是在调用`out_array`（第16行）上的`strlen`之前找到它们的方式到汇流设备的后备数组`out_array`中。
- en: 'Next, we create a `vector` of `chars` called `vchars` initialized with the
    content of `out_array` (lines 15-16). We then define an `array_source` device
    backed by this `vector`, passing to the constructor an iterator to the first element
    of `vchars` and the number of characters in `vchars` (line 17). Finally, we construct
    an input stream associated with the device (line 18) and then use the `boost::iostreams::copy`
    function template to copy characters from the input stream to the standard output
    (line 20). Running the preceding code writes the following line to `out_array`
    through the `array_sink` device:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`vchars`的`char`向量，用`out_array`的内容进行初始化（第15-16行）。然后，我们定义一个由这个`vector`支持的`array_source`设备，向构造函数传递一个指向`vchars`第一个元素的迭代器和`vchars`中的字符数（第17行）。最后，我们构造一个与该设备关联的输入流（第18行），然后使用`boost::iostreams::copy`函数模板将字符从输入流复制到标准输出（第20行）。运行上述代码将通过`array_sink`设备向`out_array`写入以下行：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It then reads each word in this phrase and prints it to the standard output
    on a new line.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它读取短语中的每个单词，并将其打印到新行的标准输出中。
- en: 'In addition to the `array` devices, the `back_insert_device` device can be
    used to adapt several standard containers as sinks. The difference between `back_insert_device`
    and `array_sink` is that `array_sink` requires a fixed memory buffer to operate
    on, whereas `back_insert_device` can use as its backing store any standard container
    with an `insert` member function. This allows the underlying memory area for a
    `back_insert_device` to grow as required by the size of input. We rewrite listing
    9.12 using a `back_insert_device` in place of the `array_sink`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`array`设备，`back_insert_device`设备还可以用于适配几个标准容器作为sink。`back_insert_device`和`array_sink`之间的区别在于，`array_sink`需要一个固定的内存缓冲区来操作，而`back_insert_device`可以使用任何具有`insert`成员函数的标准容器作为其后备存储器。这允许`back_insert_device`的底层内存区域根据输入的大小而增长。我们使用`back_insert_device`替换`array_sink`重写列表9.12：
- en: '**Listing 9.13: Using back_insert_device**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表9.13：使用back_insert_device**'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we write to `out_vec`, which is a `vector<char>` (line 11), and do so
    using the `back_insert_device` sink (line 12). We write the size of `out_vec`
    to the stream, but this may not print the total number of characters already written
    to the device at that point, because the device may buffer some of the output
    before flushing it to the vector. Since we intend to copy this data to another
    vector for reading (lines 16-17), we ensure that all the data is written to `out_vec`
    using the `std::flush` manipulator (line 14).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们写入`out_vec`，它是一个`vector<char>`（第11行），并且使用`back_insert_device` sink（第12行）进行写入。我们将`out_vec`的大小写入流中，但这可能不会打印在那时已经写入设备的字符总数，因为设备可能会在将输出刷新到向量之前对其进行缓冲。由于我们打算将这些数据复制到另一个向量以供读取（第16-17行），我们使用`std::flush`操纵器确保所有数据都写入`out_vec`（第14行）。
- en: There are other interesting devices, like the `tee_device` adaptor that allows
    writing a character sequence to two different devices, reminiscent of the Unix
    `tee` command. We will now look at how you can write your own device.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他有趣的设备，比如`tee_device`适配器，允许将字符序列写入两个不同的设备，类似于Unix的`tee`命令。现在我们将看一下如何编写自己的设备。
- en: Using filters
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用过滤器
- en: Filters act on the character stream that is written to a sink or read from a
    source, either transforming it before it is written and read, or simply observing
    some properties of the stream. The transformation can do a variety of things,
    like tagging keywords, translating text, performing regular expression substitution,
    and performing compression or decompression. Observer filters can compute line
    and word counts or compute a message digest among other things.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器作用于写入到汇或从源读取的字符流，可以在写入和读取之前对其进行转换，或者仅仅观察流的一些属性。转换可以做各种事情，比如标记关键字，翻译文本，执行正则表达式替换，以及执行压缩或解压缩。观察者过滤器可以计算行数和单词数，或者计算消息摘要等。
- en: Regular streams and stream buffers do not support filters and we need to use
    **filtering streams** and **filtering stream buffers** instead in order to use
    filters. Filtering streams and stream buffers maintain a stack of filters with
    the source or sink at the top and the outermost filter at the bottom in a data
    structure called a **chain**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 常规流和流缓冲区不支持过滤器，我们需要使用**过滤流**和**过滤流缓冲区**来使用过滤器。过滤流和流缓冲区维护一个过滤器堆栈，源或汇在顶部，最外层的过滤器在底部，称为**链**的数据结构。
- en: We will now look at several utility filters that are shipped as part of the
    Boost IOStreams library. Writing our own filters is outside the scope of this
    book, but the excellent online documentation covers this topic in adequate detail.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下Boost IOStreams库作为一部分提供的几个实用过滤器。编写自己的过滤器超出了本书的范围，但优秀的在线文档详细介绍了这个主题。
- en: Basic filters
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本过滤器
- en: 'In the first example of using filters, we use `boost::iostreams::counter` filter
    to keep a count of characters and lines in text read from a file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用过滤器的第一个示例中，我们使用`boost::iostreams::counter`过滤器来计算从文件中读取的文本的字符和行数：
- en: '**Listing 9.14: Using the counter filter**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表9.14：使用计数器过滤器**'
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We create a `boost::iostream::file_source` device for reading the contents of
    a file named on the command line (line 14). We create a `counter` filter for counting
    the number of lines and characters read (line 15). We create an object of `filtering_istream`
    (line 16) and push the filter (line 17) followed by the device (line 19). Till
    the device is pushed, we can assert that the filtering stream is incomplete (line
    18) and it is complete once the device is pushed (line 20). We copy the contents
    read from the filtering input stream to the standard output (line 22) and then
    access the character and line counts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`boost::iostream::file_source`设备来读取命令行中指定的文件的内容（第14行）。我们创建一个`counter`过滤器来计算读取的行数和字符数（第15行）。我们创建一个`filtering_istream`对象（第16行），并推送过滤器（第17行），然后是设备（第19行）。在设备被推送之前，我们可以断言过滤流是不完整的（第18行），一旦设备被推送，它就是完整的（第20行）。我们将从过滤输入流中读取的内容复制到标准输出（第22行），然后访问字符和行数。
- en: To access the counts, we need to refer to the `counter` filter object sitting
    in the chain inside the filtering stream. To get to this, we call the `component`
    member template function of `filtering_istream` passing in the index of the filter
    we want and the type of the filter. This returns a pointer to the `counter` filter
    object (line 24) and we retrieve the number of characters and lines read by calling
    the appropriate member functions (lines 25-26).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问计数，我们需要引用过滤流内部的链中的`counter`过滤器对象。为了做到这一点，我们调用`filtering_istream`的`component`成员模板函数，传入我们想要的过滤器的索引和过滤器的类型。这将返回一个指向`counter`过滤器对象的指针（第24行），我们通过调用适当的成员函数（第25-26行）检索读取的字符和行数。
- en: In the next example, we use `boost::iostreams::grep_filter` to filter out blank
    lines. Unlike the counter filter which did not modify the input stream, this transforms
    the output stream by removing blank lines.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们使用`boost::iostreams::grep_filter`来过滤掉空行。与不修改输入流的计数器过滤器不同，这个过滤器通过删除空行来转换输出流。
- en: '**Listing 9.15: Using the grep_filter**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表9.15：使用grep_filter**'
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example is on the same lines as the listing 9.14 except that we use a different
    filter, `boost::iostreams::grep_filter`, to filter out blank lines. We create
    an instance of the `grep_filter` object, passing three arguments to its constructor.
    The first argument is the regular expression `^\s*$` that matches blank lines—lines
    that contain zero or more whitespace characters (line 16). Note that the backslash
    is escaped in code. The second argument is the constant `match_default` to indicate
    that we use Perl regular expression syntax (line 17). The third argument `boost::iostreams::grep::invert`
    tells the filter to let only those lines that match the regular expression to
    be filtered out (line 17). The default behavior is to filter out only those lines
    that do not match the regular expression.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与列表9.14相同，只是我们使用了不同的过滤器`boost::iostreams::grep_filter`来过滤空行。我们创建了`grep_filter`对象的一个实例，并向其构造函数传递了三个参数。第一个参数是匹配空行的正则表达式`^\s*$`（第16行）。请注意，反斜杠在代码中被转义了。第二个参数是常量`match_default`，表示我们使用Perl正则表达式语法（第17行）。第三个参数`boost::iostreams::grep::invert`告诉过滤器只允许匹配正则表达式的行被过滤掉（第17行）。默认行为是只过滤掉不匹配正则表达式的行。
- en: 'To build this program on Unix, you must additionally link against the Boost
    Regex library:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unix上构建此程序，您还必须链接到Boost Regex库：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On a system without the Boost native packages and with Boost installed at a
    custom location, use the following more elaborate command line:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有Boost本机包并且Boost安装在自定义位置的系统上，使用以下更详细的命令行：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On Windows, using Visual Studio and enabling auto linking against DLLs, you
    do not need to explicitly specify the Regex or IOStream DLLs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，使用Visual Studio并启用自动链接到DLL，您不需要显式指定Regex或IOStream DLL。
- en: Filters for compression and decompression
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩和解压过滤器
- en: Boost IOStreams library comes with three different filters for compressing and
    decompressing data, one each for gzip, zlib, and bzip2 formats. The gzip and zlib
    formats implement different variants of the **DEFLATE algorithm** for compression,
    while the bzip2 format uses the more space-efficient **Burrows-Wheeler algorithm**.
    Since these are external libraries, they must be built and linked to our executables
    if we use these compression formats. If you have followed the detailed steps outlined
    in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing Boost*,
    to build Boost libraries with support for zlib and bzip2, then the zlib and bzip2
    shared libraries should have been built along with the Boost Iostreams shared
    library.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Boost IOStreams库配备了三种不同的数据压缩和解压过滤器，分别用于gzip、zlib和bzip2格式。gzip和zlib格式实现了不同变种的DEFLATE算法进行压缩，而bzip2格式则使用更节省空间的Burrows-Wheeler算法。由于这些是外部库，如果我们使用这些压缩格式，它们必须被构建和链接到我们的可执行文件中。如果您已经按照[第1章](ch01.html
    "第1章.介绍Boost")中概述的详细步骤构建了支持zlib和bzip2的Boost库，那么zlib和bzip2共享库应该已经与Boost Iostreams共享库一起构建了。
- en: In the following example, we compress a file named on the command line and write
    it to the disk. We then read it back, decompress it, and write it to the standard
    output.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们压缩了一个命令行中命名的文件，并将其写入磁盘。然后我们读取它，解压它，并将其写入标准输出。
- en: '**Listing 9.16: Using gzip compressor and decompressor**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表9.16：使用gzip压缩器和解压器**'
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code first uses the `boost::iostreams::gzip_compressor` filter
    (line 16) to decompress the file as it is read (line 17). It then writes this
    content to a file with the `.gz` extension appended to the original file name
    using `boost::iostreams::copy` (lines 20-22). The call to `boost::iostreams::copy`
    also flushes and closes the output and input streams passed to it. Thus, it is
    safe to read back from the file immediately after the call to `copy` returns.
    To read this compressed file back, we use a `boost::iostreams::file_source` device
    with a `boost::iostreams::gzip_decompressor` in front (lines 27-28) and write
    the decompressed output to the standard output (line 30). We reuse the `filtering_istream`
    object for reading the original file and again for reading the compressed file.
    Calling the `reset` member function on the filtering stream closes and removes
    the filter chain and device associated with the stream (line 26), so we can associate
    a new filter chain and device (lines 27-28).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先使用`boost::iostreams::gzip_compressor`过滤器（第16行）在读取文件时解压文件（第17行）。然后使用`boost::iostreams::copy`将这个内容写入一个带有`.gz`扩展名的文件中，该扩展名附加到原始文件名上（第20-22行）。对`boost::iostreams::copy`的调用还会刷新和关闭传递给它的输出和输入流。因此，在`copy`返回后立即从文件中读取是安全的。为了读取这个压缩文件，我们使用一个带有`boost::iostreams::gzip_decompressor`的`boost::iostreams::file_source`设备（第27-28行），并将解压后的输出写入标准输出（第30行）。我们重用`filtering_istream`对象来读取原始文件，然后再次用于读取压缩文件。在过滤流上调用`reset`成员函数会关闭并删除与流相关的过滤器链和设备（第26行），因此我们可以关联一个新的过滤器链和设备（第27-28行）。
- en: It is possible to override several defaults by supplying additional arguments
    to the constructor of the compressor or decompressor filter, but the essential
    structure does not change. By changing the header from `gzip.hpp` to `bzip2.hpp`
    (line 4), and replacing the `gzip_compressor` and `gzip_decompressor` with `bzip2_compressor`
    and `bzip2_decompressor` in the preceding code, we can test the code for the bzip2
    format; likewise for the zlib format. Ideally, the extensions should be changed
    aptly (.bz2 for bzip2 and .zlib for zlib). On most Unix systems, it will be worthwhile
    to test the generated compressed files by uncompressing them independently using
    gzip and bzip2 tools. Command-line tools for zlib archives seem scanty and less
    standardized. On my Ubuntu system, the `qpdf` program comes with a raw zlib compression/decompression
    utility called `zlib-flate`, which can compress to and decompress from zlib format.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向压缩器或解压器过滤器的构造函数提供额外的参数，可以覆盖几个默认值，但基本结构不会改变。通过将头文件从`gzip.hpp`更改为`bzip2.hpp`（第4行），并在前面的代码中用`bzip2_compressor`和`bzip2_decompressor`替换`gzip_compressor`和`gzip_decompressor`，我们可以测试bzip2格式的代码；同样适用于zlib格式。理想情况下，扩展名应该适当更改（.bz2用于bzip2，.zlib用于zlib）。在大多数Unix系统上，值得测试生成的压缩文件，通过使用gzip和bzip2工具单独解压缩它们。对于zlib存档的命令行工具似乎很少，且标准化程度较低。在我的Ubuntu系统上，`qpdf`程序带有一个名为`zlib-flate`的原始zlib压缩/解压缩实用程序，可以压缩到zlib格式并从zlib格式解压缩。
- en: The steps to build this program are the same as the steps outlined to build
    listing 9.15\. Even if you use the `zlib_compressor` or `bzip2_compressor` filters
    instead, the necessary shared libraries will be automatically picked up by the
    linker (and later, the runtime linker during execution) as long as the option
    `-Wl,-rpath,/opt/boost/lib` is used during linking and the path `/opt/boost/lib`
    contains the shared libraries for zlib and bzip2.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此程序的步骤与构建清单9.15时的步骤相同。即使使用`zlib_compressor`或`bzip2_compressor`过滤器，只要在链接期间使用选项`-Wl,-rpath,/opt/boost/lib`，链接器（以及稍后的运行时链接器在执行期间）将自动选择必要的共享库，路径`/opt/boost/lib`包含zlib和bzip2的共享库。
- en: Composing filters
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合过滤器
- en: Filtering streams can apply multiple filters to a character sequence in a pipeline.
    Using the `push` method on the filtering stream, we form the pipeline starting
    with the outermost filter, inserting the filters in the desired order, and ending
    with the device.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤流可以在管道中对字符序列应用多个过滤器。通过在过滤流上使用`push`方法，我们可以形成以最外层过滤器开始的管道，按所需顺序插入过滤器，并以设备结束。
- en: 'This means that for filtering an output stream, you first push the filter that
    gets applied first and work forward pushing each successive filter, followed at
    the end by the sink. For example, in order to filter out some lines and compress
    before writing to a sink, the sequence of pushes would be like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于过滤输出流，您首先推送首先应用的过滤器，然后向前推送每个连续的过滤器，最后是接收器。例如，为了过滤掉一些行并在写入接收器之前进行压缩，推送的顺序将如下所示：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For filtering input streams, you push the filters, starting with the filter
    that gets applied last and work backward pushing each preceding filter, followed
    at the end by the source. For example, in order to read a file, decompress it
    and then perform a line count, the sequence of pushes will look like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过滤输入流，您需要推送过滤器，从最后应用的过滤器开始，然后逆向工作，推送每个前置过滤器，最后是源。例如，为了读取文件，解压缩它，然后执行行计数，推送的顺序将如下所示：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Pipelining
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道
- en: 'It turns out that a little operator overloading can make this much more expressive.
    We can write the preceding chains using the pipe operator (`operator|`) in the
    following alternative notation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 原来一点点的操作符重载可以使这个过程更加具有表现力。我们可以使用管道操作符（`operator|`）以以下替代符号来编写前面的链：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding snippet is clearly more expressive with fewer lines of code.
    From left to right, the filters are strung together in the order you push them
    into the stream, with the device at the end. Not all filters can be combined in
    this way, but many readily available ones from the Boost IOStreams library can;
    more definitively, filters must conform to the **Pipable concept** to be combined
    this way. Here is a complete example of a program that reads the text in a file,
    removes blank lines, and then compresses it using bzip2:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段显然更具表现力，代码行数更少。从左到右，过滤器按照您将它们推入流中的顺序串联在一起，最后是设备。并非所有过滤器都可以以这种方式组合，但来自Boost
    IOStreams库的许多现成的过滤器可以；更明确地说，过滤器必须符合**可管道化概念**才能以这种方式组合。以下是一个完整的示例程序，该程序读取文件中的文本，删除空行，然后使用bzip2进行压缩：
- en: '**Listing 9.17: Piping filters**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.17：使用管道过滤器**'
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding example strings together a grep filter for filtering out blank
    lines (lines 16-18) and a bzip2 compressor (line 15) with a file source device
    using pipes (line 20). The rest of the code should be familiar from listings 9.15
    and 9.16.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将一个用于过滤空行的grep过滤器（第16-18行）和一个bzip2压缩器（第15行）与使用管道的文件源设备串联在一起（第20行）。代码的其余部分应该与清单9.15和9.16相似。
- en: Branching data streams with tee
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用tee分支数据流
- en: 'While using filter chains with multiple filters, it is sometimes useful, especially
    for debugging, to capture the data flowing between two filters. The `boost::iostreams::
    tee_filter` is an output filter akin to the Unix `tee` command that sits interposed
    between two filters and extracts a copy of the data stream flowing between the
    two filters. Essentially, when you want to capture data at different intermediate
    stages of processing, you can use a `tee_filter`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用具有多个过滤器的过滤器链时，有时捕获两个过滤器之间流动的数据是有用的，特别是用于调试。`boost::iostreams::tee_filter`是一个输出过滤器，类似于Unix的`tee`命令，它位于两个过滤器之间，并提取两个过滤器之间流动的数据流的副本。基本上，当您想要在处理的不同中间阶段捕获数据时，可以使用`tee_filter`：
- en: '![Branching data streams with tee](img/1217OT_09_03.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![使用tee分支数据流](img/1217OT_09_03.jpg)'
- en: 'You can also multiplex two sink devices to create a **tee device**, such that
    writing some content to the tee device writes it to both the underlying devices.
    The `boost::iostream::tee_device` class template combines two sinks to create
    such a tee device. By nesting tee devices or pipelining tee filters, we can generate
    several parallel streams that can be processed differently. The `boost::iostreams::tee`
    function template can generate tee filters and tee streams. It has two overloads—a
    single-argument overload that takes a sink and generates a `tee_filter`, and a
    two-argument overload that takes two sinks and returns a `tee_device`. The following
    example shows how to compress a file to three different compression formats (gzip,
    zlib, and bzip2) using very little code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以复用两个接收设备来创建一个**tee设备**，这样将一些内容写入tee设备会将其写入底层设备。`boost::iostream::tee_device`类模板结合了两个接收器以创建这样的tee设备。通过嵌套tee设备或管道化tee过滤器，我们可以生成几个可以以不同方式处理的并行流。`boost::iostreams::tee`函数模板可以生成tee过滤器和tee流。它有两个重载——一个单参数重载，接收一个接收器并生成一个`tee_filter`，另一个双参数重载，接收两个接收器并返回一个`tee_device`。以下示例显示了如何使用非常少的代码将文件压缩为三种不同的压缩格式（gzip、zlib和bzip2）：
- en: '**Listing 9.18: Branching output streams with tees**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单9.18：使用tee分支输出流**'
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We set up three compression filters for gzip, bzip2, and zlib (lines 17, 23,
    and 29). We need one `filtering_ostream` for each output file. We create the `gzout`
    stream for the gzip-compressed output (line 20) and the `bz2out` stream for the
    bzip2-compressed output (line 26). We create tee filters around these two streams
    (lines 21 and 27). Finally, we string together the filters gztee, bz2tee, and
    zlib in front of the zlibfile sink and push this chain into the zlibout `filtering_ostream`
    for the zlib file (line 33). Copying from the input stream `ins` into the output
    stream `zlibout` generates the three compressed output files in a pipeline, as
    shown in the following diagram:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为gzip、bzip2和zlib设置了三个压缩过滤器（第17、23和29行）。我们需要为每个输出文件创建一个`filtering_ostream`。我们为gzip压缩输出创建了`gzout`流（第20行），为bzip2压缩输出创建了`bz2out`流（第26行）。我们在这两个流周围创建了tee过滤器（第21和27行）。最后，我们将gztee、bz2tee和zlib连接到zlibfile接收器前面，并将此链推入zlibout的`filtering_ostream`中，用于zlib文件（第33行）。从输入流`ins`复制到输出流`zlibout`会生成管道中的三个压缩输出文件，如下图所示：
- en: '![Branching data streams with tee](img/1217OT_09_02.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![使用tee分支数据流](img/1217OT_09_02.jpg)'
- en: Notice that the calls to tee are not namespace-qualified but get correctly resolved
    due to Argument Dependent Lookup (see [Chapter 2](ch02.html "Chapter 2. The First
    Brush with Boost's Utilities"), *The First Brush with Boost's Utilities*).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对tee的调用没有命名空间限定，但由于参数相关查找（见[第2章](ch02.html "第2章。使用Boost实用工具的第一次尝试")，“使用Boost实用工具的第一次尝试”），它们得到了正确的解析。
- en: The Boost IOStreams library provides a very rich framework for writing and using
    devices and filters. This chapter introduces only the basic uses of this library
    and there is a whole host of filters, devices, and adaptors that can be combined
    into useful patterns for I/O.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Boost IOStreams库提供了一个非常丰富的框架，用于编写和使用设备和过滤器。本章仅介绍了此库的基本用法，还有许多过滤器、设备和适配器可以组合成有用的I/O模式。
- en: Self-test questions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple-choice questions, choose all options that apply:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: What is unique to the `canonical` and `equivalent` functions for manipulating
    paths?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于操作路径的`canonical`和`equivalent`函数有什么独特之处？
- en: a. The arguments cannot name real paths.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: a. 参数不能命名真实路径。
- en: b. Both are namespace-level functions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: b. 两者都是命名空间级别的函数。
- en: c. The arguments must name real paths.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: c. 参数必须命名真实路径。
- en: What is the problem with the following code snippet assuming the path is of
    type `boost::filesystem::path`?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段的问题是什么，假设路径的类型是`boost::filesystem::path`？
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: a. It must have static `value` field.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: a. 它必须有静态的`value`字段。
- en: b. It must have an embedded type called `type`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它必须有一个名为`type`的嵌入类型。
- en: c. It must have static `type` field.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它必须有静态的`type`字段。
- en: d. It must have an embedded type called `result`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: d. 它必须有一个名为`result`的嵌入类型。
- en: 'Given this code snippet:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这段代码：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What is the value of n?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: n的值是多少？
- en: a. 5, the total number of components in the path.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: a. 5，路径中组件的总数。
- en: b. 6, the total number of components in the path.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: b. 6，路径中组件的总数。
- en: c. 10, the sum of the number of slashes and components.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: c. 10，斜杠和组件数量的总和。
- en: d. 4, the total number of directory components.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: d. 4，目录组件的总数。
- en: You want to read a text file, remove all blank lines using a `grep_filter`,
    replace specific keywords using the `regex_filter`, and count the characters and
    lines in the result. Which of the following pipelines will you use?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想要读取一个文本文件，使用`grep_filter`删除所有空行，使用`regex_filter`替换特定关键词，并计算结果中的字符和行数。您将使用以下哪个管道？
- en: a. `file_source | grep_filter| regex_filter | counter`
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: a. `file_source | grep_filter| regex_filter | counter`
- en: b. `grep_filter | regex_filter | counter | file_source`
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: b. `grep_filter | regex_filter | counter | file_source`
- en: c. `counter | regex_filter | grep_filter |file_source`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: c. `counter | regex_filter | grep_filter |file_source`
- en: d. `file_source | counter | grep_filter | regex_filter`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: d. `file_source | counter | grep_filter | regex_filter`
- en: 'True or false: A tee filter cannot be used with an input stream.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：tee过滤器不能与输入流一起使用。
- en: a. True.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: a. 真。
- en: b. False.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the Boost Filesystem library for reading file metadata
    and state of files and directories, and performing operations on them. We also
    covered the high-level Boost IOStreams framework for performing type-safe I/O
    with rich semantics.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Boost Filesystem库，用于读取文件元数据和文件和目录状态，并对它们执行操作。我们还介绍了高级Boost IOStreams框架，用于执行具有丰富语义的类型安全I/O。
- en: Working with files and performing I/O are basic system programming tasks that
    almost any useful piece of software needs to perform and the Boost libraries we
    covered in this chapter ease those tasks through a set of portable interfaces.
    In the next chapter, we will turn our attention to another systems programming
    topic—concurrency and multithreading.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件和执行I/O操作是基本的系统编程任务，几乎任何有用的软件都需要执行这些任务，而我们在本章中介绍的Boost库通过一组可移植的接口简化了这些任务。在下一章中，我们将把注意力转向另一个系统编程主题——并发和多线程。
