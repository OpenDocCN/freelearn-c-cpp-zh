["```cpp\nint numZombies = 100; \nint& rNumZombies = numZombies; \n\n```", "```cpp\nint score = 10; \nint& rScore = score; \nscore++; \nrScore++; \n\n```", "```cpp\nscore++; \n\n```", "```cpp\nrScore++; \n\n```", "```cpp\nvoid add(int n1, int n2, int a); \nvoid referenceAdd(int n1, int n2, int& a); \n\nint main() \n{ \n   int number1 = 2; \n   int number2 = 2; \n   int answer = 0; \n\n   add(number1, number2, answer); \n   // answer still equals zero because it is passed as a copy \n   // Nothing happens to answer in the scope of main \n\n   referenceAdd(number1, number2, answer); \n   // Now answer equals 4 because it was passed by reference \n   // When the referenceAdd funtion did this: \n   // answer = num1 + num 2; \n   // It is actually changing the value stored by a \n   return 0; \n} \n\n// Here are the two function definitions \n// They are exactly the same except that \n// the second passes a reference to a \nadd(int n1, int n2, int a) \n{ \n   a = n1 + n2; \n   // a now equals 4 \n   // But when the function returns a is lost forever \n} \n\nreferenceAdd(int n1, int n2, int& a) \n{ \n   a = n1 + n2; \n   // a now equals 4 \n   // But a is a reference! \n   // So it is actually answer, back in main, that equals 4 \n} \n\n```", "```cpp\n// Create a vertex array \nVertexArray background; \n\n```", "```cpp\n// What primitive type are we using \nbackground.setPrimitiveType(Quads); \n\n```", "```cpp\n// Set the size of the vertex array \nbackground.resize(10 * 10 * 4); \n\n```", "```cpp\n// Position each vertex in the current quad \nbackground[0].position = Vector2f(0, 0); \nbackground[1].position = Vector2f(49, 0); \nbackground[2].position = Vector2f(49,49); \nbackground[3].position = Vector2f(0, 49); \n\n```", "```cpp\n// Set the texture coordinates of each vertex \nbackground[0].texCoords = Vector2f(0, 0); \nbackground[1].texCoords = Vector2f(49, 0); \nbackground[2].texCoords = Vector2f(49, 49); \nbackground[3].texCoords = Vector2f(0, 49); \n\n```", "```cpp\n// Set the texture coordinates of each vertex \nbackground[0].texCoords = Vector2f(0, 50); \nbackground[1].texCoords = Vector2f(49, 50); \nbackground[2].texCoords = Vector2f(49, 99); \nbackground[3].texCoords = Vector2f(0, 99); \n\n```", "```cpp\n// Load the texture for our background vertex array \nTexture textureBackground; \ntextureBackground.loadFromFile(\"graphics/background_sheet.png\"); \n\n```", "```cpp\n// Draw the background \nwindow.draw(background, &textureBackground); \n\n```", "```cpp\n#pragma once \nusing namespace sf;\nint createBackground(VertexArray& rVA, IntRect arena);\n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"ZombieArena.h\" \n\nint createBackground(VertexArray& rVA, IntRect arena) \n{ \n   // Anything we do to rVA we are actually doing \n   // to background (in the main function) \n\n   // How big is each tile/texture \n   const int TILE_SIZE = 50; \n   const int TILE_TYPES = 3; \n   const int VERTS_IN_QUAD = 4; \n\n   int worldWidth = arena.width / TILE_SIZE; \n   int worldHeight = arena.height / TILE_SIZE; \n\n   // What type of primitive are we using? \n   rVA.setPrimitiveType(Quads); \n\n   // Set the size of the vertex array \n   rVA.resize(worldWidth * worldHeight * VERTS_IN_QUAD); \n\n   // Start at the beginning of the vertex array \n   int currentVertex = 0; \n\n   return TILE_SIZE; \n} \n\n```", "```cpp\n   // Start at the beginning of the vertex array \n   int currentVertex = 0; \n\n for (int w = 0; w < worldWidth; w++)\n   {\n     for (int h = 0; h < worldHeight; h++)\n     {\n        // Position each vertex in the current quad\n        rVA[currentVertex + 0].position =\n            Vector2f(w * TILE_SIZE, h * TILE_SIZE);\n\n        rVA[currentVertex + 1].position =\n           Vector2f((w * TILE_SIZE) + TILE_SIZE, h * TILE_SIZE);\n\n        rVA[currentVertex + 2].position =\n           Vector2f((w * TILE_SIZE) + TILE_SIZE, (h * TILE_SIZE)\n            + TILE_SIZE);\n\n        rVA[currentVertex + 3].position =\n           Vector2f((w * TILE_SIZE), (h * TILE_SIZE)\n            + TILE_SIZE);\n\n        // Position ready for the next for vertices\n        currentVertex = currentVertex + VERTS_IN_QUAD;\n     }\n   } \n\n   return TILE_SIZE; \n} \n\n```", "```cpp\nfor (int w = 0; w < worldWidth; w++) \n   { \n      for (int h = 0; h < worldHeight; h++) \n      { \n         // Position each vertex in the current quad \n         rVA[currentVertex + 0].position =  \n            Vector2f(w * TILE_SIZE, h * TILE_SIZE); \n\n         rVA[currentVertex + 1].position = \n            Vector2f((w * TILE_SIZE) + TILE_SIZE, h * TILE_SIZE); \n\n         rVA[currentVertex + 2].position = \n            Vector2f((w * TILE_SIZE) + TILE_SIZE, (h * TILE_SIZE)  \n            + TILE_SIZE); \n\n         rVA[currentVertex + 3].position = \n            Vector2f((w * TILE_SIZE), (h * TILE_SIZE)  \n            + TILE_SIZE); \n\n // Define the position in the Texture for current quad\n        // Either grass, stone, bush or wall\n        if (h == 0 || h == worldHeight-1 ||\n            w == 0 || w == worldWidth-1)\n        {\n           // Use the wall texture\n           rVA[currentVertex + 0].texCoords =\n              Vector2f(0, 0 + TILE_TYPES * TILE_SIZE);\n           rVA[currentVertex + 1].texCoords =\n              Vector2f(TILE_SIZE, 0 +\n              TILE_TYPES * TILE_SIZE);\n           rVA[currentVertex + 2].texCoords =\n              Vector2f(TILE_SIZE, TILE_SIZE +\n              TILE_TYPES * TILE_SIZE);\n           rVA[currentVertex + 3].texCoords =\n              Vector2f(0, TILE_SIZE +\n              TILE_TYPES * TILE_SIZE);\n        } \n\n         // Position ready for the next for vertices \n         currentVertex = currentVertex + VERTS_IN_QUAD; \n      } \n   } \n\n   return TILE_SIZE; \n} \n\n```", "```cpp\n         // Define position in Texture for current quad \n         // Either grass, stone, bush or wall \n         if (h == 0 || h == worldHeight-1 || \n            w == 0 || w == worldWidth-1) \n         { \n            // Use the wall texture \n            rVA[currentVertex + 0].texCoords =  \n               Vector2f(0, 0 + TILE_TYPES * TILE_SIZE); \n\n            rVA[currentVertex + 1].texCoords =  \n               Vector2f(TILE_SIZE, 0 +  \n               TILE_TYPES * TILE_SIZE); \n\n            rVA[currentVertex + 2].texCoords =  \n               Vector2f(TILE_SIZE, TILE_SIZE +  \n               TILE_TYPES * TILE_SIZE); \n\n            rVA[currentVertex + 3].texCoords =  \n               Vector2f(0, TILE_SIZE +  \n               TILE_TYPES * TILE_SIZE); \n         } \n else\n        {\n           // Use a random floor texture\n           srand((int)time(0) + h * w - h);\n           int mOrG = (rand() % TILE_TYPES);\n           int verticalOffset = mOrG * TILE_SIZE;\n\n           rVA[currentVertex + 0].texCoords =\n              Vector2f(0, 0 + verticalOffset);\n\n           rVA[currentVertex + 1].texCoords =\n              Vector2f(TILE_SIZE, 0 + verticalOffset);\n\n           rVA[currentVertex + 2].texCoords =\n              Vector2f(TILE_SIZE, TILE_SIZE + verticalOffset);\n\n           rVA[currentVertex + 3].texCoords =\n              Vector2f(0, TILE_SIZE + verticalOffset);\n        } \n\n         // Position ready for the next for vertices \n         currentVertex = currentVertex + VERTS_IN_QUAD; \n      } \n   } \n\n   return TILE_SIZE; \n} \n\n```", "```cpp\n// Create an instance of the Player class \nPlayer player; \n\n// The boundaries of the arena \nIntRect arena; \n\n// Create the backgroundVertexArray background;\n// Load the texture for our background vertex array\nTexture textureBackground;\ntextureBackground.loadFromFile(\"graphics/background_sheet.png\"); \n\n// The main game loop \nwhile (window.isOpen()) \n\n```", "```cpp\nif (state == State::PLAYING) \n{ \n   // Prepare thelevel \n   // We will modify the next two lines later \n   arena.width = 500; \n   arena.height = 500; \n   arena.left = 0; \n   arena.top = 0; \n\n // Pass the vertex array by reference\n   // to the createBackground function\n   int tileSize = createBackground(background, arena); \n\n   // We will modify this line of code later \n // int tileSize = 50; \n\n   // Spawn the player in the middle of the arena \n   player.spawn(arena, resolution, tileSize); \n\n   // Reset the clock so there isn't a frame jump \n   clock.restart(); \n} \n\n```", "```cpp\n/* \n ************** \n Draw the scene \n ************** \n */ \n\nif (state == State::PLAYING) \n{ \n   window.clear(); \n\n   // Set the mainView to be displayed in the window \n   // And draw everything related to it \n   window.setView(mainView); \n\n // Draw the background\n   window.draw(background, &textureBackground); \n\n   // Draw the player \n   window.draw(player.getSprite()); \n} \n\n```"]