- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Exploring Techniques for Lighting, Shading, and Shadows
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索照明、阴影和阴影技术
- en: 'Welcome to an exploration of lighting and shading techniques designed to infuse
    realism into your scenes. In the world of graphics, both lighting and shading
    play an integral role in enhancing the aesthetic appeal and realism of 3D visuals.
    This chapter delves into these topics, presenting a spectrum of algorithms ranging
    from the fundamental to the complex which can add realism to your scenes. In this
    chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎探索旨在为您的场景注入现实感的照明和阴影技术。在图形领域，照明和阴影在增强3D视觉的美感和现实感方面发挥着至关重要的作用。本章深入探讨这些主题，展示了从基础到复杂的各种算法，这些算法可以增加场景的现实感。在本章中，我们将涵盖以下内容：
- en: Implementing G-buffer for deferred rendering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用于延迟渲染的G缓冲区
- en: Implementing screen space reflections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现屏幕空间反射
- en: Implementing shadow maps for real-time shadows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用于实时阴影的阴影贴图
- en: Implementing screen space ambient occlusion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现屏幕空间环境遮挡
- en: Implementing a lighting pass for illuminating the scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现照明通道以照亮场景
- en: By the end of this chapter, you will have a comprehensive understanding of these
    techniques, enabling you to adeptly implement them in your rendering projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对这些技术有全面的了解，这将使您能够熟练地将它们应用于渲染项目中。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Basic familiarity with the C++ programming language and an
    understanding of OpenGL or any other graphics API will be useful. Please revisit
    [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan Core Concepts*, under
    the T*echnical requirements* section for details on setting up and building executables
    for this chapter. We also assume that by now you are familiar with how to use
    the Vulkan API and various concepts that were introduced in previous chapters.
    All recipes for this chapter are encapsulated in a single executable and can be
    launched using `Chapter04_Deferred_Renderer.exe` executable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要确保已安装VS 2022以及Vulkan SDK。对C++编程语言的基本了解以及OpenGL或任何其他图形API的理解将很有用。请查阅“*技术要求*”部分下的[*第1章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan核心概念*，以获取有关设置和构建本章可执行文件的详细信息。我们还假设您现在已经熟悉了如何使用Vulkan
    API以及前几章中介绍的各种概念。本章的所有配方都封装在一个单独的可执行文件中，可以使用`Chapter04_Deferred_Renderer.exe`可执行文件启动。
- en: Implementing G-buffer for deferred rendering
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用于延迟渲染的G缓冲区
- en: '**Deferred rendering** is a technique that adds an additional render pass at
    the beginning of the scene rendering that accumulates various information about
    the scene in screen space, such as position, surface normal, surface color, and
    others. This extra information is stored in a buffer called the **geometry buffer**
    (**G-buffer**), where each one of the values computed during this step is stored
    for each pixel. Once this initial pass has finished, the final scene rendering
    can take place, and the extra information to improve the rendering quality by
    computing things such as reflections, ambient occlusion, atmospheric effects,
    and others can be used. The benefit of using deferred rendering is that it provides
    more efficient handling of complex scenes with many lights, as each light only
    needs to be calculated once per pixel, rather than once per object. We have essentially
    decoupled geometry and shading, which allows for more flexibility in the rendering
    pipeline. The technique also has some disadvantages, such as increased memory
    usage (for the G-buffer itself), and difficulty handling transparency and anti-aliasing.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟渲染**是一种在场景渲染开始时添加一个额外渲染通道的技术，该通道在屏幕空间中累积有关场景的各种信息，例如位置、表面法线、表面颜色等。这些额外信息存储在称为**几何缓冲区**（**G缓冲区**）的缓冲区中，其中每个在此步骤中计算出的值都存储在每个像素中。一旦这个初始通道完成，就可以进行最终的场景渲染，并且可以使用额外的信息（如反射、环境遮挡、大气效果等）来提高渲染质量。使用延迟渲染的好处是它提供了更有效地处理具有许多灯光的复杂场景的方法，因为每个灯光只需对每个像素计算一次，而不是对每个对象计算一次。我们本质上解耦了几何和阴影，这允许在渲染管道中具有更大的灵活性。这项技术也有一些缺点，例如增加了内存使用（对于G缓冲区本身），以及处理透明度和抗锯齿的难度。'
- en: In this tutorial, you will gain an understanding of the implementation of G-buffer
    for deferred rendering, its advantages in managing complex scenes with multiple
    lights, and the challenges it may present, such as increased memory usage.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将了解延迟渲染的G缓冲区实现，了解其在管理具有多个光源的复杂场景中的优势，以及它可能带来的挑战，例如内存使用增加。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating a G-buffer in Vulkan is somewhat straightforward. The bulk of the technique
    relies on creating a framebuffer that contains references to all render targets
    (textures) that will store the scene’s information, such as position, normal,
    and material data. The render pass also needs to dictate how those render targets
    should be loaded and stored at the end of the pass. Finally, in the fragment shader,
    each render target is specified as an output variable and the value of each render
    target is written to the output that refers to the correct texture or storage
    buffer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中创建G缓冲区相对直接。这项技术的主体依赖于创建一个包含所有将存储场景信息（如位置、法线和材质数据）的渲染目标的引用的帧缓冲区。渲染通道还需要规定这些渲染目标在通道结束时应该如何加载和存储。最后，在片段着色器中，每个渲染目标被指定为一个输出变量，每个渲染目标的值被写入到指向正确纹理或存储缓冲区的输出。
- en: '![Figure 4.1 – G-buffer textures](img/B18491_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – G缓冲区纹理](img/B18491_04_01.jpg)'
- en: Figure 4.1 – G-buffer textures
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – G缓冲区纹理
- en: In the repository, the G-buffer generation is encapsulated in the `GBufferPass`
    class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，G缓冲区的生成被封装在`GBufferPass`类中。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To generate a G-buffer and its artifacts, we need to first create a framebuffer
    and a corresponding `RenderPass`. In the following steps, we will show you how
    to create targets for the base color of the material, the normal, and the depth
    components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成G缓冲区和其衍生物，我们首先需要创建一个帧缓冲区和相应的`RenderPass`。在以下步骤中，我们将向您展示如何为材质的基本颜色、法线和深度组件创建目标：
- en: 'Before creating theFrambuffer object, it is necessary to create the textures
    (render targets) that will store the output of the G-buffer pass:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建帧缓冲区对象之前，有必要创建将存储G缓冲区通道输出的纹理（渲染目标）：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Framebuffer` object references the preceding targets. The order is important
    here and should be mirrored in the shader where the outputs are specified:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Framebuffer`对象引用了前面的目标。这里的顺序很重要，并且应该在指定输出的着色器中镜像：'
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `RenderPass` object describes how each render target should be loaded and
    stored. The operations should match the order of the targets used by the framebuffer:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RenderPass`对象描述了每个渲染目标应该如何加载和存储。操作顺序应与帧缓冲区使用的目标顺序相匹配：'
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the fragment shader, besides the input data originating from the previous
    stages in the pipeline, the output data is directed to each one of the targets
    using the layout keyword and the location qualifier. The location index must match
    the render target index on the framebuffer:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，除了来自管道中先前阶段的输入数据外，输出数据通过布局关键字和位置限定符被定向到每个目标。位置索引必须在帧缓冲区上与渲染目标索引匹配：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, the world normal is calculated based on the normal
    and tangent values and stored in the `outgBufferWorldNormal` location, which corresponds
    to the attachment with `index 1` (see code fragment in *step 2*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，基于法线和切线值计算出的世界法线被存储在`outgBufferWorldNormal`位置，这对应于索引为`1`的附件（参见*步骤2*中的代码片段）。
- en: Implementing screen space reflections
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现屏幕空间反射
- en: Physically correct reflections involve tracing the path of light rays as they
    bounce off surfaces. This process accounts for the geometry, material properties,
    and light sources in the scene, as well as the view angle. However, it is a very
    computationally intensive process, often too demanding for real-time rendering,
    especially in complex scenes or on less powerful hardware. To achieve a balance
    between visual quality and performance, an approximation technique known as **screen
    space reflection** (**SSR**) can be used. SSR is a method that approximates reflections
    by reusing data that has already been rendered to the screen. By utilizing a screen-space
    variant, the heavy computational cost associated with physically correct reflections
    can be significantly reduced, making it a viable technique for real-time rendering.
    In this recipe, we will explain how to compute reflections using buffers derived
    from the previous section, such as the normal and depth buffers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 物理正确的反射涉及追踪光线在表面反弹时的路径。这个过程考虑了场景中的几何形状、材料属性、光源以及视角角度。然而，这是一个计算量非常大的过程，通常对实时渲染来说要求过高，尤其是在复杂场景或较弱的硬件上。为了在视觉效果和性能之间取得平衡，可以使用一种称为**屏幕空间反射**（**SSR**）的近似技术。SSR是一种通过重用已经渲染到屏幕上的数据来近似反射的方法。通过利用屏幕空间变体，可以显著减少与物理正确反射相关的沉重计算成本，使其成为实时渲染的可行技术。在本教程中，我们将解释如何使用来自上一节中得到的缓冲区（如法线缓冲区和深度缓冲区）来计算反射。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: SSR uses the depth buffer to find intersections between a reflected ray and
    the geometry’s depth. The reflection ray is computed in world space based on the
    surface normal and the view direction and is marched in small increments until
    it leaves the screen bounds. For every step, the ray’s location is projected onto
    the screen and its coordinates are compared against the depth buffer. If the difference
    between the ray’s location and the depth buffer’s depth is less than a small threshold,
    then the ray has collided with some geometry, and the ray’s originating point
    on the surface is obscured. This reflection vector is then used to look up the
    color of the pixel in the already-rendered image at the reflected position. This
    color is then used as the reflected color, creating the illusion of a reflection.
    SSR can produce visually pleasing reflections that come close to those produced
    by much more computationally expensive physically correct reflection models; however,
    it can only reflect what’s already visible on the screen, and it may produce inaccurate
    results for complex surfaces or at screen edges.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SSR使用深度缓冲区来找到反射光线与几何形状深度的交点。反射光线基于表面法线和视图方向在世界空间中计算，并以小增量前进，直到它离开屏幕边界。对于每一步，将光线的位置投影到屏幕上，并将其坐标与深度缓冲区进行比较。如果光线位置与深度缓冲区深度的差异小于一个小阈值，则光线与某些几何形状发生了碰撞，并且表面上的光线起源点被遮挡。然后使用这个反射向量查找在已渲染图像中反射位置像素的颜色。然后使用这个颜色作为反射颜色，创造出反射的错觉。SSR可以产生视觉上令人愉悦的反射，接近那些由计算成本更高的物理正确反射模型产生的反射；然而，它只能反射屏幕上已经可见的内容，并且对于复杂表面或屏幕边缘可能产生不准确的结果。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the depth and normal buffers have been calculated, the SSR can be easily
    computed in a render or compute pass:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出了深度和法线缓冲区，SSR就可以在渲染或计算通道中轻松计算：
- en: 'The following SSR code is used by a compute pass and specifies the buffers
    used as input, generated by the deferred rendering step, as well as the transformation
    data it needs to perform the intersection in screen space:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下SSR代码由计算通道使用，指定了作为输入使用的缓冲区，这些缓冲区是由延迟渲染步骤生成的，以及它需要执行屏幕空间交点的转换数据：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Two auxiliary functions are defined in the shader. They perform the projection
    from a point in world space to screen space and calculate the projection from
    a screen space along with depth coordinate to world space:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器中定义了两个辅助函数。它们将世界空间中的一个点投影到屏幕空间，并计算从屏幕空间（包括深度坐标）到世界空间的投影：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this step, the data needed for the reflection calculations from the G-buffer
    is fetched. This includes the world normal, specular data, and base color for
    the current pixel. The UV coordinates are calculated, which are used to sample
    the base color from the G-buffer. The roughness, which controls how blurry or
    sharp the reflection is, is also extracted from the specular data. We also check
    the metalness value from the G-buffer specular data. If the material is not metallic
    (`metalness < 0.01`), it assumes it doesn’t reflect and simply writes the base
    color to the result and exits:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，从G缓冲区获取反射计算所需的数据。这包括当前像素的世界法线、镜面数据和基础颜色。计算UV坐标，这些坐标用于从G缓冲区采样基础颜色。粗糙度，它控制反射的模糊或清晰程度，也从中提取镜面数据。我们还从G缓冲区的镜面数据中检查金属度值。如果材料不是金属的（`金属度
    < 0.01`），它假定它不会反射，并将基础颜色简单地写入结果并退出：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following snippet fetches the depth of the current pixel from the depth
    buffer and generates the world position of the pixel using the UV and depth. The
    view direction is calculated from the camera position to the pixel’s world position.
    The reflection direction is then calculated using the view direction and the normal.
    The shader then performs ray marching along the reflection direction in screen
    space. It steps along the reflection ray and at each step, it checks whether the
    ray has intersected with any geometry, based on the depth difference between the
    current position of the ray and the depth at the corresponding screen position:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段从深度缓冲区获取当前像素的深度，并使用UV和深度生成像素的世界位置。从相机位置到像素的世界位置计算视图方向。然后使用视图方向和法线计算反射方向。着色器然后在屏幕空间中沿着反射方向进行光线追踪。它沿着反射光线步进，并在每个步骤中检查光线是否与任何几何体相交，基于光线当前位置的深度与相应屏幕位置的深度之间的差异：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If an intersection is found, the code fetches the color at the intersection
    point and blends it with the base color. The blending is based on the roughness
    value, which represents a characteristic of the surface at the intersection point:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到交点，代码将获取交点的颜色并将其与基础颜色混合。混合基于粗糙度值，它代表交点处的表面特性：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we learned how SSR is computed using the depth and normal
    buffers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们学习了如何使用深度和法线缓冲区计算SSR。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following are some references that go into more detail on how to implement
    SSR; we suggest you go through these references to gain a more thorough understanding:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何实现SSR（屏幕空间反射）的更详细参考；我们建议您阅读这些参考以获得更深入的理解：
- en: '[https://interplayoflight.wordpress.com/2022/09/28/notes-on-screenspace-reflections-with-fidelityfx-sssr/](https://interplayoflight.wordpress.com/2022/09/28/notes-on-screenspace-reflections-with-fidelityfx-sssr/)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://interplayoflight.wordpress.com/2022/09/28/notes-on-screenspace-reflections-with-fidelityfx-sssr/](https://interplayoflight.wordpress.com/2022/09/28/notes-on-screenspace-reflections-with-fidelityfx-sssr/)'
- en: '[http://roar11.com/2015/07/screen-space-glossy-reflections/](http://roar11.com/2015/07/screen-space-glossy-reflections/)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://roar11.com/2015/07/screen-space-glossy-reflections/](http://roar11.com/2015/07/screen-space-glossy-reflections/)'
- en: '[https://interplayoflight.wordpress.com/2019/09/07/hybrid-screen-space-reflections/](https://interplayoflight.wordpress.com/2019/09/07/hybrid-screen-space-reflections/)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://interplayoflight.wordpress.com/2019/09/07/hybrid-screen-space-reflections/](https://interplayoflight.wordpress.com/2019/09/07/hybrid-screen-space-reflections/)'
- en: Implementing shadow maps for real-time shadows
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实时阴影的阴影图实现
- en: As the name implies, **shadow maps** are used to simulate shadows. The goal
    of shadow mapping is to determine which parts of a scene are in shadow and which
    parts are illuminated by a light source by first rendering the scene from the
    light’s perspective, generating a depth map.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**阴影图**用于模拟阴影。阴影映射的目标是通过首先从光源的视角渲染场景，生成深度图，来确定场景中哪些部分处于阴影中，哪些部分被光源照亮。
- en: This depth map (also known as a shadow map) serves as a spatial record, storing
    the shortest distance from the light source to any point in the scene. By encapsulating
    the scene from the vantage point of the light source, the depth map effectively
    captures the areas of the scene that are directly visible to the light source
    and those that are occluded.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此深度图（也称为阴影图）充当空间记录，存储场景中任意点到光源的最短距离。通过从光源的视角封装场景，深度图有效地捕捉了场景中直接可见于光源的区域以及被遮挡的区域。
- en: This depth map is then used during the main render pass to determine if the
    fragment can’t be reached from the light by comparing its depth value with the
    one in the depth map. For each fragment in the scene, we perform a test to evaluate
    whether it lies in shadow. This is achieved by comparing the depth value of the
    fragment from the light source, derived from the main camera’s perspective, with
    the corresponding depth value stored in the depth map.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在主渲染通道中使用这个深度图来确定片段是否无法从光源到达，通过比较其深度值与深度图中的值。对于场景中的每个片段，我们执行一个测试来评估它是否位于阴影中。这是通过比较从光源处得到的片段深度值，该值是从主摄像机的视角推导出来的，与存储在深度图中的相应深度值进行比较来实现的。
- en: If the fragment’s depth value exceeds the value recorded in the depth map, it
    implies that the fragment is occluded by another object in the scene and is, therefore,
    in shadow. Conversely, if the fragment’s depth value is less than or equal to
    the depth map value, it signifies that the fragment is directly visible to the
    light source and is thus illuminated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果片段的深度值超过深度图中记录的值，这意味着片段被场景中的另一个物体遮挡，因此处于阴影中。相反，如果片段的深度值小于或等于深度图值，这表示片段直接可见于光源，因此被照亮。
- en: In this recipe, you will learn how to implement shadow maps to create real-time
    shadows in your 3D scene. This involves understanding the theory of shadow mapping,
    generating a depth map from the light’s perspective, and finally using this depth
    map in the main render pass to accurately determine which fragments of the scene
    are in shadow and which are illuminated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何实现阴影贴图以在3D场景中创建实时阴影。这涉及到理解阴影贴图的理论，从光源的角度生成深度图，并最终在主渲染通道中使用这个深度图来准确确定场景中哪些片段处于阴影中，哪些片段被照亮。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To obtain the shadow map, we first need to render the scene from the light’s
    perspective and retain the depth map. This render pass needs a depth texture that
    will store the depth information and simple vertex and fragment shaders. The main
    render pass, in which the scene is rendered, is where the depth map is used as
    a reference to determine if a pixel is lit or not and needs to refer to the shadow
    map generated in the previous step, along with a special sampler to access the
    depth map in the shader code. It also has code to perform the comparison between
    the fragment and the value stored in the depth map.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取阴影贴图，我们首先需要从光源的角度渲染场景并保留深度图。这个渲染通道需要一个深度纹理来存储深度信息以及简单的顶点和片段着色器。主要的渲染通道，即场景被渲染的地方，使用深度图作为参考来确定像素是否被照亮，并需要参考前一步生成的阴影贴图，以及一个特殊的采样器来在着色器代码中访问深度图。它还包括执行片段与存储在深度图中的值之间比较的代码。
- en: In the repository, a shadow map generation is encapsulated in the `ShadowPass`
    class, and usage of shadow depth texture is encapsulated in the `LightingPass`
    class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，阴影贴图生成被封装在`ShadowPass`类中，阴影深度纹理的使用被封装在`LightingPass`类中。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’ll start with a walk-through of the shadow map pass first:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从阴影贴图通道的概述开始：
- en: 'The shadow map is a regular texture with a format that supports depth values.
    Our depth texture is 4x the resolution of the normal texture and uses the `VK_FORMAT_D24_UNORM_S8_UINT`
    format:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阴影贴图是一种常规纹理，其格式支持深度值。我们的深度纹理是正常纹理分辨率的4倍，并使用`VK_FORMAT_D24_UNORM_S8_UINT`格式：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The render pass needs to clear the depth attachment at the beginning and then
    store it at the end. There are no color attachments in the shadow map render pass
    or in the framebuffer:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染通道需要在开始时清除深度附加，然后在结束时存储它。阴影贴图渲染通道或帧缓冲区中没有颜色附加：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This render pass’s pipeline definition needs to match the size of the viewport
    to the size of the shadow map and use the special vertex and fragment shaders
    for this pass. The fragment and vertex shader are conceptually identical to the
    G-buffer pass but they just need to output the depth buffer instead of multiple
    geometry buffers; it also needs a light view projection matrix instead of the
    camera’s one. As a future optimization, you could use the specialization constant
    with the G-buffer pass instead of using a separate shader:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个渲染通道的管道定义需要匹配视口的大小与阴影贴图的大小，并使用特殊的顶点和片段着色器进行此通道。片段和顶点着色器在概念上与G缓冲区通道相同，但它们只需要输出深度缓冲区而不是多个几何缓冲区；它还需要一个光视图投影矩阵而不是摄像机的矩阵。作为一个未来的优化，你可以使用与G缓冲区通道相同的专用常量而不是使用单独的着色器：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The vertex shader needs the light’s transformation matrix, which is set into
    the `depthTestEnable`, `depthWriteEnable`, and `depthCompareOperation` – will
    govern how we evaluate and store depth information during this process:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器需要光源的变换矩阵，该矩阵设置为`depthTestEnable`、`depthWriteEnable`和`depthCompareOperation`，将决定我们在此过程中如何评估和存储深度信息：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The fragment shader is empty, as it doesn’t need to output any color information:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器为空，因为它不需要输出任何颜色信息：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main render (lighting) pass uses the shadow map calculated before as a reference
    to determine if a fragment is lit or not. There is no special setup for the scene,
    except for the sampler used with the shadow map, which needs to enable a comparison
    function. The vertex and fragment shaders also need some special treatment to
    perform the depth comparison against the shadow map.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要渲染（照明）传递使用之前计算的阴影图作为参考来确定片段是否被照亮。场景没有特殊设置，除了与阴影图一起使用的采样器需要启用比较函数。顶点和片段着色器也需要一些特殊处理以执行与阴影图的深度比较。
- en: 'The sampler used to access the shadow map in the shader needs to enable the
    comparison function. We use the `VK_COMPARE_OP_LESS_OR_EQUAL` function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器中用于访问阴影图的采样器需要启用比较函数。我们使用`VK_COMPARE_OP_LESS_OR_EQUAL`函数：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The fragment shader needs a shadow map as well as a light’s view projection
    matrix. The following code includes the uniform `sampler2Dshadow`, which holds
    the depth map or shadow map. The uniform `Lights` structure contains information
    about the light source, including its position, direction, color, and the view
    projection matrix from the light’s perspective:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器也需要阴影图以及光源的视图投影矩阵。以下代码包括统一的`sampler2Dshadow`，它包含深度图或阴影图。统一的`Lights`结构包含有关光源的信息，包括其位置、方向、颜色以及从光源视角的视图投影矩阵：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We introduce a `computeShadow` auxiliary function that takes as input a position
    in light-projective space. It first converts this position into **normalized device
    coordinates** (**NDCs**), then it looks up the shadow map at the corresponding
    position and returns the shadow intensity at that point:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入一个`computeShadow`辅助函数，它接受光投影空间中的位置作为输入。它首先将此位置转换为**归一化设备坐标**（**NDCs**），然后在该对应位置查找阴影图并返回该点的阴影强度：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we introduce another auxiliary function, the `PCF` function. `16` different
    offsets around the pixel. Then, it would calculate the average of these samples
    to determine the final shadow value for the pixel. This averaging process results
    in pixels on the edge of shadows having intermediate shadow values between fully
    lit and fully shadowed, creating a soft transition that makes the shadow look
    more natural:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们介绍另一个辅助函数，即`PCF`函数。该函数在像素周围有`16`个不同的偏移量。然后，它会计算这些样本的平均值以确定像素的最终阴影值。这个过程导致阴影边缘的像素具有介于完全照亮和完全阴影之间的中间阴影值，从而创建一个柔和的过渡，使阴影看起来更自然：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the main function, we first retrieve the world position and base color of
    the fragment from the G-buffer. If the world position is zero (indicating no meaningful
    information), we simply set the output color to the base color and return early.
    As a next step, the world position is transformed into light-projective space
    using the light’s view projection matrix and passes this position to the `PCF`
    function to compute the visibility factor, which represents how much the fragment
    is in shadow. If the visibility factor is below a threshold (meaning the fragment
    is in deep shadow), it sets the visibility to a fixed value for a minimum amount
    of ambient light. Finally, we multiply the computed `outColor` by the visibility
    factor to create the final color, which will be darker if the fragment is in shadow
    and lighter if it’s lit:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先从G缓冲区检索片段的世界位置和基础颜色。如果世界位置为零（表示没有有意义的信息），我们只需将输出颜色设置为基本颜色并提前返回。作为下一步，使用光源的视图投影矩阵将世界位置转换到光投影空间，并将此位置传递给`PCF`函数以计算可见性因子，该因子表示片段在阴影中的程度。如果可见性因子低于阈值（意味着片段处于深阴影中），则将其设置为固定值以提供最小量的环境光。最后，我们将计算出的`outColor`与可见性因子相乘以创建最终颜色，如果片段在阴影中，颜色会更暗，如果片段被照亮，颜色会更亮：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding section, we illustrated how to implement shadow pass, but there
    are limitations to this technique that will be discussed in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何实现阴影传递，但这项技术的局限性将在下一节中讨论。
- en: There’s more …
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We have demonstrated the use of the basic shadow mapping technique; however,
    this technique has some limitations, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了基本阴影映射技术的使用；然而，这项技术有一些局限性，如下所述：
- en: '**Aliasing and pixelation**: One of the primary issues with simple shadow mapping
    is the problem of **aliasing**, where shadows can appear pixelated or blocky.
    This is because the resolution of the shadow map directly affects the shadow’s
    quality. If the shadow map’s resolution is too low, the resulting shadows will
    be pixelated. While increasing the shadow map’s resolution can mitigate this,
    it comes at the cost of increasing memory usage and computational load.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**走样和像素化**：简单阴影映射的主要问题之一是走样问题，阴影可能看起来是像素化的或块状的。这是因为阴影图的分辨率直接影响阴影的质量。如果阴影图的分辨率太低，生成的阴影将会是像素化的。虽然提高阴影图的分辨率可以减轻这个问题，但这会以增加内存使用和计算负载为代价。'
- en: '**Hard shadow edges**: Basic shadow mapping produces shadows with hard edges
    since it uses a binary lit or unlit test for shadow determination. Shadows often
    have soft edges due to light scattering (penumbra).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬阴影边缘**：基本阴影映射由于使用二进制光照或非光照测试来确定阴影而产生具有硬边缘的阴影。由于光散射（半影），阴影通常具有柔和的边缘。'
- en: '**Shadow acne or self-shadowing artifacts**: This problem arises when a surface
    incorrectly shadows itself due to precision errors in the depth test. Techniques
    such as biasing are used to handle this issue but choosing the right bias can
    be challenging.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影 acne 或自阴影伪影**：当表面由于深度测试中的精度错误而错误地自阴影时，会出现这个问题。使用如偏置等技术来处理这个问题，但选择正确的偏置可能具有挑战性。'
- en: 'Some of these challenges can be overcome with more advanced techniques such
    as the following:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些挑战可以通过以下更高级的技术来克服：
- en: '**Cascade shadow maps**: This technique addresses the issue of resolution by
    dividing the camera’s view frustum into multiple **cascades** or sections, each
    with its own shadow map. This allows for higher-resolution shadow maps to be used
    close to the camera, where detail is more important, and lower-resolution shadow
    maps to be used farther away.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级联阴影图**：这项技术通过将摄像机的视锥体分成多个**级联**或部分，每个部分都有自己的阴影图来解决分辨率问题。这允许在相机附近使用更高分辨率的阴影图，因为那里的细节更重要，而在较远的地方使用较低分辨率的阴影图。'
- en: '**Moment shadow maps**: This technique uses statistical moments to store more
    information about the depth distribution within a pixel, which can handle transparency
    and provide anti-aliased, soft shadows. Moment shadow maps require more memory
    and computation than basic shadow maps but can provide higher-quality shadows.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬间阴影图**：这项技术使用统计矩来存储关于像素内深度分布的更多信息，可以处理透明度并提供抗锯齿的柔和阴影。瞬间阴影图比基本阴影图需要更多的内存和计算，但可以提供更高质量的阴影。'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'The following are references that discuss and provide implementation details
    about advanced techniques such as cascade shadow maps and moment shadows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些讨论和提供高级技术（如级联阴影图和瞬间阴影）实现细节的参考：
- en: '[https://learn.microsoft.com/en-us/windows/win32/dxtecharts/cascaded-shadow-maps](https://learn.microsoft.com/en-us/windows/win32/dxtecharts/cascaded-shadow-maps)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/windows/win32/dxtecharts/cascaded-shadow-maps](https://learn.microsoft.com/en-us/windows/win32/dxtecharts/cascaded-shadow-maps)'
- en: '[https://momentsingraphics.de/I3D2015.html](https://momentsingraphics.de/I3D2015.html)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://momentsingraphics.de/I3D2015.html](https://momentsingraphics.de/I3D2015.html)'
- en: Implementing screen space ambient occlusion
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现屏幕空间环境遮挡
- en: '**Screen space ambient occlusion** (**SSAO**) can be used to approximate the
    effect of ambient occlusion in real time. Ambient occlusion is a shading and rendering
    method used to calculate how exposed each point in a scene is to ambient lighting.
    This technique adds more realistic shadows where two surfaces or objects meet,
    or where an object blocks light from reaching another object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**屏幕空间环境遮挡**（**SSAO**）可以用来实时近似环境遮挡的效果。环境遮挡是一种着色和渲染方法，用于计算场景中每个点对环境光照的暴露程度。这项技术会在两个表面或物体相遇的地方，或者物体阻挡光线到达另一个物体时，添加更真实的阴影。'
- en: In this recipe, you will learn how to implement SSAO to realistically estimate
    ambient occlusion in real time. You will grasp how to use this shading and rendering
    technique to calculate the exposure of each point in a scene to ambient lighting.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何实现 SSAO 以实时地真实地估计环境遮挡。你将掌握如何使用这种着色和渲染技术来计算场景中每个点的环境光照曝光度。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The algorithm described in this recipe calculates the difference between the
    depth of a pixel and its neighbors (samples) in a circular fashion. If a sample
    is closer to the camera than the central pixel, it contributes to the occlusion
    factor, making the pixel darker.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中描述的算法以环形方式计算像素深度与其邻居（样本）之间的差异。如果一个样本比中心像素更靠近相机，它将贡献到遮挡因子，使像素变暗。
- en: A depiction of the algorithm is shown in *Figure 4**.2*. The code loops over
    several *rings* around a central point, the pixel being processed. Within each
    ring, it takes several samples, as seen in item (a).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的描述如图 *图 4**.2* 所示。代码在以像素为中心的几个 *环* 上循环，在每个环内，它进行几个样本的采样，如项目 (a) 所示。
- en: '![Figure 4.2 – SSAO sampling pattern](img/B18491_04_02.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – SSAO 采样模式](img/B18491_04_02.jpg)'
- en: Figure 4.2 – SSAO sampling pattern
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – SSAO 采样模式
- en: A small amount of noise is applied to each sample’s location to avoid banding
    effects, as shown in item (b). Additionally, a weight is applied to samples on
    the same ring, with rings farther from the center with the smallest weights, as
    depicted in item (c).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如项目 (b) 所示，对每个样本的位置应用少量噪声以避免带状效应。此外，对同一环上的样本应用权重，距离中心越远的环权重越小，如项目 (c) 所示。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The entire SSAO algorithm is implemented as a compute shader that writes its
    output to an image:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 SSAO 算法被实现为一个计算着色器，它将输出写入图像：
- en: 'We start by declaring the inputs and outputs. The input is the depth buffer.
    The output is an image in which we’ll store the result of the algorithm. We also
    need a function to generate noise in 2D. A small amount of noise is applied to
    each sample’s location to avoid banding effects:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明输入和输出。输入是深度缓冲区。输出是一个图像，我们将在这里存储算法的结果。我们还需要一个在二维中生成噪声的函数。对每个样本的位置应用少量噪声以避免带状效应：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also need a function to convert the depth value from the depth buffer to
    a linear scale, as the values are not stored in a linear fashion:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个函数将深度缓冲区中的深度值转换为线性尺度，因为这些值不是以线性方式存储的：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The comparison between the depth value of the pixel being processed and the
    surrounding samples is done by the `compareDepths` function, which returns the
    difference between the samples:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `compareDepths` 函数比较正在处理的像素深度值和周围样本的深度值，该函数返回样本之间的差异：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The main part of the algorithm starts by collecting the pixel’s position and
    its depth value, which is converted to a linear scale. It also calculates the
    size of the buffers and calculates the noise:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法的主要部分首先收集像素的位置及其深度值，该深度值被转换为线性尺度。它还计算缓冲区的大小并计算噪声：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The size of the area inspected for samples is proportional to the depth value
    of the pixel: the farther away the pixel is from the camera, the smaller the area
    is:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查样本区域的大小与像素的深度值成正比：像素离相机越远，区域越小：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The bulk of the algorithm is where the ring radiuses and the number of samples
    are calculated. The number of samples is proportional to the ring’s diameter.
    For each sample, we compare their depths, apply the ring weight, and accumulate
    the output, which is averaged out at the end of the function:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法的大部分工作在于计算环的半径和样本的数量。样本的数量与环的直径成正比。对于每个样本，我们比较它们的深度，应用环权重，并累积输出，最后在函数结束时平均：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This concludes our recipe for SSAO. For a deeper understanding and further exploration,
    we highly recommend visiting the various resources provided in the following section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的 SSAO 配方。为了更深入的理解和进一步探索，我们强烈建议访问以下章节中提供的各种资源。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献还有
- en: 'For further understanding and an exploration of the topic of SSAO, you may
    find the following resources helpful:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解和探索 SSAO 主题，以下资源可能会有所帮助：
- en: '[https://github.com/NVIDIAGameWorks/HBAOPlus](https://github.com/NVIDIAGameWorks/HBAOPlus)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NVIDIAGameWorks/HBAOPlus](https://github.com/NVIDIAGameWorks/HBAOPlus)'
- en: '[https://www.gamedevs.org/uploads/comparative-study-of-ssao-methods.pdf](https://www.gamedevs.org/uploads/comparative-study-of-ssao-methods.pdf)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.gamedevs.org/uploads/comparative-study-of-ssao-methods.pdf](https://www.gamedevs.org/uploads/comparative-study-of-ssao-methods.pdf)'
- en: '[https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf](https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf](https://research.nvidia.com/sites/default/files/pubs/2012-06_Scalable-Ambient-Obscurance/McGuire12SAO.pdf)'
- en: '[https://www.ppsloan.org/publications/vo.pdf](https://www.ppsloan.org/publications/vo.pdf)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ppsloan.org/publications/vo.pdf](https://www.ppsloan.org/publications/vo.pdf)'
- en: '[https://github.com/GameTechDev/XeGTAO](https://github.com/GameTechDev/XeGTAO)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/GameTechDev/XeGTAO](https://github.com/GameTechDev/XeGTAO)'
- en: Implementing a lighting pass for illuminating the scene
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用于照亮场景的光照通道
- en: The last recipe in the book you how to implement a lighting pass; this is where
    we calculate the lighting for the scene. For each light in the scene, we draw
    a volume (for point lights, this would be a sphere; for directional lights, a
    full-screen quad; for spotlights, we would draw a cone) and for each pixel in
    that volume, we fetch the data from the G-buffer and calculate the lighting contribution
    of that light to the pixel. The results are then usually added together (blended)
    to a final render target to get the final image. In the demo, we only have one
    spotlight that is used as a demonstration, but we can easily add multiple lights.
    For each light in the scene, we will need to consider the area affected by the
    light (i.e., we use a shader that fetches the relevant data for each pixel from
    the G-buffer, which then uses this data to calculate how much this light source
    contributes to the final color of each pixel). For example, if we’re dealing with
    a spotlight, this volume is a cone centered at the light’s position, oriented
    in the light’s direction, and with an angle that matches the spread of the spotlight.
    The length or height of the cone should be equal to the range of the spotlight.
    Lastly, we use a physically based lighting model (the **Cook-Torrance lighting
    model**), which is applied in the fragment shader. The inputs to the lighting
    model include the light’s properties (color, intensity, position, etc.) and the
    surface properties (material color, shininess, normal, etc.), which are fetched
    from the G-buffer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的最后一个食谱介绍了如何实现光照通道；这就是我们计算场景光照的地方。对于场景中的每个光源，我们绘制一个体积（对于点光源，这将是一个球体；对于方向光源，是一个全屏四边形；对于聚光灯，我们将绘制一个圆锥体），并且对于该体积中的每个像素，我们从G缓冲区获取数据并计算该光源对该像素的光照贡献。然后将结果通常相加（混合）到最终的渲染目标中，以获得最终图像。在演示中，我们只有一个用作演示的聚光灯，但我们可以轻松地添加多个光源。对于场景中的每个光源，我们需要考虑光源影响的区域（即，我们使用一个着色器，它从G缓冲区为每个像素获取相关数据，然后使用这些数据来计算这个光源对每个像素最终颜色的贡献）。例如，如果我们处理的是聚光灯，这个体积是以光源位置为中心的圆锥体，方向与光源方向一致，角度与聚光灯的扩散相匹配。圆锥体的长度或高度应等于聚光灯的范围。最后，我们使用一个基于物理的光照模型（**Cook-Torrance光照模型**），它在片段着色器中应用。光照模型的输入包括光源属性（颜色、强度、位置等）和表面属性（材料颜色、光泽度、法线等），这些数据是从G缓冲区获取的。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The recipe is implemented in the `LightingPass` class and the `Lighting.frag`
    shader. It simply uses a full-screen vertex shader to draw a full-screen quad.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱在`LightingPass`类和`Lighting.frag`着色器中实现。它简单地使用一个全屏顶点着色器来绘制一个全屏四边形。
- en: As mentioned in the introduction of this recipe, we use the Cook-Torrance lighting
    model, which is a physically based rendering model that simulates how light interacts
    with a surface. It considers various factors such as the angle of incidence, surface
    roughness, and microfacet distribution to render realistic lighting effects. The
    algorithm uses the `Fresnel-Schlick` function, which is used to determine the
    proportion of light reflected versus refracted depending on the view angle. The
    GGX distribution function calculates the distribution of microfacets on the surface,
    which influences how rough or smooth a surface appears.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如本食谱介绍中所述，我们使用Cook-Torrance光照模型，这是一个基于物理的渲染模型，它模拟了光线与表面交互的方式。它考虑了入射角、表面粗糙度和微面分布等各个因素，以渲染逼真的光照效果。该算法使用`Fresnel-Schlick`函数，该函数用于根据视角确定反射与折射的光的比例。GGX分布函数计算表面微面的分布，这影响了表面看起来是粗糙还是光滑。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'The entire algorithm is implemented as a full-screen space quad shader that
    writes its output to a final color texture:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 整个算法实现为一个全屏空间四边形着色器，将其输出写入最终的颜色纹理：
- en: 'We start by declaring the inputs and outputs. The inputs include the G-buffer
    data (normal, specular, base color, depth, and position), ambient occlusion map,
    shadow map, camera, and light data. The output is simply `fragColor`, which is
    written to the color attachment as specified by the render pass:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明输入和输出。输入包括 G-缓冲区数据（法线、镜面、基础颜色、深度和位置）、环境遮挡图、阴影贴图、相机和灯光数据。输出是简单的 `fragColor`，它被写入由渲染通道指定的颜色附件：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Afterward, we define a few auxiliary functions; these will be used in the main
    function. These are defined in the `brdf.glsl` file.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义了一些辅助函数；这些将在主函数中使用。这些函数定义在 `brdf.glsl` 文件中。
- en: The `fresnelSchlick` function calculates the `Fresnel-Schlick` approximation,
    which models the amount of reflection and refraction based on the angle at which
    light hits the surface. The result is used to determine the specular color.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fresnelSchlick` 函数计算 `Fresnel-Schlick` 近似，它根据光线击中表面的角度来模拟反射和折射的量。结果用于确定镜面颜色。'
- en: The `distributionGGX` function calculates the distribution of microfacets on
    a surface. The result models how rough or smooth a surface appears, influencing
    the spread of the specular highlight.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`distributionGGX` 函数计算表面上的微面分布。结果模拟了表面看起来是粗糙还是光滑，影响镜面高光的扩散。'
- en: 'The `geometrySchlickGGX` function calculates the geometric attenuation term
    using `geometrySmith` function calculates the total geometric attenuation considering
    both the view direction and the light direction. It calculates geometric attenuation
    for both view and light direction and multiplies both to get the final geometric
    attenuation, this function assumes that microfacet distribution is the same in
    all directions. These functions are combined in the `Cook-Torrance BRDF` model
    to account for microfacet occlusion and shadowing effects:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`geometrySchlickGGX` 函数使用 `geometrySmith` 函数计算几何衰减项，考虑了视图方向和光方向的总几何衰减。它计算视图和光方向的几何衰减，并将两者相乘以获得最终的几何衰减，此函数假设微面分布在任何方向上都是相同的。这些函数在
    `Cook-Torrance BRDF` 模型中组合，以考虑微面遮挡和阴影效果：'
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The shader first retrieves the base color, world position, camera position,
    specular data, and normal data from the G-buffer:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器首先从 G-缓冲区检索基础颜色、世界位置、相机位置、镜面数据和法线数据：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the next steps, it calculates the view vector (`V`), light vector (`L`),
    and half vector (`H`). These vectors are used in lighting calculations:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，它计算视图向量（`V`）、光向量（`L`）和半向量（`H`）。这些向量用于光照计算：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'During this part, the `Fresnel-Schlick`, `distributionGGX`, and `geometrySmith`
    functions are called to calculate the specular reflection:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个部分，调用了 `Fresnel-Schlick`、`distributionGGX` 和 `geometrySmith` 函数来计算镜面反射：
- en: '[PRE29]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this step, the shader calculates the diffuse reflection. It’s a simple model
    based on Lambert’s cosine law, but it’s modified by applying an energy conservation
    principle:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，着色器计算漫反射。它是一个基于朗伯余弦定律的简单模型，但通过应用能量守恒原理进行了修改：
- en: '[PRE30]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In these last few steps, ambient light is calculated by simply multiplying
    the ambient light color by the base color. Here, we also calculate the attenuation
    based on the distance to the light, and the spot attenuation based on the angle
    between the light direction and the direction to the fragment. These are used
    to calculate the light intensity. The shader calculates the final color by adding
    the ambient, diffuse, and specular components together:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些最后几个步骤中，环境光通过简单地乘以环境光颜色和基础颜色来计算。在这里，我们还根据到光源的距离计算衰减，并根据光方向和片段方向之间的角度计算点衰减。这些用于计算光强度。着色器通过将环境、漫反射和镜面分量相加来计算最终颜色：
- en: '[PRE31]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the last step, the final color is then multiplied by the ambient occlusion
    factor (sampled from ambient occlusion texture calculated in the *Implementing
    screen space ambient occlusion* recipe) and the shadow visibility factor to account
    for shadows and ambient occlusion:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，最终颜色乘以环境遮挡因子（从 *实现屏幕空间环境遮挡* 菜单中采样的环境遮挡纹理）和阴影可见性因子，以考虑阴影和环境遮挡：
- en: '[PRE32]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following screenshot, we present an image that shows a shadow created
    using the shadow map technique:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们展示了一张使用阴影贴图技术创建的阴影图像：
- en: '![Figure 4.3 – A shadow using a shadow map](img/B18491_04_03.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 使用阴影贴图创建的阴影](img/B18491_04_03.jpg)'
- en: Figure 4.3 – A shadow using a shadow map
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 使用阴影贴图创建的阴影
- en: 'The following screenshot demonstrates the result of the SSR technique:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 SSR 技术的结果：
- en: '![Figure 4.4 – SSR](img/B18491_04_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – SSR](img/B18491_04_04.jpg)'
- en: Figure 4.4 – SSR
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – SSR
- en: In this chapter, we embarked on a journey to comprehend and implement some of
    the most influential techniques in 3D graphics for achieving real-time physically
    based effects using the Vulkan API. We began our exploration with the principles
    of G-buffer generation, a foundational concept of deferred rendering. This technique
    allows us to manage the complexity of modern lighting and shading, paving the
    way for the implementation of more advanced rendering effects. We then described
    techniques such as SSR and shadows, which are needed for simulating realism in
    rendered scenes. We also explored the complexities of lighting and shading with
    a deep dive into SSAO. This technique provided us with the tools to simulate the
    intricate ways light radiates in real life, adding depth and detail to corners
    in our 3D world. Finally, our exploration ended with the implementation of a lighting
    pass. By calculating the contributions of various light sources on each object
    in our scene, we successfully illuminated our 3D environment. We hope that you
    have gained a comprehensive understanding of several core techniques in modern
    lighting, shading, and shadows, which will empower you to create stunning and
    realistic 3D graphics with Vulkan.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了理解并实现使用 Vulkan API 实现实时基于物理效果的一些最具影响力的 3D 图形技术的旅程。我们的探索从 G 缓冲区生成的原理开始，这是延迟渲染的基础概念。这项技术使我们能够管理现代光照和着色的复杂性，为更高级渲染效果的实施铺平了道路。然后我们描述了如
    SSR 和阴影等技术，这些技术对于模拟渲染场景中的真实感是必需的。我们还深入探讨了光照和着色的复杂性，通过深入研究 SSAO。这项技术为我们提供了模拟现实生活中光辐射复杂方式的方法，为我们的
    3D 世界中的角落增添了深度和细节。最后，我们的探索以实现光照通道结束。通过计算场景中每个对象上各种光源的贡献，我们成功地照亮了我们的 3D 环境。我们希望您已经对现代光照、着色和阴影的几个核心技术有了全面的理解，这将使您能够使用
    Vulkan 创建令人惊叹且逼真的 3D 图形。
