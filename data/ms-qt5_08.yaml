- en: Chapter 8.  Animations - Its Alive, Alive!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 动画 - 活起来，活起来！
- en: In the previous chapter, you learned how to create a custom Qt Designer plugin.
    This chapter will push things further and teach you how to create a distributable
    Software Development Kit (SDK) to third-party developers, how the plugin system
    works with Qt, and how to make your application more attractive using fancy animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何创建自定义Qt Designer插件。本章将进一步深入，教你如何创建可分发的软件开发工具包（SDK）供第三方开发者使用，Qt插件系统的工作原理，以及如何使用华丽的动画使你的应用程序更具吸引力。
- en: The example project will be a reimplementation of the project from [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*. You will build the same image processing application,
    but with the ability to import the filters from plugins.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目将是[第7章](part0071.xhtml#aid-23MNU1 "第7章. 无痛第三方库")中的项目重新实现，*无痛第三方库*。你将构建相同的图像处理应用程序，但具有从插件导入滤镜的能力。
- en: 'This chapter will teach you how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何完成以下任务：
- en: Create an SDK using the Qt Plugin system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt插件系统创建SDK
- en: Implement custom plugins using the SDK
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SDK实现自定义插件
- en: Factorize build tasks using `.pri`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.pri` 文件分解构建任务
- en: Dynamically load plugins in your final application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最终应用程序中动态加载插件
- en: Understand the Qt Animation framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qt动画框架
- en: Use simple, sequential, and parallel animations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单、顺序和并行动画
- en: Apply custom effects using `QPropertyAnimation` and `QGraphics` effects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QPropertyAnimation`和`QGraphics`效果应用自定义效果
- en: Preparing an SDK
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备SDK
- en: 'Before diving into the code, we have to take a moment to reflect on how we
    are going to structure it. This chapter has two goals:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们必须花点时间来反思我们将如何构建它。本章有两个目标：
- en: Cover the Qt Plugin system in more depth
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨Qt插件系统
- en: Study and integrate the Qt Animation Framework
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究和集成Qt动画框架
- en: The first part of the chapter will focus on the plugin system. What we aim to
    do is provide a way to build plugins that can be integrated in our application
    to third-party developers. These plugins should be dynamically loaded. The application
    will be a direct offspring of the example project from [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*. The features will be exactly the same, except it will be
    using this new plugin system and will have fancy animations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分将专注于插件系统。我们的目标是提供一个方法来构建可以集成到我们的应用程序中的插件，供第三方开发者使用。这些插件应该是动态加载的。应用程序将是[第7章](part0071.xhtml#aid-23MNU1
    "第7章. 无痛第三方库")中的示例项目的直接后代，*无痛第三方库*。功能将完全相同，但将使用这个新的插件系统，并将具有华丽的动画。
- en: 'The structure of the project will be as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的结构将如下所示：
- en: '![Preparing an SDK](img/image00416.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![准备SDK](img/image00416.jpeg)'
- en: 'The parent project is `ch08-image-animation`, which is composed of the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 父级项目是 `ch08-image-animation`，它由以下内容组成：
- en: '`filter-plugin-original`: A library project, which is the implementation of
    the original filter'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter-plugin-original`：一个库项目，是原始滤镜的实现'
- en: '`filter-plugin-grayscale`: A library project, which is the implementation of
    the grayscale filter'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter-plugin-grayscale`：一个库项目，是灰度滤镜的实现'
- en: '`filter-plugin-blur`: A library project, which is the implementation of the
    blur filter'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter-plugin-blur`：一个库项目，是模糊滤镜的实现'
- en: '`image-animation`: A Qt Widgets application, which will load the plugins needed
    to display them and make it possible to apply each one to a loaded picture'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image-animation`：一个Qt Widgets应用程序，它将加载显示所需的插件，并使每个插件应用于加载的图片成为可能'
- en: We will develop each one of these plugins, but keep in mind that they might
    have been created by a third-party developer. To achieve this openness, an SDK
    will be available for each plugin. This SDK relies on the Qt Plugin system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发这些插件中的每一个，但请记住，它们可能是由第三方开发者创建的。为了实现这种开放性，每个插件都将提供SDK。这个SDK依赖于Qt插件系统。
- en: It is crucial to think about what should be handled by the plugin. Our application
    is an image processing piece of software. We chose to limit the responsibility
    of the plugin to the picture processing part, but this is definitely a design
    choice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到插件应该处理什么内容至关重要。我们的应用程序是一个图像处理软件。我们选择将插件的责任限制在图片处理部分，但这绝对是一个设计选择。
- en: Another approach could have been to let the plugin developer provide its own
    UI to configure the plugin (for example, to vary the intensity of the blur). In
    this chapter, we have kept it simple by focusing only on the plugin development
    itself. It is really up to you and how you want to design your application. By
    opening up the range of what the plugin can do, you also increase the burden for
    the plugin developer. There is always a trade-off; giving more choice tends to
    increase the complexity. It is a well-known fact that we developers are a bunch
    of lazy people. At least, we want to be lazy while the computer is working for
    us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是让插件开发者提供自己的 UI 来配置插件（例如，调整模糊的强度）。在本章中，我们通过仅关注插件开发本身来保持简单。这完全取决于你以及你想要如何设计你的应用程序。通过扩大插件可以执行的范围，你也增加了插件开发者的负担。总是存在权衡；提供更多选择往往会增加复杂性。众所周知，我们开发者是一群懒惰的人。至少，我们希望在计算机为我们工作时能够偷懒。
- en: 'We will start by building the SDK that will be deployed in each plugin. Execute
    the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建将在每个插件中部署的 SDK。执行以下步骤：
- en: Create a **Subdirs project** named `ch08-image-animation` (do not add a sub-project
    at the end of the wizard).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ch08-image-animation` 的 **Subdirs 项目**（在向导的末尾不要添加子项目）。
- en: In your filesystem explorer, open the `ch08-image-animation` directory and create
    an `sdk` directory.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件系统资源管理器中，打开 `ch08-image-animation` 目录并创建一个 `sdk` 目录。
- en: Inside `sdk`, create an empty `Filter.h` file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sdk` 内部创建一个空的 `Filter.h` 文件。
- en: 'Our SDK will consist of a single file, `Filter.h`, the interface (or header)
    that should be implemented with each plugin. Each plugin is responsible for returning
    the modified picture according to its desired features. Because this SDK is not
    linked to any particular project, we will simply display it in Qt Creator under
    the special folder **Other files**. To do so, update `ch08-image-animation.pro`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SDK 将由一个文件组成，`Filter.h`，这是每个插件应该实现的接口（或头文件）。每个插件负责根据其所需功能返回修改后的图片。因为此 SDK
    没有链接到任何特定项目，我们将在 Qt Creator 中的特殊文件夹 **Other files** 下显示它。为此，更新 `ch08-image-animation.pro`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After `ch08-image-animation.pro` has been parsed by Qt Creator, you should
    see the following in the **Projects** tab:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 解析 `ch08-image-animation.pro` 之后，你应该在 **Projects** 选项卡中看到以下内容：
- en: '![Preparing an SDK](img/image00417.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![准备 SDK](img/image00417.jpeg)'
- en: 'The `Filter.h` file is available at the parent project level. As a result,
    it will be easier to factorize the SDK plumbing code between our various plugins.
    Let''s implement `Filter.h`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter.h` 文件位于父项目级别。因此，它将更容易在我们的各种插件之间分解 SDK 的管道代码。让我们实现 `Filter.h`：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down this interface: a `Filter` subclass must provide a name by
    implementing `name()` and returning a processed image when implementing `process()`.
    As you can see, `Filter.h` is indeed very close to the version seen in [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个接口：`Filter` 子类必须通过实现 `name()` 方法提供名称，并在实现 `process()` 方法时返回处理后的图像。正如你所见，`Filter.h`
    确实非常接近在 [第 7 章](part0071.xhtml#aid-23MNU1 "第 7 章。无需烦恼的第三方库") 中看到的版本，*无需烦恼的第三方库*。
- en: 'However, the really new stuff comes right after the class definition:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正的新内容出现在类定义之后：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Filter_iid` is a unique identifier to let Qt know the interface name. This
    will be enforced on the implementer side, which will also have to state this identifier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter_iid` 是一个唯一标识符，让 Qt 知道接口名称。这将强制实施在实现者一方，该方还必须声明此标识符。'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a real-world use case, you should add a version number to this unique identifier.
    This will let you properly handle the versioning of your SDK and the attached
    plugins.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际应用场景，你应该给这个唯一标识符添加一个版本号。这将让你能够正确处理 SDK 和附加插件的版本。
- en: The `Q_DECLARE_INTERFACE` macro associates the class to the given identifier.
    It will give Qt the ability to check that the loaded plugin can be safely casted
    to the `Filter` type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_DECLARE_INTERFACE` 宏将类与给定的标识符关联起来。这将使 Qt 能够检查加载的插件是否可以安全地转换为 `Filter` 类型。'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In production code, it is safer to declare your interfaces inside a namespace.
    You never know the code environment in which your SDK will be deployed. This,
    way, you avoid potential name collision. If you do declare in a namespace, make
    sure that the `Q_DECLARE_INTERFACE` macro is outside the namespace scope.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，在命名空间内声明您的接口更安全。您永远不知道您的 SDK 将部署在哪种代码环境中。这样，您可以避免潜在的名称冲突。如果您在命名空间中声明，请确保
    `Q_DECLARE_INTERFACE` 宏在命名空间作用域之外。
- en: Creating your plugins
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的插件
- en: The SDK was painless to create. We can now proceed to create our first plugin.
    We already know that all our plugins will include the SDK we just completed. Fortunately,
    this can be easily factorized in a `.pri` file (PRoject Include). A `.pri` file
    behaves exactly like a `.pro` file; the only difference is that it is intended
    to be included inside `.pro` files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 的创建过程非常顺利。我们现在可以继续创建我们的第一个插件。我们已经知道所有我们的插件都将包含我们刚刚完成的 SDK。幸运的是，这可以通过一个 `.pri`
    文件（PRoject Include）轻松实现。`.pri` 文件的行为与 `.pro` 文件完全一样；唯一的区别是它旨在包含在 `.pro` 文件中。
- en: 'In the `ch08-image-animation` directory, create a file named `plugins-common.pri`
    that contains the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch08-image-animation` 目录中创建一个名为 `plugins-common.pri` 的文件，其中包含以下代码：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file will be included in each `.pro` plugin. It aims to tell the compiler
    where it can find the headers of the SDK and where to look to resolve dependencies
    between headers and sources. This will enhance the modification detection and
    properly compile the sources when needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将包含在每个 `.pro` 插件中。它的目的是告诉编译器在哪里可以找到 SDK 的头文件，以及在哪里查找头文件和源文件之间的依赖关系。这将增强修改检测，并在需要时正确编译源文件。
- en: 'To see this file in the project, we have to add it to the `OTHER_FILES` macro
    in `ch08-image-animation.pro`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中看到此文件，我们必须将其添加到 `ch08-image-animation.pro` 中的 `OTHER_FILES` 宏：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The most straightforward plugin to build is `filter-plugin-original` as it
    does not perform any specific processing on the image. Let''s create this plugin
    with the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建最直接的插件是 `filter-plugin-original`，因为它不对图像执行任何特定的处理。让我们按照以下步骤创建此插件：
- en: Create a new **Subproject** in `ch08-image-animation`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ch08-image-animation` 中创建一个新的 **子项目**。
- en: Select **Library** | **C++ Library** | **Choose...**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **库** | **C++ 库** | **选择...**。
- en: Choose a **Shared Library**, name it `filter-plugin-original`, and then click
    on **Next**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **共享库**，将其命名为 `filter-plugin-original`，然后点击 **下一步**。
- en: Select **QtCore** and go to **QtWidgets** | **Next**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **QtCore**，然后转到 **QtWidgets** | **下一步**。
- en: Name the created class `FilterOriginal` and click on **Next**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的类命名为 `FilterOriginal`，然后点击 **下一步**。
- en: Add it as a **subproject** to `ch08-image-animation` then click on **Finish**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为 **子项目** 添加到 `ch08-image-animation`，然后点击 **完成**。
- en: 'Qt Creator creates a lot of boilerplate code for us, but in this case, we do
    not need it. Update `filter-plugin-original.pro` like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 为我们创建了很多样板代码，但在这个案例中，我们不需要它。按照以下方式更新 `filter-plugin-original.pro`：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We start by specifying that the `TARGET` should be properly named according
    to the OS convention with `$$qtLibraryTarget()`. The `CONFIG` property adds the `plugin`
    directive, which tells the generated `Makefile` to include the necessary instructions
    to compile a dll/so/dylib (pick your OS).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定 `TARGET` 应根据操作系统约定正确命名，使用 `$$qtLibraryTarget()`。`CONFIG` 属性添加了 `plugin`
    指令，这告诉生成的 `Makefile` 包含编译 dll/so/dylib（根据您的操作系统选择）所需的必要指令。
- en: We removed the unnecessary `DEFINES` and `FilterOriginal_global.h`. Nothing
    specific to the plugin should be exposed to the caller, and therefore, there is
    no need to handle the symbol export.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了不必要的 `DEFINES` 和 `FilterOriginal_global.h`。插件不应该暴露给调用者任何特定内容，因此不需要处理符号导出。
- en: 'We can now proceed to `FilterOriginal.h`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到 `FilterOriginal.h`：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `FilterOriginal` class must first inherit `QObject`; when the plugin will
    be loaded, it will first be a `QObject` class before being casted to the real
    type, `Filter`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterOriginal` 类必须首先继承 `QObject`；当插件将被加载时，它将首先是一个 `QObject` 类，然后再被转换为实际类型，`Filter`。'
- en: The `Q_PLUGIN_METADATA` macro is stated to export the proper implemented interface
    identifier to Qt. It annotates the class to let the Qt metasystem know about it.
    We meet the unique identifier we defined in `Filter.h` again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_PLUGIN_METADATA` 宏声明导出适当的实现接口标识符到 Qt。它注释了类，让 Qt 元系统了解它。我们在 `Filter.h` 中再次遇到了我们定义的唯一标识符。'
- en: The `Q_INTERFACES` macro tells the Qt metaobject system which interface the
    class implements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_INTERFACES` 宏告诉 Qt 元对象系统该类实现了哪个接口。'
- en: 'Finally, the `FilterOriginal.cpp` barely deserves to be printed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`FilterOriginal.cpp` 几乎不值得打印：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, its implementation is a no-op. The only thing we added to the
    version from [Chapter 7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries
    Without a Headache"), *Third-Party Libraries Without a Headache*, is the `name()`
    function, which returns `Original`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，其实现是一个空操作。我们从[第7章](part0071.xhtml#aid-23MNU1 "第7章。无烦恼的第三方库")，*无烦恼的第三方库*版本中添加的唯一内容是`name()`函数，它返回`Original`。
- en: We will now implement the grayscale filter. As we did in [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*, we will rely on the OpenCV library to process the picture.
    The same can be said for the following plugin, the blur.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现灰度滤镜。正如我们在[第7章](part0071.xhtml#aid-23MNU1 "第7章。无烦恼的第三方库")，*无烦恼的第三方库*中所做的那样，我们将依赖OpenCV库来处理图片。同样适用于以下插件，模糊。
- en: Since these two projects have their own `.pro` file, you can already foresee
    that the OpenCV linking will be the same. This is a perfect use-case for a `.pri`
    file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个项目都有自己的`.pro`文件，你可以预见OpenCV的链接将相同。这是一个`.pri`文件的完美用例。
- en: 'Inside the `ch08-image-animation` directory, create a new file called `plugins-common-opencv.pri`.
    Do not forget to add it to `OTHER_FILES` in `ch08-image-animation.pro`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch08-image-animation`目录内，创建一个名为`plugins-common-opencv.pri`的新文件。不要忘记将其添加到`ch08-image-animation.pro`中的`OTHER_FILES`：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the content of `plugins-common-opencv.pri`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`plugins-common-opencv.pri`的内容：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The content of `plugins-common-opencv.pri` is a direct copy of what we made
    in [Chapter 7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without
    a Headache"), *Third-Party Libraries Without a Headache*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugins-common-opencv.pri`的内容是我们[第7章](part0071.xhtml#aid-23MNU1 "第7章。无烦恼的第三方库")，*无烦恼的第三方库*中制作的直接复制。'
- en: 'All the plumbing is now ready; we can now go ahead with the `filter-plugin-grayscale`
    project. As with `filter-plugin-original`, we will build it the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的准备工作都已经就绪；我们现在可以继续`filter-plugin-grayscale`项目。与`filter-plugin-original`一样，我们将按照以下方式构建它：
- en: Create a **C++ Library Subproject** of `ch08-image-animation` with the **Shared
    Library** type.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch08-image-animation`中创建一个**共享库类型**的**C++库子项目**。
- en: Create a class named `FilterGrayscale`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FilterGrayscale`的类。
- en: In the **Required Modules**, select **QtCore** and **QWidgets**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**必需模块**中选择**QtCore**和**QWidgets**。
- en: 'Here is the updated version of `filter-plugin-grayscale.pro`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`filter-plugin-grayscale.pro`的更新版本：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The content is very much like `filter-plugin-original.pro`. We only added `plugins-common-opencv.pri`
    to let our plugin link with OpenCV.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 内容与`filter-plugin-original.pro`非常相似。我们只是添加了`plugins-common-opencv.pri`，以便我们的插件能够链接到OpenCV。
- en: 'As for `FilterGrayscale`, the header is exactly like `FilterOriginal.h`. Here
    are the relevant pieces on `FilterGrayscale.cpp`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`FilterGrayscale`，其头文件与`FilterOriginal.h`完全相同。以下是`FilterGrayscale.cpp`中的相关部分：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The inclusion of `plugins-common-opencv.pri` lets us properly include the `cv.h`
    header.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`plugins-common-opencv.pri`使我们能够正确地包含`cv.h`头文件。
- en: 'The last plugin we will implement is the blur plugin. Once again, create a
    **C++ Library ** **Subproject** and create the `FilterBlur` class. The project
    structure and the content of the `.pro` file are the same. Here is `FilterBlur.cpp`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的最后一个插件是模糊插件。再次创建一个**C++库子项目**，并创建`FilterBlur`类。项目结构和`.pro`文件的内容相同。以下是`FilterBlur.cpp`：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The amount of blur is hard-coded at `17`. In a production application, it could
    have been compelling to make this amount variable from the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊量是硬编码在`17`。在生产应用程序中，使这个量可变可能更有吸引力。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to push the project further, try to include a layout in the SDK
    that contains a way to configure the plugin properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步推进项目，尝试在SDK中包含一个配置插件属性的布局方式。
- en: Loading your plugins dynamically
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态加载你的插件
- en: 'We will now deal with the application loading these plugins:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将处理加载这些插件的应用程序：
- en: Create a new **Subproject** inside `ch08-image-animation`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch08-image-animation`内部创建一个新的**子项目**。
- en: Select the type **Qt Widgets Application**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择类型**Qt Widgets 应用程序**。
- en: Name it `image-animation` and accept the default **Class Information settings**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`image-animation`并接受默认的**类信息设置**。
- en: We have a few last things to do in the `.pro` files. First, `image-animation`
    will try to load the plugins from somewhere in its output directory. Because each
    filter plugin project is independent, its output directory is separated from `image-animation`.
    Thus, each time you modify a plugin, you will have to copy yourself the compiled
    shared library inside the proper `image-animation` directory. This works to make
    it available to the `image-animation` application, but we are lazy developers,
    right?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`.pro`文件中还有一些最后要完成的事情。首先，`image-animation`将尝试从其输出目录的某个地方加载插件。因为每个过滤器插件项目都是独立的，其输出目录与`image-animation`分开。因此，每次你修改一个插件时，你都必须将编译好的共享库复制到正确的`image-animation`目录中。这样做可以使它对`image-animation`应用程序可用，但我们都是懒惰的开发者，对吧？
- en: 'We can automate this by updating `plugins-common-pri` like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更新`plugins-common-pri`来实现自动化，如下所示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In a nutshell, the output library is deployed in the output `image-animation/plugins`
    directory. Windows has a different output project structure; that is why we have
    to have a platform-specific section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，输出库被部署在输出`image-animation/plugins`目录中。Windows有一个不同的输出项目结构；这就是为什么我们必须有一个特定于平台的章节。
- en: Even better, the `plugins` directory is automatically created with the instruction `createPluginsDir.commands
    = $$QMAKE_MKDIR_CMD $$createPluginsDir.path`. Instead of using a system command
    (`mkdir`), we have to use the special `$$QMAKE_MKDIR_CMD` command. Qt will then
    replace it with the correct shell command (depending on your OS) to create the
    directory only if it does not already exist. Do not forget to add the `make install`
    build step to execute this task!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，`plugins`目录会自动通过指令`createPluginsDir.commands = $$QMAKE_MKDIR_CMD $$createPluginsDir.path`创建。我们不得不用特殊的`$$QMAKE_MKDIR_CMD`命令而不是系统命令（`mkdir`）。Qt会将其替换为正确的shell命令（取决于你的操作系统），仅在目录不存在时创建该目录。不要忘记添加`make
    install`构建步骤来执行此任务！
- en: 'The last thing to do in the `.pro` files concerns `image-animation`. The application
    will manipulate `Filter` instances. As a consequence, it needs to access the SDK.
    Add the following to `image-animation.pro`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.pro`文件中最后要处理的是`image-animation`的`image-animation`。应用程序将操作`Filter`实例。因此，它需要访问SDK。请在`image-animation.pro`中添加以下内容：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Fasten your seatbelt. We will now load our freshly baked plugins. In `image-animation`,
    create a new class named `FilterLoader`. Here is the `FilterLoader.h` content:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 系好安全带。我们现在将加载我们新鲜出炉的插件。在`image-animation`中创建一个名为`FilterLoader`的新类。以下是`FilterLoader.h`的内容：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class is responsible for loading the plugins. Once again, we rely on C++11
    smart pointers with `unique_ptr` to explicate the ownership of the `Filter` instances.
    The `FilterLoader` class will be the owner with `mFilters` and provides a getter
    to the `vector` with `filters()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责加载插件。再一次，我们依靠C++11智能指针中的`unique_ptr`来解释`Filter`实例的所有权。`FilterLoader`类将是拥有者，通过`mFilters`提供对`vector`的访问器`filters()`。
- en: 'Note that `filter()` returns a `const&` to the `vector`. This semantic brings
    two benefits:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`filter()`函数返回一个`const&`给`vector`。这种语义带来了两个好处：
- en: The reference makes sure that the `vector` is not copied. Without it, the compiler
    would have barked something like "`FilterLoader` is not the owner anymore of `mFilters`
    content!" at us. Of course, because it deals with C++ templates, the compiler
    error would have looked rather like an astounding insult to the English language.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考确保了`vector`不会被复制。如果没有它，编译器可能会发出类似“`FilterLoader`不再是`mFilters`内容的拥有者！”这样的警告。当然，因为它处理的是C++模板，编译器错误看起来可能更像是对英语语言的惊人侮辱。
- en: The `const` keyword makes sure that the `vector` type cannot be modified by
    callers.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`关键字确保调用者不能修改`vector`类型。'
- en: 'Now we can create the `FilterLoader.cpp`: file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`FilterLoader.cpp`文件：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The meat of the class lies in `loadFilter()`. We start by moving in the `plugins`
    directory with `pluginsDir`, located in the output directory of `image-animation`.
    A special case is handled for the Mac platform: `QApplication::applicationDirPath()`
    returns a path inside the bundle of the generated application. The only way to
    get out is to climb our way up three times with the `cdUp()` instruction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类的核心在于`loadFilter()`方法。我们首先使用`pluginsDir`移动到`plugins`目录，它位于`image-animation`的输出目录中。对于Mac平台有一个特殊情况处理：`QApplication::applicationDirPath()`返回生成应用程序包内的路径。唯一的方法是使用`cdUp()`指令向上爬三次。
- en: 'For each `fileName` in this directory, we try to load a `QPluginLoader` loader.
    A `QPluginLoader` provides access to a Qt plugin. It is the cross-platform way
    to load a shared library. Moreover, the `QPluginLoader` loader has the following
    benefits:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个目录中的每个`fileName`，我们尝试加载一个`QPluginLoader`加载器。`QPluginLoader`提供了对Qt插件的访问。这是加载共享库的跨平台方式。此外，`QPluginLoader`加载器有以下优点：
- en: It checks that the plugin is linked with the same version of Qt as the host
    application
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查插件是否与宿主应用程序相同的Qt版本链接
- en: It simplifies the loading of the plugin by providing direct access to the plugin
    via `instance()` rather than relying on C functions
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供通过`instance()`直接访问插件的方式，而不是依赖于C函数，它简化了插件的加载。
- en: We then proceed to try to load the plugin using `pluginLoader.instance()`. This
    will try to load the root component of the plugin. In our case, the root component
    is either `FilerOriginal`, `FilterGrayscale`, or  `FilterBlur`. This function
    always returns a `QObject*`; if the plugin could not be loaded, it returns `0`.
    This is the reason why we inherited the `QObject` class in our custom plugins.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着尝试使用`pluginLoader.instance()`加载插件。这将尝试加载插件的根组件。在我们的案例中，根组件是`FilerOriginal`、`FilterGrayscale`或`FilterBlur`。这个函数总是返回一个`QObject*`；如果插件无法加载，它返回`0`。这就是为什么我们在自定义插件中继承了`QObject`类。
- en: The call to `instance()` implicitly tries to load the plugin. Once this has
    been done, the `QPluginLoader` does not handle the memory of the `plugin`. From
    here, we cast the plugin to `Filter*` using `qobject_cast()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance()`的调用隐式地尝试加载插件。一旦完成，`QPluginLoader`不再处理`plugin`的内存。从这里，我们使用`qobject_cast()`将插件转换为`Filter*`。'
- en: The `qobject_cast()` function behaves similarly to the standard C++ `dynamic_cast()`;
    the difference is that it does not require **RTTI** (**runtime type information**).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`qobject_cast()`函数的行为类似于标准的C++ `dynamic_cast()`；区别在于它不需要**RTTI**（**运行时类型信息**）。'
- en: Last but not least, the `Filter*` casted `plugin` is wrapped inside a `unique_ptr`
    and added to `mFilters` vector.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，将`Filter*`类型的`plugin`封装在`unique_ptr`中，并添加到`mFilters`向量中。
- en: Using the plugins inside the application
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中使用插件
- en: Now that the plugins are properly loaded, they have to be reachable from the
    UI of the application. To do so, we are going to take some inspiration (shameless
    stealing) from the `FilterWidget` class of [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已正确加载，它们必须可以从应用程序的UI中访问。为此，我们将从[第7章](part0071.xhtml#aid-23MNU1 "第7章。无需烦恼的第三方库")，*无需烦恼的第三方库*中的`FilterWidget`类中汲取一些灵感（无耻的借鉴）。
- en: Create a new Qt Designer **Form Class** using the **Widget** template named `FilterWidget`.
    The `FilterWidget.ui` file is exactly the same as the one completed in [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建一个新的**表单类**，使用名为`FilterWidget`的**Widget**模板。`FilterWidget.ui`文件与[第7章](part0071.xhtml#aid-23MNU1
    "第7章。无需烦恼的第三方库")中完成的一样，*无需烦恼的第三方库*。
- en: 'Create the `FilterWidget.h` file like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`FilterWidget.h`文件如下：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Overall, we trimmed everything concerning the Qt Designer plugin and simply
    passed the `mFilter` value by reference to the constructor. The `FilterWidget`
    class is not the owner of the `Filter` anymore; it is rather the client that calls
    it. Remember that the owner of `Filter` (aka the plugin) is `FilterLoader`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们简化了与Qt Designer插件相关的一切，只是通过引用将`mFilter`值传递给构造函数。`FilterWidget`类不再是`Filter`的所有者；它更像是调用它的客户端。记住，`Filter`（即插件）的所有者是`FilterLoader`。
- en: The other modification is the new `setThumbnail()` function. It should be called
    in place of the old `updateThumbnail()`. The new `updateThumbnail()` now only
    performs the thumbnail processing and does not touch the source thumbnail. This
    division is done to prepare the work for the coming animation section. The thumbnail
    update will be done only once the animation has been finished.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个修改是新的`setThumbnail()`函数。它应该替代旧的`updateThumbnail()`调用。新的`updateThumbnail()`现在只执行缩略图处理，不接触源缩略图。这种划分是为了为即将到来的动画部分做准备。缩略图更新将在动画完成后进行。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to the source code of the chapter to see `FilterWidget.cpp`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅该章节的源代码以查看`FilterWidget.cpp`。
- en: All the low layers have been completed. The next step is to fill `MainWindow`.
    Once again, it follows the same pattern we covered in [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*. The sole difference with `MainWindow.ui` is that `filtersLayout`
    is empty. Obviously, the plugin is loaded dynamically, so we have nothing to put
    inside it at compile time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有底层都已经完成。下一步是填充 `MainWindow`。再次强调，它遵循我们在[第 7 章](part0071.xhtml#aid-23MNU1 "第
    7 章。无需烦恼的第三方库")中覆盖的模式，*无需烦恼的第三方库*。与 `MainWindow.ui` 的唯一区别是 `filtersLayout` 是空的。显然，插件是动态加载的，因此在编译时我们无法在其中放置任何内容。
- en: 'Let''s cover `MainWindow.h`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `MainWindow.h`：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only notable thing is the addition of `mFilterLoader` as a member variable.
    In `MainWindow.cpp`, we will focus on the changes only:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一值得注意的是将 `mFilterLoader` 添加为成员变量。在 `MainWindow.cpp` 中，我们将专注于更改：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `initFilters()` function does not load the filters from the `ui` content.
    Rather, it starts by calling the `mFilterLoader.loadFilters()` function to dynamically
    load the plugins from the `plugins` directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`initFilters()` 函数不会从 `ui` 内容中加载过滤器。相反，它首先调用 `mFilterLoader.loadFilters()`
    函数，从 `plugins` 目录动态加载插件。'
- en: After that, an `auto&` filter is assigned with `mFilterLoader.filters()`. Note
    that it is much more readable to use `auto` keyword. The real type is `std::vector<std::unique_ptr<Filter>>&`,
    which looks more like a cryptic incantation than a simple object type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，一个 `auto&` 过滤器被分配给 `mFilterLoader.filters()`。请注意，使用 `auto` 关键字要容易阅读得多。实际类型是
    `std::vector<std::unique_ptr<Filter>>&`，这看起来更像是一个神秘的咒语，而不是一个简单的对象类型。
- en: For each of these filters, we create a `FilterWidget*` and pass it the reference
    of the `filter`. Here, `filter` is effectively a `unique_ptr`. The people behind
    C++11 wisely modified the dereferencing operator, making it transparent to the
    new `FilterWidget(*filter)`. The combination of the `auto` keyword and the overload
    of the `->` operator, or the dereference operator, makes the use of new C++ features
    much more enjoyable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些过滤器中的每一个，我们创建一个 `FilterWidget*` 并传递 `filter` 的引用。在这里，`filter` 事实上是一个 `unique_ptr`。C++11
    背后的开发者们明智地修改了解引用操作符，使得新的 `FilterWidget(*filter)` 变得透明。`auto` 关键字和 `->` 操作符（或解引用操作符）的重载组合使得使用新的
    C++ 功能变得更加愉快。
- en: 'Look at the for loop. For each `filter` we do the following tasks:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个 for 循环。对于每个 `filter`，我们执行以下任务：
- en: Create a `FilterWidget` template.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `FilterWidget` 模板。
- en: Add the `FilterWidget` template to the `filtersLayout` children.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FilterWidget` 模板添加到 `filtersLayout` 子项中。
- en: Connect the `FilterWidget::pictureProcessed` signal to the `MainWindow::displayPicture` slot.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FilterWidget::pictureProcessed` 信号连接到 `MainWindow::displayPicture` 插槽。
- en: Add the new `FilterWidget` template to the `QVector``mFilters`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `FilterWidget` 模板添加到 `QVector` `mFilters` 中。
- en: In the end, the first `FilterWidget` is selected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择第一个 `FilterWidget`。
- en: 'The only other modification to `MainWindow.cpp` is the implementation of `loadPicture()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `MainWindow.cpp` 的唯一其他修改是 `loadPicture()` 的实现：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `updateThumbnail()` function has been split into two functions, and here
    is where it is used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateThumbnail()` 函数已经被拆分为两个函数，这里就是使用它的地方。'
- en: The application can now be tested. You should be able to execute it and see
    the dynamic plugins loaded and displaying the processed default Lenna picture.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可以进行测试。你应该能够执行它，并看到动态加载的插件以及显示处理后的默认 Lenna 图片。
- en: Discovering the Animation Framework
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索动画框架
- en: Your application works like a charm. It is now time to look at how we can make
    it jump and move, or, in a word, live. The Qt Animation Framework can be used
    to create and start animations of Qt properties. The property value will be smoothly
    interpolated by an internal global timer handle by Qt. You can animate anything
    as long as it is a Qt property. You can even create a property for your own object
    using `Q_PROPERTY`. If you forgot about `Q_PROPERTY`, please refer to [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序运行得非常出色。现在是时候看看我们如何让它跳跃和移动，或者说，让它“活”起来。Qt 动画框架可以用来创建和启动 Qt 属性的动画。Qt 将通过一个内部的全局定时器句柄平滑地插值属性值。只要它是
    Qt 属性，你可以对任何东西进行动画处理。你甚至可以使用 `Q_PROPERTY` 为你的对象创建属性。如果你忘记了 `Q_PROPERTY`，请参阅[第
    7 章](part0071.xhtml#aid-23MNU1 "第 7 章。无需烦恼的第三方库")，*无需烦恼的第三方库*。
- en: 'Three main classes are provided to build animations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了三个主要类来构建动画：
- en: '`QPropertyAnimation`: This class animates one Qt property animation'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPropertyAnimation`：这个类用于动画一个 Qt 属性动画'
- en: '`QParallelAnimationGroup`: This class animates multiple animations in parallel
    (all the animations start together)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QParallelAnimationGroup`：这个类并行动画化多个动画（所有动画同时开始）'
- en: '`QSequentialAnimationGroup`: This class animates multiple animations in sequence
    (the animations run one by one in a defined order)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSequentialAnimationGroup`：这个类按顺序动画化多个动画（动画按定义的顺序一个接一个地运行）'
- en: 'All those classes inherit `QAbstractAnimation`. Here is a diagram from the
    official Qt documentation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类都继承自`QAbstractAnimation`。以下是来自官方Qt文档的图表：
- en: '![Discovering the Animation Framework](img/image00418.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![探索动画框架](img/image00418.jpeg)'
- en: 'Please notice that `QAbstractAnimation`, `QVariantAnimation`, and `QAnimationGroup`
    are abstract classes. Here is a simple example of a Qt animation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`QAbstractAnimation`、`QVariantAnimation`和`QAnimationGroup`都是抽象类。以下是一个简单的Qt动画示例：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding snippet moves a `QLabel` label from the 0 x 0 position to 300
    x 200 in four seconds. The first thing to do is to define the target object and
    its property. In our case, the target object is `label` and we want to animate
    the property called `geometry`. Then, we set the animation duration in milliseconds: `4000`
    milliseconds for four seconds. Finally, we can decide the start and end values
    of the `geometry` property, which is a `QRect`, defined like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将一个`QLabel`标签从0 x 0位置移动到300 x 200位置，耗时四秒。首先需要定义目标对象及其属性。在我们的例子中，目标对象是`label`，我们想要动画化名为`geometry`的属性。然后，我们设置动画的持续时间（以毫秒为单位）：`4000`毫秒对应四秒。最后，我们可以决定`geometry`属性的开始和结束值，这是一个`QRect`，定义如下：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `label` object starts with the 0 x 0 position and ends with 300 x 200\.
    In this example, the size is fixed (150 x 50), but you can also animate the width
    and the height if you want.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`label`对象从0 x 0位置开始，到300 x 200位置结束。在这个例子中，大小是固定的（150 x 50），但如果你愿意，也可以动画化宽度和高度。'
- en: 'Finally, we call the `start()` function to begin the animation. In four seconds,
    the animation smoothly moves the label from the 0 x 0 position to 300 x 200\.
    By default, the animation uses a linear interpolation to provide intermediate
    values, so, after two seconds, the `label` will be at the 150 x 100 position.
    The linear interpolation of the value looks like the following schema:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`start()`函数开始动画。在四秒内，动画平滑地将标签从0 x 0位置移动到300 x 200位置。默认情况下，动画使用线性插值来提供中间值，因此，两秒后，`label`将位于150
    x 100位置。值的线性插值看起来像以下图示：
- en: '![Discovering the Animation Framework](img/image00419.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![探索动画框架](img/image00419.jpeg)'
- en: 'In our case, the `label` object will move with a constant speed from the start
    to the end position. An easing function is a mathematical function that describes
    the evolution of a value over time. The easing curve is the visual representation
    of the mathematical function. The default linear interpolation is a good start,
    but Qt provides plenty of easing curves to control the speed behavior of your
    animation. Here is the updated example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`label`对象将以恒定速度从起始位置移动到结束位置。缓动函数是一个描述值随时间演变的数学函数。缓动曲线是数学函数的视觉表示。默认的线性插值是一个好的起点，但Qt提供了许多缓动曲线来控制动画的速度行为。以下是更新后的示例：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can set the target object and the property name directly using the `QPropertyAnimation`
    constructor. As a result, we removed the `setTargetObject()` and `setPropertyName()`
    functions. After that, we use `setEasingCurve()` to specify a curve for this animation.
    The `InCirc` looks like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用`QPropertyAnimation`构造函数设置目标对象和属性名。因此，我们移除了`setTargetObject()`和`setPropertyName()`函数。之后，我们使用`setEasingCurve()`为这个动画指定一个曲线。`InCirc`看起来如下：
- en: '![Discovering the Animation Framework](img/image00420.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![探索动画框架](img/image00420.jpeg)'
- en: With this easing curve, the label starts to move really slowly but accelerates
    progressively during the animation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个缓动曲线，标签开始移动速度很慢，但在动画过程中逐渐加速。
- en: 'Another way is to define the intermediate key steps yourself, using the `setKeyValueAt()`
    function. Let''s update our example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`setKeyValueAt()`函数自己定义中间的关键步骤。让我们更新我们的例子：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are now setting key frames using `setKeyValueAt()`. The first argument is
    the time step in the range 0 to 1\. In our case, step 1 means four seconds. The
    key frames at step 0 and step 1 provide the same positions as the start/end positions
    of the first example. As you can see, we also add a key frame at step 0.25 (that''s
    one second for us) with the position 225 x 112.5\. The next schema illustrates
    this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在使用 `setKeyValueAt()` 设置关键帧。第一个参数是 0 到 1 范围内的时间步长。在我们的例子中，步骤 1 意味着四秒。步骤
    0 和步骤 1 的关键帧提供了与第一个示例的起始/结束位置相同的坐标。正如你所见，我们还在步骤 0.25（对我们来说是一秒）处添加了一个位置 225 x 112.5
    的关键帧。下一个图示说明了这一点：
- en: '![Discovering the Animation Framework](img/image00421.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![探索动画框架](img/image00421.jpeg)'
- en: You can clearly distinguish the three key frames created with `setKeyValueAt()`.
    In our example, our `label` will quickly reach the 225 x 112.5 position in one
    second. Then the label will slowly move to the 300 x 200 position during the remaining
    three seconds.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地区分使用 `setKeyValueAt()` 创建的三个关键帧。在我们的例子中，我们的 `label` 将在 一秒内迅速达到 225 x 112.5
    的位置。然后标签将在剩余的三秒内缓慢移动到 300 x 200 的位置。
- en: 'If you have more than one `QPropertyAnimation` object, you can use groups to
    create more complex sequences. Let''s see an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个以上的 `QPropertyAnimation` 对象，你可以使用组来创建更复杂的序列。让我们看一个例子：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we are using a `QSequentialAnimationGroup` to run animations
    one by one. The first thing to do is to add animations to `animationGroup`. Then,
    when we call `start()` on our animation group, `animation1` is `launched`. When `animation1`
    is finished, `animationGroup` runs `animation2`. A `QSequentialAnimationGroup`
    is finished when the last animation of the list ends. The next schema depicts
    this behavior:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `QSequentialAnimationGroup` 来依次运行动画。首先要做的是将动画添加到 `animationGroup`
    中。然后，当我们对动画组调用 `start()` 时，`animation1` 将被 `启动`。当 `animation1` 完成 时，`animationGroup`
    将运行 `animation2`。当列表中的最后一个动画结束时，`QSequentialAnimationGroup` 才会完成。下一个图示描述了这种行为：
- en: '![Discovering the Animation Framework](img/image00422.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![探索动画框架](img/image00422.jpeg)'
- en: 'The second animation group, `QParallelAnimationGroup`, is initialized and started
    in the same way as `QSequentialAnimationGroup`. But the behavior is different:
    it starts all the animations in parallel, waiting for the longest animation to
    end. Here is an illustration of this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个动画组 `QParallelAnimationGroup` 以与 `QSequentialAnimationGroup` 相同的方式初始化和启动。但行为不同：它并行启动所有动画，等待最长的动画结束。以下是这一点的说明：
- en: '![Discovering the Animation Framework](img/image00423.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![探索动画框架](img/image00423.jpeg)'
- en: Keep in mind that an animation group is itself an animation (it inherits `QAbstractAnimation`).
    As a consequence, you can add animation groups to other animation groups to create
    a very complex animation sequence!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，动画组本身也是一个动画（它继承自 `QAbstractAnimation`）。因此，你可以将动画组添加到其他动画组中，以创建一个非常复杂的动画序列！
- en: Making your thumbnails jump
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让你的缩略图跳跃
- en: 'Let''s apply what we learned about the Qt Animation Framework to our project.
    Each time the user clicks on a filter thumbnail, we want to poke it. All modifications
    will be done on the `FilterWidget` class. Let''s start with `FilterWidget.h`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们学到的有关 Qt 动画框架的知识应用到我们的项目中。每次用户点击过滤器缩略图时，我们希望对其进行“戳”操作。所有修改都将在对 `FilterWidget`
    类进行。让我们从 `FilterWidget.h` 开始：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first function, `initAnimations()`, initializes the animations used by `FilterWidget`.
    The second function, `startSelectionAnimation()`, performs tasks required to start
    this animation correctly. As you can see, we are also declaring a `QPropertyAnimation`
    class, as covered in the previous section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `initAnimations()` 初始化了 `FilterWidget` 所使用的动画。第二个函数 `startSelectionAnimation()`
    执行启动此动画所需的任务。正如你所见，我们还在前一个章节中介绍了 `QPropertyAnimation` 类。
- en: 'We can now update `FilterWidget.cpp`. Let''s update the constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新 `FilterWidget.cpp`。让我们更新构造函数：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We initialize our `QPropertyAnimation` called `mSelectionAnimation`. The constructor
    also calls `initAnimations()`. Here is its implementation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个名为 `mSelectionAnimation` 的 `QPropertyAnimation`。构造函数还调用了 `initAnimations()`。以下是其实施方法：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should be familiar with these animation initialization steps now. The target
    object is the `thumbnailLabel` displaying the filter plugin preview. The property
    name to animate is `geometry`, because we want to update the position of this `QLabel`.
    Finally, we set the animation duration to 200 ms. Like jokes, keep it short and
    sweet.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉这些动画初始化步骤了。目标对象是显示过滤器插件预览的 `thumbnailLabel`。要动画化的属性名称是 `geometry`，因为我们想更新这个
    `QLabel` 的位置。最后，我们将动画时长设置为 200 毫秒。就像笑话一样，保持简短而甜蜜。
- en: 'Update the existing mouse event handler like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有的鼠标事件处理程序如下：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each time the user clicks on the thumbnail, the selection animation moving
    the thumbnail will be called. We can now add this most important function like
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户点击缩略图时，都会调用移动缩略图的选中动画。我们现在可以添加这个最重要的函数如下：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first thing to do is to retrieve the current geometry of `thumbnailLabel`
    called `currentGeometry`. Then, we create a `targetGeometry` object with the same `x`, `width`,
    and `height` values. We only reduce the `y` position by 50, so the target position
    is always above the current position.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是获取 `thumbnailLabel` 的当前几何形状，称为 `currentGeometry`。然后，我们创建一个具有相同 `x`、`width`
    和 `height` 值的 `targetGeometry` 对象。我们只减少 `y` 位置 50，因此目标位置始终在当前位置之上。
- en: 'After that, we define our key frames:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义我们的关键帧：
- en: '**At step 0**, the value is the current position.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在步骤 0**，值是当前位置。'
- en: '**At step 0.3** (60 ms, because the total duration is 200 ms), the value is
    the target position.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在步骤 0.3**（60 毫秒，因为总时长是 200 毫秒），值是目标位置。'
- en: '**At step 1** (the end of the animation), we bring it to back the original
    position. The thumbnail will quickly reach the target position, then slowly fall
    down to its original position.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在步骤 1**（动画的结尾），我们将它恢复到原始位置。缩略图将迅速达到目标位置，然后缓慢下降到其原始位置。'
- en: These key frames must be initialized before each animation starts. Because the
    layout is dynamic, the position (and so the geometry) could have been updated
    when the user resizes the main window.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键帧必须在每次动画开始之前初始化。因为布局是动态的，当用户调整主窗口大小时，位置（以及因此的几何形状）可能已经被更新。
- en: Please note that we are preventing the animation from starting again if the
    current state is not stopped. Without this precaution, the thumbnail could move
    to the top again and again if the user clicks like a mad man on the widget.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在防止如果当前状态没有停止，动画再次开始。如果没有这个预防措施，如果用户像疯子一样连续点击小部件，缩略图可能会一次又一次地移动到顶部。
- en: You can now test your application and click on a filter effect. The filter thumbnail
    will jump to respond to your click!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以测试你的应用程序并点击一个过滤器效果。过滤器缩略图将跳起来响应你的点击！
- en: Fading the picture in
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 淡入图片
- en: When the user opens a picture, we want to fade in the image by playing with
    its opacity. The classes `QLabel` or `QWidget` do not provide an opacity property.
    However, we can add a visual effect to any `QWidget` using a `QGraphicsEffect`.
    For this animation, we will use `QGraphicsOpacityEffect` to provide an `opacity`
    property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开图片时，我们希望通过调整其不透明度来淡入图像。`QLabel` 或 `QWidget` 类不提供不透明度属性。然而，我们可以使用 `QGraphicsEffect`
    为任何 `QWidget` 添加视觉效果。对于这个动画，我们将使用 `QGraphicsOpacityEffect` 来提供 `opacity` 属性。
- en: 'Here is a schema to describe the role of each one:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个图解来描述每个组件的作用：
- en: '![Fading the picture in](img/image00424.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![淡入图片](img/image00424.jpeg)'
- en: In our case, the `QWidget` class is our `QLabel` and the `QGraphicsEffect` class
    is `QGraphicsOpacityEffect`. Qt provides the Graphics Effect system to alter the
    rendering of a `QWidget` class. The abstract class `QGraphicsEffect` has a pure
    virtual method `draw()` that is implemented by each graphics effect.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`QWidget` 类是我们的 `QLabel`，而 `QGraphicsEffect` 类是 `QGraphicsOpacityEffect`。Qt
    提供了图形效果系统来改变 `QWidget` 类的渲染。抽象类 `QGraphicsEffect` 有一个纯虚方法 `draw()`，该方法由每个图形效果实现。
- en: 'We can now update the `MainWindow.h` according to the next snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以根据下一个片段更新 `MainWindow.h`：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `initAnimations()` private function is in charge of all the animation initializations.
    The  `mLoadPictureAnimation` member variable performs the fade-in animation on
    the loaded picture. Finally, we declare `mPictureOpacityEffect`, the mandatory `QGraphicsOpacityEffect`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`initAnimations()` 这个私有函数负责所有的动画初始化。`mLoadPictureAnimation` 成员变量负责对加载的图片执行淡入动画。最后，我们声明了
    `mPictureOpacityEffect`，这是必须的 `QGraphicsOpacityEffect`。'
- en: 'Let''s switch to the implementation part with the `MainWindow.cpp` constructor:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到实现部分，使用 `MainWindow.cpp` 构造函数：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: No surprises here. We use the initializer list to construct our two new member
    variables. The `MainWindow` constructor also calls `initAnimations()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜。我们使用初始化列表来构造我们的两个新成员变量。`MainWindow`构造函数还调用了`initAnimations()`。
- en: 'Let''s look at how this animation is initialized:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动画是如何初始化的：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first thing to do is to link our `QGraphicsOpacityEffect` with our `QLabel`.
    This can be easily done by calling the `setGraphicsEffect()` function on `pictureLabel`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将我们的`QGraphicsOpacityEffect`与`QLabel`链接起来。这可以通过在`pictureLabel`上调用`setGraphicsEffect()`函数轻松完成。
- en: 'Now we can set our animation up. In this case, `mLoadPictureAnimation` targets `mPictureOpacityEffect`
    and will affect its property named `opacity`. The animation duration is `500`
    milliseconds. Next, we set the opacity value when the animation starts and ends:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置动画。在这种情况下，`mLoadPictureAnimation`针对`mPictureOpacityEffect`，将影响其名为`opacity`的属性。动画持续时间为`500`毫秒。接下来，我们设置动画开始和结束时的透明度值：
- en: At the beginning, the picture is completely transparent (`opacity` value is `0`)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始时，图片是完全透明的（`透明度`值为`0`）
- en: At the end, the picture is fully visible (`opacity` value is `1`)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，图片完全可见（`透明度`值为`1`）
- en: 'For this animation, we use the easing curve `InCubic`. This curve looks like
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个动画，我们使用`InCubic`缓动曲线。这个曲线看起来像这样：
- en: '![Fading the picture in](img/image00425.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片淡入](img/image00425.jpeg)'
- en: Feel free to try other curves to find the one that looks the best for you.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试其他曲线，找到最适合您的曲线。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get the list of all easing curves with a visual preview here:[http://doc.qt.io/qt-5/qeasingcurve.html](http://doc.qt.io/qt-5/qeasingcurve.html)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处获取所有缓动曲线的视觉预览列表：[http://doc.qt.io/qt-5/qeasingcurve.html](http://doc.qt.io/qt-5/qeasingcurve.html)
- en: 'The last step is to start the animation at the right place:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在正确的地方开始动画：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can now start your application and load a picture. You should see your picture
    fade in over 500 milliseconds!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以启动应用程序并加载一张图片。您应该会看到图片在500毫秒内淡入！
- en: Flashing the thumbnail in a sequence
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按顺序闪烁缩略图
- en: 'For this last animation, we want to display a blue flash on each filter preview
    when the thumbnail is updated. We do not want to flash all previews at the same
    time, but in a sequence, one by one. This feature will be achieved in two parts:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个动画，我们想在缩略图更新时在每个过滤器预览上显示蓝色闪光。我们不想同时闪烁所有预览，而是按顺序逐个闪烁。这个功能将通过两部分实现：
- en: Create a color animation in `FilterWidget` to display a blue flash
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`FilterWidget`中创建一个颜色动画以显示蓝色闪光
- en: Build a sequential animation group in `MainWindow` containing all `FilterWidget`
    color animations
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`MainWindow`中构建一个包含所有`FilterWidget`颜色动画的顺序动画组
- en: 'Let''s start to add the color animation. Update `FilterWidget.h` as shown in
    the following snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始添加颜色动画。按照以下代码片段更新`FilterWidget.h`：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This time we do not want to affect the opacity, but rather colorize the thumbnail
    in blue. Thus, we use another Qt standard effect: `QGraphicsColorizeEffect`. We
    also declare a new `QPropertyAnimation` named `mColorAnimation` and its corresponding
    getter, `colorAnimation()`. We declare `mColorAnimation` as a pointer because
    the ownership will be taken by the animation group of `MainWindow`. This topic
    will be covered soon.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不想影响透明度，而是将缩略图着色为蓝色。因此，我们使用另一个Qt标准效果：`QGraphicsColorizeEffect`。我们还声明了一个新的`QPropertyAnimation`，名为`mColorAnimation`，以及其对应的获取器`colorAnimation()`。我们将`mColorAnimation`声明为指针，因为所有权将由`MainWindow`的动画组接管。这个话题很快就会涉及。
- en: 'Let''s update the constructor in `FilterWidget.cpp`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`FilterWidget.cpp`中的构造函数：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We just have to construct our two new member variables, `mColorAnimation` and `mColorEffect`.
    Let''s look at the amazing complexity of the getter:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要构造我们的两个新成员变量，`mColorAnimation`和`mColorEffect`。让我们看看获取器的惊人复杂性：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It was a lie: we always try to write comprehensive code!'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个谎言：我们总是试图编写全面的代码！
- en: 'Now that the preliminaries are done, we can initialize the color animation
    by updating the  `initAnimations()` function like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初步工作完成，我们可以通过更新`initAnimations()`函数来初始化颜色动画，如下所示：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first part sets the color filter up. Here, we chose a kind of turquoise
    color for the flash effect. The colorize effect is handled by its `strength` property.
    By default, the value is `1.0`, so, we set it to `0.0` to keep it from affecting
    our default thumbnail of Lenna. Finally, we link the `thumbnailLabel` with this `mColorEffect`
    calling `setGraphicsEffect()`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分设置了颜色过滤器。在这里，我们选择了一种青绿色来作为闪烁效果。着色效果由其 `strength` 属性处理。默认值是 `1.0`，因此，我们将它设置为
    `0.0` 以防止它影响我们默认的 Lenna 缩略图。最后，我们通过调用 `setGraphicsEffect()` 将 `thumbnailLabel`
    与 `mColorEffect` 链接起来。
- en: 'The second part is the color animation preparation. This animation targets
    the color effect and its property, named `strength`. This is a short flash; `200`
    milliseconds is enough:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是颜色动画的准备。这个动画针对颜色效果及其属性，名为 `strength`。这是一个短暂的闪烁；`200` 毫秒就足够了：
- en: We want to start with a full strength effect, so we put the start value at `1.0`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望从全强度效果开始，所以我们将起始值设置为 `1.0`
- en: During the animation, the colorize effect will decrease until it reaches `0.0`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动画过程中，着色效果将逐渐减弱，直到达到 `0.0`
- en: The default linear interpolation is fine here, so we do not use any easing curve.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的默认线性插值就足够好了，所以我们没有使用任何缓动曲线。
- en: 'Here we are. The color effect/animation is initialized and we provided a `colorAnimation()`
    getter. We can now begin the second part of this feature, Updating `MainWindow.h`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里。颜色效果/动画已初始化，我们提供了一个 `colorAnimation()` 获取器。现在我们可以开始这个功能的第二部分，更新 `MainWindow.h`：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We declare a `QSequentialAnimationGroup` class to trigger, one by one, all `FilterWidget`
    color animations displaying the blue flash. Let''s update the constructor in `MainWindow.cpp`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个 `QSequentialAnimationGroup` 类来依次触发所有显示蓝色闪烁的 `FilterWidget` 颜色动画。让我们更新
    `MainWindow.cpp` 中的构造函数：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A new member variable means a new construction in the initializer list: that
    is the rule!'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 新成员变量意味着初始化列表中的新构造：这就是规则！
- en: 'We can now update `initAnimations()` to prepare our animation group:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新 `initAnimations()` 来准备我们的动画组：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Do you remember that an animation group is only an animation container? As a
    consequence, we iterate on every `FilterWidget` to get its color animation and
    fill our `mFiltersGroupAnimation` calling `addAnimation()`. Thanks to C++11's
    range-based for loop, it is really readable. Keep in mind that when you add an
    animation to an animation group, the group takes ownership of this animation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得吗，动画组只是一个动画容器？因此，我们遍历每个 `FilterWidget` 来获取其颜色动画，并调用 `addAnimation()` 填充我们的
    `mFiltersGroupAnimation`。多亏了 C++11 的基于范围的 for 循环，这使得代码非常易于阅读。请注意，当你向动画组添加动画时，组将拥有这个动画的所有权。
- en: 'Our animation group is ready. We can now start it:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动画组已经准备好了。现在我们可以启动它：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Start your application and open a picture. You can see that all filter thumbnails
    will flash one by one from left to right. This is what we intended, but it''s
    still not perfect because all the thumbnails are already updated before the flashes.
    We have this behavior because the `loadPicture()` function actually sets and updates
    all thumbnails, and then finally starts the sequential animation group. Here is
    a schema illustrating the current behavior:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的应用程序并打开一张图片。您可以看到所有过滤器缩略图将一个接一个地从左到右闪烁。这正是我们想要的，但它还不够完美，因为所有缩略图在闪烁之前都已经更新了。我们之所以有这种行为，是因为
    `loadPicture()` 函数实际上设置了并更新了所有缩略图，然后最终启动了顺序动画组。以下是说明当前行为的方案：
- en: '![Flashing the thumbnail in a sequence](img/image00426.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![按顺序闪烁缩略图](img/image00426.jpeg)'
- en: 'The schema only describes the behavior for two thumbnails, but the principle
    is the same with three thumbnails. Here is the targeted behavior:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该方案仅描述了两个缩略图的行为，但三个缩略图的原则是相同的。以下是目标行为：
- en: '![Flashing the thumbnail in a sequence](img/image00427.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![按顺序闪烁缩略图](img/image00427.jpeg)'
- en: 'We must only update the thumbnail when the flash animation is over. Fortunately,
    `QPropertyAnimation` emits the `finished` signal when the animation is over, so
    we only have to make a few changes. Update `loadPicture()` function from `MainWindow.cpp`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在闪烁动画结束后才更新缩略图。幸运的是，`QPropertyAnimation` 在动画结束后会发出 `finished` 信号，所以我们只需要做几个更改。更新
    `MainWindow.cpp` 中的 `loadPicture()` 函数：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you can see, we kept the set and only removed the update thumbnail when
    a new picture is opened by the user. At this stage, all `FilterWidget` instances
    have the correct thumbnail, but they don''t display it. Let''s fix this by updating `FilterWidget.cpp`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们保留了设置，只是在用户打开新图片时移除了更新缩略图。在这个阶段，所有 `FilterWidget` 实例都拥有正确的缩略图，但它们没有显示出来。让我们通过更新
    `FilterWidget.cpp` 来解决这个问题：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We connect a `lambda` function to the finished signal of the color animation.
    This `lambda` simply updates the thumbnail. You can now start your application
    again and load a picture. You should see that we not only animate the sequential
    blue flash, but also the thumbnail update.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个 `lambda` 函数连接到颜色动画的完成信号。这个 `lambda` 函数简单地更新缩略图。现在你可以重新启动你的应用程序并加载一张图片。你应该能看到我们不仅动画化了连续的蓝色闪光，还更新了缩略图。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you defined a `Filter` interface in your own SDK. Your filters
    are now plugins. You know how to create and load a new plugin, so your application
    is now modular and can be easily extended. We have also enhanced the application
    with the Qt Animation Framework. You know how to animate the position, the color,
    and the opacity of any `QWidget`, using `QGraphicsEffect` if necessary. We created
    a sequential animation that starts three animations one by one with `QSequentialAnimationGroup`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你在自己的 SDK 中定义了一个 `Filter` 接口。你的过滤器现在变成了插件。你知道如何创建和加载一个新的插件，因此你的应用程序现在是模块化的，并且可以轻松扩展。我们还使用
    Qt 动画框架增强了应用程序。你知道如何使用 `QGraphicsEffect`（如果需要的话）来动画化任何 `QWidget` 的位置、颜色和透明度。我们创建了一个顺序动画，通过
    `QSequentialAnimationGroup` 依次启动三个动画。
- en: 'In the next chapter, we will talk about a big subject: threading. The Qt framework
    can help you build a robust and reliable multithreading application. To illustrate
    the chapter, we will create a Mandelbrot fractal generator using threadpools.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个重要主题：线程。Qt 框架可以帮助你构建一个健壮且可靠的线程应用程序。为了说明本章内容，我们将使用线程池创建一个曼德布罗特分形生成器。
