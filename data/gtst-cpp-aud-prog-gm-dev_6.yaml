- en: Chapter 6. Low-level Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。低级音频
- en: We have now reached the final chapter of this book. So far, we have worked with
    audio at many different levels of complexity and abstraction, using both low-level
    and high-level audio engines. These audio engines provide an invaluable help to
    the developers, and we should definitely use them whenever possible. With their
    help, we have loaded and played audio files, learnt how to control sound parameters,
    simulated sound in 3D environments, and created complex, multi-layered, interactive
    sounds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了这本书的最后一章。到目前为止，我们已经在许多不同复杂度和抽象级别上使用了音频，使用了低级和高级音频引擎。这些音频引擎为开发人员提供了宝贵的帮助，我们应该在可能的时候一定要使用它们。在它们的帮助下，我们已经加载和播放了音频文件，学会了如何控制声音参数，在3D环境中模拟声音，并创建了复杂的、多层次的、交互式的声音。
- en: In this chapter, however, we will pretend that these audio engines do not exist,
    and work with nothing more than the bits and bytes that represent sound in a computer.
    We will then re-implement, in a simplified form, many of the features that FMOD
    takes care for us. We will also take a brief look at sound synthesis, which is
    the act of generating sound using mathematical formulas, instead of relying on
    recorded audio.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这一章中，我们将假装这些音频引擎不存在，只使用代表计算机中声音的位和字节。然后，我们将以简化形式重新实现FMOD为我们处理的许多功能。我们还将简要介绍声音合成，这是使用数学公式生成声音的行为，而不是依赖录制的音频。
- en: The purpose of this chapter is to further our understanding of how sound works,
    and to gain some insight into many of the features that audio engines implement
    for us. It should also serve as a starting point for those who are looking to
    implement complex audio features in their games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章的目的是进一步加深我们对声音工作原理的理解，并对音频引擎为我们实现的许多功能有所了解。它也应该作为那些希望在游戏中实现复杂音频功能的人的起点。
- en: Representing audio data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示音频数据
- en: In [Chapter 1](ch01.html "Chapter 1. Audio Concepts"), *Audio Concepts*, we
    discussed the most important concepts of digital audio theory. In particular,
    we saw that a simple array of numbers could represent an audio signal, and talked
    about topics such as PCM, sampling rate, bit depth, and multi-channel audio.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章.音频概念")中，*音频概念*，我们讨论了数字音频理论的最重要概念。特别是，我们看到一个简单的数字数组可以表示音频信号，并讨论了PCM、采样率、位深度和多声道音频等主题。
- en: In this chapter, we will be putting all of those concepts into practice, so
    make sure you understand them before continuing. For starters, let us look into
    the meaning of audio data, both in theory and in code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将把所有这些概念付诸实践，所以在继续之前确保你理解了它们。首先，让我们来看一下音频数据的含义，无论是在理论上还是在代码中。
- en: Audio data is nothing more than a sequence of numbers that represent the amplitude
    of a sound wave at even time intervals. However, there are many ways to represent
    numbers on a computer, depending on the amount of memory used to represent them,
    whether they should be able to store negative numbers, and whether the numbers
    are integers or floating point numbers. These differences result in the multiple
    data types provided by C++ to store numbers, such as `int`, `short`, `float`,
    and `double`. It makes sense then, that audio data can also be stored in several
    formats, depending on the chosen data type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 音频数据只不过是一系列数字，表示在均匀的时间间隔内声音波的振幅。然而，有许多种方法可以在计算机上表示数字，取决于用于表示它们的内存量，它们是否应该能够存储负数，以及这些数字是整数还是浮点数。这些差异导致了C++提供的多种数据类型来存储数字，如`int`、`short`、`float`和`double`。因此，根据所选择的数据类型，音频数据也可以以多种格式存储。
- en: 'In this chapter, we will limit ourselves to the most common audio format, which
    is the signed 16-bit linear PCM format. In this format, every sample is a 16-bit
    signed integer (a `signed short` in C++) ranging from -32768 at the minimum amplitude,
    to 32767 at the maximum amplitude. To simplify the notation when dealing with
    PCM samples and other quantities, we will be using the following aliases:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将限制自己使用最常见的音频格式，即有符号的16位线性PCM格式。在这种格式中，每个样本都是一个16位有符号整数（在C++中是`signed
    short`），幅度范围从最小幅度的-32768到最大幅度的32767。为了简化处理PCM样本和其他数量时的表示法，我们将使用以下别名：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After deciding what format to use, we need to create an array to hold all of
    the audio samples. The size of the array depends directly on the sampling rate
    of the sound we want to store, its duration in seconds, and the number of channels
    being used, according to the following formula:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用什么格式之后，我们需要创建一个数组来存储所有的音频样本。数组的大小直接取决于我们想要存储的声音的采样率、持续时间（以秒为单位）和正在使用的声道数，根据以下公式：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, assuming a sampling rate of 44100 Hz, we could create an array
    to store exactly 1 second of mono audio data like the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设采样率为44100 Hz，我们可以创建一个数组来存储精确1秒的单声道音频数据，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we wanted to store a stereo signal instead, we would need to store twice
    that amount of information (and the same idea applies to higher amounts of channels).
    Remember that the most common way to represent stereo audio data is to interleave
    samples, left and right, in the same array:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要存储立体声信号，我们将需要存储两倍的信息量（同样的思想也适用于更多的声道）。请记住，表示立体声音频数据的最常见方式是在同一个数组中交错存储左声道和右声道的样本：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Playing audio data
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频数据
- en: We need a way to submit the audio data to the sound card, so that we can hear
    the resulting sound. We could use a very low-level audio API, such as PortAudio,
    which provides the bare minimum functionality required to communicate with an
    audio device. However, FMOD is also perfectly capable of handling this task, and
    since we have been using it so far, there is little benefit in changing to a different
    API now. Therefore, we will use FMOD once again, but only as bridge between the
    application and the hardware, and our code will handle all of the processing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法将音频数据提交给声卡，以便我们可以听到生成的声音。我们可以使用非常低级别的音频API，例如PortAudio，它提供了与音频设备通信所需的最低功能。但是，FMOD也完全能够处理此任务，而且由于我们迄今为止一直在使用它，现在改用不同的API几乎没有好处。因此，我们将再次使用FMOD，但仅作为应用程序和硬件之间的桥梁，我们的代码将处理所有处理。
- en: The way FMOD allows us to play user created audio data is by first creating
    a sound with the `FMOD_OPENUSER` flag, and specifying a callback function that
    will provide the audio data to the sound.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD允许我们播放用户创建的音频数据的方式是首先使用`FMOD_OPENUSER`标志创建一个声音，并指定一个回调函数来提供音频数据给声音。
- en: We must create and fill a `FMOD_CREATESOUNDEXINFO` structure with a few details
    regarding the audio data that we will be submitting, such as the sampling rate,
    format, and number of channels, as well as a pointer to the function that will
    provide the data itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建并填充一个`FMOD_CREATESOUNDEXINFO`结构，其中包含关于我们将提交的音频数据的一些细节，例如采样率、格式和声道数，以及一个指向提供数据本身的函数的指针。
- en: 'For all of our examples, we will work with a sampling rate of 44100 Hz, use
    the 16-bit PCM format, and have two channels (stereo). Read the comments for more
    information about each attribute:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有的示例，我们将使用44100 Hz的采样率，使用16位PCM格式，并且有两个声道（立体声）。阅读有关每个属性的注释以获取更多信息：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we create a looping, streaming sound, specifying the `FMOD_OPENUSER`
    mode, and passing it the sound info structure to the third parameter of `createStream()`.
    We can then begin playing the sound as normal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个循环流声音，指定`FMOD_OPENUSER`模式，并将声音信息结构传递给`createStream()`的第三个参数。然后我们可以像平常一样开始播放声音：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As long as the sound is playing, the audio engine invokes our callback function
    periodically to get the data it requires. The callback function must follow a
    certain signature that takes three parameters, a reference to the sound object
    that we created, an array for us to write the audio data into, and the total number
    of bytes that we should write to the data array. It should also return `FMOD_OK`
    at the end.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 只要声音正在播放，音频引擎就会定期调用我们的回调函数，以获取所需的数据。回调函数必须遵循特定的签名，接受三个参数，即我们创建的声音对象的引用，一个用于写入音频数据的数组，以及我们应该写入数据数组的总字节数。它还应该在最后返回`FMOD_OK`。
- en: The data array is defined by a pointer to void (`void*`) because, as we discussed
    earlier, there are many different formats for the data to be in. It is up to us
    to cast the data array to the correct format. Since we created the sound with
    `FMOD_SOUND_FORMAT_PCM16`, we have to cast the data array to a `signed short*`
    first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据数组由指向void（`void*`）的指针定义，因为正如我们之前讨论的，数据有许多不同的格式。我们需要将数据数组转换为正确的格式。由于我们使用`FMOD_SOUND_FORMAT_PCM16`创建了声音，因此我们首先必须将数据数组转换为`signed
    short*`。
- en: Another important detail is that the `length` parameter specifies the amount
    of data to write to the array in `bytes`, but each of our samples is a `signed
    short`, which occupy 2 bytes each. Therefore, we should make sure to write no
    more than `length/2` samples to the data array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的细节是`length`参数指定要写入数组的数据量（以字节为单位），但我们的每个样本都是`signed short`，占用2个字节。因此，我们应该确保不要向数据数组写入超过`length/2`个样本。
- en: 'Here is an example of a callback function, which outputs silence by filling
    the entire audio buffer with zeros. Not very interesting, but it should serve
    as a good starting point:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个回调函数的示例，通过用零填充整个音频缓冲区来输出静音。虽然不是很有趣，但它应该作为一个很好的起点：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Loading a sound
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载声音
- en: The most common way to get audio data is to read it from an audio file. However,
    as we have seen before, there are many different audio file formats, and reading
    the audio data out of them is usually a non-trivial task. This is particularly
    true with compressed audio file formats, which require decoding the audio data
    using some algorithm, before we can use it in our application. In general, it
    is usually better to use an audio engine, or an external library, to read the
    contents of an audio file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 获取音频数据的最常见方式是从音频文件中读取。然而，正如我们之前所看到的，有许多不同的音频文件格式，从中读取音频数据通常是一个非平凡的任务。这在压缩的音频文件格式中尤其如此，这些格式需要使用某种算法对音频数据进行解码，然后才能在我们的应用程序中使用。一般来说，最好使用音频引擎或外部库来读取音频文件的内容。
- en: For educational purposes, we will be reading the audio data from a WAV file.
    We will, however, work under the assumption that the WAV file we read from is
    in the canonical form (that is, it contains only a format and a data subchunk,
    in that order) and that the audio data is stored without any compression. Under
    these conditions, we know where all of the data is stored, and can simply index
    into the file to read it. That is certainly not the case for every WAV file, which
    would require a more complex loading sequence.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 出于教育目的，我们将从WAV文件中读取音频数据。然而，我们将在假设我们从中读取的WAV文件是以规范形式（即，它仅包含格式和数据子块，按顺序排列），并且音频数据存储在没有任何压缩的情况下。在这些条件下，我们知道所有数据都存储在哪里，并且可以简单地索引到文件中进行读取。对于每个WAV文件来说，情况肯定不是这样，这将需要更复杂的加载顺序。
- en: The WAV file format builds upon the more generic RIFF file format. A RIFF file
    is divided into chunks of data. Every chunk begins with a 4-character ASCII identifier,
    and a 32-bit integer describing how much data is stored in the chunk. Next, there
    is the actual data of the chunk, which varies depending on the type of the chunk.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WAV文件格式建立在更通用的RIFF文件格式之上。RIFF文件被分成数据块。每个块以一个4个字符的ASCII标识符开头，然后是一个描述块中存储了多少数据的32位整数。接下来是块的实际数据，这取决于块的类型。
- en: 'All WAV files contain at least the following three chunks (with two of them
    considered subchunks of the first):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有WAV文件至少包含以下三个块（其中两个被认为是第一个的子块）：
- en: 'A **RIFF** chunk containing the string literal: WAVE'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含字符串字面值：WAVE的**RIFF**块
- en: A **Format** subchunk containing information about the audio file
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含有关音频文件信息的**格式**子块
- en: A **Data** subchunk containing the actual audio data
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含实际音频数据的**数据**子块
- en: 'The following figure shows the contents of a WAV file in a canonical format.
    Note that if the file contains compressed data, the format subchunk can contain
    more data than the one shown in the following figure. It is also possible for
    other chunks to appear in the file, or in a different order:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了标准格式的WAV文件的内容。请注意，如果文件包含压缩数据，则格式子块可能包含比下图中所示更多的数据。文件中也可能出现其他块，或以不同的顺序出现：
- en: '![Loading a sound](img/9099OT_06_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![加载声音](img/9099OT_06_01.jpg)'
- en: Now that we have a table listing the contents of a canonical WAV file, let us
    create a class to load and store all of the information that we care about from
    the file (that is, the sampling rate, bit depth, number of channels, and the audio
    data).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个列出标准WAV文件内容的表格，让我们创建一个类来加载和存储我们关心的文件信息（即采样率、位深度、声道数和音频数据）。
- en: 'Keeping in line with what we used previously in FMOD, we will name this class
    `MySound`. For simplicity, every member of the class has public accessibility,
    although we could provide a few accessor methods instead, while making the data
    private:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前在FMOD中使用的相同，我们将把这个类命名为`MySound`。为简单起见，类的每个成员都具有公共可访问性，尽管我们可以提供一些访问器方法，同时将数据设置为私有：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the constructor, we open the audio file and read all of the relevant data
    into the member variables. Note that there is no error checking anywhere, and
    that this will only work under the conditions described earlier:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们打开音频文件并将所有相关数据读入成员变量。请注意，任何地方都没有错误检查，这只能在前面描述的条件下工作：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The destructor takes care of cleaning up the memory allocated in the constructor
    to hold the audio data:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数负责清理在构造函数中分配的用于保存音频数据的内存：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Playing a sound
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放声音
- en: Now that we have all of the audio data stored in memory, we are ready to begin
    playing the sound. In order to do so we must essentially take each of the values
    stored in the data array, and send them in order to the audio card (in our case,
    using the callback method that we created earlier).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有音频数据存储在内存中，我们准备开始播放声音。为了做到这一点，我们必须基本上取出数据数组中存储的每个值，并按顺序发送到音频卡（在我们的情况下，使用之前创建的回调方法）。
- en: 'If the format, sampling rate, and number of channels in the audio data are
    the same as the output, then this process is as simple as copying values from
    one array to another. However, the process becomes significantly more complicated
    if they differ in any way, in particular:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果音频数据的格式、采样率和声道数与输出相同，则这个过程就像是将一个数组的值复制到另一个数组中一样简单。然而，如果它们在任何方面有所不同，这个过程就会变得复杂得多，特别是：
- en: If our audio data has a different sampling rate from the output, we need to
    resample the data so that it matches the sampling rate of the output, or the sound
    will play at a different rate than we expect. This operation is not trivial, and
    is beyond the scope of this chapter.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的音频数据的采样率与输出不同，我们需要对数据进行重新采样，使其与输出的采样率匹配，否则声音将以我们预期的不同速率播放。这个操作并不是简单的，超出了本章的范围。
- en: If our audio data is in a different format from the output, we need to convert
    the data to the new format first. For example, we may need to convert a 32-bit
    floating point sample into a signed 16-bit integer sample. This is not that complicated,
    and mostly requires scaling numbers from one range to another.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的音频数据与输出的格式不同，我们需要先将数据转换为新的格式。例如，我们可能需要将32位浮点样本转换为有符号16位整数样本。这并不复杂，大部分是需要将数字从一个范围缩放到另一个范围。
- en: If our audio data has different number of channels from the output, we have
    to adapt the signal to the new number of channels. Adapting a mono signal to a
    stereo is easy, as we simply need to send a duplicate of the data to both channels.
    Adapting a stereo signal to mono usually involves adding the values of both channels
    together, and dividing the result by two.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的音频数据与输出的声道数不同，我们必须使信号适应新的声道数。将单声道信号适应为立体声很容易，因为我们只需要将数据的副本发送到两个声道。将立体声信号适应为单声道通常涉及将两个声道的值相加，然后将结果除以二。
- en: 'For the sake of keeping our examples simple, we will assume that the audio
    data has a very specific format, so that no conversions need to take place:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的示例简单，我们将假设音频数据具有非常特定的格式，因此不需要进行转换：
- en: It has a sampling rate of 44100 Hz, the same as the output
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有44100 Hz的采样率，与输出相同
- en: It is stored in the PCM16 audio format, the same as the output
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以PCM16音频格式存储，与输出相同
- en: It only has one channel (mono) of data, although the output has two channels
    (stereo), so that we can see an example of how to implement panning
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只有一个声道（单声道）的数据，尽管输出有两个声道（立体声），这样我们可以看到如何实现声道平移的示例
- en: Under these conditions, we only need two things to play the sound, we need to
    be able to access the audio data, and we need a variable to keep a track of the
    current position within the sound (that is, how many samples we have written so
    far) so that we know which sample to write next. Once the position becomes larger
    than the number of samples in the data, it means that the sound has finished playing,
    and we interrupt the process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些条件下，我们只需要两样东西来播放声音，我们需要能够访问音频数据，还需要一个变量来跟踪声音的当前位置（即我们已经写了多少个样本），这样我们就知道下一个要写入的样本是哪一个。一旦位置变得大于数据中的样本数，就意味着声音已经播放完毕，我们中断这个过程。
- en: 'Like we did with the sound class, let us also create a class to encapsulate
    all of the data and behaviors related to playing sounds, which we will name `MyChannel`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对声音类所做的那样，让我们也创建一个类来封装与播放声音相关的所有数据和行为，我们将其命名为`MyChannel`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the channels in FMOD, we should be able to reuse a single channel object
    for different sounds. Therefore, instead of taking a sound object in the constructor,
    we only assign the sound object inside the `Play()` method. This method also resets
    the position value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像FMOD中的通道一样，我们应该能够为不同的声音重复使用单个通道对象。因此，我们在构造函数中不再需要一个声音对象，而是在`Play()`方法中分配声音对象。这个方法也重置了位置值：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Stop()` method, on the other hand, simply clears the reference to the
    sound object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Stop()`方法只是简单地清除了对声音对象的引用：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the most important portion of the process occurs inside the `WriteSoundData()`
    method, which will be called from within the audio callback. This method takes
    two parameters, the array of PCM samples to write to and the size of this array.
    Notice that this method already expects the `data` array to be in the correct
    format, instead of the `void*` provided to the audio callback. The `count` also
    refers to the number of samples in the array, not the number of bytes. There are
    comments in the code explaining what each line is doing:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个过程中最重要的部分发生在`WriteSoundData()`方法中，这个方法将从音频回调中调用。这个方法接受两个参数，要写入的PCM样本数组和这个数组的大小。请注意，这个方法已经期望`data`数组以正确的格式存在，而不是提供给音频回调的`void*`。`count`也指的是数组中的样本数，而不是字节数。代码中有注释解释每一行在做什么：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using this class, our audio callback becomes a lot simpler, as we can delegate
    most of the work to the `WriteSoundData()` method of the channel. In the following
    example there is a single channel object, so we can only play one sound at a time,
    but later we will see how easy it is to add support for multiple sounds, as well
    as several other features:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，我们的音频回调变得简单得多，因为我们可以将大部分工作委托给通道的`WriteSoundData()`方法。在下面的例子中，有一个单一的通道对象，所以我们一次只能播放一个声音，但稍后我们将看到添加支持多个声音以及其他几个功能是多么容易：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that in the preceding example, we begin by clearing the audio buffer
    with `memset`. This is necessary because we will not be filling the output with
    values once the sound stops playing, and FMOD does not clear the buffer automatically
    between callback calls.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，我们首先用`memset`清除了音频缓冲区。这是必要的，因为一旦声音停止播放，我们将不会填充输出值，并且FMOD不会在回调调用之间自动清除缓冲区。
- en: 'Playing a sound with this architecture is as simple as instantiating the sound,
    and asking the channel object to play it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种架构播放声音就像实例化声音一样简单，并要求通道对象播放它：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pausing a sound
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停声音
- en: Now that we have the basic functionality for playing sounds implemented using
    the `MySound` and `MyChannel` classes, we can begin adding more features to it.
    We will start with the simplest of all, pausing the sound.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用`MySound`和`MyChannel`类实现了播放声音的基本功能，我们可以开始为其添加更多功能。我们将从最简单的开始，暂停声音。
- en: 'We must add a member variable to hold the pause state, and some methods to
    modify it. We must also remember to initialize this value to `false` inside the
    constructor, and inside the `Play()` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加一个成员变量来保存暂停状态，并一些方法来修改它。我们还必须记住在构造函数中将这个值初始化为`false`，并在`Play()`方法中初始化：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, all we have to do is add a very simple condition at the beginning of the
    `WriteSoundData()` method so that it does nothing when the sound is paused. That
    is as simple as it gets!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要在`WriteSoundData()`方法的开头添加一个非常简单的条件，这样当声音暂停时它就不会做任何事情。这就是最简单的方式了！
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Looping a sound
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环播放声音
- en: 'The next feature that we will implement is the ability to endlessly make a
    sound loop. Like the ability to pause a sound, this is also quite trivial to implement.
    We begin by repeating everything that we did for pausing, but for looping instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一个功能是无限循环播放声音的能力。像暂停声音的能力一样，这也是相当容易实现的。我们首先重复为暂停所做的一切，但是为了循环播放：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the `WriteSoundData()` method, in the part where we used to detect if
    the sound had already reached the end, we first check if the loop variable is
    set to `true`, and if that is the case, we set the position back to the beginning
    instead of stopping the sound:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WriteSoundData()`方法中，我们曾经用来检测声音是否已经到达结尾的部分，我们首先检查循环变量是否设置为`true`，如果是这样，我们将位置设置回到开头，而不是停止声音：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Changing volume
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变音量
- en: The next few features that we will implement involve modifying the values that
    are sent to the output. Changing the volume of a sound is probably the simplest
    of them, as it only requires a multiplication.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一个功能涉及修改发送到输出的值。改变声音的音量可能是其中最简单的，因为它只需要一个乘法。
- en: 'Let us start by creating a variable and some methods to control the volume.
    The volume will be stored as a floating point number between 0 (silence) and 1
    (full volume). The `SetVolume()` method makes sure that the value is always inside
    this range. We should also reset the volume to 1 whenever a sound begins playing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个变量和一些方法来控制音量。音量将以0（静音）到1（最大音量）之间的浮点数存储。`SetVolume()`方法确保该值始终在此范围内。每当声音开始播放时，我们还应该将音量重置为1：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to play the sound at this volume, all we have to do is multiply each
    of the original values in the audio data by the value of the volume variable,
    before we write them to the output. Because the volume variable is a floating
    point number, we need to cast the result back to PCM16 after the multiplication:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种音量播放声音，我们只需将音频数据中的每个原始值乘以音量变量的值，然后将它们写入输出。由于音量变量是浮点数，所以在乘法后需要将结果强制转换回PCM16：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Changing pitch
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变音高
- en: Changing the pitch of a sound is slightly more complicated than changing its
    volume. The most basic way to modify the pitch of a sound (although the speed
    of the sound is also affected) is to control how fast we advance the position
    value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 改变声音的音高比改变音量稍微复杂一些。修改声音音高的最基本方法（尽管声音的速度也会受到影响）是控制我们如何快速推进位置值。
- en: So far, we have used a `position` variable that was an integer, and incremented
    its value by a full unit every time. In order to provide pitch control, we will
    change that variable to a floating point number, and add a `pitch` variable that
    determines how much to increment the position.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了一个整数`position`变量，并且每次增加一个完整的单位。为了提供音高控制，我们将把该变量更改为浮点数，并添加一个`pitch`变量，用于确定增加位置的数量。
- en: 'By default, the `pitch` variable will have a value of 1, which plays the sound
    at the normal pitch. A value of 2 will double the frequency of the sound, making
    it sound one octave higher, and a value of 0.5 will halve the frequency of the
    sound, making it sound one octave lower. For practical reasons, we will limit
    its value to the range between 0.25 (two octaves below the original sound) and
    4 (two octaves above the original sound):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pitch`变量的值将为1，这将以正常音高播放声音。值为2将使声音的频率加倍，使其听起来高一个八度，而值为0.5将使声音的频率减半，使其听起来低一个八度。出于实际原因，我们将限制其值在0.25（原始声音以下两个八度）和4（原始声音以上两个八度）之间：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside our `WriteSoundData()` method, we increment the position variable by
    the pitch amount. The hardest part in the process is how to convert the `position`
    variable that is now a floating point number, back into an array index. The simplest
    solution is to use a simple cast, which truncates the value to an integer, and
    that is what we will use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`WriteSoundData()`方法中，我们按照音高量增加位置变量。在这个过程中最困难的部分是如何将现在是浮点数的`position`变量转换回数组索引。最简单的解决方案是使用简单的强制转换，将值截断为整数，这就是我们将使用的方法：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, the truncation from the cast can introduce distortion into the signal.
    For example, if the position is advancing at a slower pace than normal, it will
    have many values that are between whole numbers, but because of the truncation
    from the cast, we will get the same value written multiple times to the output,
    instead of a flowing sound wave.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从强制转换中的截断可能会引入信号失真。例如，如果位置的前进速度比正常慢，那么会有许多值介于整数之间，但由于从强制转换中的截断，我们将多次将相同的值写入输出，而不是流动的声波。
- en: A better approach is to use linear interpolation (or another type of interpolation)
    to calculate a value for the sample that takes the surrounding values and the
    fractional portion of the position into consideration. For example, using linear
    interpolation, if the position was 2.25, instead of outputting the value of `data[2]`,
    we would output a mix of 75 percent of the value of `data[2]` with 25 percent
    of the value of `data[3]` instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用线性插值（或其他类型的插值）来计算采样值，考虑周围的值和位置的小数部分。例如，使用线性插值，如果位置是2.25，我们将输出`data[2]`值的75%与`data[3]`值的25%的混合。
- en: Changing panning
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变声音定位
- en: There are many different approaches to implement stereo panning of a sound.
    In this section, we will cover a simple approach that works just by modifying
    the volumes of the left and right channels independently.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以实现声音的立体声定位。在本节中，我们将介绍一种简单的方法，通过独立修改左右声道的音量来实现。
- en: 'Before actually doing any calculations, let us prepare the class for panning
    by adding two private variables, `leftGain` and `rightGain`, to store the volumes
    of each channel:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际进行任何计算之前，让我们通过添加两个私有变量`leftGain`和`rightGain`来为声音定位做准备，以存储每个声道的音量：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, inside the `WriteSoundData()` method, we can apply these gains to the
    data before writing it to the output, just as we did for the volume before. Naturally,
    we should only apply the values of `leftGain` and `rightGain` to their respective
    channels. In addition, because we need to cast to PCM16 after applying the gains,
    there is no need to keep the cast from earlier:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`WriteSoundData()`方法中，我们可以在将数据写入输出之前应用这些增益，就像我们之前对音量做的那样。当然，我们应该只将`leftGain`和`rightGain`的值应用于各自的声道。此外，因为我们需要在应用增益后转换为PCM16，所以没有必要保留之前的强制转换：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With these out of the way, we now need to create a floating point variable
    called `pan` and some methods to modify it. The `pan` variable should take values
    between -1 (full left) and 1 (full right). Whenever the value of `pan` changes,
    we call the private `UpdatePan()` method to calculate new values for `leftGain`
    and `rightGain`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为`pan`的浮点变量，并编写一些方法来修改它。`pan`变量的值应在-1（完全左侧）和1（完全右侧）之间。每当`pan`的值发生变化时，我们调用私有的`UpdatePan()`方法来计算`leftGain`和`rightGain`的新值。
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All that is left is to write the `UpdatePan()` method. There are a few different
    formulas to calculate the gain values for stereo panning. One of the simplest
    approaches is to use linear panning, where each channel starts at 0 percent volume
    in one side, and increases linearly to 100 percent on the other side, while being
    at 50 percent in the middle. Here is an implementation of linear panning:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是编写`UpdatePan()`方法。有几种不同的公式可以计算立体声定位的增益值。其中最简单的方法之一是使用线性定位，其中每个声道从一侧的0%音量开始，线性增加到另一侧的100%，同时在中间处于50%。以下是线性定位的实现：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another approach, which usually yields a smoother transition when panning,
    is to use **constant-power panning**, where the volume of each channel follows
    a circular curve, with the volume of each channel being roughly 71 percent in
    the middle. We have already discussed constant-power panning before, since it
    is the type of panning used by FMOD for panning mono sounds. Without going into
    details about the math involved, here is an implementation of constant-power panning:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，通常在平移时产生更平滑的过渡，是使用**恒功率平移**，其中每个通道的音量遵循圆形曲线，每个通道的音量在中间大约为71%。我们之前已经讨论过恒功率平移，因为它是FMOD用于平移单声道声音的平移类型。在不涉及数学细节的情况下，这是恒功率平移的实现：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Mixing multiple sounds
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合多个声音
- en: 'So far, we have only been playing one sound at a time, but it is quite easy
    to extend what we are doing to play multiple sounds at once. The act of combining
    multiple sounds into a single output is known as **audio mixing**, and it can
    be implemented by adding all the audio signals together, and clamping the result
    to the available range. Looking at our `WriteSoundData()` method, all we need
    to do is change the lines of code that write to the data array, so that the samples
    are added to the existing values, instead of completely replacing them:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只播放了一个声音，但很容易扩展我们正在做的事情以同时播放多个声音。将多个声音组合成单个输出的行为称为**音频混合**，可以通过将所有音频信号相加并将结果夹紧到可用范围来实现。查看我们的`WriteSoundData()`方法，我们只需要更改写入数据数组的代码行，以便将样本添加到现有值中，而不是完全替换它们：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our main application, instead of having a single channel instance, we can
    now create multiple instances, and call `WriteSoundData()` on all of them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主应用程序中，我们现在可以创建多个实例，然后对它们所有调用`WriteSoundData()`：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Implementing a delay effect
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现延迟效果
- en: 'We have already discussed, back in [Chapter 4](ch04.html "Chapter 4. 3D Audio"),
    *3D Audio*, that DSP effects are algorithms that modify the audio data to achieve
    a certain goal. Now we will see an example of how to implement a simple delay
    effect. The way a basic delay effect works, is to keep a separate buffer of data,
    and store the audio data that has already played in it. The size of the buffer
    determines how long it takes between the original sound and its echo plays. Then,
    we simply need to mix the audio data that is playing, with a portion of the old
    signal that was stored in the buffer, which produces a delay. Let us examine the
    following `MyDelay` class definition, which encapsulates the effect:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](ch04.html "第4章 3D音频")*3D音频*中讨论过，DSP效果是修改音频数据以实现特定目标的算法。现在我们将看到如何实现一个简单的延迟效果的示例。基本延迟效果的工作方式是保留一个单独的数据缓冲区，并将已经播放的音频数据存储在其中。缓冲区的大小决定了原始声音和其回声之间的时间间隔。然后，我们只需要将正在播放的音频数据与存储在缓冲区中的旧信号的一部分混合，这样就产生了延迟。让我们来看一下封装了这种效果的`MyDelay`类定义：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `MyDelay` class constructor takes two parameters, `time` and `decay`. The
    first parameter controls how many seconds it takes between the sound and the first
    echo occurs. The second parameter controls how much energy is lost during each
    echo.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyDelay`类构造函数接受两个参数，`time`和`decay`。第一个参数控制声音和第一个回声之间的时间间隔。第二个参数控制每个回声中丢失的能量量。'
- en: 'The class stores a buffer of PCM16 samples, which we initialize in the constructor
    so that it can store the equivalent of `time` seconds of data at a sampling rate
    of 44100 Hz. This buffer starts completely filled with zeros. It also contains
    a `position` variable that will be used to cycle through the buffer:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该类存储PCM16样本的缓冲区，我们在构造函数中初始化它，以便以44100 Hz的采样率存储相当于`time`秒的数据。该缓冲区最初完全填充为零。它还包含一个`position`变量，将用于循环遍历缓冲区：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The destructor deletes all the data allocated in the constructor:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数删除构造函数中分配的所有数据：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the `WriteSoundData()` method does all of the work. It begins by taking
    each sample in the output, and mixing it with a portion of the sample stored in
    the buffer at the current position. Next, we take this new value and write it
    back to the output, as well as to the buffer. Finally, we increment the position
    variable to the next sample, wrapping around the end of the buffer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WriteSoundData()`方法完成所有工作。它首先获取输出中的每个样本，并将其与当前位置缓冲区中存储的样本的一部分混合。接下来，我们将这个新值写回到输出，以及缓冲区。最后，我们将位置变量递增到下一个样本，绕过缓冲区的末尾：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To test this effect out, simply create an instance of it in the main application,
    and call the `WriteSoundData()` method at the end of the audio callback:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这种效果，只需在主应用程序中创建一个实例，并在音频回调结束时调用`WriteSoundData()`方法：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Synthesizing a sound
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合成声音
- en: Before we end this chapter, it is also worth realizing that not every sound
    needs to come from an audio file. It is also possible to generate sounds from
    scratch, using only mathematical formulas. We call this process, **sound synthesis**,
    and there are entire books just about this subject.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，值得意识到并不是每种声音都需要来自音频文件。也可以仅使用数学公式从头开始生成声音。我们称这个过程为**声音合成**，有整本书专门讨论这个主题。
- en: 'Certain sound waves are particularly common in sound synthesis because of how
    easy they are to calculate. We have already talked about one of these sound waves
    before, the sine wave. Other common examples are the square wave, the sawtooth
    wave, and the triangle wave, all represented in the following figure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些声波的计算方式非常简单，它们在声音合成中特别常见。我们之前已经讨论过其中一种声波，即正弦波。其他常见的例子包括方波、锯齿波和三角波，都在下图中表示：
- en: '![Synthesizing a sound](img/9099OT_06_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![合成声音](img/9099OT_06_02.jpg)'
- en: 'We will now see how to synthesize each of these sound waves, by creating a
    class `MyOscillator`. The use case for this class is pretty much the same as the
    `MyDelay` class described earlier; just create an instance of it, and call the
    `WriteSoundData()` method from the audio callback to make it play:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何合成这些声波，通过创建一个名为`MyOscillator`的类。这个类的用例与之前描述的`MyDelay`类几乎相同；只需创建一个实例，并在音频回调中调用`WriteSoundData（）`方法使其播放：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The class contains three member variables, `phase`, which describes how far
    we are along the sound wave, `increment`, which depends on the frequency of the
    sound and describes how much we should advance the phase between each sample,
    and `volume`, which can be changed through the `SetVolume()` method. Note that
    we are using doubles for everything instead of floats, as sound synthesis tends
    to require more precision in its calculations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个成员变量，`phase`描述了我们沿着声波走了多远，`increment`取决于声音的频率，并描述了我们在每个样本之间应该推进相位的量，`volume`可以通过`SetVolume（）`方法进行更改。请注意，我们在所有地方都使用双精度而不是浮点数，因为声音合成在计算中需要更多的精度。
- en: 'All that the class constructor does is initialize the phase to zero, the volume
    to one, and set the increment by calling `SetFrequency()` with a default value
    of 440 Hz:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数所做的一切就是将相位初始化为零，音量初始化为一，并通过使用默认值440赫兹调用`SetFrequency（）`来设置增量：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `SetFrequency()` method calculates the correct increment value using the
    following formula. In this case, we have hardcoded the sampling rate to be 44100
    Hz, but there could be a parameter to control the sampling rate:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetFrequency（）`方法使用以下公式计算正确的增量值。在这种情况下，我们已经将采样率硬编码为44100赫兹，但可以有一个参数来控制采样率：'
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As usual, most of the work is handled inside the `WriteSoundData()` method.
    First, we calculate the value of the sound wave for the current phase, and scale
    it into the correct range for a PCM16 sample (by multiplying by 32767, which is
    the highest number that can be stored in a signed short). Next, we write this
    result to the audio output, mixing it with anything that was already there. Finally,
    we increment the phase, and wrap it so that it always stays within the 0 to 2
    PI range:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，大部分工作都在`WriteSoundData（）`方法中处理。首先，我们计算当前相位的声波值，并将其缩放到PCM16样本的正确范围（通过乘以32767，这是可以存储在有符号短整数中的最大数）。接下来，我们将这个结果写入音频输出，将其与已经存在的任何内容混合。最后，我们增加相位，并将其包装起来，使其始终保持在0到2
    PI的范围内：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The actual audio data is generated by the `sine_wave()` method highlighted
    in the previous code. All that this method does is call the standard `sin()` function
    on the phase value and return the result. We can easily swap this method with
    any of the following implementations, depending on the type of sound wave that
    we want to play:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的音频数据是由前面代码中突出显示的`sine_wave（）`方法生成的。这个方法所做的就是在相位值上调用标准的`sin（）`函数并返回结果。我们可以根据我们想要播放的声波类型，轻松地用以下任何一种实现来替换这个方法：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to work directly with the bits and bytes of
    audio data, how to load the audio data from a canonical WAV file, how to play
    and control audio data using only low-level operations, how to implement a simple
    delay effect, and how to synthesize some basic sound waves.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到如何直接处理音频数据的位和字节，如何从经典的WAV文件中加载音频数据，如何仅使用低级操作播放和控制音频数据，如何实现简单的延迟效果，以及如何合成一些基本的声波。
