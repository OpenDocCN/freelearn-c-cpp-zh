- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: C++ Is Beautiful
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 美丽
- en: '*According to the mirror on* *the wall*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据墙上的镜子*'
- en: Dear reader. In this chapter, we won’t be focusing on teaching you specific
    concepts, techniques, or practical skills. Instead, our goal is to guide you through
    a different kind of experience, one that allows you to step back from the details
    and immerse yourself in the aesthetic aspects of coding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的读者。在本章中，我们不会专注于教授你特定的概念、技术或实用技能。相反，我们的目标是引导你体验一种不同类型的学习，这种体验让你能够从细节中抽身，沉浸于编码的美学方面。
- en: This chapter is designed to inspire you to see code in a new light, to recognize
    the patterns, symmetry, and even the poetry that can emerge when we write code
    with thoughtfulness and care.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在激发你以新的眼光看待代码，认识到当我们深思熟虑、细致入微地编写代码时，可能出现的模式、对称性，甚至诗意。
- en: Beauty is a unique and personal experience because it arises from the intricate
    interplay of individual perception, emotional resonance, cultural influences,
    and personal identity. Each person interprets beauty through their own sensory
    and cognitive filters, shaped by their life experiences, memories, and cultural
    background. Emotional connections, mood, and personal taste further influence
    what one finds beautiful, making it a deeply subjective experience that reflects
    one’s unique perspective on the world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 美是一种独特且个人的体验，因为它源于个人感知、情感共鸣、文化影响和个人身份的复杂相互作用。每个人都会通过自己的感官和认知过滤器来解释美，这些过滤器由他们的生活经历、记忆和文化背景塑造。情感联系、情绪和个人品味进一步影响一个人认为什么是美的，使其成为一种深刻的主观体验，反映了一个人对世界的独特视角。
- en: Some may find beauty in the fiery hues of a sunset over a Mediterranean island,
    while others might appreciate the crisp, cold allure of Scandinavian fjords. It
    is all personal.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能在地中海岛屿上日落时那炽热的色彩中找到美，而其他人可能欣赏斯堪的纳维亚峡湾的清新、寒冷的魅力。这完全是个人感受。
- en: So, while there may not be concrete lessons or objectives in this chapter, it
    offers a unique opportunity to connect with the craft of coding on a more emotional
    and intellectual level. Through this journey, we hope you’ll come to see code
    not just as a means to an end but as something inherently beautiful in its own
    right.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然本章可能没有具体的课程或目标，但它提供了一个独特的机会，让你在更情感和智力层面上与编码技艺建立联系。通过这次旅程，我们希望你能从新的角度看待代码，认识到当我们深思熟虑、细致入微地编写代码时，可能出现的模式、对称性，甚至诗意。
- en: 'In this chapter, you will experience that there is:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将体验到：
- en: Nothing new to learn here...
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里没有新的东西要学习...
- en: '... except the appreciation of beauty...'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...除了欣赏美...'
- en: '... while crafting code with techniques in mind that may disqualify you from
    ever sitting in front of a keyboard while writing professional code in an enterprise
    environment'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...在构思代码时，可能会使你在企业环境中无法坐在键盘前编写专业代码的技术'
- en: In search of beauty
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找美
- en: Each programming language is a unique work of art, beautifully distinct in its
    design, philosophy, and the possibilities it offers; just as diverse are the programmers
    who use them, each bringing their own preferences, creativity, and personality
    to the craft.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都是一件独特的艺术作品，其设计、哲学和提供的可能性都各具特色；使用它们的程序员也同样多样，每个人都将自己的偏好、创造力和个性带入这门技艺。
- en: Some developers are drawn to the elegant simplicity and structure of Python,
    relishing the clarity and expressiveness that its neatly organized whitespace
    brings to their code. Others, however, find their joy in languages such as Forth,
    where they can freely push and pop the stack with precision having full control
    and conciseness of such low-level manipulation, while seemingly enjoying the challenge
    of constructing powerful systems with minimalistic syntax. Now really, is there
    anyone using Forth anymore?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者被 Python 的优雅简洁和结构所吸引，享受着其整洁的空白字符带来的清晰和表现力。然而，其他人却在像 Forth 这样的语言中找到快乐，他们可以精确地自由地推和弹出堆栈，拥有对这种低级操作的全权和简洁性，同时似乎享受着用简约语法构建强大系统的挑战。现在，真的还有人使用
    Forth 吗？
- en: And then there are the bold adventurers who embrace the enigmatic world of Lisp,
    using its infamous long list of insipid and stubborn parenthesis. To these programmers,
    the apparent monotony of the syntax is a gateway to a rich and expressive metaprogramming
    landscape, where they can manipulate code as data in ways that feel almost alchemical,
    not to mention that they have direct access to Emacs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有那些拥抱Lisp神秘世界的勇敢冒险家，他们使用其臭名昭著的长列表的乏味和固执的括号。对这些程序员来说，语法的明显单调是通往一个丰富和表达性元编程景观的门户，在那里他们可以像处理数据一样处理代码，这种感觉几乎像是炼金术，更不用说他们可以直接访问Emacs了。
- en: 'Last but not least, there are those of us, the tribe of C++ programmers, who
    think the magical beauty of a program can fully be expressed by the following
    line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们中的一些人，C++程序员的部落，认为一个程序的魅力可以完全通过以下一行表达出来：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What more C++ beauty do we need on this planet? A line of code that looks like
    a series of winking smileys, and in the end, it returns the lucky number seven
    to the caller. There is not a huge amount of technicality lying in the preceding
    code, just a plain lambda returning a number, and to confuse you, dear reader,
    we have used the trailing returning type for the **main** , because why not?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个星球上还需要C++的哪些美感呢？一行代码看起来像一系列眨眼的笑脸，最后，它将幸运数字七返回给调用者。在这段代码中并没有多少技术性，只是一行简单的lambda函数返回一个数字，为了迷惑你，亲爱的读者，我们使用了**main**的尾随返回类型，因为为什么不呢？
- en: Also, to add an even higher level of obscurity to our snippet, we have used,
    just for the sheer beauty of them, the infamous C++ digraphs. Unfortunately for
    them, the notorious trigraphs were deprecated in C++17 so we could not use them
    to spice up our code snippet. Actually, we could have used them, but we just wouldn’t
    dare.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了给我们的代码片段增加更高的神秘感，我们仅仅是为了它们的纯粹美感，使用了臭名昭著的C++二分图。不幸的是，C++17中已经弃用了臭名昭著的三分图，所以我们无法使用它们来为我们的代码片段增添色彩。实际上，我们可以使用它们，但我们只是不敢。
- en: All that mayhem and confusion done in one line only. The real question that
    comes is can we make this even more cumbersome beautiful for you, dear reader,
    to read? And certainly, the answer to this certain question is a certain yes.
    And can we build it? Yes, we can! Almost... But firstly, we just have to get rid
    of the numbers, because hey...
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的混乱和困惑都在一行中完成。真正的问题是，我们能否让这对你，亲爱的读者，读起来更加繁琐而美丽？当然，这个问题的答案是一个确定的“是”。我们能构建它吗？是的，我们可以！几乎...但首先，我们必须要摆脱数字，因为嘿...
- en: Who likes numbers?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁喜欢数字？
- en: '... or more specifically, who needs numbers? Numbers can be highly confusing
    to people due to their abstract nature, and the fact that we don’t really need
    them in our everyday mundane life, which does not require higher-level thinking
    and the ability to grasp symbolic representations, makes them almost meaningless.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '...或者更具体地说，谁需要数字呢？由于数字具有抽象的本质，以及在我们日常生活中我们并不真正需要它们，这些数字不需要高级思维和掌握符号表示的能力，这使得它们几乎毫无意义。'
- en: Maybe this is why some tribes in the Amazon jungle didn’t even invent all of
    them (yes, I’m pointing at you, Munduruku tribe [1](B22235_09.xhtml#footnote-025)
    ). You have notions for none, one, two, up to five ... and then many. If it is
    enough for you, I can live with it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这就是为什么亚马逊丛林中的一些部落甚至没有发明出所有这些（是的，我在指你们，Munduruku部落[1](B22235_09.xhtml#footnote-025)）。你们有零、一、二、三、四、五的概念，然后是许多。如果这对你来说足够了，我可以接受。
- en: '[1](B22235_09.xhtml#footnote-025-backlink) https://www.amazon.com/Alexs-Adventures-Numberland-Alex-Bellos/dp/1408809591'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_09.xhtml#footnote-025-backlink) https://www.amazon.com/Alexs-Adventures-Numberland-Alex-Bellos/dp/1408809591'
- en: 'Let’s apply the ancient wisdom of the Amerindian people to our programming
    quest: to come up with the most beautiful C++ code snippet the world can see today.
    So, let’s get rid of those pesky numbers, keeping just 0 and 1 (for the sake of
    the almighty bits so that they don’t feel excluded), and let’s go tribal with
    the following code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用美洲原住民的古老智慧到我们的编程探索中：创造出世界上今天可以看到的最美的C++代码片段。所以，让我们摆脱那些讨厌的数字，只保留0和1（为了至高无上的比特，这样它们就不会感到被排除在外），然后让我们用以下代码片段来部落化：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Oh, the sheer beauty of it. It brings tears of joy to our eyes, doesn’t it?
    Arguably, some picky programmers might have made some vitriolic comments about
    readability, maintainability, standard compliance, and so on... especially if
    they are using Microsoft’s (tiny, squishy) C++ compiler, which flatly refuses
    to compile the preceding code. But we rejoice with trembling that we made one
    of the compilers break, while all the other major players happily digest it and
    compile.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，它的纯粹之美。它让我们眼中充满喜悦的泪水，不是吗？可以说，一些挑剔的程序员可能会对可读性、可维护性、标准合规性等方面发表一些尖酸刻薄的评论……尤其是如果他们使用的是微软的（小巧，柔软的）C++编译器，它明确拒绝编译前面的代码。但我们在颤抖中欣喜若狂，因为我们让其中一个编译器崩溃了，而所有其他的主要玩家都愉快地消化了它并编译了它。
- en: But the code unfortunately contains a lot of duplicates, which we don’t really
    like. Nor do we need duplicates, so we should also get rid of at least one of
    them, shouldn’t we? Or all of them, why not?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，代码中包含了很多重复的部分，我们并不真的喜欢。我们也不需要重复，所以我们也应该至少去掉其中的一部分，不是吗？或者全部去掉，为什么不呢？
- en: Because that is the real beauty of the C++ language. The capability to always
    redefine yourself, to provide a better version of the code at all costs, not considering
    the sacrifice made. Death to readability. Death to maintainability! Long live
    the free code of chaos, mayhem, and confusion!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这就是C++语言的真正之美。总是能够重新定义自己，不惜一切代价提供更好的代码版本，不考虑所做出的牺牲。可读性万岁。可维护性万岁！自由代码的混乱、混乱和困惑万岁！
- en: 'So, brave warriors, our quest has been laid, prepare arms (I mean keyboards),
    and let’s save those bytes, just like the following code snippet shows us:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，勇敢的战士们，我们的任务已经布置，准备好武器（我的意思是键盘），让我们像以下代码片段所展示的那样，节省那些字节吧：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just look again at the sheer beauty of it. Again, the power of C++ shines through
    the dark clouds, like a thousand supernovae, and makes possible everything our
    heart desires, such as replacing a key element of the language, for example, the
    **return** keyword with a **$** sign. Not that it is part of the standard character
    set the language specified as the valid character set, but we will have a discussion
    about this, and some bears, a little bit later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看它的纯粹之美。再次，C++的力量穿透了乌云，就像一千颗超新星，使得我们心中的所有愿望都成为可能，比如替换语言的一个关键元素，例如，将**return**关键字替换为**$**符号。这并不是因为它属于语言指定的有效字符集的一部分，但稍后我们将会讨论这个问题，以及一些熊，一点点。
- en: 'But look at the bright side of the glass. At least we did not write the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但看看玻璃的明亮面。至少我们没有写出以下代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have to admit, we contemplated writing it and adding it to the book, but
    after a glimpse at the future, we just thought that everything has its limits.
    Even the resilience of the most seasoned developers when it comes to nonsense
    (but regardless, fun) code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，我们曾考虑过写下来并把它加到书中，但展望未来后，我们只是认为一切都有其极限。即使是经验最丰富的开发者面对无意义的（但无论如何，有趣）代码时，也会感到痛苦。
- en: This is highly possibly the most evil piece of code we will present in this
    book because the level of evilness is comparable to the level of pain felt when
    you try to write a properly parenthesized Lisp program. Because what happens if
    you remove a parenthesis because there are too many, or, God forbid, add another
    one because you think it’d be a great idea? Believe me, dear reader, just don’t
    dare.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本书中展示的最邪恶的代码片段之一，因为邪恶的程度与尝试编写一个正确括号的Lisp程序时所感受到的痛苦程度相当。因为如果你因为括号太多而移除一个括号，或者，天哪，如果你认为再加一个括号是个好主意而添加一个括号，会发生什么？相信我，亲爱的读者，不要冒险。
- en: So, please pretend that the preceding code is not in the book, and even if it
    is, you haven’t seen it. And even if you have seen it, you wouldn’t dare change
    the number of parenthesis in it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请假装前面的代码不在书中，即使它在书中，你也没有看到它。即使你看到了，你也不敢改变其中的括号数量。
- en: Enough of the piece of evilness; now it is time to return to our previous code,
    which is in the competition for the most beautiful piece of C++ code this book
    can present.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的邪恶代码了；现在是我们回到之前代码的时候了，它是本书可以展示的最美的C++代码片段的竞争者。
- en: 'If only we could make it just a bit shorter, more concise, and more expressive,
    such as removing those ugly **define** and replacing them with something that
    expresses more beauty, more ... like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够让它变得更短一些，更简洁，更富有表现力，比如移除那些丑陋的**define**，并用一些更能表达美的事物来替换它们，就像以下这样：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Oh, it really hurts my eyes. Sorry about it, and apologies beforehand, but we
    cannot make this any more beautiful without incurring a very serious headache
    for the authors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这真的刺痛了我的眼睛。对此表示歉意，并提前道歉，但我们无法在不让作者头疼的情况下使它变得更美。
- en: While reading this, we suddenly realize that just because there is already an
    obfuscated C code competition, we don’t really need to overdo its C++ counterpart.
    C++ by definition can be obfuscated enough without us actively trying to obfuscate
    it, but now, after presenting the preceding chimera, we actively owe an apology
    and an explanation to you, dear reader (on the other end, chimeras can be beautiful
    too; you just need to have the right eye for it).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这段内容时，我们突然意识到，尽管已经有了混淆C代码竞赛，我们实际上并不需要过度混淆其C++对应版本。根据定义，C++可以足够混淆，无需我们主动尝试混淆它，但现在，在展示了前面的奇美拉之后，我们主动向你，亲爱的读者（在另一端，奇美拉也可以很美；你只需要有正确的眼光）道歉和解释。
- en: 'The first substantial observation we are concluding is that this code cannot
    be compiled by itself. If we try it, GCC will give errors, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出的第一个重要观察结果是，这段代码不能单独编译。如果我们尝试编译它，GCC会报错，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'ICC will complain, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ICC会报错，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'MSVC does not like that, as you can see:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MSVC不喜欢这样，正如你所见：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clang isn’t successful either:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Clang也没有成功：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, basically, the compilers have commonly agreed that they cannot agree on
    a common error message or a reason for failure, but at least none of them can
    compile that piece of code. There are a few very on-the-point error messages,
    such as **#** is possibly the result of a macro expansion (but the author of these
    lines would like to see a macro that expands to **#** because **#define D #**
    is just not working regardless of **D** ) or another message concerning that stray
    **%:** in the program.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '所以，基本上，编译器普遍同意它们不能就一个共同的错误消息或失败原因达成一致，但至少它们中的任何一个都不能编译那块代码。有一些非常具体的错误消息，比如**#**可能是宏展开的结果（但这些行的作者希望看到一个展开为**#**的宏，因为**#define
    D #**不管**D**是什么都不起作用）或者关于程序中那个散乱的**%:**的另一个消息。'
- en: All this macro expansion and so on just leads us in the direction of macros.
    If you, dear reader, are not familiar with C or C++ macros, please go grab a book
    on them, such as *The C++ Programming Language* , by Bjarne Stroustrop, because
    this book (the one you are reading right now) deals only with macros of mythical
    fame, while that one (i.e., *the* C++ book written by the father and creator of
    the language) teaches you to not to use them unless you really, really have to.
    And even then, sparsely.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些宏展开等等只是引导我们走向宏。如果你，亲爱的读者，不熟悉C或C++宏，请去拿一本关于它们的书，比如Bjarne Stroustrop的*《C++编程语言》*，因为这本书（你现在正在读的这本书）只涉及神话般的宏，而那本书（即由语言的父亲和创造者编写的C++书）教你除非你真的、真的需要，否则不要使用它们。即使那样，也要稀疏地使用。
- en: 'But back to our code. All decent compilers have the means to provide the result
    of the preprocessed C++ file, so let’s examine it for our program. By invoking
    **g++** with the **–E** flag (or Clang with the same flag, or MSVC with the **/P**
    flag if you use the command line for it; otherwise, they will be accessible from
    the build directory of the project you are working on in Visual Studio), we get
    the following listing:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到我们的代码。所有正规的编译器都有提供预处理后的C++文件结果的能力，所以让我们检查一下我们的程序。通过使用带有**–E**标志的**g++**（或者使用相同标志的Clang；如果你使用命令行，则MSVC使用**/P**标志；否则，它们将可以从你在Visual
    Studio中工作的项目的构建目录中访问），我们得到以下列表：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We just show what is necessary for now and skip the compiler-specific line info,
    which is also added to the preprocessed output. So, as we can see, the preprocessed
    output looks like a very valid C++ file (albeit not very readable)... to our surprise,
    however, we can see several **define** directives actively present in the file.
    They are prepended by the **%:** symbol, which, after digraph substitution, will
    be transformed into the hashtag symbol ( **#** ) and yield a valid program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只展示必要的部分，并跳过编译器特定的行信息，这些信息也被添加到预处理输出中。所以，正如我们所见，预处理输出看起来像一个非常有效的C++文件（尽管不太易读）...然而，令我们惊讶的是，我们可以在文件中看到几个活跃的**define**指令。它们以**%:**符号开头，经过双字符替换后，将转换为井号符号（**#**）并产生一个有效的程序。
- en: In order to further understand what is happening here, we must understand how
    the compiler deals with macros.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解这里发生的事情，我们必须了解编译器如何处理宏。
- en: The C compiler (and of course C++ too) expands macros through a methodical process
    managed by the preprocessor, beginning with tokenizing the source code and identifying
    macros for substitution. For object-like macros, a straightforward text replacement
    occurs, whereas function-like macros involve substituting the arguments provided
    in the macro invocation. Function-like macros (the ones that have a pair of parentheses)
    undergo an argument prescan, where macro arguments are fully expanded before being
    substituted into the macro body. This prescan ensures that nested macro calls
    within arguments are expanded correctly and that the final macro body is rescanned
    to catch any further macros for expansion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C 编译器（当然也包括 C++）通过预处理器管理的方法过程展开宏，从对源代码进行标记化和识别替换宏开始。对于对象型宏，发生直接的文本替换，而函数型宏则涉及替换宏调用中提供的参数。函数型宏（那些有一对括号的宏）在参数预扫描过程中进行替换，其中宏参数在替换到宏体之前被完全展开。这个预扫描确保了参数内的嵌套宏调用被正确展开，并且最终宏体被重新扫描以捕获任何进一步的宏进行展开。
- en: 'However, the prescan does not apply when arguments are stringized or concatenated,
    nor does it affect macros that are already marked as ineligible for re-expansion.
    This behavior mandates that in order to have proper expansion, we force the compiler
    to do a second pass on the concatenation macros, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当参数被字符串化或连接时，预扫描不适用，它也不会影响已被标记为不可重新展开的宏。这种行为要求为了正确展开，我们必须强制编译器对连接宏进行第二次遍历，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding snippet ensures that all the required arguments are properly expanded.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段确保了所有必要的参数都得到了正确的展开。
- en: Special macros such as **__LINE__** and **__TIME__** are treated uniquely to
    prevent further unintended expansions. After all expansions are complete, the
    preprocessor ensures that no eligible macros are left unexpanded before passing
    the final code to the compiler. This comprehensive process ensures that macros
    are expanded efficiently and correctly, even in complex scenarios involving nested
    macros and stringification operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊宏如 **__LINE__** 和 **__TIME__** 被独特处理，以防止进一步的意外展开。在所有展开完成后，预处理器确保在将最终代码传递给编译器之前，没有可展开的宏被遗漏。这一全面的过程确保了宏能够高效且正确地展开，即使在涉及嵌套宏和字符串化操作的复杂场景中也是如此。
- en: Now that we have tried to explain how the macro substitution works on a level
    that is not that obvious for the first time, it is time to get back and finally
    compile our program. As you can remember, the preprocessed source still contained
    some statements that had **define** directives in them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试解释了宏替换是如何在一个对初学者来说并不那么明显的情况下工作的，现在是时候回到我们的程序并最终编译它了。正如你所能记得的，预处理后的源代码仍然包含一些包含
    **define** 指令的语句。
- en: Now, armed with this knowledge, we will reveal an arcane piece of knowledge
    to you, dear reader. In the end, this is a book about the mysticism of C++. This
    arcane piece of knowledge is something called **double preprocessing** . Before
    continuing, however, a small detour on how the compiler deals with your code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，带着这些知识，我们将向你，亲爱的读者，揭示一个神秘的知识点。最终，这是一本关于 C++ 神秘主义的书。这个神秘的知识点被称为**双重预处理**。在继续之前，我们先简要了解一下编译器是如何处理你的代码的。
- en: During the initial stages of compiling a C++ source file, the compiler first
    undergoes preprocessing and compilation. In the preprocessing phase, the compiler
    expands macros (just like we have presented previously), processes conditional
    compilation directives ( **#ifdef** , **#ifndef** , etc.), includes header files,
    and removes comments, resulting in a complete translation unit with all external
    files and macros fully resolved. Following this, in the compilation phase, the
    preprocessed code is broken down into tokens during a phase called lexical analysis,
    which are then checked against the language’s syntax rules to construct a **parse
    tree** or **abstract syntax** **tree** ( **AST** ).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译 C++ 源文件的初始阶段，编译器首先进行预处理和编译。在预处理阶段，编译器展开宏（就像我们之前所展示的那样），处理条件编译指令（**#ifdef**、**#ifndef**
    等），包含头文件，并移除注释，从而生成一个包含所有外部文件和宏已完全解析的完整翻译单元。随后，在编译阶段，预处理后的代码在称为词法分析的阶段被分解成标记，然后根据语言的语法规则进行检查，以构建**解析树**或**抽象语法树**（**AST**）。
- en: 'This is followed by the phase called semantic analysis, where the compiler
    verifies the correct usage of types, variables, and functions, and potentially
    performs early optimizations. Finally, the compiler translates the AST into an
    **intermediate representation** ( **IR** ), setting the stage for further optimization
    and eventual machine code generation, but this is way out of the topics covered
    in this book. However, we would like to direct those of you who are interested
    in this topic to the famous “Dragon book”, also known as *Compilers: Principles,
    Techniques, and Tools* , by Alfred Aho, Jeffrey Ullman, Ravi Sethi, and Monica
    Lam. That is the go-to book for every programmer interested in developing a compiler,
    or just simply interested in learning about the techniques.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是语义分析阶段，编译器会验证类型、变量和函数的正确使用，并可能进行早期优化。最后，编译器将抽象语法树（AST）转换为**中间表示**（**IR**），为后续优化和最终机器代码生成做好准备，但这超出了本书所涵盖的主题。然而，我们愿意将那些对此话题感兴趣的人引导到著名的“龙书”，也称为《编译原理、技术和工具》，由Alfred
    Aho、Jeffrey Ullman、Ravi Sethi和Monica Lam所著。这是每个对开发编译器感兴趣或只是对学习这些技术感兴趣的程序员必读的书。
- en: But back to our double preprocessing technique. By using this technique, we
    will pass in the previous preprocessed source file into a compiler, using a technique
    known in Linux as piping and on Windows as hacking.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到我们的双重预处理技术。通过使用这项技术，我们将之前的预处理源文件传递给编译器，使用Linux中称为管道技术，在Windows中称为黑客技术的技巧。
- en: 'The following is the Windows command that accomplishes this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Windows上完成此操作的命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first part is producing the preprocessed file, which, in Visual C++ land,
    usually has the **.i** extension and the second part will take the preprocessed
    output, place it in **test.i** , and compile it as a C++ file (the **/Tp** switch
    is responsible for this). The result of this is the expected **test.exe** , which,
    after execution, performs exactly as desired.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是生成预处理文件，在Visual C++领域，通常具有**.i**扩展名，第二部分将预处理输出放置在**test.i**中，并将其作为C++文件编译（**/Tp**开关负责此操作）。结果是预期的**test.exe**，执行后正好符合预期。
- en: 'Under Linux, the sequence of commands is also very similar:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下，命令序列也非常相似：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first part, before the pipe, produces the preprocessed code using **clang++**
    , which, using Linux pipe magic, is sent into **g++** , because why not ☺. For
    this simple scenario, it wouldn’t have mattered if we had used the other way around,
    because these two compilers go hand in hand and they share the basic command-line
    options, such as **–x c++** to specify that the code it would compile is some
    sort of C++ code, or the version of the C++ standard this code complies to. The
    most important argument to the second compiler call is the last **-** sign, which
    tells the compiler to read the code from the stdin, instead of a file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道之前的第一部分，使用**clang++**生成预处理代码，利用Linux管道魔法，将其发送到**g++**，因为为什么不呢 ☺。在这个简单场景中，如果我们反过来使用，也不会有任何区别，因为这两个编译器是相辅相成的，它们共享基本的命令行选项，例如**–x
    c++**来指定要编译的代码是某种C++代码，或者代码遵循的C++标准版本。第二个编译器调用最重要的参数是最后的**-**符号，它告诉编译器从stdin读取代码，而不是从文件中读取。
- en: And that’s it. Using this arcane technique, we can compile code that we thought
    would be impossible, but... please don’t use it. This code is marginal insanity;
    it is presented just because this book is about unconventional, mythical techniques,
    targeting the advanced C++ programmer community, so don’t let this piece ruin
    your programming style, or scare you away from the keyboard. We wouldn’t want
    to lose our readers halfway through the book. Instead of focusing on this, in
    the upcoming chapter, let’s occupy our minds with sheer nothingness.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。使用这种神秘的技巧，我们可以编译我们认为不可能的代码，但...请不要使用它。这段代码近乎疯狂；它之所以被展示出来，仅仅是因为这本书是关于非常规、神话般的技术，针对的是高级C++程序员社区，所以不要让这部分内容破坏你的编程风格，或者让你远离键盘。我们不想让读者在书的中途就放弃。相反，在接下来的章节中，让我们把心思放在纯粹的虚无上。
- en: The definition of zero
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零的定义
- en: Zero is unique among numbers. The concept was present in ancient Egypt, and
    traces of it were found in ancient Babylon as a placeholder in their number system,
    but it wasn’t treated as a true number at that point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 零在数字中是独一无二的。这个概念在古埃及就已经存在，而且在古巴比伦的数字系统中找到了它的痕迹，作为占位符，但那时并没有将其视为真正的数字。
- en: The ancient Greeks have had some resentment towards it because, regardless that
    they knew its importance, initially, due to some philosophical constraints, they
    didn’t use it as a proper number, because not, to be or not to be, but how can
    nothing be, that was the question in the ancient Agora.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 古希腊人对它有所反感，因为他们虽然最初知道其重要性，但由于一些哲学限制，他们最初并没有将其作为合适的数字使用，因为不是，存在与否，而是如何使无成为可能，这是古代市场中的问题。
- en: The breakthrough came in India around the 5th century CE when mathematician
    Brahmagupta defined zero as a number and established rules for its arithmetic
    use. This concept spread to the Islamic world, notably through the works of Al-Khwarizmi,
    and then to Europe, where Fibonacci played a key role in its adoption in the 12th
    century. Thank you, Wikipedia.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 突破发生在公元5世纪左右的印度，当时数学家布拉马古普塔将零定义为数字，并为其算术使用确立了规则。这一概念通过阿尔-花拉子米等人的作品传播到伊斯兰世界，然后传到欧洲，其中斐波那契在12世纪对其采纳发挥了关键作用。感谢维基百科。
- en: 'Zero has several important properties: it is the additive identity, meaning
    adding zero to any number leaves the number unchanged. Multiplying any number
    by zero results in zero, and division by zero is undefined. Zero is an even number
    and serves as a neutral element on the number line, being neither positive nor
    negative. In exponents, raising zero to any positive power gives zero, while any
    non-zero number raised to the power of zero equals one.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 零有几个重要的属性：它是加法恒等元，意味着将零加到任何数字上都不会改变该数字。任何数字乘以零的结果都是零，而除以零是未定义的。零是一个偶数，在数轴上作为中性元素，既不是正数也不是负数。在指数中，零的任何正数次幂都是零，而任何非零数的零次幂等于一。
- en: These properties make zero fundamental in mathematics, and with this, we can
    all agree that zero is one of the most important (if not the most important) numbers
    that ever existed; its place is up right next to π, or *e* , or *i* , which we
    all know is the square root of all evil, or –1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性使零在数学中成为基本元素，因此我们可以一致认为零是历史上最重要的（如果不是最重要的）数字之一；它的位置紧挨着π，或*e*，或*i*，这是我们所有人都知道的，是所有邪恶的平方根，或-1。
- en: 'Now we have presented concrete proof that there is no other number like zero,
    we also give the following statement: C++ is a unique language. In its latest
    iteration, as of 2024, at the current time, in C++, there are six different ways
    to initialize a value to zero, honoring the fact that zero is the most important
    number. Ever. Just see the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提供了没有其他数字像零这样的具体证据，我们也给出以下声明：C++是一种独特的语言。在其最新的迭代版本中，截至2024年，在当前的C++中，有六种不同的方式将值初始化为零，以纪念零是最重要的数字。看看以下内容：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s break it down, line by line, as there are not that many lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分解，因为行数并不多：
- en: '**int z;** – Here, a global variable, **z** , of the **int** type is declared.
    Since it’s a global variable, it is automatically initialized to **0** by the
    compiler (if a global **int** variable isn’t explicitly initialized, it defaults
    to zero). This is something we can trust.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int z;** – 这里，一个全局变量**z**被声明为**int**类型。由于它是全局变量，编译器会自动将其初始化为**0**（如果全局**int**变量没有明确初始化，则默认为零）。这是我们值得信赖的。'
- en: '**int z1 = 0;** – Copy initialization. The **z1** variable is declared as an
    **int** type and initialized to **0** using copy initialization. This involves
    assigning the value of **0** to **z1** after it is created.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int z1 = 0;** – 复制初始化。**z1**变量被声明为**int**类型，并使用复制初始化设置为**0**。这涉及到在创建后将其值赋给**z1**。'
- en: '**int z2(0);** – Direct initialization. The **z2** variable is declared and
    initialized to **0** using direct initialization, which involves passing the value
    of **0** directly to the constructor of the **int** type. Not that it has any,
    but you get the idea.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int z2(0);** – 直接初始化。**z2**变量被声明并使用直接初始化设置为**0**，这涉及到直接将**0**的值传递给**int**类型的构造函数。虽然它没有其他含义，但你可以理解这个概念。'
- en: '**int z3{0};** – Brace initialization (uniform initialization). The **z3**
    variable is declared and initialized to **0** using brace initialization. It helps
    prevent issues such as narrowing conversions and provides a consistent syntax
    for initializing different types. This is a peculiar initialization, and we will
    get back to this syntax a bit later in the next chapter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int z3{0};** – 花括号初始化（统一初始化）。**z3**变量被声明并使用花括号初始化设置为**0**。这有助于防止诸如窄化转换等问题，并为初始化不同类型提供一致的语法。这是一种特殊的初始化，我们将在下一章稍后回到这种语法。'
- en: '**int z4 = {0};** – Copy list initialization. The **z4** variable is declared
    and initialized to **0** using copy list initialization, a combination of copy
    initialization and brace initialization. It’s similar to **z3** but explicitly
    uses the assignment syntax, and when we talk about simple things such as numbers,
    there is really no difference.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int z4 = {0};** – 复制列表初始化。变量 **z4** 使用复制列表初始化声明并初始化为 **0**，这是一种复制初始化和花括号初始化的组合。它与
    **z3** 类似，但明确使用了赋值语法，当我们谈论像数字这样的简单事物时，实际上并没有什么区别。'
- en: '**int z5{};** – Value initialization. The **z5** variable is initialized using
    empty braces, **{}** , known as value initialization. For fundamental types such
    as **int** , this results in **z5** being initialized to **0** . This method is
    often used to ensure that a variable is zero-initialized without explicitly assigning
    a value.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int z5{};** – 值初始化。变量 **z5** 使用空花括号 **{}** 初始化，这被称为值初始化。对于像 **int** 这样的基本类型，这会导致
    **z5** 被初始化为 **0**。这种方法通常用于确保变量被零初始化，而无需显式分配值。'
- en: 'Isn’t it beautiful, the amount of consideration that was put into making a
    variable correspond to the number zero? So, one might just ask: why are the local
    variables of C++ not initialized to zero (or their default value), just in case?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样考虑，让变量对应于数字零的数量，难道不美吗？所以，人们可能会问：为什么C++的局部变量不是初始化为零（或其默认值）？
- en: The answer to this question is partly historical and partly pragmatic. Since
    C++ is based on C, and C was designed to be as close to the metal (silicone) as
    possible, the compiler did not waste precious processor cycles to initialize a
    value to their default value, if at some stage later it was used to set to a different
    value needed by the programmer. Elementary, dear reader, as one of the most famous
    detectives would say.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案部分是历史的，部分是实用的。由于 C++ 基于C语言，而C语言被设计得尽可能接近金属（硅），编译器不会浪费宝贵的处理器周期来初始化一个值为其默认值，如果后来它被用来设置程序员需要的不同值。亲爱的读者，正如一位最著名的侦探所说，这是基本的。
- en: Last but not least, without me providing any more details, I really hope you
    have recognized the most vexing parse in **int z6();** .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，没有我提供更多细节，我真的希望你已经识别出 **int z6();** 中的“最令人头疼的解析”。
- en: The “most vexing parse” is a term used to describe a specific issue in C++ involving
    the declaration of objects that can be misinterpreted by the compiler due to ambiguities
    in the syntax. It usually arises when you declare a variable using parentheses,
    which can sometimes be interpreted as a function declaration rather than a variable
    definition, just like in our specific example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: “最令人头疼的解析”是一个用来描述C++中特定问题的术语，这个问题涉及到由于语法中的歧义，编译器可能会误解对象声明的声明。它通常发生在你使用括号声明变量时，这有时可能被解释为函数声明而不是变量定义，就像在我们的具体例子中一样。
- en: A parenthesis concerning parentheses
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于括号的旁白
- en: Now that we are here, we have to mention that there were quite a lot of mentions
    of parenthesis in this chapter. So, we are presenting possibly the most important
    pair of parentheses you can encounter during the course of this book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这里，我们必须提到，在这一章中提到了很多关于括号的内容。因此，我们在这里展示的是你在这本书的阅读过程中可能会遇到的最重要的一对括号。
- en: 'Please look at the following two functions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下两个函数：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Those two functions look almost identical, except for the tiny pair of parentheses
    around the **return** value. But the presence of those two parentheses makes the
    biggest difference. The weird-looking **decltype(auto)** introduced in C++14 is
    a type specifier that combines the functionality of **decltype** with automatic
    type deduction, allowing you to declare a variable with a type that is determined
    by the expression it is initialized with, while also retaining certain properties
    of that expression. Unlike **auto** , which deduces types based on value categories,
    **decltype(auto)** retains the value category (e.g., reference or non-reference)
    of the expression it is based on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数看起来几乎相同，除了围绕 **return** 值的微小括号对。但这两个括号的存在造成了最大的区别。C++14中引入的看起来很奇怪的 **decltype(auto)**
    是一个类型说明符，它结合了 **decltype** 的功能和自动类型推导，允许你声明一个变量，其类型由初始化它的表达式确定，同时保留该表达式的某些属性。与基于值类别推导类型的
    **auto** 不同，**decltype(auto)** 保留了基于的表达式的值类别（例如，引用或非引用）。
- en: More mundanely, the function number returns an **int** , while the function
    reference returns **int&** .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更平凡的是，函数number返回一个 **int**，而函数reference返回 **int&**。
- en: 'In order to verify the correctness of what we previously wrote, the following
    code snippets can be of great help:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们之前所写的正确性，以下代码片段可以提供极大的帮助：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code snippet examines the return type provided by the **number**
    function. As the name hastily suggests, it will return, well... a number. When
    compiled with MSVC and executed, the following is the output of the code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段检查了**number**函数提供的返回类型。正如其名匆忙暗示的那样，它将返回，嗯...一个数字。当使用MSVC编译并执行时，以下是代码的输出：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The other compilers also have the same behavior, except they do not print out
    the full type of the variable, because **gcc** and **clang** for the **int** type
    just return a single **i** and that wouldn’t have been so spectacular.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编译器也有相同的行为，只是它们不会打印出变量的完整类型，因为**gcc**和**clang**对于**int**类型只返回一个**i**，这不会那么引人注目。
- en: 'Now, let’s examine the following sequence of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查以下代码序列：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is almost identical to the one before this, except that it uses the **reference**
    method instead of **number** . Not surprisingly, the result of the execution is
    (again, appealing to MSVC) as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与之前的完全相同，只是它使用**reference**方法而不是**number**。不出所料，执行的结果（再次，引用MSVC）如下：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, with the preceding code, we have just proved that a pair of extra parentheses
    combined with **decltype(auto)** can provide some spectacular outcomes. Be warned.
    Let’s say we omit **decltype** , such as in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用前面的代码，我们刚刚证明了成对额外的括号与**decltype(auto)**结合可以提供一些惊人的结果。警告一下。假设我们省略了**decltype**，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The compiler then ignores the parentheses and just returns a normal number.
    The C++ standard specifies this behavior in the **[dcl.type.decltype]** section
    and the authors warmly recommend reading through it, in order to have a full understanding
    of what happens behind the scenes and a valid reasoning for it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器随后忽略括号，只返回一个正常的数字。C++标准在**[dcl.type.decltype]**部分指定了这种行为，作者强烈建议阅读它，以便全面了解幕后发生的事情以及合理的推理。
- en: Now, because we are C++ programmers, always in pursuit of speed, high-quality,
    and clear code, you could ask why we had to duplicate the code to identify whether
    we have a reference or not. Wouldn’t it have been perfectly valid to write something
    like the following?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们都是C++程序员，总是追求速度、高质量和清晰的代码，你可能会问为什么我们必须重复代码来识别我们是否有引用。难道不能像以下这样写就完全有效吗？
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is almost the same as above-above (above-above is like above, but refers
    to one above before the actual above), except that we have added an extra check
    to verify the type of the reference (and also removed **std::cout** in favor of
    **printf** because it generates much cleaner assembly code, and also put it in
    the body of a function). Indeed, let’s say we put it into this context and call
    the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与上面的一样（上面上面就像上面一样，但指的是实际上面之前的一个上面），除了我们增加了一个额外的检查来验证引用的类型（并且用**printf**代替了**std::cout**，因为它生成更干净的汇编代码，并且将其放在函数体中）。确实，让我们假设我们将其放入这个上下文中并调用以下代码：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We get the correct and expected output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了正确和预期的输出：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As a side note, we get the same result with other, not-that-tiny-and-squishy
    compilers, too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们用其他，不那么小而柔软的编译器也得到了相同的结果。
- en: This function template uses a forwarding reference ( **T&& var** ) to handle
    both **lvalue** and **rvalue** references, making it capable of deducing and preserving
    the reference type of the passed variable. By using the type traits library, we
    check whether **T** is a reference type using **is_reference<T>::value** , and
    further distinguish between **lvalue** and **rvalue** references using **is_lvalue_reference<T>::value**
    .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数模板使用前向引用（**T&& var**）来处理**左值引用**和**右值引用**，使其能够推断并保留传递变量的引用类型。通过使用类型特性库，我们使用**is_reference<T>::value**检查**T**是否是引用类型，并进一步使用**is_lvalue_reference<T>::value**区分**左值引用**和**右值引用**。
- en: If it’s a reference, we print whether it’s an **lvalue** or **rvalue** reference
    along with the type of the variable without the reference using **remove_reference<T>::type**
    .
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个引用，我们使用**remove_reference<T>::type**打印出它是一个**左值引用**还是**右值引用**，以及没有引用的变量的类型。
- en: If it’s not a reference, we directly print the type of the variable. This approach
    works because of the perfect forwarding mechanics in C++, allowing **T** to be
    deduced as the exact type of the passed variable, preserving its reference nature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不是一个引用，我们就直接打印变量的类型。这种方法之所以有效，是因为C++中的完美转发机制，允许**T**被推导为传递变量的确切类型，保留其引用性质。
- en: Please note that it was mandatory to use the forwarding reference, **T&& var**
    ; if we had used just **T var** , it would not work the same way for reference
    types. This is because, in this form, **T** would have been deduced as a non-reference
    type, so **var** inside the function would have been always a copy of the original
    argument, not a reference.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须使用转发引用**T&& var**；如果我们只使用**T var**，它对于引用类型就不会以相同的方式工作。这是因为，在这个形式中，**T**会被推导为非引用类型，所以函数内部的**var**始终是原始参数的副本，而不是引用。
- en: 'As an extra goodie for you, dear reader, here are some extracts of the assembly
    output of one of the compilers (GCC, in our case). You can see how it generates
    two distinct functions, and most importantly, what goes inside those functions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对你这位亲爱的读者的额外礼物，这里有一些编译器（在我们的例子中是GCC）的汇编输出摘录。你可以看到它如何生成两个不同的函数，最重要的是，这些函数内部发生了什么：
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Table 9.1: Comparing the assembly listings of various printType instantiations'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：比较各种printType实例化的汇编列表
- en: We can see two instantiations of the **printType** function for each of the
    types returned by the two functions, and how in each of them the various calls
    to the type traits were successfully implemented at the source code level, thus
    leading to the removal of unnecessary branches. We can also observe the removal
    of the unnecessary strings (nowhere is **"rvalue ref"** found in the generated
    code because the compiler identified that the branch containing it is nowhere
    to be found in the final code).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个函数的**printType**实例化，每个函数返回的类型都有两个，以及在每个实例中，各种类型特性调用都成功地在源代码级别实现，从而消除了不必要的分支。我们还可以观察到不必要的字符串的删除（现在生成的代码中找不到**"rvalue
    ref"**，因为编译器确定包含它的分支在最终代码中无处可寻）。
- en: Isn’t C++ beautiful?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C++难道不美吗？
- en: C++uties
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++uties
- en: It is time that the author of these lines has to admit something. He’s tired
    of ugly code trying to win the C++ beauty contest. Regardless of how hard we try
    to convince ourselves that the code we presented a few sections before is beautiful
    and is worth remembering, well, it is not. It is ugly and horrible, and please
    forget, dear reader, that you ever had to read something like that. Apologies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让这些文字的作者承认一些事情了。他已经厌倦了试图在C++之美竞赛中获胜的丑陋代码。无论我们如何努力说服自己，之前几节中展示的代码是美丽的，值得记住，好吧，它不是。它是丑陋的，令人厌恶的，亲爱的读者，请忘记你曾经不得不阅读这样的东西。抱歉。
- en: From this point on, we solemnly promise that we are up to no more mischief and
    will treat you only with beautiful code. No more ugly macros, no more shady substitutions,
    no more arcane techniques. Just pure, joyful, lovable C++.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们庄严地承诺，我们不会再有任何恶作剧，只会用美丽的代码来对待你。没有更多的丑陋宏，没有更多的可疑替换，没有更多的神秘技巧。只有纯粹、快乐、可爱的C++。
- en: 'As a result of this reinvention of ourselves (as the writer of beautiful C++
    code), we present you the next program, which possibly is the cutest one you can
    get your hands on:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们（作为美丽C++代码的编写者）的自我革新，我们向您展示下一个程序，这可能是你能得到的最好看的程序之一：
- en: '![img](img/B22235_09_01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B22235_09_01.jpg)'
- en: Please bear with us, for the sake of brevity, we have omitted the includes for
    **std::string** , **std::cout** , and **std::unique_ptr** . Who said C++ can’t
    be cute?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请为了简洁，我们省略了**std::string**、**std::cout**和**std::unique_ptr**的包含。谁说C++不能可爱？
- en: But sadly, the preceding code is not widely recognized as being standard C++
    (seemingly, there is no clear consensus among compiler developers on which Unicode
    identifiers to consider valid in the source code, regardless of **[tab:lex.name.allowed]**
    in the latest C++ standard), but not all hope is lost, as GCC accepts it. Maybe
    there was a bear hugger in the ranks of their developers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但遗憾的是，前面的代码并不被广泛认为是标准的C++（似乎编译器开发者之间对于在源代码中应考虑哪些Unicode标识符为有效并没有明确的共识，尽管最新的C++标准中提到了**[tab:lex.name.allowed]**），但并非所有的希望都破灭了，因为GCC接受它。也许在他们开发者队伍中有一个拥抱者。
- en: As a side note, the code presented does not do too much, just feeds some bears
    with their proper meal, considering their nutrition needs, dietary requirements,
    and affiliations with various dietary patterns and current culinary trends present
    in Bearland. Didn’t we deliver a cute program, a possible contender to the winner
    of the most beautiful C++ code?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，展示的代码并没有做太多，只是根据熊的营养需求、饮食要求和与熊国中各种饮食模式和当前烹饪趋势的关联，给熊喂食适当的食物。我们没有交付一个可爱的小程序，一个可能是最美丽C++代码竞赛的获胜者吗？
- en: There are a good number of books we encourage our dear esteemed readers to read,
    if they want their programs to follow common sense guidelines, be readable, stable,
    easily maintainable and up to the latest standards. Sadly none of those books
    detail how to write fun programs, because writing fun programs, or writing programs
    for fun involves a different mindset, and is rarely done for profit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励我们亲爱的尊敬的读者阅读一些书籍，如果他们想让他们的程序遵循常识性指南，易于阅读、稳定、易于维护并符合最新标准。遗憾的是，这些书籍中没有一本详细说明如何编写有趣的程序，因为编写有趣的程序或为了乐趣编写程序涉及不同的思维方式，而且很少为了利润而做。
- en: Programming can be an art form, producing code that surprises and delights,
    having code can include Easter eggs, humorous output, applying playful user interaction,
    or unusual visualizations. Playfulness could be as simple as using emojis as identifiers
    (as in our bear example) or making quirky applications with oddball logic. Fun
    programming often rejects the rigidity of formal practices in favor of creative
    solutions that may be inefficient or overly complex just for the sake of enjoyment,
    such as crafting an obfuscated piece of code, just because we find it to be fun.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编程可以是一种艺术形式，产生令人惊讶和愉悦的代码，拥有代码可以包括彩蛋、幽默的输出，应用俏皮的用户交互或非同寻常的视觉呈现。俏皮可能简单到使用表情符号作为标识符（如我们的熊示例）或制作逻辑古怪的应用程序。有趣的编程通常拒绝正式实践的僵化，转而选择创造性的解决方案，这些解决方案可能只是为了乐趣而不太高效或过于复杂，例如制作一个加密的代码片段，仅仅因为我们觉得它很有趣。
- en: Fun in programming can also come from solving intriguing puzzles or exploring
    unconventional programming paradigms (functional, esoteric languages such as Brainfuck
    or LOLCODE), or building projects purely out of curiosity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的乐趣也可以来自解决引人入胜的谜题或探索非常规的编程范式（如函数式、晦涩的语言如Brainfuck或LOLCODE），或者纯粹出于好奇心来构建项目。
- en: While formal books on “beautiful” or “clean” code emphasize correctness, safety,
    and readability, fun programming opens the door to spontaneity, art, and entertainment,
    so no wonder that our last happening for this chapter is taking part in the last
    one. It is short, it is cute, and it looks like something out of a fairy tale.
    With bears. Because who doesn’t like bears?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于“美观”或“简洁”代码的正式书籍强调正确性、安全性和可读性，但有趣的编程打开了即兴、艺术和娱乐的大门，因此我们本章的最后一项活动就是参与最后一项活动。它很短，很可爱，看起来像是从童话故事中出来的东西。因为有熊。因为谁不喜欢熊呢？
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Not all that is shining is gold, and not every piece of code that seems exciting
    and bears complex features is necessarily of high quality. The allure of shiny,
    intricate code can sometimes overshadow the fundamental qualities that define
    good programming practices. Good, stable code is frequently characterized by its
    straightforwardness and predictability rather than its flair. This type of code
    may seem unremarkable or mundane compared to more fun constructs, but it is precisely
    this simplicity that ensures robustness and ease of understanding. When you have
    to, please try to write boring, simple code, as it will be much easier to read
    in half a year from now, but every time you can afford to, please squeeze in a
    bear or two in your fun side project. Unless you plan to read it, too.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有闪亮的东西都是金子，也并非所有看似令人兴奋且具有复杂功能的代码必然是高质量的。光鲜、复杂的代码有时会掩盖定义良好编程实践的基本品质。好的、稳定的代码通常以其简单性和可预测性为特征，而不是其风格。与更有趣的构造相比，这种类型的代码可能看起来平淡无奇或平凡，但正是这种简单性确保了其健壮性和易于理解。当你不得不这样做时，请尽量编写无聊、简单的代码，因为半年后阅读起来会容易得多，但每次你有机会时，请尽量在你的有趣侧项目中加入一两只熊。除非你也打算阅读它。
- en: In our next chapter, Alex will go on a crusade to advocate the proper use of
    modern C++ libraries, in order to debunk the myth that C++ libraries are also
    stuck in the Stone Age.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，亚历克斯将发起一场十字军东征，倡导正确使用现代C++库，以驳斥C++库也陷入石器时代的神话。
