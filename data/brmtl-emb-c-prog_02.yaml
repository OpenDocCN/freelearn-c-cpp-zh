- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Constructing Peripheral Registers from Memory Addresses
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内存地址构建外设寄存器
- en: '**Bare-metal programming** is all about working directly with the registers
    in the microcontroller without going through a library, allowing us to gain a
    deeper understanding of the microcontroller’s capabilities and limitations. This
    approach enables us to optimize our firmware for speed and efficiency, which are
    two very important parameters in embedded systems where resources are often limited.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**裸机编程**完全是关于直接与微控制器中的寄存器工作，而不通过库，这使我们能够更深入地了解微控制器的功能和限制。这种方法使我们能够优化我们的固件以实现速度和效率，这两个参数在资源通常有限的嵌入式系统中非常重要。'
- en: In this chapter, our journey begins with an exploration of various firmware
    development methodologies, highlighting the different levels of abstraction each
    offers. We then proceed to learn how to identify the ports and pins associated
    with key components on our development board. This step is crucial for establishing
    a proper interface with the microcontroller’s peripherals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的旅程从探索各种固件开发方法开始，突出每种方法提供的不同抽象级别。然后我们继续学习如何识别我们开发板上关键组件相关的端口和引脚。这一步对于与微控制器外设建立适当的接口至关重要。
- en: Next, we delve into defining the addresses of some peripherals using the microcontroller’s
    official documentation. This will allow us to create the addresses of the various
    registers in those peripherals.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨如何使用微控制器的官方文档定义一些外设的地址。这将使我们能够创建那些外设中各种寄存器的地址。
- en: In the latter sections of the chapter, our focus shifts to practical application.
    We will use the register addresses that we’ve created to configure PA5 to activate
    the user **light-emitting diode** (**LED**) of the development board.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们的重点转向实际应用。我们将使用我们创建的寄存器地址来配置PA5，以激活开发板的用户**发光二极管**（LED）。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The different types of firmware development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的固件开发
- en: Locating and understanding the development board’s components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位和理解开发板组件
- en: Defining and creating registers through documentation insights
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过文档洞察定义和创建寄存器
- en: Register manipulation – from configuration to running your first firmware
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器操作 – 从配置到运行您的第一个固件
- en: By the end of this chapter, you will have a solid foundation in both navigating
    and programming STM32 microcontrollers at the register level. You will be equipped
    to write your initial bare-metal firmware, relying solely on information gathered
    from the documentation and the **integrated development** **environment** (**IDE**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将在寄存器级别导航和编程STM32微控制器方面打下坚实的基础。你将准备好编写你的初始裸机固件，仅依靠从文档和**集成开发环境**（IDE）收集的信息。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: The different types of firmware development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的固件开发
- en: 'There are several ways to develop the firmware for a particular microcontroller
    depending on the resources provided by the microcontroller’s manufacturer. When
    it comes to developing firmware for STM32 microcontrollers from **STMicroelectronics**,
    we can use the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微控制器制造商提供的资源，开发特定微控制器的固件有几种方法。当涉及到开发来自**意法半导体**（STMicroelectronics）的STM32微控制器的固件时，我们可以使用以下方法：
- en: '**Hardware Abstraction Layer (HAL)**: This is a library provided by STMicroelectronics.
    It simplifies the process by offering high-level APIs for configuring every aspect
    of the microcontroller. What is great about HAL is its portability. We can write
    code for one STM32 microcontroller, and easily adapt it for another, thanks to
    the uniformity of their APIs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件抽象层 (HAL)**：这是意法半导体提供的一个库。它通过提供配置微控制器每个方面的低级API来简化过程。HAL的伟大之处在于其可移植性。我们可以为某个STM32微控制器编写代码，并轻松地将其适应到另一个微控制器，这得益于它们API的一致性。'
- en: '**Low Layer (LL)**: Also from STMicroelectronics, the LL library is a leaner
    alternative to HAL, offering a faster, more expert-oriented approach that’s closer
    to the hardware.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底层 (LL)**：同样来自意法半导体，LL库是HAL的一个更精简的替代品，提供了一种更快、更专业导向的方法，更接近硬件。'
- en: '**Bare-Metal C programming**: With this approach, we dive right into the hardware,
    accessing the microcontroller’s registers directly using the C language. It’s
    more involved but offers a deeper understanding of the microcontroller’s workings.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裸机C编程**：使用这种方法，我们直接进入硬件，使用C语言直接访问微控制器的寄存器。这更复杂，但提供了对微控制器工作原理的更深入理解。'
- en: '**Assembly language**: This is similar to Bare-Metal C, but instead of C, we
    use assembly language to interact directly with the microcontroller’s registers.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编语言**：这与裸机C类似，但不是使用C语言，而是使用汇编语言直接与微控制器的寄存器交互。'
- en: 'Let’s compare the four firmware development methods we’ve discussed: HAL, LL,
    Bare-Metal C, and assembly language. Each method has its unique style and level
    of abstraction, impacting how we interact with the microcontroller’s hardware.
    We will use the example of configuring a **general-purpose input/output** (**GPIO**)
    pin as an output to illustrate these differences.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下我们讨论过的四种固件开发方法：HAL、LL、裸机C和汇编语言。每种方法都有其独特的风格和抽象级别，影响着我们与微控制器硬件的交互方式。我们将通过配置一个**通用输入/输出**（**GPIO**）引脚作为输出来说明这些差异。
- en: HAL
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HAL
- en: 'The following code snippet demonstrates how to initialize GPIOA pin 5 as an
    output using HAL:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用HAL初始化GPIOA引脚5作为输出：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s analyze the snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个片段：
- en: '`#include "stm32f4xx_hal.h":` This line includes the HAL library specific to
    the STM32F4 series, providing access to the HAL functions and data structures'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "stm32f4xx_hal.h":` 这行代码包含STM32F4系列的HAL库，提供对HAL函数和数据结构的访问'
- en: '`GPIO_InitTypeDef GPIO_InitStruct = {0}:` Here, we declare and initialize an
    instance of the `GPIO_InitTypeDef` structure, which is used to configure the GPIO
    pin properties'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO_InitTypeDef GPIO_InitStruct = {0}:` 这里，我们声明并初始化一个`GPIO_InitTypeDef`结构体实例，该结构体用于配置GPIO引脚属性'
- en: '`__HAL_RCC_GPIOA_CLK_ENABLE()`: This macro call enables the clock for GPIO
    port A, ensuring that the GPIO peripheral is powered and can function'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__HAL_RCC_GPIOA_CLK_ENABLE()`: 此宏调用启用GPIO端口A的时钟，确保GPIO外设供电并可以工作'
- en: '`GPIO_InitStruct.Pin = GPIO_PIN_5:` This line sets the pin to be configured,
    in this case, pin 5 of port A'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO_InitStruct.Pin = GPIO_PIN_5:` 这行代码设置了要配置的引脚，在这种情况下，端口A的5号引脚'
- en: '`GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP:` Over here, we configure the pin
    as an output pin'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP:` 在这里，我们将引脚配置为输出引脚'
- en: '`HAL_GPIO_Init(GPIOA, &GPIO_InitStruct):` Finally, we initialize the GPIO pin
    (PA5) with the configuration settings specified in `GPIO_InitStruct`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAL_GPIO_Init(GPIOA, &GPIO_InitStruct):` 最后，我们使用在`GPIO_InitStruct`中指定的配置设置初始化GPIO引脚（PA5）'
- en: 'This snippet shows the ease and readability of the HAL approach in performing
    common hardware interfacing tasks. We can summarize the benefits and drawbacks
    of the HAL approach as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段展示了HAL方法在执行常见硬件接口任务时的易用性和可读性。我们可以总结HAL方法的优缺点如下：
- en: '**Level of** **abstraction**: High'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象级别**：高'
- en: '**Ease of use**: Easier for beginners due to its high-level abstraction'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：由于其高级抽象，对初学者来说更容易使用'
- en: '**Code verbosity**: More verbose, with several lines of code required for simple
    tasks'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码冗长性**：更冗长，对于简单任务需要多行代码'
- en: '**Portability**: Excellent across different STM32 devices'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：在STM32设备之间表现优异'
- en: '**Performance**: Slightly slower due to additional abstraction layers'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：由于额外的抽象层，略慢'
- en: LL
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LL
- en: 'This is how we initialize GPIOA pin 5 as an output pin using the LL library:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用LL库初始化GPIOA引脚5作为输出引脚：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s break it down, line by line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析：
- en: '`#include "stm32f4xx_ll_bus.h"` and `#include "stm32f4xx_ll_gpio.h"` include
    the necessary LL library files for handling the bus system and GPIO functionality,
    respectively'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "stm32f4xx_ll_bus.h"` 和 `#include "stm32f4xx_ll_gpio.h"` 包含处理总线系统和GPIO功能的必要LL库文件'
- en: '`LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA):` This function call enables
    the clock for GPIO port A'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA):` 此函数调用启用GPIO端口A的时钟'
- en: '`LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT):` Finally, we
    set the mode of GPIOA pin 5 to output mode'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT):` 最后，我们将GPIOA引脚5的模式设置为输出模式'
- en: The LL library provides a more direct and lower-level approach to hardware interaction
    compared to HAL. This is often preferred in scenarios where finer control over
    hardware and performance is required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与HAL相比，LL库提供了更直接、更低级的硬件交互方法。在需要更精细的硬件控制和性能的场景中，这通常更受欢迎。
- en: 'The benefits and drawbacks of the LL approach are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LL方法的优缺点如下：
- en: '**Level of** **abstraction**: Medium'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象级别**：中等'
- en: '**Ease of use**: Moderate, with a balance between abstraction and direct control'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：中等，在抽象和直接控制之间取得平衡'
- en: '**Code verbosity**: Less verbose than HAL, offering a more straightforward
    approach to hardware interaction'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码冗余度**：比HAL更简洁，提供了更直接与硬件交互的方法'
- en: '**Portability**: Good, but slightly less than HAL'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：良好，但略低于HAL'
- en: '**Performance**: Faster than HAL, as it’s closer to the hardware'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：比HAL更快，因为它更接近硬件'
- en: Bare-Metal C
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 裸机C
- en: 'Let’s see how to accomplish the same task using the Bare-Metal C approach:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用裸机C方法完成相同任务：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the bare-metal c snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解裸机C代码片段：
- en: '`#define GPIOA_MODER (*(volatile unsigned long *) (GPIOA_BASE + 0x00))` and
    `#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))` define pointers
    to specific registers within the microcontroller’s memory. `GPIOA_MODER` points
    to the GPIO port A mode register, and `RCC_AHB1ENR` points to the **reset and
    clock control** (**RCC**) AHB1 peripheral clock **enable register** (**ER**).
    The use of the volatile keyword ensures that the compiler treats these as memory-mapped
    registers, preventing optimization-related issues.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define GPIOA_MODER (*(volatile unsigned long *) (GPIOA_BASE + 0x00))` 和 `#define
    RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))` 定义了指向微控制器内存中特定寄存器的指针。`GPIOA_MODER`指向GPIO端口A模式寄存器，而`RCC_AHB1ENR`指向**重置和时钟控制**（**RCC**）AHB1外设时钟**使能寄存器**（**ER**）。使用`volatile`关键字确保编译器将这些视为内存映射寄存器，防止与优化相关的问题。'
- en: '`RCC_AHB1ENR |= (1 << 0)`: This line of code enables the clock for GPIOA. It
    does this by setting the first bit (bit 0) of the `RCC_AHB1ENR` register. The
    bitwise `OR` assignment (`|=`) ensures that only the specified bit is changed
    without altering other bits in the register.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCC_AHB1ENR |= (1 << 0)`: 这行代码启用GPIOA的时钟。它通过设置`RCC_AHB1ENR`寄存器的第一个位（位0）来实现。位或赋值运算符（`|=`）确保只更改指定的位，而不会更改寄存器中的其他位。'
- en: '`GPIOA_MODER |= (1 << 10)`: This line sets PA5 to output mode. In the GPIO
    port mode register (`GPIOA_MODER`), each pin is controlled by two bits. For PA5,
    these are bits 10 and 11 (`MODER5[1:0]`). The code sets bit 10 to `1` (and leaves
    bit 11 as `0`, assuming it was already `0`), configuring PA5 as a general-purpose
    output mode.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOA_MODER |= (1 << 10)`: 这行代码将PA5设置为输出模式。在GPIO端口号模式寄存器（`GPIOA_MODER`）中，每个引脚由两个位控制。对于PA5，这些是位10和11（`MODER5[1:0]`）。代码将位10设置为`1`（并假设位11已经是`0`，将其保留为`0`），将PA5配置为通用输出模式。'
- en: 'With this approach, we can observe the granularity and direct control provided.
    By directly manipulating the microcontroller’s registers, it offers very high
    efficiency and performance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以观察到提供的粒度和直接控制。通过直接操作微控制器的寄存器，它提供了非常高的效率和性能：
- en: '**Level of** **abstraction**: Low'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象级别**：低'
- en: '**Ease of use**: Challenging for beginners, as it requires in-depth hardware
    knowledge'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：对于初学者来说具有挑战性，因为它需要深入了解硬件知识'
- en: '**Code verbosity**: Less verbose, direct'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码冗余度**：更简洁，直接'
- en: '**Portability**: Limited, as the code is often specific to a particular hardware
    setup'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：有限，因为代码通常针对特定的硬件配置'
- en: '**Performance**: Very high, as it allows for direct and optimized hardware
    manipulation'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：非常高，因为它允许直接和优化的硬件操作'
- en: Assembly language
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言
- en: 'Finally, let’s analyze the assembly language implementation for configuring
    PA5 as an output pin:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们分析配置PA5为输出引脚的汇编语言实现：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s break it down:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`EQU GPIOA_MODER`, `0x40020000` and `EQU RCC_AHB1ENR`, `0x40023800` define
    constants for the memory addresses of the GPIOA mode register (`GPIOA_MODER`)
    and the RCC AHB1 peripheral clock ER (`RCC_AHB1ENR`). `''EQU''` is used in assembly
    to equate a label to a value or address.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EQU GPIOA_MODER`, `0x40020000` 和 `EQU RCC_AHB1ENR`, `0x40023800` 定义了GPIOA模式寄存器（`GPIOA_MODER`）和RCC
    AHB1外设时钟ER（`RCC_AHB1ENR`）的内存地址常量。`''EQU''`在汇编中用于将标签等同于值或地址。'
- en: 'The rest of the assembly instructions perform two main tasks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的汇编指令执行两个主要任务：
- en: 'Enable the clock for GPIOA:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用GPIOA的时钟：
- en: '`LDR R0, =RCC_AHB1ENR`: Load the address of the `RCC_AHB1ENR` register into
    the `R0` register'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDR R0, =RCC_AHB1ENR`: 将`RCC_AHB1ENR`寄存器的地址加载到`R0`寄存器'
- en: '`LDR R1, [R0]`: Load the value of the `RCC_AHB1ENR` register into the `R1`
    register'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDR R1, [R0]`: 将`RCC_AHB1ENR`寄存器的值加载到`R1`寄存器'
- en: '`ORR R1, R1, #(1 << 0)`: Perform a bitwise `OR` operation to set bit0 of `R1`,
    turning on the clock for GPIOA'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORR R1, R1, #(1 << 0)`: 执行位或操作以设置`R1`的位0，打开GPIOA的时钟'
- en: '`STR R1, [R0]`: Store the updated value back into the `RCC_AHB1ENR` register'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STR R1, [R0]`：将更新后的值存储回`RCC_AHB1ENR`寄存器'
- en: 'Set PA5 as output:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将PA5设置为输出：
- en: '`LDR R0, =GPIOA_MODER`: Load the address of the `GPIOA_MODER` register into
    `R0`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDR R0, =GPIOA_MODER`：将`GPIOA_MODER`寄存器的地址加载到`R0`'
- en: '`LDR R1, [R0]`: Load the current value of the `GPIOA_MODER` register into `R1`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDR R1, [R0]`：将`GPIOA_MODER`寄存器的当前值加载到`R1`'
- en: '`ORR R1, R1, #(1 << 10)`: Use a bitwise `OR` operation to set bit 10 of `R1`,
    configuring PA5 as an output'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORR R1, R1, #(1 << 10)`：使用位或操作设置`R1`的第10位，将PA5配置为输出'
- en: '`STR R1, [R0]`: Store the updated value back into the `GPIOA_MODER` register'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STR R1, [R0]`：将更新后的值存储回`GPIOA_MODER`寄存器'
- en: The assembly language approach allows for extremely detailed and direct control
    over the microcontroller. We often use this in projects where high performance
    is crucial, and every aspect of the hardware needs to be precisely managed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言方法允许对微控制器进行极其详细和直接的控制。我们经常在需要高性能且每个硬件方面都需要精确管理的项目中使用这种方法。
- en: 'The assembly language approach offers us the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言方法为我们提供了以下功能：
- en: '**Level of** **abstraction**: Lowest'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象级别**：最低'
- en: '**Ease of use**: Most challenging, requiring a thorough understanding of the
    microcontroller’s architecture'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：最具挑战性，需要彻底了解微控制器架构'
- en: '**Code verbosity**: Can be verbose for complex tasks, due to low-level nature'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码冗长性**：对于复杂任务可能很冗长，因为它是低级的'
- en: '**Portability**: Very limited, as it is highly specific to the microcontroller’s
    architecture'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：非常有限，因为它高度特定于微控制器架构'
- en: '**Performance**: Highest, as it allows for the most optimized and direct control
    possible'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：最高，因为它允许进行最优化和直接的控制'
- en: 'The following diagram shows each method and its closeness to the microcontroller’s
    architecture:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了每种方法和其与微控制器架构的接近程度：
- en: '![Figure 2.1: Firmware development methods, arranged in order of proximity  to
    the microcontroller’s architecture](img/B21914_02_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：固件开发方法，按与微控制器架构的接近程度排列](img/B21914_02_01.jpg)'
- en: 'Figure 2.1: Firmware development methods, arranged in order of proximity to
    the microcontroller’s architecture'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：按与微控制器架构的接近程度排列的固件开发方法
- en: Now that we have explored the diverse approaches to firmware development for
    STM32 microcontrollers, we are ready to delve into the realm of bare-metal C programming.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了STM32微控制器固件开发的多种方法，我们准备深入裸机C编程领域。
- en: We will begin our exploration by understanding how the main components of our
    development board are connected to specific pins of the onboard microcontroller.
    This initial step is crucial for gaining insight into the hardware layout and
    preparing us for detailed programming tasks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的探索，了解开发板的主要组件是如何连接到板载微控制器的特定引脚的。这一初步步骤对于深入了解硬件布局并为详细编程任务做准备至关重要。
- en: Locating and understanding the development board’s components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位和理解开发板组件
- en: In this section, our focus is to pinpoint the specific ports and pins on the
    microcontroller to which the user LED, user push button, berg pins, and Arduino-compatible
    headers are connected on the development board. Understanding these connections
    is crucial for our programming tasks. To accurately identify these connections,
    we will consult the *NUCLEO-F411* *User Manual*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的重点是确定微控制器上连接到开发板用户LED、用户按钮、berg引脚和Arduino兼容引脚的具体端口和引脚。了解这些连接对于我们的编程任务至关重要。为了准确识别这些连接，我们将查阅*NUCLEO-F411*
    *用户手册*。
- en: '![Figure 2.2: Development board showing components of interest](img/B21914_02_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：展示感兴趣组件的开发板](img/B21914_02_02.jpg)'
- en: 'Figure 2.2: Development board showing components of interest'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：展示感兴趣组件的开发板
- en: Now, let’s locate the microcontroller pin connected to the User LED on the development
    board.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定位开发板上连接到用户LED的微控制器引脚。
- en: Locating the LED connection
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位LED连接
- en: Our first step is to navigate through the table of contents to find the section
    dedicated to LEDs. This can be done quickly by locating *Figure 2**.3* in the
    manual, which shows the page number for the *LEDs* section and allows us to jump
    directly to it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是通过目录导航找到专门介绍LED的部分。这可以通过快速定位手册中的**图2.3**来实现。它显示了LED部分的页码，使我们能够直接跳转到该部分。
- en: Click on the page number to jump to the LEDs section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 点击页码跳转到LED部分。
- en: '![Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents
    showing the page number of the LEDs section](img/B21914_02_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：这是NUCLEO-F411用户手册目录的一部分，显示了LED部分的页码](img/B21914_02_03.jpg)'
- en: 'Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents
    showing the page number of the LEDs section'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：这是NUCLEO-F411用户手册目录的一部分，显示了LED部分的页码
- en: In the *LEDs* section, we find that the User LED, labeled **User LD2**, is linked
    to the ARDUINO® signal **D13**. This corresponds to either pin PA5 or PB13, depending
    on the specific STM32 target of our board.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在**LED**部分，我们发现用户LED，标记为**User LD2**，连接到ARDUINO®信号**D13**。这对应于PA5或PB13引脚，具体取决于我们板上的STM32目标。
- en: It’s important to note the dual naming convention used in the User Manual due
    to the board’s compatibility with the Arduino IDE. In the Arduino naming scheme,
    pins are categorized as either analog (preceded by “A”) or digital (preceded by
    “D”). For example, digital pin 3 is denoted as D3\. Conversely, the standard STM32
    convention starts with a “P,” followed by a letter indicating the port and then
    the pin number within that port, such as PA5 for the 5th pin of port A.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于板与Arduino IDE的兼容性，用户手册中使用了双重命名约定。在Arduino命名方案中，引脚被分类为模拟（以“A”开头）或数字（以“D”开头）。例如，数字引脚3表示为D3。相反，标准STM32约定以“P”开头，后面跟着表示端口的字母，然后是该端口内的引脚编号，例如PA5表示A端口第5个引脚。
- en: To determine whether pin D13 of our development board is PA5 or PB13 of the
    onboard microcontroller, we refer to *Tables 11 to 23* in the manual. These tables
    map the ARDUINO® connector pins to standard STM32 pins for each development board
    covered in the document. Specifically, we look at *Figure 2**.5* showing *Table
    16*, which pertains to our development board model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定我们的开发板上的引脚D13是板载微控制器的PA5还是PB13，我们参考手册中的**表11至23**。这些表格将每个开发板上的ARDUINO®连接器引脚映射到标准STM32引脚。具体来说，我们查看显示**表16**的**图2**.5，它涉及我们的开发板型号。
- en: Navigate to *Table 11* by clicking on it as shown in *Figure 2**.4*. This action
    will take you to the initial table in the sequence of tables. Then, scroll down
    until you get to *Table 16*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击如图**图2**.4所示的方式导航到**表11**。此操作将带您进入表格序列中的第一个表格。然后，向下滚动直到到达**表16**。
- en: '![Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the
    two possible connections of the User LED](img/B21914_02_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：这是NUCLEO-F411用户手册的一部分，显示了用户LED的两个可能连接](img/B21914_02_04.jpg)'
- en: 'Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the
    two possible connections of the User LED'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：这是NUCLEO-F411用户手册的一部分，显示了用户LED的两个可能连接
- en: Upon reviewing *Table 16*, we find that D13 indeed corresponds to PA5\. This
    indicates that the User LED on our NUCLEO-F411RE development board is connected
    to pin PA5 of the onboard microcontroller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看**表16**后，我们发现D13确实对应于PA5。这表明我们的NUCLEO-F411RE开发板上的用户LED连接到板载微控制器的PA5引脚。
- en: '![Figure 2.5: Table 16 shows that D13 corresponds to PA5](img/B21914_02_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：表16显示D13对应PA5](img/B21914_02_05.jpg)'
- en: 'Figure 2.5: Table 16 shows that D13 corresponds to PA5'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：表16显示D13对应PA5
- en: Another useful component found on the development board is the User Push button.
    Let’s find the pin connection of this component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发板上发现的另一个有用组件是用户按钮。让我们找到这个组件的引脚连接。
- en: Locating the User Push button
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位用户按钮
- en: The User Push button on the development board is an important component for
    input handling in many embedded experiments, and understanding its connection
    to the microcontroller is crucial for effective programming and interaction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 开发板上的用户按钮是许多嵌入式实验中输入处理的重要组件，理解其与微控制器的连接对于有效的编程和交互至关重要。
- en: To locate the connection details of the User Push button on our board, we will
    navigate through the table of contents to find the section dedicated to *Push-buttons*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到我们板上的用户按钮的连接细节，我们将通过目录导航到专门针对**按钮**的部分。
- en: This can be done quickly by locating *Figure 2**.6* in the manual, which shows
    the page number for the *Push-buttons* section and allows us to jump directly
    to it by clicking on the page number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在手册中定位**图2**.6，可以快速完成此操作。该图显示了**按钮**部分的页码，并允许我们通过点击页码直接跳转到该部分。
- en: '![Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number
    for the Push-buttons section](img/B21914_02_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：这是NUCLEO-F411用户手册中提供按钮部分页码的部分](img/B21914_02_06.jpg)'
- en: 'Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number
    for the Push-buttons section'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：本部分NUCLEO-F411用户手册提供了按钮部分的页码
- en: Upon navigating to the *Push-buttons* section of the manual, we locate the relevant
    information about our User Push-button, identified as **B1 User**. The manual
    tells us that this button is connected to pin **PC13** of the onboard microcontroller.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航到手册的*按钮*部分后，我们找到了关于我们的用户按钮**B1 User**的相关信息。手册告诉我们，这个按钮连接到板载微控制器的**PC13**引脚。
- en: Locating the berg pins and Arduino-compatible headers
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位伯格引脚和Arduino兼容引脚
- en: 'In the *LEDs* sections, we learned that our NUCLEO-F411 development board features
    two primary naming systems for its pins: the Arduino naming system and the standard
    STM32 naming system. While bare-metal programming primarily utilizes the standard
    STM32 naming, the pins on the board itself are labeled according to the Arduino
    system. It is important to know the actual port names and pin numbers of these
    exposed pins so that we can properly connect and program external components such
    as sensors and actuators.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*LEDs*部分，我们了解到我们的NUCLEO-F411开发板为其引脚提供了两种主要的命名系统：Arduino命名系统和标准STM32命名系统。虽然裸机编程主要使用标准STM32命名，但板上的引脚标签是根据Arduino系统标注的。了解这些暴露引脚的实际端口名称和引脚编号非常重要，这样我们才能正确连接和编程外部组件，如传感器和执行器。
- en: '*Figure 2**.7* shows our NUCLEO-F411 development board with the columns of
    berg pins highlighted.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.7*显示了带有伯格引脚高亮的我们的NUCLEO-F411开发板。'
- en: '![Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted](img/B21914_02_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：这是带有伯格引脚高亮的NUCLEO-F411开发板](img/B21914_02_07.jpg)'
- en: 'Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：这是带有伯格引脚高亮的NUCLEO-F411开发板
- en: The Arduino header pins of the development board are located at the sides of
    the berg pins columns. This is highlighted in *Figure 2**.8*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 开发板的Arduino引脚位于伯格引脚列的两侧。这在*图2**.8*中被突出显示。
- en: '![Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted](img/B21914_02_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：此NUCLEO-F411开发板带有Arduino引脚高亮](img/B21914_02_08.jpg)'
- en: 'Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：此NUCLEO-F411开发板带有Arduino引脚高亮
- en: Let’s start by finding the microcontroller pin connections of the Arduino header
    pins.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先找到Arduino引脚的微控制器引脚连接。
- en: Arduino-compatible headers
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino兼容引脚
- en: To identify the standard STM32 names for the pins on the Arduino header, we
    navigate to the section titled *ARDUINO® connectors* using the table of contents.
    This directs us to *Table 11*, which provides the mappings of Arduino pins to
    STM32 pins. For our specific NUCLEO-F411 development board, we focus on *Table
    16*, which offers the relevant mapping for our model.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别Arduino引脚的标准STM32名称，我们使用目录导航到标题为*ARDUINO®连接器*的部分。这引导我们到*表11*，它提供了Arduino引脚到STM32引脚的映射。对于我们的特定NUCLEO-F411开发板，我们关注*表16*，它为我们型号提供了相关的映射。
- en: Next, let’s locate the connections of the berg pins.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定位伯格引脚的连接。
- en: The berg pins
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伯格引脚
- en: Similar to our approach with other components, to find details about the berg
    pins, we again consult the table of contents in the manual and locate the section
    called *Extension connectors*. This section includes figures illustrating the
    pinouts for various NUCLEO boards. We then scroll to find the pinout corresponding
    to our specific NUCLEO model. Here, the pinout of our development board is presented
    in the standard STM32 naming system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对其他组件的方法类似，为了找到伯格引脚的详细信息，我们再次查阅手册的目录，并定位到名为*扩展连接器*的部分。本节包括展示各种NUCLEO板引脚排布的图。然后我们滚动找到与我们特定NUCLEO型号对应的引脚排布。在这里，我们的开发板引脚排布以标准STM32命名系统呈现。
- en: Over here, we also discover that the manual refers to the columns of male header
    berg pins as the ST morpho connector. This means that whenever the *morpho connector*
    term is used, it is referring to these male header berg pins.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还发现手册将伯格引脚的列称为ST morpho连接器。这意味着每当使用*morpho连接器*这个词时，它指的是这些公头伯格引脚。
- en: '![Figure 2.9: Pinout of the NUCLEO-F411 development board](img/B21914_02_09.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：NUCLEO-F411开发板的引脚排布](img/B21914_02_09.jpg)'
- en: 'Figure 2.9: Pinout of the NUCLEO-F411 development board'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：NUCLEO-F411开发板的引脚排布
- en: In this section, we learned that NUCLEO development boards use two naming systems.
    Firstly, the Arduino naming system, which is visibly marked on the board, and
    secondly, the standard STM32 naming system, detailed in the documentation. We
    discovered that the standard STM32 naming system is particularly relevant for
    our purposes, as it directly correlates to the pin names of the onboard microcontroller.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到NUCLEO开发板使用两种命名系统。首先，是Arduino命名系统，这在板上可以明显看到，其次，是详细说明在文档中的标准STM32命名系统。我们发现，标准STM32命名系统对我们的目的特别相关，因为它直接关联到板载微控制器的引脚名称。
- en: The next section will guide us on how to access and manipulate the relevant
    memory locations of the onboard microcontroller. Our focus will be on configuring
    pin PA5 as an output pin. This will allow us to control the LED connected to PA5.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将指导我们如何访问和操作板载微控制器的相关内存位置。我们的重点将放在配置PA5引脚作为输出引脚上。这将使我们能够控制连接到PA5的LED。
- en: Defining and creating registers through documentation insights
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文档洞察定义和创建寄存器
- en: In the previous section, we established that the User LED is connected to pin
    PA5\. This means that it is linked to pin number 5 on GPIO PORTA. In other words,
    to get to the LED, we have to go through PORTA and then locate pin number 5 of
    that port.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们确定用户LED连接到PA5引脚。这意味着它与GPIO PORTA的5号引脚相连。换句话说，要到达LED，我们必须通过PORTA，然后找到该端口的5号引脚。
- en: As illustrated in *Figure 2**.10*, the microcontroller has exposed pins on all
    four sides. These pins are organized into distinct groups known as **ports**.
    For instance, pins in PORTA are denoted with the *PA* prefix, while those in PORTB
    start with *PB*, and so forth. This systematic arrangement allows us to easily
    identify and access specific pins for programming and hardware interfacing tasks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2.10*所示，微控制器在四个侧面都暴露了引脚。这些引脚被组织成不同的组，称为**端口**。例如，PORTA中的引脚用*PA*前缀表示，而PORTB中的引脚以*PB*开头，等等。这种系统性的安排使我们能够轻松识别和访问特定引脚，以便进行编程和硬件接口任务。
- en: '![Figure 2.10: STM32F411 pinout](img/B21914_02_10.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：STM32F411引脚图](img/B21914_02_10.jpg)'
- en: 'Figure 2.10: STM32F411 pinout'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：STM32F411引脚图
- en: In the next section, we will go through the steps to locate the precise address
    of GPIO PORTA.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍定位GPIO PORTA精确地址的步骤。
- en: Locating GPIO PORTA
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位GPIO PORTA
- en: To effectively interact with any part of our microcontroller, it’s essential
    to know the memory address of that specific part. Our next step is to explore
    the memory map of the microcontroller. By doing so, we can locate the address
    of GPIO PORTA in a step-by-step manner.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地与微控制器的任何部分进行交互，了解该特定部分的内存地址是至关重要的。我们的下一步是探索微控制器的内存映射。通过这样做，我们可以逐步定位GPIO
    PORTA的地址。
- en: Since our focus is now on the onboard microcontroller rather than the development
    board, we need to refer to the microcontroller’s datasheet, specifically the `stm32f411re.pdf`
    document.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的重点是板载微控制器而不是开发板，我们需要参考微控制器的数据手册，特别是`stm32f411re.pdf`文档。
- en: Let’s start by navigating to the table of contents of the document. There, we’ll
    find a section entitled *Memory Mapping*. Click on the corresponding page number
    to jump to that section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导航到文档的目录开始。在那里，我们将找到一个名为*内存映射*的部分。点击相应的页码以跳转到该部分。
- en: Over here, we find a comprehensive diagram that illustrates the entire memory
    map of the microcontroller. A relevant excerpt of this diagram is presented in
    *Figure 2**.11*, which shows the overall memory layout.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们找到了一个全面的图表，展示了微控制器的整个内存映射。该图表的相关摘录在*图2.11*中展示，显示了整体内存布局。
- en: '![Figure 2.11: Memory map](img/B21914_02_11.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11：内存映射](img/B21914_02_11.jpg)'
- en: 'Figure 2.11: Memory map'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：内存映射
- en: The memory map shows that everything inside the microcontroller is addressed
    from `0x0000 0000` to `0xFFFF FFFF`. We’re interested in the part about peripherals
    because that’s where we find GPIOA.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射显示，微控制器内部的所有内容都是从`0x0000 0000`到`0xFFFF FFFF`进行寻址的。我们感兴趣的部分是关于外设的部分，因为在那里我们找到了GPIOA。
- en: 'In the context of microcontrollers, a peripheral refers to a hardware component
    that is not part of the **central processing unit** (**CPU**) but is connected
    to the microcontroller to extend its capabilities. Peripherals perform specific
    functions and can include a wide range of components, such as the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在微控制器语境中，外设指的是不是**中央处理单元**（**CPU**）的一部分，但连接到微控制器以扩展其功能的硬件组件。外设执行特定功能，可以包括以下广泛的组件：
- en: '**GPIO ports**: These are used for interfacing with external devices such as
    LEDs, switches, and sensors. They can be programmed to either receive input signals
    or send output signals.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO端口**：这些用于与外部设备（如LED、开关和传感器）接口。它们可以被编程为接收输入信号或发送输出信号。'
- en: '**Communication interfaces**: These include serial communication interfaces
    such as a **universal asynchronous receiver-transmitter** (**UART**), **Serial
    Peripheral Interface** (**SPI**), and **Inter-Integrated Circuit** (**I2C**),
    which enable the microcontroller to communicate with other devices, sensors, or
    even other microcontrollers.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信接口**：这些包括串行通信接口，如**通用异步收发传输器**（**UART**）、**串行外设接口**（**SPI**）和**集成电路间通信**（**I2C**），这些接口使微控制器能够与其他设备、传感器甚至其他微控制器通信。'
- en: '**Timers and counters**: Timers are used for measuring time intervals or generating
    time-based events, while counters can be used to count events or pulses.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器和计数器**：定时器用于测量时间间隔或生成基于时间的事件，而计数器可用于计数事件或脉冲。'
- en: '**Analog-to-digital converters (ADCs)**: ADCs convert analog signals (such
    as those from a temperature sensor) into digital values that the microcontroller
    can process.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模数转换器（ADCs）**：ADCs将模拟信号（如来自温度传感器的信号）转换为微控制器可以处理的数字值。'
- en: The peripherals mentioned here represent a selection of the common types found
    in microcontrollers. As we progress through subsequent chapters, we will delve
    deeper into these and other peripherals.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的外设代表了在微控制器中常见的类型选择。随着我们进入后续章节，我们将更深入地探讨这些和其他外设。
- en: In *Figure 12**.11*, the memory map shows that the address range for all the
    microcontroller’s peripherals spans from `0x40000000` to `0x5FFFFFFF`. This means
    that GPIO PORTA’s address lies within this specified range.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.11*中，内存映射显示所有微控制器外设的地址范围从`0x40000000`到`0x5FFFFFFF`。这意味着GPIO PORTA的地址位于这个指定的范围内。
- en: Peripherals base address = 0x40000000
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 外设基本地址 = 0x40000000
- en: Let’s note down the start of the peripheral address, which we will refer to
    as `PERIPH_BASE`, indicating the base address for the peripherals. We will need
    this for calculating the address of GPIO PORTA. `PERIPH_BASE` = `0x40000000`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记下外设地址的起始位置，我们将称之为`PERIPH_BASE`，表示外设的基本地址。我们将需要这个地址来计算GPIO PORTA的地址。`PERIPH_BASE`
    = `0x40000000`。
- en: '*Figure 12**.12* shows a zoomed-in view of the peripherals section in the memory
    map. Here, we observe that the peripheral memory is segmented into five distinct
    blocks: APB1, APB2, AHB1, AHB2, and the Cortex-M internal peripherals block, which
    is located at the top.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.12*显示了内存映射中外设部分的放大视图。在这里，我们观察到外设内存被划分为五个不同的块：APB1、APB2、AHB1、AHB2和位于顶部的Cortex-M内部外设块。'
- en: '![Figure 2.12: Peripherals memory map](img/B21914_02_12.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12：外设内存映射](img/B21914_02_12.jpg)'
- en: 'Figure 2.12: Peripherals memory map'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：外设内存映射
- en: 'These blocks, except for the Cortex-M internal peripherals, are named after
    the bus systems they interface with – namely, the **Advanced Peripheral Bus**
    (**APB**) and the **Advanced High-Performance** **Bus** (**AHB**):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块，除了Cortex-M内部外设外，都是以它们所接口的总线系统命名的——即**高级外设总线**（**APB**）和**高级高性能总线**（**AHB**）：
- en: '**APB1 and APB2**: These buses cater to lower bandwidth peripherals, providing
    a more efficient means of communication for devices that do not require high-speed
    data transfer.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APB1和APB2**：这些总线为低带宽外设提供服务，为不需要高速数据传输的设备提供更有效的通信方式。'
- en: '**AHB1 and AHB2**: These are designed for high-speed data transfer and are
    used to connect high-bandwidth peripherals. They enable faster and more efficient
    data, control, and address communication.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AHB1和AHB2**：这些是为高速数据传输设计的，用于连接高带宽外设。它们使数据、控制和地址通信更快、更高效。'
- en: On *pages 54 to 56* of the datasheet, we find a table delineating the boundary
    addresses for each bus and the associated peripherals. A segment of this table
    is shown in *Figure 2**.13*, where we find that GPIOA is allocated a boundary
    address from `0x40020000` to `0x4002 03FF` and is connected to the AHB1 bus. Therefore,
    this indicates that the addresses for all registers related to GPIO PORTA are
    encompassed within this address range.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据表的第54页至第56页，我们找到了一个表格，列出了每个总线和相关外设的边界地址。该表格的一部分在*图2.13*中显示，其中我们发现GPIOA被分配了一个从`0x40020000`到`0x4002
    03FF`的边界地址，并且连接到AHB1总线。因此，这表明与GPIO PORTA相关的所有寄存器的地址都包含在这个地址范围内。
- en: '![Figure 2.13: Boundary address and Bus of GPIOA](img/B21914_02_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13：GPIOA的边界地址和总线](img/B21914_02_13.jpg)'
- en: 'Figure 2.13: Boundary address and Bus of GPIOA'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：GPIOA的边界地址和总线
- en: GPIOA base address = PERIPH_BASE + 0x20000 = 0x40020000
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOA基址 = PERIPH_BASE + 0x20000 = 0x40020000
- en: From the table, we find that the starting address for the GPIOA boundary is
    `0x40020000`. This reveals that adding an offset of `0x20000` to the `PERIPH_BASE`
    address (which is 0x40000000) results in the base address of GPIOA, calculated
    as `0x40000000 + 0x20000 = 0x40020000`. The term “offset value” refers to the
    value added to derive a specific address from a base address. In this case, the
    offset value for GPIOA from the `PERIPH_BASE` address is `0x20000`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从表格中，我们发现GPIOA边界地址的起始地址是`0x40020000`。这表明将`0x20000`的偏移量添加到`PERIPH_BASE`地址（即0x40000000）将得到GPIOA的基址，计算为`0x40000000
    + 0x20000 = 0x40020000`。术语“偏移值”指的是添加到基址以推导出特定地址的值。在这种情况下，从`PERIPH_BASE`地址到GPIOA的偏移值是`0x20000`。
- en: Understanding the concept of offset values is crucial for accurately calculating
    desired addresses in microcontroller programming. This understanding enables precise
    navigation and manipulation within the system’s memory map.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 理解偏移值的概念对于在微控制器编程中准确计算所需的地址至关重要。这种理解使得在系统内存映射中进行精确导航和操作成为可能。
- en: Clock gating
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟门控
- en: Having identified the exact address of GPIOA, our next step is to enable clock
    access to it before configuring its registers. This step is necessary because,
    by default, the clock to all unused peripherals is disabled to conserve power.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了GPIOA的确切地址后，我们的下一步是在配置其寄存器之前启用对它的时钟访问。这一步是必要的，因为默认情况下，所有未使用的外设的时钟都是禁用的，以节省电力。
- en: Modern microcontrollers use a power-saving technique known as **clock gating**.
    In simple terms, clock gating involves selectively turning off the clock signal
    to certain parts of the microcontroller when they’re not in use. The clock signal
    is an essential part of microcontroller operations, as it drives the sequential
    logic by providing a regular pulse that synchronizes the activities of the microcontroller’s
    circuits. However, when a particular part of the microcontroller, such as a peripheral,
    is not actively being used, the clock signal to that part is disabled. This disabling
    prevents unnecessary power consumption by idle circuits. Therefore, before using
    any peripheral, it’s required to first enable clock access to it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现代微控制器使用一种称为**时钟门控**的节能技术。简单来说，时钟门控涉及在微控制器不使用时，选择性地关闭其某些部分的时钟信号。时钟信号是微控制器操作的一个基本部分，它通过提供同步脉冲来驱动时序逻辑，从而同步微控制器电路的活动。然而，当微控制器的某个部分（如外设）未被积极使用时，该部分的时钟信号将被禁用。这种禁用可以防止空闲电路的不必要功耗。因此，在使用任何外设之前，首先需要启用对该外设的时钟访问。
- en: As shown in *Figure 2**.14*, there’s a peripheral listed as RCC, which has a
    boundary address range from `0x40023800` to `0x40023BFF`. The functions of this
    peripheral include enabling and disabling clock access to other peripherals.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2.14*所示，列出了一个名为RCC的外设，其边界地址范围从`0x40023800`到`0x40023BFF`。该外设的功能包括启用和禁用对其他外设的时钟访问。
- en: RCC base Address = PERIPH_BASE + 0x23800 = 0x40023800
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RCC基址地址 = PERIPH_BASE + 0x23800 = 0x40023800
- en: From the boundary address information, we can see that the `RCC _Base` address
    is obtained by adding an offset of `0x23800` to `PERIPH_BASE`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从边界地址信息中，我们可以看到`RCC_Base`地址是通过将`PERIPH_BASE`的偏移量`0x23800`添加到`PERIPH_BASE`获得的。
- en: '![](img/B21914_02_14.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21914_02_14.jpg)'
- en: 'Figure 2.14: Boundary address and Bus of RCC'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：RCC的边界地址和总线
- en: Having successfully determined the base addresses for the two essential peripherals
    needed to configure GPIOA pin 5 (which controls the connected LED), our next step
    involves using these base addresses to derive the specific register addresses
    necessary for setting the pin as an output and ultimately activating the LED.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功确定配置GPIOA引脚5（控制连接的LED）所需的两个基本外设的基地址后，我们的下一步是使用这些基地址推导出设置引脚为输出并最终激活LED所需的特定寄存器地址。
- en: To locate the detailed information about these registers, we will refer to the
    reference manual (*RM0383*). This document provides comprehensive insights into
    all registers and their configurations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到这些寄存器的详细信息，我们将参考参考手册（*RM0383*）。这份文档提供了关于所有寄存器和它们配置的全面见解。
- en: The AHB1 ER
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AHB1 ER
- en: Our reference manual, RM0383, is a comprehensive document spanning over 800
    pages, and some STM32 reference manuals even exceed 1,500 pages. The objective
    is not to read the entire manual cover to cover, but rather to develop the skill
    to efficiently locate specific information as needed. Previously, we established
    that GPIOA is connected to the AHB1 bus. We also learned that activating this
    peripheral requires enabling clock access through the RCC peripheral.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的参考手册，RM0383，是一本超过800页的综合性文档，一些STM32参考手册甚至超过1500页。目标不是从头到尾阅读整个手册，而是培养在需要时高效定位特定信息的能力。之前，我们确定了GPIOA连接到AHB1总线。我们还了解到，激活此外设需要通过RCC外设启用时钟访问。
- en: 'The RCC peripheral in our microcontroller includes a specific register dedicated
    to enabling the clock for each bus. In STM32 microcontrollers, the naming of registers
    follows a straightforward pattern: *peripheral acronym + underscore + register
    acronym*. For example, the register responsible for controlling clock access to
    the AHB1 bus is named `RCC_AHB1ENR`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们微控制器中的RCC外设包括一个特定的寄存器，用于为每个总线启用时钟。在STM32微控制器中，寄存器的命名遵循一个简单的模式：*外设缩写 + 下划线
    + 寄存器缩写*。例如，负责控制对AHB1总线时钟访问的寄存器命名为`RCC_AHB1ENR`。
- en: 'Let’s explain this a bit more:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步解释：
- en: '**RCC** stands for **Reset and** **Clock Control**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RCC**代表**复位和时钟控制**'
- en: '**AHB1** stands for **Advanced High-Performance** **Bus 1**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AHB1**代表**高级高性能总线1**'
- en: '**ENR** stands for **Enable Register**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENR**代表**使能寄存器**'
- en: This systematic naming convention simplifies the process of identifying and
    accessing the appropriate registers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统性的命名约定简化了识别和访问适当寄存器的过程。
- en: To find the information about the `RCC_AHB1ENR` register, we begin by opening
    the reference manual. Next, we navigate to the table of contents and search for
    the section titled *RCC AHB1 Peripheral Clock Enable Register (RCC_AHB1ENR)*.
    Once located, we click on the page number provided alongside this section title
    to directly jump to the relevant part of the document.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找关于`RCC_AHB1ENR`寄存器的信息，我们首先打开参考手册。接下来，我们导航到目录表并搜索标题为*“RCC AHB1 外设时钟使能寄存器 (RCC_AHB1ENR)”*的部分。一旦找到，我们点击该部分标题旁边提供的页码，直接跳转到文档的相关部分。
- en: 'Let’s begin by examining the details presented at the top of the page, as illustrated
    in *Figure 2**.15*. This section provides key information about the register,
    including the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从页面顶部展示的细节开始分析，如图*图2.15*所示。本节提供了关于寄存器的关键信息，包括以下内容：
- en: '**Register name**: The full name of the register is provided along with its
    abbreviation, namely **RCC AHB1 Peripheral Clock Enable** **Register** (**RCC_AHB1ENR**).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器名称**: 提供了寄存器的全名及其缩写，即**RCC AHB1 外设时钟使能寄存器**（**RCC_AHB1ENR**）。'
- en: '`0x30`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x30`.'
- en: '`0x00000000`, indicating the value the register holds upon reset. In other
    words, the default value of the register.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00000000`，表示寄存器在复位时持有的值。换句话说，寄存器的默认值。'
- en: '**Access type**: The register supports various access types – it can be accessed
    without wait states and allows word, half-word, and byte access.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问类型**: 寄存器支持各种访问类型——它可以无等待状态地访问，并允许字、半字和字节访问。'
- en: '**Register diagram**: A detailed diagram of the register is included, showing
    all 32 bits along with labels for each bit.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器图**: 包含寄存器的详细图示，显示所有32位，并为每个位提供标签。'
- en: '![Figure 2.15: RCC AHB1 ER](img/B21914_02_15.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15: RCC AHB1 ER](img/B21914_02_15.jpg)'
- en: 'Figure 2.15: RCC AHB1 ER'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '图2.15: RCC AHB1 ER'
- en: RCC_AHB1ENR Address = RCC_BASE + 0x30 = 0x40023830
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: RCC_AHB1ENR 地址 = RCC_BASE + 0x30 = 0x40023830
- en: 'From this information, we can accurately calculate the address of the `RCC_AHB1ENR`
    register. We do this by adding the `RCC_AHB1ENR` offset to the `RCC_BASE address`.
    The formula is as follows: `RCC_BASE + RCC_AHB1ENR Offset = 0x40023800 + 0x30
    =` `0x40023830`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中，我们可以准确地计算出 `RCC_AHB1ENR` 寄存器的地址。我们通过将 `RCC_AHB1ENR` 偏移量加到 `RCC_BASE`
    地址上来完成此操作。公式如下：`RCC_BASE + RCC_AHB1ENR Offset = 0x40023800 + 0x30 =` `0x40023830`。
- en: The same section of the reference manual also includes a detailed description
    of each bit within the register. We are particularly interested in the bit named
    `'GPIOAEN'`, which stands for `0`. Further down, at the start of the next page
    in the document, we find a precise description of `bit0`, as depicted in *Figure
    2**.16*. This description explains that setting `bit0` to `0` disables the GPIOA
    clock while setting it to `1` enables the GPIOA clock.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参考手册的同一部分还包括对寄存器中每个位的详细描述。我们特别关注名为 `'GPIOAEN'` 的位，它代表 `0`。在文档下一页的开始处，我们找到了对
    `bit0` 的精确描述，如图 *图 2**.16* 所示。该描述解释说，将 `bit0` 设置为 `0` 禁用 GPIOA 时钟，而将其设置为 `1` 启用
    GPIOA 时钟。
- en: '![Figure 2.16: GPIOAEN bit](img/B21914_02_16.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16：GPIOAEN 位](img/B21914_02_16.jpg)'
- en: 'Figure 2.16: GPIOAEN bit'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：GPIOAEN 位
- en: Having understood the steps required to enable clock access to GPIOA, our next
    section will focus on learning how to set and clear bits within a register.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了启用 GPIOA 时钟访问所需的步骤之后，我们下一节将重点介绍如何在寄存器中设置和清除位。
- en: Setting and clearing bits in registers
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在寄存器中设置和清除位
- en: In bare-metal programming, manipulating individual bits within registers is
    a fundamental operation. This manipulation is important for configuring hardware
    settings, controlling peripheral devices, and optimizing the performance of embedded
    systems. Let’s start by understanding bits and registers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在裸机编程中，操作寄存器中的单个位是一个基本操作。这种操作对于配置硬件设置、控制外围设备以及优化嵌入式系统的性能非常重要。让我们首先了解位和寄存器。
- en: A `0` or `1`. **Registers**, on the other hand, are small-sized storage locations
    within microcontrollers, used to store data temporarily for various operations.
    Registers are typically a collection of bits (such as 8-bit, 16-bit, or 32-bit
    registers), and each bit in a register can be manipulated individually. In bare-metal
    programming, the two most frequently used bit operations are setting a bit and
    clearing a bit.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `0` 或 `1`。另一方面，**寄存器**是微控制器中的小型存储位置，用于存储各种操作中的临时数据。寄存器通常是位集合（例如 8 位、16 位或
    32 位寄存器），寄存器中的每个位都可以单独操作。在裸机编程中，最常用的两个位操作是设置位和清除位。
- en: Setting a bit
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置位
- en: Setting a bit means changing its value to `1`. We will often use this to activate
    or enable a specific function within a microcontroller.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个位意味着将其值更改为 `1`。我们经常使用这个来激活或启用微控制器中的特定功能。
- en: '`OR` operation (`|`) is used for setting a bit:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR` 操作 (`|`) 用于设置一个位：'
- en: '[PRE4]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this operation, `1` is shifted left `(<<)` to `bit_position` and then `ORed`
    with the current value of the register. The left shift operation creates a binary
    value where only the target bit is `1`, and all others are `0`. The `OR` operation
    then sets the target bit in the register to `1`, leaving the rest unchanged.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，`1` 被左移 `(<<)` 到 `bit_position`，然后与寄存器的当前值进行 `OR` 操作。左移操作创建一个二进制值，其中只有目标位是
    `1`，其余都是 `0`。然后 `OR` 操作将寄存器中的目标位设置为 `1`，其余保持不变。
- en: 'Let’s assume `register` initially holds the `0011` (binary) value and we want
    to set the third bit (bit position 2, 0-indexed). The *bit-shifted value* would
    be `0100` (binary for `1 << 2`). The `OR` operation is then as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `register` 初始持有 `0011`（二进制）值，我们想要设置第三个位（位位置 2，0 索引）。*位移后的值*将是 `0100`（二进制表示
    `1 << 2`）。然后 `OR` 操作如下：
- en: '[PRE5]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the *first*, *second*, and *fourth* bits of the original register
    value retain their value while the value of the third bit is changed to `1`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，原始寄存器值的*第一个*、*第二个*和*第四个*位保持其值，而第三个位的值被更改为 `1`。
- en: Let’s see the opposite of setting a bit.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看设置位的相反操作。
- en: Clearing a bit
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除位
- en: Conversely, clearing a bit means changing its value to `0`, typically to deactivate
    a function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，清除一个位意味着将其值更改为 `0`，通常用于禁用功能。
- en: '`AND` (`&`) and `NOT` (`~`) operations is used for clearing a bit:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AND` (`&`) 和 `NOT` (`~`) 操作来清除一个位：
- en: '[PRE6]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `1` is left-shifted to `bit_position`, and then a bitwise `NOT` operation
    is applied to create a binary number where all bits are `1`, except the target
    bit. The `AND` operation with the register clears the target bit, leaving others
    as they are.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`1` 被左移到 `bit_position`，然后应用位运算的位非操作以创建一个二进制数，其中所有位都是 `1`，除了目标位。与寄存器进行 `AND`
    操作会清除目标位，而其他位保持不变。
- en: 'Let’s assume `register` initially holds the `0111` (binary) value and we want
    to clear the third bit (bit position 2, 0-indexed). *The bit-shifted value for
    the mask* would be `0100` (binary for `1 << 2`). To clear the bit, we use the
    bitwise `AND` operation with the bitwise `NOT` of the bit-shifted value. The operation
    is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `register` 初始持有 `0111`（二进制）值，我们想要清除第三个位（位位置2，0索引）。*掩码的位移值* 将是 `0100`（二进制表示为
    `1 << 2`）。为了清除位，我们使用位移值的位运算与位运算的位非操作。操作如下：
- en: '[PRE7]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this operation, the third bit of the register is cleared (changed to `0`),
    while the other bits retain their original values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作中，寄存器的第三个位被清除（变为 `0`），而其他位保持其原始值。
- en: Let’s summarize the key points from the last two sections. Firstly, we understood
    that enabling clock access to GPIOA requires setting `bit0` in the `RCC_AHB1ENR`
    register. Secondly, we explored how to set and clear bits in registers using bitwise
    operations. Moving forward, in the next section, we will focus on configuring
    GPIOA pin 5 (PA5) as an output pin. This step is crucial in our progress toward
    activating the LED connected to PA5\. This will take us a step closer to activating
    the LED connected to PA5.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结最后两节的关键点。首先，我们了解到要启用GPIOA的时钟访问，需要在 `RCC_AHB1ENR` 寄存器中设置 `bit0`。其次，我们探讨了如何使用位运算设置和清除寄存器中的位。接下来，在下一节中，我们将专注于将GPIOA引脚5（PA5）配置为输出引脚。这一步对于激活连接到PA5的LED至关重要。这将使我们更接近激活连接到PA5的LED。
- en: The GPIO port mode register (GPIOx_MODER)
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO端口模式寄存器（GPIOx_MODER）
- en: The **GPIO port mode register** in STM32 microcontrollers is a specialized register
    used for setting the mode of each GPIO pin. To locate information about this register,
    we navigate to the table of contents of the reference manual and look for the
    section titled *GPIO Port Mode Register (GPIOx_MODER)*. By clicking on the associated
    page number, we are directly taken to the section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器中的**GPIO端口模式寄存器**是一个专用寄存器，用于设置每个GPIO引脚的模式。为了定位有关此寄存器的信息，我们导航到参考手册的目录并查找标题为
    *GPIO端口模式寄存器 (GPIOx_MODER)* 的部分。通过点击关联的页码，我们直接跳转到该部分。
- en: '*Figure 2**.17* shows the top section of the page. Here, we can observe the
    following details:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.17* 展示了页面顶部部分。在这里，我们可以观察到以下细节：'
- en: '`GPIOA_MODER` through `GPIOE_MODER`, as well as `GPIOH_MODER`. This means the
    same register structure and configuration are consistent across these GPIO ports.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOA_MODER` 通过 `GPIOE_MODER`，以及 `GPIOH_MODER`。这意味着这些GPIO端口具有相同的寄存器结构和配置。'
- en: '`MODER` register is located at the very beginning of the port’s memory space.
    Therefore, the GPIOA `MODE` register address is the same as the GPIOA base address.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODER` 寄存器位于端口内存空间的起始位置。因此，GPIOA `MODE` 寄存器地址与GPIOA基址相同。'
- en: '`GPIOA_MODER` register is `0xA800 0000`. This value represents the initial
    configuration state of the GPIOA pins upon reset.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOA_MODER` 寄存器是 `0xA800 0000`。此值表示GPIOA引脚在复位时的初始配置状态。'
- en: '`GPIOB_MODER` register has a default reset value of `0x0000 0280`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOB_MODER` 寄存器具有默认的复位值 `0x0000 0280`。'
- en: '`MODER` registers of all other specified GPIO ports is `0x0000 0000`:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他指定GPIO端口的 `MODER` 寄存器均为 `0x0000 0000`：
- en: '**GPIOA MODE Register Address = GPIOA_BASE =** **0x40020000**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**GPIOA MODE 寄存器地址 = GPIOA_BASE =** **0x40020000**'
- en: '![Figure 2.17: GPIO port mode register](img/B21914_02_17.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17：GPIO端口模式寄存器](img/B21914_02_17.jpg)'
- en: 'Figure 2.17: GPIO port mode register'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：GPIO端口模式寄存器
- en: We also observe that this is a 32-bit register, with its bits organized in pairs.
    For example, `bit0` and `bit1` together form a pair known as `MODER0`, `bit2`
    and `bit3` form `MODER1`, `bit4` and `bit5` form `MODER2`, and so on. Each of
    these pairs corresponds to a single pin of the GPIO port. Specifically, `MODER0`
    controls the configuration of `PIN0` of the corresponding port, `MODER1` controls
    `PIN1`, and this pattern continues similarly for the other pins.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还观察到这是一个32位寄存器，其位以成对的方式组织。例如，`bit0` 和 `bit1` 一起形成一个称为 `MODER0` 的对，`bit2` 和
    `bit3` 形成称为 `MODER1` 的对，`bit4` 和 `bit5` 形成称为 `MODER2` 的对，以此类推。这些对中的每一个都对应于GPIO端口的单个引脚。具体来说，`MODER0`
    控制相应端口的 `PIN0` 的配置，`MODER1` 控制 `PIN1`，其他引脚的模式也以类似的方式继续。
- en: Given our objective of configuring the mode of `PIN5`, we need to focus on `MODER5`.
    In the register, `MODER5` comprises `bit10` and `bit11`. These two bits are the
    required bits for setting the operational mode of `PIN5`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的目标是配置 `PIN5` 的模式，我们需要关注 `MODER5`。在寄存器中，`MODER5` 由 `bit10` 和 `bit11` 组成。这两个位是设置
    `PIN5` 操作模式所需的位。
- en: The reference manual provides a truth table, illustrated in *Figure 2**.18*,
    which explains the combinations of the two `MODER` bits necessary to configure
    a pin. This table is an invaluable resource for understanding how to set the bits
    for the desired pin configuration, whether it’s as an input, output, or an alternate
    function mode.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 参考手册提供了一个真值表，如图 *2**.18* 所示，该表解释了配置引脚所需的两个 `MODER` 位组合。此表是理解如何设置位以实现所需的引脚配置（无论是作为输入、输出还是备用功能模式）的宝贵资源。
- en: '![Figure 2.18: The MODER bits configuration](img/B21914_02_18.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18：`MODER` 位配置](img/B21914_02_18.jpg)'
- en: 'Figure 2.18: The MODER bits configuration'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：`MODER` 位配置
- en: As shown in *Figure 2**.18*, the `MODER` register within the GPIO port is composed
    of pairs of bits, designated as `2y:2y+1 MODERy[1:0]`, where *y* ranges from 0
    to 15, representing each of the 16 pins in the port (`PIN0` to `PIN15`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 2**.18* 所示，GPIO 端口的 `MODER` 寄存器由位对组成，标记为 `2y:2y+1 MODERy[1:0]`，其中 *y* 的范围从
    0 到 15，代表端口中的每个 16 个引脚（`PIN0` 到 `PIN15`）。
- en: 'In this equation, *y* represents the pin number. For Pin 5, *y = 5*. Plugging
    this value into the equation gives us the bit positions in the `MODER` register
    that correspond to Pin 5:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方程中，*y* 代表引脚号。对于引脚 5，*y = 5*。将此值代入方程，我们得到 `MODER` 寄存器中对应引脚 5 的位位置：
- en: The bit positions for `MODER5` are calculated as *2*y* and *(**2*y) +1*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODER5` 的位位置计算为 *2*y* 和 *(**2*y) +1*。'
- en: 'Substituting *y = 5*, we get the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用 *y = 5* 替换，我们得到以下结果：
- en: '*2*5 = 10* and *2*5 + 1 = 11*, which are `10` and `11`, respectively.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*2*5 = 10* 和 *2*5 + 1 = 11*，分别是 `10` 和 `11`。'
- en: So, bits `10` and `11` in the MODER register (`MODER5[1:0]`) are the bits that
    control the mode of Pin 5\. By setting these bits to specific values (`00`, `01`,
    `10`, or `11`), we can configure Pin 5 as an input, general-purpose output, alternate
    function, or analog mode, respectively.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MODER 寄存器中的 `bits 10` 和 `11`（`MODER5[1:0]`）是控制引脚 5 模式的位。通过将这些位设置为特定的值（`00`、`01`、`10`
    或 `11`），我们可以将引脚 5 配置为输入、通用输出、备用功能或模拟模式。
- en: 'The GPIO `MODER` register supports four distinct bit combinations, each defining
    a different operational mode for the corresponding pin:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO `MODER` 寄存器支持四种不同的位组合，每个组合定义了对应引脚的不同操作模式：
- en: '`00`: When both bits are `0`, the corresponding pin is set as an input pin.
    This is the standard mode for pins to receive data from external sources.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`: 当两个位都是 `0` 时，相应的引脚被设置为输入引脚。这是引脚从外部源接收数据的标准模式。'
- en: '`01`: Setting the bits to `01` sets the pin function to general-purpose output.
    In this mode, the pin can send data out, for instance, to light up an LED.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01`: 将位设置为 `01` 将引脚功能设置为通用输出。在此模式下，引脚可以发送数据，例如点亮 LED。'
- en: '`10`: The `10` state configures the pin for alternate functions. Each pin can
    serve specific additional purposes (such as PWM output and I2C communication lines),
    and this mode enables those functions.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`: `10` 状态配置引脚为备用功能。每个引脚可以提供特定的附加用途（例如 PWM 输出和 I2C 通信线路），并且此模式启用这些功能。'
- en: '`11`: When the bits are set to `11`, the pin operates in analog mode. This
    mode is typically used for ADC, useful in reading values from analog sensors.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`11`: 当位设置为 `11` 时，引脚在模拟模式下运行。此模式通常用于 ADC，用于从模拟传感器读取值。'
- en: From this, we understand that to configure PA5 as an output, we must set bit
    10 of the `GPIOA_MODER` register to `0` and bit 11 to `1`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们了解到要配置 PA5 为输出，我们必须将 `GPIOA_MODER` 寄存器的第 10 位设置为 `0`，第 11 位设置为 `1`。
- en: 'Let’s summarize our progress toward activating the LED connected to PA5:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下激活连接到 PA5 的 LED 的进展：
- en: '`bit0` of the `RCC_AHB1ENR` register to `1`. This step is essential to power
    the GPIOA for operation.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `RCC_AHB1ENR` 寄存器的 `bit0` 设置为 `1`。这一步对于为 GPIOA 提供电是必不可少的。
- en: '**Configuring PA5 for output**: We have just learned how to set PA5 as a general-purpose
    output pin.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置 PA5 为输出**：我们刚刚学习了如何将 PA5 设置为通用输出引脚。'
- en: These two steps effectively configure PA5 as an output pin. The final task involves
    controlling the output state of the pin – setting it to either `1` or `0`, which
    corresponds to on or off, respectively. This translates to sending either 3.3v
    or 0v to PA5, thus turning the connected LED on or off. To manage the output state
    of a pin, we need to interact with the **Output Data Register** (**ODR**). Locating
    and configuring this register will be the focus of the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤有效地将PA5配置为输出引脚。最终的任务涉及控制引脚的输出状态——将其设置为`1`或`0`，分别对应开启或关闭。这相当于向PA5发送3.3v或0v，从而打开或关闭连接的LED。要管理引脚的输出状态，我们需要与**输出数据寄存器**（**ODR**）交互。定位和配置此寄存器将是下一节的重点。
- en: 'So far, we have the following information for our quest to activate the LED
    connected to PA5:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关于激活连接到PA5的LED的查询有以下信息：
- en: We know how to enable clock access to GPIOA through the `RCC_AHB1ENR` register
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道如何通过`RCC_AHB1ENR`寄存器启用GPIOA的时钟访问
- en: We know how to configure the PIN5 of GPIOA as a general-purpose output pin.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道如何将GPIOA的PIN5配置为通用输出引脚。
- en: These two steps make PA5 act as an output pin. The final step is to be able
    to set the output state of the pin. The state can be either `1` or `0` corresponding
    to on or off, corresponding to sending 3.3v or 0v to PA5, and finally corresponding
    to turning on or turning off the LED connected to PA5\. To set the output of a
    pin, we need to access the ODR; this shall be the focus of the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤使PA5充当输出引脚。最后一步是能够设置引脚的输出状态。状态可以是`1`或`0`，对应开启或关闭，对应向PA5发送3.3v或0v，最终对应于打开或关闭连接到PA5的LED。要设置引脚的输出，我们需要访问ODR；这将是下一节的重点。
- en: GPIO Port Output Data Register (GPIOx_ODR)
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO端口输出数据寄存器（GPIOx_ODR）
- en: The GPIO Port **ODR** in STM32 microcontrollers is used for controlling the
    output state of each GPIO pin. To find information about this register, we refer
    to the table of contents in the microcontroller’s reference manual and locate
    the section titled *GPIO Port Output Data Register (GPIOx_ODR)*. Clicking on the
    page number corresponding to this section takes us straight to the required information.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32微控制器中，GPIO端口的**ODR**用于控制每个GPIO引脚的输出状态。要查找有关此寄存器的信息，我们参考微控制器参考手册的目录，并定位标题为*GPIO端口输出数据寄存器（GPIOx_ODR）*的部分。点击此部分对应的页码将直接带我们到所需的信息。
- en: '*Figure 2**.19* displays the top part of the page, where we can observe the
    following details:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.19*显示了页面顶部，我们可以观察到以下细节：'
- en: '`GPIOA_ODR` through `GPIOE_ODR`, as well as `GPIOH_ODR`. This means the same
    register structure and configuration are consistent across these GPIO ports.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOA_ODR`通过`GPIOE_ODR`，以及`GPIOH_ODR`。这意味着这些GPIO端口具有相同的寄存器结构和配置。'
- en: '`0x14` from the base address of its respective GPIO port. This means that,
    for each GPIO port, the ODR register can be found at this offset from the port’s
    base memory address.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其相应GPIO端口的基地址的`0x14`。这意味着对于每个GPIO端口，ODR寄存器都可以在这个偏移量处找到端口的基本内存地址。
- en: '`0` upon a reset. This default state ensures that all GPIO pins are initially
    in a low output state.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复位时为`0`。此默认状态确保所有GPIO引脚最初处于低输出状态。
- en: GPIOA ODR address = GPIOA_BASE + ODR_OFFSET = 0x40020014
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOA ODR地址 = GPIOA_BASE + ODR_OFFSET = 0x40020014
- en: '`ODR_OFFSET =` `0x14`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`ODR_OFFSET =` `0x14`。'
- en: '![](img/B21914_02_19.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21914_02_19.jpg)'
- en: 'Figure 2.19: GPIO port ODR'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：GPIO端口ODR
- en: 'Let’s delve into the structure of the bits:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解位的结构：
- en: '**Bits 31:16 (reserved)**: These bits are reserved and should not be used for
    any operation.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位31:16（保留）**：这些位保留，不应用于任何操作。'
- en: '`0` to `15`, correspond to each of the 16 pins in the GPIO port. They are directly
    programmable and can be both read and written by software. Changing the value
    of these bits alters the output state of the corresponding GPIO pin.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`0`到`15`，对应于GPIO端口中的每个16个引脚。它们可以直接编程，并且可以通过软件读取和写入。更改这些位的值会改变相应GPIO引脚的输出状态。
- en: 'Let’s consider our final task of activating the LED connected to PA5:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们的最终任务——激活连接到PA5的LED：
- en: '`5`) in the `GPIOA_ODR` register.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GPIOA_ODR`寄存器的位`5`上。
- en: '`1` to bit `5` of the `GPIOA_ODR` register. This can be achieved using a bitwise
    `OR` operation, as follows:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位运算`OR`操作，如下所示：
- en: '[PRE8]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this operation, we shift `1` left by 5 positions (resulting in a binary value
    where only the 6th bit is `1`) and then `OR` it with the current value of the
    `GPIOA_ODR` register. This action sets PA5 high without altering the state of
    other pins in the port.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们将 `1` 左移 5 位（结果是一个二进制值，其中只有第 6 位是 `1`），然后将其与 `GPIOA_ODR` 寄存器的当前值进行
    `OR` 操作。这个动作将 PA5 设置为高电平，而不改变端口中其他引脚的状态。
- en: Setting PA5 high will supply voltage to the connected LED, effectively turning
    it on.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将 PA5 设置为高电平将为连接的 LED 提供电压，从而将其点亮。
- en: Now that we understand how to set the state of GPIO output pins, in the next
    section, we will combine all the pieces of information we’ve acquired and develop
    our first firmware.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何设置 GPIO 输出引脚的状态，在下一节中，我们将结合我们所学到的所有信息来开发我们的第一个固件。
- en: Register manipulation – from configuration to running your first firmware
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器操作 – 从配置到运行第一个固件
- en: In this section, we will apply the knowledge acquired throughout this chapter
    to develop our first bare-metal firmware.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用本章学到的知识来开发我们的第一个裸机固件。
- en: 'We begin by creating a new project, a process we covered in [*Chapter 1*](B21914_01.xhtml#_idTextAnchor015).
    Here is a summary of the steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新项目，这个过程我们在 [*第一章*](B21914_01.xhtml#_idTextAnchor015) 中已经介绍过。以下是步骤的总结：
- en: '**Start a new project**: Go to **File** | **New** | **STM32 Project** in your
    IDE.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始一个新项目**：在你的 IDE 中，转到 **文件** | **新建** | **STM32 项目**。'
- en: '**Select the target microcontroller**: A **Target Selection** window will appear,
    prompting you to choose the microcontroller or development board for your project.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择目标微控制器**：将出现一个 **目标选择** 窗口，提示您为项目选择微控制器或开发板。'
- en: '**Use the board selector**: Click on the **Board** **Selector** tab.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用板选择器**：单击 **板** **选择器** 选项卡。'
- en: '`NUCLEO-F411` in the **Commercial Part** **Number** field.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **商业零件编号** 字段中填写 `NUCLEO-F411`。
- en: '**Select our board**: From the list of boards that appear, choose **NUCLEO-F411RE**
    and then click **Next**.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择我们的板**：从出现的板列表中选择 **NUCLEO-F411RE**，然后单击 **下一步**。'
- en: '`RegisterManipulation`.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RegisterManipulation`。'
- en: '`Empty` project setup.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`空` 项目设置。'
- en: '**Final step**: Click **Finish** to create your project.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最后一步**：单击 **完成** 以创建项目。'
- en: Once the project is created, open the `main.c` file in your project workspace.
    Clear all pre-existing text in this file to start with a clean slate for our code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，打开项目工作区中的 `main.c` 文件。清除此文件中所有现有的文本，以便从干净的状态开始编写我们的代码。
- en: For a clearer understanding, we will structure our code into two distinct sections.
    The first section will be titled `Register Definitions`, and the second will be
    named `Main Function`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地理解，我们将把我们的代码分为两个不同的部分。第一部分将命名为 `寄存器定义`，第二部分将命名为 `主函数`。
- en: Register Definitions
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Register Definitions
- en: 'This section of the code defines constants and macros for memory addresses
    and bit masks. Here are all the memory addresses and bit masks required for controlling
    the LED connected to PA5:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了用于内存地址和位掩码的常量和宏。以下是控制连接到 PA5 的 LED 所需的所有内存地址和位掩码：
- en: '[PRE9]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '// Line 17: Start of main function'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: // 行 17：main 函数开始
- en: int main(void)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '//  18: Enable clock access to GPIOA'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: // 18：启用对 GPIOA 的时钟访问
- en: RCC_AHB1EN_R |= GPIOAEN;
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: RCC_AHB1EN_R |= GPIOAEN;
- en: 'GPIOA_MODE_R |= (1U<<10);  //  19: Set bit 10 to 1'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOA_MODE_R |= (1U<<10);  // 19：将位 10 设置为 1
- en: 'GPIOA_MODE_R &= ~(1U<<11); //  20: Set bit 11 to 0'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOA_MODE_R &= ~(1U<<11); // 20：将位 11 设置为 0
- en: '//  21: Start of infinite loop'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: // 21：无限循环开始
- en: while(1)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '// Line 22: Set PA5(LED_PIN) high'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: // 22：将 PA5(LED_PIN) 设置为高
- en: GPIOA_OD_R |= LED_PIN;
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOA_OD_R |= LED_PIN;
- en: '}  //  23: End of infinite loop'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '}  // 23：无限循环结束'
- en: '}  //  24: End of main function'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '}  // 24：main 函数结束'
- en: '[PRE10]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '// Line 17: Start of main function'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 17：main 函数开始
- en: int main(void)
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '[PRE11]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '// Line 18: Enable clock access to GPIOA'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 18：启用对 GPIOA 的时钟访问
- en: RCC_AHB1EN_R |= GPIOAEN;
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RCC_AHB1EN_R |= GPIOAEN;
- en: '[PRE12]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'GPIOA_MODE_R |= (1U<<10);  // Line 19: Set bit 10 to 1'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GPIOA_MODE_R |= (1U<<10);  // 行 19：将位 10 设置为 1
- en: 'GPIOA_MODE_R &= ~(1U<<11); // Line 20: Set bit 11 to 0'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GPIOA_MODE_R &= ~(1U<<11); // 行 20：将位 11 设置为 0
- en: '[PRE13]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '// Line 21: Start of infinite loop'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 21：无限循环开始
- en: while(1)
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '// Line 22: Set PA5(LED_PIN) high'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 22：将 PA5(LED_PIN) 设置为高
- en: GPIOA_OD_R |= LED_PIN;
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GPIOA_OD_R |= LED_PIN;
- en: '}  // Line 23: End of infinite loop'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}  // 行 23：无限循环结束'
- en: '[PRE14]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '}  // Line 24: End of main function'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}  // 24：main 函数结束'
- en: '[PRE15]'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '//  1: Define base address for peripherals'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: // 1：定义外设的基址
- en: '#define PERIPH_BASE        (0x40000000UL)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '#define PERIPH_BASE        (0x40000000UL)'
- en: '//  2: Offset for AHB1 peripheral bus'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: // 2：AHB1 外设总线偏移量
- en: '#define AHB1PERIPH_OFFSET  (0x00020000UL)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '#define AHB1PERIPH_OFFSET  (0x00020000UL)'
- en: '//  3: Base address for AHB1 peripherals'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: // 3：AHB1 外设的基址
- en: '#define AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '#define AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)'
- en: '//  4: Offset for GPIOA'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '//  4: GPIOA的偏移量'
- en: '#define GPIOA_OFFSET       (0x0000UL)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '#define GPIOA_OFFSET       (0x0000UL)'
- en: '//  5: Base address for GPIOA'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '//  5: GPIOA的基址'
- en: '#define GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '#define GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)'
- en: '//  6: Offset for RCC'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '//  6: RCC的偏移量'
- en: '#define RCC_OFFSET         (0x3800UL)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '#define RCC_OFFSET         (0x3800UL)'
- en: '//  7: Base address for RCC'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '//  7: RCC的基址'
- en: '#define RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '#define RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)'
- en: '//  8: Offset for AHB1EN register'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '//  8: AHB1EN寄存器的偏移量'
- en: '#define AHB1EN_R_OFFSET    (0x30UL)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '#define AHB1EN_R_OFFSET    (0x30UL)'
- en: '//  9: Address of AHB1EN register'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '//  9: AHB1EN寄存器的地址'
- en: '#define RCC_AHB1EN_R  (*(volatile unsigned int *)(RCC_BASE +  AHB1EN_R_OFFSET))'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '#define RCC_AHB1EN_R  (*(volatile unsigned int *)(RCC_BASE +  AHB1EN_R_OFFSET))'
- en: '//  10: Offset for mode register'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '//  10: 模式寄存器的偏移量'
- en: '#define MODE_R_OFFSET      (0x00UL)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '#define MODE_R_OFFSET      (0x00UL)'
- en: '//  11: Address of GPIOA mode register'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '//  11: GPIOA模式寄存器的地址'
- en: '#define GPIOA_MODE_R  (*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '#define GPIOA_MODE_R  (*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))'
- en: '//  12: Offset for output data register'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '//  12: 输出数据寄存器的偏移量'
- en: '#define OD_R_OFFSET   (0x14UL)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '#define OD_R_OFFSET   (0x14UL)'
- en: '//  13: Address of GPIOA output data register'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '//  13: GPIOA输出数据寄存器的地址'
- en: '#define GPIOA_OD_R    (*(volatile unsigned int *)(GPIOA_BASE +  OD_R_OFFSET))'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '#define GPIOA_OD_R    (*(volatile unsigned int *)(GPIOA_BASE +  OD_R_OFFSET))'
- en: '//  14: Bit mask for enabling GPIOA (bit 0)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '//  14: 使能GPIOA的位掩码（位0）'
- en: '#define GPIOAEN       (1U<<0)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '#define GPIOAEN       (1U<<0)'
- en: '//  15: Bit mask for GPIOA pin 5'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '//  15: GPIOA引脚5的位掩码'
- en: '#define PIN5          (1U<<5)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '#define PIN5          (1U<<5)'
- en: '//  16: Alias for PIN5 representing LED pin'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '//  16: 代表LED引脚的PIN5的别名'
- en: '#define LED_PIN       PIN5'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '#define LED_PIN       PIN5'
- en: '//  17: Start of main function'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '//  17: 主函数开始'
- en: int main(void)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '//  18: Enable clock access to GPIOA'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '//  18: 使能GPIOA的时钟访问'
- en: RCC_AHB1EN_R |= GPIOAEN;
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: RCC_AHB1EN_R |= GPIOAEN;
- en: 'GPIOA_MODE_R |= (1U<<10);  //  19: Set bit 10 to 1'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'GPIOA_MODE_R |= (1U<<10);  //  19: 将位10设置为1'
- en: 'GPIOA_MODE_R &= ~(1U<<11); //  20: Set bit 11 to 0'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'GPIOA_MODE_R &= ~(1U<<11); //  20: 将位11设置为0'
- en: '//  21: Start of infinite loop'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '//  21: 无限循环开始'
- en: while(1)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '//  22: Set PA5(LED_PIN) high'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '//  22: 将PA5(LED_PIN)置高'
- en: GPIOA_OD_R |= LED_PIN;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOA_OD_R |= LED_PIN;
- en: '}  //  23: End of infinite loop'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '}  //  23: 无限循环结束'
- en: '}  //  24: End of main function'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '}  //  24: 主函数结束'
- en: '[PRE16]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
