["```cpp\n      #include <iostream>\n      #include <chrono>\n      #include <ratio>\n      #include <cmath>\n      #include <iomanip>\n      #include <optional>      \n\n      using namespace std;\n```", "```cpp\n      using seconds = chrono::duration<double>;\n```", "```cpp\n      using milliseconds = chrono::duration<\n          double, ratio_multiply<seconds::period, milli>>;\n```", "```cpp\n      using microseconds = chrono::duration<\n          double, ratio_multiply<seconds::period, micro>>;\n```", "```cpp\n      static pair<string, seconds> get_input()\n      {\n          string s;\n```", "```cpp\n          const auto tic (chrono::steady_clock::now());\n```", "```cpp\n          if (!(cin >> s)) {\n              return {{}, {}};\n          }\n```", "```cpp\n          const auto toc (chrono::steady_clock::now());\n\n          return {s, toc - tic};\n      }\n```", "```cpp\n      int main()\n      {\n          while (true) {\n              cout << \"Please type the word \"C++17\" as\"\n                      \" fast as you can.n> \";\n\n              const auto [user_input, diff] = get_input();\n```", "```cpp\n              if (user_input == \"\") { break; }\n```", "```cpp\n              if (user_input == \"C++17\") {\n                  cout << \"Bravo. You did it in:n\" \n                       << fixed << setprecision(2)\n                       << setw(12) << diff.count() \n                       << \" seconds.n\"\n                       << setw(12) << milliseconds(diff).count()\n                       << \" milliseconds.n\"\n                       << setw(12) << microseconds(diff).count()\n                       << \" microseconds.n\";\n                  break;\n```", "```cpp\n              } else {\n                  cout << \"Sorry, your input does not match.\"\n                          \" You may try again.n\";\n              }\n          }\n      }\n```", "```cpp\n      $ ./ratio_conversion \n      Please type the word \"C++17\" as fast as you can.\n      > c+17\n      Sorry, your input does not match. You may try again.\n      Please type the word \"C++17\" as fast as you can.\n      > C++17\n      Bravo. You did it in:\n              1.48 seconds.\n           1480.10 milliseconds.\n        1480099.00 microseconds.\n```", "```cpp\ntemplate<\n    class Rep, \n    class Period = std::ratio<1> \n> class duration;\n```", "```cpp\nusing seconds      = chrono::duration<double>;\nusing milliseconds = chrono::duration<double, \n ratio_multiply<seconds::period, milli>>;\nusing microseconds = chrono::duration<double, \n ratio_multiply<seconds::period, micro>>;\n```", "```cpp\nusing seconds      = chrono::duration<double, ratio<1, 1>>;\nusing milliseconds = chrono::duration<double, ratio<1, 1000>>;\nusing microseconds = chrono::duration<double, ratio<1, 1000000>>;\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <chrono>      \n\n      using namespace std;\n```", "```cpp\n      ostream& operator<<(ostream &os, \n                    const chrono::time_point<chrono::system_clock> &t)\n      {\n          const auto tt   (chrono::system_clock::to_time_t(t));\n          const auto loct (std::localtime(&tt));\n          return os << put_time(loct, \"%c\");\n      }\n```", "```cpp\n      using days = chrono::duration<\n          chrono::hours::rep,\n          ratio_multiply<chrono::hours::period, ratio<24>>>;\n```", "```cpp\n      constexpr days operator \"\"_days(unsigned long long h)\n      {\n          return days{h};\n      }\n```", "```cpp\n      int main()\n      {\n          auto now (chrono::system_clock::now());\n\n          cout << \"The current date and time is \" << now << 'n';\n```", "```cpp\n          chrono::hours chrono_12h {12};\n\n          cout << \"In 12 hours, it will be \"\n               << (now + chrono_12h)<< 'n';\n```", "```cpp\n          using namespace chrono_literals;\n\n          cout << \"12 hours and 15 minutes ago, it was \"\n               << (now - 12h - 15min) << 'n'\n               << \"1 week ago, it was \"\n               << (now - 7_days) << 'n';\n      }\n```", "```cpp\n $ ./relative_absolute_times \n      The current date and time is Fri May  5 13:20:38 2017\n      In 12 hours, it will be Sat May  6 01:20:38 2017\n      12 hours and 15 minutes ago, it was Fri May  5 01:05:38 2017\n      1 week ago, it was Fri Apr 28 13:20:38 2017\n```", "```cpp\nostream& operator<<(ostream &os, \n                    const chrono::time_point<chrono::system_clock> &t)\n{\n    const auto tt   (chrono::system_clock::to_time_t(t));\n    const auto loct (std::localtime(&tt));\n    return os << put_time(loct, \"%c\");\n}\n```", "```cpp\n      #include <iostream>\n      #include <optional>     \n\n      using namespace std;\n```", "```cpp\n      using oint = optional<int>;\n```", "```cpp\n      oint read_int()\n      {\n          int i;\n          if (cin >> i) { return {i}; }\n          return {};\n      }\n```", "```cpp\n      oint operator+(oint a, oint b)\n      {\n          if (!a || !b) { return {}; }\n\n          return {*a + *b};\n      }\n```", "```cpp\n      oint operator+(oint a, int b)\n      {\n          if (!a) { return {}; }\n\n          return {*a + b};\n      }\n```", "```cpp\n      int main()\n      {\n          cout << \"Please enter 2 integers.n> \";\n\n          auto a {read_int()};\n          auto b {read_int()};\n```", "```cpp\n          auto sum (a + b + 10);\n```", "```cpp\n          if (sum) {\n             cout << *a << \" + \" << *b << \" + 10 = \"\n                  << *sum << 'n';\n```", "```cpp\n          } else {\n             cout << \"sorry, the input was \"\n                     \"something else than 2 numbers.n\";\n          }\n      }\n```", "```cpp\n      $ ./optional \n      Please enter 2 integers.\n      > 1 2\n      1 + 2 + 10 = 13\n```", "```cpp\n      $ ./optional \n      Please enter 2 integers.\n      > 2 z\n      sorry, the input was something else than 2 numbers.\n```", "```cpp\ncout << \"Please enter 3 numbers:n\";\n\ntry {\n    cout << \"Sum: \" \n         << (*read_int() + *read_int() + *read_int()) \n         << 'n';\n} catch (const std::bad_optional_access &) {\n    cout << \"Unfortunately you did not enter 3 numbersn\";\n}\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <tuple>\n      #include <functional>\n      #include <string>\n      #include <list>      \n\n      using namespace std;\n```", "```cpp\n      static void print_student(size_t id, const string &name, double gpa)\n      {\n          cout << \"Student \" << quoted(name) \n               << \", ID: \"   << id \n               << \", GPA: \"  << gpa << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          using student = tuple<size_t, string, double>;\n          student john {123, \"John Doe\"s, 3.7};\n```", "```cpp\n          {\n              const auto &[id, name, gpa] = john;\n              print_student(id, name, gpa);\n          }\n          cout << \"-----n\";\n```", "```cpp\n          auto arguments_for_later = {\n              make_tuple(234, \"John Doe\"s,  3.7),\n              make_tuple(345, \"Billy Foo\"s, 4.0),\n              make_tuple(456, \"Cathy Bar\"s, 3.5),\n          };\n```", "```cpp\n          for (const auto &[id, name, gpa] : arguments_for_later) {\n              print_student(id, name, gpa);\n          }\n          cout << \"-----n\";\n```", "```cpp\n          apply(print_student, john);\n          cout << \"-----n\";\n```", "```cpp\n          for (const auto &args : arguments_for_later) {\n              apply(print_student, args);\n          }\n          cout << \"-----n\";\n      }\n```", "```cpp\n      $ ./apply_functions_on_tuples \n      Student \"John Doe\", ID: 123, GPA: 3.7\n      -----\n      Student \"John Doe\", ID: 234, GPA: 3.7\n      Student \"Billy Foo\", ID: 345, GPA: 4\n      Student \"Cathy Bar\", ID: 456, GPA: 3.5\n      -----\n      Student \"John Doe\", ID: 123, GPA: 3.7\n      -----\n      Student \"John Doe\", ID: 234, GPA: 3.7\n      Student \"Billy Foo\", ID: 345, GPA: 4\n      Student \"Cathy Bar\", ID: 456, GPA: 3.5\n      -----\n```", "```cpp\nstruct Foo {\n    int a;\n    string b;\n    float c;\n};\n```", "```cpp\nusing Foo = tuple<int, string, float>;\n```", "```cpp\n      #include <iostream>\n      #include <tuple>\n      #include <list>\n      #include <utility>\n      #include <string>\n      #include <iterator>\n      #include <numeric>\n      #include <algorithm>      \n\n      using namespace std;\n```", "```cpp\n      template <typename T, typename ... Ts>\n      void print_args(ostream &os, const T &v, const Ts &...vs)\n      {\n          os << v;\n```", "```cpp\n          (void)initializer_list<int>{((os << \", \" << vs), 0)...};\n      }\n```", "```cpp\n      template <typename ... Ts>\n      ostream& operator<<(ostream &os, const tuple<Ts...> &t)\n      {\n```", "```cpp\n          auto print_to_os ([&os](const auto &...xs) {\n              print_args(os, xs...);\n          });\n```", "```cpp\n          os << \"(\";\n          apply(print_to_os, t);\n          return os << \")\";\n      }\n```", "```cpp\n      template <typename T>\n      tuple<double, double, double, double>\n      sum_min_max_avg(const T &range)\n      {\n```", "```cpp\n          auto min_max (minmax_element(begin(range), end(range)));\n          auto sum     (accumulate(begin(range), end(range), 0.0));\n          return {sum, *min_max.first, *min_max.second, \n                  sum / range.size()};\n      }\n```", "```cpp\n      template <typename T1, typename T2>\n      static auto zip(const T1 &a, const T2 &b)\n      {\n```", "```cpp\n          auto z ([](auto ...xs) {\n              return [xs...](auto ...ys) {\n                  return tuple_cat(make_tuple(xs, ys) ...);\n              };\n          });\n```", "```cpp\n          return apply(apply(z, a), b);\n      }\n```", "```cpp\n      int main()\n      {\n          auto student_desc (make_tuple(\"ID\", \"Name\", \"GPA\"));\n          auto student      (make_tuple(123456, \"John Doe\", 3.7));\n```", "```cpp\n          cout << student_desc << 'n'\n               << student      << 'n';\n```", "```cpp\n          cout << tuple_cat(student_desc, student) << 'n';\n```", "```cpp\n          auto zipped (zip(student_desc, student));\n          cout << zipped << 'n';\n```", "```cpp\n          auto numbers = {0.0, 1.0, 2.0, 3.0, 4.0};\n          cout << zip(\n                  make_tuple(\"Sum\", \"Minimum\", \"Maximum\", \"Average\"),\n                  sum_min_max_avg(numbers))\n               << 'n';\n      }\n```", "```cpp\n      $ ./tuple\n      (ID, Name, GPA)\n      (123456, John Doe, 3.7)\n      (ID, Name, GPA, 123456, John Doe, 3.7)\n      (ID, 123456, Name, John Doe, GPA, 3.7)\n      (Sum, 10, Minimum, 0, Maximum, 4, Average, 2)\n```", "```cpp\ntemplate <typename T, typename ... Ts>\nvoid print_args(ostream &os, const T &v, const Ts &...vs)\n{\n    os << v;\n\n    (void)initializer_list<int>{((os << \", \" << vs), 0)...};\n}\n```", "```cpp\ntemplate <typename ... Ts>\nostream& operator<<(ostream &os, const tuple<Ts...> &t)\n{\n    auto capt_tup ([&os](const auto &...xs) {\n        print_args(os, xs...);\n    });\n\n    os << \"(\";\n    apply(capt_tup, t);\n    return os << \")\";\n}\n```", "```cpp\ntemplate <typename T1, typename T2>\nauto zip(const T1 &a, const T2 &b)\n{\n    auto z ([](auto ...xs) {\n        return [xs...](auto ...ys) {\n            return tuple_cat(make_tuple(xs, ys) ...);\n        };\n    });\n    return apply(apply(z, a), b);\n}\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <list>\n      #include <any>\n      #include <iterator>     \n\n      using namespace std;\n```", "```cpp\n      using int_list = list<int>;\n```", "```cpp\n      void print_anything(const std::any &a)\n      {\n```", "```cpp\n          if (!a.has_value()) {\n              cout << \"Nothing.n\";\n```", "```cpp\n          } else if (a.type() == typeid(string)) {\n              cout << \"It's a string: \"\n                   << quoted(any_cast<const string&>(a)) << 'n';\n```", "```cpp\n          } else if (a.type() == typeid(int)) {\n              cout << \"It's an integer: \"\n                   << any_cast<int>(a) << 'n';\n```", "```cpp\n          } else if (a.type() == typeid(int_list)) {\n              const auto &l (any_cast<const int_list&>(a));\n\n              cout << \"It's a list: \";\n              copy(begin(l), end(l), \n                   ostream_iterator<int>{cout, \", \"});\n              cout << 'n';\n```", "```cpp\n          } else {\n              cout << \"Can't handle this item.n\";\n          }\n      }\n```", "```cpp\n      int main()\n      {\n          print_anything({});\n          print_anything(\"abc\"s);\n          print_anything(123);\n          print_anything(int_list{1, 2, 3});\n```", "```cpp\n          print_anything(any(in_place_type_t<int_list>{}, {1, 2, 3}));\n      }\n```", "```cpp\n      $ ./any \n      Nothing.\n      It's a string: \"abc\"\n      It's an integer: 123\n      It's a list: 1, 2, 3, \n      It's a list: 1, 2, 3, \n```", "```cpp\nunion U { \n    int    a;\n    char  *b; \n    float  c;\n};\n\nvoid func(U u) { std::cout << u.b << 'n'; }\n```", "```cpp\n      #include <iostream>\n      #include <variant>\n      #include <list>\n      #include <string>\n      #include <algorithm>      \n\n      using namespace std;\n```", "```cpp\n      class cat {\n          string name;\n\n      public:\n          cat(string n) : name{n} {}\n\n          void meow() const {\n              cout << name << \" says Meow!n\";\n          }\n      };\n```", "```cpp\n      class dog {\n          string name;\n\n      public:\n          dog(string n) : name{n} {}\n\n          void woof() const {\n              cout << name << \" says Woof!n\";\n          }\n      };\n```", "```cpp\n      using animal = variant<dog, cat>;\n```", "```cpp\n      template <typename T>\n      bool is_type(const animal &a) {\n          return holds_alternative<T>(a);\n      }\n```", "```cpp\n      struct animal_voice\n      {\n          void operator()(const dog &d) const { d.woof(); }\n          void operator()(const cat &c) const { c.meow(); }\n      };\n```", "```cpp\n      int main()\n      {\n          list<animal> l {cat{\"Tuba\"}, dog{\"Balou\"}, cat{\"Bobby\"}};\n```", "```cpp\n          for (const animal &a : l) {\n              switch (a.index()) {\n              case 0: \n                  get<dog>(a).woof();\n                  break;\n              case 1:\n                  get<cat>(a).meow();\n                  break;\n              }\n          }\n          cout << \"-----n\";\n```", "```cpp\n          for (const animal &a : l) {\n              if (const auto d (get_if<dog>(&a)); d) {\n                  d->woof();\n              } else if (const auto c (get_if<cat>(&a)); c) {\n                  c->meow();\n              }\n          }\n          cout << \"-----n\";\n```", "```cpp\n          for (const animal &a : l) {\n              visit(animal_voice{}, a);\n          }\n          cout << \"-----n\";\n```", "```cpp\n          cout << \"There are \"\n               << count_if(begin(l), end(l), is_type<cat>)\n               << \" cats and \"\n               << count_if(begin(l), end(l), is_type<dog>)\n               << \" dogs in the list.n\";\n      }\n```", "```cpp\n      $ ./variant \n      Tuba says Meow!\n      Balou says Woof!\n      Bobby says Meow!\n      -----\n      Tuba says Meow!\n      Balou says Woof!\n      Bobby says Meow!\n      -----\n      Tuba says Meow!\n      Balou says Woof!\n      Bobby says Meow!\n      -----\n      There are 2 cats and 1 dogs in the list.\n```", "```cpp\nunion U {\n    A a;\n    B b;\n    C c;\n};\n```", "```cpp\nstruct animal_voice\n{\n    void operator()(const dog &d) const { d.woof(); }\n    void operator()(const cat &c) const { c.meow(); }\n};\n```", "```cpp\n      #include <iostream>\n      #include <memory>  \n\n      using namespace std;\n```", "```cpp\n      class Foo\n      {\n      public:\n          string name;\n\n          Foo(string n)\n              : name{move(n)}\n          { cout << \"CTOR \" << name << 'n'; }\n\n          ~Foo() { cout << \"DTOR \" << name << 'n'; }\n      };\n```", "```cpp\n      void process_item(unique_ptr<Foo> p)\n      {\n          if (!p) { return; }\n\n          cout << \"Processing \" << p->name << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          {\n              unique_ptr<Foo> p1 {new Foo{\"foo\"}};\n              auto            p2 (make_unique<Foo>(\"bar\"));\n          }\n```", "```cpp\n          process_item(make_unique<Foo>(\"foo1\"));\n```", "```cpp\n          auto p1 (make_unique<Foo>(\"foo2\"));\n          auto p2 (make_unique<Foo>(\"foo3\"));\n\n          process_item(move(p1));\n\n          cout << \"End of main()n\";\n      }\n```", "```cpp\n      $ ./unique_ptr \n      CTOR foo\n      CTOR bar\n      DTOR bar\n      DTOR foo\n      CTOR foo1\n      Processing foo1\n      DTOR foo1\n      CTOR foo2\n      CTOR foo3\n      Processing foo2\n      DTOR foo2\n      End of main()\n      DTOR foo3\n```", "```cpp\n      #include <iostream>\n      #include <memory>      \n\n      using namespace std;\n```", "```cpp\n      class Foo\n      {\n      public:\n          string name;\n\n          Foo(string n)\n              : name{move(n)}\n          { cout << \"CTOR \" << name << 'n'; }\n\n          ~Foo() { cout << \"DTOR \" << name << 'n'; }\n      };\n```", "```cpp\n      void f(shared_ptr<Foo> sp)\n      {\n          cout << \"f: use counter at \" \n               << sp.use_count() << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          shared_ptr<Foo> fa;\n```", "```cpp\n          {\n              cout << \"Inner scope beginn\";\n\n              shared_ptr<Foo> f1 {new Foo{\"foo\"}};\n              auto            f2 (make_shared<Foo>(\"bar\"));\n```", "```cpp\n              cout << \"f1's use counter at \" << f1.use_count() << 'n';\n              fa = f1;\n              cout << \"f1's use counter at \" << f1.use_count() << 'n';\n```", "```cpp\n          }\n          cout << \"Back to outer scopen\";\n\n          cout << fa.use_count() << 'n';\n```", "```cpp\n          cout << \"first f() calln\";\n          f(fa);\n          cout << \"second f() calln\";\n          f(move(fa));\n```", "```cpp\n          cout << \"end of main()n\";\n      }\n```", "```cpp\n      $ ./shared_ptr\n      Inner scope begin\n      CTOR foo\n      CTOR bar\n      f1's use counter at 1\n      f1's use counter at 2\n      DTOR bar\n      Back to outer scope\n      1\n      first f() call\n      f: use counter at 2\n      second f() call\n      f: use counter at 1\n      DTOR foo\n      end of main()\n```", "```cpp\nvoid function(shared_ptr<A>, shared_ptr<B>, int);\n// \"function\" is defined somewhere else\n\n// ...somewhere later in the code:\nfunction(new A{}, new B{}, other_function());\n```", "```cpp\n// 1.)\nfunction(make_shared<A>(), make_shared<B>(), other_function());\n\n// 2.)\nshared_ptr<A> ap {new A{}};\nshared_ptr<B> bp {new B{}};\nfunction(ap, bp, other_function());\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <memory>      \n\n      using namespace std;\n```", "```cpp\n      struct Foo {\n          int value;\n\n          Foo(int i) : value{i} {}\n          ~Foo() { cout << \"DTOR Foo \" << value << 'n'; }\n      };\n```", "```cpp\n      void weak_ptr_info(const weak_ptr<Foo> &p)\n      {\n          cout << \"---------\" << boolalpha\n               << \"nexpired:   \" << p.expired()\n               << \"nuse_count: \" << p.use_count()\n               << \"ncontent:   \";\n```", "```cpp\n          if (const auto sp (p.lock()); sp) {\n              cout << sp->value << 'n';\n          } else {\n              cout << \"<null>n\";\n          }\n      }\n```", "```cpp\n      int main()\n      {\n          weak_ptr<Foo> weak_foo;\n\n          weak_ptr_info(weak_foo);\n```", "```cpp\n          {\n              auto shared_foo (make_shared<Foo>(1337));\n              weak_foo = shared_foo;\n```", "```cpp\n              weak_ptr_info(weak_foo);\n          }\n\n          weak_ptr_info(weak_foo);\n      }\n```", "```cpp\n      $ ./weak_ptr \n      ---------\n      expired:   true\n      use_count: 0\n      content:   <null>\n      ---------\n      expired:   false\n      use_count: 1\n      content:   1337\n      DTOR Foo 1337\n      ---------\n      expired:   true\n      use_count: 0\n      content:   <null>\n```", "```cpp\n      #include <iostream>\n      #include <memory>\n      #include <string>      \n\n      using namespace std;\n```", "```cpp\n      class Foo\n      {\n          string name;\n\n          Foo(string n)\n              : name{n}\n          { cout << \"CTOR \" << name << 'n'; }\n\n          ~Foo() { cout << \"DTOR \" << name << 'n';}\n```", "```cpp\n      public:\n          static Foo* create_foo(string s) { \n             return new Foo{move(s)};\n          }\n\n          static void destroy_foo(Foo *p) { delete p; }\n      };\n```", "```cpp\n      static shared_ptr<Foo> make_shared_foo(string s)\n      {\n          return {Foo::create_foo(move(s)), Foo::destroy_foo};\n      }\n```", "```cpp\n      static unique_ptr<Foo, void (*)(Foo*)> make_unique_foo(string s)\n      {\n          return {Foo::create_foo(move(s)), Foo::destroy_foo};\n      }\n```", "```cpp\n      int main()\n      {\n          auto ps (make_shared_foo(\"shared Foo instance\"));\n          auto pu (make_unique_foo(\"unique Foo instance\"));\n      }\n```", "```cpp\n      $ ./legacy_shared_ptr \n      CTOR shared Foo instance\n      CTOR unique Foo instance\n      DTOR unique Foo instance\n      DTOR shared Foo instance\n```", "```cpp\n      #include <iostream>\n      #include <memory>\n      #include <string>      \n\n      using namespace std;\n```", "```cpp\n      struct person {\n          string name;\n          size_t age;\n\n          person(string n, size_t a)\n              : name{move(n)}, age{a}\n          { cout << \"CTOR \" << name << 'n'; }\n\n          ~person() { cout << \"DTOR \" << name << 'n'; }\n      };\n```", "```cpp\n      int main()\n      {\n          shared_ptr<string> shared_name;\n          shared_ptr<size_t> shared_age;\n```", "```cpp\n          {\n              auto sperson (make_shared<person>(\"John Doe\", 30));\n```", "```cpp\n              shared_name = shared_ptr<string>(sperson, &sperson->name);\n              shared_age  = shared_ptr<size_t>(sperson, &sperson->age);\n          }\n```", "```cpp\n          cout << \"name: \"  << *shared_name\n               << \"nage: \" << *shared_age << 'n';\n      }\n```", "```cpp\n      $ ./shared_members \n      CTOR John Doe\n      name: John Doe\n      age:  30\n      DTOR John Doe\n```", "```cpp\nauto sperson (make_shared<person>(\"John Doe\", 30));\nauto sname   (shared_ptr<string>(sperson, &sperson->name));\n```", "```cpp\n      #include <iostream>\n      #include <string>\n      #include <vector>\n      #include <random>\n      #include <iomanip>\n      #include <limits>\n      #include <cstdlib>\n      #include <algorithm>      \n\n      using namespace std;\n```", "```cpp\n      template <typename RD>\n      void histogram(size_t partitions, size_t samples)\n      {\n          using rand_t = typename RD::result_type;\n          partitions = max<size_t>(partitions, 10);\n```", "```cpp\n          RD rd;\n          rand_t div ((double(RD::max()) + 1) / partitions);\n```", "```cpp\n          vector<size_t> v (partitions);\n          for (size_t i {0}; i < samples; ++i) { \n              ++v[rd() / div];\n          }\n```", "```cpp\n          rand_t max_elm (*max_element(begin(v), end(v)));\n          rand_t max_div (max(max_elm / 100, rand_t(1)));\n```", "```cpp\n          for (size_t i {0}; i < partitions; ++i) {\n              cout << setw(2) << i << \": \"\n                   << string(v[i] / max_div, '*') << 'n';\n          }\n      }\n```", "```cpp\n      int main(int argc, char **argv)\n      {\n          if (argc != 3) {\n              cout << \"Usage: \" << argv[0] \n                   << \" <partitions> <samples>n\";\n              return 1;\n          }\n```", "```cpp\n          size_t partitions {stoull(argv[1])};\n          size_t samples    {stoull(argv[2])};\n```", "```cpp\n          cout << \"random_device\" << 'n';\n          histogram<random_device>(partitions, samples);\n```", "```cpp\n          cout << \"ndefault_random_engine\" << 'n';\n          histogram<default_random_engine>(partitions, samples);\n```", "```cpp\n          cout << \"nminstd_rand0\" << 'n';\n          histogram<minstd_rand0>(partitions, samples);\n          cout << \"nminstd_rand\" << 'n';\n          histogram<minstd_rand>(partitions, samples);\n\n          cout << \"nmt19937\" << 'n';\n          histogram<mt19937>(partitions, samples);\n          cout << \"nmt19937_64\" << 'n';\n          histogram<mt19937_64>(partitions, samples);\n\n          cout << \"nranlux24_base\" << 'n';\n          histogram<ranlux24_base>(partitions, samples);\n          cout << \"nranlux48_base\" << 'n';\n          histogram<ranlux48_base>(partitions, samples);\n\n          cout << \"nranlux24\" << 'n';\n          histogram<ranlux24>(partitions, samples);\n          cout << \"nranlux48\" << 'n';\n          histogram<ranlux48>(partitions, samples);\n\n          cout << \"nknuth_b\" << 'n';\n          histogram<knuth_b>(partitions, samples);\n      }\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <random>\n      #include <map>\n      #include <string>\n      #include <algorithm>     \n\n      using namespace std;\n```", "```cpp\n      template <typename T>\n      void print_distro(T distro, size_t samples)\n      {\n          default_random_engine e;\n          map<int, size_t> m;\n```", "```cpp\n          for (size_t i {0}; i < samples; ++i) {\n              m[distro(e)] += 1;\n          }\n```", "```cpp\n          size_t max_elm (max_element(begin(m), end(m),\n              [](const auto &a, const auto &b) { \n                   return a.second < b.second; \n              })->second);\n          size_t max_div (max(max_elm / 100, size_t(1)));\n```", "```cpp\n          for (const auto [randval, count] : m) {\n              if (count < max_elm / 200) { continue; }\n\n              cout << setw(3) << randval << \" : \"\n                   << string(count / max_div, '*') << 'n';\n          }\n      }\n```", "```cpp\n      int main(int argc, char **argv)\n      {\n          if (argc != 2) {\n              cout << \"Usage: \" << argv[0] \n                   << \" <samples>n\";\n              return 1;\n          }\n```", "```cpp\n          size_t samples {stoull(argv[1])};\n```", "```cpp\n          cout << \"uniform_int_distributionn\";\n          print_distro(uniform_int_distribution<int>{0, 9}, samples);\n\n          cout << \"normal_distributionn\";\n          print_distro(normal_distribution<double>{0.0, 2.0}, samples);\n```", "```cpp\n          initializer_list<double> intervals {0, 5, 10, 30};\n          initializer_list<double> weights {0.2, 0.3, 0.5};\n          cout << \"piecewise_constant_distributionn\";\n          print_distro(\n              piecewise_constant_distribution<double>{\n                  begin(intervals), end(intervals), \n                  begin(weights)}, \n             samples);\n```", "```cpp\n          cout << \"piecewise_linear_distributionn\";\n          initializer_list<double> weights2 {0, 1, 1, 0};\n          print_distro(\n              piecewise_linear_distribution<double>{\n                  begin(intervals), end(intervals), begin(weights2)}, \n              samples);\n```", "```cpp\n          cout << \"bernoulli_distributionn\";\n          print_distro(std::bernoulli_distribution{0.75}, samples);\n\n          cout << \"discrete_distributionn\";\n          print_distro(discrete_distribution<int>{{1, 2, 4, 8}}, samples);\n```", "```cpp\n          cout << \"binomial_distributionn\";\n          print_distro(binomial_distribution<int>{10, 0.3}, samples);\n          cout << \"negative_binomial_distributionn\";\n          print_distro(\n              negative_binomial_distribution<int>{10, 0.8}, \n              samples);\n          cout << \"geometric_distributionn\";\n          print_distro(geometric_distribution<int>{0.4}, samples);\n          cout << \"exponential_distributionn\";\n          print_distro(exponential_distribution<double>{0.4}, samples);\n          cout << \"gamma_distributionn\";\n          print_distro(gamma_distribution<double>{1.5, 1.0}, samples);\n          cout << \"weibull_distributionn\";\n          print_distro(weibull_distribution<double>{1.5, 1.0}, samples);\n          cout << \"extreme_value_distributionn\";\n          print_distro(\n              extreme_value_distribution<double>{0.0, 1.0}, \n              samples);\n          cout << \"lognormal_distributionn\";\n          print_distro(lognormal_distribution<double>{0.5, 0.5}, samples);\n          cout << \"chi_squared_distributionn\";\n          print_distro(chi_squared_distribution<double>{1.0}, samples);\n          cout << \"cauchy_distributionn\";\n          print_distro(cauchy_distribution<double>{0.0, 0.1}, samples);\n          cout << \"fisher_f_distributionn\";\n          print_distro(fisher_f_distribution<double>{1.0, 1.0}, samples);\n          cout << \"student_t_distributionn\";\n          print_distro(student_t_distribution<double>{1.0}, samples);\n      }\n```"]