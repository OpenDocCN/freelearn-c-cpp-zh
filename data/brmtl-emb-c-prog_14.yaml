- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: External Interrupts and Events (EXTI)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部中断和事件（EXTI）
- en: In this chapter, we will learn about interrupts and their critical role in embedded
    systems development. Interrupts are pivotal for creating responsive and efficient
    firmware, allowing microcontrollers to handle real-time events effectively. By
    understanding interrupts, you can develop systems that can react promptly to external
    stimuli, making your embedded applications more robust and versatile.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于中断及其在嵌入式系统开发中的关键作用。中断对于创建响应迅速且高效的固件至关重要，它允许微控制器有效地处理实时事件。通过理解中断，你可以开发出能够迅速对外部刺激做出反应的系统，使你的嵌入式应用更加健壮和多功能。
- en: We will begin by exploring the fundamental role of interrupts in firmware, contrasting
    them with exceptions to highlight their unique purposes and handling mechanisms.
    Following this, we will dive into the specifics of the **Interrupt Service Routine**
    (**ISR**), the **Interrupt Vector Table** (**IVT**), and the **Nested Vectored
    Interrupt Controller** (**NVIC**), which collectively form the backbone of interrupt
    handling in Arm Cortex-M microcontrollers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨中断在固件中的基本作用，通过与异常进行对比来突出它们独特的目的和处理机制。随后，我们将深入研究**中断服务例程**（**ISR**）、**中断向量表**（**IVT**）和**嵌套向量中断控制器**（**NVIC**）的细节，这些共同构成了Arm
    Cortex-M微控制器中断处理的核心。
- en: Next, we will focus on the STM32 **External Interrupt** (**EXTI**) controller,
    an essential peripheral for managing external interrupts in STM32 microcontrollers.
    We will examine the key features and registers of the EXTI controller, learning
    how to configure and utilize it for various applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于STM32 **外部中断**（**EXTI**）控制器，这是在STM32微控制器中管理外部中断的一个基本外围设备。我们将检查EXTI控制器的关键特性和寄存器，学习如何配置和利用它来满足各种应用需求。
- en: Finally, we will apply this knowledge by developing an EXTI driver, providing
    you with practical experience in implementing interrupt-driven firmware. This
    hands-on approach will solidify your understanding and enable you to create responsive,
    interrupt-based systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过开发EXTI驱动程序来应用这些知识，为你提供实现中断驱动固件的实践经验。这种动手方法将巩固你的理解，并使你能够创建响应迅速、基于中断的系统。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Interrupts and their role in firmware
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断及其在固件中的作用
- en: The STM32 EXTI controller
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32 EXTI控制器
- en: Developing the EXTI driver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发EXTI驱动程序
- en: By the end of this chapter, you will have a comprehensive understanding of interrupts
    and how to develop bare-metal EXTI drivers for STM32 microcontrollers, empowering
    you to create responsive and efficient embedded systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面理解中断以及如何为STM32微控制器开发裸机EXTI驱动程序，这将使你能够创建响应迅速且高效的嵌入式系统。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code examples for this chapter can be found on GitHub at the following
    link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在以下GitHub链接中找到：
- en: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)'
- en: Interrupts and their role in firmware
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断及其在固件中的作用
- en: Interrupts are one of the most critical mechanisms in embedded systems, allowing
    microcontrollers to react to real-time events efficiently. To fully appreciate
    their role in firmware, it’s essential to understand what interrupts are, how
    they work, and the various scenarios where they prove indispensable. So, let’s
    dive in and explore the fascinating world of interrupts, their operation, and
    their practical applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是嵌入式系统中最重要的机制之一，它允许微控制器有效地对实时事件做出反应。要充分理解它们在固件中的作用，了解中断是什么、它们如何工作以及它们在哪些场景中证明是不可或缺的至关重要。因此，让我们深入探索中断的迷人世界，它们的操作以及它们的实际应用。
- en: What are interrupts?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是中断？
- en: Imagine you’re deeply engrossed in reading a book but then the doorbell rings.
    You momentarily stop reading, attend to the visitor, and then return to your book.
    Interrupts in microcontrollers work similarly. They are signals that temporarily
    halt the current execution of a program to allow a special routine, known as an
    ISR, to run. Once the ISR completes, the microcontroller resumes its previous
    task right where it left off.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正全神贯注地读书，但这时门铃响了。你暂时停止阅读，接待访客，然后回到你的书。微控制器中的中断工作方式类似。它们是暂时停止程序当前执行的信号，以便运行一个称为ISR的特殊例程。一旦ISR完成，微控制器就会从上次中断的地方恢复其之前的任务。
- en: Interrupts can be triggered by hardware events, such as a timer overflow, a
    key press, or data reception on a communication interface. They can also be generated
    by software, providing a flexible way to manage both external and internal events.
    Now, let’s see how they work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 中断可以由硬件事件触发，例如定时器溢出、按键或通信接口上的数据接收。它们也可以由软件生成，提供了一种灵活的方式来管理外部和内部事件。现在，让我们看看它们是如何工作的。
- en: How do interrupts work?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断是如何工作的？
- en: 'At the heart of interrupt handling is the concept of context switching. When
    an interrupt occurs, the microcontroller saves its current state—essentially,
    a snapshot of all the important information, such as the program counter and CPU
    registers. This allows the microcontroller to pause its current task, execute
    the ISR, and then restore the saved state to continue where it left off. The process
    typically follows these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理的核心是上下文切换的概念。当中断发生时，微控制器保存其当前状态——本质上，是所有重要信息的快照，例如程序计数器和CPU寄存器。这允许微控制器暂停当前任务，执行中断服务例程（ISR），然后恢复保存的状态以继续之前中断的地方。这个过程通常遵循以下步骤：
- en: '**Interrupt request**: An event triggers an **Interrupt** **Request** (**IRQ**).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中断请求**：一个事件触发一个**中断** **请求**（**IRQ**）。'
- en: '**Acknowledge and prioritize**: The interrupt controller acknowledges the request
    and prioritizes it based on predefined levels.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确认并优先处理**：中断控制器确认请求并根据预定义的级别对其进行优先级排序。'
- en: '**Context save**: The CPU saves its current execution context.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存上下文**：CPU保存其当前的执行上下文。'
- en: '**Vector fetch**: The CPU fetches the address of the ISR from the IVT.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向量检索**：CPU从中断向量表（IVT）中检索ISR的地址。'
- en: '**ISR execution**: The ISR runs to handle the interrupt.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ISR执行**：ISR运行以处理中断。'
- en: '**Context restore**: After the ISR completes, the CPU restores the saved context.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**恢复上下文**：在ISR完成后，CPU恢复保存的上下文。'
- en: '**Resume execution**: The CPU resumes the interrupted task.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**恢复执行**：CPU恢复中断的任务。'
- en: You may wonder why interrupts are important. Let’s find out.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么中断很重要。让我们来了解一下。
- en: Importance of interrupts in firmware
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断在固件中的重要性
- en: 'Interrupts are important for creating efficient and responsive embedded systems.
    Here are some key reasons why they are so important:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 中断对于创建高效和响应灵敏的嵌入式系统至关重要。以下是它们之所以如此重要的几个关键原因：
- en: '**Real-time response**: Interrupts allow a microcontroller to react almost
    instantaneously to critical events. For instance, in a motor control system, an
    interrupt can immediately handle a sensor signal indicating that the motor has
    reached its desired position.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时响应**：中断允许微控制器对关键事件做出几乎瞬时的反应。例如，在电机控制系统中，一个中断可以立即处理一个表示电机已达到期望位置的传感器信号。'
- en: '**Resource optimization**: Instead of constantly polling for events (which
    wastes CPU cycles and power), interrupts enable the CPU to remain in a low-power
    state or focus on other tasks until an event occurs. This optimization is crucial
    for battery-powered devices such as wearables or remote sensors.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源优化**：而不是不断轮询事件（这浪费了CPU周期和电力），中断允许CPU保持低功耗状态或专注于其他任务，直到事件发生。这种优化对于可穿戴设备或远程传感器等电池供电设备至关重要。'
- en: '**Prioritization and preemption**: Interrupts can be prioritized, allowing
    more critical tasks to preempt less critical ones. This ensures that high-priority
    tasks, such as emergency stop signals in industrial machinery, are addressed immediately.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级和抢占**：中断可以被优先级排序，允许更关键的任务抢占不那么关键的任务。这确保了像工业机械中的紧急停止信号这样的高优先级任务能够立即得到处理。'
- en: 'When discussing interrupts, we often encounter another key term: exceptions.
    Although they share similarities, they serve different purposes in embedded systems.
    Let’s explore the differences between interrupts and exceptions.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论中断时，我们经常遇到另一个关键术语：异常。尽管它们有相似之处，但在嵌入式系统中它们有不同的用途。让我们来探讨中断和异常之间的区别。
- en: Interrupts versus exceptions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断与异常的比较
- en: Interrupts are signals from hardware or software indicating an event that needs
    immediate attention. Examples include timer overflows, GPIO pin changes, and peripheral
    data reception.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是硬件或软件发出的信号，指示需要立即关注的事件。例如，定时器溢出、GPIO 引脚变化和外设数据接收。
- en: As we learned earlier, interrupts enable embedded systems to handle real-time
    events and are essential for responsive and efficient system behavior. When an
    interrupt occurs, the CPU stops executing the main program and jumps to a predefined
    address to execute the ISR.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，中断使嵌入式系统能够处理实时事件，对于响应和高效的系统行为至关重要。当中断发生时，CPU 停止执行主程序，跳转到一个预定义的地址来执行
    ISR。
- en: Exceptions are events that disrupt the normal execution flow, often due to errors
    such as divide-by-zero operations or accessing invalid memory addresses. While
    similar to interrupts, exceptions typically handle error conditions and system-level
    events.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是中断正常执行流程的事件，通常是由于除以零操作或访问无效内存地址等错误引起的。虽然与中断类似，但异常通常处理错误条件和系统级事件。
- en: Differences between interrupts and exceptions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断与异常的区别
- en: 'Here are some of the differences between the two:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两者之间的一些区别：
- en: '**Source**: Interrupts usually originate from external hardware devices or
    other peripherals within the microcontroller, while exceptions are typically the
    result of internal CPU operations'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源**：中断通常来自外部硬件设备或微控制器内的其他外设，而异常通常是内部 CPU 操作的结果'
- en: '**Purpose**: Interrupts manage real-time events, whereas exceptions handle
    error conditions and system anomalies'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的**：中断管理实时事件，而异常处理错误条件和系统异常'
- en: '**Handling**: Both use ISRs, but exceptions often involve more complex error
    handling and recovery mechanisms'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理**：两者都使用 ISR，但异常通常涉及更复杂的错误处理和恢复机制'
- en: 'To properly understand how interrupts are handled, we need to examine the three
    key components involved: the NVIC, the ISR, and the IVT.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确理解中断的处理方式，我们需要检查涉及到的三个关键组件：NVIC、ISR 和 IVT。
- en: The NVIC, ISR, and IVT
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NVIC、ISR 和 IVT
- en: The NVIC in Arm Cortex-M microcontrollers, such as the STM32 series, plays a
    pivotal role in managing interrupts. Let’s explore what the NVIC is, how it works,
    and why it’s so important for embedded development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arm Cortex-M 微控制器（如 STM32 系列）中，NVIC 在管理中断方面发挥着关键作用。让我们来探讨 NVIC 是什么，它是如何工作的，以及为什么它对嵌入式开发如此重要。
- en: The NVIC
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NVIC
- en: The NVIC is a hardware module integrated into Arm Cortex-M microcontrollers
    that manages the prioritization and handling of interrupts. It enables the microcontroller
    to respond to interrupts quickly and efficiently, while also allowing for nested
    interrupts, where higher-priority interrupts can preempt lower-priority ones.
    This capability is essential for real-time applications where timely responses
    to events are critical.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NVIC 是集成到 Arm Cortex-M 微控制器（如 STM32 系列）中的硬件模块，它负责管理中断的优先级和处理。它使微控制器能够快速有效地响应中断，同时允许嵌套中断，其中高优先级的中断可以抢占低优先级的中断。这种能力对于需要及时响应事件的实时应用至关重要。
- en: 'Its key features include the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它的关键特性包括以下内容：
- en: '**Interrupt prioritization**: The NVIC supports multiple priority levels, allowing
    us to assign different priorities to different interrupts. This ensures that more
    critical tasks are handled first.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断优先级**：NVIC 支持多个优先级，允许我们为不同的中断分配不同的优先级。这确保了更关键的任务首先得到处理。'
- en: '**Nested interrupts**: The NVIC allows higher-priority interrupts to interrupt
    lower-priority ones. This feature is crucial for maintaining system responsiveness
    in real-time applications.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套中断**：NVIC 允许高优先级的中断中断低优先级的中断。这一特性对于保持实时应用中的系统响应性至关重要。'
- en: '**Dynamic priority adjustment**: We can dynamically adjust the priority of
    interrupts during runtime, providing flexibility to adapt to changing conditions.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态优先级调整**：我们可以在运行时动态调整中断的优先级，以适应不断变化的情况。'
- en: The diagram in *Figure 14**.1* illustrates the NVIC and its connections to various
    components within the microcontroller.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 14.1* 中的图表说明了 NVIC 及其与微控制器内各种组件的连接。'
- en: '![Figure 14.1: The NVIC](img/B21914_14_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1：NVIC](img/B21914_14_1.jpg)'
- en: 'Figure 14.1: The NVIC'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：NVIC
- en: Next, we have the ISR.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看 ISR。
- en: The ISR
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ISR
- en: The ISR is a crucial piece of the puzzle when it comes to handling interrupts
    in embedded systems. The ISR is a specialized function that the CPU executes in
    response to an interrupt. Every interrupt has its own ISR. When an interrupt occurs,
    the CPU temporarily halts its current task, saves its state, and jumps to the
    ISR’s predefined address (function) to execute the necessary code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中处理中断时，ISR（中断服务例程）是谜题的关键部分。ISR是一个专门的功能，CPU在响应中断时执行。每个中断都有自己的ISR。当中断发生时，CPU暂时停止其当前任务，保存其状态，并跳转到ISR预定义的地址（函数）以执行必要的代码。
- en: The final critical component is the IVT.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个关键组件是IVT（中断向量表）。
- en: The IVT
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IVT
- en: The IVT is like the roadmap for the CPU when an interrupt occurs. It’s a data
    structure that holds the addresses of all the ISRs. Each interrupt source is assigned
    a specific entry in this table, mapping it to its corresponding ISR. When an interrupt
    is triggered, the CPU consults the IVT to find the address of the ISR associated
    with that interrupt. This lookup ensures that the CPU can quickly and efficiently
    jump to the right piece of code to handle the event.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生中断时，IVT就像是CPU的路线图。它是一个包含所有ISR地址的数据结构。每个中断源在这个表中都有一个特定的条目，将其映射到相应的ISR。当中断被触发时，CPU会咨询IVT以找到与该中断相关联的ISR的地址。这种查找确保CPU可以快速有效地跳转到正确的代码片段来处理事件。
- en: 'Its key features include the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它的关键特性包括以下内容：
- en: '`0x00000000`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00000000`。'
- en: '**ISR addresses**: Each entry in the IVT contains the address of an ISR. When
    an interrupt occurs, the CPU uses the IVT to quickly locate and jump to the appropriate
    ISR.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISR地址**：IVT中的每个条目都包含一个ISR的地址。当中断发生时，CPU使用IVT快速定位并跳转到适当的ISR。'
- en: '`0` might be for a reset interrupt, vector number `1` for a **non-maskable
    interrupt** (**NMI**), and so on.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`可能用于复位中断，向量号`1`用于**不可屏蔽中断**（NMI），等等。'
- en: '**Configurable**: In many systems, the IVT can be configured during system
    initialization to point to the ISRs defined in your firmware.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置性**：在许多系统中，IVT可以在系统初始化期间配置，以指向你的固件中定义的ISR。'
- en: Comparative analysis—interrupt-driven solutions versus polling-based solutions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较分析—中断驱动解决方案与基于轮询的解决方案
- en: But what happens when we don’t use interrupts? Let’s explore some real-world
    case studies to illustrate the difference between solutions using interrupts and
    those that rely on polling.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们不使用中断时会发生什么？让我们通过一些真实的案例研究来探讨使用中断和依赖于轮询的解决方案之间的差异。
- en: Case study 1—button debouncing
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 1—按钮去抖动
- en: 'In embedded systems, handling user inputs such as button presses is a common
    task. However, the way these inputs are managed can significantly impact the efficiency
    and responsiveness of the system. One particular issue is dealing with the problem
    of “bouncing,” where a mechanical button generates multiple rapid signals due
    to its physical characteristics. This can lead to incorrect readings and erratic
    behavior if not properly managed. In this case study, we will explore two approaches
    to handling button debouncing: one without interrupts and the other using interrupts.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，处理用户输入，如按钮按下，是一项常见任务。然而，这些输入的管理方式可以显著影响系统的效率和响应性。一个特别的问题是处理“抖动”问题，由于机械按钮的物理特性，它会产生多个快速信号。如果不妥善管理，这可能导致错误的读取和不规则的行为。在本案例研究中，我们将探讨两种处理按钮去抖动的方法：一种不使用中断，另一种使用中断。
- en: We’ll start with the approach that doesn’t use interrupts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从不使用中断的方法开始。
- en: Imagine you have a simple user interface with a button that, when pressed, toggles
    an LED. Without interrupts, the most straightforward approach is to continuously
    check (or “poll”) the button’s state in the main loop. This involves repeatedly
    reading the button’s input pin to see whether it has changed from high to low,
    indicating a press. The problem here is that mechanical buttons can generate spurious
    signals due to physical bouncing, leading to multiple detections of a single press.
    To handle this, you need to add a delay after detecting a press, effectively ignoring
    further signals for a short period.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个简单的用户界面，其中有一个按钮，当按下时，会切换LED的状态。在没有中断的情况下，最直接的方法是在主循环中持续检查（或“轮询”）按钮的状态。这涉及到反复读取按钮的输入引脚，以查看它是否从高电平变为低电平，指示按下。问题在于，机械按钮由于物理抖动可能会产生虚假信号，导致对单个按下的多次检测。为了处理这个问题，你需要在检测到按下后添加一个延迟，有效地忽略一段时间的进一步信号。
- en: 'There are a couple of drawbacks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些缺点：
- en: '**Inefficiency**: The CPU is constantly busy checking the button state, wasting
    valuable processing time that could be used for other tasks'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低效**：CPU不断忙于检查按钮状态，浪费了本可以用于其他任务的有价值的处理时间。'
- en: '**Delayed response**: Adding a delay to handle debouncing means the system
    might miss other important tasks while waiting for the button to stabilize'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟响应**：添加延迟以处理去抖动意味着系统可能在等待按钮稳定时错过其他重要任务。'
- en: Let’s look at the approach with interrupts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用中断的方法。
- en: Using interrupts, you configure the button pin to generate an interrupt on a
    falling edge (when the button is pressed). The ISR is triggered immediately when
    the button is pressed, handling the debouncing logic. The main loop remains free
    to perform other tasks without the overhead of constantly polling the button.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中断，您可以将按钮引脚配置为在下降沿（按钮被按下时）产生中断。当按钮被按下时，ISR会立即触发，处理去抖动逻辑。主循环保持空闲，可以执行其他任务，无需不断轮询按钮。
- en: 'There are a couple of benefits:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个好处：
- en: '**Efficiency**: The CPU can focus on other tasks and only respond to the button
    press when necessary'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：CPU可以专注于其他任务，并在必要时才响应按钮按下。'
- en: '**Immediate response**: The ISR responds instantly to the button press, making
    the system more responsive'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时响应**：ISR立即对按钮按下做出响应，使系统更具响应性。'
- en: Case study 2—sensor data acquisition
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 2—传感器数据获取
- en: 'Another common task in embedded systems is acquiring data from sensors, especially
    in applications such as weather stations, where multiple sensors continuously
    monitor environmental conditions. The method used to handle sensor data acquisition
    can greatly affect the system’s complexity and efficiency. Let’s compare two approaches:
    one without using interrupts and the other leveraging interrupts to optimize the
    process.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，另一个常见任务是获取传感器数据，特别是在气象站等应用中，多个传感器持续监控环境条件。处理传感器数据获取的方法可以极大地影响系统的复杂性和效率。让我们比较两种方法：一种不使用中断，另一种利用中断来优化过程。
- en: We’ll start with the approach that doesn’t use interrupts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从不使用中断的方法开始。
- en: Consider a weather station that reads data from various sensors such as temperature,
    humidity, and pressure at regular intervals. Without interrupts, the main loop
    would include code to periodically read data from each sensor. This could be done
    using timers to create delays between readings, ensuring data is acquired at the
    right intervals.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个气象站，它定期从各种传感器（如温度、湿度和压力）读取数据。如果没有使用中断，主循环将包括定期从每个传感器读取数据的代码。这可以通过定时器来实现，在读取之间创建延迟，确保数据在正确的间隔内获取。
- en: 'There are a couple of drawbacks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个缺点：
- en: '**Complexity**: Managing multiple sensors with precise timing using polling
    can lead to a complicated main loop'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：使用轮询管理多个传感器并精确计时可能导致主循环复杂化。'
- en: '**Inefficiency**: The main loop might spend a lot of time waiting for timers
    to expire—again, wasting CPU resources'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低效**：主循环可能会花费大量时间等待定时器到期——再次，浪费CPU资源。'
- en: Let’s look at the approach with interrupts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用中断的方法。
- en: Using interrupts, each sensor can trigger an interrupt when new data is available.
    The ISR for each sensor reads the data and stores it in a buffer for the main
    loop to process later. This approach decouples data acquisition from the main
    loop, allowing it to focus on data processing and other tasks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中断，每个传感器可以在新数据可用时触发中断。每个传感器的ISR读取数据并将其存储在缓冲区中，供主循环稍后处理。这种方法将数据获取与主循环解耦，允许它专注于数据处理和其他任务。
- en: 'There are a couple of benefits:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个好处：
- en: '**Simplified code**: The main loop is cleaner and easier to manage, as it doesn’t
    need to handle timing and sensor polling directly.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化代码**：主循环更简洁，更容易管理，因为它不需要直接处理定时和传感器轮询。'
- en: '**Resource efficiency**: The CPU spends less time waiting and more time processing,
    leading to more efficient use of resources.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源效率**：CPU花费更少的时间等待，更多的时间处理，从而更有效地利用资源。'
- en: Case study 3—communication protocols
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 3—通信协议
- en: 'Now, let’s see how interrupts can improve communication. Effective communication
    between a microcontroller and external devices is crucial for many embedded systems,
    whether you’re dealing with sensors, displays, or other peripherals. The approach
    you take to manage data transmission and reception can have a significant impact
    on your system’s performance, particularly in terms of CPU load and latency. Let’s
    analyze two methods for handling communication over **Universal Asynchronous Receiver/Transmitter**
    (**UART**): one without using interrupts and the other leveraging interrupts to
    optimize the process.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看中断如何改善通信。在许多嵌入式系统中，微控制器与外部设备之间的有效通信至关重要，无论您是处理传感器、显示器还是其他外围设备。您采取的数据传输和接收管理方法会对您的系统性能产生重大影响，尤其是在
    CPU 负载和延迟方面。让我们分析两种处理通过 **通用异步收发器/传输器**（**UART**）通信的方法：一种不使用中断，另一种利用中断来优化过程。
- en: We’ll start with the approach that doesn’t use interrupts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从不使用中断的方法开始。
- en: Let’s look at a scenario where a microcontroller communicates with another device
    over UART. Without interrupts, the firmware would continuously check the UART
    status register to see whether new data has arrived or whether the transmitter
    is ready to send data. This polling approach ensures no data is missed, but it
    can be very CPU-intensive.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这样一个场景：一个微控制器通过 UART 与另一个设备通信。如果没有中断，固件将不断检查 UART 状态寄存器，以查看是否有新数据到达或发送器是否准备好发送数据。这种轮询方法确保不会错过任何数据，但它可能会非常占用
    CPU 资源。
- en: 'There are a couple of drawbacks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个缺点：
- en: '**Resource efficiency**: Continuous polling keeps the CPU busy, leaving less
    processing power for other tasks'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源效率**：连续轮询使 CPU 忙碌，留给其他任务的处理器资源更少'
- en: '**Latency**: The time between data arrival and processing depends on how frequently
    the UART status is checked'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：数据到达和处理之间的时间取决于 UART 状态检查的频率'
- en: Let’s look at the approach with interrupts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用中断的方法。
- en: Enabling UART interrupts allows the microcontroller to handle data reception
    and transmission events automatically. When new data arrives, an interrupt is
    triggered, and the ISR reads the data and processes it. Similarly, when the transmitter
    is ready, another interrupt can handle sending data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 UART 中断允许微控制器自动处理数据接收和传输事件。当新数据到达时，会触发一个中断，ISR 读取数据并处理它。同样，当发送器准备好时，另一个中断可以处理发送数据。
- en: 'There are a couple of benefits:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个好处：
- en: '**Low CPU load**: The CPU can perform other tasks and only deal with UART events
    when necessary'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低 CPU 负载**：CPU 可以执行其他任务，仅在必要时处理 UART 事件'
- en: '**Real-time handling**: Data is processed immediately upon arrival, reducing
    latency and improving communication efficiency'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时处理**：数据到达后立即处理，减少延迟并提高通信效率'
- en: Interrupts provide a powerful and efficient way to handle real-time events in
    embedded systems. Compared to polling methods, interrupts offer significant benefits
    in terms of responsiveness, efficiency, and code simplicity. By understanding
    and leveraging interrupts, you can develop more robust and efficient firmware,
    capable of handling a wide range of real-time applications. Whether it’s managing
    user inputs, acquiring sensor data, handling communication protocols, or maintaining
    accurate timekeeping, interrupts are an indispensable tool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 中断为嵌入式系统中实时事件的处理提供了一种强大而高效的方法。与轮询方法相比，中断在响应性、效率和代码简单性方面提供了显著的好处。通过理解和利用中断，您可以开发出更健壮、更高效的固件，能够处理各种实时应用。无论是管理用户输入、获取传感器数据、处理通信协议还是保持精确的时间控制，中断都是不可或缺的工具。
- en: In the next section, we shall explore the STM32 EXTI controller peripheral.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 STM32 EXTI 控制器外设。
- en: The STM32 EXTI controller
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32 EXTI 控制器
- en: The EXTI module in STM32 microcontrollers is designed to manage external interrupt
    lines. These lines can be triggered by signals on GPIO pins, enabling your microcontroller
    to react to changes in the external environment quickly and efficiently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: STM32 微控制器中的 EXTI 模块旨在管理外部中断线。这些线可以被 GPIO 引脚上的信号触发，使您的微控制器能够快速有效地对外部环境的变化做出反应。
- en: The EXTI controller is equipped with a range of features that enhance its flexibility
    and utility in embedded systems. Let’s explore these features in detail and understand
    their practical applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI 控制器配备了一系列功能，增强了其在嵌入式系统中的灵活性和实用性。让我们详细探讨这些功能，并了解它们的实际应用。
- en: Key features of the EXTI
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXTI 的关键特性
- en: 'Here are the key features of the EXTI module that make it a versatile and powerful
    tool for managing external and internal events in STM32 microcontrollers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是EXTI模块的关键特性，使其成为STM32微控制器中管理外部和内部事件的灵活且强大的工具：
- en: Provides up to 23 independent interrupt/event lines, with up to 16 from GPIO
    pins, and the rest from internal signals
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多达23个独立的中断/事件线，其中最多16个来自GPIO引脚，其余来自内部信号
- en: Each line can be independently configured as either an interrupt or an event
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条线都可以独立配置为中断或事件
- en: 'Edge detection options for each line: rising, falling, or both edges'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条线的边缘检测选项：上升沿、下降沿或两者都检测
- en: Dedicated status flags for each line to indicate pending interrupts/events
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条线都有专用的状态标志来指示挂起的中断/事件
- en: Ability to generate software interrupts/events
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成软件中断/事件的能力
- en: An event registers that something happened by setting a corresponding status
    flag bit, but does not trigger an interrupt or execute any code (ISR).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 事件寄存器通过设置对应的状态标志位来表示发生了某些事件，但不触发中断或执行任何代码（ISR）。
- en: For example, events can be used to wake the system from sleep mode without executing
    an ISR.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，事件可以用来在没有执行ISR的情况下唤醒系统。
- en: To use the EXTI for generating interrupts, we need to configure and enable the
    interrupt line properly. This involves programming the trigger registers to detect
    the desired edge (rising, falling, or both) and enabling the IRQ by setting the
    appropriate bit in the interrupt mask register. When the specified edge is detected
    on the external interrupt line, an IRQ is generated, and the corresponding pending
    bit is set. This pending bit must be cleared by writing a *1* to it in the pending
    register.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用EXTI生成中断，我们需要正确配置和启用中断线。这涉及到编程触发寄存器以检测所需的边缘（上升沿、下降沿或两者），并通过在中断屏蔽寄存器中设置适当的位来启用IRQ。当检测到外部中断线上指定的边缘时，将生成一个IRQ，并设置相应的挂起位。必须通过在挂起寄存器中写入*1*来清除此挂起位。
- en: To generate events, we simply configure the event line by setting the appropriate
    trigger registers and enabling the corresponding bit in the event mask register.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成事件，我们只需通过设置适当的触发寄存器和在事件屏蔽寄存器中启用相应的位来配置事件线。
- en: We can also generate interrupts/events by software by writing a *1* to the software
    interrupt/event register (EXTI_SWIER).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过写入*1*到软件中断/事件寄存器（EXTI_SWIER）来通过软件生成中断/事件。
- en: 'Configuring the lines as interrupt sources involves three steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将线路配置为中断源涉及三个步骤：
- en: '**Configure mask bits**: Set the mask bits for the 23 interrupt lines using
    the **Interrupt Mask** **Register** (**EXTI_IMR**).'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置屏蔽位**：使用**中断屏蔽寄存器**（**EXTI_IMR**）设置23个中断线的屏蔽位。'
- en: '**Configure trigger selection bits**: Use the **Rising Trigger Selection Register**
    (**EXTI_RTSR**) and **Falling Trigger Selection Register** (**EXTI_FTSR**) to
    set the desired trigger conditions for the interrupt lines.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置触发选择位**：使用**上升沿触发选择寄存器**（**EXTI_RTSR**）和**下降沿触发选择寄存器**（**EXTI_FTSR**）来设置中断线的期望触发条件。'
- en: '**Enable the NVIC IRQ channel**: Over here, we simply configure the **enable**
    and **mask** bits that control the NVIC IRQ channel mapped to the EXTI.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用NVIC中断通道**：在这里，我们只需配置控制映射到EXTI的NVIC中断通道的**启用**和**屏蔽**位。'
- en: Before we develop the EXTI driver, let’s first understand how the EXTI lines
    are mapped to the GPIO pins.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发EXTI驱动程序之前，让我们首先了解EXTI线是如何映射到GPIO引脚上的。
- en: External interrupt/event line mapping
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部中断/事件线映射
- en: The EXTI controller can connect up to 81 GPIOs (in the STM32F411xC/E series)
    to the 16 external interrupt/event lines. The GPIO pins are mapped to the EXTI
    lines through the SYSCFG_EXTICR registers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI控制器可以将多达81个GPIO（在STM32F411xC/E系列中）连接到16个外部中断/事件线上。GPIO引脚通过SYSCFG_EXTICR寄存器映射到EXTI线上。
- en: GPIO pins and EXTI lines
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPIO引脚和EXTI线
- en: 'Each GPIO pin on the STM32 microcontroller can be connected to an EXTI line,
    allowing it to generate external interrupts. This flexibility means you can enable
    interrupts for any GPIO pin, but there’s a catch: multiple pins share the same
    EXTI line. This sharing is based on the pin number, not the port.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器上的每个GPIO引脚都可以连接到EXTI线，允许它生成外部中断。这种灵活性意味着您可以启用任何GPIO引脚的中断，但有一个限制：多个引脚共享相同的EXTI线。这种共享基于引脚号，而不是端口。
- en: 'Here’s a breakdown of how the pins are connected:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何连接引脚的分解：
- en: Pin 0 of every port is connected to EXTI0_IRQ
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个端口的第0个引脚连接到EXTI0_IRQ
- en: Pin 1 of every port is connected to EXTI1_IRQ
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个端口的第1个引脚连接到EXTI1_IRQ
- en: Pin 2 of every port is connected to EXTI2_IRQ
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个端口的第2个引脚连接到EXTI2_IRQ
- en: Pin 3 of every port is connected to EXTI3_IRQ
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个端口的第 3 个引脚连接到 EXTI3_IRQ
- en: And so on...
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等...
- en: This mapping means that all pins with the same number across different ports
    share the same EXTI line. For example, PA0, PB0, PC0, PD0, PE0, and PH0 are all
    connected to EXTI0.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射意味着不同端口的相同编号引脚共享相同的 EXTI 线。例如，PA0、PB0、PC0、PD0、PE0 和 PH0 都连接到 EXTI0。
- en: Important note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Shared EXTI lines**: Since multiple pins share the same EXTI line, you cannot
    enable interrupts on two pins with the same number across different ports simultaneously.
    For instance, if you enable an interrupt on PB0, you cannot also enable an interrupt
    on PA0 because both pins share EXTI0.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享 EXTI 线**：由于多个引脚共享相同的 EXTI 线，因此您不能同时在不同端口的相同编号的引脚上启用中断。例如，如果您在 PB0 上启用中断，则不能同时也在
    PA0 上启用中断，因为这两个引脚都共享 EXTI0。'
- en: '**Configuration in SYSCFG_EXTICR**: The SYSCFG **external interrupt configuration
    registers** (**EXTICRs**) are used to select which port’s pin will be connected
    to a particular EXTI line. This selection ensures that only one pin from one port
    can be the source for a given EXTI line.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 SYSCFG_EXTICR 中的配置**：SYSCFG 外部中断配置寄存器（EXTICRs）用于选择哪个端口的引脚将连接到特定的 EXTI 线。这种选择确保了只有一个端口的引脚可以作为给定
    EXTI 线的源。'
- en: Developing the EXTI driver
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 EXTI 驱动程序
- en: The STM32 EXTI module relies on several key registers to configure its operation.
    These registers allow you to set up trigger conditions, enable interrupts, and
    manage pending interrupt requests. Understanding these registers is crucial for
    effectively using the EXTI module in your embedded projects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: STM32 EXTI 模块依赖于几个关键寄存器来配置其操作。这些寄存器允许您设置触发条件、启用中断和管理挂起的中断请求。理解这些寄存器对于在嵌入式项目中有效地使用
    EXTI 模块至关重要。
- en: EXTI_IMR
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXTI_IMR
- en: We use the EXTI_IMR to enable or disable interrupts on each EXTI line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 EXTI_IMR 来启用或禁用每个 EXTI 线上的中断。
- en: The bits in this register are named `x` = `0` to `22`). Setting a bit to `1`
    unmasks the interrupt line, allowing it to generate an interrupt request. Conversely,
    setting it to `0` masks the line, preventing it from generating interrupts.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该寄存器中的位命名为 `x` = `0` 到 `22`)。将位设置为 `1` 解除中断线的屏蔽，允许它生成中断请求。相反，将其设置为 `0` 屏蔽线，防止它生成中断。
- en: EXTI_RTSR
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXTI_RTSR
- en: The EXTI_RTSR configures the rising edge trigger for each EXTI line. When a
    rising edge is detected on a line configured in this register, it can generate
    an interrupt or an event.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI_RTSR 配置每个 EXTI 线的上升沿触发。当检测到配置在此寄存器中的线上有上升沿时，它可以生成中断或事件。
- en: The bits in this register are named `x` = `0` to `22`). Setting a bit to `1`
    configures the line to trigger on a rising edge.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该寄存器中的位命名为 `x` = `0` 到 `22`)。将位设置为 `1` 配置线在上升沿触发。
- en: EXTI_FTSR
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXTI_FTSR
- en: The EXTI_FTSR is used to configure the falling edge trigger for each EXTI line.
    When a falling edge is detected on a line set in this register, it can generate
    an interrupt or an event.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI_FTSR 用于配置每个 EXTI 线的下降沿触发。当检测到设置在此寄存器中的线上有下降沿时，它可以生成中断或事件。
- en: The bits in this register are named `x` = `0` to `22`). Setting a bit to `1`
    configures the line to trigger on a falling edge.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该寄存器中的位命名为 `x` = `0` 到 `22`)。将位设置为 `1` 配置线在下降沿触发。
- en: Pending Register (EXTI_PR)
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待处理寄存器 (EXTI_PR)
- en: The EXTI_PR indicates which EXTI lines have pending interrupt requests. This
    register is also used to clear pending interrupts by writing a `1` to the appropriate
    bit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI_PR 指示哪些 EXTI 线有挂起的中断请求。此寄存器还用于通过向适当的位写入 `1` 来清除挂起的中断。
- en: The bits in this register are named `x` = `0` to `22`). A bit set to `1` indicates
    a pending interrupt request. Writing `1` to the bit clears the pending request.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该寄存器中的位命名为 `x` = `0` 到 `22`)。设置为 `1` 的位表示挂起的中断请求。向该位写入 `1` 清除挂起请求。
- en: Let’s configure PC13 as an EXTI pin.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置 PC13 为 EXTI 引脚。
- en: The EXTI driver
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXTI 驱动程序
- en: Create a copy of your previous project in your IDE and rename this copied project
    `EXTI`. Next, create a new file named `gpio_exti.c` in the `Src` folder and another
    file named `gpio_exti.h` in the `Inc` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 IDE 中创建您之前项目的副本，并将此复制的项目重命名为 `EXTI`。接下来，在 `Src` 文件夹中创建一个名为 `gpio_exti.c`
    的新文件，并在 `Inc` 文件夹中创建一个名为 `gpio_exti.h` 的新文件。
- en: 'Populate `gpio_exti.c` with the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码填充 `gpio_exti.c`：
- en: '[PRE0]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down each step within the `pc13_exti_init` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解 `pc13_exti_init` 函数中的每个步骤：
- en: '[PRE1]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line disables global interrupts to ensure that the configuration process
    is not interrupted, which is crucial for maintaining consistency and avoiding
    race conditions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码禁用全局中断以确保配置过程不被中断，这对于保持一致性并避免竞争条件至关重要。
- en: '[PRE2]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This line enables the clock for GPIOC by setting the appropriate bit in the
    `AHB1` peripheral clock enable register (`AHB1ENR`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在`AHB1`外设时钟使能寄存器（`AHB1ENR`）中设置适当的位来启用GPIOC的时钟。
- en: '[PRE3]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines configure pin `PC13` as an input by clearing the appropriate bits
    in the GPIO mode register (`MODER`).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码通过清除GPIO模式寄存器（`MODER`）中适当的位来配置引脚`PC13`为输入。
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This line enables the clock for `SYSCFG` by setting the appropriate bit in the
    `APB2` peripheral clock enable register (`APB2ENR`). `SYSCFG` is required for
    configuring the EXTI lines to map to the appropriate GPIO pins.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在`APB2`外设时钟使能寄存器（`APB2ENR`）中设置适当的位来启用`SYSCFG`的时钟。`SYSCFG`对于配置EXTI线映射到适当的GPIO引脚是必需的。
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line configures the `SYSCFG` external interrupt configuration register
    to map EXTI line 13 to `PORTC`. The `EXTICR[3]` register controls EXTI lines 12
    to 15, and setting the correct bits ensures that `EXTI13` is connected to `PC13`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码配置`SYSCFG`外部中断配置寄存器，将EXTI线13映射到`PORTC`。`EXTICR[3]`寄存器控制EXTI线12到15，设置正确的位确保`EXTI13`连接到`PC13`。
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This line unmasks EXTI line 13 by setting the appropriate bit in the interrupt
    mask register (`IMR`). Unmasking the line allows it to generate interrupt requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在中断屏蔽寄存器（`IMR`）中设置适当的位取消屏蔽EXTI线13。取消屏蔽该线允许它生成中断请求。
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line sets EXTI line 13 to trigger on a falling edge by setting the appropriate
    bit in the FTSR. This configuration is essential for detecting when the signal
    transitions from high to low.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在FTSR中设置适当的位将EXTI线13设置为下降沿触发。这种配置对于检测信号从高到低的转换至关重要。
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line enables the `EXTI15_10` interrupt line in the NVIC. EXTI lines 10
    to 15 share an IRQ in the NVIC, and enabling it allows the microcontroller to
    handle interrupts from these lines.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在NVIC中启用`EXTI15_10`中断线。EXTI线10到15在NVIC中共享一个IRQ，启用它允许微控制器处理这些线的中断。
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line re-enables global interrupts after the configuration is complete,
    allowing the microcontroller to respond to interrupts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在配置完成后重新启用全局中断，允许微控制器响应中断。
- en: Our next task is to populate the `gpio_exti.h` file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是填充`gpio_exti.h`文件。
- en: 'Here is the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#include <stdio.h>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include "adc.h"'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "adc.h"'
- en: '#include "uart.h"'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: '#include "gpio.h"'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "gpio.h"'
- en: '#include "gpio_exti.h"'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "gpio_exti.h"'
- en: uint8_t g_btn_press;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: uint8_t g_btn_press;
- en: int main(void)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Initialize debug UART*/
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: /*初始化调试UART*/
- en: uart_init();
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: uart_init();
- en: /*Initialize LED*/
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: /*初始化LED*/
- en: led_init();
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: led_init();
- en: /*Initialize EXTI*/
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: /*初始化EXTI*/
- en: pc13_exti_init();
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: pc13_exti_init();
- en: while(1)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static void exti_callback(void)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: static void exti_callback(void)
- en: '{'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: printf("BTN Pressed...\n\r");
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: printf("BTN Pressed...\n\r");
- en: led_toggle();
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: led_toggle();
- en: '}'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void EXTI15_10_IRQHandler(void) {
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: void EXTI15_10_IRQHandler(void) {
- en: if((EXTI->PR & LINE13)!=0)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: if((EXTI->PR & LINE13)!=0)
- en: '{'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Clear PR flag*/
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: /*清除PR标志*/
- en: EXTI->PR |=LINE13;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI->PR |=LINE13;
- en: //Do something...
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: //执行某些操作...
- en: exti_callback();
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: exti_callback();
- en: '}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: if((EXTI->PR & LINE13) != 0)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: if((EXTI->PR & LINE13) != 0)
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: EXTI->PR |= LINE13;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI->PR |= LINE13;
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: exti_callback();
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: exti_callback();
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
