- en: 3D Minigolf
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D迷你高尔夫
- en: The previous projects in this book have been designed in 2D space. This is intentional,
    in order to introduce the various features and concepts of Godot while keeping
    the projects' scopes limited. In this chapter, you'll venture into the 3D side
    of game development. For some, 3D development feels significantly more difficult
    to manage; for others, it is more straightforward. In either case, there is certainly
    an additional layer of complexity for you to understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的前几个项目都是在2D空间中设计的。这是故意的，为了在保持项目范围有限的同时介绍Godot的各种功能和概念。在本章中，你将进入游戏开发的3D方面。对于一些人来说，3D开发感觉管理起来要困难得多；对于另一些人来说，它则更为直接。无论如何，你确实需要理解一个额外的复杂性层次。
- en: If you've never worked with any kind of 3D software before, you may find yourself
    encountering many new concepts. This chapter will explain them as much as possible,
    but remember to refer to the Godot documentation whenever you need a more in-depth
    understanding of a particular topic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过任何类型的3D软件，你可能会发现自己遇到了许多新概念。本章将尽可能多地解释它们，但请记住，在需要更深入理解特定主题时，要参考Godot文档。
- en: The game you'll make in this chapter is called **Minigolf**. This will consist
    of a small customizable course, a ball, and an interface for aiming and shooting
    the ball towards the hole.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将制作的游戏被称为**迷你高尔夫**。这包括一个小型可定制的球场、一个球和一个瞄准并射击球向洞的方向的界面。
- en: 'This is what you''ll learn in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章你将学习的内容：
- en: Navigating Godot's 3D editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航Godot的3D编辑器
- en: The Spatial node and its properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间节点及其属性
- en: Importing 3D meshes and using 3D collision shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入3D网格并使用3D碰撞形状
- en: How to use 3D cameras, both stationary and moving
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用3D相机，包括静止的和移动的
- en: Using GridMap to place the tiles of your golf course
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GridMap放置你的高尔夫球场的瓷砖
- en: Setting up lighting and the environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置照明和环境
- en: An introduction to PBR rendering and materials
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PBR渲染和材质简介
- en: But first, here's a brief introduction to 3D in Godot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，这里是对Godot中3D的简要介绍。
- en: Introduction to 3D
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D简介
- en: One of the strengths of Godot is its ability to handle both 2D and 3D games.
    While much of what you've learned earlier in this book applies equally well in
    3D (nodes, scenes, signals, and so on), changing from 2D to 3D brings with it
    a whole new layer of complexity and capabilities. First, you'll find that there
    are some additional features available in the 3D editor window, and it's a good
    idea to familiarize yourself with how to navigate in the 3D editor window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Godot的一个优点是它能够处理2D和3D游戏。虽然你在这本书中之前学到的许多内容在3D中同样适用（节点、场景、信号等），但从2D到3D的转变会带来全新的复杂性和功能。首先，你会发现3D编辑器窗口中有一些额外的功能，熟悉如何在3D编辑器窗口中导航是个好主意。
- en: Orienting in 3D space
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D空间中的定位
- en: 'When you click on the 3D button at the top of the editor window, you will see
    the 3D project view:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编辑器窗口顶部的3D按钮上点击时，你会看到3D项目视图：
- en: '![](img/00140.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00140.jpeg)'
- en: The first thing you should notice is the three colored lines in the center.
    These are the *x* (red), *y* (green), and *z* (blue) axes. The point where they
    meet is the origin, with coordinates of `(0, 0, 0)`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该注意到的是中心的三条彩色线条。这些是*x*（红色）、*y*（绿色）和*z*（蓝色）轴。它们相交的点就是原点，坐标为`(0, 0, 0)`。
- en: Just as you used `Vector2(x, y)` to indicate a position in two-dimensional space,
    `Vector3(x, y, z)` describes a position in three dimensions along these three
    axes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用`Vector2(x, y)`来表示二维空间中的一个位置一样，`Vector3(x, y, z)`描述了沿着这三个轴的三维空间中的一个位置。
- en: One issue that arises when working in 3D is that different applications use
    different conventions for orientation. Godot uses Y-Up orientation, so when looking
    at the axes, if *x* is pointing to the left/right, then *y* is up/down, and *z*
    is forward/back. You may find when using other popular 3D software that they use
    Z-Up. It's good to be aware of this, as it can lead to confusion when moving between
    different programs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D环境中工作时，会出现的一个问题是不同的应用程序使用不同的方向约定。Godot使用Y-Up方向，因此当查看坐标轴时，如果*x*指向左/右，那么*y*就是上/下，而*z*是前/后。你可能在使用其他流行的3D软件时会发现它们使用Z-Up。了解这一点是好的，因为它在在不同程序之间移动时可能会导致混淆。
- en: 'Another major aspect to be aware of is the unit of measure. In 2D, everything
    is measured in pixels, which makes sense as a natural basis for measurement when
    drawing on the screen. However, when working in 3D space, pixels aren''t really
    useful. Two objects of exactly the same size will occupy different areas on the
    screen depending on how far away they are from the camera (more about cameras
    soon). For this reason, in 3D space all objects in Godot are measured in generic
    units. You''re free to call these units whatever you like: meters, inches, or
    even light years, depending on the scale of your game world.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的主要方面是度量单位。在2D中，所有内容都是以像素为单位测量的，这在屏幕上绘制时是一个自然的度量基础。然而，当在3D空间中工作时，像素并不太有用。两个大小完全相同的对象，根据它们与摄像机的距离不同，将在屏幕上占据不同的区域（关于摄像机的更多信息即将揭晓）。因此，在3D空间中，Godot中的所有对象都使用通用单位进行测量。您可以自由地称这些单位为米、英寸，甚至光年，具体取决于您游戏世界的规模。
- en: Godot's 3D editor
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Godot的3D编辑器
- en: 'Before getting started with 3D, it will be useful to briefly review how to
    navigate in Godot''s 3D space. The camera is controlled with the mouse and keyboard:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用3D之前，简要回顾如何在Godot的3D空间中导航将很有用。相机由鼠标和键盘控制：
- en: 'Mousewheel up/down: Zoom in/out'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标滚轮向上/向下：缩放
- en: 'Middle button + drag: Orbit the camera around the current target'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间按钮 + 拖动：围绕当前目标旋转相机
- en: '*Shift* + middle button + drag: Pan camera up/down/left/right'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift* + 中间按钮 + 拖动：上下/左右平移相机'
- en: 'Right-click + drag: Rotate camera in place'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键点击 + 拖动：在当前位置旋转相机
- en: If you're familiar with popular 3D games such as *Minecraft*, you can press *Shift*
    + *F* to switch to Freelook mode. In this mode, you can use the WASD keys to *fly*
    around the scene while aiming with the mouse. Press *Shift* + *F* again to exit
    Freelook mode.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉像*Minecraft*这样的流行3D游戏，您可以按*Shift* + *F*切换到Freelook模式。在此模式下，您可以使用WASD键在场景中*飞行*，同时用鼠标瞄准。再次按*Shift*
    + *F*退出Freelook模式。
- en: 'You can also alter the camera''s view by clicking on the [ Perspective ] label
    in the upper-left corner. Here, you can snap the camera to a particular orientation
    such as Top View or Front View:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过点击左上角的[视角]标签来改变相机的视图。在这里，您可以快速定位相机到特定的方向，如俯视图或前视图：
- en: '![](img/00141.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00141.jpeg)'
- en: This can be especially useful on large displays when combined with the use of
    multiple Viewports. Click the View menu and you can split the screen into multiple
    views of the space, allowing you to see an object from all sides simultaneously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这在结合使用多个视口的大屏幕上尤其有用。点击视图菜单，您可以将屏幕分割成多个空间视图，让您能够同时从各个侧面看到对象。
- en: Note that each of these menu options has a keyboard shortcut associated with
    it. You can click on Editor *|* Editor Settings *|* 3D to adjust the 3D navigation
    and shortcuts to your liking.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些菜单选项中的每一个都有一个与之关联的键盘快捷键。您可以通过点击编辑器 *|* 编辑器设置 *|* 3D来调整3D导航和快捷键，以满足您的需求。
- en: '![](img/00142.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00142.jpeg)'
- en: 'When using multiple viewports, each can be set to a different perspective so
    you can see the effect of your actions from multiple directions at the same time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个视口时，每个视口都可以设置为不同的视角，这样您就可以同时从多个方向看到您动作的效果：
- en: '![](img/00143.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00143.jpeg)'
- en: Adding 3D objects
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加3D对象
- en: 'It''s time to add your first 3D node. Just as all 2D nodes inherit from `Node2D`,
    which provides properties such as `position` and `rotation`, 3D nodes inherit
    from the `Spatial` node. Add one to the scene and you''ll see the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加您的第一个3D节点了。就像所有2D节点都继承自`Node2D`，它提供了如`position`和`rotation`等属性一样，3D节点继承自`Spatial`节点。将一个添加到场景中，您将看到以下内容：
- en: '![](img/00144.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00144.jpeg)'
- en: That colorful object you see is not the node, but rather a 3D *gizmo*. Gizmos
    are tools that allow you to move and rotate objects in space. The three rings
    control rotation, while the three arrows move (translate) the object along the
    three axes. Notice that the rings and arrows are color-coded to match the axis
    colors. The arrows move the object *along* the respective axis, while the rings
    rotate the object *around* a particular axis. There are also three small squares
    that lock one axis and allow you to move the object in a single plane.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的那个彩色对象不是节点，而是一个3D *gizmo*。Gizmos是允许您在空间中移动和旋转对象的工具。三个环控制旋转，而三个箭头沿着三个轴移动（平移）对象。请注意，环和箭头是按照轴的颜色进行编码的。箭头沿着相应的轴移动对象，而环则围绕特定的轴旋转对象。还有三个小方块可以锁定一个轴，并允许您在单个平面上移动对象。
- en: Take a few minutes to experiment and get familiar with the gizmo. Use Undo if
    you find yourself getting lost.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间进行实验，熟悉小工具。如果你发现自己迷失了方向，请使用撤销。
- en: 'Sometimes, gizmos get in the way. You can click on the mode icons to restrict
    yourself to only one type of transformation: move, rotate, or scale:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，小工具会碍事。你可以点击模式图标来限制自己只进行一种类型的变换：移动、旋转或缩放：
- en: '![](img/00145.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00145.jpeg)'
- en: The *Q*, *W*, *E*, and *R* keys are shortcuts for these buttons, allowing for
    quickly changing between modes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Q*、*W*、*E*和*R*键是这些按钮的快捷键，允许快速在模式之间切换。'
- en: Global versus Local Space
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局空间与局部空间
- en: 'By default, the gizmo controls operate in global space. Try rotating the object.
    No matter how you turn it, the gizmo''s movement arrows still point along the
    axes. Now try this: put the `Spatial` node back to its original position and orientation
    (or delete it and add a new one). Rotate the object around one axis, then click
    the Local Space Mode (T) button:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，小工具控件在全局空间中操作。尝试旋转对象。无论你如何转动它，小工具的运动箭头仍然沿着轴指向。现在试试这个：将`Spatial`节点放回其原始位置和方向（或者删除它并添加一个新的）。围绕一个轴旋转对象，然后点击局部空间模式（T）按钮：
- en: '![](img/00146.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00146.jpeg)'
- en: Observe what happened to the gizmo arrows. They now point along the *object's*
    local *x*/*y*/*z* axes and not the world's. When you click and drag them, they
    will move the object relative to its axes. Switching back and forth between these
    two modes can make it much easier to place an object exactly where you want it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 观察小工具箭头发生了什么。现在它们指向的是对象的局部*x*/*y*/*z*轴，而不是世界轴。当你点击并拖动它们时，它们会相对于轴移动对象。在这些两种模式之间切换可以使放置对象精确到想要的位置变得容易得多。
- en: Transforms
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换
- en: 'Look at the Inspector for your `Spatial` node. Instead of a Position property,
    you now have Translation, as well as Rotation Degrees and Scale. As you move the
    object around, observe how these values change. Note that the Translation represents
    the object''s coordinates relative to the origin:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看你的`Spatial`节点的检查器。现在你有了平移、旋转度数以及缩放，而不是位置属性。当你移动对象时，观察这些值如何变化。注意，平移表示对象相对于原点的坐标：
- en: '![](img/00147.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00147.jpeg)'
- en: You'll also notice a Transform property, which also changes as you move and
    rotate the object. When you change translation or rotation, you'll notice that
    the 12 transform quantities will change as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到一个变换属性，它也会随着你移动和旋转对象而改变。当你改变平移或旋转时，你会注意到12个变换量也会相应改变。
- en: A full explanation of the math behind transforms is beyond the scope of this
    book, but in a nutshell, a transform is a *matrix* that describes an object's
    translation, rotation, and scale all at once. You briefly used the 2D equivalent
    in the Space Rocks game earlier in this book, but the concept is more widely applied
    in 3D.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变换背后的数学解释超出了本书的范围，但简单来说，变换是一个*矩阵*，它同时描述了一个对象的平移、旋转和缩放。你之前在本书中的Space Rocks游戏中简要使用过2D等价物，但这个概念在3D中应用得更广泛。
- en: Transforms in code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码中的变换
- en: 'When positioning a 3D node via code, you have access to its `transform` and
    `global_transform` properties, which are `Transform` objects. A `Transform` has
    two sub-properties: `origin` and `basis`. The `origin` represents the body''s
    offset from its parent''s origin or the global origin, respectively. The `basis`
    property contains three vectors that define a local coordinate system traveling
    with the object. Think of the three axis arrows in the gizmo when you are in Local
    Space mode.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过代码定位3D节点时，你可以访问其`transform`和`global_transform`属性，它们是`Transform`对象。`Transform`有两个子属性：`origin`和`basis`。`origin`表示物体相对于其父物体的原点或全局原点的偏移。`basis`属性包含三个向量，这些向量定义了一个与物体一起移动的局部坐标系。当你处于局部空间模式时，想想小工具中的三个轴箭头。
- en: You'll see more about how to use 3D transforms later in this section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本节后面了解更多关于如何使用3D变换的信息。
- en: Meshes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格
- en: 'Just like `Node2D`, a `Spatial` node has no size or appearance of its own.
    In 2D, you added a Sprite to assign a texture to the node. In 3D, you need to
    add a *mesh*. A mesh is a mathematical description of a shape. It consists of
    a collection of points, called *vertices*. These vertices are connected by lines,
    called *edges,* and multiple edges (at least three) together make a *face*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Node2D`一样，`Spatial`节点本身没有大小或外观。在2D中，你添加了一个Sprite来为节点分配纹理。在3D中，你需要添加一个*网格*。网格是形状的数学描述。它由一组称为*顶点*的点组成。这些顶点通过称为*边*的线连接起来，多个边（至少三个）共同构成一个*面*：
- en: '![](img/00148.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00148.jpeg)'
- en: A cube, for example, is composed of eight vertices, twelve edges, and six faces.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个立方体由八个顶点、十二条边和六个面组成。
- en: If you've ever used 3D design software, this will be very familiar to you. If
    you haven't, and you're interested in learning about 3D modeling, Blender is a
    very popular open source tool for designing 3D objects. You can find many tutorials
    and lessons on the internet to help you get started with Blender.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过3D设计软件，这对你来说将非常熟悉。如果你没有，并且你对学习3D建模感兴趣，Blender是一个非常流行的开源工具，用于设计3D对象。你可以在互联网上找到许多教程和课程，帮助你开始使用Blender。
- en: Importing meshes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入网格
- en: Whatever modeling software you may use, you will need to export your models
    in a format that is readable by Godot. Wavefront (`.obj`) and Collada (`.dae`)
    are the most popular. Unfortunately, if you're using Blender, its Collada exporter
    has some flaws that make it unusable with Godot. To fix this, Godot's developers
    have created a Blender plugin called **Better Collada Exporter** that you can
    download from [https://godotengine.org/download](https://godotengine.org/download).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么建模软件，你都需要以Godot可读的格式导出你的模型。Wavefront (`.obj`) 和 Collada (`.dae`) 是最流行的。不幸的是，如果你使用Blender，它的Collada导出器有一些缺陷，使其无法与Godot一起使用。为了解决这个问题，Godot的开发者创建了一个名为**Better
    Collada Exporter**的Blender插件，你可以从[https://godotengine.org/download](https://godotengine.org/download)下载。
- en: If your objects are in another format, such as FBX, you'll need to use a converter
    tool to save them as OBJ or DAE in order to use them with Godot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的对象是其他格式，例如FBX，你需要使用转换工具将它们保存为OBJ或DAE格式，以便与Godot一起使用。
- en: A new format called GLTF is gaining in popularity and has some significant advantages
    over Collada. Godot already supports it, so feel free to experiment with any models
    you may find in this format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为GLTF的新格式越来越受欢迎，并且与Collada相比有一些显著的优势。Godot已经支持它，所以你可以自由地尝试使用任何你找到的这种格式的模型。
- en: Primitives
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原语
- en: 'If you don''t have any models handy, or if you just need a simple model quickly,
    Godot has the ability to create certain 3D meshes directly. Add a `MeshInstance`
    node as a child of Spatial, and in the Inspector, click the Mesh property:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有现成的模型，或者你只需要一个简单的模型，Godot具有直接创建某些3D网格的能力。将`MeshInstance`节点作为Spatial的子节点添加，然后在检查器中点击网格属性：
- en: .![](img/00149.jpeg)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/00149.jpeg)'
- en: These predefined shapes are called *primitives* and they represent a handy collection
    of common useful shapes. You can use these shapes for a variety of purposes, as
    you'll see later in this chapter. Select New CubeMesh and you'll see a plain cube
    appear on the screen. The cube itself is white, but it may appear bluish on your
    screen due to the default ambient light in the 3D editor window. You'll learn
    how to work with lighting later in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预定义的形状被称为*原语*，它们代表了一组方便的常用形状。你可以将这些形状用于各种目的，正如你将在本章后面看到的那样。选择“新建立方体网格”，你会在屏幕上看到一个普通的立方体。立方体本身是白色的，但由于3D编辑器窗口中的默认环境光，它可能在你屏幕上呈现蓝色。你将在本章后面学习如何处理光照。
- en: Multiple meshes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个网格
- en: Often, you'll find yourself with an object composed of many different meshes.
    A character might have separate meshes for its head, torso, and limbs. If you
    have a great many of these types of objects, it can lead to performance issues
    as the engine tries to render so many meshes. As a result, `MultiMeshInstance`
    is designed to provide a high-performance method of grouping many meshes together
    into a single object. You probably don't need it yet, because it won't be necessary
    for this project, but keep it in mind as a tool that may come in handy later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现一个由许多不同网格组成的对象。一个角色可能有其头部、躯干和四肢的单独网格。如果你有很多这种类型的对象，当引擎尝试渲染这么多网格时，可能会导致性能问题。因此，`MultiMeshInstance`被设计为提供将许多网格组合成一个单一对象的高性能方法。你可能现在还不需要它，因为在这个项目中它不是必需的，但请记住，它可能是一个以后会派上用场的工具。
- en: Cameras
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机
- en: 'Try running the scene with your cube mesh. Where is it? In 3D, you won''t see
    anything in the game viewport without using a `Camera`. Add one, and use the camera''s
    gizmo to position and point it towards the cube, as in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行带有你的立方体网格的场景。它在哪？在3D中，不使用`Camera`你将看不到游戏视口中的任何东西。添加一个相机，并使用相机的操纵杆将其定位并指向立方体，如以下截图所示：
- en: '![](img/00150.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00150.jpeg)'
- en: The pinkish-purple, pyramid-shaped object is called the camera's *fustrum*.
    It represents the camera's view, and can be made narrow or wide to affect the
    camera's *field of view*. The triangular arrow at the top of the fustrum is the
    camera's up direction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那个粉紫色、金字塔形状的物体被称为相机的 *fustrum*。它代表相机的视图，可以使其变窄或变宽以影响相机的 *视野*。fustrum 顶部的三角形箭头是相机的向上方向。
- en: As you're moving the camera around, you can use the Preview button in the upper-right
    to check your aim. Preview will always show you what the selected camera can see.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动相机时，你可以使用右上角的预览按钮来检查你的目标。预览将始终显示所选相机可以看到的内容。
- en: 'As with the `Camera2D` you used earlier, a `Camera` must be set as Current
    for it to be active. Its other properties affect how it *sees*: field of view,
    projection, and near/far. The default values of these properties are good for
    this project, but go ahead and experiment with them to see how they affect the
    view of the cube. Use Undo to return everything to the default values when you''re
    done.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前使用的 `Camera2D` 一样，一个 `Camera` 必须被设置为当前状态才能使其生效。它的其他属性会影响其 *视角*：视野、投影和近/远。这些属性的默认值对于这个项目来说很好，但你可以尝试调整它们，看看它们如何影响立方体的视图。完成操作后，使用撤销将一切恢复到默认值。
- en: Project setup
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Now that you've learned how to navigate in Godot's 3D editor, you're ready to
    start on the Minigolf project. As with the other projects, download the game assets
    from the following link and unzip them in your project folder. The unzipped `assets`
    folder contains images, 3D models, and the other assets you need to complete the
    project. You can download a Zip file of the art and sounds (collectively known
    as *assets*) for the game here, [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何在 Godot 的 3D 编辑器中导航，你准备好开始 Minigolf 项目了。与其他项目一样，从以下链接下载游戏资源，并将其解压到你的项目文件夹中。解压后的
    `assets` 文件夹包含图像、3D 模型以及其他完成项目所需的资源。你可以从这里下载包含游戏艺术和声音（统称为 *assets*）的 Zip 文件，[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)。
- en: 'This game will use the left mouse button as an input. The Input Map does not
    have any default actions defined for this, so you need to add one. Open Project
    | Project Settings and go to the Input Map tab. Add a new action called click,
    then click the plus to add a Mouse Button event to it. Choose Left Button:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏将使用左鼠标按钮作为输入。输入映射没有为这个定义任何默认动作，所以你需要添加一个。打开项目 | 项目设置，然后转到输入映射选项卡。添加一个名为点击的新动作，然后点击加号添加一个鼠标按钮事件。选择左键：
- en: '![](img/00151.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00151.jpeg)'
- en: Creating the course
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建课程
- en: For the first scene, add a node called `Main` to serve as your scene's root.
    This scene will contain the major parts of the game, starting with the course
    itself. Start by adding a `GridMap` node to lay out the course.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个场景，添加一个名为 `Main` 的节点作为场景的根节点。这个场景将包含游戏的主要部分，从课程本身开始。首先添加一个 `GridMap` 节点来布置课程。
- en: GridMaps
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格地图
- en: '`GridMap` is the 3D equivalent of the `TileMap` node you used in earlier projects.
    It allows you to use a collection of meshes (contained in a `MeshLibrary`) and
    lay them out in a grid to more quickly design an environment. Because it is 3D,
    you can stack the meshes in any direction, although for this project, you''ll
    stick to the same plane.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridMap` 是 `TileMap` 节点的 3D 等价物，你在之前的项目中使用过。它允许你使用一组网格（包含在 `MeshLibrary` 中）并在网格中布置它们，以更快地设计环境。因为它是一个
    3D 对象，你可以以任何方向堆叠网格，尽管在这个项目中，你将坚持在同一平面上。'
- en: Making a MeshLibrary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网格库
- en: The `res://assets` folder contains a pre-generated `MeshLibrary` for the project,
    containing all the necessary course parts along with collision shapes. However,
    if you need to change it or make your own, you'll find the procedure is very similar
    to how `TileSet` is created in 2D.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`res://assets` 文件夹包含了一个为项目预生成的 `MeshLibrary`，其中包含所有必要的课程部分以及碰撞形状。然而，如果你需要更改它或创建自己的，你会发现这个过程与在
    2D 中创建 `TileSet` 非常相似。'
- en: The scene used to create the pre-generated `MeshLibrary` can also be found in
    the `res://assets` folder. Its name is `course_tiles_edit1.tscn`. Feel free to
    open it and look at how it is set up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建预生成的 `MeshLibrary` 的场景也可以在 `res://assets` 文件夹中找到。它的名字是 `course_tiles_edit1.tscn`。你可以随意打开它，看看它是如何设置的。
- en: Start by making a new scene, with a `Spatial` as its root. To this node, add
    any number of `MeshInstance`. You can find the original course meshes, exported
    from Blender, in the `res://assets/dae` folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的场景，以 `Spatial` 作为其根节点。向此节点添加任意数量的 `MeshInstance`。您可以在 `res://assets/dae`
    文件夹中找到原始的课程网格，这些网格是从 Blender 导出的。
- en: The names you give to these nodes will be their names in the `MeshLibrary`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您给这些节点取的名字将是它们在 `MeshLibrary` 中的名字。
- en: Once you have added the meshes, they need static collision bodies added to them.
    Creating collision shapes that match a given mesh can be complicated, but Godot
    has a method of automatically generating them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了网格，就需要为它们添加静态碰撞体。创建与给定网格匹配的碰撞形状可能很复杂，但 Godot 有一种自动生成它们的方法。
- en: 'Select a mesh and you''ll see a `Mesh` menu appear at the top of the editor
    window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个网格，您将在编辑器窗口的顶部看到一个 `Mesh` 菜单：
- en: '![](img/00152.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00152.jpeg)'
- en: 'Select Create Trimesh Static Body and Godot will create a `StaticBody` and
    add a `CollisionShape` using the mesh''s data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 选择创建三角形静态体和 Godot 将创建一个 `StaticBody` 并使用网格数据添加一个 `CollisionShape`：
- en: '![](img/00153.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00153.jpeg)'
- en: Do this with each of your mesh objects, and then select Scene | Convert To |
    MeshLibrary to save the resource.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个网格对象都这样做，然后选择场景 | 转换到 | 网格库以保存资源。
- en: Drawing the course
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制课程
- en: 'Drag the `MeshLibrary` (`res://assets/course_tiles.tres` or the one you created)
    into the Theme property of `GridMap` in the Inspector. Also, check that the Cell/Size
    property is set to `(2, 2, 2)`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MeshLibrary` (`res://assets/course_tiles.tres` 或您创建的版本) 拖入检查器中 `GridMap`
    的主题属性。同时，确保单元格/大小属性设置为 `(2, 2, 2)`：
- en: '![](img/00154.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00154.jpeg)'
- en: Try drawing by selecting the tile piece from the list on the right and placing
    it by left-clicking in the editor window. You can rotate a piece around the y
    axis by pressing *S*. To remove a tile, use *Shift* + right-click.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从右侧的列表中选择瓦片块并在编辑器窗口中左键单击来绘制。通过按 *S* 可以围绕 y 轴旋转一个块。要删除瓦片，请使用 *Shift* + 右键单击。
- en: For now, stick to a simple course; you can get fancy later when everything is
    working. Don't forget the hole!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，坚持使用简单的课程；当一切正常工作时，您可以在以后变得花哨。别忘了洞！
- en: '![](img/00155.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00155.jpeg)'
- en: Now, it's time to see what this is going to look like when the game is run.
    Add a `Camera` to the scene. Move it up and angle it so it looks down on the course.
    Remember, you can use the Preview button to check what the camera sees.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看当游戏运行时这会是什么样子了。向场景中添加一个 `Camera`。将其向上移动并调整角度，使其向下看课程。记住，您可以使用预览按钮来检查摄像机看到的内容。
- en: Run the scene. You'll see that everything seems very dark. By default, there
    is minimal environmental light in the scene. To see more clearly, you need to
    add more light.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景。您会看到一切似乎都非常暗。默认情况下，场景中环境光最少。要更清楚地看到，您需要添加更多光源。
- en: WorldEnvironment
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WorldEnvironment
- en: Lighting is a complex subject all on its own. Deciding where to place lights
    and how to set their color and intensity can dramatically affect how a scene looks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 照明是一个独立的复杂主题。决定灯光的位置以及如何设置它们的颜色和强度可以显著影响场景的外观。
- en: 'Godot provides three lighting nodes in 3D:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 在 3D 中提供了三个照明节点：
- en: '`OmniLight`: For light that is emitted in all directions, like from a light
    bulb or candle'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OmniLight`：用于从所有方向发射的光，例如来自灯泡或蜡烛'
- en: '`DirectionalLight`: Infinite light from a distant source, such as sunlight'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirectionalLight`：来自遥远来源的无限光源，例如阳光'
- en: '`SpotLight`: Directional light from a single source, such as a flashlight'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpotLight`：来自单个光源的方向性光源，例如手电筒'
- en: In addition to using individual lights, you can also set an *ambient* light
    using `WorldEnvironment`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用单个灯光外，您还可以使用 `WorldEnvironment` 设置环境光。
- en: 'Add a `WorldEnvironment` node to the scene. In the Inspector, select New Environment
    in the Environment property. Everything will turn black, but don''t worry, you''ll
    fix that soon:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中添加一个 `WorldEnvironment` 节点。在检查器中，选择环境属性中的“新建环境”。一切都会变黑，但别担心，您很快就会解决这个问题：
- en: '![](img/00156.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00156.jpeg)'
- en: Click on New Environment and you'll see a large list of properties. The one
    you want is Ambient Light. Set Color to white and you'll see your scene become
    more brightly lit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 点击新建环境，您将看到一个大型属性列表。您想要的是环境光。将颜色设置为白色，您会看到场景变得更亮。
- en: Keep in mind that ambient light comes from all directions equally. If your scene
    needs shadows or other light effects, you'll want to use one of the `Light` nodes.
    You'll see how light nodes work later in the chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，环境光来自所有方向均匀。如果您的场景需要阴影或其他光照效果，您将想要使用 `Light` 节点之一。您将在本章后面看到光照节点是如何工作的。
- en: Finishing the scene
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成场景
- en: 'Now that you have the course laid out, two more items remain: the *tee,* or
    location where the ball will start, and a way to detect when the ball has entered
    the hole.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经布置好了课程，剩下两项：*tee*，即球体开始的位置，以及检测球体何时进入洞口的方法。
- en: Add a `Position3D` node named `Tee`. Just like `Position2D`, this node is used
    to mark a location in space. Place this node where you want the ball to start.
    Make sure you put it just above the surface so that the ball doesn't spawn inside
    the ground.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`Tee`的`Position3D`节点。就像`Position2D`一样，此节点用于在空间中标记一个位置。将此节点放置在你想要球体开始的位置。确保将其放置在表面之上，这样球体就不会在地面内部生成。
- en: 'To detect the ball entering the hole, you can use an `Area` node. This node
    is directly analogous to the 2D version: it can signal when a body enters its
    assigned shape. Add an `Area` and give it a `CollisionShape` child.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测球体进入洞口，可以使用一个`Area`节点。此节点与2D版本直接对应：它可以在一个身体进入其分配的形状时发出信号。添加一个`Area`节点并给它一个`CollisionShape`子节点。
- en: 'In the child''s Shape property of the `CollisionShape`, add a `SphereShape`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CollisionShape`的子节点形状属性中添加一个`SphereShape`：
- en: '![](img/00157.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00157.jpeg)'
- en: 'To size the collision sphere, use the single radius adjustment handle:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整碰撞球体的大小，使用单个半径调整手柄：
- en: '![](img/00158.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00158.jpeg)'
- en: Place the `Area` just below the hole and size the collision shape so that it
    overlaps the bottom of the hole. Don't let it project above the top of the hole,
    or the ball will count as *in* when it hasn't dropped in yet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Area`放置在洞口下方，并调整碰撞形状的大小，使其与洞底重叠。不要让它延伸到洞口顶部，否则球体在尚未落下时会被计为*在洞内*。
- en: '![](img/00159.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00159.jpeg)'
- en: You may find it easier to position the node if you use the Perspective button
    to view the hole from one direction at at time. When you've finished positioning
    it, change the name of the `Area` to `Hole`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用透视按钮从不同方向一次查看洞口，可能会更容易定位节点。当你完成定位后，将`Area`的名称更改为`Hole`。
- en: Ball
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球体
- en: Now, you're ready to make the ball. Since the ball needs physics—gravity, friction,
    collision with walls, and other physics properties—`RigidBody` will be the best
    choice of node. Create a new scene with a `RigidBody` named `Ball`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好制作球体了。由于球体需要物理属性——重力、摩擦力、与墙壁的碰撞以及其他物理属性——“刚体”将是节点选择的最佳选择。创建一个新的场景，并命名为`Ball`的`RigidBody`。
- en: RigidBody is the 3D equivalent of the `RigidBody2D` node you used in [Chapter
    3](part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2), *Escape the Maze*.
    Its behavior and properties are very similar, and you use many of the same methods
    to interact with it, such as `apply_impulse()` and `_integrate_forces()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`RigidBody`是你在[第3章](part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2)，“逃离迷宫”中使用的`RigidBody2D`节点的3D等效物。它的行为和属性非常相似，并且你可以使用许多相同的方法与之交互，例如`apply_impulse()`和`_integrate_forces()`。'
- en: 'The shape of the ball needs to be a sphere. The basic 3D shapes such as sphere,
    cube, cylinder, and so on are called *primitives*. Godot can automatically make
    primitives using the `MeshInstance` node, so add one as a child of the body. In
    the Inspector, choose New SphereMesh in the Mesh property:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 球的形状需要是一个球体。基本的三维形状，如球体、立方体、圆柱体等，被称为*原语*。Godot可以使用`MeshInstance`节点自动创建原语，因此添加一个作为身体的子节点。在检查器中，在网格属性中选择“新建球体网格”：
- en: '![](img/00160.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00160.jpeg)'
- en: 'The default size is much too large, so click on the new sphere mesh and set
    its size properties, Radius to `0.15` and Height to `0.3`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认大小太大，因此单击新的球体网格并设置其大小属性，半径为`0.15`，高度为`0.3`：
- en: '![](img/00161.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00161.jpeg)'
- en: 'Next, add a `CollisionShape` node to the `Ball` and give it a `SphereShape`.
    Size it to fit the mesh using the size handle (orange dot):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`Ball`添加一个`CollisionShape`节点并给它一个`SphereShape`。使用大小手柄（橙色点）调整其大小以适应网格：
- en: '![](img/00162.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00162.jpeg)'
- en: Testing the ball
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试球体
- en: To test the ball, add it to the `Main` scene with the instance button. Position
    it somewhere above the course and hit Play. You should see the ball fall and land
    on the ground. You may find it helpful to add another `Camera` node positioned
    on the side of the course for a different view. Set the Current property on whichever
    camera you want to use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试球体，使用实例按钮将其添加到`Main`场景中。将其放置在课程上方某处并播放。你应该看到球体落下并落在地面上。你可能发现添加另一个位于课程侧面的`Camera`节点以获得不同视角很有帮助。设置你想要使用的相机的当前属性。
- en: You can also temporarily give the ball some motion by setting its Linear/Velocity
    property. Try setting it to different values and playing the scene. Remember that
    the *y* axis is up and that using too large a value may cause the ball to go right
    through the wall. Set it back to `(0, 0, 0)` when you're done.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过设置其线性/速度属性来暂时给球一些运动。尝试设置不同的值并播放场景。记住，*y*轴是向上的，使用过大的值可能会导致球直接穿过墙壁。完成后将其设置回`(0,
    0, 0)`。
- en: Improving collisions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善碰撞
- en: You may have noticed when adjusting the velocity that the ball sometimes goes
    straight through the wall and/or bounces oddly, especially if you choose a high
    value. There are a few adjustments you can make to the `RigidBody` properties
    to improve the collision behavior at high speeds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当调整速度时，你可能注意到球有时会直接穿过墙壁和/或以奇怪的方式反弹，尤其是如果你选择一个高值。你可以对`RigidBody`属性进行一些调整，以改善高速下的碰撞行为。
- en: First, turn on **Continuous Collision Detection** (**CCD**). You'll find it
    listed as Continuous Cd in the Inspector. Using CCD alters the way the physics
    engine calculates collisions. Normally, the engine operates by first moving the
    object and then testing for and resolving collisions. This is fast, and works
    in most common situations. When using CCD, however, the engine projects the object's
    movement along its path and attempts to predict where the collision may occur.
    This is slower than the default behavior, and so not as efficient, especially
    when simulating many objects, but it is much more accurate. Since you only have
    one ball in the game, CCD is a good option because it won't introduce any noticeable
    performance penalty, but will greatly improve collision detection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开**连续碰撞检测**（**CCD**）。你将在检查器中找到它列出的连续Cd。使用CCD会改变物理引擎计算碰撞的方式。通常，引擎通过首先移动对象，然后测试和解决碰撞来运行。这很快，并且在大多数常见情况下都有效。然而，当使用CCD时，引擎将对象沿其路径投影移动，并尝试预测碰撞可能发生的位置。这比默认行为慢，因此效率不高，尤其是在模拟许多对象时，但它要精确得多。由于你游戏中只有一个球，CCD是一个不错的选择，因为它不会引入任何明显的性能损失，但会大大提高碰撞检测。
- en: The ball also needs a little more action, so set the Bounce to `0.2` and the Gravity
    Scale to `2`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 球也需要更多的动作，所以将“反弹”设置为`0.2`，将“重力比例”设置为`2`。
- en: Finally, you may also have noticed that the ball takes a long time to come to
    a stop. Set the Linear/Damp property to `0.5` and Angular/Damp to `0.1` so that
    you won't have to wait as long for the ball to stop moving.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能也注意到球停止需要很长时间。将`Linear/Damp`属性设置为`0.5`，将`Angular/Damp`设置为`0.1`，这样你就不必等待球停止移动那么长时间。
- en: UI
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'Now that the ball is on the course, you need a way to aim and hit the ball.
    There are a number of possible control schemes for a game of this type. For this
    project, you''ll use a two-step process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在球已经在轨道上了，你需要一种瞄准和击打球的方法。对于这种类型的游戏，有许多可能的控制方案。对于这个项目，你将使用两步过程：
- en: 'Aim: An arrow will appear swinging back and forth. Clicking the mouse button
    will set the aim direction to the arrow''s.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 瞄准：箭头将出现来回摆动。点击鼠标按钮将瞄准方向设置为箭头的方向。
- en: 'Shoot: A power bar will move up and down on the screen. Clicking the mouse
    will set the power and launch the ball.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 射击：力量条将在屏幕上上下移动。点击鼠标将设置力量并发射球。
- en: Aiming arrow
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瞄准箭头
- en: 'Drawing an object in 3D is not as easy as it is in 2D. In many cases, you''ll
    have to switch to a 3D modeling program such as Blender to create your game''s
    objects. However, in this case Godot''s primitives have you covered; to make an
    arrow, you just need two meshes: a long, thin rectangle and a triangular prism.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D中绘制一个物体并不像在2D中那么容易。在许多情况下，你将不得不切换到像Blender这样的3D建模程序来创建你的游戏物体。然而，在这种情况下，Godot的原生形状已经为你准备好了；要制作一个箭头，你只需要两个网格：一个长而薄的矩形和一个三角棱柱。
- en: 'Start a new scene by adding a `Spatial` node with a `MeshInstance` child. Add
    a new `CubeMesh`. Click on the Mesh property and set the Size property to `(0.5,
    0.2, 2)`. This is the body of the arrow, but it still has one problem. If you
    rotate the parent, the mesh rotates around its center. Instead, you need the arrow
    to rotate around its end, so change the Transform/Translation of MeshInstance
    to `(0, 0, -1)`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个带有`MeshInstance`子节点的`Spatial`节点来创建一个新的场景。添加一个新的`CubeMesh`。点击网格属性，并将大小属性设置为`(0.5,
    0.2, 2)`。这是箭头的主体，但它仍然有一个问题。如果你旋转父对象，网格将围绕其中心旋转。相反，你需要箭头围绕其末端旋转，所以将`MeshInstance`的变换/平移更改为`(0,
    0, -1)`：
- en: '![](img/00163.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00163.jpeg)'
- en: Try rotating the `Arrow` (root) node with the gizmo to confirm that the shape
    is now offset correctly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用gizmo旋转`Arrow`（根）节点，以确认形状现在偏移正确。
- en: To create the point of the arrow, add another `MeshInstance`, and this time
    choose New PrismMesh. Set its size to `(1.5, 2, 0.5)`. You now have a flat triangle
    shape. To place it properly at the end of the rectangle, change the mesh's Transform/Translation
    to `(0, 0, -3)` and its Rotation Degrees to `(-90, 0, 0)`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建箭头的尖端，添加另一个`MeshInstance`，这次选择New PrismMesh。将其大小设置为`(1.5, 2, 0.5)`。现在你有一个平面的三角形形状。为了将其正确放置在矩形的末端，将网格的Transform/Translation更改为`(0,
    0, -3)`，并将其Rotation Degrees更改为`(-90, 0, 0)`。
- en: Using primitives is a quick way to create placeholder objects directly in Godot
    without having to open up your 3D modeling software.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原语是直接在Godot中创建占位符对象的一种快速方法，而无需打开你的3D建模软件。
- en: 'Finally, scale the whole arrow down by setting the root node''s Transform/Scale
    to `(0.5, 0.5, 0.5)`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将根节点的Transform/Scale设置为`(0.5, 0.5, 0.5)`来缩小整个箭头：
- en: '![](img/00164.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00164.jpeg)'
- en: You now have a completed arrow shape. Save it, then instance it in the `Main`
    scene.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了一个箭头形状。保存它，然后在`Main`场景中实例化它。
- en: UI display
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI显示
- en: 'Create a new scene with a CanvasLayer called `UI`. In this scene, you''ll show
    the power bar as well as the shot count for the player''s score. Add a `MarginContainer`,
    `VBoxContainer`, two `Label` properties, and a `TextureProgress`. Name them as
    shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，其中包含一个名为`UI`的CanvasLayer。在这个场景中，你将显示力量条以及玩家的得分次数。添加一个`MarginContainer`、`VBoxContainer`、两个`Label`属性和一个`TextureProgress`。按照以下名称命名：
- en: '![](img/00165.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00165.jpeg)'
- en: 'Set the Custom Constants of `MarginContainer` all to `20`. Add the `Xolonium-Regular.ttf`
    font to both of the `Label` nodes and set their font sizes to `30`. Set the `Shots` label''s
    Text to Shots: 0 and the `Label` Text to Power. Drag one of the colored bar textures
    from `res://assets` into the Texture/Progress of `PowerBar`. By default, `TextureProgress`
    bars grow from left to right, so for a vertical orientation, change the Fill Mode
    to Bottom to Top.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '将`MarginContainer`的`Custom Constants`全部设置为`20`。将`Xolonium-Regular.ttf`字体添加到两个`Label`节点中，并将它们的字体大小设置为`30`。将`Shots`标签的文本设置为Shots:
    0，将`Label`的文本设置为Power。将`res://assets`中的一个彩色条纹理拖放到`PowerBar`的Texture/Progress中。默认情况下，`TextureProgress`条从左到右增长，因此对于垂直方向，将填充模式更改为从下到上。'
- en: 'The completed UI layout should look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的UI布局应该看起来像这样：
- en: '![](img/00166.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00166.jpeg)'
- en: Instance this scene in the `Main` scene. Because it's a CanvasLayer, it will
    be drawn on top of the 3D camera view.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`场景中实例化此场景。因为它是一个CanvasLayer，所以它将被绘制在3D相机视图之上。
- en: Scripts
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'In this section, you''ll create the scripts needed to make everything work
    together. The flow of the game will be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建使一切协同工作的脚本。游戏流程如下：
- en: Place the ball at the start (`Tee`)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球放置在起点（Tee）
- en: 'Angle mode: Aim the ball'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角度模式：瞄准球
- en: 'Power mode: Set the hit power'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 力量模式：设置击球力量
- en: Launch the ball
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射球
- en: Repeat from step 2 until the ball is in the hole
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2，直到球进入洞中
- en: UI
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI
- en: 'Add the following script to the `UI` to update the UI elements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本添加到`UI`以更新UI元素：
- en: '[PRE0]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The two functions provide a way to update the UI elements when they need to
    display a new value. As you did in the Space Rocks game, changing the progress
    bar's texture based on its size gives a nice high/medium/low feel to the power
    level.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数提供了一种在需要显示新值时更新UI元素的方法。正如你在Space Rocks游戏中做的那样，根据进度条的大小更改纹理，给力量级别带来很好的高/中/低感觉。
- en: Main
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Main
- en: 'Next, add a script to `Main` and start with these variables:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`Main`添加一个脚本，并从以下变量开始：
- en: '[PRE1]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `enum` lists the states the game can be in, while the `power*` and `angle*`
    variables will be used to set their respective values and change them over time.
    Take a look at the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`列出了游戏可能处于的状态，而`power*`和`angle*`变量将用于设置它们的相应值并在时间上改变它们。看看以下代码片段：'
- en: '[PRE2]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the beginning, the ball is placed at the location of the `Tee` using both
    bodies'' `transform.origin` properties. Then, the game is put into the `SET_ANGLE`
    state:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，球被放置在`Tee`的位置，使用两个物体的`transform.origin`属性。然后，游戏被置于`SET_ANGLE`状态：
- en: '[PRE3]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `SET_ANGLE` state places the arrow at the ball's location. Recall that you
    offset the arrow, so it will appear to be pointing out from the ball. When rotating
    the arrow, you rotate it around the *y* axis so that it remains flat (the *y*
    axis points upwards).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET_ANGLE`状态将箭头放置在球的位置。回想一下，你偏移了箭头，所以它看起来是从球指向外。当旋转箭头时，你围绕*y*轴旋转它，使其保持平坦（*y*轴向上）。'
- en: Also, note that when entering the `SHOOT` state, you call the `shoot()` function
    on the `Ball`. You'll add that function in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在进入`SHOOT`状态时，你在`Ball`上调用`shoot()`函数。你将在下一节中添加该函数。
- en: 'The next step is to check for user input:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查用户输入：
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only input for the game is clicking the left mouse button. Depending on
    what state you''re in, clicking it will transition to the next state:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的唯一输入是点击左鼠标按钮。根据你处于什么状态，点击它将过渡到下一个状态：
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `_process()`, you determine what to animate based on the state. For now,
    it just calls the function that animates the property that''s currently being
    set:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_process()`中，你根据状态确定要动画化什么。现在，它只是调用当前正在设置的属性动画的函数：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both of these functions are similar. They gradually change a value between two
    extremes, reversing direction when a limit is hit. Note that the arrow is animating
    over a +/- 90-degree arc.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都很相似。它们在两个极端之间逐渐改变一个值，当达到极限时反转方向。请注意，箭头在±90度的弧上动画。
- en: Ball
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球
- en: 'In the ball script, there are two functions needed. First, an impulse must
    be applied to the ball to launch it. Second, when the ball stops moving, it needs
    to notify the `Main` scene so that the player can take another shot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在球脚本中，需要两个函数。首先，必须对球施加一个脉冲以使其发射。其次，当球停止移动时，需要通知`Main`场景，以便玩家可以再次射击：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you saw in the Space Rocks game, you can use the physics state in `_integrate_forces()`
    to safely stop the ball if the speed has gotten too slow. Remember, due to floating
    point number precision, the velocity may not actually slow to `0` on its own.
    The ball may appear to be stopped, but its velocity may actually be something
    like `0.0000001` instead. Rather than wait for it to reach `0`, you can make the
    ball stop if its speed drops below `0.1`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在《太空岩石》游戏中看到的，你可以在`_integrate_forces()`中使用物理状态安全地停止球，如果速度变得太慢。记住，由于浮点数精度，速度可能不会自行减慢到`0`。球可能看起来已经停止，但它的速度实际上可能是`0.0000001`。而不是等待它达到`0`，你可以使球停止，如果其速度低于`0.1`。
- en: Hole
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洞
- en: 'To detect when the ball has dropped into the hole, click on the `Area` in `Main`
    and connect its `body_entered` signal:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测球是否掉入洞中，请点击`Main`中的`Area`并连接其`body_entered`信号：
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Changing to the `WIN` state will prevent the ball's `stopped` signal from allowing
    another shot.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`WIN`状态将防止球的`stopped`信号允许再次射击。
- en: Testing it out
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试它
- en: Try running the game. You may want to make sure you have a very easy course
    with a straight shot to the hole for this part. You should see the arrow rotating
    at the ball's position. When you click the mouse button, the arrow stops, and
    the power bar starts moving up and down. When you click a second time, the ball
    is launched.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏。你可能想确保这部分有一个非常简单的课程，直线射击到洞口。你应该看到箭头在球的位置旋转。当你点击鼠标按钮时，箭头停止，力量条开始上下移动。当你第二次点击时，球被发射。
- en: If any of those steps don't work, don't go any further, but stop and go back
    to try and find what you missed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些步骤中的任何一个不起作用，不要继续前进，而是停止并返回尝试找出你遗漏了什么。
- en: Once everything is working, you'll notice some areas that need improvement.
    First, when the ball stops moving the arrow may not point in the direction you
    want. The reason for this is that the starting angle is always `0`, which points
    along the *z* axis, and then the arrow swings +/- 90 degrees from there. In the
    next sections, you'll have the option of improving the aiming in two ways.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常后，你会注意到一些需要改进的地方。首先，当球停止移动时，箭头可能不会指向你想要的方向。原因是起始角度始终是`0`，这指向*z*轴，然后箭头从那里挥动±90度。在下一节中，你将有两个改进瞄准的方法。
- en: Improving aiming – option 1
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善瞄准 – 选项1
- en: The aim could be improved by making the 180-degree swing of the arrow always
    begin by pointing towards the hole.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使箭头的180度挥动始终指向洞口，可以提高目标。
- en: 'Add a variable called `hole_dir` to the `Main` script. At the start of aiming,
    this will be set to the angle pointing towards the hole using the following function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`脚本中添加一个名为`hole_dir`的变量。在瞄准开始时，这将通过以下函数设置为指向洞口的角：
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that the ball's position is its center, so it's slightly above the
    surface, while the hole's center is somewhat below. Because of this, an arrow
    pointing directly between them would point at a downward angle into the ground.
    To prevent this and keep the arrow level, you can use only the *x* and *z* values
    from the `transform.origin` to produce a `Vector2`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，球的位置是其中心，所以它略微高于表面，而洞的中心则稍微低于表面。因此，直接指向它们之间的箭头会指向地面的向下角度。为了防止这种情况并保持箭头水平，你可以只使用`transform.origin`的*x*和*z*值来生成一个`Vector2`。
- en: 'Now the initial arrow direction is towards the hole, so you can alter the animation
    to add +/-90 degrees to that angle:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始箭头方向是指向洞的，因此你可以改变动画，将±90度添加到该角度：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, change the `SET_ANGLE` state to call the function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`SET_ANGLE`状态更改为调用函数：
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try the game again. The ball should now always point in the general direction
    of the hole. This is better, but you still can't point in any direction you like.
    For that, you can try aiming option 2.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试游戏。现在球应该总是指向洞的大致方向。这更好，但你仍然不能指向你喜欢的任何方向。为此，你可以尝试瞄准选项2。
- en: Improving aiming – option 2
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进瞄准 – 选项2
- en: The previous solution is acceptable, but there is another possibility. Instead
    of the arrow bouncing back and forth, you can aim by moving the mouse side-to-side.
    The benefit of this option is that you're not limited to 180 degrees of motion.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法是可以接受的，但还有一种可能性。不是让箭头来回弹跳，你可以通过移动鼠标左右瞄准。这个选项的好处是，你不受180度运动的限制。
- en: 'To accomplish this, you can make use of a particular input event: `InputEventMouseMotion`.
    This event occurs when the mouse moves, and returns with it a `relative` property
    representing how far the mouse moved in the previous frame. You can use this value
    to rotate the arrow by a small amount.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以利用特定的输入事件：`InputEventMouseMotion`。当鼠标移动时，此事件发生，并返回一个`relative`属性，表示鼠标在上一帧中移动的距离。你可以使用这个值来旋转箭头一个小量。
- en: 'First, disable the arrow animation by removing the `SET_ANGLE` portion from
    `_process()`. Next, add the following code to `_input()`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过从`_process()`中移除`SET_ANGLE`部分来禁用箭头动画。接下来，将以下代码添加到`_input()`中：
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This sets the arrow's rotation as you move the mouse left/right on the screen.
    Dividing by `150` ensures that the movement isn't too fast and that you can move
    a full 360 degrees if you move the mouse all the way from one side of the screen
    to the other. Depending on your mouse's sensitivity, you can adjust this to your
    preference.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了箭头的旋转，当你将鼠标在屏幕上左右移动时。除以`150`确保移动不会太快，并且如果你将鼠标从屏幕的一侧移动到另一侧，你可以移动完整的360度。根据你鼠标的灵敏度，你可以调整这个值以适应你的偏好。
- en: Camera improvements
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像头改进
- en: Another problem, especially if you have a relatively large course, is that if
    your camera is placed to show the starting area near the tee, it may not show
    the other parts of the course well, or at all. This can make it challenging to
    aim when the ball is in certain places.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题，尤其是如果你有一个相对较大的课程，那就是如果你的摄像头放置在展示发球区附近，可能无法很好地显示课程的其他部分，甚至根本无法显示。这可能会在球位于某些位置时使瞄准变得具有挑战性。
- en: In this section, you'll learn two different ways to address this problem. One
    involves creating multiple cameras and activating whichever one is closer to the
    ball's position. The other solution is to create an *orbiting* camera that follows
    the ball and that the player can control to view the course from any angle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习两种不同的方法来解决此问题。一种方法涉及创建多个摄像头并激活离球位置最近的那个。另一种解决方案是创建一个*环绕*摄像头，它跟随球并允许玩家控制从任何角度查看课程。
- en: Multiple cameras
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个摄像头
- en: 'Add a second `Camera` node and position it near the hole or at the opposite
    end of your course, for example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第二个`Camera`节点并将其放置在洞附近或课程的对端，例如：
- en: '![](img/00167.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00167.jpeg)'
- en: 'Add an `Area` child to this second camera. Name it `Camera2Area` and then add
    a `CollisionShape`. You could use a spherical shape just as well, but for this
    example, choose a `BoxShape`. Note that because you''ve rotated the camera, the
    box is rotated as well. You can reverse this by setting the rotation of `CollisionShape`
    to the opposite value, or you can leave it rotated. Either way, adjust the size
    and position of the box to cover the portion of the course you want the camera
    to be responsible for:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 向这个第二个相机添加一个`Area`子节点。命名为`Camera2Area`，然后添加一个`CollisionShape`。你也可以使用球形形状，但在这个例子中，选择一个`BoxShape`。请注意，因为你已经旋转了相机，所以盒子也旋转了。你可以通过将`CollisionShape`的旋转设置为相反的值来反转这一点，或者你可以让它保持旋转。无论如何，调整盒子的大小和位置以覆盖你想要相机负责的赛道部分：
- en: '![](img/00168.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00168.jpeg)'
- en: 'Now, connect the area''s `body_entered` signal to the main script. When the
    ball enters the area, the signal will be emitted, and you can change the active
    camera:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将区域的`body_entered`信号连接到主脚本。当球进入区域时，将发出信号，你可以更改活动相机：
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Play the game again and hit the ball toward the new camera area. Confirm that
    the camera view changes when the ball enters the area. For a large course, you
    can add as many cameras as you want/need and set them to activate for different
    sections of the course.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏并击打球向新的相机区域。确认当球进入区域时相机视图发生变化。对于大型场地，你可以添加尽可能多的相机并将它们设置为激活不同部分的赛道。
- en: The drawback of this method is that the cameras are still static. Unless you've
    very carefully placed them in the right positions, it still may not be comfortable
    to aim the ball from some locations on the course.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是相机仍然是静态的。除非你非常小心地将它们放置在正确的位置，否则从赛道上的某些位置瞄准球可能仍然不舒服。
- en: Orbiting camera
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转相机
- en: 'In many 3D games, the player can control a camera that rotates and moves as
    desired. Typically, the control scheme uses a combination of mouse and keyboard.
    The first step will be to add some new input actions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多3D游戏中，玩家可以控制一个可以按需旋转和移动的相机。通常，控制方案使用鼠标和键盘的组合。第一步将是添加一些新的输入动作：
- en: '![](img/00169.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00169.jpeg)'
- en: The WASD keys will be used to orbit the camera by moving it side to side and
    up and down. The mouse wheel will control zooming in/out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: WASD键将被用来通过左右和上下移动来旋转相机。鼠标滚轮将控制缩放。
- en: Creating a gimbal
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建陀螺仪
- en: 'The camera movement needs to have some restrictions. For one, it should always
    remain level, and not be tilted side to side. Try this: take a camera and rotate
    it a small amount around x (red ring), then a small amount around *z* (blue ring).
    Now, reverse the *x* rotation and click the Preview button. Do you see how the
    camera is now tilted?'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 相机移动需要有一些限制。一方面，它应该始终保持水平，而不是倾斜。尝试这样做：拿一个相机，围绕x轴（红色环）旋转一小部分，然后围绕*z*轴（蓝色环）旋转一小部分。现在，反转*x*旋转并点击预览按钮。你是否看到相机现在倾斜了？
- en: The solution to this problem is to place the camera on a *gimbal—*a device designed
    to keep an object level during movement. You can create a gimbal using two `Spatial`
    nodes, which will control the camera's left/right and up/down movement respectively.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将相机放置在**陀螺仪**上——一种设计用来在运动中保持物体水平状态的装置。你可以使用两个`Spatial`节点来创建一个陀螺仪，它们将分别控制相机的左右和上下移动。
- en: First, make sure to remove any other `Camera` nodes in the scene. If you tried
    the multiple camera setup from the previous section and you'd rather not delete
    them, you can set their Current values to Off and disconnect any `Area` signals
    for them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保从场景中移除任何其他`Camera`节点。如果你尝试了上一节中的多相机设置并且不想删除它们，你可以将它们的`Current`值设置为`Off`，并断开任何`Area`信号。
- en: 'Add a new `Spatial` node called `GimbalOut` and place it near the center of
    the course. Make sure not to rotate it. Give it a `Spatial` child called `GimbalIn`,
    and then add a `Camera` to that node. Set the Transform/Translation of Camera
    to `(0, 0, 10)`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的名为`GimbalOut`的`Spatial`节点并将其放置在赛道中心附近。确保不要旋转它。给它一个名为`GimbalIn`的`Spatial`子节点，然后向该节点添加一个`Camera`。将相机的变换/平移设置为`(0,
    0, 10)`：
- en: '![](img/00170.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00170.jpeg)'
- en: 'Here''s how the gimbal works: the outer spatial is allowed to rotate *only*
    in *y*, while the inner one rotates *only* in *x*. You can try it yourself, but
    make sure you change to Local Space Mode (see the *Introduction to 3D* section).
    Remember to only move the *green* ring of the outer gimbal node and only the *red*
    ring of the inner one. Don''t change the camera at all. Reset all the rotations
    to `0` once you''ve finished experimenting.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是陀螺仪的工作原理：外部的空间允许仅在*y*轴上旋转*仅*，而内部的一个*仅*在*x*轴上旋转。你可以亲自尝试，但请确保切换到本地空间模式（参见*3D
    简介*部分）。记住，只移动外部陀螺仪节点的*绿色*环和内部节点的*红色*环。不要改变相机设置。实验完成后，将所有旋转重置为`0`。
- en: 'To control this motion in the game, attach a script to `GimbalOut` and add
    the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏中控制这种运动，请将脚本附加到`GimbalOut`上并添加以下内容：
- en: '[PRE14]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the left/right actions rotate `GimbalOut` only on the *y* axis,
    while the up/down actions rotate `GimbalIn` on the *x* axis. The entire gimbal
    system's `scale` property is used to handle zooming. It is also necessary to set
    some limits using `clamp()`. The rotation limit holds up/down movement between
    `-0.2` (almost level with the ground) to `-90` degrees (looking straight down)
    while the zoom limit keeps you from getting too close or too far away.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，左右动作仅在*y*轴上旋转`GimbalOut`，而上下动作在*x*轴上旋转`GimbalIn`。整个陀螺仪系统的`scale`属性用于处理缩放。还需要使用`clamp()`设置一些限制。旋转限制将上下移动保持在`-0.2`（几乎与地面水平）到`-90`度（直视下方）之间，而缩放限制则防止你离得太近或太远。
- en: Run the game and test the camera controls. You should be able to pan in all
    four directions and zoom with your mouse wheel. However, the gimbal's position
    is still static, so you may have trouble seeing the ball properly from certain
    angles.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并测试相机控制。你应该能够使用鼠标滚轮在所有四个方向上平移和缩放。然而，陀螺仪的位置仍然是静态的，因此你可能从某些角度难以正确看到球。
- en: Tracking camera
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪相机
- en: 'There is one final improvement to the camera: making it follow the ball. Now
    that you have a stable, gimbaled camera, it will work great if the gimbal is set
    to follow the ball''s position. Add this line to the `Main` scene''s `_process()`
    function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对相机的一个最终改进是让它跟随球。现在你有一个稳定的、可旋转的相机，如果陀螺仪设置为跟随球的位置，它将工作得很好。将以下行添加到`Main`场景的`_process()`函数中：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that you shouldn't set the gimbal's transform to the ball's transform,
    or it will also *rotate* as the ball rolls!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不应该将陀螺仪的变换设置为球的变换，否则它也会随着球的滚动而*旋转*！
- en: Try the game now and observe how the camera tracks the ball's movement while
    still being able to rotate and zoom.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试游戏并观察相机如何追踪球的运动，同时仍然能够旋转和缩放。
- en: Visual effects
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉效果
- en: 'The appearance of the ball and the other meshes in your scene have been intentionally
    left very plain. You can think of the flat, white ball like a blank canvas, ready
    to be molded and shaped the way you want it. Applying graphics to 3D models can
    be a very complex process, especially if you''re not familiar with it. First,
    a bit of vocabulary:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 球和其他场景中网格的外观已经被故意设计得非常简单。你可以将这个扁平的白色球想象成一个空白画布，准备好按照你的意愿塑造和塑形。将图形应用到3D模型上可能是一个非常复杂的过程，尤其是如果你不熟悉它。首先，一些词汇：
- en: '**Textures**: Textures are flat, 2D images that are *wrapped* around 3D objects
    to give them more interesting appearances. Imagine wrapping a present: the flat
    paper is folded around the package, conforming to its shape. Textures can be very
    simple or quite complex depending on the shape they are designed to be applied
    to. An example of a simple one would be a small pattern of bricks that can be
    repeated on a large wall object.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：纹理是平面的、二维图像，它们被*包裹*在3D对象周围，以赋予它们更有趣的外观。想象一下包裹一个礼物：平面的纸张被折叠在包裹周围，以适应其形状。纹理可以是非常简单的，也可以非常复杂，这取决于它们设计要应用到哪种形状上。一个简单的例子可能是一小块可以重复在大型墙面物体上的砖块图案。'
- en: '**Shaders**: While textures determine *what* is drawn on an object''s surface,
    shaders determine *how* it is drawn. Imagine that same brick wall. How would it
    look if it were wet? The mesh and the texture would still be the same, but the
    way the light reflects from it would be quite different. This is the function
    of shaders: to alter the appearance of an object without actually changing it. Shaders
    are typically written in a specialized programming language and can use a great
    deal of advanced math, the details of which are beyond the scope of this book.
    For many effects, writing your own shader is unavoidable. However, Godot provides
    an alternative method of creating a shader for your object that allows for a great
    deal of customization without diving into shader code: `ShaderMaterial`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器**：虽然纹理决定了对象表面绘制的内容，但着色器决定了绘制的方式。想象一下同样的砖墙。如果它湿了会是什么样子？网格和纹理仍然是相同的，但光线从其反射的方式会有很大的不同。这就是着色器的功能：在不实际改变对象的情况下改变其外观。着色器通常用一种专门的编程语言编写，并且可以使用大量的高级数学，这些细节超出了本书的范围。对于许多效果，编写自己的着色器是不可避免的。然而，Godot提供了一种创建着色器的替代方法，允许在不深入研究着色器代码的情况下对对象进行大量定制：`ShaderMaterial`。'
- en: '**Materials**: Godot uses a computer graphics model called **Physically Based
    Rendering** (**PBR**). The goal of PBR is to render the surface of objects in
    a way that more accurately models the way light works in the real world. These
    affects are applied to meshes using the `Material` property. Materials are essentially
    containers for textures and shaders. Rather than apply them individually, they
    are contained in the material, which is then added to the object. The material''s
    properties determine how the textures and shader effects are applied. Using Godot''s
    built-in material properties, you can simulate a wide range of realistic (or stylized)
    real-world physical materials, such as stone, cloth, or metal. If the built-in
    properties aren''t enough for your purposes, you can write your own shader code
    to add even more effects.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质**：Godot使用一种称为**基于物理的渲染**（**PBR**）的计算机图形模型。PBR的目标是以更准确地模拟现实世界中光线作用的方式渲染物体的表面。这些效果通过`Material`属性应用于网格。材质基本上是纹理和着色器的容器。而不是单独应用它们，它们被包含在材质中，然后添加到对象上。材质的属性决定了纹理和着色器效果如何应用。使用Godot内置的材质属性，您可以模拟各种现实世界（或风格化）的物理材质，如石头、布料或金属。如果内置属性不足以满足您的需求，您可以编写自己的着色器代码以添加更多效果。'
- en: You can add a PBR material to a mesh using a `SpatialMaterial`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`SpatialMaterial`将PBR材质添加到网格中。
- en: SpatialMaterials
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpatialMaterials
- en: 'Click on the ball''s `MeshInstance` and, under Material, select New SpatialMaterial,
    then click the new material. You will see a great number of parameters, far more
    than can be covered in this book. This section will focus on some of the most
    useful ones for making the ball look more appealing. You are encouraged to visit [http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html](http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html) for
    a full explanation of all the `SpatialMaterial` settings. To improve the look
    of the ball, try experimenting with these parameters:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 点击球体的`MeshInstance`，然后在材质下选择新建`SpatialMaterial`，然后点击新材质。您将看到大量的参数，远超过本书所能涵盖的范围。本节将重点介绍一些使球体看起来更吸引人的最有用参数。鼓励您访问[http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html](http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html)以获取所有`SpatialMaterial`设置的完整解释。为了改善球体的外观，尝试对这些参数进行实验：
- en: '**Albedo**: This property sets the base color of the material. Change this
    to make the ball whatever color you like. If you''re working with an object that
    needs a texture to be applied, you can add it here as well.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Albedo**：此属性设置材质的基本颜色。更改此属性可以使球体呈现您喜欢的任何颜色。如果您正在处理需要应用纹理的对象，您也可以在此处添加它。'
- en: '**Metallic and Roughness**: These parameters control how reflective the surface
    is. Both can be set to values between `0` and `1`. The Metallic value controls
    the *shininess*; higher values will reflect more light. The *Roughness* value
    applies an amount of blur to the reflection. You can simulate a wide variety of
    materials by adjusting these two properties. The following is a guide to how the *Roughness*
    and *Metallic* properties affect the appearance of an object. Keep in mind that
    lighting and other factors will alter the surface appearance as well. Understanding
    how light and reflections interact with surface properties is a big part of learning
    to design effective 3D objects:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金属和粗糙度**：这些参数控制表面如何反射。两者都可以设置为 `0` 到 `1` 之间的值。金属值控制 *光泽度*；值越高，反射的光越多。粗糙度值对反射应用一定程度的模糊。通过调整这两个属性，你可以模拟各种材料。以下是如何
    *粗糙度* 和 *金属* 属性影响物体外观的指南。请记住，照明和其他因素也会改变表面外观。了解光和反射如何与表面属性相互作用是学习设计有效3D对象的重要组成部分：'
- en: '![](img/00171.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: '**Normal Map**: Normal mapping is a 3D graphics technique for *faking* the
    appearance of bumps and dents in a surface. Modeling these in the mesh itself
    would result in a large increase in the number of polygons, or faces, making up
    the object, leading to reduced performance. Instead, a 2D texture is used that
    maps the pattern of light and shadow that would result from these small surface
    features. The lighting engine then uses that information to alter the lighting
    as if those details were actually there. A properly constructed normal map can
    add a great amount of detail to an otherwise bland-looking object.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线图**：法线映射是一种3D图形技术，用于 *模拟* 表面上的凹凸。在网格本身中建模这些会导致组成对象的三角形数量或面数大幅增加，从而降低性能。相反，使用一个2D纹理来映射这些小表面特征会产生光和影的图案。然后，照明引擎使用这些信息来改变照明，就像那些细节实际上存在一样。一个正确构建的法线图可以为原本看起来平淡无奇的对象添加大量细节。'
- en: 'The ball is a perfect example of a good use of normal mapping because a real
    golf ball has hundreds of dimples on its surface, but the sphere primitive is
    a smooth surface. Using a regular texture could add spots, but they would look
    flat and painted on. A normal map that would simulate those dimples looks like
    this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个球体是一个很好的法线映射应用的例子，因为真实的高尔夫球在其表面有数百个凹坑，但球体原语是一个光滑的表面。使用常规纹理可以添加斑点，但它们看起来会显得扁平且涂鸦在上面。模拟这些凹坑的法线图看起来像这样：
- en: '![](img/00172.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00172.jpeg)'
- en: It doesn't look like much, but the pattern of red and blue contains information
    telling the engine which direction it should assume the surface is facing at that
    point and therefore which direction light should reflect from it there. Note the
    stretching along the top and the bottom—that's because this image is made to be
    wrapped around a sphere shape.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来并不起眼，但红色和蓝色的图案包含了告诉引擎在那个点表面应该朝哪个方向的信息，因此光线应该从哪个方向反射出来。注意顶部和底部的拉伸——这是因为这张图片是为了包裹成球形形状而制作的。
- en: 'Enable the Normal Map property and drag `res://assets/ball_normal_map.png`
    into the *Texture* field. Try this with the *Albedo* color set to white at first,
    so you can best see the effect. Adjust the `Depth` parameter to increase or decrease
    the strength of the effect. A negative value will make the dimples look inset;
    something between `-1.0` and `-1.5` is a good value:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 启用法线图属性，并将 `res://assets/ball_normal_map.png` 拖入 *纹理* 字段。最初将 *Albedo* 颜色设置为白色，这样你可以最好地看到效果。调整
    `Depth` 参数以增加或减少效果强度。负值会使凹坑看起来是凹进去的；在 `-1.0` 和 `-1.5` 之间的值是一个不错的选择：
- en: '![](img/00173.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: Take some time to experiment with these settings and find a combination you
    like. Don't forget to try it in the game as well, as the ambient lighting of the
    `WorldEnvironment` will effect the final result.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间尝试这些设置，找到你喜欢的组合。别忘了在游戏中也试试，因为 `WorldEnvironment` 的环境光照会影响最终结果。
- en: Environment options
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境选项
- en: 'When you added the WorldEnvironment, the only parameter you changed was the *Ambient
    Light* color. In this section, you''ll learn about some of the other properties
    you can adjust for improved visual appeal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加了 WorldEnvironment，你唯一更改的参数是 *环境光照* 颜色。在本节中，你将了解一些你可以调整以改善视觉效果的其他属性：
- en: '**Background**: This parameter lets you specify what the background of the
    world looks like. The default value is Clear Color, which is the plain grey you
    see currently. Change the Mode to Sky and, in the Sky property, choose New Procedural
    Sky. Note that the sky is not just for background appearance—objects will reflect
    and absorb its ambient light. Observe how the ball''s appearance changes as you
    change the `Energy` parameter. This setting can be used to give the impression
    of a day or night sky, or even that of an alien planet.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：此参数允许你指定世界的背景看起来像什么。默认值是Clear Color，即你目前看到的纯灰色。将模式更改为Sky，并在Sky属性中，选择新的程序化天空。请注意，天空不仅仅是背景外观——物体将反射和吸收其环境光。观察当改变`Energy`参数时球的外观如何变化。此设置可用于营造白天或夜晚天空的印象，甚至外星行星的印象。'
- en: '**Screen Space Ambient Occlusion** (**SSAO**): When enabled, this parameter
    works together with any ambient light to produce shadows in corners. You have
    two sources of ambient light now: the *Background* (sky) and the *Ambient Light*
    settings. Enable SSAO and you''ll immediately see an improvement, making the walls
    of the course look much less fake and plastic. Feel free to try adjusting the
    various SSAO properties, but remember, a small change can make a big difference.
    Adjust the properties in small increments, and observe the effects before changing
    them further.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕空间环境光遮蔽**（**SSAO**）：当启用时，此参数与任何环境光一起工作，在角落产生阴影。现在你有两个环境光来源：*背景*（天空）和*环境光*设置。启用SSAO后，你会立即看到改进，使课程的墙壁看起来不那么虚假和塑料。请随意尝试调整各种SSAO属性，但请记住，微小的变化可以产生很大的差异。以小增量调整属性，并在更改它们之前观察效果。'
- en: '**DOF Far Blur**: *Depth of Field* adds a blur effect to objects that are above
    a certain distance from the camera. Try adjusting the Distance property to see
    the effect.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOF远模糊**：*景深*为距离相机一定距离以上的物体添加模糊效果。尝试调整距离属性以查看效果。'
- en: For more information about advanced usage of environmental effects, see [http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html](http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关环境效果的高级使用信息，请参阅[http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html](http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html)。
- en: Lighting
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光
- en: 'Add a `DirectionalLight` to the scene. This type of light simulates an infinite
    number of parallel rays of light, so it''s often used to represent sunlight or
    another very distant source of light that illuminates an entire area equally.
    The location of the node in the scene doesn''t matter, only its direction, so
    you can position it anywhere you like. Aim it using the gizmo so that it strikes
    the course at an angle, then turn Shadow/Enabled to On so that you''ll see shadows
    being cast from the walls and other objects:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DirectionalLight`添加到场景中。此类光线模拟无限数量的平行光线，因此常用于表示阳光或另一个照亮整个区域的光源。节点在场景中的位置无关紧要，只有其方向，因此你可以将其放置在任何你喜欢的地方。使用gizmo定位它，使其以角度击中课程，然后切换Shadow/Enabled为开启，以便你会看到从墙壁和其他物体投射出的阴影：
- en: '![](img/00174.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00174.jpeg)'
- en: There are a number of properties available to adjust and alter the appearance
    of the shadows, both in the *Shadow* section, which is present for all `Light`
    nodes, and in the *Directional Shadow* section, which is specific to `DirectionalLight`.
    The default values will work for most general cases, but the one property that
    you should probably adjust to improve shadow appearance is *Max Distance*. Lowering
    this value will improve shadow appearance, but only when the camera is closer
    than the given distance. If your camera will mostly be close to objects, you can
    reduce this value. To see the effect, try setting it to just `10` and zooming
    in/out, then do the same with it set to `1000`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多属性可用于调整和改变阴影的外观，无论是在所有`Light`节点都存在的*阴影*部分，还是在特定于`DirectionalLight`的*方向性阴影*部分。默认值将适用于大多数通用情况，但你可能需要调整的一个属性是*最大距离*。降低此值将改善阴影外观，但仅当相机距离小于给定距离时。如果你的相机将主要靠近物体，你可以降低此值。要查看效果，尝试将其设置为`10`并缩放，然后将其设置为`1000`进行相同的操作。
- en: Directional light can even be used to simulate the day/night cycle. If you attach
    a script to the light and slowly rotate it around one axis, you'll see the shadows
    change as if the sun is rising and setting.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 方向性光线甚至可以用来模拟昼夜循环。如果你将脚本附加到光线并围绕一个轴缓慢旋转它，你会看到阴影的变化，就像太阳在升起和落下一样。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the world of 3D graphics. One of Godot's great
    strengths is that the same tools and workflow are used in both 2D and 3D. Everything
    you learned about the process of creating scenes, instancing, and using signals
    works in the same way. For example, an interface you build with control nodes
    for a 2D game can be dropped into a 3D game and will work just the same.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带你进入了3D图形的世界。Godot的一个巨大优势是，在2D和3D中使用了相同的工具和工作流程。你关于创建场景、实例化和使用信号的过程中学到的所有内容都以相同的方式工作。例如，你为2D游戏构建的带有控制节点的界面可以放入3D游戏中，并且会以同样的方式工作。
- en: In this chapter, you learned how to navigate in the the 3D editor to view and
    place nodes using gizmos.You learned about meshes and how to quickly make your
    own objects using Godot's primitives. You used GridMap to lay out your minigolf
    course. You learned about using cameras, lighting, and the world environment to
    design how your game will appear on screen. Finally, you got a taste of using
    PBR rendering via Godot's SpatialMaterial resource.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在3D编辑器中导航，使用工具箱来查看和放置节点。你了解了网格和如何使用Godot的原生形状快速创建自己的对象。你使用了GridMap来布置你的迷你高尔夫球场。你学习了如何使用摄像机、照明和世界环境来设计你的游戏在屏幕上的显示效果。最后，你体验了通过Godot的SpatialMaterial资源使用PBR渲染。
- en: Congratulations, you've made it to the end! But with these five projects, your
    journey to becoming a game developer has just begun. As you become more proficient
    with Godot's features, you'll be able to make any game you can imagine.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经走到了终点！但有了这五个项目，你成为游戏开发者的旅程才刚刚开始。随着你对Godot功能的熟练掌握，你将能够制作出你所能想象到的任何游戏。
