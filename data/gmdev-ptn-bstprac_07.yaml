- en: Improving Performance with Object Pools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象池提高性能
- en: In programming languages, one of the most time-consuming things for the computer
    to do is deal with memory allocation. It's fairly inefficient and, depending on
    the resources being used, could slow down your game drastically.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，对于计算机来说，最耗时的事情之一就是处理内存分配。这相当低效，并且根据所使用的资源，可能会极大地减慢你的游戏速度。
- en: A common element found in shooter games, or any game with explosions or bullets,
    is to create and destroy many objects in quick succession. Take, for example,
    the *Touhou Project* series of games, where there are many bullets being fired
    by both the player and enemies. When done in the simplest manner, calling `new`
    when you want to create a bullet and `delete` when you want to remove it will
    cause our game to lag or freeze over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在射击游戏中常见的一个元素，或者任何有爆炸或子弹的游戏，是快速连续创建和销毁许多对象。以 *东方Project* 系列游戏为例，玩家和敌人都会发射大量子弹。如果以最简单的方式完成，当需要创建子弹时调用
    `new`，当需要移除它时调用 `delete`，这会导致我们的游戏随着时间的推移而变得卡顿或冻结。
- en: To prevent this from happening, we can make use of the Object Pool pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们可以利用对象池模式。
- en: Chapter overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: In this chapter, we will create an object pool that will allow players to spawn
    a large number of bullets on the screen for the game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个对象池，允许玩家在屏幕上为游戏生成大量子弹。
- en: Your objectives
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'This chapter will be split into a number of topics. It will contain a simple
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。它将包含一个从头到尾的简单分步过程。以下是我们的任务大纲：
- en: Why we should care about memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们应该关心内存
- en: The Object Pool pattern explained
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池模式解释
- en: Using memory pools--overloading `new` and `delete`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存池--重载 `new` 和 `delete`
- en: Design decisions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计决策
- en: Why you should care about memory
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你应该关心内存
- en: As a programmer, you're probably already used to using `new` and `delete` (or
    `malloc` and `free` if you're writing C), and you may be wondering why you would
    want to handle memory by yourself when it's already built into the language and
    is easy to use. Well, the first thing is that like most aspects of using a high-level
    programming language, you do not know what is going on behind the scenes. If you
    write your own logic to handle memory, you can create your own statistics and
    additional debugging support, such as automatically initializing data. You can
    also check for things such as memory leaks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你可能已经习惯了使用 `new` 和 `delete`（如果你正在编写 C 语言，则是 `malloc` 和 `free`），你可能想知道为什么你想自己处理内存，尽管它已经内置到语言中并且使用起来很简单。好吧，首先，就像使用高级编程语言的大多数方面一样，你并不知道幕后发生了什么。如果你编写自己的逻辑来处理内存，你可以创建自己的统计数据和额外的调试支持，例如自动初始化数据。你还可以检查内存泄漏等问题。
- en: However, for game developers the most important aspect to look into is that
    of performance. Allocating memory for a single object or thousands of them at
    once is approximately the same time as the computer needs to look through your
    computer's memory for an opening that isn't being used, and then give you the
    address to the beginning of that contiguous piece of memory. If you keep requesting
    small pieces of memory over and over again this can lead to memory fragmentation,
    which is to say that there isn't enough free continuous space when you want to
    get a larger object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于游戏开发者来说，最重要的方面是性能。为单个对象或一次性为成千上万个对象分配内存，所需时间与计算机查找你的计算机内存中未使用的空隙并给出该连续内存块起始地址所需的时间大致相同。如果你一次又一次地请求小块内存，这可能导致内存碎片化，也就是说，当你想要获取更大的对象时，没有足够的连续空闲空间。
- en: '![](img/00045.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: 'We may start off with some memory like this, with the gray sections being free
    memory and black being memory set aside because we called `new` for that amount
    of data. Each time we call for new, the computer needs to look for the first address
    that is open which has enough space to fit the object type we provide:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能开始时有一些这样的内存，灰色部分是空闲内存，黑色部分是因为我们为该数据量调用了 `new`。每次我们调用 `new` 时，计算机都需要寻找第一个有足够空间容纳我们提供的对象类型的空地址：
- en: '![](img/00046.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: 'Later on, we remove some of the memory and that opens up some space, but the
    computer will need to look at each address and spend more time searching:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们删除了一些内存，腾出了一些空间，但计算机需要查看每个地址并花费更多时间搜索：
- en: '![](img/00047.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: Finally, we get to a spot where we have very little open data and it requires
    a lot of work to find a place to insert new data, due to the memory becoming fragmented.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了一个地方，那里几乎没有开放数据，并且由于内存碎片化，插入新数据需要大量工作。
- en: This is especially important if you are developing titles for a console or for
    a mobile device, as the size of memory you have to work with is much smaller than
    what you're used to working with on a PC. If you used computers five or more years
    ago you may remember the idea of defragging your computer, in which your computer
    would shift pieces of memory over in order to create larger blocks that could
    be used later. But this was a very time-consuming process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于开发控制台或移动设备游戏尤其重要，因为你要处理的内存大小远小于你在PC上习惯使用的大小。如果你五年或更早之前使用过电脑，你可能记得电脑碎片化的概念，其中电脑会移动内存块以创建可以稍后使用的较大块。但这是一个非常耗时的过程。
- en: Mach5 doesn't easily give us the ability to support having game objects being
    created in this way but, if you are interested in doing this, we do have a way
    that can use the concepts of an object pool in order to not waste resources; we
    will discuss that later on in the chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Mach5并不容易提供支持以这种方式创建游戏对象的能力，但如果你对此感兴趣，我们确实有一种可以使用对象池概念的方法来避免资源浪费；我们将在本章后面讨论这一点。
- en: An excellent article on writing memory managers for game programming can be
    found at [http://www.gamasutra.com/view/feature/2971/play_by_play_effective_memory_.php](http://www.gamasutra.com/view/feature/2971/play_by_play_effective_memory_.php).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇关于为游戏编程编写内存管理器的优秀文章可以在[http://www.gamasutra.com/view/feature/2971/play_by_play_effective_memory_.php](http://www.gamasutra.com/view/feature/2971/play_by_play_effective_memory_.php)找到。
- en: The Object Pool pattern explained
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池模式解释
- en: Previously, we talked about the Singleton design pattern and how it's used to
    create a single instance of something inside of our project, often something static.
    We know there is only one and it's only created once, and that we can share it
    with the rest of our project without issues. However, the Singleton pattern only
    works when the instance is initialized.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了单例设计模式及其如何在项目中创建单个实例，通常是静态的。我们知道只有一个，并且它只创建一次，我们可以无问题地与项目的其余部分共享它。然而，单例模式仅在实例初始化时才有效。
- en: The object pool is similar but, instead of one object, we want to have a group
    (or pool) of objects (or instances) that we can refer to within the rest of the
    project. Whenever the project wants to access these objects, we have another object
    called an **object pool**, which acts as a liaison between the project and the
    objects themselves.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池类似，但不是单个对象，我们希望有一个组（或池）的对象（或实例），我们可以在项目的其余部分中引用。每当项目想要访问这些对象时，我们还有一个被称为**对象池**的另一个对象，它充当项目与对象本身之间的联络员。
- en: Also called a resource pool or an N-ton elsewhere in computer science (but most
    frequently in game development referred to as an object pool) you can think of
    the object pool as having a similar role to a manager. When our program wants
    an object to work with, the manager knows which objects are currently being used
    and will give you one that isn't, or expand to create a new one. This promotes
    reusing previously created objects instead of creating and deleting them on the
    fly. This provides a number of advantages when the cost of initializing a class
    instance is an expensive operation, or when the rate of instantiation is high
    and the amount of time the objects are being used is low.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为资源池或N吨在其他计算机科学领域（但在游戏开发中通常被称为对象池）中，你可以将对象池想象成一个类似管理者的角色。当我们的程序需要使用一个对象时，管理者知道哪些对象正在被使用，并将提供一个未被使用的对象，或者扩展以创建一个新的对象。这促进了之前创建的对象的重用，而不是在运行时创建和删除它们。当初始化类实例的成本很高，或者实例化的速率很高而对象的使用时间很低时，这提供了一系列优势。
- en: Let's consider our space shooter game as an example. Any time we press the spacebar,
    we have been creating a new object of the laser we want to shoot out. Also, any
    time we shoot something, we have to destroy them. This will slow down the performance
    of our game. This is not a huge issue now with such a simple game, but in AAA
    games we use this idea a lot, for example, in any of the games in the Naughty
    Dog's *Uncharted* series or most FPS titles. The enemies in these games are very
    complex, and having them in the game is very expensive. Instead of having a bunch
    of enemy objects in the game what will often be done instead is, after using enemies
    and having them die, they just turn invisible and when you need a new enemy, the
    dead object gets moved to a new position and gets turned on again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的太空射击游戏为例。每次我们按下空格键时，我们都会创建一个新的激光对象。同样，每次我们射击某个东西时，我们都需要销毁它们。这将减慢我们游戏的表现。对于这样一个简单的游戏来说，这并不是一个大问题，但在
    AAA 游戏中，我们经常使用这个想法，例如，在 Naughty Dog 的 *Uncharted* 系列中的任何一款游戏或大多数 FPS 游戏中。这些游戏中的敌人非常复杂，将它们放入游戏中成本很高。因此，通常不会在游戏中保留一大堆敌人对象，而是在使用敌人并让它们死亡后，它们会变得不可见，当你需要新的敌人时，死亡的物体会被移动到新的位置并重新激活。
- en: 'The very basic elements of an object pool will look something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池的基本元素看起来可能像这样：
- en: '![](img/00048.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: In our object pool's case, we have some type of variable that we want to hold
    the copies of. In this case, I've named it `GameObject`, but you'll also hear
    it referred to as a `Reusable` or `Resource` class instead. We use the `AcquireObject`
    function to get an object from our object pool, and we use the `ReleaseObject`
    function when we are finished working with it. The `GetInstance` function works
    in a similar manner to how it did with the Singleton class we talked about earlier,
    by giving us access to the `ObjectPool` referred to by it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的对象池的情况下，我们有一些类型的变量，我们想要持有其副本。在这种情况下，我将其命名为 `GameObject`，但你也会听到它被称为 `Reusable`
    或 `Resource` 类。我们使用 `AcquireObject` 函数从我们的对象池中获取一个对象，当我们完成对其操作时，我们使用 `ReleaseObject`
    函数。`GetInstance` 函数的工作方式与我们在前面讨论的 Singleton 类类似，它为我们提供了访问它所引用的 `ObjectPool` 的权限。
- en: In the Mach5 Engine, there isn't an included object pool by default, so we will
    actually need to extend the engine to support it. That means we'll need to actually
    build one from scratch.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mach5 引擎中，默认情况下并没有包含对象池，因此我们需要扩展引擎以支持它。这意味着我们需要从头开始构建一个。
- en: There are multiple ways to implement the Object Pool pattern or to get a similar
    behavior. We'll go over some of the commonly seen versions and the cons before
    moving to our final version.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式来实现对象池模式或获得类似的行为。在我们转向最终版本之前，我们将讨论一些常见的版本及其缺点。
- en: Implementing a basic object pool
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本对象池
- en: 'Let''s first start off by creating an object pool for a simple class that we
    can create multiples of:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从一个可以创建多个实例的简单类开始创建对象池：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, this sample `GameObject` class contains a name of the object to identify
    it by and some example properties to make the class seem more game-object-like.
    Obviously, you can easily add more properties and the same principles apply. In
    this case, we have a function called `Initialize`, which provides both a `set`
    and `reset` of values for the class. Finally, I added in a `GetInfo` function
    to print out information about the class so we can verify that things are working
    correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个示例 `GameObject` 类包含一个用于识别对象的名称和一些示例属性，使类看起来更像游戏对象。显然，你可以轻松地添加更多属性，并且相同的原理适用。在这种情况下，我们有一个名为
    `Initialize` 的函数，它为类提供 `set` 和 `reset` 值。最后，我添加了一个 `GetInfo` 函数来打印有关类的信息，这样我们就可以验证一切是否正常工作。
- en: 'The implementation for the class will look something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现将看起来像这样：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have our game objects created, we need the pool to be created:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了游戏对象，我们需要创建池：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To start off with there are two variables: `pool`, which will contain all of
    the available objects within our object pool, and `instance`, which is a way for
    us to access it. Note that our object pool uses the Singleton design pattern,
    in that there can only be one per type of object you''d like to have copies of.
    In this instance, we have the same issues that we talked about earlier, namely
    that you have to actually delete the pool and remove all of the elements that
    were created, which is why we added in a `ClearPool` function which does exactly
    that. The implementation for the class will look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有两个变量：`pool`，它将包含我们对象池中所有的可用对象，以及`instance`，这是我们访问它的一种方式。请注意，我们的对象池使用Singleton设计模式，这意味着对于你想要复制的每种类型的对象，只能有一个。在这种情况下，我们遇到了之前讨论过的问题，即你必须实际删除池并移除创建的所有元素，这就是为什么我们添加了一个`ClearPool`函数，它正好做了这件事。类的实现将类似于以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this preceding function, we first check if `instance` is set. If it''s not,
    we dynamically allocate memory for it and set the `instance` variable to it. Either
    way, we''ll have an instance afterwards, and that is what we return:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的函数中，我们首先检查`instance`是否已设置。如果没有设置，我们为其动态分配内存并将其设置为`instance`变量。无论如何，我们之后都会有一个实例，这就是我们返回的内容：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ClearPool` function will continuously remove objects from the pool until
    it is empty. We first get a reference to the object, by retrieving the last element
    using the `back` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearPool`函数会持续从池中移除对象，直到池为空。我们首先通过使用`back`函数获取对象的引用，来检索最后一个元素。'
- en: 'We then remove the element from the pool before deleting the object itself
    safely:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在删除对象本身之前从池中移除该元素：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, C++ requires that we initialize the `instance` variable, so we add
    that last.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++要求我们必须初始化`instance`变量，所以我们最后添加了这一项。
- en: 'Once we have this foundational code in, we can start to use the classes. An
    example usage could be the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个基础代码，我们就可以开始使用类了。一个示例用法可能是以下内容：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we save this script and run it in a blank project, you''ll see the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此脚本保存并在空白项目中运行它，你会看到以下内容：
- en: '![](img/00049.gif)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.gif)'
- en: In this case, we first get our `ObjectPool` that makes use of the `GetInstance`
    function, and then obtain an object from the object pool using the `AcquireObject`
    function (which calls `new` to create the object). From there we print out its
    values and, due to the constructor, it is set to our predefined default values.
    We then assign the values and use it. Afterward, we release it from the list in
    which we placed it on the pool, to be reused when we are ready. We then get the
    object again and show that it's already reset to be reused in exactly the same
    way as before!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先获取使用`GetInstance`函数的`ObjectPool`，然后使用`AcquireObject`函数（它调用`new`来创建对象）从对象池中获取一个对象。从那里我们打印出它的值，由于构造函数，它被设置为预定义的默认值。然后我们分配值并使用它。之后，我们将它从放置在池中的列表中释放出来，以便在准备好时重用。然后我们再次获取该对象，并显示它已经重置，可以像之前一样重用！
- en: Operator overloading in C++
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的操作符重载
- en: We now have a good foundation to build on, but we can actually make our object
    pool much nicer to use. One of the cooler features in C++ is the fact that you
    can override the default behaviors of operators, typically referred to as **operator
    overloading**. This is done with functions being created with specific names that
    contain the operator keyword, followed by what operator you want to define. Just
    like regular functions, they have return types as well as parameters that get
    passed to them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个很好的基础可以在此基础上构建，但实际上我们可以使我们的对象池更容易使用。C++中一个很酷的特性是你可以覆盖操作符的默认行为，通常称为**操作符重载**。这是通过创建具有特定名称的函数来完成的，这些名称包含操作符关键字，后面跟着你想要定义的操作符。就像常规函数一样，它们也有返回类型以及传递给它们的参数。
- en: For more information on operator overloading and how it works in C++, check
    out [http://www.cprogramming.com/tutorial/operator_overloading.html](http://www.cprogramming.com/tutorial/operator_overloading.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于操作符重载及其在C++中的工作方式，更多信息请查看[http://www.cprogramming.com/tutorial/operator_overloading.html](http://www.cprogramming.com/tutorial/operator_overloading.html)。
- en: In addition to common operators, such as `+`, `-`, and `/`, we also have the
    ability to overload the `new` and `delete` operators as well, allowing us to use
    our own custom object pool instead!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的操作符，如`+`、`-`和`/`之外，我们还有能力重载`new`和`delete`操作符，这样我们就可以使用我们自己的自定义对象池了！
- en: 'To do this, we will need to add the following to the end of the `GameObject`
    class, and add the following bold lines to the class definition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要将以下内容添加到`GameObject`类的末尾，并将以下加粗行添加到类定义中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we added two new functions to the `GameObject` class--one for us to create
    our own version of `new` and another for our version of `delete`. Then, we need
    to add the implementations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`GameObject`类添加了两个新函数——一个用于我们创建自己的`new`版本，另一个用于我们的`delete`版本。然后，我们需要添加实现：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our case, we are just using the `ObjectPool` class'' functions to acquire
    and release our objects when needed, instead of just allocating memory all of
    the time. Then, we can modify the original implementation code as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只是使用`ObjectPool`类的函数在需要时获取和释放我们的对象，而不是一直分配内存。然后，我们可以按如下方式修改原始实现代码：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, don''t run the code just yet. If you remember, we call the `new` and `delete`
    operators inside of our `ObjectPool` class, so running the code now will cause
    a stack overflow error, because when `AquireObject` calls `new`, it will call
    the `GameObject` class'' version of `new`, which in turn calls the `AquireObject`
    function, and so on and so forth. To fix this, we''ll need to use the C version
    of allocating memory, the `malloc` and `free` functions, in order to get memory
    from the system:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请不要立即运行代码。如果你还记得，我们在`ObjectPool`类内部调用了`new`和`delete`运算符，所以现在运行代码将导致堆栈溢出错误，因为当`AquireObject`调用`new`时，它将调用`GameObject`类的`new`版本，然后它又调用`AquireObject`函数，如此循环往复。为了解决这个问题，我们需要使用C版本的内存分配，即`malloc`和`free`函数，从系统中获取内存：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we should be able to run and see if everything is working the way we intended!
    This version works fairly well as long as you want your users to still call `new`
    and `delete`; however, it gives you a performance boost over time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够运行并查看一切是否按预期工作！这个版本在用户仍然调用`new`和`delete`的情况下工作得相当好；然而，它随着时间的推移提供了性能提升。
- en: Building the object pool for Mach5
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Mach5构建对象池
- en: Now that we've seen an object pool in action, let's next learn how we can integrate
    the Object Pool pattern into the Mach5 game engine. Since we are creating a shooter
    game, one of the things that we spawn a lot during gameplay are the laser bullets
    from our ship, which makes it perfect for using object pool functionality. And
    unlike the previous examples, we'll see a version of the object pool that will
    not need to use pointers to access the pool, and we'll not have to worry about
    the pool being created. To do this, we'll need to make some adjustments to the
    starter project. First, we are going to need to change how our bullets are destroyed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了对象池的实际应用，接下来让我们学习如何将对象池模式集成到Mach5游戏引擎中。由于我们正在创建一个射击游戏，在游戏过程中我们生成很多的是来自我们飞船的激光子弹，这使得使用对象池功能变得非常合适。与之前的示例不同，我们将看到一个不需要使用指针来访问池的对象池版本，我们也不必担心池的创建。为了做到这一点，我们需要对起始项目做一些调整。首先，我们需要改变子弹的销毁方式。
- en: 'If you go into the `Bullet.ini` file located at `Mach5-master\EngineTest\EngineTest\ArcheTypes`,
    you''ll see the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入位于`Mach5-master\EngineTest\EngineTest\ArcheTypes`的`Bullet.ini`文件，你会看到以下内容：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Go in and remove `OutsideViewKillComponent` and replace it with `BulletComponent`.
    We are replacing `OutsideViewKillComponent` because when it leaves the screen,
    it will set the object's `isDead` property to `true`, which will call `delete`
    on it and remove it from the world. We are actually going to take care of this
    ourselves, so let's replace this with our own behavior, which we will write inside
    of the `BulletComponent` script that we will write later on in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进入并移除`OutsideViewKillComponent`，并用`BulletComponent`替换它。我们替换`OutsideViewKillComponent`是因为当它离开屏幕时，它会将对象的`isDead`属性设置为`true`，这将调用它上面的`delete`并从世界中移除它。我们实际上将自行处理这个问题，所以让我们用我们自己的行为来替换它，这个行为我们将在这个章节稍后编写的`BulletComponent`脚本中实现。
- en: Next, we will want to create a new place for our `ObjectPool` so, with that
    in mind, go to the Solution Explorer tab and then right-click on the Core/Singletons
    folder and select New Filter. Once you create one, name it `ObjectPool`. From
    there, right-click on the newly created folder and select New Item.... Then, from
    the menu select the Header File (.h) option and give it a name of `M5ObjectPool.h`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望为我们的`ObjectPool`创建一个新的位置，因此，考虑到这一点，转到解决方案资源管理器选项卡，然后右键单击Core/Singletons文件夹，并选择新建过滤器。创建一个后，将其命名为`ObjectPool`。从那里，右键单击新创建的文件夹，并选择新建项...然后从菜单中选择头文件(.h)选项，并将其命名为`M5ObjectPool.h`。
- en: 'In the `.h` file, we''ll put in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.h`文件中，我们将放入以下代码：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You'll notice that the class is very similar to what we've done in the past
    but, instead of using the `GameObject` class, we are going to use the Mach5 engine's
    `M5Object` class. We've also templatized the class to make it so that this will
    work with any kind of object archetype that exists (including our bullet, which
    is represented by `AT_Bullet`). I've also added a new variable called `available`,
    which is a **deque** (pronounced **deck**), which stands for a double-ended queue.
    This variable will contain all of the objects that both exist and are unused,
    so we can easily tell if we have any objects that we can use or if we need to
    create a new one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个类与我们过去所做的工作非常相似，但我们不是使用`GameObject`类，而是使用Mach5引擎的`M5Object`类。我们还模板化了这个类，使其能够与任何存在的对象原型一起工作（包括我们的子弹，它由`AT_Bullet`表示）。我还添加了一个新的变量`available`，它是一个**deque**（发音为**deck**），代表双端队列。这个变量将包含所有存在且未使用的对象，这样我们就可以轻松地判断是否有可用的对象，或者是否需要创建一个新的对象。
- en: If you want to learn more about the deque class, check out [http://www.cplusplus.com/reference/deque/deque/](http://www.cplusplus.com/reference/deque/deque/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于deque类的信息，请查看[http://www.cplusplus.com/reference/deque/deque/](http://www.cplusplus.com/reference/deque/deque/)。
- en: 'We''ll also want to create an `M5ObjectPool.cpp` file as well. In the `.cpp`,
    we''ll write the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望创建一个`M5ObjectPool.cpp`文件。在`.cpp`中，我们将写入以下代码：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this instance, we are first going to check if we have any objects inside
    of the available list. If none exist we will spawn a new object, making use of
    the `M5ObjectManager` class'' `CreateObject` function. We then add it to the pool
    as it is an object in our object pool, but we do not make it available as it''s
    going to be used upon being acquired:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先会检查是否有任何对象在可用列表中。如果没有，我们将创建一个新的对象，利用`M5ObjectManager`类的`CreateObject`函数。然后，我们将其添加到池中，因为它是我们对象池中的一个对象，但我们不会使其可用，因为它在被获取后将会被使用：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the `ReleaseObject` function marks an object as being available
    for reuse. But, we want to do some error checking to make sure that the function
    is being used properly and isn't being provided with an invalid object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ReleaseObject`函数将一个对象标记为可重复使用。但是，我们想要进行一些错误检查，以确保函数被正确使用，并且没有提供无效的对象。
- en: 'First, the code makes sure that the object is the same type as the object pool''s
    and that it is actually located inside the pool somewhere. This ensures that we
    will only be adding objects that are valid into our available deque. If we know
    the object is valid, we then look through the objects we already have in the deque
    and make sure that the object hasn''t already been added before. If it hasn''t,
    we then add it into the available deque:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码确保对象与对象池的类型相同，并且实际上位于池中的某个位置。这确保了我们只会将有效的对象添加到我们的可用deque中。如果我们知道对象是有效的，那么我们就会查看deque中已有的对象，并确保该对象尚未被添加。如果没有，我们将其添加到可用deque中：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `ClearPool` function, we just go through every object in the pool and
    destroy that game object. Then, we clear out the available list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ClearPool`函数中，我们只是遍历池中的每一个对象，并销毁那个游戏对象。然后，我们清空可用列表：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we need to declare the pool and available objects so they can be created
    in the future.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要声明池和可用对象，以便将来可以创建它们。
- en: Now that we have this base functionality, we need to return these objects back
    to our available pool. To do this, we'll need to add the `BulletComponent` component
    we mentioned previously. Since this component is exclusive to our game, let's
    move over to the `SpaceShooter`/`Components` filter and create a new filter called
    `BulletComp`. From there, create two new files, `BulletComponent.h` and `BulletComponent.cpp`,
    making sure the location is set to the `Mach5-master\EngineTest\EngineTest\Source\`
    folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个基本功能，我们需要将这些对象返回到我们的可用池中。为此，我们需要添加之前提到的`BulletComponent`组件。由于这个组件仅属于我们的游戏，让我们转到`SpaceShooter`/`Components`过滤器，创建一个新的过滤器，称为`BulletComp`。从那里，创建两个新的文件，`BulletComponent.h`和`BulletComponent.cpp`，确保位置设置为`Mach5-master\EngineTest\EngineTest\Source\`文件夹。
- en: 'In the `.h` file, put in the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.h`文件中，放入以下代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, inside of the `.cpp` file, use the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`.cpp`文件中，使用以下代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save your files. This will make it so that if the object has a bullet component,
    it''ll be returned to the list; but we have to first make our objects. Go into
    the `PlayerInputComponent.cpp` file and update the section of code for creating
    bullets in the `Update` function, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的文件。这样，如果对象有一个子弹组件，它将被返回到列表中；但我们必须首先制作我们的对象。进入`PlayerInputComponent.cpp`文件，并更新`Update`函数中创建子弹的代码部分，如下所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we've replaced the creation of `bullet1` and `bullet2` to use our
    `ObjectPool` class' `AcquireObject` function, instead of our `ObjectManager` class'
    version.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`bullet1`和`bullet2`的创建替换为使用我们的`ObjectPool`类的`AcquireObject`函数，而不是我们的`ObjectManager`类的版本。
- en: 'Now it will be difficult for us to see if we are using objects that have just
    been created or if they are things we are reusing. Let''s go back into `BulletComponent`
    and modify a property before we give it back to the object pool:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们很难看出我们是在使用刚刚创建的对象，还是正在重用的对象。在我们将其放回对象池之前，让我们回到`BulletComponent`并修改一个属性：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we can go ahead and save our scripts and run our game!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存我们的脚本并运行我们的游戏！
- en: '![](img/00050.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00050.jpeg)'
- en: 'You''ll notice that, at the beginning of play, the objects have a scale of
    `2.5, 2.5`. However, once some objects go off the screen, you''ll see something
    similar to the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在游戏开始时，对象的缩放比例为`2.5, 2.5`。然而，一旦一些对象离开屏幕，你会看到以下类似的截图：
- en: '![](img/00051.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00051.jpeg)'
- en: When we shoot the new bullets, they have been scaled down! With this, we know
    that our pool is working correctly, and that we are reusing the objects we've
    made before!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们射击新子弹时，它们已经被缩小了！有了这个，我们知道我们的池子正在正常工作，并且我们正在重用我们之前创建的对象！
- en: Issues with object pools
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池的问题
- en: Now, as great as object pools are, we should take some time to talk about times
    when you would not want to use object pools, and the alternatives out there.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管对象池很棒，但我们应该花点时间讨论你不想使用对象池的情况，以及可供选择的替代方案。
- en: First of all, you need to remember that when you are using a memory manager,
    you are telling the computer that you are smarter than them and that you know
    how the data should be handled. This is more power than other languages tend to
    give you, and using Uncle Ben's famous line, "*with great power comes great responsibility"* as
    we mentioned previously in this book in [Chapter 2](part0047.html#1CQAE0-04600e4b10ea45a2839ef4fc3675aeb7), *One
    Instance to Rule Them All - Singletons*. When using an object pool, you typically
    want to use it when objects only have a limited lifetime and a lot of them will
    be created, but not all at the same time. If at one point in time you'll have
    10,000 on the screen, but the rest of the game you'll have 30 max, that 9,970
    other objects' worth of memory will just be standing there waiting for you in
    the unlikely event that you want to use it again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要记住，当你使用内存管理器时，你是在告诉计算机你比它们聪明，你知道数据应该如何处理。这比其他语言通常给你的权力要大，正如我们在本书第2章[一个实例统治一切
    - 单例](part0047.html#1CQAE0-04600e4b10ea45a2839ef4fc3675aeb7)中提到的，使用Uncle Ben的名言，“*能力越大，责任越大*”。当使用对象池时，你通常希望它在对象只有有限的生命周期并且会创建很多对象，但不是同时创建时使用。如果在某个时刻你将在屏幕上有10,000个对象，但游戏的其他部分你最多只有30个，那么那9,970个其他对象的内存将只是在那里等待，以防万一你想再次使用它。
- en: An alternative method of handling a lot of objects at once is through a circular
    linked list, in which the last element connects to the first. This will guarantee
    that you'll never create more things than you have allocated memory for. If you
    happen to go all the way around you'll just be replacing the oldest one and, if
    you have so many things on the screen at once, users will not notice the oldest
    one being removed. This can be useful for things such as particle systems which
    we will be talking about in [Chapter 10](part0179.html#5AMKM0-04600e4b10ea45a2839ef4fc3675aeb7), *Sharing
    Objects with the Flyweight Pattern*. If you're spawning many particles, people
    probably will not notice the game replacing the oldest particles with new ones.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同时处理大量对象的一种替代方法是使用循环链表，其中最后一个元素连接到第一个。这将保证你永远不会创建比你分配的内存更多的东西。如果你恰好绕了一圈，你只是在替换最旧的元素，而且如果你一次在屏幕上有这么多东西，用户不会注意到最旧的元素被移除。这对于像粒子系统这样的东西很有用，我们将在第10章[共享对象与享元模式](part0179.html#5AMKM0-04600e4b10ea45a2839ef4fc3675aeb7)中讨论。如果你在生成许多粒子，人们可能不会注意到游戏在用新粒子替换最旧的粒子。
- en: For more information on circular linked lists, check out [https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm](https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于循环链表的信息，请查看[https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm](https://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm)。
- en: We were also using a type of object pool that allocated one element at a time.
    Alternatively, you could allocate memory for a large number of them at a time
    to ensure that you'll always have that memory reserved. While it's not needed
    in this case, it's definitely something to use for large classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一种类型的对象池，每次只分配一个元素。或者，你也可以一次性为大量元素分配内存，以确保你始终有预留的内存。虽然在这个情况下并不需要，但确实是在处理大型类时值得使用的方法。
- en: While the code samples listed are in C#, Michal Warkocz lists some very good
    examples of why an object pool may be a bad choice to use here: [https://blog.goyello.com/2015/03/24/how-to-fool-garbage-collector/](https://blog.goyello.com/2015/03/24/how-to-fool-garbage-collector/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列出的代码示例是C#编写的，但Michal Warkocz列出了一些非常好的例子，说明了为什么对象池可能不是这里的好选择：[https://blog.goyello.com/2015/03/24/how-to-fool-garbage-collector/](https://blog.goyello.com/2015/03/24/how-to-fool-garbage-collector/)。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have used object pools to reduce system resources and user
    frustration by storing and reusing objects instead of creating and removing them.
    After spending this time polishing your work, you'll probably want to spend time
    modifying the UI of your game, which is what we will be talking about in the next
    chapter!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过存储和重用对象而不是创建和删除对象，使用对象池来减少系统资源和用户的不满。在花时间润色你的工作之后，你可能想要花时间修改你游戏的用户界面，这正是我们将在下一章中讨论的内容！
