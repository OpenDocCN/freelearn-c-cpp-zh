- en: 6\. Entity Framework with SQL Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用SQL Server的实体框架
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the basics of database design, storage, and processing
    using SQL and C#. You will learn about the Entity Framework (EF), and Object-Relational
    Mapper (ORM) and use them to convert database results into C# objects. You will
    then learn about the main performance pitfalls of SQL and EF and how to find and
    fix them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍使用SQL和C#进行数据库设计、存储和处理的基础知识。您将了解Entity Framework（EF）和对象关系映射器（ORM），并使用它们将数据库结果转换为C#对象。然后，您将了解SQL和EF的主要性能陷阱以及如何找到并修复它们。
- en: Finally, you will delve into enterprise practices of working with databases
    by looking at Repository and Command Query Responsibility Segregation (CQRS) patterns
    and also by setting up a local database for development and testing. By the end
    of this chapter, you will be able to create and design your own database using
    PostgreSQL Server and use EF to hook a C# backend to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将通过查看存储库和命令查询责任分离（CQRS）模式以及设置本地数据库进行开发和测试，深入了解与数据库一起工作的企业实践。在本章结束时，您将能够使用PostgreSQL
    Server创建和设计自己的数据库，并使用EF将C#后端连接到它。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: There are multiple types of databases, but the most common one is relational,
    and the language for managing relational databases is SQL. SQL is optimized for
    data persistence. However, executing business rules in it is inefficient. Therefore,
    before consumption, data is often fetched in application memory and transformed
    into objects. This transformation is called object-relational mapping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的数据库，但最常见的是关系型数据库，管理关系型数据库的语言是SQL。SQL被优化用于数据持久性。然而，在其中执行业务规则是低效的。因此，在使用之前，数据通常会在应用程序内存中获取并转换为对象。这种转换称为对象关系映射。
- en: 'There is a lot of complexity in mapping database records to objects. However,
    this complexity is mitigated by Object-Relational Mapper (ORM). Some ORMs only
    do mapping (called micro-ORMs), but many popular ORMs also abstract away database
    language and allow you to use the same language to execute business rules and
    process data:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库记录映射到对象中存在很多复杂性。但是，对象关系映射器（ORM）可以减轻这种复杂性。一些ORM只进行映射（称为微型ORM），但许多流行的ORM还可以抽象数据库语言，并允许您使用相同的语言执行业务规则和处理数据：
- en: '![Figure 6.1: How an ORM works in translating C# to SQL and back'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：ORM如何在C#和SQL之间进行翻译和转换'
- en: '](img/B16835_06_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_01.jpg)'
- en: 'Figure 6.1: How an ORM works in translating C# to SQL and back'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：ORM如何在C#和SQL之间进行翻译和转换
- en: The focus of this chapter will be on Entity Framework (EF)—the most popular
    ORM in .NET. In the practical sections of this chapter, you will use it to rapidly
    prototype relational databases, and then make queries against them. It's worth
    mentioning that internally, whenever databases are involved, you are interacting
    with the ADO.NET part of .NET.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将放在Entity Framework（EF）上——这是.NET中最流行的ORM。在本章的实践部分中，您将使用它快速原型化关系数据库，然后对其进行查询。值得一提的是，在内部，每当涉及到数据库时，您都在与.NET的ADO.NET部分交互。
- en: 'Before proceeding, however, it''s recommended that you install the latest version
    of PostgreSQL with PostgreSQL Server found here: [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).
    You can find the installation instructions for this in the *Preface*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续之前，建议您安装最新版本的PostgreSQL，并在此处找到PostgreSQL Server：[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)。您可以在*前言*中找到有关此的安装说明。
- en: This chapter will use the `AdventureWorks` database, which is an adaptation
    of a popular example database that Microsoft often uses; it will be defined in
    detail in the following section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用`AdventureWorks`数据库，这是微软经常使用的一个常见示例数据库的改编；它将在以下部分详细定义。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For those who are interested in learning the basics of databases and how to
    work with PostgreSQL, a reference chapter has been included in the GitHub repository
    of this book. You can access it at [https://packt.link/sezEm](https://packt.link/sezEm).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有兴趣学习数据库基础知识以及如何使用PostgreSQL的人，本书的GitHub存储库中已经包含了一个参考章节。您可以在[https://packt.link/sezEm](https://packt.link/sezEm)上访问它。
- en: Creating a Demo Database Before You Start
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开始之前创建演示数据库
- en: You will use `Adventureworks` as an example because it is a common database
    used by Microsoft and has just enough complexity to learn about databases topic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`Adventureworks`作为示例，因为它是微软经常使用的常见数据库，并且具有足够的复杂性来学习数据库主题。
- en: 'Perform the following steps to do so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open the command line and make a directory where you will call `AdventureWorks`
    database and move to that directory:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行并创建一个目录，您将在其中调用`AdventureWorks`数据库，并移动到该目录：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replace `<change-with-your-download-path-to-The-C-Sharp-Workshop>` with a directory
    where you downloaded the The-C-Sharp-Workshop repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<change-with-your-download-path-to-The-C-Sharp-Workshop>`替换为您下载The-C-Sharp-Workshop存储库的目录。
- en: 'Create an empty `Adventureworks` database by running the following command
    in the console:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在控制台中运行以下命令创建一个空的`Adventureworks`数据库：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create tables and populate them with data using the installation script.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用安装脚本创建表并填充数据。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The installation script is found at [https://packt.link/0SHd5](https://packt.link/0SHd5).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装脚本位于[https://packt.link/0SHd5](https://packt.link/0SHd5)。
- en: 'Run the following command pointing to the installation script:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，指向安装脚本：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Modeling Databases Using EF
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EF建模数据库
- en: Working with a database from any other language comes with an interesting problem
    and that is, how do you convert table rows into C# objects? In C#, communicating
    with a database requires a database connection and SQL statements. Executing the
    statements will bring up a results reader, which is very similar to a table. Using
    the results reader dictionary, you can go through the results and map them into
    a new object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何其他语言连接到数据库都会带来一个有趣的问题，那就是，你如何将表行转换为C#对象？在C#中，与数据库通信需要一个数据库连接和SQL语句。执行这些语句将带来一个结果读取器，它非常类似于一个表。使用结果读取器字典，你可以浏览结果并将它们映射到一个新的对象中。
- en: 'The code for this would look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码看起来像下面这样：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don't worry about the details of this code yet; it will be broken down soon.
    For now, it is enough to know that the preceding snippet returns all rows from
    the `factory.product` table and maps the results to a list named `products`. Using
    this approach may be okay when working with a single table, but when joins are
    involved, it becomes tricky. Mapping from one type to another, as has been done
    here, is very granular and can become tedious. In order to run this example, go
    to [https://packt.link/2oxXn](https://packt.link/2oxXn) and comment all lines
    within `static void Main(string[] args)` body except `Examples.TalkingWithDb.Raw.Demo.Run();`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心这段代码的细节；它很快就会被分解。现在，知道前面的片段返回`factory.product`表中的所有行，并将结果映射到一个名为`products`的列表就足够了。当处理单个表时，使用这种方法可能还可以，但是当涉及到连接时，情况就变得棘手了。像这里所做的那样，从一种类型映射到另一种类型是非常细粒度的，可能会变得乏味。要运行这个示例，转到[https://packt.link/2oxXn](https://packt.link/2oxXn)，并在`static
    void Main(string[] args)`主体中注释掉所有行，除了`Examples.TalkingWithDb.Raw.Demo.Run();`。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/7uIJq](https://packt.link/7uIJq).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/7uIJq](https://packt.link/7uIJq)找到用于这个示例的代码。
- en: 'Another factor to consider is that when you deal with SQL from the client side,
    you should be careful. You should not assume that a user will use your program
    as intended. So, you should therefore add validation on both the client and server
    sides. For example, if a textbox requires a user ID to be entered, the client
    could enter `105` and get the details of the user of that ID. The query for this
    would be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是，当你在客户端处理SQL时，你应该小心。你不应该假设用户会按照预期使用你的程序。因此，你应该在客户端和服务器端都添加验证。例如，如果一个文本框需要输入用户ID，客户端可以输入`105`并获取该ID的用户的详细信息。这个查询如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A user could also enter `105 or 1 = 1`, which is always true and thus this
    query returns all users:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也可以输入`105 or 1 = 1`，这总是为真，因此这个查询返回所有用户：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At best, this breaks your application. At worst, it leaks all the data. This
    kind of exploit is called SQL injection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的情况是，这会破坏你的应用程序。最坏的情况是，它会泄漏所有数据。这种利用被称为SQL注入。
- en: A simple yet effective way to solve the problem of accepting any kind of user
    input is to use an ORM as it allows you to convert database tables into C# objects
    and vice versa. In the .NET ecosystem, the three ORMs most commonly used are EF,
    Dapper, and NHibernate. Dapper is effective when top performance is needed because
    working with it involves executing raw SQL statements. Such ORMs are called micro-ORMs
    because they just do the mapping and nothing else.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解决接受任何类型用户输入问题的一个简单而有效的方法是使用ORM，因为它允许你将数据库表转换为C#对象，反之亦然。在.NET生态系统中，最常用的三个ORM是EF、Dapper和NHibernate。当需要最佳性能时，Dapper是有效的，因为使用它需要执行原始的SQL语句。这样的ORM被称为微ORM，因为它们只做映射，没有其他功能。
- en: NHibernate originated with the Java ecosystem and was one of the first ORMs
    in .NET. NHibernate, just like EF, solves a bigger problem than micro-ORMs by
    trying to abstract away SQL and database-related low-level details. Using a full-fledged
    ORM, such as EF or Nhibernate, often means that you don't need to write SQL to
    communicate with a database. In fact, the two ORMs allow you to generate complex
    databases out of the objects you have. The opposite is also possible (that is,
    you can generate objects out of databases you already have).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: NHibernate起源于Java生态系统，并且是.NET中最早的ORM之一。NHibernate和EF一样，通过尝试抽象SQL和与数据库相关的低级细节来解决比微ORM更大的问题。使用完整的ORM，比如EF或Nhibernate，通常意味着你不需要编写SQL来与数据库通信。事实上，这两个ORM允许你根据你拥有的对象生成复杂的数据库。相反的也是可能的（即，你可以根据你已经拥有的数据库生成对象）。
- en: In the next sections, the focus will be on EF. Why not Dapper? Because Dapper
    requires knowledge of SQL and you want to make use of a simplified syntax. Why
    not NHibernate? Because NHibernate is old, it has too many configuration options,
    none of which are useful for getting started with ORMs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，重点将放在EF上。为什么不是Dapper？因为Dapper需要对SQL有所了解，而你想要使用简化的语法。为什么不是NHibernate？因为NHibernate太老了，它有太多的配置选项，没有一个对于开始使用ORM是有用的。
- en: Before delving into EF, you first need to connect to a database. So, proceed
    to learn about connection string and security.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究EF之前，你首先需要连接到一个数据库。因此，继续学习连接字符串和安全性。
- en: Connection String and Security
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串和安全性
- en: 'No matter what language you use, connecting to a database will always involve
    using a connection string. It contains three important parts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么语言，连接到数据库总是需要使用连接字符串。它包含三个重要部分：
- en: IP or a server name.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP或服务器名称。
- en: The name of the database you would like to connect to.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要连接的数据库的名称。
- en: Some sort of security credentials (or none, if using a trusted connection only
    used for databases on the same network).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种安全凭证（或者没有，如果只使用受信任的连接用于同一网络上的数据库）。
- en: 'To connect to the local database you were previously working on in the *Modeling
    Databases Using EF* section (`new NpgsqlConnection(ConnectionString))`, you could
    use the following connection string (the password has been obfuscated for security
    reasons):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到之前在*使用EF建模数据库*部分中工作的本地数据库（`new NpgsqlConnection(ConnectionString)`），你可以使用以下连接字符串（出于安全原因，密码已被隐藏）：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The connection string will be used when you will add the environment variables
    in your OS. This is detailed ahead. Different databases use different connections.
    For example, the following databases use these connections:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在操作系统中添加环境变量时，将使用连接字符串。这将在后面详细说明。不同的数据库使用不同的连接。例如，以下数据库使用这些连接：
- en: 'SQL Server: `SqlConnection`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server：`SqlConnection`
- en: 'PostgreSQL: `NpgsqlConnection`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL：`NpgsqlConnection`
- en: 'MySql: `MySqlConnection`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySql：`MySqlConnection`
- en: 'SQLite: `SqliteConnection`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite：`SqliteConnection`
- en: The connection object is the touching point between .NET and SQL database because
    it is only through it that you can communicate with a database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 连接对象是.NET和SQL数据库之间的接触点，因为只有通过它才能与数据库通信。
- en: 'Hardcoding a **connection string** comes with a few problems:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 硬编码**连接字符串**存在一些问题：
- en: To change a connection string, the program must be recompiled.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改连接字符串，必须重新编译程序。
- en: It's not secure. The connection string can be viewed by everyone who knows how
    to decompile code (or worse, is publicly visible if it's an open-source project).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不安全。连接字符串可以被知道如何反编译代码的每个人查看（或更糟糕的是，如果它是一个开源项目，它可能是公开可见的）。
- en: 'Therefore, a connection string is usually stored in a configuration file. This
    does not solve the problem of sensitive parts of a connection string being stored.
    To fix that, often, either the whole string or a part of it is replaced during
    the application''s deployment. There are three main ways to securely store and
    retrieve application secrets:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连接字符串通常存储在配置文件中。这并不能解决存储连接字符串敏感部分的问题。为了解决这个问题，通常在应用程序部署期间，整个字符串或其中的一部分会被替换。有三种主要方法可以安全地存储和检索应用程序机密信息：
- en: 'Environment variables: These are variables unique to a system and can be accessed
    by any application on the same machine. This is the simplest secure approach and
    might not be safe in a production environment.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量：这些是系统特有的变量，可以被同一台机器上的任何应用程序访问。这是最简单的安全方法，但在生产环境中可能不安全。
- en: 'Secret Manager tool (available in both .NET and .NET Core applications): Similar
    to environment variables but more .NET specific, it will store all secrets on
    the local machine as well but in a file called `secrets.json`. This option, too,
    might not be safe in a production environment.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密管理器工具（在.NET和.NET Core应用程序中都可用）：类似于环境变量，但更具体于.NET，它也会将所有秘密存储在名为`secrets.json`的文件中。这个选项在生产环境中也可能不安全。
- en: 'Key vault: This is the most secure approach because, unlike the other two,
    it is not coupled with a specific environment. Key vaults store secrets in one
    centralized place; usually remotely. This approach is most commonly used for enterprise
    applications. In the context of Azure, Azure Key Vault is the best choice and
    is perfect for a production environment.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥保管库：这是最安全的方法，因为与其他两种方法不同，它不与特定环境耦合。密钥保管库将秘密存储在一个集中的地方；通常是远程的。这种方法最常用于企业应用程序。在Azure的上下文中，Azure密钥保管库是最佳选择，非常适合生产环境。
- en: In the following example, you'll try to securely store the connection string
    you made previously. You will use the simplest secure approach that is suitable
    for a development environment—that is, environment variables. This approach fits
    local development the best because the other two require third-party tools to
    set up and take much longer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您将尝试安全地存储先前创建的连接字符串。您将使用最简单的安全方法，适用于开发环境，即环境变量。这种方法最适合本地开发，因为其他两种方法需要第三方工具来设置，并且需要更长的时间。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you continue, make sure to go through *Exercise 1* of the *Reference
    Chapter*, *A Primer for Simple Databases and SQL*. It has the steps needed to
    create a new database with the needed tables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保阅读*参考章节*中的*练习1*。它包含创建具有所需表的新数据库所需的步骤。
- en: 'Adding an environment variable in your OS is just a matter of performing some
    simple steps. Perform the following steps in Windows to set the environment variables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的操作系统中添加环境变量只是执行一些简单步骤的问题。在Windows中执行以下步骤来设置环境变量：
- en: Go to `Control Panel`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“控制面板”。
- en: Click `System & Security` and choose `System`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“系统和安全”，然后选择“系统”。
- en: Type `Environmental Variables` in the search box.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中键入“环境变量”。
- en: Then choose `Edit Environment Variables for your account` from the list displayed.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从显示的列表中选择“编辑您的帐户的环境变量”。
- en: Inside the `Environment Variables` window, click `New` under the `System Variables`
    window.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“环境变量”窗口中，单击“系统变量”窗口下的“新建”。
- en: Inside the New System variable window, type `GlobalFactory` beside the `Variable
    name`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新建系统变量”窗口中，在“变量名称”旁边键入“GlobalFactory”。
- en: 'Beside `Variable value`, paste the following:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“变量值”旁边，粘贴以下内容：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next click `OK` on all windows to set your environment variables.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在所有窗口上单击“确定”以设置您的环境变量。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here the password would carry your database superuser password which you entered
    while creating the `globalfactory2021` database in PostgreSQL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的密码将携带您在创建`globalfactory2021`数据库时输入的数据库超级用户密码。
- en: 'Mac: From the command line, find `bash-profile: ~/.bash-profile f`. Open it
    using any text editor, then at the end of the file, add `export GlobalFactory=''Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021''`.
    Lastly, run `source ~/.bash-profile`, which will update the environment variables.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mac：从命令行中找到`bash-profile: ~/.bash-profile f`。使用任何文本编辑器打开它，然后在文件末尾添加`export
    GlobalFactory=''Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021''`。最后，运行`source
    ~/.bash-profile`，这将更新环境变量。'
- en: 'Linux: From the command line, run this: `export GlobalFactory=''Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021''`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux：从命令行运行：`export GlobalFactory='Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021'`。
- en: 'Getting the environment variable instead of an in-memory one can now be done
    by placing a property in `Program.cs`, at the top of the class, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过在`Program.cs`中的类顶部放置一个属性来获取环境变量，如下所示：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line returns the value of the `GlobalFactory` environment variable, configured
    for the local user. In the preceding snippet, you have added this line to `Program.cs`
    and made it static because that makes it easily accessible throughout the application.
    While in big applications, it is not a practice you would want to go for; however,
    for your purposes here, this is fine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此行返回为本地用户配置的`GlobalFactory`环境变量的值。在前面的代码片段中，您已将此行添加到`Program.cs`并将其设置为静态，因为这样可以在整个应用程序中轻松访问。在大型应用程序中，这不是您想要选择的做法；然而，在这里，这是可以的。
- en: Before you grasp models—the centerpiece of a program—you need to know about
    the major versions of EF.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握模型——程序的中心——之前，您需要了解EF的主要版本。
- en: Which One to Choose—EF or EF Core?
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择哪一个——EF还是EF Core？
- en: There are two major versions of EF—EF and EF Core. Both are widely used, but
    you should be aware of some factors before making the choice that fits your project's
    requirements the best. EF was first released in 2008\. At that time, there was
    no .NET Core and C# was for **Windows only** and strictly required .NET Framework.
    Currently, the latest major version of EF is 6 and it's likely that there won't
    be any other major version, because in 2016, along with .NET Core 1.0 came EF
    Core 1 (a rework of EF 6).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: EF有两个主要版本——EF和EF Core。两者都被广泛使用，但在选择最适合项目要求的选择之前，您应该了解一些因素。EF首次发布于2008年。那时还没有.NET
    Core，C#仅适用于**Windows**，严格要求.NET Framework。目前，EF的最新主要版本是6，很可能不会有其他主要版本，因为2016年，随着.NET
    Core 1.0的推出，EF Core 1（对EF 6的重新设计）也随之而来。
- en: EF Core was initially named EF 7\. However, it was a complete rewrite of EF
    6 and therefore was soon renamed EF Core 1.0\. EF works only on .NET and is for
    Windows only, whereas .NET Core works only on .NET Core and is multi-platform.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core最初被命名为EF 7。然而，它是EF 6的完全重写，因此很快被重新命名为EF Core 1.0。EF仅适用于.NET，仅适用于Windows，而.NET
    Core仅适用于.NET Core，并且是多平台的。
- en: Feature-wise, both frameworks are similar and are still being developed. However,
    the focus these days is on EF Core because the future of C# is associated with
    .NET 6, which is a multi-platform framework. At the time of writing this book,
    EF 6 has a richer set of features. However, EF Core is quickly catching up and
    is likely to soon be ahead. If your project's specifications do not require working
    with .NET Framework, it is preferable to stick with EF Core.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能上，这两个框架都很相似，并且仍在不断发展。然而，如今的重点是EF Core，因为C#的未来与.NET 6相关联，这是一个多平台框架。在撰写本书时，EF
    6具有更丰富的功能。然而，EF Core正在迅速赶上，并很可能很快就会领先。如果您的项目规格不要求使用.NET Framework，最好坚持使用EF Core。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the latest list of differences between the two, please refer to a comparison
    by Microsoft here: [https://docs.microsoft.com/en-us/ef/efcore-and-ef6/](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关两者之间的最新差异列表，请参阅Microsoft的比较：[https://docs.microsoft.com/en-us/ef/efcore-and-ef6/](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/)。
- en: 'Before you proceed, install the EF Core NuGet package so that you get access
    to the EF Core API. With the project open in Visual Studio Code (VS Code), run
    the following line in the terminal:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，安装EF Core NuGet包，以便访问EF Core API。在Visual Studio Code（VS Code）中打开项目后，在终端中运行以下命令：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By itself, `EntityFrameworkCore` is just a tool to abstract away database structures.
    To connect it with a specific database provider, you will need another package.
    Here you are using PostgreSQL. Therefore, the package you will install is `Npgsql.EntityFrameworkCore.PostgreSQL`.
    In order to install it, from the VS Code console, run the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用`EntityFrameworkCore`只是一个抽象数据库结构的工具。要将其与特定的数据库提供程序连接，您将需要另一个包。在这里，您正在使用PostgreSQL。因此，您将安装的包是`Npgsql.EntityFrameworkCore.PostgreSQL`。为了安装它，请从VS
    Code控制台运行以下命令：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You are now aware of the two versions of EF and how they work with .NET Framework and
    .NET. The next section will delve into the models which are the heart of a program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了EF的两个版本以及它们如何与.NET Framework和.NET一起使用。下一节将深入探讨模型，这是程序的核心。
- en: Model
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: A class designed to represent a business object is called a model. It always
    has data managed by properties or methods. Models are the centerpiece of a program.
    They don't depend on anything; other parts of a program point to them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示业务对象的类称为模型。它始终具有由属性或方法管理的数据。模型是程序的中心。它们不依赖于任何东西；程序的其他部分指向它们。
- en: An object to which an ORM maps data tables is called an entity. In simple applications,
    an entity and a model are the same class. In complex applications, a change to
    a database is a common thing. That means that entities change often, and if you
    do not have a separate class for a model, your model would be impacted as well.
    Business logic should be isolated from database changes, and it is therefore recommended
    to have two classes—one for an entity and one for a model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ORM映射数据表的对象称为实体。在简单的应用程序中，实体和模型是相同的类。在复杂的应用程序中，对数据库的更改是常见的事情。这意味着实体经常发生变化，如果没有一个单独的类用于模型，您的模型也会受到影响。业务逻辑应该与数据库更改隔离，因此建议有两个类——一个用于实体，一个用于模型。
- en: Before you continue with the next section, have a quick look at the `factory.product`
    and `factory.manufacturer` tables. One manufacturer makes many products. The following
    Entity Relationship (ER) diagram illustrates this relationship in *Figure 6.2*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一节之前，快速查看`factory.product`和`factory.manufacturer`表。一个制造商生产多种产品。下面的实体关系（ER）图在*图6.2*中说明了这种关系。
- en: '![Figure 6.2: ER diagram of products and manufacturers'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：产品和制造商的ER图'
- en: '](img/B16835_06_02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_02.jpg)'
- en: 'Figure 6.2: ER diagram of products and manufacturers'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：产品和制造商的ER图
- en: 'An entity, ideally, should mirror table columns. You can mirror columns through
    properties. For example, a `factory.product` table has `id`, `name`, `price`,
    and `manufacturerId`. An object that maps to that would look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个实体应该反映表列。您可以通过属性来反映列。例如，`factory.product`表具有`id`、`name`、`price`和`manufacturerId`。映射到该表的对象将如下所示：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You know that only the price of a product can change; the rest of the properties
    would not. However, in the preceding snippet, a setter has still been written
    for every property. This is because entities created through an ORM always need
    to have all properties with setters, or else it might not set the value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道产品的唯一变化是价格；其余的属性不会变。然而，在前面的代码片段中，为每个属性仍然编写了一个setter。这是因为通过ORM创建的实体始终需要具有所有属性的setter，否则它可能不会设置值。
- en: 'An entity should be designed to match a table structure, but it does not always
    have to be that way. For example, if the `Id` property were renamed to `PrimaryKey`,
    you could still use EF the same way by using a special data annotation `[Key]`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实体应该被设计成匹配表结构，但并不总是必须这样。例如，如果`Id`属性被重命名为`PrimaryKey`，你仍然可以通过使用特殊的数据注释`[Key]`来以相同的方式使用EF：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Data Annotation is an attribute that adds metadata to a property. You can use
    it to provide a different name, have a constraint column as a key, add the minimum
    and maximum lengths for fields, add precision, declare a field as mandatory, and
    more. On their own, data annotations don't do anything. They don't add logic to
    a model. Some other components will consume annotated objects, which will involve
    reading their attributes and performing actions based on that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据注释是为属性添加元数据的属性。你可以使用它来提供不同的名称，将约束列作为键，为字段添加最小和最大长度，添加精度，声明字段为必填项等。单独使用数据注释不会做任何事情。它们不会向模型添加逻辑。一些其他组件将消耗带注释的对象，这将涉及读取它们的属性并根据此执行操作。
- en: 'Your model (illustrating the ER diagram from *Figure 6.2*) is almost complete,
    but there are a few problems to be addressed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模型（从*图6.2*中说明的ER图）几乎完成了，但还有一些问题需要解决：
- en: First, the table-model mapping is missing a schema (`factory`, in this case),
    and so you need to specify it explicitly using a `Table` attribute.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，表-模型映射缺少模式（在这种情况下是`factory`），因此你需要使用`Table`属性明确指定它。
- en: Second, by default if you wanted to also retrieve a `manufacturer`, you would
    need another query. You can fix this by adding a navigational property that refers
    to the manufacturer. But why should you use a navigational property? If there
    were only an ID, you would need a separate query to get the related entity. However,
    using navigational properties, you can use eager loading and get two or more entities
    at once.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，默认情况下，如果你想检索`manufacturer`，你需要另一个查询。你可以通过添加一个指向制造商的导航属性来解决这个问题。但为什么要使用导航属性？如果只有一个ID，你需要一个单独的查询来获取相关的实体。然而，使用导航属性，你可以使用急切加载并一次获取两个或更多实体。
- en: 'The following code snippet will show you how to create a `Manufacturer` class
    and fix these issues for both models:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将向你展示如何为`Manufacturer`类创建一个类，并为这两个模型解决这些问题：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the new `List<Product>();` part. It is needed so that if a table does not
    yet have products, the code would still function when you try to add a new product
    without throwing `NullReferenceException`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的`List<Product>();`部分。这是必需的，以便如果表尚未有产品，当您尝试添加新产品时，代码仍然可以正常运行，而不会抛出`NullReferenceException`。
- en: 'In the following snippet of code, a model is created for a product table:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，为产品表创建了一个模型：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The two models are complete for mapping to tables from your database. You did
    not replace an ID property with a navigational property; both are present. If
    you did not do this, it would require the parent entity (`Manufacturer`) to be
    fetched before you could do anything with a product. With this approach, you can
    work with a product in isolation from the manufacturer. All you need is an ID
    link.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模型都已经完整地映射到了你的数据库中的表。你没有用导航属性替换ID属性；两者都存在。如果你没有这样做，那么在你对产品进行任何操作之前，都需要先获取父实体（`Manufacturer`）。通过这种方法，你可以独立于制造商使用产品。你只需要一个ID链接。
- en: On top of the mentioned fixes, you made your navigational properties (`Manufacturer`
    and `Products`) virtual. This is needed to enable lazy loading for EF. Lazy loading
    means that there is no data loaded in a property until that property is referenced.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述修复之外，你还将你的导航属性（`Manufacturer`和`Products`）设为虚拟的。这是为了启用EF的延迟加载。延迟加载意味着在引用该属性之前，该属性中没有加载任何数据。
- en: Finally, it is worth mentioning that for manufacturer products, you used `ICollection`
    and not `IEnumerable` or other collections. This makes sense because EF will need
    to populate the collection when it retrieves and map the items. `List` or even
    `Set` could work, but when designing object-oriented code, you should focus on
    the highest abstraction you can depend on, in this case it is `ICollection`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，对于制造商产品，你使用了`ICollection`而不是`IEnumerable`或其他集合。这是有道理的，因为EF需要在检索和映射项目时填充集合。`List`甚至`Set`都可以工作，但在设计面向对象的代码时，你应该专注于你可以依赖的最高抽象，这种情况下就是`ICollection`。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gfgB1](https://packt.link/gfgB1).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/gfgB1](https://packt.link/gfgB1)找到此示例使用的代码。
- en: In order to run this example, go to [https://packt.link/2oxXn](https://packt.link/2oxXn)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `Examples.TalkingWithDb.Orm.Demo.Run();`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请转到[https://packt.link/2oxXn](https://packt.link/2oxXn)，并在`static void`
    `Main(string[] args)`主体中注释掉所有行，除了`Examples.TalkingWithDb.Orm.Demo.Run();`。
- en: You are now clear about the entity, models, entity relationship, data annotation,
    eager loading, and lazy loading. The next section will show you how to combine
    everything and communicate with a database through EF Core.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经清楚了实体、模型、实体关系、数据注释、急切加载和延迟加载。下一节将向你展示如何将所有内容结合起来，并通过EF Core与数据库通信。
- en: DbContext and DbSet
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DbContext和DbSet
- en: '`DbContext` is what EF uses as an abstraction to a database. A new database
    abstraction must be derived from the `DbContext` class and provide a way of connecting
    to a database. Just like a database contains one or more tables, `DbContext` contains
    one or more `DbSet` entities. For example, consider the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbContext`是EF用作数据库抽象的东西。新的数据库抽象必须从`DbContext`类派生，并提供连接到数据库的方法。就像数据库包含一个或多个表一样，`DbContext`包含一个或多个`DbSet`实体。例如，考虑以下代码：'
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, `FactoryDbContext` is an abstraction of the database that you created
    before, with two tables: `Products` and `Manufacturers`. The `OnConfiguring` method
    takes `DbContextOptionsBuilder`, which allows you to specify what database you
    want to connect to and how that connection is made. In this case, you are using
    PostgreSQL Server and specifying a database to connect to. Please note that in
    case there is an already configured database provider then you will not use `Npgsql`
    in the `if` statement i.e., the `if (!optionsBuilder.IsConfigured)` statement.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FactoryDbContext`是您之前创建的数据库的抽象，其中包含两个表：`Products`和`Manufacturers`。`OnConfiguring`方法使用`DbContextOptionsBuilder`，它允许您指定要连接到的数据库以及连接的方式。在这种情况下，您使用PostgreSQL
    Server并指定要连接的数据库。请注意，如果已经配置了数据库提供程序，那么您将不会在`if`语句中使用`Npgsql`，即`if (!optionsBuilder.IsConfigured)`语句。
- en: 'It is important to note that you should not completely depend on a specific
    database provider for two reasons:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，出于两个原因，您不应完全依赖于特定的数据库提供程序：
- en: Firstly, changing a database provider is easy; it is just a matter of using
    a different extension method on a builder.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，更改数据库提供程序很容易；只需在构建器上使用不同的扩展方法即可。
- en: Secondly, EF has an in-memory database provider, which is effective for testing.
    Alternatively, you could use SQLite as well as a lightweight database meant just
    for testing.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，EF具有内存数据库提供程序，用于测试非常有效。或者，您也可以使用SQLite，这是一个轻量级的数据库，专门用于测试。
- en: 'Currently, your database abstraction needs improvement because it only lets
    you communicate with the SQL Server database. Instead of hardcoding the options,
    you will inject them. Injecting allows you to configure an existing class differently,
    without modifying it. You do not need to change the models to be able to choose
    the database you want to connect to. You can specify which database you want to
    connect to by passing an `options` object through the `FactoryDbContext` constructor:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，您的数据库抽象需要改进，因为它只允许您与SQL Server数据库通信。您将注入而不是硬编码选项。注入允许您以不同的方式配置现有类，而无需修改它。您无需更改模型即可选择要连接的数据库。您可以通过通过`FactoryDbContext`构造函数传递`options`对象来指定要连接的数据库：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The default constructor is for the default provider, which will be used when
    no options are supplied. In this case, the context was designed to use PostgreSQL;
    therefore, you would add the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数是为默认提供程序而设计的，当没有提供选项时将使用该提供程序。在这种情况下，上下文被设计为使用PostgreSQL；因此，您将添加以下代码：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`DbContext` can be configured using `DbContextOptions`. In this example, you
    need to configure a database provider (PostgreSQL) and a connection string. Choose
    the provider using `DbContextOptionsBuilder`. The `UseNpgsql` is how you hook
    the PostgreSQL provider with your database context, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbContext`可以使用`DbContextOptions`进行配置。在此示例中，您需要配置数据库提供程序（PostgreSQL）和连接字符串。使用`DbContextOptionsBuilder`选择提供程序。`UseNpgsql`是将PostgreSQL提供程序与数据库上下文连接的方法，如下所示：'
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The full `DbContext` now looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`DbContext`现在如下所示：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to run this example, go to [https://packt.link/2oxXn](https://packt.link/2oxXn)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `Examples.TalkingWithDb.Orm.Demo.Run();`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请转到[https://packt.link/2oxXn](https://packt.link/2oxXn)，并在`static void`
    `Main(string[] args)`主体中注释所有行，除了`Examples.TalkingWithDb.Orm.Demo.Run();`。
- en: 'To get the products from the database you have made, you first connect to a
    database by initializing an instance of your `DbContext`. You then call a wanted
    `DbSet` from that context and send a call to a database by calling `ToList()`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要从您创建的数据库中获取产品，您首先通过初始化`DbContext`的实例来连接到数据库。然后，您从该上下文调用所需的`DbSet`，并通过调用`ToList()`向数据库发送调用：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, you create a `FactoryDbContext` (which creates a connection to
    the `GlobalFactory` database) and the `context.Products.ToList()` equates to a
    `SELECT * FROM Products` SQL statement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您创建了一个`FactoryDbContext`（它创建了与`GlobalFactory`数据库的连接），`context.Products.ToList()`相当于`SELECT
    * FROM Products`的SQL语句。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The two lines mentioned are not included within GitHub. They are trivial and
    are here only for illustrative purposes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的两行不包括在GitHub中。它们是微不足道的，仅用于举例说明。
- en: 'When you initialize a `DbContext`, you almost always create a connection to
    a database, and if not managed, you might eventually run out of connections inside
    a connection pool (a collection of available connections). `DbContext` is an unmanaged
    resource; it implements the `IDisposable` interface, and so it needs explicit
    cleanup. Here, you applied a C# feature—inline using—which disposes of the object
    after it leaves the scope it is at:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当您初始化`DbContext`时，几乎总是创建与数据库的连接，如果不加以管理，最终可能会耗尽连接池中的连接（可用连接的集合）。`DbContext`是一个未经管理的资源；它实现了`IDisposable`接口，因此需要显式清理。在这里，您应用了C#特性——内联使用——它在离开其所在范围后处理对象：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you have a `DbContext`, getting data from it is trivial:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个`DbContext`时，从中获取数据是微不足道的：
- en: Access a `DbSet`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`DbSet`。
- en: Convert it into a list.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其转换为列表。
- en: Why do you need to make any conversions, though? That is because `DbSet`, much
    like `IEnumerable`, is lazy-loaded. It encapsulates the SQL needed to execute.
    So, unless you explicitly demand it (for example, by calling `ToList`), there
    won't be any data queried. Calling `ToList` does the actual call to a database
    and retrieves all the products.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么需要进行任何转换呢？那是因为`DbSet`与`IEnumerable`一样，是惰性加载的。它封装了执行所需的SQL。因此，除非您明确要求（例如，通过调用`ToList`），否则不会查询任何数据。调用`ToList`会实际调用数据库并检索所有产品。
- en: You now know all about databases. The next section will touch on the `AdventureWorks`
    database which is a common database for teaching SQL to beginners.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了关于数据库的所有内容。下一节将涉及`AdventureWorks`数据库，这是一个常用的用于教授SQL给初学者的数据库。
- en: AdventureWorks Database
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AdventureWorks数据库
- en: '`AdventureWorks` is a database used for learning purposes. It contains dozens
    of tables and has hundreds of records in each table. The tables are focused on
    wholesale, which is a common scenario in enterprise applications. In other words,
    the `AdventureWorks` database provides examples for learning with closeness to
    real-world problems.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdventureWorks`是一个用于学习目的的数据库。它包含数十个表，每个表中都有数百条记录。这些表侧重于批发，这在企业应用程序中是一个常见的场景。换句话说，`AdventureWorks`数据库提供了与真实世界问题紧密相关的学习示例。'
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You must first create the `AdventureWorks` database in PostgreSQL. You can find
    the steps to create this database in the reference chapter placed on GitHub.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须首先在PostgreSQL中创建`AdventureWorks`数据库。您可以在放置在GitHub上的参考章节中找到创建此数据库的步骤。
- en: The previous sections covered entity, models, and how to combine everything
    and communicate with a database. You also learned about `DbContext` and `DbSet`.
    This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分涵盖了实体、模型以及如何将所有内容组合起来并与数据库通信。您还学习了`DbContext`和`DbSet`。这结束了本节的理论部分。在接下来的部分，您将通过练习将其付诸实践。
- en: 'Exercise 6.01: Reading Stock Locations from AdventureWorks Database'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：从AdventureWorks数据库中读取库存位置
- en: 'The simplest use case of EF is to read data tables into C# objects. This exercise
    will teach you how to create a data entity class and add correct attributes to
    it. For this, you will create an inventory `location` table within the example
    `AdventureWorks` database. Perform the following steps to do so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: EF的最简单用例是将数据表读入C#对象。这个练习将教你如何创建一个数据实体类并为其添加正确的属性。为此，你将在示例`AdventureWorks`数据库中创建一个库存`location`表。执行以下步骤：
- en: 'Create a `Location` entity. It should have `LocationId`, `Name`, `Costrate`,
    `Availability`, and `ModifiedDate` properties, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Location`实体。它应该具有`LocationId`、`Name`、`Costrate`、`Availability`和`ModifiedDate`属性，如下所示：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A `[Table]` attribute has been applied because you need to specify a schema
    as well as a properly capitalized table name. On top of that, every column name
    needs to be explicitly specified using the `[Column]` attribute since the capitalization
    does not match.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您需要指定模式以及正确大写的表名，所以已经应用了`[Table]`属性。除此之外，每个列名都需要使用`[Column]`属性显式指定，因为大小写不匹配。
- en: 'Create a class named `AdventureWorksContext`, which inherits the `DbContext`,
    as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AdventureWorksContext`的类，它继承自`DbContext`，如下所示：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inheriting `DbContext` is necessary if you want to reuse the base functionality
    of database abstraction such as connecting to a database. The use of base functionality
    is visible in the two base constructors. In the parameterized constructor, you
    use PostgreSQL; in non-parameterized you can supply whatever database provider
    you choose.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要重用数据库抽象的基本功能，比如连接到数据库，那么继承`DbContext`是必要的。基本功能的使用在两个基本构造函数中是可见的。在带参数的构造函数中，您使用PostgreSQL；在非参数化的构造函数中，您可以选择任何数据库提供程序。
- en: 'Now use the `Program.AdventureWorksConnectionString` connection string as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用`Program.AdventureWorksConnectionString`连接字符串，如下所示：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This represents the needed `location` table.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了所需的`location`表。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please keep your PostgreSQL passwords safe. Don't write them in code in plaintext,
    instead use environment variables or secrets.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请保管好您的PostgreSQL密码。不要将它们以明文形式写入代码中，而是使用环境变量或密钥。
- en: 'Connect to a database:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is as simple as creating a new `DbContext`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像创建一个新的`DbContext`一样简单。
- en: 'Get all products by adding the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码获取所有产品：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that you have queried the locations and no longer need to keep the connection
    open, it is better to disconnect from the database. In order to disconnect from
    the database, call the `Dispose` method as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经查询了位置，并且不再需要保持连接打开，最好断开与数据库的连接。为了断开与数据库的连接，请调用`Dispose`方法，如下所示：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Print the results by adding the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码打印结果：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code itself is run from [https://packt.link/2oxXn](https://packt.link/2oxXn).
    Make sure to comment all lines within `static void` `Main(string[] args)` body,
    except `Exercises.Exercise03.Demo.Run()`. When you run the code, the following
    output gets displayed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身是从[https://packt.link/2oxXn](https://packt.link/2oxXn)运行的。请确保在`static void`
    `Main(string[] args)`主体中注释掉所有行，除了`Exercises.Exercise03.Demo.Run()`。运行代码时，将显示以下输出：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Working with EF is simple. As you can see from this exercise, it is intuitive
    and feels like a natural extension to C#.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EF很简单。正如您从这个练习中看到的那样，它是直观的，并且感觉像是C#的自然扩展。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/9Weup](https://packt.link/9Weup).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/9Weup](https://packt.link/9Weup)找到此练习中使用的代码。
- en: Querying a Database—LINQ to SQL
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据库—LINQ to SQL
- en: 'One of the more interesting features of EF is that running SQL statements is
    very much like working with a collection. For example, say you want to retrieve
    a product by its name. You can get a product by name the same way you would be
    using LINQ:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: EF的一个更有趣的特性是运行SQL语句非常类似于使用集合。例如，假设您想通过名称检索产品。您可以通过名称获取产品，就像使用LINQ一样：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `FirstOrDefault` returns the first matching product by its name. If no
    product by that name exists, then it returns a `null`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FirstOrDefault`通过名称返回第一个匹配的产品。如果不存在该名称的产品，则返回`null`。
- en: 'What about finding a unique element by its ID? In that case, you would use
    a special method (`Find`), which either gets an entity from a database or, if
    one with the same ID has been retrieved recently, returns it from memory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么通过ID查找唯一元素呢？在这种情况下，您将使用一个特殊的方法（`Find`），它可以从数据库中获取一个实体，或者如果最近已经检索到具有相同ID的实体，则从内存中返回它：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When using a primary key, it is better to use `Find` instead of `Where` because
    it has a slightly different meaning in the context of EF. Instead of trying to
    create a SQL query and execute it, `Find` will check whether this item has already
    been accessed and will retrieve it from a cache, rather than going through a database.
    This makes for more efficient operations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用主键时，最好使用`Find`而不是`Where`，因为在EF的上下文中，它的含义略有不同。`Find`不会尝试创建并执行SQL查询，而是会检查该项是否已被访问，并将其从缓存中检索出来，而不是通过数据库。这可以使操作更加高效。
- en: 'What about finding all products by the related manufacturer ID? You can create
    a method that returns an `IEnumerable<Product>` for this purpose, named `GetByManufacturer`,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何通过相关制造商ID找到所有产品呢？您可以创建一个返回`IEnumerable<Product>`的方法，名为`GetByManufacturer`，如下所示：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You might be wondering why you should choose to use `Where` instead of `Find`
    here. That is because you are getting many products by their foreign key `manufacturerId`.
    Be careful not to mix foreign and primary keys; `Find` is used only for primary
    keys.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么在这里选择使用`Where`而不是`Find`。那是因为您通过它们的外键`manufacturerId`获取了许多产品。要小心不要混淆外键和主键；`Find`仅用于主键。
- en: In order to run this example, go to [https://packt.link/2oxXn](https://packt.link/2oxXn)
    and comment all lines within `static void Main(string[] args)` body except `Examples.Crud.Demo.Run();`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请转到[https://packt.link/2oxXn](https://packt.link/2oxXn)，并注释掉`static void
    Main(string[] args)`主体中的所有行，除了`Examples.Crud.Demo.Run();`。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/pwcwx](https://packt.link/pwcwx).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/pwcwx](https://packt.link/pwcwx)找到此示例使用的代码。
- en: Now, how about retrieving related entities? If you simply call `db.Manufacturers.ToList()`,
    you will have null products. This is because the products will not be retrieved
    automatically unless explicitly specified. If you didn't call `ToList()`, you
    could make use of lazy-loading (that is, loading the required entities on demand),
    but that would result in a very suboptimal solution as you would always be querying
    child entities for every parent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何检索相关实体呢？如果您简单地调用`db.Manufacturers.ToList()`，您将得到空产品。这是因为除非明确指定，否则不会自动检索产品。如果您没有调用`ToList()`，您可以利用延迟加载（即按需加载所需的实体），但这将导致非常不理想的解决方案，因为您将始终为每个父实体查询子实体。
- en: 'A proper solution is to call `Include(parent => parent.ChildToInclude)`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的解决方案是调用`Include(parent => parent.ChildToInclude)`：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This approach is called eager loading. With this approach, you specify which
    child entities should be retrieved immediately. There will be scenarios where
    child entities will have their child entities; there, you could call `ThenInclude`.
    In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.Crud.Demo.Run();` in `Program.cs`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法称为急切加载。使用此方法，您可以指定应立即检索哪些子实体。在某些情况下，子实体将具有它们的子实体；在这种情况下，您可以调用`ThenInclude`。要运行此示例，请在`Program.cs`中注释掉`static
    void Main(string[] args)`主体中的所有行，除了`Examples.Crud.Demo.Run();`。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/c82nA](https://packt.link/c82nA).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/c82nA](https://packt.link/c82nA)找到此示例使用的代码。
- en: Remember when it was established that trying to get everything from a table
    is not the right thing to do in most cases? Eager loading has the same problem.
    So, what should you do if you only want some properties? It's time to learn about
    the other side of LINQ.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前确定在大多数情况下尝试从表中获取所有内容都不是正确的做法吗？急切加载也有同样的问题。那么，如果您只想要一些属性，该怎么办呢？现在是时候了解LINQ的另一面了。
- en: Query Syntax
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询语法
- en: 'Query syntax is an alternative syntax to LINQ lambdas. It is very similar to
    SQL. The main advantage of query syntax over lambdas is that it feels more natural
    to write queries when you have complex joins and want only some of the data back.
    Imagine you wanted to get all product-manufacturer name pairs. You cannot simply
    get manufacturers and include products; you only want two products. If you tried
    using LINQ, the code would like the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语法是LINQ lambda的一种替代语法。它非常类似于SQL。查询语法相对于lambda的主要优势在于，当您进行复杂的连接并且只想返回一些数据时，编写查询时会感觉更自然。想象一下，您想要获取所有产品制造商名称对。您不能简单地获取制造商并包括产品；您只想要两个产品。如果尝试使用LINQ，代码将如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The same operation using query syntax looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询语法进行相同的操作如下：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Break the code down:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 分解代码：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now select all products and their columns:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择所有产品及其列：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For every product, add manufacturer columns like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个产品，添加制造商列如下：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Manufacturer columns are added only for products which have `ManufacturerId`
    equal to the `Id` of the manufacturer (`INNER JOIN`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 只为`ManufacturerId`等于制造商的`Id`的产品添加制造商列（`INNER JOIN`）。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Why can't you write `==` instead of `equals`? That is because, in LINQ query
    syntax, `equals` completes a join; it is not just a comparison of two values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不能使用`==`而不是`equals`？那是因为在LINQ查询语法中，`equals`完成了一个连接；它不仅仅是两个值的比较。
- en: The `select` part is the same in both lambda and query syntax; however, it's
    worth mentioning what you selected. The `select new {...}` means that you create
    a new anonymous object to have all the things you want to select. The idea is
    to later use this to return a strongly typed object that you need. Therefore,
    after a `ToList` method, you are likely to perform another `select` operation
    to map the results for the final return. You cannot do the mapping right away
    because before you do `ToList`, you are still working with an expression that
    is yet to be converted into SQL. Only after `ToList` is called can you be sure
    that you are working with C# objects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`部分在lambda和查询语法中是相同的；但是，值得一提的是您选择了什么。`select new {...}`表示您创建了一个新的匿名对象，其中包含您想要选择的所有内容。想法是稍后使用它来返回您需要的强类型对象。因此，在`ToList`方法之后，您可能会执行另一个`select`操作，以将结果映射到最终返回的结果。您不能立即进行映射，因为在执行`ToList`之前，您仍在处理一个尚未转换为SQL的表达式。只有在调用`ToList`之后，您才能确信您正在使用C#对象。'
- en: Finally, you may be wondering why the join is surrounded by brackets before
    calling `ToList`. That's because you were still in query syntax mode and the only
    way to escape it and go back to normal LINQ is by surrounding it with brackets.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能想知道为什么在调用`ToList`之前，连接被括在括号中。那是因为您仍然处于查询语法模式中，唯一的方法是用括号括起来逃离它并返回到正常的LINQ。
- en: 'If you struggle to remember LINQ query syntax, remember a `foreach` loop:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您难以记住LINQ查询语法，可以记住`foreach`循环：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The query syntax of `from` is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`的查询语法如下：'
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The highlighted part in the preceding code snippet is the syntax parts that
    overlap on both. This also applies to join. The two make the most of query syntax.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，突出显示的部分是两者都重叠的语法部分。这也适用于join。这两者充分利用了查询语法。
- en: Both lambda and query syntax has the same performance metrics because, in the
    end, the query syntax will be compiled into the lambda equivalent. When making
    complex joins, it might make more sense to use a query syntax because it will
    look closer to SQL and therefore might be easier to grasp.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最终查询语法将被编译成lambda等效形式，因此lambda和查询语法具有相同的性能指标。在进行复杂的连接时，可能更有意义使用查询语法，因为它看起来更接近SQL，因此可能更容易理解。
- en: 'Now run the code. In order to run this example, comment all lines within `static
    void Main(string[] args)` body except `Examples.Crud.Demo.Run();` in `Program.cs`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码。为了运行此示例，请在`static void Main(string[] args)`主体中注释掉所有行，除了`Program.cs`中的`Examples.Crud.Demo.Run();`：
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/c82nA](https://packt.link/c82nA).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/c82nA](https://packt.link/c82nA)找到此示例使用的代码。
- en: You now know that query syntax is an alternative syntax to LINQ lambdas. But
    how you can perform the remaining operations with rows that are, create, update,
    and delete, using query syntax? The next section details how that can be done.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道查询语法是LINQ lambda的另一种语法。但是如何使用查询语法执行剩余的行操作，即创建、更新和删除？下一节详细介绍了如何完成这些操作。
- en: The Rest of CRUD
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRUD的其余部分
- en: 'Adding, updating, and removing data using query syntax is also similar to basic
    LINQ. However, similar to executing the queries by calling `ToList`, it involves
    one extra step that is, committing the changes. Consider the following code where
    you are creating a new product:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询语法添加、更新和删除数据也类似于基本的LINQ。然而，类似于通过调用`ToList`执行查询，它涉及一个额外的步骤，即提交更改。考虑以下代码，您正在创建一个新产品：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code should look almost completely familiar, except for the last line.
    The `SaveChanges` method is used to run the actual SQL. If you don't call it,
    nothing will happen, and the changes will be gone after disconnecting from the
    database. Also, when adding a child entity (`product`), you don't have to get
    a parent entity (`manufacturer`). All you have to do is to provide a link between
    the two via the foreign key (`ManufacturerId`).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来几乎完全熟悉，除了最后一行。`SaveChanges`方法用于运行实际的SQL。如果不调用它，什么也不会发生，并且在与数据库断开连接后更改将消失。此外，当添加子实体（`product`）时，您不必获取父实体（`manufacturer`）。您所需要做的就是通过外键（`ManufacturerId`）在两者之间提供一个链接。
- en: Why do you need an extra method to apply your changes? Wouldn't it be simpler
    to call `Add` and immediately have a new product row created? In practice, it
    is not that simple. What happens if multiple `Add` methods of different entities
    need to be performed, and what if one of them fails? Should you allow some of
    them to succeed, while others fail? The worst thing you can do is to put your
    database in an invalid state, or, in other words, break data integrity. You need
    a mechanism to either complete fully or fail without affecting anything.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要额外的方法来应用您的更改？调用`Add`并立即创建一个新的产品行不是更简单吗？实际上，情况并不那么简单。如果需要执行不同实体的多个`Add`方法，如果其中一个失败会发生什么？您是否应该允许其中一些成功，而其他失败？您能做的最糟糕的事情就是让您的数据库处于无效状态，或者换句话说，破坏数据完整性。您需要一种机制，要么完全完成，要么失败而不影响任何事情。
- en: In the SQL context, such commands that are run together are called a transaction.
    You can do two things with transactions—either commit or roll them back. In EF,
    every action, other than a query, results in a transaction. The `SaveChanges`
    completes the transaction, whereas a command failing rolls the transaction back.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL上下文中，一起运行的这些命令称为事务。您可以通过事务做两件事——提交或回滚。在EF中，除了查询之外的每个操作都会导致一个事务。`SaveChanges`完成事务，而命令失败会回滚事务。
- en: 'If you were to call plain SQL commands in C#, you would need to create a parameterized
    SQL command, provide each argument separately, and concatenate SQL for multi-query
    updates. For a small entity it may be easy; however, as the size grows the complexity
    increases as well. Using EF, you don''t need to care about low-level details,
    such as passing arguments to a command. For example, with EF, adding a `manufacturer`
    with a few products is as simple as adding a `manufacturer` to a `Manufacturers`
    list:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在C#中调用纯SQL命令，您需要创建一个参数化的SQL命令，分别提供每个参数，并连接多个查询更新的SQL。对于一个小的实体来说可能很容易；然而，随着大小的增长，复杂性也会增加。使用EF，您不需要关心低级细节，比如将参数传递给命令。例如，使用EF，添加带有几个产品的`manufacturer`就像向`Manufacturers`列表添加`manufacturer`一样简单：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, creating manufacturers is nearly the same as adding an element
    to a list. The major difference is the need to complete the changes using `db.SaveChanges()`
    method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，创建制造商几乎与向列表添加元素相同。主要区别在于需要使用`db.SaveChanges()`方法完成更改。
- en: 'What about updating an existing product? Set the price of a product to `45.99`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么更新现有产品呢？将产品的价格设置为`45.99`：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you look carefully at this code, you are provided with not only the updated
    `Price` and an existing item `Id` but also all other fields. This is because there
    is no way for EF to know whether you want to set existing values to null or only
    set the new values. But don't worry; logically, there is rarely a case when you
    update something out of nowhere. You should have a set of items loaded somewhere.
    Therefore, updating an existing object would simply be a matter of setting a new
    value of a property of that object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看此代码，您不仅提供了更新后的`Price`和现有项目`Id`，还提供了所有其他字段。这是因为EF无法知道您是要将现有值设置为null还是仅设置新值。但不用担心；从逻辑上讲，很少有情况是您从无处更新某些内容。您应该在某个地方加载一组项目。因此，更新现有对象只是简单地设置该对象的属性的新值的问题。
- en: 'Of course, there are exceptions when you want to update just one thing. In
    that case, you can have a dedicated method and be completely in control. In the
    following snippet, you will update product values, but only when they are not
    null:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时您只想更新一件事。在这种情况下，您可以有一个专用的方法并完全控制。在以下代码片段中，您将更新产品值，但仅当它们不为null时：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, you would only update the values if they were not the default ones. Ideally,
    when working in situations like this (in which you only want to update some of
    the fields), you should have a dedicated model for the updated fields, send those
    fields, and map them using libraries such as AutoMapper.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有在值不是默认值时才会更新值。理想情况下，在这种情况下工作时（您只想更新某些字段），您应该为更新后的字段创建一个专用模型，发送这些字段，并使用AutoMapper等库进行映射。
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about AutoMapper, refer to their official documentation at [https://docs.automapper.org/en/stable/Getting-started.html](https://docs.automapper.org/en/stable/Getting-started.html).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关AutoMapper的更多信息，请参阅官方文档[https://docs.automapper.org/en/stable/Getting-started.html](https://docs.automapper.org/en/stable/Getting-started.html)。
- en: 'What about deleting existing rows from a database? This involves first getting
    the object you want to remove and only then remove it. For example, say you want
    to remove a product with a particular ID:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从数据库中删除现有行？这首先涉及获取要删除的对象，然后再将其删除。例如，假设您要删除具有特定ID的产品：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once again, removing something from a database is nearly the same as removing
    an element from a list with a small difference that `db.SaveChanges()` is used
    to confirm the changes. In order to run this example, comment all lines within
    `static void Main(string[] args)` body except `Examples.Crud.Demo.Run();` in `Program.cs`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从数据库中删除某些内容几乎与从列表中删除元素相同，只是有一个小差异，即使用`db.SaveChanges()`来确认更改。为了运行此示例，请在`Program.cs`中的`static
    void Main(string[] args)`主体中注释掉除`Examples.Crud.Demo.Run();`之外的所有行。
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/bH5c4](https://packt.link/bH5c4).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/bH5c4](https://packt.link/bH5c4)找到此示例使用的代码。
- en: You have grasped that the basic concept of CRUD is a combination of four functions—create,
    read, update, and delete. Now it is time to put this into practice in the following
    exercise.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经掌握了CRUD的基本概念是四个功能的组合——创建、读取、更新和删除。现在是时候在以下练习中将其付诸实践了。
- en: 'Exercise 6.02: Updating Products and Manufacturers Table'
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：更新产品和制造商表
- en: 'You have already created a `GlobalFactory` database with `Products` and `Manufacturers`
    tables, and you now have enough components to perform full Create, Read, Update
    and Delete (CRUD) on the database. In this exercise, you will use `FactoryDbContext`
    to create methods inside a new class called `GlobalFactoryService`, which can
    accomplish the following tasks:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了一个带有`Products`和`Manufacturers`表的`GlobalFactory`数据库，现在您有足够的组件来对数据库执行完整的创建、读取、更新和删除（CRUD）。在此练习中，您将使用`FactoryDbContext`在名为`GlobalFactoryService`的新类中创建方法，该方法可以完成以下任务：
- en: Add a list of manufacturers in the US.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向美国制造商列表中添加制造商。
- en: Add a list of products to all manufacturers in the US.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向美国所有制造商添加产品列表。
- en: Update any one product in the US with a given discount price.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的折扣价格更新美国的任何一个产品。
- en: Remove any one product from the US region.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从美国地区删除任何一个产品。
- en: Get all manufacturers from the US and their products.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取来自美国的所有制造商及其产品。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: First, create a `GlobalFactoryService` class.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`GlobalFactoryService`类。
- en: Create `FactoryDbContext` inside a constructor and inject the context. Injecting
    the context means that you have a choice of setting it up in any way you want
    (for example, using different providers).
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数内创建`FactoryDbContext`并注入上下文。注入上下文意味着您可以选择以任何您想要的方式设置它（例如，使用不同的提供程序）。
- en: 'Create a constructor that accepts `FactoryDbContext` as an argument, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受`FactoryDbContext`作为参数的构造函数，如下所示：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a `public void CreateManufacturersInUsa(IEnumerable<string> names)`
    method, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`public void CreateManufacturersInUsa(IEnumerable<string> names)`方法，如下所示：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A manufacturer has only two custom fields—`Name` and `Country`. In this case,
    the value of the `Country` is known to be `"USA"`. All you have to do is to pass
    a list of manufacturer `names` and build `Manufacturers` by combining the value
    of the `Country` with their name.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 制造商只有两个自定义字段——`Name`和`Country`。在这种情况下，`Country`的值已知为`"USA"`。您只需传递一个制造商名称列表，并通过将`Country`的值与其名称组合来构建`Manufacturers`。
- en: To create the products, create a `public void CreateUsaProducts(IEnumerable<Product>
    products)` method.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建产品，请创建一个`public void CreateUsaProducts(IEnumerable<Product> products)`方法。
- en: Then get all the manufacturers in the US.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后获取美国所有制造商。
- en: 'Finally, iterate each manufacturer and add all the products to each of them:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，迭代每个制造商并将所有产品添加到每个制造商：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that in this example, you have recreated a new product every time that
    you add the same product to a manufacturer. This is done because even though the
    product has the same properties, it belongs to a different manufacturer. In order
    for that distinction to be set, you need to pass different objects. If you do
    not do that, the products will be assigned to the same (last referenced) manufacturer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，每次将相同的产品添加到制造商时，您都重新创建了一个新产品。这是因为即使产品具有相同的属性，它也属于不同的制造商。为了设置该区别，您需要传递不同的对象。如果不这样做，产品将被分配给相同的（最后引用的）制造商。
- en: Create a `public void SetAnyUsaProductOnDiscount(decimal discountedPrice)` method.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`public void SetAnyUsaProductOnDiscount(decimal discountedPrice)`方法。
- en: To set any USA product on discount, first get all the products from the US region
    and then select the first of them (order doesn't matter).
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要对任何美国产品打折，请首先获取来自美国地区的所有产品，然后选择它们中的第一个（顺序无关紧要）。
- en: 'Next set a new `Price` for that product, and call `SaveChanges()` to confirm
    it:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为该产品设置一个新的`Price`，并调用`SaveChanges()`来确认它：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a `public void RemoveAnyProductInUsa()` method.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`public void RemoveAnyProductInUsa()`方法。
- en: 'To delete an item, simply select the first product in the `"USA"` group and
    remove it:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除一个项目，只需选择“USA”组中的第一个产品并将其删除：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Observe that the `SaveChanges` has been called after every step.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每一步之后都调用了`SaveChanges`。
- en: In order to get a manufacturers from USA, create a `public IEnumerable<Manufacturer>
    GetManufacturersInUsa()` method.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从美国获取制造商，请创建一个`public IEnumerable<Manufacturer> GetManufacturersInUsa()`方法。
- en: 'Call the `ToList()` at the end of a query so that the SQL gets executed:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询的末尾调用`ToList()`，以便执行SQL：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a `Demo` class where you call all functions:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Demo`类，在其中调用所有函数：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In order to run this exercise, comment all lines within `static void Main(string[]
    args)` body except `Exercises.Exercise02.Demo.Run();` in `Program.cs`. The output
    of the preceding code will be as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此练习，请在`Program.cs`中的`static void Main(string[] args)`主体中注释掉所有行，除了`Exercises.Exercise02.Demo.Run();`。上述代码的输出如下：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This output shows exactly what you wanted to achieve. You created two manufacturers:
    `Best Buy` and `Iron Retail`. Each of them had two products, but from the first
    manufacturer, `Best Buy`, you removed one. Therefore, only a single product appears
    under it, as opposed to two products under `Iron Retail`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出完全符合您的预期。您创建了两个制造商：`Best Buy`和`Iron Retail`。每个制造商都有两种产品，但是从第一个制造商`Best Buy`中删除了一个。因此，在其下只显示一个产品，而不是在`Iron
    Retail`下显示两个产品。
- en: Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/uq97N](https://packt.link/uq97N).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/uq97N](https://packt.link/uq97N)找到用于此练习的代码。
- en: At this point, you know how to interact with an existing database. However,
    what you have done so far is manually written models to fit the `GlobalFactory`
    database you have created. Using EF, you only need one side—either a database
    or a `DbContext` schema. In the next sections, you will learn how to work with
    either approach.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经知道如何与现有数据库交互。但是，到目前为止，您所做的是手动编写模型以适应您创建的`GlobalFactory`数据库。使用EF，您只需要一边-要么是数据库，要么是`DbContext`模式。在接下来的几节中，您将学习如何使用任一种方法。
- en: Database First
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库优先
- en: In some cases, you won't have to design a database yourself. Often, an architect
    will do that for you and then a database administrator will handle further changes.
    In other cases, you may get to work with some really old projects and a legacy
    database. Both scenarios are perfect for a database first approach because you
    can generate a `DbContext` schema with all the needed models using an existing
    database.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您不必自己设计数据库。通常，架构师会为您做这项工作，然后数据库管理员将处理进一步的更改。在其他情况下，您可能会与一些非常古老的项目和传统数据库一起工作。这两种情况都非常适合数据库优先方法，因为您可以使用现有数据库生成具有所有所需模型的`DbContext`模式。
- en: 'The project selected must be an executable project. For example, `WebApi` and
    `ConsoleApp` are okay; however, a class library is not (you cannot run a class
    library; you can only reference it from other applications). So, install EF tools
    by running this in the console:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的项目必须是可执行项目。例如，`WebApi`和`ConsoleApp`都可以；但是，类库不行（您不能运行类库；您只能从其他应用程序引用它）。因此，请通过在控制台中运行以下命令来安装EF工具：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, run the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This command reads the database schema (you specified to generate the database
    from all the schemas rather than just one production schema) and generates models
    out of it. You used the `AdventureWorks` database. Using the `-o` flag, you select
    the output directory, and using the `–schema` flag, you specify the schemas you
    would like to generate the database from.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令读取数据库架构（您指定从所有架构而不仅仅是一个生产架构生成数据库）并从中生成模型。您使用了`AdventureWorks`数据库。使用`-o`标志，您选择输出目录，并使用`–schema`标志，您指定要从中生成数据库的架构。
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The generated models from an existing database can be found at [https://packt.link/8KIOK](https://packt.link/8KIOK).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.link/8KIOK](https://packt.link/8KIOK)找到从现有数据库生成的模型。
- en: The models generated are quite interesting. They reveal two things that have
    not yet been talked about. When you created a `Manufacturer` class (read the *Modeling
    Databases Using EF* section), you did not initialize a collection of products
    from a constructor. This is not a big issue, but instead of not returning data,
    you get a null reference exception, which might not be what you want. None of
    the models, no matter how simple or complex they are, have attributes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模型非常有趣。它们揭示了两件尚未讨论的事情。当您创建`Manufacturer`类（请阅读*使用EF建模数据库*部分）时，您没有从构造函数初始化产品集合。这不是一个大问题，但是您不返回数据，而是得到一个空引用异常，这可能不是您想要的。无论模型有多简单或复杂，都没有属性。
- en: You are almost done with the db-first approach. The next section will revisit
    `DbContext` and inspect how EF does it so you can then apply what you learned
    in a code-first approach.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎已经完成了数据库优先方法。下一节将重新审视`DbContext`并检查EF是如何做的，以便您可以在代码优先方法中应用所学到的知识。
- en: Revisiting DbContext
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重温DbContext
- en: 'By logically grasping the following snippet, `AdventureWorksContext`, you will
    notice that the default configuration is passed slightly differently from the
    one created in the *DbContext and DbSet* section. Instead of directly using a
    connection string for SQL Server, the generated context uses the `OnConfiguring`
    method to double-check the given context options and if they are unconfigured,
    set one. This is a cleaner approach because you don''t have to manually initialize
    the builder yourself and prevent unconfigured options:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逻辑上理解以下片段`AdventureWorksContext`，您会注意到默认配置与在*DbContext和DbSet*部分中创建的配置略有不同。生成的上下文使用`OnConfiguring`方法来直接使用SQL
    Server的连接字符串，以双重检查给定的上下文选项，如果它们未配置，则设置一个。这是一个更清晰的方法，因为您不必手动初始化生成器自己并防止未配置的选项：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next, there is a method named `OnModelCreating`. It is a method that takes `ModelBuilder`
    that is used to dynamically build models for your database. `ModelBuilder` directly
    replaces the attribute-based approach because it allows you to keep the models
    attribute-free and add whatever constraints or mappings are needed when the context
    is initialized. It includes column names, constraints, keys, and indexes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个名为`OnModelCreating`的方法。这是一个接受`ModelBuilder`的方法，用于动态构建数据库的模型。`ModelBuilder`直接取代了基于属性的方法，因为它允许您保持模型无属性，并在初始化上下文时添加任何约束或映射所需的内容。它包括列名、约束、键和索引。
- en: '`ModelBuilder` allows you to use Fluent API (that is, method chaining), which
    in turn allows you to add extra configurations to models. Consider the following
    single, fully configured model:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelBuilder`允许您使用Fluent API（即方法链接），从而允许您向模型添加额外的配置。考虑以下单个、完全配置的模型：'
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Looking at this part of `ModelBuilder` will give you a full picture of how
    the model maps to a table and its columns, keys, indexes, and relations. The generated
    code is broken down for you. To begin configuring an entity, you need to call
    the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`ModelBuilder`的这部分将让您完整地了解模型如何映射到表及其列、键、索引和关系。生成的代码已经为您分解了。要开始配置一个实体，您需要调用以下内容：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Mapping to the table and schema looks like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到表和模式看起来像这样：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can also add constraints (for example, to make sure that a field is not
    null) and set the character limit and name of a column the property maps to. In
    the following code, you''re doing so for `Name`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加约束（例如，确保字段不为空）并设置属性映射到的列的字符限制和名称。在下面的代码中，您正在为`Name`这样做：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Lastly, some entities have multiple navigational properties associated with
    them. When multiple navigational properties are involved, EF may not be able to
    clearly interpret what the relationship should be. In those cases, you will need
    to configure it manually, as shown in the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些实体与它们相关联的多个导航属性。当涉及多个导航属性时，EF可能无法清楚地解释关系应该是什么。在这些情况下，您需要手动配置它，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code maps the `Manufacturer` entity to `Product` with a 1:n relationship
    and sets the foreign key column to `product_manufacturerid_id`. Spotting those
    cases might be tricky; therefore, you should only add manual configurations when
    an error informs you about such an ambiguity:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将`Manufacturer`实体映射到`Product`，并设置了1：n的关系，并将外键列设置为`product_manufacturerid_id`。发现这些情况可能有些棘手；因此，只有在错误提示您存在这种模棱两可的情况时，才应添加手动配置：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no runnable code here; this is just a scaffold of a database.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有可运行的代码；这只是一个数据库的脚手架。
- en: Now you know what a generated `DbContext` looks like and how to customize models
    yourself. Without touching model classes, and instead using `ModelBuidler`, it
    is time to get familiar with doing the opposite, which is generating a database
    out of the context.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了生成的`DbContext`是什么样子，以及如何自定义模型。而不是触及模型类，而是使用`ModelBuidler`，现在是时候熟悉相反的操作，即从上下文生成数据库。
- en: Generating DbContext from an Existing Database
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从现有数据库生成DbContext
- en: For subsequent examples, you will be using the `GlobalFactory2021` database.
    Just to be sure that what you have made is the same as what the database contains,
    you'll perform database scaffolding one more time. Scaffolding is an operation
    that takes a database schema (or `DbContext`, in this case) and generates a physical
    database out of it.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的示例中，您将使用`GlobalFactory2021`数据库。只是为了确保您所做的与数据库包含的内容相同，您将再次执行数据库脚手架。脚手架是一个操作，它接受一个数据库模式（或在这种情况下是`DbContext`）并生成一个物理数据库。
- en: 'Open the console and run the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 打开控制台并运行以下命令：
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For security, do not forget to replace the hardcoded connection string in `DbContext`
    with the one from the environment variable. The resulting `DbContext` should look
    like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全考虑，请不要忘记将`DbContext`中的硬编码连接字符串替换为环境变量中的连接字符串。生成的`DbContext`应该如下所示：
- en: '![Figure 6.3: DbContext generated after applying the scaffold command'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：应用脚手架命令后生成的DbContext'
- en: '](img/B16835_06_03.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_03.jpg)'
- en: 'Figure 6.3: DbContext generated after applying the scaffold command'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：应用脚手架命令后生成的DbContext
- en: One of the main advantages of EF is that you can quickly define entities and
    then create a database out of them. But first, you'll need to learn the code first
    approach.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: EF的主要优势之一是您可以快速定义实体，然后从中创建数据库。但首先，您需要先学习代码优先的方法。
- en: Code First and Migrations
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Code First和Migrations
- en: Usually, when you need to create a proof of concept, you will create a `DbContext`
    schema with the models and then generate a database out of that. Such an approach
    is called code first.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您需要创建一个概念验证时，您将创建一个带有模型的`DbContext`模式，然后从中生成一个数据库。这种方法称为代码优先。
- en: 'In this example, you will use the context you have generated from the `GlobalFactory2021`
    database and then generate a new database out of it. This approach requires an
    extra package named `Design`, so make sure it is installed by running the following
    command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您将使用从`GlobalFactory2021`数据库生成的上下文，然后生成一个新的数据库。这种方法需要一个名为`Design`的额外包，所以请确保通过运行以下命令来安装它：
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'EF is able to generate a database and have different versioning for it. In
    fact, it can move from one database version to another. A single database version
    at any given time is called migration. Migrations are needed to ensure that you
    do not just always recreate databases (after all, you don''t want to lose the
    existing data), but instead, apply them neatly in a secure and trusted way. To
    add the first migration, from the VS Code terminal, run the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: EF能够生成数据库并对其进行不同的版本控制。实际上，它可以从一个数据库版本移动到另一个数据库版本。在任何给定时间，单个数据库版本称为迁移。迁移是必需的，以确保您不仅仅是一直重新创建数据库（毕竟，您不想丢失现有数据），而是以一种安全和可信赖的方式将它们整齐地应用。要添加第一个迁移，从VS
    Code终端运行以下命令：
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will generate a migration file:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个迁移文件：
- en: '![Figure 6.4: New migration with defaults placed under the project Migrations
    folder'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：将默认值放置在项目迁移文件夹下的新迁移'
- en: in the project root
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录
- en: '](img/B16835_06_04.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_04.jpg)'
- en: 'Figure 6.4: New migration with defaults placed under the project Migrations
    folder in the project root'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：将默认值放置在项目根目录中的项目迁移文件夹下
- en: The migration provides EF with information about the next database schema version
    and can therefore be used to generate a database from (or apply new changes to
    an existing database). Note that since you have multiple `DbContext` schemas and
    EF cannot tell you which context to use, you have to provide one explicitly. It
    is also worth mentioning that running this command requires selecting a default
    project, which includes the required context. and placing the migrations in that
    project's directory.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移为EF提供了关于下一个数据库模式版本的信息，因此可以用于从迁移生成数据库（或将新更改应用于现有数据库）。请注意，由于您有多个`DbContext`模式，EF无法告诉您要使用哪个上下文，因此您必须显式提供一个。还值得一提的是，运行此命令需要选择一个默认项目，其中包括所需的上下文，并将迁移放置在该项目的目录中。
- en: 'Why can''t you just generate a database right away? When working with data,
    capturing a change at any given time and being able to go back to a previous version
    is very important. Even though directly generating a database might sound easy,
    it is not a viable approach because changes happen all the time. You want to be
    in control and have a choice to switch between versions at will. The migrations
    approach also works with code versioning systems, such as Git, because you can
    see the changes made to your database through a migration file. You will learn
    more about version control in *Chapter 11*, *Production-Ready C#: from Development
    to Deployment*.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不能立即生成一个数据库？在处理数据时，随时捕获变化并能够返回到以前的版本非常重要。尽管直接生成数据库听起来可能很容易，但这不是一种可行的方法，因为变化一直在发生。您希望能够控制并选择在不同版本之间切换的权利。迁移方法还与代码版本控制系统（如Git）一起使用，因为您可以通过迁移文件查看对数据库所做的更改。您将在*第11章*《生产就绪的C#：从开发到部署》中了解更多关于版本控制的内容。
- en: 'Before creating a database, make sure you change the database name inside the
    connection string so that a new database can be created and not overwritten. Creating
    a new database from a migration you have can be done by running this command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据库之前，请确保更改连接字符串中的数据库名称，以便可以创建新数据库而不是覆盖现有数据库。通过运行以下命令可以从迁移中创建一个新数据库：
- en: '[PRE67]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you open `pgAdmin`, you will see a very familiar view with the `manufacturer`
    and `product`. However, there is one new table for the migration history:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`pgAdmin`，您将看到一个非常熟悉的视图，其中包括`manufacturer`和`product`。但是，还有一个新的表用于迁移历史记录：
- en: '![Figure 6.5: Generated database inside pgAdmin browser (simplified view for
    brevity)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：在pgAdmin浏览器中生成的数据库（简化视图以节省篇幅）'
- en: '](img/B16835_06_05.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_05.jpg)'
- en: 'Figure 6.5: Generated database inside pgAdmin browser (simplified view for
    brevity)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：在pgAdmin浏览器中生成的数据库（简化视图以节省篇幅）
- en: 'The `__EFMigrationsHistory` table lays out all the migrations performed, when
    they were performed, and the EF version with which they were executed. In the
    following screenshot, you can see the first migration created as `MyfirstMigration`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`__EFMigrationsHistory`表列出了执行的所有迁移，以及它们执行的时间和EF版本。在下面的截图中，您可以看到第一个迁移被创建为`MyfirstMigration`：'
- en: '![Figure 6.6: EFMigrationsHistory table rows'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：EFMigrationsHistory表行'
- en: '](img/B16835_06_06.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_06.jpg)'
- en: 'Figure 6.6: EFMigrationsHistory table rows'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：EFMigrationsHistory表行
- en: You might find it strange that a migrations table has only two columns. However,
    those two columns have all the needed information, such as when, what, and how.
    Under `MigrationId`, the digits before `_` refer to the date and time the migration
    was run. This is followed by the migration name. The `ProductVersion` refers to
    the EF Core version with which the command was executed.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会觉得奇怪，迁移表只有两列。但是，这两列包含了所有所需的信息，例如何时、什么和如何。在`MigrationId`下，下划线前的数字是迁移运行的日期和时间。然后是迁移名称。`ProductVersion`指的是执行该命令的EF
    Core版本。
- en: What if you wanted to make changes in your data models? What if you would like
    the `manufacturer` table to also have a date for the foundation? You would need
    to go through the same flow—add a migration and update the database.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更改数据模型，该怎么办？如果您希望`manufacturer`表也有一个成立日期？您需要经过相同的流程——添加一个迁移并更新数据库。
- en: 'So first, you would add a new property inside a `Manufacturer` class:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，您将在`Manufacturer`类中添加一个新属性：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here `FoundedAt` is a date. It does not need time associated with it, so you
    should specify an appropriate SQL Server type that maps to it. You would do this
    in `GlobalFactory2021Context` inside the `OnModelCreating` method:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FoundedAt`是一个日期。它不需要与之关联的时间，因此您应该指定一个适当的SQL Server类型，将其映射到它。您可以在`GlobalFactory2021Context`中的`OnModelCreating`方法中执行此操作：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now you can add that to a new migration:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将其添加到新的迁移中：
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Apply the new migration to the database:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将新迁移应用到数据库：
- en: '[PRE71]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will add a new entry to the migration history:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向迁移历史记录添加一个新条目：
- en: '![Figure 6.7: Migration 2 as the new migration created in the migrations table'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：迁移2作为在迁移表中创建的新迁移'
- en: '](img/B16835_06_07.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_07.jpg)'
- en: 'Figure 6.7: Migration 2 as the new migration created in the migrations table'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：迁移2作为迁移表中创建的新迁移
- en: 'You should see the new column in the `manufacturer` table as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在`manufacturer`表中看到新的列如下：
- en: '![Figure 6.8: The manufacturer table with the new column named as foundedat'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：带有新列名称为foundedat的制造商表'
- en: '](img/B16835_06_08.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_08.jpg)'
- en: 'Figure 6.8: The manufacturer table with the new column named as foundedat'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：带有新列名称为foundedat的制造商表
- en: 'Now you know how to apply your models, change them, and generate a database
    out of the models. So far, you have made the following changes:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何应用你的模型，改变它们，并且从模型中生成数据库。到目前为止，你已经做出了以下更改：
- en: Added the `FoundedAt` property and model builder changes.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`FoundedAt`属性和模型构建器的更改。
- en: Created a migration file.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个迁移文件。
- en: Updated a database with that migration file.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该迁移文件更新了数据库。
- en: 'Undoing those changes will involve doing the opposite, in this sequence:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销这些更改将涉及按照以下顺序进行相反的操作：
- en: Rolling back database changes (updating the database to the last successful migration).
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚数据库更改（将数据库更新到最后一个成功的迁移）。
- en: Removing the migration file.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除迁移文件。
- en: Removing model builder changes.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除模型构建器的更改。
- en: 'EF migrations allow you to selectively apply any migration you want. Here,
    you will be applying the previous migration:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: EF迁移允许你选择性地应用任何你想要的迁移。在这里，你将应用之前的迁移：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You will delete the migration file using the following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用以下命令删除迁移文件：
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When working with big and complex databases, especially when they are already
    in production, performing migration using EF tools may become too complex. After
    all, you do not have full control of the exact script EF will generate for a migration.
    If you ever need a custom migration script, EF will no longer fit your bill. However,
    you can always convert whatever EF would do into SQL. You can do this by running
    the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型和复杂的数据库时，特别是当它们已经在生产中时，使用EF工具执行迁移可能会变得太复杂。毕竟，你无法完全控制EF为迁移生成的确切脚本。如果你需要自定义迁移脚本，EF将不再适合你。然而，你总是可以将EF会做的事情转换成SQL。你可以通过运行以下命令来做到这一点：
- en: '[PRE74]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This command produces, instead of a C# migration class, a SQL script. Executing
    a SQL script (often modified) is the preferred way of performing migrations in
    a production environment.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令产生的是一个SQL脚本，而不是一个C#迁移类。在生产环境中，执行SQL脚本（通常是修改后的）是执行迁移的首选方式。
- en: Those are just some basic yet common scenarios that you will be dealing with
    when working with databases. Change almost always happens; therefore, you should
    expect it and be prepared, as you will see in the following exercise.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些基本但常见的情景，当你处理数据库时会遇到。变化几乎总是会发生；因此，你应该期待并做好准备，正如你将在接下来的练习中看到的。
- en: 'Exercise 6.03: Managing Product Price Changes'
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：管理产品价格变动
- en: Once again, your manager is impressed with your results. This time, they have
    asked you to keep track of product price changes. They would like a new table,
    `ProductPriceHistory`, that holds a record of the changes in the price of a product.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经理再次对你的成果印象深刻。这一次，他们要求你跟踪产品价格的变化。他们想要一个新的表，`ProductPriceHistory`，记录产品价格的变化记录。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'To track price changes, add a new model, `ProductPriceHistory` with the following
    fields:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪价格变动，添加一个新的模型，`ProductPriceHistory`，包括以下字段：
- en: '`Id`'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`'
- en: '`Price`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price`'
- en: '`DateOfPrrice`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateOfPrrice`'
- en: '`ProductId`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductId`'
- en: '`Product`'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`'
- en: 'The code for the new model will be as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 新模型的代码将如下所示：
- en: '[PRE75]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, update the `Product` model so that it includes the historical price changes.
    So, add a new collection property, `ProductPriceHistory`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`Product`模型，以便包括历史价格变动。因此，添加一个新的集合属性，`ProductPriceHistory`：
- en: '[PRE76]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Change the `Price` column. `Price` should now be a method that gets the latest
    price of a product and the full model now looks like this:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Price`列。`Price`现在应该是一个获取产品最新价格的方法，整个模型现在看起来像这样：
- en: '[PRE77]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Update `DbContext` to include a new `DbSet` and add the `ProductPriceHistory`
    configuration to the `OnModelCreating` method, as follows:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`DbContext`以包括一个新的`DbSet`，并将`ProductPriceHistory`配置添加到`OnModelCreating`方法中，如下所示：
- en: '[PRE78]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The preceding code provides mappings to a table and column property types. A
    `Product` has many historical price changes, therefore it forms a 1:n relation
    with a `PriceHistory`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码提供了对表和列属性类型的映射。一个`Product`有许多历史价格变动，因此它与`PriceHistory`形成了1:n的关系。
- en: 'Just after the preceding code, create a 1:n relation between `Product` and `PriceHistory`:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码之后，创建`Product`和`PriceHistory`之间的1:n关系：
- en: '[PRE79]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For the database change to be captured (so that you can apply the change from
    code to database or roll back), add the `migration` as follows:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了捕获数据库更改（以便你可以从代码到数据库应用更改或回滚），添加以下`migration`：
- en: '[PRE80]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following will be generated:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 将会生成以下内容：
- en: '![Figure 6.9: The generated database migrations and extra files'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：生成的数据库迁移和额外文件'
- en: '](img/B16835_06_09.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_09.jpg)'
- en: 'Figure 6.9: The generated database migrations and extra files'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：生成的数据库迁移和额外文件
- en: 'In order to apply the migration, run the following command:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了应用迁移，运行以下命令：
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `Demo` by adding some dummy data:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一些虚拟数据创建一个`Demo`：
- en: '[PRE82]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, you first created a `manufacturer` and its `product` and then added a
    few price changes. Once the changes were saved, you disconnected from the database
    (so that you don't work with cached entities). In order to test whether it works,
    you queried all `"Fake Toys"` manufacturer with their products and their price
    history.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你首先创建了一个`manufacturer`和它的`product`，然后添加了一些价格变动。一旦更改保存了，你就断开了与数据库的连接（这样你就不会使用缓存的实体）。为了测试它是否有效，你查询了所有带有产品和价格历史的“Fake
    Toys”制造商。
- en: Note
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working with dates, especially in the context of databases or environments
    that may be shared beyond your local, prefer to use dates without your locale
    by calling `DateTime.UtcNow`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理日期时，特别是在数据库或可能在本地之外共享的环境中，最好通过调用`DateTime.UtcNow`来使用不带有本地语言环境的日期。
- en: 'In order to run this exercise, comment all lines within `static void Main(string[]
    args)` body except `Exercises.Exercise03.Demo.Run();` in `Program.cs`. You will
    see the following output:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行这个练习，在`static void Main(string[] args)`体中注释掉所有行，除了`Program.cs`中的`Exercises.Exercise03.Demo.Run();`。你会看到以下输出：
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `Demo`, you created a `manufacturer` with one product which is a toy
    (`Rubber Sweater`). The toy has two prices: `15.11` and `15.50` (the latest).
    You then saved that toy in the database, disconnected, and reconnected from that
    database (making sure that the toy is not cached, but rather fetched), and executed
    an eager loading-based join.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Demo`中，你创建了一个`manufacturer`，有一个产品是一个玩具（`Rubber Sweater`）。这个玩具有两个价格：`15.11`和`15.50`（最新的）。然后你将这个玩具保存到数据库中，断开连接，重新连接到数据库（确保玩具没有被缓存，而是被获取），并执行了基于急切加载的连接。
- en: Note
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for his exercise at [https://packt.link/viVZW](https://packt.link/viVZW).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/viVZW](https://packt.link/viVZW)找到用于这个练习的代码。
- en: EF is effective for rapid database development, but for that same reason, it
    is also very dangerous. Inexperienced developers often rely on the magic that
    happens behind the scenes and therefore forget that EF cannot magically optimize
    data models to fit your specific scenario or guess that the intended query should
    perform better. The following sections will review the main mistakes that people
    make while working with EF.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: EF对于快速数据库开发非常有效，但出于同样的原因，它也非常危险。经验不足的开发人员经常依赖于幕后发生的魔法，因此忘记了EF不能神奇地优化数据模型以适应您的特定情况，或者猜测预期的查询应该执行得更好。接下来的章节将回顾在使用EF时人们常犯的主要错误。
- en: Pitfalls of EF
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EF的陷阱
- en: EF abstracts a lot of details from you, significantly simplifying your work.
    However, it also introduces the risk of not being aware of what is actually happening.
    Sometimes, you might achieve what you want, but there may be a chance that you
    are not optimally achieving your goal. The following are some of the most common
    mistakes made in EF.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: EF从你那里抽象出了很多细节，极大地简化了你的工作。然而，它也引入了不知道实际发生了什么的风险。有时，你可能会实现你想要的东西，但可能有机会你并没有最优地实现你的目标。以下是EF中常见的一些错误。
- en: Examples Setup
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例设置
- en: 'For all the following examples, assume that you will have this line initialized
    at the start:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下的例子，假设你在开始时已经初始化了这一行：
- en: '[PRE85]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Assume, too, that every example will finish with this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 还要假设每个例子都会以这个结束：
- en: '[PRE86]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Also, the data itself will be seeded (pre-generated) using the following code:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据本身将使用以下代码进行种子化（预生成）：
- en: '[PRE87]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The preceding code creates a `manufacturer` with `10,000` products, but only
    if that `manufacturer` does not already exist. The `ManufacturerName` will be
    exactly 13 characters long, and their prices will be random, but no bigger than
    the maximum price. All of this information is saved to a database before you disconnect
    from it.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个`manufacturer`，有`10,000`个产品，但只有在`manufacturer`不存在时才会创建。`ManufacturerName`将恰好是13个字符长，它们的价格将是随机的，但不会超过最高价格。所有这些信息都会在您断开连接之前保存到数据库中。
- en: Note
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is no runnable code and will be used in all the performance comparison examples.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是可运行的代码，将在所有性能比较示例中使用。
- en: 'All the examples will compare two functions achieving the same output. A summary
    of all the comparisons is done by executing this demo code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的例子都将比较两个实现相同输出的函数。通过执行这个演示代码来总结所有的比较：
- en: '[PRE88]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here, you compare in-memory and SQL filtering, lazy and eager loading, tracked
    and untracked entities, and adding entities one by one as opposed to adding them
    in bulk. In the paragraphs that follow, you will find the functions being compared,
    but every comparison will show the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将比较内存和SQL过滤，惰性和急切加载，被跟踪和未被跟踪的实体，以及逐个添加实体与批量添加实体。在接下来的段落中，你将找到被比较的函数，但每个比较都会显示以下内容：
- en: Names of a scenario
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个场景的名称
- en: Slow and fast versions for doing the same thing
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做同样事情的慢速和快速版本
- en: You will be using a stopwatch to measure execution time and print a formatted
    comparison after each run. In order to run this example, comment all lines within
    `static void Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`. You can refer to the *Summary of Results* section for the output.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用秒表来测量执行时间，并在每次运行后打印格式化的比较。为了运行这个例子，在`static void Main(string[] args)`体中注释掉所有行，除了`Program.cs`中的`Examples.PerformanceTraps.Demo.Run();`。你可以参考*结果摘要*部分查看输出。
- en: The idea behind these examples is to compare an efficient way of working with
    EF with a direct equivalent inefficient way. The slow scenario is the inefficient
    way and the fast (which is the efficient one) is the way it should be done. The
    next section will detail the efficient way of using EF.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子的背后思想是比较使用EF的高效方式和直接等效的低效方式。慢速场景是低效的方式，快速（即高效的方式）是应该做的方式。下一节将详细介绍使用EF的高效方式。
- en: Multiple Adds
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多次添加
- en: 'Sometimes, without realizing it at the time, you''ll find that you tend to
    use the most straightforward route while writing programs. For example, to add
    100 items, you may use 100 individual addition operations. However, this isn''t
    always the optimal approach and is especially inefficient when you''re using EF.
    Instead of one query for a bulk of 100, you might run a single insert 100 times.
    As an example, see the following code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，没有意识到当时，你会发现在编写程序时倾向于使用最直接的路线。例如，要添加100个项目，您可能会使用100个单独的添加操作。然而，这并不总是最佳的方法，特别是在使用EF时效率低下。与其一次查询100个，不如运行100次单个插入。例如，看下面的代码：
- en: '[PRE89]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This code creates `1,000` products and attaches them to `DbContext`. What happens
    is that those `1,000` entities inside a `DbContext` schema are tracked. Instead
    of tracking them all as a single batch, you track each individually.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了`1,000`个产品并将它们附加到`DbContext`。发生的情况是，`DbContext`模式中的这`1,000`个实体被跟踪。你不是将它们全部作为一个批次进行跟踪，而是单独跟踪每一个。
- en: 'What you want to do, though, is to work with range operations:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，你想要做的是使用范围操作：
- en: '`AddRange` or'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRange`或者'
- en: '`UpdateRange`, or'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateRange`，或者'
- en: '`RemoveRange`'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveRange`'
- en: 'A better version of the preceding code, designed to work in an optimal way
    with batches, looks like this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的版本，旨在以最佳方式与批处理一起工作的前面的代码如下：
- en: '[PRE90]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When creating multiple items with the intention to add them to the database,
    you should first add them to a list. After your list is complete, you can add
    the items as a batch to `DbSet<Product>`. You still have the problem of multiple
    adds, but the benefit of it over directly calling a `DbSet<Product>` add is that
    you no longer hit the change tracker with every add. In order to run this example,
    comment all lines within `static void` `Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建多个项目并打算将它们添加到数据库时，你应该首先将它们添加到一个列表中。在列表完成后，你可以将项目作为一个批次添加到`DbSet<Product>`。你仍然面临多次添加的问题，但与直接调用`DbSet<Product>`添加相比，它的好处在于你不再在每次添加时都触发更改跟踪器。为了运行这个示例，在`static
    void Main(string[] args)`体中的所有行都要注释掉，除了`Program.cs`中的`Examples.PerformanceTraps.Demo.Run();`。
- en: Note
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/wPLyB](https://packt.link/wPLyB).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/wPLyB](https://packt.link/wPLyB)找到此示例的代码。
- en: The next section will take a look at another pitfall—how to query properly based
    on equality of properties.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍另一个陷阱——如何基于属性的相等性进行正确的查询。
- en: Equals over ==
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等于号而不是==
- en: 'The devil lies in the details. C# developers usually do not make this mistake,
    but if you are moving between languages (especially from Java), you might be doing
    this when filtering:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 魔鬼就在细节中。C#开发人员通常不会犯这个错误，但是如果你在不同语言之间切换（尤其是从Java切换），在过滤时可能会犯这个错误：
- en: '[PRE91]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For LINQ, it is harmless. However, while using EF, this approach is not recommended.
    The problem is that EF can convert only some expressions to SQL. Usually, a complex
    method, such as equals, cannot be converted because it comes from a base object
    class, which can have multiple implementations. Instead, use a simple equality operator:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LINQ来说，这是无害的。然而，在使用EF时，这种方法是不推荐的。问题在于EF只能将一些表达式转换为SQL。通常，像equals这样的复杂方法无法转换，因为它来自一个基本对象类，该类可以有多个实现。相反，使用简单的等号运算符：
- en: '[PRE92]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The problem with the first attempt was that it would first get all products
    (that is, execute a `get` statement in SQL) and only then the filter would be
    applied (in memory, in C#). Once again, this is problematic because getting with
    a filter applied in a database-native language is optimal but getting products
    in SQL and then filtering in C# is suboptimal. The problem is solved in the second
    attempt by replacing `Equals` with the equality operator, `==`. In order to run
    this example, comment all lines within `static void Main(string[] args)` body
    except `Examples.PerformanceTraps.Demo.Run();` in `Program.cs`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试的问题在于它首先获取所有产品（即在SQL中执行`get`语句），然后才应用过滤（在C#中的内存中）。再次强调，这是有问题的，因为在数据库本地语言中应用过滤是最佳的，但在SQL中获取产品，然后在C#中进行过滤是次优的。第二次尝试通过用等号`==`替换`Equals`解决了这个问题。为了运行这个示例，在`static
    void Main(string[] args)`体中的所有行都要注释掉，除了`Program.cs`中的`Examples.PerformanceTraps.Demo.Run();`。
- en: Note
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/js2es](https://packt.link/js2es).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/js2es](https://packt.link/js2es)找到此示例的代码。
- en: Using IEnumerable over IQueryable
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IEnumerable而不是IQueryable
- en: 'Another example involves misunderstanding the concept of `IEnumerable<Product>`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子涉及对`IEnumerable<Product>`概念的误解：
- en: '[PRE93]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, you are getting products by a specific product name. But what happens
    when you assign a `DbSet<Product>` object to `Ienumerable<Product>` is that the
    `SELECT *` statement is executed. Therefore, instead of getting only the filtered
    products that you need, you will first get everything and then manually filter
    it.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在通过特定的产品名称获取产品。但是当你将`DbSet<Product>`对象分配给`Ienumerable<Product>`时，会执行`SELECT
    *`语句。因此，你不会得到你需要的过滤产品，而是首先得到所有的产品，然后手动进行过滤。
- en: 'You might wonder why you couldn''t filter right away. In some cases, it makes
    sense to build queries and pass them across methods. But when doing so, you should
    not execute them until they are completely built. Therefore, instead of `Ienumerable<Product>`,
    you should use `Iqueryable<Product>`, which is an abstraction of queried entities—an
    expression that will be converted to SQL after calling `ToList<Product>` or similar.
    An efficient version of the preceding code would look like this:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么不能立即进行过滤。在某些情况下，构建查询并将其传递给方法是有意义的。但是在这样做时，你不应该在完全构建之前执行它们。因此，你应该使用`Iqueryable<Product>`，而不是`Ienumerable<Product>`，它是被查询实体的抽象——一个在调用`ToList<Product>`或类似方法后将被转换为SQL的表达式。前面代码的高效版本如下：
- en: '[PRE94]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The latter works faster because you apply a filter in SQL and not in memory.
    In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.PerformanceTraps.Demo.Run();` in `Program.cs`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的工作速度更快，因为你在SQL中应用了一个过滤器，而不是在内存中。为了运行这个示例，在`static void Main(string[] args)`体中的所有行都要注释掉，除了`Program.cs`中的`Examples.PerformanceTraps.Demo.Run();`。
- en: Note
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ehq6C](https://packt.link/ehq6C).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ehq6C](https://packt.link/ehq6C)找到此示例的代码。
- en: Eager and lazy loading has already been mentioned, but there is still another
    complexity that is significant enough and should be covered. The next section
    details them.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 急切加载和延迟加载已经提到了，但还有另一个足够重要并且应该被覆盖的复杂性。下一节详细介绍了它们。
- en: Lazy over Eager Loading
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟加载优于急切加载
- en: In EF, you have an interesting n+1 queries problem. For example, if you get
    a list of items, then getting the list of their respective manufacturers afterward
    would result in a SQL query being executed; this would be lazy-loaded. Fortunately,
    from EF 2.1, this no longer happens by default, and it needs to be enabled explicitly.
    Assume that in the following examples, you have already enabled it.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在EF中，您会遇到一个有趣的n+1查询问题。例如，如果您获取了一个项目列表，然后获取它们各自的制造商列表，那么将会执行一个SQL查询；这将是延迟加载。幸运的是，从EF
    2.1开始，默认情况下不再发生这种情况，需要显式启用。假设在以下示例中，您已经启用了它。
- en: 'Here is a query to get any first item and its manufacturer:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个查询，用于获取任何第一个项目及其制造商：
- en: '[PRE95]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Initially, upon looking at this code, you might think that there is no issue,
    but this small chunk of code executes two SQL queries:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，看这段代码时，您可能会认为没有问题，但这小块代码执行了两个SQL查询：
- en: First, it selects the top product.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它选择顶级产品。
- en: Then it selects the associated manufacturer, along with the manufacturer ID.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后选择相关的制造商，以及制造商ID。
- en: 'To make the code more efficient, you need to explicitly specify that you do
    want the `Manufacturer` to be included with a product. A better, more efficient
    version of the code is as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更有效，您需要明确指定要包含制造商的产品。代码的更好、更有效的版本如下：
- en: '[PRE96]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The latter translates to a single query where a join between two tables is made
    and the first item from one of them is returned. In order to run this example,
    comment all lines within `static void Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 后者转换为一个查询，其中两个表之间进行了连接，并从其中一个表中返回第一个项目。为了运行此示例，请在`Program.cs`中的`static void
    Main(string[] args)`主体中注释掉除`Examples.PerformanceTraps.Demo.Run();`之外的所有行。
- en: Note
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/osrEM](https://packt.link/osrEM).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/osrEM](https://packt.link/osrEM)找到此示例使用的代码。
- en: Read-Only Queries
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读查询
- en: 'EF assumes many things when running your queries. In most cases, it gets it
    right, but there are many cases when you should be explicit and order it not to
    assume. For example, you could get all the products like this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行查询时，EF会假设很多东西。在大多数情况下，它做得很对，但也有很多情况下，您应该明确指示它不要假设。例如，您可以这样获取所有产品：
- en: '[PRE97]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'By default, EF will track all retrieved and changed entities. This is useful
    in some cases, but not always. When you have read-only queries, to just get and
    not modify entities, you would explicitly tell EF to not track any of them. An
    optimal way of getting products is as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，EF将跟踪所有检索和更改的实体。在某些情况下这很有用，但并非总是如此。当您有只读查询时，只需获取而不修改实体，您需要明确告诉EF不要跟踪它们中的任何一个。获取产品的最佳方式如下：
- en: '[PRE98]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: All this code does is run a query against the database and map the results.
    EF keeps the context clean. In order to run this example, comment all lines within
    `static void Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的全部功能就是针对数据库运行查询并映射结果。EF保持上下文清晰。为了运行此示例，请在`Program.cs`中的`static void Main(string[]
    args)`主体中注释掉除`Examples.PerformanceTraps.Demo.Run();`之外的所有行。
- en: Note
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/rSW1k](https://packt.link/rSW1k).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/rSW1k](https://packt.link/rSW1k)找到此示例使用的代码。
- en: Summary of Results
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果摘要
- en: 'The following snippet shows all results from the previous sections, in a tabulated form:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段以表格形式显示了前几节的所有结果：
- en: '[PRE99]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note that the output depends on the machine you are running the database, the
    data, and more. The point of this comparison is not to give you hard rules of
    what should be chosen, but rather to show how different approaches might save
    a lot of computing time.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出取决于您运行数据库的计算机、数据等。这种比较的目的不是给出应该选择什么的硬性规则，而是展示不同方法可能节省大量的计算时间。
- en: EF is a powerful tool that allows rapid work with databases; however, you should
    be careful with how you use it. Do not worry, even if you think you are not sure
    how the queries work internally, there is still a way to see what happens underneath.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: EF是一个强大的工具，可以快速处理数据库；但是，您在使用它时需要小心。不用担心，即使您认为不确定查询在内部是如何工作的，仍然有办法查看发生了什么。
- en: Tools to Help You Spot Problems Early On
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助您及早发现问题的工具
- en: 'EF is a toolbox in itself; it allows you to easily hook into it and track what
    is happening without any external tools. You can enable logging all the EF actions
    by adding this to the `OnConfiguring` method:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: EF本身就是一个工具箱；它允许您轻松地连接到它并跟踪发生的一切，而无需任何外部工具。您可以通过将以下内容添加到`OnConfiguring`方法来启用记录所有EF操作：
- en: '[PRE100]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If you run any of the example''s code, this will log the trace inside an `output`
    window, as follows:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行示例代码中的任何一个，将在`output`窗口中记录跟踪，如下所示：
- en: '![Figure 6.10: Debugging output after running the performance pitfalls demo'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10：运行性能陷阱演示后的调试输出'
- en: '](img/B16835_06_10.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_10.jpg)'
- en: 'Figure 6.10: Debugging output after running the performance pitfalls demo'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：运行性能陷阱演示后的调试输出
- en: The image shows what SQL is generated when EF executes the code—specifically
    selecting all products.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图像显示了EF执行代码时生成的SQL，具体选择了所有产品。
- en: This approach is useful when you want to both fully debug your application and
    know every step EF makes. It is efficient for spotting queries that you expect
    to execute as SQL but execute in memory.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要完全调试应用程序并了解EF的每一步时，这种方法非常有用。它对于发现您期望作为SQL执行但在内存中执行的查询非常有效。
- en: In the next section, you will learn about patterns that will help you organize
    database communication code.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解有助于组织数据库通信代码的模式。
- en: Working with a Database in Enterprise
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在企业中使用数据库
- en: When talking about databases, you usually imagine SQL or another language to
    talk with them. On top of that, another language (C#, in this case) is most often
    used to connect to a database to execute SQL queries. If not controlled, C# gets
    mixed with SQL, and it causes a mess of your code. Over the years, there have
    been a few patterns refined to implement the communication with a database in
    a clean way. Two such patterns, namely, Repository and CQRS, are commonly used
    to this day.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到数据库时，通常会想到SQL或其他语言来与它们交流。除此之外，另一种语言（在这种情况下是C#）通常用于连接数据库以执行SQL查询。如果不加以控制，C#会与SQL混合在一起，导致代码混乱。多年来，已经有一些模式被完善，以清晰地实现与数据库的通信。其中两种模式，即Repository和CQRS，如今仍然常用。
- en: Repository Pattern
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储库模式
- en: 'The Repository is a pattern that targets a model and defines all (if needed)
    possible CRUD operations. For example, if you take a `Product` model, you could
    have a repository with this interface:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库是一个针对模型的模式，定义了所有（如果需要）可能的CRUD操作。例如，如果您拿一个`Product`模型，您可以有一个具有这个接口的存储库：
- en: '[PRE101]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is a classical repository pattern where every database operation is abstracted
    away. This allows you to do pretty much anything you want in a database without
    worrying about the underlying database or even the technology you use to communicate
    with the database.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的存储库模式，其中每个数据库操作都被抽象化了。这使您可以在数据库中做几乎任何想做的事情，而不必担心底层数据库甚至与数据库通信的技术。
- en: Note that a `Create` method in this case returns an integer. Usually, when writing
    code, you would segregate methods that change a state from those that query something.
    In other words, do not try to both get something and change something. However,
    in this case, it is difficult to achieve because the ID of an entity will be generated
    by the database. Therefore, if you want to do something with the entity, you will
    need to get that ID. You could instead return the whole entity, but that is like
    getting a house when all you need is an address.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，“Create”方法返回一个整数。通常在编写代码时，会将改变状态的方法与查询某些内容的方法分开。换句话说，不要试图同时获取某些内容和更改某些内容。然而，在这种情况下，很难实现，因为实体的ID将由数据库生成。因此，如果您想对实体进行操作，您将需要获取该ID。您可以返回整个实体，但这就像得到一栋房子，而您只需要一个地址。
- en: 'Given you want to do the same four operations (create, delete, update, and
    get), the pattern would look like this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想执行相同的四个操作（创建、删除、更新和获取），模式将如下所示：
- en: '[PRE102]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'It looks almost the same; the only difference is the targeted entity. Given
    that you had a very simple application that just does data processing in a very
    simple way, it would make sense to make these repositories generic:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来几乎一样；唯一的区别是目标实体。鉴于您有一个非常简单的应用程序，只是以非常简单的方式进行数据处理，将这些存储库变成通用的是有意义的：
- en: '[PRE103]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, instead of `Product` or `Manufacturer`, the interface takes a generic
    `TEntity` that must be a class. You have also inherited an `IDisposable` interface
    to clean up all the resources that a repository used. This repository is still
    flawed. So, should you be able to persist any class? In that case, it would be
    nice to mark the classes that you could persist in.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，接口不再是`Product`或`Manufacturer`，而是采用了一个必须是类的通用`TEntity`。您还继承了一个`IDisposable`接口，以清理存储库使用的所有资源。这个存储库仍然有缺陷。那么，您是否能够持久化任何类？在这种情况下，标记可以持久化的类将是不错的。
- en: Yes, you can do that. When talking about a repository, you should realize that
    even if something is supposed to be saved in a database, that does not mean that
    it will be saved separately. For example, contact information will always be saved
    with a person. A person can exist without contact information but contact information
    cannot exist without a person. Both person and contact information are entities.
    However, a person is also an aggregate (that is the entity that you will be targeting
    when adding data to a database), and it can exist by itself. This means that it
    makes no sense to have a repository for contact information if storing it would
    violate data integrity. Therefore, you should create a repository not per entity,
    but per aggregate.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您可以这样做。谈到存储库时，您应该意识到，即使某些内容应该保存在数据库中，这并不意味着它们将被单独保存。例如，联系信息将始终与人一起保存。一个人可以存在而没有联系信息，但联系信息不能没有人存在。人和联系信息都是实体。然而，人也是一个聚合（即在向数据库添加数据时将要定位的实体），它可以独立存在。这意味着如果存储它会违反数据完整性，那么为联系信息创建存储库是没有意义的。因此，您应该根据聚合而不是实体创建存储库。
- en: 'What should every row in a database have? It should have an ID. An entity is
    a model that you can persist (that is, have an ID); therefore, you can define
    an interface for it:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的每一行应该有什么？它应该有一个ID。实体是一个可以持久化的模型（即具有ID）；因此，您可以为其定义一个接口：
- en: '[PRE104]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Please note that here you are using a `get`-only property because it does not
    make sense to set an ID in all cases. However, being able to identify an object
    (by getting the ID) is critical. Also note that the ID, in this case, is an integer
    because it is just a simple example and there will not be much data; but in real
    applications, it is usually either an integer or a GUID. Sometimes, an ID could
    even be both. In those cases, a consideration to make an entity interface generic
    (that is, taking generic `TId`) could be made.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里使用的是一个只读属性，因为在所有情况下设置ID都是没有意义的。然而，能够通过获取ID来识别对象是至关重要的。还要注意，在这种情况下，ID是一个整数，因为这只是一个简单的例子，数据量不会很大；但在实际应用中，通常是整数或GUID。有时，ID甚至可以是两者兼而有之。在这些情况下，可以考虑使实体接口成为通用的（即采用通用的`TId`）。
- en: 'What about an aggregate? An aggregate is an entity; you would therefore write
    the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合怎么样？聚合是一个实体；因此，您将编写以下内容：
- en: '[PRE105]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In this scenario, you would then just write `Person: IAggregate, ContactInfo:
    IEntity`. If you apply the same principles to the two tables you had, you will
    get `Product: IAggregate, Manufacturer: IAggregate` because the two can be saved
    separately.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，您只需编写`Person: IAggregate, ContactInfo: IEntity`。如果您将相同的原则应用于您拥有的两个表，您将得到`Product:
    IAggregate, Manufacturer: IAggregate`，因为这两个可以分别保存。'
- en: Note
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no runnable code here; however, you will be using it in the upcoming
    exercise. You can find the code used for this example at [https://packt.link/JDLAo](https://packt.link/JDLAo).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有可运行的代码；但是，您将在即将进行的练习中使用它。您可以在[https://packt.link/JDLAo](https://packt.link/JDLAo)找到此示例使用的代码。
- en: Writing a repository for every aggregate might become a tedious job, especially
    if there is no special logic to the way persistence is done. In the upcoming exercise,
    you will learn how to generalize and reuse repositories.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个聚合编写存储库可能会变得乏味，特别是如果没有特殊逻辑来完成持久化。在即将进行的练习中，您将学习如何泛化和重用存储库。
- en: 'Exercise 6.04: Creating a Generic Repository'
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04：创建通用存储库
- en: Being coupled to an ORM may make your business logic harder to test. Also, due
    to persistence being so rooted at the core of most applications, it might be a
    hassle to change an ORM. For those reasons, you may want to put an abstraction
    layer in between business logic and a database. If you use `DbContext` as is,
    you couple yourself to `EntityFramework`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 与ORM耦合可能会使您的业务逻辑更难以测试。此外，由于持久性根植于大多数应用程序的核心，更改ORM可能会很麻烦。出于这些原因，您可能希望在业务逻辑和数据库之间放置一个抽象层。如果您使用`DbContext`，则将自己与`EntityFramework`耦合。
- en: 'In this exercise, you will learn how to create a database operations abstraction—a
    generic repository—that will work on any entity and support create, delete, update,
    and get operations. Implement those methods one by one:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，您将学习如何创建一个数据库操作抽象——通用存储库，它将适用于任何实体并支持创建、删除、更新和获取操作。逐一实现这些方法：
- en: 'First, create a generic repository class that takes `DbContext` in the constructor:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个通用存储库类，该类在构造函数中接受`DbContext`：
- en: '[PRE106]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `context.Set<TEntity>()` allows getting a table-model binding and then using
    it throughout the repository. Another interesting point is that you didn't have
    to supply a concrete `DbContext` as it uses generic entities, and a generic repository
    is applicable to every kind of context.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Set<TEntity>()`允许获取表模型绑定，然后在整个存储库中使用它。另一个有趣的地方是，您不必提供具体的`DbContext`，因为它使用通用实体，通用存储库适用于每种类型的上下文。'
- en: 'To implement a `Create` operation, add a method to insert a single aggregate:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`Create`操作，请添加一个插入单个聚合的方法：
- en: '[PRE107]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To implement a `Delete` operation, add a method to delete an aggregate by ID:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`Delete`操作，请添加一个按ID删除聚合的方法：
- en: '[PRE108]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To implement an `Update` operation, add a method to update an entity by overriding
    the old values with the values of a new entity:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`Update`操作，请添加一个通过使用新实体的值覆盖旧值来更新实体的方法：
- en: '[PRE109]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'To implement a `Read` operation, add a method to get a single entity by ID:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`Read`操作，请添加一个按ID获取单个实体的方法：
- en: '[PRE110]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'A `Read` operation should also support getting all the entities. So, add a
    method to get all entities:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Read`操作还应支持获取所有实体。因此，请添加一个获取所有实体的方法：'
- en: '[PRE111]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Passing a `DbContext` to a constructor will open a database connection. As
    soon as you are done using a database, you should disconnect. In order to support
    a conventional disconnect, implement an `IDisposable` pattern:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DbContext`传递给构造函数将打开数据库连接。一旦您使用完数据库，就应该断开连接。为了支持常规断开连接，实现一个`IDisposable`模式：
- en: '[PRE112]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To test whether the generic repository works, create a new `Run()` method:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试通用存储库是否有效，请创建一个新的`Run()`方法：
- en: '[PRE113]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Inside the `Run()` method, initialize a new repository for the `Manufacturer` entity:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Run()`方法内，为`Manufacturer`实体初始化一个新的存储库：
- en: '[PRE114]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Test whether the `Create` operation works, by inserting a new `manufacturer`
    as shown in the following code:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过插入新的`manufacturer`来测试`Create`操作是否有效，如下所示：
- en: '[PRE115]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Test whether the `Update` operation works, by updating the manufacturer''s
    name as follows:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更新制造商的名称来测试`Update`操作是否有效，如下所示：
- en: '[PRE116]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Test whether the `Read` operation works on a single entity, by retrieving the
    new manufacturer from a database and print it:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从数据库中检索新制造商并打印它来测试`Read`操作是否有效：
- en: '[PRE117]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You should see the following output:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE118]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Test whether the `Read` operation works on all entities by getting the count
    of all manufacturers with the following code:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下代码获取所有制造商的计数，测试`Read`操作是否有效：
- en: '[PRE119]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'You can test whether the `Delete` operation works by deleting the new manufacturer
    as follows:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过删除新制造商来测试`Delete`操作是否有效，如下所示：
- en: '[PRE120]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In order to see the impact of delete (one less manufacturer is expected), compare
    the counts as follows:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看删除的影响（预期减少一个制造商），请按以下方式比较计数：
- en: '[PRE121]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In order to run this exercise, comment all lines within `static void Main(string[]
    args)` body except `Exercises.Exercise04.Demo.Run();` in `Program.cs`. You should
    see the following output upon running the `dotnet run` command:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行此练习，请在`Program.cs`中的`static void Main(string[] args)`主体中注释掉除`Exercises.Exercise04.Demo.Run();`之外的所有行。运行`dotnet
    run`命令后，您应该看到以下输出：
- en: '[PRE122]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Repositories used to be the way to go (maybe 10-20 years ago) for implementing
    interactions with a database because these were a well-abstracted way to make
    calls against a database. An abstraction from a database would enable people to
    change the underlying database provider if needed. If a database changes, only
    the class that implements the interface will change but whatever consumes the
    interface will remain unaffected.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，使用存储库是实现与数据库交互的一种方式（也许是10-20年前），因为这是一种很好的抽象方式来调用数据库。与数据库的抽象将使人们能够根据需要更改底层数据库提供程序。如果数据库更改，只有实现接口的类会更改，但使用接口的任何内容都不会受到影响。
- en: Looking back at `DbContext` and `DbSet`, you might ask why those can't be used
    directly. The answer is that you can, and it serves a similar purpose as repositories
    do. That is why the repository pattern should only be used if your queries are
    sufficiently complex (meaning it's several lines long).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾`DbContext`和`DbSet`，您可能会问为什么不能直接使用它们。答案是您可以，并且它的作用与存储库相似。这就是为什么只有在您的查询足够复杂（意味着它有几行长）时，才应该使用存储库模式。
- en: Note
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/jDR0C](https://packt.link/jDR0C).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/jDR0C](https://packt.link/jDR0C)找到此练习使用的代码。
- en: The next section will explore another benefit of EF that is, local database
    testing.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将探索EF的另一个好处，即本地数据库测试。
- en: Testing Data Persistence Logic Locally
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地测试数据持久性逻辑
- en: When developing software, you should always have quality and testability in
    mind. The problem with database testability is that it often requires a physical
    machine to host a database somewhere. However, you do not always have access to
    such a setup, especially at the start of a project.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，您应该始终牢记质量和可测试性。数据库可测试性的问题在于，它通常需要一个物理机器来托管数据库。然而，您并不总是能够访问这样的设置，特别是在项目开始阶段。
- en: 'Thankfully, EF is very flexible and offers a few packages to help out here.
    There are three main ways of testing with EF—`InMemory`, using SQLite, and calling
    an actual database. You have already seen plenty of demos calling a physical database.
    Next, you''ll explore the other two: In-Memory and SQLite.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，EF非常灵活，并提供了一些包来帮助。使用EF进行测试有三种主要方式——`InMemory`，使用SQLite，以及调用实际数据库。您已经看到了很多调用物理数据库的演示。接下来，您将探索另外两种：In-Memory和SQLite。
- en: In-Memory Database Provider
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存数据库提供程序
- en: An in-memory database provider is just a bunch of in-memory lists available
    internally that make no queries whatsoever to a database. Usually, even garbage
    collection eliminates its state. Before you can continue, just like all other
    database providers, you will need to add one to your project.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 内存数据库提供程序只是一堆内部可用的内存列表，根本不会对数据库进行任何查询。通常，即使垃圾回收也会消除其状态。在继续之前，就像所有其他数据库提供程序一样，您需要将其添加到项目中。
- en: 'Run the following command:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE123]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This command enables you to use an in-memory database when supplying `DbContextOptionsBuilder`
    with the `UseInMemoryDatabase` option, as done in the following snippet:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当在以下片段中向`DbContextOptionsBuilder`提供`UseInMemoryDatabase`选项时，此命令使您能够使用内存数据库：
- en: '[PRE124]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In this snippet, you've used an options builder and created a new, isolated,
    in-memory database. The most important part here is the `builder.UseInMemoryDatabase();`
    method, which specifies that an in-memory database should be created. Also, note
    the `Guid.NewGuid().ToString()` argument. This argument is for a database name.
    In this case, it means that every time you call that line you will generate a
    unique database name, thus ensuring isolation between the new test databases.
    If you don't use this argument, you risk affecting a context under the test state.
    You want to avoid that for testing scenarios. When it comes to testing, starting
    with a fresh state is the right way to go.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，您使用了一个选项构建器并创建了一个新的、隔离的内存数据库。这里最重要的部分是`builder.UseInMemoryDatabase();`方法，它指定应创建一个内存数据库。还要注意`Guid.NewGuid().ToString()`参数。这个参数是用于数据库名称的。在这种情况下，这意味着每次调用该行时，您将生成一个唯一的数据库名称，从而确保新测试数据库之间的隔离。如果不使用这个参数，您可能会影响测试状态下的上下文。在测试方案中，从一个新的状态开始是正确的方法。
- en: In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.TestingDb.Demo.Run();` in `Program.cs`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个例子，在`Program.cs`中的`static void Main(string[] args)`体内注释掉除`Examples.TestingDb.Demo.Run();`之外的所有行。
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/mOodJ](https://packt.link/mOodJ).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/mOodJ](https://packt.link/mOodJ)找到此示例使用的代码。
- en: 'To test whether a generic repository for manufacturers works (assume that the
    preceding code will be reused), first create a new repository:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试制造商的通用存储库是否有效（假设前面的代码将被重用），首先创建一个新的存储库：
- en: '[PRE125]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The power of this pattern is that a new entity repository is simply specified
    as a different generic argument. If you wanted to test a manufacturer, you would
    not need to design a repository class for it. All you would have to do is to initialize
    a repository with `Manufacturer` passed as a generic argument, for example `new
    Repository<Manfacturer>(db)`.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的强大之处在于，一个新的实体存储库只需指定为不同的泛型参数即可。如果您想测试制造商，您不需要为其设计一个存储库类。您只需要使用`Manufacturer`作为泛型参数初始化存储库，例如`new
    Repository<Manfacturer>(db)`。
- en: 'Now, create a test `product` and save it:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个测试`product`并保存它：
- en: '[PRE126]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'To test the price update method, update `product.Price` and call the `Update` method:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试价格更新方法，请更新`product.Price`并调用`Update`方法：
- en: '[PRE127]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In order to check whether a product was created successfully, call a `Get`
    method and pass the new product `id`:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查产品是否成功创建，请调用`Get`方法并传递新产品的`id`：
- en: '[PRE128]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Type the following to print the product to the console:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容以将产品打印到控制台：
- en: '[PRE129]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The output will get displayed as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示如下：
- en: '[PRE130]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now you need to check whether delete works. So, create a new product:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要检查删除是否有效。因此，创建一个新产品：
- en: '[PRE131]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Check the current count of products in a repository:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 检查存储库中产品的当前数量：
- en: '[PRE132]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now delete the product:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 现在删除产品：
- en: '[PRE133]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Check the count once again, comparing it with the previous one:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查数量，与之前的数量进行比较：
- en: '[PRE134]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.TestingDb.Demo.Run();` in `Program.cs`. The following
    output will get displayed:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个例子，在`Program.cs`中的`static void Main(string[] args)`体内注释掉除`Examples.TestingDb.Demo.Run();`之外的所有行。将显示以下输出：
- en: '[PRE135]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/DGjf2](https://packt.link/DGjf2).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/DGjf2](https://packt.link/DGjf2)找到此示例使用的代码。
- en: Using an In-Memory provider has its limitations. Up next, you will learn another
    alternative to testing code depending on the `DbContext` with fewer limitations.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存提供程序有其局限性。接下来，您将学习另一种依赖于`DbContext`的测试代码的替代方案，它具有更少的限制。
- en: SQLite Database Provider
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite数据库提供程序
- en: The problem with in-memory providers is that you cannot run any SQL statements
    on them. If you do, the code fails. Also, an in-memory provider is all about in-memory
    data structures and has nothing to do with SQL. SQLite database provider is free
    from those problems. The only issue it has is that SQLite is a dialect of SQL,
    so some raw SQL queries of other providers might not work.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 内存提供程序的问题在于您无法在其上运行任何SQL语句。如果这样做，代码将失败。此外，内存提供程序完全是关于内存数据结构，与SQL无关。SQLite数据库提供程序没有这些问题。它唯一的问题是SQLite是SQL的一个方言，因此其他提供程序的一些原始SQL查询可能无法工作。
- en: 'To try out SQLite, run the following command in the VS Code terminal:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试SQLite，请在VS Code终端中运行以下命令：
- en: '[PRE136]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The installed NuGet allows you to use SQLite provider when creating a `DbContext`
    schema, like this:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的NuGet允许您在创建`DbContext`模式时使用SQLite提供程序，就像这样：
- en: '[PRE137]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In the preceding snippet, you have created a SQL connection, specifying that
    an in-memory SQLite database will be used. The `Db.Database.EnsureCreated()` was
    needed because the database would not always be created using that connection
    string. In order to run this example, comment all lines within `static void` `Main(string[]
    args)` body except `Examples.TestingDb.Demo.Run();` in `Program.cs`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，您已经创建了一个SQL连接，指定将使用内存中的SQLite数据库。`Db.Database.EnsureCreated()`是必需的，因为使用该连接字符串不会始终创建数据库。为了运行此示例，在`Program.cs`中的`static
    void Main(string[] args)`主体中除了`Examples.TestingDb.Demo.Run();`之外，注释掉所有行。
- en: Note
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/rW3JS](https://packt.link/rW3JS).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/rW3JS](https://packt.link/rW3JS)找到此示例中使用的代码。
- en: 'If you were to create `ProductsRepository` and run the same code from the `InMemory`
    database example, you would get an error: `SQLite Error 19: ''FOREIGN KEY constraint
    failed''`. This is due to a missing manufacturer with an ID of 1 to which you
    are trying to link the new test products. This is a prime example of why the EF
    in-memory provider is not that reliable.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您要创建`ProductsRepository`并从`InMemory`数据库示例运行相同的代码，您将收到错误消息：`SQLite Error 19:
    ''FOREIGN KEY constraint failed''`。这是由于缺少ID为1的制造商，您正在尝试将新的测试产品链接到该制造商。这是EF内存提供程序不太可靠的一个典型例子。'
- en: 'In order to fix this, add the following just before creating a test product:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在创建测试产品之前添加以下内容：
- en: '[PRE138]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The only thing to remember is to clean up. After you are done using a database
    context that was created using a SQL connection, do not forget to dispose of that
    connection this way:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要记住的是清理。在使用使用SQL连接创建的数据库上下文后，不要忘记以这种方式处理该连接：
- en: '[PRE139]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: At this point, you already know how to use `DbContext` in many different ways
    in order to communicate with a database. However, a dependency on a third-party
    library (EF Core) and unit testing maybe be tricky if all depends on a specific
    ORM. In the next paragraph, you will learn how to escape such a dependency.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经知道如何以多种不同的方式使用`DbContext`与数据库进行通信。但是，如果所有内容都依赖于特定的ORM，那么对第三方库（EF Core）和单元测试的依赖可能会有些棘手。在下一段中，您将学习如何摆脱这种依赖。
- en: A Few Words on Repository
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于存储库的几句话
- en: The Repository pattern works for simple CRUD applications because it can further
    simplify database interactions. However, given you are using EF, it is already
    simple enough to interact with a database and another layer of abstraction is
    not always justified. After all, one of the key reasons why the Repository pattern
    caught so much attention is that it allows you to escape database interactions.
    However, the EF in-memory provider allows that too, so there is even less of a
    reason to use a repository.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式适用于简单的CRUD应用程序，因为它可以进一步简化数据库交互。但是，如果您使用EF，与数据库交互已经足够简单，不一定需要另一层抽象。毕竟，存储库模式引起如此多关注的一个关键原因是它允许您摆脱数据库交互。但是，EF内存提供程序也允许这样做，因此使用存储库的理由甚至更少。
- en: The generic repository pattern is a useful abstraction. It abstracts away database
    interaction under a simple interface. However, for non-trivial scenarios, you
    are likely to need your custom CRUD operations and then you would create a non-generic
    repository. In fact, non-generic repositories are the recommended approach (given
    you want to implement the pattern) because you rarely want all the CRUD methods
    for all the entities. It is not rare to end up with as little as a single method
    on a repository. If you use a generic repository, you could still make all methods
    virtual and override them, but then you will end up overriding all the time or
    having methods that you don't use. It is less than ideal.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 通用存储库模式是一个有用的抽象。它将数据库交互抽象为一个简单的接口。但是，对于非平凡的场景，您可能需要自定义CRUD操作，然后您将创建一个非通用存储库。实际上，非通用存储库是推荐的方法（如果您想要实现该模式），因为您很少希望为所有实体使用所有CRUD方法。最终，您可能只会在存储库上拥有一个方法。如果您使用通用存储库，您仍然可以使所有方法虚拟并重写它们，但是您最终会一直重写或拥有您不使用的方法。这不是理想的。
- en: The following section will explore a different pattern that strives to make
    simple, optimal interactions per database operation—CQRS.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨另一种旨在实现每个数据库操作的简单、最佳交互的模式——CQRS。
- en: Query and Command Handlers Patterns
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询和命令处理程序模式
- en: 'Command Query Responsibility Segregation (CQRS) is a pattern that aims to separate
    reads from writes. Instead of one class for all CRUD operations, you will have
    one class per CRUD method. On top of that, instead of one entity that fits all,
    you will have request and query object models dedicated to those specific scenarios.
    In CQRS, all database operations can be classified into two:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）是一种旨在将读操作与写操作分离的模式。您将拥有一个类来处理所有CRUD操作，而是每个CRUD方法都有一个类。除此之外，您将拥有专门用于特定场景的请求和查询对象模型，而不是一个适用于所有情况的实体。在CQRS中，所有数据库操作可以分为两类：
- en: 'Command: An operation that changes state (create, update, delete).'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令：改变状态的操作（创建、更新、删除）。
- en: 'Query: An operation that gets something, without affecting the state.'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询：获取某些内容而不影响状态的操作。
- en: '![Figure 6.11: CQRS pattern as used by Martin Fowler'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：Martin Fowler使用的CQRS模式'
- en: '](img/B16835_06_11.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_11.jpg)'
- en: 'Figure 6.11: CQRS pattern as used by Martin Fowler'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：Martin Fowler使用的CQRS模式
- en: Note
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The original source for this diagram can be found at [https://www.martinfowler.com/bliki/CQRS.html](https://www.martinfowler.com/bliki/CQRS.html).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表的原始来源可以在[https://www.martinfowler.com/bliki/CQRS.html](https://www.martinfowler.com/bliki/CQRS.html)找到。
- en: 'In order to implement a command handler for creating a product, you would start
    by defining the command. What does the product need? It needs a name and a price,
    as well as a manufacturer. The ID for the create command is not needed (because
    the database generates it) and the manufacturer property can be removed as well
    because you will not make use of navigational properties. The name of a CQRS operation
    is made up of three parts—operation name, entity name, and `command` or `query`
    suffix. You are creating a product; therefore, the model will be called `CreateProductCommand`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现创建产品的命令处理程序，你将首先定义命令。产品需要什么？它需要一个名称和一个价格，以及一个制造商。不需要创建命令的ID（因为数据库会生成它），制造商属性也可以被移除，因为你不会使用导航属性。CQRS操作的名称由三部分组成——操作名称、实体名称和`command`或`query`后缀。你正在创建一个产品，因此模型将被称为`CreateProductCommand`：
- en: '[PRE140]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Next, you will create a handler of this command. In the constructor, pass the
    database context. In the `Handle` method, pass `CreateProductCommand`:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个处理这个命令的处理程序。在构造函数中，传递数据库上下文。在`Handle`方法中，传递`CreateProductCommand`：
- en: '[PRE141]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Handlers are simple, single-method objects that implement all that is needed
    to process a command or a query. In order to test things, you''ll also create
    a `GetProductQueryHandler` class:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序是简单的、单方法的对象，它实现了处理命令或查询所需的一切。为了测试事情，你还将创建一个`GetProductQueryHandler`类：
- en: '[PRE142]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The idea is almost the same, except that, in this case, querying is so simple
    that the optimal model for it is a simple integer. In some scenarios, if you can
    predict the complexity growing and the query becoming more complex, then even
    such an integer could go to a model (in order to avoid a breaking change of query
    format changing completely—from a primitive integer to an object).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法几乎是一样的，只是在这种情况下，查询是如此简单，以至于它的最佳模型是一个简单的整数。在某些情景中，如果你能预测复杂性增长和查询变得更加复杂，那么甚至这样一个整数也可以成为一个模型（以避免查询格式完全改变的破坏性变化——从原始整数到对象）。
- en: 'In order to see whether the command and query work, you will be using an in-memory
    database context once again. So, create a command to create a new product, a handler
    to handle it, execute it, and print the results as follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看命令和查询是否有效，你将再次使用内存数据库上下文。因此，创建一个命令来创建一个新产品，一个处理程序来处理它，执行它，并打印结果如下：
- en: '[PRE143]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Create a query to get the created product and a handler to execute the query:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个查询来获取创建的产品和一个处理程序来执行查询：
- en: '[PRE144]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.Cqrs.Demo.Test();` in `Program.cs`. The output will
    be displayed as follows:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个示例，在`static void Main(string[] args)`主体中注释掉除`Examples.Cqrs.Demo.Test();`之外的所有行。输出将显示如下：
- en: '[PRE145]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/Ij6J8](https://packt.link/Ij6J8).
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/Ij6J8](https://packt.link/Ij6J8)找到本示例使用的代码。
- en: You might have wondered why, after so many demos, the `ProductId` is still `1`.
    That's because it is an in-memory database—one that you create fresh for a new
    test every time. Since you are starting with an empty database every time, the
    first addition of a new entity to a database results in a new item with an ID
    of 1.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想为什么在这么多演示之后，“ProductId”仍然是“1”。那是因为这是一个内存数据库——每次都为新测试创建一个新的。由于每次都是从空数据库开始，向数据库添加新实体的第一个结果是一个ID为1的新项目。
- en: You might wonder if you made some changes to a database or added a column to
    it, and how it would impact the rest of the codebase and the business logic. The
    next section will detail these scenarios.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如果你对数据库进行了一些更改或添加了一个列，它会如何影响代码库和业务逻辑的其余部分。下一节将详细介绍这些情景。
- en: Separating the Database Model from the Business Logic (Domain) Model
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据库模型与业务逻辑（域）模型分离
- en: Databases often change. However, should that impact the rest of the codebase?
    Should the fact that a column type changed, or another column was added affect
    the business logic? There is no straight answer to that. It all depends on the
    project scope, the resources, and the team's maturity. However, if you are working
    on a medium or a big project, you should consider segregating the database and
    domain completely. This does not only mean that different logic should be placed
    in different projects, but it also means that those projects should be decoupled
    from one another.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库经常发生变化。然而，这是否应该影响代码库的其余部分？列类型的更改或其他列的添加是否应该影响业务逻辑？这并没有直接的答案。这一切取决于项目范围、资源和团队的成熟度。然而，如果你正在进行一个中等或大型项目，你应该考虑完全隔离数据库和域。这不仅意味着不同的逻辑应该放在不同的项目中，而且还意味着这些项目应该彼此解耦。
- en: It is okay for a database layer to consume a domain layer, but it is not okay
    for the domain layer to do the same. If you want a complete separation between
    the two, you will have to introduce an anti-corruption layer. It is a concept
    that says not to consume foreign models and instead map them as soon as they hit
    the public component of that layer. The idea is that all interfaces should be
    domain-specific (that is, work with domain models). However, for a database communication
    implementation, internally, you will be working with database entities instead
    of domain models. This requires mapping one to another (when taking input or returning
    output).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库层可以消耗领域层，但领域层不可以这样做。如果你想在两者之间实现完全分离，你将不得不引入一个反腐层。这个概念是说不要消耗外部模型，而是在它们到达该层的公共组件时立即映射它们。这个想法是所有接口都应该是领域特定的（即与领域模型一起工作）。然而，对于数据库通信实现，内部上，你将使用数据库实体而不是领域模型。这需要将一个映射到另一个（在输入或返回输出时）。
- en: In cases where database entities change completely, the domain-specific interface
    will remain the same. Only the mapping will change, which will prevent the database
    from impacting anything else. It is not an easy thing to grasp and implement for
    a beginner. It is recommended that you ignore that for now; your personal project
    scope is not worth the effort and you might not see any benefit.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库实体完全改变的情况下，领域特定接口将保持不变。只有映射会改变，这将防止数据库影响其他任何东西。这对于初学者来说并不容易理解和实现。建议你现在忽略它；你个人项目的范围不值得这样做，你可能看不到任何好处。
- en: This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an activity.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本节的理论部分。在接下来的部分中，您将通过一个活动将其付诸实践。
- en: 'Activity 6.01: Tracking System for Trucks Dispatched'
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：已派遣卡车的跟踪系统
- en: A logistics company has hired you to keep track of dispatched trucks. A single
    dispatch includes the current location of a truck, the truck's ID, and the driver's
    ID. In this activity, you will create a database for dispatched trucks, seed it
    with a few dispatches, and prove it works by getting all possible data from it.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 一家物流公司已经雇佣了你来跟踪已派遣的卡车。一个单独的派遣包括卡车的当前位置、卡车的ID和司机的ID。在这个活动中，您将为已派遣的卡车创建一个数据库，用一些派遣进行种子播种，并通过从中获取所有可能的数据来证明它的工作。
- en: 'You will create two classes (`Truck` and `Person`), which consist of the following objects:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建两个类（`Truck`和`Person`），其中包括以下对象：
- en: '`Truck`: `Id`, `Brand`, `Model`, `YearOfMaking`'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Truck`：`Id`，`Brand`，`Model`，`YearOfMaking`'
- en: '`Person`: `Id`, `Name`, `DoB`'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person`：`Id`，`Name`，`DoB`'
- en: All tables are stored in the `TruckLogistics` database, in the `TruckLogistics` schema.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表都存储在`TruckLogistics`数据库中，位于`TruckLogistics`模式中。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Create a `Person` class.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Person`类。
- en: Create a `Truck` class.
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Truck`类。
- en: Create a `TruckDispatch` class.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TruckDispatch`类。
- en: Create a `TruckDispatchDbContext` schema with three tables.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TruckDispatchDbContext`模式，其中包括三个表。
- en: Create a connection string (ideally from environment variables).
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个连接字符串（最好来自环境变量）。
- en: Add a database migration.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加数据库迁移。
- en: Generate a database from the migration.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从迁移生成数据库。
- en: Connect to a database.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库。
- en: Seed the database with the initial data.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用初始数据对数据库进行种子播种。
- en: Get all data from the database.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库获取所有数据。
- en: Print the results.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果。
- en: Dispose of the `TruckDispatchesDbContext` schema (that is, disconnect).
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`TruckDispatchesDbContext`模式（即断开连接）。
- en: 'After completing these steps correctly, you should see the following output:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 正确完成这些步骤后，您应该看到以下输出：
- en: '[PRE146]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In order to run this activity, comment all lines within `static void Main(string[]
    args)` body except `Activities.Activity01.Demo.Run()`; in `Program.cs`.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个活动，在`static void Main(string[] args)`主体中注释掉所有行，除了`Program.cs`中的`Activities.Activity01.Demo.Run()`。
- en: 'The database should look like this:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库应该是这样的：
- en: '![Figure 6.12: Generated TruckLogistics database (simplified for brevity)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12：生成的TruckLogistics数据库（为简洁起见简化）'
- en: '](img/B16835_06_12.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_12.jpg)'
- en: 'Figure 6.12: Generated TruckLogistics database (simplified for brevity)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：生成的TruckLogistics数据库（为简洁起见简化）
- en: 'And the following migration files (similar, not exact) will be created:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将创建以下迁移文件（类似但不完全相同）：
- en: '![Figure 6.13: Migration files created for the solution'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13：为解决方案创建的迁移文件'
- en: '](img/B16835_06_13.jpg)'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_06_13.jpg)'
- en: 'Figure 6.13: Migration files created for the solution'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：为解决方案创建的迁移文件
- en: Note
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到此活动的解决方案。
- en: With the successful execution of this activity, you should now have solid know-how
    of how EF is used for rapidly developing solutions integrated with a database.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 通过成功执行此活动，您现在应该对如何使用EF快速开发与数据库集成的解决方案有扎实的了解。
- en: Summary
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you covered the benefits of an ORM and how to talk with a database
    from C# using the EF Core 6\. EF allowed you to abstract a database using `DbContext`
    and include abstractions to tables, `DbSet`.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了ORM的好处以及如何使用EF Core 6从C#与数据库交互。EF允许您使用`DbContext`来抽象数据库，并包括对表、`DbSet`的抽象。
- en: You experienced the simplicity of consuming a database using EF, which felt
    almost the same as writing LINQ queries. The only difference was the initial setup
    of a connection using a database context. You learned the client input should
    not be trusted, but ORMs allow you to consume queries with confidence because
    they take security into consideration and protect you from SQL injection. However,
    the way you connect to a database (that is, the connection string) has to be secured,
    and for that reason, you must store it just like any other secret and not hardcode
    it. You also studied the most common pitfalls when working with EF and tools that
    could help avoid those pitfalls. This chapter has given you enough skills to create
    and consume databases using EF.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 您体验了使用EF消耗数据库的简单性，这几乎与编写LINQ查询相同。唯一的区别是使用数据库上下文进行连接的初始设置。您学到了客户端输入不应该被信任，但ORM允许您放心地消耗查询，因为它们考虑了安全性并保护您免受SQL注入。然而，连接到数据库的方式（即连接字符串）必须得到保护，因此，您必须像任何其他秘密一样存储它，而不是硬编码它。您还学习了在使用EF时最常见的陷阱以及可以帮助避免这些陷阱的工具。本章为您提供了足够的技能来使用EF创建和消耗数据库。
- en: In the next chapter, you will be focusing more on web applications—what they
    are, and how to build them.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将更多地关注Web应用程序——它们是什么，以及如何构建它们。
