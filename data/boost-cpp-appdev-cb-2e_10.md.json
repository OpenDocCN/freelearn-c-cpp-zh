["```cpp\n#include <something_that_defines_macros>\n#if !defined(__clang__) \\\n    && !defined(__ICC) \\\n    && !defined(__INTEL_COMPILER) \\\n    && (defined(__GNUC__) || defined(__GNUG__))\n\n// GCC specific\n\n#endif\n```", "```cpp\n#include <boost/predef/compiler.h>\n```", "```cpp\n#if BOOST_COMP_GNUC\n\n// GCC specific\n\n#endif\n```", "```cpp\n#if defined(BOOST_COMP_GNUC) // Wrong!\n\n// GCC specific\n\n#endif\n```", "```cpp\n#include <boost/predef/os.h>\n#include <boost/predef/compiler.h>\n\n#if BOOST_COMP_GNUC && BOOST_OS_LINUX && !BOOST_OS_ANDROID\n\n// Do something for non Android Linux.\n\n#endif\n```", "```cpp\n#include <boost/config.hpp>\n```", "```cpp\n#ifdef BOOST_HAS_INT128\n```", "```cpp\ntypedef boost::int128_type int_t;\ntypedef boost::uint128_type uint_t;\n\ninline int_t mul(int_t v1, int_t v2, int_t v3) {\n    return v1 * v2 * v3;\n}\n```", "```cpp\n#else // #ifdef BOOST_HAS_INT128\n\n#ifdef BOOST_NO_LONG_LONG\n#error \"This code requires at least int64_t support\"\n#endif\n```", "```cpp\nstruct int_t { boost::long_long_type hi, lo; };\nstruct uint_t { boost::ulong_long_type hi, lo; };\n\ninline int_t mul(int_t v1, int_t v2, int_t v3) {\n    // Some hand written math.\n    // ...\n}\n\n#endif // #ifdef BOOST_HAS_INT128\n```", "```cpp\nboost::long_long_type  \nboost::ulong_long_type  \n```", "```cpp\nboost::int128_type \nboost::uint128_type \n```", "```cpp\n#include <boost/config.hpp> \n```", "```cpp\n#if !defined(BOOST_NO_RTTI) \\\n    && !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)\n\n#include <typeindex>\nusing std::type_index;\n\ntemplate <class T>\ntype_index type_id() {\n    return typeid(T);\n}\n```", "```cpp\n#else\n\n#include <cstring>\n#include <iosfwd> // std::basic_ostream\n#include <boost/current_function.hpp>\n\nstruct type_index {\n    const char * name_;\n\n    explicit type_index(const char* name)\n        : name_(name)\n    {}\n\n    const char* name() const { return name_; }\n};\n\ninline bool operator == (type_index v1, type_index v2) {\n    return !std::strcmp(v1.name_, v2.name_);\n}\n\ninline bool operator != (type_index v1, type_index v2) {\n    return !(v1 == v2);\n}\n```", "```cpp\ntemplate <class T>\ninline type_index type_id() {\n    return type_index(BOOST_CURRENT_FUNCTION);\n}\n\n#endif\n```", "```cpp\n#include <cassert>\n\nint main() {\n    assert(type_id<unsigned int>() == type_id<unsigned>());\n    assert(type_id<double>() != type_id<long double>());\n}\n```", "```cpp\n type_index type_id() [with T = double]\n```", "```cpp\n#include <boost/type_index.hpp>\n\nvoid test() {\n    using boost::typeindex::type_id;\n\n    assert(type_id<unsigned int>() == type_id<unsigned>());\n    assert(type_id<double>() != type_id<long double>());\n}\n```", "```cpp\n#include <boost/config.hpp> \n```", "```cpp\n#if !defined(BOOST_NO_CXX11_CONSTEXPR) \\\n    && !defined(BOOST_NO_CXX11_HDR_ARRAY)\n\ntemplate <class T>\nconstexpr int get_size(const T& val) {\n    return val.size() * sizeof(typename T::value_type);\n}\n```", "```cpp\n#else\n#error \"This code requires C++11 constexpr and std::array\"\n#endif\n```", "```cpp\n#include <array>\n\nint main() {\n    std::array<short, 5> arr;\n    static_assert(get_size(arr) == 5 * sizeof(short), \"\");\n\n    unsigned char data[get_size(arr)];\n}\n```", "```cpp\ntemplate <class T, T Value> \nstruct integral_constant { \n    BOOST_STATIC_CONSTEXPR T value = Value; \n\n    BOOST_CONSTEXPR operator T() const { \n        return this->value; \n    } \n}; \n```", "```cpp\nchar array[integral_constant<int, 10>()]; \n```", "```cpp\n#include <boost/config.hpp>\n\nclass move_nothrow {\n    // Some class class members go here.\n    // ...\n\npublic:\n    move_nothrow() BOOST_NOEXCEPT;\n    move_nothrow(move_nothrow&&) BOOST_NOEXCEPT\n        // Members initialization goes here.\n        // ...\n    {}\n\n    move_nothrow& operator=(move_nothrow&&) BOOST_NOEXCEPT {\n        // Implementation goes here.\n        // ...\n        return *this;\n    }\n\n    move_nothrow(const move_nothrow&);\n    move_nothrow& operator=(const move_nothrow&);\n};\n```", "```cpp\n#include <vector>\n\nint main() {\n    std::vector<move_nothrow> v(10);\n    v.push_back(move_nothrow());\n}\n```", "```cpp\n undefined reference to `move_nothrow::move_nothrow(move_nothrow \n    const&)  \n```", "```cpp\n// In header file.\nint foo() BOOST_NOEXCEPT; \n\n// In source file.\nint foo() BOOST_NOEXCEPT { \n    return 0; \n} \n```", "```cpp\n#include <boost/config.hpp> \n```", "```cpp\n#if defined(MY_LIBRARY_LINK_DYNAMIC)\n#   if defined(MY_LIBRARY_COMPILATION)\n#       define MY_LIBRARY_API BOOST_SYMBOL_EXPORT\n#   else\n#       define MY_LIBRARY_API BOOST_SYMBOL_IMPORT\n#   endif\n#else\n#   define MY_LIBRARY_API\n#endif\n```", "```cpp\nint MY_LIBRARY_API foo();\n\nclass MY_LIBRARY_API bar {\npublic:\n    /* ... */ \n    int meow() const;\n};\n```", "```cpp\n#include <stdexcept>\n\nstruct BOOST_SYMBOL_VISIBLE bar_exception\n    : public std::exception \n{};\n```", "```cpp\n#define MY_LIBRARY_COMPILATION\n#include \"my_library.hpp\"\n```", "```cpp\nint MY_LIBRARY_API foo() {\n    // Implementation goes here.\n    // ...\n    return 0;\n}\n\nint bar::meow() const {\n    throw bar_exception();\n}\n```", "```cpp\n#include \"../06_A_my_library/my_library.hpp\"\n#include <cassert>\n\nint main() {\n    assert(foo() == 0);\n    bar b;\n    try {\n        b.meow();\n        assert(false);\n    } catch (const bar_exception&) {}\n}\n```", "```cpp\n#if defined(MY_LIBRARY_COMPILATION) \n#    define MY_LIBRARY_API BOOST_SYMBOL_EXPORT \n#else \n#    define MY_LIBRARY_API BOOST_SYMBOL_IMPORT \n#endif \n```", "```cpp\n#include <boost/version.hpp>\n#include <boost/lexical_cast.hpp>\n```", "```cpp\n#if (BOOST_VERSION >= 105200)\n\nint to_int(const char* str, std::size_t length) {\n    return boost::lexical_cast<int>(str, length);\n}\n```", "```cpp\n#else\n\nint to_int(const char* str, std::size_t length) {\n    return boost::lexical_cast<int>(\n        std::string(str, length)\n    );\n}\n\n#endif\n```", "```cpp\n#include <cassert>\n\nint main() {\n    assert(to_int(\"10000000\", 3) == 100);\n}\n```"]