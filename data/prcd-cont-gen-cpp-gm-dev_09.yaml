- en: Chapter 9. Procedural Dungeon Generation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。程序地牢生成
- en: Perhaps the most iconic and defining feature of roguelike games is their procedurally
    generated levels. This is one of the main features that contributes to the replayability
    that the genre is renowned for having. It keeps the game fresh and challenging
    and the players on their toes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是地牢游戏最具标志性和定义性的特征之一就是它们的程序生成关卡。这是导致该类型游戏具有可重复性的主要特征之一。它使游戏保持新鲜和具有挑战性，让玩家保持警惕。
- en: 'Throughout the course of this book, we''ve progressed from the simple generation
    of single numbers to the implementation of complex procedural behavior, such as
    path finding. It''s time for our pièce de résistance: procedurally generating
    our levels. In addition to this, we''ll also work on making levels more distinct
    using the functions that we created in [Chapter 6](ch06.html "Chapter 6. Procedurally
    Generating Art"), *Procedurally Generating Art*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们从简单生成单个数字逐步实现了复杂的程序行为，比如路径查找。现在是时候展示我们的杰作了：程序生成我们的关卡。除此之外，我们还将使用我们在[第6章](ch06.html
    "第6章。程序生成艺术")中创建的函数来使关卡更加独特，*程序生成艺术*。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The benefits of procedurally designing levels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序设计关卡的好处
- en: Maze generation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷宫生成
- en: Room generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间生成
- en: Tile mapping
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓦片映射
- en: The benefits of procedural level design
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序设计关卡的好处
- en: The procedural generation of game levels and environments brings with it a myriad
    of benefits, not only for players but also for developers. It's always good to
    understand the positives and negatives of a technology before we use it. So, let's
    take a look at some of the biggest benefits that it brings to games before we
    implement it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏关卡和环境的程序生成带来了许多好处，不仅对玩家有益，对开发者也有益。在使用之前了解技术的优缺点总是好事。因此，在我们实施之前，让我们先看看它为游戏带来的一些最大好处。
- en: Replayability
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重复性
- en: The most obvious benefit of procedurally generated levels is their variety and
    the replayability that they bring to a game. With each run, the environment changes.
    This means that players cannot learn the locations of items, enemies, and this
    keeps the challenge alive and fresh, giving players reasons to play the game again
    and again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成关卡最明显的好处是它们的多样性和给游戏带来的可重复性。每次运行，环境都会发生变化。这意味着玩家无法学习物品和敌人的位置，这保持了挑战的新鲜感，给玩家理由一次又一次地玩游戏。
- en: A reduction in development time
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少开发时间
- en: Another benefit that is common in all implementations of procedural generation
    is the time that it saves in development. In our roguelike game, we're going to
    have an endless number of unique levels. If we were creating our levels manually
    this would simply not be possible. We would be limited to perhaps a hundred levels
    at the most.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成的一个普遍好处是它节省的开发时间。在我们的地牢游戏中，我们将拥有无数个独特的关卡。如果我们手动创建关卡，这是不可能的。我们最多只能限制在一百个关卡。
- en: Utilizing procedural generation like this takes this workload off the developers,
    saving both time and money, and increases the scope of what's possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这样的程序生成可以减轻开发者的工作量，节省时间和金钱，并扩大了可能性的范围。
- en: Larger game worlds
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更大的游戏世界
- en: Remember that procedural generation in itself is in no way random. We induce
    randomness by using random values and terms in our algorithms and calculations.
    Given that, we can use procedural generation within a level design to share levels
    without actually having to store them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，程序生成本身并不是随机的。我们通过在算法和计算中使用随机值和术语来引入随机性。鉴于此，我们可以在关卡设计中使用程序生成来共享关卡，而无需实际存储它们。
- en: Lots of games that generate worlds randomly will allow you to input a world
    seed. With this value, two people on two different machines can generate the same
    level. With this approach, you can generate a theoretically never-ending level,
    ensuring that all players generate the same one. Also, you'll only have to store
    the world seed instead of potentially hundreds of megabytes of world data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多随机生成世界的游戏允许你输入一个世界种子。有了这个值，两台不同机器上的人可以生成相同的关卡。通过这种方法，你可以生成一个理论上无限的关卡，确保所有玩家生成相同的关卡。此外，你只需要存储世界种子，而不是潜在的数百兆字节的世界数据。
- en: Considerations
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑因素
- en: As with everything, there are two sides of the same coin. Therefore, despite
    the benefits that procedural level generation brings, there are some considerations
    and compromises that need to be made.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 和一切一样，都有两面性。因此，尽管程序生成关卡带来了好处，但也需要考虑和妥协。
- en: A lack of control
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制的缺失
- en: A lack of control is a common pitfall of procedural generation in general, but
    it's perhaps never more prevalent than when generating levels. Game levels are
    the arena in which our stories are told and our game mechanics are experimented
    with. Given that, they are usually handcrafted by dedicated level designers. Leaving
    this job to an algorithm results in a significant loss of control.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 控制的缺失是程序生成的一个常见陷阱，但在生成关卡时可能比其他情况更为突出。游戏关卡是我们讲述故事和尝试游戏机制的竞技场。因此，它们通常由专门的关卡设计师手工制作。将这项工作交给算法会导致严重的控制丧失。
- en: Games with simple mechanics and stories will generally fair okay, but if you
    have complex mechanics or a story that you want to tell in a particular way, procedural
    level generation may require you to relinquish more control than you can afford.
    An algorithm can never replicate the little touches that a seasoned professional
    brings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有简单机制和故事的游戏通常会表现得不错，但如果你有复杂的机制或者想以特定方式讲述故事，程序生成关卡可能需要你放弃更多的控制权。算法永远无法复制经验丰富的专业人员带来的小细节。
- en: Required computing power
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需的计算能力
- en: Another consideration that needs to be taken into account is the computing power
    that is required. In our case, it's not that bad. We only have a 2D array of a
    small size that needs to be generated. However, if you're generating 3D terrain
    on a large scale, this cost becomes more significant and needs to be factored.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要考虑的一个问题是所需的计算能力。在我们的情况下，情况并不那么糟糕。我们只需要生成一个小尺寸的2D数组。然而，如果您在大规模生成3D地形，这个成本就变得更加重要，需要加以考虑。
- en: Imagine a situation where we are required to work with a level grid of 1000
    by 1000\. Every time we generate a level there will be a significant number of
    calculations that will need to be performed, and we need to ensure that all our
    players' hardware can cope! With steady increases in the computing power this
    is becoming less of an issue. In fact, this is the reason why games are becoming
    very complex and dynamic. We have the hardware that is required to achieve it,
    but we still need to be conscious of the limits.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们需要处理一个1000x1000的关卡网格。每次生成关卡时都会有大量的计算需要进行，我们需要确保所有玩家的硬件都能够应对！随着计算能力的稳步增加，这变得不再是一个问题。事实上，这就是游戏变得非常复杂和动态的原因。我们有实现它所需的硬件，但我们仍然需要意识到其限制。
- en: Suitability
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用性
- en: The final consideration is simply whether your game will benefit from procedural
    generation. Just because it might be technically possible to implement it in a
    title, it doesn't mean that it belongs there. If you don't require lots of levels
    and you have complex mechanics and systems, then it's probably not worth implementing
    it. You're better off spending this time in handcrafting a selection of levels
    that you know will work really well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的考虑只是您的游戏是否会受益于程序生成。仅仅因为在游戏中可能可以实现它，并不意味着它就应该存在。如果您不需要大量的关卡，并且有复杂的机制和系统，那么可能不值得实现它。最好花时间精心制作一些您知道会非常有效的关卡。
- en: This is a good point to bear in mind in general. Don't get carried away with
    the technicalities of the game and how amazing the code is. The bottom line is
    that your game needs to be fun and engaging. Always prioritize gameplay.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要牢记的好点。不要被游戏的技术性和代码的精彩所迷惑。最重要的是，您的游戏需要有趣和引人入胜。始终优先考虑游戏性。
- en: An overview of dungeon generation overview
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地牢生成概述
- en: 'Dungeon generation is a vast topic with a wide range of possible implementations,
    with each implementation having its own characteristics. However, underneath the
    nuances of different algorithms, dungeon generation generally involves the generation
    of rooms and a maze and the integration of the two, as shown in the following
    diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢生成是一个广泛的主题，有各种可能的实现方式，每种实现方式都有其自身的特点。然而，在不同算法的细微差别之下，地牢生成通常涉及生成房间和迷宫，以及将两者整合在一起，如下图所示：
- en: '![An overview of dungeon generation overview](img/B04920_09_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![地牢生成概述](img/B04920_09_01.jpg)'
- en: Procedurally generating dungeons is not that different from the work that we
    did on path finding. It's all about viewing a level as nodes and manipulating
    them. Before we implement it we'll break it down into the three main stages that
    were identified previously, namely the generation of rooms, the generation of
    a maze, and the integration of all together.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成地牢与我们在路径查找上所做的工作并没有太大的不同。它关键在于将关卡视为节点并对其进行操作。在我们实现之前，我们将其分解为之前确定的三个主要阶段，即生成房间、生成迷宫以及将它们整合在一起。
- en: Generating rooms
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成房间
- en: 'Dungeons are a series of interconnected rooms, and their generation is the
    first step in many systems. There is no complex algorithm behind this; we simply
    choose a room size and place a number of them in the level. The characteristics
    of this level will be determined by factors such as the number of rooms, their
    size, and how they are placed, as shown in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢是一系列相互连接的房间，它们的生成是许多系统中的第一步。这背后没有复杂的算法；我们只是选择一个房间大小，并在关卡中放置一些房间。这个关卡的特性将由房间的数量、大小以及它们的放置方式等因素决定，如下图所示：
- en: '![Generating rooms](img/B04920_09_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![生成房间](img/B04920_09_02.jpg)'
- en: Generating a maze
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成迷宫
- en: 'Another important step in dungeon generation is to generate a maze throughout
    the playable area, turning the level into a series of connected hallways. These
    can then either join the existing rooms, or have rooms carved into them to create
    open areas. There are a number of algorithms that are used to generated mazes
    like this, and we''ll use the popular **recursive backtracker** algorithm. Don''t
    worry, we''ll have a look at this algorithm in detail shortly! The following screenshot
    shows an example of such a maze:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢生成的另一个重要步骤是在可玩区域生成迷宫，将关卡变成一系列相连的走廊。然后这些走廊可以连接现有的房间，或者在其中雕刻房间以创建开放区域。有许多算法用于生成这样的迷宫，我们将使用流行的**递归回溯**算法。别担心，我们很快就会详细了解这个算法！以下截图显示了这样一个迷宫的示例：
- en: '![Generating a maze](img/B04920_09_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![生成迷宫](img/B04920_09_03.jpg)'
- en: Connecting rooms and mazes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接房间和迷宫
- en: 'If you choose to generate rooms first and then create a maze to connect them,
    the final step is to integrate them. Currently, the maze will run right past all
    the rooms, but thankfully, it''s an easy task to join them. We need to just look
    around each room and add a connecting block to a valid adjacent path, as shown
    in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择先生成房间，然后创建迷宫来连接它们，最后一步是将它们整合在一起。目前，迷宫会直接经过所有的房间，但幸运的是，将它们连接起来是一项简单的任务。我们只需要查看每个房间的周围，并向有效的相邻路径添加连接块，如下图所示：
- en: '![Connecting rooms and mazes](img/B04920_09_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![连接房间和迷宫](img/B04920_09_04.jpg)'
- en: In our implementation, we're actually going to do this the other way around.
    We'll generate a maze and then carve open areas into it. This method creates more
    open and maze-like areas, whereas the first method creates interconnected closed
    rooms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，实际上我们要以另一种方式来做。我们将生成一个迷宫，然后在其中开辟出开放区域。这种方法创建了更多开放和迷宫般的区域，而第一种方法则创建了相互连接的封闭房间。
- en: The recursive backtracker
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归回溯法
- en: The recursive backtracker, as the name suggests, involves recursively calling
    a function that carves passages between two tiles in the game grid. By choosing
    random directions to carve this path, the algorithm carves its way through the
    level as far as possible before resolving its recursions, working back to the
    start node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 递归回溯法，顾名思义，涉及递归调用一个函数，在游戏网格中的两个瓦片之间雕刻通道。通过选择随机方向来雕刻这条路径，算法在解决递归之前尽可能远地雕刻其路径，然后回到起始节点。
- en: 'The following is pseudocode for one such algorithm:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个这样的算法的伪代码：
- en: Choose random direction and make a connection to the adjacent node if it has
    not yet been visited. This node becomes the current node (a recursive call).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择随机方向并连接到相邻节点，如果它尚未被访问。这个节点成为当前节点（一个递归调用）。
- en: If all the adjacent cells in each direction have already been visited, go back
    to the last cell (return from the previous recursive call).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果每个方向上的相邻单元格都已经被访问过，那么返回到上一个单元格（从上一个递归调用中返回）。
- en: If you're back at the start node, the algorithm is complete.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你回到了起始节点，算法就完成了。
- en: As we can see, there's really not much to it! The only pitfall is that you need
    to have the entire maze in memory. For large mazes this method can be inefficient
    or maybe not possible at all! However, for our implementation, it will work perfectly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，实际上并没有太多的东西！唯一的陷阱是你需要将整个迷宫保存在内存中。对于大型迷宫，这种方法可能效率低下，甚至可能根本不可能！然而，对于我们的实现，它将完美地工作。
- en: Procedurally generating a dungeon
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化生成地下城
- en: It's time to put this theory into practice and implement procedural dungeon
    generation in our game for real. We'll move the `Level` class from loading its
    data from a text file to generating it at runtime, and we'll also cover the application
    of the correct sprites to the tiles in the random level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这个理论付诸实践，在我们的游戏中实现程序化地下城生成。我们将把`Level`类从从文本文件加载其数据转移到在运行时生成数据，并且我们还将覆盖将正确的精灵应用到随机关卡中的瓦片上。
- en: 'As we identified, one way of approaching this is to generate a maze over the
    entire play area and then generate rooms to carve out some larger open areas.
    This method not only generates tighter, more intertwined levels, but also saves
    us the step of having to connect mazes to rooms, leaving us with just two steps
    to generate great levels:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所确定的，一种处理这个问题的方法是在整个游戏区域生成一个迷宫，然后生成房间来雕刻出一些更大的开放区域。这种方法不仅生成了更紧密、更交织的关卡，而且还省去了我们连接迷宫和房间的步骤，使我们只需两个步骤就能生成出色的关卡：
- en: '![Procedurally generating a dungeon](img/B04920_09_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![程序化生成地下城](img/B04920_09_05.jpg)'
- en: Changing how we view the maze
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变我们看待迷宫的方式
- en: Before we write any code, we're going to make a change to the project so that
    we can easily see the entire level. Currently, the view is zoomed, and we have
    the light blocking the level. We want to be able to see the entire maze as we
    work on the algorithm. So let's make some changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们将对项目进行一些更改，以便我们可以轻松地看到整个关卡。目前，视图是放大的，并且光线挡住了关卡。我们希望在处理算法时能够看到整个迷宫。所以让我们做一些改变。
- en: The first thing that we'll do is disable the main game view and instead draw
    everything using the **UI** view. The **Game** view draws draws everything twice
    as large as the original size, while the UI view draws things with a scale of
    1:1\. By disabling the change to the **Game** view, we'll see more of the level.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是禁用主游戏视图，而是使用**UI**视图来绘制所有东西。**Game**视图以原始大小的两倍绘制所有东西，而UI视图以1:1的比例绘制东西。通过禁用对**Game**视图的更改，我们将看到更多的关卡。
- en: 'Update the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更新以下代码：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All that we''ve done here is comment out the line that sets the main game''s
    view. Let''s now do the same for the code responsible for drawing the light in
    the level:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的一切就是注释掉了设置主游戏视图的那一行。现在让我们对负责在关卡中绘制光线的代码做同样的操作：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two changes drastically change how the level now appears and will help
    us see the maze as we work:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个改变大大改变了关卡的外观，将帮助我们在工作时看到迷宫：
- en: '![Changing how we view the maze](img/B04920_09_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![改变我们看待迷宫的方式](img/B04920_09_06.jpg)'
- en: Updating the Game and Level classes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏和关卡类
- en: 'Before we start implementing the maze generator, we need to define some functions
    that we''ll be using. For starters, our level is currently loaded from the `Level::LoadLevelFromFile`
    function. We need to create an appropriate function for the new code. Let''s remove
    the `Level::LoadLevelFromFile` function and add the following code in its place
    in `Level.h`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现迷宫生成器之前，我们需要定义一些我们将要使用的函数。首先，我们的关卡目前是从`Level::LoadLevelFromFile`函数中加载的。我们需要为新代码创建一个合适的函数。让我们删除`Level::LoadLevelFromFile`函数，并在`Level.h`中加入以下代码：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''re going to need a similar function in the `Game` class, which will encapsulate
    all the code to generate a random level, so ensure that you add the same function
    declaration to `Game.h` also. We have a couple of functions that are related to
    generating a level, and all of these can be encapsulated in this function. We
    need to add the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要在`Game`类中添加一个类似的函数，它将封装所有生成随机关卡的代码，因此请确保您也在`Game.h`中添加相同的函数声明。我们有一些与生成关卡相关的函数，所有这些函数都可以封装在这个函数中。我们需要添加以下内容：
- en: 'A call to `Level::GenerateLevel`: This enables the placement of key in the
    level'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Level::GenerateLevel`：这使得在关卡中放置钥匙成为可能
- en: 'A call to `Game::PopulateLevel`: This helps in the generation of a random level
    goal'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Game::PopulateLevel`：这有助于生成一个随机的关卡目标
- en: Notice one of these items is to add a key to the level. The item already exists
    in our solution, as does all supporting code, and as we'll soon be able to generate
    levels at random we can now spawn one in the level.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意其中一个项目是向级别添加一个钥匙。该项目已经存在于我们的解决方案中，所有支持代码也都存在，因此我们很快就能够在级别中生成一个。
- en: 'Let''s add this function to `Game.cpp`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个函数添加到`Game.cpp`中：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We created the `Goal::GenerateLevelGoal` function in [Chapter 8](ch08.html "Chapter 8. Procedural
    Behavior and Mechanics"), *Procedural Behavior and Mechanics*. So, this is where
    we actually implement it. Each time a new level is generated, we create a 1 in
    3 chance that a goal will be generated if there isn't one that's currently active.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](ch08.html "第8章。程序行为和机制")*程序行为和机制*中创建了`Goal::GenerateLevelGoal`函数。因此，这就是我们实际实现它的地方。每次生成新的关卡时，我们都有三分之一的机会生成一个目标，如果当前没有活动的目标的话。
- en: 'Since we now have the function that will generate our levels at random, and
    have added the key, let''s quickly add the code to generate a new level when the
    player reaches the door. We already have the if statement ready, we just need
    to add the behavior:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在有了能够随机生成我们的关卡的函数，并且已经添加了钥匙，让我们快速添加代码，以便在玩家到达门时生成新的关卡。我们已经准备好了if语句，我们只需要添加行为：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that this is completed, all we have left to do is call our `Game::GenerateLevel`
    function instead of our depreciated `Level::LoadLevelFromFile`, and remove the
    code to set the players location and the call to `Game::PopulateLevel`. Our new
    `Game::GenerateLevel` function will take care of all of that. Let''s update the
    following code in `Game::Initialize`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个已经完成了，我们唯一剩下的事情就是调用我们的`Game::GenerateLevel`函数，而不是我们已经弃用的`Level::LoadLevelFromFile`，并删除设置玩家位置和调用`Game::PopulateLevel`的代码。我们的新的`Game::GenerateLevel`函数将处理所有这些。让我们更新`Game::Initialize`中的以下代码：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that the code is updated, we can now turn our attention towards the dungeon
    generation algorithm.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经更新，我们现在可以把注意力转向地牢生成算法。
- en: Generating a maze
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成迷宫
- en: The first stage of creating a random dungeon is to generate a maze throughout
    the entire play area. We've covered the recursive backtracker method that we're
    going to use. However, we need to do some preparation beforehand.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建随机地牢的第一阶段是在整个游戏区域生成一个迷宫。我们已经介绍了我们将使用的递归回溯方法。但是，我们需要在此之前做一些准备工作。
- en: Preparing before the generation of a maze
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成迷宫之前的准备
- en: 'The recursive backtracking algorithm works by forging passages between two
    nodes. Given this, we need the maze to be in a position where all the nodes in
    the grid are surrounded by walls, that is, something that looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 递归回溯算法通过在两个节点之间建立通道来工作。鉴于此，我们需要迷宫处于这样的位置，即网格中的所有节点都被墙壁包围，也就是说，看起来像这样：
- en: '![Preparing before the generation of a maze](img/B04920_09_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![生成迷宫之前的准备](img/B04920_09_07.jpg)'
- en: The shaded squares represent wall tiles, and the blank squares represent floor
    space. You will see in the left grid that each floor tile is surrounded on all
    sides by a wall. The right tile shows what the grid would look like once the algorithm
    is run, breaking through these walls to create paths. Our task is to make the
    grid look like the one on the left!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影方块代表墙砖，空白方块代表地板空间。您将在左侧网格中看到每个地板砖都被四面墙壁包围。右侧的砖块显示了算法运行后网格的样子，打破这些墙壁以创建路径。我们的任务是使网格看起来像左侧的那个！
- en: When you look at the grid to the left, you will see that all the shaded tiles
    have odd indices; only the tiles that have an even column and a row index are
    blank. This makes it easy to create this grid. We need to loop through all the
    tiles, and if both the indices are even, we leave it blank. Otherwise, we convert
    it into a wall tile.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看左侧的网格时，您会发现所有阴影砖块都具有奇数索引；只有具有偶数列和行索引的砖块是空白的。这样很容易创建这个网格。我们需要循环遍历所有砖块，如果两个索引都是偶数，我们就留下空白。否则，我们将其转换为墙砖。
- en: 'Let''s start defining the `Level::GenerateLevel` function by implementing this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义`Level::GenerateLevel`函数，通过实现这个来开始：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before we run our game we need to quickly disable any code that uses the level
    grid. This includes our call to `Game::PopulateLevel` and the placement of the
    key in `Game::GenerateLevel`. It also includes the call to `Game::SpawnRandomTiles`
    in `Game::Initialize`. These functions rely on the level grid been setup, and
    it isn't yet! Without disabling these the game will hang as it looks for floor
    tiles! We'll turn them back on when we're done.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行游戏之前，我们需要快速禁用任何使用级别网格的代码。这包括我们对`Game::PopulateLevel`的调用以及在`Game::GenerateLevel`中放置钥匙。还包括在`Game::Initialize`中对`Game::SpawnRandomTiles`的调用。这些函数依赖于级别网格的设置，但现在还没有设置！如果不禁用这些，游戏将因为寻找地板瓦片而挂起！完成后我们会重新启用它们。
- en: If you run the game now, you will see that we have a grid that looks like the
    image to the left. The first step is complete!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，您将看到我们有一个看起来像左侧图像的网格。第一步完成了！
- en: 'The following screenshot shows the result when we run the game now:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了我们现在运行游戏时的结果：
- en: '![Preparing before the generation of a maze](img/B04920_09_08.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![生成迷宫之前的准备](img/B04920_09_08.jpg)'
- en: Carving passages
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开辟通道
- en: 'Now that the checkerboard pattern is created, it''s time to implement the main
    body of the algorithm. Here''s a reminder of how the recursive backtracker algorithm
    works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，棋盘格模式已经创建，是时候实现算法的主体部分了。以下是递归回溯算法的工作原理的提醒：
- en: Choose a random direction and make a connection to the adjacent node if it has
    not yet been visited. This node becomes the current node (a recursive call).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个随机方向，并与相邻节点建立连接（如果尚未访问）。这个节点成为当前节点（递归调用）。
- en: If all adjacent cells in each direction have already been visited, go back to
    the last cell (return from the previous recursive call).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果每个方向的所有相邻单元格都已经被访问过，则返回到上一个单元格（从先前的递归调用返回）。
- en: If you're back at the start node, the algorithm is complete.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果回到起始节点，则算法完成。
- en: 'We know that this algorithm is recursive, so let''s start by declaring the
    function that will contain the algorithm. Since this function will create paths
    between two nodes, we''ll call it `CreatePath`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个算法是递归的，所以让我们从声明包含算法的函数开始。由于这个函数将在两个节点之间创建路径，我们将把它称为`CreatePath`：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting with the first point in the algorithm breakdown, we need to identify
    the node that we're working with and choose a random direction. Getting the correct
    node is easy, and to choose a random direction, we'll use an array. We can define
    an array of `sf::vector2i` that defines all the possible directions. For example,
    `{-2, 0}` will indicate a movement to the tile to the left, as we'll decrement
    the column index by 2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从算法分解的第一个点开始，我们需要识别我们正在处理的节点并选择一个随机方向。获取正确的节点很容易，为了选择一个随机方向，我们将使用一个数组。我们可以定义一个`sf::vector2i`数组，定义所有可能的方向。例如，`{-2,
    0}`将表示向左移动一个瓷砖，因为我们将把列索引减2。
- en: Remember, we have to move two tiles at a time due to the checkerboard pattern.
    The tile that is directly adjacent to us is a wall so we need to move one step
    further to reach the tile that we want to work on. We then need to shuffle the
    array of directions so that the algorithm doesn't tend towards any one in particular.
    If we didn't do this for example, it would always check north first, resulting
    in lots of north-running passages!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于棋盘格的模式，我们必须每次移动两个瓷砖。直接相邻的瓷砖是一堵墙，所以我们需要再走一步才能到达我们想要处理的瓷砖。然后我们需要打乱方向数组，这样算法就不会倾向于任何一个特定的方向。例如，如果我们不这样做，它将总是首先检查北方，导致很多向北的通道！
- en: 'Let''s start defining the `Level::CreatePath` function by adding the following
    to `Level.cpp`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义`Level::CreatePath`函数，将以下内容添加到`Level.cpp`中：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we iterate over these directions and check whether we can find any valid
    tiles that have not yet been visited. A tile is valid if it exists in the grid,
    and you can tell whether it's been visited yet or not depending on whether it's
    empty.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历这些方向，并检查是否可以找到任何尚未被访问的有效瓷砖。如果一个瓷砖存在于网格中，并且你可以根据它是否为空来判断它是否已经被访问。
- en: 'Let''s add this functionality by appending the following code to the open function''s
    definition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将以下代码附加到打开函数的定义来添加这个功能：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the code reaches this point we know that we're looking at a new tile as it's
    both valid and currently empty. To create a path to it we need to knock down the
    wall between us and change both the wall and our new tile with floor tiles. We
    now call `Level::CreatPath` once more, passing the indices of the new tile as
    the parameters. It's here that the recursion happens and the algorithm progresses
    forward.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码到达这一点，我们知道我们正在看一个新的瓷砖，因为它既有效又当前为空。为了创建到它的路径，我们需要拆掉我们之间的墙，并将墙和我们的新瓷砖都改为地板瓷砖。现在我们再次调用`Level::CreatPath`，传递新瓷砖的索引作为参数。递归就发生在这里，算法继续前进。
- en: 'Let''s finish the function''s definition with the following bit of code to
    achieve this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成函数的定义，使用以下代码来实现这一点：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's clarify exactly what's happening here. Every time an empty tile is identified,
    a recursive call to `Level::CarvePath` is made, and that tile's indices are passed.
    As it does this, it works its way through the level, nesting deeper and deeper
    into recursion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一下这里到底发生了什么。每当识别到一个空瓷砖时，就会对`Level::CarvePath`进行递归调用，并传递该瓷砖的索引。当它这样做时，它会通过关卡，逐渐深入递归。
- en: When all the directions have been checked and there is no valid tile, the current
    call from `Level::CreatePath` will return, allowing the previous call to check
    its remaining directions. As this process continues the algorithm works its way
    back through the path until it reaches the start node, at which point nodes have
    been visited.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有方向都被检查并且没有有效的瓷砖时，`Level::CreatePath`的当前调用将返回，允许上一次调用检查其剩余的方向。随着这个过程的继续，算法会沿着路径返回，直到它到达起始节点，此时节点已经被访问。
- en: 'Hopefully, the comments in the function make it clear which part is doing what.
    Now that this is complete we can now call it from the `Level::GenerateLevel` function
    right after we set up the grid:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 希望函数中的注释清楚地说明了哪一部分在做什么。现在这一步完成后，我们现在可以在`Level::GenerateLevel`函数中调用它，就在我们设置网格之后：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s compile the project once again and see what we have:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次编译项目，看看我们有什么：
- en: '![Carving passages](img/B04920_09_09.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Carving passages](img/B04920_09_09.jpg)'
- en: We have the maze! For some games, this will be enough, but we don't want all
    the single tile paths. We're want more open areas so that we can fight the enemies!
    You'll also see that the tile sprites are looking very weird. Don't worry about
    it now; we'll fix it as soon as we add the rooms!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有迷宫了！对于一些游戏来说，这已经足够了，但我们不想要所有的单瓷砖路径。我们想要更多的开放区域，这样我们就可以与敌人战斗！你还会看到瓷砖精灵看起来非常奇怪。现在不要担心它，我们一旦添加了房间就会修复它！
- en: Adding rooms
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加房间
- en: 'Previously, we learned that adding rooms was a simple task. We now get to see
    this firsthand. Our goal is to add some open areas, and the simplest way to do
    this is to pick some random locations and convert the surrounding tiles to floor
    tiles. To keep the `Level` class neat, we''ll encompass this behavior in its own
    function. Add the following function declaration to `Level.h`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学到了添加房间是一个简单的任务。现在我们可以亲自看到这一点。我们的目标是添加一些开放区域，最简单的方法是选择一些随机位置，并将周围的瓷砖转换为地板瓷砖。为了保持`Level`类的整洁，我们将把这种行为包含在它自己的函数中。在`Level.h`中添加以下函数声明：
- en: '`private`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`：'
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our ongoing efforts to write versatile and scalable code, we added a parameter
    to denote how many rooms we want to create so that we can vary it at will.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们不断努力编写通用和可扩展的代码的过程中，我们添加了一个参数来表示我们想要创建多少个房间，这样我们可以随意变化它。
- en: 'Let''s jump right into defining the function. To start, we''re going to need
    a loop to iterate once for each room that we wish to add. Add the following method
    definition in `Level.cpp`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始定义这个函数。首先，我们需要一个循环，每次迭代都要添加一个我们希望添加的房间。在`Level.cpp`中添加以下方法定义：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can create our rooms. The first task is to decide how big we want them
    to be. After playing with the algorithm I found that having a greater number of
    smaller rooms works well. As always, we''ll throw in some RNG here by having the
    rooms'' size fall within a random range:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的房间了。第一个任务是决定我们想要它们有多大。通过尝试算法，我发现拥有更多数量的较小房间效果很好。和往常一样，我们将通过使房间的大小落在一个随机范围内来增加一些随机性：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will generate rooms with a width and height of either 1 or 2\. I know that
    this sounds small, but trust me. It works really well!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成宽度和高度为1或2的房间。我知道这听起来很小，但相信我。它确实非常有效！
- en: 'Next we need to choose a place in the level for this room to be placed. We''ll
    pick a random point and build the room around it. For this we need to generate
    a random tile index and then create nested `for` loops to iterate over the 2D
    array, thus describing the room:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为这个房间在关卡中选择一个位置。我们将选择一个随机点并围绕它建造房间。为此，我们需要生成一个随机瓷砖索引，然后创建嵌套的`for`循环来迭代2D数组，从而描述房间：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When generating the start position, you can see that we've been careful not
    to include the outer edge in either direction. These are the level's retaining
    walls and should be left alone.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成起始位置时，你可以看到我们小心翼翼地没有包括任何方向上的外边缘。这些是关卡的挡墙，应该保持不变。
- en: 'The last part of the function now simply involves turning the room tiles into
    floor tiles. First, we check whether we haven''t gone out of bounds by making
    a call to `Level::TileIsValid`. We then ensure that the new title does not lie
    on the outer edge of the grid; the outer rows/columns should all be walls to contain
    the level. If both of these criteria are met, we can make it a floor block by
    using the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后部分现在只涉及将房间瓷砖变成地板瓷砖。首先，我们通过调用`Level::TileIsValid`来检查我们是否超出了边界。然后，我们确保新的标题不位于网格的外边缘；外部行/列都应该是墙，以限制关卡。如果这两个条件都满足，我们可以使用以下代码将其变成地板块：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's time to make a call to this function. Currently in `Level::GenerateLevel`
    we set our grid up and then make the first call to `Level::CreatePath` to start
    the recursive algorithm. When this first initial call is returned, we know that
    the maze has been fully generated. It's at this stage that we'll create the rooms.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调用这个函数了。目前在`Level::GenerateLevel`中，我们设置了我们的网格，然后进行了第一次调用`Level::CreatePath`来启动递归算法。当这个初始调用返回时，我们知道迷宫已经完全生成。在这个阶段，我们将创建房间。
- en: 'Let''s append a call to the new `Level::CreateRooms` function right after the
    first call to `Level::CreatePath`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第一次调用`Level::CreatePath`之后立即追加一个对新的`Level::CreateRooms`函数的调用：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s time for another build so that we can see our work. Hopefully now we
    have a random maze running through the level as well as a number of larger open
    areas where we can allow players to fight more freely:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行另一个构建，这样我们就可以看到我们的工作。希望现在我们的关卡中有一个随机的迷宫，以及一些更大的开放区域，可以让玩家更自由地战斗：
- en: '![Adding rooms](img/B04920_09_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![添加房间](img/B04920_09_10.jpg)'
- en: Choosing the tile textures
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择瓷砖纹理
- en: Until now we've been loading a prebuilt level from a text file. This level file
    already knew which textures needed to be used and where they should be used, but
    since we're now generating them procedurally, that's not the case. We need to
    decide which tiles should have which sprites.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在从文本文件中加载一个预构建的关卡。这个关卡文件已经知道需要使用哪些纹理以及它们应该被使用的位置，但由于我们现在是通过程序生成它们，情况就不一样了。我们需要决定哪些瓷砖应该有哪些精灵。
- en: The if/else approach
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if/else方法
- en: A common way of approaching this is simply to create a monstrous `if/else` statement.
    In principle, it's a simple task; define each tile through a series of `if` statements
    and set the right tile. However, in reality, you end up with a complex mess of
    code that is very difficult to read.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的常见方式就是简单地创建一个庞大的`if/else`语句。原则上，这是一个简单的任务；通过一系列的`if`语句来定义每个瓷砖并设置正确的瓷砖。然而，在现实中，你最终会得到一堆复杂的代码，非常难以阅读。
- en: Imagine a situation where you have a tile set of fifty possible variants. The
    amount of code required to choose which tile goes where would be crazy. Thankfully,
    there's a much simpler solution to the problem, and it is one of my favorite examples
    of an elegant solution to a problem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '想象一种情况，你有一个包含五十种可能变体的瓷砖集。为了选择哪个瓷砖放在哪里，需要的代码量将是疯狂的。幸运的是，这个问题有一个更简单的解决方案，这是我最喜欢的一个优雅解决问题的例子。 '
- en: Bitwise tile maps
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算瓷砖地图
- en: 'In our game, we concern ourselves with four directions, namely up, down, left,
    and right. Given that, when we need to calculate tile textures we only need to
    check in these four directions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们关注四个方向，即上、下、左和右。因此，当我们需要计算瓷砖纹理时，我们只需要在这四个方向上进行检查：
- en: '![Bitwise tile maps](img/B04920_09_11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![位运算瓷砖地图](img/B04920_09_11.jpg)'
- en: In the preceding diagram, you can see that the tiles marked with 0s are those
    that are used to determine the texture given to tile X. This is where the elegant
    solution comes into play. If we read the tiles into a binary number, starting
    from the top tile and counting from the least significant digit, we get the 4
    digit binary number, 0000\. If the tile is a wall we set the corresponding bit
    to 1\. If the tile is floor we leave it as 0.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，你可以看到标有0的瓷砖是用来确定给瓷砖X的纹理的。这就是优雅解决方案的地方。如果我们从顶部瓷砖开始，从最低有效位开始计数，将瓷砖读入二进制数，我们得到4位二进制数，0000。如果瓷砖是墙，我们将相应的位设置为1。如果瓷砖是地板，我们将其保持为0。
- en: 'If we apply this to the four possible tile locations that surround the tile
    X, we can calculate values for each tile:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个应用到围绕瓷砖X的四个可能的瓷砖位置，我们可以计算每个瓷砖的值：
- en: '![Bitwise tile maps](img/B04920_09_12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![位运算瓷砖地图](img/B04920_09_12.jpg)'
- en: 'Hopefully, this diagram makes things clearer. Starting from the top tile and
    reading clockwise, we feed the values of the tiles into a bit integer from the
    least significant digit to the most. This gives each tile surrounding the main
    tile a distinct value, and we can visualize this through the following image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这张图能让事情更清晰。从顶部瓷砖开始，顺时针阅读，我们将瓷砖的值输入到一个位整数中，从最不重要的数字到最重要的数字。这使得周围每个瓷砖都有一个不同的值，我们可以通过以下图像来可视化这一点：
- en: '![Bitwise tile maps](img/B04920_09_13.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![位瓷砖地图](img/B04920_09_13.jpg)'
- en: Calculating the tile values
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算瓷砖的值
- en: 'When deciding upon the tile texture that we need, we evaluate which tiles surround
    the target tile, and where we have a wall we store its value that we identified
    in the previous image. A real example will help you visualize this process. Let''s
    suppose that we need to find the correct texture for tile X:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定我们需要的瓷砖纹理时，我们评估了围绕目标瓷砖的瓷砖，并在有墙壁的地方存储了我们在前面图像中识别出的值。一个真实的例子将帮助你可视化这个过程。假设我们需要找到瓷砖X的正确纹理：
- en: '![Calculating the tile values](img/B04920_09_14.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![计算瓷砖的值](img/B04920_09_14.jpg)'
- en: 'In this scenario, the tile value will be calculated in the following way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，瓷砖的值将按以下方式计算：
- en: 1 + 4 = 5
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 4 = 5
- en: Using this method, each possible tile orientation for X is represented through
    a unique value ranging from 0 to 15\. It's so elegant and simple!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，X的每种可能的瓷砖方向都通过一个从0到15的唯一值表示。如此优雅简单！
- en: Mapping the tile value to textures
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将瓷砖值映射到纹理
- en: 'The final piece of this puzzle is mapping these values to textures. In `Util.h`,
    you will see that the following enumerator defines the all types:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后一块是将这些值映射到纹理上。在“Util.h”中，你会看到以下枚举器定义了所有类型：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While the order of these tiles may seem somewhat random, they are actually in
    a very specific order. Enumerators start counting from 0\. Therefore, we can see
    that the first value, `WALL_SINGLE`, has a value of 0\. Going back to our chart,
    we can see that this is correct, as that's the texture that we'll need when there
    is nothing surrounding the tile.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些瓷砖的顺序可能看起来有些随机，但它们实际上是按照非常特定的顺序排列的。枚举器从0开始计数。因此，我们可以看到第一个值“WALL_SINGLE”的值为0。回到我们的图表，我们可以看到这是正确的，因为这就是我们在没有周围瓷砖的情况下需要的纹理。
- en: Taking another random example, the `WALL_TOP` value has a value of 10\. If we
    look at the grid, this will mean that the tiles only to the right and left of
    the target tile are walls. 2 + 8 = 10\. That's correct! For all possible tiles,
    I worked out their bitmask values and ensured that their enumerator values matched
    up.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个随机的例子，“WALL_TOP”值为10。如果我们看一下网格，这意味着目标瓷砖的右侧和左侧的瓷砖都是墙。2 + 8 = 10。没错！对于所有可能的瓷砖，我计算出了它们的位掩码值，并确保它们的枚举器值匹配。
- en: Calculating tile textures
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算瓷砖纹理
- en: 'Let''s get this implemented in the project. First, we''ll declare a function
    that we can encapsulate this behavior in our `Level` header:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中实现这个。首先，我们将在我们的“Level”头文件中声明一个函数，我们可以将这个行为封装起来：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the function''s body, we want to start by iterating over all the tiles,
    identifying which of them are walls. It''s these tiles that need their sprites
    calculating correct texture:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数的主体，我们希望首先迭代所有的瓷砖，识别哪些是墙。正是这些瓷砖需要计算正确的纹理：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we look at those tiles around us, using the values we calculated earlier,
    to come up with a final value for the tile. We check each tile in procession,
    again starting from the top, going clockwise, and increasing the value by the
    appropriate amount if there is a wall there:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看看我们周围的瓷砖，使用我们之前计算的值，来得出瓷砖的最终值。我们按顺序检查每个瓷砖，再次从顶部开始，顺时针旋转，并根据适当的数量增加值，如果那里有墙的话：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All that''s left at this stage is to assign the correct texture and ID to the
    tile. We previously covered how we set up the enumerator, denoting the tile types
    to line up directly with this value, so we can simply use the texture value as
    the tile type and the index of the texture:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段剩下的就是为瓷砖分配正确的纹理和ID。我们之前讨论过如何设置枚举器，表示瓷砖类型与这个值直接对应，所以我们可以简单地使用纹理值作为瓷砖类型和纹理的索引：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this the function is complete. The final step is to ensure that we add
    a call to it in the `Level::GenerateLevel` function right after we''ve generated
    the rooms, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数就完成了。最后一步是确保我们在“Level::GenerateLevel”函数中添加一个调用，就在我们生成了房间之后，如下所示：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s not waste any time and get our game built:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不浪费任何时间，开始构建我们的游戏：
- en: '![Calculating tile textures](img/B04920_09_15.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![计算瓷砖纹理](img/B04920_09_15.jpg)'
- en: How great does that look! Run it a few times and see all the different mazes
    that are generated. We generate a maze, carve some larger areas, and resolve the
    textures. Procedurally generated dungeons. While this is great, we can do better.
    Our mazes lack character and individuality. So let's introduce some aesthetic
    variance to the environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来多棒啊！多次运行它，看看生成的不同迷宫。我们生成一个迷宫，雕刻一些更大的区域，并解决纹理。程序生成的地牢。虽然这很棒，但我们可以做得更好。我们的迷宫缺乏特色和个性。所以让我们为环境引入一些审美的变化。
- en: Creating unique floor themes
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独特的地板主题
- en: In [Chapter 6](ch06.html "Chapter 6. Procedurally Generating Art"), *Procedurally
    Generating Art*, we spent some time looking at procedurally generating sprites.
    We also created a function named `Level::SetColor`, which allows us to set an
    overlay color for all the tiles in the level. Let's put this to use and create
    a unique feel for each floor of the dungeon.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。程序生成艺术")中，*程序生成艺术*，我们花了一些时间研究程序生成精灵。我们还创建了一个名为“Level::SetColor”的函数，它允许我们为地牢中的所有瓷砖设置覆盖颜色。让我们利用这一点，为地牢的每一层创建独特的感觉。
- en: 'Let''s create distinct floors that each have a unique aesthetic. Every 5 levels
    we can generate a new random color and apply it to our level. Our `Level` class
    already has the following variables:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建每个都有独特审美的不同地板。每5层我们可以生成一个新的随机颜色，并将其应用到我们的地牢。我们的“Level”类已经有了以下变量：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can use these to track how many rooms we have generated and when we should
    change the effect. To start, we have to keep track of which floor and room we''re
    on. At the end of the `Level::GenerateLevel` function, we''ll start by incrementing
    the `m_roomNumber` variable. When it''s `5`, we can increment `m_floorNumber`
    and generate a new color overlay; don''t forget to reset the room counter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些来跟踪我们生成了多少个房间，以及何时应该更改效果。首先，我们必须跟踪我们在哪个楼层和房间。在`Level::GenerateLevel`函数的末尾，我们将首先递增`m_roomNumber`变量。当它为`5`时，我们可以递增`m_floorNumber`并生成一个新的颜色叠加；不要忘记重置房间计数器：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we learned in [Chapter 6](ch06.html "Chapter 6. Procedurally Generating Art"),
    *Procedurally Generating Art*, to generate a new color we need to generate three
    random values that lie between 0 and 255\. These values are the red, green, and
    blue channels that make up the color. The fourth value is alpha and denotes the
    transparency of the sprite.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](ch06.html "第6章。程序生成艺术")中学到的，*程序生成艺术*，要生成新颜色，我们需要生成三个介于0和255之间的随机值。这些值是组成颜色的红色、绿色和蓝色通道。第四个值是alpha，表示精灵的透明度。
- en: It's important to bear in mind that if we generate color values that are closer
    to 0, we'll get a white color, and if we go too far on the other end, the color
    will be too dark. For this reason, we aren't going to generate a number anywhere
    in the range of 0 to 255, but cap this slightly so that we always get a workable
    color. The alpha value will be set to 255 every time, as we don't want any of
    the tiles to be transparent.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，如果我们生成接近0的颜色值，我们将得到白色，如果我们在另一端走得太远，颜色将会太暗。因此，我们不会在0到255的范围内生成任何数字，而是略微限制，以便我们始终获得可用的颜色。alpha值将每次设置为255，因为我们不希望任何瓦片是透明的。
- en: 'We''ll generate a random color and then make a call to `Level::SetColor`, passing
    the newly generated value to it. This will give the level a unique aesthetics:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一个随机颜色，然后调用`Level::SetColor`，将新生成的值传递给它。这将赋予关卡独特的美学：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is the second time we wanted to generate a random color. Given this, it
    might be a good candidate to receive its own function. As a short exercise, abstract
    this code into its own function and update the game code accordingly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第二次想要生成随机颜色。鉴于此，将其抽象为自己的函数可能是一个不错的选择。作为一个简短的练习，将此代码抽象为自己的函数，并相应地更新游戏代码。
- en: 'Before we can run our game and see the results, we need to make one more change.
    Currently, a random level color will only be set when we move the floors for the
    first time. We need to execute the same code when our level is first generated.
    We can do this in the constructor of the level. Let''s simply append the following
    code to `Level::Level`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行游戏并查看结果之前，我们需要再做一些更改。当前，随机关卡颜色仅在我们第一次移动楼层时设置。我们需要在生成关卡时执行相同的代码。我们可以在关卡的构造函数中执行此操作。让我们简单地将以下代码附加到`Level::Level`中：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we're ready to run the game once more. We can see that when our level is
    a random color, and when we make our way through 5 levels we know this color will
    change!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备再次运行游戏。我们可以看到当我们的关卡是随机颜色时，当我们通过5个关卡时，我们知道这种颜色将会改变！
- en: 'Let''s run the game and see this in action:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏，看看它的表现：
- en: '![Creating unique floor themes](img/B04920_09_16.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![创建独特的楼层主题](img/B04920_09_16.jpg)'
- en: Adding entry and exit points
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加入口和出口点
- en: Since we're no longer loading our level from pre-defined level data, we need
    to calculate a valid entry and exit point for each room. Since the whole level
    is a maze, we can generate an entry point right at the bottom of maze and make
    it the player's goal to find the exit at the top of the level. The multiple passages
    and dead ends will keep the player searching!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再从预定义的关卡数据中加载关卡，我们需要为每个房间计算有效的入口和出口点。由于整个关卡是一个迷宫，我们可以在迷宫底部随机生成一个入口点，并使玩家的目标是找到顶部的出口。多个通道和死胡同将使玩家不断搜索！
- en: We already have these tiles defined in our wall enumerator, so it's a simple
    case of finding locations for them in the level. As always, we'll start by declaring
    a function in which this behavior will lie. It's always a good idea to encapsulate
    chunks of code that perform a single task in a function. This not only makes behavior
    and responsibility clear, but also makes code more reusable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的墙枚举器中定义了这些瓦片，所以只需在关卡中找到它们的位置。和往常一样，我们将首先声明一个函数，其中将包含此行为。将执行单个任务的代码块封装在函数中总是一个好主意。这不仅使行为和责任清晰，还使代码更具可重用性。
- en: 'Let''s declare the following function in `Level.h`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Level.h`中声明以下函数：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, for the method body, we want to start by identifying suitable indices for
    the start and end tiles. Since we'll place the tiles on the top and bottom rows,
    we only have to generate a single index, namely the column. The rows' indices
    will be 0 and `GRID_HEIGHT-1` respectively.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于方法体，我们希望首先确定适合的起始和结束瓦片的索引。由于我们将在顶部和底部行放置瓦片，因此我们只需要生成一个索引，即列。行的索引分别为0和`GRID_HEIGHT-1`。
- en: 'To do this, we''ll select a column index at random and check whether the location
    is suitable for entry node. For the entry node, we need to ensure that there''s
    no tile above. Likewise, for the exit node, we need to ensure that there''s nothing
    below us:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将随机选择一个列索引，并检查该位置是否适合作为入口节点。对于入口节点，我们需要确保上方没有瓦片。同样，对于出口节点，我们需要确保下方没有东西：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the `while` loops like this needs to be approached with extreme caution.
    If a valid tile did not exist, the program will hang and crash. In this case,
    we can be sure that there's always a valid tile due to the way the algorithm works.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用`while`循环需要极度谨慎。如果不存在有效的瓦片，程序将挂起并崩溃。在这种情况下，由于算法的工作方式，我们可以确保始终存在有效的瓦片。
- en: 'Now that we have the start and end nodes identified, all that''s left is to
    set the nodes as the correct type of tiles. The entry node needs to be set to
    `TILE::WALL_ENTRANCE`, and the exit node has to be set to `TILE::WALL_DOOR_LOCKED`,
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了起点和终点节点，剩下的就是将节点设置为正确类型的瓦片。入口节点需要设置为`TILE::WALL_ENTRANCE`，出口节点必须设置为`TILE::WALL_DOOR_LOCKED`，如下所示：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that this function is finished, we just need to make a call to it once
    a level is generated. We''ll do this at the end of the `Level::GenreateLevel`
    function right after we calculate the textures:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数已经完成，我们只需要在生成关卡后调用它。我们将在`Level::GenreateLevel`函数的末尾调用它，就在我们计算纹理之后：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting a player's spawn location
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置玩家的生成位置
- en: Now we have identified the entrance and exit nodes, we need to move our player
    accordingly. The code to generate a start node lies in the level class, so we're
    going to need to add a function that will return this start location. We could
    just generate the entrance and exit nodes in the game class, but this would be
    poor design. It's much better to place the code where it belongs and create `getter`
    and `setter` methods to access it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了入口和出口节点，我们需要相应地移动我们的玩家。生成起始节点的代码位于level类中，所以我们需要添加一个函数来返回这个起始位置。我们可以在游戏类中生成入口和出口节点，但这样设计很差。最好将代码放在它应该放置的地方，并创建`getter`和`setter`方法来访问它。
- en: However, before we can return the spawn location we actually have to calculate
    it! To do so, we need to know where the entry node is. Once the `Level::GenerateEntryExit`
    function has returned that information is lost. We could iterate over the bottom
    row of the tiles to find it, but that would be inefficient. Instead, we'll create
    a variable in `Level` class to hold this information and calculate the spawn location
    in `Level::GenerateEntryExit`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们返回生成位置之前，我们实际上需要计算它！为了这样做，我们需要知道入口节点在哪里。一旦`Level::GenerateEntryExit`函数返回了这些信息，它就丢失了。我们可以遍历瓦片的底部行来找到它，但那样效率低下。相反，我们将在`Level`类中创建一个变量来保存这些信息，并在`Level::GenerateEntryExit`中计算生成位置。
- en: 'Let''s start by declaring these variables in `Level.h`, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`Level.h`中声明这些变量，如下所示：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we know that the entrance to each level is going to be somewhere in the
    bottom row. This means that to calculate the spawn location we simply need to
    find the absolute position of the tile immediately above that. The `Level` class
    already has a function to get the absolute location of a tile, so it's as simple
    as making a single call to that function and passing the correct tile.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道每个关卡的入口都会在底部的某个地方。这意味着要计算生成位置，我们只需要找到正好在上面的瓦片的绝对位置。`Level`类已经有一个函数来获取瓦片的绝对位置，所以只需要调用一次该函数并传递正确的瓦片即可。
- en: While we're here we need to sneak in a little bit of similar code. We need to
    store the location of the new exit so that the `Level::UnlockDoor` function knows
    which tile to change. The Level class already has a variable for this information,
    so it's a simple one-liner code that we'll sneak in.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，我们需要偷偷加入一点类似的代码。我们需要存储新出口的位置，以便`Level::UnlockDoor`函数知道要更改哪个瓦片。`Level`类已经有了这个信息的变量，所以我们将偷偷加入一个简单的一行代码。
- en: 'Let''s append this behavior to the end of the `Level::GenerateEntryExit` function,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个行为追加到`Level::GenerateEntryExit`函数的末尾，如下所示：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now all that we need is a dead simple `getter` function to return the spawn
    location of the player, don''t forget the declaration:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一个非常简单的`getter`函数来返回玩家的生成位置，不要忘记声明：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now it's time to apply this spawn location to a player. `Game::GenerateLevel`
    is the function where we generate a level so we'll set the player's location here.
    After the call to `Level::GenerateLevel` we can fetch the spawn location, knowing
    that it will be updated, and use this value as the position for the player.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这个生成位置应用到玩家身上了。`Game::GenerateLevel`是我们生成关卡的函数，所以我们将在这里设置玩家的位置。在调用`Level::GenerateLevel`之后，我们可以获取生成位置，知道它将被更新，并将这个值作为玩家的位置。
- en: 'We can also now uncomment the code to spawn a key, our call to `Game::PopulateLevel`,
    and our call to `Game::SpawnRandomTiles`. With our level now setup these function
    will work as intended. Let''s get that code uncommented, and update `Game::GenerateLevel`
    with the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也可以取消注释生成钥匙的代码，我们对`Game::PopulateLevel`的调用，以及我们对`Game::SpawnRandomTiles`的调用。现在我们的关卡已经设置好了，这些函数将按预期工作。让我们取消注释那些代码，并更新`Game::GenerateLevel`如下：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Time to test the code. Now when we run the game, we should see not only a great
    looking maze, but also an entrance at the bottom with our player directly above
    it, and an exit at the top of the level:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试代码了。现在当我们运行游戏时，我们应该不仅能看到一个看起来很棒的迷宫，还能看到底部有一个入口，我们的玩家直接在上面，顶部有一个出口：
- en: '![Setting a player''s spawn location](img/B04920_09_17.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![设置玩家的生成位置](img/B04920_09_17.jpg)'
- en: Undoing the debug changes
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撤销调试更改
- en: 'The work on our dungeon generation is now complete! Let''s quickly revert the
    debug changes that we made to the code. We need to uncomment the line that enables
    the game view and the lighting code; both of these lines are in the `Game::Draw`
    function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地牢生成工作现在已经完成了！让我们快速撤销我们对代码所做的调试更改。我们需要取消注释启用游戏视图和照明代码的行；这两行都在`Game::Draw`函数中：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Instead of adding or removing the debug code like this, you could create a `dev`
    mode that can be toggled and is available in the DEBUG mode.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与其像这样添加或删除调试代码，不如创建一个可以在DEBUG模式下切换的`dev`模式。
- en: Exercises
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you assess your strengths and weaknesses in
    the material covered:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你测试本章内容的知识，这里有一些练习题供你练习。它们对于本书的其余部分并不是必要的，但是练习它们将帮助你评估你在所学内容中的优势和劣势：
- en: There are many different algorithms available that could be used to generate
    mazes, such as the randomized **Prim**'s algorithm and **Kruskal**'s algorithm.
    Choose one of these algorithms and have a go at replacing the recursive backtracking
    implementation with your own implementation.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有许多不同的算法可用于生成迷宫，例如随机的Prim算法和Kruskal算法。选择其中一个算法，尝试用你自己的实现替换递归回溯实现。
- en: We worked with quite a small level size. Try increasing it and varying the characteristics
    of the levels that are generated. Increase the number of rooms, their size, and
    so on.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了相当小的关卡尺寸。尝试增加关卡的大小，并改变生成的关卡的特征。增加房间的数量、它们的大小等等。
- en: You may have noticed that our torches are missing! Since we no longer load the
    level from a level file, we need to add them ourselves. Torches should be placed
    on tiles of the `TILE::WALL_TOP` type. Have a go at creating this function yourself.
    If you get stuck, you can always look at the next chapter's code for a hint on
    where to start.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的火炬不见了！因为我们不再从关卡文件中加载关卡，我们需要自己添加它们。火炬应该放置在`TILE::WALL_TOP`类型的瓦片上。尝试自己创建这个函数。如果遇到困难，你可以看看下一章的代码，找到开始的提示。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we learned how our game, which previously loaded predefined
    level data from a text file, can generate its own level data during runtime. This
    brings a great level of replayability to the game, ensuring gameplay stays fresh
    and challenging. We also used a function that we defined in the earlier chapters
    to bring more character to our levels; we used sprite effects to create a distinct
    feeling for each floor. Practically all aspects of our game are procedurally generated
    now, and we have a fully-fledged roguelike project under our belt.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了我们的游戏如何在运行时生成自己的关卡数据，而不是之前从文本文件中加载预定义的关卡数据。这为游戏带来了很高的可重玩性，确保游戏性保持新鲜和具有挑战性。我们还使用了在前几章中定义的函数，为我们的关卡增添更多特色；我们使用了精灵效果为每个楼层创造了独特的感觉。我们的游戏现在几乎所有方面都是程序生成的，我们已经完成了一个完整的Roguelike项目。
- en: Now that our work on the template project is complete, we'll be using the final
    chapter to take a look at component-based design. Procedural generation is all
    about flexibility. Therefore, it makes sense that we'd want to work with the most
    flexible architecture. Component-based architecture can achieve this. Having a
    good understanding of this design approach will help you progress and build larger,
    more flexible systems.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模板项目工作已经完成，我们将在最后一章中来看一下基于组件的设计。程序生成的关键在于灵活性。因此，我们希望使用最灵活的架构。基于组件的架构可以实现这一点。对这种设计方法有很好的理解将有助于您进步并构建更大、更灵活的系统。
