- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: The Boot-Up Procedure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动程序
- en: 'Now that the mechanisms, tools, and methodologies are in place, it is finally
    time to start looking at the procedures required to run the software on the target.
    Booting up an embedded system is a process that often requires knowledge of the
    specific system and the mechanisms in play. Depending on the target, there are
    a few indications we need to look for in the manual to find out what the system
    expects from the developer to successfully boot executables from the flash memory.
    This chapter will focus on the description of the boot process, with emphasis
    on the case of the Cortex-M microcontroller, which we decided to use as a reference
    platform. In particular, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在机制、工具和方法都已经就绪，是时候开始关注在目标上运行软件所需的程序了。启动嵌入式系统是一个通常需要了解特定系统和所涉及的机制的过程。根据目标的不同，我们需要在手册中查找一些指示，以了解系统对开发者的期望，以便成功从闪存中启动可执行文件。本章将专注于启动过程的描述，特别强调我们决定用作参考平台的
    Cortex-M 微控制器。特别是，我们将涵盖以下主题：
- en: The interrupt vector table
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断向量表
- en: Memory layout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存布局
- en: Building and running the boot code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行启动代码
- en: Multiple boot stages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个启动阶段
- en: By the end of this chapter, you will have an overview of main-loop embedded
    development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解主循环嵌入式开发的整体情况。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4)。
- en: The interrupt vector table
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断向量表
- en: The **interrupt vector table**, often abbreviated to **IVT** or simply **IV**,
    is an array of pointers to functions associated by the CPU to handle specific
    *exceptions*, such as faults, system service requests from the application, and
    interrupt requests from peripherals. The IVT is usually located at the beginning
    of the binary image and thus is stored starting from the lowest address in the
    flash memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断向量表**，通常缩写为 **IVT** 或简单地 **IV**，是一组与 CPU 关联的函数指针，用于处理特定的 *异常*，例如故障、来自应用程序的系统服务请求和来自外设的中断请求。IVT
    通常位于二进制图像的开头，因此从闪存的最低地址开始存储。'
- en: An interrupt request from a hardware component or peripheral will force the
    CPU to abruptly suspend the execution and execute the function at the associated
    position in the vector. For this reason, these functions are called **interrupt
    service routines** (or simply **ISRs**). Runtime exceptions and faults can be
    handled in the same way as hardware interrupts, so special service routines are
    associated with internal CPU triggers through the same table.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 来自硬件组件或外设的中断请求将迫使 CPU 突然暂停执行并执行向量中相关位置的功能。因此，这些函数被称为 **中断服务例程**（或简称 **ISRs**）。运行时异常和故障可以像处理硬件中断一样处理，因此通过相同的表关联了特殊的服务例程和内部
    CPU 触发器。
- en: The order of the ISRs enumerated in the vector, and their exact positions depend
    on the CPU architecture, the microcontroller model, and the peripherals supported.
    Each interrupt line corresponds to a predefined interrupt number and, depending
    on the microcontroller features, may be assigned a priority.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量中枚举的 ISRs 的顺序及其确切位置取决于 CPU 架构、微控制器型号和支持的外设。每条中断线对应一个预定义的中断号，并且根据微控制器的特性，可能被分配一个优先级。
- en: 'In a Cortex-M microcontroller, the first 16 positions in memory are reserved
    for storing the pointers to system handlers, which are architecture-dependent,
    and associated to different types of CPU runtime exceptions. The lowest address
    is used to store the initial value of the stack pointer, and the next 15 positions
    are reserved for system services and fault handlers. However, some of these positions
    are reserved and not connected to any event. The system exceptions that can be
    handled using separate service routines in a Cortex-M CPU are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cortex-M 微控制器中，内存的前16位位置被保留用于存储系统处理器的指针，这些指针与架构相关，并关联到不同类型的CPU运行时异常。最低地址用于存储栈指针的初始值，接下来的15个位置被保留用于系统服务和故障处理器。然而，其中一些位置被保留但没有连接到任何事件。在
    Cortex-M CPU 中可以使用单独的服务例程处理的系统异常如下：
- en: Reset
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复位
- en: '**Non-Maskable** **Interrupt** (**NMI**)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可屏蔽** **中断** (**NMI**)'
- en: Hard fault
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件故障
- en: Memory exception
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存异常
- en: Bus fault
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总线故障
- en: Usage fault
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用故障
- en: Supervisor call
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督调用
- en: Debug monitor event
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试监视器事件
- en: PendSV call
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PendSV调用
- en: System tick
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统滴答
- en: The order of the hardware interrupts, starting from position 16, depends on
    the microcontroller configuration and, thus, on the specific silicon model, as
    the interrupt configuration refers to specific components, interfaces, and external
    peripheral activities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中断的顺序，从位置16开始，取决于微控制器配置，因此取决于特定的硅模型，因为中断配置涉及特定的组件、接口和外部外围设备活动。
- en: A fully populated vector of external interrupt handlers for STM32F407 and LM3S
    targets can be found in this book’s code repository.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码仓库中可以找到STM32F407和LM3S目标的外部中断处理程序的全量向量。
- en: Startup code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动代码
- en: In order to boot a workable system, we need to define the interrupt vector and
    associate pointers with defined functions. A typical startup code file for our
    reference platform places the interrupt vector in a dedicated section using the
    GCC `section` attribute. As the section will be put at the beginning of the image,
    we must define our interrupt vector starting with the reserved space for the initial
    stack pointer, followed by the system exception handlers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动一个可工作的系统，我们需要定义中断向量和将指针与定义的函数关联起来。我们参考平台的典型启动代码文件使用GCC的`section`属性将中断向量放置在专用部分。由于该部分将被放置在映像的起始位置，我们必须从为初始堆栈指针保留的空间开始定义我们的中断向量，然后是系统异常处理程序。
- en: 'The zeros correspond to the positions of the reserved/unused slots:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 零对应于保留/未使用插槽的位置：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From this position on, we define the interrupt lines for the external peripherals
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个位置开始，我们定义外部外围设备的中断线如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The startup code must also include the implementation of every symbol referenced
    in the array. The handler can be defined as `void` procedures with no arguments,
    in the same format as the signature of the IV:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 启动代码还必须包括数组中引用的每个符号的实现。处理程序可以定义为无参数的`void`过程，其格式与IV签名相同。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The interrupt handler in this example never returns, as a result of an unrecoverable
    bus error, and hangs the system forever. Empty interrupt handlers can be associated
    to both system and external interrupts using weak symbols that can be overridden
    in the device driver modules by simply defining them again in the relevant code
    section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可恢复的总线错误，此示例中的中断处理程序永远不会返回，并使系统永远挂起。可以使用弱符号将空的中断处理程序与系统和外部中断关联起来，这些弱符号可以在设备驱动程序模块中通过在相关代码部分重新定义它们来覆盖。
- en: Reset handler
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置处理程序
- en: When the microcontroller is powered on, it starts the execution from the `reset`
    handler. This is a special ISR that does not return but rather performs initialization
    of the `.data` and `.bss` sections, and then calls the entry point of the application.
    The initialization of the `.data` and `.bss` sections consists of copying the
    initial value of the variables in the `.data` section in flash onto the actual
    section in RAM where variables are accessed at runtime and filling the `.bss`
    section in RAM with zeros so that the initial value of static symbols is guaranteed
    to be zero as per C convention.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当微控制器上电时，它从`reset`处理程序开始执行。这是一个特殊的ISR，它不会返回，而是执行`.data`和`.bss`段的初始化，然后调用应用程序的入口点。`.data`和`.bss`段的初始化包括将`.data`段中变量的初始值从闪存复制到运行时访问变量的实际RAM段，并在RAM中的`.bss`段用零填充，以确保静态符号的初始值按照C语言约定为零。
- en: 'The source and destination addresses of the `.data` and `.bss` sections in
    RAM are computed by the linker when generating the binary image and exported as
    pointers using the linker script. The implementation of `isr_reset` may look similar
    to the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`.data`和`.bss`段在RAM中的源地址和目标地址由链接器在生成二进制映像时计算，并通过链接脚本导出为指针。`isr_reset`的实现可能看起来像以下这样：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the variables in the `.bss` and `.data` sections have been initialized,
    it is finally possible to call the `main` function, which is the entry point of
    the application. The application code ensures that `main` never returns by implementing
    an infinite loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当`.bss`和`.data`段中的变量被初始化后，最终可以调用`main`函数，这是应用程序的入口点。应用程序代码通过实现一个无限循环来确保`main`永远不会返回。
- en: Allocating the stack
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配堆栈
- en: In order to comply with the **application binary interface** (**ABI**) of the
    CPU, it is required to assign space in memory for the execution stack. This can
    be done in different ways, but usually, it is preferable to mark the end of the
    stack space in the linker script and associate the stack space to a specific area
    in RAM, not in use by any section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合CPU的**应用程序二进制接口**（**ABI**），需要在内存中为执行栈分配空间。这可以通过不同的方式完成，但通常，在链接脚本中标记栈空间的末尾并将其关联到RAM中未使用的特定区域更为可取，而不是在某个部分中使用。
- en: The address obtained through the `END_STACK` symbol, exported by the linker
    script, points to the end of an unused area in RAM. As mentioned earlier, its
    value must be stored at the beginning of the vector table, at address `0` in our
    case, just before the IV. The address of the end of the stack has to be constant
    and cannot be calculated at runtime because the IV content is stored in the flash
    memory and thus cannot be modified later on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过链接脚本导出的`END_STACK`符号所获得的地址指向RAM中未使用区域的末尾。如前所述，其值必须存储在向量表的开头，在我们的例子中是在IV之前，地址为`0`。栈末尾的地址必须是常量，不能在运行时计算，因为IV内容存储在闪存中，因此以后不能修改。
- en: Properly sizing the execution stack in memory is a delicate task that includes
    the assessment of the whole code base, keeping in mind stack usage from local
    variables and the depth of the call trace at any time during the execution. The
    analysis of all the factors related to stack usage and troubleshooting will be
    part of a wider topic that is covered in the next chapter. Our simple startup
    code provided here has a stack size that is big enough to contain the local variables
    and the function call stack, as it is mapped by the linker script as far as possible
    from the `.bss` and `.data` sections. Further aspects of the placement of the
    stack are considered in [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149), *Memory
    Management*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中正确设置执行栈的大小是一项微妙的工作，它包括评估整个代码库，同时考虑到局部变量和执行过程中任何时刻的调用跟踪深度。与栈使用相关所有因素的分析和故障排除将作为下一章中更广泛主题的一部分进行讨论。这里提供的简单启动代码具有足够的栈大小，足以容纳局部变量和函数调用栈，因为它由链接脚本尽可能远地映射到`.bss`和`.data`部分。关于栈放置的进一步方面将在[*第五章*](B18730_05.xhtml#_idTextAnchor149)
    *内存管理*中进行考虑。
- en: Fault handlers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障处理程序
- en: 'Fault-related events are triggered by the CPU in the case of execution errors
    or policy violations. The CPU is able to detect a number of runtime errors, such
    as the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生执行错误或策略违规时，CPU会触发与故障相关的事件。CPU能够检测到许多运行时错误，例如以下内容：
- en: Attempting to execute code outside the memory areas marked as executable
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在标记为可执行的内存区域之外执行代码
- en: Fetching data or the next instruction to execute from an invalid location
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从无效位置获取数据或执行的下一条指令
- en: Illegal loading or storing using an unaligned address
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未对齐地址进行非法加载或存储
- en: Division by zero
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零除
- en: Trying to access unavailable coprocessor functionalities
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问不可用的协处理器功能
- en: Attempting to read/write/execute outside the memory areas allowed for the current
    running mode
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在当前运行模式下允许的内存区域之外进行读写/执行
- en: Some core microcontrollers support different types of exceptions depending on
    the type of error. The Cortex-M3/M4 can distinguish between bus errors, usage
    faults, memory access violations, and generic faults, triggering the related exception.
    In other, smaller systems, fewer details are available on the type of runtime
    error.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些核心微控制器根据错误类型支持不同类型的异常。Cortex-M3/M4可以根据总线错误、使用故障、内存访问违规和通用故障进行区分，触发相关异常。在其他较小的系统中，关于运行时错误类型的详细信息较少。
- en: Very often, a fault will make the system unusable or unable to continue the
    execution due to the CPU register values or the stack being corrupted. In some
    cases, even placing a breakpoint inside the exception handler is not sufficient
    to detect the cause of the problem, making debugging harder. Some CPUs support
    extended information on the cause of the fault, which is available through memory-mapped
    registers after the exception occurs. In the case of the Cortex-M3/M4, this information
    is available through the `0xE000ED28` on all Cortex-M3/M4 CPUs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，故障会使系统无法使用或无法继续执行，因为CPU寄存器值或栈被破坏。在某些情况下，即使在异常处理程序中放置断点也不足以检测问题的原因，这使得调试更加困难。一些CPU支持关于故障原因的扩展信息，这些信息在异常发生后可以通过内存映射寄存器获得。在Cortex-M3/M4的情况下，这些信息通过所有Cortex-M3/M4
    CPU上的`0xE000ED28`获得。
- en: Memory violations may be non-fatal if the corresponding exception handler implements
    some kind of recovery strategy and can be useful to detect and react to the fault
    at runtime, which is especially useful in multithreaded environments, as we will
    see in more detail in [*Chapter 9*](B18730_09.xhtml#_idTextAnchor311), *Distributed
    Systems and* *IoT Architecture*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相应的异常处理程序实现了某种恢复策略，内存违规可能不会导致严重后果，并且可以在运行时检测和响应故障，这在多线程环境中特别有用，我们将在[第9章](B18730_09.xhtml#_idTextAnchor311)“分布式系统和物联网架构”中更详细地看到。
- en: Memory layout
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存布局
- en: The linker script, as we already know, contains the instructions for the linker
    on how to assemble the components of an embedded system. More specifically, it
    describes the sections mapped in memory and how they are deployed into the flash
    and the RAM of the target, as in the example provided in [*Chapter 2*](B18730_02.xhtml#_idTextAnchor055),
    *Work Environment and* *Workflow Optimization*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，链接脚本包含了链接器如何组装嵌入式系统组件的指令。更具体地说，它描述了映射到内存中的部分以及它们如何部署到目标机的闪存和RAM中，如[第2章](B18730_02.xhtml#_idTextAnchor055)“工作环境和工作流程优化”中提供的示例所示。
- en: In most embedded devices, and in particular our reference platform, the `.text`
    output section in the linker script, which contains all the executable code, should
    also include the special input section dedicated to storing the IV at the very
    beginning of the executable image.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数嵌入式设备中，尤其是在我们的参考平台上，链接脚本中的`.text`输出部分，其中包含所有可执行代码，还应包括专门用于在可执行图像开头存储IV的特殊输入部分。
- en: 'We integrate the linker script by adding the `.isr_vector` section at the beginning
    of the `.text` output section before the rest of the code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`.text`输出部分的开头添加`.isr_vector`部分来集成链接脚本，在其余代码之前：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining a read-only area in flash, which is dedicated to the vector table,
    is the only strict requirement for our system to boot up properly, as the address
    of the `isr_reset` function is retrieved by the CPU at boot time from the `0x04`
    address in memory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在闪存中定义一个只读区域，该区域专门用于向量表，是我们系统正确启动的唯一严格要求，因为CPU在启动时从内存中的`0x04`地址检索`isr_reset`函数的地址。
- en: 'Right after the definition for the text and read-only areas in flash, the linker
    script should export the value of the current address, which is the beginning
    of the `.data` output section stored in flash. This section contains the initial
    value of all the global and static variables that have been initialized in the
    code. In the example linker script, the beginning of the `.data` section is marked
    by the `_stored_data` linker script variable, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义闪存中的文本和只读区域之后，链接脚本应导出当前地址的值，即存储在闪存中的`.data`输出部分的开始。该部分包含在代码中初始化的所有全局和静态变量的初始值。在示例链接脚本中，`.data`部分的开始由`_stored_data`链接脚本变量标记，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The data section will eventually be mapped in RAM, but its initialization is
    done manually in the `isr_reset` function by copying the content from flash to
    the actual region designated to the `.data` section in RAM. The linker script
    provides a mechanism to separate the `AT` keyword in the definition of the section.
    If no `AT` keyword is specified, the LMA is, by default, set to the same address
    as the VMA. In our case, the VMA of the `.data` input section is in RAM and exported
    using the `_start_data` pointer, which will be used by `isr_vector` as the destination
    address when copying the values of the symbols stored from flash. The LMA of `.data`,
    though, is located in the flash memory, so we set the LMA address to the `_stored_data`
    pointer in flash, while defining the `.data` output section:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据部分最终将在RAM中映射，但其初始化是通过`isr_reset`函数手动完成的，该函数通过从闪存复制内容到RAM中实际指定的`.data`部分区域。链接脚本提供了一个机制来分离定义部分中的`AT`关键字。如果没有指定`AT`关键字，则默认情况下，LMA设置为与VMA相同的地址。在我们的例子中，`.data`输入部分的VMA位于RAM中，并通过`_start_data`指针导出，该指针将被`isr_vector`用作复制从闪存存储的符号值的目标地址。然而，`.data`的LMA位于闪存中，因此我们将LMA地址设置为闪存中的`_stored_data`指针，同时定义`.data`输出部分：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For `.bss`, there is no LMA, as no data is stored in the image for this section.
    When including the `.bss` output section, its VMA will automatically be set to
    the end of the `.data` output section:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.bss`，没有LMA，因为该部分在图像中不存储任何数据。当包含`.bss`输出部分时，其VMA将自动设置为`.data`输出部分的末尾：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, in this design, the linker is expected to provide the initial value
    for the execution stack. Using the highest address in memory is a common choice
    for a single-threaded application, even though, as discussed in the next chapter,
    this may cause problems in the case of stack overflow. For this example, however,
    this is an acceptable solution, and we define the `END_STACK` symbol by adding
    the following line to the linker script:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个设计中，我们期望链接器提供执行堆栈的初始值。使用内存中的最高地址是单线程应用程序的一个常见选择，尽管，如下一章所讨论的，这可能会在堆栈溢出的情况下引起问题。然而，对于这个例子来说，这是一个可接受的解决方案，我们通过在链接脚本中添加以下行来定义
    `END_STACK` 符号：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To better understand where each symbol will be placed in memory, variable definitions
    can be added to the startup file in different places within the code. This way,
    we can check the locations where the variables are stored in memory when running
    the executable in the debugger for the first time. Supposing that we have variables
    stored in both the `.data` and `.bss` output sections, the memory layout for the
    example startup code may look like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解每个符号在内存中的位置，可以在代码的不同位置添加变量定义到启动文件中。这样，我们可以在第一次在调试器中运行可执行文件时检查变量在内存中的存储位置。假设我们在
    `.data` 和 `.bss` 输出部分中存储了变量，示例启动代码的内存布局可能如下所示：
- en: '![Figure 4.1 – Memory layout in the example startup code](img/B18730_04_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 示例启动代码中的内存布局](img/B18730_04_01.jpg)'
- en: Figure 4.1 – Memory layout in the example startup code
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 示例启动代码中的内存布局
- en: 'When the executable is linked, the symbols are automatically set at compile
    time to indicate the beginning and the end of each section in memory. In our case,
    variables indicating the beginning and the end of each section are automatically
    assigned to the right value, depending on the size of the sections that the linker
    will include when creating the executable. Since the size of each section is known
    at compile time, the linker is able to identify those situations where the `.text`
    and `.data` sections do not fit into the flash, and a linker error is generated
    at the end of the build. Creating a map file is useful for checking the size and
    the location of each symbol. In our boot-up example code, here is how the `.text`
    section appears within the map file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当可执行文件链接时，符号在编译时自动设置，以指示内存中每个部分的开始和结束。在我们的例子中，指示每个部分开始和结束的变量会根据链接器在创建可执行文件时包含的各部分的大小自动分配正确的值。由于每个部分的大小在编译时是已知的，链接器能够识别出
    `.text` 和 `.data` 部分无法适应闪存的情况，并在构建结束时生成链接器错误。创建映射文件对于检查每个符号的大小和位置很有用。在我们的引导示例代码中，映射文件中
    `.text` 部分如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, we can find the boundaries of each section, exported by the linker
    script at compile time:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在编译时通过链接脚本找到每个部分的边界：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `.rodata` input section, which is empty in this minimalist example, is mapped
    in the flash memory area, in between `.text` and the data LMA. This is reserved
    for constant symbols because constants do not have to be mapped in RAM. It is
    advisable to enforce the `const` C modifier when defining constant symbols because
    RAM is often our most precious resource, and in some cases, even sparing a few
    bytes of writable memory by moving constant symbols to the flash can make a difference
    in the project development, as flash memory is usually much bigger, and its usage
    can be easily determined at linking time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`.rodata` 输入部分，在这个极简示例中为空，映射在闪存区域中，位于 `.text` 和数据 LMA 之间。这部分是为常量符号预留的，因为常量不需要映射到
    RAM 中。在定义常量符号时强制使用 `const` C 修饰符是明智的，因为 RAM 经常是我们最宝贵的资源，在某些情况下，通过将常量符号移动到闪存中，即使节省几个字节的可写内存也可能对项目开发产生影响，因为闪存通常要大得多，其使用情况在链接时可以很容易地确定。'
- en: Building and running the boot code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行引导代码
- en: The example provided here is one of the simplest executable images that can
    be run on the target. To assemble, compile, and link everything together, we can
    use a simple makefile that automates all the steps and allows us to focus on our
    software life cycle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的示例是可以在目标设备上运行的简单可执行镜像之一。为了汇编、编译和链接所有内容，我们可以使用一个简单的 makefile，它自动化所有步骤，并允许我们专注于我们的软件生命周期。
- en: When the image is ready, we can transfer it to the real target or alternatively,
    run it using an emulator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像准备就绪时，我们可以将其传输到实际目标设备，或者使用仿真器运行它。
- en: The makefile
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile
- en: A very basic makefile to build our startup application describes the final target
    (`image.bin`) and the intermediate steps required to build it. Makefile syntax
    is, in general, very vast, and covering all the functions provided by **Make**
    is outside the scope of this book. However, the few concepts explained here should
    be sufficient to get up and running on automating the build process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基本的 Makefile 用于构建我们的启动应用程序，描述了最终目标（`image.bin`）以及构建它所需的中间步骤。一般来说，Makefile
    语法非常广泛，涵盖本书范围之外的所有 **Make** 提供的功能。然而，这里解释的几个概念应该足以让你开始自动化构建过程。
- en: Defining the targets for our makefile, in this case, is quite simple. The `startup.c`
    source file, containing the IV, some exception handlers, and the main and the
    global variables we used in the example, can be compiled and assembled into a
    `startup.o` object file. The linker uses the indications provided in the `target.ld`
    linker script to deploy the symbols in the correct sections, producing the `.elf`
    executable image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，定义我们的 Makefile 的目标相当简单。包含 IV、一些异常处理程序以及我们在示例中使用的 main 和全局变量的 `startup.c`
    源文件可以被编译和汇编成一个 `startup.o` 对象文件。链接器使用 `target.ld` 链接器脚本中提供的指示来部署符号到正确的部分，生成 `.elf`
    可执行映像。
- en: 'Finally, `objcopy` is used to transform the `.elf` executable into a binary
    image, which can be transferred to the target or run using QEMU:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `objcopy` 将 `.elf` 可执行文件转换为二进制映像，该映像可以传输到目标或使用 QEMU 运行：
- en: '![Figure 4.2 – Build steps and dependencies](img/B18730_04_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 构建步骤和依赖关系](img/B18730_04_02.jpg)'
- en: Figure 4.2 – Build steps and dependencies
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 构建步骤和依赖关系
- en: 'The makefile should contain a few configuration variables to describe the toolchain.
    The `=` assignment operator allows you to set values for the variables when invoking
    the `make` command. Some of these variables are implicitly used as default during
    compilation and linking. It is common practice to define the toolchain prefix
    using the `CROSS_COMPILE` variable and use that as a prefix for the tools involved
    in the build process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 应该包含一些配置变量来描述工具链。`=` 赋值运算符允许你在调用 `make` 命令时为变量设置值。其中一些变量在编译和链接过程中默认使用。通常使用
    `CROSS_COMPILE` 变量来定义工具链前缀，并将其用作构建过程中涉及的工具的前缀：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Changing the default cross compiler for this project can be done by running
    `make` and assigning a different value to the `CROSS_COMPILE` environment variable.
    All the names of the tools are prefixed by the `CROSS_COMPILE` variable expansion
    so that the build steps will use the components from the given toolchain. In the
    same way, we can define our default flags for the compiler and the linker:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `make` 并将不同的值分配给 `CROSS_COMPILE` 环境变量来更改此项目的默认交叉编译器。所有工具的名称都以前缀 `CROSS_COMPILE`
    扩展，以便构建步骤将使用给定工具链的组件。同样，我们可以定义编译器和链接器的默认标志：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When invoked with no arguments, Make builds the first target defined in the
    `image.bin` makefile. A new target for `image.bin` can be defined as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当不带参数调用时，Make 会构建 `image.bin` Makefile 中定义的第一个目标。可以为 `image.bin` 定义一个新的目标，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `$@` and `$^` variables will be replaced in the recipe with the target
    and the list of dependencies, respectively. This means that, in the example, the
    makefile will process the recipe as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`$@` 和 `$^` 变量将在配方中分别替换为目标和依赖项列表。这意味着在示例中，Makefile 将按照以下方式处理配方：'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the command we need to produce a raw binary image from the `.``elf`
    executable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要从 `.elf` 可执行文件生成原始二进制映像的命令。
- en: 'Similarly, we can define the recipe for `image.elf`, which is the linking step,
    depending on the `startup.o` compiled object file, and the linker script:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以定义 `image.elf` 的配方，这是链接步骤，依赖于编译的 `startup.o` 对象文件和链接器脚本：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, we are not going to use the `$^` variable for the list of dependencies,
    as the recipe includes the linker script in the linker command line using `LDFLAGS`.
    The recipe for the linking step will be expanded by `main` as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不会使用 `$^` 变量来表示依赖项列表，因为配方在链接命令行中使用 `LDFLAGS` 包含了链接器脚本。链接步骤的配方将由 `main`
    如下展开：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using `-nostdlib` ensures that no default C libraries are linked automatically
    to the project, among those available in the toolchain, that would, by default,
    be linked in to produce the executables. This ensures that no symbols are automatically
    pulled.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-nostdlib` 确保不会自动将工具链中可用的默认 C 库链接到项目中，这些库默认情况下会被链接到可执行文件中。这确保了不会自动提取任何符号。
- en: 'The last step for resolving dependencies is compiling the source code into
    the object file. This is done in a makefile implicit recipe that eventually gets
    translated to the following when using the project default values:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决依赖关系的最后一步是将源代码编译成目标文件。这是在 makefile 中隐式配方中完成的，最终在项目默认值使用时转换为以下内容：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `-mcpu=cortex-m3` flag ensures that the code produced is compatible
    with Cortex-M targets from Cortex-M3 onward. The same binary can, in fact, eventually
    be run on any Cortex-M3, M4, or M7 target, and it is generic until we do not decide
    to use any CPU-specific feature, or define hardware interrupt handlers, as the
    order of those depends on the specific microcontroller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-mcpu=cortex-m3` 标志确保生成的代码与 Cortex-M3 及以后的 Cortex-M 目标兼容。实际上，相同的二进制文件最终可以在任何
    Cortex-M3、M4 或 M7 目标上运行，并且它是通用的，直到我们决定使用任何特定的 CPU 特性，或者定义硬件中断处理程序，因为它们的顺序取决于特定的微控制器。
- en: 'By defining a `clean` target, at any point in time, it is possible to start
    over from a clean slate, by removing the intermediate targets and the final image
    and running `make` again. The `clean` target is also often included in the same
    makefile. In our example, it looks as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个 `clean` 目标，在任何时候，都可以通过删除中间目标和最终镜像并再次运行 `make` 来从头开始。`clean` 目标通常也包含在同一个
    makefile 中。在我们的例子中，它看起来如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `clean` target usually has no dependencies. Running `make clean` removes
    all the intermediate and final targets as instructed in the recipe, leaving the
    sources and the linker script untouched.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean` 目标通常没有依赖。运行 `make clean` 会按照配方中的指示删除所有中间和最终目标，同时保留源文件和链接脚本不变。'
- en: Running the application
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Once the image is built, we can run it on a real target or using `qemu-system-arm`,
    as explained in [*Chapter 2*](B18730_02.xhtml#_idTextAnchor055), *Work Environment
    and Workflow Optimization*. Since the application will produce no output while
    running on the emulator, to investigate more about the actual behavior of the
    software, we need to attach a debugger to it. When running the emulator, `qemu-system-arm`
    must be invoked with the `-S` option, meaning stop, so that it will not start
    the execution until the debugger is connected. Since the `CFLAGS` variable in
    the previous step contains the `-g` option, all the symbol names will be kept
    in the `.elf` executable so that the debugger can follow the execution through
    the code line by line, placing breakpoints and checking the values for the variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了镜像，我们可以在真实目标上运行它，或者使用 `qemu-system-arm`，如[*第2章*](B18730_02.xhtml#_idTextAnchor055)中所述，*工作环境和流程优化*。由于应用程序在模拟器上运行时不会产生输出，为了更深入地了解软件的实际行为，我们需要将其附加到调试器上。在运行模拟器时，必须使用
    `-S` 选项调用 `qemu-system-arm`，这意味着停止，这样它就不会在调试器连接之前开始执行。由于前一步骤中的 `CFLAGS` 变量包含 `-g`
    选项，所有符号名称都将保留在 `.elf` 可执行文件中，以便调试器可以逐行跟踪代码执行，设置断点并检查变量的值。
- en: Following the procedures step by step and comparing addresses and values with
    those in the `.map` files can be helpful in understanding what is happening and
    how the context changes through the entire boot sequence.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步遵循程序，并将地址和值与 `.map` 文件中的进行比较，有助于理解正在发生的事情以及整个引导过程中上下文是如何变化的。
- en: Multiple boot stages
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个引导阶段
- en: Booting a target through a bootloader is useful in several cases. In a real-life
    scenario, being able to update the running software on devices in a remote location
    means that developers are able to fix bugs and introduce new features after the
    first version of the embedded system has been deployed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引导加载程序引导目标在多种情况下很有用。在实际场景中，能够在远程位置的设备上更新正在运行的软件意味着开发人员能够在嵌入式系统第一版部署后修复错误和引入新功能。
- en: 'This represents a huge advantage for maintenance when a bug is discovered in
    the field, or when the software has to be re-engineered to adapt to changes in
    requirements. Bootloaders may implement automatic remote upgrades and other useful
    features, such as the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这在发现现场错误或软件需要重新设计以适应需求变化时，对维护来说是一个巨大的优势。引导加载程序可以实现自动远程升级和其他有用的功能，例如以下内容：
- en: Loading of the application image from an external storage
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部存储加载应用程序镜像
- en: Verification of the integrity of the application image before boot
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引导前验证应用程序镜像的完整性
- en: Failover mechanisms in case of a corrupted application
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序损坏情况下的故障转移机制
- en: Multiple bootloaders can be chained to perform a multiple-stage boot sequence.
    This allows you to have separate software images for the multiple boot stages,
    which can be uploaded to the flash independently. A first-stage boot, when present,
    is usually very simple and used to simply select the entry point for the next
    stage. However, in some cases, early stages benefit from slightly more complex
    designs to implement software upgrade mechanisms or other features. The example
    proposed here shows the separation between two boot stages, achieved using the
    functionalities available in many Cortex-M processors. The only purpose of this
    simple bootloader is to initialize the system for booting the application in the
    next stage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以链式连接多个引导加载程序以执行多阶段引导序列。这允许您为多个引导阶段拥有独立的软件映像，这些映像可以独立上传到闪存。如果存在，第一阶段引导通常非常简单，仅用于简单地选择下一阶段的入口点。然而，在某些情况下，早期阶段可能从稍微复杂的设计中受益，以实现软件升级机制或其他功能。这里提出的示例展示了使用许多Cortex-M处理器提供的功能实现的两个引导阶段之间的分离。这个简单的引导加载程序的唯一目的是初始化系统，以便在下一阶段引导应用程序。
- en: Bootloader
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: The first-stage bootloader starts up as a normal standalone application. Its
    IV must be located at the beginning of the flash, and the `reset` handler initializes
    the associated `.data` and `.bss` memory sections, like in a normal single-stage
    boot. A partition at the beginning of the flash should be reserved for the `.text`
    and `.data` bootloader sections. To do so, the linker script for the bootloader
    will only include the beginning of the flash memory, and that of the application
    will have an offset of the same size.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段引导加载程序作为正常独立应用程序启动。其IV必须位于闪存的开始处，`reset`处理程序初始化相关的`.data`和`.bss`内存段，就像在正常单阶段引导中一样。闪存开始处应预留一个分区用于`.text`和`.data`引导加载程序段。为此，引导加载程序的链接脚本将仅包括闪存内存的开始部分，而应用程序的链接脚本将具有相同大小的偏移量。
- en: 'The bootloader and the application will, in fact, be built into two separate
    binaries. This way, the two linker scripts can have the same name for sections,
    and differ only by the description of the `FLASH` partition in the linker memory.
    Nevertheless, the method suggested next is only one of the possible configurations:
    a more complex setup may benefit from exporting the full geometry using the start
    addresses and sizes of all the partitions.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，引导加载程序和应用程序将被构建成两个独立的二进制文件。这样，两个链接脚本可以为段使用相同的名称，而仅在链接内存中`FLASH`分区的描述上有所不同。尽管如此，下面建议的方法只是可能配置之一：更复杂的设置可能从使用所有分区的起始地址和大小导出完整几何形状中受益。
- en: 'If we want to reserve 4 KB for the bootloader partition, we can hardcode the
    `FLASH` area in the bootloader linker script as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为引导加载程序分区预留4 KB，我们可以在引导加载程序的链接脚本中硬编码`FLASH`区域如下：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, the linker script of the application has an offset in the origin,
    hardcoded to the size of the bootloader, so that the `.text` output section of
    the application always starts at the `0x1000` address. From the application point
    of view, the whole `FLASH` area starts from the `0x00001000` address:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，应用程序的链接脚本在原点有一个偏移量，硬编码为引导加载程序的大小，这样应用程序的`.text`输出段始终从`0x1000`地址开始。从应用程序的角度来看，整个`FLASH`区域从`0x00001000`地址开始：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The geometry of the flash, in this case, would be the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，闪存的几何形状如下所示：
- en: "![Figure 4.3 – Layout of the flash content, showing the sections of both \uFEFF\
    the bootloader and the application](img/B18730_04_03.jpg)"
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 闪存内容布局，显示引导加载程序和应用程序的段](img/B18730_04_03.jpg)'
- en: Figure 4.3 – Layout of the flash content, showing the sections of both the bootloader
    and the application
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 闪存内容布局，显示引导加载程序和应用程序的段
- en: '`reset` handler in the IV of the application stored with offset `4` inside
    the vector table.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中断向量表（IV）中的`reset`处理程序存储在向量表内的偏移量`4`处。
- en: 'The application may enforce its own memory layout. At startup, it will be able
    to initialize the new `.data` and `.bss` sections according to the new geometry
    and even define a new initial stack pointer and IV. The bootloader can obtain
    these two pointers by reading the first two words of the IV stored at address
    `0x1000`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以强制实施自己的内存布局。在启动时，它将能够根据新的几何形状初始化新的`.data`和`.bss`段，甚至可以定义新的初始堆栈指针和IV。引导加载程序可以通过读取存储在地址`0x1000`的IV中的前两个单词来获取这两个指针：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before jumping to the entry point of the application, we want to reset the
    main execution stack pointer to the end address of the stack. Since MSP is a special-purpose
    CPU register in the ARMv7-M architecture, it can only be written using the assembly
    instruction **move special from register** (**msr**). The following code is inlined
    in the bootloader to set the correct application stack pointer to the value stored
    in flash at the beginning of the application image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到应用程序的入口点之前，我们希望将主执行堆栈指针重置为堆栈的末尾地址。由于MSP是ARMv7-M架构中的一个专用CPU寄存器，它只能使用汇编指令**从寄存器移动特殊**（**msr**）来写入。以下代码在引导加载程序中内联，以将正确的应用程序堆栈指针设置为存储在应用程序映像开头于闪存的值：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Cortex-M3 and other, more powerful, 32-bit Cortex-M CPUs, a control register
    is present within the system control block area, which can be used to specify
    an offset for the vector table at runtime. This is the `0xE000ED08`. Writing the
    application offset to this register means that, from that moment, the new IV is
    in place, and the interrupt handlers defined in the application will be executed
    upon exceptions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cortex-M3和其他更强大的32位Cortex-M CPU中，系统控制块区域中存在一个控制寄存器，可以在运行时指定向量表的偏移量。这是`0xE000ED08`。将应用程序偏移量写入此寄存器意味着从那时起，新的IV就位了，并且应用程序中定义的中断处理程序将在异常发生时执行：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When this mechanism is not available, like in Cortex-M0 microcontrollers, which
    do not have a VTOR, the application will still share the interrupt vector with
    the bootloader after it is started. To provide a different set of interrupt handlers,
    the relevant function pointers can be stored in a different area of the flash,
    and the bootloader can check whether the application had been started or not at
    every interrupt, and in case it was, call the respective handler from the table
    in the application space.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当此机制不可用时，例如在Cortex-M0微控制器中，它没有VTOR，应用程序在启动后仍然会与引导加载程序共享中断向量。为了提供不同的一组中断处理程序，相关的函数指针可以存储在闪存的不同区域，引导加载程序可以在每次中断时检查应用程序是否已启动，如果是的话，则从应用程序空间中的表中调用相应的处理程序。
- en: When handling pointers to interrupt handlers and other exception routines, it
    is important to consider that an exception can occur at any time while running
    the code, especially if the bootloader has enabled peripherals or activated timers
    in the CPU. To prevent unpredictable jumps to interrupt routine, it is advisable
    to disable all the interrupts while the pointers are being updated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理指向中断处理程序和其他异常例程的指针时，重要的是要考虑在代码运行期间任何时间都可能发生异常，尤其是如果引导加载程序已启用CPU中的外围设备或激活了定时器。为了防止不可预测地跳转到中断例程，在更新指针时建议禁用所有中断。
- en: 'The instruction set provides mechanisms to temporarily mask all the interrupts.
    While running with the interrupt globally disabled, the execution cannot be interrupted
    by any exception, excluding NMI. In Cortex-M, interrupts can be temporarily disabled
    by using the `cpsid i` assembly statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集提供了暂时屏蔽所有中断的机制。在全局禁用中断的情况下运行时，执行不能被任何异常中断，除了NMI。在Cortex-M中，可以使用`cpsid i`汇编语句暂时禁用中断：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To enable the interrupt again, the `cpsie i` instruction is used:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要再次启用中断，使用`cpsie i`指令：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Running code with interrupts disabled should be done as much as strictly necessary,
    and not done only in special cases where other solutions are not available because
    it impacts the latency of the entire system. In this special case, it is used
    to ensure that no service routines are invoked while the IV is being relocated.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用中断的情况下运行代码应尽可能严格地执行，而不仅仅是在没有其他解决方案的特殊情况下，因为这会影响整个系统的延迟。在这种情况下，它被用来确保在IV被重新定位时不会调用任何服务例程。
- en: 'The last action performed by the bootloader in its short life is a direct jump
    to the `reset` handler in the application IV. Since the function will never return,
    and a brand-new stack space has been just allocated, we force an unconditional
    jump by setting the value CPU program counter register to start executing from
    the address of `app_entry`, which is pointed to by `isr_reset`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序在其短暂的生命周期中执行的最后一个操作是直接跳转到应用IV中的`reset`处理程序。由于该函数永远不会返回，并且刚刚分配了一个全新的堆栈空间，我们通过将CPU程序计数器寄存器的值设置为从`app_entry`地址开始执行来强制无条件跳转，`app_entry`由`isr_reset`指向：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In our example, this function will never return, since we replaced the execution
    stack pointer value. This is compatible with the behavior foreseen by the `reset`
    handler, which will, in turn, jump to the main function in the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这个函数永远不会返回，因为我们替换了执行栈指针的值。这与 `reset` 处理器预期的行为兼容，它反过来会跳转到应用程序中的主函数。
- en: Building the image
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Since the two executables will be built in separate `.elf` files, there are
    mechanisms to join the content of the two partitions together into a single image,
    to upload to the target, or to use in the emulator. The bootloader partition can
    be filled with zeros up to its size by using the `--pad-to` option of `objcopy`
    when converting the `.elf` executable into the binary image. Wearing the flash
    can be reduced by using the `0xFF` value to fill the padding area, which can be
    obtained by passing the `--gap-` option `fill=0xFF`. The resultant image `bootloader.bin`
    will be exactly `4096` bytes so that the application image can be concatenated
    at the end of it. The steps to compose an image containing the two partitions
    are the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个可执行文件将分别构建在单独的 `.elf` 文件中，存在机制将两个分区的内文合并成一个单一镜像，以便上传到目标设备或用于仿真器。可以通过使用 `objcopy`
    的 `--pad-to` 选项将引导加载分区填充至其大小，当将 `.elf` 可执行文件转换为二进制镜像时。使用 `0xFF` 值填充填充区域可以减少闪存的使用，这可以通过传递
    `--gap-` 选项 `fill=0xFF` 来实现。生成的镜像 `bootloader.bin` 将正好是 `4096` 字节，以便在末尾附加应用程序镜像。组成包含两个分区的镜像的步骤如下：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looking at the resultant `image.bin` file with a hexadecimal editor, it should
    be possible to identify the end of the bootloader within the first partition by
    recognizing the zero pattern that is used by `objdump` as padding, and the application
    code starting at address `0x1000`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制编辑器查看生成的 `image.bin` 文件，应该能够通过识别 `objdump` 使用的填充零模式来识别第一个分区中引导加载器的结束，以及从地址
    `0x1000` 开始的应用程序代码。
- en: By aligning the application offset to the start of a physical page in flash
    instead, it is even possible to upload the two images in separate steps, allowing
    you, for instance, to upgrade the application code, leaving the bootloader partition
    untouched.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将应用程序偏移量对齐到闪存中物理页面的起始处，甚至可以在单独的步骤中上传两个镜像，例如，允许您升级应用程序代码，同时不修改引导加载分区。
- en: Debugging a multi-stage system
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试多阶段系统
- en: The separation between two or more stages implies that the symbols of the two
    executables are linked into different `.elf` files. Debugging using both sets
    of symbols is still possible, but the symbols from both `.elf` files must be loaded
    in the debugger in two steps. When the debugger is executed using the symbols
    from the bootloader, by adding the `bootloader.elf` file as an argument, or using
    the file command from the GDB command line, the symbols of the bootloader are
    loaded in the symbol table for the debugging session. To add the symbols from
    the application `.elf` file, we can add the corresponding `.elf` at a later stage
    using `add-symbol-file`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或更多阶段的分离意味着两个可执行文件的符号被链接到不同的 `.elf` 文件中。使用两组符号进行调试仍然可能，但必须分两步在调试器中加载来自两个 `.elf`
    文件的符号。当使用引导加载器的符号执行调试器时，通过将 `bootloader.elf` 文件作为参数添加，或使用 GDB 命令行的文件命令，引导加载器的符号被加载到调试会话的符号表中。要添加来自应用程序
    `.elf` 文件的符号，我们可以在稍后阶段使用 `add-symbol-file` 添加相应的 `.elf` 文件。
- en: 'The `add-symbol-file` directive, unlike `file`, ensures that the symbols of
    a second executable are loaded without overwriting the ones previously loaded
    and allows you to specify the address where the `.text` section starts. In the
    system composed in this example, there is no clash between the two sets of symbols,
    as the two partitions do not share any area on the flash. The debugger can continue
    the execution normally and still have all the symbols available after the bootloader
    jumps to the application entry point:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `file` 命令不同，`add-symbol-file` 指令确保第二个可执行文件的符号被加载，而不会覆盖之前加载的符号，并允许您指定 `.text`
    部分开始的地址。在本文例中构建的系统，两组符号之间没有冲突，因为两个分区在闪存上不共享任何区域。调试器可以正常继续执行，并在引导加载器跳转到应用程序入口点后仍然拥有所有符号：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Sharing the same names for sections and symbols between the two executables
    is legal, as the two executables are self-contained and not linked together. The
    debugger is aware of duplicate names when we refer to a symbol by its name during
    debugging. For example, if we place a breakpoint on `main` and we have correctly
    loaded the symbols from both executables, the breakpoint will be set on both locations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个可执行文件之间共享相同的段和符号名称是合法的，因为这两个可执行文件是自包含的，并且没有链接在一起。当我们在调试期间通过名称引用符号时，调试器会意识到重复的名称。例如，如果我们放置一个断点在
    `main` 上，并且我们已经正确加载了两个可执行文件的符号，那么断点将在两个位置设置：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Separate boot stages are completely isolated from each other and do not share
    any executable code. For this reason, software distributed with different licenses,
    even if not compatible with each other, can run in separate boot stages. As seen
    in the example, the two software images can use the same symbol names without
    creating conflicts, as they would have been running on two separate systems.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的引导阶段彼此完全隔离，不共享任何可执行代码。因此，带有不同许可证的软件，即使它们不兼容，也可以在不同的引导阶段中运行。正如示例所示，两个软件映像可以使用相同的符号名称而不产生冲突，就像它们在两个不同的系统上运行一样。
- en: In some cases, however, multiple boot stages may have functionalities in common
    that can be implemented using the same library. Unfortunately, there is no simple
    way to access the symbols of the library from separate software images. The mechanism
    described in the next example provides access to shared libraries between the
    two stages by storing the symbols needed only once in the flash.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，然而，多个引导阶段可能具有共同的功能，可以使用相同的库来实现。不幸的是，没有简单的方法可以从单独的软件映像访问库的符号。下一个示例中描述的机制通过只在闪存中存储一次所需的符号，为两个阶段之间的共享库提供访问权限。
- en: Shared libraries
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库
- en: 'Suppose that there is a small library providing general-purpose utilities or
    device drivers, which is in use by both the bootloader and the application. Even
    when the footprint is small, it is preferable not to have duplicate definitions
    of the same functions in the flash memory. The library can instead be linked in
    a dedicated section of the bootloader and referred to in a later stage. In our
    preceding two-stage example, we can safely place the API function pointers in
    an array starting at address `0x400`, which is past the end of the interrupt vector
    we are currently using. In a real project, the offset must be high enough to be
    after the actual vector table in memory. The `.utils` input section is placed
    in the linker script in between the vector table and the start of `.text` in the
    bootloader:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个小型库提供通用工具或设备驱动程序，该库被引导加载程序和应用软件共同使用。即使占位符很小，也不建议在闪存中重复定义相同的功能。相反，库可以链接到引导加载程序的专用部分，并在后续阶段引用。在我们的前两个阶段示例中，我们可以安全地将
    API 函数指针放置在地址 `0x400` 的数组中，该地址位于我们当前使用的中断向量之后。在实际项目中，偏移量必须足够高，以便在内存中的实际向量表之后。`.utils`
    输入部分放置在链接脚本中，在向量表和引导加载程序中 `.text` 的开始之间：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The actual function definitions can be placed in a different source file and
    linked in the bootloader. What is actually in the `.utils` section is a table
    containing the pointers to the actual address of the functions inside the `.text`
    bootloader output section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的功能定义可以放在不同的源文件中，并在引导加载程序中链接。实际上在 `.utils` 部分的是包含指向 `.text` 引导加载程序输出部分内部实际功能地址的指针表：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The layout of the bootloader now has this extra `.utils` section, aligned at
    address `0x400`, containing a table with the pointers to the library functions
    that are meant to be exported for use from other stages:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在引导加载程序的布局中增加了这个额外的 `.utils` 部分，地址对齐为 `0x400`，包含一个表，其中包含指向打算从其他阶段导出使用的库函数的指针：
- en: '![Figure 4.4 – Bootloader partition with the .utils section](img/B18730_04_04.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 带有 .utils 部分的引导加载程序分区](img/B18730_04_04.jpg)'
- en: Figure 4.4 – Bootloader partition with the .utils section
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 带有 .utils 部分的引导加载程序分区
- en: 'The application expects to find the function table at the given address:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序期望在指定的地址找到功能表：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The address of the single functions that have been stored in the bootloader
    is now available, but there is no information about the signature of these functions.
    For this reason, the application can only access the API properly if the pointers
    are converted to match the expected function signature. An inline wrapper can
    then be provided so that the application code can access the function directly:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经可以访问存储在引导加载程序中的单个函数的地址，但关于这些函数签名的信息却不存在。因此，只有当指针被转换为与预期的函数签名匹配时，应用程序才能正确地访问API。然后可以提供一个内联包装器，以便应用程序代码可以直接访问该函数：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, the contract is implicitly shared between the two modules, and
    the correspondence between the function signatures is not checked at compile time,
    nor is the validity of the function pointer stored in flash. On the other hand,
    it is a valid approach to avoid binary code duplication and might be an effective
    way to reduce flash usage by sharing symbols across separate contexts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，合同在两个模块之间隐式共享，函数签名之间的对应关系在编译时不会被检查，存储在闪存中的函数指针的有效性也不会被检查。另一方面，避免二进制代码重复是一种有效的方法，并且可能通过在分离的上下文中共享符号来有效地减少闪存使用。
- en: Remote firmware updates
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程固件更新
- en: One of the reasons to include a bootloader in an embedded system design is often
    to provide a mechanism to update the running application from a remote location.
    As mentioned in the previous chapter, a reliable update mechanism is often a critical
    requirement for vulnerability management. On rich embedded systems running Linux,
    bootloaders are often equipped with their own TCP/IP stacks, network device drivers,
    and protocol-specific implementations to transfer kernel and filesystem updates
    autonomously. On smaller embedded systems, it is often convenient to assign this
    task to the application, which is in most cases already using similar communication
    channels for other functional purposes. Once the new firmware has been downloaded
    and stored in any non-volatile memory support (for example, in a partition at
    the end of the flash memory), a bootloader could implement a mechanism to install
    the received update by overwriting the previous firmware in the **Application**
    partition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统设计中包含引导加载程序的原因之一通常是提供一个机制，以便从远程位置更新正在运行的应用程序。如前一章所述，可靠的更新机制通常是漏洞管理的一个关键要求。在运行Linux的丰富嵌入式系统中，引导加载程序通常配备自己的TCP/IP堆栈、网络设备驱动程序和特定协议的实现，以自主地传输内核和文件系统更新。在较小的嵌入式系统中，通常方便将此任务分配给应用程序，在大多数情况下，该应用程序已经使用类似的通信渠道用于其他功能目的。一旦新的固件被下载并存储在任何非易失性存储支持中（例如，在闪存末尾的分区中），引导加载程序可以实现一个机制，通过覆盖**应用程序**分区中的先前固件来安装接收到的更新。
- en: Secure boot
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全引导
- en: Many projects require a mechanism to prevent the execution of unauthorized or
    altered firmware that could have been compromised intentionally by an attacker
    in an attempt to take control of the system. This is a task for secure bootloaders,
    which use cryptography to verify the authenticity of a signature calculated on
    the content of the firmware image on board. Secure bootloaders implementing such
    mechanisms rely on a trust anchor to store a public key and require the use of
    a manifest that must be attached to the firmware image file. The manifest contains
    the signature that has been created by the owner of the private key associated
    with the public key stored in the device. Cryptographic signature verification
    is a very effective method to prevent unauthorized firmware updates, both from
    remote locations and from physical attacks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目需要一个机制来防止执行未经授权或篡改的固件，这种固件可能被攻击者有意破坏以尝试控制系统。这是一个安全引导加载程序的任务，它使用密码学来验证基于板载固件映像内容的签名。实现此类机制的安全引导加载程序依赖于一个信任锚来存储公钥，并要求使用必须附加到固件映像文件上的清单。清单包含由与存储在设备中的公钥相关联的私钥所有者创建的签名。密码学签名验证是一种非常有效的防止未经授权的固件更新的方法，无论是来自远程位置还是来自物理攻击。
- en: Implementing a secure bootloader from scratch is a considerable amount of work.
    A few open source projects provide a mechanism to sign and verify images using
    cryptography algorithms. **wolfBoot** is a secure bootloader providing integrity
    and authenticity checks of the current firmware and the candidates for update
    installations. It provides a fail-safe mechanism to swap the two firmware partitions’
    content during the update installation, to provide a backup in case of failed
    execution of the newly updated image. The bootloader comes with tools to generate
    the signature and attach the manifest to the file to be transferred to the device,
    and a wide range of configurable options, ciphers, and features.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始实现一个安全的引导加载程序是一项相当大的工作量。一些开源项目提供了使用加密算法对镜像进行签名和验证的机制。**wolfBoot**是一个提供当前固件和更新安装候选者完整性和真实性检查的安全引导加载程序。它提供了一个在更新安装过程中交换两个固件分区内容的故障安全机制，以在新的更新镜像执行失败时提供备份。引导加载程序附带生成签名并将清单附加到要传输到设备的文件的工具，以及一系列可配置的选项、加密方式和功能。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Understanding the boot procedure is a key step toward the development of an
    embedded system. We have seen how to boot straight into the bare-metal application,
    and we have examined the structures involved in a multi-stage system boot, such
    as separate linker scripts with different entry points, the relocation of IVs
    via CPU registers, and shared code sections across stages.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 理解引导过程是开发嵌入式系统的一个关键步骤。我们已经看到了如何直接引导到裸机应用程序，并且我们检查了多阶段系统引导中涉及的架构，例如具有不同入口点的单独链接脚本、通过CPU寄存器重定位IVs以及跨阶段的共享代码段。
- en: In the next chapter, we will explore mechanisms and approaches for memory management
    that represent the most important factor to take into account while developing
    safe and reliable embedded systems.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨内存管理的机制和方法，这是在开发安全可靠的嵌入式系统时需要考虑的最重要因素。
