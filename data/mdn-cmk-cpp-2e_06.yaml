- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using Generator Expressions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '使用生成器表达式  '
- en: Many CMake users don’t encounter generator expressions in their private explorations
    as they are quite advanced concepts. However, they are crucial for projects that
    are preparing for the general availability stage, or first release to the wider
    audience, as they play an important role in exporting, installing, and packaging.
    If you’re trying to just learn the basics of CMake quickly and focus on the C++
    aspect, feel free to skip this chapter for now and return to it later. On the
    other hand, we discuss generator expressions at this time, because the following
    chapters will reference this knowledge when explaining the more in-depth aspects
    of CMake.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '许多 CMake 用户在私下学习时并未遇到生成器表达式，因为它们是相对高级的概念。然而，它们对于那些准备进入广泛发布阶段或首次发布给更广泛观众的项目至关重要，因为它们在导出、安装和打包中扮演着重要角色。如果你只是想快速学习
    CMake 的基础知识，并专注于 C++ 方面，可以暂时跳过本章，稍后再回来。另一方面，我们现在讨论生成器表达式，是因为接下来的章节将在解释 CMake 的更深层次内容时引用这些知识。  '
- en: 'We’ll start by introducing the subject of generator expressions: what they
    are, what their uses are, and how they are formed and expanded. This will be followed
    by a short presentation of the nesting mechanism and a more thorough description
    of the conditional expansion, which allows the use of Boolean logic, comparison
    operations, and queries. Of course, we’ll do a deep dive into the vastness of
    the available expressions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将首先介绍生成器表达式的主题：它们是什么，它们的用途是什么，以及它们是如何构建和展开的。接下来会简要介绍嵌套机制，并更详细地描述条件扩展，这允许使用布尔逻辑、比较操作和查询。当然，我们还会深入探讨可用表达式的广度。  '
- en: 'But first, we’ll study the transformations of strings, lists, and paths, as
    it’s good to get the basics out of the way before focusing on the main subject.
    Ultimately, generator expressions are used in practice to fetch the information
    available in later stages of building and present it in the appropriate context.
    Determining that context is a huge part of their value. We’ll discover how to
    parametrize our build process based on the build configuration selected by the
    user, the platform at hand, and the current toolchain. That is, what compiler
    is being used, what its version is, and which capabilities it has, that’s not
    all: we’ll figure out how to query the properties of build targets and their related
    information.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '但是首先，我们将研究字符串、列表和路径的转换，因为在集中研究主要内容之前，了解这些基础内容是很有益的。最终，生成器表达式在实际应用中用于获取在构建的后期阶段中可用的信息，并将其呈现于适当的上下文中。确定这个上下文是它们价值的一个重要部分。我们将探讨如何根据用户选择的构建配置、当前平台和工具链来参数化我们的构建过程。也就是说，正在使用什么编译器，它的版本是什么，以及它具备哪些功能，这还不止：我们将弄清楚如何查询构建目标的属性及其相关信息。  '
- en: To make sure we can fully appreciate the value of the generator expressions,
    I have included a few interesting examples of use as the final part of this chapter.
    Oh, and there’s a quick explanation of how to see the output of generator expressions
    as this is a bit tricky. Don’t worry though, generator expressions aren’t as complex
    as they might seem, and you will be using them in no time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保我们能够充分理解生成器表达式的价值，我在本章的最后部分包括了一些有趣的使用示例。此外，还提供了如何查看生成器表达式输出的简短说明，因为这有些棘手。不过别担心，生成器表达式并不像它们看起来那么复杂，你很快就能开始使用它们了。  '
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '本章将介绍以下主要内容：  '
- en: What are generator expressions?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是生成器表达式？  '
- en: Learning the basic rules of general expression syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '学习一般表达式语法的基本规则  '
- en: Conditional expansion
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '条件扩展  '
- en: Querying and transforming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '查询与转换  '
- en: Trying out examples
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '试验示例  '
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '技术要求  '
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch06](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在 GitHub 上找到本章中涉及的代码文件，网址为：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch06](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch06)。  '
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '要构建本书提供的示例，请始终使用推荐的命令：  '
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将`<build tree>`和`<source tree>`占位符替换为适当的路径。提醒一下：**build tree**是目标/输出目录的路径，**source
    tree**是源代码所在的路径。
- en: What are generator expressions?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器表达式是什么？
- en: 'CMake is building the solution in three stages: configuration, generation,
    and running the build tool. Generally, all the required data is available during
    the configuration stage. However, occasionally, we encounter a situation similar
    to the “chicken and the egg” paradox. Take an example from the *Using a custom
    command as a target hook* section in *Chapter 5*, *Working with Targets* – where
    a target needs to know the path of a binary artifact of another target. Unfortunately,
    this information becomes available only after all the listfiles are parsed and
    the configuration stage is complete.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CMake在三个阶段构建解决方案：配置、生成和运行构建工具。通常，在配置阶段所有所需的数据都是可用的。然而，有时我们会遇到类似“先有鸡还是先有蛋”这种悖论的情况。举个例子，来自*第5章*中*使用自定义命令作为目标钩子*部分——某个目标需要知道另一个目标的二进制工件路径。不幸的是，这些信息只有在所有列表文件解析完毕并且配置阶段完成后才会变得可用。
- en: So, how do we tackle such a problem? One solution could be to create a placeholder
    for the information and delay its evaluation until the next stage – the **generation
    stage**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这样的问题呢？一种解决方案是为该信息创建一个占位符，并将其评估延迟到下一个阶段——**生成阶段**。
- en: This is precisely what generator expressions (also referred to as “genexes”)
    do. They are built around target properties such as `LINK_LIBRARIES`, `INCLUDE_DIRECTORIES`,
    `COMPILE_DEFINITIONS`, and propagated properties, although not all. They follow
    rules similar to the conditional statements and variable evaluation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是生成器表达式（也称为“genexes”）的作用。它们围绕目标属性构建，如`LINK_LIBRARIES`、`INCLUDE_DIRECTORIES`、`COMPILE_DEFINITIONS`和传播的属性，尽管并非所有属性都如此。它们遵循类似于条件语句和变量评估的规则。
- en: Generator expressions will be evaluated at the generation stage (when the configuration
    is complete and the buildsystem is created), which means that capturing their
    output into a variable and printing it to the console is not straightforward.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式将在生成阶段进行评估（即配置完成并创建构建系统时），这意味着将它们的输出捕获到变量中并打印到控制台并不直接。
- en: There’s a significant number of generator expressions, and in a way, they constitute
    their own, domain-specific language – language that supports conditional expressions,
    logical operations, comparisons, transformations, queries, and ordering. Utilizing
    generator expressions enables manipulation and queries of strings, lists, version
    numbers, shell paths, configurations, and build targets. In this chapter, we will
    provide brief overviews of these concepts, focusing on the essentials since they
    are less necessary in most cases. Our primary focus will be on the main application
    of generator expressions, which involves gathering information from the generated
    configuration of targets and the state of the build environment. For full reference,
    it’s best to read the official CMake manual online (see the *Further reading*
    section for the URL).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式有很多种，从某种意义上说，它们构成了自己的一种领域特定语言——一种支持条件表达式、逻辑运算、比较、转换、查询和排序的语言。使用生成器表达式可以操作和查询字符串、列表、版本号、shell路径、配置和构建目标。在本章中，我们将简要概述这些概念，重点介绍基础知识，因为在大多数情况下它们不是必需的。我们主要关注生成器表达式的主要应用，即从生成的目标配置和构建环境的状态中获取信息。欲了解完整参考资料，最好在线阅读官方CMake手册（请参阅*进一步阅读*部分以获取网址）。
- en: Everything is better explained with an example, so let’s jump right into it,
    and describe the syntax of generator expressions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一切通过示例解释更为清晰，因此我们直接进入，描述生成器表达式的语法。
- en: Learning the basic rules of general expression syntax
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习常规表达式语法的基本规则
- en: 'To use generator expressions, we’ll need to add them to a CMake listfile through
    a command that supports generator expression evaluation. Most of the target-specific
    commands do, and there are plenty of others (review the official documentation
    of a particular command to learn more). A command that is often used with generator
    exception is `target_compile_definitions()`. To use a generator expression, we’ll
    need to provide it as a command argument like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用生成器表达式，我们需要通过支持生成器表达式评估的命令将其添加到CMake列表文件中。大多数特定目标的命令都支持生成器表达式评估，还有许多其他命令（可以查看特定命令的官方文档了解更多）。一个常与生成器表达式一起使用的命令是`target_compile_definitions()`。要使用生成器表达式，我们需要将其作为命令参数提供，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command adds a `-D` definition flag to the compiler’s arguments (ignore
    `PUBLIC` for now) that sets the `BAR` preprocessor definition to *the path* at
    which the **binary artifact** of the `foo` target will be produced. This works
    because the generator expression is stored in the current form in a variable.
    The expansion is effectively postponed until the generation stage when many things
    are fully configured and known.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将一个`-D`定义标志添加到编译器的参数中（暂时忽略`PUBLIC`），该标志设置`BAR`预处理器定义为`foo`目标生成的**二进制文件**的*路径*。之所以有效，是因为生成器表达式以当前的形式存储在一个变量中。展开实际上推迟到生成阶段，此时许多内容已经完全配置并确定。
- en: How is the generator expression formed?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式是如何形成的？
- en: '![](img/B19844_06_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_06_01.png)'
- en: 'Figure 6.1: The syntax of a generator expression'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：生成器表达式的语法
- en: 'As you can see in *Figure 6.1*, the structure seems fairly simple and readable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.1*所示，结构看起来相当简单且易于阅读：
- en: Open with a dollar and a bracket (`$<`).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以美元符号和括号（`$<`）打开。
- en: Add the `EXPRESSION` name.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`EXPRESSION`名称。
- en: If an expression requires arguments, add a colon (`:`) and provide the `arg1`,
    `arg2` … `argN` values, separated with a comma (`,`).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式需要参数，请添加冒号（`:`）并提供`arg1`、`arg2` … `argN`值，以逗号（`,`）分隔。
- en: Close the expression with `>`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`>`结束表达式。
- en: There are expressions that do not require any arguments, such as `$<PLATFORM_ID>`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不需要任何参数的表达式，例如`$<PLATFORM_ID>`。
- en: It’s important to note that unless explicitly stated otherwise, expressions
    are typically evaluated in the context of the target using the expression. This
    association is inferred from the command in which the expression is used. In the
    previous example, we saw how `target_compile_definitions()` provides `foo` as
    the target it operates on. The target-specific generator expressions used in that
    command will therefore implicitly use `foo`. Do note, however, that the generator
    expression used in the example, `$<TARGET_FILE>`, requires the target attribute
    as the context to operate on. There are other generator expressions that don’t
    accept targets as arguments (like `$<COMPILE_LANGUAGE>`), and will implicitly
    use the target of the enclosing command. These will be discussed in more detail
    later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，除非明确指出，否则表达式通常在使用该表达式的目标上下文中进行评估。这一关联可以从使用表达式的命令中推断出来。在前面的例子中，我们看到`target_compile_definitions()`将`foo`作为它操作的目标。因此，在该命令中使用的特定目标生成器表达式将隐式地使用`foo`。然而，值得注意的是，例子中使用的生成器表达式`$<TARGET_FILE>`需要目标属性作为其操作的上下文。还有一些生成器表达式不接受目标作为参数（如`$<COMPILE_LANGUAGE>`），而是隐式使用封闭命令的目标。稍后会对这些进行更详细的讨论。
- en: Generator expressions can quickly become very confusing and complicated when
    using their more advanced features, so it’s important to understand their specifics
    beforehand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用生成器表达式的高级特性时，生成器表达式可能会变得非常混乱和复杂，因此在使用之前了解其具体内容非常重要。
- en: Nesting
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套
- en: 'Let’s start with the ability to pass a generator expression as an argument
    to another generator expression or, in other words, generator expression nesting:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从将生成器表达式作为参数传递给另一个生成器表达式的能力开始，换句话说，就是生成器表达式的嵌套：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This isn’t a very complex example, but it’s easy to imagine what happens when
    we increase nesting levels and work with commands using multiple arguments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不复杂，但很容易想象当我们增加嵌套层数并与使用多个参数的命令配合工作时会发生什么。
- en: 'To complicate matters even further, it’s possible to add a regular variable
    expansion to the mix:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让问题更复杂一些，可能还需要将常规变量展开与生成器表达式一起使用：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `my_variable` variable will be expanded first, at the configuration stage.
    Subsequently, the generation expression will be expanded at the generation stage.
    There are some rare uses for this feature, but I strongly recommend avoiding it:
    generator expressions provide virtually all necessary functions. Mixing regular
    variables into these expressions adds a layer of indirection that is hard to debug.
    Additionally, information collected in the config stage will often be outdated,
    as users will override values used in generator expressions through command-line
    parameters at the build or installation stage.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_variable` 变量会首先在配置阶段展开。随后，生成表达式将在生成阶段展开。这种特性有一些罕见的用法，但我强烈建议避免使用：生成器表达式几乎提供了所有必要的功能。将常规变量混入这些表达式中会增加难以调试的间接性层次。此外，在配置阶段收集的信息通常会过时，因为用户会在构建或安装阶段通过命令行参数覆盖生成器表达式中使用的值。'
- en: Having covered the syntax, let’s move on to discuss the fundamental mechanisms
    available in generator expressions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在讲解语法之后，让我们继续讨论生成器表达式中可用的基本机制。
- en: Conditional expansion
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件展开
- en: 'Determining whether an expression should be expanded is supported with Boolean
    logic in generator expressions. While this is a great feature, its syntax can
    be inconsistent and difficult to read due to legacy reasons. It’s available in
    two forms. The first form supports both happy and sad paths:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器表达式中，是否应该展开一个表达式是通过布尔逻辑来确定的。尽管这是一个很棒的特性，但由于历史原因，它的语法可能不一致且难以阅读。它有两种形式。第一种形式同时支持顺利路径和错误路径：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `IF` expression relies on nesting to be useful: you can replace any of
    the arguments with another expression and produce quite complex evaluations (you
    can even nest one `IF` condition in another). This form requires exactly three
    arguments, so we can’t omit anything. Our best option to skip a value in case
    of an unmet condition is the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`IF` 表达式依赖于嵌套才能发挥作用：你可以将任何参数替换为另一个表达式，生成相当复杂的求值（甚至可以将一个 `IF` 条件嵌套在另一个里面）。这种形式需要恰好三个参数，因此我们不能省略任何一个。为了跳过条件不满足时的值，最好的选择是：'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There’s a shorthand version that allows you to skip the `IF` keyword and the
    comma:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种简写形式，可以跳过 `IF` 关键字和逗号：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it breaks the convention of providing the `EXPRESSION` name
    as the first token. I assume that the intention here was to shorten the expression
    and avoid typing those precious few characters, but the outcome can be really
    hard to rationalize. Here’s one example from the CMake documentation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它打破了将 `EXPRESSION` 名称作为第一个标记的惯例。我猜这里的意图是缩短表达式，避免输入那些宝贵的字符，但结果可能很难合理化。这是来自
    CMake 文档的一个示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This expression returns `COMPILING_CXX_WITH_CLANG` only for C++ code compiled
    with one of the Clang compilers. (it returns an empty string in all other cases).
    I wish the syntax was aligned with conditions for the regular `IF` command, but
    sadly that’s not the case. Now, you can recognize the second form if you see it
    somewhere, but you should avoid it in your own projects for the sake of readability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式只有在用 Clang 编译器编译的 C++ 代码中才会返回 `COMPILING_CXX_WITH_CLANG`（在其他所有情况下返回空字符串）。我希望语法能与常规
    `IF` 命令的条件对齐，但遗憾的是并非如此。现在，如果你在某个地方看到第二种形式，你应该能够识别它，但为了可读性，最好避免在自己的项目中使用。
- en: Evaluating to Boolean
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值求值
- en: Generator expressions are evaluated to one of two types – Boolean or string.
    Boolean is represented by `1` (true) and `0` (false). There are no dedicated numerical
    types; everything that isn’t a Boolean is just a string.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式会求值为两种类型之一——布尔值或字符串。布尔值由 `1`（真）和 `0`（假）表示。没有专门的数值类型；任何不是布尔值的东西都只是字符串。
- en: It’s important to remember that nested expressions passed as conditions in conditional
    expressions are explicitly required to evaluate to Boolean.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，作为条件传递的嵌套表达式必须显式地求值为布尔值。
- en: Boolean types can be converted to strings implicitly, but you’ll need to use
    an explicit `BOOL` operator (explained ahead) to do the opposite.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型可以隐式转换为字符串，但你需要使用显式的 `BOOL` 运算符（稍后解释）来实现反向转换。
- en: 'There are three categories of expressions that get evaluated to Boolean: logical
    operators, comparison expressions, and queries. Let’s take a quick look at these
    types.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值的表达式有三种类型：逻辑运算符、比较表达式和查询。让我们快速看一下这些类型。
- en: Logical operators
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'There are four logical operators:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个逻辑运算符：
- en: '`$<NOT:arg>`: This negates the Boolean argument.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<NOT:arg>`：这个表达式用于否定布尔参数。'
- en: '`$<AND:arg1,arg2,arg3...>`: This returns true if all the arguments are true.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<AND:arg1,arg2,arg3...>`：如果所有参数都为真，则返回true。'
- en: '`$<OR:arg1,arg2,arg3...>`: This returns true if any of the arguments is true.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<OR:arg1,arg2,arg3...>`：如果任意一个参数为真，则返回true。'
- en: '`$<BOOL:string_arg>`: This converts arguments from a string to a Boolean type.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BOOL:string_arg>`：此操作将字符串类型的参数转换为布尔类型。'
- en: 'String conversion with `$<BOOL>` will evaluate to Boolean true (`1`) if none
    of these conditions are met:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$<BOOL>`进行字符串转换时，如果未满足以下条件，则会计算为布尔值true（`1`）：
- en: The string is empty.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串为空。
- en: The string is a case-insensitive equivalent of `0`, `FALSE`, `OFF`, `N`, `NO`,
    `IGNORE`, or `NOTFOUND`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是`0`、`FALSE`、`OFF`、`N`、`NO`、`IGNORE`或`NOTFOUND`的大小写不敏感等价物。
- en: The string ends in the `-NOTFOUND` suffix (case-sensitive).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串以`-NOTFOUND`后缀结尾（区分大小写）。
- en: Comparisons
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较
- en: 'Comparisons will evaluate to `1` if their condition is met and `0` otherwise.
    Here are a few of the most common operations that you might find useful:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 比较将根据其条件计算为`1`（满足条件时）或`0`（不满足条件时）。以下是一些你可能会觉得有用的常见操作：
- en: '`$<STREQUAL:arg1,arg2>`: This compares strings in a case-sensitive fashion.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<STREQUAL:arg1,arg2>`：此操作按大小写敏感方式比较字符串。'
- en: '`$<EQUAL:arg1,arg2>`: This converts a string to a number and compares equality.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<EQUAL:arg1,arg2>`：此操作将字符串转换为数字并进行相等比较。'
- en: '`$<IN_LIST:arg,list>`: This checks whether the `arg` element is in the `list`
    list (case sensitive).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<IN_LIST:arg,list>`：此操作检查`list`列表中是否包含`arg`元素（区分大小写）。'
- en: '`$<VERSION_EQUAL:v1,v2>`, `$<VERSION_LESS:v1,v2>`, `$<VERSION_GREATER:v1,v2>`,
    `$<VERSION_LESS_EQUAL:v1,v2>`, and `$<VERSION_GREATER_EQUAL:v1,v2>` compare versions
    in a component-wise fashion.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<VERSION_EQUAL:v1,v2>`、`$<VERSION_LESS:v1,v2>`、`$<VERSION_GREATER:v1,v2>`、`$<VERSION_LESS_EQUAL:v1,v2>`和`$<VERSION_GREATER_EQUAL:v1,v2>`按组件逐一比较版本。'
- en: '`$<PATH_EQUAL:path1,path2>`: This compares the lexical representations of two
    paths without any normalization (since CMake 3.24).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH_EQUAL:path1,path2>`：此操作比较两个路径的词法表示，而不进行任何规范化（自CMake 3.24起）。'
- en: Queries
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: 'Queries simply return the Boolean value directly from a variable, or as a result
    of an operation. One of the simplest queries is:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查询会直接从一个变量返回布尔值，或作为某个操作的结果返回。最简单的查询之一是：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you might guess, it returns true if the target was defined in the configuration
    stage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，如果目标在配置阶段已定义，则返回true。
- en: 'Now, you know how to apply conditional expansion, use logical operators, comparison,
    and basic queries to evaluate to Boolean. That is useful on its own, but generator
    expressions have much more to offer, especially in the context of queries: they
    can be used in the `IF` conditional expansion, or on their own as arguments to
    commands. It’s time to introduce them in an appropriate context.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何应用条件展开、使用逻辑运算符、比较以及基本查询来计算布尔值。单单这些就很有用，但生成器表达式能提供更多，特别是在查询的上下文中：它们可以在`IF`条件展开中使用，或者单独作为命令的参数使用。是时候在适当的上下文中介绍它们了。
- en: Querying and transforming
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和转换
- en: Many generator expressions are available, but to avoid getting lost in the weeds,
    let’s focus on the most common ones. We’ll start with some basic transformations
    of the available data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多生成器表达式可用，但为了避免迷失在细节中，让我们专注于最常用的一些。我们将从对可用数据的一些基本转换开始。
- en: Dealing with strings, lists, and paths
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理字符串、列表和路径
- en: 'Generator expressions provide only the bare minimum of operations to transform
    and query data structures. Working with strings in the generator stage is possible
    with the following expressions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式仅提供了最低限度的操作，用于转换和查询数据结构。在生成器阶段处理字符串是可能的，以下是一些常用的表达式：
- en: '`$<LOWER_CASE:string>`, `$<UPPER_CASE:string>`: This converts to `string` to
    the required case.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LOWER_CASE:string>`、`$<UPPER_CASE:string>`：此操作将`string`转换为所需的大小写。'
- en: 'List operations were fairly limited until recently. Since CMake 3.15, the following
    operations have been available:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表操作直到最近才得到了很大的扩展。从CMake 3.15开始，以下操作可用：
- en: '`$<IN_LIST:string,list>`: This returns true if `list` contains a `string` value.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<IN_LIST:string,list>`：如果`list`中包含`string`值，则返回true。'
- en: '`$<JOIN:list,d>`: This joins a semicolon-separated `list` using a `d` delimiter.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<JOIN:list,d>`：此表达式使用`d`分隔符连接一个以分号分隔的`list`。'
- en: '`$<REMOVE_DUPLICATES:list>`: This deduplicates `list` (without sorting).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<REMOVE_DUPLICATES:list>`：此操作去除`list`中的重复项（不排序）。'
- en: '`$<FILTER:list,INCLUDE|EXCLUDE,regex>`: This includes/excludes items from `list`
    using a `regex`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<FILTER:list,INCLUDE|EXCLUDE,regex>`：此操作使用`regex`包含或排除`list`中的项。'
- en: 'Since 3.27, the `$<LIST:OPERATION>` generator expressions were added, where
    `OPERATION` is one of:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从3.27版本开始，添加了`$<LIST:OPERATION>`生成器表达式，其中`OPERATION`可以是以下之一：
- en: '`LENGTH`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LENGTH`'
- en: '`GET`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`SUBLIST`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBLIST`'
- en: '`FIND`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIND`'
- en: '`JOIN`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JOIN`'
- en: '`APPEND`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`'
- en: '`PREPEND`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREPEND`'
- en: '`INSERT`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`'
- en: '`POP_BACK`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POP_BACK`'
- en: '`POP_FRONT`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POP_FRONT`'
- en: '`REMOVE_ITEM`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOVE_ITEM`'
- en: '`REMOVE_AT`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOVE_AT`'
- en: '`REMOVE_DUPLICATES`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOVE_DUPLICATES`'
- en: '`FILTER`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILTER`'
- en: '`TRANSFORM`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRANSFORM`'
- en: '`REVERSE`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REVERSE`'
- en: '`SORT`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SORT`'
- en: It’s rather rare to work with lists in generator expressions, so we’re only
    indicating what’s possible. If you find yourself in one of these cases, see the
    online manual for instructions on how to use these operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器表达式中处理列表的情况比较少见，因此我们仅指示可能的情况。如果你遇到这些情况，请查看在线手册，了解如何使用这些操作。
- en: 'Finally, we can query and transform the system paths. It’s a useful addition
    because of its portability across different operating systems. The following simple
    queries have been available since CMake 3.24:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以查询和变换系统路径。这是一个有用的补充，因为它在不同操作系统之间具有可移植性。自CMake 3.24起，以下简单查询已经可以使用：
- en: '`$<PATH:HAS_ROOT_NAME,path>`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_ROOT_NAME,path>`'
- en: '`$<PATH:HAS_ROOT_DIRECTORY,path>`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_ROOT_DIRECTORY,path>`'
- en: '`$<PATH:HAS_ROOT_PATH,path>`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_ROOT_PATH,path>`'
- en: '`$<PATH:HAS_FILENAME,path>`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_FILENAME,path>`'
- en: '`$<PATH:HAS_EXTENSION,path>`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_EXTENSION,path>`'
- en: '`$<PATH:HAS_STEM,path>`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_STEM,path>`'
- en: '`$<PATH:HAS_RELATIVE_PART,path>`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_RELATIVE_PART,path>`'
- en: '`$<PATH:HAS_PARENT_PATH,path>`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:HAS_PARENT_PATH,path>`'
- en: '`$<PATH:IS_ABSOLUTE,path>`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:IS_ABSOLUTE,path>`'
- en: '`$<PATH:IS_RELATIVE,path>`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:IS_RELATIVE,path>`'
- en: '`$<PATH:IS_PREFIX[,NORMALIZE],prefix,path`>: This returns true if prefix is
    the prefix of path'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:IS_PREFIX[,NORMALIZE],prefix,path>`：如果前缀是路径的前缀，则返回true。'
- en: 'Analogically, we can retrieve all the path components we were able to check
    for (since CMake 3.27, it’s been possible to provide a list of paths rather than
    just one path):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以检索我们能够检查的所有路径组件（自CMake 3.27起，可以提供路径列表，而不仅仅是一个路径）：
- en: '`$<PATH:GET_ROOT_NAME,path...>`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_ROOT_NAME,path...>`'
- en: '`$<PATH:GET_ROOT_DIRECTORY,path...>`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_ROOT_DIRECTORY,path...>`'
- en: '`$<PATH:GET_ROOT_PATH,path...>`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_ROOT_PATH,path...>`'
- en: '`$<PATH:GET_FILENAME,path...>`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_FILENAME,path...>`'
- en: '`$<PATH:GET_EXTENSION[,LAST_ONLY],path...>`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_EXTENSION[,LAST_ONLY],path...>`'
- en: '`$<PATH:GET_STEM[,LAST_ONLY],path...>`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_STEM[,LAST_ONLY],path...>`'
- en: '`$<PATH:GET_RELATIVE_PART,path...>`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_RELATIVE_PART,path...>`'
- en: '`$<PATH:GET_PARENT_PATH,path...>`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:GET_PARENT_PATH,path...>`'
- en: 'Additionally, some transform operations were introduced in 3.24; we’ll just
    list them for completeness:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，3.24版本引入了一些变换操作；我们将列出它们以供完整性参考：
- en: '`$<PATH:CMAKE_PATH[,NORMALIZE],path...>`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:CMAKE_PATH[,NORMALIZE],path...>`'
- en: '`$<PATH:APPEND,path...,input,...>`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:APPEND,path...,input,...>`'
- en: '`$<PATH:REMOVE_FILENAME,path...>`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:REMOVE_FILENAME,path...>`'
- en: '`$<PATH:REPLACE_FILENAME,path...,input>`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:REPLACE_FILENAME,path...,input>`'
- en: '`$<PATH:REMOVE_EXTENSION[,LAST_ONLY],path...>`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:REMOVE_EXTENSION[,LAST_ONLY],path...>`'
- en: '`$<PATH:REPLACE_EXTENSION[,LAST_ONLY],path...,input>`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:REPLACE_EXTENSION[,LAST_ONLY],path...,input>`'
- en: '`$<PATH:NORMAL_PATH,path...>`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:NORMAL_PATH,path...>`'
- en: '`$<PATH:RELATIVE_PATH,path...,base_directory>`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:RELATIVE_PATH,path...,base_directory>`'
- en: '`$<PATH:ABSOLUTE_PATH[,NORMALIZE],path...,base_directory>`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PATH:ABSOLUTE_PATH[,NORMALIZE],path...,base_directory>`'
- en: 'There’s one more path operation, which formats the provided path to the style
    supported by the shell of the host: `$<SHELL_PATH:path...>`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个路径操作，它将提供的路径格式化为主机的shell支持的样式：`$<SHELL_PATH:path...>`。
- en: Again, previous expressions are introduced for later reference, not as information
    that you need to memorize right now. The bulk of the recommended practical knowledge
    is detailed in the subsequent sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，之前介绍的表达式是为了以后参考，并不是现在就需要记住的信息。推荐的实际应用知识详细信息在随后的章节中。
- en: Parametrizing the build configuration and platform
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化构建配置和平台
- en: 'One of the key pieces of information that CMake users will provide when building
    a project is the desired build configuration. In most cases, it will be `Debug`
    or `Release`. We can use the generator expressions to access these values through
    the following statements:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: CMake用户在构建项目时提供的关键信息之一是所需的构建配置。在大多数情况下，它将是`Debug`或`Release`。我们可以使用生成器表达式通过以下语句访问这些值：
- en: '`$<CONFIG>`: This returns the current build configuration as a string: `Debug`,
    `Release`, or another.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<CONFIG>`：此表达式返回当前构建配置的字符串：`Debug`、`Release`或其他。'
- en: '`$<CONFIG:configs>`: This returns true if `configs` contains the current build
    configuration (case-insensitive comparison).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<CONFIG:configs>`：如果`configs`包含当前构建配置（不区分大小写比较），则返回true。'
- en: 'We discussed the platform in the *Chapter 4*, *Setting Up Your First CMake
    Project* in the *Understanding the build environment* section. We can read related
    information the same way as with configuration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第4章*，*设置你的第一个CMake项目*中的*理解构建环境*部分讨论了平台。我们可以像读取配置一样阅读相关信息：
- en: '`$<PLATFORM_ID>`: This returns the current platform ID as a string: `Linux`,
    `Windows`, or `Darwin` for macOS.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PLATFORM_ID>`：这将返回当前平台ID的字符串形式：`Linux`、`Windows`或`Darwin`（针对macOS）。'
- en: '`$<PLATFORM_ID:platform>` is true if `platform` contains the current platform
    ID.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<PLATFORM_ID:platform>` 如果`platform`包含当前平台ID，则为真。'
- en: 'Such configuration or platform-specific parametrization is a powerful addition
    to our toolbelt. We can use it in conjunction with the conditional expansion we
    discussed earlier:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定于配置或平台的参数化是我们工具箱中的强大补充。我们可以将其与之前讨论的条件展开一起使用：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, we may apply one compilation flag when building test binaries,
    and another for production:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在构建测试二进制文件时可能应用一个编译标志，而在生产环境中应用另一个：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But this is just the beginning. There are plenty of other circumstances we can
    address with generator expressions. Of course, the next important aspect is the
    tooling present in the system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是开始。还有许多其他情况可以通过生成器表达式来处理。当然，下一个重要的方面是系统中存在的工具。
- en: Tuning for toolchain
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具链调优
- en: Toolchains, toolkits, or, simply, compilers and linkers luckily (sadly?) aren’t
    consistent across vendors. This has all sorts of consequences. Some of them are
    great (better performance in special cases), others not so much (varied configuration
    flavors, discrepancies in flag naming, and more).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链、工具包，或者说编译器和链接器，幸运的是（或不幸的是？）在不同供应商之间并不一致。这带来了各种后果。它们中有些是好的（在特殊情况下性能更好），而有些则不那么理想（配置风格多样，标志命名不一致等）。
- en: Generator expressions help here by providing sets of queries that can be utilized
    to alleviate problems and opportunistically improve user experience where possible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在这里通过提供一系列查询来帮助缓解问题，并在可能的情况下改善用户体验。
- en: As with the build configurations and platform, there are multiple expressions
    that return information about the toolchain, both as string and Boolean. However,
    we’re required to specify which language we’re interested in (replace `#LNG` with
    one of `C`, `CXX`, `CUDA`, `OBJC`, `OBJCXX`, `Fortran`, `HIP`, or `ISPC`). Support
    for `HIP` was added in 3.21.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建配置和平台一样，有多个表达式返回关于工具链的信息，无论是字符串还是布尔值。然而，我们需要指定我们感兴趣的语言（将`#LNG`替换为`C`、`CXX`、`CUDA`、`OBJC`、`OBJCXX`、`Fortran`、`HIP`或`ISPC`之一）。对`HIP`的支持在3.21版本中添加。
- en: '`$<#LNG_COMPILER_ID>`: This returns CMake’s compiler ID of the `#LNG` compiler
    used.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<#LNG_COMPILER_ID>`：这将返回所使用的`#LNG`编译器的CMake编译器ID。'
- en: '`$<#LNG_COMPILER_VERSION>`: This returns CMake’s compiler version of the `#LNG`
    compiler used.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<#LNG_COMPILER_VERSION>`：这将返回所使用的`#LNG`编译器的CMake编译器版本。'
- en: To check which compiler will execute for C++, we should use the `$<CXX_COMPILER_ID>`
    generator expression. The returned value, the CMake’s compiler ID, is a constant
    defined for every supported compiler. You may encounter values like `AppleClang`,
    `ARMCC`, `Clang`, `GNU`, `Intel`, and `MSVC`. For the full list, check the official
    documentation (URL in the *Further reading* section).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查C++将使用哪个编译器，我们应该使用`$<CXX_COMPILER_ID>`生成器表达式。返回的值，即CMake的编译器ID，是为每个支持的编译器定义的常量。你可能会遇到诸如`AppleClang`、`ARMCC`、`Clang`、`GNU`、`Intel`和`MSVC`等值。完整列表请参考官方文档（*进一步阅读*部分中的URL）。
- en: 'Similarly to the previous section, we can also utilize the toolchain information
    in conditional expressions. There are multiple queries that return `true` if any
    of the provided arguments matches a specific value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于上一节，我们还可以在条件表达式中利用工具链信息。有多个查询可以返回`true`，如果任何提供的参数与特定值匹配：
- en: '`$<#LNG_COMPILER_ID:ids>`: This returns true if `ids` contains CMake’s #`LNG`
    compiler ID.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<#LNG_COMPILER_ID:ids>`：如果`ids`包含CMake的`#LNG`编译器ID，则返回true。'
- en: '`$<#LNG_COMPILER_VERSION:vers>`: This returns true if `vers` contains the CMake’s
    #`LNG` compiler version.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<#LNG_COMPILER_VERSION:vers>`：如果`vers`包含CMake的`#LNG`编译器版本，则返回true。'
- en: '`$<COMPILE_FEATURES:features>`: This returns true if all features provided
    in `features` are supported by the compiler for this target.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_FEATURES:features>`：如果`features`中列出的所有特性都被此目标的编译器支持，则返回true。'
- en: 'Inside commands requiring a target argument, like `target_compile_definitions()`,
    we can use one of the target-specific expressions to get a string value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要目标参数的命令中，如`target_compile_definitions()`，我们可以使用其中一种特定于目标的表达式来获取字符串值：
- en: '`$<COMPILE_LANGUAGE>`: This returns the language of source files at the compilation
    step.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_LANGUAGE>`：返回编译步骤中源文件的语言。'
- en: '`$<LINK_LANGUAGE>`: This returns the language of source files at the link step.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_LANGUAGE>`：返回链接步骤中源文件的语言。'
- en: 'To evaluate a simple Boolean query:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 评估一个简单的布尔查询：
- en: '`$<COMPILE_LANGUAGE:langs>`: This returns true if `langs` contains a language
    used for the compilation of this target. This can be used to provide language-specific
    flags to the compiler. For example, to compile C++ sources of the target with
    the `-fno-exceptions` flag:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_LANGUAGE:langs>`：如果`langs`包含用于编译该目标的语言，则返回true。可以使用此表达式为编译器提供特定语言的标志。例如，为了使用`-fno-exceptions`标志编译目标的C++源文件：'
- en: '[PRE11]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`$<LINK_LANGUAGE:langs>` – It follows the same rules as `COMPILE_LANGUAGE`
    and returns true if `langs` contains a language used for linking of this target.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_LANGUAGE:langs>` – 它遵循与`COMPILE_LANGUAGE`相同的规则，如果`langs`包含用于该目标链接的语言，则返回true。'
- en: 'Or, to query more complex scenarios:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，查询更复杂的场景：
- en: '`$<COMPILE_LANG_AND_ID:lang,compiler_ids...>`: This returns true if the `lang`
    language is used for this target, and one of the compilers in the `compiler_ids`
    list will be used for this compilation. This expression is useful to specify compile
    definitions for specific compilers:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMPILE_LANG_AND_ID:lang,compiler_ids...>`：如果`lang`语言用于此目标，并且`compiler_ids`列表中的某个编译器将用于此编译，则返回true。这个表达式对于为特定编译器指定编译定义非常有用：'
- en: '[PRE12]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, for C++ sources (`CXX)` compiled with `AppleClang` or `Clang`,
    the `-DCXX_CLANG` definition will be set. For the C++ sources compiled with the
    `Intel` compiler, the `-DCXX_INTEL` definition flag will be set. Lastly, for the
    C sources (`C`) compiled with the `Clang` compiler, we’ll set a `-DC_CLANG` definition.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，对于使用`AppleClang`或`Clang`编译的C++源文件（`CXX`），将设置`-DCXX_CLANG`定义。对于使用`Intel`编译器编译的C++源文件，将设置`-DCXX_INTEL`定义标志。最后，对于使用`Clang`编译器编译的C源文件（`C`），将设置`-DC_CLANG`定义。
- en: '`$<LINK_LANG_AND_ID:lang,compiler_ids...>`: This works like `COMPILE_LANG_AND_ID`,
    but checks the language used for the link step instead. Use this expression to
    specify link libraries, link options, link directories, and link dependencies
    of a particular language and a linker combination in a target.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<LINK_LANG_AND_ID:lang,compiler_ids...>`：它的作用类似于`COMPILE_LANG_AND_ID`，但检查的是链接步骤中使用的语言。使用此表达式可以指定特定语言和链接器组合的链接库、链接选项、链接目录和链接依赖项。'
- en: An important note to make here is that a single target can be combined from
    sources of multiple languages. For example, it’s possible to link C artifacts
    with C++ (but we should declare both languages in the `project()` command). Therefore,
    generator expressions referencing a specific language will be used for some source
    files, but not for others.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，一个单独的目标可以由多种语言的源文件组成。例如，可以将C语言的产物与C++链接（但我们应该在`project()`命令中声明这两种语言）。因此，引用特定语言的生成器表达式将用于某些源文件，但不会用于其他源文件。
- en: 'Let’s move on to the next important category: target-related generator expressions.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论下一个重要类别：与目标相关的生成器表达式。
- en: Querying target-related information
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询与目标相关的信息
- en: There are plenty of generator expressions that query target properties and check
    target-related information. Note that until CMake 3.19, many target expressions
    referencing another target were used to automatically create a dependency between
    them. This no longer happens in the latest versions of CMake.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多生成器表达式可以查询目标属性并检查与目标相关的信息。请注意，直到CMake 3.19，许多引用另一个目标的目标表达式会自动在它们之间创建依赖关系。但在CMake的最新版本中，这种情况不再发生。
- en: 'Some generator expressions will infer the target from the command being called;
    the most commonly used is the basic query that returns the target’s property value:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器表达式会从被调用的命令中推断目标；最常用的是返回目标属性值的基本查询：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Less known, but useful in the `target_link_libraries()` command, is the `$<LINK_ONLY:deps>`
    generator expression. It allows us to store the `PRIVATE` link dependencies, which
    won’t be propagated through transitive usage requirements; these are used in interface
    libraries, which we discussed in *Chapter 5*, *Working with Targets*, in the *Understanding
    the transitive usage requirements* section.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个较少为人知，但在`target_link_libraries()`命令中非常有用的生成器表达式是`$<LINK_ONLY:deps>`。它允许我们存储`PRIVATE`链接依赖项，这些依赖项不会通过传递的使用要求传播；这些依赖项用于接口库，我们在*第5章*、*与目标的工作*中的*理解传递使用要求*部分已经讨论过。
- en: 'There also is a set of install and export-related expressions, which infer
    their targets from the context they’re being used. We’ll discuss them in depth
    in *Chapter 14*, *Installing and Packaging*, so we can just have a quick introduction
    for now:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组与安装和导出相关的表达式，它们通过上下文推断出目标。我们将在*第14章*，*安装与打包*中深入讨论这些表达式，因此现在我们只做一个简短的介绍：
- en: '`$<INSTALL_PREFIX>`: This returns the install prefix when the target is exported
    with `install(EXPORT)` or when evaluated in `INSTALL_NAME_DIR`; otherwise, it
    is empty.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_PREFIX>`：当目标通过`install(EXPORT)`导出，或在`INSTALL_NAME_DIR`中评估时，这返回安装前缀；否则，它为空。'
- en: '`$<INSTALL_INTERFACE:string>`: This returns `string` when the expression is
    exported with `install(EXPORT)`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_INTERFACE:string>`：当表达式与`install(EXPORT)`一起导出时，这返回`string`。'
- en: '`$<BUILD_INTERFACE:string>`: This returns `string` when the expression is exported
    with the `export()` command or by another target in the same buildsystem.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_INTERFACE:string>`：当表达式通过`export()`命令或由同一构建系统中的另一个目标导出时，这返回`string`。'
- en: '`$<BUILD_LOCAL_INTERFACE:string>`: This returns `string` when the expression
    is exported by another target in the same buildsystem.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_LOCAL_INTERFACE:string>`：当表达式被同一构建系统中另一个目标导出时，这返回`string`。'
- en: 'However, most queries require the target name to be explicitly provided as
    the first argument:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数查询要求明确提供目标名称作为第一个参数：
- en: '`$<TARGET_EXISTS:target>`: This returns true if the target exists.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_EXISTS:target>`：如果目标存在，这返回`true`。'
- en: '`$<TARGET_NAME_IF_EXISTS:target>`: This returns the `target` name if the target
    exists and an empty string otherwise.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_NAME_IF_EXISTS:target>`：如果目标存在，它返回`target`名称，否则返回空字符串。'
- en: '`$<TARGET_PROPERTY:target,prop>`: This returns the `prop` property value for
    the target.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_PROPERTY:target,prop>`：这返回目标的`prop`属性值。'
- en: '`$<TARGET_OBJECTS:target>`: This returns a list of *object files* for an *object
    library* target.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_OBJECTS:target>`：这返回*目标库*的*目标文件*列表。'
- en: 'You can query the path of the target artifact:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查询目标构件的路径：
- en: '`$<TARGET_FILE:target>`: This returns the full path.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE:target>`：这返回完整路径。'
- en: '`$<TARGET_FILE_NAME:target>`: This returns just the filename.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_NAME:target>`：这只返回文件名。'
- en: '`$<TARGET_FILE_BASE_NAME:target>`: This returns the base name.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_BASE_NAME:target>`：这返回基本名称。'
- en: '`$<TARGET_FILE_NAME:target>`: This returns the base name without the prefix
    or suffix (for `libmylib.so` the base name would be `mylib`).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_NAME:target>`：这返回没有前缀或后缀的基本名称（例如，对于`libmylib.so`，基本名称为`mylib`）。'
- en: '`$<TARGET_FILE_PREFIX:target>`: This returns just the prefix (for example,
    `lib`).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_PREFIX:target>`：这只返回前缀（例如，`lib`）。'
- en: '`$<TARGET_FILE_SUFFIX:target>`: This returns just the suffix (for example,
    `.so` or `.exe`).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_SUFFIX:target>`：这只返回后缀（例如，`.so`或`.exe`）。'
- en: '`$<TARGET_FILE_DIR:target>`: This returns the directory.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE_DIR:target>`：这返回目录。'
- en: 'There are families of expressions that offer similar functionality as the regular
    `TARGET_FILE` expression (each expression also accepts the `_NAME`, `_BASE_NAME`
    or `_DIR` suffix):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些表达式族提供与常规`TARGET_FILE`表达式类似的功能（每个表达式还接受`_NAME`、`_BASE_NAME`或`_DIR`后缀）：
- en: '`TARGET_LINKER_FILE`: This queries the path of the file used when linking to
    the target. Usually, it is the library produced by the target (`.a`, `.lib`, `.so`).
    However, on platforms with **Dynamic-Link Libraries** (**DLLs**), it will be a
    `.lib` import library associated with the target’s DLL.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_LINKER_FILE`：这查询用于链接到目标的文件路径。通常，它是目标生成的库（`.a`，`.lib`，`.so`）。但是，在使用**动态链接库**（**DLLs**）的平台上，它将是与目标的
    DLL 关联的 `.lib` 导入库。'
- en: '`TARGET_PDB_FILE`: This queries the path of the linker-generated program database
    file (`.pdb`).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_PDB_FILE`：这查询链接器生成的程序数据库文件（`.pdb`）的路径。'
- en: Managing libraries is a complex topic, and CMake offers a lot of generator expressions
    to help. However, we’ll postpone introducing them until they become relevant in
    *Chapter 8*, *Linking Executables and Libraries*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 管理库是一个复杂的话题，CMake 提供了许多生成器表达式来帮助解决。我们将在*第8章*，*链接可执行文件和库*中引入它们，直到它们变得相关。
- en: 'Finally, there are some Apple package-specific expressions as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些特定于 Apple 包的表达式：
- en: '`$<TARGET_BUNDLE_DIR:target>`: This is the full path to the bundle directory
    (`my.app`, `my.framework`, or `my.bundle`) for the target.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_BUNDLE_DIR:target>`：这是目标的捆绑目录（`my.app`，`my.framework`或`my.bundle`）的完整路径。'
- en: '`$<TARGET_BUNDLE_CONTENT_DIR:target>`: This is the full path to the bundle
    content directory for the target. On macOS, it’s `my.app/Contents`, `my.framework`,
    or `my.bundle/Contents`. Other **Software Development Kits** (**SDKs**) (such
    as iOS) have a flat bundle structure – `my.app`, `my.framework`, or `my.bundle`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_BUNDLE_CONTENT_DIR:target>`：这是目标的完整路径，指向目标的捆绑内容目录。在 macOS 上，它是`my.app/Contents`、`my.framework`或`my.bundle/Contents`。其他**软件开发工具包**（**SDKs**）（例如
    iOS）具有平坦的捆绑结构——`my.app`、`my.framework`或`my.bundle`。'
- en: These are the main generator expressions for dealing with targets. It’s worth
    knowing, there’s plenty more. I recommend referring to the official documentation
    for a complete list.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是处理目标的主要生成器表达式。值得知道的是，还有很多其他的表达式。我建议参考官方文档以获取完整列表。
- en: Escaping
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义
- en: 'On a rare occasion, you may need to pass a character to a generator expression
    that has a special meaning. To escape this behavior, use the following expressions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，你可能需要将一个具有特殊含义的字符传递给生成器表达式。为了转义这种行为，可以使用以下表达式：
- en: '`$<ANGLE-R>`: This a literal `>` symbol'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<ANGLE-R>`：这是一个字面量的`>`符号'
- en: '`$<COMMA>`: This a literal `,` symbol'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<COMMA>`：这是一个字面量的`,`符号'
- en: '`$<SEMICOLON>`: This a literal `;` symbol'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<SEMICOLON>`：这是一个字面量的`;`符号'
- en: The last expression can be useful to prevent list expansion when an argument
    containing `;` is used.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的表达式可以在使用包含`;`的参数时防止列表扩展。
- en: Now that we have introduced all the queries and transformations, we can see
    how they work in practice. Let’s go through some examples of applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了所有查询和转换，我们可以看看它们在实践中的应用。让我们通过一些示例来了解如何使用它们。
- en: Trying out examples
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试验例子
- en: 'Everything is easier to grasp when there’s a good practical example to support
    the theory. Obviously, we’d like to write some CMake code and try it out. However,
    since generator expressions aren’t evaluated until after the configuration is
    complete, we cannot use any configuration-time commands like `message()` to experiment.
    We need to use some special tricks instead. To debug generator expressions, you
    can use either of these methods:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个好的实践例子来支持理论时，一切都会更容易理解。显然，我们希望编写一些 CMake 代码并试一试。然而，由于生成器表达式直到配置完成后才会被求值，因此我们不能使用像`message()`这样的配置时命令来进行实验。我们需要使用一些特殊的技巧来进行调试。要调试生成器表达式，你可以使用以下方法之一：
- en: 'Write it to a file (this particular version of the `file()` command supports
    generator expressions): `file(GENERATE OUTPUT filename CONTENT "$<...>")`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其写入文件（这个版本的`file()`命令支持生成器表达式）：`file(GENERATE OUTPUT filename CONTENT "$<...>")`
- en: 'Add a custom target and build it explicitly from the command line: `add_custom_target(gendbg
    COMMAND ${CMAKE_COMMAND} -E echo "$<...>")`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行显式添加一个自定义目标并构建它：`add_custom_target(gendbg COMMAND ${CMAKE_COMMAND} -E echo
    "$<...>")`
- en: I recommend the first option for simpler practice. Remember, though, that we
    won’t be able to use all the expressions in these commands, as some are target
    specific. Having covered this, let’s look at some of the uses for generator expressions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐第一种选项，便于简单练习。不过记住，我们无法在这些命令中使用所有表达式，因为有些表达式是针对特定目标的。介绍完这些之后，我们来看一些生成器表达式的应用实例。
- en: Build configurations
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建配置
- en: 'In *Chapter 1*, *First Steps with CMake*, we discussed the build type, specifying
    which configuration we are building – `Debug`, `Release`, and so on. There may
    be cases where you’d like to act differently based on what kind of build you’re
    making. A simple and easy way to do so is by utilizing the `$<CONFIG>` generator
    expression:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*使用 CMake 的第一步* 中，我们讨论了构建类型，指定我们正在构建的配置——`Debug`，`Release`，等等。可能会有这种情况，你希望根据正在进行的构建类型采取不同的操作。一个简单易行的方法是使用`$<CONFIG>`生成器表达式：
- en: '[PRE14]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example checks whether the config equals `DEBUG`; if that’s the
    case, the nested expression is evaluated to `1`. The outer shorthand `if` expression
    then becomes `true`, and our `-ginline-points` debug flag gets added to the options.
    It’s important to know this form, so you’ll be able to understand such expressions
    in other projects, but I’d recommend using the more verbose `$<IF:...>` for better
    readability.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子检查配置是否等于`DEBUG`；如果是这种情况，嵌套的表达式将被求值为`1`。外部简写的`if`表达式将变为`true`，我们的`-ginline-points`调试标志被添加到选项中。了解这种形式很重要，这样你就能理解其他项目中的类似表达式，但我建议使用更为详细的`$<IF:...>`，以提高可读性。
- en: System-specific one liners
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统特定的一行命令
- en: 'Generator expressions can also be used to compact verbose `if` commands into
    neat one liners. Let’s suppose we have the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式还可以用来将冗长的`if`命令压缩成简洁的一行代码。假设我们有以下代码：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It tells the compiler to add `-DLINUX=1` to the arguments if this is the target
    system. While this isn’t terribly long, it could be replaced with a fairly simple
    expression:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉编译器，如果这是目标系统，就将`-DLINUX=1`添加到参数中。虽然这并不算太长，但可以用一个相当简单的表达式替代：
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Such code works well, but there’s a limit to how much you can pack into a generator
    expression until it becomes too hard to read. On top of that, many CMake users
    postpone learning about generator expressions and have trouble following what
    happens. Luckily, we won’t have such problems after completing this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码运行良好，但你能放入生成器表达式中的内容是有限的，一旦超过了这个限度，就会变得难以阅读。此外，许多CMake用户推迟学习生成器表达式，导致他们难以跟上发生的事情。幸运的是，完成本章后，我们将不再遇到这些问题。
- en: Interface libraries with compiler-specific flags
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有特定编译器标志的接口库
- en: 'Interface libraries, as we discussed in *Chapter 5*, *Working with Targets*,
    can be used to provide flags to match the compiler:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第五章*《与目标一起工作》中讨论的那样，接口库可以用来提供与编译器匹配的标志：
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Even in such a simple example, we can already see how difficult an expression
    is to understand when we nest too many generator expressions. Unfortunately, sometimes
    this is the only way to achieve the desired effect. Here’s the explanation of
    the example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这样一个简单的例子中，我们也能看到当我们嵌套太多生成器表达式时，表达式变得多么难以理解。不幸的是，有时这是实现所需效果的唯一方法。以下是该例子的解释：
- en: We check whether `COMPILER_ID` is `GNU`; if that’s the case, we evaluate `OR`
    to `1`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查`COMPILER_ID`是否为`GNU`；如果是这样，我们将`OR`的值评估为`1`。
- en: If it’s not, we check whether `COMPILER_ID` is `Clang`, and evaluate `OR` to
    `1`. Otherwise, evaluate `OR` to `0`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，我们检查`COMPILER_ID`是否为`Clang`，并将`OR`评估为`1`。否则，将`OR`评估为`0`。
- en: If `OR` is evaluated to `1`, add `-rtti` to the `enable_rtti` **compile options**.
    Otherwise, do nothing.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`OR`的值被评估为`1`，则将`-rtti`添加到`enable_rtti` **编译选项**中。否则，什么也不做。
- en: 'Next, we can link our libraries and executables with the `enable_rtti` interface
    library. CMake will add the `-rtti` flag if a compiler supports it. Side note:
    **RTTI** stands for **run-time type information** and is used in C++ with keywords
    like `typeid` to determine the class of an object at run time; unless your code
    is using this feature, the flag doesn’t need to be enabled.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将我们的库和可执行文件与`enable_rtti`接口库进行链接。如果编译器支持，它会添加`-rtti`标志。顺便提一下，**RTTI**代表**运行时类型信息**，在C++中使用`typeid`等关键字来确定对象的类；除非你的代码使用了这个功能，否则不需要启用该标志。
- en: Nested generator expressions
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套的生成器表达式
- en: Sometimes, it’s not obvious what happens when we try to nest elements in a generator
    expression. We can debug the expressions by generating a test output to a debug
    file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们尝试在生成器表达式中嵌套元素时，结果并不明显。我们可以通过生成测试输出到调试文件来调试表达式。
- en: 'Let’s try out a few things and see what happens:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些东西，看看会发生什么：
- en: '**ch06/01-nesting/CMakeLists.txt**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch06/01-nesting/CMakeLists.txt**'
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After building this project as described in the *Technical requirements* section
    of this chapter, we can read the produced `nesting` file using the Unix `cat`
    command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章*技术要求*部分的描述构建此项目后，我们可以使用Unix `cat`命令读取生成的`nesting`文件：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how each line works:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每行代码的工作原理：
- en: The `PLATFORM_ID` output value is `LINUX`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PLATFORM_ID`的输出值是`LINUX`。'
- en: The output from the nested value will get transformed correctly to uppercase
    `LINUX`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套值的输出将正确转换为大写`LINUX`。
- en: We can transform plain strings.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以转换普通字符串。
- en: We can transform the content of configuration-stage variables.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以转换配置阶段变量的内容。
- en: Variables will be interpolated first, and closing angle brackets (`>`) will
    be interpreted as part of the genex, in that only part of the string will get
    capitalized.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量会首先进行插值，并且闭合的尖括号（`>`）会被解释为生成器表达式的一部分，因此只有部分字符串会被转换为大写。
- en: In other words, be aware that the content of variables may affect the behavior
    of your genex expansions. If you need an angle bracket in a variable, use `$<ANGLE-R>`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要意识到变量的内容可能会影响生成器表达式扩展的行为。如果需要在变量中使用尖括号，请使用`$<ANGLE-R>`。
- en: The difference between a conditional expression and the evaluation of a BOOL
    operator
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件表达式与BOOL操作符评估之间的区别
- en: 'Generator expressions can be a little confusing when it comes to evaluating
    Boolean types to strings. It is important to understand how they differ from regular
    conditional expressions, starting with an explicit `IF` keyword:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估布尔类型为字符串时，生成器表达式可能有些令人困惑。理解它们与常规条件表达式的不同之处是很重要的，从显式的`IF`关键字开始：
- en: '**ch06/02-boolean/CMakeLists.txt**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch06/02-boolean/CMakeLists.txt**'
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s read the produced file using the Linux `cat` command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Linux 的 `cat` 命令查看生成的文件：
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s examine the output for each line:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查每一行的输出：
- en: This is a Boolean expansion, where `BOOL` is `0`; therefore, the `TRUE` string
    isn’t written.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个布尔扩展，其中 `BOOL` 为 `0`；因此，`TRUE` 字符串没有被写出。
- en: This is a typical mistake – the author intended to print `TRUE` or `FALSE` depending
    on the `BOOL` value, but since it is a Boolean `false` expansion as well, two
    arguments are treated as one and not printed.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个典型的错误 – 作者打算根据 `BOOL` 值打印 `TRUE` 或 `FALSE`，但由于它也是布尔 `false` 扩展，两个参数被视为一个并未打印出来。
- en: This is the same mistake for a reversed value – it is a Boolean `true` expansion
    that has both arguments written in a single line.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个反向值的相同错误 – 它是一个布尔 `true` 扩展，两个参数写在同一行。
- en: This is a proper conditional expression starting with `IF` – it prints `FALSE`
    because the first argument is `0`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个正确的条件表达式，以 `IF` 开头 – 它打印 `FALSE`，因为第一个参数为 `0`。
- en: This is the correct usage of a conditional expression, however, when we don’t
    need to provide values for Boolean `false`, we should use the form used in the
    first line.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是条件表达式的正确用法，但当我们不需要为布尔 `false` 提供值时，我们应使用第一行中使用的形式。
- en: Generator expressions are notorious for their convoluted syntax. The differences
    mentioned in this example can confuse even experienced builders. If in doubt,
    copy such an expression to another file and analyze it by adding indentation and
    whitespace to understand it better.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式因其复杂的语法而闻名。本示例中提到的差异甚至会让经验丰富的构建者感到困惑。如果有疑问，可以将此类表达式复制到另一个文件，并通过添加缩进和空白来进行分析，以便更好地理解。
- en: Seeing examples of how generator expressions work has prepared us to use them
    in practice. Upcoming chapters will discuss many topics, where generator expressions
    will be relevant. In time, we’ll cover even more of their applications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过看到生成器表达式的工作示例，我们已经为实际使用它们做好了准备。接下来的章节将讨论许多与生成器表达式相关的主题。随着时间的推移，我们将涵盖更多它们的应用。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about unpacking the ins and outs of generator expressions,
    or “genexes.” We started with the basics of forming and expanding generator expressions
    and looked at their nesting mechanism. We dove into the power of conditional expansion,
    which taps into Boolean logic, comparison operations, and queries. This aspect
    of generator expressions shines when adapting our build process based on factors
    like user-chosen build configuration, platform, and the current toolchain.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讲解了生成器表达式，或称“genexes”的细节。我们从生成和扩展生成器表达式的基础开始，探索了它们的嵌套机制。我们深入探讨了条件扩展的强大功能，它涉及布尔逻辑、比较操作和查询。生成器表达式在根据用户选择的构建配置、平台和当前工具链等因素调整构建过程时，展现出其强大的优势。
- en: We have also covered the basic but essential transformations of strings, lists,
    and paths. A major highlight was using genexes to query the information gathered
    at the later build stages and present it when the context matches the requirements.
    We also now know how to check our compiler’s ID, version, and capabilities. We
    explored querying the build target properties and extracting the related information
    using generator expressions. The chapter is wrapped up with practical examples
    and guidance on viewing the output where possible. With this, you’re now ready
    to use the generator expressions in your projects.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了字符串、列表和路径的基本但至关重要的转换。一个亮点是使用生成器表达式查询在后期构建阶段收集的信息，并在上下文匹配要求时显示这些信息。我们现在也知道如何检查编译器的
    ID、版本和功能。我们还探讨了如何查询构建目标属性并使用生成器表达式提取相关信息。本章以实际示例和在可能的情况下查看输出的指南结束。至此，你已经准备好在项目中使用生成器表达式了。
- en: In the next chapter, we’ll learn how to compile programs with CMake. Specifically,
    we’ll talk about how to configure and optimize this process.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 CMake 编译程序。具体来说，我们将讨论如何配置和优化这一过程。
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章所涵盖主题的更多信息，您可以参考以下内容：
- en: 'Generator expressions in the official documentation: [https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档中的生成器表达式：[https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html)
- en: 'Supported compiler IDs: [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的编译器ID：[https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html)
- en: 'Mixing languages in Cmake: [https://stackoverflow.com/questions/8096887/mixing-c-and-c-with-cmake](https://stackoverflow.com/questions/8096887/mixing-c-and-c-with-cmake
    )'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CMake中混合语言：[https://stackoverflow.com/questions/8096887/mixing-c-and-c-with-cmake](https://stackoverflow.com/questions/8096887/mixing-c-and-c-with-cmake)
- en: Leave a review!
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过在亚马逊上留下评论，帮助像你一样的读者。扫描下面的二维码，免费获取一本你选择的电子书。
- en: '![](img/Review_Copy.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_Copy.png)'
