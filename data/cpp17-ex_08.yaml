- en: The Computer Plays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机走棋
- en: In this chapter, we continue to work on the Othello and Noughts and Crosses games.
    The new part of this chapter is the computer playing against the human; instead
    of two human players, the computer plays against a human.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续开发 Othello 和井字棋游戏。本章的新内容是计算机与人类对弈；而不是两个人类玩家，计算机与人类对弈。
- en: 'Topics we will cover in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: Game-theory reasoning. In both games, the human or the computer can make the
    first move, and we add code for the computer to play against the human.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博弈论推理。在这两个游戏中，人类或计算机可以首先走棋，我们为计算机添加了与人类对弈的代码。
- en: In Othello, for each move, we scan the game grid and try to find the move that
    causes the highest number of the human's marks to be swapped.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Othello 中，对于每一步，我们扫描游戏网格并试图找到导致人类标记交换数量最多的走法。
- en: In Noughts and Crosses, we try to find the position in the game grid that gives
    us the highest number of marks in a row, or, if the human is about to get five
    in row, we have to place the computer’s mark in a position that prevents that.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在井字棋游戏中，我们试图找到游戏网格中能给我们带来最高行数标记的位置，或者如果人类即将在行中获得五个标记，我们必须放置计算机的标记在防止这种情况发生的位置。
- en: An introduction to random number generation. If the computer can choose between
    several equivalent moves, it shall randomly select one of the moves.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数生成简介。如果计算机可以在几个等效的走法之间选择，它应随机选择其中一个走法。
- en: We continue to use C++ features such as classes, fields, and methods. We also
    continue to use Qt features such as windows and widgets.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续使用 C++ 特性，如类、字段和方法。我们还继续使用 Qt 特性，如窗口和小部件。
- en: Othello
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Othello
- en: In the Othello application of this chapter, we reuse the `MainWindow` and `GameWidget` classes
    of the previous chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 Othello 应用程序中，我们重用了上一章的 `MainWindow` 和 `GameWidget` 类。
- en: The OthelloWindow class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OthelloWindow 类
- en: The `OthelloWindow` class is rather similar to its counterpart in the previous
    chapter. However, in addition to the menus and items, the window of this version
    also holds submenus. The submenus will be added by calling the `addAction` method
    in the `OthelloWindow.cpp` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWindow` 类与上一章的对应类相当相似。然而，除了菜单和选项外，这个版本的窗口还包含子菜单。子菜单将通过在 `OthelloWindow.cpp`
    文件中调用 `addAction` 方法来添加。'
- en: '**OthelloWindow.h**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWindow.h**'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `OthelloWindow.cpp` file holds the definitions of the methods of the `OthelloWindow` class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWindow.cpp` 文件包含 `OthelloWindow` 类的方法定义。'
- en: '**OthelloWindow.cpp**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWindow.cpp**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The title of the window has been changed to `Othello Advanced`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的标题已更改为 `Othello Advanced`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two submenus of the Game menu, `Computer Starts` and `Human Starts`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏菜单中有两个子菜单，`Computer Starts` 和 `Human Starts`：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Computer Starts` submenu holds the two items `Computer Black` and `Computer
    White`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Computer Starts` 子菜单包含两个选项 `Computer Black` 和 `Computer White`：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Human Starts` submenu holds two items, `Human Black` and `Human White`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Human Starts` 子菜单包含两个选项，`Human Black` 和 `Human White`：'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The OthelloWidget Class
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OthelloWidget 类
- en: 'The `OthelloWidget` class holds the functionality of Othello. It allows the
    computer to play against a human:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWidget` 类包含 Othello 的功能。它允许计算机与人类对弈：'
- en: '**OthelloWidget.h**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWidget.h**'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `OthelloWidget.cpp` file holds the definitions of the methods of the `OthelloWidget` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`OthelloWidget.cpp` 文件包含 `OthelloWidget` 类的方法定义：'
- en: '**OthelloWidget.cpp**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**OthelloWidget.cpp**'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `isComputerStartsBlackEnabled`, `isComputerStartsWhiteEnabled`, `isHumanStartsBlackEnabled`,
    and `isHumanStartsWhiteEnabled` methods are called before the `Computer Starts`
    and `Human Starts` submenus. They become enabled if there is no game in progress:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `Computer Starts` 和 `Human Starts` 子菜单之前，会调用 `isComputerStartsBlackEnabled`、`isComputerStartsWhiteEnabled`、`isHumanStartsBlackEnabled`
    和 `isHumanStartsWhiteEnabled` 方法。如果没有进行游戏，它们将变为可用状态：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `onComputerStartsBlack` and `onComputerStartsWhite` methods are called
    when the user selects one of the items of the `Computer Starts` submenu. They
    set the computer mark to black or white, start the game by setting the mark in
    the middle of the game grid, and update the window:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Computer Starts` 子菜单中的一个选项时，会调用 `onComputerStartsBlack` 和 `onComputerStartsWhite`
    方法。它们将计算机标记设置为黑色或白色，通过在游戏网格中间设置标记来开始游戏，并更新窗口：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `onHumanStartsBlack` and `onHumanStartsWhite` methods are called when the
    user selects one of the items of the `Human Starts` submenu. They set the computer
    mark to black or white and update the window. They do not set any mark in the
    game grid. Instead, the human is to make the first move:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在`Human Starts`子菜单中选择一个项目时，会调用`onHumanStartsBlack`和`onHumanStartsWhite`方法。它们将电脑标记设置为黑色或白色并更新窗口。它们在游戏网格中不设置任何标记。相反，人类将首先移动：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `mouseMark` method is called when the user clicks one empty position in
    the game grid. We start by setting the next mark at the position, and turn the
    marks as a result of the move:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在游戏网格中点击一个空位置时，会调用`mouseMark`方法。我们首先设置下一个标记在位置上，然后根据移动翻转标记：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the human''s move did not cause the game grid to become full, we call to
    `calculateComputerMove` to set the computer mark to the position, causing the
    maximum number of opposite marks to be turned. We then update the window and call
    `checkWinner` again to decide if the computer move caused the game grid to become
    full:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人类的移动没有使游戏网格变满，我们调用`calculateComputerMove`来设置电脑标记到该位置，从而翻转最大数量的相反标记。然后我们更新窗口并再次调用`checkWinner`以决定电脑的移动是否使游戏网格变满：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `drawMark` method is called when a position in the game grid needs to be
    repainted. It draws the mark in the same way as in the previous chapter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏网格中的某个位置需要重新绘制时，会调用`drawMark`方法。它以与上一章相同的方式绘制标记：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `checkWinner` method of this chapter is also similar to its counterpart
    in the previous chapter. It checks whether the game grid is full. If it is full,
    the winner is announced, or else it is a draw:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的`checkWinner`方法与上一章的对应方法类似。它检查游戏网格是否已满。如果已满，则宣布获胜者，否则为平局：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `calculateComputerMove` method calculates the move of the computer that
    generates the highest number of turned opposite marks. We iterate through the
    computer marks and, for each mark, call `calculateTurns` to obtain the maximum
    number of opposite marks that would be turned if we placed the marks at that position.
    For each mark, we also obtain the number of neighbours, which is valuable if we
    do not find any marks to turn.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateComputerMove`方法计算电脑的移动，该移动生成最多的翻转相反标记。我们遍历电脑标记，并对每个标记调用`calculateTurns`以获取如果我们把标记放在那个位置，将翻转的相反标记的最大数量。对于每个标记，我们还获取邻居的数量，这在找不到任何标记翻转时很有价值。'
- en: 'The `maxTurnSetSize` and `maxNeighbours` fields hold the maximum number of
    turnable marks and neighbours; `maxTurnSetList` holds a list of the maximum sets
    of positions of turnable marks, and `maxNeighboursList` holds a list of the maximum
    number of neighbours:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxTurnSetSize`和`maxNeighbours`字段保存可翻转标记和邻居的最大数量；`maxTurnSetList`保存可翻转标记位置的最大集合列表，而`maxNeighboursList`保存邻居数量的最大列表：'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We iterate through all the positions in the game grid. For each empty position,
    we obtain the number of opposite marks to be turned if we were to place our mark
    in that position. We also obtain the number of opposite neighbours:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历游戏网格中的所有位置。对于每个空位置，我们获取如果我们把标记放在那个位置，将翻转的相反标记的数量。我们还获取相反邻居的数量：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we find a set of turnable marks that is larger than the current maximum set,
    we set the `maxTurnSetSize` field to the size of the new turnable set, insert
    the current position in the set, clear `maxTurnSetList` (since we do not want
    its previous smaller sets), and add the new set.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现一个可翻转标记的集合大于当前的最大集合，我们将`maxTurnSetSize`字段设置为新的可翻转集合的大小，将当前位置插入集合中，清除`maxTurnSetList`（因为我们不希望保留其之前的较小集合），并添加新的集合。
- en: 'We add the current set for the sake of simplicity; it is easier to add it to
    the set than to store it in any other way:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加当前集合是为了简化；将其添加到集合中比以其他方式存储它更容易：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the new set is not empty and of equal size to the maximum set, then we simply
    add it to `maxTurnSetList`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新集合不为空且与最大集合大小相等，我们只需将其添加到`maxTurnSetList`：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also check the number of neighbours of the current position. We work in
    the same way as in the `turnable` set case. If the neighbours are more than the
    maximum number of neighbours, we clear `maxNeighboursList` and add the new position:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查当前位置的邻居数量。我们以与`turnable`集合案例相同的方式进行工作。如果邻居数量超过最大邻居数量，我们清除`maxNeighboursList`并添加新位置：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If there is at least one neighbour, and the neighbours is equal to the maximum
    number of neighbours, we add it to the `maxNeighboursList` list:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个邻居，并且邻居数量等于最大邻居数量，我们将它添加到`maxNeighboursList`列表中：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If there is at least one position where we will turn at least one opposite mark,
    we choose it. If there are several positions that will turn the same amount of
    opposite marks, we randomly select one of them. We use the C standard functions
    `srand`, `rand`, and `time` to obtain a random integer number.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个位置我们将转动至少一个相反标记，我们就选择它。如果有几个位置将转动相同数量的相反标记，我们就随机选择其中一个。我们使用C标准函数`srand`、`rand`和`time`来获取一个随机整数。
- en: 'The random number generator algorithm takes a start value and then generates
    a sequence of random numbers. The `srand` function initializes the generator with
    a start value, and then `rand` is called repeatedly in order to obtain new random
    numbers. In order to not call `srand` with the same start value every time (which
    would result in the same random number sequence), we call `srand` with the result
    of a call to the `time` standard C function, which returns the number of seconds
    since January 1, 1970\. In this way, the random number generator is initialized
    with a new value for each game, and we obtain a new sequence of random numbers
    by repeatedly calling `rand`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成算法接受一个起始值，然后生成一系列随机数。`srand`函数使用起始值初始化生成器，然后`rand`被反复调用以获取新的随机数。为了不在每次调用`srand`时使用相同的起始值（这将导致相同的随机数序列），我们使用调用`time`标准C函数的结果来调用`srand`，该函数返回自1970年1月1日以来的秒数。这样，随机数生成器为每场比赛初始化一个新的值，我们通过反复调用`rand`来获得新的随机数序列：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we have obtained the set of positions to be turned, we iterate through
    the set and set the computer mark to all its positions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获得了要转动的位置集合后，我们遍历集合并将电脑标记设置到所有这些位置：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If there is no position that would cause opposite marks to be turned, we look
    at the neighbours instead. In the same way, we randomly select one of the positions
    with the maximum number of neighbours. Note that we do not need to iterate through
    any set; in this case, we only set one mark:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有位置会导致相反标记转动，我们就查看邻居。同样地，我们随机选择具有最大邻居数量的位置之一。请注意，我们不需要迭代任何集合；在这种情况下，我们只设置一个标记：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `turn` method is called when the human has made a move. It calls `calculateMark`
    to obtain a set of turnable opposite marks, and then iterates through the set
    and sets each position in the game grid:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类玩家移动时调用`turn`方法。它调用`calculateMark`以获取可转动相反标记的集合，然后遍历集合并在游戏网格中设置每个位置：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `calculateTurns` method calculates the set of turnable opposite marks and
    number of neighbours of the given position:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateTurns`方法计算给定位置的可转动相反标记的集合和邻居的数量：'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each integer pair in `directionArray` refers to a direction in accordance with
    the compass rising:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`directionArray`中的每个整数对都指代根据罗盘上升的方向：'
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The size of an array can be decided by dividing its total size (in bytes) by
    the size of its first value:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小可以通过将其总大小（以字节为单位）除以第一个值的尺寸来决定：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We iterate through the directions and, for each direction, keep moving as long
    as we find the mark of the opponent:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历方向，并对每个方向，只要我们找到对手的标记就继续移动：
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `row` and `column` fields hold the current row and column as long as we
    iterate through a direction:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`row`和`column`字段在遍历方向时保持当前行和列：'
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, we check if we have a neighbor of the opponent mark in the closest position.
    If we have not reached one of the borders of the game grid, and if there is an
    opponent mark in the position, we increase `neighbours`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查我们是否在最近的位置有一个对手标记的邻居。如果我们没有到达游戏网格的边界之一，并且在该位置有一个对手标记，我们就增加`neighbours`：
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We gather the marks we find during the iteration in `directionSet`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在迭代过程中找到的标记收集到`directionSet`中：
- en: '[PRE31]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we reach one of the borders of the game grid, or if we find an empty position,
    we break the iteration:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达游戏网格的边界之一，或者如果我们找到一个空位，我们就会中断迭代：
- en: '[PRE32]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we find the player''s mark, we add the `directionSet` to the total set and
    break the iterations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了玩家的标记，我们将`directionSet`添加到总集合中，并中断迭代：
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we do find the player''s mark or an empty position, we have found the opponent''s
    mark, and we add its position to the direction set:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实找到了玩家的标记或空位，我们就找到了对手的标记，并将它的位置添加到方向集合中：
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The main function
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: As always, the `main` function creates an application, shows the window, and
    executes the application until the user closes the window or selects the Exit
    menu item.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，`main`函数创建一个应用程序，显示窗口，并执行应用程序直到用户关闭窗口或选择退出菜单项。
- en: '**Main.cpp**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE35]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Noughts and Crosses
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奥运十字
- en: The Noughts and Crosses application of this chapter is based on the version
    in the previous chapter. The difference is that in this version the computer plays
    against a human.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的Noughts and Crosses应用程序基于上一章的版本。不同之处在于，在这个版本中，计算机与人类进行对战：
- en: The NaCWindow class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`NaCWindow`类'
- en: 'The `NaCWindow` class is similar to the `OthelloWindow` class in the previous
    section (NaC is an abbreviation for Noughts and Crosses). It adds two submenus
    to the game menu, where the computer or human makes the first move and selects
    a nought or cross:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaCWindow`类与上一节中的`OthelloWindow`类类似（NaC是Noughts and Crosses的缩写）。它向游戏菜单中添加了两个子菜单，其中计算机或人类先手，并选择零或叉：'
- en: '**NaCWindow.h**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWindow.h**'
- en: '[PRE36]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `NaCWindow.cpp` file holds the definitions of the methods of the `NaCWindow` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaCWindow.cpp`文件包含了`NaCWindow`类的方法定义：'
- en: '**NaCWindow.cpp**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWindow.cpp**'
- en: '[PRE37]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The title has been changed to `Noughts and Crosses Advanced`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标题已更改为`Noughts and Crosses Advanced`：
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The NaCWidget class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`NaCWidget`类'
- en: 'The `NaCWidget` class has been improved compared to the version in the previous
    chapter. It holds the `calculateComputerMove` and `calculateMarkValue` methods
    for the computer to play against the human:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章中的版本相比，`NaCWidget`类得到了改进。它包含了计算机对抗人类时使用的`calculateComputerMove`和`calculateMarkValue`方法：
- en: '**NaCWidget.h**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWidget.h**'
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `NaCWidget.cpp` file holds the definitions of the methods of the `NaCWidget` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaCWidget.cpp`文件包含了`NaCWidget`类的方法定义：'
- en: '**NaCWidget.cpp**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaCWidget.cpp**'
- en: '[PRE40]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `isComputerStartsNoughtEnabled`, `isComputerStartsCrossEnabled`, `isHumanStartsNoughtEnabled`,
    and `isHumanStartsCrossEnabled` methods decide whether to enable the `Computer
    Nought`, `Computer Cross`, `Human Nought`, and `Human cross` menu items. They
    are all enabled when there is no game in progress:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`isComputerStartsNoughtEnabled`、`isComputerStartsCrossEnabled`、`isHumanStartsNoughtEnabled`和`isHumanStartsCrossEnabled`方法决定是否启用`计算机零`、`计算机叉`、`人类零`和`人类叉`菜单项。在没有进行游戏时，它们都是启用的：'
- en: '[PRE41]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `onComputerStartsNought`, `onComputerStartsCross`, `onHumanStartsNought`,
    and `onHumanStartsCross` are called when the user selects the `Computer Noughts`,
    `Computer Cross`, `Human Noughts`, and `Human Cross` menu items. They set the
    game in progress, set the computer and human marks to nought and cross, and update
    the window. In cases where the computer makes the first move, it is placed in
    the middle of the game grid in order to use the game grid as effectively as possible:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择`计算机零`、`计算机叉`、`人类零`和`人类叉`菜单项时，会调用`onComputerStartsNought`、`onComputerStartsCross`、`onHumanStartsNought`和`onHumanStartsCross`。它们设置游戏状态，将计算机和人类的标记设置为零和叉，并更新窗口。如果计算机先手，它将被放置在游戏网格的中间，以便尽可能有效地使用游戏网格：
- en: '[PRE42]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `mouseMark` method is called when the human player clicks an empty position
    in the game grid. We start by setting the mark to the position and updating the
    window:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类玩家在游戏网格中点击一个空位时，会调用`mouseMark`方法。我们首先将标记设置到该位置并更新窗口：
- en: '[PRE43]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the human''s move did not cause them to win the game, we calculate the next
    move of the computer, set the position, check if the move has caused the computer
    to win the game, and update the window:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人类的移动没有让他们赢得游戏，我们计算计算机的下一步移动，设置位置，检查移动是否让计算机赢得了游戏，并更新窗口：
- en: '[PRE44]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `drawMark` method is called when a position needs to be repainted. It is
    similar to its counterpart in the previous chapter. It draws a nought or a cross:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要重新绘制位置时，会调用`drawMark`方法。它与上一章中的对应方法类似。它绘制一个零或一个叉：
- en: '[PRE45]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `checkWinner` method is also similar to its counterpart in the previous
    chapter. It decides if the latest move has caused five marks in a row. If it has,
    the winner is announced:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkWinner`方法与上一章中的对应方法类似。它决定最新的移动是否导致了五连珠。如果是，则宣布获胜者：'
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `countMarks` method counts the number of marks in a row. It has been improved
    compared to its counterpart in the previous chapter. In this version, we also
    count the highest possible number of marks in a row that the move can lead to.
    Since `countMarks` is called by `calculateComputerMove`, we need to know how many
    marks in a row the move may lead to:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`countMarks`方法用于计算一行中的标记数量。与上一章中的对应方法相比，它已经得到了改进。在这个版本中，我们还计算了移动可以导致的一行中可能出现的最高标记数量。由于`countMarks`方法是由`calculateComputerMove`调用的，我们需要知道移动可能导致的一行中的标记数量：'
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `markCount` field holds the number of marks in a row that we would get
    if we placed our mark at the given position; `freeCount` holds the number of marks
    in a row we possibly can get if we continue to add marks in that row. The reason
    is that the computer will not add marks to a row that cannot become five in a
    row:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`markCount`字段保存了如果我们把标记放在给定位置，我们将得到的连续标记的数量；`freeCount`保存了如果我们继续在那个行添加标记，我们可能得到的连续标记的数量。原因是电脑不会在无法形成连续五个标记的行上添加标记：'
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We iterate through the game grid in the given direction:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以给定方向遍历游戏网格：
- en: '[PRE49]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As long as we find the mark, we increase both `markCount` and `freeCount`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们找到标记，我们就增加`markCount`和`freeCount`：
- en: '[PRE50]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we find an empty position, we add `0.4` (since a free row is better than
    a closed row) to the `markCount`, and continue to increase the `freeCount`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个空位，我们将`0.4`（因为空闲行比封闭行好）加到`markCount`上，并继续增加`freeCount`：
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we find neither the computer mark nor an empty position, we must have found
    the human''s mark, and we break the iteration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们既没有找到电脑的标记也没有找到空位，那么我们一定找到了人类的标记，然后我们中断迭代：
- en: '[PRE52]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'At the end of each iteration, we add the row and columns steps to the current
    row and column:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代的末尾，我们将行和列的步数添加到当前行和列：
- en: '[PRE53]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We perform a similar iteration in the opposite direction. The only difference
    is that we subtract the row and columns steps at the end of each iteration, instead
    of adding to them:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在相反方向上执行类似的迭代。唯一的区别是在每次迭代的末尾，我们减去行和列的步数，而不是将它们加到上面：
- en: '[PRE54]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the free count is at least five, we return the mark count. If it is less
    than five, we return zero, since we cannot obtain five in a row in this direction:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果空闲计数至少为五，我们返回标记计数。如果它少于五，我们返回零，因为我们不能在这个方向上获得连续五个标记：
- en: '[PRE55]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `calculateComputerMove` method calculates the computer move that causes
    the maximum numbers of marks in a row. We count both the computer and human's
    rows, since we may be facing a situation where we need to stop the human from
    winning instead of maximizing the computer's chance to win.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateComputerMove`方法计算导致最大连续标记数量的电脑移动。我们计算电脑和人类的行，因为我们可能面临需要阻止人类获胜而不是最大化电脑获胜机会的情况。'
- en: 'The `maxComputerValue` and `maxHumanValue` fields hold the maximum number of
    marks in a row that we have found so far. The `maxComputerList` and `maxHumanList`
    hold the position that causes the maximum number of marks in a row for the computer
    and the human:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxComputerValue`和`maxHumanValue`字段保存了我们迄今为止找到的连续标记的最大数量。`maxComputerList`和`maxHumanList`保存了导致电脑和人类连续标记最大数量的位置：'
- en: '[PRE56]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We iterate through the game grid. For each empty position, we try to set the
    computer and human mark and see how many marks in a row that would cause:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历游戏网格。对于每个空位，我们尝试设置电脑和人类的标记，并查看这将导致多少个连续标记：
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We obtain the maximum number of marks in a row for the computer and human mark.
    If it is larger than the previous maximum number, we clear the list and add the
    position to the list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得电脑和人类标记的连续标记的最大数量。如果它大于之前的最大数量，我们清除列表并将位置添加到列表中：
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the new number of marks in a row is greater than zero or equals the maximum
    number, we just add the position:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的连续标记数量大于零或等于最大数量，我们只需添加位置：
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We do the same for the human mark as the computer mark:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对电脑标记和人类标记做同样的处理：
- en: '[PRE60]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we reset the position to the empty value:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将位置重置为空值：
- en: '[PRE61]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The computer or human must have at least one in a row for a position:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 电脑或人类必须至少有一个在行的位置：
- en: '[PRE62]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the computer''s value is at least two and larger the human value, or if
    the human value is less the four, we randomly select one of the computer''s maximum
    moves:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电脑的值至少为两个且大于人类值，或者如果人类值小于四个，我们将随机选择电脑的最大移动之一：
- en: '[PRE63]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, if the computer cannot make at least two in a row, or if the human
    is about to get five in a row, we randomly select one of the human''s maximum
    moves:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果电脑无法连续放置至少两个标记，或者如果人类即将连续放置五个标记，我们将随机选择人类最大移动中的一个：
- en: '[PRE64]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `calculateMarkValue` method calculates the maximum number of marks in a
    row that the given position may cause by calculating the larger value of its four
    directions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateMarkValue`方法通过计算其四个方向中的较大值来计算给定位置可能导致的连续标记的最大数量：'
- en: '[PRE65]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The main function
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Finally, the `main` function works at it always does in the Qt applications:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main`函数在Qt应用程序中总是这样工作：
- en: '**Main.cpp**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp**'
- en: '[PRE66]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have developed more advanced versions of the games of the
    previous chapter. In both Othello and Noughts and Crosses, we have added code
    that lets the computer play against the human. In Othello, we looked for the position
    in the game grid that would cause the highest number of the opponent’s marks to
    be changed. In Noughts and Crosses, we searched for the move that gave the computer
    the highest possible number of marks in a row, preferably five in a row. However,
    we also had to search for the potential number of marks in a row for the opponent,
    and prevent their next move if it led to victory. Now, I suggest that you sit
    back and enjoy a couple of rounds with the computer before moving on to the next
    chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了上一章游戏的高级版本。在奥赛罗和井字棋游戏中，我们添加了代码，使计算机能够与人类对弈。在奥赛罗游戏中，我们寻找游戏网格中能够导致对手标记数量变化最大的位置。在井字棋游戏中，我们寻找能够使计算机获得尽可能多的连续标记的走法，最好是连续五条。然而，我们还得寻找对手可能的连续标记数量，并阻止他们的下一步棋，如果这会导致胜利。现在，我建议你在继续到下一章之前，先坐下来和计算机玩几局，享受一下。
- en: In the next chapter, we will start developing a **Domain-Specific Language**
    (**DSL**), which is a language intended for a specific domain. We will develop
    a DSL for specifying the drawings of graphical objects, such as lines, rectangles,
    ellipses, and text, as well as the settings for color, font, pen and brush style,
    and alignment. We will also write a viewer that displays the graphical objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始开发一种**领域特定语言**（**DSL**），这是一种针对特定领域设计的语言。我们将开发一个DSL来指定图形对象的绘制，例如线条、矩形、椭圆和文本，以及颜色、字体、笔和刷的样式以及对齐设置。我们还将编写一个查看器来显示图形对象。
