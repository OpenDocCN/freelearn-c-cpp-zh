- en: '*Chapter 12*: Creating Your Professional Project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*12章*：创建你的专业项目
- en: We gathered all the required knowledge to build professional projects; we learned
    about structuring, building, dependency management, testing, analyzing, installing,
    and packaging. It's time to put these acquired skills into practice by creating
    a coherent, professional project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了构建专业项目的所有必要知识；我们学习了结构化、构建、依赖管理、测试、分析、安装和打包。是时候将这些学到的技能付诸实践，通过创建一个连贯、专业的项目。
- en: The important thing to understand is that even trivial programs will benefit
    from automated quality checks and a streamlined end-to-end process that turns
    raw code into a fully fledged solution. It's true that this is often a considerable
    investment, as many steps need to be taken in order to prepare everything right
    – even more so if we're trying to add these mechanisms to already existing code
    bases (usually, they're already large and convoluted).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的重要一点是，即使是简单的程序，也会从自动化质量检查和简化的端到端过程中受益，这些过程将原始代码转化为完全成熟的解决方案。确实，这通常是一个相当大的投资，因为需要采取许多步骤才能一切准备就绪——尤其是如果我们试图将这些机制添加到已经存在的代码库中（通常，它们已经很大且复杂）。
- en: That's the very reason to use CMake from the get-go and set all the piping upfront;
    not only it will be easier to configure but, more importantly, it's also much
    more efficient to do it early, as all the quality controls and build automation
    have to be added to long-term projects at some point anyway.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是从一开始就使用CMake并提前设置所有管道的理由；这样做不仅配置起来会更简单，更重要的是，早点做会更有效率，因为所有的质量控制和构建自动化最终都需要添加到长期项目中。
- en: This is exactly what we'll do in this chapter – we'll write a new solution that
    is as small and as simple as possible. It will perform just a single (almost)
    practical function – adding two numbers together. Limiting the functionality of
    the business code will allow us to focus on every other aspect of the project
    that we learned about in the previous chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是本章我们将要做的——我们将编写一个新的解决方案，尽可能小和简单。它将执行一个单一的（几乎）实用功能——将两个数字相加。限制业务代码的功能将允许我们关注项目中学到的每个其他方面。
- en: To have a more involved problem to solve, this project will build both a library
    and an executable. The library will provide the internal business logic and will
    also be available for other projects to consume as a CMake package. The executable
    will be meant for end users only and will implement a user interface that shows
    the functionality of the underlying library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个更复杂的问题来解决，这个项目将同时构建一个库和一个可执行文件。该库将提供内部业务逻辑，并作为CMake包供其他项目使用。可执行文件只为最终用户而设计，并实现一个用户界面，显示底层库的功能。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Planning our work
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划我们的工作
- en: Project layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目布局
- en: Building and managing dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建与管理依赖
- en: Testing and program analysis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与程序分析
- en: Installing and packaging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装与打包
- en: Providing the documentation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供文档
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files present in this chapter at GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节中找到的代码文件在GitHub上：
- en: '[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter12](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter12)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter12](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter12)'
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，请始终使用推荐命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为适当的路径。作为提醒：**build tree** 是目标/输出目录的路径，**source
    tree** 是源代码所在的位置的路径。
- en: Planning our work
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的工作
- en: 'The software we''ll be building in this chapter isn''t meant to be extremely
    complex – we''ll create a simple calculator that adds two numbers together (*Figure
    12.1*). It will be released as a console application with a text user interface
    and a library to perform mathematical operations, which can potentially be used
    in another project. While there isn''t much use for such a project in real life,
    as C++ offers plenty of support for calculations in its standard library, its
    banality will be perfect to explore how all techniques discussed in this book
    work together in practice:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要构建的软件并不打算非常复杂——我们将创建一个简单的计算器，用于相加两个数字（*图12.1*）。它将被发布为一个具有文本用户界面的控制台应用程序和一个执行数学运算的库，这可以潜在地用于另一个项目。虽然在现实生活中这种项目用处不大，因为C++在其标准库中提供了大量的计算支持，但它的平凡性将完美地探索本书中讨论的所有技术如何在实践中共同工作：
- en: '![Figure 12.1 – The two states of a console calculator''s user interface'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 控制台计算器用户界面的两种状态'
- en: '](img/Figure_12.1_B17205.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B17205.jpg)'
- en: Figure 12.1 – The two states of a console calculator's user interface
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 控制台计算器用户界面的两种状态
- en: Usually, projects either produce a user-facing executable or a library for developers.
    Projects that do both are a bit rarer but not totally uncommon – some applications
    offer standalone SDKs or libraries supporting the creation of plugins. Another
    case may be a library that offers examples of its usage. The project we'll build
    in this chapter somewhat fits into the last category.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，项目要么产生面向用户的可执行文件，要么为开发者提供库。同时做两者的项目比较少见，但并非完全罕见——一些应用程序提供独立的SDK或支持插件创建的库。另一种情况可能是提供其使用示例的库。本章我们将要构建的项目在一定程度上适合最后一类。
- en: 'We will start planning by reviewing the list of chapters, recalling their content,
    and selecting the techniques and tools described therein that we will use to build
    our computing application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过回顾章节列表、回顾其内容，并选择其中描述的技巧和工具来开始规划，以构建我们的计算应用程序：
- en: '[*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First Steps
    with CMake*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[第*1*章](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)，*CMake的初步步骤*：'
- en: 'The first chapter gave us basic information on CMake – how to install it and
    use its command line to build prepared projects. Information on project files
    provided here will be key: the responsibilities of different files, conventionally
    used names, and some quirks. In this chapter, we also discussed preset files for
    generators, but we''ll skip these in this project.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章为我们提供了关于CMake的基本信息——如何安装它以及如何使用其命令行构建准备好的项目。这里提供的关于项目文件的信息将是关键：不同文件的责任、通常使用的名称和一些古怪之处。在本章中，我们还讨论了生成器的预设文件，但在本项目中将跳过这些内容。
- en: '[*Chapter 2*](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051), *The CMake Language*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[第*2*章](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051)，*CMake语言*：'
- en: 'Here, we introduced tools necessary to write correct listfiles and scripts.
    We shared fundamental information on code: comments, command invocations, and
    arguments. We also thoroughly explained variables, lists, and control structures
    and presented a few very useful commands. This knowledge will be applied throughout
    the project.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了编写正确的列表文件和脚本所需的工具。我们分享了关于代码：注释、命令调用和参数的基本信息。我们还详细解释了变量、列表和控制结构，并介绍了一些非常有用的命令。这些知识将在整个项目中得到应用。
- en: '[*Chapter 3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078), *Setting Up
    Your First CMake Project*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[第*3*章](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)，*设置你的第一个CMake项目*：'
- en: 'Topics covered in the third chapter will have a critical impact on the project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章讨论的主题将对项目产生重大影响：
- en: Specifying a minimal CMake version decides which CMake policies will apply;
    naming, versioning, and configuring a project's language affects the basic behavior
    of the build.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定最小的CMake版本决定了哪些CMake政策将适用；命名、版本化和配置项目的语言影响了构建的基本行为。
- en: Insights into project partitioning and structuring that shape the layout of
    directories and files.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于项目划分和结构化的洞察力塑造了目录和文件的结构布局。
- en: System discovery variables to help us decide how to handle different environments,
    specifically for this project – for example, do we need to run `ldconfig`?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统发现变量有助于我们决定如何处理不同的环境，特别是针对本项目——例如，我们需要运行`ldconfig`吗？
- en: Toolchain configuration allows the requirement of a particular version of C++
    and a standard supported by the compiler.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链配置允许指定特定版本的C++和编译器支持的标准。
- en: This chapter also tells us that it's often a good idea to disable in-source
    builds, so we'll do that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还告诉我们，禁用源代码构建通常是个好主意，所以我们将会这样做。
- en: '[*Chapter 4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106), *Working with
    Targets*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106)，*使用目标工作*：'
- en: 'Here, we highlighted how every modern CMake project makes extensive use of
    targets. Ours will too, for the following reasons:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们强调了现代CMake项目如何广泛使用目标。我们的项目也将如此，以下原因是：
- en: Defining a few libraries and executables (both for test and production) will
    keep the project organized and *DRY.*
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义几个库和可执行文件（用于测试和生产）将使项目保持组织性并*保持干燥.*
- en: Target properties and transitive usage requirements (propagated properties)
    keep configuration close to target definitions.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标属性和传递使用要求（传播属性）使配置接近目标定义。
- en: Generator expressions are going to appear throughout the solution, but we'll
    keep them as simple as possible.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式将在解决方案中多次出现，但我们将其尽可能保持简单。
- en: In this project, we'll use custom commands to generate files for Valgrind and
    coverage reports, and we'll use target hooks (`PRE_BUILD`) to clean the `.gcda`
    files produced by coverage instrumentation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用自定义命令生成Valgrind和覆盖报告文件，并使用目标挂钩（`PRE_BUILD`）来清理由覆盖度 instrumentation
    产生的`.gcda`文件。
- en: '[*Chapter 5*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126), *Compiling C++
    Sources with CMake*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)，*使用CMake编译C++源代码*：'
- en: 'There''s no C++ project without compilation. The basics are quite simple, but
    CMake allows us to tweak this process in so many ways: extend the sources of a
    target, configure the optimizer, and provide debugging information. For this project,
    the default compilation flags will do just fine, but we''ll go ahead and play
    a bit with the preprocessor:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 没有编译的C++项目是不存在的。基础知识相当简单，但CMake允许我们在许多方面调整此过程：扩展目标源、配置优化器、提供调试信息。对于这个项目，默认编译标志就足够了，但我们将继续尝试预处理器：
- en: We'll store build metadata (the project version, build time, and the Git commit
    SHA) in the compiled executable and show it to the user.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在编译的可执行文件中存储构建元数据（项目版本、构建时间和Git提交SHA），并展示给用户。
- en: We'll enable the precompilation of headers. It's not really a necessity in such
    a small project, but it will help us practice this concept.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将启用头文件的预编译。在一个如此小的项目中，这并不是真正的必需品，但它将帮助我们练习这个概念。
- en: Unity builds won't be necessary – the project won't be big enough to make adding
    them worthwhile.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 统一构建将不再必要——项目不会足够大，以至于添加它们值得。
- en: '[*Chapter 6*](B17205_06_Final_JC_ePub.xhtml#_idTextAnchor146), *Linking with
    CMake*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](B17205_06_Final_JC_ePub.xhtml#_idTextAnchor146)，*使用CMake链接*：'
- en: 'The sixth chapter provides us with general information on linking (useful in
    any project), most of which comes in handy by default. But since this project
    also provides a library, we''ll explicitly refer to some building instructions
    on the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章为我们提供了关于链接（在任何项目中都有用）的一般信息，其中大部分默认情况下就很有用。但由于该项目还提供了一个库，我们将明确参考一些以下构建说明：
- en: Static libraries for testing and development
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试和开发的静态库
- en: Shared libraries for release
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发布的共享库
- en: This chapter outlines how to separate `main()` for testing, which we'll do as
    well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了如何为测试分离`main()`，我们也将这样做。
- en: '[*Chapter 7*](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162), *Managing Dependencies
    with CMake*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162)，*使用CMake管理依赖关系*：'
- en: 'To make the project more interesting, we''ll bring an external dependency:
    a text UI library. We described a few dependency management methods in this chapter.
    Picking the right one isn''t too difficult: the `FetchContent` utility module
    is usually recommended and most convenient (unless we are solving a specific corner
    case described in the chapter).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目更有趣，我们将引入一个外部依赖项：一个文本UI库。我们在这一章描述了几种依赖管理方法。选择正确的一个并不太困难：通常推荐使用`FetchContent`实用程序模块，最为方便（除非我们正在解决本章中描述的具体边缘情况）。
- en: '[*Chapter 8*](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179), *Testing Frameworks*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179)，*测试框架*：'
- en: Proper automated tests are imperative to assure that quality of our solution
    doesn't degrade over time. We'll add the support for CTest and properly structure
    our project for testing (we'll apply the `main()` separation mentioned earlier).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的自动化测试对于确保我们解决方案的质量随时间不会降低至关重要。我们将添加对CTest的支持，并适当结构我们的项目以进行测试（我们将应用前面提到的`main()`分离）。
- en: 'Also, in this chapter, we discussed two testing frameworks: Catch2 and GTest
    with gMock; for this project, we''ll use the latter. To get clear information
    on our coverage, we''ll generate HTML reports with LCOV'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们讨论了两个测试框架：Catch2和GTest带gMock；对于这个项目，我们将使用后者。为了获得清晰的覆盖信息，我们将使用LCOV生成HTML报告。
- en: '[*Chapter 9*](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195), *Program Analysis
    Tools*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195) *程序分析工具*：'
- en: 'To perform static analysis, we can choose from a variety of tools: Clang-Tidy,
    Cpplint, Cppcheck, include-what-you-use, and link what you use. In this case,
    we''ll go with Cppcheck , as Clang-Tidy doesn''t work very well with precompiled
    headers built with GCC. The dynamic analysis will be done with Valgrind''s Memcheck
    tool, and we''ll use the Memcheck-cover wrapper to generate HTML reports. Our
    source will be also automatically formatted during the build with ClangFormat.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行静态分析，我们可以选择多种工具：Clang-Tidy，Cpplint，Cppcheck，include-what-you-use，以及link
    what you use。在本例中，我们将选择Cppcheck，因为Clang-Tidy与使用GCC生成的预编译头配合不佳。动态分析将使用Valgrind的Memcheck工具完成，我们将使用Memcheck-cover包装器生成HTML报告。在构建过程中，我们的源代码也将自动使用ClangFormat格式化。
- en: '[*Chapter 10*](B17205_10_Final_JC_ePub.xhtml#_idTextAnchor210), *Generating
    Documentation:*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](B17205_10_Final_JC_ePub.xhtml#_idTextAnchor210) *生成文档：*'
- en: Since we'll be providing a library as part of this project, it's key to provide
    at least some documentation to go with it. As we already know, CMake allows us
    to automate the generation of it with Doxygen. We'll do that in a refreshed design
    by adding the doxygen-awesome-css look to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将提供一个库作为这个项目的一部分，提供至少一些文档是关键的。正如我们所知，CMake允许我们使用Doxygen来自动生成文档。我们将通过添加doxygen-awesome-css样式来对其进行刷新设计。
- en: '[*Chapter 11*](B17205_11_Final_JC_ePub.xhtml#_idTextAnchor217), *Installing
    and Packaging*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](B17205_11_Final_JC_ePub.xhtml#_idTextAnchor217) *安装和打包：*'
- en: Finally, we'll configure the installation and packaging of our solution. We'll
    prepare files to form the package as described, along with target definitions.
    We'll install that and the artifacts from build targets to appropriate directories
    by including the `GNUInstallDirs` module. We will additionally configure a few
    components to modularize the solution and prepare it for use with CPack.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将配置解决方案的安装和打包。我们将准备形成包的文件，以及目标定义。我们将使用`GNUInstallDirs`模块将该解决方案和构建目标的艺术品安装到适当的目录中。此外，我们将配置一些组件以模块化解决方案，并准备与CPack一起使用。
- en: 'Professional projects also come with a few text files: `README`, `LICENSE`,
    `INSTALL`, and so on. We''ll touch on this briefly at the end.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 专业项目还包括一些文本文件：`README`，`LICENSE`，`INSTALL`等。我们将在最后简要提及这一点。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To make things simpler, we won't implement logic that checks whether all the
    required utilities and dependencies are available. We'll rely on CMake here to
    show its diagnostics and tell users what's missing. If projects that you publish
    after reading this book get significant traction, you might want to consider adding
    these mechanisms to improve the user experience.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们不会实现检查所有必需的工具和依赖是否可用的逻辑。我们将依靠CMake在这里显示其诊断信息，并告诉用户缺少什么。如果你在阅读这本书后发布的项目获得了显著的牵引力，你可能会想要考虑添加这些机制以改善用户体验。
- en: Having formed a clear plan, let's discuss how to actually structure the project,
    both in terms of logical targets and directory structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 已经形成了明确的计划，接下来让我们讨论一下如何实际地组织项目，包括逻辑目标和目录结构。
- en: Project layout
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目布局
- en: 'To build any project, we should start with a clear understanding of what logical
    targets are going to be created in it. In this case, we''ll follow the structure
    shown in *Figure 12.2*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建任何项目，我们应该首先清楚理解其中将要创建的逻辑目标。在本例中，我们将遵循*图12.2*所示的结构：
- en: '![Figure 12.2 – A structure of logical targets'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 逻辑目标结构'
- en: '](img/Figure_12.2_B17205.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B17205.jpg)'
- en: Figure 12.2 – A structure of logical targets
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 逻辑目标结构
- en: Let's explore the structure by following the build order. First, we'll compile
    `calc_obj`, which is an **object library**. We did mention *object libraries*
    a few times in the book, but we didn't actually introduce them as a concept. Let's
    do this now.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照构建顺序来探索结构。首先，我们将编译`calc_obj`，这是一个**对象库**。我们在书中提到了几次*对象库*，但并没有真正介绍这个概念。现在让我们来做这件事。
- en: Object libraries
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象库
- en: '*Object libraries* are used to group multiple source files under a single logical
    target and are compiled into the (`.o`) *object files* during a build. To create
    an *object library*, we use the same method as with other libraries with the `OBJECT`
    keyword:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对象库用于将多个源文件组合到一个单一的逻辑目标中，并在构建过程中编译成（`.o`）*目标文件*。要创建一个对象库，我们使用与其它库相同的`OBJECT`关键字方法：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Object files* produced during the build can be added as compiled elements
    to other targets with the `$<TARGET_OBJECTS:objlib>` generator expression:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中生成的*目标文件*可以通过`$<TARGET_OBJECTS:objlib>`生成器表达式作为编译元素添加到其他目标中：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alternatively, you can add them as dependencies with the `target_link_libraries()`
    command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您可以使用`target_link_libraries()`命令将它们作为依赖项添加。
- en: In our `Calc` library, *object libraries* will be useful to avoid repeating
    the compilation of library sources for the static and shared versions of the library.
    We'll just need to remember to explicitly compile the *object files* with `POSITION_INDEPENDENT_CODE`,
    as this is a requirement for a shared library.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Calc`库中，对象库将有助于避免为库的静态和共享版本重复编译库源。我们只需要记住显式编译*目标文件*时使用`POSITION_INDEPENDENT_CODE`，因为这是共享库的一个要求。
- en: 'With this out of the way, let''s get back to the targets of this project: `calc_obj`
    will provide compiled *object files*, which then will be used for both the `calc_static`
    and `calc_shared` libraries. What are the practical differences between them and
    why provide two libraries at all?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这些之后，让我们回到这个项目的目标：`calc_obj`将提供编译后的*目标文件*，然后将用于`calc_static`和`calc_shared`库。它们之间有什么实际的区别，为什么要提供两个库？
- en: Shared libraries versus static libraries
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库与静态库
- en: We briefly introduced both types of libraries in [*Chapter 6*](B17205_06_Final_JC_ePub.xhtml#_idTextAnchor146),
    *Linking with CMake*. We then mentioned that overall memory usage can be better
    for multiple programs using the same shared library and that it's likely that
    a user already has the most popular libraries or knows how to quickly install
    them. More importantly, shared libraries are delivered in separate files that
    must be installed in specific paths for the dynamic linker to find them, while
    static libraries are merged as part of the executable file. In that form, they
    are slightly faster to use, as no additional lookups are required to find the
    location of code in memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第6章*](B17205_06_Final_JC_ePub.xhtml#_idTextAnchor146)中简要介绍了这两种库，*使用CMake链接*。我们提到，总体内存使用对于使用相同共享库的多个程序可能更有利，并且用户可能已经拥有最流行的库，或者知道如何快速安装它们。更重要的是，共享库以单独的文件形式提供，必须安装在特定的路径上，动态链接器才能找到它们，而静态库作为可执行文件的一部分合并。在这种形式下，它们的使用速度略快，因为不需要进行额外的查找来找到内存中代码的位置。
- en: As library authors, we can decide whether we're providing a static or shared
    version of the library, or we can simply ship both versions and leave this decision
    to the programmer using our library. We're opting for the latter here (just to
    see how it's done).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为库作者，我们可以决定是否提供库的静态或共享版本，或者我们可以简单地提供这两个版本，并将此决定留给使用我们库的程序员。我们在这里选择后一种方法（只是为了看看它是如何完成的）。
- en: A static library will be consumed by the `calc_test` target, which will contain
    unit tests that guarantee that the provided business functionality of the library
    works as expected. As mentioned, we're building both versions from the same set
    of compiled *object files*. In this scenario, it's perfectly fine to test either
    version, as there really should be no practical difference in their behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库将由`calc_test`目标消耗，其中将包含确保库提供的业务功能按预期工作的单元测试。如前所述，我们从相同的一组编译*目标文件*构建两个版本。在这种场景下，测试任何一个版本都是完全可以的，因为它们的实际行为应该没有实际的区别。
- en: 'The console app provided with `calc_console_static` target will use the shared
    library. This target will also link against an external dependency: the **Functional
    Terminal (X) User Interface** (**FTXUI**) library by Arthur Sonzogni (there is
    a link to the GitHub project in the *Further reading section*). It provides a
    dependence-free, cross-platform framework for text user interfaces.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`calc_console_static`目标将使用共享库。此目标还将链接到外部依赖项：**函数式终端(X)用户界面**（**FTXUI**）库，由Arthur
    Sonzogni编写（在*进一步阅读部分*有一个到GitHub项目的链接）。它为文本用户界面提供了一个无依赖、跨平台的框架。
- en: The last two targets are `calc_console` and `calc_console_test`. The `calc_console`
    target is just a bootstrap `main()` wrapper around `calc_console_static`. Its
    only purpose is to extract the entry point from the business code. This allows
    us to write the unit tests (which need to provide their own entry point) and run
    them from `calc_console_test`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个目标是`calc_console`和`calc_console_test`。`calc_console`目标只是一个围绕`calc_console_static`的`main()`引导包装器。它的唯一目的是从业务代码中提取入口点。这允许我们编写单元测试（需要提供自己的入口点）并从`calc_console_test`运行它们。
- en: We now know what targets need to be built and how they relate to each other.
    Let's figure out how to structure the project with files and directories.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道需要构建哪些目标以及它们之间的关系。让我们弄清楚如何用文件和目录结构化项目。
- en: Project file structure
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目文件结构
- en: 'The project consists of two primary targets, the `calc` library and the `calc_console`
    executable, each of which will reside in directory trees under `src` and `test`
    to separate production code from tests (shown in *Figure 12.3*). Additionally,
    we''ll have our files in two other directories:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含两个主要目标，`calc`库和`calc_console`可执行文件，每个目标都将在`src`和`test`下的目录树中，以将生产代码与测试分开（如*图
    12.3*所示）。此外，我们将在另外两个目录中拥有我们的文件：
- en: The *root directory* containing top-level configuration and key project documentation
    files
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目根目录，包含顶级配置和关键项目文档文件
- en: 'The `cmake` directory for all the utility modules and helper files used by
    CMake to build and install the project:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于所有实用模块和帮助文件的`cmake`目录，CMake 使用这些文件来构建和安装项目：
- en: '![Figure 12.3 – The directory structure of the project'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – 项目目录结构'
- en: '](img/Figure_12.3_B17205.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B17205.jpg)'
- en: Figure 12.3 – The directory structure of the project
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 项目目录结构
- en: 'Here''s the full list of files in each of the four main directories:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个四个主要目录中的完整文件列表：
- en: '![](img/B17205_Table_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17205_Table_01.jpg)'
- en: Initially, the `cmake` directory is busier than the business code, but this
    will quickly change as the project grows in functionality. The effort to start
    a clean project is significant, but don't worry – it will pay off very soon.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`cmake`目录比业务代码更繁忙，但随着项目的功能增长，这种情况会很快改变。启动一个干净项目的努力是巨大的，但不用担心——很快就会得到回报。
- en: 'We''ll go through all files and see in detail what they do and what role they
    play in the project. This will happen in four steps: building, testing, installing
    and providing documentation.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历所有文件，并详细查看它们做什么以及它们在项目中的作用。这将在四个步骤中完成：构建、测试、安装和提供文档。
- en: Building and managing dependencies
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和管理依赖项
- en: 'All build processes work the same way. We start from the top-level listfile
    and navigate downward into the project source tree. *Figure 12.4* shows which
    project files partake in building. Numbers in parentheses indicate the order of
    the CMake script execution:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的构建过程都是相同的。我们从顶层列表文件开始，向下导航到项目源树。*图 12.4* 显示了哪些项目文件参与构建。圆括号中的数字表示 CMake 脚本执行的顺序：
- en: '![Figure 12.4 – Files used in the build stage'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4 – 构建阶段使用的文件'
- en: '](img/Figure_12.4_B17205.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.4_B17205.jpg)'
- en: Figure 12.4 – Files used in the build stage
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 构建阶段使用的文件
- en: 'Our top-level listfile will configure the project and load nested elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶层列表文件将配置项目并加载嵌套元素：
- en: chapter-12/01-full-project/CMakeLists.txt
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/CMakeLists.txt
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start by providing key project details and adding a path to the CMake utility
    modules (the `cmake` directory in our project). We then disable in-source builds
    (through a custom module) and include two key directories:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提供关键项目详情，并添加到 CMake 实用模块的路径（我们项目中的`cmake`目录）。然后我们禁用源内构建（通过自定义模块），并包括两个关键目录：
- en: '`src`, containing the project source (to be named `bin` in the build tree)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`，包含项目源代码（在构建树中将被命名为`bin`）'
- en: '`test`, containing all the testing utilities'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`，包含所有的测试工具'
- en: 'Finally, we include another module that will set up the installation of the
    project. This will be discussed in another section. Meanwhile, let''s take a look
    at the `NoInSourceBuilds` module to understand how it works:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们包含另一个模块，将设置项目的安装。这将在另一节中讨论。与此同时，让我们看看`NoInSourceBuilds`模块是如何工作的：
- en: chapter-12/01-full-project/cmake/NoInSourceBuilds.cmake
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/NoInSourceBuilds.cmake
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No surprises here – we simply check whether the user provided a destination
    directory as an argument to the `cmake` command to store generated files. It has
    to be a different path than the project source tree. If that's not the case, we
    inform the user how to provide it and how to clean the repository after the mistake.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有惊喜——我们只是检查用户是否为`cmake`命令提供了目标目录作为参数来存储生成的文件。这必须与项目源树不同的路径。如果不是这样，我们告知用户如何提供它，以及如何在犯错误后清理仓库。
- en: 'Our top-level listfile then includes the `src` subdirectory, instructing CMake
    to read the listfile in it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶级列表文件然后包含了`src`子目录，指示 CMake 读取其中的列表文件：
- en: chapter-12/01-full-project/src/CMakeLists.txt
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/CMakeLists.txt
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This file is very subtle – it simply steps into the nested directories, executing
    the listfiles in them. Let's follow the listfile of the `calc` library – it's
    a bit involved, so we'll discuss it in parts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件非常微妙——它只是进入嵌套目录，执行其中的列表文件。让我们跟随`calc`库的列表文件——它有点复杂，所以我们将分部分讨论。
- en: Building the Calc library
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Calc 库
- en: 'The list file for `calc` contains bits of testing configuration, but we''ll
    focus on the building for now; the remainder will be discussed in the *Testing
    and program analysis* section:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc`的列表文件包含一些测试配置，但我们现在将关注构建；其余内容将在*测试和程序分析*部分讨论：'
- en: chapter-12/01-full-project/src/calc/CMakeLists.txt (fragment)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc/CMakeLists.txt（片段）
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We declare three targets:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了三个目标：
- en: '`calc_obj`, an *object library* compiling a `calc.cpp` implementation file.
    It also references the `calc.h` header file through the `PUBLIC_HEADER` property,
    which can be found in the configured *include directory* (thanks to generator
    expressions providing appropriate paths for a specific mode – build or install).
    By using this library, we avoid repeated compilation of other targets, but we
    also need to enable `POSITION_INDEPENDENT_CODE` so that generated *object files*
    are usable by the shared library.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_obj`，一个*对象库*，编译一个`calc.cpp`实现文件。它还通过`PUBLIC_HEADER`属性引用`calc.h`头文件，该属性可以在配置的*包含目录*中找到（感谢生成器表达式提供特定模式的适当路径——构建或安装）。使用这个库，我们避免了其他目标的重复编译，但我们也需要启用`POSITION_INDEPENDENT_CODE`，以便生成的*对象文件*可以被共享库使用。'
- en: '`calc_shared`, a shared library depending on `calc_obj`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_shared`，一个依赖于`calc_obj`的共享库。'
- en: '`calc_static`, a static library depending on `calc_obj`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_static`，一个依赖于`calc_obj`的静态库。'
- en: 'For completeness, we''ll add a listing of the `calc` library''s C++ code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们将添加`calc`库的 C++ 代码清单：
- en: chapter-12/01-full-project/src/calc/include/calc/calc.h
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc/include/calc/calc.h
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code is quite basic: it declares two global functions enclosed in a `Calc`
    namespace (C++ namespaces are extremely useful in libraries, helping to avoid
    name collisions).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当基础：它声明了两个全局函数，包含在`Calc`命名空间中（C++命名空间在库中非常有用，帮助避免名称冲突）。
- en: 'The implementation file is also very straightforward:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件也非常直接：
- en: chapter-12/01-full-project/src/calc/calc.cpp
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc/calc.cpp
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This wraps up the explanation of files in the `src/calc` directory. Next up
    is the `src/calc_console` and building the executable of the console calculator
    using this library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了`src/calc`目录中文件的解释。接下来是`src/calc_console`，以及使用这个库构建控制台计算器的可执行文件。
- en: Building the Calc Console executable
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Calc 控制台可执行文件
- en: 'The source directory of `calc_console` contains several files: a listfile,
    two implementation files (business code and a bootstrap), and a header file. The
    listfile looks as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_console`的源目录包含几个文件：一个列表文件，两个实现文件（业务代码和引导程序），和一个头文件。列表文件如下所示：'
- en: chapter-12/01-full-project/src/calc_console/CMakeLists.txt (fragment)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc_console/CMakeLists.txt（片段）
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The listfile seem very busy, but now, as experienced CMake users, we can easily
    untangle what''s happening inside:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表文件看起来很忙，但现在，作为有经验的 CMake 用户，我们可以轻松地解开里面正在发生的事情：
- en: Include CMake module to fetch FTXUI dependency.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 CMake 模块以获取 FTXUI 依赖。
- en: Declare the `calc_console_static` target, which contains the business code,
    but not the `main()` function, to allow GTest to define its own entry point.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`calc_console_static`目标，其中包含业务代码，但不包括`main()`函数，以允许 GTest 定义自己的入口点。
- en: Add a header precompilation – we're just adding a standard `string` header to
    prove a point, but for larger projects, we could add many more (including headers
    belonging to the project).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个头文件预编译——我们只是添加了一个标准的`string`头文件来证明一个观点，但对于更大的项目，我们可以添加更多（包括项目所属的头文件）。
- en: Link the business code with the shared `calc_shared` library and the FTXUI library.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将业务代码与共享的`calc_shared`库和FTXUI库链接。
- en: 'Add all the actions to be taken on this target: the generation of build information,
    testing, program analysis, and documentation.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有要在该目标上执行的动作：生成构建信息、测试、程序分析和文档。
- en: Add and link the `calc_console` bootstrap executable, which provides the entry
    point.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加并链接`calc_console`引导可执行文件，该文件提供了入口点。
- en: Again, we'll defer discussing testing and documentation to appropriate sections
    in this chapter. Let's take a look at dependency management and build info generation
    instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将推迟讨论测试和文档，而是查看依赖管理和构建信息生成。
- en: 'Note that we''re preferring the utility module over find-module to bring in
    the FTXUI. This is because it isn''t very likely that this dependency is already
    present in the system. Rather than hoping to find it, we''ll fetch and install
    it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们倾向于使用实用模块而不是find-module来引入FTXUI。这是因为这个依赖项不太可能已经存在于系统中。与其希望找到它，不如我们获取并安装它：
- en: chapter-12/01-full-project/cmake/GetFTXUI.cmake
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/GetFTXUI.cmake
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We're using the recommended `FetchContent` method, described in detail in [*Chapter
    7*](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162), *Managing Dependencies with
    CMake*. The only unusual addition is the calls of the `option()` command. They
    allow us to skip lengthy steps of the FTXUI build and disengage its installation
    configuration from the installation of this project. The same will be necessary
    for GTest dependency. The `option()` command is referenced in the *Further reading*
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了推荐的`FetchContent`方法，在[第7章](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162)，《使用CMake管理依赖项》中有详细描述。唯一的异常添加是`option()`命令的调用。它们允许我们跳过FTXUI构建的繁琐步骤，并使它的安装配置与这个项目的安装分离。对于GTest依赖项也需要这样做。`option()`命令在*进一步阅读*部分中有参考。
- en: 'The listfile for `calc_command` includes one more custom utility module that
    is build-related: `BuildInfo`. We''ll use it to record three values that can be
    surfaced in the executable:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_command`的列表文件包含了一个更多的自定义实用模块，与构建相关：`BuildInfo`。我们将使用它来记录三个可以在可执行文件中显示的值：'
- en: SHA of the current Git commit
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前Git提交的SHA
- en: The timestamp of the build
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建的时间戳
- en: The project version specified in the top-level listfile
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级列表文件中指定的项目版本
- en: 'You might remember from [*Chapter 5*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126),
    *Compiling C++ Sources with CMake*, that we can use CMake to capture some build-time
    values and provide them to C++ code through template files – for example, with
    a handy C++ struct:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从[第5章](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)，《使用CMake编译C++源码》，我们可以使用CMake捕获一些构建时的值，并通过模板文件将它们提供给C++代码——例如，使用一个方便的C++结构体：
- en: chapter-12/01-full-project/cmake/buildinfo.h.in
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/buildinfo.h.in
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To fill that structure during the configuration stage, we''ll use the following
    code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在配置阶段填充该结构，我们将使用以下代码：
- en: chapter-12/01-full-project/cmake/BuildInfo.cmake
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/BuildInfo.cmake
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Including the module will set variables containing information we're after and
    then we'll call `configure_file()` to generate `buildinfo.h`. All that's left
    is to call the `BuildInfo` function and add the directory of the produced file
    to *include directories* of the desired target. The file can be then shared with
    multiple different consumers if needed. In such a case, you'll probably want to
    add `include_guard(GLOBAL)` at the top of the listfile to avoid running the `git`
    command for every target.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 包含模块将设置包含我们所需信息的变量，然后我们将调用`configure_file()`来生成`buildinfo.h`。剩下要做的就是调用`BuildInfo`函数，并将生成的文件目录添加到所需目标*include
    directories*中。如果需要，该文件可以与多个不同的消费者共享。在这种情况下，你可能需要在列表文件的顶部添加`include_guard(GLOBAL)`，以避免为每个目标运行`git`命令。
- en: 'Before delving into the implementation of the console calculator, I''d like
    to underline that you shouldn''t worry too much about the complexity of the `tui.cpp`
    file. To fully understand it, you''ll require some knowledge of the FXTUI library
    – we don''t want to get in too deep here. Instead, let''s focus on the highlighted
    lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论控制台计算器的实现之前，我想强调你不必太担心`tui.cpp`文件的复杂性。要完全理解它，你将需要对FXTUI库有一定的了解——我们在这里不想深入讲解。相反，让我们关注高亮的行：
- en: chapter-12/01-full-project/src/calc_console/tui.cpp
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc_console/tui.cpp
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This piece of code provides a `getTui()` function, which returns a `ftxui::Component`,
    an object that encapsulates an interactive UI element with labels, text fields,
    separators, and a border. If you're interested in how it works in detail, you'll
    find suitable references in the *Further reading* section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码提供了一个`getTui()`函数，它返回一个`ftxui::Component`，一个封装了标签、文本字段、分隔符和边框的交互式UI元素的对象。如果你对它是如何工作的细节感兴趣，你会在*进一步阅读*部分找到合适的参考资料。
- en: 'More importantly, look at the include directives: they refer to the headers
    we provided earlier with the `calc_obj` target and the `BuildInfo` module. The
    first line of the lambda function provided to the constructor of the `Renderer`
    class will call the library''s `Calc::Sum` method and use the resulting value
    to print a label with `sum` (by calling the `text()` function below).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，看看包含指令：它们指的是我们之前通过`calc_obj`目标和`BuildInfo`模块提供的头文件。lambda函数构造函数提供的第一个调用库的`Calc::Sum`方法，并使用结果值打印带有`sum`的标签（通过调用下面的`text()`函数）。
- en: Similarly, the labels are used to present the user with the `BuildInfo::` values
    collected at build time in three consecutive calls to `text()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，标签用于呈现在构建时通过连续三次调用`text()`收集的`BuildInfo::`值。
- en: 'This method has its declaration in the related header file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在其相关的头文件中声明：
- en: chapter-12/01-full-project/src/calc_console/include/tui.h
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc_console/include/tui.h
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is then used by the bootstrap from the `calc_console` target:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后由`calc_console`目标中的引导程序使用：
- en: chapter-12/01-full-project/src/calc_console/bootstrap.cpp
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc_console/bootstrap.cpp
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This short piece of code utilizes `ftxui` to create an interactive console screen
    that takes the `Component` object returned by `getTui()`, makes it visible to
    the user, and collects keyboard events in a loop, creating an interface, as shown
    in *Figure 12.1*. Again, understanding this in full isn't really crucial, as the
    main purpose of `ftxui` is to provide us with an external dependency that we can
    use to practice CMake techniques.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的代码利用了`ftxui`来创建一个交互式控制台屏幕，它接收`getTui()`返回的`Component`对象，使其对用户可见，并在循环中收集键盘事件，创建一个界面，如图*12.1*所示。再次强调，完全理解这一点并不是非常关键，因为`ftxui`的主要目的是为我们提供一个外部依赖，我们可以用它来练习CMake技术。
- en: We've covered all the files in the `src` directory. Let's move on to the aforementioned
    topic of testing and analyzing the program.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了`src`目录中的所有文件。让我们继续讨论前面提到的测试和分析程序的主题。
- en: Testing and program analysis
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试与程序分析
- en: 'Program analysis and testing go hand in hand to assure the quality of our solutions.
    For example, running Valgrind becomes more consistent when test code is used.
    For this reason, we''ll configure those two things together. *Figure 12.5* illustrates
    the execution flow and files needed to set them up (a few snippets will be added
    to the `src` directory):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 程序分析与测试相辅相成，确保我们解决方案的质量。例如，当使用测试代码时，运行Valgrind变得更加一致。为此，我们将配置这两件事在一起。图*12.5*展示了执行流程和设置所需的文件（将在`src`目录中添加几个片段）：
- en: '![Figure 12.5 – Files used to enable testing and program analysis'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 用于启用测试和程序分析的文件](img/Figure_12.5_B17205.jpg)'
- en: '](img/Figure_12.5_B17205.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.5_B17205.jpg)'
- en: Figure 12.5 – Files used to enable testing and program analysis
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 用于启用测试和程序分析的文件
- en: 'As we already know, tests live in the `test` directory, and their listfile
    gets executed from the top-level listfile with the `add_subdirectory()` command.
    Let''s see what''s inside:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，测试文件位于`test`目录中，它们的列表文件通过`add_subdirectory()`命令从顶层列表文件执行。让我们看看里面有什么：
- en: chapter-12/01-full-project/test/CMakeLists.txt
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/CMakeLists.txt
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Testing utilities defined in the `Testing` module are included at this level
    to allow both target groups (from the `calc` and the `calc_console` directories)
    to use them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Testing`模块中定义的测试工具包括在这个级别，以允许两个目标组（来自`calc`和`calc_console`目录）使用它们：
- en: chapter-12/01-full-project/cmake/Testing.cmake (fragment)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Testing.cmake (片段)
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We enabled testing and included the `FetchContent` module to get GTest and GMock.
    We're not really using GMock in this project, but these two frameworks are bundled
    in a single repository, so we need to configure GMock as well. The highlighted
    part of this configuration disengages the installation of both frameworks from
    the installation of our project (by setting the appropriate `option()` to `OFF`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了测试并包含了`FetchContent`模块以获取GTest和GMock。在这个项目中我们实际上并没有使用GMock，但这两个框架都包含在一个单一的存储库中，因此我们也需要配置GMock。此配置的突出部分使这两个框架的安装与我们的项目的安装分离（通过将适当的`option()`设置为`OFF`）。
- en: 'Next, we need to create a function that enables the thorough testing of business
    targets. We''ll keep it in the same file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个函数，以启用对业务目标的彻底测试。我们将其保存在同一个文件中：
- en: chapter-12/01-full-project/cmake/Testing.cmake (continued)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Testing.cmake（继续）
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we first include the necessary modules: `GoogleTest` is bundled with
    CMake, but `Coverage` and `Memcheck` will be written by us. We then provide an
    `AddTests` macro, which will prepare a target for testing, instrument coverage,
    and memory checking. Let''s see how it works in detail.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先包含必要的模块：`GoogleTest`与CMake捆绑在一起，但`Coverage`和`Memcheck`将由我们编写。然后我们提供了一个`AddTests`宏，该宏将准备一个测试目标、启用覆盖和内存检查。让我们详细看看它是如何工作的。
- en: Preparing the coverage module
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备覆盖模块
- en: 'Adding coverage to multiple targets is a little bit tricky, as it consists
    of a few steps. We start by introducing two functions that enable coverage tracking
    and clean stale tracking files between builds:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个目标添加覆盖是一个有点棘手的过程，因为它包括几个步骤。我们首先介绍两个函数，以启用覆盖跟踪并在构建之间清理陈旧的跟踪文件：
- en: chapter-12/01-full-project/cmake/Coverage.cmake (fragment)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Coverage.cmake（片段）
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding functions will be used later, when we get to individual target
    configurations (`calc_...` and `calc_console_...`). The `Coverage` module will
    also provide a function that generates the custom coverage target:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将在我们到达单独的目标配置（`calc_...`和`calc_console_...`）时被使用。`Coverage`模块还将提供一个生成自定义覆盖目标的函数：
- en: chapter-12/01-full-project/cmake/Coverage.cmake (continued)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Coverage.cmake（继续）
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`AddCoverage()` is called in the `AddTests()` function in the `Testing` module.
    It differs slightly from the one introduced in [*Chapter 8*](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179),
    *Testing Frameworks*, as it takes the name of the target into account and adds
    it to the output path to avoid any collisions.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddCoverage()`函数在`Testing`模块中的`AddTests()`函数中被调用。它与[第8章](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179)中介绍的*测试框架*略有不同，因为它考虑了目标名称，并将其添加到输出路径以避免任何冲突。'
- en: 'To generate reports for both test targets, we simply need to run two `cmake`
    commands (after configuring the project with the `Debug` build type):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成两个测试目标的报告，我们只需运行两个`cmake`命令（在用`Debug`构建类型配置项目后）：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's now time to modify the Memcheck module that we created earlier (in [*Chapter
    9*](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195), *Program Analysis Tools*)
    to handle multiple targets.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们修改之前创建的Memcheck模块的时候了（在第9章[*程序分析工具*](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195)中）以处理多个目标。
- en: Preparing the Memcheck module
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Memcheck模块
- en: 'Generation of the Valgrind memory management report is called by `AddTests()`.
    We''ll start this module with the general setup:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTests()`调用了Valgrind内存管理报告的生成。我们将从一般设置开始这个模块：'
- en: chapter-12/01-full-project/cmake/Memcheck.cmake (fragment)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Memcheck.cmake（片段）
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''re familiar with this code already; let''s look at the function that''ll
    create appropriate targets for report generation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉这段代码了；让我们看看将创建适当目标的函数：
- en: chapter-12/01-full-project/cmake/Memcheck.cmake (continued)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Memcheck.cmake（继续）
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To handle multiple targets, the `REPORT_PATH` variable is set to store the path
    to a target-specific report. This variable is then used in subsequent commands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理多个目标，`REPORT_PATH`变量被设置以存储目标特定的报告路径。然后在此后的命令中使用此变量。
- en: 'Generation of Memcheck reports can be achieved with following commands (this
    works better in the `Debug` build type):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令生成Memcheck报告（这在`Debug`构建类型中效果更好）：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These are all modules used by the `Testing` module. Let's see how it is used.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是`Testing`模块所使用的模块。我们来看看它是如何使用的。
- en: Applying testing scenarios
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用测试场景
- en: 'A few things have to happen for the testing to work:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让测试工作，必须发生几件事情：
- en: We need to create nested listfiles and define test targets for both directories.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为两个目录创建嵌套列表文件并定义测试目标。
- en: Unit tests need to be written and prepared as executable targets.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试需要编写并作为可执行目标准备。
- en: These targets need to have `AddTests()` called on them.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些目标需要调用 `AddTests()`。
- en: '**Software Under Test** (**SUT**) needs to be instrumented to enable coverage
    collection.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**被测试的软件**（**SUT**）需要被修改以启用覆盖率收集。'
- en: Collected coverage should be cleaned between the builds to avoid segmentation
    faults.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集的覆盖率应在构建之间清理，以避免段错误。
- en: 'As implied in `test/CMakeLists.txt`, we''ll create two nested listfiles that
    configure our tests. Once more, we''ll provide one for the library:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `test/CMakeLists.txt` 暗示的那样，我们将创建两个嵌套列表文件来配置我们的测试。再一次，我们将为库提供一个：
- en: chapter-12/01-full-project/test/calc/CMakeLists.txt (fragment)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/calc/CMakeLists.txt（片段）
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll also provide one for the executable:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会为可执行文件提供一个：
- en: chapter-12/01-full-project/test/calc_console/CMakeLists.txt (fragment)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/calc_console/CMakeLists.txt（片段）
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To keep things brief, we''ll provide as simple unit tests as possible. One
    file will cover the library:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简洁，我们将提供尽可能简单的单元测试。一个文件将覆盖库：
- en: chapter-12/01-full-project/test/calc/calc_test.cpp
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/calc/calc_test.cpp
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we''ll have a second file to test the business code. For this purpose,
    we''ll use the FXTUI library. Again, there''s no expectation that you will understand
    this source code in every detail. Test listings are provided in this chapter merely
    for completeness:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个第二个文件来测试业务代码。为此，我们将使用 FXTUI 库。同样，我们不期望你详细了解这个源代码。本章提供的测试列表只是为了完整：
- en: chapter-12/01-full-project/test/calc_console/tui_test.cpp
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/calc_console/tui_test.cpp
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This test code simply renders the textual UI in a default state to a static
    screen object, which then gets stored in a string. In order for the test to pass,
    the output needs to contain a substring with the default sum.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试代码简单地将文本界面渲染为默认状态到一个静态屏幕对象，然后将其存储在一个字符串中。为了使测试通过，输出需要包含默认和的子字符串。
- en: 'Now, we''ll need to complete the remaining steps: after we have created test
    targets and prepared their source code, it''s time to register them in CPack with
    the `AddTests()` function from the `Testing` module.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要完成剩下的步骤：创建测试目标并准备好它们的源代码后，是时候使用 `Testing` 模块的 `AddTests()` 函数将它们注册到 CPack
    了。
- en: 'We do this for the library:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为图书馆这样做：
- en: chapter-12/01-full-project/test/calc/CMakeLists.txt (continued)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/calc/CMakeLists.txt（继续）
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then do it for the executable:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为可执行文件这样做：
- en: chapter-12/01-full-project/test/calc_console/CMakeLists.txt (continued)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/test/calc_console/CMakeLists.txt（继续）
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Subsequently, we instruct the SUT to enable coverage instrumentation with `EnableCoverage()`.
    Note that in the case of the library, we had to add instrumentation to the *object
    library* rather than the static one. This is because the `--coverage` flag has
    to be added to the compilation step, which happens when `calc_obj` is being built.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们指示 SUT 使用 `EnableCoverage()` 启用覆盖率 instrumentation。注意，在库的情况下，我们必须添加 instrumentation
    到 *对象库* 而不是静态库。这是因为 `--coverage` 标志必须添加到编译步骤，这发生在 `calc_obj` 正在构建的时候。
- en: Unfortunately, we can't add cleaning of the coverage files here, as CMake requires
    `add_custom_command` hooks to be called in the same directory as the target definition.
    This brings us back to the `src/calc` and `src/calc_console` listfiles that we
    didn't complete previously. We'll need to add `CleanCoverage(calc_static)` and
    `CleanCoverage(calc_console_static)` respectively (we have to include the `Coverage`
    module first). What else needs to be added to these files? Instructions to enable
    static analysis!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我们在这里不能添加覆盖率文件的清理，因为 CMake 要求 `add_custom_command` 钩子必须在目标定义相同的目录中调用。这使我们回到了之前未完成的
    `src/calc` 和 `src/calc_console` 列表文件。我们需要分别添加 `CleanCoverage(calc_static)` 和 `CleanCoverage(calc_console_static)`（我们首先必须包含
    `Coverage` 模块）。还需要向这些文件添加什么吗？启用静态分析的说明！
- en: Adding static analysis tools
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加静态分析工具
- en: 'We postponed the continuation of business code listfiles until now so that
    we can discuss added modules in the appropriate context. We can add a `CleanCoverage`
    function call and a few other things to the library listfile:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将业务代码列表文件的继续推迟到现在，这样我们就可以在适当的情况下讨论添加的模块。我们可以在库列表文件中添加一个 `CleanCoverage` 函数调用和其他一些东西：
- en: chapter-12/01-full-project/src/calc/CMakeLists.txt (continued)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc/CMakeLists.txt（继续）
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also add them to the executable:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将它们添加到可执行文件中：
- en: chapter-12/01-full-project/src/calc_console/CMakeLists.cmake (continued)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 章节-12/01-full-project/src/calc_console/CMakeLists.cmake (继续)
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These files are almost complete now (as the second comment suggests, we still
    need to add the documentation code, which will happen in the *Automatic documentation
    generation* section).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件现在几乎完成了（正如第二个注释所暗示的，我们还需要添加文档代码，这将在*自动文档生成*部分完成）。
- en: 'Two new modules appear in the listings: `Format` and `CppCheck`. Let''s dive
    into the first one:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中出现了两个新模块：`Format`和`CppCheck`。让我们先来看第一个：
- en: chapter-12/01-full-project/cmake/Format.cmake
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 章节-12/01-full-project/cmake/Format.cmake
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Format()` function is an exact copy of the formatting function described
    in [*Chapter 9*](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195), *Program Analysis
    Tools*; we're simply reusing it here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format()`函数是[第9章](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195)《程序分析工具》中描述的格式化函数的完整复制；我们在这里只是重新使用它。'
- en: 'Next up is a completely new `CppCheck` module:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个全新的`CppCheck`模块：
- en: chapter-12/01-full-project/cmake/CppCheck.cmake
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 章节-12/01-full-project/cmake/CppCheck.cmake
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is simple and convenient. You may see some resemblance to the Clang-Tidy
    module (from [*Chapter 9*](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195), *Program
    Analysis Tools*); this is CMake''s strength – many concepts working the same way.
    Note the arguments passed to `cppcheck`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单又方便。您可能会发现它与Clang-Tidy模块有些相似（来自[第9章](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195)，《程序分析工具》）；这是CMake的优势——许多概念的工作方式都是一致的。注意传递给`cppcheck`的参数：
- en: '`--enable=warning` – This specifies that we''d like to get warning messages.
    You can enable additional checks – refer to the Cppcheck manual for more details
    (the link can be found in the *Further reading section*).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable=warning` – 这指定了我们希望获得警告信息。您可以启用其他检查——具体请参考Cppcheck手册（在*进一步阅读部分*可以找到链接）。'
- en: '`--error-exitcode=10` – This specifies that we''d like to get an error code
    when `cppcheck` detects an issue. This can be any number from `1` to `255` (as
    `0` indicates success), although some numbers can be reserved by the system.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--error-exitcode=10` – 这指定了当`cppcheck`检测到问题时，我们希望得到一个错误代码。这可以是从`1`到`255`的任何数字（`0`表示成功），尽管有些数字可能被系统保留。'
- en: Usage is very convenient – calling `AddCppCheck` will inform CMake that it needs
    to run the checks automatically on the specified target.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非常方便——调用`AddCppCheck`将通知CMake需要在指定的目标上自动运行检查。
- en: We have virtually created all files in the `src` and `test` subdirectories.
    Now, our solution builds and can be fully tested. It's finally time to move to
    installation and packaging.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`src`和`test`子目录中几乎创建了所有文件。现在，我们的解决方案可以构建并完全测试。终于到了安装和打包的时候了。
- en: Installing and packaging
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和打包
- en: 'We''re circling back to the subject discussed in the previous chapter and starting
    with a quick overview of the files needed to set up installation and packaging:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到前一章讨论的主题，并从快速查看设置安装和打包所需的文件开始：
- en: '![Figure 12.6 – Files configuring installation and packaging'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.6 – 配置安装和打包文件的示例'
- en: '](img/Figure_12.6_B17205.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.6_B17205.jpg)'
- en: Figure 12.6 – Files configuring installation and packaging
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.6 – 配置安装和打包文件的示例'
- en: 'Only files are needed here – most of the work is already done in previous sections.
    As you may remember, the top-level listfile includes a CMake module that''s going
    to handle this process:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只需要文件——大部分工作已经在之前的章节中完成。正如您可能记得的，顶层列表文件包含一个CMake模块，它将处理这个过程：
- en: chapter-12/01-full-project/CMakeLists.txt (fragment)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 章节-12/01-full-project/CMakeLists.txt (片段)
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''re interested in installing two items:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的是安装两个项目：
- en: 'The Calc library artifacts: the static library, the shared library, and header
    files along with their target export file'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算库工件：静态库、共享库以及与之相关的头文件和目标导出文件
- en: The Calc console executable
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算控制台可执行文件
- en: The package definition config-file will only introduce library targets, as potential
    consuming projects won't depend on the executable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 包定义配置文件将只引入库目标，因为潜在的消费项目不会依赖于可执行文件。
- en: 'After configuring the installation steps, we''ll move on to the CPack configuration.
    The high-level overview of the `Install` module looks like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置安装步骤之后，我们将转向CPack配置。`Install`模块的高级概述如下：
- en: chapter-12/01-full-project/cmake/Install.cmake (overview)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 章节-12/01-full-project/cmake/Install.cmake (概览)
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Everything is planned, so it's time to write an installation module for the
    library.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都有计划，所以是时候为库编写一个安装模块了。
- en: Installation of the library
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库的安装
- en: 'To install the library, it''s best to start by configuring logical targets
    and specifying the destination for their artifacts. To avoid providing paths manually,
    we''ll be using default values provided by the `GNUInstallDirs` module. For modularity,
    we''ll group the artifacts into components. The default installation will install
    all files, but you may choose to only install the `runtime` component and skip
    the `development` artifacts:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装库，最好先配置逻辑目标并指定其工件的安装位置。为了避免手动提供路径，我们将使用`GNUInstallDirs`模块提供的默认值。为了模块化，我们将把工件分组到组件中。默认安装将安装所有文件，但你可以选择只安装`runtime`组件并跳过`development`工件：
- en: chapter-12/01-full-project/cmake/Install.cmake (fragment)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Install.cmake（片段）
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'During the installation, we''d like to register the shared library we copied
    with `ldconfig`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，我们想用`ldconfig`注册我们复制的共享库：
- en: chapter-12/01-full-project/cmake/Install.cmake (continued)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Install.cmake（继续）
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Having those steps prepared, we can make the library visible to other CMake
    projects by wrapping it in a reusable CMake package. We''ll need to generate and
    install the target export file and the config-file that includes it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些步骤的准备，我们可以通过将其封装在可重用的CMake包中来使库对其他CMake项目可见。我们需要生成并安装目标导出文件和包括它的配置文件：
- en: chapter-12/01-full-project/cmake/Install.cmake (continued)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Install.cmake（继续）
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we already know, for very simple packages, the config-file can be really
    minimal:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，对于非常简单的包，配置文件可以非常简洁：
- en: chapter-12/01-full-project/CalcConfig.cmake
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/CalcConfig.cmake
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it. The library will now be installed when you run `cmake` in `--install`
    mode after building the solution. All that remains to be installed is the executable.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，在构建解决方案后运行`cmake`的`--install`模式，库将被安装。剩下的要安装的只有可执行文件。
- en: Installation of the executable
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行文件的安装
- en: 'The installation of binary executables is the simplest step of all. We just
    need to use a single command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所有二进制可执行文件的安装是最简单的一步。我们只需要使用一个命令：
- en: chapter-12/01-full-project/cmake/Install.cmake (continued)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Install.cmake（继续）
- en: '[PRE41]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And it's done! Let's move on to the last part of the configuration – packing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 完成啦！让我们继续进行配置的最后部分——打包。
- en: Packaging with CPack
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CPack打包
- en: 'We can go wild and configure a vast multitude of supported package types; for
    this project, however, a basic configuration will be enough:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以放手去配置一大堆受支持的包类型；对于这个项目，然而，基本的配置就足够了：
- en: chapter-12/01-full-project/cmake/Install.cmake (continued)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Install.cmake（继续）
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Such a minimal setup works well for standard archives, such as ZIP files. We
    can test the whole installation and packaging with a single command (the project
    has to be built beforehand):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简洁的设置对于标准归档文件，如ZIP文件，效果很好。我们可以用一个命令（项目必须先构建）来测试整个安装和打包：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This concludes the installation and packaging; the next order of business is
    documentation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和打包就此结束；接下来要处理的事务是文档。
- en: Providing the documentation
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供文档
- en: 'The final element of a professional project is, of course, the documentation.
    It comes in two categories:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个专业项目的最后一个元素是文档。它分为两个类别：
- en: Technical documentation (interfaces, designs, classes, and files)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术文档（接口、设计、类和文件）
- en: General documentation (all other not-as-technical documents)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般文档（其他不如此技术性的文档）
- en: As we saw in [*Chapter 10*](B17205_10_Final_JC_ePub.xhtml#_idTextAnchor210),
    *Generating Documentation*, a lot of technical documentation can be generated
    automatically with CMake by using Doxygen.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](B17205_10_Final_JC_ePub.xhtml#_idTextAnchor210)中看到的，*生成文档*，很多技术文档可以通过使用Doxygen在CMake中自动生成。
- en: Automatic documentation generation
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动文档生成
- en: 'A thing to mention: some projects generate documentation during the build stage
    and package it with the rest of the project. It''s a matter of preference. For
    this project, we have decided not to do so. You might have a good reason to choose
    otherwise (such as hosting the documentation online).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提及的是：一些项目在构建阶段生成文档，并将其与其他项目内容一起打包。这是个人喜好问题。对于这个项目，我们决定不这样做。你可能有选择其他方式的好理由（例如，在网上托管文档）。
- en: '*Figure 12.7* shows the overview of the execution flow that is used in this
    process:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7展示了在此过程中使用的执行流程概述：
- en: '![Figure 12.7 – Files used to generate documentation'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 用于生成文档的文件'
- en: '](img/Figure_12.7_B17205.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.7_B17205.jpg)'
- en: Figure 12.7 – Files used to generate documentation
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 用于生成文档的文件
- en: 'To generate documentation for our targets, we''ll create another CMake utility
    module, `Doxygen`. We''ll start by using the Doxygen find-module and downloading
    the `doxygen-awesome-css` project for themes:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们目标的用户文档，我们将创建另一个CMake工具模块`Doxygen`。我们将从使用Doxygen查找模块和下载`doxygen-awesome-css`项目主题开始：
- en: chapter-12/01-full-project/cmake/Doxygen.cmake (fragment)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Doxygen.cmake（片段）
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we''ll need a function to create targets that generate documentation.
    We''ll draw closely from code introduced in [*Chapter 10*](B17205_10_Final_JC_ePub.xhtml#_idTextAnchor210),
    *Generating Documentation*, and modify it to support many targets:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个函数来创建生成文档的目标。我们将从[第10章](B17205_10_Final_JC_ePub.xhtml#_idTextAnchor210)《生成文档》中介绍的代码中汲取灵感，并对其进行修改以支持许多目标：
- en: chapter-12/01-full-project/cmake/Doxygen.cmake (continued)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/cmake/Doxygen.cmake（继续）
- en: '[PRE45]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we need to use this function by calling it for the library target:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过为库目标调用它来使用这个函数：
- en: chapter-12/01-full-project/src/calc/CMakeLists.txt (continued)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc/CMakeLists.txt（继续）
- en: '[PRE46]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And we call it for the console executable:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为控制台可执行文件调用它：
- en: chapter-12/01-full-project/src/calc_console/CMakeLists.txt (continued)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/src/calc_console/CMakeLists.txt（继续）
- en: '[PRE47]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Two new targets are added to the project: `doxygen-calc` and `doxygen-calc_console`,
    and technical documentation can be generated on demand.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中添加了两个新目标：`doxygen-calc`和`doxygen-calc_console`，可以按需生成技术文档。
- en: What other documents should we provide?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该提供其他文档吗？
- en: Not-as-technical documents of professional project
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非技术性专业文档
- en: 'Professional projects should always include at least two documents that are
    stored in a top-level directory:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 专业项目应该总是至少包括两个存储在顶级目录中的文件：
- en: '`README` – generally describes the project'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README` – 通常描述项目'
- en: '`LICENSE` – specifies the legal characteristics of the project'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE` – 指定项目的法律特性'
- en: 'You might also consider adding these:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想添加这些：
- en: '`INSTALL` – describes the steps required for installation'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALL` – 描述安装所需的步骤'
- en: '`CHANGELOG` – lists important changes that happened in different versions'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGELOG` – 列出不同版本中发生的重要变化'
- en: '`AUTHORS` – contains credits and contact information if a project has multiple
    contributors'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHORS` – 如果项目有多个贡献者，则包含信用和联系信息'
- en: '`BUGS` – informs about known bugs and instructs how to report new ones'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUGS` – 告知已知错误，并指导如何报告新错误'
- en: 'CMake as such doesn''t play any role when it comes to these files – there''s
    no automated behavior or scripts to use. However, these files are an essential
    part of C++ projects and should be covered for completeness. For reference, we''ll
    provide a minimal set of exemplary files, starting with a short `README` file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 至于CMake，当涉及到这些文件时并不会发挥任何作用——没有自动化行为或脚本可以使用。然而，这些文件是C++项目的重要组成部分，应该为完整性而覆盖。作为参考，我们将提供一套最小化的示例文件，从一个简短的`README`文件开始：
- en: chapter-12/01-full-project/README.md
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/README.md
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is short and maybe a little silly. Note the `.md` extension – it stands
    for *Markdown*, which is a text-based formatting language that is easily readable.
    Websites such as GitHub and many text editors will render these files with rich
    formatting.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件简短而可能有点傻。注意`.md`扩展名——它代表*Markdown*，这是一种易于阅读的基于文本的格式化语言。像GitHub这样的网站和许多文本编辑器都会以丰富的格式显示这些文件。
- en: 'Our `INSTALL` file will look like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`INSTALL`文件将如下所示：
- en: chapter-12/01-full-project/INSTALL
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/INSTALL
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This file turned out to be a bit longer, but it covers the most important requirements,
    steps, and commands, and it will work just fine for our needs.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件最后变得有点长，但它涵盖了最重要的要求、步骤和命令，它将完全符合我们的需求。
- en: 'The `LICENSE` file is a bit tricky, as it requires some expertise in copyright
    law (and otherwise). Instead of writing all clauses by ourselves, we can do what
    many other projects do and use a readily available software license. For this
    project, we''ll go with the MIT License, which is extremely permissive. You might
    want to choose something else, depending on the needs of a specific project –
    check the *Further reading* section for some useful references:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`LICENSE`文件有点棘手，因为它需要一些版权法的专业知识（否则）。与其自己写所有的条款，我们可以像许多其他项目一样，使用现成的软件许可证。对于这个项目，我们将选择MIT许可证，这是一个非常宽松的许可证。根据特定项目的需求，您可能想要选择其他的东西——在*进一步阅读*部分查看一些有用的参考资料：'
- en: chapter-12/01-full-project/LICENSE
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/LICENSE
- en: '[PRE50]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, we have the `CHANGELOG`. As suggested earlier, it''s good to keep track
    of changes in a file so that developers using your project can easily find out
    which version supports the features they need. For example, it might be useful
    to say that a multiplication feature was added to the library in version 0.8.2\.
    Something as simple as the following is already helpful:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`CHANGELOG`。正如之前所建议的，保留一个文件来跟踪变更是个好主意，这样使用你项目的开发者可以轻松地找到哪个版本支持他们需要的特性。例如，说库在0.8.2版本中增加了乘法功能可能是有用的。如下所示的简单内容已经很有帮助了：
- en: chapter-12/01-full-project/CHANGELOG
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: chapter-12/01-full-project/CHANGELOG
- en: '[PRE51]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our professional project is now complete – we can build it, test it, generate
    packages, upload all sources to a repository, and release artifacts. Of course,
    it would be easier if this could happen automatically, perhaps with a CI/CD pipeline.
    But that's a story for another book.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的专业项目现在已经完成——我们可以构建它，测试它，生成包，将所有源代码上传到仓库，并发布工件。当然，如果这一切可以自动发生，也许通过CI/CD管道，那就更容易了。但那是另一本书的故事。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: This chapter wraps up our long journey through CMake. Now you fully understand
    what problems CMake aims to solve and which steps are necessary to automate these
    solutions.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章结束了我们通过CMake的漫长旅程。现在你完全理解了CMake旨在解决的问题以及实现这些解决方案所需的步骤。
- en: 'In the first three chapters, we explored all the basics: what CMake is and
    how users leverage it to bring raw source code to life, what the key components
    of CMake are, and what purpose different project files have. We explained the
    syntax of CMake: comments, command invocation, arguments, variables, and control
    structures. We''ve discovered how modules and subprojects work, what the correct
    project structure is, and how to work with various platforms and toolchains.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们探索了所有基础知识：什么是CMake以及用户如何利用它将源代码从原始状态变为可运行状态，CMake的关键组件是什么，不同项目文件有什么目的。我们解释了CMake的语法：注释，命令调用，参数，变量和控制结构。我们发现了模块和子项目是如何工作的，正确的项目结构是什么，以及如何与各种平台和工具链一起工作。
- en: 'The second part of the book taught us about building with CMake: how to use
    targets, custom commands, build types, and generator expressions. We dove deep
    into the technicalities of compilation, and the configuration of a preprocessor
    and an optimizer. We discussed linking and introduced different library types.
    Then, we investigated how CMake helps to manage the dependencies of a project
    with the `FetchContent` and `ExternalProject` modules. We also researched Git
    submodules as a possible alternative. Most importantly, we studied how to find
    installed packages with `find_package()` and `FindPkgConfig`. If these weren''t
    enough, we looked into writing our own find-modules.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第二部分教导我们如何使用CMake进行构建：如何使用目标，自定义命令，构建类型和生成器表达式。我们深入探讨了编译的技术细节，以及预处理器和优化器的配置。我们讨论了链接，并介绍了不同的库类型。然后，我们研究了CMake如何使用`FetchContent`和`ExternalProject`模块来管理项目的依赖关系。我们还研究了Git子模块作为可能的替代方案。最重要的是，我们学习了如何使用`find_package()`和`FindPkgConfig`查找已安装的包。如果这些还不够，我们探讨了编写自己的查找模块。
- en: 'The last part told us how to go about the automation of testing, analysis,
    documentation, installing, and packaging. We looked into CTest and testing frameworks:
    Catch2, GoogleTest, and GoogleMock. Coverage reporting was covered too. [*Chapter
    9*](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195), *Program Analysis Tools*,
    gave us an understanding of different analysis tools: a formatter and static checkers
    (Clang-Tidy, Cppcheck, and so on), and explained how to add the Memcheck memory
    analyzer from the Valgrind suite. Next, we briefly described how to generate documentation
    with Doxygen and how to make it presentable. Lastly, we demonstrated how to install
    projects on the system, create reusable CMake packages, and configure and use
    CPack to generate binary packages.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分告诉我们如何进行测试，分析，文档，安装和打包的自动化。我们研究了CTest和测试框架：Catch2，GoogleTest和GoogleMock。覆盖率报告也得到了涵盖。第[9章](B17205_09_Final_JC_ePub.xhtml#_idTextAnchor195)，*程序分析工具*，让我们了解了不同的分析工具：格式化器和静态检查器（Clang-Tidy，Cppcheck等），并解释了如何添加Valgrind套件中的Memcheck内存分析器。接下来，我们简要介绍了如何使用Doxygen生成文档以及如何使其更具吸引力。最后，我们展示了如何将项目安装到系统上，创建可重用的CMake包，以及如何配置和使用CPack生成二进制包。
- en: The last chapter drew on all this knowledge to showcase a completely professional
    project.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章利用了所有的知识来展示一个完全专业的项目。
- en: '*Congratulations on completing this book. We''ve covered everything necessary
    to develop, test, and package high-quality C ++ software. The best way to make
    progress from here is to put what you have learned into practice and create great
    software for your users. Good luck!*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成这本书。我们已经涵盖了开发、测试和打包高质量C ++软件所需的一切内容。从这里开始取得进步的最佳方式是将你所学的内容付诸实践，为你的用户创建伟大的软件。祝你好运！
- en: '*R.*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: R.
- en: Further reading
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以参考以下链接：
- en: '*Building both a static library and a shared library*:[https://stackoverflow.com/q/2152077](https://stackoverflow.com/q/2152077)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何同时构建静态库和共享库：[https://stackoverflow.com/q/2152077](https://stackoverflow.com/q/2152077)
- en: '*A FXTUI library project*: [https://github.com/ArthurSonzogni/FTXUI](https://github.com/ArthurSonzogni/FTXUI)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FXTUI库项目：[https://github.com/ArthurSonzogni/FTXUI](https://github.com/ArthurSonzogni/FTXUI)
- en: '*The documentation of the option() command*: [https://cmake.org/cmake/help/latest/command/option.html](https://cmake.org/cmake/help/latest/command/option.html)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项()命令的文档：[https://cmake.org/cmake/help/latest/command/option.html](https://cmake.org/cmake/help/latest/command/option.html)
- en: '*Preparing for Release (of open source software) by Google*:[https://opensource.google/docs/releasing/preparing/](https://opensource.google/docs/releasing/preparing/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌关于为开源软件准备发布的文档：[https://opensource.google/docs/releasing/preparing/](https://opensource.google/docs/releasing/preparing/)
- en: '*Why we can''t use Clang-Tidy for GCC-precompiled headers*: [https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104](https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们不能用Clang-Tidy对GCC预编译头进行处理：[https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104](https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104)
- en: '*Cppcheck manual*:[https://cppcheck.sourceforge.io/manual.pdf](https://cppcheck.sourceforge.io/manual.pdf)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cppcheck手册：[https://cppcheck.sourceforge.io/manual.pdf](https://cppcheck.sourceforge.io/manual.pdf)
- en: '*How to write a README*:[https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/](https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写README文件：[https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/](https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/)
- en: '*Creative Commons Licenses for GitHub Projects*: [https://github.com/santisoler/cc-licenses](https://github.com/santisoler/cc-licenses)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对GitHub项目的Creative Commons许可证：[https://github.com/santisoler/cc-licenses](https://github.com/santisoler/cc-licenses)
- en: '*Commonly used project licenses recognized by GitHub*: [https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被GitHub识别的常用项目许可证：[https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)
