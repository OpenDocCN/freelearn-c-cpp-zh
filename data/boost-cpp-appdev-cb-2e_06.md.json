["```cpp\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\nnamespace detail {\n\ntemplate <class T>\nstruct task_wrapped {\nprivate:\n    T task_unwrapped_;\n\npublic:\n    explicit task_wrapped(const T& f)\n        : task_unwrapped_(f)\n    {}\n\n    void operator()() const {\n        // Resetting interruption.\n        try {\n            boost::this_thread::interruption_point();\n        } catch(const boost::thread_interrupted&){}\n\n        try {\n            // Executing task.\n            task_unwrapped_();\n        } catch (const std::exception& e) {\n            std::cerr<< \"Exception: \" << e.what() << '\\n';\n        } catch (const boost::thread_interrupted&) {\n            std::cerr<< \"Thread interrupted\\n\";\n        } catch (...) {\n            std::cerr<< \"Unknown exception\\n\";\n        }\n    }\n};\n\n} // namespace detail\n```", "```cpp\nnamespace detail {\n\ntemplate <class T>\ntask_wrapped<T> make_task_wrapped(const T& task_unwrapped) {\n    return task_wrapped<T>(task_unwrapped);\n}\n\n} // namespace detail\n```", "```cpp\n#include <boost/asio/io_service.hpp> \n\nclass tasks_processor: private boost::noncopyable {\nprotected:\n    static boost::asio::io_service& get_ios() {\n        static boost::asio::io_service ios;\n        static boost::asio::io_service::work work(ios);\n\n        return ios;\n    }\n```", "```cpp\npublic:\n    template <class T>\n    static void push_task(const T& task_unwrapped) {\n        get_ios().post(detail::make_task_wrapped(task_unwrapped));\n    }\n```", "```cpp\n    static void start() {\n        get_ios().run();\n    }\n\n    static void stop() {\n        get_ios().stop();\n    }\n}; // tasks_processor\n```", "```cpp\nint func_test() {\n    static int counter = 0;\n    ++ counter;\n    boost::this_thread::interruption_point();\n\n    switch (counter) {\n    case 3:\n        throw std::logic_error(\"Just checking\");\n\n    case 10:\n        // Emulation of thread interruption.\n        // Caught inside task_wrapped and does not stop execution.\n        throw boost::thread_interrupted();\n\n    case 90:\n        // Stopping the tasks_processor.\n        tasks_processor::stop();\n    }\n\n    return counter;\n}\n```", "```cpp\nint main () {\n    for (std::size_t i = 0; i < 100; ++i) {\n        tasks_processor::push_task(&func_test);\n    }\n\n    // Processing was not started.\n    assert(func_test() == 1);\n\n    // We can also use lambda as a task.\n    // Counting 2 + 2 asynchronously.\n    int sum = 0;\n    tasks_processor::push_task(\n        [&sum]() { sum = 2 + 2; }\n    );\n\n    // Processing was not started.\n    assert(sum == 0);\n\n    // Does not throw, but blocks till\n    // one of the tasks it is owning\n    // calls tasks_processor::stop().\n    tasks_processor::start();\n    assert(func_test() == 91);\n}\n```", "```cpp\ntry { \n    boost::this_thread::interruption_point(); \n} catch(const boost::thread_interrupted&){}\n```", "```cpp\nstatic boost::asio::io_service& get_ios() {\n    static boost::asio::io_service ios;\n    static boost::asio::io_service::work work(ios);\n\n    return ios;\n}\n```", "```cpp\nclass tasks_processor {\n    // ...\npublic:\n    template <class Time, class Func>\n    static void run_delayed(Time duration_or_time, const Func& f) {\n        std::unique_ptr<boost::asio::deadline_timer> timer(\n            new boost::asio::deadline_timer(\n                get_ios(), duration_or_time\n            )\n        );\n\n        timer_ref.async_wait(\n            detail::timer_task<Func>(\n                std::move(timer),\n                f\n            )\n        );\n    }\n};\n```", "```cpp\n#include <boost/asio/io_service.hpp>\n#include <boost/asio/deadline_timer.hpp>\n#include <boost/system/error_code.hpp>\n#include <memory>  // std::unique_ptr\n#include <iostream>\n\nnamespace detail {\n\n    template <class Functor>\n    struct timer_task {\n    private:\n        std::unique_ptr<boost::asio::deadline_timer> timer_;\n        task_wrapped<Functor> task_;\n\n    public:\n        explicit timer_task(\n                std::unique_ptr<boost::asio::deadline_timer> timer,\n                const Functor& task_unwrapped)\n            : timer_(std::move(timer))\n            , task_(task_unwrapped)\n        {}\n\n        void operator()(const boost::system::error_code& error) const {\n            if (!error) {\n                task_();\n            } else {\n                std::cerr << error << '\\n';\n            }\n        }\n    };\n\n} // namespace detail\n```", "```cpp\nint main () {\n    const int seconds_to_wait = 3;\n    int i = 0;\n\n    tasks_processor::run_delayed(\n        boost::posix_time::seconds(seconds_to_wait),\n        test_functor(i)\n    );\n\n    tasks_processor::run_delayed(\n        boost::posix_time::from_time_t(time(NULL) + 1),\n        &test_func1\n    );\n\n    assert(i == 0);\n\n    // Blocks till one of the tasks\n    // calls tasks_processor::stop().\n    tasks_processor::start();\n}\n```", "```cpp\nstruct test_functor {\n    int& i_;\n\n    explicit test_functor(int& i);\n\n    void operator()() const {\n        i_ = 1;\n        tasks_processor::stop();\n    }\n};\n\nvoid test_func1();\n```", "```cpp\n    template <class Time, class Functor>\n    static void run_delayed(Time duration_or_time, const Functor& f) {\n        std::unique_ptr<boost::asio::deadline_timer> \n        timer( /* ... */ );\n\n        boost::asio::deadline_timer& timer_ref = *timer;\n\n        timer_ref.async_wait(\n            detail::timer_task<Functor>(\n                std::move(timer),\n                f\n            )\n        );\n    }\n```", "```cpp\nboost::asio::deadline_timer& timer_ref = *timer;\n```", "```cpp\n            detail::timer_task<Functor>(\n                std::move(timer),\n                f\n            )\n```", "```cpp\ntimer_ref.async_wait( /* timer_task */ )\n```", "```cpp\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/core/noncopyable.hpp>\n\nstruct connection_with_data: boost::noncopyable {\n    boost::asio::ip::tcp::socket socket;\n    std::string data;\n\n    explicit connection_with_data(boost::asio::io_service& ios)\n        : socket(ios) \n    {}\n\n    void shutdown() {\n        if (!socket.is_open()) {\n            return;\n        }\n\n        boost::system::error_code ignore;\n        socket.shutdown(\n            boost::asio::ip::tcp::socket::shutdown_both,\n            ignore\n        );\n        socket.close(ignore);\n    }\n\n    ~connection_with_data() {\n        shutdown();\n    }\n};\n```", "```cpp\n#include <memory> // std::unique_ptr\n\ntypedef std::unique_ptr<connection_with_data> connection_ptr;\n```", "```cpp\nclass tasks_processor {\n    // ...\npublic:\n    static connection_ptr create_connection(\n        const char* addr,\n        unsigned short port_num)\n    {\n        connection_ptr c( new connection_with_data(get_ios()) );\n\n        c->socket.connect(boost::asio::ip::tcp::endpoint(\n            boost::asio::ip::address_v4::from_string(addr),\n            port_num\n        ));\n\n        return c;\n    }\n};\n```", "```cpp\n#include <boost/asio/write.hpp>\n\ntemplate <class T>\nstruct task_wrapped_with_connection;\n\ntemplate <class Functor>\nvoid async_write_data(connection_ptr&& c, const Functor& f) {\n    boost::asio::ip::tcp::socket& s = c->socket;\n    std::string& d = c->data;\n\n    boost::asio::async_write(\n        s,\n        boost::asio::buffer(d),\n        task_wrapped_with_connection<Functor>(std::move(c), f)\n    );\n}\n```", "```cpp\n#include <boost/asio/read.hpp>\n\ntemplate <class Functor>\nvoid async_read_data(\n    connection_ptr&& c,\n    const Functor& f,\n    std::size_t at_least_bytes)\n{\n    c->data.resize(at_least_bytes);\n    c->data.resize(at_least_bytes);\n\n    boost::asio::ip::tcp::socket& s = c->socket;\n    std::string& d = c->data;\n    char* p = (d.empty() ? 0 : &d[0]);\n\n    boost::asio::async_read(\n        s,\n        boost::asio::buffer(p, d.size()),\n        task_wrapped_with_connection<Functor>(std::move(c), f)\n    );\n}\n\ntemplate <class Functor>\nvoid async_read_data_at_least(\n    connection_ptr&& c,\n    const Functor& f,\n    std::size_t at_least_bytes,\n    std::size_t at_most)\n{\n    std::string& d = c->data;\n    d.resize(at_most);\n    char* p = (at_most == 0 ? 0 : &d[0]);\n\n    boost::asio::ip::tcp::socket& s = c->socket;\n\n    boost::asio::async_read(\n        s,\n        boost::asio::buffer(p, at_most),\n        boost::asio::transfer_at_least(at_least_bytes),\n        task_wrapped_with_connection<Functor>(std::move(c), f)\n    );\n}\n```", "```cpp\ntemplate <class T>\nstruct task_wrapped_with_connection {\nprivate:\n    connection_ptr c_;\n    T task_unwrapped_;\n\npublic:\n    explicit task_wrapped_with_connection\n    (connection_ptr&& c, const T& f)\n        : c_(std::move(c))\n        , task_unwrapped_(f)\n    {}\n\n    void operator()(\n        const boost::system::error_code& error,\n        std::size_t bytes_count)\n    {\n        c_->data.resize(bytes_count);\n        task_unwrapped_(std::move(c_), error);\n    }\n};\n```", "```cpp\nvoid send_auth() {\n    connection_ptr soc = tasks_processor::create_connection(\n        \"127.0.0.1\", g_port_num\n    );\n    soc->data = \"auth_name\";\n\n    async_write_data(\n        std::move(soc),\n        &on_send\n    );\n}\n```", "```cpp\nvoid receive_auth_response(\n    connection_ptr&& soc,\n    const boost::system::error_code& err)\n{\n    if (err) {\n        std::cerr << \"Error on sending data: \" \n        << err.message() << '\\n';\n        assert(false);\n    }\n\n    async_read_data(\n        std::move(soc),\n        &process_server_response,\n        2\n    );\n}\n```", "```cpp\nvoid process_server_response(\n        connection_ptr&& soc,\n        const boost::system::error_code& err)\n{\n    if (err && err != boost::asio::error::eof) {\n        std::cerr << \"Client error on receive: \"\n        << err.message() << '\\n';\n        assert(false);\n    }\n\n    if (soc->data.size() != 2) {\n        std::cerr << \"Wrong bytes count\\n\";\n        assert(false);\n    }\n\n    if (soc->data != \"OK\") {\n        std::cerr << \"Wrong response: \" << soc->data << '\\n';\n        assert(false);\n    }\n\n    soc->shutdown();\n    tasks_processor::stop();\n}\n```", "```cpp\n        c->socket.connect(boost::asio::ip::tcp::endpoint(\n            boost::asio::ip::address_v4::from_string(addr),\n            port_num\n        ));\n```", "```cpp\n#include <boost/asio/write.hpp>\n\ntemplate <class Functor>\nvoid async_write_data(connection_ptr&& c, const Functor& f) {\n```", "```cpp\nboost::asio::ip::tcp::socket& s = c->socket;\nstd::string& d = c->data;\n```", "```cpp\n    boost::asio::async_write(\n        s,\n        boost::asio::buffer(d),\n        task_wrapped_with_connection<Functor>(std::move(c), f)\n    );\n}\n```", "```cpp\nvoid on_send(connection_ptr&& soc, const boost::system::\nerror_code& err);\n\nvoid connect_and_send() {\n    connection_ptr s = tasks_processor::create_connection\n    (\"127.0.0.1\", 80);\n\n    s->data = \"data_to_send\";\n    async_write_data(\n        std::move(s),\n        &on_send\n    );\n}\n```", "```cpp\nboost::asio::async_read(\n    s,\n    boost::asio::buffer(p, at_most),\n    boost::asio::transfer_at_least(at_least_bytes),\n    task_wrapped_with_connection<Functor>(std::move(c), f)\n);\n```", "```cpp\nvoid process_server_response(\n        connection_ptr&& soc,\n        const boost::system::error_code& err);\n```", "```cpp\n    if (err && err != boost::asio::error::eof) {\n        std::cerr << \"Client error on receive: \" \n        << err.message() << '\\n';\n        assert(false);\n    }\n```", "```cpp\nif (soc->data.size() != 2) {\n    std::cerr << \"Wrong bytes count\\n\";\n    assert(false);\n}\n\nif (soc->data != \"OK\") {\n    std::cerr << \"Wrong response: \" << soc->data << '\\n';\n    assert(false);\n}\n```", "```cpp\nvoid operator()(\n    const boost::system::error_code& error,\n    std::size_t bytes_count)\n{\n    const auto lambda = [this, &error, bytes_count]() {\n        this->c_->data.resize(bytes_count);\n        this->task_unwrapped_(std::move(this->c_), error);\n    };\n\n    const auto task = detail::make_task_wrapped(lambda);\n    task();\n}\n```", "```cpp\nclass tasks_processor {\n    typedef boost::asio::ip::tcp::acceptor acceptor_t;\n\n    typedef boost::function<\n        void(connection_ptr, const boost::system::error_code&)\n    > on_accpet_func_t;\n```", "```cpp\nprivate:\n    struct tcp_listener {\n        acceptor_t              acceptor_;\n        const on_accpet_func_t  func_;\n        connection_ptr          new_c_;\n\n        template <class Functor>\n        tcp_listener(\n                boost::asio::io_service& io_service,\n                unsigned short port,\n                const Functor& task_unwrapped)\n            : acceptor_(io_service, boost::asio::ip::tcp::endpoint(\n                boost::asio::ip::tcp::v4(), port\n            ))\n            , func_(task_unwrapped)\n        {}\n    };\n\n    typedef std::unique_ptr<tcp_listener> listener_ptr;\n```", "```cpp\npublic:  \n   template <class Functor>\n    static void add_listener(unsigned short port_num, const Functor& f) {\n        std::unique_ptr<tcp_listener> listener(\n            new tcp_listener(get_ios(), port_num, f)\n        );\n\n        start_accepting_connection(std::move(listener));\n    }\n```", "```cpp\nprivate:\n   static void start_accepting_connection(listener_ptr&& listener) {\n        if (!listener->acceptor_.is_open()) {\n            return;\n        }\n\n        listener->new_c_.reset(new connection_with_data(\n            listener->acceptor_.get_io_service()\n        ));\n\n        boost::asio::ip::tcp::socket& s = listener->new_c_->socket;\n        acceptor_t& a = listener->acceptor_;\n        a.async_accept(\n            s,\n            tasks_processor::handle_accept(std::move(listener))\n        );\n    }\n```", "```cpp\nprivate:\n    struct handle_accept {\n        listener_ptr listener;\n\n        explicit handle_accept(listener_ptr&& l)\n            : listener(std::move(l))\n        {}\n\n        void operator()(const boost::system::error_code& error) {\n            task_wrapped_with_connection<on_accpet_func_t> task(\n                std::move(listener->new_c_), listener->func_\n            );\n\n            start_accepting_connection(std::move(listener));\n            task(error, 0);\n        }\n    };\n```", "```cpp\nclass authorizer {\npublic:\n    static void on_connection_accpet(\n        connection_ptr&& connection,\n        const boost::system::error_code& error)\n    {\n        assert(!error);\n        // ...\n    }\n};\n\nint main() {\n    tasks_processor::add_listener(80, &authorizer::on_connection_accpet);\n    tasks_processor::start();\n}\n```", "```cpp\nboost::asio::socket_base::reuse_address option(true); \nacceptor_.set_option(option); \n```", "```cpp\n#include <boost/thread/thread.hpp> \n\nclass tasks_processor {\npublic:\n    // Default value will attempt to guess optimal count of threads.\n    static void start_multiple(std::size_t threads_count = 0) {\n        if (!threads_count) {\n            threads_count = (std::max)(static_cast<int>(\n                boost::thread::hardware_concurrency()), 1\n            );\n        }\n\n        // First thread is the current thread.\n        -- threads_count;\n\n        boost::asio::io_service& ios = get_ios();\n        boost::thread_group tg;\n        for (std::size_t i = 0; i < threads_count; ++i) {\n            tg.create_thread([&ios]() { ios.run(); });\n        }\n\n        ios.run();\n        tg.join_all();\n    }\n};\n```", "```cpp\n#include <boost/thread/thread.hpp>\n\nsubsystem1 subs1;\nsubsystem2 subs2;\n\nvoid process_data() {\n    while (!subs1.is_stopped()) {\n        data_packet data = subs1.get_data();\n        decoded_data d_decoded = decode_data(data);\n        compressed_data c_data = compress_data(d_decoded);\n        subs2.send_data(c_data);\n    }\n}\n\nvoid run_in_multiple_threads() {\n    boost::thread t(&process_data);\n    process_data();\n\n    t.join();\n}\n```", "```cpp\nwork_queue decoding_queue, compressing_queue, sending_queue;\n```", "```cpp\nvoid start_data_accepting();\nvoid do_decode(const data_packet& packet);\nvoid do_compress(const decoded_data& packet);\n\nvoid start_data_accepting() {\n    while (!subs1.is_stopped()) {\n        data_packet packet = subs1.get_data();\n\n        decoding_queue.push_task(\n            [packet]() {\n                do_decode(packet);\n            }\n        );\n    }\n}\n\nvoid do_decode(const data_packet& packet) {\n    decoded_data d_decoded = decode_data(packet);\n\n    compressing_queue.push_task(\n        [d_decoded]() {\n            do_compress(d_decoded);\n        }\n    );\n}\n\nvoid do_compress(const decoded_data& packet) {\n    compressed_data c_data = compress_data(packet);\n\n    sending_queue.push_task(\n        [c_data]() {\n            subs2.send_data(c_data);\n        }\n    );\n}\n```", "```cpp\n#include <deque>\n#include <boost/function.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/condition_variable.hpp>\n\nclass work_queue {\npublic:\n    typedef boost::function<void()> task_type;\n\nprivate:\n    std::deque<task_type>       tasks_;\n    boost::mutex                mutex_;\n    boost::condition_variable   cond_;\n    bool                        is_stopped_;\n\npublic:\n    work_queue()\n        : is_stopped_(false)\n    {}\n\n    void run();\n    void stop();\n\n    // Same as in Chapter 5, but with\n    // rvalue references support.\n    void push_task(task_type&& task);\n};\n```", "```cpp\nvoid work_queue::stop() {\n    boost::lock_guard<boost::mutex> lock(mutex_);\n    is_stopped_ = true;\n    cond_.notify_all();\n}\n\nvoid work_queue::run() {\n    while (1) {\n        boost::unique_lock<boost::mutex> lock(mutex_);\n        while (tasks_.empty()) {\n            if (is_stopped_) {\n                return;\n            }\n            cond_.wait(lock);\n        }\n\n        task_type t = std::move(tasks_.front());\n        tasks_.pop_front();\n        lock.unlock();\n\n        t();\n    }\n}\n```", "```cpp\n#include <boost/thread/thread.hpp> \nint main() {\n    boost::thread t_data_decoding(\n        []() { decoding_queue.run(); }\n    );\n    boost::thread t_data_compressing(\n        []() { compressing_queue.run(); }\n    );\n    boost::thread t_data_sending(\n        []() { sending_queue.run(); }\n    );\n\n    start_data_accepting();\n```", "```cpp\n    decoding_queue.stop();\n    t_data_decoding.join();\n\n    compressing_queue.stop();\n    t_data_compressing.join();\n\n    sending_queue.stop();\n    t_data_sending.join();\n```", "```cpp\n#include <boost/array.hpp>\n#include <boost/thread/barrier.hpp>\n#include <boost/thread/thread.hpp>\n\ntypedef boost::array<std::size_t, 10000> vector_type;\ntypedef boost::array<vector_type, 4> data_t;\n\nvoid fill_data(vector_type& data);\nvoid compute_send_data(data_t& data);\n\nvoid runner(std::size_t thread_index, boost::barrier& barrier, data_t& data) {\n    for (std::size_t i = 0; i < 1000; ++ i) {\n        fill_data(data.at(thread_index));\n        barrier.wait();\n\n        if (!thread_index) {\n            compute_send_data(data);\n        }\n        barrier.wait();\n    }\n}\n\nint main() {\n    // Initing barrier.\n    boost::barrier barrier(data_t::static_size);\n\n    // Initing data.\n    data_t data;\n\n    // Run on 4 threads.\n    boost::thread_group tg;\n    for (std::size_t i = 0; i < data_t::static_size; ++i) {\n        tg.create_thread([i, &barrier, &data] () {\n            runner(i, barrier, data);\n        });\n    }\n\n    tg.join_all();\n}\n```", "```cpp\n#include <boost/atomic.hpp> \ntypedef boost::atomic<unsigned int> atomic_count_t; \n```", "```cpp\nvoid clever_runner(\n        std::size_t thread_index,\n        std::size_t iteration,\n        atomic_count_t& counter,\n        data_t& data)\n{\n    fill_data(data.at(thread_index));\n\n    if (++counter != data_t::static_size) {\n        return;\n    }\n\n    compute_send_data(data);\n\n    if (++iteration == 1000) {\n        // Exiting, because 1000 iterations are done.\n        tasks_processor::stop();\n        return;\n    }\n\n    counter = 0;\n    for (std::size_t i = 0; i < data_t::static_size; ++ i) {\n        tasks_processor::push_task([i, iteration, &counter, &data]() {\n            clever_runner( \n                i, \n                iteration,\n                counter,\n                data\n            );\n        });\n    }\n}\n```", "```cpp\n    // Initing counter.\n    atomic_count_t counter(0);\n\n    // Initing data.\n    data_t data;\n\n    // Run 4 tasks.\n    for (std::size_t i = 0; i < data_t::static_size; ++i) {\n        tasks_processor::push_task([i, &counter, &data]() {\n            clever_runner( \n                i, \n                0, // first iteration\n                counter,\n                data\n            );\n        });\n    }\n\n    tasks_processor::start();\n```", "```cpp\n#include <boost/exception_ptr.hpp>\n\nstruct process_exception {\n    boost::exception_ptr exc_;\n\n    explicit process_exception(const boost::exception_ptr& exc)\n        : exc_(exc)\n    {}\n\n    void operator()() const;\n};\n```", "```cpp\n#include <boost/lexical_cast.hpp>\nvoid func_test2(); // Forward declaration.\n\nvoid process_exception::operator()() const  {\n    try {\n        boost::rethrow_exception(exc_);\n    } catch (const boost::bad_lexical_cast& /*e*/) {\n        std::cout << \"Lexical cast exception detected\\n\" << std::endl;\n\n        // Pushing another task to execute.\n        tasks_processor::push_task(&func_test2);\n    } catch (...) {\n        std::cout << \"Can not handle such exceptions:\\n\" \n            << boost::current_exception_diagnostic_information() \n            << std::endl;\n\n        // Stopping.\n        tasks_processor::stop();\n    }\n}\n```", "```cpp\n#include <stdexcept>\nvoid func_test1() {\n    try {\n        boost::lexical_cast<int>(\"oops!\");\n    } catch (...) {\n        tasks_processor::push_task(\n            process_exception(boost::current_exception())\n        );\n    }\n}\n\nvoid func_test2() {\n    try {\n        // ...\n        BOOST_THROW_EXCEPTION(std::logic_error(\"Some fatal logic error\"));\n        // ...\n    } catch (...) {\n        tasks_processor::push_task(\n            process_exception(boost::current_exception())\n        );\n    }\n}\n```", "```cpp\n  tasks_processor::get().push_task(&func_test1); \n  tasks_processor::get().start(); \n```", "```cpp\nLexical cast exception detected\n\nCan not handle such exceptions:\nmain.cpp(48): Throw in function void func_test2()\nDynamic exception type: boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::logic_error> >\nstd::exception::what: Some fatal logic error  \n```", "```cpp\nvoid run_throw(boost::exception_ptr& ptr) {\n    try {\n        // A lot of code goes here.\n    } catch (...) {\n        ptr = boost::current_exception();\n    }\n}\n\nint main () {\n    boost::exception_ptr ptr;\n\n    // Do some work in parallel.\n    boost::thread t(\n        &run_throw,\n        boost::ref(ptr)\n    );\n\n    // Some code goes here.\n    // ...\n\n    t.join();\n\n    // Checking for exception.\n    if (ptr) {\n        // Exception occurred in thread.\n        boost::rethrow_exception(ptr);\n    }\n}\n```", "```cpp\n#include <boost/asio/signal_set.hpp> \n#include <boost/function.hpp> \n```", "```cpp\nprotected:\n    static boost::asio::signal_set& signals() {\n        static boost::asio::signal_set signals_(get_ios());\n        return signals_;\n    }\n\n    static boost::function<void(int)>& signal_handler() {\n        static boost::function<void(int)> users_signal_handler_;\n        return users_signal_handler_;\n    }\n```", "```cpp\n    static void handle_signals(\n            const boost::system::error_code& error,\n            int signal_number)\n    {\n        signals().async_wait(&tasks_processor::handle_signals);\n\n        if (error) {\n            std::cerr << \"Error in signal handling: \" << error << '\\n';\n        } else {\n            boost::function<void(int)> h = signal_handler();\n            h(signal_number);\n        }\n\n    }\n```", "```cpp\npublic:\n\n    // This function is not thread safe!\n    // Must be called before all the `start()` calls.\n    // Function can be called only once.\n    template <class Func>\n    static void register_signals_handler(\n            const Func& f,\n            std::initializer_list<int> signals_to_wait)\n    {\n        // Making sure that this is the first call.\n        assert(!signal_handler()); \n\n        signal_handler() = f;\n        boost::asio::signal_set& sigs = signals();\n\n        std::for_each(\n            signals_to_wait.begin(),\n            signals_to_wait.end(),\n            [&sigs](int signal) { sigs.add(signal); }\n        );\n\n        sigs.async_wait(&tasks_processor::handle_signals);\n    }\n```", "```cpp\nvoid accept_3_signals_and_stop(int signal) {\n    static int signals_count = 0;\n    assert(signal == SIGINT);\n\n    ++ signals_count;\n    std::cout << \"Captured \" << signals_count << \" SIGINT\\n\"; \n    if (signals_count == 3) {\n        tasks_processor::stop();\n    }\n}\n\nint main () {\n    tasks_processor::register_signals_handler(\n        &accept_3_signals_and_stop,\n        { SIGINT, SIGSEGV }\n    );\n\n    tasks_processor::start();\n}\n```", "```cpp\nCaptured 1 SIGINT\nCaptured 2 SIGINT\nCaptured 3 SIGINT\nPress any key to continue . . .\n```", "```cpp\nboost::function<void(int)> h = signal_handler();\n\ndetail::make_task_wrapped([h, signal_number]() {\n    h(signal_number);\n})(); // make and run task_wrapped\n```"]