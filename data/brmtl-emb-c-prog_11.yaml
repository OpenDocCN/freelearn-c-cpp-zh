- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Analog-to-Digital Converter (ADC)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟到数字转换器（ADC）
- en: In this chapter, we will learn about the **analog-to-digital converter** (**ADC**),
    an important peripheral in embedded systems that enables the microcontroller to
    interface with the analog world. We will start by providing an overview of the
    analog-to-digital conversion process, the importance of the ADC, and its key specifications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**模拟到数字转换器**（**ADC**），这是嵌入式系统中一个重要的外围设备，它使微控制器能够与模拟世界进行接口。我们将首先概述模拟到数字转换过程、ADC的重要性及其关键规格。
- en: Following this, we will extract and analyze the relevant registers from the
    STM32F411 reference manual that are necessary for ADC operations. Finally, we
    will develop a bare-metal ADC driver to demonstrate the practical application
    of the theoretical concepts we’ve discussed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将从STM32F411参考手册中提取和分析ADC操作所需的有关寄存器。最后，我们将开发一个裸机ADC驱动程序，以展示我们讨论的理论概念的实际应用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Overview of analog-to-digital conversion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟到数字转换概述
- en: The STM32F4 ADC peripheral
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32F4 ADC外围设备
- en: The key ADC registers and flags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键ADC寄存器和标志
- en: Developing the ADC driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发ADC驱动程序
- en: By the end of this chapter, you will have a comprehensive understanding of the
    STM32 ADC peripheral and the skills necessary to develop efficient drivers for
    it, enabling you to effectively integrate analog-to-digital conversion capabilities
    into your embedded systems projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将全面了解STM32 ADC外围设备及其开发高效驱动程序所需的技能，这将使您能够有效地将模拟到数字转换功能集成到您的嵌入式系统项目中。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Overview of analog-to-digital conversion
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟到数字转换概述
- en: ADC is a critical process in embedded systems that allows our microcontrollers
    to interpret and process real-world analog signals. In this section, we will walk
    through this process, explaining each step involved in converting an analog signal
    into digital values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ADC是嵌入式系统中的一个关键过程，它允许我们的微控制器解释和处理现实世界的模拟信号。在本节中，我们将逐步介绍这个过程，解释将模拟信号转换为数字值所涉及的每个步骤。
- en: What is analog-to-digital conversion?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是模拟到数字转换？
- en: Analog-to-digital conversion is the process of converting a continuous analog
    signal into a discrete digital representation. Analog signals, which can have
    any value within a certain range, are transformed into digital signals, which
    have specific, quantized levels. This conversion is essential because microcontrollers
    and digital systems can only process digital data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟到数字转换是将连续的模拟信号转换为离散数字表示的过程。模拟信号可以在一定范围内具有任何值，而数字信号具有特定的、量化的级别。这种转换是必不可少的，因为微控制器和数字系统只能处理数字数据。
- en: 'The conversion process typically involves several key steps: sampling, quantization,
    and encoding. Let’s break down these steps, starting with sampling.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程通常涉及几个关键步骤：采样、量化和编码。让我们从采样开始分解这些步骤。
- en: Sampling
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采样
- en: '**Sampling** involves measuring the amplitude of an analog signal at regular
    intervals, called **sampling intervals**. The result is a series of discrete values
    that approximate the original analog signal. *Figure 11**.1* depicts this process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样**涉及在定期的时间间隔内测量模拟信号的幅度，这些时间间隔称为**采样间隔**。结果是近似原始模拟信号的一系列离散值。*图11.1*展示了这个过程：'
- en: '![Figure 11.1: The sampling process](img/B21914_11_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：采样过程](img/B21914_11_1.jpg)'
- en: 'Figure 11.1: The sampling process'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：采样过程
- en: The rate at which the analog signal is sampled is known as the **sampling rate**
    or **sampling frequency**. This is typically measured in samples per second (Hz).
    According to the **Nyquist Theorem**, the sampling rate must be at least twice
    the highest frequency present in the analog signal to accurately reconstruct the
    original signal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟信号采样的速率被称为**采样率**或**采样频率**。这通常以每秒的样本数（Hz）来衡量。根据**奈奎斯特定理**，采样率必须至少是模拟信号中最高频率的两倍，才能准确重建原始信号。
- en: The next step in the process is quantization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的下一步是量化。
- en: Quantization
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量化
- en: '**Quantization** is the process of mapping the sampled analog values to the
    nearest discrete levels available in the digital domain. Each discrete level corresponds
    to a unique digital code.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**量化**是将采样模拟值映射到数字域中可用的最近离散级别的过程。每个离散级别对应一个唯一的数字码。'
- en: The number of discrete levels available for quantization is determined by the
    resolution of the analog-to-digital converter. For example, an *8-bit ADC has
    256 levels (28)*, while a *12-bit ADC has 4096* *levels (212)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于量化的离散级别数量由模拟到数字转换器的分辨率决定。例如，一个 *8位ADC* 有256个级别（2^8），而一个 *12位ADC* 有4096个级别（2^12）。
- en: The quantization process inherently introduces an error, known as **quantization
    error** or **quantization noise**, because the exact analog value is approximated
    to the nearest digital level. We can minimize this error by increasing the resolution
    of the ADC. For example, if an analog signal ranges *from 0 to 3.3V* and an *8-bit
    ADC* is used, the quantization step size is approximately *12.9 mV (3.3V / 256)*.
    An analog input of *1.5V* might be quantized to the closest digital level, which
    could be slightly higher or lower than *1.5V*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 量化过程固有的引入了一个误差，称为**量化误差**或**量化噪声**，因为精确的模拟值被近似到最近的数字级别。我们可以通过增加ADC的分辨率来最小化这个误差。例如，如果一个模拟信号的范围是
    *从0到3.3V*，并且使用了一个 *8位ADC*，那么量化步长大约是 *12.9 mV (3.3V / 256)*。一个 *1.5V* 的模拟输入可能被量化到最接近的数字级别，这可能会略高于或低于
    *1.5V*。
- en: The final step in the process is encoding.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的最终步骤是编码。
- en: Encoding
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码
- en: '**Encoding** is the final step and is where the quantized levels are converted
    into a binary code that can be processed by the digital system. Each quantized
    level is represented by a unique binary value.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**是最终步骤，是将量化级别转换为数字系统能够处理的二进制码。每个量化级别由一个唯一的二进制值表示。'
- en: The number of bits used in the ADC determines the binary code length. For example,
    a *10-bit* ADC will produce a *10-bit* binary number for each sampled value. Continuing
    with our previous example, if the quantized level for *1.5V* is determined to
    be level *116*, the binary representation would be *01110100* for an *8-bit* ADC.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ADC中使用的位数决定了二进制码的长度。例如，一个 *10位* ADC将为每个采样值生成一个 *10位* 二进制数。继续我们之前的例子，如果 *1.5V*
    的量化级别被确定为 *116* 级别，对于 *8位* ADC，其二进制表示将是 *01110100*。
- en: '*Figure 11**.2* shows the encoding process of a *6-bit ADC*. The columns in
    the table show the 6-bit binary representation of the quantization levels. For
    a 6-bit ADC, the digital output ranges from `000000` for the lowest quantization
    level to `111111` for the highest. Each binary value corresponds to a specific
    quantization level:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.2* 显示了 *6位模数转换器（ADC）* 的编码过程。表中的列显示了6位二进制表示的量化级别。对于6位ADC，数字输出范围从最低量化级别
    `000000` 到最高量化级别 `111111`。每个二进制值对应一个特定的量化级别：'
- en: '![Figure 11.2: The encoding process](img/B21914_11_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：编码过程](img/B21914_11_2.jpg)'
- en: 'Figure 11.2: The encoding process'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：编码过程
- en: In summary, the analog-to-digital conversion process begins with an analog input
    signal, which can vary continuously over time. This signal could be a voltage
    from a temperature sensor, an audio signal, or any other analog signal. The analog-to-digital
    converter typically includes a sample-and-hold circuit that captures and holds
    the analog signal at each sampling interval. This ensures that the signal remains
    constant during the conversion process. The core of the ADC performs quantization
    and encoding. It compares the held analog value to a set of reference voltages
    to determine the closest matching digital level. The resulting digital code is
    output from the ADC and can be read by our microcontroller or digital system for
    further processing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，模拟到数字转换过程始于一个模拟输入信号，该信号随时间连续变化。这个信号可能是一个温度传感器的电压、音频信号或任何其他模拟信号。模数转换器通常包括一个采样保持电路，在每个采样间隔捕获并保持模拟信号。这确保信号在转换过程中保持恒定。ADC的核心执行量化和编码。它将保持的模拟值与一组参考电压进行比较，以确定最接近的匹配数字级别。结果数字码从ADC输出，可以被我们的微控制器或数字系统读取以进行进一步处理。
- en: In the next section, we will explain some of the key terms that were used in
    this section, including resolution and **reference** **voltage** (**VREF**).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释本节中使用的一些关键术语，包括分辨率和**参考电压**（**VREF**）。
- en: Key specifications of the ADC – resolution, step size, and VREF
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC的关键规格 – 分辨率、步长和VREF
- en: To effectively use ADCs, it’s important to understand their key specifications,
    which define their performance for various applications. Let’s start with resolution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用ADC，了解它们的关键规格非常重要，这些规格定义了它们在各种应用中的性能。让我们从分辨率开始。
- en: Resolution
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分辨率
- en: The resolution of an ADC determines the number of distinct output levels it
    can produce, corresponding to the number of intervals the input voltage range
    is divided into. It is typically expressed in bits. Higher resolution allows us
    to have a more precise representation of the analog input signal, reducing quantization
    error and improving the accuracy of measurements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ADC的分辨率决定了它可以产生的不同输出级别的数量，对应于输入电压范围被分成的间隔数量。它通常以比特为单位表示。更高的分辨率允许我们更精确地表示模拟输入信号，减少量化误差并提高测量的准确性。
- en: For an *N-bit* ADC, the number of discrete output levels is *2N*. For example,
    an *8-bit* ADC has *256(28)* levels, while a *12-bit* ADC has *4,096* levels.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个*N位* ADC，离散输出级别的数量是*2N*。例如，一个*8位* ADC有*256(2^8)*个级别，而一个*12位* ADC有*4,096*个级别。
- en: '*Table 11.1* shows common ADC resolutions and their corresponding number of
    discrete levels. The following table highlights how the number of discrete levels
    increases exponentially with the resolution, providing finer granularity in the
    digital representation of the analog input signal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*表11.1* 展示了常见的ADC分辨率及其对应的离散级别数量。以下表格突出了随着分辨率的增加，离散级别数量呈指数增长，从而在模拟输入信号的数字表示中提供更细的粒度：'
- en: '| **ADC** **Resolution (bits)** | **Number of Discrete** **Levels (2^N)** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **ADC** **分辨率（比特）** | **离散** **级别数量（2^N）** |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 8 | 256 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 |'
- en: '| 10 | 1,024 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1,024 |'
- en: '| 12 | 4,096 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4,096 |'
- en: '| 14 | 16,384 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 16,384 |'
- en: '| 16 | 65,536 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 |'
- en: '| 18 | 262,144 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 262,144 |'
- en: '| 20 | 1,048,576 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1,048,576 |'
- en: '| 24 | 16,777,216 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 16,777,216 |'
- en: 'Table 11.1: Common ADC resolutions'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1：常见的ADC分辨率
- en: The next key specification is the **VREF**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键规格是**VREF**。
- en: VREF
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VREF
- en: The VREF is the maximum voltage that our ADC can convert. The analog input voltage
    is compared to this VREF to produce a digital value. The stability and accuracy
    of the VREF directly impact the accuracy of the ADC as any fluctuations in the
    VREF can cause corresponding errors in the digital output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: VREF是我们ADC可以转换的最大电压。模拟输入电压与这个VREF进行比较，以产生一个数字值。VREF的稳定性和精度直接影响ADC的准确性，因为VREF的任何波动都可能导致数字输出中的相应误差。
- en: We can choose to derive the VREF from the microcontroller or provide an external
    one for more precise applications. Internal references are convenient but might
    have higher variability, while external references can offer better stability
    and accuracy. The choice of VREF depends on our application’s accuracy requirements
    and the nature of the analog signal being measured.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择从微控制器中提取VREF，或者为更精确的应用提供外部VREF。内部参考方便，但可能具有更高的可变性，而外部参考可以提供更好的稳定性和精度。VREF的选择取决于我们应用的精度要求和被测量的模拟信号的特性。
- en: For example, if the VREF is 5V, the ADC can accurately convert any analog input
    signal within the range of 0V to 5V.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果VREF是5V，ADC可以准确地转换0V到5V范围内的任何模拟输入信号。
- en: The last specification we’ll examine is the step size.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个是步长。
- en: Step size
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步长
- en: The step size is the smallest change in analog input that can be distinguished
    by the ADC. It is determined by the VRED and the resolution and it determines
    the granularity of the ADC’s output. A smaller step size indicates finer resolution,
    allowing the ADC to detect smaller changes in the input signal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 步长是ADC可以区分的最小模拟输入变化。它由VRED和分辨率决定，并决定了ADC输出的粒度。较小的步长表示更细的分辨率，允许ADC检测输入信号中的更小变化。
- en: 'The step size is calculated by *dividing the VREF by 2 raised to the power
    of the ADC’s resolution* (number of bits):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 步长是通过将VREF除以2的ADC分辨率次幂（位数）来计算的：
- en: '![<math  display="block"><mrow><mrow><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>V</mi><mi>R</mi><mi>E</mi><mi>F</mi></mrow><msup><mn>2</mn><mi
    mathvariant="normal">N</mi></msup></mfrac></mrow></mrow></math>](img/4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![<math display="block"><mrow><mrow><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>V</mi><mi>R</mi><mi>E</mi><mi>F</mi></mrow><msup><mn>2</mn><mi
    mathvariant="normal">N</mi></msup></mfrac></mrow></mrow></math>](img/4.png)'
- en: Here, *VREF* is the reference voltage and *N* is the resolution bits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*VREF*是参考电压，*N*是分辨率位数。
- en: 'For example, for a 10-bit ADC with VREF = 3.3V:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于一个VREF = 3.3V的10位ADC：
- en: '![<math  display="block"><mrow><mrow><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mn>3.3</mn><mi>V</mi></mrow><msup><mn>2</mn><mn>10</mn></msup></mfrac><mo>=</mo><mfrac><mrow><mn>3.3</mn><mi>V</mi></mrow><mn>1024</mn></mfrac><mo>=</mo><mn>3.22</mn><mi>m</mi><mi>V</mi></mrow></mrow></math>](img/5.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![<math display="block"><mrow><mrow><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mn>3.3</mn><mi>V</mi></mrow><msup><mn>2</mn><mn>10</mn></msup></mfrac><mo>=</mo><mfrac><mrow><mn>3.3</mn><mi>V</mi></mrow><mn>1024</mn></mfrac><mo>=</mo><mn>3.22</mn><mi>m</mi><mi>V</mi></mrow></mrow></math>](img/5.png)'
- en: 'This means that each increment in the quantized digital output corresponds
    to a *3.22mV* change in the analog input. *Table 11.2* lists common ADC resolutions,
    the corresponding number of steps, and the step size using a VREF of 3.3V:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着量化数字输出的每次增加对应于模拟输入中*3.22mV*的变化。*表11.2*列出了常见的ADC分辨率、相应的步数和步长，使用3.3V的VREF：
- en: '| **ADC** **Resolution (Bits)** | **Number of** **Steps (2^N)** | **Step**
    **Size (mV)** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **ADC** **分辨率（位）** | **步数（2^N）** | **步长（mV）** |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8 | 256 | 12.9 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 | 12.9 |'
- en: '| 10 | 1,024 | 3.22 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1,024 | 3.22 |'
- en: '| 12 | 4,096 | 0.805 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4,096 | 0.805 |'
- en: '| 14 | 16,384 | 0.201 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 16,384 | 0.201 |'
- en: '| 16 | 65,536 | 0.0504 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 | 0.0504 |'
- en: '| 18 | 262,144 | 0.0126 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 262,144 | 0.0126 |'
- en: '| 20 | 1,048,576 | 0.0032 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1,048,576 | 0.0032 |'
- en: '| 24 | 16,777,216 | 0.000197 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 16,777,216 | 0.000197 |'
- en: 'Table 11.2: ADC resolutions and step sizes at 3.3V VREF'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2：3.3V VREF下的ADC分辨率和步长
- en: This table provides a clear view of how the step size decreases with increasing
    resolution, allowing for finer granularity in the digital representation of the
    analog input.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此表清晰地展示了随着分辨率的增加，步长如何减小，从而允许在模拟输入的数字表示中具有更细的粒度。
- en: This concludes our overview of the analog-to-digital conversion process. In
    the next section, we will examine the ADC peripheral of our STM32 microcontroller.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对模拟-数字转换过程的概述。在下一节中，我们将检查我们的STM32微控制器的ADC外设。
- en: The STM32F4 ADC peripheral
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32F4 ADC外设
- en: Our STM32F411 microcontroller features a 12-bit ADC capable of measuring signals
    from up to *19 multiplexed channels*. The ADC can operate in various modes, such
    as single, continuous, scan, or discontinuous, with the results stored in *a 16-bit
    data register*. Additionally, the ADC has an analog watchdog feature that allows
    the system to detect when the input voltage exceeds predefined thresholds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的STM32F411微控制器配备了一个12位ADC，能够测量多达*19个多路复用通道*的信号。ADC可以在各种模式下运行，如单次、连续、扫描或不连续，结果存储在*一个16位数据寄存器*中。此外，ADC还具有模拟看门狗功能，允许系统检测输入电压是否超过预定义的阈值。
- en: Before we explain the various ADC modes, let’s understand what we mean by ADC
    channels.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释各种ADC模式之前，让我们先了解我们所说的ADC通道是什么意思。
- en: The ADC channels
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC通道
- en: An **ADC channel** is a dedicated pathway through which an analog signal is
    fed into the ADC so that it can be converted into a digital value. Each ADC channel
    corresponds to a specific GPIO pin configured to operate in analog mode.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**ADC通道**是一个专用路径，通过该路径将模拟信号输入到ADC中，以便将其转换为数字值。每个ADC通道对应一个配置为模拟模式的特定GPIO引脚。'
- en: Sensors, which produce analog signals representing physical phenomena (such
    as temperature, light, or pressure), are interfaced with our microcontroller through
    these GPIO pins. By configuring a GPIO pin as an analog input, the microcontroller
    can receive the sensor’s analog output signal on the corresponding ADC channel.
    The ADC then converts this continuous analog signal into a discrete digital representation
    that the microcontroller can process, analyze, and use for further decision-making
    tasks in our embedded systems applications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器，产生代表物理现象（如温度、光或压力）的模拟信号，通过这些GPIO引脚与我们的微控制器接口。通过将GPIO引脚配置为模拟输入，微控制器可以在相应的ADC通道上接收传感器的模拟输出信号。然后ADC将这个连续的模拟信号转换为微控制器可以处理、分析和用于我们嵌入式系统应用中进一步决策任务的离散数字表示。
- en: You might be wondering, does having 19 channels mean we have 19 separate ADC
    modules? This is where multiplexing comes into play.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，19个通道是否意味着我们有19个独立的ADC模块？这正是多路复用发挥作用的地方。
- en: Multiplexing ADC channels
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多路复用ADC通道
- en: '**Multiplexing** allows the ADC to switch between different input signals,
    sampling each one sequentially. This is achieved using an analog multiplexer (MUX)
    within the ADC peripheral. As we learned earlier, each of the ADC channels is
    connected to a specific GPIO pin configured for analog input. The analog MUX selects
    which analog input signal (from the GPIO pins or internal sources) is connected
    to the ADC’s sampling circuitry at any given time. This selection is controlled
    by the ADC’s configuration registers.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**多路复用**允许ADC在不同的输入信号之间切换，依次采样每个信号。这是通过ADC外围中的模拟多路复用器（MUX）实现的。正如我们之前所学的，每个ADC通道都连接到一个配置为模拟输入的特定GPIO引脚。模拟MUX选择哪个模拟输入信号（来自GPIO引脚或内部源）连接到ADC的采样电路，在任何给定时间。这种选择由ADC的配置寄存器控制。'
- en: '*Figure 11**.3* shows the ADC channels’ connection to the analog multiplexor
    within the ADC peripheral block:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.3*显示了ADC通道与ADC外围块内模拟多路复用器的连接：'
- en: '![Figure 11.3: ADC channel multiplexing](img/B21914_11_3.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：ADC通道多路复用](img/B21914_11_3.jpg)'
- en: 'Figure 11.3: ADC channel multiplexing'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：ADC通道多路复用
- en: Now, let’s examine the available ADC modes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查可用的ADC模式。
- en: The ADC modes
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ADC模式
- en: The ADC in our STM32F411 microcontroller can operate in several modes, each
    tailored to specific application requirements. The primary modes of operation
    include single conversion mode, continuous conversion mode, scan mode, discontinuous
    mode, and injected conversion mode.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的STM32F411微控制器中，ADC可以在几种模式下运行，每种模式都针对特定的应用需求进行了定制。主要的工作模式包括单次转换模式、连续转换模式、扫描模式、不连续模式和注入转换模式。
- en: 'Let’s break them down:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析：
- en: '`0` in the `ADC_CR2` register.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_CR2`寄存器中的`0`。'
- en: '*Example use case*: Reading the value from a temperature sensor at specific
    intervals.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例用例*：在特定间隔读取温度传感器的值。'
- en: '`1` in the `ADC_CR2` register.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_CR2`寄存器中的`1`。'
- en: '*Example Use Case*: Continuously monitoring a potentiometer to track its position
    in real time.'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例用例*：持续监测电位计以实时跟踪其位置。'
- en: '`ADC_CR1` register and then configuring the sequence of channels in the `ADC_SQRx`
    registers. If the `ADC_CR2`, the sequence restarts after the last channel is converted.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`ADC_CR1`寄存器并配置`ADC_SQRx`寄存器中的通道序列，然后通过设置`ADC_CR2`寄存器或通过外部触发来启动转换。如果`ADC_CR2`，则在最后一个通道转换后，序列将重新开始。
- en: '*Example use case*: Sampling multiple sensor inputs in a data acquisition system.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例用例*：在数据采集系统中采样多个传感器输入。'
- en: '`ADC_CR1` register and then defining the number of channels to convert in each
    group by setting the `ADC_CR1` register.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先通过设置`ADC_CR1`寄存器来定义每个组中要转换的通道数量。
- en: '*Example use case*: Reducing the sampling rate for a subset of channels in
    a multi-channel system.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例用例*：在多通道系统中降低部分通道的采样率。'
- en: '`ADC_JSQR` register, and then starting the conversion by setting the `ADC_CR2`
    register or via an external trigger.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`ADC_JSQR`寄存器，然后通过设置`ADC_CR2`寄存器或通过外部触发来启动转换。
- en: '*Example use case*: Prioritizing critical cell voltage measurements in a **battery
    management system** (**BMS**) during rapid charging or discharging.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例用例*：在快速充电或放电期间，优先测量**电池管理系统（BMS**）中的关键电池单元电压。'
- en: Before exploring the common ADC registers, let’s understand the two types of
    channels available in the STM32F411 microcontroller.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索常见的ADC寄存器之前，让我们先了解STM32F411微控制器中可用的两种通道类型。
- en: Understanding regular channels versus injected channels in STM32F411 ADC
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解STM32F411 ADC中的常规通道与注入通道
- en: 'In the STM32F411 microcontroller, the ADC offers a versatile approach to handling
    multiple analog inputs through two main types of channels: regular channels and
    injected channels. Regular channels are configured for routine, sequential conversions,
    ideal for periodic data acquisition from sensors where timing is not extremely
    critical. These channels follow a predefined sequence set by the `ADC_SQRx` registers
    and can be triggered by software or external events.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32F411微控制器中，ADC通过两种主要类型的通道（常规通道和注入通道）提供了一种灵活的方法来处理多个模拟输入。常规通道用于常规的、顺序的转换，非常适合从传感器进行周期性数据采集，其中时间不是极其关键。这些通道遵循由`ADC_SQRx`寄存器设置的预定义序列，并且可以由软件或外部事件触发。
- en: In contrast, injected channels, such as those configured in injected conversion
    mode, are designed for *high-priority*, *time-sensitive tasks*, interrupting the
    regular sequence to perform immediate conversions when specific conditions are
    met. This makes injected channels perfect for capturing critical measurements
    with precise timing, such as motor current sensing in control applications. Additionally,
    the ADC includes an *Analog Watchdog feature*, which can monitor both regular
    and injected channels for values that exceed predefined thresholds, generating
    interrupts to handle out-of-range conditions. This dual-channel capability, combined
    with the Analog Watchdog, provides a robust framework for diverse applications,
    from routine environmental monitoring to critical real-time data processing and
    safety monitoring.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，注入通道，如配置在注入转换模式中的通道，是为**高优先级**、**时间敏感**的任务设计的，当满足特定条件时，会中断常规序列以执行即时转换。这使得注入通道非常适合捕获具有精确时间的关键测量，例如在控制应用中的电机电流感应。此外，ADC还包括一个**模拟看门狗功能**，可以监控常规和注入通道的值，如果超出预定义的阈值，将生成中断以处理越界条件。这种双通道能力与模拟看门狗相结合，为各种应用提供了一个强大的框架，从常规的环境监测到关键实时数据处理和安全监控。
- en: In the next section, we will examine the key registers of the ADC peripheral
    and some of the flags associated with the ADC operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查ADC外围的关键寄存器以及与ADC操作相关的某些标志。
- en: The key ADC registers and flags
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键的ADC寄存器和标志
- en: In this section, we will explore the characteristics and functions of some of
    the crucial registers within the ADC peripheral.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨ADC外围中一些关键寄存器的特性和功能。
- en: Let’s start with ADC Control Register 1 (`ADC_CR1`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从ADC控制寄存器1（`ADC_CR1`）开始。
- en: ADC Control Register 1 (ADC_CR1)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC控制寄存器1（ADC_CR1）
- en: This is one of the main control registers that’s used to configure the ADC’s
    operational settings. It provides various configuration options, such as resolution,
    scan mode, discontinuous mode, and interrupt enable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于配置ADC操作设置的几个主要控制寄存器之一。它提供了各种配置选项，例如分辨率、扫描模式、断续模式和中断使能。
- en: 'The following are the key bits in this register:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该寄存器中的关键位：
- en: '**RES[1:0]** (**resolution bits**): These bits set the resolution of the ADC
    (12-bit, 10-bit, 8-bit, or 6-bit)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RES[1:0]**（**分辨率位**）：这些位设置ADC的分辨率（12位、10位、8位或6位）'
- en: '**SCAN** (**scan mode**): Setting this bit enables scan mode, allowing the
    ADC to convert multiple channels in sequence'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCAN**（**扫描模式**）：设置此位启用扫描模式，允许ADC按顺序转换多个通道'
- en: '**DISCEN** (**discontinuous mode**): When set, this bit enables discontinuous
    mode on regular channels'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DISCEN**（**断续模式**）：当设置时，此位在常规通道上启用断续模式'
- en: '**AWDEN** (**Analog Watchdog enable**): This bit enables the Analog Watchdog
    on all regular channels'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWDEN**（**模拟看门狗使能**）：此位使能所有常规通道上的模拟看门狗'
- en: '**EOCIE** (**end of conversion interrupt enable**): When set, this bit allows
    an interrupt to be generated when the EOC flag is set'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EOCIE**（**转换结束中断使能**）：当设置时，此位允许在EOC标志设置时生成中断'
- en: You can find detailed information about this register on page 229 of the STM32F411
    reference manual (RM0383).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在STM32F411参考手册的第229页找到关于此寄存器的详细信息（RM0383）。
- en: Next, we have ADC Control Register 2 (`ADC_CR2`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有ADC控制寄存器2（`ADC_CR2`）。
- en: ADC Control Register 2 (ADC_CR2)
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC控制寄存器2（ADC_CR2）
- en: This is another crucial control register that handles different aspects of ADC
    operation, including the start of conversion, data alignment, and external triggers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个处理ADC操作不同方面的关键控制寄存器，包括转换开始、数据对齐和外部触发。
- en: 'Here are the key bits in this register:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该寄存器中的关键位：
- en: '**ADON** (**ADC on**): This bit turns the ADC on or off'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADON**（**ADC开启**）：此位控制ADC的开启或关闭'
- en: '**CONT** (**continuous conversion**): Setting this bit enables continuous conversion
    mode'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CONT**（**连续转换**）：设置此位启用连续转换模式'
- en: '**SWSTART** (**start conversion of regular channels**): Setting this bit starts
    the conversion of regular channels'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SWSTART**（**启动常规通道转换**）：设置此位开始常规通道的转换'
- en: '**ALIGN** (**data alignment**): This bit sets the alignment of the converted
    data (right or left)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALIGN**（**数据对齐**）：此位设置转换数据的对齐方式（右对齐或左对齐）'
- en: '**EXTEN[1:0]**: This is an external trigger that enables polarity selection
    for regular channels'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXTEN[1:0]**：这是一个外部触发器，用于为常规通道选择极性'
- en: Further information about this register can be found on page 231 of the reference
    manual.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此寄存器的更多信息可以在参考手册的第231页找到。
- en: Let’s move on to the ADC Regular Sequence Register (`ADC_SQRx`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 ADC 常规序列寄存器 (`ADC_SQRx`).
- en: ADC Regular Sequence Register (ADC_SQRx)
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC 常规序列寄存器 (ADC_SQRx)
- en: The `ADC_SQRx` registers define the sequence in which the ADC converts the channels.
    There are multiple SQR registers to handle the sequence for up to 16 regular channels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADC_SQRx` 寄存器定义了 ADC 转换通道的顺序。有多个 SQR 寄存器来处理多达 16 个常规通道的序列。'
- en: 'Here are the key bits in this register:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个寄存器中的关键位：
- en: '**L[3:0]**: Regular channel sequence length. These bits set the total number
    of conversions in the regular sequence.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L[3:0]**：常规通道序列长度。这些位设置常规序列中的转换总数。'
- en: '**SQ1-SQ16**: Regular channel sequence. These bits specify the order of the
    channels to be converted.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQ1-SQ16**：常规通道序列。这些位指定要转换的通道的顺序。'
- en: You can read more about this register on page 235 of the reference. The next
    crucial register is the ADC Data Register (`ADC_DR`)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在参考资料的 235 页上了解更多关于此寄存器的信息。下一个关键的寄存器是 ADC 数据寄存器 (`ADC_DR`)
- en: ADC Data Register (ADC_DR)
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC 数据寄存器 (ADC_DR)
- en: The `ADC_DR` register holds the result of the conversion. This is where the
    digital representation of the analog input is stored after the conversion is complete.
    The register is read-only and the data is stored in the lower 16 bits of the register.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADC_DR` 寄存器保存转换的结果。这是在转换完成后存储模拟输入数字表示的地方。该寄存器是只读的，数据存储在寄存器的低 16 位中。'
- en: The final register we will examine is the ADC Status Register (`ADC_SR`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个寄存器是 ADC 状态寄存器 (`ADC_SR`)。
- en: ADC Status Register (ADC_SR)
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC 状态寄存器 (ADC_SR)
- en: This register holds various status flags that indicate the state of the ADC.
    These flags are essential for monitoring the ADC’s operation and handling interrupts.
    We’ll examine these flags in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此寄存器包含各种状态标志，指示 ADC 的状态。这些标志对于监控 ADC 的操作和处理中断至关重要。我们将在下一节中检查这些标志。
- en: The key ADC flags
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键 ADC 标志
- en: ADC flags are status indicators that inform the system about the state of the
    ADC operations. These flags are essential for monitoring the ADC’s progress, handling
    interrupts, and managing errors.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ADC 标志是状态指示器，它们通知系统关于 ADC 操作的状态。这些标志对于监控 ADC 的进度、处理中断和管理错误至关重要。
- en: 'The key ADC flags in the STM32F411 are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F411 中的关键 ADC 标志如下：
- en: '`ADC_SR` register at bit position 1 (EOC) and is set by hardware when a regular
    conversion finishes.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_SR` 寄存器位于位位置 1 (EOC) 并由硬件在常规转换完成后设置。'
- en: If the `ADC_CR1` register is set, the EOC flag can trigger an interrupt. In
    this case, an interrupt service routine can be triggered to process the converted
    data.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `ADC_CR1` 寄存器被设置，EOC 标志可以触发中断。在这种情况下，可以触发一个中断服务例程来处理转换后的数据。
- en: '`ADC_SR` register at bit position 2 (`ADC_CR1` register.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_SR` 寄存器位于位位置 2 (`ADC_CR1` 寄存器).'
- en: '`ADC_SR` register at bit position 0 (`ADC_CR1` register.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_SR` 寄存器位于位位置 0 (`ADC_CR1` 寄存器).'
- en: '`ADC_SR` register at bit position 5 (`ADC_CR1` register.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_SR` 寄存器位于位位置 5 (`ADC_CR1` 寄存器).'
- en: '**Start conversion (STRT) flag**: The **STRT** flag indicates that an ADC conversion
    has started. We can use this flag to verify that the ADC has initiated a conversion
    process.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始转换 (STRT) 标志**：**STRT** 标志表示 ADC 转换已经开始。我们可以使用这个标志来验证 ADC 是否已启动转换过程。'
- en: Understanding and effectively using ADC flags is crucial for managing ADC operations
    in our STM32 microcontroller. Flags such as EOC, JEOC, AWD, OVR, and STRT provide
    essential information about the status of conversions, data integrity, and threshold
    monitoring. By leveraging these flags, we can enhance the reliability and functionality
    of our ADC implementations, ensuring accurate and timely data acquisition and
    processing in our embedded systems projects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并有效地使用 ADC 标志对于管理我们 STM32 微控制器中的 ADC 操作至关重要。如 EOC、JEOC、AWD、OVR 和 STRT 等标志提供了关于转换状态、数据完整性和阈值监控的基本信息。通过利用这些标志，我们可以增强我们
    ADC 实现的可靠性和功能性，确保在嵌入式系统项目中准确及时地获取和处理数据。
- en: In the next section, we will apply the information we’ve learned to develop
    an ADC driver for reading analog sensor values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将应用我们所学到的信息来开发一个用于读取模拟传感器值的 ADC 驱动程序。
- en: Developing the ADC driver
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 ADC 驱动程序
- en: In this section, we will apply everything we have learned about the ADC peripheral
    to develop a driver for reading sensor values from a sensor connected to one of
    the ADC channels.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用我们关于 ADC 外设所学的所有知识来开发一个用于从连接到 ADC 通道之一的传感器读取传感器值的驱动程序。
- en: Identifying the GPIO pins for the ADC
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别 ADC 的 GPIO 引脚
- en: 'Let’s begin by identifying the GPIO pins connected to the ADC channels. To
    do this, refer to the table on *page 39* of the *STM32F411RE datasheet*. This
    table lists all the GPIO pins of the microcontroller, along with their descriptions
    and additional functionalities. As shown in *Figure 11**.4*, part of this table
    reveals that `ADC1_IN1`. This indicates that **PA1** is connected to ADC1, **channel
    1**:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先识别连接到 ADC 通道的 GPIO 引脚。为此，请参考 *STM32F411RE 数据手册* 的 *第 39 页* 中的表格。该表格列出了微控制器的所有
    GPIO 引脚，以及它们的描述和附加功能。如图 *图 11**.4 所示，该表格的一部分揭示了 `ADC1_IN1`。这表明 **PA1** 连接到 ADC1，**通道
    1**：
- en: '![Figure 11.4: Pin definitions](img/B21914_11_4.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：引脚定义](img/B21914_11_4.jpg)'
- en: 'Figure 11.4: Pin definitions'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：引脚定义
- en: Let’s configure **PA1** so that it functions as an ADC pin.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置 **PA1** 以使其作为 ADC 引脚工作。
- en: First, create a copy of your previous project in your IDE, following the steps
    outlined in earlier chapters. Rename this copied project to `ADC`. Next, create
    a new file named `adc.c` in the `Src` folder and another file named `adc.h` in
    the `Inc` folder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的 IDE 中创建你之前项目的副本，按照前面章节中概述的步骤进行。将这个复制的项目重命名为 `ADC`。接下来，在 `Src` 文件夹中创建一个名为
    `adc.c` 的新文件，并在 `Inc` 文件夹中创建一个名为 `adc.h` 的新文件。
- en: 'Populate your `adc.c` file with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `adc.c` 文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down the source code, starting with the macro definitions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解源代码，从宏定义开始：
- en: '[PRE1]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s break down the macros:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这些宏：
- en: '`GPIOAEN`: This macro enables the clock for GPIOA by setting bit 0 in the `AHB1ENR`
    register'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOAEN`：这个宏通过在 `AHB1ENR` 寄存器中设置第 0 位来启用 GPIOA 的时钟'
- en: '`ADC1EN`: This enables the clock for ADC1 by setting bit 8 in the `APB2ENR`
    register'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC1EN`：通过在 `APB2ENR` 寄存器中设置第 8 位来启用 ADC1 的时钟'
- en: '`ADC_CH1`: This selects channel 1 for the ADC conversion in the `SQR3` register'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_CH1`：在 `SQR3` 寄存器中为 ADC 转换选择通道 1'
- en: '`ADC_SEQ_LEN_1`: This sets the conversion sequence length to 1 in the `SQR1`
    register'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_SEQ_LEN_1`：在 `SQR1` 寄存器中将转换序列长度设置为 1'
- en: '`CR2_ADCON`: This enables the ADC module by setting bit 0 in the `CR2` register'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR2_ADCON`：通过在 `CR2` 寄存器中设置第 0 位来启用 ADC 模块'
- en: '`CR2_CONT`: This enables continuous conversion mode by setting bit 1 in the
    `CR2` register'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR2_CONT`：通过在 `CR2` 寄存器中设置第 1 位来启用连续转换模式'
- en: '`CR2_SWSTART`: This starts the ADC conversion by setting bit 30 in the `CR2`
    register'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR2_SWSTART`：通过在 `CR2` 寄存器中设置第 30 位来启动 ADC 转换'
- en: '`SR_EOC`: This macro waits for the end of conversion by reading bit 1 in the
    **status** **register** (**SR**)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SR_EOC`：这个宏通过读取 **状态** **寄存器**（**SR**）中的第 1 位来等待转换结束'
- en: 'Next, we must analyze the configuration sequence of the GPIO pin that’s used
    for ADC functionality:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须分析用于 ADC 功能的 GPIO 引脚的配置序列：
- en: '[PRE2]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This line enables the clock for `GPIOA` by setting the appropriate bit in the
    `AHB1ENR` register using the **GPIOAEN** macro:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在 `AHB1ENR` 寄存器中设置适当的位来启用 `GPIOA` 的时钟，使用 **GPIOAEN** 宏：
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines configure `GPIOA_MODER` register.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行配置 `GPIOA_MODER` 寄存器。
- en: 'Let’s move on to the part of the code that configures the ADC parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到配置 ADC 参数的代码部分：
- en: '[PRE4]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This line enables the clock for ADC1 by setting the appropriate bit in the `APB2ENR`
    register using the **ADC1EN** macro.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在 `APB2ENR` 寄存器中设置适当的位来启用 ADC1 的时钟，使用 **ADC1EN** 宏。
- en: '[PRE5]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This line sets channel 1 as the start of the conversion sequence in the `ADC_SQR3`
    register using the **ADC_CH1** macro:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用 **ADC_CH1** 宏在 `ADC_SQR3` 寄存器中将通道 1 设置为转换序列的开始：
- en: '[PRE6]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This line sets the sequence length to 1 in the `ADC_SQR1` register using the
    **ADC_SEQ_LEN_1** macro, meaning only one channel will be converted:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用 **ADC_SEQ_LEN_1** 宏在 `ADC_SQR1` 寄存器中将序列长度设置为 1，这意味着只有一个通道将被转换：
- en: '[PRE7]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line enables the ADC module by setting the `ADC_CR2` register.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过设置 `ADC_CR2` 寄存器来启用 ADC 模块。
- en: 'Next, we can start the conversion:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始转换：
- en: '[PRE8]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This line enables continuous conversion mode by setting the `ADC_CR2` register
    using the **CR2_CONT** macro:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过使用 **CR2_CONT** 宏设置 `ADC_CR2` 寄存器来启用连续转换模式：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line starts the ADC conversion by setting the `ADC_CR2` register using
    the **CR2_SWSTART** macro.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过使用 **CR2_SWSTART** 宏设置 `ADC_CR2` 寄存器来启动 ADC 转换：
- en: 'Next, we must wait for the results to be ready:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须等待结果准备好：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This line waits until the conversion is complete by checking the `ADC_SR` register:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过检查 `ADC_SR` 寄存器来等待转换完成：
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line reads the converted digital value from the `ADC_DR` register.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码从 `ADC_DR` 寄存器读取转换后的数字值。
- en: 'In summary, our code performs the following actions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的代码执行以下操作：
- en: '**Initializes the ADC** **GPIO pin**:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化ADC** **GPIO引脚**:'
- en: Enables the clock for GPIOA
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用GPIOA的时钟
- en: Sets PA1 to analog mode
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将PA1设置为模拟模式
- en: '**Configures the** **ADC module**:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置ADC模块**:'
- en: Enables the clock for ADC1
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用ADC1的时钟
- en: Sets channel 1 as the start of the conversion sequence
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将通道1设置为转换序列的起始
- en: Sets the conversion sequence’s length to 1
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将转换序列的长度设置为1
- en: Enables the ADC module
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用ADC模块
- en: '**Starts the ADC** **conversion process**:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始ADC** **转换过程**:'
- en: Enables continuous conversion mode
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用连续转换模式
- en: Starts the ADC conversion process
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始ADC转换过程
- en: '**Reads the** **ADC value**:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**读取ADC** **值**:'
- en: Waits for the conversion to complete
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待转换完成
- en: Reads the converted value from the ADC data register
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ADC数据寄存器读取转换后的值
- en: 'Our next task is to populate the `adc.h` file. Here’s the code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是填充`adc.h`文件。以下是代码：
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#include <stdio.h>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include "adc.h"'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "adc.h"'
- en: '#include "uart.h"'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: int sensor_value;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: int sensor_value;
- en: int main(void)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Initialize debug UART*/
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: /* 初始化调试串口 */
- en: uart_init();
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: uart_init();
- en: /*Initialize ADC*/
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: /* 初始化ADC */
- en: pa1_adc_init();
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: pa1_adc_init();
- en: /*Start conversion*/
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: /* 开始转换 */
- en: start_conversion();
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: start_conversion();
- en: while(1)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: sensor_value = adc_read();
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: sensor_value = adc_read();
- en: 'printf("Sensor Value: %d\r\n",sensor_value);'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'printf("传感器值: %d\r\n",sensor_value);'
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#include <stdio.h>'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include "adc.h"'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include "adc.h"'
- en: '#include "uart.h"'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: '[PRE14]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: int sensor_value;
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: int sensor_value;
- en: '[PRE15]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: /* Initialize debug UART */
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /* 初始化调试串口 */
- en: uart_init();
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: uart_init();
- en: '[PRE16]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: /* Initialize ADC */
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /* 初始化ADC */
- en: pa1_adc_init();
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pa1_adc_init();
- en: '[PRE17]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: /* Start conversion */
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /* 开始转换 */
- en: start_conversion();
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: start_conversion();
- en: '[PRE18]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: sensor_value = adc_read();
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sensor_value = adc_read();
- en: 'printf("Sensor Value: %d\r\n", sensor_value);'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'printf("传感器值: %d\r\n", sensor_value);'
- en: '[PRE19]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
