["```cpp\n    /* auto.cpp */\n\n    #include <iostream>\n    #include <typeinfo>\n\n    int main()\n    {\n      std::cout << \"[auto.cpp]\" << std::endl;\n\n      // Creating several auto-type variables\n      auto a = 1;\n      auto b = 1.0;\n      auto c = a + b;\n      auto d = {b, c};\n\n      // Displaying the preceding variables' type\n      std::cout << \"type of a: \" << typeid(a).name() << std::endl;\n      std::cout << \"type of b: \" << typeid(b).name() << std::endl;\n      std::cout << \"type of c: \" << typeid(c).name() << std::endl;\n      std::cout << \"type of d: \" << typeid(d).name() << std::endl;\n      return 0;\n    }\n\n```", "```cpp\n    int add(int i, int j)\n    {\n      return i + j;\n    }\n\n```", "```cpp\n    auto add(int i, int j)\n    {\n      return i + j;\n    }\n\n```", "```cpp\n    auto add(int i, int j) -> int\n    {\n      return i + j;\n    }\n\n```", "```cpp\n    int main()\n    {\n      // The body of the function\n    }\n\n```", "```cpp\n    auto main -> int\n    {\n      // The body of the function\n    }\n\n```", "```cpp\n    const int func1();\n    const int& func2();\n    int i;\n\n    struct X { double d; };\n    const X* x = new X();\n\n```", "```cpp\n    // Declaring const int variable\n    // using func1() type\n    decltype(func1()) f1;\n\n    // Declaring const int& variable\n    // using func2() type\n    decltype(func2()) f2;\n\n    // Declaring int variable\n    // using i type\n    decltype(i) i1;\n\n    // Declaring double variable\n    // using struct X type\n    decltype(x->d) d1; // type is double\n    decltype((x->d)) d2; // type is const double&\n\n```", "```cpp\n    template<typename I, typename J, typename K>\n    K add(I i, J j)\n    {\n      return i + j;\n    }\n\n```", "```cpp\n    template<typename I, typename J>\n    auto add(I i, J j) -> decltype(i + j)\n    {\n      return i + j;\n    }\n\n```", "```cpp\n    /* decltype.cpp */\n    #include <iostream>\n\n    // Creating template\n    template<typename I, typename J>\n    auto add(I i, J j) -> decltype(i + j)\n    {\n      return i + j;\n    }\n\n    auto main() -> int\n    {\n      std::cout << \"[decltype.cpp]\" << std::endl;\n\n      // Consuming the template\n      auto d = add<int, double>(2, 2.5);\n\n      // Displaying the preceding variables' type\n      std::cout << \"result of 2 + 2.5: \" << d << std::endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    void funct(const char *);\n    void funct(int)\n\n```", "```cpp\n    funct(NULL);\n\n```", "```cpp\n    funct(nullptr);\n\n```", "```cpp\n    int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n```", "```cpp\n    for (unsigned int i = 0; i < sizeof(arr)/sizeof(arr[0]); ++i)\n    // Do something to the array\n\n```", "```cpp\n    for (auto i = std::begin(arr); i != std::end(arr); ++i)\n    // Do something to the array\n\n```", "```cpp\n    /* begin_end.cpp */\n    #include <iostream>\n\n    auto main() -> int\n    {\n      std::cout << \"[begin_end.cpp]\" << std::endl;\n\n      // Declaring an array\n      int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n      // Displaying the array elements\n      // using conventional for-loop\n      std::cout << \"Displaying array element using conventional for-\n       loop\";\n      std::cout << std::endl;\n      for (unsigned int i = 0; i < sizeof(arr)/sizeof(arr[0]); ++i)\n      std::cout << arr[i] << \" \";\n      std::cout << std::endl;\n\n      // Displaying the array elements\n      // using non-member begin() and end()\n      std::cout << \"Displaying array element using non-member begin()\n       and end()\";\n      std::cout << std::endl;\n      for (auto i = std::begin(arr); i != std::end(arr); ++i)\n       std::cout << *i << \" \";\n      std::cout << std::endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    for (auto a : arr)\n    // Do something with a\n\n```", "```cpp\n    /* range_based_for_loop.cpp */\n    #include <iostream>\n\n    auto main() -> int\n    {\n      std::cout << \"[range_based_for_loop.cpp]\" << std::endl;\n\n      // Declaring an array\n      int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n      // Displaying the array elements\n      // using non-member begin() and end()\n      std::cout << \"Displaying array element using range-based for\n        loop\";\n      std::cout << std::endl;\n      for (auto a : arr) std::cout << a << \" \";\n      std::cout << std::endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* array.cpp */\n    #include <array>\n    #include <iostream>\n\n    auto main() -> int\n    {\n      std::cout << \"[array.cpp]\" << std::endl;\n\n      // Initializing an array containing five integer elements\n      std::array<int, 10> arr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n      // Displaying the original elements of the array\n      std::cout << \"Original Data : \";\n      for(auto a : arr) std::cout << a << \" \";\n      std::cout << std::endl;\n\n      // Modifying the content of\n      // the 1st and 3rd element of the array\n      arr[1] = 9;\n      arr[3] = 7;\n\n      // Displaying the altered array elements\n      std::cout << \"Manipulated Data: \";\n      for(auto a : arr) std::cout << a << \" \";\n      std::cout << std::endl;\n\n      return 0;\n     }\n\n```", "```cpp\n    /* vector.cpp */\n    #include <vector>\n    #include <iostream>\n\n    auto main() -> int\n    {\n      std::cout << \"[vector.cpp]\" << std::endl;\n\n      // Initializing a vector containing three integer elements\n      std::vector<int> vect = { 0, 1, 2 };\n\n      // Displaying the original elements of the vector\n      std::cout << \"Original Data : \";\n      for (auto v : vect) std::cout << v << \" \";\n      std::cout << std::endl;\n\n      // Adding two new data\n      vect.push_back(3);\n      vect.push_back(4);\n\n      // Displaying the elements of the new vector\n      // and reverse the order\n      std::cout << \"New Data Added : \";\n      for (auto v : vect) std::cout << v << \" \";\n      std::cout << std::endl;\n\n      // Modifying the content of\n      // the 2nd and 4th element of the vector\n      vect.at(2) = 5;\n      vect.at(4) = 6;\n\n      // Displaying the altered array elements\n      std::cout << \"Manipulate Data: \";\n      for (auto v : vect) std::cout << v << \" \";\n      std::cout << std::endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* sort.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n\n    bool comparer(int a, int b)\n    {\n      return (a > b);\n    }\n\n    auto main() -> int\n    {\n      std::cout << \"[sort.cpp]\" << std::endl;\n\n      // Initializing a vector containing several integer elements\n      std::vector<int> vect = { 20, 43, 11, 78, 5, 96 };\n\n      // Displaying the original elements of the vector\n      std::cout << \"Original Data : \";\n      for (auto v : vect)\n      std::cout << v << \" \";\n      std::cout << std::endl;\n\n      // Sorting the vector element ascending\n      std::sort(std::begin(vect), std::end(vect));\n\n      // Displaying the ascending sorted elements\n      // of the vector\n      std::cout << \"Ascending Sorted : \";\n      for (auto v : vect)\n      std::cout << v << \" \";\n      std::cout << std::endl;\n\n      // Sorting the vector element descending\n      // using comparer\n      std::sort(std::begin(vect), std::end(vect), comparer);\n\n      // Displaying the descending sorted elements\n      // of the vector\n      std::cout << \"Descending Sorted: \";\n      for (auto v : vect)\n      std::cout << v << \" \";\n      std::cout << std::endl;\n\n      return 0;\n   }\n\n```", "```cpp\n    /* vehicle.h */\n    #ifndef __VEHICLE_H__\n    #define __VEHICLE_H__\n\n    #include <string>\n\n    class Vehicle\n    {\n      private:\n        std::string vehicleType;\n        int totalOfWheel;\n\n      public:\n        Vehicle(\n          const std::string &type,\n          int _wheel);\n        Vehicle();\n        ~Vehicle();\n        std::string GetType() const {return vehicleType;}\n        int GetNumOfWheel() const {return totalOfWheel;}\n    };\n\n    #endif // End of __VEHICLE_H__\n\n```", "```cpp\n    /* vehicle.cpp */\n    #include \"vehicle.h\"\n\n    using namespace std;\n\n    // Constructor with default value for\n    // m_vehicleType and m_totalOfWheel\n    Vehicle::Vehicle() : m_totalOfWheel(0)\n    {\n    }\n\n    // Constructor with user-defined value for\n    // m_vehicleType and m_totalOfWheel\n    Vehicle::Vehicle( const string &type, int wheel) :\n     m_vehicleType(type),\n     m_totalOfWheel(wheel)\n    {\n    }\n\n    // Destructor\n    Vehicle::~Vehicle()\n    {\n    }\n\n```", "```cpp\n    /* find.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n    #include \"../vehicle/vehicle.h\"\n\n    using namespace std;\n\n    bool TwoWheeled(const Vehicle &vehicle)\n    {\n      return _vehicle.GetNumOfWheel() == 2 ? \n        true : false;\n     }\n\n    auto main() -> int\n    {\n      cout << \"[find.cpp]\" << endl;\n\n      // Initializing several Vehicle instances\n      Vehicle car(\"car\", 4);\n      Vehicle motorcycle(\"motorcycle\", 2);\n      Vehicle bicycle(\"bicycle\", 2);\n      Vehicle bus(\"bus\", 6);\n\n      // Assigning the preceding Vehicle instances to a vector\n      vector<Vehicle> vehicles = { car, motorcycle, bicycle, bus };\n\n      // Displaying the elements of the vector\n      cout << \"All vehicles:\" << endl;;\n      for (auto v : vehicles)\n        std::cout << v.GetType() << endl;\n      cout << endl;\n\n      // Displaying the elements of the vector\n      // which are the two-wheeled vehicles\n      cout << \"Two-wheeled vehicle(s):\" << endl;;\n      auto tw = find_if(\n                      begin(vehicles),\n                      end(vehicles),\n                      TwoWheeled);\n      while (tw != end(vehicles))\n      {\n        cout << tw->GetType() << endl ;\n        tw = find_if(++tw, end(vehicles), TwoWheeled);\n      }\n      cout << endl;\n\n      // Displaying the elements of the vector\n      // which are not the two-wheeled vehicles\n      cout << \"Not the two-wheeled vehicle(s):\" << endl;;\n      auto ntw = find_if_not(begin(vehicles),\n                           end(vehicles),\n                           TwoWheeled);\n      while (ntw != end(vehicles))\n      {\n        cout << ntw->GetType() << endl ;\n        ntw = find_if_not(++ntw, end(vehicles), TwoWheeled);\n      }\n\n      return 0;\n     }\n\n```", "```cpp\n    /* for_each.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n    #include \"vehicle.h\"\n\n    using namespace std;\n\n    void PrintOut(const Vehicle &vehicle)\n    {\n      cout << vehicle.GetType() << endl;\n    }\n\n    auto main() -> int\n   {\n      cout << \"[for_each.cpp]\" << endl;\n\n      // Initializing several Vehicle instances\n      Vehicle car(\"car\", 4);\n      Vehicle motorcycle(\"motorcycle\", 2);\n      Vehicle bicycle(\"bicycle\", 2);\n      Vehicle bus(\"bus\", 6);\n\n      // Assigning the preceding Vehicle instances to a vector\n      vector<Vehicle> vehicles = { car, motorcycle, bicycle, bus };\n\n      // Displaying the elements of the vector\n      cout << \"All vehicles:\" << endl;\n      for_each(begin(vehicles), end(vehicles), PrintOut);\n\n      return 0;\n    }\n\n```", "```cpp\n    [](){} \n\n```", "```cpp\n    /* lambda_tiny_func.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n    #include \"../vehicle/vehicle.h\"\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_tiny_func.cpp]\" << endl;\n\n      // Initializing several Vehicle instances\n      Vehicle car(\"car\", 4);\n      Vehicle motorcycle(\"motorcycle\", 2);\n      Vehicle bicycle(\"bicycle\", 2);\n      Vehicle bus(\"bus\", 6);\n\n      // Assigning the preceding Vehicle instances to a vector\n      vector<Vehicle> vehicles = { car, motorcycle, bicycle, bus };\n\n      // Displaying the elements of the vector\n      // using Lambda expression\n      cout << \"All vehicles:\" << endl;\n      for_each(\n             begin(vehicles),\n             end(vehicles),\n             [](const Vehicle &vehicle){\n                 cout << vehicle.GetType() << endl;\n            });\n\n      return 0;\n    }\n\n```", "```cpp\n    /* lambda_multiline_func.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_multiline_func.cpp]\" << endl;\n\n      // Initializing a vector containing integer element\n      vector<int> vect;\n      for (int i = 0; i < 10; ++i)\n        vect.push_back(i);\n\n      // Displaying whether or not the element is prime number\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n) {\n                cout << n << \" is\";\n                if(n < 2)\n                {\n                  if(n == 0)\n                  cout << \" not\";\n                }\n                else\n                {\n                  for (int j = 2; j < n; ++j)\n                    {\n                       if (n % j == 0)\n                       {\n                         cout << \" not\";\n                         break;\n                       }\n                   }\n                 }\n\n                cout << \" prime number\" << endl;\n            });\n\n        return 0;\n     }\n\n```", "```cpp\n    /* lambda_returning_value.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_returning_value.cpp]\" << endl;\n\n      // Initializing a vector containing integer element\n      vector<int> vect;\n      for (int i = 0; i < 10; ++i)\n        vect.push_back(i);\n\n      // Displaying the elements of vect\n      cout << \"Original Data:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n){\n                cout << n << \" \";\n            });\n      cout << endl;\n\n      // Creating another vect2 vector\n      vector<int> vect2;\n      // Resize the size of vect2 exactly same with vect\n      vect2.resize(vect.size());\n      // Doubling the elements of vect and store to vect2\n      transform(\n              begin(vect),\n              end(vect),\n              begin(vect2),\n              [](int n) {\n                return n * n;\n            });\n\n      // Displaying the elements of vect2\n      cout << \"Squared Data:\" << endl;\n      for_each(\n             begin(vect2),\n             end(vect2),\n             [](int n) {\n                cout << n << \" \";\n            });\n      cout << endl;\n\n      // Creating another vect3 vector\n      vector<double> vect3;\n      // Resize the size of vect3 exactly same with vect\n      vect3.resize(vect.size());\n      // Finding the average of the elements of vect\n      // and store to vect2\n      transform(\n              begin(vect2),\n              end(vect2),\n              begin(vect3),\n              [](int n) -> double {\n                return n / 2.0;\n            });\n\n      // Displaying the elements of vect3\n      cout << \"Average Data:\" << endl;\n      for_each(\n             begin(vect3),\n             end(vect3),\n             [](double d) {\n                cout << d << \" \";\n            });\n      cout << endl;\n\n      return 0;\n     }\n\n```", "```cpp\n    /* lambda_capturing_by_value.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_capturing_by_value.cpp]\" << endl;\n\n      // Initializing a vector containing integer element\n      vector<int> vect;\n      for (int i = 0; i < 10; ++i)\n      vect.push_back(i);\n\n      // Displaying the elements of vect\n      cout << \"Original Data:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n){\n                cout << n << \" \";\n             });\n      cout << endl;\n\n      // Initializing two variables\n      int a = 2;\n      int b = 8;\n\n      // Capturing value explicitly from the two variables\n      cout << \"Printing elements between \" << a;\n      cout << \" and \" << b << \" explicitly [a,b]:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [a,b](int n){\n                if (n >= a && n <= b)\n                cout << n << \" \";\n             });\n      cout << endl;\n\n      // Modifying variable a and b\n      a = 3;\n      b = 7;\n\n      // Capturing value implicitly from the two variables\n      cout << \"printing elements between \" << a;\n      cout << \" and \" << b << \" implicitly[=]:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [=](int n){\n                if (n >= a && n <= b)\n                cout << n << \" \";\n            });\n      cout << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* lambda_capturing_by_value_mutable.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_capturing_by_value_mutable.cpp]\" << endl;\n\n      // Initializing a vector containing integer element\n      vector<int> vect;\n      for (int i = 0; i < 10; ++i)\n        vect.push_back(i);\n\n      // Displaying the elements of vect\n      cout << \"Original Data:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n){\n                 cout << n << \" \";\n            });\n      cout << endl;\n\n      // Initializing two variables\n      int a = 1;\n      int b = 1;\n\n      // Capturing value from the two variables\n      // without mutate them\n      for_each(\n             begin(vect),\n             end(vect),\n             [=](int& x) mutable {\n                 const int old = x;\n                 x *= 2;\n                 a = b;\n                 b = old;\n             });\n\n      // Displaying the elements of vect\n      cout << \"Squared Data:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n) {\n                  cout << n << \" \";\n            });\n      cout << endl << endl;\n\n      // Displaying value of variable a and b\n      cout << \"a = \" << a << endl;\n      cout << \"b = \" << b << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* lambda_capturing_by_reference.cpp */\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_capturing_by_reference.cpp]\" << endl;\n\n      // Initializing a vector containing integer element\n      vector<int> vect;\n      for (int i = 0; i < 10; ++i)\n        vect.push_back(i);\n\n      // Displaying the elements of vect\n      cout << \"Original Data:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n){\n                 cout << n << \" \";\n            });\n      cout << endl;\n\n      // Initializing two variables\n      int a = 1;\n      int b = 1;\n\n      // Capturing value from the two variables\n      // and mutate them\n      for_each(\n             begin(vect),\n             end(vect),\n             [&a, &b](int& x){\n                 const int old = x;\n                 x *= 2;\n                 a = b;\n                 b = old;\n            });\n\n      // Displaying the elements of vect\n      cout << \"Squared Data:\" << endl;\n      for_each(\n             begin(vect),\n             end(vect),\n             [](int n) {\n                 cout << n << \" \";\n            });\n      cout << endl << endl;\n\n      // Displaying value of variable a and b\n      cout << \"a = \" << a << endl;\n      cout << \"b = \" << b << endl;\n\n      return 0;\n     }\n\n```", "```cpp\n    /* lambda_initialization_captures.cpp */\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_initialization_captures.cpp]\" << endl;\n\n      // Initializing a variable\n      int a = 5;\n      cout << \"Initial a = \" << a << endl;\n\n      // Initializing value to lambda using the variable\n      auto myLambda = [&x = a]() { x += 2; };\n\n      // Executing the Lambda\n      myLambda();\n\n      // Displaying a new value of the variable\n      cout << \"New a = \" << a << endl;\n\n      return 0;\n     }\n\n```", "```cpp\n    /* lambda_expression_generic.cpp */\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambda_expression_generic.cpp]\" << endl;\n\n      // Creating a generic lambda expression\n      auto findMax = [](auto &x, auto &y){\n        return x > y ? x : y; };\n\n      // Initializing various variables\n      int i1 = 5, i2 = 3;\n      float f1 = 2.5f, f2 = 2.05f;\n\n      // Consuming generic lambda expression\n      // using integer data type\n      cout << \"i1 = 5, i2 = 3\" << endl;\n      cout << \"Max: \" << findMax(i1, i2) << endl << endl;\n\n      // Consuming generic lambda expression\n      // using double data type\n      cout << \"f1 = 2.5f, f2 = 2.05f\" << endl;\n      cout << \"Max: \" << findMax(f1, f2) << endl << endl;\n\n      return 0;\n     }\n\n```", "```cpp\n    auto up1 = unique_ptr<int>{};\n    auto up2 = unique_ptr<int>{ nullptr };\n    auto up3 = unique_ptr<int>{ new int { 1234 } };\n\n```", "```cpp\n    auto up4 = make_unique<int>(1234);\n\n```", "```cpp\n    /* unique_ptr_1.cpp */\n    #include <memory>\n    #include <iostream>\n\n    using namespace std;\n\n    struct BodyMass\n    {\n      int Id;\n      float Weight;\n\n      BodyMass(int id, float weight) :\n        Id(id),\n        Weight(weight)\n        {\n          cout << \"BodyMass is constructed!\" << endl;\n          cout << \"Id = \" << Id << endl;\n          cout << \"Weight = \" << Weight << endl;\n        }\n\n       ~BodyMass()\n       {\n         cout << \"BodyMass is destructed!\" << endl;\n       }\n     };\n\n     auto main() -> int\n     {\n       cout << \"[unique_ptr_1.cpp]\" << endl;\n       auto myWeight = make_unique<BodyMass>(1, 165.3f);\n       cout << endl << \"Doing something!!!\" << endl << endl;\n       return 0;\n     }\n\n```", "```cpp\n    /* unique_ptr_2.cpp */\n    #include <memory>\n    #include <iostream>\n\n    using namespace std;\n\n    struct BodyMass\n    {\n      int Id;\n      float Weight;\n\n      BodyMass(int id, float weight) :\n        Id(id), \n        Weight(weight)\n        {\n          cout << \"BodyMass is constructed!\" << endl;\n          cout << \"Id = \" << Id << endl;\n          cout << \"Weight = \" << Weight << endl;\n        }\n\n BodyMass(const BodyMass &other) :\n Id(other.Id),\n Weight(other.Weight)\n {\n cout << \"BodyMass is copy constructed!\" << endl;\n cout << \"Id = \" << Id << endl;\n cout << \"Weight = \" << Weight << endl;\n }\n\n      ~BodyMass()\n       {\n          cout << \"BodyMass is destructed!\" << endl;\n       }\n    };\n\n    auto main() -> int\n    {\n      cout << \"[unique_ptr_2.cpp]\" << endl;\n\n      auto myWeight = make_unique<BodyMass>(1, 165.3f);\n\n      // The compiler will forbid to create another pointer\n      // that points to the same allocated memory/object\n      // since it's unique pointer\n      //auto myWeight2 = myWeight;\n\n      // However, we can do the following expression\n      // since it actually copies the object that has been allocated\n      // (not the unique_pointer)\n      auto copyWeight = *myWeight;\n\n      return 0;\n    }\n\n```", "```cpp\n    auto myWeight2 = myWeight;\n\n```", "```cpp\n    auto copyWeight = *myWeight;\n\n```", "```cpp\n    /* unique_ptr_3.cpp */\n    #include <memory>\n    #include <iostream>\n\n    using namespace std;\n\n    struct BodyMass\n    {\n      int Id;\n      float Weight;\n\n      BodyMass(int id, float weight) :\n        Id(id), \n        Weight(weight)\n        {\n          cout << \"BodyMass is constructed!\" << endl;\n          cout << \"Id = \" << Id << endl;\n          cout << \"Weight = \" << Weight << endl;\n        }\n\n      ~BodyMass()\n       {\n         cout << \"BodyMass is destructed!\" << endl;\n       }\n    };\n\n    unique_ptr<BodyMass> GetBodyMass()\n    {\n      return make_unique<BodyMass>(1, 165.3f);\n    }\n\n    unique_ptr<BodyMass> UpdateBodyMass(\n      unique_ptr<BodyMass> bodyMass)\n      {\n        bodyMass->Weight += 1.0f;\n        return bodyMass;\n      }\n\n     auto main() -> int\n     {\n       cout << \"[unique_ptr_3.cpp]\" << endl;\n\n       auto myWeight = GetBodyMass();\n\n       cout << \"Current weight = \" << myWeight->Weight << endl;\n\n       myWeight = UpdateBodyMass(move(myWeight));\n\n       cout << \"Updated weight = \" << myWeight->Weight << endl;\n\n       return 0;\n     }\n\n```", "```cpp\n    /* shared_ptr_1.cpp */\n    #include <memory>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[shared_ptr_1.cpp]\" << endl;\n\n      auto sp1 = shared_ptr<int>{};\n\n      if(sp1)\n         cout << \"sp1 is initialized\" << endl;\n      else\n         cout << \"sp1 is not initialized\" << endl;\n      cout << \"sp1 pointing counter = \" << sp1.use_count() << endl;\n      if(sp1.unique())\n         cout << \"sp1 is unique\" << endl;\n      else\n        cout << \"sp1 is not unique\" << endl;\n      cout << endl;\n\n      sp1 = make_shared<int>(1234);\n\n      if(sp1)\n        cout << \"sp1 is initialized\" << endl;\n      else\n        cout << \"sp1 is not initialized\" << endl;\n      cout << \"sp1 pointing counter = \" << sp1.use_count() << endl;\n      if(sp1.unique())\n        cout << \"sp1 is unique\" << endl;\n      else\n        cout << \"sp1 is not unique\" << endl;\n      cout << endl;\n\n      auto sp2 = sp1;\n\n      cout << \"sp1 pointing counter = \" << sp1.use_count() << endl;\n      if(sp1.unique())\n        cout << \"sp1 is unique\" << endl;\n      else\n        cout << \"sp1 is not unique\" << endl;\n      cout << endl;\n\n      cout << \"sp2 pointing counter = \" << sp2.use_count() << endl;\n      if(sp2.unique())\n        cout << \"sp2 is unique\" << endl;\n      else\n        cout << \"sp2 is not unique\" << endl;\n      cout << endl;\n\n      sp2.reset();\n\n      cout << \"sp1 pointing counter = \" << sp1.use_count() << endl;\n      if(sp1.unique())\n        cout << \"sp1 is unique\" << endl;\n      else\n        cout << \"sp1 is not unique\" << endl;\n      cout << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* weak_ptr_1.cpp */\n    #include <memory>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[weak_ptr_1.cpp]\" << endl;\n\n      auto sp = make_shared<int>(1234);\n\n      auto wp = weak_ptr<int>{ sp };\n\n      if(wp.expired())\n       cout << \"wp is expired\" << endl;\n      else\n       cout << \"wp is not expired\" << endl;\n      cout << \"wp pointing counter = \" << wp.use_count() << endl;\n      if(auto locked = wp.lock())\n       cout << \"wp is locked. Value = \" << *locked << endl;\n      else\n      {\n        cout << \"wp is unlocked\" << endl;\n        wp.reset();\n      }\n      cout << endl;\n\n      sp = nullptr;\n\n      if(wp.expired())\n       cout << \"wp is expired\" << endl;\n      else\n       cout << \"wp is not expired\" << endl;\n      cout << \"wp pointing counter = \" << wp.use_count() << endl;\n      if(auto locked = wp.lock())\n       cout << \"wp is locked. Value = \" << *locked << endl;\n      else\n      {\n        cout << \"wp is unlocked\" << endl;\n        wp.reset();\n      }\n      cout << endl;\n\n      return 0;\n     }\n\n```", "```cpp\n    /* tuples_1.cpp */\n    #include <tuple>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[tuples_1.cpp]\" << endl;\n\n      // Initializing two Tuples\n      tuple<int, string, bool> t1(1, \"Robert\", true);\n      auto t2 = make_tuple(2, \"Anna\", false);\n\n      // Displaying t1 Tuple elements\n      cout << \"t1 elements:\" << endl;\n      cout << get<0>(t1) << endl;\n      cout << get<1>(t1) << endl;\n      cout << (get<2>(t1) == true ? \"Male\" : \"Female\") << endl;\n      cout << endl;\n\n      // Displaying t2 Tuple elements\n      cout << \"t2 elements:\" << endl;\n      cout << get<0>(t2) << endl;\n      cout << get<1>(t2) << endl;\n      cout << (get<2>(t2) == true ? \"Male\" : \"Female\") << endl;\n      cout << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* tuples_2.cpp */\n    #include <tuple>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n   {\n      cout << \"[tuples_2.cpp]\" << endl;\n\n      // Initializing two Tuples\n      tuple<int, string, bool> t1(1, \"Robert\", true);\n      auto t2 = make_tuple(2, \"Anna\", false);\n\n      int i;\n      string s;\n      bool b;\n\n      // Unpacking t1 Tuples\n      tie(i, s, b) = t1;\n      cout << \"tie(i, s, b) = t1\" << endl;\n      cout << \"i = \" << i << endl;\n      cout << \"s = \" << s << endl;\n      cout << \"b = \" << boolalpha << b << endl;\n      cout << endl;\n\n      // Unpacking t2 Tuples\n      tie(ignore, s, ignore) = t2;\n      cout << \"tie(ignore, s, ignore) = t2\" << endl;\n      cout << \"new i = \" << i << endl;\n      cout << \"new s = \" << s << endl;\n      cout << \"new b = \" << boolalpha << b << endl;\n      cout << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* tuples_3.cpp */\n    #include <tuple>\n    #include <iostream>\n\n    using namespace std;\n\n    tuple<int, string, bool> GetData(int DataId)\n    {\n      if (DataId == 1) \n        return std::make_tuple(0, \"Chloe\", false);\n      else if (DataId == 2) \n        return std::make_tuple(1, \"Bryan\", true);\n      else \n        return std::make_tuple(2, \"Zoey\", false);\n     }\n\n    auto main() -> int\n    {\n      cout << \"[tuples_3.cpp]\" << endl;\n\n      auto name = GetData(1);\n      cout << \"Details of Id 1\" << endl;\n      cout << \"ID = \" << get<0>(name) << endl;\n      cout << \"Name = \" << get<1>(name) << endl;\n      cout << \"Gender = \" << (get<2>(name) == true ? \n        \"Male\" : \"Female\");\n      cout << endl << endl;\n\n      int i;\n      string s;\n      bool b;\n      tie(i, s, b) = GetData(2);\n      cout << \"Details of Id 2\" << endl;\n      cout << \"ID = \" << i << endl;\n      cout << \"Name = \" << s << endl;\n      cout << \"Gender = \" << (b == true ? \"Male\" : \"Female\");\n      cout << endl;\n\n      return 0;\n    }\n\n```"]