- en: Appendix A. C++11 Language Features Emulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. C++11 语言特性模拟
- en: 'In this section, we will review some concepts from C++ programming that will
    be conceptually important in understanding several topics covered in this book.
    Many of these concepts have been introduced relatively recently as part of C++11\.
    We will look at: RAII, copy- and move-semantics, `auto`, range-based for-loops,
    and C++11 exception handling enhancements. We will look at how these features
    can be emulated under a pre-C++11 compiler using parts of the Boost libraries.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些 C++ 编程中的概念，这些概念在理解本书涵盖的几个主题中具有概念上的重要性。其中许多概念是作为 C++11 的一部分相对较新地引入的。我们将研究：RAII、复制和移动语义、`auto`、基于范围的
    for 循环以及 C++11 异常处理增强。我们将看看如何在预 C++11 编译器下使用 Boost 库的部分来模拟这些特性。
- en: RAII
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAII
- en: C++ programs frequently deal with system resources like memory, file and socket
    handles, shared memory segments, mutexes, and so on. There are well-defined primitives,
    some from the C Standard Library and many more from the native systems programming
    interfaces, which are used to request and relinquish these resources. Failing
    to guarantee the release of acquired resources can cause grave problems to an
    application's performance and correctness.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 程序经常处理系统资源，如内存、文件和套接字句柄、共享内存段、互斥锁等。有明确定义的原语，一些来自 C 标准库，还有更多来自本地系统编程接口，用于请求和释放这些资源。未能保证已获取资源的释放可能会对应用程序的性能和正确性造成严重问题。
- en: The destructor of a C++ object *on the stack* is automatically invoked during
    stack unwinding. The unwinding happens when a scope is exited due to control reaching
    the end of the scope, or by executing `return`, `goto`, `break`, or `continue`.
    A scope is also exited as a result of an exception being thrown. In either case,
    the destructor is guaranteed to be called. This guarantee is limited to C++ objects
    on the stack. It does not apply to C++ objects on the heap because they are not
    associated with a lexical scope. Furthermore, it does not apply to the aforementioned
    resources like memory and file descriptors, which are objects of Plain Old Data
    types (POD-types) and therefore do not have a destructor.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 对象 *在堆栈上* 的析构函数在堆栈展开时会自动调用。展开发生在由于控制达到作用域的末尾而退出作用域，或者通过执行 `return`、`goto`、`break`
    或 `continue`。由于抛出异常而导致作用域退出也会发生展开。在任何情况下，都保证调用析构函数。这个保证仅限于堆栈上的 C++ 对象。它不适用于堆上的
    C++ 对象，因为它们不与词法作用域相关。此外，它也不适用于前面提到的资源，如内存和文件描述符，它们是平凡旧数据类型（POD 类型）的对象，因此没有析构函数。
- en: 'Consider the following C++ code using the `new[]` and `delete[]` operators:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用 `new[]` 和 `delete[]` 运算符的 C++ 代码：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The programmer was careful to release the buffer allocated. However, if another
    programmer came and flippantly wrote code to exit the scope somewhere between
    the calls to `new` and `delete`, then `buffer` would never be released and you
    would leak memory. Exceptions could arise in the intervening code too with the
    same result. This is true not just of memory but of any resource which requires
    a manual step to release, like `delete[]` in this case.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员小心释放了分配的缓冲区。但是，如果另一个程序员随意编写代码，在调用 `new` 和 `delete` 之间的某个地方退出作用域，那么 `buffer`
    就永远不会被释放，您将会泄漏内存。异常也可能在介入的代码中出现，导致相同的结果。这不仅适用于内存，还适用于任何需要手动释放的资源，比如在这种情况下的 `delete[]`。
- en: This is where we can utilize the guaranteed invocation of a destructor when
    exiting a scope to guarantee the clean-up of resources. We can create a wrapper
    class whose constructor acquires ownership of the resource and whose destructor
    releases the resource. A few lines of code can explain this technique that usually
    goes by the name **Resource Acquisition is Initialization** or **RAII**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以利用在退出作用域时保证调用析构函数来保证资源的清理。我们可以创建一个包装类，其构造函数获取资源的所有权，其析构函数释放资源。几行代码可以解释这种通常被称为**资源获取即初始化**或**RAII**的技术。
- en: '**Listing A.1: RAII in action**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 A.1：RAII 的实际应用**'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `String` class encapsulates a C-style string. We pass it a C-style string
    during construction, and it creates a copy of the passed string on the free store
    if it is not null. The helper function `dupstr` allocates memory for the `String`
    object on the free store using the the `new[]` operator (line 24). If allocation
    fails, `operator new[]` throws `std::bad_alloc`, and the `String` object never
    comes into being. In other words, resource acquisition must succeed for initialization
    to succeed. This is the other key aspect of RAII.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类封装了一个 C 风格的字符串。我们在构造过程中传递了一个 C 风格的字符串，并且如果它不为空，它会在自由存储器上创建传递的字符串的副本。辅助函数
    `dupstr` 使用 `new[]` 运算符（第 24 行）在自由存储器上为 `String` 对象分配内存。如果分配失败，`operator new[]`
    抛出 `std::bad_alloc`，并且 `String` 对象永远不会存在。换句话说，资源获取必须成功才能使初始化成功。这是 RAII 的另一个关键方面。'
- en: 'We use the `String` class in code as shown here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用 `String` 类，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create an instance of `String` called `favBand`, which internally allocates
    a character buffer dynamically. When `favBand` goes out of scope normally or due
    to an exception, its destructor is called and it releases this buffer. You can
    apply this technique to all forms of resources that require manual release, and
    it will never let a resource leak creep in. The `String` class is said to own
    the buffer resource, that is, it has *unique ownership semantics*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `favBand` 的 `String` 实例，它在内部动态分配了一个字符缓冲区。当 `favBand` 正常或由于异常而超出范围时，它的析构函数被调用并释放这个缓冲区。您可以将这种技术应用于所有需要手动释放的资源形式，并且它永远不会让资源泄漏。`String`
    类被认为拥有缓冲区资源，即它具有*独占所有权语义*。
- en: Copy semantics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制语义
- en: An object keeps state information in its data members, which can themselves
    be of POD-types or class types. If you do not define a copy constructor for your
    class, then the compiler implicitly defines one for you. This implicitly-defined
    copy constructor copies each member in turn, invoking the copy constructor of
    members of class type and performing a bitwise copy of POD-type members. The same
    is true of the assignment operator. The compiler generates one if you do not define
    your own, and it performs member-wise assignment, invoking the assignment operators
    of member objects of class-type, and performing bitwise copies of POD-type members.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象在其数据成员中保留状态信息，这些成员本身可以是POD类型或类类型。如果你没有为你的类定义一个复制构造函数，那么编译器会隐式为你定义一个。这个隐式定义的复制构造函数依次复制每个成员，调用类类型成员的复制构造函数，并对POD类型成员执行位拷贝。赋值运算符也是如此。如果你没有定义自己的赋值运算符，编译器会生成一个，并执行成员逐个赋值，调用类类型成员对象的赋值运算符，并对POD类型成员执行位拷贝。
- en: 'The following example illustrates this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这一点：
- en: '**Listing A.2: Implicit destructor, copy constructor, and assignment operator**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.2：隐式析构函数、复制构造函数和赋值运算符**'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Class `Bar` contains an instance of class `Foo` as a member (line 25). Class
    `Foo` defines a destructor (line 11), a copy constructor (line 7), and an assignment
    operator, (line 15) each of which prints some message. Class `Bar` does not define
    any of these special functions. We create an instance of `Bar` called `b1` (line
    30) and a copy of `b1` called `b2` (line 33). We then assign `b1` to `b2` (line
    36). Here is the output when the program is run:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Bar`包含类`Foo`的一个实例作为成员（第25行）。类`Foo`定义了一个析构函数（第11行），一个复制构造函数（第7行）和一个赋值运算符（第15行），每个函数都打印一些消息。类`Bar`没有定义任何这些特殊函数。我们创建了一个名为`b1`的`Bar`实例（第30行），以及`b1`的一个副本`b2`（第33行）。然后我们将`b1`赋值给`b2`（第36行）。当程序运行时，输出如下：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Through the messages printed, we can trace the calls made to `Foo`'s special
    functions from `Bar`'s implicitly generated special functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打印的消息，我们可以追踪从`Bar`的隐式生成的特殊函数调用`Foo`的特殊函数。
- en: This works adequately for all cases except when you encapsulate a pointer or
    non-class type handle to some resource in your class. The implicitly-defined copy
    constructor or assignment operator will copy the pointer or handle but not the
    underlying resources, generating an object which is a **shallow copy** of another.
    This is rarely what is needed and this is where a user-defined copy constructor
    and assignment operator are needed to define the correct copy semantics. If such
    copy semantics do not make sense for the class, the copy constructor and assignment
    operator ought to be disabled. In addition, you would also need to manage resource
    lifetimes using RAII, and therefore define a destructor rather than relying on
    the compiler-generated one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这对所有情况都有效，除了当你在类中封装指针或非类类型句柄到某些资源时。隐式定义的复制构造函数或赋值运算符将复制指针或句柄，但不会复制底层资源，生成一个**浅复制**的对象。这很少是需要的，这就是需要用户定义复制构造函数和赋值运算符来定义正确的复制语义的地方。如果这样的复制语义对于类没有意义，复制构造函数和赋值运算符应该被禁用。此外，您还需要使用RAII来管理资源的生命周期，因此需要定义一个析构函数，而不是依赖于编译器生成的析构函数。
- en: There is a well-known rule called the **Rule of Three** that regularizes this
    common idiom. It says that if you need to define your own destructor for a class,
    you should also define your own copy constructor and assignment operator or disable
    them. The `String` class we defined in listing A.1 is such a candidate and we
    will add the remaining two of the three canonical methods shortly. As we noted,
    not all classes need to define these functions, only those that encapsulate resources.
    In fact, it is recommended that a class using these resources should be different
    from the class managing the lifetime of these resources. Thus, we should create
    a wrapper around each resource for managing that resource using specialized types
    like smart pointers ([Chapter 3](ch03.html "Chapter 3. Memory Management and Exception
    Safety"), *Memory Management and Exception Safety*), `boost::ptr_container` ([Chapter
    5](ch05.html "Chapter 5. Effective Data Structures beyond STL"), *Effective Data
    Structures beyond STL*), `std::vector`, and so on. The class using the resources
    should have the wrappers rather than the raw resources as members. This way, the
    class using the resource does not have to also bother about managing the resource
    life cycles, and the implicitly-defined destructor, copy constructor, and assignment
    operator would be adequate for its purposes. This has come to be called the **Rule
    of Zero**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个众所周知的规则叫做**三规则**，它规范了这个常见的习惯用法。它说如果你需要为一个类定义自己的析构函数，你也应该定义自己的复制构造函数和赋值运算符，或者禁用它们。我们在A.1清单中定义的`String`类就是这样一个候选者，我们将很快添加剩下的三个规范方法。正如我们所指出的，并不是所有的类都需要定义这些函数，只有封装资源的类才需要。事实上，建议使用这些资源的类应该与管理这些资源的类不同。因此，我们应该为每个资源创建一个包装器，使用专门的类型来管理这些资源，比如智能指针（[第3章](ch03.html
    "第3章。内存管理和异常安全性")，“内存管理和异常安全性”），`boost::ptr_container`（[第5章](ch05.html "第5章。超出STL的有效数据结构")，“超出STL的有效数据结构”），`std::vector`等等。使用资源的类应该有包装器而不是原始资源作为成员。这样，使用资源的类就不必再担心管理资源的生命周期，隐式定义的析构函数、复制构造函数和赋值运算符对它的目的就足够了。这就被称为**零规则**。
- en: The nothrow swap
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不抛出交换
- en: 'Thanks to Rule of Zero, you should rarely need to bother about the Rule of
    Three. But when you do have to use the Rule of Three, there are a few nitty-gritties
    to take care of. Let us first understand how you would define a copy operation
    for the `String` class in listing A.1:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢零规则，你应该很少需要担心三规则。但是当你确实需要使用三规则时，有一些细枝末节需要注意。让我们首先了解如何在A.1清单中为`String`类定义一个复制操作：
- en: '**Listing A.1a: Copy constructor**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.1a：复制构造函数**'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The implementation of copy constructor is no different than that of the constructor
    in listing A.1\. The assignment operator requires more care. Consider how `String`
    objects are assigned to in the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数的实现与清单A.1中的构造函数没有区别。赋值运算符需要更多的注意。考虑以下示例中如何对`String`对象进行赋值：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On line 3, we assign `band2` to `band1`. As part of this, `band1`''s old state
    should be deallocated and then overwritten with a copy of `band2`''s internal
    state. The problem is that copying `band2`''s internal state might fail, and so
    `band1`''s old state should not be destroyed until `band2`''s state has been copied
    successfully. Here is a succinct way to achieve this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们将`band2`赋值给`band1`。作为此过程的一部分，应释放`band1`的旧状态，然后用`band2`的内部状态的副本进行覆盖。问题在于复制`band2`的内部状态可能会失败，因此在成功复制`band2`的状态之前，不应销毁`band1`的旧状态。以下是实现此目的的简洁方法：
- en: '**Listing A.1b: Assignment operator**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.1b：赋值运算符**'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We create `tmp` as a copy of `rhs` (line 3) and if this copying fails, it should
    throw an exception and the assignment operation would fail. The internal state
    of the assignee, `this`, should not change. The call to `swap` (line 4) executes
    only if the copying succeeded (line 3). The call to `swap` exchanges the internal
    states of `this` and the `tmp` object. As a result, `this` now contains the copy
    of `rhs` and `tmp` contains the older state of `this`. At the end of this function,
    `tmp` goes out of scope and releases the old state of `this`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`tmp`作为`rhs`的副本创建（第3行），如果此复制失败，它应该抛出异常，赋值操作将失败。被赋值对象`this`的内部状态不应更改。对`swap`的调用（第4行）仅在复制成功时执行（第3行）。对`swap`的调用交换了`this`和`tmp`对象的内部状态。因此，`this`现在包含`rhs`的副本，而`tmp`包含`this`的旧状态。在此函数结束时，`tmp`超出范围并释放了`this`的旧状态。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is possible to optimize this implementation further by considering special
    cases. If the assignee (left-hand side) already has storage that is at least as
    large as needed to contain the contents of `rhs`, then we can simply copy the
    contents of `rhs` into the assignee, without the need for extra allocation and
    deallocation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑特殊情况，可以进一步优化此实现。如果被赋值对象（左侧）已经具有至少与`rhs`的内容相同大小的存储空间，那么我们可以简单地将`rhs`的内容复制到被赋值对象中，而无需额外的分配和释放。
- en: 'Here is the implementation of the `swap` member function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`swap`成员函数的实现：
- en: '**Listing A.1c: nothrow swap**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.1c：nothrow swap**'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exchanging variables of primitive types (integers, pointers, and so on) should
    not cause any exceptions to be thrown, a fact we advertise using the C++11 keyword
    `noexcept`. We could have written `throw()` instead of `noexcept`, but exception
    specifications are deprecated in C++11 and `noexcept` is more efficient than a
    `throw()` clause. This swap function, written entirely in terms of exchanging
    primitive data types, is guaranteed to succeed and would never leave the assignee
    in an inconsistent state.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 交换原始类型变量（整数、指针等）不应引发任何异常，这一事实我们使用C++11关键字`noexcept`来宣传。我们可以使用`throw()`代替`noexcept`，但异常规范在C++11中已被弃用，而`noexcept`比`throw()`子句更有效。这个`swap`函数完全是用交换原始数据类型来写的，保证成功并且永远不会使被赋值对象处于不一致的状态。
- en: Move semantics and rvalue references
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动语义和右值引用
- en: 'Copy semantics are for creating clones of objects. It is useful sometimes,
    but not always needed or even meaningful. Consider the following class that encapsulates
    a TCP client socket. A TCP socket is an integer that represents one endpoint of
    a TCP connection and through which data can be sent or received to the other endpoint.
    The TCP socket class can have the following interface:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 复制语义用于创建对象的克隆。有时很有用，但并非总是需要或有意义。考虑封装TCP客户端套接字的以下类。TCP套接字是一个整数，表示TCP连接的一个端点，通过它可以向另一个端点发送或接收数据。TCP套接字类可以有以下接口：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The constructor opens a connection to a host on a specified port and initializes
    the `socket_fd_` member variable. The destructor closes the connection. TCP does
    not define a way to make clones of open sockets (unlike file descriptors with
    `dup`/`dup2`) and therefore cloning `TCPSocket` would not be meaningful either.
    Therefore, we disable copy semantics by declaring the copy constructor and copy
    assignment operators private. In C++11, the preferred way to do this is to declare
    these members as deleted:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数打开到指定端口上主机的连接并初始化`socket_fd_`成员变量。析构函数关闭连接。TCP不定义一种克隆打开套接字的方法（不像具有`dup`/`dup2`的文件描述符），因此克隆`TCPSocket`也没有意义。因此，通过将复制构造函数和复制赋值运算符声明为私有来禁用复制语义。在C++11中，这样做的首选方法是将这些成员声明为已删除：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although not copyable, it would make perfect sense to create a `TCPSocket`
    object in one function and then return it to a calling function. Consider a factory
    function that creates connections to some remote TCP service:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不可复制，但在一个函数中创建`TCPSocket`对象然后返回给调用函数是完全合理的。考虑一个创建到某个远程TCP服务的连接的工厂函数：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Such a function would encapsulate the details about which host and port to
    connect to, and would create an object of `TCPSocket` to be returned to the caller.
    This would not really call for copy semantics at all, but move semantics, in which
    the contents of the `TCPSocket` object created in the `connectToService` function
    would be transferred to another `TCPSocket` object at the call site:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数将封装关于连接到哪个主机和端口的详细信息，并创建一个要返回给调用者的`TCPSocket`对象。这实际上根本不需要复制语义，而是需要移动语义，在`connectToService`函数中创建的`TCPSocket`对象的内容将被转移到调用点的另一个`TCPSocket`对象中：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In C++03, this would not be possible to write without enabling the copy constructor.
    We could subvert the copy constructor to provide move semantics, but there are
    many problems with this approach:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++03中，如果不启用复制构造函数，将无法编写此代码。我们可以通过曲线救国复制构造函数来提供移动语义，但这种方法存在许多问题：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that this version of the "copy" constructor actually moves the contents
    out of its argument, which is why the argument is non-const. With this definition,
    we can actually implement the `connectToService` function, and use it as shown
    earlier. But nothing would prevent situations like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个“复制”构造函数实际上将其参数的内容移出，这就是为什么参数是非const的原因。有了这个定义，我们实际上可以实现`connectToService`函数，并像之前那样使用它。但是没有什么可以阻止以下情况发生：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We obtain an instance of `TCPSocket` called `socket` by calling `connectToService`
    (line 8) and pass this instance to `performIO` (line 9). But the copy constructor
    used to pass `socket` by value to `performIO` moves its contents out, and when
    `performIO` returns, `socket` no longer encapsulates a valid TCP socket. By disguising
    a move as a copy, we have created an unintuitive and error-prone interface; if
    you are familiar with `std::auto_ptr`, you would have seen this before.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`connectToService`（第8行）获得了名为`socket`的`TCPSocket`实例，并将此实例传递给`performIO`（第9行）。但用于将`socket`按值传递给`performIO`的复制构造函数移出了其内容，当`performIO`返回时，`socket`不再封装有效的TCP套接字。通过将移动伪装成复制，我们创建了一个令人费解且容易出错的接口；如果您熟悉`std::auto_ptr`，您以前可能已经见过这种情况。
- en: rvalue references
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 右值引用
- en: 'In order to support move semantics better, we must first answer the question:
    which objects can be moved from? Consider the `TCPSocket` example again. In the
    function `connectToService`, the expression `TCPSocket(get_service_host(), get_service_port())`
    is an *unnamed temporary* object of `TCPSocket` whose sole purpose is to be transferred
    to the caller''s context. There is no way for anyone to refer to this object beyond
    the statement where it gets created. It makes perfect sense to move the contents
    out of such an object. But in the following snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地支持移动语义，我们必须首先回答一个问题：哪些对象可以被移动？再次考虑`TCPSocket`示例。在函数`connectToService`中，表达式`TCPSocket(get_service_host(),
    get_service_port())`是`TCPSocket`的*无名临时*对象，其唯一目的是传递到调用者的上下文。没有人可以在创建该语句之后引用此对象。从这样的对象中移出内容是完全合理的。但在以下代码片段中：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It would be dangerous to move out the contents of `socket` object because in
    the calling context, the object is still bound to the name `socket` and can be
    used in further operations. The expression `socket` is called an **lvalue expression**—one
    that has an identity and whose address can be taken by prefixing the &-operator
    to the expression. Non-lvalue expressions are referred to as **rvalue expressions**.
    These are unnamed expressions whose address cannot be computed using the &-operator
    on the expression. An expression, such as `TCPSocket(get_service_host(), get_service_port())`
    is an rvalue expression.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从`socket`对象中移出内容是危险的，因为在调用上下文中，对象仍然绑定到名称`socket`，并且可以在进一步的操作中使用。表达式`socket`被称为**左值表达式**——具有标识并且其地址可以通过在表达式前加上&-运算符来获取。非左值表达式被称为**右值表达式**。这些是无名表达式，其地址不能使用&-运算符在表达式上计算。例如，`TCPSocket(get_service_host(),
    get_service_port())`是一个右值表达式。
- en: 'We can say that, in general, it is dangerous to move contents from an lvalue
    expression but safe to move contents from rvalue expressions. Thus, the following
    is dangerous:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，从左值表达式中移动内容是危险的，但从右值表达式中移动内容是安全的。因此，以下是危险的：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But the following is alright:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下是可以的：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note here that the expression `connectToService()` is not an lvalue expression
    and therefore qualifies as an rvalue expression. In order to distinguish between
    lvalue and rvalue expressions, C++11 introduced a new class of references called
    **rvalue references** that can refer to rvalue-expressions but not lvalue-expressions.
    Such references are declared using a new syntax involving double ampersands as
    shown below:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，表达式`connectToService()`不是左值表达式，因此符合右值表达式的条件。为了区分左值和右值表达式，C++11引入了一种新的引用类别，称为**右值引用**，它可以引用右值表达式但不能引用左值表达式。这些引用使用双和符号的新语法声明，如下所示：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The other class of references that were earlier simply called *references*
    are now called **lvalue references**. A non-const lvalue reference can only refer
    to an lvalue expression, while a const lvalue reference can also refer to an rvalue
    expression:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 早期被简单称为*引用*的引用的另一类现在称为**左值引用**。非const左值引用只能引用左值表达式，而const左值引用也可以引用右值表达式：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An rvalue reference can be, and usually is, non-const:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 右值引用可以是非const的，通常是非const的：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding snippet, the expression `socketref` itself is an lvalue-expression
    because you can compute its address using &-operator. But it is bound to an rvalue-expression,
    and object referred to by the non-const rvalue reference can be modified through
    it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，表达式`socketref`本身是一个左值表达式，因为可以使用&-运算符计算其地址。但它绑定到一个右值表达式，并且通过非const右值引用引用的对象可以通过它进行修改。
- en: rvalue-reference overloads
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右值引用重载
- en: 'We can create overloads of a function based on whether they take lvalue expressions
    or rvalue expressions. In particular, we can overload the copy constructor to
    take rvalue expressions. For the `TCPSocket` class, we can write the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据它们是否接受左值表达式或右值表达式来创建函数的重载。特别是，我们可以重载复制构造函数以接受右值表达式。对于`TCPSocket`类，我们可以编写以下内容：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the lvalue overload is the deleted copy constructor, rvalue overload is
    called the move constructor because this is implemented to usurp or "steal" the
    contents of the rvalue expression passed to it. It moves the contents of the source
    to the target, leaving the source (`rvref`) in some unspecified state that is
    safe to destruct. In this case, this amounts to setting the `socket_fd_` member
    of the `rvref` to -1.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然左值重载是删除的复制构造函数，但右值重载被称为移动构造函数，因为它被实现为篡夺或“窃取”传递给它的右值表达式的内容。它将源的内容移动到目标，将源（`rvref`）留在某种未指定的状态中，可以安全地销毁。在这种情况下，这相当于将`rvref`的`socket_fd_`成员设置为-1。
- en: 'With this definition of the move constructor, `TCPSocket` becomes movable but
    not copyable. The `connectToService` implementation would work correctly:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动构造函数的定义，`TCPSocket` 可以移动，但不能复制。`connectToService` 的实现将正常工作：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This would move the temporary object back to the caller. But the following
    call to `performIO` would be ill-formed because `socket` is an lvalue expression
    and `TCPSocket` only defines move semantics for which an rvalue expression was
    necessary:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把临时对象移回到调用者。但是，对 `performIO` 的后续调用将是不合法的，因为 `socket` 是一个左值表达式，而 `TCPSocket`
    仅为其定义了需要右值表达式的移动语义：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a good thing because you cannot move contents out of an object like
    `socket` that you could potentially use later. An rvalue-expression of a movable
    type can be passed by value and thus the following will be well-formed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好事，因为您不能移动像 `socket` 这样的对象的内容，而您可能稍后还会使用它。可移动类型的右值表达式可以通过值传递，因此以下内容将是合法的：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the expression `connectToService()`is an rvalue expression because
    it is not bound to a name and its address cannot be taken.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，表达式 `connectToService()` 是一个右值表达式，因为它未绑定到名称，其地址也无法被获取。
- en: 'A type can be both copyable and movable. For example, we could implement a
    move constructor for the `String` class in addition to its copy constructor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以既可复制又可移动。例如，我们可以为 `String` 类实现一个移动构造函数，除了它的复制构造函数：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The nothrow `swap` plays a central role in the implementation of move semantics.
    The contents of the source and target objects are exchanged. So when the source
    object goes out of scope in the calling scope, it releases its new contents (the
    target object's old state). The target object lives on with its new state (the
    source object's original state). The move is implemented in terms of the nothrow
    `swap,` which just swaps pointers and values of primitive types, and it is guaranteed
    to succeed; hence, the `noexcept` specification. In fact, moving objects usually
    requires less work involving swapping pointers and other data bits, while copying
    often requires new allocations that could potentially fail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: nothrow `swap` 在移动语义的实现中起着核心作用。源对象和目标对象的内容被交换。因此，当源对象在调用范围内超出范围时，它释放其新内容（目标对象的旧状态）。目标对象继续存在，具有其新状态（源对象的原始状态）。移动是基于nothrow
    `swap` 实现的，它只交换原始类型的指针和值，并且保证成功；因此，使用了 `noexcept` 说明。实际上，移动对象通常需要更少的工作，涉及交换指针和其他数据位，而复制通常需要可能失败的新分配。
- en: Move assignment
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动赋值
- en: 'Just as we can construct an object by stealing the contents of another object,
    we can also move the contents of one object to another after both have been constructed.
    To do this, we can define a **move assignment operator**, an rvalue-overload of
    the copy assignment operator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以通过窃取另一个对象的内容来构造对象一样，我们也可以在两者都构造之后将一个对象的内容移动到另一个对象。为此，我们可以定义一个**移动赋值运算符**，即复制赋值运算符的右值重载：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, we can define a **universal assignment operator** that works
    for both lvalue and rvalue expressions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以定义一个**通用赋值运算符**，适用于左值和右值表达式：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the universal assignment operator cannot coexist with either the lvalue
    or the rvalue overload, else there would be ambiguity in overload resolution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通用赋值运算符不能与左值或右值重载共存，否则在重载解析中会存在歧义。
- en: xvalues
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xvalues
- en: 'When you call a function with an rvalue expression, the compiler resolves function
    calls to an rvalue-overload of the function if one is available. But if you call
    the function with a named variable, it gets resolved to an lvalue overload if
    one is available or the program is ill-formed. Now you might have a named variable
    that you can move from because you have no use for it later:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用右值表达式调用函数时，如果有可用的右值重载函数，则编译器会将函数调用解析为右值重载函数。但是，如果您使用命名变量调用函数，则会将其解析为左值重载（如果有的话），否则程序将是不合法的。现在，您可能有一个命名变量，可以从中移动，因为您以后不需要使用它：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding example will fail to compile because `performIO` takes its sole
    parameter by value and `socket` is of a move-only type but it is not an rvalue
    expression. By using `std::move`, you can cast an lvalue expression to an rvalue
    expression, and pass it to a function that expects an rvalue expression. The `std::move`
    function template is defined in the standard header `utility`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将无法编译，因为 `performIO` 以值传递其唯一参数，而 `socket` 是一个仅移动类型，但它不是右值表达式。通过使用 `std::move`，您可以将左值表达式转换为右值表达式，并将其传递给期望右值表达式的函数。`std::move`
    函数模板在标准头文件 `utility` 中定义。
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `std::move(socket)` gives us an rvalue reference to `socket`; it
    does not cause any data to be moved out of `socket`. When we pass this expression
    of rvalue-reference type to the function `performIO`, which takes its parameter
    by value, a new `TCPSocket` object is created in the `performIO` function, corresponding
    to its by-value parameter. It is **move initialized** from `socket`, that is,
    its move constructor steals the contents of `socket`. Following the call to `performIO`,
    the variable `socket` loses its contents and therefore should not be used in further
    operations. If the move constructor of `TCPSocket` is correctly implemented, then
    `socket` should still be safe to destruct.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `std::move(socket)` 的调用给我们一个对 `socket` 的右值引用；它不会导致任何数据从 `socket` 中移出。当我们将这种右值引用类型的表达式传递给以值传递其参数的函数
    `performIO` 时，在 `performIO` 函数中创建了一个新的 `TCPSocket` 对象，对应于其按值参数。它是从 `socket` 进行**移动初始化**的，也就是说，它的移动构造函数窃取了
    `socket` 的内容。在调用 `performIO` 后，变量 `socket` 失去了其内容，因此不应在后续操作中使用。如果 `TCPSocket`
    的移动构造函数正确实现，那么 `socket` 应该仍然可以安全地销毁。
- en: The expression `std::move(socket)` shares the identity of `socket`, but it would
    *potentially* be moved from within the function it is passed to. Such expressions
    are called **xvalues**, the *x* standing for *expired*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `std::move(socket)` 共享 `socket` 的标识，但它可能在传递给函数时被移动。这种表达式称为**xvalues**，*x*
    代表 *expired*。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**xvalues** have a well-defined identity like lvalues, but can be moved from
    like rvalues. **xvalues** bind to rvalue reference parameters of a function.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**xvalues**像lvalues一样有明确定义的标识，但可以像rvalues一样移动。**xvalues**绑定到函数的rvalue引用参数。'
- en: 'If `performIO` did not take its parameter by value but as an rvalue-reference
    then one thing would change:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`performIO`没有按值接受其参数，而是按rvalue-reference，那么有一件事会改变：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The call to `performIO(std::move(socket))` would still be well-formed, but would
    not automatically move out the contents of `socket`. This is because we pass a
    reference to an existing object here, whereas we create a new object that is move
    initialized from `socket` when we pass by value. In this case, unless the `performIO`
    function implementation explicitly moves out the contents of `socket`, it would
    still remain valid in the calling context after the call to `performIO`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对`performIO(std::move(socket))`的调用仍然是良好的形式，但不会自动移出`socket`的内容。这是因为我们在这里传递了一个现有对象的引用，而当我们按值传递时，我们创建了一个从`socket`移动初始化的新对象。在这种情况下，除非`performIO`函数的实现明确地移出`socket`的内容，否则在调用`performIO`之后，它仍将在调用上下文中保持有效。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In general, if you have cast your object to an rvalue-expression and passed
    it to a function that expects an rvalue-reference, you should just assume that
    it has been moved from and not use it beyond the call.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果您将对象转换为rvalue表达式并将其传递给期望rvalue引用的函数，您应该假设它已经被移动，并且在调用之后不再使用它。
- en: An object of type T that is *local to a function* can be returned by value from
    that function if T has an accessible move or copy constructor. If a move constructor
    is available, the returned value will be move-initialized, else it would be copy-initialized.
    If however, the object is not local to the function, then it must have an accessible
    copy constructor to be returned by value. Additionally, compilers, whenever they
    can, optimize away copies and moves.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果T类型的对象是*函数内部的本地对象*，并且T具有可访问的移动或复制构造函数，则可以从该函数中返回该对象的值。如果有移动构造函数，则返回值将被移动初始化，否则将被复制初始化。但是，如果对象不是函数内部的本地对象，则必须具有可访问的复制构造函数才能按值返回。此外，编译器在可能的情况下会优化掉复制和移动。
- en: 'Consider the implementation of `connectToService` and how it is used:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`connectToService`的实现以及它的使用方式：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the compiler will actually construct the temporary (line 3) directly
    in the storage for the `socket` object (line 6) where the return value of `connectToService`
    was meant to be moved to. This way, it would simply optimize away the move initialization
    of `socket` (line 6). This optimization is effected even if the move constructor
    has side effects, which means that those side effects may not take effect as a
    result of this optimization. In the same way, the compiler can optimize away copy
    initialization and directly construct the returned object at the target site.
    This is referred to as **Return Value Optimization** (**RVO**) and has been the
    norm for all major compilers since C++03, when it optimized away only copies.
    Although the copy or move constructors are not invoked when RVO takes effect,
    they must nevertheless be defined and accessible for RVO to work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器实际上会直接在`socket`对象的存储空间（第3行）中构造临时对象，而`connectToService`的返回值原本是要移动到的地方（第6行）。这样，它会简单地优化掉`socket`的移动初始化（第6行）。即使移动构造函数具有副作用，这种优化也会生效，这意味着这些副作用可能不会因此优化而产生效果。同样，编译器可以优化掉复制初始化，并直接在目标位置构造返回的对象。这被称为**返回值优化**（**RVO**），自C++03以来一直是所有主要编译器的标准，当时它只优化了复制。尽管在RVO生效时不会调用复制或移动构造函数，但它们仍然必须被定义和可访问才能使RVO生效。
- en: While RVO applies when rvalue expressions are returned, the compiler can sometimes
    optimize away a copy or move, even when a named *local* object on the stack is
    returned from a function. This is known as **Named Return Value Optimization**
    (**NRVO**).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回rvalue表达式时，RVO适用，但是即使从函数中返回了命名的*本地*堆栈对象，编译器有时也可以优化掉复制或移动。这被称为**命名返回值优化**（**NRVO**）。
- en: 'Return Value Optimization is a specific case of **Copy Elision**, in which
    the compiler optimizes away a move or copy of an rvalue expression to construct
    it directly in the target storage:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值优化是**复制省略**的一个特例，其中编译器优化掉rvalue表达式的移动或复制，直接在目标存储中构造它：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, the expression `a + b` is an rvalue expression that
    generates a temporary object of type `std::string`. This object will not be copied
    into the function `reverse` instead the copy would be *elided*, and the object
    resulting from the expression `a + b` would be constructed directly in the storage
    for `reverse`'s parameter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，表达式`a + b`是一个rvalue表达式，它生成了一个`std::string`类型的临时对象。这个对象不会被复制到函数`reverse`中，而是*省略*了复制，并且由表达式`a
    + b`生成的对象会直接在`reverse`的参数的存储空间中构造。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Passing and returning an object of type T by value requires either move or copy
    semantics to be defined for T. If a move constructor is available, it is used,
    otherwise the copy constructor is used. Whenever possible, the compiler optimizes
    away copy or move operations and constructs the object directly at the target
    site in the calling or called function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递和返回类型T的对象需要为T定义移动或复制语义。如果有移动构造函数，则使用它，否则使用复制构造函数。在可能的情况下，编译器会优化掉复制或移动操作，并直接在调用或被调用函数的目标位置构造对象。
- en: Move emulation using Boost.Move
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost.Move进行移动模拟
- en: 'In this section, we look at how, with relative ease, you can actually retrofit
    much of the move semantics for your own legacy classes using the Boost.Move library.
    First, consider the interface of the `String` class in C++ 11 syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何使用Boost.Move库相对容易地为自己的传统类实际上实现了大部分移动语义的后期改造。首先，考虑C++ 11语法中`String`类的接口：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let us now see how you would define an equivalent interface using Boost''s
    facilities:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Boost的工具定义等效的接口：
- en: '**Listing A.2a: Move emulation with Boost.Move**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.2a：使用Boost.Move进行移动模拟**'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The key changes are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关键更改如下：
- en: 'Line 6: The macro `BOOST_COPYABLE_AND_MOVABLE(String)` defines some internal
    infrastructure to support copy and move semantics, and distinguish between lvalues
    and rvalues of type `String`. This is declared as private.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6行：宏`BOOST_COPYABLE_AND_MOVABLE(String)`定义了一些内部基础设施，以支持`String`类型的拷贝和移动语义，并区分`String`类型的左值和右值。这被声明为私有。
- en: 'Line 19: A copy assignment operator that takes the type `BOOST_COPY_ASSIGN_REF(String)`.
    This is a wrapper type for `String` to which `String` lvalues can be implicitly
    converted.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第19行：一个拷贝赋值运算符，它接受类型`BOOST_COPY_ASSIGN_REF(String)`。这是`String`的包装类型，可以隐式转换为`String`的左值。
- en: 'Line 22 and 25: A move constructor and a move-assignment operator that take
    the wrapper type `BOOST_RV_REF(String)`. String rvalues implicitly convert to
    this type.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第22行和25行：接受包装类型`BOOST_RV_REF(String)`的移动构造函数和移动赋值运算符。`String`的右值隐式转换为此类型。
- en: Note that on line 16, the copy constructor does not change.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，第16行的拷贝构造函数不会改变。
- en: Under a C++ 03 compiler, the emulation of move-semantics is provided without
    any special support from the language or the compiler. With a C++ 11 compiler,
    the macros automatically use C++ 11 native constructs for supporting move-semantics.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++ 03编译器下，移动语义的模拟是在没有语言或编译器的特殊支持的情况下提供的。使用C++ 11编译器，宏自动使用C++ 11本机构造来支持移动语义。
- en: The implementation is pretty much the same as the C++ 11 version except for
    the parameter types.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与C++ 11版本基本相同，只是参数类型不同。
- en: '**Listing A.2b: Move emulation with Boost Move**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.2b：使用Boost Move进行移动模拟**'
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we wanted to make our class only support move semantics but not copy semantics,
    then we should have used the macro `BOOST_MOVABLE_NOT_COPYABLE` in place of `BOOST_COPYABLE_AND_MOVABLE`
    and should not have defined the copy constructor and copy assignment operator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想使我们的类支持移动语义而不支持拷贝语义，那么我们应该使用宏`BOOST_MOVABLE_NOT_COPYABLE`代替`BOOST_COPYABLE_AND_MOVABLE`，并且不应该定义拷贝构造函数和拷贝赋值运算符。
- en: 'In the copy/move assignment operators, we could check for self-assignment if
    we wanted by putting the code that does the swapping/copying inside an if-block
    like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在拷贝/移动赋值运算符中，如果需要，我们可以通过将执行交换/复制的代码放在if块内来检查自赋值，如下所示：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will not change the correctness of the code as long the implementation
    of copy/move is exception-safe. But it would help to improve the performance by
    avoiding further operations in case of assignment to the self.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只要拷贝/移动的实现是异常安全的，这不会改变代码的正确性。但是，通过避免对自身进行赋值的进一步操作，可以提高性能。
- en: 'So in summary, the following macros help us emulate move-semantics in C++ 03:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总之，以下宏帮助我们在C++ 03中模拟移动语义：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also use `BOOST_RV_REF(…)` encapsulated types for parameters of other
    member methods, besides the move constructors and assignment operators.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了移动构造函数和赋值运算符之外，还可以使用`BOOST_RV_REF(…)`封装类型作为其他成员方法的参数。
- en: 'If you want to move from an lvalue, you would naturally have to cast it to
    an "rvalue-emulating" expression. You do this using `boost::move`, which corresponds
    to `std::move` in C++ 11\. Here are some examples of invoking different copy and
    move operations on `String` objects using the Boost move emulation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要从左值移动，自然需要将其转换为“模拟右值”的表达式。您可以使用`boost::move`来实现这一点，它对应于C++ 11中的`std::move`。以下是使用Boost移动模拟在`String`对象上调用不同的拷贝和移动操作的一些示例：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: C++11 auto and Boost.Auto
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++11 auto和Boost.Auto
- en: 'Consider how you declare an iterator to a vector of strings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何声明指向字符串向量的迭代器：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The declared type of `iter` is big and unwieldy and it is a pain to write it
    explicitly every time. Given that the compiler knows the type of the initializing
    expression on the right-hand side, that is, `vec.begin()`, this is also superfluous.
    Starting with C++11, you can use the `auto` keyword to ask the compiler to deduce
    the type of a declared variable using the type of the expression it is initialized
    with. Thus, the preceding tedium is replaced by the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter`的声明类型很大且笨重，每次显式写出来都很麻烦。鉴于编译器知道右侧初始化表达式的类型，即`vec.begin()`，这也是多余的。从C++11开始，您可以使用`auto`关键字要求编译器使用初始化表达式的类型来推导已声明变量的类型。因此，前面的繁琐被以下内容替换：'
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Consider the following statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下语句：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The deduced type of `var` is the same as the deduced type `T`, when the following
    function template is called with the argument `expr`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用参数`expr`调用以下函数模板时，`var`的推导类型与推导类型`T`相同：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Type deduction rules
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推导规则
- en: 'There are a few rules to keep in mind. First, if the initializing expression
    is a reference, the reference is stripped in the deduced type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些规则需要记住。首先，如果初始化表达式是引用，则在推导类型中引用被剥离：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you want to declare an lvalue-reference, you must explicitly adorn the `auto`
    keyword with an ampersand (&), as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要声明左值引用，必须将`auto`关键字明确加上`&`，如下所示：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the initializing expression is not copyable, you must make the assignee a
    reference in this way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始化表达式不可复制，必须以这种方式使被赋值者成为引用。
- en: 'The second rule is that `const` and `volatile` qualifiers of the initializing
    expression are stripped in the deduced type, unless the variable declared with
    `auto` is explicitly declared as a reference:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是，初始化表达式的`const`和`volatile`限定符在推导类型中被剥离，除非使用`auto`声明的变量被显式声明为引用：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Again, if you want to add a `const` or `volatile` qualifier, you must do so
    explicitly, as shown:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要添加`const`或`volatile`限定符，必须显式这样做，如下所示：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Common uses
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用法
- en: 'The `auto` keyword is very convenient to use in a lot of situations. It lets
    you get away from having to type long template IDs, in particular when the initializing
    expression is a function call. Here are a couple of examples to illustrate the
    advantages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字在许多情况下非常方便。它让您摆脱了不得不输入长模板ID的困扰，特别是当初始化表达式是函数调用时。以下是一些示例，以说明其优点：'
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note the savings in the type names achieved through the use of `auto`. Also,
    note that while creating the `tuple` called `coords` using `boost::make_tuple`,
    we do not use the assignment syntax for initialization.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意通过使用`auto`实现的类型名称的节省。另外，请注意，在创建名为`coords`的`tuple`时，我们没有使用赋值语法进行初始化。
- en: Boost.Auto
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Auto
- en: 'If you are on a pre-C++11 compiler, you can emulate this effect using the `BOOST_AUTO`
    and `BOOST_AUTO_TPL` macros. Thus, you can write the last snippet as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是C++11之前的编译器，可以使用`BOOST_AUTO`和`BOOST_AUTO_TPL`宏来模拟这种效果。因此，您可以将最后一小节写成如下形式：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the header file `boost/typeof/typeof.hpp` that needs to be included to
    use the macro.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意需要包含的头文件`boost/typeof/typeof.hpp`以使用该宏。
- en: 'If you want to declare a reference type, you can adorn the variable with a
    leading ampersand (&). Likewise, to qualify your variable with `const` or `volatile`,
    you should add the `const` or `volatile` qualifier before the variable name. Here
    is an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要声明引用类型，可以在变量前加上引导符号（&）。同样，要为变量添加`const`或`volatile`限定符，应在变量名之前添加`const`或`volatile`限定符。以下是一个示例：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Range-based for-loops
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于范围的for循环
- en: Range-based for-loops are another syntactic convenience introduced in C++11\.
    Range-based for-loops allow you to iterate through a sequence of values like arrays,
    containers, iterator ranges, and so on, without having to explicitly specify boundary
    conditions. It makes iterating less error-prone by obviating the need to specify
    boundary conditions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的for循环是C++11中引入的另一个语法便利。基于范围的for循环允许您遍历值的序列，如数组、容器、迭代器范围等，而无需显式指定边界条件。它通过消除了需要指定边界条件来使迭代更不容易出错。
- en: 'The general syntax for range-based for-loop is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的for循环的一般语法是：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The **sequence expression** identifies a sequence of values like an array or
    a container, that is to be iterated through. The **range declaration** identifies
    a variable that would represent each element from the sequence in successive iterations
    of the loop. Range-based for-loops automatically recognize arrays, brace-enclosed
    sequences of expressions, and containers with `begin` and `end` member functions
    that return forward iterators. To iterate through all elements in an array, you
    write this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列表达式**标识要遍历的值序列，如数组或容器。**范围声明**标识一个变量，该变量将在循环的连续迭代中代表序列中的每个元素。基于范围的for循环自动识别数组、大括号包围的表达式序列和具有返回前向迭代器的`begin`和`end`成员函数的容器。要遍历数组中的所有元素，可以这样写：'
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also iterate through a sequence of expressions enclosed in braces:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以遍历大括号括起来的表达式序列：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Iterating through elements in a container that exposes forward iterators through
    `begin` and `end` member functions is not all that different:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历通过`begin`和`end`成员函数公开前向迭代器的容器中的元素并没有太大不同：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The range expression declares a loop variable called `elem` using `auto` to
    deduce its type. This use of `auto` in range-based for-loops is idiomatic and
    common. To traverse sequences encapsulated within other kinds of objects, range-based
    for-loops require that two namespace-level methods, `begin` and `end`, be available
    and be resolved via *Argument Dependent Lookup* (see [Chapter 2](ch02.html "Chapter 2. The
    First Brush with Boost's Utilities"), *The First Brush with Boost's Utilities*).
    Range-based for-loops are great for traversing sequences whose lengths remain
    fixed during traversal.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 范围表达式使用`auto`声明了一个名为`elem`的循环变量来推断其类型。基于范围的for循环中使用`auto`的这种方式是惯用的和常见的。要遍历封装在其他类型对象中的序列，基于范围的for循环要求两个命名空间级别的方法`begin`和`end`可用，并且可以通过*参数相关查找*（见[第2章](ch02.html
    "第2章。Boost实用工具的第一次接触")，*Boost实用工具的第一次接触*）来解析。基于范围的for循环非常适合遍历在遍历期间长度保持不变的序列。
- en: Boost.Foreach
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Foreach
- en: 'You can use the `BOOST_FOREACH` macro to emulate the basic uses of C++11''s
    range-based for-loops:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`BOOST_FOREACH`宏来模拟C++11基于范围的for循环的基本用法：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding example, we use the `BOOST_FOREACH` macro to iterate through
    the elements of a vector of strings called `names`, using a loop variable called
    `name` of type `string`. Using `BOOST_FOREACH`, you can iterate over arrays, containers
    with member functions `begin` and `end` that return forward iterators, iterator
    pairs, and null-terminated character arrays. Note that C++11 range-based for-loops
    do not readily support the last two types of sequences. On the other hand, with
    `BOOST_FOREACH`, you cannot deduce the type of the loop variable using the `auto`
    keyword.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`BOOST_FOREACH`宏来遍历名为`names`的字符串向量的元素，使用名为`name`的`string`类型的循环变量。使用`BOOST_FOREACH`，您可以遍历数组、具有返回前向迭代器的成员函数`begin`和`end`的容器、迭代器对和以空字符结尾的字符数组。请注意，C++11基于范围的for循环不容易支持最后两种类型的序列。另一方面，使用`BOOST_FOREACH`，您无法使用`auto`关键字推断循环变量的类型。
- en: C++11 exception-handling improvements
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++11异常处理改进
- en: C++11 introduced the ability to capture and store an exception that can be passed
    around and rethrown later. This is particularly useful for propagating exceptions
    across threads.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了捕获和存储异常的能力，可以在稍后传递并重新抛出。这对于在线程之间传播异常特别有用。
- en: Storing and rethrowing exceptions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和重新抛出异常
- en: To store an exception, the type `std::exception_ptr` is used. `std::exception_ptr`
    is a smart pointer type with shared ownership semantics, not unlike `std::shared_ptr`
    (see [Chapter 3](ch03.html "Chapter 3. Memory Management and Exception Safety"),
    *Memory Management and Exception Safety*). An instance of `std::exception_ptr`
    is copyable and movable and can be passed to other functions potentially across
    threads. A default-constructed `std::exception_ptr` is a null object that does
    not point to any exception. Copying a `std::exception_ptr` object creates two
    instances that manage the same underlying exception object. The underlying exception
    object continues to exist as long as the last `exception_ptr` instance containing
    it exists.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储异常，使用类型`std::exception_ptr`。`std::exception_ptr`是一种具有共享所有权语义的智能指针类型，类似于`std::shared_ptr`（参见[第3章](ch03.html
    "第3章。内存管理和异常安全性")，“内存管理和异常安全性”）。`std::exception_ptr`的实例是可复制和可移动的，并且可以传递给其他函数，可能跨线程。默认构造的`std::exception_ptr`是一个空对象，不指向任何异常。复制`std::exception_ptr`对象会创建两个管理相同底层异常对象的实例。只要包含它的最后一个`exception_ptr`实例存在，底层异常对象就会继续存在。
- en: The function `std::current_exception`, when called inside a catch-block, returns
    the active exception for which the catch-block was executed, wrapped in an instance
    of `std::exception_ptr`. When called outside a catch-block, it returns a null
    `std::exception_ptr` instance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`std::current_exception`在catch块内调用时，返回执行该catch块的活动异常，包装在`std::exception_ptr`的实例中。在catch块外调用时，返回一个空的`std::exception_ptr`实例。
- en: The function `std::rethrow_exception` is passed an instance of `std::exception_ptr`
    (which must not be null) and throws the exception contained in the `std::exception_ptr`
    instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`std::rethrow_exception`接收一个`std::exception_ptr`的实例（不能为null），并抛出`std::exception_ptr`实例中包含的异常。
- en: '**Listing A.3: Using std::exception_ptr**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.3：使用std::exception_ptr**'
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the preceding example prints the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述示例会打印以下内容：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `main` function calls `do_more_work` (line 30), which in turn calls `do_work`
    (line 18), which simply throws a `runtime_error` exception (line 8) that finds
    its way down to a catch-block in `do_more_work` (line 19). We declare an object
    `eptr` of type `std::exception_ptr` in `do_more_work` (line 15) and inside the
    catch-block, we call `std::current_exception` and assign the result to `eptr`.
    Later, we create a copy of `eptr` (line 23), and push both instances into a global
    vector of `exception_ptr`s (lines 24-25).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数调用`do_more_work`（第30行），然后调用`do_work`（第18行），后者只是抛出一个`runtime_error`异常（第8行），该异常最终到达`do_more_work`（第19行）中的catch块。我们在`do_more_work`（第15行）中声明了一个类型为`std::exception_ptr`的对象`eptr`，并在catch块内调用`std::current_exception`，并将结果赋给`eptr`。稍后，我们创建了`eptr`的副本（第23行），并将两个实例推入全局`exception_ptr`向量（第24-25行）。'
- en: In the `main` function, we run through the `exception_ptr` instances in the
    global vector, throw each using `std::rethrow_exception` (line 33), catch it and
    print its message. Note that in the process, we print the message from the same
    exception twice because we have two instances of `exception_ptr` containing the
    same exception.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们遍历全局向量中的`exception_ptr`实例，使用`std::rethrow_exception`（第33行）抛出每个异常，并捕获并打印其消息。请注意，在此过程中，我们打印相同异常的消息两次，因为我们有两个包含相同异常的`exception_ptr`实例。
- en: Storing and rethrowing exception using Boost
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost存储和重新抛出异常
- en: In pre-C++11 environments, you can use the `boost::exception_ptr` type to store
    exceptions and `boost::rethrow_exception` to throw the exception stored in `boost::exception_ptr`.
    There is also the `boost::current_exception` function which works akin to `std::current_exception`.
    But without underlying language support, it requires help from the programmer
    to function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前的环境中，可以使用`boost::exception_ptr`类型来存储异常，并使用`boost::rethrow_exception`来抛出存储在`boost::exception_ptr`中的异常。还有`boost::current_exception`函数，其工作方式类似于`std::current_exception`。但是在没有底层语言支持的情况下，它需要程序员的帮助才能运行。
- en: 'In order for `boost::current_exception` to return the currently active exception
    wrapped in `boost::exception_ptr`, we must modify the exception before throwing
    it to make it amenable to be handled using this mechanism. To do this, we call
    `boost::enable_current_exception` on the exception to be thrown. The following
    snippet illustrates this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`boost::current_exception`返回当前活动的异常，包装在`boost::exception_ptr`中，我们必须修改异常，然后才能抛出它，以便使用这种机制进行处理。为此，我们在要抛出的异常上调用`boost::enable_current_exception`。以下代码片段说明了这一点：
- en: '**Listing A.4: Using boost::exception_ptr**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单A.4：使用boost::exception_ptr**'
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Self-test questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'The Rule of Three states that if you define your own destructor for a class,
    you should also define:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三大法则规定，如果为类定义自己的析构函数，则还应定义：
- en: a. Your own copy constructor
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: a. 您自己的复制构造函数
- en: b. Your own assignment operator
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: b. 您自己的赋值运算符
- en: c. Both a and b
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: c. 两者都是
- en: d. Either a or b
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: d. 两者中的任意一个
- en: 'Assuming the class `String` has both copy and move constructors, which of the
    following does not invoke a move constructor:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设类`String`既有复制构造函数又有移动构造函数，以下哪个不会调用移动构造函数：
- en: a. `String s1(getName());`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: a. `String s1(getName());`
- en: b. `String s2(s1);`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: b. `String s2(s1);`
- en: c. `String s2(std::move(s1));`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: c. `String s2(std::move(s1));`
- en: d. `String s3("Hello");`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: d. `String s3("Hello");`
- en: 'The purpose of `std::move` function is to:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::move`函数的目的是：'
- en: a. Move contents of its argument out
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: a. 移动其参数的内容
- en: b. Create an lvalue reference from an rvalue reference
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: b. 从右值引用创建左值引用
- en: c. Create an xvalue from an lvalue expression
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: c. 从左值表达式创建xvalue
- en: d. Swap contents of its argument with another object
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: d. 交换其参数的内容与另一个对象
- en: 'In which of the following cases does Return Value Optimization apply?:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种情况适用于返回值优化？：
- en: a. `return std::string("Hello");`
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: a. `return std::string("Hello");`
- en: b. `string reverse(string);string a, b;reverse(a + b);`
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: b. `string reverse(string);string a, b;reverse(a + b);`
- en: c. `std::string s("Hello");return s;`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: c. `std::string s("Hello");return s;`
- en: d. `std::string a, b;return a + b.`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: d. `std::string a, b;return a + b.`
- en: References
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*,
    *Scott Meyers*, *O''Reilly Media*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*，*Scott
    Meyers*，*O''Reilly Media*》'
- en: '*A Tour of C++*, *Bjarne Stroustrup*, *Addison Wesley Professional*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++之旅》，Bjarne Stroustrup，Addison Wesley Professional
- en: '*The C++ Programming Language (4/e)*, *Bjarne Stroustrup*, *Addison Wesley
    Professional*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++程序设计语言（第4版）》，Bjarne Stroustrup，Addison Wesley Professional
