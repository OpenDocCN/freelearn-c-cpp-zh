- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Explore Improvements Early
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 早期探索改进
- en: We’ve come a long way with the testing library and have been using TDD the entire
    time to get us here. Sometimes, it’s important to explore new ideas before a project
    gets too far. After creating anything, we’ll have insights that we didn’t have
    at the beginning. And after working with a design for a while, we’ll develop a
    feel for what we like and what we might want to change. I encourage you to take
    this time to reflect on a design before proceeding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试库方面已经取得了很大的进步，并且一直在使用TDD来达到这里。有时，在项目走得太远之前探索新想法是很重要的。在创建任何事物之后，我们将有在开始时没有的见解。并且在与设计一起工作了一段时间之后，我们将对喜欢什么以及可能想要改变什么有一个感觉。我鼓励你在继续之前花时间反思设计。
- en: We have something that is working and a bit of experience using it, so is there
    anything that we can improve?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一些正在工作的事物，并且在使用它方面有一些经验，那么我们是否可以改进些什么？
- en: This approach is like a higher-level process of TDD, as explained in [*Chapter
    3*](B18567_03.xhtml#_idTextAnchor031), *The TDD Process*. First, we work out how
    we’d like to use something, then get it built, then do the minimal amount of work
    to get it working and the tests passing, and then enhance the design. We’ve got
    many things working now, but we haven’t gone so far yet where it would be too
    hard to change. We’re going to look at ways that the overall design could be enhanced.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于TDD的高级过程，如[*第3章*](B18567_03.xhtml#_idTextAnchor031)《TDD过程》中所述。首先，我们确定我们想要如何使用某物，然后构建它，然后进行最小的工作量以使其工作并通过测试，然后增强设计。我们现在有很多事物正在工作，但我们还没有走到一个改变会变得过于困难的地步。我们将探讨如何增强整体设计的方法。
- en: 'At this point, it’s also a good idea to look around at other similar solutions
    and compare them. Get ideas. And try some new things to see whether they might
    be better. I’ve done this and would like to explore two topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，环顾四周看看其他类似解决方案并比较它们也是一个好主意。获取想法。并尝试一些新事物，看看它们是否可能更好。我已经这样做，并希望在本章中探讨两个主题：
- en: Can we use a new feature of C++ 20 to get line numbers instead of using `__LINE__`?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否使用C++ 20的新特性来获取行号，而不是使用`__LINE__`？
- en: What would the tests look like if we used lambdas?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用lambda表达式，测试看起来会是什么样子？
- en: By the end of this chapter, you’ll understand the importance of and the process
    involved in exploring improvements early on in the design of your projects. Even
    if you don’t always decide to accept new ideas and make changes, your project
    will be better because you have taken the time to consider alternatives.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解在项目设计早期探索改进的重要性和涉及的过程。即使你并不总是决定接受新想法并做出改变，但你的项目会因为你有时间考虑替代方案而变得更好。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code in this chapter uses standard C++, and we will try out a feature introduced
    in C++ 20\. The code is based on and continues from the previous chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码使用标准C++，我们将尝试C++ 20中引入的特性。代码基于并延续前几章。
- en: 'You can find all of the code for this chapter at the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个GitHub仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: Getting line numbers without macros
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无宏获取行号
- en: C++ 20 includes a new class that will help us get line numbers. In fact, it
    has a lot more information than just the line number. It includes the name of
    the file, the function name, and even the column number. However, we only need
    the line number. Note that at the time of writing this book, the implementation
    of this new class for my compiler has a bug. The end result is that I have had
    to put the code back to the way it was before the changes described in this section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 20 包含了一个新的类，它将帮助我们获取行号。实际上，它包含的信息远不止行号。它包括文件名、函数名，甚至列号。然而，我们只需要行号。请注意，在撰写本书时，这个新类在我编译器的实现中有一个错误。结果是，我不得不将代码放回到本节描述的更改之前的版本。
- en: 'The new class is called `source_location`, and once it finally works correctly,
    we can change all of the existing `confirm` functions so that they accept `std::source_location`
    instead of the int for the line number. One example of an existing `confirm` function
    looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类被称为`source_location`，一旦它最终正确工作，我们可以将所有现有的`confirm`函数更改为接受`std::source_location`而不是行号的int。一个现有的`confirm`函数的例子如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can eventually update the confirm functions to use `std::source_location`
    by changing all of the `confirm` functions, including the template override, to
    be similar to the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以通过将所有`confirm`函数，包括模板重载，改为类似以下形式来更新确认函数以使用`std::source_location`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’re not going to be making these changes right now because of the bug. The
    code does work as long as there is only a single source file in the project that
    tries to use `source_location`. The moment more than one source file tries to
    use `source_location`, there is a linker warning and the line method returns bad
    data. The bug should eventually get fixed, and I’m leaving this section in the
    book because it is a better approach. Depending on what compiler you are using,
    you might be able to start using `source_location` now.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会因为bug而进行这些更改。只要项目中只有一个源文件尝试使用`source_location`，代码就能正常工作。一旦多个源文件尝试使用`source_location`，就会产生链接器警告，并且该行方法返回错误数据。这个bug最终应该会被修复，我保留这本书中的这一部分，因为它是一个更好的方法。根据你使用的编译器，你现在可能已经开始使用`source_location`了。
- en: Not only does the last parameter type and name change, but the usage needs to
    change when the line number is passed to the exception when it’s thrown. Notice
    how the new parameter includes a default value that gets set to the current location.
    The default parameter value means we no longer need to pass anything for the line
    number. The new location will get a default value that includes the current line
    number.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅最后一个参数的类型和名称发生了变化，当抛出异常时，传递给异常的行号也需要更改。注意新参数包含一个默认值，该值被设置为当前位置。默认参数值意味着我们不再需要传递行号。新位置将获得一个包含当前行号的默认值。
- en: 'We need to include the header file for `source_location` at the top of `Test.h`,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Test.h`的顶部包含`source_location`的头文件，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The macros that call `confirm` need to be updated to no longer worry about
    the line number:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`confirm`的宏需要更新，不再需要担心行号：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once `source_location` works properly, then we won’t really need these macros
    anymore. The first two are still useful because they eliminate the need to specify
    the expected bool value. Additionally, all three are slightly useful because they
    wrap up the specification of the `MereTDD` namespace. Even though we won’t technically
    need to keep using the macros, I like to keep using them because I think that
    the all-caps names help the confirmations stand out in the tests better.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`source_location`正常工作，我们就真的不再需要这些宏了。前两个仍然有用，因为它们消除了指定预期布尔值的需求。此外，所有三个都有点有用，因为它们封装了`MereTDD`命名空间的指定。尽管从技术上讲我们不需要继续使用宏，但我喜欢继续使用它们，因为我认为全部大写字母的名称有助于使确认在测试中更加突出。
- en: This improvement would have been minor and limited to just the `confirm` functions
    and macros. So, should we still move to C++ 20 even though we can’t yet use `source_location`?
    I think so. If nothing else, this bug shows that changes are always being made
    to the standard libraries, and using the latest compiler and standard library
    is normally the best choice. Plus, there will be features we will use later in
    the book that are only found in C++20\. For example, we’ll be using the `std::map`
    class and a useful method that was added in C++20 to determine whether the map
    contains an element already. We’ll be using *concepts* in [*Chapter 12*](B18567_12.xhtml#_idTextAnchor123),
    *Creating Better Test Confirmations*, which are only found in C++20.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改进将非常小，仅限于`confirm`函数和宏。那么，即使我们目前还不能使用`source_location`，我们是否仍然应该迁移到C++ 20呢？我认为是的。至少，这个bug表明标准库总是在不断变化，通常使用最新的编译器和标准库是最好的选择。此外，书中后面将使用到的一些特性只能在C++20中找到。例如，我们将使用`std::map`类和C++20中添加的一个有用方法来确定映射是否已包含元素。我们将在[*第12章*](B18567_12.xhtml#_idTextAnchor123)“创建更好的测试确认”中使用*概念*，这些概念仅在C++20中存在。
- en: The next improvement will be a bit more involved.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个改进将更加复杂。
- en: Exploring lambdas for tests
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索测试中的lambda表达式
- en: It’s getting more and more common for developers to avoid macros in their code.
    And I agree that there is almost no need for macros anymore. With `std::source_location`
    from the previous section, one of the last reasons to use macros has been eliminated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者避免在代码中使用宏变得越来越普遍。我同意现在几乎不再需要宏。从上一节中的`std::source_location`来看，使用宏的最后一个理由已经被消除。
- en: Some companies might even have rules against using macros anywhere in their
    code. I think that’s a bit too much especially given the trouble with `std::source_location`.
    Macros still have the ability to wrap up code so that it can be inserted instead
    of the macro itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司甚至可能在其代码的任何地方都禁止使用宏。我认为这有点过分，尤其是考虑到`std::source_location`的问题。宏仍然有能力将代码封装起来，以便可以插入而不是使用宏本身。
- en: As the previous section shows, the `CONFIRM_TRUE`, `CONFIRM_FALSE`, and `CONFIRM`
    macros may no longer be absolutely necessary. I still like them. But if you don’t
    want to use them, then you don’t have to – at least once `std::source_location`
    works reliably in a large project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，`CONFIRM_TRUE`、`CONFIRM_FALSE`和`CONFIRM`宏可能不再绝对必要。我仍然喜欢它们。但如果你不想使用它们，那么你不必使用——至少在`std::source_location`在大项目中可靠工作之前。
- en: The `TEST` and `TEST_EX` macros are still needed because they wrap up the declaration
    of the derived test classes, give them unique names, and set up the code so that
    the test body can follow. The result looks like we’re declaring a simple function.
    This is the effect we want. A test should be simple to write. What we have now
    is about as simple as it gets. But the design uses macros. Is there anything we
    can do to remove the need for the `TEST` and `TEST_EX` macros?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEST`和`TEST_EX`宏仍然需要，因为它们封装了派生测试类的声明，为它们提供了独特的名称，并设置了代码，以便测试体可以跟随。结果看起来就像我们正在声明一个简单的函数。这是我们想要的效果。测试应该简单易写。我们现在拥有的几乎是最简单的了。但是，设计使用了宏。我们能否做些什么来消除对`TEST`和`TEST_EX`宏的需求？'
- en: 'Whatever changes we make, we should keep the simplicity of declaring a test
    in `Creation.cpp` so that it looks similar to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们做出什么改变，我们都应该保持`Creation.cpp`中声明测试的简单性，使其看起来类似于以下内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we really need is something that introduces a test, gives it a name, lets
    the test register itself, and then lets us write the body of the test function.
    The `TEST` macro provides this ability by hiding the declaration of a global instance
    of a class derived from the `TestBase` class. This declaration is left unfinished
    by the macro, so we can provide the body of the test function inside the curly
    braces. The other `TEST_EX` macro does something similar with the addition of
    catching the exception provided to the macro.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一种能够引入测试、给它命名、让测试注册自己，然后让我们编写测试函数体的东西。`TEST`宏通过隐藏从`TestBase`类派生的类的全局实例的声明来提供这种能力。这个声明被宏留下未完成，因此我们可以在大括号内提供测试函数体的内容。另一个`TEST_EX`宏通过捕获传递给宏的异常来做类似的事情。
- en: 'There is another way to write a function body in C++ without giving the function
    body a name. And that is to declare a *lambda*. What would a test look like if
    we stopped using the `TEST` macro and implemented the test function with a lambda
    instead? For now, let’s just focus on tests that do not expect an exception to
    be thrown. The following is what an empty test might look like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，还有一种编写函数体而不给函数体命名的方法。那就是声明一个*lambda*。如果我们停止使用`TEST`宏，并用lambda代替实现测试函数，测试会是什么样子？目前，让我们只关注那些不期望抛出异常的测试。以下是一个空测试可能的样子：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this example, I’m trying to stick to the syntax needed by C++. This assumes
    we have a class called `Test` that we want to create an instance of. In this design,
    tests would reuse the `Test` class instead of defining a new class. The `Test`
    class would override the `operator =` method to accept a lambda. We need to give
    the instance a name so that the example uses `test123`. Why `test123`? Well, any
    object instance created still needs a unique name, so I’m using a number to provide
    something unique. We would need to continue using a macro to generate a unique
    number based on the line number if we decided to use this design. So, while this
    design avoids a new derived class for each test, it creates a new lambda for each
    test instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我试图坚持C++所需的语法。这假设我们有一个名为`Test`的类，我们想要创建其实例。在这个设计中，测试将重用`Test`类而不是定义一个新的类。`Test`类将重写`operator
    =`方法以接受lambda。我们需要给实例一个名字，以便示例使用`test123`。为什么是`test123`？好吧，任何创建的对象实例仍然需要一个独特的名称，所以我使用数字来提供一些独特性。如果我们决定使用这个设计，我们可能需要继续使用宏来根据行号生成一个独特的数字。因此，虽然这个设计避免了为每个测试创建一个新的派生类，但它为每个测试创建了一个新的lambda。
- en: 'There’s a bigger problem with this idea. The code doesn’t compile. It might
    be possible to get the code to compile within a function. But as a declaration
    of a global `Test` instance, we can’t call an assignment operator. The best I
    can come up with would be to put the lambda inside the constructor as a new argument,
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法有一个更大的问题。代码无法编译。可能在函数内部将代码编译成功。但作为一个全局`Test`实例的声明，我们无法调用赋值运算符。我能想到的最好的办法是将lambda放在构造函数内部作为新的参数，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While it works for this test, it causes problems in the expected failure tests
    when we try to call the `setExpectedFailureReason` method because `setExpectedFailureReason`
    is not in scope within the lambda body. Also, we’re getting further away from
    the simple way we have now of declaring a test. The extra lambda syntax and the
    closing parenthesis and semicolon at the end make this harder to get right.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对这个测试有效，但当尝试调用`setExpectedFailureReason`方法时，它会在预期的失败测试中引起问题，因为`setExpectedFailureReason`不在lambda体内部的作用域内。此外，我们离我们现在简单声明测试的方式越来越远。额外的lambda语法以及最后的括号和分号使得正确实现这一点变得更加困难。
- en: 'I’ve seen at least one other test library that does use lambdas and appears
    to avoid the need to declare a unique name and, thereby, avoid the need for a
    macro with something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我至少看到过另一个使用lambda表达式并且似乎避免了声明唯一名称的需求的测试库，从而避免了需要使用类似以下内容的宏：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But what this actually does is call a *function* named `Test` and pass the string
    literal as an argument. Then, the function returns a temporary object that overrides
    `operator =`, which is called to accept the lambda. The only place functions can
    be called is within other functions or class methods. That means a solution like
    this needs to declare tests from within a function, and the tests cannot be declared
    globally as instances like we are doing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，这是调用一个名为`Test`的*函数*并将字符串字面量作为参数传递。然后，该函数返回一个临时对象，它覆盖了`operator=`，这是调用lambda时调用的。函数只能在其他函数或类方法内部调用。这意味着像这样需要一个解决方案需要在函数内部声明测试，并且测试不能像我们现在这样作为实例全局声明。
- en: Usually, this means you declare all your tests from within the `main` function.
    Or you declare your tests as simple functions and call those functions from within
    `main`. Either way, you end up modifying `main` to call every test function. If
    you forget to modify `main`, then your test won’t get run. We’re going to keep
    `main` simple and uncluttered. The only thing `main` will do in our solution is
    run the tests that have been registered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这意味着你需要在`main`函数内部声明所有测试。或者，你可以将测试声明为简单的函数，并在`main`函数内部调用这些函数。无论哪种方式，你最终都需要修改`main`来调用每个测试函数。如果你忘记修改`main`，那么你的测试将不会运行。我们将保持`main`简单且不杂乱。在我们的解决方案中，`main`将只执行已注册的测试。
- en: Even though lambdas won’t work for us because of the added complexity and because
    of the inability to call test methods such as `setExpectedFailureReason`, we can
    improve the current design a bit. The `TEST` and, especially, `TEST_EX` macros
    are doing work that we can remove from the macros.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于增加的复杂性和无法调用测试方法（如`setExpectedFailureReason`）等问题，lambda表达式对我们不起作用，但我们仍然可以稍微改进当前的设计。`TEST`和特别是`TEST_EX`宏正在执行我们可以从宏中移除的工作。
- en: 'Let’s start by modifying the `TestBase` class in `Test.h` so that it registers
    itself instead of doing the registration with derived classes in the macros. Also,
    we need to move the `getTests` function right before the `TestBase` class. And
    we need to forward declare the `TestBase` class since `getTests` uses a pointer
    to `TestBase`, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改`Test.h`中的`TestBase`类开始，使其注册自身而不是在宏中使用派生类进行注册。此外，我们需要将`getTests`函数移动到`TestBase`类之前。我们还需要提前声明`TestBase`类，因为`getTests`使用一个指向`TestBase`的指针，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll keep the rest of `TestBase` unchanged because it handles properties such
    as the name and whether the test passed or not. We still have derived classes,
    but the goal of this simplification is to remove any work that the `TEST` and
    `TEST_EX` macros need to perform.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持`TestBase`的其余部分不变，因为它处理诸如名称和测试是否通过等属性。我们仍然有派生类，但这个简化的目标是移除`TEST`和`TEST_EX`宏需要执行的所有工作。
- en: 'Most of the work that the `TEST` macro needs to do is to declare a derived
    class with a `run` method that will be filled in. The need to register the test
    is now handled by `TestBase`. The `TEST_EX` macro can be simplified further by
    creating another class called `TestExBase`, which will deal with the expected
    exception. Declare this new class right after `TestBase`. It looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEST`宏需要做的绝大部分工作是声明一个带有`run`方法的派生类，该方法将被填充。现在，注册测试的需求由`TestBase`处理。可以通过创建另一个名为`TestExBase`的类来进一步简化`TEST_EX`宏，该类将处理预期的异常。在`TestBase`之后立即声明这个新类。它看起来像这样：'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `TestExBase` class derives from `TestBase` and is a template class designed
    to catch the expected exception. This code is currently written into `TEST_EX`,
    and we will change `TEST_EX` to use this new base class instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestExBase`类从`TestBase`派生，是一个模板类，旨在捕获预期的异常。此代码目前写入`TEST_EX`中，我们将更改`TEST_EX`以使用这个新的基类。'
- en: 'We’re ready to simplify the `TEST` and `TEST_EX` macros. The new `TEST` macro
    looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好简化`TEST`和`TEST_EX`宏。新的`TEST`宏看起来像这样：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s slightly simpler than before. The constructor no longer needs to have code
    in the body because the registration is done in the base class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相比，这稍微简单一些。构造函数不再需要在主体中包含代码，因为注册是在基类中完成的。
- en: 'The bigger simplification is in the `TEST_EX` macro, which looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的简化在于`TEST_EX`宏，看起来像这样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s a lot simpler than before because all the exception handling is done in
    its direct base class. Notice how the macro still needs to use the `#` operator
    for `exceptionType` when constructing the instance. Additionally, notice how it
    uses `exceptionType` without the `#` operator when specifying the template type
    to derive from.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它比之前简单得多，因为所有的异常处理都在其直接基类中完成。注意，当构造实例时，宏仍然需要使用`#`运算符来指定`exceptionType`。此外，注意当指定从其派生模板类型时，它使用`exceptionType`而不使用`#`运算符。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored ways in which to improve the test library by making use
    of a new feature in C++ 20 to get line numbers from the standard library instead
    of from the preprocessor. Even though the new code doesn’t work right now, it
    will eventually make the `CONFIRM_TRUE`, `CONFIRM_FALSE`, and `CONFIRM` macros
    optional. You will no longer have to use the macros. But I still like to use them
    because they help wrap up code that is easy to get wrong. And the macros are easier
    to spot in the tests because they use all capital letters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了利用C++ 20中的新功能从标准库而不是从预处理器获取行号来改进测试库的方法。尽管新代码现在不起作用，但它最终将使`CONFIRM_TRUE`、`CONFIRM_FALSE`和`CONFIRM`宏成为可选的。您将不再需要使用这些宏。但我仍然喜欢使用它们，因为它们有助于封装容易出错代码。而且，由于它们使用全部大写字母，宏在测试中更容易被发现。
- en: We also explored a trend to avoid macros when declaring tests and what it would
    look like if we used lambdas instead. The approach almost worked with a more complicated
    test declaration. The extra complexity doesn’t matter though because the design
    did not work for all the tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了避免在声明测试时使用宏的趋势，以及如果我们使用lambda表达式会是什么样子。这种方法在更复杂的测试声明中几乎可行。然而，额外的复杂性并不重要，因为该设计并不适用于所有测试。
- en: It is still valuable for you to read about the proposed changes. You can learn
    about how other test libraries might work and understand why this book explains
    a solution that embraces macros.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读关于提议的更改仍然很有价值。您可以了解其他测试库可能的工作方式，并理解为什么这本书解释了一个采用宏的解决方案。
- en: This chapter has also shown you how to follow the TDD process at a higher level.
    The step in the process to enhance a test can be applied to an overall design.
    We were able to improve and simplify the `TEST` and `TEST_EX` macros, which makes
    all of the tests better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向您展示了如何在高层次上遵循TDD（测试驱动开发）流程。在流程中增强测试的步骤可以应用于整体设计。我们能够改进并简化了`TEST`和`TEST_EX`宏，这使得所有测试都变得更好。
- en: The next chapter will explore what will be needed to add code that will run
    before and after the tests to help get things ready for the tests and clean things
    up after the tests finish.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨在测试前后添加代码的需求，以帮助为测试做好准备并在测试完成后清理。
