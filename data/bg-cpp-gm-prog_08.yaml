- en: Chapter 8. Pointers, the Standard Template Library, and Texture Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。指针，标准模板库和纹理管理
- en: We will learn a lot, as well as get plenty done to the game in this chapter.
    We will first learn about the fundamental C++ topic of **pointers**. Pointers
    are variables that hold memory addresses. Typically, a pointer will hold the memory
    address of another variable. This sounds a bit like a reference but we will see
    how they are much more powerful. We will also use a pointer to handle an ever-expanding
    horde of zombies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学到很多，也会在游戏中完成很多工作。我们将首先学习关于**指针**的基本C++主题。指针是保存内存地址的变量。通常，指针将保存另一个变量的内存地址。这听起来有点像引用，但我们将看到它们更加强大。我们还将使用指针来处理一个不断扩大的僵尸群。
- en: We will also learn about the **Standard Template Library** (**STL**) which is
    a collection of classes that allow us to quickly and easily implement common data
    management techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习**标准模板库**（STL），这是一组允许我们快速轻松地实现常见数据管理技术的类集合。
- en: Once we understand the basics of the STL, we will be able to use that new knowledge
    to manage all the textures from the game, because if we have 1000 zombies, we
    don't really want to load a copy of a zombie graphic into the GPU for each and
    every one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了STL的基础知识，我们就能够利用这些新知识来管理游戏中的所有纹理，因为如果我们有1000个僵尸，我们实际上不希望为每一个加载一份僵尸图形到GPU中。
- en: We will also dig a little deeper into OOP and use a **static** function which
    is a function of a class that can be called without an instance of the class.
    At the same time, we will see how we can design a class to ensure that only one
    instance can ever exist. This is ideal when we need to guarantee that different
    parts of our code will use the same data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将深入研究面向对象编程，并使用静态函数，这是一个类的函数，可以在没有类实例的情况下调用。同时，我们将看到如何设计一个类，以确保只能存在一个实例。当我们需要保证代码的不同部分将使用相同的数据时，这是理想的。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下主题：
- en: Learn about pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于指针
- en: Learn about the STL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于STL
- en: Implement the `Texture Holder` class using static functions and a **singleton**
    class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态函数和**单例**类实现`Texture Holder`类
- en: Implement a pointer to a horde of zombies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个指向一群僵尸的指针
- en: Edit some existing code to use the `TextureHolder` class for the player and
    background
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑一些现有的代码，使用`TextureHolder`类为玩家和背景
- en: Pointers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: Pointers can be the cause of frustration while learning to code C++. Actually,
    however, the concept is simple.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习C++编程时，指针可能会引起挫折。但实际上，这个概念很简单。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **pointer** is a variable that holds a memory address.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针**是一个保存内存地址的变量。'
- en: That's it! Nothing there to get concerned about. What probably causes the frustration
    to beginners is the syntax, the code we use to handle pointers. With this in mind
    we will step through each part of the code for using pointers. You can then begin
    the ongoing process of mastering them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！没有什么需要担心的。对初学者可能引起挫折的是语法，我们用来处理指针的代码。考虑到这一点，我们将逐步介绍使用指针的代码的每个部分。然后你可以开始不断地掌握它们。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this section, we will actually learn more about pointers than we need for
    this project. In the next project, we will make greater use of pointers. Despite
    this, we will only scratch the surface of the topic. Further study is definitely
    recommended and we will talk more about that in the final chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们实际上会学到比这个项目需要的更多关于指针。在下一个项目中，我们将更多地使用指针。尽管如此，我们只是浅尝辄止。强烈建议进一步学习，我们将在最后一章更多地谈论这个问题。
- en: Rarely do I suggest that memorizing facts, figures, or syntax is the best way
    to learn. However, memorizing the fairly brief but crucial syntax related to pointers
    might be worthwhile. This is so that it sinks so deep into our brains we can never
    forget it. We can then talk about why we need pointers and examine their relationship
    to references. A pointer analogy might help.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少建议记忆事实、数字或语法是学习的最佳方式。然而，记忆与指针相关的相当简短但至关重要的语法可能是值得的。这样它就会深深地扎根在我们的大脑中，我们永远不会忘记它。然后我们可以讨论为什么我们需要指针，并研究它们与引用的关系。指针的类比可能会有所帮助。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If a variable is a house and its contents are the value it holds, then a pointer
    is the address of the house.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量就像一座房子，它的内容就是它所持有的值，那么指针就是房子的地址。
- en: We learned in the previous chapter while discussing references that when we
    pass values to, or return values from, a function, we are actually making a completely
    new house the exact same as the previous one. We are making a copy of the value
    passed to or from a function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中学到，当我们将值传递给函数，或者从函数返回值时，实际上是在制作一个完全与之前相同的新房子。我们正在复制传递给函数或从函数返回的值。
- en: At this point, pointers are probably starting to sound a bit like references.
    That's because they are a bit like references. Pointers, however, are much more
    flexible, powerful, and have their own special and unique uses. These special
    and unique uses require a special and unique syntax.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，指针可能开始听起来有点像引用。那是因为它们有点像引用。然而，指针更加灵活、强大，并且有它们自己特殊和独特的用途。这些特殊和独特的用途需要特殊和独特的语法。
- en: Pointer syntax
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针语法
- en: 'There are two main operators associated with pointers. The first is the **address
    of** operator:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针相关的主要运算符有两个。第一个是**取地址**运算符：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And the second is the **dereference** operator:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是**解引用**运算符：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will take a look now at the different ways we use these operators with pointers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下我们如何使用这些运算符与指针。
- en: 'The first thing you will notice is that the address of operator is the same
    as the reference operator. To add to the woes of an aspiring C++ game programmer,
    the operators do different things in different contexts. Knowing this from the
    outset is valuable. If you are staring at some code involving pointers and it
    seems like you are going mad, know this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的第一件事是地址运算符与引用运算符相同。为了增加一个渴望成为C++游戏程序员的人的困境，这两个运算符在不同的上下文中做不同的事情。从一开始就知道这一点是很有价值的。如果你盯着一些涉及指针的代码看，感觉自己要发疯，知道这一点：
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You are perfectly sane! You just need to look at the detail of the context.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你是完全理智的！你只需要看看上下文的细节。
- en: Now you know that if something isn't clear and immediately obvious it is not
    your fault. Pointers are not clear and immediately obvious, but looking carefully
    at the context will reveal what is going on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道，如果有什么东西不清楚和立即明显，那不是你的错。指针不是清晰和立即明显的，但仔细观察上下文会揭示发生了什么。
- en: Armed with the knowledge that you need to pay more attention to pointers than
    to previous syntax, as well as what the two operators are (address of and dereference),
    we can now start to actually see some real pointer code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识，你需要比以前的语法更加关注指针，以及这两个运算符是什么（地址运算符和解引用），我们现在可以开始看一些真正的指针代码了。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure you have memorized the two operators before proceeding.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在继续之前已经记住了这两个运算符。
- en: Declaring a pointer
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明指针
- en: 'To declare a new pointer, we use the dereference operator along with the type
    of variable the pointer will be holding the address of. Take a look at the code
    and we will go into it some more:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个新的指针，我们使用解引用运算符以及指针将要保存的变量的类型。看一下代码，我们将进一步讨论它：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code declares a new pointer called `pHealth` that can hold the address
    of a variable of type `int`. Notice I said can hold a variable of type `int`.
    As with other variables a pointer also needs to be initialized with a value to
    make proper use of it. The name `pHealth` as with other variables is arbitrary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了一个名为`pHealth`的新指针，可以保存`int`类型变量的地址。请注意，我说的是可以保存`int`类型的变量。与其他变量一样，指针也需要初始化一个值才能正确使用它。与其他变量一样，名称`pHealth`是任意的。
- en: It is common practice to prefix the names of variables that are pointers with
    a `p`. It is then much easier to remember when we are dealing with a pointer and
    to distinguish them from regular variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常习惯上，将指针的名称前缀为`p`。这样在处理指针时更容易记住，并且可以将它们与常规变量区分开来。
- en: The white space used around the dereference operator is optional (because C++
    rarely cares about spaces in syntax), but recommended because it aids readability.
    Take a look at the following three lines of code, which do exactly the same thing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符周围使用的空格是可选的（因为C++在语法上很少关心空格），但建议使用，因为它有助于可读性。看一下以下三行代码，它们做的事情完全相同。
- en: 'This format we have just seen, in the previous example, with the dereference
    operator next to the type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在前面的例子中看到的格式，带有解引用运算符紧挨着类型：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'White space either side of the dereference operator:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符两侧的空格是可选的。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The dereference operator next to the name of the pointer:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符紧挨着指针的名称：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth being aware of these possibilities so that when you read code, perhaps
    on the Web, you will understand they are all the same. In this book, we will always
    use the first option with the dereference operator next to the type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些可能性是值得的，这样当你阅读代码时，也许在网上，你会明白它们都是一样的。在本书中，我们将始终使用与类型紧挨着的解引用运算符的第一个选项。
- en: Just like a regular variable can only successfully contain data of the appropriate
    type, a pointer should only hold the address of a variable of the appropriate
    type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规变量只能成功地包含适当类型的数据一样，指针也应该只保存适当类型的变量的地址。
- en: A pointer to type `int` should not hold the address of a String, Zombie, Player,
    Sprite, float, or any other type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 指向`int`类型的指针不应该保存String、Zombie、Player、Sprite、float或任何其他类型的地址。
- en: Initializing a pointer
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化指针
- en: 'Next we can see how to get the address of a variable into a pointer. Take a
    look at the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以看到如何将变量的地址存入指针中。看一下以下代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code, we declare an `int` variable called `health` and initialize
    it to `5`. It makes sense, although we have never discussed it before, that this
    variable must be somewhere in our computer's memory. It must have a memory address.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为`health`的`int`变量，并将其初始化为`5`。尽管我们以前从未讨论过，但这个变量必须在计算机内存中的某个地方。它必须有一个内存地址。
- en: 'We can access this address using the address of operator. Look closely at the
    last line of the previous code. We initialize `pHealth` with the address of `health`,
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用地址运算符访问这个地址。仔细看前面代码的最后一行。我们用`health`的地址初始化了`pHealth`，就像这样：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `pHealth`, now holds the address of the regular `int`, `health`. In C++
    terminology we say that `pHealth` points to health.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`pHealth`现在保存了常规`int`变量`health`的地址。在C++术语中，我们说`pHealth`指向health。
- en: We can use `pHealth` by passing it to a function, so that function can work
    on `health`, just like we did with references. There would be no reason for pointers
    if that was all we were going to do with them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`pHealth`传递给一个函数来使用它，这样函数就可以处理`health`，就像我们用引用一样。如果我们只是这样做，指针就没有存在的理由了。
- en: Reinitializing pointers
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新初始化指针
- en: 'A pointer, unlike a reference, can be reinitialized to point to a different
    address. Take a look at the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 指针，不像引用，可以重新初始化以指向不同的地址。看一下以下代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now `pHealth` points to the `int` variable, `score`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`pHealth`指向`int`变量`score`。
- en: Of course the name of our pointer, `pHealth`, is now slightly ambiguous and
    should perhaps have been called `pIntPointer`. The key thing to understand here
    is that we can do this reassignment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的指针名称`pHealth`现在有点模糊，可能应该被称为`pIntPointer`。在这里要理解的关键是我们可以进行这种重新赋值。
- en: At this stage we haven't actually used a pointer for anything other than simply
    pointing (holding a memory address). Let's see how we can access the value stored
    at the address pointed to by a pointer. This will make them genuinely useful.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上还没有使用指针来做任何其他事情，而只是简单地指向（保存内存地址）。 让我们看看如何访问指针指向的地址存储的值。 这将使它们真正有用。
- en: Dereferencing a pointer
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解引用指针
- en: 'So we know that a pointer holds an address in memory. If we were to output
    this address in our game, perhaps in our HUD, after it has been declared and initialized,
    it might look something like this: `9876`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道指针保存内存中的地址。 如果我们在游戏中输出这个地址，也许在我们的HUD中，声明并初始化后，它可能看起来像这样：`9876`。
- en: It is just a value. A value that represents an address in memory. On different
    operating systems and hardware types, the range of these values will vary. In
    the context of this book we never need to manipulate an address directly. We only
    care what the value stored at the address that is pointed to is.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个值。 一个代表内存中地址的值。 在不同的操作系统和硬件类型上，这些值的范围会有所不同。 在本书的上下文中，我们从不需要直接操作地址。 我们只关心指向的地址存储的值是什么。
- en: The actual addresses used by variables are determined when the game is executed
    (at run-time) and therefore, there is no way of knowing the address of a variable
    and hence the value stored in a pointer, while we are coding the game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 变量使用的实际地址是在游戏执行时（在运行时）确定的，因此，在编写游戏时，无法知道变量的地址以及指针中存储的值。
- en: We access the value stored at the address pointed to by a pointer by using the
    dereference operator, `*`. The following code manipulates some variables directly,
    and by using a pointer. Try and follow along and then we will go through it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用解引用运算符`*`访问指针指向的地址存储的值。 以下代码直接操作了一些变量，并使用了指针。 试着跟着走，然后我们会解释一下。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Warning! The code that follows is pointless (pun intended). It just demonstrates
    using pointers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！ 接下来的代码毫无意义（有点刻意）。 它只是演示使用指针。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code, we declare two int variables, `score` and `hiScore`. We
    then initialize them with the values zero and ten respectively. We next declare
    two pointers to `int`. They are `pIntPointer1` and `pIntPointer2`. We initialize
    them in the same step as declaring them to hold the addresses of (point to) the
    variables `score` and `hiScore` respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了两个int变量，`score`和`hiScore`。 然后我们分别用零和十初始化它们。 接下来，我们声明了两个指向`int`的指针。
    它们是`pIntPointer1`和`pIntPointer2`。 我们在声明它们的同时初始化它们，以保存（指向）变量`score`和`hiScore`的地址。
- en: 'Next we add ten to `score` in the usual way, `score += 10`. Then we see that
    by using the dereference operator on a pointer we can access the value stored
    at the address they point to. The following code actually changed the value stored
    by the variable pointed to by `pIntPointer1`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以通常的方式给`score`加上十分，`score += 10`。 然后我们看到，通过在指针上使用解引用运算符，我们可以访问指向的地址存储的值。
    以下代码实际上改变了由`pIntPointer1`指向的变量存储的值：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last part of the previous code dereferences both of the pointers to assign
    the value pointed to by `pIntPointer1` as the value pointed to by `pIntPointer2`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的最后一部分解引用了两个指针，将`pIntPointer1`指向的值分配为`pIntPointer2`指向的值：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both `score` and `hiScore` are now equal to `20`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`和`hiScore`现在都等于`20`。'
- en: Pointers are versatile and powerful
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针是多才多艺且强大的
- en: We can do so much more with pointers. Here are just a few useful things we can
    do.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用指针做更多的事情。 以下是一些有用的事情。
- en: Dynamically allocated memory
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态分配的内存
- en: All the pointers we have seen so far point to memory addresses that have a scope
    limited only to the function they are created in. So if we declare and initialize
    a pointer to a local variable, when the function returns, the pointer, the local
    variable, and the memory address is gone. It is out of scope.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有指针都指向作用域仅限于它们创建的函数的内存地址。 因此，如果我们声明并初始化一个指向局部变量的指针，当函数返回时，指针、局部变量和内存地址都会消失。
    它超出了作用域。
- en: Up until now we have been using a fixed amount of memory that is decided in
    advance of the game being executed. Furthermore, the memory we have been using
    is controlled by the operating system and variables are lost and created as we
    call and return from functions. What we need is a way to use memory that is always
    in scope, until we are finished with it. We want to have access to memory we can
    call our own and take responsibility for.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用预先决定的固定内存量。 此外，我们一直在使用的内存由操作系统控制，变量在我们调用和返回函数时会丢失和创建。 我们需要的是一种使用始终在作用域内的内存的方法，直到我们完成为止。
    我们希望拥有可以自己调用并负责的内存。
- en: When we declare variables (including pointers), they are in an area of memory
    known as the **stack**. There is another area of memory, which although allocated/controlled
    by the operating system, can be allocated at runtime. This other area of memory
    is called the **free store** or sometimes the **heap**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明变量（包括指针）时，它们位于称为**堆栈**的内存区域中。 还有另一个内存区域，尽管由操作系统分配/控制，但可以在运行时分配。 这另一个内存区域称为**自由存储**，有时也称为**堆**。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Memory on the heap does not have scope to a particular function. Returning from
    a function does not delete the memory on the heap.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 堆上的内存没有特定函数的作用域。 从函数返回不会删除堆上的内存。
- en: This gives us great power. With access to memory that is only limited by the
    resources of the computer our game is running on, we can plan games with a huge
    amount of objects. In our case we want a vast horde of zombies. As Spider-man's
    uncle wouldn't hesitate to remind us, however, *with great power comes great responsibility*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们很大的力量。 通过访问计算机运行游戏的资源所限制的内存，我们可以规划具有大量对象的游戏。 在我们的情况下，我们想要一个庞大的僵尸群。 然而，正如蜘蛛侠的叔叔会毫不犹豫地提醒我们的那样，*伴随着巨大的力量而来的是巨大的责任*。
- en: Let's look at how we can use pointers to take advantage of the memory on the
    free store and also how we release that memory back to the operating system when
    we are finished with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用指针来利用自由存储器上的内存，以及在完成后如何将该内存释放回操作系统。
- en: 'To create a pointer that points to a value on the heap, first we need a pointer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个指向堆上值的指针，首先我们需要一个指针：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous line of code, we declare a pointer as we have seen before, but
    as we are not initializing it to point to a variable, we initialize it to `nullptr`.
    We do this because it is good practice. Consider dereferencing a pointer (changing
    a value at the address it points to) when you don't even know what it is pointing
    to. It would be the programming equivalent of going to the shooting range, blindfolding
    someone, spinning them around, and telling them to shoot. By pointing a pointer
    to nothing (`nullptr`) we can't do any harm with it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们声明了一个指针，就像我们以前看到的那样，但是由于我们没有将其初始化为指向一个变量，而是将其初始化为`nullptr`。我们这样做是因为这是一个好习惯。考虑解引用一个指针（更改它指向的地址的值），当你甚至不知道它指向什么时。这将是编程等同于去射击场，蒙住某人的眼睛，让他转个圈，然后告诉他射击。通过将指针指向空（`nullptr`），我们不会对其造成任何伤害。
- en: 'When we are ready to request memory on the free store we use the new keyword
    as shown in the following line of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备在自由存储器上请求内存时，我们使用`new`关键字，如下面的代码行所示：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The pointer `pToInt` now holds the memory address of space on the free store
    that is just the right size to hold an `int` value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 指针`pToInt`现在保存了在自由存储器上的内存地址，该内存大小刚好可以容纳一个`int`值。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Any allocated memory is returned when the program ends. It is, however, important
    to realize that this memory will never be freed (within the execution of our game),
    unless we free it. If we continue to take memory from the free store without giving
    it back, eventually it will run out and the game will crash.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分配的内存在程序结束时都会被返回。然而，重要的是要意识到，除非我们释放它，否则这段内存永远不会被释放（在我们的游戏执行中）。如果我们继续从自由存储器中获取内存而不归还，最终它将耗尽并且游戏会崩溃。
- en: It is unlikely that we would ever run out of memory by occasionally taking `int`
    sized chunks of the free store. But if our program has a function or loop that
    requests memory, and this function or loop is executed regularly throughout the
    game, eventually the game will slow and then crash. Furthermore, if we allocate
    lots of objects on the free store and don't manage them correctly, then this situation
    can happen quite quickly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不太可能因为偶尔从自由存储器中获取`int`大小的内存块而耗尽内存。但是，如果我们的程序有一个频繁执行请求内存的函数或循环，最终游戏将变慢然后崩溃。此外，如果我们在自由存储器上分配了大量对象并且没有正确管理它们，那么这种情况可能会很快发生。
- en: 'The following line of code, hands back (deletes) the memory on the free store
    that was previously pointed to by `pToInt`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行，将之前由`pToInt`指向的自由存储器上的内存返回（删除）：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the memory that was previously pointed to by `pToInt` is no longer ours
    to do what we like with, we must make take precautions. Although the memory has
    been handed back to the operating system, `pToInt` still holds the address of
    this memory, which no longer belongs to us.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，之前由`pToInt`指向的内存不再属于我们，我们必须采取预防措施。尽管内存已经返回给操作系统，但`pToInt`仍然保存着这段内存的地址，这段内存不再属于我们。
- en: 'The following line of code ensures that `pToInt` can''t be used to attempt
    to manipulate or access this memory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行确保`pToInt`不能用于尝试操作或访问这段内存：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If a pointer points to an address that is invalid it is called a **wild** or
    **dangling** pointer. If you attempt to dereference a dangling pointer, if you
    are lucky the game will crash and you will get a memory access violation error.
    If you are unlucky you will create a bug that will be incredibly difficult to
    find. Furthermore, if we use memory on the free store that will persist beyond
    the life of a function, we must make sure to keep a pointer to it or we will have
    leaked memory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指针指向的地址无效，则称为**野指针**或**悬空指针**。如果您尝试对悬空指针进行解引用，如果幸运的话，游戏会崩溃，并且会收到内存访问违规错误。如果不幸的话，您将创建一个非常难以找到的错误。此外，如果我们使用自由存储器上的内存超出函数生命周期，我们必须确保保留指向它的指针，否则我们将泄漏内存。
- en: Now we can declare pointers and point them to newly allocated memory on the
    free store. We can manipulate and access the memory they point to by dereferencing
    them. We can return memory to the free store when we are done with it and we know
    how to avoid having a dangling pointer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明指针并将它们指向自由存储器上新分配的内存。我们可以通过对它们进行解引用来操作和访问它们指向的内存。当我们完成后，我们可以将内存返回到自由存储器，并且我们知道如何避免悬空指针。
- en: Let's look at some more advantages of pointers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看指针的一些更多优势。
- en: Passing a pointer to a function
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将指针传递给函数
- en: 'First we would need to write a function that has a pointer in the signature,
    like the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编写一个具有指针在签名中的函数，如下面的代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous function simply dereferences the pointer and adds one to the value
    stored at the pointed address.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数只是对指针进行解引用，并将存储在指定地址的值加一。
- en: 'Now we can use that function and pass the address of a variable or another
    pointer to a variable explicitly:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用该函数，并显式地传递一个变量的地址或另一个指向变量的指针：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, as shown in the previous code, within the function we are actually manipulating
    the variable from the calling code and can do so using the address of a variable
    or a pointer to that variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如前面的代码所示，在函数内部，我们实际上正在操作来自调用代码的变量，并且可以使用变量的地址或指向该变量的指针来这样做。
- en: Declaring and using a pointer to an object
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明并使用指向对象的指针
- en: 'Pointers are not just for regular variables. We can also declare pointers to
    user-defined types like our classes. This is how we would declare a pointer to
    an object of type `Player`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 指针不仅适用于常规变量。我们还可以声明指向用户定义类型（如我们的类）的指针。这是我们声明指向类型为`Player`的对象的指针的方法：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can even access the member functions of a `Player` object directly from
    the pointer, like the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以直接从指针访问`Player`对象的成员函数，就像下面的代码一样：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We won't need to use pointers to objects in this project and we will explore
    them more carefully before we do, in the next project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不需要使用指向对象的指针，我们将在下一个项目中更加仔细地探讨它们。
- en: Pointers and arrays
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针和数组
- en: Arrays and pointers have something in common. An array name is a memory address.
    More specifically the name of an array is the memory address of the first element
    in that array. To put, yet another way, an array name points to the first element
    of an array. The best way to understand this is to read on to see the next example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和指针有一些共同之处。数组名是一个内存地址。更具体地说，数组的名称是数组中第一个元素的内存地址。换句话说，数组名指向数组的第一个元素。理解这一点的最好方法是继续阅读，看下一个例子。
- en: 'We can create a pointer to the type that an array holds and then use the pointer
    in exactly the same way using exactly the same syntax that we would the array:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个指向数组保存的类型的指针，然后使用指针以与我们使用数组完全相同的方式使用相同的语法：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This also means that a function that has a prototype that accepts a pointer,
    also accepts arrays of the type the pointer is pointing to. We will use this fact
    when we build our ever-increasing horde of zombies.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着一个具有接受指针原型的函数也接受指针指向的类型的数组。当我们建立我们不断增加的僵尸群时，我们将利用这一事实。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Regarding the relationship between pointers and references, the compiler actually
    uses pointers when implementing our references. This means that references are
    just a handy tool (that uses pointers under the hood). You could think of a reference
    as an automatic gearbox that is fine and convenient for driving around town, whereas
    pointers are a manual gearbox, more complicated but with the correct use, gives
    better results/performance/flexibility.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于指针和引用之间的关系，编译器在实现我们的引用时实际上使用指针。这意味着引用只是一个方便的工具（在幕后使用指针）。你可以把引用看作是一种自动变速箱，适合在城里开车，而指针是一种手动变速箱，更复杂，但正确使用时能够获得更好的结果/性能/灵活性。
- en: Summary of pointers
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针总结
- en: 'Pointers are a bit fiddly at times. In fact, our discussion of pointers was
    only an introduction to the subject. The only way to get comfortable with them
    is to use them as much as possible. All you need to understand about pointers
    in order to complete this project is the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 指针有时有点棘手。事实上，我们对指针的讨论只是对这个主题的一个介绍。要想熟练掌握它们，唯一的方法就是尽可能多地使用它们。在完成这个项目时，你需要理解关于指针的以下内容：
- en: Pointers are variables that store a memory address.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针是存储内存地址的变量。
- en: We can pass pointers to functions to directly manipulate values from the calling
    function's scope, within the called function. Arrays are the memory address of
    the first element. We can pass this address as a pointer because that is exactly
    what it is.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将指针传递给函数，直接从调用函数的范围内调用函数中操作值。数组是第一个元素的内存地址。我们可以将这个地址作为指针传递，因为这正是它的作用。
- en: We can use pointers to point to memory on the free store. This means we can
    dynamically allocate large amounts of memory while the game is running.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用指针指向自由存储器上的内存。这意味着我们可以在游戏运行时动态分配大量内存。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To further mystify the issue of pointers, C++ got upgraded fairly recently.
    There are now yet more ways to use pointers. We will learn a little about smart
    pointers in the final chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步使指针的问题变得神秘，C++最近进行了升级。现在有更多的方法来使用指针。我们将在最后一章学习一些关于智能指针的知识。
- en: There is just one more topic to cover and we can get coding the Zombie Arena
    project again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个主题要讨论，然后我们可以再次开始编写僵尸竞技场项目。
- en: The Standard Template Library
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准模板库
- en: The STL is a collection of data containers and ways to manipulate the data we
    put in those containers. Or to be more specific, it is a way to store and manipulate
    different types of C++ variables and classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: STL是一组数据容器和操作我们放入这些容器中的数据的方法。更具体地说，它是一种存储和操作不同类型的C++变量和类的方法。
- en: We can think of the different containers as customized and more advanced arrays.
    The STL is part of C++. It is not an optional thing that needs to be set up, such
    as SFML.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将不同的容器视为定制和更高级的数组。STL是C++的一部分。它不是一个可选的需要设置的东西，比如SFML。
- en: The STL is part of C++ because its containers and the code that manipulates
    them is fundamental to many types of code that many apps will need to use.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: STL是C++的一部分，因为它的容器和操作它们的代码对许多应用程序需要使用的许多类型的代码至关重要。
- en: In short, the STL implements code that we and just about every C++ programmer
    is almost bound to need, at least at some point and probably quite regularly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，STL实现了我们和几乎每个C++程序员几乎肯定需要的代码，至少在某个时候可能会经常需要。
- en: If we were to write our own code to contain and manage our data, then it is
    unlikely we would write it as efficiently as the people who wrote the STL.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要编写自己的代码来包含和管理我们的数据，那么我们不太可能像编写STL的人那样高效地编写它。
- en: So by using the STL we guarantee that we are using the best-written code possible
    to manage our data. Even SFML uses the STL. For example, under the hood, the `VertexArray`
    class uses the STL.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用STL，我们保证使用最佳编写的代码来管理我们的数据。甚至SFML也使用STL。例如，在幕后，`VertexArray`类使用STL。
- en: 'All we need to do is to choose the right type of container from those that
    are available. The types of container that are available through the STL include
    the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是从可用的容器中选择正确的类型。通过STL可用的容器类型包括以下内容：
- en: '**Vector**: Like an array with boosters. Dynamic resizing, sorting, and searching.
    This is probably the most useful container.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量**：就像一个带有助推器的数组。动态调整大小，排序和搜索。这可能是最有用的容器。'
- en: '**List**: A container that allows the ordering of data.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：允许对数据进行排序的容器。'
- en: '**Map**: An associative container that allows the user to store data as key/value
    pairs. This is where one piece of data is the key to finding the other piece.
    A Map can also grow and shrink, as well as be searched.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Map**：一种允许用户将数据存储为键/值对的关联容器。这是一种数据是查找另一种数据的关键的地方。地图也可以增长和缩小，以及进行搜索。'
- en: '**Set**: A container that guarantees that each and every element is unique.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Set**：一个容器，保证每个元素都是唯一的。'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a full list of STL container types and explanations, visit the following
    link: [http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm](http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有关STL容器类型和解释的完整列表，请访问以下链接：[http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm](http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm)
- en: In the Zombie Arena game, we will use a Map.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在僵尸竞技场游戏中，我们将使用地图。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want a glimpse into the kind of complexity that the STL is sparing us,
    then take a look at this tutorial which implements the kind of thing that a list
    would do. Note that the tutorial implements only the very simplest barebones of
    a list: [http://www.sanfoundry.com/cpp-program-implement-single-linked-list/](http://www.sanfoundry.com/cpp-program-implement-single-linked-list/).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想一窥STL为我们节省的复杂性，那么请看一下这个教程，该教程实现了列表将要做的事情。请注意，该教程仅实现了列表的最简单的基本功能：[http://www.sanfoundry.com/cpp-program-implement-single-linked-list/](http://www.sanfoundry.com/cpp-program-implement-single-linked-list/)。
- en: We can easily see that we will save a lot of time and definitely end up with
    a better game if we explore the STL. Let's take a closer look at how to use Map
    and then we will see how it will be useful to us in the Zombie Arena game.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看到，如果我们探索STL，我们将节省大量时间，并且最终会得到一个更好的游戏。让我们更仔细地看看如何使用Map，然后我们将看到它在僵尸竞技场游戏中对我们有多有用。
- en: What is a Map
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是地图
- en: A **Map** is a container that is dynamically resizable. We can add and remove
    elements with ease. What makes a Map special compared to the other containers
    in the STL is the way that we access the data within it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Map**是一个动态可调整大小的容器。我们可以轻松地添加和删除元素。与STL中的其他容器相比，地图的特殊之处在于我们访问其中的数据的方式。'
- en: The data in a Map is stored in pairs. Consider the situation where you log in
    to an account, perhaps with a username and password. A Map would be perfect for
    looking up the username and then checking the value of the associated password.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 地图中的数据是成对存储的。考虑这样一种情况，您登录到一个帐户，可能使用用户名和密码。地图非常适合查找用户名，然后检查相关密码的值。
- en: A Map would also be just right for things like account names and numbers or
    perhaps company names and share prices.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 地图也可以用于诸如帐户名称和数字，或者公司名称和股价等事物。
- en: Note that when we use Map from the STL, we decide the type of values that form
    the key-value pairs. The values could be data types such as `string` and `int`,
    such as account numbers, strings such as usernames and passwords, or user-defined
    types like objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们使用STL中的Map时，我们决定形成键值对的值的类型。这些值可以是数据类型，如string和int，例如帐户号码，用户名和密码等字符串，或者用户定义的类型，如对象。
- en: What follows is some real code to make us familiar with Map.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些真实的代码，让我们熟悉地图。
- en: Declaring a Map
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明地图
- en: 'This is how we could declare a Map:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何声明一个Map的方式：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous line of code declares a new `map` called `accounts` that has a
    key of String objects, each of which will refer to a value that is int.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行代码声明了一个名为“accounts”的新“map”，它具有String对象的键，每个键将引用一个int值。
- en: We can now store key-value-pairs of Strings that refer to data type such as
    `int` and we will see how next.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以存储字符串到数据类型（如int）的键值对，接下来我们将看到如何做到这一点。
- en: Adding data to a Map
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向地图中添加数据
- en: 'Let''s go ahead and add a key-value pair to accounts:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向帐户添加键值对：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now there is an entry in the `map` that can be accessed using the key of John.
    The following code adds two more entries to the accounts `map`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个可以使用John作为键访问的地图条目。以下代码向帐户“map”添加了另外两个条目：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our Map has three entries in it. Let's see how we can access the account numbers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地图中有三个条目。让我们看看如何访问帐户号码。
- en: Finding data in a Map
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在地图中查找数据
- en: 'We would access the data in exactly the same way that we added it, by using
    the key. As an example, we could assign the value stored by the key `Onkar` to
    a new `int`, `accountNumber`, like this code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问数据的方式与添加数据的方式完全相同，即使用键。例如，我们可以将键“Onkar”存储的值赋给一个新的int“accountNumber”，就像这样的代码：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The int variable `accountNumber` now stores the value `7654321`. We can do anything
    to a value stored in a Map that we can do to that type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: int变量“accountNumber”现在存储值“7654321”。我们可以对存储在地图中的值做任何我们可以对该类型的值做的事情。
- en: Removing data from a Map
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从地图中删除数据
- en: 'Taking values out of our Map is also straightforward. This next line of code
    removes the key, `John`, and its associated value:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的地图中取值也很简单。下一行代码删除了键“John”及其关联的值：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's look at a few more things we can do with a Map.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用Map做些什么。
- en: Checking the size of a Map
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查地图的大小
- en: 'We might like to know how many key-value pairs we have in our Map. This next
    line of code does just that:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想知道我们的地图中有多少键值对。下一行代码就是这样做的：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The int variable size now holds the value of two. This is because accounts holds
    values for `Onkar` and Wilson, we deleted John.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，int变量size保存的值是2。这是因为accounts保存了“Onkar”和Wilson的值，我们删除了John。
- en: Checking for keys in a Map
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查地图中的键
- en: 'The most relevant feature of a Map is the ability to find a value using the
    key. We can test for the presence or otherwise of a specific key like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 地图最相关的特性是使用键查找值的能力。我们可以这样测试特定键的存在与否：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous code, the value `!= accounts.end` is used to determine when
    a key doesn't exist or does exist. If the searched for key is not present in the
    Map, then `accounts.end` will be the result of the `if` statement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，“！= accounts.end”用于确定键是否存在或不存在。如果搜索的键在地图中不存在，那么“accounts.end”将成为“if”语句的结果。
- en: Looping/iterating through the key-value pairs of a Map
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环/迭代地图的键值对
- en: We have seen how we can use a `forloop` to loop/iterate through all the values
    of an array. What if we want to do something similar to a Map?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`for`循环来循环/迭代数组的所有值。如果我们想对Map做类似的事情怎么办？
- en: 'The following code shows how we could loop through each key-value pair of the
    accounts Map and add one to each of the account numbers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们如何循环遍历accounts Map的每个键值对，并为每个帐户号码加一：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The condition of the for loop is probably the most interesting part of the previous
    code. The first part of the condition is the longest part. The `map<string,int>::iterator
    it = accounts.begin()` code is more understandable if we break it down.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: for循环的条件可能是前面代码中最有趣的部分。条件的第一部分是最长的部分。如果我们把`map<string,int>::iterator it = accounts.begin()`代码分解开来，它会更容易理解。
- en: The `map<string,int>::iterator` code is a type. We are declaring an `iterator`
    suitable for a `map` with key-value pairs of `string` and `int`. The iterators,
    name is `it`. We assign the value returned from `accounts.begin()` to `it`. The
    iterator `it` now holds the first key-value-pair in the accounts `map`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`map<string,int>::iterator`代码是一种类型。我们声明了一个适用于具有`string`和`int`键值对的`map`的`iterator`。迭代器的名称是`it`。我们将从`accounts.begin()`返回的值赋给`it`。迭代器`it`现在保存了`map`中的第一个键值对。'
- en: The rest of the condition of the `for` loop works as follows. The code `it !=
    accounts.end()` means the loop will continue until the end of the `map` is reached
    and `it++` simply steps to the next key-value-pair in the `map`, each pass through
    the loop.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的条件的其余部分工作如下。代码`it != accounts.end()`表示循环将继续直到达到`map`的末尾，`it++`只是在循环中每次通过时步进到下一个键值对。'
- en: Inside the for loop, `it->second` accesses the second element of the key-value
    pair and `+=1` adds one to the value. Note that we can access the key (which is
    the first part of the key-value pair) with `it->first`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内，`it->second`访问键值对的第二个元素，`+=1`将值加一。请注意，我们可以使用`it->first`访问键（它是键值对的第一部分）。
- en: The auto keyword
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: auto关键字
- en: 'The code in the condition of the for loop was quite verbose, especially the
    `map<string,int>::iterator` type. C++ supplies a neat way to reduce verbosity
    with the `auto` keyword. Using the `auto` keyword, we could improve the previous
    code to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的条件中的代码相当冗长，特别是`map<string,int>::iterator`类型。C++提供了一种简洁的方法来减少冗长，即使用`auto`关键字。使用`auto`关键字，我们可以改进前面的代码如下：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The auto keyword instructs the compiler to automatically deduce the type for
    us. This will be especially useful with the next class that we write.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: auto关键字指示编译器自动为我们推断类型。这将在我们编写的下一个类中特别有用。
- en: STL summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL摘要
- en: As with almost every C++ concept that we have covered in this book, the STL
    is a massive topic. Whole books have been written covering just the STL. At this
    point, however, we know enough to build a class that uses an STL Map to store
    SFML `Texture` objects. We can then have textures that can be retrieved/loaded
    by using the filename as the key of the key-value pair.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中涵盖的几乎每个C++概念一样，STL是一个庞大的主题。已经有整整一本书专门讨论STL。然而，到目前为止，我们已经了解到足够的知识来构建一个使用STL
    Map来存储SFML `Texture`对象的类。然后我们可以通过使用文件名作为键的键值对来检索/加载纹理。
- en: The reason why we would go to this extra level of complexity and not just carry
    on using the `Texture` class as we have been so far, will become apparent as we
    proceed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要增加这种额外的复杂性，而不是像到目前为止一样继续使用`Texture`类，随着我们的进行，这将变得明显。
- en: The TextureHolder Class
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TextureHolder类
- en: Thousands of zombies represent a new challenge. Not only would loading, storing,
    and manipulating thousands of copies of three different zombie textures take up
    a lot of memory, but also a lot of processing power. We will create a new type
    of class that overcomes this problem and allows us to store just one of each texture.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 成千上万的僵尸代表了一个新的挑战。不仅加载、存储和操作三种不同僵尸纹理的成千上万个副本会占用大量内存，还会占用大量处理能力。我们将创建一个新类型的类来解决这个问题，并允许我们只存储每种纹理的一个副本。
- en: We will also code the class in such a way that there can only ever be one instance
    of it. This type of class is called a **singleton**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将以这样的方式编写类，使得它只能有一个实例。这种类型的类被称为**单例**。
- en: A singleton is a design pattern, a way to structure our code that is proven
    to work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一种设计模式，一种已被证明有效的代码结构方式。
- en: Furthermore, we will also code the class so that it can be used anywhere in
    our game code directly through the class name, without access to an instance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将编写类，以便可以直接通过类名在我们的游戏代码中的任何地方使用它，而无需访问实例。
- en: Coding the TextureHolder header file
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写TextureHolder头文件
- en: Make the new header file. Right-click **Header Files** in the **Solution Explorer**
    and select **Add** | **New Item...**. In the **Add New Item** window, highlight
    (by left-clicking) **Header File (** `.h` **)** and then in the **Name** field
    type `TextureHolder.h`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的头文件。在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，选择（通过左键单击）**头文件（**
    `.h` **）**，然后在**名称**字段中输入`TextureHolder.h`。
- en: 'Add the code that follows into the `TextureHolder.h` file and then we can discuss
    it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TextureHolder.h`文件中，然后我们可以讨论它：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the previous code, notice that we have an include directive for `map` from
    the STL. We declare a `map` that holds String and SFML `Texture` key-value pairs.
    The `map` is called `m_Textures`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意我们为STL中的`map`包含了一个包含指令。我们声明了一个包含String和SFML `Texture`键值对的`map`。这个`map`被称为`m_Textures`。
- en: 'In the previous code, this line is next:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，接下来是这行：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous line of code is quite interesting. We are declaring a static pointer
    to an object of type `TextureHolder` called `m_s_Instance`. This means that the
    `TextureHolder` class has an object that is the same type as itself. Not only
    that, but because it is static, it can be used through the class itself, without
    an instance of the class. When we code the related `.cpp` file we will see how
    we use this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行代码非常有趣。我们声明了一个指向`TextureHolder`类型对象的静态指针，称为`m_s_Instance`。这意味着`TextureHolder`类有一个与自身相同类型的对象。不仅如此，因为它是静态的，所以可以通过类本身使用，而无需类的实例。当我们编写相关的`.cpp`文件时，我们将看到如何使用它。
- en: In the `public` part of the class we have the prototype for the constructor
    function, `TextureHolder`. The constructor takes no arguments and, as usual, has
    no return type. This is the same as the default constructor. We are going to override
    the default constructor with a definition that makes our singleton work how we
    want it to.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的`public`部分，我们有构造函数`TextureHolder`的原型。构造函数不带参数，并且像通常一样没有返回类型。这与默认构造函数相同。我们将使用定义来覆盖默认构造函数，使我们的单例工作如我们所希望的那样。
- en: 'We have another function called `GetTexture`. Let''s look at the signature
    again and analyze exactly what is happening:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个名为`GetTexture`的函数。让我们再次看一下签名，并分析到底发生了什么：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, notice that the function returns a reference to a `Texture`. This means
    that `GetTexture` will return a reference, which is efficient because it avoids
    making a copy of what could be a fairly large graphic. Also notice the function
    is declared as `static`. This means the function can be used without an instance
    of the class. The function takes a `String` as a constant reference, as a parameter.
    The effect of this is twofold. Firstly, the operation is efficient and secondly,
    because the reference is constant, it can't be changed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意函数返回一个`Texture`的引用。这意味着`GetTexture`将返回一个引用，这是有效的，因为它避免了对可能是相当大的图形进行复制。还要注意函数声明为`static`。这意味着该函数可以在没有类实例的情况下使用。该函数以`String`作为常量引用作为参数。这样做的效果是双重的。首先，操作是有效的，其次，因为引用是常量的，所以它是不可改变的。
- en: Coding the TextureHolder function definitions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写TextureHolder函数定义
- en: Now we can create a new `.cpp` file that will contain the function definition.
    This will enable us to see the reasons behind our new types of functions and variables.
    Right-click **Source Files** in the **Solution Explorer** and select **Add | New
    Item...**. In the **Add New Item** window, highlight (by left-clicking), **C++
    File** ( **`.cpp`** ) and then in the **Name** field type `TextureHolder.cpp`.
    Finally, click the **Add** button. We are now ready to code the class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的`.cpp`文件，其中包含函数定义。这将使我们能够看到我们新类型的函数和变量背后的原因。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加
    | 新项目...**。在**添加新项**窗口中，通过左键单击突出显示**C++文件**（**`.cpp`**），然后在**名称**字段中键入`TextureHolder.cpp`。最后，单击**添加**按钮。我们现在准备编写类的代码。
- en: 'Add the following code and then we can discuss it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，然后我们可以讨论它：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous code, we initialize our pointer to type `TextureHolder` to `nullptr`.
    In the constructor, the code `assert(m_s_Instance == nullptr)` ensures that `m_s_Instance`
    equals `nullptr`. If it doesn't, the game will exit execution. Then the code `m_s_Instance
    = this` assigns the pointer to this instance. Now consider where this code is
    taking place. The code is in the constructor. The constructor is the way that
    we create instances of objects from classes. So effectively we now have a pointer
    to a `TextureHolder` that points to the one and only instance of itself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将指向`TextureHolder`类型的指针初始化为`nullptr`。在构造函数中，代码`assert(m_s_Instance
    == nullptr)`确保`m_s_Instance`等于`nullptr`。如果不是，则游戏将退出执行。然后代码`m_s_Instance = this`将指针分配给此实例。现在考虑一下这段代码发生在哪里。代码在构造函数中。构造函数是我们从类中创建对象实例的方式。因此，实际上我们现在有一个指向`TextureHolder`的指针，指向自身的唯一实例。
- en: 'Add the final part of the code to the `TextureHolder.cpp` file. There are more
    comments than code next. Examine the code and read the comments as you add the
    code and then we can go through it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一部分代码添加到`TextureHolder.cpp`文件中。接下来的注释比代码更多。在添加代码时，请检查代码并阅读注释，然后我们可以一起讨论：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first thing you will probably notice about the previous code is the `auto`
    keyword. The `auto` keyword was explained in the previous section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到前面代码中的第一件事是`auto`关键字。`auto`关键字在前一节中有解释。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to know what the actual types that have been replaced by `auto`
    are, then take a look at the comments immediately after each use of `auto` in
    the previous code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道`auto`替换的实际类型是什么，请看一下前面代码中每次使用`auto`后面的注释。
- en: At the start of the code we get a reference to `m_textures`. Then we attempt
    to get an iterator to the key-value pair represented by the passed-in filename
    (`filename`). If we find a matching key, we return the texture with `return keyValuePair->second`.
    Otherwise we add the texture to the `map` and then return it to the calling code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开头，我们获取了对`m_textures`的引用。然后我们尝试获取一个迭代器，该迭代器表示传入的文件名（`filename`）所代表的键值对。如果我们找到匹配的键，我们返回`return
    keyValuePair->second`的纹理。否则，我们将纹理添加到`map`中，然后将其返回给调用代码。
- en: Admittedly, the `TextureHolder` class introduced lots of new concepts (singletons,
    `static` functions, constant references, `this`, and the `auto` keyword) and syntax.
    Add to this the fact that we have only just learned about pointers and the STL,
    and this section's code might have been a little daunting.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，`TextureHolder`类引入了许多新概念（单例、`static`函数、常量引用、`this`和`auto`关键字）和语法。再加上我们刚刚学习了指针和STL，这一部分的代码可能有点令人生畏。
- en: What exactly have we achieved with TextureHolder?
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextureHolder到底实现了什么？
- en: The point is that now we have this class, we can go wild using textures wherever
    we like in our code and not worry about running out of memory or having access
    to a particular texture in a particular function or class. We will see how to
    use `TextureHolder` really soon.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是现在我们有了这个类，我们可以在代码中随意使用纹理，而不必担心内存不足或者在特定函数或类中访问特定纹理。我们很快就会看到如何使用`TextureHolder`。
- en: Building a horde of zombies
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一群僵尸
- en: Now we are armed with the `TextureHolder` class to make sure that our zombie
    textures are easily available, as well as only loaded into the GPU once, we can
    look into creating a whole horde of them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`TextureHolder`类，以确保我们的僵尸纹理易于获取，并且只加载到GPU一次，我们可以着手创建一整群僵尸。
- en: We will store zombies in an array and as the process of building and spawning
    a horde of zombies involves quite a few lines of code, it is a good candidate
    for abstracting to a separate function. Soon we will code the `CreateHorde` function
    but first, of course, we need a `Zombie` class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把僵尸存储在一个数组中，由于构建和生成一群僵尸的过程涉及相当多的代码行，因此将其抽象为一个单独的函数是一个很好的选择。很快我们将编写`CreateHorde`函数，但首先，当然，我们需要一个`Zombie`类。
- en: Coding the Zombie.h file
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Zombie.h文件
- en: The first step to building a class to represent a zombie is to code the member
    variables and function prototypes in a header file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代表僵尸的类的第一步是在头文件中编写成员变量和函数原型。
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking) **Header
    File (`.h`)** and then in the **Name** field type `Zombie.h`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，突出显示（单击左键）**头文件（.h）**，然后在**名称**字段中键入`Zombie.h`。
- en: 'Add the following code into the `Zombie.h` file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Zombie.h`文件中：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The previous code declares all the private member variables of the `Zombie`
    class. At the top of the previous code, we have three constant variables to hold
    the speeds of each type of zombie. A very slow **Crawler**, a slightly faster
    **Bloater**, and a somewhat speedy **Chaser**. We can experiment with the value
    of these three constants to help balance the difficulty level of the game. Also
    worth mentioning here is that these three values are only used as a starting value
    for the speed of each zombie type. As we will see later in this chapter, we will
    vary the speed of every zombie by a small percentage from these values. This stops
    zombies of the same type from bunching up together as they pursue the player.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码声明了`Zombie`类的所有私有成员变量。在先前的代码顶部，我们有三个常量变量来保存每种类型僵尸的速度。一个非常缓慢的**爬行者**，一个稍快的**膨胀者**，以及一个相当快的**追逐者**。我们可以尝试调整这三个常量的值，以帮助平衡游戏的难度级别。值得一提的是，这三个值仅用作每种僵尸类型速度的起始值。正如我们将在本章后面看到的，我们将从这些值中以一小百分比变化每个僵尸的速度。这样可以防止相同类型的僵尸在追逐玩家时聚集在一起。
- en: The next three constants, determine the health level for each zombie type. Note
    that Bloaters are the toughest followed by Crawlers. As a matter of balance, the
    Chaser zombies will be the easiest to kill.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个常量确定了每种僵尸类型的生命值。请注意，膨胀者是最坚韧的，其次是爬行者。为了平衡，追逐者僵尸将是最容易被杀死的。
- en: Next we have two more constants `MAX_VARIANCE` and `OFFSET;` these will help
    us determine the individual speed of each zombie. We will see exactly how when
    we code the `Zombie.cpp` file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有两个更多的常量`MAX_VARIANCE`和`OFFSET;`，这些将帮助我们确定每个僵尸的个体速度。当我们编写`Zombie.cpp`文件时，我们将看到具体如何做到这一点。
- en: 'After these constants we declare a bunch of variables that should look familiar
    because we had very similar variables in our `Player` class. The `m_Position`,
    `m_Sprite`, `m_Speed`, and `m_Health` variables are for what their names imply:
    the position, sprite, speed, and health of the zombie object.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些常量之后，我们声明了一堆变量，这些变量应该看起来很熟悉，因为我们在`Player`类中有非常相似的变量。`m_Position`、`m_Sprite`、`m_Speed`和`m_Health`变量分别代表了僵尸对象的位置、精灵、速度和生命值。
- en: Finally, in the previous code, we declare a `Boolean` `m_Alive` which will be
    `true` when the zombie is alive and hunting but `false` when its health gets to
    zero and it is just a splurge of blood on our otherwise pretty background.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在先前的代码中，我们声明了一个布尔值`m_Alive`，当僵尸活着并追捕时为`true`，但当其生命值降到零时为`false`，它只是我们漂亮背景上的一滩血迹。
- en: 'Now to complete the `Zombie.h` file. Add the function prototypes highlighted
    below and then we will talk about them:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来完成`Zombie.h`文件。添加下面突出显示的函数原型，然后我们将讨论它们：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the previous code, there is a `hit` function which we can call every time
    the zombie is hit by a bullet. The function can then take the necessary steps,
    such as taking health from the zombie (reducing the value of `m_Health`) or killing
    it dead (setting `m_Alive` to false).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，有一个`hit`函数，我们可以在僵尸被子弹击中时调用它。该函数可以采取必要的步骤，比如从僵尸身上减少生命值（减少`m_Health`的值）或者将其杀死（将`m_Alive`设置为false）。
- en: The `isAlive` function returns a `Boolean`, which lets the calling code know
    whether the zombie is alive or dead. We don't want to perform collision detection
    or remove health from the player for walking over a blood splat.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAlive`函数返回一个布尔值，让调用代码知道僵尸是活着还是死了。我们不希望对走过血迹时发生碰撞检测或从玩家身上减少生命值。'
- en: The `spawn` function takes a starting position, a type (Crawler, Bloater, or
    Chaser, represented by an int), as well as a seed to use in some random number
    generation that we will see in the next section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`函数接受一个起始位置、一个类型（爬行者、膨胀者或追逐者，用一个整数表示），以及一个种子，用于一些我们将在下一节中看到的随机数生成。'
- en: Just as we have in the `Player` class, the `Zombie` class has `getPosition`
    and `getSprite` functions to get a rectangle that represents the space occupied
    by the zombie and the sprite that can be drawn each frame.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`Player`类中一样，`Zombie`类有`getPosition`和`getSprite`函数，用于获取代表僵尸所占空间的矩形和可以在每一帧绘制的精灵。
- en: The last prototype in the previous code is the `update` method. We could probably
    have guessed that it would receive the elapsed time since the last frame but also
    notice that it receives a `Vector2f` called `playerLocation`. This vector will
    indeed be the exact coordinates of the center of the player. We will see soon
    how we use this vector to chase after the player.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码中的最后一个原型是`update`方法。我们可能已经猜到它会接收自上一帧以来的经过的时间，但也要注意它接收了一个名为`playerLocation`的`Vector2f`。这个向量确实是玩家中心的确切坐标。我们很快就会看到我们如何使用这个向量来追逐玩家。
- en: Coding the Zombie.cpp file
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Zombie.cpp文件
- en: Next we will code the actual functionality of the Zombie class, the function
    definitions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将编写Zombie类的实际功能，即函数定义。
- en: Create a new `.cpp` file that will contain the function definitions. Right-click
    **Source Files** in the **Solution Explorer** and select **Add | New Item...**.
    In the **Add New Item** window, highlight (by left-clicking) **C++ File** ( **`.cpp`**
    ) and then in the **Name** field type `Zombie.cpp`. Finally, click the **Add**
    button. We are now ready to code the class.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`.cpp`文件，其中包含函数定义。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加 | 新项目...**。在**添加新项目**窗口中，通过左键单击**C++文件**（**`.cpp`**），然后在**名称**字段中键入`Zombie.cpp`。最后，单击**添加**按钮。我们现在准备好编写类了。
- en: 'Add the following code to the `Zombie.cpp` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下代码添加到`Zombie.cpp`文件中：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First we add the necessary include directives and then the line `using namespace
    std`. You might remember a few instances when we have prefixed our object declarations
    with `std::`. This `using` directive means we don't need to do that for the code
    in this file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加必要的包含指令，然后添加`using namespace std`这一行。您可能还记得我们在一些情况下在对象声明前面加上了`std::`。这个`using`指令意味着我们在这个文件中的代码不需要这样做。
- en: 'Now add the following code, which is the definition of the `spawn` function.
    Study the code once you have added it and then we will go through it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加以下代码，这是`spawn`函数的定义。添加后，请仔细研究代码，然后我们将逐步讲解：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first thing the function does is `switch` based on the `int` type which
    is passed in as a parameter. Within the `switch`, block there is a case for each
    zombie type. Depending upon the type and the appropriate texture, speed and health
    are initialized to the relevant member variables.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一件事是基于传入的`int`类型进行`switch`。在`switch`块内，为每种僵尸类型都有一个case。根据类型和相应的纹理，速度和生命值被初始化为相关的成员变量。
- en: Of interest here is that we use the static `TextureHolder::GetTexture` function
    to assign the texture. This means that no matter how many zombies we spawn, there
    will be a maximum of three textures in the memory of the GPU.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们使用静态的`TextureHolder::GetTexture`函数来分配纹理。这意味着无论我们生成多少僵尸，GPU的内存中最多只会有三种纹理。
- en: 'The next three lines of code (excluding comments) do the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的最后三行（不包括注释）分别执行以下操作：
- en: Seed the random number generator with the `seed` variable that was passed in
    as a parameter.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用作参数传入的`seed`变量来初始化随机数生成器。
- en: Declare and initialize the `modifier` float variable using the `rand` function
    and the `MAX_VARIANCE` and `OFFSET` constants. The result is a fraction between
    zero and one which can be used to make each and every zombie's speed unique. The
    reason we want to do this is so that the zombies don't bunch up on top of each
    other too much.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rand`函数和`MAX_VARIANCE`和`OFFSET`常量声明和初始化`modifier`浮点变量。结果是一个介于零和一之间的分数，可以用来使每个僵尸的速度都是独特的。我们之所以要这样做，是因为我们不希望僵尸们太过拥挤。
- en: We can now multiply `m_Speed` by `modifier` and we have a zombie whose speed
    is within `MAX_VARRIANCE` percent of the constant defined for this particular
    type of zombie's speed.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以将`m_Speed`乘以`modifier`，这样我们就得到了一个速度在这种特定类型的僵尸速度常量的`MAX_VARRIANCE`百分比内的僵尸。
- en: After we have resolved the speed, we assign the passed in position held in `startX`
    and `startY` to `m_Position.x` and `m_Position.y` respectively.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了速度之后，我们将`startX`和`startY`中传入的位置分别赋给`m_Position.x`和`m_Position.y`。
- en: The last two lines of code in the previous listing set the origin of the sprite
    to the center and use the `m_Position` vector to set the position of the sprite.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的最后两行代码设置了精灵的原点为中心，并使用`m_Position`向量来设置精灵的位置。
- en: 'Now add this code for the `hit` function to the `Zombie.cpp` file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下代码添加到`Zombie.cpp`文件中，用于`hit`函数：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `hit` function is nice and simple. Reduce `m_Health` by one then check whether
    `m_Health` is below zero.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`hit`函数非常简单。将`m_Health`减一，然后检查`m_Health`是否小于零。'
- en: If it is below zero, set `m_Alive` to false, swap the zombie's texture for a
    blood splat, and return `true` to the calling code, so it knows the zombie is
    now dead.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小于零，将`m_Alive`设置为false，将僵尸的纹理替换为血迹，并返回true给调用代码，这样它就知道僵尸现在已经死了。
- en: If the zombie has survived the hit, return `false`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果僵尸幸存下来，返回false。
- en: 'Add the next three getter functions, which just return a value to the calling
    code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面的三个getter函数，它们只是将一个值返回给调用代码：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous three functions are quite self-explanatory, perhaps with the exception
    that the `getPosition` function uses the `m_Sprite.getLocalBounds` function to
    get the `FloatRect`, which is returned to the calling code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的三个函数相当容易理解，也许除了`getPosition`函数使用`m_Sprite.getLocalBounds`函数来获取`FloatRect`之外，这个例外。这个函数返回给调用代码。
- en: 'Finally, for the `Zombie` class, add the code for the `update` function; look
    closely at the code and then we will go through it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为`Zombie`类添加`update`函数的代码；仔细查看代码，然后我们将逐步讲解：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First we copy `playerLocation.x` and `playerLocation.y` into the local variables
    `playerX` and `playerY`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`playerLocation.x`和`playerLocation.y`复制到本地变量`playerX`和`playerY`中。
- en: Next there are four `if` statements. They test to see whether the zombie is
    to the left, right, above, or below the current player's position. These four
    `if` statements, when they evaluate to `true`, adjust the zombie's `m_Position.x`
    and `m_Position.y` values appropriately using the usual formula, `speed * time`
    since last frame. More specifically, the code is `m_Speed * elapsedTime`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来有四个`if`语句。它们测试僵尸是否在当前玩家位置的左侧、右侧、上方或下方。这四个`if`语句在评估为`true`时，使用通常的公式`speed
    * time`来适当地调整僵尸的`m_Position.x`和`m_Position.y`值。更具体地说，代码是`m_Speed * elapsedTime`。
- en: After the four `if` statements, `m_Sprite` is moved to its new location.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在四个`if`语句之后，`m_Sprite`被移动到它的新位置。
- en: We then use the same calculation we previously used with the player and the
    mouse pointer; this time, however, we do so for the zombie and the player. This
    calculation finds the angle needed to face the zombie toward the player.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用与之前用于玩家和鼠标指针的相同计算；不过这次是用于僵尸和玩家。这个计算找到了面向玩家的僵尸所需的角度。
- en: Finally, we call `m_Sprite.setRotation` to actually rotate the zombie sprite.
    Remember that this function will be called for every zombie (that is alive) on
    every frame of the game.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`m_Sprite.setRotation`来实际旋转僵尸精灵。请记住，这个函数将在游戏的每一帧中为每个（活着的）僵尸调用。
- en: Using the Zombie class to create a horde
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Zombie类创建一个僵尸群
- en: Now we have a class to create a living, attacking, and killable zombie, we want
    to spawn a whole horde of them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个类来创建一个活着的、攻击的和可杀死的僵尸，我们想要生成一整群它们。
- en: To achieve this, we will write a separate function and we will use a pointer
    so that we can refer to our horde that will be declared in `main` but configured
    in a different scope.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将编写一个单独的函数，并使用指针，以便我们可以引用在`main`中声明但在不同范围内配置的我们的僵尸群。
- en: 'Open the `ZombieArena.h` file in Visual Studio and add the highlighted lines
    of code shown next:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`ZombieArena.h`文件，并添加下面显示的突出显示的代码行：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we have a prototype, we can code the function definition.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个原型，我们可以编写函数定义了。
- en: Create a new `.cpp` file that will contain the function definition. Right-click
    **Source Files** in the **Solution Explorer** and select **Add | New Item...**.
    In the **Add New Item** window, highlight (by left-clicking) **C++ File** (`.cpp`)
    and then in the **Name** field type `CreateHorde.cpp`. Finally, click the **Add**
    button.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`.cpp`文件，其中包含函数定义。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加 | 新建项...**。在**添加新项**窗口中，选择（通过左键单击）**C++文件**（`.cpp`），然后在**名称**字段中键入`CreateHorde.cpp`。最后，单击**添加**按钮。
- en: 'Add and study the code shown next into the `CreateHorde.cpp` file. Afterwards,
    we will break it down into chunks and discuss it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将下面显示的代码添加到`CreateHorde.cpp`文件中并学习它。之后，我们将把它分解成块并讨论它：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's look at all the previous code again, in bite-size pieces.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次逐步查看所有以前的代码。
- en: 'First we add the now familiar include directives:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们添加了现在熟悉的包含指令：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next comes the function signature. Notice that the function must return a pointer
    to a `Zombie` object. We will be creating an array of `Zombie` objects. Once we
    are done creating the horde, we will return the array. When we return the array,
    we are actually returning the address of the first element of the array. This,
    as we learned in the section earlier in this chapter, is the same thing as a pointer.
    The signature also shows that we have two parameters. The first, `numZombies`,
    will be the number of zombies this current horde requires and the second, arena,
    is an `IntRect` that holds the size of the current arena in which to create this
    horde.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是函数签名。请注意，函数必须返回一个指向`Zombie`对象的指针。我们将创建一个`Zombie`对象的数组。一旦我们创建了这个僵尸群，我们将返回这个数组。当我们返回数组时，实际上是返回数组的第一个元素的地址。这与本章前面学到的内容相同，也就是指针。函数签名还显示我们有两个参数。第一个参数`numZombies`将是当前僵尸群所需的僵尸数量，第二个参数`arena`是一个`IntRect`，用于保存当前竞技场的大小，以便创建这个僵尸群。
- en: 'After the function signature, we declare a pointer to type `Zombie` called
    `zombies` and initialize with the memory address of the first element of an array,
    which we dynamically allocate on the heap:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名之后，我们声明了一个名为`zombies`的指向`Zombie`类型的指针，并用数组的第一个元素的内存地址进行初始化，这个数组是我们在堆上动态分配的。
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next code simply copies the extremities of the arena into `maxY`, `minY`,
    `maxX`, and `minX`. We subtract twenty pixels from the right and bottom while
    adding twenty pixels to the top and left. We use these four local variables to
    help position each of the zombies. We made the twenty-pixel adjustments to stop
    the zombies appearing on top of the walls:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码简单地将竞技场的边界复制到`maxY`、`minY`、`maxX`和`minX`中。我们从右边和底部减去20像素，同时在顶部和左边加上20像素。我们使用这四个局部变量来帮助定位每个僵尸。我们进行了20像素的调整，以防止僵尸出现在墙上。
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we enter a `for` loop that will loop through each of the `Zombie` objects
    in the zombies array from zero through to `numZombies`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入一个`for`循环，该循环将遍历从零到`numZombies`的每个`Zombie`对象在僵尸数组中的元素：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the `for` loop, the first thing the code does is seed the random number
    generator and then generate a random number between zero and three. This number
    is stored in the `side` variable. We will use the `side` variable to decide whether
    the zombie spawns at the left, top, right, or bottom of the arena. We also declare
    two `int` variables, `x` and `y`. These two variables will temporarily hold the
    actual horizontal and vertical coordinates of the current zombie:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内，代码的第一件事是初始化随机数生成器，然后生成一个介于零和三之间的随机数。这个数字存储在`side`变量中。我们将使用`side`变量来决定僵尸是在竞技场的左侧、顶部、右侧还是底部生成。我们还声明了两个`int`变量`x`和`y`。这两个变量将临时保存当前僵尸的实际水平和垂直坐标。
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Still inside the `for` loop we have a `switch` block with four `case` statements.
    Notice the `case` statements are for 0, 1, 2, and 3 and the argument in the switch
    statement is side. Inside each of the case blocks, we initialize x and y with
    one predetermined value, either minX, maxX, minY, or maxY, and one randomly generated
    value. Look closely at the combinations of each predetermined and random value.
    You will see that they are appropriate for positioning the current zombie randomly
    across either the left side, top side, right side, or bottom side. The effect
    of this will be that each zombie can spawn randomly, anywhere on the outside edge
    of the arena:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们有一个`switch`块，包含四个`case`语句。注意`case`语句分别为0、1、2和3，而switch语句中的参数是side。在每个case块内，我们使用一个预定值（minX、maxX、minY或maxY）和一个随机生成的值来初始化x和y。仔细观察每个预定值和随机值的组合，你会发现它们适合将当前僵尸随机放置在竞技场的左侧、顶部、右侧或底部。这样做的效果是，每个僵尸可以在竞技场的外边缘随机生成：
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Still inside the `for` loop, we seed the random number generator again and generate
    a random number between 0 and 2\. We store this number in the type variable. The
    type variable will determine whether the current zombie will be a Chaser, Bloater,
    or Crawler.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内部，我们再次初始化随机数生成器，并生成一个介于0和2之间的随机数。我们将这个数字存储在type变量中。type变量将决定当前僵尸是Chaser、Bloater还是Crawler。
- en: 'After the type is determined, we call the `spawn` function on the current `Zombie`
    object in the `zombies` array. As a reminder, the arguments sent into the `spawn`
    function determine the starting location of the zombie and the type of zombie
    it will be. The apparently arbitrary `i` is passed in as it is used as a unique
    seed that randomly varies the speed of a zombie within an appropriate range. This
    stops our zombies **bunching up** and becoming a blob rather than a horde:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 确定类型后，我们在`zombies`数组中的当前`Zombie`对象上调用`spawn`函数。作为提醒，传入`spawn`函数的参数确定了僵尸的起始位置和僵尸的类型。看似任意的`i`被传入，因为它被用作一个唯一的种子，可以在适当的范围内随机变化僵尸的速度。这样可以防止我们的僵尸**聚集**在一起，而不是形成一群：
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `for` loop repeats itself once for each zombie contained in `numZombies`
    and then we return the array. The array, as another reminder, is simply an address
    of the first element of itself. The array is dynamically allocated on the heap
    so it persists after the function returns:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环对`numZombies`中包含的每个僵尸重复一次，然后返回数组。再次提醒，数组只是它自身的第一个元素的地址。数组是在堆上动态分配的，因此在函数返回后它将持续存在：'
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we can bring our zombies to life.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让僵尸活过来。
- en: Bringing the horde to life (back to life)
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让僵尸群复活
- en: We have a `Zombie` class and a function to make a randomly spawning horde of
    them. We have the `TextureHolder` singleton as a neat way to hold just three textures
    that can be used for dozens, even thousands, of zombies. Now we can add the horde
    to our game engine in `main`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Zombie`类和一个函数来随机生成一群僵尸。我们有`TextureHolder`单例作为一种简洁的方式来保存仅三个纹理，可以用于数十甚至数千个僵尸。现在我们可以在`main`中将僵尸群添加到我们的游戏引擎中。
- en: 'Add the following highlighted code to include the `TextureHolder` class. Then,
    just inside `main`, we initialize the one and only instance of `TextureHolder`
    that can be used from anywhere within our game:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码以包含`TextureHolder`类。然后，在`main`内部，我们初始化了唯一的`TextureHolder`实例，可以在游戏的任何地方使用：
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The next few lines of highlighted code declare some control variables for the
    number of zombies at the start of the wave, the number of zombies still to be
    killed, and, of course, a pointer to `Zombie` called `zombies` which we initialize
    to `nullptr`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来几行突出显示的代码声明了一些控制变量，用于波开始时僵尸的数量、仍需杀死的僵尸数量，当然还有一个名为`zombies`的`Zombie`指针，我们将其初始化为`nullptr`。
- en: 'Add the highlighted code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 添加突出显示的代码：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, in the `PLAYING` section nested inside the `LEVELING_UP` section, we
    add code that does the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`LEVELING_UP`部分嵌套的`PLAYING`部分中，我们添加以下代码：
- en: Initializes `numZombies` to `10`. As the project progresses this will eventually
    be dynamic and based on the current wave number
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`numZombies`初始化为`10`。随着项目的进展，这将最终变得动态，并基于当前波数。
- en: Deletes any pre-existing allocated memory, otherwise each new call to `createHorde`
    would take up progressively more memory but without freeing the previous horde's
    memory
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除任何已分配的内存，否则每次调用`createHorde`都会占用越来越多的内存，而不释放先前僵尸群的内存
- en: Then calls `createHorde` and assigns the returned memory address to `zombies`
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后调用`createHorde`并将返回的内存地址分配给`zombies`
- en: Initializes `zombiesAlive` with `numZombies` because we haven't killed any at
    this point
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`zombiesAlive`初始化为`numZombies`，因为在这一点上我们还没有杀死任何僵尸
- en: 'Add the highlighted code we have just discussed:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚刚讨论过的突出显示的代码：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now add the following highlighted code to the `ZombieArena.cpp` file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下突出显示的代码添加到`ZombieArena.cpp`文件中：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: All that the new code does is loop through the array of zombies, check the current
    zombie is alive, and if it is, calls its `update` function with the necessary
    arguments.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码所做的一切就是循环遍历僵尸数组，检查当前僵尸是否还活着，如果是的话，就用必要的参数调用它的`update`函数。
- en: 'Add the following code to draw all the zombies:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码来绘制所有的僵尸：
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The previous code loops through all the zombies and calls the `getSprite` function
    to allow the `draw` method to do its work. We don't check whether the zombie is
    alive because even if the zombie is dead we want to draw the blood splatter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码循环遍历所有的僵尸，并调用`getSprite`函数以允许`draw`方法发挥作用。我们不检查僵尸是否还活着，因为即使僵尸已经死亡，我们也希望绘制血迹。
- en: 'At the end of the main function, we make sure to delete our pointer, although
    technically this isn''t essential because the game is about to exit and the operating
    system will reclaim all the memory used after the `return 0` statement:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的末尾，我们确保删除了我们的指针，尽管从技术上讲这并非必要，因为游戏即将退出，操作系统将在`return 0`语句之后回收所有使用的内存：
- en: '[PRE57]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can run the game and see the zombies spawn around the edge of the arena.
    They will immediately head straight toward the player at their various speeds.
    Just for fun I increased the size of the arena and increased the number of zombies
    to 1000.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行游戏，看到僵尸在竞技场的边缘生成。它们会立即以各自的速度直奔玩家而去。为了好玩，我增加了竞技场的大小，并将僵尸数量增加到1000。
- en: '![Bringing the horde to life (back to life)](img/image_08_001.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![将僵尸群带回生命（重新活过来）](img/image_08_001.jpg)'
- en: This is going to end badly!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以失败告终！
- en: 'Notice that you can also pause and resume the onslaught of the horde using
    the **Enter** key because of the code we wrote in [Chapter 6](ch06.html "Chapter 6. 
    Object-Oriented Programming, Classes, and SFML Views"): *Object-Oriented Programming,
    Classes, and SFML Views*.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们在[第6章](ch06.html "第6章。面向对象编程，类和SFML视图")中编写的代码，您还可以使用**Enter**键暂停和恢复僵尸群的袭击：*面向对象编程，类和SFML视图*。
- en: Using the TextureHolder class for all textures
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`TextureHolder`类加载所有纹理
- en: Since we have our `TextureHolder` class, we might as well be consistent and
    use it to load all our textures. Let's make some very small alterations to the
    existing code that loads textures for the background sprite sheet and the player.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了`TextureHolder`类，我们可能会一致地使用它来加载所有的纹理。让我们对加载背景精灵表和玩家纹理的现有代码进行一些非常小的修改。
- en: Change the way the background gets its textures
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改背景获取纹理的方式
- en: 'In the `ZombieArena.cpp` file, find this code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ZombieArena.cpp`文件中，找到这段代码：
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Delete the code highlighted previously and replace it with the following highlighted
    code, which uses our new `TextureHolder` class:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 删除先前突出显示的代码，并用以下突出显示的代码替换，该代码使用我们的新`TextureHolder`类：
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Change the way Player gets its texture
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改Player获取纹理的方式
- en: 'In the `Player.cpp` file, inside the constructor, find this code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player.cpp`文件中，在构造函数内，找到这段代码：
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Delete the code highlighted previously and replace it with this code, which
    uses our new `TextureHolder` class. In addition, add the include directive to
    add the `TextureHolder` header to the file. The new code is shown highlighted,
    in context:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 删除先前突出显示的代码，并用使用我们的新`TextureHolder`类的以下代码替换。此外，添加包含指令以将`TextureHolder`头文件添加到文件中。新代码如下所示，突出显示在上下文中：
- en: '[PRE61]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: From now on we will use the `TextureHolder` class for loading all textures.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用`TextureHolder`类加载所有纹理。
- en: FAQ
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: 'Here are some questions that might be on your mind:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可能会想到的一些问题：
- en: Q) What's the difference between pointers and references?
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Q）指针和引用有什么区别？
- en: A) Pointers are like references with boosters. Pointers can be changed to point
    to different variables (memory addresses), as well as point to dynamically allocated
    memory on the free store.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: A）指针就像带有助推器的引用。指针可以更改指向不同变量（内存地址），以及指向自由存储器上动态分配的内存。
- en: Q) What's the deal with arrays and pointers?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Q）数组和指针有什么关系？
- en: A) Arrays are really constant pointers to their first element.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: A）数组实际上是指向它们第一个元素的常量指针。
- en: Q) Can you remind me about the `new` keyword and memory leaks?
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Q）您能提醒我一下`new`关键字和内存泄漏吗？
- en: A) When we use memory on the free store using the `new` keyword, it persists
    even when the function it was created in has returned and all the local variables
    are gone. When we are done with using memory on the free store we must release
    it. So if we use memory on the free store, that we want to persist, beyond the
    life of a function, we must make sure to keep a pointer to it or we will have
    leaked memory. It would be like putting all our belongings in our house and then
    forgetting where we live! When we return the zombies array from `createHorde`,
    it is like passing the relay baton (memory address) from `createHorde` to `main`.
    It's like saying OK, here is your horde of zombies - they are your responsibility
    now. We wouldn't want any leaked zombies running around in our RAM so we must
    remember to call `delete` on pointers to dynamically allocated memory.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: A）当我们使用`new`关键字在自由存储器上使用内存时，即使创建它的函数已经返回并且所有局部变量都消失了，它仍然存在。当我们使用自由存储器上的内存时，我们必须释放它。因此，如果我们使用自由存储器上的内存，我们希望它在函数的生命周期之外持续存在，我们必须确保保留指向它的指针，否则我们将泄漏内存。这就像把所有的东西放在我们的房子里然后忘记我们住在哪里一样！当我们从`createHorde`返回僵尸数组时，就像是把接力棒（内存地址）从`createHorde`传递给`main`。这就像是说好的，这是你的一群僵尸
    - 现在它们是你的责任了。我们不希望我们的RAM中有任何泄漏的僵尸，所以我们必须记得在指向动态分配内存的指针上调用`delete`。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You might have noticed that the zombies don't appear to be very dangerous. They
    just drift through the player without leaving a scratch. At the moment this is
    a good thing because the player has no way to defend himself.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些僵尸似乎并不那么危险。它们只是漂浮在玩家身边，而不留下任何伤痕。目前这是件好事，因为玩家没有办法自卫。
- en: In the next chapter, we will make two more classes. One will be for ammo and
    health pickups, and one for bullets that the player can shoot. After we have done
    that, we will learn how to detect collisions, so that the bullets and zombies
    do some damage and the pickups can be collected by the player.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将制作另外两个类。一个用于弹药和生命值的拾取，另一个用于玩家可以射击的子弹。在完成这些之后，我们将学习如何检测碰撞，以便子弹和僵尸造成一些伤害，并且玩家可以收集拾取物品。
