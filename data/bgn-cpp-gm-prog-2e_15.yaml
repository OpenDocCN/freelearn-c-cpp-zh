- en: '*Chapter 14*: Abstraction and Code Management – Making Better Use of OOP'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：抽象和代码管理 – 更好地利用面向对象编程'
- en: In this chapter, we will take a first look at the penultimate project of this
    book. The project we will be building will use advanced features such as directional
    sound, which has the effect of appearing to play relative to the position of the
    player. It will also have split-screen cooperative gameplay. In addition, this
    project will introduce the concept of **Shaders**, which are programs written
    in another language that run directly on the graphics card. By the end of [*Chapter
    18*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356), *Particle Systems and Shaders*,
    you will have a fully functioning, multiplayer platform game built in the style
    of the hit classic *Thomas Was Alone*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首次查看本书的最后一项项目。我们将构建的项目将使用诸如方向性声音等高级功能，这些声音似乎与玩家的位置相关。它还将具有分屏合作游戏。此外，该项目还将引入**着色器**的概念，这些着色器是用另一种语言编写的程序，可以直接在图形卡上运行。到[*第18章*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356)，“粒子系统和着色器”结束时，你将拥有一个完全功能的多玩家平台游戏，其风格模仿了热门经典游戏*托马斯·瓦瑟德*。
- en: 'This chapter''s focus will be getting the project started and exploring how
    the code will be structured to make better use of OOP. Here are the details of
    the topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是启动项目并探讨如何构建代码以更好地利用面向对象编程。以下是本章将涵盖的主题细节：
- en: Introducing the final project, **Thomas Was Late**, including the gameplay features
    and project assets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍最终项目，**托马斯·瓦瑟德迟到**，包括游戏玩法功能和项目资源
- en: A detailed discussion of how we will improve the structure of the code compared
    to previous projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前项目相比，我们将如何改进代码结构的详细讨论
- en: Coding the Thomas Was Late game engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写托马斯·瓦瑟德迟到游戏引擎的代码
- en: Implementing split-screen functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分屏功能
- en: The Thomas Was Late game
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托马斯·瓦瑟德迟到游戏
- en: Tip
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: At this point, if you haven't already, I suggest that you go and watch a video
    of Thomas Was Alone at [http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你还没有的话，我建议你去看一下托马斯·瓦瑟德独自一人的视频，[http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/)。
- en: Notice the simple but aesthetically excellent graphics. The video also shows
    a variety of gameplay challenges such as using the character's different attributes
    (height, jump, power, and so on). To keep our game simple without losing the challenge,
    we will have fewer puzzle features than Thomas Was Alone but will have the additional
    challenge of creating the need for two players to play cooperatively. Just to
    make sure the game is not too easy, we will also make the players have to rush
    to beat the clock, which is why the name of our game is Thomas Was Late.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到简单但美观的图形。视频还展示了各种游戏挑战，例如使用角色的不同属性（高度、跳跃、力量等）。为了保持我们的游戏简单而不失去挑战性，我们将比托马斯·瓦瑟德更少的谜题功能，但将增加需要两名玩家合作游戏的额外挑战。为了确保游戏不会太简单，我们还将让玩家必须赶时间打败时钟，这就是为什么我们的游戏名字叫托马斯·瓦瑟德迟到。
- en: Features of Thomas Was Late
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托马斯·瓦瑟德迟到游戏的特点
- en: 'Our game will not be nearly as advanced as the masterpiece that we are attempting
    to emulate, but it will have a good selection of exciting game-play features,
    such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将不会像我们试图模仿的杰作那样先进，但它将拥有丰富的令人兴奋的游戏玩法特点，例如以下内容：
- en: A clock that counts down from a time appropriate to the challenge of the level.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从适合该级别挑战的时间开始倒计时的时钟。
- en: Fire pits that emit a roar relative to the position of the player and respawn
    the player at the start if they fall in. Water pits have the same effect but without
    the directional sound effects.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火坑会根据玩家的位置发出咆哮声，如果玩家掉入其中，则会在起点重生。水坑有相同的效果，但没有方向性音效。
- en: Cooperative gameplay. Both players will have to get their characters to the
    goal within the allotted time. They will need to work together frequently so that
    the shorter, lower-jumping Bob will need to stand on his friend's (Thomas') head.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合作游戏。两名玩家必须在规定时间内将他们的角色带到终点。他们需要经常合作，因为跳得较矮、跳跃能力较低的鲍勃需要站在他的朋友（托马斯）的头上。
- en: The player will have the option of switching between full and split-screen so
    they can attempt to control both characters themselves.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家可以选择在全屏和分屏之间切换，以便他们可以自己尝试控制两个角色。
- en: Each level will be designed in, and loaded from, a text file. This will make
    it easy to design varied and numerous levels.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关卡都将设计并从文本文件中加载。这将使得设计多样化和大量的关卡变得容易。
- en: 'Take a look at the following annotated screenshot of the game to see some of
    the features in action and the components/assets that make up the game:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下注释的截图，看看游戏中的某些功能是如何运作的，以及构成游戏的游戏组件/资产：
- en: '![](img/B14278_14_01a.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_14_01a.jpg)'
- en: 'Let''s look at each of these features and describe a few more:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些功能中的每一个，并描述一些更多：
- en: The preceding screenshot shows a simple HUD that details the level number and
    the number of seconds remaining until the player(s) fail and must restart the
    level.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的截图显示了一个简单的HUD，其中详细说明了关卡编号以及玩家（们）失败并必须重新开始关卡之前剩余的秒数。
- en: You can also clearly see the split-screen coop in action. Remember that this
    is optional. A single player can take on the game, fullscreen, while switching
    the camera focus between Thomas and Bob.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以清楚地看到分屏合作模式的效果。记住，这是可选的。单个玩家可以全屏玩游戏，同时切换摄像头焦点在托马斯和鲍勃之间。
- en: It is not very clear in the preceding screenshot (especially in print), but
    when a character dies, they will explode in a starburst/firework-like particle
    effect.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的截图（尤其是在印刷品中）中并不非常清晰，但当角色死亡时，它们将以星爆/烟花般的粒子效果爆炸。
- en: The water and fire tiles can be strategically placed to make the level fun,
    as well as forcing cooperation between the characters. More on this will be covered
    in [*Chapter 16*](B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327), *Building Playable
    Levels and Collision Detection*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水和火砖可以被战略性地放置，使关卡有趣，同时也迫使角色之间进行合作。关于这一点，将在[*第16章*](B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327)中详细说明，*构建可玩关卡和碰撞检测*。
- en: Next, notice Thomas and Bob. They are not only different in height but also
    have significantly varied jumping abilities. This means that Bob is dependent
    upon Thomas for big jumps, and levels can be designed to force Thomas to take
    a specific route to avoid him "banging his head".
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，注意托马斯和鲍勃。他们不仅身高不同，而且跳跃能力差异很大。这意味着鲍勃在跳跃时依赖于托马斯，关卡可以设计成迫使托马斯走一条特定的路线以避免他“撞头”。
- en: In addition, the fire tiles will emit a roaring sound. These will be relative
    to the position of Thomas. Not only will they be directional and come from either
    the left or right speaker, they will also get louder and quieter as Thomas moves
    closer to or further away from the source.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，火砖会发出咆哮声。这些声音将与托马斯的位置相关。它们不仅会根据方向从左或右扬声器发出，而且当托马斯靠近或远离声音源时，声音也会变得更大或更小。
- en: Finally, in the preceding annotated screenshot, you can see the background.
    Why not compare how that looks to the `background.png` file (shown later in this
    chapter)? You will see it is quite different. We will use OpenGL shader effects
    in [*Chapter 18*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356), *Particle Systems
    and Shaders*, to achieve the moving, almost bubbling, effect in the background.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在前面的注释截图中，你可以看到背景。为什么不比较一下它与`background.png`文件（本章后面将展示）的外观？你会发现它们相当不同。我们将在[*第18章*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356)中，*粒子系统和着色器*，使用OpenGL着色器效果来实现背景中移动的、几乎像冒泡的效果。
- en: All of these features warrant a few more screenshots so that we can keep the
    finished product in mind as we write the C++ code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都值得展示更多截图，这样我们可以在编写C++代码时记住最终产品。
- en: 'The following screenshot shows Thomas and Bob arriving at a fire pit that Bob
    has no chance of jumping over without help:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了托马斯和鲍勃到达一个火坑，鲍勃没有帮助就无法跳过去：
- en: '![](img/B14278_14_01b.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_14_01b.jpg)'
- en: 'The following screenshot shows Bob and Thomas collaborating to clear a precarious
    jump:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了鲍勃和托马斯合作清除一个危险的跳跃：
- en: '![](img/B14278_14_01c.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_14_01c.jpg)'
- en: 'The following screenshot shows how we can design puzzles where a "leap of faith"
    is required in order to reach the goal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了我们如何设计需要“信仰跳跃”才能达到目标的谜题：
- en: '![](img/B14278_14_01d.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_14_01d.jpg)'
- en: 'The following screenshot demonstrates how we can design oppressive cave systems
    of almost any size. We can also devise levels where Bob and Thomas are forced
    to split up and go different routes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了我们如何设计几乎任何大小的压抑洞穴系统。我们还可以设计鲍勃和托马斯被迫分开走不同路线的关卡：
- en: '![](img/B14278_14_01e.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_14_01e.jpg)'
- en: Creating the project
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Creating the Thomas Was Late project will follow the same procedure that we
    used in the previous three projects. Since creating a project is a slightly fiddly
    process, I will detail all the steps again here. For even more detail and images,
    refer to setting up the Timber!!! project in [*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017),
    *C++, SFML, Visual Studio, and Starting the First Game*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Thomas Was Late 项目将遵循我们在前三个项目中使用的相同程序。由于创建项目是一个稍微有些繁琐的过程，所以我将再次详细说明所有步骤。对于更多细节和图片，请参考[*第1章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)中设置
    Timber!!! 项目的步骤，*C++、SFML、Visual Studio 和开始第一个游戏*：
- en: Start Visual Studio and click on the **Create New Project** button. If you have
    another project open, you can select **File** | **New project**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 并点击**创建新项目**按钮。如果你已经打开了另一个项目，你可以选择**文件** | **新建项目**。
- en: In the window shown next, choose **Console app** and click the **Next** button.
    You will then see the **Configure your new project** window.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后显示的窗口中，选择**控制台应用程序**并点击**下一步**按钮。然后你会看到**配置你的新项目**窗口。
- en: In the `TWL` in the **Project** **name** field.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目名称**字段中的**TWL**。
- en: In the `VS Projects` folder.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VS Projects`文件夹中。
- en: Check the option to **Place solution and project in the same directory**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**将解决方案和项目放在同一目录下**的选项。
- en: When you have completed these steps, click **Create**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些步骤后，点击**创建**。
- en: We will now configure the project to use the SFML files that we put in the `SFML`
    folder. From the main menu, select **Project** | **TWL properties…**. At this
    stage, you should have the **TWL Property Pages** window open.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将配置项目以使用我们放在`SFML`文件夹中的 SFML 文件。从主菜单中选择**项目** | **TWL 属性…**。在这个阶段，你应该已经打开了**TWL
    属性页**窗口。
- en: In the **TWL Property Pages** window, take the following steps. Select **All
    Configurations** from the **Configuration:** dropdown.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TWL 属性页**窗口中，执行以下步骤。从**配置：**下拉菜单中选择**所有配置**。
- en: Now, select **C/C++** and then **General** from the left-hand menu.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从左侧菜单中选择**C/C++**然后**常规**。
- en: Now, locate the `\SFML\include`. The full path to type, if you located your
    `SFML` folder on your D drive, is `D:\SFML\include`. Vary your path if you installed
    SFML on a different drive.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定位到`\SFML\include`。如果你将`SFML`文件夹安装在 D 驱动器上，需要输入的完整路径是`D:\SFML\include`。如果你的
    SFML 安装在不同的驱动器上，请相应地更改路径。
- en: Click **Apply** to save your configurations so far.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Now, still in the same window, perform the following steps. From the left-hand
    menu, select **Linker** and then **General**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在这个窗口中，执行以下步骤。从左侧菜单中选择**链接器**然后**常规**。
- en: Now, find the `SFML` folder is, followed by `\SFML\lib`. So, the full path to
    type if you located your `SFML` folder on your D drive is `D:\SFML\lib`. Vary
    your path if you installed SFML to a different drive.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，找到`SFML`文件夹的位置，然后是`\SFML\lib`。所以，如果你将`SFML`文件夹安装在 D 驱动器上，需要输入的完整路径是`D:\SFML\lib`。如果你的
    SFML 安装在不同的驱动器上，请相应地更改路径。
- en: Click **Apply** to save your configurations so far.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Next, still in the same window, perform these steps. Switch the **Configuration:**
    dropdown to **Debug** as we will be running and testing Pong in debug mode.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，仍然在这个窗口中，执行以下步骤。将**配置：**下拉菜单切换到**调试**，因为我们将在调试模式下运行和测试 Pong。
- en: Select **Linker** and then **Input**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**链接器**然后**输入**。
- en: Find the `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`.
    Be extra careful to place the cursor exactly at the start of the edit box's current
    content so that you don't overwrite any of the text that is already there.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`。请格外小心地将光标放在编辑框当前内容的起始位置，以免覆盖任何已经存在的文本。
- en: Click **OK**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: Click **Apply** and then **OK**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**然后**确定**。
- en: 'That''s the project properties configured and ready to go. Now, we need to
    copy the SFML `.dll` files into the main project directory by following these
    steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么项目属性已经配置好，准备就绪。现在，我们需要按照以下步骤将 SFML `.dll` 文件复制到主项目目录中：
- en: My main project directory is `D:\VS Projects\TWL`. This folder was created by
    Visual Studio in the previous steps. If you put your `Projects` folder somewhere
    else, then perform this step there instead. The files we need to copy into the
    project folder are located in our `SFML\bin` folder. Open a window for each of
    the two locations and highlight all the `.dll` files.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的主要项目目录是`D:\VS Projects\TWL`。这个文件夹是在之前的步骤中由 Visual Studio 创建的。如果你将你的`Projects`文件夹放在其他地方，请在这里执行此步骤。我们需要复制到项目文件夹中的文件位于我们的`SFML\bin`文件夹中。为这两个位置打开一个窗口，并突出显示所有的`.dll`文件。
- en: Now, copy and paste the highlighted files into the project.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将高亮显示的文件复制并粘贴到项目中。
- en: The project is now set up and ready to go.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已经设置好，准备启动。
- en: The project's assets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的资源
- en: The assets in this project are even more numerous and diverse than the Zombie
    Arena game. As usual, the assets include a font for the writing on the screen,
    sound effects for different actions such as jumping, reaching the goal, or the
    distant roar of fire, and, of course, graphics for Thomas and Bob as well as a
    sprite sheet for all the background tiles.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目中的资源比Zombie Arena游戏更加众多和多样化。通常，资源包括屏幕上的文字字体、跳跃、达到目标或远处火的声音等不同动作的声音效果，以及当然，托马斯和鲍勃的图形以及所有背景瓦片的精灵图集。
- en: All of the assets that are required for this game are included in the download
    bundle. They can be found in the `Chapter 14/graphics` and `Chapter 14/sound`
    folders.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏所需的全部资源都包含在下载包中。它们可以在`Chapter 14/graphics`和`Chapter 14/sound`文件夹中找到。
- en: In addition to the graphics, sounds, and fonts that we have come to expect,
    this game has two new asset types. They are level design files and GLSL shader
    programs. Let's find out about each of them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已知的图形、声音和字体之外，这个游戏还有两种新的资源类型。它们是关卡设计文件和GLSL着色器程序。让我们了解它们各自的详情。
- en: Game level designs
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏关卡设计
- en: Levels are all created in a text file. By using the numbers 0 through 3, we
    can build level designs to challenge players. All the level designs are in the
    `levels` folder in the same directory as the other assets. Feel free to take a
    peek at one now, but we will look at them in detail in *Chapter 18*, *Particle
    Systems and Shaders*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 级别都是在一个文本文件中创建的。通过使用数字0到3，我们可以构建挑战玩家的关卡设计。所有的关卡设计都在与其它资源相同的目录下的`levels`文件夹中。现在你可以随意查看其中一个，但我们将在第18章*粒子系统和着色器*中详细探讨它们。
- en: In addition to these level design assets, we have a special type of graphical
    asset called **shaders**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些关卡设计资源之外，我们还有一种特殊的图形资源类型，称为**着色器**。
- en: GLSL shaders
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GLSL着色器
- en: '`Chapter 14/shaders` folder of the download bundle.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下载包中的`Chapter 14/shaders`文件夹。
- en: The graphical assets close up
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形资源概览
- en: 'The graphical assets make up the parts of the scene of our game. If you take
    a look at the graphical assets, it should be clear where in our game they will
    be used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图形资源构成了我们游戏场景的各个部分。如果你查看图形资源，应该很清楚它们在我们游戏中将被用于何处：
- en: '![](img/B14278_14_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_14_03.jpg)'
- en: If the tiles on the `tiles_sheet` graphic look a little different to the screenshots
    of the game, this is because they are partly transparent and the background showing
    through changes them a little. If the background graphic looks totally different
    to the actual background in the game screenshots, that is because the shader programs
    we will write will manipulate each and every pixel, each and every frame, to create
    a kind of "molten" effect.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`tiles_sheet`图形中的瓦片看起来与游戏截图略有不同，这是因为它们部分透明，背景透过会改变它们的样子。如果背景图形看起来与游戏截图中的实际背景完全不同，那是因为我们将编写的着色器程序将操纵每个像素，每一帧，以创建一种“熔化”效果。
- en: The sound assets close up
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音资源概览
- en: 'The sound files are all in `.wav` format. These files contain the sound effects
    that we will play at certain events throughout the game. They are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 声音文件都是`.wav`格式。这些文件包含我们在游戏中的某些事件中播放的声音效果。它们如下所示：
- en: '`fallinfire.wav`: A sound that will be played when the player''s head goes
    into fire and the player has no chance of escape.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallinfire.wav`：当玩家的头部进入火中且玩家没有逃脱机会时播放的声音。'
- en: '`fallinwater.wav`: Water has the same end effect as fire: death. This sound
    effect notifies the player that they need to start from the beginning of the level.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallinwater.wav`：水有与火相同的效果：死亡。这个声音效果会通知玩家他们需要从关卡开始处重新开始。'
- en: '`fire1.wav`: This sound effect is recorded in mono. It will be played at different
    volumes, based on the player''s distance from fire tiles and from different speakers
    based on whether the player is to the left or the right of the fire tile. Clearly,
    we will need to learn a few more tricks to implement this functionality.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fire1.wav`：这个声音效果是单声道的。它将在玩家距离火瓦片的不同距离处播放不同音量的声音，并且根据玩家是否位于火瓦片的左侧或右侧，通过不同的扬声器播放。显然，我们需要学习更多技巧来实现这一功能。'
- en: '`jump.wav`: A pleasing (slightly predictable) whooping sound for when the player
    jumps.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jump.wav`：当玩家跳跃时，一个令人愉悦（略带可预测性）的欢呼声。'
- en: '`reachgoal.wav`: A pleasing victory sound for when the player(s) get both characters
    (Thomas and Bob) to the goal tile.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reachgoal.wav`：当玩家（们）将托马斯和鲍勃两个角色都带到目标方块时，发出的令人愉悦的胜利声音。'
- en: The sound effects are very straightforward, and you can easily create your own.
    If you intend to replace the `fire1.wav` file, be sure to save your sounds in
    mono (not stereo) format. The reasons for this will be explained in [*Chapter
    17*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340), *Sound Spatialization and
    HUD.*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 音效非常直接，你可以轻松地创建自己的。如果你打算替换`fire1.wav`文件，请确保以单声道（不是立体声）格式保存你的声音。原因将在[*第17章*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340)中解释，*声音空间化和HUD*。
- en: Adding the assets to the project
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将资源添加到项目中
- en: Once you have decided which assets you will use, it is time to add them to the
    project. The following instructions will assume you are using all the assets that
    were supplied in this book's download bundle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定使用哪些资源，就是时候将它们添加到项目中了。以下说明将假设你使用的是本书下载包中提供的所有资源。
- en: 'Where you are using your own, simply replace the appropriate sound or graphic
    file with your own, using exactly the same filename. Let''s get started:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是自己的资源，只需用你自己的相应声音或图形文件替换，使用完全相同的文件名。让我们开始吧：
- en: Browse to the `D:\VS Projects\TWL` folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到`D:\VS Projects\TWL`文件夹。
- en: Create five new folders within this folder and name them `graphics`, `sound`,
    `fonts`, `shaders,` and `levels`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内创建五个新的文件夹，分别命名为`graphics`、`sound`、`fonts`、`shaders`和`levels`。
- en: From the download bundle, copy the entire contents of `Chapter 14/graphics`
    into the `D:\VS Projects\TWL\graphics` folder.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 14/graphics`目录下的全部内容复制到`D:\VS Projects\TWL\graphics`文件夹。
- en: From the download bundle, copy the entire contents of `Chapter 14/sound` into
    the `D:\VS Projects\TWL\sound` folder.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 14/sound`目录下的全部内容复制到`D:\VS Projects\TWL\sound`文件夹。
- en: Now, visit [http://www.dafont.com/roboto.font](http://www.dafont.com/roboto.font)
    in your web browser and download the **Roboto Light** font.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的网络浏览器中访问[http://www.dafont.com/roboto.font](http://www.dafont.com/roboto.font)并下载**Roboto
    Light**字体。
- en: Extract the contents of the zipped download and add the `Roboto-Light.ttf` file
    to the `D:\VS Projects\TWL\fonts` folder.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载内容，并将`Roboto-Light.ttf`文件添加到`D:\VS Projects\TWL\fonts`文件夹。
- en: From the download bundle, copy the entire contents of `Chapter 12/levels` into
    the `D:\VS Projects\TWL\levels` folder.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 12/levels`目录下的全部内容复制到`D:\VS Projects\TWL\levels`文件夹。
- en: From the download bundle, copy the entire contents of `Chapter 12/shaders` into
    the `D:\VS Projects\TWL\shaders` folder.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 12/shaders`目录下的全部内容复制到`D:\VS Projects\TWL\shaders`文件夹。
- en: Now that we have a new project, along with all the assets we will need for the
    entire project, we can talk about how we will structure the game engine code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的项目，以及整个项目所需的所有资源，我们可以谈谈我们将如何构建游戏引擎代码。
- en: Structuring the Thomas Was Late code
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建托马斯迟到的代码结构
- en: One of the problems that has been getting worse from project to project, despite
    taking measures to reduce the problem, is how long and unwieldy the code gets.
    **Object-oriented programming** (**OOP**) allows us to break our projects up into
    logical and manageable chunks, known as classes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经采取措施来减少问题，但项目与项目之间的问题却越来越严重，其中一个问题是代码变得越来越长且难以管理。**面向对象编程**（**OOP**）允许我们将项目分解成逻辑上和可管理的块，称为类。
- en: We will make a big improvement to the manageability of the code in this project
    with the introduction of an `Engine` class. Among other functions, the `Engine`
    class will have three private functions. These are `input`, `update`, and `draw`.
    These should sound very familiar. Each of these functions will hold a chunk of
    the code that was previously in the `main` function. Each of these functions will
    be in a code file of its own, that is, `Input.cpp`, `Update.cpp`, and `Draw.cpp`,
    respectively.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入`Engine`类，我们将大幅提高本项目代码的可管理性。除了其他功能外，`Engine`类将包含三个私有函数。这些是`input`、`update`和`draw`。这些听起来应该非常熟悉。每个这些函数都将包含之前在`main`函数中的一部分代码。每个这些函数都将位于自己的代码文件中，即`Input.cpp`、`Update.cpp`和`Draw.cpp`，分别。
- en: 'There will also be one public function in the `Engine` class, which can be
    called with an instance of `Engine`. This function is `run` and will be responsible
    for calling `input`, `update`, and `draw` once for each frame of the game:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engine`类还将有一个公共函数，可以通过`Engine`实例调用。这个函数是`run`，它将负责在每一帧游戏中分别调用`input`、`update`和`draw`：'
- en: '![](img/B14278_14_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_14_06.jpg)'
- en: 'Furthermore, because we have abstracted the major parts of the game engine
    to the `Engine` class, we can also move many of the variables from `main` and
    make them members of `Engine`. All we need to do to get our game engine fired
    up is create an instance of `Engine` and call its `run` function. Here is a sneak
    preview of the super-simple `main` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们已经将游戏引擎的主要部分抽象到了`Engine`类中，我们还可以将许多变量从`main`移动到`Engine`中，使其成为成员。要启动我们的游戏引擎，我们只需要创建一个`Engine`实例并调用它的`run`函数。以下是一个超级简单的`main`函数的预览：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't add the previous code just yet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要添加之前的代码。
- en: To make our code even more manageable and readable, we will also abstract responsibility
    for big tasks such as loading a level and collision detection to separate functions
    (in separate code files). These two functions are `loadLevel` and `detectCollisions`.
    We will also code other functions to handle some of the new features of the Thomas
    Was Late project. We will cover them in detail, as and when they occur.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更加易于管理和阅读，我们还将把加载关卡和碰撞检测等大型任务的责任抽象到单独的函数（在单独的代码文件中）。这两个函数是`loadLevel`和`detectCollisions`。我们还将编写其他函数来处理托马斯迟到项目的一些新功能。我们将详细讨论它们，在它们出现时。
- en: To further take advantage of OOP, we will delegate responsibility for areas
    of the game entirely to new classes. You probably remember that the sound and
    HUD code was quite lengthy in previous projects. We will build a `SoundManager`
    and `HUD` class to handle these aspects in a cleaner manner. Exactly how they
    work will be explored in depth when we implement them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步利用面向对象编程，我们将把游戏的一些区域的责任完全委托给新的类。你可能还记得，在之前的项目中，声音和HUD代码相当长。我们将构建一个`SoundManager`和`HUD`类来以更整洁的方式处理这些方面。它们是如何工作的，我们将在实现它们时进行深入探讨。
- en: The game levels themselves are also much more in-depth than previous games,
    so we will also code a `LevelManager` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏关卡本身也比之前的游戏更加深入，因此我们也将编写一个`LevelManager`类。
- en: 'As you would expect, the playable characters will be made with classes as well.
    For this project, however, we will learn some more C++ and implement a `PlayableCharacter`
    class with all the common functionality of Thomas and Bob. Then, the `Thomas`
    and `Bob` classes will *inherit* this common functionality as well as implementing
    their own unique functions and abilities. This technique, perhaps unsurprisingly,
    is called **inheritance**. I will go into more detail about inheritance in the
    next chapter: [*Chapter 15*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306),
    *Advanced OOP – Inheritance and Polymorphism*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，可玩角色也将通过类来创建。然而，对于这个项目，我们将学习更多C++知识，并实现一个包含托马斯和鲍勃所有常见功能的`PlayableCharacter`类。然后，`Thomas`和`Bob`类将继承这些常见功能，同时实现它们自己的独特功能和能力。这种技术，也许不出所料，被称为**继承**。我将在下一章中详细介绍继承：[*第15章*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306)，*高级面向对象编程
    – 继承和多态*。
- en: We will also implement several other classes to perform specific responsibilities.
    For example, we will make some neat explosions using particle systems. You might
    be able to guess that, to do this, we will code a `Particle` class and a `ParticleSystem`
    class. All these classes will have instances that are members of the `Engine`
    class. Doing things this way will make all the features of the game accessible
    from the game engine but encapsulate the details into the appropriate classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现几个其他类来执行特定的责任。例如，我们将使用粒子系统制作一些漂亮的爆炸效果。你可能已经猜到，为了做到这一点，我们将编写一个`Particle`类和一个`ParticleSystem`类。所有这些类都将有作为`Engine`类成员的实例。这样做将使游戏的所有功能都可通过游戏引擎访问，但将细节封装到适当的类中。
- en: Tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that despite these new techniques to separate out the different aspects
    of our code, by the end of this project, we will still have some slightly unwieldy
    classes. The final project of this book, while a much simpler shooter game, will
    explore one more way of organizing our code to make it manageable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们采用了这些新技术来分离代码的不同方面，但到这个项目的最后，我们仍然会有些不太容易管理的类。本书的最终项目，虽然是一个更简单的射击游戏，将探索一种组织代码的新方法，使其易于管理。
- en: The last thing to mention before we move on to seeing the actual code that will
    make the `Engine` class is that we will reuse, without any changes whatsoever,
    the `TextureHolder` class that we discussed and coded for the Zombie Arena game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查看将创建`Engine`类的实际代码之前，最后要提到的是，我们将完全不加修改地重用我们为僵尸竞技场游戏讨论和编写的`TextureHolder`类。
- en: Building the game engine
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏引擎
- en: As we suggested in the previous section, we will code a class called `Engine`
    that will control and bind the different parts of the Thomas Was Late game.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中建议的，我们将编写一个名为`Engine`的类，该类将控制并绑定《托马斯迟到了》游戏的不同部分。
- en: The first thing we will do is make the `TextureHolder` class from the previous
    project available in this one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将上一个项目中的`TextureHolder`类应用到这个项目中。
- en: Reusing the TextureHolder class
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新使用TextureHolder类
- en: The `TextureHolder` class that we discussed and coded for the Zombie Arena game
    will also be useful in this project. While it is possible to add the files (`TextureHolder.h`
    and `TextureHolder.cpp`) directly from the previous project, without recoding
    them or recreating the files, I don't want to assume that you haven't jumped straight
    to this project. What follows is very brief instructions, along with the complete
    code listing we need, to create the `TextureHolder` class. If you want the class
    or the code explained, please see [*Chapter 10*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214),
    *Pointers, the Standard Template Library, and Texture Management*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在《僵尸竞技场》游戏中讨论并编写的`TextureHolder`类也将在这个项目中很有用。虽然我们可以直接从上一个项目中添加文件（`TextureHolder.h`和`TextureHolder.cpp`），而不需要重新编码或重新创建文件，但我不想假设你直接跳到了这个项目。以下是非常简短的说明，以及我们需要创建`TextureHolder`类所需的完整代码列表。如果你想了解该类或代码的解释，请参阅[*第10章*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)，*指针、标准模板库和纹理管理*。
- en: Tip
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you did complete the previous project and you *do* want to add the class
    from the Zombie Arena project, simply do the following. In the `TextureHolder.h`
    from the previous project and select it. In the `TextureHolder.cpp` from the previous
    project and select it. You can now use the `TextureHolder` class in this project.
    Note that the files are shared between projects and any changes will take effect
    in both projects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了上一个项目，并且确实想添加《僵尸竞技场》项目中的类，请按照以下步骤操作。在上一项目的`TextureHolder.h`中右键点击并选择它。在上一项目的`TextureHolder.cpp`中右键点击并选择它。你现在可以在本项目中使用`TextureHolder`类。请注意，这些文件在项目之间是共享的，任何更改都将影响两个项目。
- en: To create the `TextureHolder` class from scratch, right-click `TextureHolder.h`.
    Finally, click the **Add** button.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头创建`TextureHolder`类，右键点击`TextureHolder.h`。最后，点击**添加**按钮。
- en: 'Add the following code to `TextureHolder.h`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TextureHolder.h`中：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Right-click `TextureHolder.cpp`. Finally, click the **Add** button.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`TextureHolder.cpp`。最后，点击**添加**按钮。
- en: 'Add the following code to `TextureHolder.cpp`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TextureHolder.cpp`中：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can now get on with our new `Engine` class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续我们的新`Engine`类。
- en: Coding Engine.h
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coding Engine.h
- en: As usual, we will start with the header file, which holds the function declarations
    and member variables. Note that we will revisit this file throughout the project
    to add more functions and member variables. At this stage, we will add just the
    code that is necessary.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从头文件开始，它包含函数声明和成员变量。请注意，我们将在整个项目中重新访问此文件以添加更多函数和成员变量。在这个阶段，我们将只添加必要的代码。
- en: Right-click `Engine.h`. Finally, click the `Engine` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`Engine.h`。最后，点击`Engine`类。
- en: 'Add the following member variables, as well as the function declarations. Many
    of them we have seen before in the other projects and some of them were discussed
    in the *Structuring the Thomas Was Late Code* section. Take note of the function
    and variable names, as well as whether they are private or public. Add the following
    code to the `Engine.h` file and then we will talk about it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下成员变量以及函数声明。其中许多我们在其他项目中已经见过，一些在*《托马斯迟到了》代码结构*部分中讨论过。请注意函数和变量名，以及它们是私有还是公共的。将以下代码添加到`Engine.h`文件中，然后我们将讨论它：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a complete run down of all the private variables and functions. Where
    it is appropriate, I will spend a little longer on the explanation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有私有变量和函数的完整列表。在适当的地方，我会花更多的时间来解释：
- en: '`TextureHolder th`: The one and only instance of the `TextureHolder` class.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextureHolder th`：`TextureHolder`类的唯一实例。'
- en: '`TILE_SIZE`: A useful constant to remind us that each tile in the sprite-sheet
    is 50 pixels wide and 50 pixels high.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TILE_SIZE`：一个有用的常量，提醒我们精灵图集中的每个图块宽度为50像素，高度为50像素。'
- en: '`VERTS_IN_QUAD`: A useful constant to make our manipulation of a `VertexArray`
    less error-prone. There are, in fact, four vertices in a quad. Now, we can''t
    forget it.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERTS_IN_QUAD`：一个有用的常量，可以使我们对`VertexArray`的操作更不容易出错。实际上，一个四边形有四个顶点。现在，我们不要忘记它。'
- en: '`GRAVITY`: A constant int value representing the number of pixels by which
    the game characters will be pushed downward each second. This is quite a fun value
    to play with once the game is done. We initialize it to 300 here as this works
    well for our initial level designs.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GRAVITY`：一个表示游戏角色每秒将被向下推多少像素的常量整数值。一旦游戏完成，这是一个很有趣的值来玩。我们在这里将其初始化为 300，因为这对我们的初始关卡设计来说效果很好。'
- en: '`m_Window`: The usual `RenderWindow` object that we have had in all our projects.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_Window`：我们所有项目中都有的常规 `RenderWindow` 对象。'
- en: 'The SFML `View` objects, `m_MainView`, `m_LeftView`, `m_RightView`, `m_BGMainView`:
    `m_BGLeftView`, `m_BGRightView`, and `m_HudView`: The first three `View` objects
    are for the full screen view and the left and right and split-screen views of
    the game. We also have a separate SFML `View` object for each of those three,
    which will draw the background behind. The last `View` object, `m_HudView`, will
    be drawn on top of the appropriate combination of the other six views to display
    the score, the remaining time, and any messages to the players. Having seven different
    `View` objects might imply complexity, but when you see how we deal with them
    as the chapter progresses, you will see they are quite straightforward. We will
    have the whole split-screen/full screen conundrum sorted out by the end of this
    chapter.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML `View` 对象，`m_MainView`、`m_LeftView`、`m_RightView`、`m_BGMainView`：`m_BGLeftView`、`m_BGRightView`
    和 `m_HudView`：前三个 `View` 对象用于全屏视图以及游戏的左右和分割屏幕视图。我们还有一个单独的 SFML `View` 对象用于这三个视图，它将绘制背景。最后一个
    `View` 对象，`m_HudView`，将绘制在其他六个视图的适当组合之上，以显示得分、剩余时间和对玩家的任何消息。拥有七个不同的 `View` 对象可能意味着复杂性，但当你看到随着章节的进展我们如何处理它们时，你会发现它们相当简单。我们将在本章结束时解决整个分割屏幕/全屏的难题。
- en: '`Sprite m_BackgroundSprite` and `Texture m_BackgroundTexture`: Somewhat predictably,
    this combination of SFML Sprite and Texture will be for showing and holding the
    background graphic from the graphics assets folder.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite m_BackgroundSprite` 和 `Texture m_BackgroundTexture`：有些可以预见，这个 SFML
    Sprite 和 Texture 的组合将用于显示和保存来自图形资源文件夹的背景图形。'
- en: '`m_Playing`: This Boolean will keep the game engine informed about whether
    the level has started yet (by pressing the *Enter* key). The player does not have
    the option to pause the game once they have started it.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_Playing`：这个布尔值将让游戏引擎知道关卡是否已经开始（通过按下 *Enter* 键）。一旦开始，玩家没有暂停游戏的选择。'
- en: '`m_Character1`: When the screen is full screen, should it center on Thomas
    (`m_Character1` `= true`) or Bob (`m_Character1 = false`)? Initially, it is initialized
    to true, to center on Thomas.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_Character1`：当屏幕全屏时，应该以托马斯（`m_Character1` `= true`）为中心，还是以鲍勃（`m_Character1
    = false`）为中心？最初，它被初始化为 true，以托马斯为中心。'
- en: '`m_SplitScreen`: This variable is used to determine whether the game currently
    being played is in split-screen mode or not. We will use this variable to decide
    how exactly to use all the View objects we declared a few steps ago.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_SplitScreen`：这个变量用于确定当前正在玩的游戏是否处于分割屏幕模式。我们将使用这个变量来决定如何确切地使用我们之前声明过的所有视图对象。'
- en: '`m_TimeRemaining` variable: This `float` variable holds how much time (in seconds)
    is remaining to get to the goal of the current level. In the previous code, it
    is set to 10 for the purposes of testing, until we get to set a specific time
    for each level.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_TimeRemaining` 变量：这个 `float` 变量保存了到达当前关卡目标剩余的时间（以秒为单位）。在之前的代码中，它被设置为 10
    用于测试，直到我们为每个关卡设置一个特定的时间。'
- en: '`m_GameTimeTotal` variable: This variable is an SFML `Time` object. It keeps
    track of how long the game has been played for.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_GameTimeTotal` 变量：这个变量是一个 SFML `Time` 对象。它记录了游戏已经进行了多长时间。'
- en: '`m_NewLevelRequired` Boolean variable: This variable keeps an eye on whether
    the player has just completed or failed a level. We can then use it to trigger
    loading the next level or restarting the current level.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_NewLevelRequired` 布尔变量：这个变量关注玩家是否刚刚完成或失败了某个关卡。然后我们可以使用它来触发加载下一个关卡或重新开始当前关卡。'
- en: 'The `input` function: This function will handle all the player''s input, which
    in this game is entirely from the keyboard. At first glance, it would appear that
    it handles all the keyboard input directly. In this game, however, we will be
    handling keyboard input that directly affects Thomas or Bob within the `Thomas`
    and `Bob` classes. This function will also handle keyboard input such as quitting,
    switching to split-screen, and any other keyboard input.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input` 函数：这个函数将处理所有玩家的输入，在这个游戏中，输入完全来自键盘。乍一看，它似乎直接处理所有键盘输入。然而，在这个游戏中，我们将处理直接影响托马斯或鲍勃的键盘输入，这些输入在`Thomas`和`Bob`类中。此函数还将处理退出、切换到分屏和其他键盘输入等操作。'
- en: 'The `update` function: This function will do all the work that we previously
    did in the update section of the `main` function. We will also call some other
    functions from the `update` function in order to keep the code organized. If you
    look back at the code, you will see that it receives a `float` parameter that
    will hold the fraction of a second that has passed since the previous frame. This,
    of course, is just what we need to update all our game objects.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update` 函数：这个函数将执行我们之前在`main`函数更新部分所做的所有工作。我们还将从`update`函数中调用其他一些函数，以保持代码的整洁。如果你回顾一下代码，你会看到它接收一个`float`参数，该参数将保存自上一帧以来经过的秒数的分数。这当然正是我们更新所有游戏对象所需要的。'
- en: 'The `draw` function: This function will hold all the code that used to go in
    the drawing section of the main function in previous projects. We will, however,
    have some drawing code that is not kept in this function when we look at other
    ways to draw with SFML. We will see this new code when we learn about particle
    systems in [*Chapter 18*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356), *Particle
    Systems and Shaders*.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw` 函数：这个函数将包含之前项目中主函数绘图部分的所有代码。然而，当我们查看使用 SFML 绘图的其他方法时，我们将有一些绘图代码不会保留在这个函数中。我们将在学习[*第18章*](B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356)“粒子系统和着色器”时看到这段新代码。'
- en: 'Now, let''s run through all the public functions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行所有公共函数：
- en: 'The `Engine` constructor function: As we have come to expect, this function
    will be called when we first declare an instance of `Engine`. It will do all the
    setup and initialization of the class. We will see exactly what when we code the
    `Engine.cpp` file shortly.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine` 构造函数：正如我们所期待的，当我们首次声明`Engine`实例时，这个函数将被调用。它将执行类的所有设置和初始化。我们将在稍后编写`Engine.cpp`文件时看到具体内容。'
- en: 'The `run` function: This is the only public function that we need to call.
    It will trigger the execution of `input`, `update`, and `draw`, and will do all
    the work for us.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run` 函数：这是我们唯一需要调用的公共函数。它将触发`input`、`update`和`draw`的执行，并为我们完成所有工作。'
- en: Next, we will see the definitions of all these functions and some of the variables
    in action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到所有这些函数的定义和一些变量的实际应用。
- en: Coding Engine.cpp
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Engine.cpp
- en: In all our previous classes, we have put all the function definitions into the
    `.cpp` file prefixed with the class name. As our aim for this project is to make
    the code more manageable, we are doing things a little differently.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有类中，我们都将所有函数定义放入以类名命名的`.cpp`文件中。由于我们这个项目的目标是使代码更易于管理，所以我们采取了一些不同的做法。
- en: In the `Engine.cpp` file, we will place the constructor (`Engine`) and the public
    `run` function. The rest of the functions will be going in their own `.cpp` file
    with a name that makes it clear which function goes where. This will not be a
    problem for the compiler if we add the appropriate include directive (`#include
    "Engine.h"`)at the top of all the files that contain function definitions from
    the `Engine` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Engine.cpp`文件中，我们将放置构造函数（`Engine`）和公共的`run`函数。其余的函数将放在它们自己的`.cpp`文件中，文件名将清楚地表明哪个函数放在哪里。如果我们向包含`Engine`类函数定义的所有文件顶部添加适当的包含指令（`#include
    "Engine.h"`），这不会成为编译器的问题。
- en: Let's get started by coding `Engine` and running it in `Engine.cpp`. Right-click
    `Engine.cpp`. Finally, click the `.cpp` file for the `Engine` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写`Engine`类代码并运行`Engine.cpp`文件开始。右键单击`Engine.cpp`。最后，单击`Engine`类的`.cpp`文件。
- en: Coding the Engine class constructor definition
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Engine 类构造函数定义
- en: The code for this function will go in the `Engine.cpp` file we have recently
    created.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码将放在我们最近创建的`Engine.cpp`文件中。
- en: 'Add the following code and then we can discuss it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码后，我们就可以讨论它了：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have seen much of this code before. For example, there are the usual lines
    of code to get the screen resolution, as well as to create a `RenderWindow`. At
    the end of the previous code, we use the now-familiar code to load a texture and
    assign it to a Sprite. In this case, we are loading the `background.png` texture
    and assigning it to `m_BackgroundSprite`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到过很多这样的代码。例如，有获取屏幕分辨率以及创建 `RenderWindow` 的常规代码行。在之前的代码末尾，我们使用现在熟悉的代码来加载一个纹理并将其分配给
    Sprite。在这种情况下，我们正在加载 `background.png` 纹理并将其分配给 `m_BackgroundSprite`。
- en: It is the code in between the four calls to the `setViewport` function that
    needs some explanation. The `setViewport` function assigns a portion of the screen
    to an SFML `View` object. It doesn't work with pixel coordinates, however. It
    works using a ratio. Here, "1" is the entire screen (width or height). The first
    two values in each call to `setViewport` are the starting position (horizontally
    then vertically), while the last two are the ending position.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的是在四次调用 `setViewport` 函数之间的代码。`setViewport` 函数将屏幕的一部分分配给一个 SFML `View` 对象。然而，它不使用像素坐标，而是使用比例。在这里，“1”代表整个屏幕（宽度或高度）。每次调用
    `setViewport` 的前两个值是起始位置（水平然后垂直），而最后两个是结束位置。
- en: Notice that `m_LeftView` and `m_BGLeftView` are placed in exactly the same place,
    that is, starting on virtually the far-left (0.001) of the screen and ending two-thousandths
    from the center (0.498).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `m_LeftView` 和 `m_BGLeftView` 放置在完全相同的位置，即从屏幕的虚拟最左侧（0.001）开始，延伸到中心的两千分之一（0.498）。
- en: '`m_RightView` and `m_BGRightView` are also in exactly the same position as
    each other, starting just right of the previous two `View` objects (0.5) and extending
    to almost the far-right-hand side (0.998).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_RightView` 和 `m_BGRightView` 也位于彼此的完全相同的位置，从之前的两个 `View` 对象的右侧（0.5）开始，延伸到几乎最右侧（0.998）。'
- en: Furthermore, all the views leave a tiny slither of a gap at the top and bottom
    of the screen. When we draw these `View` objects on the screen, on top of a white
    background, it will have the effect of splitting the screen with a thin white
    line between the two sides of the screen, as well as a thin white border around
    the edges.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有视图在屏幕顶部和底部都留有一小段间隙。当我们将这些 `View` 对象绘制到屏幕上，在白色背景之上时，它将在屏幕两侧之间产生一条细白线，以及边缘的细白边框。
- en: 'I have tried to represent this effect in the following diagram:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试在以下图中表示这个效果：
- en: '![](img/Image90695.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image90695.jpg)'
- en: The best way to understand it is to finish this chapter, run the code, and see
    it in action.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理解它的最好方法是完成这一章，运行代码，并看到它的实际效果。
- en: Coding the run function definition
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 `run` 函数定义的代码
- en: The code for this function will go in the `Engine.cpp` file we have recently
    created.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码将放入我们最近创建的 `Engine.cpp` 文件中。
- en: 'Add the following code immediately after the previous constructor code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的构造函数代码之后立即添加以下代码：
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `run` function is the center of our engine; it initiates all the other
    parts. First, we declare a `Clock` object. Next, we have the familiar `while(window.isOpen())`
    loop, which creates the game loop. Inside this while loop, we do the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 函数是我们引擎的中心；它启动所有其他部分。首先，我们声明一个 `Clock` 对象。接下来，我们有熟悉的 `while(window.isOpen())`
    循环，它创建游戏循环。在这个 while 循环内部，我们执行以下操作：'
- en: Restart `clock` and save the time that the previous loop took in `dt.`
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动 `clock` 并将前一个循环所花费的时间保存到 `dt` 中。
- en: Keep track of the total time elapsed in `m_GameTimeTotal.`
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `m_GameTimeTotal` 中跟踪已过总时间。
- en: Declare and initialize a `float` to represent the fraction of a second that
    elapsed during the previous frame.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化一个 `float` 来表示上一帧经过的秒数的一部分。
- en: Call `input.`
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `input`。
- en: Call `update`, passing in the elapsed time (`dtAsSeconds`).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `update`，传入经过的时间（`dtAsSeconds`）。
- en: Call `draw.`
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `draw`。
- en: All of this should look very familiar. What's new is that it is wrapped in the
    `run` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些看起来应该非常熟悉。新的地方是它被包裹在 `run` 函数中。
- en: Coding the input function definition
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 `input` 函数定义的代码
- en: As we explained previously, the code for the `input` function will go in its
    own file because it is more extensive than the constructor or the `run` function.
    We will use `#include "Engine.h"` and prefix the function signature with `Engine::`
    to make sure the compiler is aware of our intentions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的那样，`input` 函数的代码将放入它自己的文件中，因为它比构造函数或 `run` 函数更复杂。我们将使用 `#include "Engine.h"`
    并在函数签名前加上 `Engine::` 前缀，以确保编译器了解我们的意图。
- en: Right-click `Input.cpp`. Finally, click the `input` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `Input.cpp`。最后，点击 `input` 函数。
- en: 'Add the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE6]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Like the previous projects, we check the `RenderWindow` event queue each frame.
    Also like we''ve already done before, we detect specific keyboard keys using `if
    (Keyboard::isKeyPressed...`. The most relevant information in the code we just
    added is what the keys do:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前的几个项目，我们每帧都会检查 `RenderWindow` 事件队列。同样，我们也像之前做的那样，使用 `if (Keyboard::isKeyPressed...`
    检测特定的键盘键。我们刚刚添加的代码中最相关的信息是这些键的功能：
- en: As per usual, the *Esc* key closes the window and the game will quit.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同往常，*Esc* 键会关闭窗口，并且游戏将退出。
- en: The *Enter* key sets `m_Playing` to true and eventually this will have the effect
    of starting the level.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Enter* 键将 `m_Playing` 设置为 true，最终这将导致开始关卡。'
- en: The *Q* key alternates the value of `m_Character1` between true and false. This
    key only has an effect in full screen mode. It will switch between Thomas and
    Bob being the center of the main `View`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q* 键在 `m_Character1` 的值之间交替切换为 true 和 false。此键仅在全屏模式下有效。它将在托马斯和鲍勃之间切换为主 `View`
    的中心。'
- en: The *E* keyboard key switches `m_SplitScreen` between true and false. This will
    have the effect of switching between full screen and split-screen views.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E* 键盘键在 `m_SplitScreen` 之间切换为 true 和 false。这将导致在全屏和分割屏幕视图之间切换。'
- en: Most of this keyboard functionality will be fully working by the end of this
    chapter. We are getting close to being able to run our game engine. Next, let's
    code the `update` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，大部分键盘功能将完全可用。我们越来越接近能够运行我们的游戏引擎。接下来，让我们编写 `update` 函数。
- en: Coding the update function definition
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 `update` 函数定义
- en: As we explained previously, the code for this function will go in its own file
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，这个函数的代码将放在它自己的文件中，因为它比构造函数或 `run` 函数更复杂。我们将使用 `#include "Engine.h"`
    并在函数签名前加上 `Engine::` 前缀，以确保编译器了解我们的意图。
- en: Right-click `Update.cpp`. Finally, click the `update` function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `Update.cpp`。最后，点击 `update` 函数。
- en: 'Add the following code to the `Update.cpp` file to implement the `update` function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Update.cpp` 文件中以实现 `update` 函数：
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, notice that the `update` function receives the time the previous frame
    took as a parameter. This, of course, will be essential for the update function
    to fulfill its role.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意 `update` 函数接收前一个帧所花费的时间作为参数。这当然对于 `update` 函数履行其角色至关重要。
- en: The previous code doesn't achieve anything visible at this stage. It does put
    in the structure that we will require for future chapters. It subtracts the time
    the previous frame took from `m_TimeRemaining` and checks whether time has run
    out. If it has, it sets `m_NewLevelRequired` to `true`. All this code is wrapped
    in an `if` statement that only executes when `m_Playing` is `true`. The reason
    for this is that, like the previous projects, we don't want time advancing and
    objects updating when the game has not started.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，之前的代码没有实现任何可见的功能。它确实为我们未来章节所需的结构奠定了基础。它从 `m_TimeRemaining` 中减去前一个帧所花费的时间，并检查时间是否已用完。如果时间已用完，它将
    `m_NewLevelRequired` 设置为 `true`。所有这些代码都包含在一个只有当 `m_Playing` 为 `true` 时才执行的 `if`
    语句中。这样做的原因是，如同之前的几个项目，我们不希望在游戏未开始时时间前进和对象更新。
- en: We will build on this code as the project continues.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的继续，我们将在此基础上构建代码。
- en: Coding the draw function definition
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 `draw` 函数定义
- en: As we explained previously, the code for this function will go in its own file
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，这个函数的代码将放在它自己的文件中，因为它比构造函数或 `run` 函数更复杂。我们将使用 `#include "Engine.h"`
    并在函数签名前加上 `Engine::` 前缀，以确保编译器了解我们的意图。
- en: Right-click `Draw.cpp`. Finally click the `draw` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `Draw.cpp`。最后点击 `draw` 函数。
- en: 'Add the following code to the `Draw.cpp` file to implement the `draw` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Draw.cpp` 文件中以实现 `draw` 函数：
- en: '[PRE8]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the previous code, there is nothing we haven''t seen before. The code starts,
    as usual, by clearing the screen. In this project, we clear the screen with White.
    What''s new is the way the different drawing options are separated by a condition
    that checks whether the screen is currently split or not:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，没有我们之前没有见过的内容。代码像往常一样从清除屏幕开始。在这个项目中，我们使用白色清除屏幕。新的地方在于不同的绘图选项是通过检查屏幕是否当前分割的条件来分隔的：
- en: '[PRE9]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the screen is not split, we draw the background sprite in the background
    `View` (`m_BGView`) and then switch to the main full screen `View` (`m_MainView`).
    Note that, currently, we don't do any drawing in `m_MainView`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕没有分割，我们在背景`View`（`m_BGView`）中绘制背景精灵，然后切换到主全屏`View`（`m_MainView`）。请注意，目前我们并没有在`m_MainView`中进行任何绘制。
- en: If, on the other hand, the screen is split, the code in the `else` block is
    executed and we draw `m_BGLeftView` with the background sprite on the left of
    the screen, followed by switching to `m_LeftView`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果屏幕分割，则执行`else`块中的代码，我们使用屏幕左侧的背景精灵绘制`m_BGLeftView`，然后切换到`m_LeftView`。
- en: Then, still in the `else` block, we draw `m_BGRightView` with the background
    sprite on the right of the screen, followed by switching to `m_RightView`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，仍然在`else`块中，我们在屏幕右侧使用背景精灵绘制`m_BGRightView`，然后切换到`m_RightView`。
- en: Outside of the `if` `else` structure we just described, we switch to the `m_HUDView`.
    At this stage, we are not actually drawing anything in `m_HUDView`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才描述的`if` `else`结构之外，我们切换到`m_HUDView`。在这个阶段，我们实际上并没有在`m_HUDView`中绘制任何东西。
- en: Like  the other two (`input`, `update`) of the three most significant functions,
    we will go back to the `draw` function often. We will add new elements for our
    game that need to be drawn. You will notice that, each time we do, we will add
    code into each of the main, left-hand, and right-hand sections.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他两个（`input`、`update`）三个最重要的函数一样，我们经常会回到`draw`函数。我们将为游戏添加需要绘制的新元素。你会注意到，每次我们这样做时，我们都会在主、左手和右手部分添加代码。
- en: Let's quickly recap on the `Engine` class and then we can fire it up.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下`Engine`类，然后我们可以启动它。
- en: The Engine class so far
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止的`Engine`类
- en: What we have done is abstract  all the code that used to be in the `main` function
    into the `input`, `update`, and `draw` functions. The continuous looping of these
    functions, as well as the timing, is handled by the `run` function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将原来在`main`函数中的所有代码抽象到`input`、`update`和`draw`函数中。这些函数的连续循环以及计时由`run`函数处理。
- en: 'Consider leaving the **Input.cpp**, **Update.cpp**, and **Draw.cpp** tabs open
    in Visual Studio, perhaps organized in order, as shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在Visual Studio中保留**Input.cpp**、**Update.cpp**和**Draw.cpp**标签页打开，可能按照以下截图所示进行组织：
- en: '![](img/B14278_14_09.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_14_09.jpg)'
- en: We will revisit each of these functions throughout the course of the project
    and add more code. Now that we have the basic structure and functionality of the
    `Engine` class, we can create an instance of it in the `main` function and see
    it in action.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个项目过程中回顾每个这些函数，并添加更多代码。现在，我们已经有了`Engine`类的基本结构和功能，我们可以在`main`函数中创建它的实例，并看到它的实际效果。
- en: Coding the main function
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写主函数
- en: Let's rename the `TFL.cpp` file that was autogenerated when the project was
    created to `Main.cpp`. Right-click the `TFL` file in the `Main.cpp`. This will
    be the file that contains our `main` function and the code that instantiates the
    `Engine` class.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将项目创建时自动生成的`TFL.cpp`文件重命名为`Main.cpp`。在`Main.cpp`中右键点击`TFL`文件。这将是我们包含`main`函数和实例化`Engine`类代码的文件。
- en: 'Add the following code to `Main.cpp`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Main.cpp`中：
- en: '[PRE10]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All we do is add an `include` directive for the `Engine` class, declare an instance
    of `Engine`, and then call its `run` function. Everything will be handled by the
    `Engine` class until the player quits and the execution returns to `main` and
    the `return 0` statement.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切只是为`Engine`类添加一个`include`指令，声明一个`Engine`实例，然后调用它的`run`函数。直到玩家退出，执行返回到`main`和`return
    0`语句之前，一切都将由`Engine`类处理。
- en: That was easy. Now, we can run the game and see the empty background, either
    in full screen or split-screen, which will eventually contain all the action.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。现在，我们可以运行游戏并看到空白的背景，无论是全屏还是分屏，最终将包含所有动作。
- en: 'Here is the game so far in full screen mode, showing just the background:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到目前为止的全屏模式下的游戏，只显示背景：
- en: '![](img/B14278_14_10.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_14_10.jpg)'
- en: 'Now, tap the *E* key. You will be able to see the screen neatly partitioned
    into two halves, ready for split-screen coop gameplay:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按一下*E*键。你将能够看到屏幕整洁地分成两半，准备进行分屏合作游戏：
- en: '![](img/B14278_14_11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_14_11.jpg)'
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the Thomas Was Late game and laid the foundations
    of understanding as well as the code structure for the rest of the project. It
    is certainly true that there are a lot of files in the Solution Explorer but,
    provided we understand the purpose of each, we will find the implementation of
    the rest of the project quite easy.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了《托马斯迟到了》游戏，并为理解以及整个项目的代码结构奠定了基础。当然，在解决方案资源管理器中确实有很多文件，但如果我们理解了每个文件的目的，我们会发现整个项目的其余部分实现起来相当容易。
- en: In the next chapter, we will learn about two more fundamental C++ topics, inheritance
    and polymorphism. We will also begin to put them to use by building three classes
    to represent two playable characters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习两个更基础的C++主题，继承和多态。我们还将通过构建三个类来代表两个可玩角色，开始将它们应用到实践中。
- en: FAQ
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'Here is a question that might be on your mind:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可能出现在你脑海中的问题：
- en: Q) I don't fully understand the structure of the code files. What should I do?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我不完全理解代码文件的结构。我该怎么做？
- en: A) It is true that abstraction can make the structure of our code less clear,
    but the actual code itself becomes so much easier. Instead of cramming everything
    into the `main` function like we did in the previous projects, we will split the
    code up into `Input.cpp`, `Update.cpp`, and `Draw.cpp`. Furthermore, we will use
    more classes to group together related code as we proceed. Study the *Structuring
    the Thomas Was Late code* section again, especially the diagrams.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: A) 确实，抽象可能会使我们的代码结构变得不那么清晰，但实际的代码本身会变得容易得多。与我们在之前的项目中一样，将所有内容都塞进`main`函数中，我们将代码拆分为`Input.cpp`、`Update.cpp`和`Draw.cpp`。此外，随着我们的进行，我们将使用更多的类来将相关的代码分组在一起。再次研究《托马斯迟到了代码结构》部分，特别是那些图表。
