- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Designing and Developing APIs in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中设计和开发API
- en: In the world of software development, the design of **application programming
    interfaces** (**APIs**) is of paramount importance. Good APIs serve as the backbone
    of software libraries, facilitating interaction between different software components
    and enabling developers to leverage functionality efficiently and effectively.
    Well-designed APIs are intuitive, easy to use, and maintainable, playing a crucial
    role in the success and longevity of software projects. In this chapter, we will
    delve into principles and practices for designing maintainable APIs for libraries
    developed in C++. We will explore key aspects of API design, including clarity,
    consistency, and extensibility, and provide concrete examples to illustrate best
    practices. By understanding and applying these principles, you will be able to
    create APIs that not only meet the immediate needs of users but also remain robust
    and adaptable over time, ensuring that your libraries are both powerful and user-friendly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的世界里，**应用程序编程接口**（API）的设计至关重要。好的API是软件库的骨架，促进不同软件组件之间的交互，使开发者能够高效有效地利用功能。设计良好的API直观、易用且可维护，在软件项目的成功和持久性中扮演着关键角色。在本章中，我们将深入探讨为在C++中开发的库设计可维护API的原则和实践。我们将探讨API设计的要点，包括清晰性、一致性和可扩展性，并提供具体示例来说明最佳实践。通过理解和应用这些原则，您将能够创建不仅满足用户当前需求，而且随着时间的推移保持稳健和适应性强的API，确保您的库既强大又用户友好。
- en: Principles of minimalistic API design
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简约API设计原则
- en: 'Minimalistic APIs are designed to provide only the essential functionalities
    required to perform specific tasks, avoiding unnecessary features and complexity.
    The primary goal is to offer a clean, efficient, and user-friendly interface that
    facilitates easy integration and usage. Key benefits of minimalistic APIs include
    the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简约API旨在提供执行特定任务所需的必要功能，避免不必要的特性和复杂性。主要目标是提供一个干净、高效且用户友好的界面，便于轻松集成和使用。简约API的关键优势包括以下内容：
- en: '**Ease of use**: Users can quickly understand and utilize the API without extensive
    learning or documentation, promoting faster development cycles'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：用户可以快速理解和利用API，无需进行广泛的学习或查阅文档，从而促进更快的开发周期'
- en: '**Maintainability**: Simplified APIs are easier to maintain, allowing for straightforward
    updates and bug fixes without introducing new complexities'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：简化的API更容易维护，允许进行简单的更新和错误修复，而不会引入新的复杂性'
- en: '**Performance**: Leaner APIs tend to have better performance due to reduced
    overhead and more efficient execution paths'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：由于减少了开销和更高效的执行路径，更轻量级的API往往具有更好的性能'
- en: '**Reliability**: With fewer components and interactions, the likelihood of
    bugs and unexpected issues is minimized, leading to more reliable and stable software'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：由于组件和交互较少，错误和意外问题的可能性最小化，从而使得软件更加可靠和稳定'
- en: 'Simplicity and clarity are fundamental principles in the design of minimalistic
    APIs. These principles ensure that the API remains accessible and user-friendly,
    enhancing the overall developer experience. Key aspects of simplicity and clarity
    include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁和清晰是设计简约API的基本原则。这些原则确保API保持可访问性和用户友好性，从而提升整体开发体验。简洁和清晰的关键方面包括以下内容：
- en: '**Straightforward interfaces**: Designing simple and clear interfaces helps
    developers quickly grasp the available functionalities, making it easier to integrate
    and use the API effectively'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直观界面**：设计简单明了的界面有助于开发者快速掌握可用功能，使其更容易集成并有效使用API'
- en: '**Reduced cognitive load**: By minimizing the mental effort required to understand
    and use the API, developers are less likely to make mistakes, leading to more
    efficient development processes'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低认知负荷**：通过最小化理解和使用API所需的脑力劳动，开发者犯错误的可能性降低，从而提高开发过程的效率'
- en: '**Intuitive design**: An API that adheres to simplicity and clarity aligns
    closely with common usage patterns and developer expectations, making it more
    intuitive and easier to adopt'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直观设计**：遵循简洁和清晰的API与常见的使用模式和开发者期望紧密一致，使其更加直观且易于采用'
- en: 'Overengineering and unnecessary complexity can severely undermine the effectiveness
    of an API. To avoid these pitfalls, consider the following strategies:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 过度设计和不必要的复杂性会严重削弱API的有效性。为了避免这些陷阱，请考虑以下策略：
- en: '**Focus on core functionality**: Concentrate on delivering essential features
    that address the primary use cases. Avoid adding extraneous features that are
    not directly aligned with the core purpose of the API.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注核心功能**：专注于提供解决主要用例的基本功能。避免添加与API核心目的不直接相关的额外功能。'
- en: '**Iterative design**: Begin with a **minimum viable product** (**MVP**) and
    incrementally add features based on user feedback and actual needs rather than
    speculative requirements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代设计**：从**最小可行产品（MVP）**开始，并根据用户反馈和实际需求逐步添加功能，而不是基于推测性需求。 '
- en: '**Clear documentation**: Provide comprehensive yet concise documentation that
    focuses on core functionality and common use cases. This helps prevent confusion
    and misuse.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的文档**：提供全面而简洁的文档，重点关注核心功能和常见用例。这有助于防止混淆和误用。'
- en: '**Consistent naming conventions**: Use consistent and descriptive names for
    functions, classes, and parameters to enhance clarity and predictability.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的命名约定**：为函数、类和参数使用一致且描述性的名称，以增强清晰性和可预测性。'
- en: '**Minimal dependencies**: Reduce the number of external dependencies to simplify
    the integration process and minimize potential compatibility issues.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小依赖性**：减少外部依赖项的数量以简化集成过程并最小化潜在的兼容性问题。'
- en: Techniques for achieving minimalism
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现极简主义的技术
- en: Functional decomposition is the process of breaking down complex functionalities
    into smaller, more manageable units. This technique is crucial for creating minimalistic
    APIs as it promotes simplicity and modularity. By decomposing functions, you ensure
    that each part of the API has a clear, well-defined purpose, which enhances maintainability
    and usability.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分解是将复杂功能分解成更小、更易于管理的单元的过程。这项技术对于创建极简API至关重要，因为它促进了简单性和模块化。通过分解函数，你确保API的每个部分都有一个清晰、明确的目的，这增强了可维护性和可用性。
- en: 'Key aspects of functional decomposition include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分解的关键方面包括以下内容：
- en: '**Modular design**: Design the API such that each module or function handles
    a specific aspect of the overall functionality. This **separation of concerns**
    (**SoC**) ensures that each part of the API has a clear, well-defined purpose.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化设计**：设计API，使每个模块或函数处理整体功能的一个特定方面。这种**关注点分离（SoC）**确保API的每个部分都有一个清晰、明确的目的。'
- en: '**Single Responsibility Principle (SRP)**: Each function or class should have
    one, and only one, reason to change. This principle helps in keeping the API simple
    and focused.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则（SRP）**：每个函数或类应该只有一个，并且只有一个，改变的理由。这一原则有助于保持API简单并专注于目标。'
- en: '**Reusable components**: By decomposing functions into smaller units, you can
    create reusable components that can be combined in different ways to achieve various
    tasks, enhancing the flexibility and reusability of the API.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用组件**：通过将函数分解成更小的单元，可以创建可重用组件，这些组件可以以不同的方式组合来实现各种任务，从而增强API的灵活性和可重用性。'
- en: Interface segregation aims to keep interfaces lean and focused on specific tasks,
    avoiding the design of monolithic interfaces that try to cover too many use cases.
    This principle ensures that clients only need to know about the methods that are
    relevant to them, making the API easier to use and understand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接口分离旨在保持接口精简并专注于特定任务，避免设计试图覆盖过多用例的单一接口。这一原则确保客户端只需了解与他们相关的方 法，使API更容易使用和理解。
- en: 'Key aspects of interface segregation include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接口分离的关键方面包括以下内容：
- en: '**Specific interfaces**: Instead of one large, general-purpose interface, design
    multiple smaller, specific interfaces. Each interface should cater to a specific
    aspect of the functionality.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定接口**：而不是一个大型、通用接口，设计多个较小、特定的接口。每个接口应针对功能的一个特定方面。'
- en: '**User-centric design**: Consider the needs of the end users of your API. Design
    interfaces that are intuitive and provide only methods they need for their tasks,
    avoiding unnecessary complexity.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以用户为中心的设计**：考虑API的最终用户的需要。设计直观的接口，只提供他们完成任务所需的方法，避免不必要的复杂性。'
- en: '**Reduced client impact**: Smaller, focused interfaces minimize the impact
    on clients when changes are necessary. Clients using a specific interface are
    less likely to be affected by changes in unrelated functionality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少客户端影响**：较小的、专注的接口在需要更改时对客户端的影响最小。使用特定接口的客户端不太可能受到无关功能更改的影响。'
- en: 'Let us consider an example where a complex API class is responsible for various
    features, such as loading, processing, and saving data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中复杂的API类负责各种功能，如加载、处理和保存数据：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The major issue is that the class has too many responsibilities, mixing different
    data sources and sinks, leading to complexity and lack of focus. Let us start
    with extracting the loading and processing functionalities into separate classes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是该类承担了过多的责任，混合了不同的数据源和目的地，导致复杂性和缺乏专注。让我们从将加载和处理功能提取到单独的类开始：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to extract the saving functionalities into separate classes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将保存功能提取到单独的类中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Minimizing the number of dependencies required by the API is crucial for achieving
    minimalism. Fewer dependencies lead to a more stable, reliable, and maintainable
    API. Dependencies can complicate integration, increase the risk of compatibility
    issues, and make the API harder to understand.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化API所需的依赖数量对于实现简约至关重要。更少的依赖导致API更稳定、可靠和易于维护。依赖关系可能会复杂化集成，增加兼容性问题风险，并使API更难理解。
- en: 'Key strategies for reducing dependencies include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 减少依赖的关键策略包括以下内容：
- en: '**Core functionality focus**: Concentrate on implementing core functionalities
    within the API itself, avoiding reliance on external libraries or components unless
    absolutely necessary.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心功能重点**：专注于在API内部实现核心功能，除非绝对必要，否则避免依赖外部库或组件。'
- en: '**Selective use of libraries**: When external libraries are required, choose
    those that are stable, well maintained, and widely used. Ensure that they align
    closely with the needs of your API.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性使用库**：当需要外部库时，选择那些稳定、维护良好且广泛使用的库。确保它们与API的需求紧密一致。'
- en: '**Decoupled design**: Design the API in a way that it can function independently
    of external components as much as possible. Use **dependency injection** (**DI**)
    or other design patterns to decouple the implementation from specific dependencies.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦设计**：尽可能设计API使其能够独立于外部组件运行。使用**依赖注入**（**DI**）或其他设计模式将实现与特定依赖解耦。'
- en: '**Version management**: Carefully manage and specify versions of any dependencies
    to avoid compatibility issues. Ensure that updates to dependencies do not break
    the API or introduce instability.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本管理**：仔细管理和指定任何依赖的版本，以避免兼容性问题。确保依赖的更新不会破坏API或引入不稳定性。'
- en: Real-world examples of minimalistic API design
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简约API设计的现实世界示例
- en: 'To solidify our understanding of these concepts, we will examine a few real-world
    examples of API design in C++. These examples will highlight common challenges
    and effective solutions, demonstrating how to apply the principles of good API
    design in practical scenarios. Through these examples, we aim to provide clear,
    actionable insights that you can apply to your own projects, ensuring that your
    APIs are not only functional but also elegant and maintainable. Let’s dive into
    the intricacies of real-world API design and see how these principles come to
    life in practice:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们对这些概念的理解，我们将检查几个C++中API设计的现实世界示例。这些示例将突出常见挑战和有效解决方案，展示如何在实际场景中应用良好的API设计原则。通过这些示例，我们旨在提供清晰、可操作的见解，您可以将它们应用于自己的项目，确保您的API不仅功能齐全，而且优雅且易于维护。让我们深入了解现实世界API设计的复杂性，并看看这些原则如何在实践中发挥作用：
- en: '**JSON for Modern C++ (nlohmann/json)**: This library is an excellent example
    of minimalistic API design. It provides intuitive and straightforward methods
    for parsing, serializing, and manipulating JSON data in C++ and has the following
    benefits:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现代C++的JSON（nlohmann/json）**：这个库是简约API设计的优秀示例。它提供了直观且直接的方法来解析、序列化和操作C++中的JSON数据，并具有以下优点：'
- en: '**Simplicity**: Clear and concise interface that is easy to use.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：清晰简洁的界面，易于使用。'
- en: '**Functional decomposition**: Each function handles a specific task related
    to JSON processing.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能分解**：每个函数处理与JSON处理相关的特定任务。'
- en: '**Minimal dependencies**: Designed to work with the C++ Standard Library, avoiding
    unnecessary external dependencies:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小依赖**：设计为与C++标准库一起工作，避免不必要的外部依赖：'
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**SQLite C++ Interface (SQLiteCpp)**: This library offers a minimalistic interface
    for interacting with SQLite databases in C++. It has the following benefits:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite C++接口（SQLiteCpp）**：这个库为使用C++与SQLite数据库交互提供了一个简约的接口。它有以下优点：'
- en: '**Simplicity**: Provides a straightforward and clear API for database operations.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：提供直观且清晰的数据库操作 API。'
- en: '**Interface segregation**: Separate classes for different database operations
    such as queries and transactions.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：为不同的数据库操作（如查询和事务）创建不同的类。'
- en: '**Minimal dependencies**: Built to use SQLite and the C++ Standard Library:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小依赖性**：构建用于 SQLite 和 C++ 标准库：'
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Common pitfalls and how to avoid them
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱及其避免方法
- en: 'Overcomplication occurs when the API design includes unnecessary features or
    complexity, making it difficult to use and maintain. Here’s how to mitigate this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 设计包含不必要的功能或复杂性时，会发生过度复杂化，使其难以使用和维护。以下是减轻这种情况的方法：
- en: '**Avoidance strategy**: Focus on core functionalities required by the end users.
    Regularly review the API design to eliminate any unnecessary features.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免策略**：关注最终用户所需的核心功能。定期审查 API 设计，以消除任何不必要的功能。'
- en: 'Feature creep happens when additional features are continually added to the
    API, leading to increased complexity and reduced usability. Here’s how you can
    avoid this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 功能蔓延发生在不断向 API 添加额外功能时，导致复杂性增加和可用性降低。以下是您可以避免这种情况的方法：
- en: '**Avoidance strategy**: Implement a strict feature prioritization process.
    Ensure that new features are aligned with the core purpose of the API and are
    necessary for the target users.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免策略**：实施严格的特性优先级排序流程。确保新特性与 API 的核心目的相一致，并且对于目标用户来说是必要的。'
- en: Important caveats of developing shared libraries in C++
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中开发共享库的重要注意事项
- en: Developing shared libraries in C++ requires careful consideration to ensure
    compatibility, stability, and usability. Originally, shared libraries were intended
    to promote code reuse, modularity, and efficient memory usage, allowing multiple
    programs to use the same library code simultaneously. This approach was expected
    to reduce redundancy, save system resources, and provide the ability to replace
    only parts of applications. While this approach worked well for widely used libraries,
    such as `libc`, `libstdc++`, OpenSSL, and others, it proved to be less efficient
    for applications. Shared libraries provided with an application can rarely be
    spotlessly replaced with a newer version. Usually, it is required to replace the
    whole installation kit, which includes the application and all its dependencies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中开发共享库需要仔细考虑以确保兼容性、稳定性和可用性。最初，共享库旨在促进代码重用、模块化和高效内存使用，允许多个程序同时使用相同的库代码。这种方法预计可以减少冗余、节省系统资源，并能够仅替换应用程序的部分。虽然这种方法对于广泛使用的库（如
    `libc`、`libstdc++`、OpenSSL 等）效果良好，但它对于应用程序来说效率较低。与应用程序一起提供的共享库很少能够完美地替换为较新版本。通常，需要替换整个安装套件，包括应用程序及其所有依赖项。
- en: Nowadays, shared libraries are often used to enable interoperability between
    different programming languages. For instance, a C++ library might be used in
    applications written in Java or Python. This cross-language functionality extends
    the usability and reach of the library but introduces certain complexities and
    caveats that developers must consider.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，共享库通常用于实现不同编程语言之间的互操作性。例如，C++ 库可能被用于用 Java 或 Python 编写的应用程序中。这种跨语言功能扩展了库的可用性和范围，但同时也引入了某些复杂性和注意事项，开发者必须考虑。
- en: Shared libraries within a single project
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个项目内的共享库
- en: If the shared library is designed to be used within a single project and loaded
    by an executable compiled with the same compiler, then shared objects (or DLLs)
    with C++ interfaces are generally acceptable. However, this approach comes with
    caveats, such as the use of singletons, which can lead to issues with multithreading
    and unexpected initialization order. When singletons are used, managing their
    initialization and destruction in a multithreaded environment can be challenging,
    leading to potential race conditions and unpredictable behavior. Additionally,
    ensuring the correct order of initialization and destruction of global state is
    complex, which can result in subtle and hard-to-diagnose bugs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果共享库设计为在单个项目中使用，并且由使用相同编译器编译的可执行文件加载，那么具有 C++ 接口的共享对象（或 DLL）通常是可接受的。然而，这种方法存在一些注意事项，例如单例的使用，这可能导致多线程问题和意外的初始化顺序。当使用单例时，在多线程环境中管理它们的初始化和销毁可能具有挑战性，可能导致潜在的竞争条件和不可预测的行为。此外，确保全局状态初始化和销毁的正确顺序很复杂，这可能导致微妙且难以诊断的错误。
- en: Shared libraries for wider distribution
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于更广泛分发的共享库
- en: If the shared library is expected to be distributed more widely, where the developers
    cannot predict the compiler used by the end users or if the library might be used
    from other programming languages, then C++ shared libraries are not an ideal choice.
    This is primarily because the C++ `libc` or operating system syscalls, which are
    also in C. A common solution to this problem is to develop a C wrapper around
    the C++ code and ship the C interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期共享库将被更广泛地分发，开发者无法预测最终用户使用的编译器，或者如果库可能被用于其他编程语言，那么 C++ 共享库并不是一个理想的选择。这主要是因为
    C++ 的 `libc` 或操作系统系统调用，它们也在 C 中。解决这个问题的常见方法是在 C++ 代码周围开发一个 C 封装器，并附带 C 接口。
- en: Example – MessageSender class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - `MessageSender` 类
- en: Next is an example demonstrating this approach, where we create a C++ `MessageSender`
    class and provide a C wrapper for it. The class has a constructor that initializes
    a `MessageSender` instance with a specified receiver and two overloaded `send`
    methods that allow sending messages either as a `std::vector<uint8_t>` instance
    or as a raw pointer with a specified length. The implementation prints messages
    to the console to demonstrate functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了这种方法，其中我们创建了一个 C++ 的 `MessageSender` 类，并为它提供了一个 C 封装器。该类有一个构造函数，用于使用指定的接收者初始化
    `MessageSender` 实例，并且有两个重载的 `send` 方法，允许以 `std::vector<uint8_t>` 实例或指定长度的原始指针的形式发送消息。实现将消息打印到控制台以展示功能。
- en: 'Here’s the C++ library implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 C++ 库的实现：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the C wrapper implementation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 C 封装器的实现：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the C++ `MessageSender` class is defined in the `MessageSender.hpp`
    and `MessageSender.cpp` files. The class has a constructor that initializes a
    `MessageSender` instance with a specified receiver and two overloaded `send` methods
    that allow sending messages either as a `std::vector<uint8_t>` instance or as
    a raw pointer with a specified length. The implementation prints messages to the
    console to demonstrate functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，C++ 的 `MessageSender` 类定义在 `MessageSender.hpp` 和 `MessageSender.cpp`
    文件中。该类有一个构造函数，用于使用指定的接收者初始化 `MessageSender` 实例，并且有两个重载的 `send` 方法，允许以 `std::vector<uint8_t>`
    实例或指定长度的原始指针的形式发送消息。实现将消息打印到控制台以展示功能。
- en: To make this C++ class usable from other programming languages or with different
    compilers, we create a C wrapper. The C wrapper is defined in the `MessageSender.h`
    and `MessageSenderC.cpp` files. The header file uses an `extern "C"` block to
    ensure that the C++ functions are callable from C, preventing name mangling. The
    C wrapper uses an opaque handle, `void*` (typedef as `MessageSenderHandle`), to
    represent the `MessageSender` instance in C, abstracting the actual C++ class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个 C++ 类可以从其他编程语言或不同的编译器中使用，我们创建了一个 C 封装器。C 封装器定义在 `MessageSender.h` 和 `MessageSenderC.cpp`
    文件中。头文件使用 `extern "C"` 块来确保 C++ 函数可以从 C 中调用，防止名称修饰。C 封装器使用不透明的句柄 `void*`（定义为 `MessageSenderHandle`），在
    C 中表示 `MessageSender` 实例，抽象了实际的 C++ 类。
- en: The `create_message_sender` function allocates and initializes a `MessageSender`
    instance and returns a handle to it. Note that it uses `new(std::nothrow)` to
    avoid throwing exceptions in case of memory allocation failure. C or any other
    programming language that does not support exceptions can still use this function
    without issues.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_message_sender` 函数分配并初始化一个 `MessageSender` 实例，并返回其句柄。请注意，它使用 `new(std::nothrow)`
    以避免在内存分配失败时抛出异常。即使 C 或其他不支持异常的编程语言也可以无问题地使用此函数。'
- en: The `destroy_message_sender` function deallocates the `MessageSender` instance
    to ensure proper cleanup. The `send_message` function calls the corresponding
    `send` method on the `MessageSender` instance using the handle, facilitating message
    sending.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy_message_sender` 函数释放 `MessageSender` 实例，以确保正确清理。`send_message` 函数使用句柄调用
    `MessageSender` 实例上的相应 `send` 方法，从而简化消息发送过程。'
- en: By handling memory allocation and deallocation within the same binary, this
    approach avoids issues related to different memory allocators being used by the
    end user, which can lead to memory corruption or leaks. The C wrapper provides
    a stable and consistent interface that can be used across different compilers
    and languages, ensuring greater compatibility and stability. This method addresses
    the complexities of developing shared libraries and ensures their broad usability
    and reliability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在同一个二进制文件内处理内存分配和释放，这种方法避免了与最终用户使用不同内存分配器相关的问题，这些问题可能导致内存损坏或泄漏。C包装器提供了一个稳定且一致的接口，可以在不同的编译器和语言中使用，确保更高的兼容性和稳定性。这种方法解决了开发共享库的复杂性，并确保它们的广泛可用性和可靠性。
- en: 'If the C++ library is expected to throw exceptions, it is important to handle
    them properly in C wrapper functions to prevent exceptions from propagating to
    the caller. For example, we can have the following exception types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预计C++库会抛出异常，那么在C包装器函数中正确处理这些异常是很重要的，以防止异常传播到调用者。例如，我们可以有以下异常类型：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, the C wrapper functions can catch these exceptions and return appropriate
    error codes or messages to the caller:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，C包装器函数可以捕获这些异常，并向调用者返回适当的错误代码或消息：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we use `std::abort` in case of an unknown exception, as it is not
    safe to propagate unknown exceptions across language boundaries.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在遇到未知异常时，我们使用`std::abort`，因为将未知异常传播到语言边界是不安全的。
- en: This example illustrates how to create a C wrapper around a C++ library to ensure
    compatibility and stability when developing shared libraries. By following these
    guidelines, developers can create robust, maintainable, and widely compatible
    shared libraries, ensuring their usability across various platforms and programming
    environments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了如何创建一个C包装器来确保在开发共享库时的兼容性和稳定性。遵循这些指南，开发者可以创建健壮、可维护且广泛兼容的共享库，确保它们在各种平台和编程环境中的可用性。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored critical aspects of designing and developing shared
    libraries in C++. Shared libraries were initially conceived to promote code reuse,
    modularity, and efficient memory usage by allowing multiple programs to utilize
    the same library code simultaneously. This approach reduces redundancy and conserves
    system resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了设计和开发C++共享库的关键方面。共享库最初是为了促进代码重用、模块化和高效内存使用而设计的，允许多个程序同时利用相同的库代码。这种方法减少了冗余并节省了系统资源。
- en: We delved into the nuances of developing shared libraries for different contexts.
    When the shared library is intended for use within a single project and compiled
    with the same compiler, shared objects (or DLLs) with C++ interfaces can be suitable,
    albeit with caution around singletons and global state to avoid multithreading
    issues and unpredictable initialization order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了在不同上下文中开发共享库的细微差别。当共享库打算在单个项目中使用并与相同的编译器编译时，具有C++接口的共享对象（或DLL）可能是合适的，尽管需要小心处理单例和全局状态，以避免多线程问题和不可预测的初始化顺序。
- en: However, for wider distribution where the end user’s compiler or programming
    language might differ, using C++ shared libraries directly is less advisable due
    to the instability of the C++ ABI across different compilers and versions. To
    overcome this, we discussed creating a C wrapper around the C++ code, leveraging
    the stable C ABI for broader compatibility and cross-language functionality.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更广泛的分发，如果最终用户的编译器或编程语言可能不同，由于C++ ABI在不同编译器和版本之间的不稳定性，直接使用C++共享库就不太可取。为了克服这一点，我们讨论了在C++代码周围创建C包装器，利用稳定的C
    ABI以实现更广泛的兼容性和跨语言功能。
- en: We provided a comprehensive example using a `MessageSender` class, illustrating
    how to create a C++ library and its corresponding C wrapper. The example emphasized
    safe memory management by ensuring allocation and deallocation within the same
    binary and handling exceptions gracefully by representing them with an enumerated
    status in the C interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个使用`MessageSender`类的综合示例，说明了如何创建C++库及其相应的C包装器。示例强调了通过确保在同一个二进制文件内进行分配和释放以及通过在C接口中以枚举状态表示来优雅地处理异常来安全地管理内存。
- en: By following these guidelines, developers can create robust, maintainable, and
    widely compatible shared libraries, ensuring their usability across various platforms
    and programming environments. This chapter equips developers with the necessary
    knowledge to address common caveats and implement best practices in shared library
    development, fostering effective and reliable software solutions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些指南，开发者可以创建健壮、可维护且广泛兼容的共享库，确保它们在各种平台和编程环境中的可用性。本章为开发者提供了解决常见问题并在共享库开发中实施最佳实践所需的知识，从而培养出有效且可靠的软件解决方案。
- en: In the next chapter, we will shift our focus to code formatting, exploring best
    practices for creating clear, consistent, and readable code, which is essential
    for collaboration and long-term maintenance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的重点转向代码格式化，探讨创建清晰、一致和可读代码的最佳实践，这对于协作和长期维护至关重要。
