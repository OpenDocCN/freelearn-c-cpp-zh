["```cpp\n    #include <iostream>\n    #include <vector>\n    #include <climits>\n    using namespace std;\n    ```", "```cpp\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0int start;\u00a0\u00a0\u00a0\u00a0// The starting vertex\n    \u00a0\u00a0\u00a0\u00a0int end;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// The destination vertex\n    \u00a0\u00a0\u00a0\u00a0int weight;\u00a0\u00a0\u00a0// The edge weight\n    \u00a0\u00a0\u00a0\u00a0// Constructor\n    \u00a0\u00a0\u00a0\u00a0Edge(int s, int e, int w) : start(s), end(e), weight(w) {}\n    };\n    ```", "```cpp\n    const int UNKNOWN = INT_MAX;\n    vector<Edge*> edges; \u00a0\u00a0// Collection of edge pointers\n    int V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Total number of vertices in the graph\n    int E;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Total number of edges in the graph\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0cin >> V >> E;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < E; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int node_a, node_b, weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> node_a >> node_b >> weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Add a new edge using the defined constructor\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges.push_back(new Edge(node_a, node_b, weight));\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Choose a starting node\n    \u00a0\u00a0\u00a0\u00a0int start;\n    \u00a0\u00a0\u00a0\u00a0cin >> start;\n    \u00a0\u00a0\u00a0\u00a0// Run the Bellman-Ford algorithm on the graph for \n    \u00a0\u00a0\u00a0\u00a0// the chosen starting vertex \n    \u00a0\u00a0\u00a0\u00a0BellmanFord(start);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void BellmanFord(int start)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<int> distance(V, UNKNOWN);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[start] = 0;\n    ```", "```cpp\n    // Perform V - 1 iterations\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Iterate over entire set of edges\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = edge->start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = edge->end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Skip nodes which have not yet been considered\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the current distance value for the destination\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// node is greater than the sum of the source node's\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// distance and the edge's weight, change its distance\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// to the lesser value.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] + w < distance[v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[v] = distance[u] + w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    cout << \"DISTANCE FROM VERTEX \" << start << \":\\n\"\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0cout << \"\\t\" << i << \": \";\n    \u00a0\u00a0\u00a0\u00a0if(distance[i] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Unvisited\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0cout << distance[i] << endl;\n    }\n    ```", "```cpp\n    5 5\n    0 1 3\n    1 2 5\n    1 3 10\n    3 2 -7\n    2 4 2\n    0\n    ```", "```cpp\n    DISTANCE FROM VERTEX 0:\n    \u00a0\u00a0\u00a0\u00a00: 0\n    \u00a0\u00a0\u00a0\u00a01: 3\n    \u00a0\u00a0\u00a0\u00a02: 6\n    \u00a0\u00a0\u00a0\u00a03: 13\n    \u00a0\u00a0\u00a0\u00a04: 8\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0// Iterate through edges one last time\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = edge->start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = edge->end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = edge->weight;\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] + w < distance[v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"NEGATIVE CYCLE FOUND\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    void BellmanFord(int start)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance(V, UNKNOWN);\n    \u00a0\u00a0\u00a0\u00a0distance[start] = 0;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 1; i < V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = edge->start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = edge->end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] + w < distance[v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[v] = distance[u] + w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = edge->start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = edge->end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] + w < distance[v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"NEGATIVE CYCLE FOUND\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0cout << \"DISTANCE FROM VERTEX \" << start << \":\\n\";\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\\t\" << i << \": \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[i] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Unvisited\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << distance[i] << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    6 8\n    0 1 3\n    1 3 -8\n    2 1 3\n    2 5 5\n    3 2 3\n    2 4 2\n    4 5 -1\n    5 1 8\n    0\n    ```", "```cpp\n    NEGATIVE CYCLE FOUND\n    ```", "```cpp\n3\nSE -10\nSE -8\nS -6\nS 7\nE -10\nS 20\nE -1\nNE 5\n```", "```cpp\n0 \u2014> 3 (-10)\n3 \u2014> 6 (+7)\n6 \u2014> 7 (-1)\n7 \u2014> 4 (+5)\n4 \u2014> 5 (-10)\n5 \u2014> 8 (+20)\n(-10) + 7 + (-1) + 5 + (-10) + 20 \n= 11 more units of energy\n```", "```cpp\nW(uv) = w(uv) + d[s, u] - d[s, v]\n```", "```cpp\nAB \u2014> (-7) +   0  \u2013 (-7) = 0\nBC \u2014> (-2) + (-7) \u2013 (-9) = 0\nCA \u2014>  10  + (-9) \u2013   0  = 1\nAD \u2014> (-5) +   0  \u2013 (-5) = 0\nDE \u2014>   4  + (-5) \u2013 (-1) = 0\n```", "```cpp\n(w(AB) + d[s, A] - d[s, B]) + (w(BC) + d[s, B] - d[s, C]) + \u2026 + (w(DE) + d[s, D] - d[s, E])\n(w(AB) + w(BC) + w(CA) + w(AD) + w(DE)) + d[s, A] - d[s, E]\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <climits>\n    using namespace std;\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0int start;\n    \u00a0\u00a0\u00a0\u00a0int end;\u00a0\u00a0 \n    \u00a0\u00a0\u00a0\u00a0int weight;\n    \u00a0\u00a0\u00a0\u00a0Edge(int s, int e, int w) : start(s), end(e), weight(w) {}\n    };\n    const int UNKNOWN = INT_MAX;\n    vector<Edge*> edges;\n    int V; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n    int E; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n    ```", "```cpp\n    vector<int> BellmanFord(int V, vector<Edge*> edges)\n    ```", "```cpp\n    vector<int> distance(V + 1, UNKNOWN);\n    int s = V;\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0edges.push_back(new Edge(s, i, 0));\n    }\n    distance[s] = 0;\n    ```", "```cpp\n    for(int i = 1; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = edge->start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = edge->end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] + w < distance[v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[v] = distance[u] + w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    bool HasNegativeCycle(vector<int> distance, vector<Edge*> edges)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = edge->start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = edge->end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] == UNKNOWN) continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[u] + w < distance[v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    if(HasNegativeCycle(distance, edges))\n    {\n    \u00a0\u00a0\u00a0\u00a0cout << \"NEGATIVE CYCLE FOUND\" << endl;\n    \u00a0\u00a0\u00a0\u00a0return {};\n    }\n    ```", "```cpp\n    vector<int> Dijkstra(int V, int start, vector<Edge*> edges)\n    ```", "```cpp\n    vector<int> distance(V, UNKNOWN);\n    vector<bool> visited(V, false);\n    distance[start] = 0;\n    ```", "```cpp\n    // Find vertex with shortest distance from current position and\n    // return its index\n    int GetMinDistance(vector<int> &distance, vector<bool> &visited)\n    {\n    \u00a0\u00a0\u00a0\u00a0int minDistance = UNKNOWN;\n    \u00a0\u00a0\u00a0\u00a0int result;\n    \u00a0\u00a0\u00a0\u00a0for(int v = 0; v < distance.size(); v++)\n    \u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(!visited[v] && distance[v] <= minDistance)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minDistance = distance[v];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    for(int i = 0; i < V - 1; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Find index of unvisited node with shortest distance\n    \u00a0\u00a0\u00a0\u00a0int curr = GetMinDistance(distance, visited);\n    \u00a0\u00a0\u00a0\u00a0visited[curr] = true;\n    \u00a0\u00a0\u00a0\u00a0// Iterate through edges\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Only consider neighboring nodes\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(edge->start != curr) continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Disregard if already visited\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(visited[edge->end]) continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[curr] != UNKNOWN && distance[curr] + edge->weight < distance[edge->end])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[edge->end] = distance[curr] + edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return distance;\n    ```", "```cpp\n    void Johnson(int V, vector<Edge*> edges)\n    ```", "```cpp\n    // Get distance array from modified graph\n    vector<int> h = BellmanFord(V, edges);\n    ```", "```cpp\n    if(h.empty()) return; \n    ```", "```cpp\n    for(int i = 0; i < edges.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0edges[i]->weight += (h[edges[i]->start] - h[edges[i]->end]);\n    }\n    ```", "```cpp\n    // Create a matrix for storing distance values\n    vector<vector<int>> shortest(V);\n    // Retrieve shortest distances for each vertex\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0shortest[i] = Dijkstra(V, i, edges);\n    }\n    ```", "```cpp\n    // Reweight again in reverse to get original values\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0cout << i << \":\\n\";\n    \u00a0\u00a0\u00a0\u00a0for(int j = 0; j < V; j++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(shortest[i][j] != UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0shortest[i][j] += h[j] - h[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\\t\" << j << \": \" << shortest[i][j] << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int V, E;\n    \u00a0\u00a0\u00a0\u00a0cin >> V >> E;\n    \u00a0\u00a0\u00a0\u00a0vector<Edge*> edges;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < E; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int node_a, node_b, weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> node_a >> node_b >> weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges.push_back(new Edge(node_a, node_b, weight));\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0Johnson(V, edges);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    7 9\n    0 1 3\n    1 2 5\n    1 3 10\n    1 5 -4\n    2 4 2\n    3 2 -7\n    4 1 -3\n    5 6 -8\n    6 0 12\n    ```", "```cpp\n    0:\n    \u00a0\u00a0\u00a0\u00a00: 0\n    \u00a0\u00a0\u00a0\u00a01: 3\n    \u00a0\u00a0\u00a0\u00a02: 6\n    \u00a0\u00a0\u00a0\u00a03: 13\n    \u00a0\u00a0\u00a0\u00a04: 8\n    \u00a0\u00a0\u00a0\u00a05: -1\n    \u00a0\u00a0\u00a0\u00a06: -9\n    1:\n    \u00a0\u00a0\u00a0\u00a00: 0\n    \u00a0\u00a0\u00a0\u00a01: 0\n    \u00a0\u00a0\u00a0\u00a02: 3\n    \u00a0\u00a0\u00a0\u00a03: 10\n    \u00a0\u00a0\u00a0\u00a04: 5\n    \u00a0\u00a0\u00a0\u00a05: -4\n    \u00a0\u00a0\u00a0\u00a06: -12\n    2:\n    \u00a0\u00a0\u00a0\u00a00: -1\n    \u00a0\u00a0\u00a0\u00a01: -1\n    \u00a0\u00a0\u00a0\u00a02: 0\n    \u00a0\u00a0\u00a0\u00a03: 9\n    \u00a0\u00a0\u00a0\u00a04: 2\n    \u00a0\u00a0\u00a0\u00a05: -5\n    \u00a0\u00a0\u00a0\u00a06: -13\n    4:\n    \u00a0\u00a0\u00a0\u00a00: -3\n    \u00a0\u00a0\u00a0\u00a01: -3\n    \u00a0\u00a0\u00a0\u00a02: 0\n    \u00a0\u00a0\u00a0\u00a03: 7\n    \u00a0\u00a0\u00a0\u00a04: 0\n    \u00a0\u00a0\u00a0\u00a05: -7\n    \u00a0\u00a0\u00a0\u00a06: -15\n    5:\n    \u00a0\u00a0\u00a0\u00a00: 4\n    \u00a0\u00a0\u00a0\u00a01: 7\n    \u00a0\u00a0\u00a0\u00a02: 10\n    \u00a0\u00a0\u00a0\u00a03: 17\n    \u00a0\u00a0\u00a0\u00a04: 12\n    \u00a0\u00a0\u00a0\u00a05: 0\n    \u00a0\u00a0\u00a0\u00a06: -8\n    6:\n    \u00a0\u00a0\u00a0\u00a00: 12\n    \u00a0\u00a0\u00a0\u00a01: 15\n    \u00a0\u00a0\u00a0\u00a02: 18\n    \u00a0\u00a0\u00a0\u00a03: 25\n    \u00a0\u00a0\u00a0\u00a04: 20\n    \u00a0\u00a0\u00a0\u00a05: 11\n    \u00a0\u00a0\u00a0\u00a06: 0\n    ```", "```cpp\nstatic unsigned long int randNext = 1;\nint rand(void) // RAND_MAX assumed to be 32767\n{\n\u00a0\u00a0\u00a0\u00a0randNext = randNext * 1103515245 + 12345;\n\u00a0\u00a0\u00a0\u00a0return (unsigned int)(randNext/65536) % 32768\n}\nvoid srand(unsigned int seed)\n{\n\u00a0\u00a0\u00a0\u00a0randNext = seed;\n}\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <stack>\n    ```", "```cpp\n    vector<vector<int>> Kosaraju(int V, vector<vector<int>> adj)\n    ```", "```cpp\n    vector<bool> visited(V, false);\n    stack<int> stack;\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(!visited[i])\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FillStack(i, visited, adj, stack);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void FillStack(int node, vector<bool> &visited,\n    vector<vector<int>> &adj, stack<int> &stack)\n    {\n    \u00a0\u00a0\u00a0\u00a0visited[node] = true;\n    \u00a0\u00a0\u00a0\u00a0for(auto next : adj[node])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(!visited[next])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FillStack(next, visited, adj, stack);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0stack.push(node);\n    }\n    ```", "```cpp\n    vector<vector<int>> Transpose(int V, vector<vector<int>> adj)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> transpose(V);\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto next : adj[i])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0transpose[next].push_back(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return transpose;\n    }\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> transpose = Transpose(V, adj);\n\n    \u00a0\u00a0\u00a0\u00a0fill(visited.begin(), visited.end(), false);\n    ```", "```cpp\n    void CollectConnectedComponents(int node, vector<bool> &visited,\n    vector<vector<int>> &adj, vector<int> &component)\n    {\n    \u00a0\u00a0\u00a0\u00a0visited[node] = true;\n    \u00a0\u00a0\u00a0\u00a0component.push_back(node);\n    \u00a0\u00a0\u00a0\u00a0for(auto next : adj[node])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(!visited[next])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CollectConnectedComponents(next, visited, adj, component);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    vector<vector<int>> connectedComponents;\n    while(!stack.empty())\n    {\n    \u00a0\u00a0\u00a0\u00a0int node = stack.top();\n    \u00a0\u00a0\u00a0\u00a0stack.pop();\n    \u00a0\u00a0\u00a0\u00a0if(!visited[node])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<int> component;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CollectConnectedComponents(node, visited, transpose, component);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0connectedComponents.push_back(component);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return connectedComponents;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int V;\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> adj;\n    \u00a0\u00a0\u00a0\u00a0auto connectedComponents = Kosaraju(V, adj);\n    \u00a0\u00a0\u00a0\u00a0cout << \"Graph contains \" << connectedComponents.size() << \" strongly connected components.\" << endl;\n    \u00a0\u00a0\u00a0\u00a0for(auto component : connectedComponents)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto node : component)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << node << \" \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int V = 9;\n    vector<vector<int>> adj =\n    {\n    \u00a0\u00a0\u00a0\u00a0{ 1, 3 },\n    \u00a0\u00a0\u00a0\u00a0{ 2, 4 },\n    \u00a0\u00a0\u00a0\u00a0{ 3, 5 },\n    \u00a0\u00a0\u00a0\u00a0{ 7 },\n    \u00a0\u00a0\u00a0\u00a0{ 2 },\n    \u00a0\u00a0\u00a0\u00a0{ 4, 6 },\n    \u00a0\u00a0\u00a0\u00a0{ 7, 2 },\n    \u00a0\u00a0\u00a0\u00a0{ 8 },\n    \u00a0\u00a0\u00a0\u00a0{ 3 } \n    };\n    ```", "```cpp\n    Graph contains 4 strongly connected components.\n    \u00a0\u00a0\u00a0\u00a00 \n    \u00a0\u00a0\u00a0\u00a01 \n    \u00a0\u00a0\u00a0\u00a02 4 5 6 \n    \u00a0\u00a0\u00a0\u00a03 8 7\n    ```"]