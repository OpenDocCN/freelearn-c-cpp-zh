- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Writing Generic Containers with Explicit Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式内存管理编写泛型容器
- en: 'We have come quite a long way since the beginning of our journey into the wonders
    of memory management mechanisms and techniques in C++. From [*Chapter 4*](B21071_04.xhtml#_idTextAnchor062)
    to [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116), we built an interesting toolbox,
    one on which we can build and from which we can adapt to solve new problems we
    might face in the future. This toolbox now contains, among other things, the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自我们从C++内存管理机制和技术奥秘的旅程开始以来，我们已经走了很长的路。从 [*第4章*](B21071_04.xhtml#_idTextAnchor062)
    到 [*第7章*](B21071_07.xhtml#_idTextAnchor116)，我们建立了一个有趣的工具箱，我们可以在此基础上构建，也可以从中适应以解决我们未来可能遇到的新问题。这个工具箱现在包含了许多其他东西，例如以下内容：
- en: Techniques through which an object implicitly manages its resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这些技术，对象隐式管理其资源
- en: Types that behave like pointers but encode responsibility over the pointee in
    the type system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似指针但将指向者的责任编码在类型系统中的类型
- en: Various ways in which we can take over the behavior of memory allocation mechanisms
    of a program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以接管程序内存分配机制行为的各种方式
- en: One (important!) aspect of memory management we have not covered yet is how
    containers manage memory. This is actually quite an interesting topic, one that
    we will address through three different angles, in three different chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未涉及的一个（非常重要！）的内存管理方面是如何在容器中管理内存。这实际上是一个非常有趣的话题，我们将通过三个不同的角度，在三个不同的章节中探讨这个问题。
- en: 'The first angle is how to handle memory management *explicitly* yet efficiently
    in a container. This is what the current chapter is about. In some application
    domains, it is customary to implement (or maintain) one’s own containers instead
    of using those provided by the standard library. There can be various reasons
    for this: for example, maybe your company has highly specialized needs. Maybe
    your company has been unsatisfied with standard library containers’ performance
    in the past, perhaps because the implementations were less efficient than they
    hoped back then, and developed its own alternative containers in response. After
    years of writing code based on your own containers, moving back to standard library
    containers might seem too costly.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个角度是如何在容器中显式且高效地处理内存管理。这正是当前章节的内容。在某些应用领域，实现（或维护）自己的容器而不是使用标准库提供的容器是一种惯例。这样做可能有各种原因：例如，也许贵公司有高度专业化的需求。也许贵公司对标准库容器过去的性能不满意，可能是因为当时的实现没有达到预期的效率，因此开发了替代的容器。在基于自己的容器编写代码多年之后，回到标准库容器可能会显得成本过高。
- en: The second angle, which is somewhat shorter, is how to handle memory *implicitly*
    yet efficiently in a container, and will be covered in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)
    of this book, where we will revisit and simplify the implementations seen in the
    current chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个角度，相对较短，是如何在容器中隐式且高效地处理内存，将在本书的[*第13章*](B21071_13.xhtml#_idTextAnchor187)中介绍，我们将回顾并简化当前章节中看到的实现。
- en: The third angle, which is more complex and subtle, is how to handle memory through
    an allocator in a container, and will form [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199)
    of this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个角度，它更为复杂和微妙，是如何通过容器中的分配器来处理内存，并将构成本书的[*第14章*](B21071_14.xhtml#_idTextAnchor199)。
- en: In the current chapter, we will write a (naïve) `std::vector<T>` lookalike named
    `Vector<T>`. We will use that as an opportunity to discuss exception safety (an
    important issue, especially when writing generic code). Then, we will notice that
    we have been very inefficient up to that point, in the sense that `std::vector<T>`
    will be significantly more efficient than our `Vector<T>` alternative, at least
    for some types. Based on this realization, we will revisit our design with better
    memory management, seeing important improvements in many aspects, and discuss
    some important low-level standard facilities for memory management that can (and
    will) make our lives easier.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前章节中，我们将编写一个类似（天真）的 `std::vector<T>` 的名为 `Vector<T>` 的类。我们将利用这个机会来讨论异常安全性（一个重要的问题，尤其是在编写泛型代码时）。然后，我们会注意到，到目前为止，我们在效率上非常低，从某种程度上说，`std::vector<T>`
    将比我们的 `Vector<T>` 替代品更有效率，至少对于某些类型来说是这样。基于这一认识，我们将重新审视我们的设计，以更好的内存管理，看到许多方面的重大改进，并讨论一些重要的低级标准内存管理设施，这些设施可以使我们的生活更容易。
- en: We will also write a homemade `std::forward_list<T>` lookalike named `ForwardList<T>`,
    as there are issues and considerations specific to node-based containers that
    a vector-like type does not really allow us to discuss. This chapter will write
    a “vanilla” version of a forward list, and we will revisit it briefly in [*Chapter
    13*](B21071_13.xhtml#_idTextAnchor187), then in more detail in [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一个名为 `ForwardList<T>` 的类似 `std::forward_list<T>` 的自定义版本，因为基于节点的容器存在一些特定的问题和考虑因素，而类似向量的类型实际上并不允许我们深入讨论。本章将编写一个“纯”版本的链表，我们将在[*第13章*](B21071_13.xhtml#_idTextAnchor187)中简要回顾它，然后在[*第14章*](B21071_14.xhtml#_idTextAnchor199)中更详细地讨论。
- en: 'This means that after reading this chapter, you will be able to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在阅读完本章之后，你将能够做到以下几件事情：
- en: Write a correct and exception-safe container with naïve memory management techniques
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始的内存管理技术编写正确且异常安全的容器
- en: Understand the problems associated with `const` or reference data members
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与 `const` 或引用数据成员相关的问题
- en: Use standard-provided low-level memory management algorithms
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准提供的低级内存管理算法
- en: More generally, you will know why `std::vector<T>` is so fast, and why that
    type is so difficult to beat at the resource management game. You will also get
    an idea of the challenges faced by node-based containers such as `std::forward_list<T>`,
    although later chapters will delve more deeply into this. That does not mean you
    should not write your own containers (for specific use cases, we can often do
    better than a general solution), but it does mean that you will know better why
    (and when) to do so, and how much effort you will need to invest.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，你将知道为什么 `std::vector<T>` 是如此之快，以及为什么在资源管理游戏中这个类型如此难以超越。你还将了解基于节点的容器（如
    `std::forward_list<T>`）面临的挑战，尽管后面的章节将更深入地探讨这一点。但这并不意味着你不应该编写自己的容器（对于特定的用例，我们通常可以做得比通用解决方案更好），但这确实意味着你将更好地了解为什么（以及何时）这样做，以及你需要投入多少努力。
- en: Exhaustiveness or representativeness
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 全面性或代表性
- en: This book does not in general aim for exhaustive representations or implementations
    (there are size limits to a physical object such as a book!), and this chapter
    will be no exception to that rule… far from it! Implementing the full set of member
    functions provided for two container types inspired by the standard library would
    require this book to grow immensely – and your standard library implementation
    covers many more corner cases (and offers many more cool optimizations) than a
    book such as this one could hope to present. For that reason, we will try to expose
    a core set of member functions from which you can build instead of trying to write
    every single one of them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通常不追求全面的表现或实现（物理对象如书籍有大小限制！），本章也不例外……远非如此！实现受标准库启发的两种容器类型所提供的全部成员函数将使本书大幅增长——而且你的标准库实现涵盖了比本书所能展示的更多边缘情况（以及提供了更多酷炫的优化）。因此，我们将尝试展示一组核心成员函数，你可以从中构建，而不是试图编写每一个。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12)。
- en: Writing your own vector<T> alternative
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的 vector<T> 替代方案
- en: 'Suppose you get up one day and say: “Hey, I’m going to beat `std::vector` at
    its own game” and confidently start coding. Some words to the wise:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一天突然说：“嘿，我要在 `std::vector` 的领域打败它”并自信地开始编码。以下是一些建议：
- en: 'This seemingly simple task is astonishingly difficult to accomplish: for one
    thing, `std::vector` is a work of art, and then there’s the fact that your favorite
    standard library writers are spectacularly skilled individuals.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个看似简单的任务竟然如此难以完成：一方面，`std::vector` 是一件艺术品，另一方面，你的标准库编写者也是技艺高超的个人。
- en: You might still think you can do it, so it’s fine to try, but make sure you
    test your ideas with both a type of element that is trivially constructible (for
    example, `int` or `double`) and one that is not (for example, `std::string`) and
    compare the results. For many, the former will lead to stellar performance, but
    the latter might bring …sadness.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能仍然认为你可以做到，所以尝试一下是完全可以的，但请确保用两种类型的元素测试你的想法：一种是 trivially constructible（例如，`int`或`double`），另一种不是（例如，`std::string`），并比较结果。对于许多人来说，前者将导致出色的性能，但后者可能会带来……悲伤。
- en: The reason for this difference is that a container such as `std::vector` is
    extremely efficient at… managing memory (I know, reading this in this book must
    come as quite a shock!). It is much better, in fact, than a homegrown alternative
    would be, unless you invest significant time and effort and (most probably) have
    a specific use case in mind, one for which the homegrown version would be optimized
    more specifically.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种差异的原因在于，像`std::vector`这样的容器在管理内存方面非常高效（我知道，在这本书中读到这一点肯定相当令人震惊！）。实际上，它比自制的替代品要好得多，除非你投入大量的时间和精力，并且（很可能是）有一个特定的用例在心中，对于这个用例，自制的版本会被更具体地优化。
- en: Your standard library vendor does invest such time and effort and does so for
    your very benefit, so it is possible that learning how to use `std::vector` optimally
    will end up being an avenue that brings better results than trying to write your
    personal equivalent container. Of course, in the end, which container to use is
    up to you, and you can often write code for custom situations that outperforms
    general solutions the way standard containers do.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你的标准库供应商确实投入了这样的时间和精力，这样做是为了你的利益，因此，学习如何最优地使用`std::vector`可能最终会是一条比尝试编写你自己的等效容器带来更好结果的道路。当然，最终，使用哪个容器取决于你，你通常可以为特定情况编写代码，其性能优于标准容器的通用解决方案。
- en: A general note on how we will write our containers
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们将如何编写我们的容器的通用说明
- en: 'We will be writing (and using) containers in this chapter and the ones that
    follow, so a brief explanation is needed if we want to have a common understanding
    of how we will proceed. For one thing, we will use type aliases in our containers
    that match those used in standard containers, as this helps toward a more fluid
    integration in other standard library tools, such as the standard algorithms.
    Then, we will strive to use the same public names for our member functions as
    those used in the standard library (for example, we will write `empty()` for the
    predicate used to test whether a container is empty or not, matching existing
    practice in the standard library, even though some might argue `is_empty()` would
    be preferable). Finally, we will adopt a gradual refinement approach: our first
    versions will be simpler but less efficient than later ones, so be patient, dear
    reader: we are following our own path to enlightenment!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章和随后的章节中编写（并使用）容器，因此如果我们要对我们将如何进行有一个共同的理解，就需要简要解释。首先，我们将在容器中使用与标准容器中使用的类型别名相匹配的类型别名，因为这有助于在其他标准库工具（如标准算法）中实现更流畅的集成。然后，我们将努力使用与标准库中相同的公共名称来命名我们的成员函数（例如，我们将编写`empty()`来测试容器是否为空或不是，这与标准库中的现有实践相匹配，尽管有些人可能会认为`is_empty()`更可取）。最后，我们将采用逐步改进的方法：我们的第一个版本将比后来的版本简单但效率较低，所以耐心点，亲爱的读者：我们正在遵循自己的道路走向启迪！
- en: Representational choices for a container of contiguous elements
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续元素容器的表示选择
- en: Informally, a `std::vector` represents a dynamically allocated array that can
    grow as needed. As with any array, a `std::vector<T>` is a sequence of elements
    of type `T` arranged contiguously in memory. We will name our homemade version
    `Vector<T>` to make it visibly distinct from `std::vector<T>`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，`std::vector`代表一个动态分配的数组，可以根据需要增长。与任何数组一样，`std::vector<T>`是内存中连续排列的`T`类型元素的序列。我们将我们的自制版本命名为`Vector<T>`，以便使其与`std::vector<T>`在视觉上明显区分开来。
- en: To get a reasonably performant implementation, the first key idea is to *distinguish
    size from capacity*. If we do not do so, deciding to make size and capacity the
    same thing, our `Vector<T>` implementation will always conceptually be full and
    will need to grow, which means allocating more memory, copying the elements from
    the old storage to the new storage, getting rid of the old storage, and so on
    with every insertion of even a single element. To say such an implementation would
    be painful seems like a severe understatement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个性能合理的实现，第一个关键思想是*区分大小和容量*。如果我们不这样做，决定将大小和容量视为同一件事，我们的`Vector<T>`实现将始终在概念上处于满载状态，并且需要增长，这意味着分配更多内存，将元素从旧存储复制到新存储，丢弃旧存储，等等，每次插入单个元素都需要这样做。说这样的实现会痛苦似乎是一个严重的低估。
- en: 'There are two main approaches to the internal representation of a vector-like
    type. One is to keep track of three pointers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 向量类类型的内部表示主要有两种方法。一种方法是跟踪三个指针：
- en: One to the beginning of the allocated storage
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向分配存储的开始
- en: One to the end of the elements
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向元素末尾
- en: One to the end of the allocated storage (note that we are referring to half-open
    ranges here, with the beginning included and the end excluded)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向分配存储的末尾（注意，我们在这里指的是半开区间，包括开始但不包括结束）
- en: 'A simplified illustration would be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的说明如下：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another is to keep a pointer to the beginning of the allocated storage as well
    as two integers (for the container’s size and capacity, respectively). A simplified
    illustration in this case would be the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法是保留对分配存储开始的指针，以及两个整数（分别用于容器的尺寸和容量）。在这种情况下，一个简化的说明如下：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are equivalent representations in the sense that they both allow us to
    write a correct container, but they bring different trade-offs. For example, keeping
    three pointers makes computing the `end()` iterator fast but makes `size()` and
    `capacity()` require computing a pointer subtraction, whereas keeping a pointer
    and two integers makes both `size()` and `capacity()` fast but requires computing
    the addition of a pointer and an integer to get the `end()` iterator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，这些是等效的表示，因为它们都允许我们编写正确的容器，但它们带来了不同的权衡。例如，保留三个指针使得计算`end()`迭代器变得快速，但使得`size()`和`capacity()`需要计算指针减法，而保留一个指针和两个整数使得`size()`和`capacity()`都快速，但需要计算指针和整数的加法来获取`end()`迭代器。
- en: As far as size goes, the three-pointer representation makes `sizeof(Vector<T>)`
    equal to `3*sizeof(void*)`, thus probably 24 bytes on a 64-bit platform with an
    alignment of 8\. The pointer and two integers might be of the same size or might
    be slightly different depending on the integer types used. For example, choosing
    32-bit integers for the size and capacity on a 64-bit machine would lead to a
    16-byte representation and an alignment of 8\. These details may make a difference
    on a resource-constrained system, but as you have probably deduced already, the
    main memory consumption cost of something such as `Vector<T>` comes from the memory
    allocated for the `T` objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就大小而言，三指针表示使得`sizeof(Vector<T>)`等于`3*sizeof(void*)`，因此在64位平台上，对齐为8的情况下，可能是24字节。指针和两个整数可能具有相同的大小，也可能根据使用的整数类型略有不同。例如，在64位机器上选择32位整数作为大小和容量将导致16字节的表示和对齐为8。这些细节可能在资源受限的系统上有所区别，但正如你可能已经推断出的那样，`Vector<T>`等事物的主要内存消耗成本来自为`T`对象分配的内存。
- en: Different implementations will make different representational choices due to
    size considerations, estimates of which member functions will be called more often
    on average, and so on. We will need to make a choice too; in this book, we will
    choose the “one pointer and two integers” approach, but keep in mind it’s one
    of a few reasonable options (you can even play with the idea and implement what
    follows through other representational choices and see where this leads you!).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大小考虑、对哪些成员函数平均调用频率的估计等因素，不同的实现将做出不同的表示选择。我们也将需要做出选择；在这本书中，我们将选择“一个指针和两个整数”的方法，但请记住，这只是几个合理选项之一（你甚至可以玩一下这个想法，通过其他表示选择来实现以下内容，看看这会把你引向何方！）。
- en: The implementation of Vector<T>
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Vector<T>`的实现'
- en: 'We will walk through our initial (naïve) `Vector<T>` implementation step by
    step, building a gradual understanding of how this all works, and what makes us
    claim that this implementation is indeed naïve. Our initial step has mostly been
    covered already and consists of defining our abstractions through standard library-conforming
    type aliases and choosing our internal representation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步分析我们的初始（天真）`Vector<T>`实现，逐步了解这一切是如何工作的，以及是什么让我们声称这个实现确实是天真的。我们的第一步已经基本完成，主要是通过定义我们的抽象，通过符合标准库的类型别名和选择我们的内部表示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will notice that this implementation makes the choice of using non-`static`
    data member initializers for the three data members of a `Vector<T>`, initializing
    them to their default values (integers are 0, the pointer is null), which is suitable
    in our implementation as it represents an empty container, which seems like a
    reasonable state for a default `Vector<T>`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这种实现选择了为`Vector<T>`的三个数据成员使用非`static`数据成员初始化器，并将它们初始化为其默认值（整数是0，指针是null），这在我们的实现中是合适的，因为它代表了一个空的容器，这似乎是一个默认`Vector<T>`的合理状态。
- en: 'Some simple yet fundamental member functions follow:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单但基本的成员函数随后而来：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Pay attention to the implementation of `empty()` and `full()`. Some people
    will prefer accessing data members (here: using `nelems` and `cap` instead of
    `size()` and `capacity()`) internally when implementing member functions, but
    consider reusing your more fundamental member functions to implement the more
    “synthetic” ones. This will make your code less sensitive to changes in the implementation,
    and C++ compilers are very good at function inlining, particularly when these
    functions are non-`virtual`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`empty()`和`full()`的实现。有些人可能会在实现成员函数时内部访问数据成员（在这里：使用`nelems`和`cap`而不是`size()`和`capacity()`），但考虑重用你更基本的成员函数来实现更“合成”的函数。这将使你的代码对实现的变化不那么敏感，并且C++编译器非常擅长函数内联，尤其是当这些函数是非`virtual`时。
- en: At this point, the most useful set of members we could probably design is the
    iterator types and data members of our class, as this will help us use standard
    algorithms to cleanly and efficiently implement the rest of our member functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能能设计出的最有用的成员集可能是我们类的迭代器类型和数据成员，因为这将帮助我们使用标准算法干净且高效地实现其余的成员函数。
- en: Iterators
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'C++ containers usually expose iterators as part of their interface, and ours
    will be no exception. We will define type aliases for the `const` and non-`const`
    iterator types, as this makes it simpler to implement alternatives such as bounds-checked
    iterators if we feel the need to do so, and implement both `const` and non-`const`
    versions of the `begin()` and `end()` member functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C++容器通常将其接口的一部分暴露为迭代器，我们的也不例外。我们将为`const`和非`const`迭代器类型定义类型别名，因为这使实现如界限检查迭代器等替代方案变得简单，如果我们觉得需要这样做，并实现`begin()`和`end()`成员函数的`const`和非`const`版本：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You might complain about the syntactic repetition that comes with writing a
    `const` and non-`const` version for `begin()` and `end()`, as these are syntactically
    similar yet semantically distinct. If you have a C++23 compiler at hand, you can
    simplify this somewhat through the handy “deduced `this`” feature:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对为`begin()`和`end()`编写的`const`和非`const`版本带来的语法重复表示不满，因为它们在语法上相似，但在语义上不同。如果你手头有C++23编译器，你可以通过方便的“推导`this`”功能来简化这一点：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a slightly more complicated way of expressing these functions, but it
    lets us coalesce both versions of `begin()` and `end()` into one by leveraging
    the type deduction system through forwarding references.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种稍微复杂的方式来表达这些函数，但它通过利用类型推导系统通过转发引用将`begin()`和`end()`的两个版本合并为一个。
- en: Constructors and other special member functions
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和其他特殊成员函数
- en: 'We now get to our constructors. The first two we will look at are the default
    constructor and a parametric constructor that takes as arguments a number of elements
    and an initial value, such that `Vector<char>(3,''a'')` yields a container with
    three elements of value `''a''`. Note that the `default`-ed default constructor
    (yes, I know) in this case is implicitly `constexpr` as all the non-`static` member
    initializers can be resolved in a `constexpr` context:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看构造函数。我们将首先查看的是默认构造函数和一个参数化构造函数，它接受元素数量和一个初始值作为参数，这样`Vector<char>(3,'a')`就产生了一个包含三个值为`'a'`的元素的容器。请注意，在这种情况下，`default`默认构造函数（是的，我知道）是隐式`constexpr`的，因为所有非`static`成员初始化器都可以在`constexpr`上下文中解析：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pay attention to the exception-handling code in this constructor, as it will
    come back again and again. We are writing a generic container, so we are using
    some type `T` we have no prior knowledge of. When calling `std::fill()`, which
    assigns the value of the `init` argument to each of the `T` objects in the sequence,
    we are assigning a `T` value to a `T` object, but we do not know whether that
    assignment operator can throw.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在这个构造函数中的异常处理代码，因为它会反复出现。我们正在编写一个通用容器，因此我们使用了一些我们事先不知道的类型 `T`。当调用 `std::fill()`，将
    `init` 参数的值赋给序列中每个 `T` 对象时，我们正在将一个 `T` 值赋给一个 `T` 对象，但我们不知道那个赋值操作符是否可以抛出异常。
- en: 'Our responsibility is to `elems`, a dynamically allocated array of `T`, so
    if one of the assignment operators throws, we need to make sure that array is
    destroyed and deallocated before the `Vector<T>` constructor fails; otherwise,
    we will leak the memory and (even worse) the objects we had constructed in that
    array will not be finalized. The `catch(...)` block means “catch anything,” without
    really knowing what you caught in this case, and the `throw;` expression means
    “re-throw whatever you had caught.” Indeed, we do not want to handle the exception
    in such a case (we do not have sufficient knowledge of the execution context to
    do so: is this a console application? A graphical application? An embedded system?
    Something else?); we just want to make sure our failure to construct the `Vector<T>`
    object did not leak resources and let user code know exactly why it is that our
    constructor failed to meet its postconditions (failed to construct a valid object).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的职责是 `elems`，一个动态分配的 `T` 类型的数组，所以如果其中一个赋值操作符抛出异常，我们需要确保在 `Vector<T>` 构造函数失败之前，该数组被销毁并释放；否则，我们将泄漏内存，甚至更糟的是，我们在这个数组中构造的对象将不会被最终化。`catch(...)`
    块意味着“捕获任何东西”，实际上并不真正知道在这种情况下你捕获了什么，而 `throw;` 表达式意味着“重新抛出你所捕获的任何东西”。确实，我们不想在这种情况下处理异常（我们没有足够的执行上下文知识来这样做：这是一个控制台应用程序？一个图形应用程序？一个嵌入式系统？其他什么？）；我们只想确保我们未能构造
    `Vector<T>` 对象没有泄漏资源，并让用户代码确切地知道为什么我们的构造函数未能满足其后置条件（未能构造一个有效的对象）。
- en: 'The copy constructor will follow a similar pattern, except that instead of
    filling the sequence with copies of a single value, it copies values from a source
    sequence (`other`) to a destination sequence (`*this` or `elems` depending on
    how you see it). The move constructor is, of course, quite different:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数将遵循类似的模式，除了不是用单个值的副本填充序列，而是从源序列（`other`）复制值到目标序列（`*this` 或 `elems`，取决于你如何看待它）。移动构造函数当然大不相同：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the copy constructor is a costly beast for this type: an allocation
    for `other.size()` objects (with as many calls to the default constructor of type
    `T` accompanying this for non-trivially-constructible objects), then `other.size()`
    assignments, and exception handling thrown in.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于这种类型，复制构造函数是一个昂贵的家伙：为 `other.size()` 个对象进行分配（对于非平凡构造的对象，伴随着对类型 `T` 的默认构造函数的多次调用），然后进行
    `other.size()` 次赋值，以及抛入异常处理。
- en: 'The move constructor is simpler: it’s a constant-time, `noexcept` function.
    You don’t technically need move operations in most classes (C++ got along fine
    for years without move operations, after all), but when you can take advantage
    of them, you probably should do so. The speed improvements can be stupendous,
    and execution speed becomes more predictable.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数更简单：它是一个常数时间的 `noexcept` 函数。在大多数类中，技术上不需要移动操作（毕竟，C++ 没有移动操作也能良好地运行多年），但当你能利用它们时，你很可能应该这样做。速度提升可能是惊人的，执行速度变得更加可预测。
- en: On values and salient properties
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于价值和显著特性
- en: 'If you read the copy constructor’s code attentively, you might have noticed
    that `*this` did not copy `other.capacity()`, instead deciding to make `cap` a
    copy of `other.size()`. That’s actually the correct thing to do in such a case:
    the `size()` of a container is what is called a `capacity()` is more of an artifact
    of that object’s life, showing traces of how it has grown over time. What we want
    is that, after copying an object, the original and the copy compare equal with
    respect to `operator==` and, of course, `capacity()` does not intervene in that
    function: two arrays are generally considered equal if they have the same number
    of elements and each of these elements has the same value when compared to its
    counterpart in the other container. Copying the capacity would work in practice,
    but it would be wasteful for most use cases.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读复制构造函数的代码，可能会注意到`*this`没有复制`other.capacity()`，而是决定让`cap`成为`other.size()`的副本。实际上，在这种情况下这样做是正确的：容器的大小（即所谓的`capacity()`）更多的是该对象生命周期的产物，显示了它随时间增长的过程。我们想要的是，在复制一个对象之后，原始对象和副本在`operator==`运算符下比较相等，当然，`capacity()`函数不会干预这个功能：两个数组通常被认为相等，如果它们有相同数量的元素，并且当与另一个容器中的对应元素比较时，每个元素都有相同的值。在实际情况中复制容量是可行的，但对于大多数用例来说，这将是浪费的。
- en: 'I added (for convenience) a constructor that accepts an `initializer_list<T>`,
    argument to allow for initializing a `Vector<T>` object with a sequence of values
    of type `T`. The destructor should be self-explanatory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个构造函数，它接受一个`initializer_list<T>`参数，以便用类型为`T`的值的序列初始化`Vector<T>`对象。析构函数应该是自解释的：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implementing the copy assignment operator from a source object (here: `other`)
    to a destination object (`*this`) can be complicated if done in an… undisciplined
    manner, as it involves cleanup code (for the before-assignment contents of `*this`),
    duplication of the state of the source object, and ensuring we handle both self-assignment
    and potential exceptions thrown when duplicating the source object’s state appropriately.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以……无纪律的方式实现从源对象（这里：`other`）到目标对象（`*this`）的复制赋值运算符，可能会很复杂，因为它涉及到清理代码（`*this`在赋值之前的内容）、复制源对象的状态，并确保我们正确处理自赋值和复制源对象状态时可能抛出的异常。
- en: 'Luckily, there’s a neat trick suggested by Scott Meyers (and re-proposed by
    countless others!) who noticed that copy assignment can be expressed as a combination
    of a copy constructor (the locus of object duplication), the destructor (where
    cleanup happens) and a `swap()` member function: you simply copy the argument
    into an anonymous object (to make its lifetime minimal), then swap the states
    of that unnamed temporary with those of `*this`, leading to `*this` becoming a
    copy of `other`. This programming idiom almost always works, which explains its
    success!'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Scott Meyers（以及无数其他人）提出的一个巧妙技巧解决了这个问题，他注意到复制赋值可以表达为复制构造函数（对象复制的焦点）、析构函数（清理发生的地方）和`swap()`成员函数的组合：你只需将参数复制到一个匿名对象中（以使它的生命周期最小），然后交换那个未命名的临时对象的状态与`*this`的状态，从而使得`*this`成为`other`的副本。这种编程习惯几乎总是有效的，这也解释了它的成功！
- en: 'Move assignment can be expressed along the same lines as copy assignment, but
    replacing the copy constructor with a move constructor in the implementation of
    the assignment operator:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 移动赋值可以像复制赋值一样表达，但在赋值运算符的实现中，用移动构造函数替换复制构造函数：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Basic services of a vector-like class
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类似向量的类的基本服务
- en: 'We have now implemented the special member functions that handle the internal
    representation of a `Vector<T>` object, but there is more to writing a convenient
    dynamic array type. For example, member functions that let you access the `first()`
    element, or the last (`back()`) element, or that let you access the element at
    a specific index in the array (using square brackets) are all to be expected:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了处理`Vector<T>`对象内部表示的特殊成员函数，但编写一个方便的动态数组类型还有更多的工作要做。例如，成员函数允许你访问`first()`元素，或者最后一个（`back()`）元素，或者允许你通过方括号访问数组中的特定索引的元素（这些都是预期的）：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As can be expected, calling `front()` or `back()` on an empty `Vector<T>` is
    undefined behavior (you could make these functions throw if you prefer, but then
    everyone would pay the price for those few programs that are badly behaved maybe
    only in so-called `this`” feature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在空的`Vector<T>`上调用`front()`或`back()`是未定义的行为（如果你愿意，你可以让这些函数抛出异常，但这样所有人都要为那些可能只在不那么“this”的功能中表现不佳的少数程序付出代价）：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Some will want to add an `at()` member function in both `const` and non-`const`
    form that behaves like `operator[]` but throws an exception if an attempt to access
    the underlying array is out of bounds. Feel free to do so if you wish.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者可能会想在 `const` 和非 `const` 形式下都添加一个 `at()` 成员函数，它的行为类似于 `operator[]`，但如果尝试访问底层数组越界则抛出异常。如果你愿意，可以这样做。
- en: 'Comparing two `Vector<T>` objects for equivalence or lack thereof is a relatively
    easy matter if we use algorithms since we implemented iterators for our type:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个 `Vector<T>` 对象是否相等或不相等，如果我们使用算法，并且为我们的类型实现了迭代器，那么这是一个相对简单的问题：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, you might say, we reach the point that interests us the most in a
    book discussing memory management: how to add elements to our container, and how
    the underlying memory is managed. Without going through every mechanism client
    code could use to add elements to a `Vector<T>` object, we will at least examine
    the `push_back()` and `emplace_back()` member functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能会说，我们达到了讨论内存管理的书籍中最吸引我们的点：如何向我们的容器中添加元素，以及底层内存是如何管理的。在不逐一介绍客户端代码可能使用的向
    `Vector<T>` 对象添加元素的所有机制的情况下，我们至少会检查 `push_back()` 和 `emplace_back()` 成员函数：
- en: 'In this version, there will be two `push_back()` member functions: one that
    takes `const T&` as argument and one that instead takes a `T&&`. The one that
    takes a `const T&` argument will copy that argument at the end of the container,
    and the one that takes a `T&&` will move it at that location.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个版本中，将有两个 `push_back()` 成员函数：一个接受 `const T&` 作为参数，另一个接受 `T&&`。接受 `const T&`
    参数的那个函数将在容器的末尾复制该参数，而接受 `T&&` 的那个函数将移动它到那个位置。
- en: The `emplace_back()` member function will take a variadic pack of arguments,
    then perfectly forward them to the constructor of a `T` object that will be placed
    at the end of the container.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_back()` 成员函数将接受一个可变参数包，然后将它们完美地转发到将被放置在容器末尾的 `T` 对象的构造函数中。'
- en: A reference to the newly constructed object is returned by `emplace_back()`
    for convenience, in case user code would like to use it right away. This is not
    done by `push_back()`, which is called with a fully constructed object to which
    user code already has access.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_back()` 通过返回对新构造对象的引用来提供便利，以防用户代码希望立即使用它。这不是通过 `push_back()` 实现的，`push_back()`
    是用一个已经完全构造的对象调用的，用户代码已经可以访问它。'
- en: In all three functions, we first check whether the container is full, in which
    case we call `grow()`, a private member function. The `grow()` function needs
    to allocate more memory than what the container currently holds, something that
    can, of course, fail. Note that if `grow()` throws, the addition of a new object
    never occurred and the container remains intact. Note that `grow()` takes into
    account the possibility of a `capacity()` of value `0`, in which case an arbitrary
    default capacity is chosen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个函数中，我们首先检查容器是否已满，如果是，则调用 `grow()`，这是一个私有成员函数。`grow()` 函数需要分配比容器当前持有的更多内存，这当然可能会失败。注意，如果
    `grow()` 抛出异常，则新对象的添加从未发生，容器保持完整。注意，`grow()` 考虑了 `capacity()` 的值为 `0` 的可能性，在这种情况下，将选择任意默认容量。
- en: 'Once `grow()` has succeeded, we add the new element after the last object in
    the container’s storage. Note that the value is added through assignment, which
    implies an object to the left side of the assignment operation, meaning that `grow()`
    not only added storage but initialized it with (most probably) default objects
    of type `T`. Thus, we can infer that with this implementation of `Vector<T>`,
    type `T` needs to expose a default constructor:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `grow()` 成功，我们就在容器的存储中添加新元素到最后的对象之后。注意，值是通过赋值添加的，这意味着赋值操作左侧的对象，意味着 `grow()`
    不仅添加了存储，还用（很可能是）类型 `T` 的默认对象初始化了它。因此，我们可以推断，在这个 `Vector<T>` 的实现中，类型 `T` 需要公开一个默认构造函数：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that the insertion code in `push_back()` and `emplace_back()` does, in
    both cases, the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`push_back()` 和 `emplace_back()` 中的插入代码在两种情况下都执行以下操作：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You might be tempted to combine the incrementation of the number of elements
    and the actual insertion expression into one, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想将元素数量的增加和实际的插入表达式合并为一个，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Do *not* do that, however. “Why are you stopping me?” you might ask. Well,
    this would lead to exception-unsafe code! The reason for this is that the suffix
    version of `operator++()` has a high (very high!) priority, *much* higher than
    assignment does. This means that in the combined expression, `nelems++` happens
    very early on (which might go unnoticed as that expression yields the old value
    of `nelems`), and assignment follows later, but assignment can throw: we are assigning
    from an object of some type `T` to another object of that same type, and we do
    not know whether `T::operator=(const T&)` will throw. Of course, if it does throw,
    the assignment will not have occurred, and no object will have been added at the
    end of the containers; but the number of elements will have been incremented,
    leading to an incoherent `Vector<T>` object.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要这样做。“你为什么阻止我？”你可能会问。嗯，这会导致异常不安全的代码！原因在于 `operator++()` 的后缀版本有很高的（非常高！）优先级，*远高于*赋值。这意味着在组合表达式中，`nelems++`
    发生得非常早（这可能会被忽视，因为那个表达式返回 `nelems` 的旧值），而赋值发生在稍后，但赋值可能会抛出异常：我们正在将类型 `T` 的对象赋值给另一个相同类型的对象，我们不知道
    `T::operator=(const T&)` 是否会抛出异常。当然，如果它抛出了异常，赋值就不会发生，并且容器末尾不会添加任何对象；但元素的数量会增加，导致一个不一致的
    `Vector<T>` 对象。
- en: 'There’s a general trick here: do not modify your object until you know you
    can do so safely. Try to do the potentially throwing operations first, then do
    the operations that can mutate your object. You will sleep better, and the risks
    of object corruption will be alleviated somewhat.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个通用的技巧：在你知道可以安全修改之前不要修改你的对象。尽量先执行可能抛出异常的操作，然后执行可以修改你的对象的操作。这样你会睡得更好，并且对象损坏的风险会得到一定程度的缓解。
- en: Our `grow()` member function did its work by calling `resize()` and doubling
    the container’s capacity (unless that capacity was 0, in which case it picked
    a default capacity). How does `resize()` work? With our implementation, it’s a
    matter of allocating enough memory to cover the needs of the new capacity, copying
    or moving the objects from the old memory block to the new one, then replacing
    the old memory block with the new one and updating the capacity.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `grow()` 成员函数通过调用 `resize()` 并将容器的容量加倍（除非该容量为 0，在这种情况下它选择一个默认容量）来完成其工作。`resize()`
    是如何工作的？在我们的实现中，这只是一个分配足够内存来覆盖新容量需求的问题，然后将对象从旧内存块复制或移动到新内存块，然后替换旧内存块并更新容量。
- en: 'How do we know whether we should move or copy the objects? Well, since moving
    could destroy the original objects, we only do so if `T::operator=(T&&)` is explicitly
    `noexcept`. The `std::is_nothrow_move_assignable<T>` trait is our tool of choice
    to determine whether that is indeed the case (if it is not, then we copy the objects,
    which is the safe option as it leaves the original objects intact):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道应该移动还是复制对象？嗯，由于移动可能会破坏原始对象，我们只有在 `T::operator=(T&&)` 明确为 `noexcept` 的情况下才会这样做。`std::is_nothrow_move_assignable<T>`
    特性是我们用来确定这一点（如果它不是，那么我们复制对象，这是安全的选择，因为它保留了原始对象）的工具：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There we go. It’s not exactly trivial code, I agree, but it’s not insurmountable
    either. Remember that this is only our first draft, and that it will be much slower
    than `std::vector<T>` for a wide array of types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我同意这并不是简单的代码，但它也不是不可逾越的。记住，这仅仅是我们第一次草稿，并且对于大量类型来说，它将比 `std::vector<T>` 慢得多。
- en: 'One last aspect of this container we should address is how to `insert()` elements
    into it and how to `erase()` elements from it. In industrial-strength containers
    such as those found in the standard library, there is a wide array of functions
    to perform these two tasks, so we will limit ourselves to one of each: inserting
    a sequence of values at a given location in the container and erasing an element
    at a given location from the container.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该解决的这个容器的最后一个方面是如何向其中 `insert()` 元素以及如何从其中 `erase()` 元素。在工业级容器，如标准库中找到的容器，有一系列函数来执行这两个任务，所以我们将限制自己只做每个任务中的一个：在容器的指定位置插入一系列值，以及从容器的指定位置删除一个元素。
- en: Our `insert()` member function will be a template that takes a pair of source
    iterators named `first` and `last`, as well as a `const_iterator` named `pos`
    representing a location within the `Vector<T>` object. Making it a `template`
    means that we will be able to use pairs of iterators from any container as a source
    of values to insert, a useful property indeed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`insert()`成员函数将是一个模板，它接受一对源迭代器，命名为`first`和`last`，以及一个名为`pos`的`const_iterator`，它表示`Vector<T>`对象内的一个位置。将其作为模板意味着我们可以使用任何容器的迭代器对作为插入值的来源，这确实是一个有用的特性。
- en: Within the function, we will use a non-`const` equivalent of `pos` named `pos_`,
    but only because we are writing a simplified and incomplete container where many
    member functions that would work on `const_iterator` objects are missing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们将使用`pos`的非`const`等价物，命名为`pos_`，但这仅仅是因为我们正在编写一个简化和不完整的容器，其中许多本应在`const_iterator`对象上工作的成员函数缺失。
- en: To perform the insertion, we will compute `remaining`, the space we will have
    available in the container (expressed as a number of objects), and `n`, which
    will be the number of objects to insert. If the available space remaining is insufficient,
    we will allocate more through our `resize()` member function. Of course, calling
    `resize()` will probably lead to `pos_` becoming invalid (it pointed into the
    old block of memory, which will be replaced by another block once `resize()` has
    completed its task), so we take care of computing the relative `index` in the
    container before resizing, and recomputing the equivalent of `pos_` in the new
    memory block after resizing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行插入，我们将计算`remaining`，这是容器中可用的空间（以对象数量表示），以及`n`，它将是插入的对象数量。如果剩余空间不足，我们将通过我们的`resize()`成员函数分配更多空间。当然，调用`resize()`可能会导致`pos_`变得无效（它指向旧的内存块，一旦`resize()`完成任务，它将被另一个块替换），因此我们在调整大小之前会计算容器中的相对`index`，并在调整大小后在新的内存块中重新计算`pos_`的等价物。
- en: 'An interesting twist in the insertion process is that we will want to copy
    (or move, but we will keep things simple here) the objects from `pos_` to `end()`
    at the location *ending* at `end()+n` before performing the insertion of `n` objects
    at the `pos_` location, but that copy has to be made *backward* (from the last
    to the first) if we are to avoid overwriting some of the objects we are trying
    to copy along the way. The `std::copy_backward()` algorithm is expressed this
    way: the third argument expressed where the destination of the copy stops, not
    where it begins.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 插入过程中的一个有趣转折是，在执行`pos_`位置插入`n`个对象之前，我们希望将`pos_`到`end()`处的对象复制（或移动，但在这里我们将保持简单）到`end()+n`的位置，但如果我们想避免在复制过程中覆盖一些我们试图复制的对象，那么这个复制必须**向后**（从最后一个到第一个）进行。`std::copy_backward()`算法就是这样表达的：第三个参数表示复制的目标停止的位置，而不是开始的位置。
- en: 'Only then do we copy the sequence determined by `first` and `last` at position
    `pos_`, update the number of elements in the `Vector<T>` object, and return what
    the standard requires (an iterator to the first element inserted, or `pos` in
    the case where `first==last`, meaning that they determine an empty sequence):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在这种情况下，我们才会复制由`first`和`last`确定的序列到`pos_`位置，更新`Vector<T>`对象中的元素数量，并返回标准所要求的（指向第一个插入元素的迭代器，或者在`first==last`的情况下返回`pos`，这意味着它们确定了一个空序列）：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our `erase()` member function will take a `const_iterator` argument named `pos`
    representing the location of the element to erase from the `Vector<T>` object.
    We again resort to the trick of using a non-`const` iterator named `pos_` within
    the function. Erasing `end()` is a no-op (as it should); otherwise, we perform
    a linear copy from `next(pos_)` to `end()` into the location starting at `pos_`,
    effectively replacing each element from that point on with its immediate successor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`erase()`成员函数将接受一个名为`pos`的`const_iterator`参数，表示要从`Vector<T>`对象中删除的元素的位置。我们再次求助于在函数内部使用一个名为`pos_`的非`const`迭代器的技巧。删除`end()`是一个无操作（正如它应该的那样）；否则，我们将从`next(pos_)`到`end()`进行线性复制到以`pos_`开始的地址，有效地用其直接后继替换从该点开始的所有元素。
- en: Finally, we replace the last element with some default value, something that
    might not seem necessary but actually is since the `T` object at the end could
    have been holding some resource that needed to be freed. For example, in a program
    where we use a `Vector<Res>` object and where `Res` is an RAII type that releases
    a resource on destruction, not replacing the object “lying around just past the
    end” might lead to the associated resource being closed only when the `Vector`
    object is destroyed, which might occur later, maybe much later, than client code
    would expect it to be.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将最后一个元素替换为某个默认值，这可能看起来不是必要的，但实际上是必要的，因为末尾的 `T` 对象可能正在持有需要释放的资源。例如，在一个使用
    `Vector<Res>` 对象的程序中，其中 `Res` 是一个 RAII 类型，在析构时释放资源，如果不替换“位于末尾之后”的对象，可能会导致相关的资源仅在
    `Vector` 对象被销毁时关闭，这可能会比客户端代码预期的晚得多。
- en: 'We then update the number of elements in the `Vector<T>` object. Once again,
    this implementation means we are requiring that `T` exposes a default constructor,
    something that is not fundamentally necessary (and a requirement that we will
    alleviate later in this chapter):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们更新 `Vector<T>` 对象中的元素数量。再次强调，这种实现意味着我们要求 `T` 提供一个默认构造函数，这并不是根本必要的（我们将在本章后面减轻这一要求）：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I’m sure you’re wondering how we could do better, but we will get back to this
    very soon. We will look at how to implement a simple node-based container (a homemade
    `std::forward_list<T>`-like type) in the meantime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您一定在想我们如何做得更好，但我们会很快回到这个问题。在此期间，我们将研究如何实现一个基于节点的容器（类似于自制的 `std::forward_list<T>`
    类型）。
- en: Writing your own forward_list<T> alternative
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的 `forward_list<T>` 替代方案
- en: 'Writing a node-based container such as `std::list`, `std::unordered_map`, `std::
    map`, and so on is an interesting exercise, but in this chapter, the fact that
    it is interesting will not necessarily “shine” right away. The points of interest
    for such classes will be more evident in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)
    and [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199), but we will still write
    a basic, simplified version here to make the side-by-side evolution of our container
    types clearer in the pages and chapters to come.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '编写类似于 `std::list`、`std::unordered_map`、`std::map` 等基于节点的容器是一个有趣的练习，但在这个章节中，它有趣的事实并不一定会立即“闪耀”。这类类的兴趣点将在第13章和第14章中更为明显，但我们将仍然编写一个基本、简化的版本，以便在接下来的页面和章节中更清晰地展示我们的容器类型的发展。 '
- en: A forward list is an exercise in leanness. We want the type to be small and
    do what it does well. Some forward lists occupy the size of a single pointer in
    memory (a pointer to the first node in the sequence); in our implementation, we
    will pay the price for an additional integer (the number of elements) in order
    to get a constant-time complexity guarantee for the `size()` member function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前向列表是一种对精简的练习。我们希望类型尽可能小，并且能很好地完成其功能。一些前向列表在内存中只占用单个指针的大小（指向序列中第一个节点的指针）；在我们的实现中，我们将为额外的整数（元素数量）付出代价，以获得
    `size()` 成员函数的常数时间复杂度保证。
- en: Representational choices for a node-based container
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于节点的容器的表示选择
- en: In our implementation, `ForwardList<T>` will hold nodes, and each node will
    hold a pair made of a value (of type `T`) and a pointer to the next node in the
    sequence. The last node will have a null pointer as the `next` node.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，`ForwardList<T>` 将持有节点，每个节点将包含一个由值（类型为 `T`）和指向序列中下一个节点的指针组成的对。最后一个节点将具有空指针作为
    `next` 节点。
- en: The representation of a `ForwardList<T>` object will thus be a `Node*` and an
    unsigned integral (for the number of elements in the list). Our implementation
    will be very simple and will show a small set of member functions. Feel free to
    enrich it as you want, as long as you limit yourself to functions that can be
    written efficiently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForwardList<T>` 对象的表示将是一个 `Node*` 和一个无符号整数（表示列表中的元素数量）。我们的实现将非常简单，并展示一组小的成员函数。您可以随意扩展它，只要您限制自己只编写高效可写的函数。'
- en: The implementation of ForwardList<T>
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ForwardList<T>` 的实现'
- en: 'As we did for `Vector<T>`, we will walk through our initial (naïve) `ForwardList<T>`
    implementation in steps. Our initial step consists of defining our abstractions
    through standard library-conforming type aliases and choosing our internal representation,
    as is usually the case with containers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对 `Vector<T>` 所做的那样，我们将逐步分析我们的初始（天真）`ForwardList<T>` 实现。我们的第一步是通过标准库符合的类型别名定义我们的抽象，并选择我们的内部表示，这通常是容器的情况：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As mentioned earlier, a`ForwardList<T>::Node` object will hold a value and
    a pointer to the next node in the sequence. Initially, the next node will always
    be a null pointer; it is the list’s responsibility to organize nodes, the nodes
    themselves being responsible for the ownership of the values stored therein:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ForwardList<T>::Node`对象将持有值和指向序列中下一个节点的指针。最初，下一个节点始终是一个空指针；组织节点是列表的责任，节点本身负责存储的值的所有权：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The default state of a `ForwardList<T>` object will be equivalent to that of
    an empty list (a null pointer for `head` and no elements). That’s a reasonable
    default for most containers as an empty container is usually what users expect
    in practice when asking for a default constructor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForwardList<T>`对象的默认状态将与空列表（`head`为空指针且没有元素）相当。这对于大多数容器来说是一个合理的默认值，因为用户在实际中请求默认构造函数时通常期望一个空容器。'
- en: 'The `size()` and `empty()` member functions are both trivial to write. I expressed
    `empty()` in terms of a null head rather than as a zero `size()` since in some
    (reasonable) forward list implementations, the size would be computed, not stored,
    which would make `size()` a linear complexity operation instead of a constant-time
    one. In practice, exposing a constant-time `size()` member function is a good
    idea as it matches most users’ expectations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()`和`empty()`成员函数都很容易编写。我使用空头而不是零`size()`来表达`empty()`，因为在某些（合理的）`ForwardList`实现中，大小会被计算而不是存储，这将使`size()`成为一个线性复杂度的操作而不是常数时间的操作。在实践中，公开一个常数时间的`size()`成员函数是一个好主意，因为它符合大多数用户的期望：'
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterators on a linked list cannot be raw pointers, as the elements it stores
    are not contiguous in memory. We need a class whose instances can iterate over
    elements of the list, and that can take into account the `const`-ness of the elements
    (or lack thereof).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 链表上的迭代器不能是原始指针，因为它存储的元素在内存中不是连续的。我们需要一个类，其实例可以遍历列表中的元素，并且可以考虑到元素的`const`属性（或缺乏该属性）。
- en: Our (private) `ForwardList<T>::Iterator` class will be a template on some type,
    `U`, where (in practice) `U` will be `T` for `ForwardList<T>::iterator` and `const
    T` for `ForwardList<T>::const_iterator`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的（私有）`ForwardList<T>::Iterator`类将是一个模板，其类型为`U`，其中（在实践中）`U`对于`ForwardList<T>::iterator`将是`T`，对于`ForwardList<T>::const_iterator`将是`const
    T`。
- en: 'Standard iterators in C++ are expected to provide five aliases:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的标准迭代器预期提供五个别名：
- en: '`value_type`: The type of the pointed-to value.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_type`：被指向值的类型。'
- en: '`reference`: The type that represents a reference to a pointed-to value.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reference`：表示指向被指向值的引用的类型。'
- en: '`pointer`: The type that represents a pointer to a pointed-to value.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pointer`：表示指向被指向值的指针的类型。'
- en: '`difference_type`: The type that represents the distance between two iterators
    of this type (a signed integral).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference_type`：表示此类型两个迭代器之间距离的类型（一个有符号整数）。'
- en: '`iterator_category`: There are six categories as of C++20, and they guide the
    code generation by describing what an iterator can do. In our case, since we will
    provide `++` but not `--`, we will describe our iterators as being part of `forward_iterator_category`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator_category`：截至C++20，有六个类别，它们通过描述迭代器可以做什么来指导代码生成。在我们的情况下，因为我们将提供`++`但不提供`--`，我们将我们的迭代器描述为`forward_iterator_category`的一部分。'
- en: 'An iterator is an object that describes how we can traverse a sequence of values,
    and `ForwardList<T>::Iterator` is no exception. The key operations exposed by
    an iterator are probably `operator++()` (advance one position in the sequence),
    `operator!=()` (compare two iterators to know whether we have attained the end
    of a sequence), as well as `operator*()` and `operator->()` (accessing the pointed-to
    element or its services). Note that we make `ForwardList<T>` our friend as that
    class will be responsible for the organization of nodes, which is easier done
    when you have full access privileges to private data members such as `cur`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一个描述我们如何遍历值序列的对象，`ForwardList<T>::Iterator`也不例外。迭代器暴露的关键操作可能是`operator++()`（在序列中前进一个位置）、`operator!=()`（比较两个迭代器以确定我们是否到达了序列的末尾），以及`operator*()`和`operator->()`（访问被指向的元素或其服务）。请注意，我们将`ForwardList<T>`作为友元，因为这个类将负责节点的组织，当您对私有数据成员（如`cur`）具有完全访问权限时，这会更容易完成：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding proposed implementation uses a template based on the type, `U`,
    of the elements that an `Iterator<U>` can traverse. We used `U` instead of `T`
    as `T` is the type of the values in a `ForwardList<T>` object. In `ForwardList<T>`,
    we then make aliases for types `Iterator<T>` and `Iterator<const T>` through `iterator`
    and `const_iterator`, respectively. We could also have written two distinct types
    had we preferred that approach, but a template seemed less verbose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提出的实现使用了一个基于元素类型 `U` 的模板，这些元素可以被 `Iterator<U>` 遍历。我们使用 `U` 而不是 `T`，因为 `T`
    是 `ForwardList<T>` 对象中值的类型。在 `ForwardList<T>` 中，我们通过 `iterator` 和 `const_iterator`
    分别为 `Iterator<T>` 和 `Iterator<const T>` 类型创建别名。如果我们更喜欢那种方法，我们也可以编写两个不同的类型，但模板似乎更简洁。
- en: 'The `begin()` and `end()` set of member functions are essentially trivial;
    `begin()` yields an iterator to the head of the list, and the conceptual just-after-the-end
    node returned by `end()` is a null pointer, which is what the default constructor
    of our `Iterator<U>` gives us:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()` 和 `end()` 成员函数集实际上非常简单；`begin()` 返回列表的头部迭代器，而 `end()` 返回的“概念上位于末尾”的节点是一个空指针，这正是我们的
    `Iterator<U>` 的默认构造函数所提供的：'
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will sometimes need to `clear()` a `ForwardList<T>` object, which will lead
    us to destroy that container’s content. In this implementation, for simplicity,
    I made the destructor call the `clear()` member function, but we could have spared
    a tiny bit of processing time (the reinitialization of `nelems`, not needed in
    the destructor) by writing the destructor separately:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时需要清除 `ForwardList<T>` 对象，这将导致我们销毁该容器的内容。在这个实现中，为了简单起见，我让析构函数调用 `clear()`
    成员函数，但我们可以通过单独编写析构函数来节省一点处理时间（`nelems` 的重新初始化，在析构函数中不需要）：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One thing that might seem tempting would be to write a `Node` destructor that
    applies `delete` to its `next` data member; if we did so, `clear()` would simply
    be `delete head;` (which would call `delete head->next` and continue from that
    point on, recursively) followed by `nelems=0;`. However, I would not do that if
    I were you: on principle, the `ForwardList<T>` object should organize the nodes
    in a `ForwardList<T>`, and this responsibility should not be given to the numerous
    `Node` objects themselves. Then, there is a small technical problem: calling `delete
    head;` would call `delete head->next;`, which would then technically call `delete`
    on `head-> next-> next;` and so on. This leads to a very concrete risk of stack
    overflow if the list is long enough, something that a loop would avoid altogether.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人感到诱惑的事情是编写一个 `Node` 析构函数，它会对它的 `next` 数据成员应用 `delete`；如果我们这样做，`clear()`
    将会简单地是 `delete head;`（这将调用 `delete head->next` 并从该点递归地继续）然后是 `nelems=0;`。然而，如果我是你，我不会这样做：原则上，`ForwardList<T>`
    对象应该组织 `ForwardList<T>` 中的节点，而这个责任不应该交给众多的 `Node` 对象本身。然后，还有一个小的技术问题：调用 `delete
    head;` 将会调用 `delete head->next;`，然后技术上会调用 `delete` 在 `head->next->next;` 上，依此类推。如果列表足够长，这会导致非常具体的栈溢出风险，而循环可以完全避免这种情况。
- en: 'There is a simple lesson here: life is easier when each class has a single
    responsibility. This is something that’s been known for a while as the “single
    responsibility principle”. That principle is the ‘S’ in the well-known SOLID principles
    of object-oriented programming. Let the container deal with the organization of
    nodes in a node-based container and let the nodes store values.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的教训：当每个类都有一个单一责任时，生活会更简单。这已经有一段时间被知道为“单一责任原则”。这个原则是众所周知的面向对象编程 SOLID
    原则中的 'S'。让容器处理基于节点的容器中的节点组织，并让节点存储值。
- en: 'As far as constructors go, we will implement a small set for this class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就构造函数而言，我们将为这个类实现一个小集合：
- en: A default constructor that models an empty list
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模拟空列表的默认构造函数
- en: A constructor that accepts a `std::initializer_list<T>` as argument
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受 `std::initializer_list<T>` 作为参数的构造函数
- en: A copy constructor that duplicates each node from the source list in order
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复制构造函数，它按顺序从源列表复制每个节点
- en: A move constructor
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个移动构造函数
- en: 'A sequence constructor that accepts two objects of some type, `It`, that satisfies
    the `std::input_iterator` concept (essentially: that lets you make at least a
    single pass through the sequence and consume the elements, which is all we need
    to do the job)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受满足 `std::input_iterator` 概念的某些类型 `It` 的两个对象的序列构造函数（本质上：允许你至少遍历一次序列并消费元素，这是我们完成工作所需的所有）
- en: 'It happens that this last constructor can be seen as a generalization of some
    of the others, and that only the default constructor and the move constructor
    really benefit from being written separately (we could technically compute the
    size of the sequence more efficiently if we did not delegate the work to a general
    constructor, so if this makes a difference in your code base, feel free to do
    so):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个最后的构造函数可以被看作是对其他一些构造函数的泛化，并且只有默认构造函数和移动构造函数真正从单独编写中受益（如果我们不将工作委托给一个通用构造函数，我们可以更有效地计算序列的大小，所以如果这在你的代码库中有所区别，请随意这样做）：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Unsurprisingly, assignment can be expressed through the safe assignment idiom
    that we applied in the case of type `Vector<T>` earlier:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，赋值可以通过我们在之前 `Vector<T>` 类型案例中应用的安全赋值习语来表示：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Some of the remaining operations can reasonably be said to be trivial, for
    example, `front()`, `operator==()`, and `push_front()`. As you could reasonably
    assume for a forward list, we will implement neither a `back()` nor a `push_back()`
    member function as there would not be an efficient way to do so with our representational
    choices (the only reasonable algorithm would require looping through the whole
    construct in order to find the last node, leading to a linear complexity algorithm):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一些剩余的操作可以合理地被认为是微不足道的，例如，`front()`、`operator==()` 和 `push_front()`。正如你可以合理地假设对于前向列表，我们不会实现
    `back()` 或 `push_back()` 成员函数，因为我们没有有效的算法来完成我们的表示选择（唯一合理的算法需要遍历整个结构以找到最后一个节点，从而导致线性复杂度的算法）：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As an example of value insertion into a container, consider the following `insert_after()`
    member function, which inserts a node with a value of `value` after the node pointed
    to by `pos`. With this function, we could easily build more complex ones, such
    as one that inserts a sequence of values after some position in the list (try
    it!):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将值插入容器的一个例子，考虑以下 `insert_after()` 成员函数，该函数在由 `pos` 指向的节点之后插入一个值为 `value` 的节点。使用此函数，我们可以轻松构建更复杂的函数，例如在列表中的某个位置之后插入一系列值的函数（试试看！）：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Offering the possibility of adding elements to a container is a useful feature
    indeed, and so is offering the option of removing an element from a container.
    As an example, see the following `erase_after()` member function implementation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 提供向容器中添加元素的可能性确实是一个有用的功能，同样，提供从容器中删除元素的选择也是。例如，请参见以下 `erase_after()` 成员函数的实现：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That should do the job for this class. For the rest of this chapter, there will
    be little room for improvement for `ForwardList<T>`, but we will return to this
    class in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187), and more so in [*Chapter
    14*](B21071_14.xhtml#_idTextAnchor199).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就足够了这个类。在本章的其余部分，对于 `ForwardList<T>` 来说，改进的空间很小，但我们将回到这个类，特别是在 [*第13章*](B21071_13.xhtml#_idTextAnchor187)，以及更详细的
    [*第14章*](B21071_14.xhtml#_idTextAnchor199)。
- en: For `Vector<T>`, however, we can do significantly better than we have so far…
    at the cost of some added complexity. But we are ready for this, are we not?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `Vector<T>`，我们可以做得比迄今为止更好……但这需要一些额外的复杂性。但我们准备好了，不是吗？
- en: Better memory management
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的内存管理
- en: 'So, this humble writer claims our nice but simple `Vector<T>` type is no match
    for `std::vector<T>`. That may seem like a bold claim: after all, we seemed to
    do what was needed and, no less, we used algorithms instead of raw loops; we caught
    exceptions as we wanted to be exception-safe but limited ourselves to cleaning
    up the resources… What are we doing wrong?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这位谦逊的作者声称我们优雅但简单的 `Vector<T>` 类型与 `std::vector<T>` 无法匹敌。这听起来可能是一个大胆的声明：毕竟，我们似乎已经完成了所需的工作，而且，我们不仅使用了算法而不是原始循环；我们还捕获了异常，因为我们希望异常安全，但仅限于清理资源……我们做错了什么？
- en: If you run comparative benchmarks between a `Vector<int>` object and a `std::vector<int>`
    object, in fact, you will probably not notice much of a difference in the respective
    numbers of both tests. For example, try adding a million `int` objects (through
    `push_back()`) to each of these containers and you will think our container holds
    its own quite well. Cool! Now, change that to a comparative test between `Vector<std::string>`
    and `std::vector<std::string>` and you might be saddened a bit, seeing that we’re
    “left behind in the dust,” as they say.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个 `Vector<int>` 对象和一个 `std::vector<int>` 对象之间运行比较基准测试，实际上，你可能会在两个测试的相应数字之间发现不了太大的差异。例如，尝试向每个这些容器中添加一百万个
    `int` 对象（通过 `push_back()`），你会认为我们的容器表现得很不错。酷！现在，将其改为 `Vector<std::string>` 和 `std::vector<std::string>`
    之间的比较测试，你可能会有些失望，因为我们“落后在尘埃中”，正如他们所说。
- en: A word about the small object optimization
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于小对象优化的一词
- en: This will show more if you add strings that are not too short (try at least
    25 characters, say) as with “short” strings (for some indeterminate value of “short”)
    most standard libraries will perform what is called the **Small String Optimization**
    (**SSO**), a special case of the **Small Object Optimization** (**SOO**). Through
    this optimization, when the data to store in an object is small enough, the implementation
    will use the storage for the so-called “control block” (the data members, really)
    of the object as raw storage, avoiding dynamic memory allocation altogether. Because
    of this, “small” strings do not allocate and are very, very fast in practice.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加的不是太短的字符串（至少25个字符，比如），这将显示更多，因为对于某些不确定的“短”字符串值，大多数标准库都会执行所谓的**小字符串优化**（**SSO**），这是**小对象优化**（**SOO**）的一个特例。通过这种优化，当存储在对象中的数据足够小的时候，实现将使用所谓的“控制块”（实际上是数据成员）的存储作为原始存储，从而完全避免动态内存分配。正因为如此，“小”字符串不会分配，并且在实践中非常非常快。
- en: But why?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么呢？
- en: 'There is a clue in the type of element in both tests: `int` is a trivially
    constructible type, and `std::string` is not. This clue is an indication that
    `std::vector` might be calling fewer constructors than we are, essentially being
    more efficient than `Vector<T>` in the way it handles memory and the objects therein.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个测试的元素类型中有一个线索：`int`是一个平凡可构造的类型，而`std::string`不是。这个线索表明`std::vector`可能调用
    fewer 构造函数，本质上比`Vector<T>`在处理内存和其中的对象方面更有效率。
- en: 'What’s the problem? Well, let’s look at one of the constructors of `Vector<T>`
    to get an appreciation of the problem with our implementation. Any constructor
    but the default constructor (defaulted in our implementation) and the move constructor
    would do, so let’s take the one that accepts a number of elements and an initial
    value as arguments. Pay special attention to the highlighted code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？好吧，让我们看看`Vector<T>`的一个构造函数，以了解我们实现中存在的问题。除了默认构造函数（在我们的实现中是默认的）和移动构造函数之外，任何构造函数都可以，所以让我们选择接受元素数量和初始值作为参数的那个。请特别注意以下高亮代码：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The construction of the `elems` data member allocates a block of memory big
    enough to hold `n` objects of type `T` and calls the default constructor for each
    of these `n` elements. Obviously, if `T` is trivially constructible, then these
    default constructors are not a big source of worries, but you could question the
    virtue of so doing if `T` is not trivially constructible.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`elems`数据成员的构造分配了一个足够容纳`n`个类型为`T`的对象的内存块，并为这些`n`个元素中的每一个调用默认构造函数。显然，如果`T`是平凡可构造的，那么这些默认构造函数并不是一个大的担忧来源，但如果你认为`T`不是平凡可构造的，那么你可能会质疑这样做的好处。'
- en: 'Still, you might want to argue that the objects need to be constructed, but
    then look ahead and you will notice that `std::fill()` replaces each of these
    default `T` objects with a copy of `init`, showing that the initial default construction
    of the objects was essentially a waste of time (we never used these objects!).
    This is the sort of thing that `std::vector<T>` does so much better than we do:
    it avoids wasteful operations, restricting itself to what is necessary.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然，你可能会争辩说对象需要被构造，但然后向前看，你会注意到`std::fill()`将每个这些默认的`T`对象替换为`init`的一个副本，这表明对象的初始默认构造基本上是浪费时间（我们从未使用过这些对象！）这是`std::vector<T>`比我们做得更好的那种类型：避免浪费操作，仅限于必要的事情。
- en: We will now try to see how we could get closer in performance to what `std::vector<T>`
    achieves in practice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将尝试了解我们如何能更接近`std::vector<T>`在实践中实现的效果。
- en: A more efficient Vector<T>
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高效的Vector<T>
- en: The key to a more efficient `Vector<T>` is distinguishing allocation from construction,
    something we have discussed many times in this book, and, well, lying to the type
    system in adequate ways and in a controlled environment. Yes, those “evil” early
    chapters of this book will come in handy now.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更高效的`Vector<T>`的关键是区分分配和构造，这是我们在这本书中多次讨论过的，并且，嗯，以适当的方式和受控的环境欺骗类型系统。是的，这本书中那些“邪恶”的早期章节现在会很有用。
- en: We will not rewrite the entirety of `Vector<T>` in these pages, but we will
    look at selected member functions to highlight what needs to be done (a full implementation
    is available in the GitHub repository mentioned at the beginning of this chapter).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本页中重写整个`Vector<T>`，但我们会查看选定的成员函数来突出需要完成的工作（完整的实现可以在本章开头提到的GitHub仓库中找到）。
- en: 'We could try to do this effort manually, using the language facilities we already
    know about, such as `std::malloc()`, to allocate a raw memory block and placement
    `new` to construct the objects in that block. Taking the same constructor that
    takes a number of elements and an initial value as arguments, we would then get
    the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试手动进行这项工作，使用我们已知的语言设施，例如 `std::malloc()`，来分配一个原始内存块，并使用放置 `new` 来在该块中构造对象。使用相同的构造函数，该构造函数接受元素数量和初始值作为参数，我们就会得到以下内容：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that’s… unpleasant. Pay attention to the sections marked with are **A**
    to **D** in this function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是…令人不愉快。请注意这个函数中标记为 **A** 到 **D** 的部分：
- en: In `n` objects of type `T` but limit ourselves to raw memory allocation (the
    constructor of no `T` object is being called at this point), yet we keep a `T*`
    to that block of memory for our own purposes. Our implementation needs to be aware,
    internally, that the type of the `elems` pointer is incorrect at this stage.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `n` 个类型为 `T` 的对象中，但我们限制自己使用原始内存分配（在这个点上没有调用 `T` 对象的构造函数），但我们保留一个指向该内存块的 `T*`
    以供我们自己的目的。我们的实现需要内部知道，在这一点上 `elems` 指针的类型是不正确的。
- en: In `begin()` knowing that `iterator` is the same thing as `T*` in our implementation.
    If our implementation used a class instead of a raw pointer to model an iterator,
    we would have to do some work here to get the underlying pointer to the raw storage
    in order to implement the rest of the function.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `begin()` 中知道 `iterator` 在我们的实现中与 `T*` 是同一件事。如果我们的实现使用类而不是原始指针来模拟迭代器，我们就必须在这里做一些工作，以获取底层指针到原始存储的指针，以便实现函数的其余部分。
- en: In `T` objects in place within the block of memory we allocated. Since there
    are no objects there to replace, we construct these objects with the placement
    `new`, and use the fact that we lied to the type system (in the sense that we
    used a `T*` even though we allocated raw memory) to do the pointer arithmetic
    required to move from one object to another.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们分配的内存块内 `T` 对象的位置。由于那里没有对象可以替换，我们使用放置 `new` 来构造这些对象，并利用我们对类型系统撒谎的事实（即我们使用了
    `T*`，尽管我们分配了原始内存）来进行从对象到对象的指针算术操作。
- en: In `T` objects. Since we are the only ones who know that there are `T` objects
    therein, just as we are the only ones who know exactly where the first object
    that we failed to construct is, we need to destroy the objects manually, then
    free the (now raw) memory block and re-throw the exception. As a bonus, this implementation
    is not even standards-compliant; we should destroy the objects in reverse order
    of construction, something this example does not do.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `T` 对象中。因为我们是我们唯一知道其中存在 `T` 个对象的人，就像我们是我们唯一知道我们未能构造的第一个对象确切位置的人一样，我们需要手动销毁这些对象，然后释放（现在为原始的）内存块并重新抛出异常。作为额外的好处，这种实现甚至不符合标准；我们应该按照构造的相反顺序销毁对象，而本例并没有这样做。
- en: 'By the way, this example shows a clear example of the reasons why you cannot
    throw from a destructor: if an exception is thrown during **D**, we cannot reasonably
    hope to recover (at least not without incurring prohibitive costs).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这个例子清楚地说明了为什么你不能从析构函数中抛出异常：如果在 **D** 期间抛出异常，我们无法合理地希望恢复（至少不是不承担高昂的成本）。
- en: You, dear reader, are probably thinking right now that this is unreasonably
    complicated and way too error-prone for non-specialists to hope to be able to
    write a whole container that way. Indeed, this sort of complexity would creep
    into a significant number of member functions, making quality control much more
    difficult than you would hope.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你，亲爱的读者，现在可能正在想，这对非专业人士来说过于复杂，而且错误率极高，以至于他们无法希望以这种方式编写整个容器。确实，这种复杂性会渗透到大量成员函数中，使得质量控制比你所希望的更加困难。
- en: But wait, there is hope! As you might imagine, your library vendors face the
    same challenges we do (and more!), so the standard library provides low-level
    facilities that make handling raw memory in homemade containers a reasonably achievable
    task as long as you know, well, what you have read in this book so far.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，还有希望！正如你可能想象的那样，你的库供应商面临着与我们相同的挑战（以及更多！），因此标准库提供了低级设施，使得在自定义容器中处理原始内存成为一项合理可实现的任务，只要你了解，嗯，你在这本书中迄今为止所读到的内容。
- en: Using low-level standard facilities
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用低级标准设施
- en: The `<memory>` standard library header is a treasure trove of useful facilities
    for those who dabble in memory management. We have already discussed the standard
    smart pointers defined in that header (see [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079)
    for a reminder), but if you look a bit deeper, you will see some algorithms made
    to operate on raw memory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`<memory>` 标准库头文件是内存管理爱好者的一座宝库。我们已经在该头文件中讨论了定义的标准智能指针（见[*第5章*](B21071_05.xhtml#_idTextAnchor079)以获取提醒），但如果你深入研究，你将看到一些用于操作原始内存的算法。'
- en: Keeping as an example the `Vector<T>` constructor that takes a number of elements
    and an initial value as argument, we went from something rather simple that allocates
    an array of `T` objects and replaces them through a call to `std::fill()` to something
    significantly more complicated. The original version was both simple and inefficient
    (we constructed unneeded objects just to replace them); the replacement was much
    more efficient (doing minimal work) but required much more skill to write and
    maintain.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `Vector<T>` 构造函数为例，它接受一个元素数量和一个初始值作为参数，我们从相对简单的东西开始，它分配一个 `T` 对象的数组并通过调用 `std::fill()`
    来替换它们，变成了一个显著更复杂的版本。原始版本既简单又低效（我们构建了不需要的对象只是为了替换它们）；替换版本更高效（做最小的工作），但需要更多的技能来编写和维护。
- en: We will now examine the impact of these facilities on the implementation of
    our allocating member functions. The first such functions we will pay attention
    to are the constructors, as they make a nice starting point.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查这些功能对我们分配成员函数实现的影响。我们将首先关注构造函数，因为它们是一个很好的起点。
- en: Impact on constructors
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对构造函数的影响
- en: 'In practice, when you want to write a homemade container that manages memory
    explicitly, it’s better to use the low-level facilities found in `<memory>`. Take
    the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当你想编写一个显式管理内存的自定义容器时，最好使用 `<memory>` 中找到的低级功能。以下是一个例子：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is much nicer than the version we entirely wrote ourselves, is it not?
    The two highlights of this version are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们完全自己编写的版本要好得多，不是吗？这个版本的两大亮点如下：
- en: We allocate a properly sized block of raw memory instead of an array of `T`
    objects, thus avoiding all of the unneeded default constructors the initial version
    had.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们分配了一个适当大小的原始内存块，而不是 `T` 对象的数组，从而避免了初始版本中所有不必要的默认构造函数。
- en: We replaced the call to `std::fill()` (found in `<algorithm>`), which uses `T::operator=(const
    T&)` and thus supposes an existing object to the left side of the assignment with
    a call to `std::uninitialized_fill()`, which instead supposes that it is iterating
    through raw memory and initializes the objects through the placement `new`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用 `std::uninitialized_fill()` 的调用替换了 `std::fill()`（在 `<algorithm>` 中找到），它使用
    `T::operator=(const T&)` 并因此假设赋值操作左侧存在一个现有的对象，而 `std::uninitialized_fill()` 则假设它正在遍历原始内存并通过放置
    `new` 来初始化对象。
- en: The beauty of this algorithm (and others of this family) is that it is exception-safe.
    If one of the constructors invoked by `std::uninitialized_fill()` ends up throwing,
    then the objects it had managed to create before the exception occurred will be
    destroyed (in reverse order of construction, as they should) before the exception
    leaves the function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法（以及这个家族的其他算法）的美丽之处在于它是异常安全的。如果由 `std::uninitialized_fill()` 调用的任何一个构造函数最终抛出异常，那么在异常发生之前它成功创建的对象将会被销毁（按照构造的相反顺序，正如它们应该的那样），然后异常才会离开函数。
- en: It’s what we had written (clumsily) by hand, really. Apart from the fact that
    we now allocate and free raw memory, the rest of the code is very similar to the
    original, simple version. This probably makes you feel much better… and it should.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们手动（笨拙地）编写的。除了我们现在分配和释放原始内存之外，其余的代码与原始的简单版本非常相似。这可能会让你感觉好很多……而且确实应该如此。
- en: 'A similar approach can be taken with other constructors. Take, for example,
    the copy constructor:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他构造函数也可以采取类似的方法。以复制构造函数为例：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, with the proper algorithms, the fast implementations that work
    on raw memory are very similar to the naïve and slower versions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有了合适的算法，在原始内存上工作的快速实现与原始的、较慢的版本非常相似。
- en: 'The key point here is to understand the boundaries of the API. A function such
    as `std::uninitialized_copy()` takes three arguments: the beginning and end of
    a source sequence (this sequence is presumed to contain objects) and the beginning
    of the destination sequence (this sequence is presumed to be appropriately aligned
    and made of raw memory, not objects). If the function concludes its execution
    because it met its postconditions and constructed the objects in the destination
    sequence, then that destination sequence contains objects. On the other hand,
    if the function fails to meet its postconditions, then there are no objects in
    the destination sequence as whatever the function has constructed, it will also
    have destructed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的是理解API的边界。例如，`std::uninitialized_copy()`函数接受三个参数：源序列的开始和结束（这个序列假定包含对象）以及目标序列的开始（这个序列假定是适当对齐的，由原始内存组成，而不是对象）。如果函数因为满足其后置条件并在目标序列中构造了对象而完成其执行，那么目标序列包含对象。另一方面，如果函数未能满足其后置条件，那么目标序列中没有对象，因为无论函数构造了什么，它也会销毁。
- en: Similar maneuvers can be done with other constructors, keeping in mind that
    the default constructor and the move constructor are implemented very differently
    and as such deserve a different treatment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用其他构造函数进行类似的操作，记住默认构造函数和移动构造函数实现得非常不同，因此需要不同的处理方式。
- en: Impact on the destructor
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对析构函数的影响
- en: 'The destructor in this implementation of `Vector<T>` is interesting: when the
    object reaches the end of its lifetime, we cannot simply call `delete[]` on the
    `elems` data member as it has not been allocated by `new[]` in the first place
    and it is made of a sequence of `T` objects, potentially followed by a sequence
    of raw bytes. We would not want to call `T::~T()` on an arbitrary sequence of
    bytes since this could cause quite a lot of damage in our program and incur **UB**.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Vector<T>`的这个实现中，析构函数很有趣：当对象达到其生命周期的末尾时，我们不能简单地对其`elems`数据成员调用`delete[]`，因为它最初并没有通过`new[]`分配，它是由一系列`T`对象组成的，后面可能跟着一系列原始字节。我们不想对任意序列的字节调用`T::~T()`，因为这可能会在我们的程序中造成相当大的破坏并引起**UB**。
- en: 'The only entity that knows how many objects there are in the container is the
    `Vector<T>` object itself, which means that it will need to `destroy()` the remaining
    objects, and only then `free()` the (now devoid of objects) memory block that
    remains. Applying the `std::destroy()` algorithm on a sequence of `T` objects
    calls `T::~T()` on each of them, turning a sequence of objects into raw memory:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一知道容器中有多少对象的是`Vector<T>`对象本身，这意味着它将需要`destroy()`剩余的对象，然后才能`free()`（现在已无对象）的剩余内存块。在`T`对象序列上应用`std::destroy()`算法会在每个对象上调用`T::~T()`，将对象序列转换为原始内存：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These low-level memory management algorithms really help in clarifying the intent
    of the code we write, as you can see.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些低级内存管理算法确实有助于阐明我们编写的代码的意图，正如你所看到的。
- en: Impact on per-element insertion functions
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对每个元素插入函数的影响
- en: A similar situation happens in member functions `push_back()` and `emplace_back()`
    where we used to replace through an assignment some existing object at the end
    of our array; we now need to construct an object at the end of the array since
    there is no object there anymore (we do not construct objects needlessly; that’s
    the point of our efforts!).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员函数`push_back()`和`emplace_back()`中也发生了类似的情况，我们过去通过赋值替换数组末尾的一些现有对象；现在我们需要在数组的末尾构造一个对象，因为那里已经没有对象了（我们不无谓地构造对象；这就是我们努力的目标！）。
- en: 'We could use placement `new` to do this, obviously, but the standard library
    offers a moral equivalent named `std::construct_at()`. This makes our intent even
    clearer from the source code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用placement `new`来完成这个任务，但标准库提供了一个道德上的等价物，名为`std::construct_at()`。这使得从源代码中我们的意图更加清晰：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Impact on growth functions
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对增长函数的影响
- en: The `grow()` function we had implemented initially called `resize()` on our
    `Vector<T>`, but `resize()` is meant to initialize the storage with objects. To
    make the allocated storage grow in size without initializing it with objects,
    we need a different member function, namely `reserve()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初实现的`grow()`函数在`Vector<T>`上调用的是`resize()`，但`resize()`是用来初始化存储为对象的。为了在不使用对象初始化的情况下使分配的存储空间增长，我们需要一个不同的成员函数，即`reserve()`。
- en: On the differences between resize() and reserve()
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`resize()`和`reserve()`之间的区别
- en: Expressed simply, `resize()` potentially adds objects to the container, and
    as such it can modify both `size()` and `capacity()`. On the other hand, `reserve()`
    adds no object to the container, limiting itself to potentially increasing the
    storage space being used by the container; in other words, `reserve()` can change
    `capacity()` but will not change `size()`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`resize()` 可能向容器中添加对象，因此它可以修改 `size()` 和 `capacity()`。另一方面，`reserve()`
    不会向容器添加任何对象，仅限于可能增加容器使用的存储空间；换句话说，`reserve()` 可以改变 `capacity()` 但不会改变 `size()`。
- en: 'Following the example set by `std::vector<T>`, our `Vector<T>` class will offer
    both `resize()` and `reserve()`. A version of `resize()` adapted to the new reality
    of our part-objects, part-raw-memory container follows, accompanied by an implementation
    of `reserve()` that suits `Vector<T>`. We will discuss `reserve()` and `resize()`
    separately:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着 `std::vector<T>` 设定的例子，我们的 `Vector<T>` 类将提供 `resize()` 和 `reserve()`。以下是一个
    `resize()` 的版本，它适应了我们部分对象、部分原始内存容器的现实情况，并伴随着一个适合 `Vector<T>` 的 `reserve()` 实现。我们将分别讨论
    `reserve()` 和 `resize()`：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `reserve()` member function first ensures that the requested new capacity
    is higher than the existing one (otherwise there’s nothing to do). If that is
    so, it allocates a new memory block and either moves or copies the existing elements
    of the `Vector<T>` object into that new memory (a copy will be made if moving
    `T` objects can throw: it pays to make move operations `noexcept`, dear readers!)
    using algorithms that construct objects into raw memory.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`reserve()` 成员函数首先确保请求的新容量高于现有容量（否则就没有什么可做的）。如果是这样，它将分配一个新的内存块，并将 `Vector<T>`
    对象的现有元素移动或复制到该新内存中（如果移动 `T` 对象可以抛出异常，则将进行复制：亲爱的读者，进行移动操作时 `noexcept` 是值得的！）使用构建对象到原始内存中的算法。'
- en: 'The `T` objects left in `elems` are then destroyed (even if they have been
    moved-from: they still need to be finalized), and we ensure that `cap` is updated
    and `elems` points to the new block of storage. Of course, `size()` does not change
    as no new object has been added to the container.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后销毁 `elems` 中留下的 `T` 对象（即使它们已经被移动：它们仍然需要被最终化），并确保更新 `cap` 并使 `elems` 指向新的存储块。当然，`size()`
    不会改变，因为容器中没有添加新对象。
- en: 'The procedure is similar for `resize()` (as follows), except that the locations
    in the memory block starting at the `size()` index are initialized with a default
    `T` instead of being left in their raw memory state. Consequently, `size()` is
    updated, leading to different semantics from those obtained following a call to
    `reserve()`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `resize()`（如下所示）的过程类似，但不同之处在于，从 `size()` 索引开始的内存块中的位置被初始化为默认的 `T` 而不是保留在原始内存状态。因此，`size()`
    被更新，导致与调用 `reserve()` 后获得的语义不同：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This more sophisticated structure we are implementing will obviously have an
    impact on the way we `insert()` or `erase()` elements.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实施的这种更复杂的结构显然会影响我们 `insert()` 或 `erase()` 元素的方式。
- en: Impact on element insertion and erasure functions
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对元素插入和删除函数的影响
- en: As expected, member functions such as `insert()` and `erase()` have to be updated
    to take into account the changes we have made to the internal organization of
    `Vector<T>` objects. That does not have to be painful (and, indeed, required changes,
    if any, can be tiny) as long as the semantics of every function are clear from
    the onset, but it does require care.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，成员函数如 `insert()` 和 `erase()` 必须更新以考虑我们对 `Vector<T>` 对象内部组织所做的更改。只要每个函数的语义从一开始就清晰，这并不痛苦（实际上，如果有任何更改，它们可能非常微小），但它确实需要小心。
- en: 'For example, using `insert(pos,first,last)` as an example, we are moving from
    the simple model described in *Figure 12**.1*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以 `insert(pos,first,last)` 为例，我们正在从 *图12.1* 描述的简单模型转移到：
- en: '![Figure 12.1 – Example of the naïve Vector<T> insertion model](img/B21071_12_01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 简单Vector<T>插入模型的示例](img/B21071_12_01.jpg)'
- en: Figure 12.1 – Example of the naïve Vector<T> insertion model
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 简单Vector<T>插入模型的示例
- en: 'Here, inserting a `[first,last)` sequence at position `pos` means copying (in
    reverse order) the elements in `[pos,end())` at position `pos + n`, then overwriting
    the elements of `[pos,pos+n)` with `[first,last)` to the more complex model described
    in *Figure 12**.2*:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在位置 `pos` 插入 `[first,last)` 序列意味着（以相反顺序）复制 `[pos,end())` 中的元素到位置 `pos +
    n`，然后使用 `[first,last)` 覆盖 `[pos,pos+n)` 中的元素，以更复杂的模型描述 *图12.2*：
- en: '![Figure 12.2 – Example of the current Vector<T> insertion model](img/B21071_12_02.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 当前Vector<T>插入模型的示例](img/B21071_12_02.jpg)'
- en: Figure 12.2 – Example of the current Vector<T> insertion model
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 当前 Vector<T> 插入模型的示例
- en: The idea is that we need to insert `[first,last)` at position `pos`, which means
    that the elements in `[pos,pos+n)` have to be copied (or moved) to the right.
    This will require constructing some objects in raw memory (the gray area in the
    preceding figure) and replacing some other objects through copy (or move) assignment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是我们需要在 `pos` 位置插入 `[first,last)`，这意味着 `[pos,pos+n)` 中的元素必须被复制（或移动）。这将需要在原始内存中构造一些对象（如图中所示的灰色区域）并通过复制（或移动）赋值来替换一些其他对象。
- en: 'There are four steps to consider here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要考虑四个步骤：
- en: How many elements should be copied or moved from the `[begin(),end())` sequence
    to the raw memory block at the end of the container, and where in that block should
    the resulting objects be constructed.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该从 `[begin(),end())` 序列中复制或移动多少个元素到容器末尾的原始内存块中，以及在这些块中应该在哪里构造结果对象。
- en: If there are elements from the `[first,last)` sequence to insert in raw memory
    (there could be none), how many should there be? If there are any such objects,
    they will be inserted at `end()`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要从 `[first,last)` 序列中插入到原始内存中的元素（可能没有），应该有多少个？如果有这样的对象，它们将被插入到 `end()`。
- en: If there are elements to copy or move from the `[pos,end())` sequence to copy
    or move as a replacement to existing objects in the container (there could be
    none), how many should there be? The end of the destination range will be `end()`
    in this case.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要从 `[pos,end())` 序列中复制或移动元素以替换容器中现有的对象（可能没有），应该有多少个？在这种情况下，目标范围的末尾将是 `end()`。
- en: Finally, whatever remains to be inserted from the `[first,last)` sequence will
    be copied in the container starting at `pos`.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，从 `[first,last)` 序列中剩余要插入的部分将被复制到容器的 `pos` 位置开始处。
- en: 'A possible implementation would be the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的实现方式如下：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Make sure you do not move the elements in `[first,last)`, however: that would
    be user-hostile as it would potentially destroy the data in the source range!'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您不要移动 `[first,last)` 中的元素：这将是对用户不友好的，因为它可能会破坏源范围内的数据！
- en: 'As for the `erase()` member function that we had written in a more naïve manner
    initially, the key adjustment we will need to make is in the way we handle the
    removed element: you might remember that in our naïve version, we assigned a default
    `T` to the erased element at the end of the container, and complained that this
    added the suspicious requirement of a default constructor in type `T`. In this
    version, we will quite simply destroy this object, ending its lifetime and turning
    its underlying storage back into raw memory:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们最初以更天真方式编写的 `erase()` 成员函数，我们需要做出的关键调整是在处理被移除元素的方式上：您可能还记得，在我们的天真版本中，我们在容器的末尾将默认的
    `T` 赋值给被移除的元素，并抱怨这增加了类型 `T` 中默认构造函数的可疑要求。在这个版本中，我们将简单地销毁这个对象，结束其生命周期，并将其底层存储转换回原始内存：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Hopefully, this gives you, dear reader, a better idea of what it takes to write
    a more serious implementation of a homemade `std::vector`-like type and a better
    appreciation for the craftsmanship of the individuals behind your favorite standard
    library provider. Know that they do all this and more for your programs to be
    the wonderfully efficient things they are!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能让您，亲爱的读者，对编写更严肃的自家 `std::vector` 类型的实现有更好的理解，并对您最喜欢的标准库提供者的工艺有更高的欣赏。要知道，他们为您的程序能够如此高效地运行付出了这一切和更多！
- en: Const or reference members and std::launder()
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量或引用成员和 std::launder()
- en: Before we conclude this chapter, we need to say a few words on those oddities
    that are containers that hold objects of `const` types, as well as on containers
    whose elements are of a type with `const` or reference members.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，我们需要说几句关于那些奇怪的容器，这些容器持有 `const` 类型的对象，以及那些元素为具有 `const` 或引用成员的类型容器的奇事。
- en: 'Consider this seemingly innocuous program:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个看似无害的程序：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With the implementation we have, this will refuse to compile as our implementation
    calls a number of low-level functions (`std::free()`, `std::destroy_at()`, `std::construct_at()`,
    and so on) that take a pointer to a non-`const` type as an argument.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们目前的实现而言，这将无法编译，因为我们的实现调用了一些低级函数（如 `std::free()`、`std::destroy_at()`、`std::construct_at()`
    等），这些函数的参数是一个指向非 `const` 类型的指针。
- en: If we are to support such a program, it means we will have to “cast away” `const`-ness
    in some places in our implementation. For example, replacing the following line
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要支持这样的程序，这意味着我们将在实现的一些地方“去除”`const`属性。例如，替换以下行
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'with this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'with this:'
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '#include <type_traits>'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <type_traits>'
- en: template <class T>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 模板 <class T>
- en: struct X {
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: struct X {
- en: static_assert(std::is_trivially_destructible_v<T>);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: static_assert(std::is_trivially_destructible_v<T>);
- en: T &r;
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: T &r;
- en: 'public:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: 'X(T &r) : r{ r } {'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'X(T &r) : r{ r } {'
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: T& value() { return r; }
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: T& value() { return r; }
- en: const T & value() const { return r; }
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: const T & value() const { return r; }
- en: '};'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // ...
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: // ...
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '#include <iostream>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <new>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <new>'
- en: int main() {
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: int n = 3;
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 3;
- en: X<int> h{ n };
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: X<int> h{ n };
- en: h.value()++;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: h.value()++;
- en: std::cout << n << '\n'; // 4
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << n << '\n'; // 4
- en: std::cout << h.value() << '\n'; // 4
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << h.value() << '\n'; // 4
- en: int m = -3;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: int m = -3;
- en: // h = X<int>{ m }; // nope
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: // h = X<int>{ m }; // 不行
- en: X<int> *p = new (static_cast<void*>(&h)) X<int>{ m };
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: X<int> *p = new (static_cast<void*>(&h)) X<int>{ m };
- en: std::cout << p->value() << '\n'; // -3
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << p->value() << '\n'; // -3
- en: // UB (-3? 4? something else?)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: // UB (-3? 4? 其他什么？)
- en: std::cout << h.value() << '\n';
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << h.value() << '\n';
- en: std::cout << std::launder(&h)->value() << '\n'; // -3
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << std::launder(&h)->value() << '\n'; // -3
- en: '}'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
