- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Sanitizing and Testing Asynchronous Software
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理和测试异步软件
- en: '**Testing** is the process of evaluating and verifying that a software solution
    does what it’s meant to do, validating its quality and ensuring that user requirements
    are met. With proper testing, we can prevent bugs from happening and improve performance.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**是评估和验证软件解决方案是否按预期工作，验证其质量并确保满足用户需求的过程。通过适当的测试，我们可以预防错误的发生并提高性能。'
- en: In this chapter, we will explore several techniques to test asynchronous software,
    mainly using the **GoogleTest** library and sanitizers available from **GNU Compiler
    Collection** ( **GCC** ) and **Clang** compilers. Some prior knowledge in unit
    testing is required. In the *Further reading* section at the end of this chapter,
    you can find some references that could be useful to refresh and expand your knowledge
    in these areas.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几种测试异步软件的技术，主要使用**GoogleTest**库以及来自**GNU 编译器集合**（**GCC**）和**Clang**编译器的清理器。需要一些单元测试的先验知识。在本章末尾的**进一步阅读**部分，您可以找到一些可能有助于刷新和扩展这些领域知识的参考资料。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Sanitizing code to analyze the software and find potential issues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理代码以分析软件并查找潜在问题
- en: Testing asynchronous code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will need to install **GoogleTest** ( [https://google.github.io/googletest](https://google.github.io/googletest)
    ) to compile some of the examples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要安装**GoogleTest**（[https://google.github.io/googletest](https://google.github.io/googletest)）来编译一些示例。
- en: Some examples need a compiler supporting C++20. Therefore, check the *Technical
    requirements* section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051) , as
    it includes some guidance on how to install GCC 13 and Clang 8 compilers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例需要支持 C++20 的编译器。因此，请参阅[*第 3 章*](B22219_03.xhtml#_idTextAnchor051)中的**技术要求**部分，因为它包含有关如何安装
    GCC 13 和 Clang 8 编译器的指导。
- en: 'You can find all the complete code in the following GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 仓库中找到所有完整代码：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: 'The examples for this chapter are located under the **Chapter_12** folder.
    All source code files can be compiled using CMake as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于**Chapter_12**文件夹下。所有源代码文件都可以使用以下 CMake 编译：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Executable binaries will be generated under the **bin** directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行二进制文件将在**bin**目录下生成。
- en: Sanitizing code to analyze the software and find potential issues
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理代码以分析软件并查找潜在问题
- en: '**Sanitizers** are tools, originally developed by Google, used to detect and
    prevent various types of issues or security vulnerabilities in code, helping developers
    catch bugs early in the development process, reducing the cost of issues being
    fixed late, and increasing software stability and security.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**清理器**是工具，最初由 Google 开发，用于检测和预防代码中各种类型的问题或安全漏洞，帮助开发者尽早在开发过程中捕捉到错误，减少后期修复问题的成本，并提高软件的稳定性和安全性。'
- en: Sanitizers are usually integrated into development environments and are usually
    enabled during manual testing or when running unit tests, **continuous integration**
    ( **CI** ) pipelines, or code review pipelines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 清理器通常集成到开发环境中，并在手动测试或运行单元测试、**持续集成**（**CI**）管道或代码审查管道时启用。
- en: C++ compilers, such as GCC and Clang, have compiler options to generate code
    when building the program to track the execution at runtime and report errors
    and vulnerabilities. They are implemented in Clang from version 3.1 and GCC from
    version 4.8.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器，如 GCC 和 Clang，在构建程序时提供编译器选项以生成代码，以跟踪运行时的执行并报告错误和漏洞。这些功能从 Clang 3.1 版本和
    GCC 4.8 版本开始实现。
- en: As extra instructions are injected into the program’s binary code, there is
    a performance penalty of around 1.5x to 4x slowdowns depending on the sanitizer
    type. Also, there is an overall memory overhead of 2x to 4x and a stack size increase
    of up to 3x. But note that slowdowns are much lower than the ones experienced
    when using other instrumentation frameworks or dynamic analysis tools, such as
    **Valgrind** ( [https://valgrind.org](https://valgrind.org) ), which imposes a
    much higher slowdown of up to 50 times slower than production binaries. On the
    other hand, the benefit of using Valgrind is that no recompilation is needed.
    Both approaches only detect issues while the program is running and only on those
    code paths that the execution traverses. So, we need to ensure sufficient coverage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向程序的二进制代码中注入了额外的指令，根据清理器类型，性能惩罚约为1.5倍到4倍减慢。此外，总体内存开销为2倍到4倍，堆栈大小增加最多3倍。但请注意，减慢程度远低于使用其他仪器框架或动态分析工具（如**Valgrind**
    [https://valgrind.org](https://valgrind.org)）时遇到的减慢，后者比生产二进制文件慢高达50倍。另一方面，使用Valgrind的好处是不需要重新编译。两种方法都仅在程序运行时检测问题，并且仅在执行遍历的代码路径上检测。因此，我们需要确保足够的覆盖率。
- en: There are also static analysis tools and linters, useful for detecting issues
    during compilation and checking all the code that is being included in the program.
    For example, compilers, such as GCC and Clang, can perform extra checks and provide
    useful information by enabling the **–Werror** , **–Wall** , and **–** **pedantic**
    options.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有静态分析工具和代码检查器，它们在编译期间检测问题并检查程序中包含的所有代码，非常有用。例如，通过启用**–Werror**、**–Wall**和**–pedantic**选项，编译器如GCC和Clang可以执行额外的检查并提供有用的信息。
- en: There are also open source alternatives, such as **Cppcheck** or **Flawfinder**
    , or commercial solutions that are free for open source projects, such as **PVS-Studio**
    or **Coverity Scan** . Other solutions, such as **SonarQube** , **CodeSonar**
    , or **OCLint** , can be used in **continuous integration / continuous delivery**
    ( **CI/CD** ) pipelines for ongoing quality tracking.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有开源替代方案，如**Cppcheck**或**Flawfinder**，或免费提供给开源项目的商业解决方案，如**PVS-Studio**或**Coverity
    Scan**。其他解决方案，如**SonarQube**、**CodeSonar**或**OCLint**，可用于**持续集成/持续交付**（**CI/CD**）管道中的持续质量跟踪。
- en: In this section, we will focus on sanitizers, which can be enabled by passing
    some special options to the compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注可以通过向编译器传递一些特殊选项来启用的清理器。
- en: Compiler options
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器选项
- en: To enable sanitizers, we need to pass some compiler options when compiling the
    program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用清理器，我们需要在编译程序时传递一些编译器选项。
- en: 'The main option is **--fsanitize=sanitizer_name** , where **sanitizer_name**
    is one of the following options:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主要选项是**--fsanitize=sanitizer_name**，其中**sanitizer_name**是以下选项之一：
- en: '**address** : This is for **AddressSanitizer** ( **ASan** ), to detect memory
    errors such as buffer overflows and use-after-free bugs'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**：这是针对**AddressSanitizer**（**ASan**），用于检测内存错误，如缓冲区溢出和使用后释放错误'
- en: '**thread** : This is for **ThreadSanitizer** ( **TSan** ), to identify data
    races and other thread synchronization issues in multi-threaded programs by monitoring
    thread interactions'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程**：这是针对**ThreadSanitizer**（**TSan**），通过监控线程交互来识别多线程程序中的数据竞争和其他线程同步问题'
- en: '**leak** : This is for **LeakSanitizer** ( **LSan** ), to spot memory leaks
    by tracking memory allocations and ensuring that all allocated memory is properly
    freed'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泄露**：这是针对**LeakSanitizer**（**LSan**），通过跟踪内存分配并确保所有分配的内存都得到适当释放来发现内存泄露'
- en: '**memory** : This is for **MemorySanitizer** ( **MSan** ), to uncover the use
    of uninitialized memory'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：这是针对**MemorySanitizer**（**MSan**），用于揭示未初始化内存的使用'
- en: '**undefined** : This is for **UndefinedBehaviorSanitizer** ( **UBSan** ), to
    detect undefined behavior, such as integer overflows, invalid type casts, and
    other erroneous operations'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未定义**：这是针对**UndefinedBehaviorSanitizer**（**UBSan**），用于检测未定义行为，例如整数溢出、无效类型转换和其他错误操作'
- en: Clang also includes **dataflow** , **cfi** (control flow integrity), **safe_stack**
    , and **realtime** .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Clang还包括**dataflow**、**cfi**（控制流完整性）、**safe_stack**和**realtime**。
- en: GCC adds **kernel-address** , **hwaddress** , **kernel-hwaddress** , **pointer-compare**
    , **pointer-subtract** , and **shadow-call-stack** .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GCC增加了**kernel-address**、**hwaddress**、**kernel-hwaddress**、**pointer-compare**、**pointer-subtract**和**shadow-call-stack**。
- en: As this list and flag behavior can change over time, it’s recommended to check
    the compilers’ official documentation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此列表和标志行为可能会随时间而变化，建议检查编译器的官方文档。
- en: 'Additional flags might be needed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要额外的标志：
- en: '**-fno-omit-frame-pointer** : A **frame pointer** is a register used by compilers
    to track the current stack frame, containing, among other information, the base
    address of the current function. Omitting frame pointers might increase the performance
    of the program but at the cost of making debugging significantly harder; it makes
    it more difficult to locate local variables and reconstruct stack traces.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-fno-omit-frame-pointer**：帧指针是编译器用来跟踪当前堆栈帧的寄存器，其中包含其他信息，如当前函数的基址。省略帧指针可能会提高程序的性能，但代价是使调试变得非常困难；它使得定位局部变量和重建堆栈跟踪更加困难。'
- en: '**-g** : Include debug information and display filenames and line numbers in
    the warning messages. If the debugger GDB is used, the **–ggdb** option might
    be desirable as the compiler can produce more expressive symbols to be used when
    debugging. Also, a level can be specified by using **–g[level]** , with **[level]**
    being a value from **0** to **3** , adding more debug information at each level
    increase. The default level is **2** .'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-g**：包含调试信息，并在警告消息中显示文件名和行号。如果使用调试器GDB，则可能希望使用**–ggdb**选项，因为编译器可以生成更易于调试的符号。还可以通过使用**–g[level]**指定一个级别，其中**[level]**是一个从**0**到**3**的值，每次级别增加都会添加更多的调试信息。默认级别是**2**。'
- en: '**–fsanitize-recover** : These options cause the sanitizer to attempt to continue
    running the program as if no error was detected.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**–fsanitize-recover**：这些选项会导致清理器尝试继续运行程序，就像没有检测到错误一样。'
- en: '**–fno-sanitize-recover** : The sanitizer will detect only the first error,
    and the program will exit with a non-zero exit code.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**–fno-sanitize-recover**：清理器将仅检测到第一个错误，并且程序将以非零退出码退出。'
- en: To keep a reasonable performance, we might need to adjust the optimization level
    by specifying the **–O[num]** option. Different sanitizers work best up to a certain
    level of optimization. It’s best to start with **–O0** and, if the slowdown is
    significant, try to increase to **–O1** , **–O2** , and so on. Also, as different
    sanitizers and compilers recommend specific optimization levels, check their documentation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持合理的性能，我们可能需要通过指定**–O[num]**选项来调整优化级别。不同的清理器在一定的优化级别上表现最佳。最好从**–O0**开始，如果减速显著，尝试增加到**–O1**、**–O2**等。此外，由于不同的清理器和编译器推荐特定的优化级别，请检查它们的文档。
- en: 'When using Clang, to make stack traces easy to understand and let sanitizers
    convert addresses into source code locations, apart from using the flags mentioned
    earlier, we can also set the specific environment variable, **[X]SAN_SYMBOLIZER_PATH**
    , to the location of **llvm-symbolizer** (with **[X]** being **A** for AddressSatinizer,
    **L** for LSan, **M** for MSan, and so on). We can also include this location
    in the **PATH** environment variable. Here is an example of setting the **PATH**
    variables when using **AddressSatinizer** :'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Clang时，为了使堆栈跟踪易于理解，并让清理器将地址转换为源代码位置，除了使用前面提到的标志外，我们还可以将特定的环境变量**[X]SAN_SYMBOLIZER_PATH**设置为**llvm-symbolizer**的位置（其中**[X]**为**A**表示AddressSanitizer，**L**表示LSan，**M**表示MSan等）。我们还可以将此位置包含在**PATH**环境变量中。以下是在使用**AddressSanitizer**时设置**PATH**变量的示例：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that enabling **–Werror** with certain sanitizers can lead to false positives.
    Also, other compiler flags might be needed, but warning messages during execution
    will show that a problem is happening and will be evident that a flag is needed.
    Check the sanitizers’ and compilers’ documentation to find which flag to use in
    those cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，启用**–Werror**与某些清理器一起可能会导致误报。此外，可能还需要其他编译器标志，但执行期间的警告消息将显示正在发生问题，并且将明显表明需要某个标志。请检查清理器和编译器的文档，以找到在那些情况下应使用的标志。
- en: Avoiding sanitizing part of the code
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免对代码部分进行清理
- en: 'Sometimes, we may want to silence some sanitizer warning and skip sanitizing
    some functions due to the following reasons: it is a well-known issue, the function
    is correct, it’s a false positive, this function needs to speed up, or it is an
    issue in a third-party library. In those cases, we can use suppression files or
    exclude the code area by using some macro instructions. There is also a blacklist
    mechanism, but as it is deprecated in favor of suppression files; we will not
    comment on it here.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望静音某些清理器警告，并跳过某些函数的清理，原因如下：这是一个已知问题，该函数是正确的，这是一个误报，该函数需要加速，或者这是一个第三方库的问题。在这些情况下，我们可以使用抑制文件或通过使用某些宏指令排除代码区域。还有一个黑名单机制，但由于它已被抑制文件取代，我们在此不做评论。
- en: 'With suppression files, we just need to create a text file listing the areas
    of the code where we don’t want the sanitizer to run. Each line consists of a
    pattern following a specific format depending on the sanitizer, but typically,
    the structure is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抑制文件，我们只需要创建一个文本文件，列出我们不希望清理器运行的代码区域。每一行都包含一个模式，该模式根据清理器的不同而有所不同，但通常结构如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, **type** indicates the type of suppression, for example, the **leak**
    and **race** values, and **location_pattern** is a regular expression matching
    the function or library name to suppress. Here is an example of a suppression
    file for an ASan, explained in the next section:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**type** 表示抑制的类型，例如，**leak** 和 **race** 值，而 **location_pattern** 是匹配要抑制的函数或库名的正则表达式。下面是一个
    ASan 的抑制文件示例，将在下一节中解释：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s call this file **myasan.supp** . Then, compile and pass this suppression
    file to the sanitizer via **[X]SAN_OPTIONS** as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个文件为 **myasan.supp**。然后，编译并使用以下命令将抑制文件传递给清理器通过 **[X]SAN_OPTIONS**：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also use macros in source code to exclude specific functions to be sanitized
    by using **__attribute__((no_sanitize("<sanitizer_name>")))** as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在源代码中使用宏来排除特定的函数，使其不被清理器清理，如下所示使用 **__attribute__((no_sanitize("<sanitizer_name>")))**：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This technique provides a fine-grained compile-time control over what should
    be instrumented by the sanitizer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术提供了对清理器应该对什么进行插装的细粒度编译时控制。
- en: Let’s now explore the most common types of code sanitizers, starting with one
    of the most relevant to check address misusages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索最常见的代码清理器类型，从与检查地址误用最相关的一种开始。
- en: AddressSanitizer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AddressSanitizer
- en: The purpose of ASan is to detect memory-related errors happening due to buffer
    overflows (heap, stack, and global) during out-of-bounds accesses of arrays, using
    a block of memory after being released with free or delete operations, and other
    memory leaks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 的目的是检测由于数组越界访问、使用释放的内存块（堆、栈和全局）以及其他内存泄漏而发生的内存相关错误。
- en: Apart from setting **-fsanitize=address** and other flags recommended earlier,
    we can also use **–fsanitize-address-use-after-scope** to detect the memory used
    after moving out of scope or setting the **ASAN_OPTIONS=option detect_stack_use_after_return=1**
    environment variable to detect use after return.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置 **-fsanitize=address** 和之前推荐的其他标志外，我们还可以使用 **–fsanitize-address-use-after-scope**
    来检测移出作用域后使用的内存，或者设置环境变量 **ASAN_OPTIONS=option detect_stack_use_after_return=1**
    来检测返回后使用。
- en: '**ASAN_OPTIONS** can also be used to instruct the ASan to print the stack trace
    or set a log file as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASAN_OPTIONS** 也可以用来指示 ASan 打印堆栈跟踪或设置日志文件，如下所示：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Clang on Linux has full support for ASan, followed by GCC on Linux. By default,
    ASan is disabled as it adds extra runtime overhead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 上的 Clang 完全支持 ASan，其次是 Linux 上的 GCC。默认情况下，ASan 是禁用的，因为它会增加额外的运行时开销。
- en: Also, ASan processes all calls to **glibc** – the GNU C library providing the
    core libraries for GNU systems. However, this is not the case with other libraries,
    so it’s recommended to recompile such libraries with the **–fsanitize=address**
    option. As commented earlier, with Valgrind, recompilation is not required.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ASan 处理所有对 **glibc** 的调用——这是为 GNU 系统提供核心库的 GNU C 库。然而，其他库的情况并非如此，因此建议使用 **–fsanitize=address**
    选项重新编译此类库。如前所述，使用 Valgrind 不需要重新编译。
- en: ASan can be combined with UBSan, which we will see later, but It slows down
    the performance by around 50%.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 可以与 UBSan 结合使用，我们将在后面看到，但这会降低性能约 50%。
- en: 'If we want a more aggressive diagnostics sanitizing, we can use the following
    flag combination:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更激进的诊断清理，可以使用以下标志组合：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s see two examples of using ASan to detect common software issues, with
    memory being used after being freed and detecting buffer overflows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 ASan 检测常见软件问题的两个示例，包括释放内存后继续使用和检测缓冲区溢出。
- en: Memory usage after being freed
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 释放内存后的内存使用
- en: 'One common issue in software is using memory after being freed. In this example,
    memory allocated in the heap is being used after being deleted:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中常见的一个问题是释放内存后继续使用。在这个例子中，堆中分配的内存被删除后仍在使用：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s suppose that the previous source code is in a file called **test.cpp**
    . To enable ASan, we just compile the file using the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设之前的源代码在一个名为 **test.cpp** 的文件中。要启用 ASan，我们只需使用以下命令编译文件：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, executing the resulting output **test** program, we obtain the following
    output (note that the output is simplified, only showing relevant content and
    might differ from different compiler versions and execution context):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行生成的输出 **test** 程序，我们得到以下输出（注意，输出已简化，仅显示相关内容，可能因不同的编译器版本和执行环境而有所不同）：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output shows that the ASan was applied and detected a heap-use-after-free
    error. This error is happening in the **T0** thread (main thread). The output
    also points to the code where that memory region was allocated, and later freed,
    and its size (400 bytes region).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 ASan 已应用并检测到一个堆使用后释放错误。这个错误发生在 **T0** 线程（主线程）。输出还指向了分配该内存区域的代码，稍后释放，以及其大小（400
    字节区域）。
- en: These kinds of errors not only happen with heap memory but also with memory
    regions allocated in the stack or global area. ASan can be used to detect these
    kinds of issues, such as memory overflows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这类错误不仅发生在堆内存中，也发生在栈或全局区域分配的内存区域中。ASan 可以用来检测这类问题，例如内存溢出。
- en: Memory overflows
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存溢出
- en: Memory overflows, also known as buffer overflows or overruns, happen when some
    data is written in a memory address past the allocated memory of a buffer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内存溢出，也称为缓冲区溢出或越界，发生在将某些数据写入超出缓冲区分配内存的地址时。
- en: 'The following example shows a heap memory overflow:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个堆内存溢出：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After compiling and running the resulting program, this is the output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行生成的程序后，这是输出：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see from the output, now ASan reports a heap-buffer-overflow error
    in the main thread ( **T0** ) when accessing a memory address beyond a 400-byte
    region (the **arr** variable).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，现在 ASan 报告了主线程（**T0**）在访问超过 400 字节区域（**arr** 变量）的内存地址时的堆缓冲区溢出错误。
- en: A sanitizer that is integrated into ASan is LSan. Let’s learn now how to detect
    memory leaks using this sanitizer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 集成到 ASan 中的清理器是 LSan。现在让我们学习如何使用这个清理器来检测内存泄漏。
- en: LeakSanitizer
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LeakSanitizer
- en: LSan is used to detect memory leaks happening when memory has been allocated
    but not properly freed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: LSan 用于检测内存泄漏，当内存已分配但未正确释放时发生。
- en: LSan is integrated into ASan and enabled by default on Linux systems. It can
    be enabled on macOS by using **ASAN_OPTIONS=detect_leaks=1** . To disable it,
    just set **detect_leaks=0** .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: LSan 集成到 ASan 中，并在 Linux 系统上默认启用。在 macOS 上可以通过使用 **ASAN_OPTIONS=detect_leaks=1**
    来启用它。要禁用它，只需设置 **detect_leaks=0** 。
- en: If the **–fsanitize=leak** option is used, the program will link against a subset
    of the ASan supporting LSan, disabling compile-time instrumentation and reducing
    the ASan slowdown. Note that this mode is not as well tested as the default mode.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 **–fsanitize=leak** 选项，程序将链接到支持 LSan 的 ASan 的子集，禁用编译时仪器并减少 ASan 的减速。请注意，此模式不如默认模式经过充分测试。
- en: 'Let’s see an example of memory leak:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个内存泄漏的例子：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, 100 bytes are allocated (the **arr** variable) but never freed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，分配了 100 字节（**arr** 变量），但从未释放。
- en: 'To enable LSan, we just compile the file using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 LSan，我们只需使用以下命令编译文件：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the resulting test binary, we obtain the following result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生成的测试二进制文件，我们得到以下结果：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: LSan correctly reports that a memory region of 100 bytes was allocated by using
    the operator **new** but never deleted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: LSan 正确报告了一个 100 字节大小的内存区域是通过使用操作符 **new** 分配的，但从未被删除。
- en: 'As this book explores multithreading and asynchronous programming, let’s learn
    now about a sanitizer to detect data races and other thread issues: TSan.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书探讨了多线程和异步编程，现在让我们了解一个用于检测数据竞争和其他线程问题的清理器：TSan。
- en: ThreadSanitizer
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadSanitizer
- en: TSan is used to detect threading issues, especially data races and synchronization
    issues. It cannot be combined with ASan or LSan. TSan is the sanitizer most aligned
    with the content of this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: TSan 用于检测线程问题，特别是数据竞争和同步问题。它不能与 ASan 或 LSan 结合使用。TSan 是与本书内容最一致的清理器。
- en: 'This sanitizer is enabled by specifying the **–fsanitize=thread** compiler
    option and its behavior can be modified by using the **TSAN_OPTIONS** environment
    variable. For example, if we want to stop after the first error, just use the
    following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定 **–fsanitize=thread** 编译器选项启用此清理器，可以通过使用 **TSAN_OPTIONS** 环境变量来修改其行为。例如，如果我们想在第一次错误后停止，只需使用以下命令：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Also, for a reasonable performance, use the compiler’s **–** **O2** option.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了合理的性能，使用编译器的 **–** **O2** 选项。
- en: TSan only reports race conditions happening at runtime, thus it won’t alert
    on race conditions present in code paths not executed at runtime. Therefore, we
    need to design tests that provide good coverage and use a realistic workload.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: TSan只报告在运行时发生的竞争条件，因此它不会在未在运行时执行的代码路径中存在的竞争条件上发出警报。因此，我们需要设计提供良好覆盖率和使用真实工作负载的测试。
- en: 'Let’s see some examples of TSan detecting data races. In the next example,
    we’ll do this by using a global variable without protecting its access with a
    mutex:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看TSan检测数据竞争的一些示例。在下一个示例中，我们将通过使用一个全局变量而不使用互斥锁来保护其访问来实现这一点：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After compiling the program, use the following command to enable TSan:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序后，使用以下命令启用TSan：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running the resulting program generates the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生成的程序会生成以下输出：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From the output, it’s clear that there is a data race when accessing **globalVar**
    in the **increase()** and **decrease()** functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，在**increase()**和**decrease()**函数访问**globalVar**时存在数据竞争。
- en: 'If we decide to use GCC instead of Clang, the following error can be reported
    when running the resulting program:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用GCC而不是Clang，在运行生成的程序时可能会报告以下错误：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This memory mapping issue is caused by a security feature called **address space
    layout randomization** ( **ASLR** ), a memory-protection technique used by the
    OS to protect against buffer overflow attacks by randomizing the address space
    of processes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内存映射问题是由称为**地址空间布局随机化**（**ASLR**）的安全功能引起的，这是一种操作系统使用的内存保护技术，通过随机化进程的地址空间来防止缓冲区溢出攻击。
- en: 'One solution is to reduce ASLR by using the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用以下命令减少ASLR：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The value passed to **vm.mmap_rnd_bits** ( **30** in the preceding command)
    can be reduced further if the error is still happening. To check that the value
    is correctly set, just run the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误仍然发生，传递给**vm.mmap_rnd_bits**（在先前的命令中为**30**）的值可以进一步降低。为了检查该值是否正确设置，只需运行以下命令：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this change is not permanent. Therefore, when the machine reboots,
    its value will be set to the default one. To persist this change, add **m.mmap_rnd_bits=30**
    to **/etc/sysctl.conf** .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此更改不是永久的。因此，当机器重新启动时，其值将设置为默认值。要持久化此更改，请将**m.mmap_rnd_bits=30**添加到**/etc/sysctl.conf**。
- en: 'But that reduces the security of the system, so it might be preferable to temporarily
    disable ASLR for a particular program by using the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但这降低了系统的安全性，因此可能更倾向于使用以下命令临时禁用特定程序的ASLR：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the preceding command will show a similar output to what was shown earlier
    when compiling with Clang.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令将显示与使用Clang编译时显示的类似输出。
- en: 'Let’s move to another example where a **std::map** object is accessed without
    a mutex. Even if the map is being accessed for different key values, as writing
    to a **std::map** invalidates their iterators, that can cause data races:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到另一个示例，其中**std::map**对象在没有互斥锁的情况下被访问。即使映射被用于不同的键值，因为写入**std::map**会使其迭代器无效，这也可能导致数据竞争：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compiling and running the resulting binary generates a large output with three
    warnings. Here, we only show the most relevant lines of the first warning (other
    warnings are similar):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行生成的二进制文件会生成大量输出，包含三个警告。在这里，我们只显示第一个警告中最相关的行（其他警告类似）：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The TSan warnings are flagged when both the **t1** and **t2** threads are writing
    into the map, **m** .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当**t1**和**t2**线程都在向映射，**m**写入时，TSan警告会标记。
- en: 'In the next example, there is only one auxiliary thread accessing the map via
    a pointer, but this thread is competing against the main thread to access and
    use the map. The **t** thread accesses the map, **m** , to change the value for
    the **foo** key; meanwhile, the main thread prints its value to the console:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，只有一个辅助线程通过指针访问映射，但此线程与主线程竞争以访问和使用映射。**t**线程访问映射，**m**，以更改**foo**键的值；同时，主线程将其值打印到控制台：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Compiling and running this example generates a massive output with seven TSan
    warnings. Here, we only show the first warning. Feel free to check the complete
    report by compiling and running the example in the GitHub repository:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此示例会生成大量输出，包含七个TSan警告。在这里，我们只显示第一个警告。您可以自由地通过在GitHub存储库中编译和运行示例来检查完整的报告：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the output, TSan is warning about a data race when accessing a **std::map**
    object allocated in the heap. That object is the map **m** .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，TSan正在警告访问在堆中分配的**std::map**对象时存在数据竞争。该对象是映射**m**。
- en: However, TSan can not only detect data races due to a lack of mutexes but can
    also report when a variable must be atomic.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TSan 不仅可以通过缺少互斥锁来检测数据竞争，还可以报告何时变量必须是原子的。
- en: 'The next example shows that scenario. The **RefCountedObject** class defines
    objects that can keep a reference count of how many objects of that class have
    been created. Smart pointers follow this idea to delete the underlying allocated
    memory on destruction when the counter reaches the value **0** . In this example,
    we are only showing the **Ref()** and **Unref()** functions that increment and
    decrement the reference count variable, **ref_** . To avoid issues in a multithreading
    environment, **ref_** must be an atomic variable. As here, this is not the case,
    and the **t1** and **t2** threads are modifying **ref_** , a possible data race
    can happen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了这种情况。**RefCountedObject** 类定义了可以保持该类已创建对象数量的引用计数的对象。智能指针遵循这个想法，当计数器达到值
    **0** 时，在销毁时删除底层分配的内存。在这个例子中，我们只展示了 **Ref()** 和 **Unref()** 函数，它们增加和减少引用计数变量 **ref_**。为了避免多线程环境中的问题，**ref_**
    必须是一个原子变量。正如这里所示，这并不是这种情况，**t1** 和 **t2** 线程正在修改 **ref_**，可能发生数据竞争：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compiling and running this example shows the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此示例会产生以下输出：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: TSan output shows that there is a data race condition happening in the **Unref()**
    function when accessing a memory location previously modified by the **Ref()**
    function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: TSan 输出显示，当访问之前由 **Ref()** 函数修改的内存位置时，**Unref()** 函数中发生了数据竞争条件。
- en: 'Data races can also happen in objects being initialized from several threads
    without any synchronization mechanism. In the following example, an object of
    type **MyObj** is being created in the **init_object()** function, and the global
    static pointer, **obj** , is assigned its address. As this pointer is not protected
    by a mutex, there is a data race happening when the **t1** and **t2** threads
    try to create an object and update the **obj** pointer from the **func1()** and
    **func2()** functions respectively:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据竞争也可能发生在没有同步机制的情况下从多个线程初始化的对象中。在以下示例中，**MyObj** 类型的对象在 **init_object()** 函数中被创建，全局静态指针
    **obj** 被分配其地址。由于此指针没有由互斥锁保护，当 **t1** 和 **t2** 线程分别从 **func1()** 和 **func2()**
    函数尝试创建对象并更新 **obj** 指针时，会发生数据竞争：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is the output after compiling and running this example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译并运行此示例后的输出：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output shows what we described earlier, a data race happening due to access
    to the **obj** global variable from **func1()** and **func2()** .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了我们之前描述的情况，由于从 **func1()** 和 **func2()** 访问 **obj** 全局变量而导致的数据竞争。
- en: As the C++11 standard has officially deemed data races as undefined behavior,
    let’s see now how to use UBSan to detect undefined behavior issues in the program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C++11 标准已正式将数据竞争视为未定义行为，现在让我们看看如何使用 UBSan 来检测程序中的未定义行为问题。
- en: UndefinedBehaviorSanitizer
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UndefinedBehaviorSanitizer
- en: UBSan can detect undefined behavior in code, for example, when shifting bits
    by an excessive amount, integer overflows, or misuse of null pointers. It can
    be enabled by specifying the **–fsanitize=undefined** option. Its behavior can
    be modified at runtime by setting the **UBSAN_OPTIONS** variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: UBSan 可以检测代码中的未定义行为，例如，当通过过多的位移操作、整数溢出或误用空指针时。可以通过指定 **–fsanitize=undefined**
    选项来启用它。其行为可以通过设置 **UBSAN_OPTIONS** 变量在运行时进行修改。
- en: Many errors that can be detected by UBSan are also detected by the compiler
    during compilation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 UBSan 可以检测到的错误也可以在编译期间由编译器检测到。
- en: 'Let’s see a simple example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To compile the program and enable UBSan, use the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序并启用 UBSan，请使用以下命令：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the resulting program generates the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生成的程序会产生以下输出：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output is quite simple and self-explanatory; there is a signed integer overflow
    operation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常简单且易于理解；存在一个有符号整数溢出操作。
- en: 'Let’s now learn about another useful C++ sanitizer to detect uninitialized
    memory and other memory usage issues: MSan.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解另一个有用的 C++ 检查器，用于检测未初始化的内存和其他内存使用问题：MSan。
- en: MemorySanitizer
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MemorySanitizer
- en: MSan can detect uninitialized memory usage, for example, when using variables
    or pointers before they have been assigned a value or address. It can also track
    uninitialized bits in a bitfield.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MSan 可以检测未初始化的内存使用，例如，在使用变量或指针之前没有分配值或地址时。它还可以跟踪位域中的未初始化位。
- en: 'To enable MSan, use the following compiler flags:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 MSan，请使用以下编译器标志：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It can also track each uninitialized value to the memory allocation from where
    it was created by specifying the **-** **fsanitize-memory-track-origins** option.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以通过指定**-** **fsanitize-memory-track-origins**选项将每个未初始化的值追踪到其创建的内存分配。
- en: GCC has no support for MSan, so the **-fsanitize=memory** flag is not valid
    when using this compiler.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GCC不支持MSan，因此当使用此编译器时，**-fsanitize=memory**标志是无效的。
- en: 'In the following example, the **arr** integer array is created, but only its
    position **5** is initialized. The value at position **0** is used when printing
    the message to the console, but this value is still uninitialized:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，创建了**arr**整数数组，但只初始化了其位置**5**。在向控制台打印消息时使用位置**0**的值，但此值仍然是未初始化的：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To compile the program and enable MSan, use the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序并启用MSan，请使用以下命令：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running the resulting program generates the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生成的程序将生成以下输出：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, the output shows clearly that an uninitialized value is being used at
    line 6 when reading the value at position **0** in the **arr** array.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，输出清楚地显示，在读取**arr**数组中位置**0**的值时，在第6行使用了未初始化的值。
- en: Finally, let’s summarize other sanitizers in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在下一节总结其他检查器。
- en: Other sanitizers
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他检查器
- en: 'There are other sanitizers available that are useful when developing for certain
    systems, such as kernel or real-time development:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在为某些系统（如内核或实时开发）开发时，还有其他有用的检查器：
- en: '**Hardware-assisted AddressSanitizers (HWASan)** : A new variant of ASan that
    consumes much less memory by using the hardware ability to ignore the top byte
    of a pointer. It can be enabled by specifying the **–** **fsanitize=hwaddress**
    option.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件辅助地址检查器 (HWASan)**：ASan的一个新变体，通过使用硬件能力忽略指针的最高字节来消耗更少的内存。可以通过指定**–** **fsanitize=hwaddress**选项来启用。'
- en: '**RealTimeSanitizer (RTSan)** : Real-time testing tool to detect real-time
    violations when calling methods that are not safe in functions with deterministic
    runtime requirements.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时检查器 (RTSan)**：实时测试工具，用于检测在调用具有确定运行时要求的函数中不安全的函数时发生的实时违规。'
- en: '**FuzzerSanitizer** : A sanitizer that detects potential vulnerabilities by
    feeding large volumes of random data into the program, checking if the program
    crashes, and looking for memory corruption or other security vulnerabilities.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fuzzer检查器**：一种检查器，通过向程序输入大量随机数据来检测潜在漏洞，检查程序是否崩溃，并寻找内存损坏或其他安全漏洞。'
- en: '**Kernel-related sanitizers** : There are also sanitizers available to track
    issues by kernel developers. For the sake of curiosity, some of these are as follows:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核相关检查器**：还有其他检查器可用于通过内核开发者跟踪问题。出于好奇，以下是一些例子：'
- en: '**Kernel Address** **Sanitizer** ( **KASAN** )'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核地址** **检查器** ( **KASAN** )'
- en: '**Kernel Concurrency** **Sanitizer** ( **KCSAN** )'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核并发** **检查器** ( **KCSAN** )'
- en: '**Kernel** **Electric-Fence** ( **KFENCE** )'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核** **电栅栏** ( **KFENCE** )'
- en: '**Kernel Memory** **Sanitizer** ( **KMSAN** )'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核内存** **检查器** ( **KMSAN** )'
- en: '**Kernel Thread** **Sanitizer** ( **KTSAN** )'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核线程** **检查器** ( **KTSAN** )'
- en: Sanitizers can automatically find many issues in our code. Once we have found
    and debugged some bugs and can reproduce scenarios that lead to those specific
    bugs, it would be convenient to design some tests that cover those cases to avoid
    future changes in code that could lead to similar problems or incidents.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器可以自动在我们的代码中找到许多问题。一旦我们找到并调试了一些错误，并且可以重现导致这些特定错误的场景，设计一些涵盖这些情况的测试将非常方便，以避免未来代码中的更改可能导致类似问题或事件。
- en: Let’s learn how to test multithreaded and asynchronous code in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节学习如何测试多线程和异步代码。
- en: Testing asynchronous code
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: Finally, let’s explore some techniques to test asynchronous code. The examples
    shown in this section need **GoogleTest** and **GoogleTest Mock** ( **gMock**
    ) libraries to compile. If you are unfamiliar with these libraries, please check
    the official documentation on how to install and use them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们探索一些测试异步代码的技术。本节中显示的示例需要**GoogleTest**和**GoogleTest Mock** ( **gMock**
    )库来编译。如果您不熟悉这些库，请查阅官方文档了解如何安装和使用它们。
- en: As we know, **unit testing** is the practice of writing small and isolated tests
    that verify the functionality and behavior of a single unit of code. Unit testing
    helps to find and fix bugs, refactor and improve your code quality, document and
    communicate the underlying code design, and facilitate collaboration and integration.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，**单元测试**是一种编写小型且独立的测试的实践，用于验证单个代码单元的功能和行为。单元测试有助于发现和修复错误，重构和改进代码质量，记录和传达底层代码设计，并促进协作和集成。
- en: This section will not cover the best way to group tests into logical and descriptive
    suites, or when you should use assertions or expectations to verify the values
    of different variables and tested methods outcomes. The purpose of this section
    is to provide some guidelines on how to create unit tests to test asynchronous
    code. Therefore, some previous knowledge about unit testing or **test-driven development**
    ( **TDD** ) is desirable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不会涵盖将测试分组到逻辑和描述性套件的最佳方式，或者何时应该使用断言或期望来验证不同变量和测试方法结果的值。本节的目的在于提供一些关于如何创建单元测试以测试异步代码的指南。因此，对单元测试或**测试驱动开发**（**TDD**）有一些先前的知识是可取的。
- en: The main difficulty when dealing with asynchronous code is that it might execute
    in another thread, and usually without knowing when that will happen, or when
    it will complete.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步代码的主要困难在于它可能在另一个线程中执行，通常不知道何时会发生，或何时完成。
- en: The main approach to follow when testing asynchronous code is to try to separate
    the functionality from multithreading, meaning that we might want to test the
    asynchronous code in a synchronous way, trying to execute it in one specific thread,
    removing context switching, threads creation and destruction, and other activities
    that might affect the result and timings on the tests. Sometimes, timers are also
    used, waiting for a callback to be invoked before timeout.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步代码时，主要遵循的方法是将功能与多线程分离，这意味着我们可能希望以同步方式测试异步代码，尝试在一个特定的线程中执行它，移除上下文切换、线程创建和销毁以及其他可能影响测试结果和时序的活动。有时，也会使用计时器，在超时前等待回调被调用。
- en: Testing a simple asynchronous function
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个简单的异步函数
- en: 'Let’s start with a small example of testing an asynchronous operation. This
    example shows a **asyncFunc()** function that is tested by running it asynchronously
    by using **std::async** , as shown in [*Chapter 7*](B22219_07.xhtml#_idTextAnchor143)
    :'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试一个异步操作的小例子开始。此示例展示了**asyncFunc()**函数，它通过使用**std::async**异步运行来测试，如[第7章](B22219_07.xhtml#_idTextAnchor143)中所示：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**std::async** returns a future that is used to retrieve the computed value.
    In this case, **asyncFunc** just waits for **100ms** before returning the value
    **42** . If the asynchronous task runs properly, the test will pass as there is
    an expectation instruction checking that the returned value is in fact **42**
    .'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::async**返回一个future，用于检索计算值。在这种情况下，**asyncFunc**只是等待**100ms**然后返回值**42**。如果异步任务运行正常，测试将通过，因为有一个期望指令检查返回的值确实是**42**。'
- en: There is only one test defined, using the **TEST()** macro, where its first
    parameter is the test suite name (in this example, **AsyncTests** ) and the second
    parameter is the test name ( **TestHandleAsyncOperation** ).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 只定义了一个测试，使用**TEST()**宏，其中第一个参数是测试套件名称（在这个例子中，**AsyncTests**），第二个参数是测试名称（**TestHandleAsyncOperation**）。
- en: In the **main()** function, the GoogleTest library is initialized by calling
    **::testing::InitGoogleTest()** . This function parses the command line for the
    flags that GoogleTest recognizes. Then, **RUN_ALL_TESTS()** is called, which collects
    and runs all tests and returns **0** if all tests are successful or **1** otherwise.
    This function originally was a macro, which is why its name is in uppercase.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在**main()**函数中，通过调用**::testing::InitGoogleTest()**初始化GoogleTest库。此函数解析命令行以获取GoogleTest识别的标志。然后调用**RUN_ALL_TESTS()**，该函数收集并运行所有测试，如果所有测试都成功则返回**0**，否则返回**1**。这个函数最初是一个宏，这就是为什么它的名字是大写的。
- en: Limiting test durations by using timeouts
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用超时限制测试时长
- en: 'One issue that could happen with this approach is that the asynchronous task
    can fail to be scheduled for any reason, take longer than expected to complete,
    or just not get completed for any reason. To deal with this situation, a timer
    can be used, setting its timeout period to a reasonable value to give enough time
    for the test to complete successfully. Therefore, if the timer times out, the
    test will fail. The following example shows that approach by using a timed waiting
    on the future returned by **std::async** :'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能出现的一个问题是，异步任务可能由于任何原因而未能被调度，完成时间超过预期，或者由于任何原因未能完成。为了处理这种情况，可以使用计时器，将其超时时间设置为合理的值，以便给测试足够的时间成功完成。因此，如果计时器超时，测试将失败。以下示例通过在
    **std::async** 返回的 future 上使用定时等待来展示这种方法：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the **wait_for()** function of the future object **result** is called,
    waiting 200 ms for the asynchronous task to complete. As the task will be completed
    in 100 ms, the timeout will not expire. If for any reason **wait_for()** is called
    with a value lower than 100 ms, it would time out and the **FAIL()** macro will
    be called, making the test fail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用 future 对象 **result** 的 **wait_for()** 函数，等待 200 毫秒以完成异步任务。由于任务将在 100 毫秒内完成，超时不会过期。如果由于任何原因，**wait_for()**
    被调用时的时间值低于 100 毫秒，它将超时，并调用 **FAIL()** 宏，使测试失败。
- en: The test continues running and checks if the returned value is **42** as in
    the previous example, and then also checks if the time spent running the asynchronous
    task is less than the used timeout.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试继续运行并检查返回的值是否为 **42**，正如前一个示例中所示，并且还检查执行异步任务所花费的时间是否少于使用的超时时间。
- en: Testing callbacks
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试回调
- en: 'Testing callback is a relevant task, especially when implementing libraries
    and **application programming interfaces** ( **APIs** ). The following example
    shows how to test that a callback has been called and its result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试回调是一个相关任务，尤其是在实现库和 **应用程序编程接口** ( **API** ) 时。以下示例展示了如何测试回调已被调用及其结果：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The **TestCallback** test just defines a callback as a lambda function that
    accepts an argument. This lambda function captures by reference the **result**
    variable where the **value** argument is stored, and the **callback_called** Boolean
    variable that by default is **false** and set to **true** when the callback is
    called.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**TestCallback** 测试仅定义了一个作为 lambda 函数的回调，该 lambda 函数接受一个参数。这个 lambda 函数通过引用捕获存储
    **value** 参数的 **result** 变量，以及默认为 **false** 并在回调被调用时设置为 **true** 的 **callback_called**
    布尔变量。'
- en: Then, the test calls the **asyncFunc()** function that spawns a thread that
    waits for one second before calling the callback and passing the value **42**
    . The test waits for two seconds before checking if the callback has been called
    by using the **EXPECT_TRUE** macro and checking the value of **callback_called**
    , and if **result** has the expected value of **42** .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试调用 **asyncFunc()** 函数，该函数启动一个线程，该线程在调用回调并传递值 **42** 之前等待一秒钟。测试在等待两秒钟后使用
    **EXPECT_TRUE** 宏检查是否调用了回调，并检查 **callback_called** 的值，以及 **result** 是否具有预期的值 **42**。
- en: Testing event-driven software
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试事件驱动软件
- en: 'We saw in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) how to use **Boost.Asio**
    and its event queue to dispatch asynchronous tasks. In event-driven programming,
    typically, we also need to test callbacks, as in the previous example. We can
    set up the test to inject callbacks and validate the result after they are called.
    The following example shows how to test asynchronous tasks in a Boost.Asio program:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 9 章*](B22219_09.xhtml#_idTextAnchor184) 中看到了如何使用 **Boost.Asio** 和其事件队列来调度异步任务。在事件驱动编程中，通常还需要测试回调，如前一个示例所示。我们可以设置测试以注入回调并在它们被调用后验证结果。以下示例展示了如何在
    Boost.Asio 程序中测试异步任务：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The **BoostAsio** test starts by creating an I/O execution context object, **io_context**
    , and passing it to the **asyncFunc()** function together with a lambda function
    implementing a task or callback to run in the background. This callback simply
    sets the value of the **result** variable, captured by the lambda function, to
    the value passed to it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**BoostAsio** 测试首先创建一个 I/O 执行上下文对象 **io_context**，并将其传递给 **asyncFunc()** 函数，同时传递一个
    lambda 函数，该 lambda 函数实现一个在后台运行的任务或回调。这个回调简单地设置由 lambda 函数捕获的 **result** 变量的值，将其设置为传递给它的值。'
- en: The **asyncFunc()** function just uses **io_context** to post a task that consists
    of a lambda function that calls the callback with the value **42** after waiting
    for 100 ms.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**asyncFunc()** 函数仅使用 **io_context** 来发布一个任务，该任务由一个 lambda 函数组成，该函数在等待 100
    毫秒后调用回调并传递值 **42**。'
- en: The test then just waits for 150 ms for the background task to finish and checks
    that the result value is **42** to mark the test as passed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试只是等待 150 毫秒，直到后台任务完成，并检查结果值是否为 **42**，以标记测试通过。
- en: Mocking external resources
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟外部资源
- en: If the asynchronous code also depends on external resources, such as file access,
    network servers, timers, or other modules, we might need to mock them and avoid
    unwanted failures due to any resource issues translated into the tests. Mocking
    and stubbing are techniques used to replace or modify the behavior of a real object
    or function with a fake or simplified one, for testing purposes. This way, we
    can control the input and output of the asynchronous code and avoid side effects
    or interference from other factors.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异步代码还依赖于外部资源，例如文件访问、网络服务器、计时器或其他模块，我们可能需要模拟它们，以避免由于任何资源问题导致的测试失败。模拟和存根是用于在测试目的下用假或简化的对象或函数替换或修改真实对象或函数行为的技巧。这样，我们可以控制异步代码的输入和输出，并避免副作用或其他因素的干扰。
- en: For example, if the tested code depends on a server, the server can fail to
    connect or execute its task, making the test fail. In these cases, failures are
    due to resource issues, not due to the asynchronous code being tested, causing
    a false, and usually transient, failure. We can mock external resources by using
    our own mock classes that mimic their interfaces. Let’s see an example of how
    to use a mock class and use dependency injection to use that class for testing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果测试的代码依赖于服务器，服务器可能无法连接或执行其任务，导致测试失败。在这些情况下，失败是由于资源问题，而不是由于测试的异步代码，导致了一个错误，通常是一个短暂的错误。我们可以通过使用我们自己的模拟类来模拟外部资源，这些模拟类模仿它们的接口。让我们看看如何使用模拟类和使用依赖注入来测试该类的示例。
- en: 'In this example, there is an external resource, **AsyncTaskScheduler** , whose
    **runTask()** method is used to execute an asynchronous task. As we only want
    to test the asynchronous task and remove any undesired side effects that the asynchronous
    task scheduler could generate, we can use a mock class mimicking the **AsyncScheduler**
    interface. This class is **MockTaskScheduler** , which inherits from **AsyncTaskScheduler**
    and implements its **runTask()** base class method, where the task is run synchronously:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个外部资源 **AsyncTaskScheduler**，其 **runTask()** 方法用于执行异步任务。因为我们只想测试异步任务并消除异步任务调度器可能产生的任何不期望的副作用，我们可以使用模拟类模仿
    **AsyncScheduler** 接口。这个类是 **MockTaskScheduler**，它继承自 **AsyncTaskScheduler** 并实现了其
    **runTask()** 基类方法，其中任务是同步运行的：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The **TestDependencyInjection** test just creates a **MockTaskScheduler** object
    and a task in the form of a lambda function and uses the mock object to execute
    the task by running the **runTask()** function. Once the task runs, **result**
    will have the value **42** .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**TestDependencyInjection** 测试仅创建一个 **MockTaskScheduler** 对象和一个 lambda 函数形式的任务，并使用模拟对象通过运行
    **runTask()** 函数来执行任务。一旦任务运行，**result** 将具有值 **42**。'
- en: 'Instead of fully defining the mock class, we can also use the gMock library
    and mock only the needed methods. This example shows gMock in action:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以用 gMock 库完全定义模拟类，还可以只模拟所需的方法。以下示例展示了 gMock 的应用：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, **MockTaskScheduler** also inherits from **AsyncTaskScheduler** , where
    the interface is defined, but instead of overriding its methods, the **MOCK_METHOD**
    macro is used instead, where the return type, the mocked method name, and its
    parameters are passed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**MockTaskScheduler** 也继承自 **AsyncTaskScheduler**，其中定义了接口，但不是通过重写其方法，而是使用
    **MOCK_METHOD** 宏，其中传递了返回类型、模拟方法名称及其参数。
- en: Then, the **TestMockMethod** test uses the **EXPECT_CALL** macro to define an
    expected call to the **runTask()** mocked method in **MockTaskScheduler** , which
    will happen only once and invoke the lambda function task, which returns the value
    **42** .
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**TestMockMethod** 测试使用 **EXPECT_CALL** 宏来定义对 **MockTaskScheduler** 中 **runTask()**
    模拟方法的预期调用，该调用只会发生一次，并调用 lambda 函数任务，该任务返回值 **42**。
- en: That call just happens in the next instruction where **scheduler.runTask()**
    is called, storing the returned value in the result. The test finishes by checking
    if **result** is the expected value of **42** .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用仅在下一个指令中发生，其中调用 **scheduler.runTask()**，并将返回值存储在结果中。测试通过检查 **result** 是否是预期的
    **42** 值来完成。
- en: Testing exceptions and failures
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异常和失败
- en: Asynchronous tasks do not always succeed and generate a valid result. Sometimes
    something can go wrong (network failures, timeouts, exceptions, etc.), and returning
    an error or throwing an exception is the way to let the user know about this situation.
    We should simulate failures to ensure that the code handles these gracefully.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 异步任务并不总是成功并生成有效的结果。有时可能会出错（网络故障、超时、异常等），返回错误或抛出异常是通知用户这种情况的方式。我们应该模拟失败以确保代码能够优雅地处理这些情况。
- en: 'Testing errors or exceptions can be done in the usual way, by using a try-catch
    block and using assertions or expectations to check if an error is thrown and
    make the test succeed or fail. GoogleTest also provides the **EXPECT_ANY_THROW()**
    macro that simplifies checking if an exception has happened. Both approaches are
    shown in the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试错误或异常可以像通常那样进行，通过使用 try-catch 块和使用断言或期望来检查是否抛出了错误，并使测试成功或失败。GoogleTest 还提供了
    **EXPECT_ANY_THROW()** 宏，它简化了检查是否发生了异常。以下示例展示了这两种方法：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Both the **TestAsyncFailure1** and **TestAsyncFailure2** tests are very similar.
    Both execute asynchronously the **asyncFunc()** function, which now accepts a
    **should_fail** Boolean argument indicating whether the task should succeed and
    return the value **42** or fail and throw an exception. Both tests make the task
    fail, with the difference being that **TestAsyncFailure1** uses the **FAIL()**
    macro if no exception is thrown, making the test fail, or **SUCCEED()** if an
    exception is caught by the try-catch block, and **TestAsyncFailure2** uses the
    **EXPECT_ANY_THROW()** macro to check if an exception happens when trying to retrieve
    the result from the future result by calling its **get()** method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**TestAsyncFailure1** 和 **TestAsyncFailure2** 这两个测试非常相似。它们都异步执行了 **asyncFunc()**
    函数，该函数现在接受一个 **should_fail** 布尔参数，指示任务是否应该成功并返回值 **42**，或者失败并抛出异常。两个测试都使任务失败，区别在于
    **TestAsyncFailure1** 在没有抛出异常的情况下使用 **FAIL()** 宏使测试失败，或者在 try-catch 块捕获到异常时使用
    **SUCCEED()**，而 **TestAsyncFailure2** 使用 **EXPECT_ANY_THROW()** 宏来检查在尝试通过调用其 **get()**
    方法从 future result 获取结果时是否发生了异常。'
- en: Testing multiple threads
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试多个线程
- en: When testing asynchronous software involving multiple threads in C++, one common
    and effective technique is using condition variables to synchronize the threads.
    As we have seen in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) , condition
    variables allow threads to wait for certain conditions to be met before proceeding,
    making them essential for managing inter-thread communication and coordination.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中测试涉及多个线程的异步软件时，一个常见且有效的技术是使用条件变量来同步线程。正如我们在 [*第 4 章*](B22219_04.xhtml#_idTextAnchor074)
    中所看到的，条件变量允许线程在满足某些条件之前等待，这使得它们对于管理线程间的通信和协调至关重要。
- en: Next is an example where multiple threads perform some tasks while the main
    thread waits for all other threads to finish.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个示例，其中多个线程执行一些任务，而主线程等待所有其他线程完成。
- en: 'Let’s start by defining some necessary global variables, such as the total
    number of threads ( **num_threads** ), **counter** as an atomic variable that
    will increase each time the asynchronous task is invoked, and the condition variable,
    **cv** , and its associated mutex, **mtx** , which will help to unblock the main
    thread once all asynchronous tasks have been completed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一些必要的全局变量，例如线程总数（ **num_threads** ），**counter** 作为每次异步任务被调用时都会增加的原子变量，以及条件变量
    **cv** 和其关联的互斥锁 **mtx**，这将有助于在所有异步任务完成后解锁主线程：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The **asyncTask()** function will execute the asynchronous task (simply waiting
    for 100 ms in this example) before increasing the **counter** atomic variable
    and notifying via the **cv** condition variable to the main thread that its work
    is done:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**asyncTask()** 函数将在增加 **counter** 原子变量并通过 **cv** 条件变量通知主线程其工作已完成之前执行异步任务（在这个例子中简单等待
    100 毫秒）：'
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The **TestMultipleThreads** test will start by spawning a number of threads
    where each one will asynchronously run the **asyncTask()** task. Then, it will
    wait, using a condition variable that **counter** has the same value as the number
    of threads, meaning that all background tasks have finished their work. The condition
    variable sets a timeout of 150 ms using the **wait_for()** function to limit the
    time the test can run but gives some room for all background tasks to be completed
    successfully:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**TestMultipleThreads** 测试将首先启动多个线程，每个线程将异步运行 **asyncTask()** 任务。然后，它将等待，使用一个条件变量，其中
    **counter** 的值与线程数相同，这意味着所有后台任务都已完成工作。条件变量使用 **wait_for()** 函数设置150毫秒的超时时间，以限制测试可以运行的时间，但为所有后台任务成功完成留出一些空间：'
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The test finishes by checking that indeed **counter** has the same value as
    **num_threads** .
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过检查确实 **counter** 的值与 **num_threads** 相同来结束。
- en: 'Finally, the **main()** function is implemented:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实现 **main()** 函数：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As explained earlier, the program starts by initializing the GoogleTest library
    by calling **::testing::InitGoogleTest()** and then calling **RUN_ALL_TESTS()**
    to collect and run all tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，程序通过调用 **::testing::InitGoogleTest()** 来初始化 GoogleTest 库，然后调用 **RUN_ALL_TESTS()**
    来收集和运行所有测试。
- en: Testing coroutines
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试协程
- en: With C++20, coroutines provide a new way to write and manage asynchronous code.
    Coroutine-based code can be tested by using a similar approach to other asynchronous
    code, but with the subtle difference that coroutines can suspend and be resumed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++20 的推出，协程提供了一种编写和管理异步代码的新方法。基于协程的代码可以通过使用与其他异步代码类似的方法进行测试，但有一个细微的区别，即协程可以挂起和恢复。
- en: Let’s see an example with a simple coroutine.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的协程示例来看看。
- en: We have seen in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) that coroutines
    have some boilerplate code to define their promise type and awaitable methods.
    Let’s start by implementing the **Task** structure that will define the coroutine.
    Please revisit [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) to fully understand
    this code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第8章*](B22219_08.xhtml#_idTextAnchor164) 中看到，协程有一些样板代码来定义它们的承诺类型和可等待方法。让我们先实现定义协程的
    **Task** 结构。请重新阅读 [*第8章*](B22219_08.xhtml#_idTextAnchor164) 以全面理解这段代码。
- en: 'Let’s start by defining the **Task** structure:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 **Task** 结构：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Inside **Task** , we define **promise_type** , which describes how the coroutine
    is managed. This type provides certain predefined methods (hooks) that control
    how the values are returned, how the coroutine is suspended, and how resources
    are managed once the coroutine is completed:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Task** 中，我们定义 **promise_type**，它描述了协程是如何管理的。此类型提供了一些预定义的方法（钩子），用于控制值的返回方式、协程的挂起方式以及协程完成后资源的管理方式：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, the methods used for controlling the suspension and resumption of the
    coroutine are implemented:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现用于控制协程挂起和恢复的方法：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Having the **Task** structure in place, let’s define two coroutines, one that
    computes a valid value and another that throws an exception:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了 **Task** 结构之后，让我们定义两个协程，一个用于计算有效值，另一个用于抛出异常：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As test functions inside the **TEST()** macro in GoogleTest cannot directly
    be coroutines because they don’t have a **promise_type** structure associated
    with them, we need to define some helper functions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GoogleTest 中的 **TEST()** 宏内的测试函数不能直接是协程，因为它们没有与它们关联的 **promise_type** 结构，我们需要定义一些辅助函数：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With that in place, we can now implement the tests:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们现在可以实施测试：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The **TestCoroutine** test defines a task using the **testCoroutineHelper()**
    helper function and passing the value **5** . When resuming the coroutine, it’s
    expected that it will return the value doubled, thus the value **10** , which
    is tested using **EXPECT_EQ()** .
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**TestCoroutine** 测试使用 **testCoroutineHelper()** 辅助函数定义了一个任务，并传递了值 **5**。在恢复协程时，预期它将返回双倍值，即
    **10**，这通过 **EXPECT_EQ()** 进行测试。'
- en: The **TestCoroutineWithException** test uses a similar approach, but now using
    the **testCoroutineWithExceptionHelper()** helper function, which will throw an
    exception when the coroutine is resumed. This is exactly what happens inside the
    **EXPECT_THROW()** assertion macro before checking that indeed the exception is
    of type **std::runtime_error** .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**TestCoroutineWithException** 测试使用类似的方法，但现在使用 **testCoroutineWithExceptionHelper()**
    辅助函数，当协程恢复时将抛出异常。这正是 **EXPECT_THROW()** 断言宏在检查确实异常是 **std::runtime_error** 类型之前所发生的事情。'
- en: Stress testing
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压力测试
- en: A race condition detector can be achieved by performing stress testing. For
    highly concurrent or multi-threaded asynchronous code, stress testing is crucial.
    We can simulate high load with multiple asynchronous tasks to check if the system
    behaves correctly under stress. Also, it’s important to use random delays, thread
    interleaving, or stress-testing tools, to reduce deterministic conditions, increasing
    the test coverage.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行压力测试可以实现竞态条件检测。对于高度并发或多线程异步代码，压力测试至关重要。我们可以通过多个异步任务来模拟高负载，以检查系统在压力下的行为是否正确。此外，使用随机延迟、线程交错或压力测试工具也很重要，以减少确定性条件，增加测试覆盖率。
- en: 'The next example shows the implementation of a stress test that spawns 100
    ( **total_nums** ) threads that execute the asynchronous task where the atomic
    variable counter is increased with each run after a random wait:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了实现一个压力测试，该测试启动100（**total_nums**）个线程执行异步任务，其中原子变量计数器在每个运行后随机等待增加：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The test succeeds if the counter has the same value as the total number of threads.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数器的值与线程总数相同，则测试成功。
- en: Parallelizing tests
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化测试
- en: To run test suites quicker we can parallelize the tests running in different
    threads, but tests must be independent, each running in a specific thread as a
    synchronous single-threaded solution. Also, they need to set up and tear down
    any necessary objects without keeping the state from previous test runs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快地运行测试套件，我们可以并行化在不同线程中运行的测试，但测试必须是独立的，每个测试都在特定的线程中作为一个同步的单线程解决方案运行。此外，它们还需要设置和拆除任何必要的对象，而不会保留之前测试运行的状态。
- en: 'When using CMake together with GoogleTest, we can run all detected tests in
    parallel by specifying the number of concurrent jobs we want to use with the following
    command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CMake与GoogleTest一起时，我们可以通过指定以下命令来并行运行所有检测到的测试：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: All the examples shown in this section are a small subset of what can be done
    for testing asynchronous code. We hope that these techniques provide enough insight
    and knowledge to develop further testing techniques that deal with specific scenarios
    you might face.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的所有示例只是测试异步代码可以进行的很小一部分。我们希望这些技术能提供足够的洞察力和知识，以开发进一步的处理特定场景的测试技术。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how to sanitize and test asynchronous programs.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何清理和测试异步程序。
- en: We started by learning how to sanitize code using sanitizers to help find multithreaded
    and asynchronous issues, such as race conditions, memory leaks, and use-after-scope
    errors, among many other issues.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了如何使用sanitizers来清理代码，以帮助找到多线程和异步问题，例如竞态条件、内存泄漏和作用域后使用错误等问题。
- en: Then, some testing techniques designed to deal with asynchronous software were
    described, using GoogleTest as the testing library.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，描述了一些旨在处理异步软件的测试技术，使用GoogleTest作为测试库。
- en: Using these tools and techniques helps detect and prevent undefined behavior,
    memory errors, and security vulnerabilities while ensuring that concurrent operations
    execute correctly, timing issues are handled properly, and code performs as expected
    under various conditions. This improves the overall program’s reliability and
    stability.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具和技术有助于检测和预防未定义行为、内存错误和安全漏洞，同时确保并发操作正确执行，正确处理时序问题，并在各种条件下代码按预期执行。这提高了整个程序的整体可靠性和稳定性。
- en: In the next chapter, we will learn about performance and optimization techniques
    that can be used to improve asynchronous programs’ runtime and resource usage.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习可以用来提高异步程序运行时间和资源使用的性能和优化技术。
- en: Further reading
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Sanitizers: [https://github.com/google/sanitizers](https://github.com/google/sanitizers)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sanitizers: [https://github.com/google/sanitizers](https://github.com/google/sanitizers)'
- en: 'Clang 20.0 ASan: [https://clang.llvm.org/docs/AddressSanitizer.html](https://clang.llvm.org/docs/AddressSanitizer.html)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 ASan: [https://clang.llvm.org/docs/AddressSanitizer.html](https://clang.llvm.org/docs/AddressSanitizer.html)'
- en: 'Clang 20.0 hardware-assisted ASan: [https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html](https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 硬件辅助 ASan: [https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html](https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html)'
- en: 'Clang 20.0 TSan: [https://clang.llvm.org/docs/ThreadSanitizer.html](https://clang.llvm.org/docs/ThreadSanitizer.html)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 TSan: [https://clang.llvm.org/docs/ThreadSanitizer.html](https://clang.llvm.org/docs/ThreadSanitizer.html)'
- en: 'Clang 20.0 MSan: [https://clang.llvm.org/docs/MemorySanitizer.html](https://clang.llvm.org/docs/MemorySanitizer.html)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 MSan: [https://clang.llvm.org/docs/MemorySanitizer.html](https://clang.llvm.org/docs/MemorySanitizer.html)'
- en: 'Clang 20.0 UBSan : [https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 UBSan: [https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)'
- en: 'Clang 20.0 DataFlowSanitizer: [https://clang.llvm.org/docs/DataFlowSanitizer.html](https://clang.llvm.org/docs/DataFlowSanitizer.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 DataFlowSanitizer: [https://clang.llvm.org/docs/DataFlowSanitizer.html](https://clang.llvm.org/docs/DataFlowSanitizer.html)'
- en: 'Clang 20.0 LSan: [https://clang.llvm.org/docs/LeakSanitizer.html](https://clang.llvm.org/docs/LeakSanitizer.html)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 LSan: [https://clang.llvm.org/docs/LeakSanitizer.html](https://clang.llvm.org/docs/LeakSanitizer.html)'
- en: 'Clang 20.0 RealtimeSanitizer: [https://clang.llvm.org/docs/RealtimeSanitizer.html](https://clang.llvm.org/docs/RealtimeSanitizer.html)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 RealtimeSanitizer: [https://clang.llvm.org/docs/RealtimeSanitizer.html](https://clang.llvm.org/docs/RealtimeSanitizer.html)'
- en: 'Clang 20.0 SanitizerCoverage: [https://clang.llvm.org/docs/SanitizerCoverage.html](https://clang.llvm.org/docs/SanitizerCoverage.html)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 SanitizerCoverage: [https://clang.llvm.org/docs/SanitizerCoverage.html](https://clang.llvm.org/docs/SanitizerCoverage.html)'
- en: 'Clang 20.0 SanitizerStats: [https://clang.llvm.org/docs/SanitizerStats.html](https://clang.llvm.org/docs/SanitizerStats.html)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 20.0 SanitizerStats: [https://clang.llvm.org/docs/SanitizerStats.html](https://clang.llvm.org/docs/SanitizerStats.html)'
- en: 'GCC: *Program Instrumentation* *Options* : [https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GCC: *程序仪器* *选项*: [https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
- en: 'Apple Developer: *Diagnosing memory, thread, and crash issues* *early* : [https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early](https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Apple开发者: *早期诊断内存、线程和崩溃问题*: [https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early](https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early)'
- en: 'GCC: *Options for Debugging Your* *Program* : [https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GCC: *调试你的* *程序* 的选项: [https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html)'
- en: 'OpenSSL: *Compiler Options Hardening Guide for C and* *C++* : [https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html](https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenSSL: *C和C++编译器选项加固指南*: [https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html](https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html)'
- en: 'Memory error checking in C and C++: Comparing Sanitizers and Valgrind: [https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind](https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C和C++中的内存错误检查：比较Sanitizers和Valgrind: [https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind](https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind)'
- en: 'The GNU C Library: [https://www.gnu.org/software/libc](https://www.gnu.org/software/libc)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GNU C库: [https://www.gnu.org/software/libc](https://www.gnu.org/software/libc)'
- en: 'Sanitizers: Common flags: [https://github.com/google/sanitizers/wiki/SanitizerCommonFlags](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sanitizers: 常见标志: [https://github.com/google/sanitizers/wiki/SanitizerCommonFlags](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags)'
- en: 'AddressSanitizer flags: [https://github.com/google/sanitizers/wiki/AddressSanitizerFlags](https://github.com/google/sanitizers/wiki/AddressSanitizerFlags)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AddressSanitizer标志: [https://github.com/google/sanitizers/wiki/AddressSanitizerFlags](https://github.com/google/sanitizers/wiki/AddressSanitizerFlags)'
- en: 'AddressSanitizer: A Fast Address Sanity Checker: [https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf](https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AddressSanitizer: 快速地址检查器: [https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf](https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf)'
- en: 'MemorySanitizer: Fast detector of uninitialized memory use in C++: [https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MemorySanitizer: C++中未初始化内存使用的快速检测器: [https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf)'
- en: 'Linux Kernel Sanitizers: [https://github.com/google/kernel-sanitizers](https://github.com/google/kernel-sanitizers)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux内核Sanitizers: [https://github.com/google/kernel-sanitizers](https://github.com/google/kernel-sanitizers)'
- en: 'TSan flags: [https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags](https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TSan标志: [https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags](https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags)'
- en: 'TSan: Popular data races: [https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces](https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TSan：常见的数据竞争: [https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces](https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces)'
- en: 'TSan report format: [https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat](https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TSan报告格式: [https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat](https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat)'
- en: 'TSan algorithm: [https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TSan算法: [https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm)'
- en: 'Address space layout randomization: [https://en.wikipedia.org/wiki/Address_space_layout_randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '地址空间布局随机化: [https://en.wikipedia.org/wiki/Address_space_layout_randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)'
- en: 'GoogleTest User’s Guide: [https://google.github.io/googletest](https://google.github.io/googletest)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GoogleTest用户指南: [https://google.github.io/googletest](https://google.github.io/googletest)'
