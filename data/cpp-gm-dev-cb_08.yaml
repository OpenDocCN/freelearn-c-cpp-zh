- en: Chapter 8. AI in Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 游戏开发中的人工智能
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下食谱：
- en: Adding artificial intelligence to a game
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向游戏添加人工智能
- en: Using heuristics in a game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中使用启发式
- en: Using a Binary Space Partition Tree
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二进制空间分区树
- en: Creating a decision making AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建决策制定AI
- en: Adding behavioral movements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加行为动作
- en: Using neural network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用神经网络
- en: Using genetic algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遗传算法
- en: Using other waypoint systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他航路点系统
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Artificial intelligence** (**AI**) can be defined in many ways. Artificial
    intelligence deals with finding similarities in different situations and differences
    in similar situations. AI can help to bring realism to a game. The user playing
    the game should feel that that entity that they are competing against is another
    human. Achieving this is extremely difficult and can consume a lot of processing
    cycles. In fact, there is a *turing test* held every year to determine whether
    an AI can fool other humans into believing that it is human. Now, if we use a
    lot of processing cycles for the AI, then executing the game at above 40 FPS can
    become extremely difficult. Hence we need to write efficient algorithms to achieve
    this.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）可以用许多方式来定义。人工智能处理在不同情况下找到相似之处和在相似情况下找到差异。AI可以帮助游戏变得更加真实。玩游戏的用户应该感觉到他们正在与另一个人竞争。实现这一点非常困难，可能会消耗大量的处理周期。事实上，每年都会举行*图灵测试*来确定AI是否能愚弄其他人相信它是人类。现在，如果我们为AI使用了大量的处理周期，那么以超过40
    FPS的速度执行游戏可能会变得非常困难。因此，我们需要编写高效的算法来实现这一点。'
- en: Adding artificial intelligence to a game
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向游戏添加人工智能
- en: Adding artificial intelligence to a game may be easy or extremely difficult,
    based on the level of realism or complexity we are trying to achieve. In this
    recipe, we will start with the basics of adding artificial intelligence.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 向游戏添加人工智能可能很容易，也可能非常困难，这取决于我们试图实现的现实水平或复杂性。在这个食谱中，我们将从添加人工智能的基础开始。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows and a version
    of Visual Studio. No other prerequisites are required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本食谱，您需要一台运行Windows的机器和一个版本的Visual Studio。不需要其他先决条件。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we will see how easy it is to add a basic artificial intelligence
    to the game. Add a source file called `Source.cpp`. Add the following code to
    it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到向游戏添加基本人工智能有多么容易。添加一个名为`Source.cpp`的源文件。将以下代码添加到其中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the previous example, we are using a string array to store a response. The
    idea of the software is to create an intelligent chat bot that can reply to questions
    asked by users and interact with them as if it were human. Hence the first task
    was to create an array of responses. The next thing to do is to ask the user for
    the question. In this example, we are searching for a basic keyword called `Hi`
    and, based on that, we are displaying the appropriate answer. Of course, this
    is a very basic implementation. Ideally we would have a list of keywords and responses
    when either of the keywords is triggered. We can even personalize this by asking
    the user for their name and then appending it to the answer every time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用字符串数组来存储响应。软件的想法是创建一个智能聊天机器人，可以回答用户提出的问题并与他们交互，就像它是人类一样。因此，第一项任务是创建一个响应数组。接下来要做的事情是询问用户问题。在这个例子中，我们正在搜索一个名为`Hi`的基本关键字，并根据此显示适当的答案。当然，这是一个非常基本的实现。理想情况下，我们会有一个关键字和响应的列表，当触发任何关键字时。我们甚至可以通过询问用户的名字来个性化这一点，然后每次都将其附加到答案中。
- en: The user may also ask to search for something. That is actually quite an easy
    thing to do. If we have detected the word that the user is longing to search for
    correctly, we just need to enter that into the search engine. Whatever result
    the page displays, we can report it back to the user. We can also use voice commands
    to enter the questions and give the responses. In this case, we would also need
    to implement some kind of **NLP** (**Natural Language** **Processing**). After
    the voice command is correctly identified, all the other processes are exactly
    the same.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以要求搜索某些内容。这实际上是一件非常容易的事情。如果我们正确检测到用户渴望搜索的单词，我们只需要将其输入到搜索引擎中。页面显示任何结果，我们都可以向用户报告。我们还可以使用语音命令输入问题并给出回应。在这种情况下，我们还需要实现某种**NLP**（**自然语言**
    **处理**）。在正确识别语音命令之后，所有其他流程都是完全相同的。
- en: Using heuristics in a game
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用启发式
- en: Adding heuristics in a game means to define rules. We need to define a set of
    rules for the AI agent so that it can move to its destination in the best possible
    way. For example, if we want to write a pathfinding algorithm, and define only
    its start and end positions, it may get there in many different ways. However,
    if we want the agent to reach the goal in a particular way, we need to establish
    a heuristic function for it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中添加启发式意味着定义规则。我们需要为AI代理定义一组规则，以便它以最佳方式移动到目的地。例如，如果我们想编写一个路径规划算法，并且只定义其起始和结束位置，它可能以许多不同的方式到达那里。然而，如果我们希望代理以特定方式达到目标，我们需要为其建立一个启发式函数。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a Windows machine and a working copy of Visual Studio. No other prerequisites
    are required.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一台Windows机器和一个运行Visual Studio的工作副本。不需要其他先决条件。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we will find out how easy it is to add a heuristic function
    to our game for pathfinding. Add a source file called `Source.cpp` and add the
    following code to it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将发现为我们的游戏添加启发式函数进行路径规划有多么容易。添加一个名为`Source.cpp`的源文件，并将以下代码添加到其中：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are many ways to define what a heuristic is. However, the simplest way
    to think about it is that it is a function that provides hints and directions
    for the AI to reach a specified goal. Let us say that our AI needs to go from
    point `A` to point `D`. Now, there are also points `B` and `C` somewhere on the
    map. How should the AI decide which path to take? This is what is provided by
    a heuristic function. In this example, we have used a heuristic in a pathfinding
    algorithm called `A*`. In special cases where the heuristic function is `0`, we
    get an algorithm called **Dijkstra's**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义启发式的方法有很多种。然而，最简单的思考方法是它是一个为AI提供提示和方向以达到指定目标的函数。假设我们的AI需要从点`A`到点`D`。现在，地图上还有点`B`和`C`。AI应该如何决定要走哪条路径？这就是启发式函数提供的内容。在这个例子中，我们在称为`A*`的路径查找算法中使用了启发式。在特殊情况下，启发式函数为`0`，我们得到一个称为**Dijkstra**的算法。
- en: Let us consider Dijkstra's first. It will be easier to understand `A*` later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑Dijkstra。稍后理解`A*`会更容易。
- en: '![How it works…](img/4929_08_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_08_01.jpg)'
- en: Let us consider we need to find the shortest path between **s** and **x**, traversing
    all nodes at least once. **s**, **t**, **y**, **x**, and **z** are the different
    nodes or the different subdestinations. The number from one node to another node
    is the cost of going from one node to the other. The algorithm states that we
    start from **s** with a **0** value and consider all other nodes to be infinite.
    The next thing to consider is the nodes adjacent to **s**. The nodes adjacent
    to **s** are **t** and **y**. The cost of reaching them is **5** and **10** respectively.
    We note that and then replace the infinity value at those nodes with **5** and
    **10**. Now let us consider the node **y**. The adjacent nodes are **t**, **x**,
    and **z**. The cost to reach **x** is **5** (its current node value) plus **9**
    (path cost value) equals *14*. Similarly, the cost to reach **z** is *5 + 2 =
    7*. So we replace the infinity values of **x** and **z** with **14** and **7**
    respectively. Now, the cost to reach **t** is *5 + 3 = 8*. However, it already
    has a node value. Its value is **10**. Since *8<10*, we will replace **t** with
    **8**. We keep on doing this for all the nodes. After that we will get the minimum
    cost to traverse all the nodes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们需要找到**s**和**x**之间的最短路径，至少遍历所有节点一次。**s**、**t**、**y**、**x**和**z**是不同的节点或不同的子目的地。从一个节点到另一个节点的数字是从一个节点到另一个节点的成本。该算法规定我们从**s**开始，值为**0**，并认为所有其他节点都是无限的。接下来要考虑的是与**s**相邻的节点。与**s**相邻的节点是**t**和**y**。到达它们的成本分别为**5**和**10**。我们注意到这一点，然后用**5**和**10**替换这些节点的无限值。现在让我们考虑节点**y**。相邻的节点是**t**、**x**和**z**。到达**x**的成本是**5**（它的当前节点值）加上**9**（路径成本值）等于*14*。同样，到达**z**的成本是*5
    + 2 = 7*。因此，我们分别用**14**和**7**替换**x**和**z**的无限值。现在，到达**t**的成本是*5 + 3 = 8*。然而，它已经有一个节点值。它的值是**10**。由于*8<10*，我们将**t**替换为**8**。我们继续对所有节点进行这样的操作。之后，我们将得到遍历所有节点的最小成本。
- en: '`A*` has two cost functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`A*`有两个成本函数：'
- en: '`g(x)`: This is the same as Dijkstra. It is the real cost to reach node **x**.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g(x)`: 这与Dijkstra相同。这是到达节点**x**的实际成本。'
- en: '`h(x)`: This is the approximate cost from node **x** to the goal node. It is
    a heuristic function. This heuristic function should never overestimate the cost.
    That means the real cost to reach goal node from node **x** should be greater
    than or equal to `h(x)`. It is called an admissible heuristic.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h(x)`: 这是从节点**x**到目标节点的近似成本。这是一个启发式函数。这个启发式函数不应该高估成本。这意味着从节点**x**到达目标节点的实际成本应该大于或等于`h(x)`。这被称为可接受的启发式。'
- en: The total cost of each node is calculated using *f(x) = g(x)+h(x)*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的总成本使用*f(x) = g(x)+h(x)*计算。
- en: In `A*`, we do not need to traverse all nodes, we just need to find the minimum
    path from start to the destination. An A* search only expands a node if it seems
    promising. It only focuses on reaching the goal node from the current node, not
    reaching every other node. It is optimal if the heuristic function is admissible.
    So writing the heuristic function is the key to checking whether to expand to
    a node or not. In the previous example, we used neighboring nodes and formed a
    priority list to decide that.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`A*`中，我们不需要遍历所有节点，我们只需要找到从起点到目的地的最短路径。A*搜索只会扩展一个节点，如果它看起来很有前途。它只关注从当前节点到达目标节点，而不是到达其他每个节点。如果启发式函数是可接受的，它是最优的。因此，编写启发式函数是检查是否扩展到节点的关键。在前面的例子中，我们使用相邻节点并形成一个优先列表来决定。
- en: Using a Binary Space Partition Tree
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二进制空间分区树
- en: Sometimes in games we work with a lot of geometry and huge 3D worlds. If our
    game camera was to render all of it all the time, then it would be extremely expensive
    and the game would not be able to run smoothly at higher frame rates. Hence we
    need to write intelligent algorithms so that the world is divided into more manageable
    chunks that can be traversed easily using a tree structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在游戏中，我们需要处理大量的几何图形和庞大的3D世界。如果我们的游戏摄像头一直渲染所有内容，那么成本将非常昂贵，游戏将无法以更高的帧率平稳运行。因此，我们需要编写智能算法，以便将世界划分为更易管理的块，可以使用树结构轻松遍历。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You need to have a working Windows machine and a working copy of Visual Studio.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要有一台运行良好的Windows机器和一个运行良好的Visual Studio副本。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add a source file called `Source.cpp`. Then add the following code to it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`Source.cpp`的源文件。然后将以下代码添加到其中：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A **Binary Space Partition** (**BSP**) tree, as the name implies, is a tree
    structure within which a geometrical space is partitioned. To be more precise,
    in BSP a plane is portioned into more hyperplanes. A plane is such that it has
    one dimension less than the ambient space from which it was created. So a 3D plane
    would have 2D hyperplanes and a 2D plane would have 1D lines. The idea behind
    this is once we have divided the planes into these hyperplanes in a logical manner,
    we can save the formation into a tree structure. Finally, we can traverse the
    tree structure in real time to provide better frame rates for the game overall.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制空间分区**（**BSP**）树，顾名思义，是一个树结构，其中一个几何空间被分割。更准确地说，在BSP中，一个平面被分割成更多的超平面。一个平面是这样的，它的维度比它所在的环境空间少一个。因此，一个3D平面将有2D超平面，而一个2D平面将有1D线。这背后的想法是一旦我们以逻辑方式将平面分割成这些超平面，我们可以将形成保存到树结构中。最后，我们可以实时遍历树结构，为整个游戏提供更好的帧率。'
- en: 'Let us consider an example in which the world looks like the following diagram.
    The camera must decide which areas it should render and which it should not. Hence,
    dividing them using a logical algorithm is necessary:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，世界看起来像下面的图表。摄像机必须决定应该渲染哪些区域，哪些不应该。因此，使用逻辑算法进行划分是必要的：
- en: '![How it works…](img/4929_08_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4929_08_02.jpg)'
- en: 'After we apply the algorithm, the tree structure should look like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用算法后，树结构应该如下所示：
- en: '![How it works…](img/4929_08_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4929_08_03.jpg)'
- en: Finally, we traverse this algorithm as with any other tree structure, using
    the concept of parent and child, and we get the desired sections that the camera
    should render.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们像处理任何其他树结构一样遍历这个算法，使用父节点和子节点的概念，得到摄像机应该渲染的所需部分。
- en: Creating a decision making AI
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建决策制定AI
- en: A **decision tree** is one of the most useful things to have in machine learning
    for AI. Given a large number of scenarios, based on certain parameters, decision
    making is essential. If we can write a system that can make these decisions well,
    then we can not only have a well-written algorithm but also have a lot of unpredictability
    in terms of gameplay. This will add a lot of variation to the game and will help
    the *replayability* of the overall game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**决策树**是机器学习中最有用的东西之一。在大量的情景中，基于某些参数，决策是必不可少的。如果我们能够编写一个能够做出这些决定的系统，那么我们不仅可以拥有一个写得很好的算法，而且在游戏玩法方面也会有很多的不可预测性。这将为游戏增加很多变化，并有助于整体游戏的可重复性。'
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine and Visual Studio. No other
    prerequisites are required.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要一台Windows机器和Visual Studio。不需要其他先决条件。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will find out how easy it is to add source control:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将发现添加源代码控制是多么容易：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As the name suggests, a decision tree is a subset of the tree data structure.
    Therefore, there is a root node and two child nodes. The root node denotes a condition
    and the child nodes will have the probable solutions. On the next level, those
    solution nodes will become part of the condition, which will lead to two more
    solution nodes. Hence, as the preceding example shows, the entire structure is
    modeled on the basis of a tree structure. We have a root node and then primary
    and secondary nodes. We need to traverse the tree to continuously find the answers
    to a situation based on the root nodes and the child nodes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，决策树是树数据结构的一个子集。因此，有一个根节点和两个子节点。根节点表示一个条件，子节点将有可能的解决方案。在下一个级别，这些解决方案节点将成为条件的一部分，这将导致另外两个解决方案节点。因此，正如前面的例子所示，整个结构是基于树结构建模的。我们有一个根节点，然后是主节点和次级节点。我们需要遍历树来不断地找到基于根节点和子节点的情况的答案。
- en: We have also written a `Query` function that will query the tree structure to
    find out what the most probable scenario is for the situation. That in turn will
    get the help of a decision function, which will add its own level of heuristics,
    combined with the result of the query, and generate the output for the solution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编写了一个`Query`函数，它将查询树结构，找出情况的最可能场景。这将得到一个决策函数的帮助，它将添加自己的启发式水平，结合查询的结果，生成解决方案的输出。
- en: Decision trees are extremely fast, because for every scenario we are checking
    only half the tree. So in effect we have reduced the search space by half. The
    tree structure also makes it robust, so that we can add and remove nodes on the
    fly as well. This gives us a lot of flexibility and the overall architecture of
    the game is improved.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树非常快，因为对于每种情况，我们只检查了树的一半。因此，实际上我们将搜索空间减少了一半。树结构也使其更加健壮，因此我们也可以随时添加和删除节点。这给了我们很大的灵活性，游戏的整体架构也得到了改进。
- en: Adding behavioral movements
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加行为动作
- en: When we talk about AI in games, after pathfinding the next most important thing
    to consider is movement. When does an AI decide that it has to walk, run, jump,
    or slide? The ability to make these decisions quickly and correctly will make
    the AI really competitive in games and extremely difficult to beat. We can do
    all this with the help of behavioral movements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论游戏中的人工智能时，寻路之后需要考虑的下一个最重要的事情就是移动。AI何时决定走路、跑步、跳跃或滑行？能够快速而正确地做出这些决定将使AI在游戏中变得非常有竞争力，极其难以击败。我们可以通过行为动作来实现所有这些。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine and Visual Studio. No other
    prerequisites are required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要一台Windows机器和Visual Studio。不需要其他先决条件。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this example, you will find out how easy it is to create a decision tree.
    Add a source file called `Source.cpp` and add the following code to it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将发现创建决策树是多么容易。添加一个名为`Source.cpp`的源文件，并将以下代码添加到其中：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example, we have implemented a simple state machine. The state machine
    is created with the **state-machine** design pattern in mind. So the states in
    this case are walk and run. The objective is that if the AI is walking and then
    needs to switch to running, it can do so at runtime. Similarly, if it is running,
    it can switch to walking at runtime. However, if it is already walking, and a
    request comes to walk, it should notify itself that there is no need to change
    the state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了一个简单的状态机。状态机是根据**状态机**设计模式创建的。因此，在这种情况下，状态是行走和奔跑。目标是，如果AI正在行走，然后需要切换到奔跑，它可以在运行时这样做。同样，如果它正在奔跑，它可以在运行时切换到行走。但是，如果它已经在行走，而请求来了要求行走，它应该通知自己不需要改变状态。
- en: All these change of states are handled by a class called machine, hence the
    name state-machine pattern. The reason why this structure is preferred by many
    over the traditional state machine design is that all the states need not be defined
    in one class and then a switch case statement can be used to change states. Although
    this method is correct, every additional step that is added to the game would
    require changing and adding to the same class structure. This is a recipe for
    bugs and possible disasters in the future. Instead, we are going for a more object-oriented
    approach where every state is a class in itself.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些状态的变化都由一个名为machine的类处理，因此得名状态机模式。为什么这种结构被许多人优先于传统的状态机设计，是因为所有状态不需要在一个类中定义，然后使用switch
    case语句来改变状态。虽然这种方法是正确的，但是每增加一个步骤都需要改变和添加到相同的类结构中。这是未来可能出现错误和灾难的风险。相反，我们采用更面向对象的方法，其中每个状态都是一个独立的类。
- en: The `machine` class holds a pointer to the `StateTo` class and then pushes the
    request to the appropriate child class of the state. If we need to add the jump
    state, we do not need to change much in the code. We need to write a new `jump`
    class and add the corresponding functionalities. Because the machine has a pointer
    to the base class (state), it will correspondingly push the request for jump to
    the correct derived class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`machine`类持有指向`StateTo`类的指针，然后将请求推送到状态的适当子类。如果我们需要添加跳跃状态，我们不需要在代码中做太多改动。我们只需要编写一个新的`jump`类并添加相应的功能。因为机器持有指向基类（状态）的指针，它将相应地将跳跃请求推送到正确的派生类。'
- en: Using neural network
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用神经网络
- en: '**Artificial neural networks** (**ANNs**) are an advanced form of AI used in
    some games. They may not be directly used in-game; however, they may be used during
    the production phase to train the AI agents. Neural nets are mostly used as predictive
    algorithms. Based on certain parameters, and historical data, they calculate the
    most likely decision or attribute that the AI agent will distribute. ANNs are
    not restricted to games; they are used across multiple diverse domains to predict
    possible outcomes.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工神经网络**（**ANNs**）是一种高级的人工智能形式，用于一些游戏中。它们可能不会直接在游戏中使用；然而，在生产阶段可能会用于训练AI代理人。神经网络主要用作预测算法。基于某些参数和历史数据，它们计算AI代理人最可能的决策或属性。ANNs不仅限于游戏；它们被用于多个不同的领域来预测可能的结果。'
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您需要一台运行Windows和Visual Studio的计算机。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Take a look at the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: In this example snippet, we have created the backbone to write a neural network
    that can predict a letter which is drawn on the screen. Many devices and touch
    screen tablets have this ability to detect a letter that you draw on screen. Let
    us take this and think in terms of game design. If we want to create a game in
    which we draw shapes, and the corresponding weapon will be given to us, which
    we can then use in battle, we can use this as a template to train the agents to
    identify a shape before the game is released onto the market. Generally, games
    like these only detect basic shapes. These can be easily detected and do not require
    neural nets to train agents.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例片段中，我们创建了一个骨干来编写一个可以预测屏幕上绘制的字母的神经网络。许多设备和触摸屏平板电脑都具有检测您在屏幕上绘制的字母的能力。让我们以游戏设计的方式来思考这个问题。如果我们想创建一个游戏，在游戏中我们绘制形状，然后会给我们相应的武器，我们可以在战斗中使用，我们可以使用这个作为模板来训练代理人在游戏发布到市场之前识别形状。通常，这些游戏只能检测基本形状。这些可以很容易地被检测到，不需要神经网络来训练代理人。
- en: 'In games, ANNs will mostly be used to create good AI behavior. However, it
    is not wise to use ANNs while the game is being played, as they are expensive
    and take a long time to train agents. Let us look at the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，ANNs主要用于创建良好的AI行为。然而，在游戏进行时使用ANNs是不明智的，因为它们成本高，训练代理人需要很长时间。让我们看下面的例子：
- en: '| Class type | Speed | HP |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 速度 | HP |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Melee | Speed (4) | 25 (HP) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 近战 | 速度（4） | 25（HP） |'
- en: '| Archer | Speed (7) | 22 (HP) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 弓箭手 | 速度（7） | 22（HP） |'
- en: '| Magic | Speed (6.4) | 20 (HP) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 魔法 | 速度（6.4） | 20（HP） |'
- en: '| ? | Speed (6.6) | 21 (HP) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| ? | 速度（6.6） | 21（HP） |'
- en: Given the data, what is the most likely class of the unknown? The number of
    parameters (**Class type**, **Speed**, and **HP**) is only three, but in reality
    it will be over 10\. It will be difficult to predict the class by just looking
    at those numbers. That's where an ANN comes in. It can predict any of the missing
    column data based on other columns' data and previous historical data. This becomes
    a very handy tool for the designer to use to balance the game.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据，未知的最可能的类是什么？参数的数量（**类别**，**速度**和**HP**）只有三个，但实际上将超过10个。仅仅通过观察这些数字来预测类别将是困难的。这就是ANN的用武之地。它可以根据其他列的数据和以前的历史数据预测任何缺失的列数据。这对设计师来说是一个非常方便的工具，可以用来平衡游戏。
- en: A few concepts of the ANN which we have implemented is necessary to understand.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的ANN的一些概念是必要的。
- en: 'An ANN is typically defined by three types of parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ANN通常由三种类型的参数定义：
- en: The interconnection pattern between the different layers of neurons.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经元不同层之间的互连模式。
- en: The learning process for updating the weights of the interconnections.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新相互连接权重的学习过程。
- en: The activation function that converts a neuron's weighted input to its output
    activation.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将神经元加权输入转换为其输出激活的激活函数。
- en: 'Let''s take a look at the following diagram explaining the layers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面解释层的图表：
- en: '![How it works…](img/4929_08_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_08_04.jpg)'
- en: '**Input Layer** is the layer in which we supply all the column data that is
    known, both historical and new. The process first involves supplying data whose
    output we already know. This phase is known as the learning phase. There are two
    types of learning algorithms, supervised and non-supervised. The explanation for
    these is out of the scope of this book. After that, there is a training algorithm
    that is applied to minimize the errors in the desired output. Back-propagation
    is one such technique, in which the weights that calculate the neural network
    function are adjusted till we get close to the desired result. After the network
    is set and is giving correct results for already known outputs, we can then supply
    new data and find the results for the unknown column data.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入层**是我们提供所有已知的列数据的层，包括历史数据和新数据。该过程首先涉及提供我们已经知道输出的数据。这个阶段被称为学习阶段。有两种类型的学习算法，监督和非监督。这些的解释超出了本书的范围。之后，有一个训练算法，用于最小化期望输出中的错误。反向传播是一种这样的技术，通过调整计算神经网络函数的权重，直到我们接近期望的结果。在网络设置并为已知输出提供正确结果后，我们可以提供新数据并找到未知列数据的结果。'
- en: Using genetic algorithms
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用遗传算法
- en: A **genetic** **algorithm** (**GA**) is a method of **evolutionary** **algorithm**
    (**EA**). They are particularly useful when we want to write predictive algorithms
    in which only the strongest is selected and the rest are rejected. This is how
    it gets its name. So at every iteration it mutates, does a cross-over, and only
    the best is selected for the next iteration of population. The idea behind genetic
    algorithms is that after multiple iterations only the best possible candidates
    are left.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**遗传算法**（**GA**）是一种**进化算法**（**EA**）的方法。当我们想要编写预测算法时，它们特别有用，其中只选择最强的，其余的被拒绝。这就是它得名的原因。因此，在每次迭代中，它会发生突变，进行交叉，并且只选择最好的进入下一代种群。遗传算法背后的想法是经过多次迭代后，只有最佳的候选者留下。'
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need a machine running Windows with an
    installed version of Visual Studio.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，您需要一台安装了Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will find out how easy it is to write a genetic algorithm:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将发现编写遗传算法有多么容易：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GA may seem extremely difficult to understand or make sense of at first. However,
    GAs are extremely simple. Let us think of a situation in which we have a land
    that is filled with dragons with different attributes. The objective or goal of
    the dragon is to defeat a human player who has some attributes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，遗传算法可能看起来非常难以理解或毫无意义。然而，遗传算法非常简单。让我们想象一种情况，我们有一片充满了具有不同属性的龙的土地。龙的目标是击败具有某些属性的人类玩家。
- en: '**Dragon(AI)**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**龙（AI）**'
- en: '![How it works…](img/4929_08_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_08_06.jpg)'
- en: '**Human(Player)**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**人类（玩家）**'
- en: '![How it works…](img/4929_08_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_08_07.jpg)'
- en: 'So for the Dragon to be competitive against the Human, it must learn how to
    run, defend, and attack. Let us see how GA helps us to do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使龙对抗人类具有竞争力，它必须学会奔跑，防御和攻击。让我们看看遗传算法如何帮助我们做到这一点：
- en: Step 1 (Initial Population)
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1（初始种群）
- en: '**Dragon(AI):**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**龙（AI）：**'
- en: This is our initial population. Each has its own set of properties. We are just
    considering three dragons. In practice, there will be more than that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的初始种群。每个都有自己的属性集。我们只考虑三条龙。实际上，会有更多。
- en: '![Step 1 (Initial Population)](img/4929_08_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![步骤1（初始种群）](img/4929_08_08.jpg)'
- en: Step 2 (Fitness function)
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2（适应函数）
- en: The fitness function (%) determines how fit a particular dragon is from the
    population. 100% is perfect fitness.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度函数（%）确定种群中特定龙的适应程度。100%是完美适应度。
- en: '![Step 2 (Fitness function)](img/4929_08_09.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![步骤2（适应函数）](img/4929_08_09.jpg)'
- en: Step 3 Cross-over
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3 交叉
- en: 'Based on the fitness function and the attributes that are missing, there will
    be a cross-over or reproduction phase to create a new dragon with both properties:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于适应函数和缺失的属性，将进行交叉或繁殖阶段，以创建具有两种属性的新龙：
- en: '**Table 1**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1**'
- en: '| Fitness | Dragon | Attribute 1 | Attribute 2 | Attribute 3 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 适应度 | 龙 | 属性1 | 属性2 | 属性3 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 60% | Dragon 1 | Run | Defend | Attack |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 60% | 龙1 | 奔跑 | 防御 | 攻击 |'
- en: '| 75% | Dragon 2 | Run | Defend | Attack |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 75% | 龙2 | 奔跑 | 防御 | 攻击 |'
- en: '| 20% | Dragon 3 | Run | Defend | Attack |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 20% | 龙3 | 奔跑 | 防御 | 攻击 |'
- en: '**Table 2**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2**'
- en: '![Step 3 Cross-over](img/4929_08_010.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![步骤3 交叉](img/4929_08_010.jpg)'
- en: The dragon with the least fitness function will be removed from the population.
    (Survival of the fittest).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度函数最低的龙将从种群中移除。（适者生存）。
- en: '![Step 3 Cross-over](img/4929_08_011.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![步骤3 交叉](img/4929_08_011.jpg)'
- en: Step 4 Mutate
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤4 突变
- en: 'So we have now got a new dragon that can run as well as attack and has a fitness
    function of *67%*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了一条新的龙，它既可以奔跑又可以攻击，并且适应度函数为*67%*：
- en: '![Step 4 Mutate](img/4929_08_012.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![步骤4 突变](img/4929_08_012.jpg)'
- en: 'We must now repeat the process (new generation) with other dragons in the population
    until we are satisfied with the result. The ideal population will be when all
    dragons have the following capabilities:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须重复这个过程（新一代）与种群中的其他龙，直到我们对结果满意为止。理想的种群将是当所有龙都具有以下能力时：
- en: '![Step 4 Mutate](img/4929_08_013.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![步骤4 突变](img/4929_08_013.jpg)'
- en: However, this may not always be possible. We need to be satisfied it is closer
    to the goal. All the stages described here are implemented as functions, and could
    be expanded upon based on the requirements of the AI agent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是可能的。我们需要确保它更接近目标。这里描述的所有阶段都被实现为函数，并且可以根据AI代理的要求进行扩展。
- en: Now you could ask, why don't we create dragons with all the properties in the
    first place? That's where adaptive AI comes into play. If we define all the properties
    in the dragons before the user plays the game, it may be very easy to defeat the
    dragons as the game progresses. However, if the AI dragons can adapt based on
    how the player defeats them, it may get progressively more difficult to beat the
    AI. As the player defeats the AI, we need to record the parameters and add that
    parameter as a goal attribute for the dragon, which it can achieve after a few
    cross-overs and mutations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问，为什么我们不一开始就创建具有所有属性的龙呢？这就是自适应AI发挥作用的地方。如果我们在用户玩游戏之前就定义了龙的所有属性，随着游戏的进行，可能会很容易击败龙。然而，如果AI龙可以根据玩家如何击败它们来适应，那么击败AI可能会变得越来越困难。当玩家击败AI时，我们需要记录参数，并将该参数作为龙的目标属性添加，它可以在几次交叉和突变后实现。
- en: Using other waypoint systems
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他航点系统
- en: Waypoints are a way of writing pathfinding algorithms. They are extremely easy
    to write. However, if not thought out properly, they can be extremely buggy and
    the AI can look extremely stupid. Many older games often had this sort of bug,
    which resulted in a revolution in the implementation of waypoint systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 航点是编写路径规划算法的一种方式。它们非常容易编写。然而，如果没有正确考虑，它们可能会非常有bug，AI看起来可能非常愚蠢。许多旧游戏经常出现这种bug，这导致了航点系统实现的革命。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows with an
    installed version of Visual Studio. No other prerequisites are required.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要一台运行Windows的机器，并安装了Visual Studio的版本。不需要其他先决条件。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this recipe, we will find out how easy it is to create waypoint systems:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将发现创建航点系统有多么容易：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, we will just discuss a basic implementation of the waypoint
    system. As the name suggests, waypoints are just 2D/3D points in world space that
    we want the AI agent to follow. All the agent has to do is move from point **A**
    to point **B**. However, this has complications. For example, let us consider
    the following diagram:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将讨论航点系统的基本实现。顾名思义，航点只是我们希望AI代理跟随的世界空间中的2D/3D点。代理所要做的就是从点**A**移动到点**B**。然而，这有复杂性。例如，让我们考虑以下图表：
- en: '![How it works…](img/4929_08_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_08_05.jpg)'
- en: To get from **A** to **B** is easy. Now, to get from **B** to **C** it has to
    follow a pathfinding algorithm such as A* or Djikstra's algorithm. In that case,
    it will avoid the obstacle in the center and move towards **C**. Now let's say
    it has suddenly seen the user at point **A**, part way through the journey. How
    should it react? If we just provide waypoints, it will look at its dictionary
    of points that it is allowed to move to and which is closest to it. The answer
    will be **A**. However, if it starts going towards **A**, it will be blocked by
    the wall and it may get stuck in a loop, hitting the wall continuously. You may
    have seen this behavior a lot in older games. In this case, the AI must make a
    decision to go back to **B** and then to **A**. So we can't use a waypoint algorithm
    on its own. For better performance and efficiency, we need to write a decision-making
    algorithm and a pathfinding algorithm along with it. This is what is used in most
    modern games, along with techniques such as **NavMesh** and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从**A**到**B**很容易。现在，要从**B**到**C**，它必须遵循A*或Djikstra的算法。在这种情况下，它将避开中心的障碍物，向**C**移动。现在假设它突然在旅途中看到了用户在点**A**。它应该如何反应？如果我们只提供航点，它将查看允许移动到的点的字典，并找到最接近它的点。答案将是**A**。然而，如果它开始朝**A**走去，它将被墙挡住，可能会陷入循环，不断撞墙。你可能在旧游戏中经常看到这种行为。在这种情况下，AI必须做出决定，返回**B**，然后再到**A**。因此，我们不能单独使用航点算法。为了更好的性能和效率，我们需要编写一个决策算法和一个路径规划算法。这是大多数现代游戏中使用的技术，还有**NavMesh**等技术。
