["```cpp\nbool linear_search(int N, std::vector<int>& sequence)\n{\n\u00a0\u00a0\u00a0\u00a0for (auto i : sequence)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == N)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;      // Element found!\n\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0return false;\n}\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    #include <numeric>\n    ```", "```cpp\n    bool linear_search(int N, std::vector<int>& S)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto i : S)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == N)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Element found!\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    bool binary_search(int N, std::vector<int>& S)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto first = S.begin();\n    \u00a0\u00a0\u00a0\u00a0auto last = S.end();\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Get the middle element of current range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto range_length = std::distance(first, last);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto mid_element_index = first + std::floor(range_length / 2);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto mid_element = *(first + mid_element_index);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Compare the middle element of current range with N\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mid_element == N)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (mid_element > N)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::advance(last, -mid_element_index);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mid_element < N)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::advance(first, mid_element_index);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If only one element left in the current range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (range_length == 1)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void run_small_search_test()\n    {\n    \u00a0\u00a0\u00a0\u00a0auto N = 2;\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> S{ 1, 3, 2, 4, 5, 7, 9, 8, 6 };\n    \u00a0\u00a0\u00a0\u00a0std::sort(S.begin(), S.end());\n    \u00a0\u00a0\u00a0\u00a0if (linear_search(N, S))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Element found in set by linear search!\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Element not found.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0if (binary_search(N, S))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Element found in set by binary search!\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Element not found.\" << std::endl;\n    }\n    ```", "```cpp\n    void run_large_search_test(int size, int N)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> S;\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// distribution in range [1, size]\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> uniform_dist(1, size); \n    \u00a0\u00a0\u00a0\u00a0// Insert random elements\n    \u00a0\u00a0\u00a0\u00a0for (auto i=0;i<size;i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S.push_back(uniform_dist(rand));\n    \u00a0\u00a0\u00a0\u00a0std::sort(S.begin(), S.end());\n    \u00a0\u00a0\u00a0\u00a0// To measure the time taken, start the clock\n    \u00a0\u00a0\u00a0\u00a0std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();\n\n    \u00a0\u00a0\u00a0\u00a0bool search_result = binary_search(111, S);\n    \u00a0\u00a0\u00a0\u00a0// Stop the clock\n    \u00a0\u00a0\u00a0\u00a0std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Time taken by binary search = \" << \n    std::chrono::duration_cast<std::chrono::microseconds>\n    (end - begin).count() << std::endl;\n\n    \u00a0\u00a0\u00a0\u00a0if (search_result)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Element found in set!\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Element not found.\" << std::endl;\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0run_small_search_test();\n    \u00a0\u00a0\u00a0\u00a0run_large_search_test(100000, 36543);\n    \u00a0\u00a0\u00a0\u00a0run_large_search_test(1000000, 36543);\n    \u00a0\u00a0\u00a0\u00a0run_large_search_test(10000000, 36543);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\nbool linear_search(float N, std::vector<float>& S)\nbool binary_search(float N, std::vector<float>& S)\n```", "```cpp\n     class Student\n    {\n    \u00a0\u00a0\u00a0\u00a0std::pair<int, int> name;\n    \u00a0\u00a0\u00a0\u00a0bool vaccinated;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    #include <numeric>\n    ```", "```cpp\n    template <typename T>\n    std::vector<T> merge(std::vector<T>& arr1, std::vector<T>& arr2)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> merged;\n    \u00a0\u00a0\u00a0\u00a0auto iter1 = arr1.begin();\n    \u00a0\u00a0\u00a0\u00a0auto iter2 = arr2.begin();\n    \u00a0\u00a0\u00a0\u00a0while (iter1 != arr1.end() && iter2 != arr2.end())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (*iter1 < *iter2)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iter1++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter2);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iter2++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (iter1 != arr1.end())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; iter1 != arr1.end(); iter1++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter1);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; iter2 != arr2.end(); iter2++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter2);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return merged;\n    }\n    ```", "```cpp\n    template <typename T>\n    std::vector<T> merge_sort(std::vector<T> arr)\n    {\n    \u00a0\u00a0\u00a0\u00a0if (arr.size() > 1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto mid = size_t(arr.size() / 2);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto left_half = merge_sort<T>(std::vector<T>(arr.begin(), arr.begin() + mid));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto right_half = merge_sort<T>(std::vector<T>(arr.begin() + mid, arr.end()));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return merge<T>(left_half, right_half);\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0return arr;\n    }\n    ```", "```cpp\n    template <typename T>\n    void print_vector(std::vector<T> arr)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i : arr)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    ```", "```cpp\n    void run_merge_sort_test()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int>\u00a0\u00a0\u00a0\u00a0S1{ 45, 1, 3, 1, 2, 3, 45, 5, 1, 2, 44, 5, 7 };\n    \u00a0\u00a0\u00a0\u00a0std::vector<float>\u00a0\u00a0S2{ 45.6f, 1.0f, 3.8f, 1.01f, 2.2f, 3.9f, 45.3f, 5.5f, 1.0f, 2.0f, 44.0f, 5.0f, 7.0f };\n    \u00a0\u00a0\u00a0\u00a0std::vector<double> S3{ 45.6, 1.0, 3.8, 1.01, 2.2, 3.9, 45.3, 5.5, 1.0, 2.0,\u00a0\u00a044.0, 5.0, 7.0 };\n    \u00a0\u00a0\u00a0\u00a0std::vector<char>\u00a0\u00a0 C{ 'b','z','a','e','f','t','q','u','y' };\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Unsorted arrays:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<int>(S1);\n    \u00a0\u00a0\u00a0\u00a0print_vector<float>(S2);\n    \u00a0\u00a0\u00a0\u00a0print_vector<double>(S3);\n    \u00a0\u00a0\u00a0\u00a0print_vector<char>(C);\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto sorted_S1 = merge_sort<int>(S1);\n    \u00a0\u00a0\u00a0\u00a0auto sorted_S2 = merge_sort<float>(S2);\n    \u00a0\u00a0\u00a0\u00a0auto sorted_S3 = merge_sort<double>(S3);\n    \u00a0\u00a0\u00a0\u00a0auto sorted_C = merge_sort<char>(C);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Arrays sorted using merge sort:\" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<int>(sorted_S1);\n    \u00a0\u00a0\u00a0\u00a0print_vector<float>(sorted_S2);\n    \u00a0\u00a0\u00a0\u00a0print_vector<double>(sorted_S3);\n    \u00a0\u00a0\u00a0\u00a0print_vector<char>(sorted_C);\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0run_merge_sort_test();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    #include <numeric>\n    ```", "```cpp\n    template <typename T>\n    auto partition(typename std::vector<T>::iterator begin,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typename std::vector<T>::iterator last)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Create 3 iterators, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// one pointing to the pivot, one to the first element and \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// one to the last element of the vector.\n    \u00a0\u00a0\u00a0\u00a0auto pivot_val = *begin;\n    \u00a0\u00a0\u00a0\u00a0auto left_iter = begin+1;\n    \u00a0\u00a0\u00a0\u00a0auto right_iter = last;\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Starting from the first element of vector, find an element that is greater than pivot.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (*left_iter <= pivot_val && \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 std::distance(left_iter, right_iter) > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left_iter++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Starting from the end of vector moving to the beginning, find an element that is lesser than the pivot.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (*right_iter > pivot_val && \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 std::distance(left_iter, right_iter) > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right_iter--;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If left and right iterators meet, there are no elements left to swap. Else, swap the elements pointed to by the left and right iterators\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (left_iter == right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::iter_swap(left_iter, right_iter);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (pivot_val > *right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::iter_swap(begin, right_iter);\n\n    \u00a0\u00a0\u00a0\u00a0return right_iter;\n    }\n    ```", "```cpp\n    template <typename T>\n    void quick_sort(typename std::vector<T>::iterator begin, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typename std::vector<T>::iterator last)\n    {\n    \u00a0\u00a0\u00a0\u00a0// If there are more than 1 elements in the vector\n    \u00a0\u00a0\u00a0\u00a0if (std::distance(begin, last) >= 1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Apply the partition operation\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto partition_iter = partition<T>(begin, last);\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Recursively sort the vectors created by the partition operation\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quick_sort<T>(begin, partition_iter-1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quick_sort<T>(partition_iter, last);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    template <typename T>\n    void print_vector(std::vector<T> arr)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i : arr)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    ```", "```cpp\n    void run_quick_sort_test()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> S1{ 45, 1, 3, 1, 2, 3, 45, 5, 1, 2, 44, 5, 7 };\n    \u00a0\u00a0\u00a0\u00a0std::vector<float>\u00a0\u00a0S2{ 45.6f, 1.0f, 3.8f, 1.01f, 2.2f, 3.9f, 45.3f, 5.5f, 1.0f, 2.0f, 44.0f, 5.0f, 7.0f };\n    \u00a0\u00a0\u00a0\u00a0std::vector<double> S3{ 45.6, 1.0, 3.8, 1.01, 2.2, 3.9, 45.3, 5.5, 1.0, 2.0,\u00a0\u00a044.0, 5.0, 7.0 };\n    \u00a0\u00a0\u00a0\u00a0std::vector<char> C{ 'b','z','a','e','f','t','q','u','y'};\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Unsorted arrays:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<int>(S1);\n    \u00a0\u00a0\u00a0\u00a0print_vector<float>(S2);\n    \u00a0\u00a0\u00a0\u00a0print_vector<double>(S3);\n    \u00a0\u00a0\u00a0\u00a0print_vector<char>(C);\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0quick_sort<int>(S1.begin(), S1.end() - 1);\n    \u00a0\u00a0\u00a0\u00a0quick_sort<float>(S2.begin(), S2.end() - 1);\n    \u00a0\u00a0\u00a0\u00a0quick_sort<double>(S3.begin(), S3.end() - 1);\n    \u00a0\u00a0\u00a0\u00a0quick_sort<char>(C.begin(), C.end() - 1);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Arrays sorted using quick sort:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<int>(S1);\n    \u00a0\u00a0\u00a0\u00a0print_vector<float>(S2);\n    \u00a0\u00a0\u00a0\u00a0print_vector<double>(S3);\n    \u00a0\u00a0\u00a0\u00a0print_vector<char>(C);\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0run_quick_sort_test();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    #include <numeric>\n    ```", "```cpp\n    template<typename T>\n    auto find_median(typename std::vector<T>::iterator begin, typename std::vector<T>::iterator last)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Sort the array\n    \u00a0\u00a0\u00a0\u00a0quick_sort<T>(begin, last);\n\n    \u00a0\u00a0\u00a0\u00a0// Return the middle element, i.e. median\n    \u00a0\u00a0\u00a0\u00a0return begin + (std::distance(begin, last)/2); \n    }\n    ```", "```cpp\n    template <typename T>\n    auto partition_using_given_pivot(\n    typename std::vector<T>::iterator begin, \n    typename std::vector<T>::iterator end, \n    typename std::vector<T>::iterator pivot)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Since the pivot is already given,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Create two iterators pointing to the first and last element of the vector respectively\n    \u00a0\u00a0\u00a0\u00a0auto left_iter = begin;\n    \u00a0\u00a0\u00a0\u00a0auto right_iter = end;\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Starting from the first element of vector, find an element that is greater than pivot.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (*left_iter < *pivot && left_iter != right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left_iter++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Starting from the end of vector moving to the beginning, find an element that is lesser than the pivot.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (*right_iter >= *pivot && \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left_iter != right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right_iter--;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If left and right iterators meet, there are no elements left to swap. Else, swap the elements pointed to by the left and right iterators.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (left_iter == right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::iter_swap(left_iter, right_iter);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (*pivot > *right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::iter_swap(pivot, right_iter);\n    \u00a0\u00a0\u00a0\u00a0return right_iter;\n    }\n    ```", "```cpp\n    // Finds ith smallest element in vector V\n    template<typename T>\n    typename std::vector<T>::iterator linear_time_select(\n    typename std::vector<T>::iterator begin,\n    typename std::vector<T>::iterator last, size_t i)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto size = std::distance(begin, last);\n    \u00a0\u00a0\u00a0\u00a0if (size > 0 && i < size) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Get the number of V_i groups of 5 elements each\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto num_Vi = (size+4) / 5; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t j = 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// For each V_i, find the median and store in vector M\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<T> M;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; j < size/5; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto b = begin + (j * 5);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto l = begin + (j * 5) + 5;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0M.push_back(*find_median<T>(b, l));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (j * 5 < size)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto b = begin + (j * 5);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto l = begin + (j * 5) + (size % 5);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0M.push_back(*find_median<T>(b, l));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Find the middle element ('q' as discussed)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 auto median_of_medians = (M.size() == 1)? M.begin():\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0linear_time_select<T>(M.begin(), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0M.end()-1, M.size() / 2);\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Apply the partition operation and find correct position 'k' of pivot 'q'.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto partition_iter = partition_using_given_pivot<T>(begin, last, median_of_medians);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto k = std::distance(begin, partition_iter)+1;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == k)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return partition_iter;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (i < k)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return linear_time_select<T>(begin, partition_iter - 1, i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (i > k)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return linear_time_select<T>(partition_iter + 1, last, i-k);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return begin;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    template <typename T>\n    std::vector<T> merge(std::vector<T>& arr1, std::vector<T>& arr2)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> merged;\n    \u00a0\u00a0\u00a0\u00a0auto iter1 = arr1.begin();\n    \u00a0\u00a0\u00a0\u00a0auto iter2 = arr2.begin();\n    \u00a0\u00a0\u00a0\u00a0while (iter1 != arr1.end() && iter2 != arr2.end())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (*iter1 < *iter2)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iter1++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter2);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iter2++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (iter1 != arr1.end())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; iter1 != arr1.end(); iter1++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter1);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; iter2 != arr2.end(); iter2++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0merged.emplace_back(*iter2);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return merged;\n    }\n    template <typename T>\n    std::vector<T> merge_sort(std::vector<T> arr)\n    {\n    \u00a0\u00a0\u00a0\u00a0if (arr.size() > 1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto mid = size_t(arr.size() / 2);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto left_half = merge_sort(std::vector<T>(arr.begin(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr.begin() + mid));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto right_half = merge_sort(std::vector<T>(arr.begin() + mid,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr.end()));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return merge<T>(left_half, right_half);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return arr;\n    }\n    ```", "```cpp\n    void run_linear_select_test()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> S1{ 45, 1, 3, 1, 2, 3, 45, 5, 1, 2, 44, 5, 7 };\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Original vector:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<int> (S1);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Sorted vector:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_vector<int>(merge_sort<int>(S1));\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"3rd element: \" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 << *linear_time_select<int>(S1.begin(), S1.end() - 1, 3) << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"5th element: \" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 << *linear_time_select<int>(S1.begin(), S1.end() - 1, 5) << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"11th element: \" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 << *linear_time_select<int>(S1.begin(), S1.end() - 1, 11) << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0run_linear_select_test();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    #include <numeric>\n    ```", "```cpp\n    void transform_test(size_t size)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> S, Tr;\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> uniform_dist(1, size);\n    \u00a0\u00a0\u00a0\u00a0// Insert random elements\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 0; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S.push_back(uniform_dist(rand));\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Original array, S: \";\n    \u00a0\u00a0\u00a0\u00a0for (auto i : S)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::transform(S.begin(), S.end(), std::back_inserter(Tr), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[](int x) {return std::pow(x, 2.0); });\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Transformed array, Tr: \";\n    \u00a0\u00a0\u00a0\u00a0for (auto i : Tr)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0// For_each\n    \u00a0\u00a0\u00a0\u00a0std::for_each(S.begin(), S.end(), [](int &x) {x = std::pow(x, 2.0); });\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"After applying for_each to S: \";\n    \u00a0\u00a0\u00a0\u00a0for (auto i : S)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    ```", "```cpp\n    void reduce_test(size_t size)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> S;\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> uniform_dist(1, size);\n    \u00a0\u00a0\u00a0\u00a0// Insert random elements\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 0; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S.push_back(uniform_dist(rand));\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl << \"Reduce test== \" << std::endl << \"Original array, S: \";\n    \u00a0\u00a0\u00a0\u00a0for (auto i : S)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0// Accumulate\n    \u00a0\u00a0\u00a0\u00a0std::cout<<\"std::accumulate() = \" << std::accumulate(S.begin(), S.end(), 0, [](int acc, int x) {return acc+x; });\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    ```", "```cpp\n    int main() \n    {\n    \u00a0\u00a0\u00a0\u00a0transform_test(10);\n    \u00a0\u00a0\u00a0\u00a0reduce_test(10);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include \"mapreduce.hpp\"\n    namespace prime_calculator {\n    \u00a0\u00a0\u00a0\u00a0bool const is_prime(long const number)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (number > 2)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (number % 2 == 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0long const n = std::abs(number);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0long const sqrt_number = static_cast<long>(std::sqrt(\n    static_cast<double>(n)));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (long i = 3; i <= sqrt_number; i += 2)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (n % i == 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (number == 0 || number == 1)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0template<typename MapTask>\n    \u00a0\u00a0\u00a0\u00a0class number_source : mapreduce::detail::noncopyable\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0public:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0number_source(long first, long last, long step)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: sequence_(0), first_(first), last_(last), step_(step)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool const setup_key(typename MapTask::key_type& key)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0key = sequence_++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (key * step_ <= last_);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool const get_data(typename MapTask::key_type const& key, typename MapTask::value_type& value)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typename MapTask::value_type val;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val.first = first_ + (key * step_);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val.second = std::min(val.first + step_ - 1, last_);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::swap(val, value);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0private:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0long sequence_;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0long const step_;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0long const last_;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0long const first_;\n    \u00a0\u00a0\u00a0\u00a0};\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0struct map_task : public mapreduce::map_task<long, std::pair<long, long> >\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0template<typename Runtime>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void operator()(Runtime& runtime, key_type const& key, \n    value_type const& value) const\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (key_type loop = value.first; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0loop <= value.second; loop++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0runtime.emit_intermediate(is_prime(loop), loop);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0};\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0struct reduce_task : public mapreduce::reduce_task<bool, long>\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0template<typename Runtime, typename It>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void operator()(Runtime& runtime, key_type const& key, It it, It ite) const\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (key)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::for_each(it, ite, std::bind(&Runtime::emit, \n    &runtime, true, std::placeholders::_1));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0typedef\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mapreduce::job<\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prime_calculator::map_task,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prime_calculator::reduce_task,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mapreduce::null_combiner,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prime_calculator::number_source<prime_calculator::map_task>> job;\n    } // namespace prime_calculator\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0mapreduce::specification spec;\n    \u00a0\u00a0\u00a0\u00a0int prime_limit = 1000;\n    \u00a0\u00a0\u00a0\u00a0// Set number of threads to be used\n    \u00a0\u00a0\u00a0\u00a0spec.map_tasks = std::max(1U, std::thread::hardware_concurrency());\n    \u00a0\u00a0\u00a0\u00a0spec.reduce_tasks = std::max(1U, std::thread::hardware_concurrency());\n    \u00a0\u00a0\u00a0\u00a0// Set the source of numbers in given range\n    \u00a0\u00a0\u00a0\u00a0prime_calculator::job::datasource_type datasource(0, prime_limit, prime_limit / spec.reduce_tasks);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"\\nCalculating Prime Numbers in the range 0 .. \" << prime_limit << \" ...\" << std::endl;\n\n    std::cout << std::endl << \"Using \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< std::max(1U, std::thread::hardware_concurrency()) << \" CPU cores\";\n    \u00a0\u00a0\u00a0\u00a0// Run mapreduce\n    \u00a0\u00a0\u00a0\u00a0prime_calculator::job job(datasource, spec);\n    \u00a0\u00a0\u00a0\u00a0mapreduce::results result;\n    \u00a0\u00a0\u00a0\u00a0job.run<mapreduce::schedule_policy::cpu_parallel<prime_calculator::job> >(result);\n\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"\\nMapReduce finished in \" \n    << result.job_runtime.count() << \" with \" \n    << std::distance(job.begin_results(), job.end_results()) \n    << \" results\" << std::endl;\n\n    // Print results\n    \u00a0\u00a0\u00a0\u00a0for (auto it = job.begin_results(); it != job.end_results(); ++it)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << it->second << \" \";\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\nThe quick brown fox jumps over a rabbit\n```", "```cpp\nThe quick marathon runner won the race\n```", "```cpp\nThe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\nquick\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\na\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nbrown\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nfox\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\njumps\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nmarathon\u00a0\u00a0\u00a0\u00a01\nover\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nrabbit\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nrace\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nrunner\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nthe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\nwon\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\n```", "```cpp\n    struct map_task : public mapreduce::map_task<\n    \u00a0\u00a0\u00a0\u00a0std::string,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// MapKey (filename)\n    \u00a0\u00a0\u00a0\u00a0std::pair<char const*, std::uintmax_t>> // MapValue (memory mapped file\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// contents)\n    {\n    template<typename Runtime>\n    \u00a0\u00a0\u00a0\u00a0void operator()(Runtime& runtime, key_type const& key, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value_type& value) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Write your code here.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Use runtime.emit_intermediate() to emit <k,v> pairs\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template<typename KeyType>\n    struct reduce_task : public mapreduce::reduce_task<KeyType, unsigned>\n    {\n    \u00a0\u00a0\u00a0\u00a0using typename mapreduce::reduce_task<KeyType, unsigned>::key_type;\n    \u00a0\u00a0\u00a0\u00a0template<typename Runtime, typename It>\n    \u00a0\u00a0\u00a0\u00a0void operator()(Runtime& runtime, key_type const& key, It it, It const ite) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Write your code here.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Use runtime.emit() to emit the resulting <k,v> pairs\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```"]