- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Setting Up Your First Multiplayer Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的第一个多人游戏环境
- en: Setting up a full networked game in UE5 can be an intimidating task. It requires
    knowledge of networking, coding, and the engine itself, all of which can be overwhelming
    for even experienced developers. But with the right guidance and some elbow grease,
    it is possible to create an engaging multiplayer experience in no time (well,
    sort of...)!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中设置完整的联网游戏可能是一项令人畏惧的任务。这需要了解网络、编码以及引擎本身，所有这些都可能让经验丰富的开发者感到不知所措。但是，有了正确的指导和一些努力，您可以在很短的时间内（好吧，有点儿...）创建一个引人入胜的多人游戏体验！
- en: To prevent multiple issues with rethinking and modifications, the first step
    should be gaining a clear understanding of the project’s topic. This avoids confusion
    from the onset and enables a smoother workflow. After that, you will need to create
    an Unreal project and get things set up properly. This includes creating your
    **Gameplay Framework** (**GF**) classes so that you have access to all the necessary
    features needed for development, as well as configuring your project settings
    to use such classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在重新思考和修改过程中出现多个问题，第一步应该是清楚地理解项目的主题。这可以避免从一开始就产生混淆，并使工作流程更加顺畅。之后，您需要创建一个虚幻项目并正确设置一切。这包括创建您的**游戏框架**（**GF**）类，以便您能够访问开发所需的所有必要功能，以及配置项目设置以使用这些类。
- en: By the end of this chapter, you will have a solid understanding of programming
    in UE with C++ and will have laid the foundation for your multiplayer game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对使用C++在UE中进行编程有一个扎实的理解，并为您的多人游戏奠定了基础。
- en: 'Through the next sections, I will present you with the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将向您介绍以下主题：
- en: Introducing Unreal Shadows – Legacy of the Lichlord
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍虚幻阴影 - 骷髅领主的遗产
- en: Understanding C++ in Unreal Engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚幻引擎中理解C++
- en: Starting your Unreal multiplayer project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始您的虚幻多人游戏项目
- en: Adding the player classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加玩家类
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with this chapter, you should have set up Visual Studio (or
    JetBrains Rider) with all Unreal dependencies, as explained in [*Chapter 1*](B18203_01.xhtml#_idTextAnchor016),
    *Getting Started with Multiplayer* *Game Development*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，您应该已经按照[*第1章*](B18203_01.xhtml#_idTextAnchor016)中解释的，设置了包含所有虚幻依赖项的Visual
    Studio（或JetBrains Rider）。
- en: You’ll be using some starter content available in this book’s companion repository
    located at [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用本书配套仓库中提供的起始内容，该仓库位于[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)。
- en: 'Through this link, locate the section for this chapter and download the following
    `.zip` file: `Unreal Shadows – Starter Content`. If you somehow get lost during
    the progress of this chapter, in the repository, you will also find the up-to-date
    project files here: `Unreal Shadows –` `Chapter` `04` `End`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此链接，找到本章的相应部分并下载以下`.zip`文件：`Unreal Shadows – Starter Content`。如果在本章的进展过程中您迷路了，在仓库中您也会在这里找到最新的项目文件：`Unreal
    Shadows –` `Chapter` `04` `End`。
- en: Also, to fully understand this chapter, it is necessary to have some basic knowledge
    about C++ programming while I guide you through the key characteristics of the
    main peculiarities of the UE framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了完全理解本章内容，在您跟随我了解UE框架主要特性的关键特性时，您需要对C++编程有一些基本知识。
- en: Introducing Unreal Shadows – Legacy of the Lichlord
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍虚幻阴影 - 骷髅领主的遗产
- en: 'Consider the following passage from a (never published) fantasy book called
    *Unreal Shadows – Legacy of* *the Lichlord*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自（从未出版）奇幻小说《虚幻阴影 - 骷髅领主的遗产》的段落：
- en: '*“The air was thick with the stench of decay as the three thieves made their
    way into the Lichlord’s dungeon. Their mission was clear: infiltrate the fortress,
    find the king’s knight, and bring him back alive. Anything they could find lying
    around was theirs to* *take home.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*“空气中弥漫着腐朽的恶臭，三个盗贼走进了骷髅领主的地下城。他们的任务很明确：潜入堡垒，找到国王的骑士，并把他活着带回来。他们找到的任何东西都可以带回家。”*'
- en: '*As they crept through the shadowy corridors, they all knew that they were
    not alone: dozens of undead minions lurked around every corner, their greenish
    eyes* *staring blankly.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*当他们悄悄穿过阴暗的走廊时，他们都清楚自己并不孤单：成群的亡灵小兵潜伏在每一个角落，他们那绿色的眼睛空洞地 staring blankly.*'
- en: '*The guild had faced their fair share of dangerous foes before, but never had
    they encountered such a formidable army of the undead. Quietly, they slipped past
    the corridors, careful not to attract any attention. The last thing they needed
    was to draw the entire horde down* *upon them.”*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*公会之前已经遇到了不少危险的敌人，但从未遇到过如此强大的不死军队。他们静静地穿过走廊，小心翼翼地不引起任何注意。他们最不想做的就是吸引整个僵尸群向他们扑来。* '
- en: Congratulations – you have just been hired to create the video game adaptation
    of this best-selling book! And what’s more, it will be a multiplayer game!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你 – 你刚刚被雇佣来制作这部畅销书的视频游戏改编版！而且更棒的是，它将是一款多人游戏！
- en: Explaining the project brief
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释项目概述
- en: The game you’ll be developing will be a **third-person shooter** that will use
    the **hide and seek** gameplay twist, as introduced in [*Chapter 1*](B18203_01.xhtml#_idTextAnchor016),
    *Getting Started with Multiplayer Game Development*. This means that this will
    be a stealth game where players will survive only by moving quietly and carefully.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要开发的游戏将是一款**第三人称射击游戏**，它将使用**捉迷藏**游戏玩法变化，正如在[*第一章*](B18203_01.xhtml#_idTextAnchor016)中介绍的那样，*开始多人游戏开发*。这意味着这将是一款潜行游戏，玩家只能通过安静和谨慎地移动来生存。
- en: In this multiplayer game, each participant will play the role of a member of
    the Guild of Thieves, a secret organization of rogues and thieves, infiltrating
    the realm of an undead wizard. The main aim will be to rescue non-player characters
    that are kept (hopefully alive!) in the dungeon prisons. Additionally, players
    will collect treasures and equipment from past and less lucky adventurers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这款多人游戏中，每个参与者将扮演盗贼公会的一员，这是一个由游民和盗贼组成的秘密组织，潜入一个不死巫师的领域。主要目标将是营救被关押在地下监狱中的非玩家角色（希望它们还活着！）。此外，玩家还将收集来自过去和不太幸运的冒险者的宝藏和装备。
- en: 'Each character will have the ability to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色都将具备以下能力：
- en: Move around by walking or running
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过行走或跑步移动
- en: Handle a weapon
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵武器
- en: Get power-ups
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取增强道具
- en: Equip new weapons
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装备新武器
- en: Increase skills by means of experience points
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过经验点提高技能
- en: The primary focus of this game will be on stealthy movement, as the undead army
    will prove too strong for the character to engage in direct combat. As a result,
    movement (especially running) and wielding weapons will create noise, making the
    previously unaware enemies instantly alert to the player’s presence.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏的主要焦点将是潜行移动，因为不死军队将证明对角色来说直接交战过于强大。因此，移动（尤其是奔跑）和挥舞武器会产生噪音，使得之前未察觉的敌人立刻对玩家的存在警觉起来。
- en: Enemies will be represented by the Lichlord minions, a horde of undead skeletons
    that will wander around the level unaware of the player characters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人将由Lichlord的随从代表，一群无意识的骷髅僵尸，它们将在关卡中四处游荡，对玩家角色一无所知。
- en: Excessive noise from the characters or falling into traps will alert nearby
    enemies, making it nearly impossible to complete the game. Regrettably for the
    player characters, gaining experience points will only be made possible by defeating
    enemies, adding further engagement to the overall experience!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 角色发出的过多噪音或掉入陷阱会惊动附近的敌人，使得完成游戏变得几乎不可能。遗憾的是，玩家角色获得经验点只能通过击败敌人来实现，这进一步增加了整体体验的参与度！
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As this book is about multiplayer game programming rather than game design,
    balancing game mechanics will not be a primary focus of gameplay; instead, the
    focus will be on making things function effectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是关于多人游戏编程而不是游戏设计，因此游戏机制的平衡将不会是游戏玩法的主要焦点；相反，重点将在于使事物有效运作。
- en: Starting the project
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始项目
- en: We want the game to be visually appealing, but I’m guessing that most of you
    might not have a 3D modeling background (I don’t have one!). That’s why we will
    be using some amazing assets by Kay Lousberg ([https://kaylousberg.com/](https://kaylousberg.com/))
    that are freely available for personal and commercial purposes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望游戏在视觉上吸引人，但我猜你们大多数人可能没有3D建模的背景（我没有！）。这就是为什么我们将使用Kay Lousberg([https://kaylousberg.com/](https://kaylousberg.com/))提供的某些惊人的资源，这些资源可以免费用于个人和商业用途。
- en: '*Figure 4**.1* shows one of the packs we will be using:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.1* 展示了我们将要使用的一种包装：'
- en: '![Figure 4.1 – The KayKit Dungeon Pack](img/Figure_04.1_B18203.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – KayKit 地牢包](img/Figure_04.1_B18203.jpg)'
- en: Figure 4.1 – The KayKit Dungeon Pack
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – KayKit 地牢包
- en: You will start by creating a brand-new project starting from the **Blank** template
    available in UE5 and then you will add some assets from the aforementioned kits;
    however, to avoid the tedious task of importing them correctly, I have already
    packaged them for you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从UE5中可用的**空白**模板创建一个全新的项目开始，然后你将添加上述套件中的某些资产；然而，为了避免正确导入它们的繁琐任务，我已经为你打包好了。
- en: 'The project files, along with the code for each chapter, can be found on this
    book’s companion project page located here: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文件以及每一章的代码都可以在这个书的配套项目页面上找到，位于此处：[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)。
- en: Having established what you will be working on, it is now time to gain an understanding
    of how C++ is used within UE5\. The following section will provide a brief introduction
    to the primary features offered by the engine framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了你要做什么之后，现在是时候了解如何在UE5中使用C++了。以下部分将简要介绍引擎框架提供的核心功能。
- en: Understanding C++ in Unreal Engine
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解虚幻引擎中的C++
- en: If you share my love for game development and programming, you’ll likely find
    that writing C++ code in UE5 is quite fun and actually not too hard to get started
    with. Epic Games made a great job of adding features that make C++ easy to use
    for (almost) everyone.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样热爱游戏开发和编程，你可能会发现，在UE5中编写C++代码相当有趣，而且实际上并不太难入门。Epic Games在添加让C++变得容易使用的功能方面做得非常出色。
- en: Although it is possible to write standard C++ code in UE5, to achieve better
    performance with your games, it is advisable to use the engine’s most common features
    such as the built-in Reflection System and memory management.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在UE5中可以编写标准的C++代码，但要实现更好的游戏性能，建议使用引擎最常用的功能，如内置的反射系统和内存管理。
- en: Blueprints and C++
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝图和C++
- en: 'As you may already know, UE provides two methods for programming your game
    logic: Blueprint Visual Scripting and C++.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，UE提供了两种编程游戏逻辑的方法：蓝图可视化脚本和C++。
- en: '**Blueprints Visual Scripting** makes it easier for developers who don’t have
    extensive coding experience to create complex game mechanics without writing any
    code. On the other hand, **C++** is an **object-oriented programming** (**OOP**)
    language that requires more technical knowledge but offers much greater control
    over the game engine than Blueprints does.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝图可视化脚本**使得没有丰富编码经验的开发者能够创建复杂的游戏机制，而无需编写任何代码。另一方面，**C++**是一种**面向对象编程**（**OOP**）语言，它需要更多的技术知识，但比蓝图提供了对游戏引擎的更多控制。'
- en: It should be noted that C++ and Blueprints are strictly connected, as Blueprints
    provide a visual representation of the underlying C++ code and adhere to its principles,
    including inheritance and polymorphism. While Blueprints do not demand advanced
    coding skills, they do follow the same principles as the programming language
    in terms of data types, pointers, references, and other rules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，C++和蓝图是严格相连的，因为蓝图提供了底层C++代码的视觉表示，并遵循其原则，包括继承和多态。虽然蓝图不需要高级编码技能，但它们在数据类型、指针、引用和其他规则方面遵循与编程语言相同的原理。
- en: Both languages can be used together in UE5 projects and most of the time, what
    you can achieve with C++ can equally be done in Blueprints; however, C++ excels
    in customizing core features of UE or creating plugins that extend its functionality
    even further beyond what’s available out of the box.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种语言都可以在UE5项目中一起使用，大多数情况下，你可以用C++实现的事情同样可以用蓝图实现；然而，C++在定制UE的核心功能或创建扩展其功能（超出开箱即用的功能）的插件方面表现更出色。
- en: Although both Blueprint Visual Scripting and C++ offer powerful toolsets when
    working with UE projects, C++ provides lower-level access by way of object-oriented
    coding techniques – that’s why it is very important to have a strong knowledge
    of it once you start developing multiplayer games.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管蓝图可视化脚本和C++在处理UE项目时都提供了强大的工具集，但C++通过面向对象编程技术提供了更底层的访问权限——这就是为什么一旦开始开发多人游戏，对它的深入了解非常重要。
- en: Understanding C++ classes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C++类
- en: An Unreal Engine C++ class is, well, a regular C++ class!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个虚幻引擎C++类，嗯，就是一个普通的C++类！
- en: 'If you have already a good knowledge of OOP in C++, you will feel at home here:
    the process of creating a new UE C++ class begins by first defining what type
    of object it will represent, such as an Actor or a Component. Once the type has
    been defined, variables and methods are declared in the header file (`.h`) and
    code logic is implemented in the source file (`.cpp`).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对 C++ 中的 OOP 有很好的了解，你在这里会感到很自在：创建新的 UE C++ 类的过程首先是通过定义它将表示的对象类型开始的，例如 Actor
    或组件。一旦定义了类型，变量和方法就在头文件（`.h`）中声明，代码逻辑在源文件（`.cpp`）中实现。
- en: While the source file behaves like a regular C++ file of its kind, the header
    file will let you declare additional information for variables and functions that
    will be used by Blueprints inheriting from your class. Additionally, it will ease
    the pain of managing memory at runtime (I will get back to this in a while).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源文件的行为类似于其种类的常规 C++ 文件，但头文件将允许你为将用于继承自你的类的 Blueprints 的变量和函数声明附加信息。此外，它将减轻在运行时管理内存的痛苦（我稍后会回到这一点）。
- en: With the release of UE5, Epic Games introduced an amazing inspection tool called
    `BP_BasePickup` created during the last chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 UE5 的发布，Epic Games 引入了一个令人惊叹的检查工具，称为 `BP_BasePickup`，这是在上一个章节中创建的。
- en: '![Figure 4.2 – The C++ Header Preview tool in action](img/Figure_04.2_B18203.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – C++ 头文件预览工具的实际应用](img/Figure_04.2_B18203.jpg)'
- en: Figure 4.2 – The C++ Header Preview tool in action
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – C++ 头文件预览工具的实际应用
- en: 'In UE, there are three main class types that you’ll be deriving from during
    development:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE 中，有三个主要的类类型，你将在开发过程中从中派生：
- en: 'A **UObject** is the base class of UE and provides most of the main features
    available in UE, such as **garbage collection** (**GC**) (yes, UE provides it!),
    networking support, reflection of properties and methods, and so on. An **AActor**
    is a UObject that can be added to a game level either from the Editor or at runtime:
    in this second case, we say that the Actor has been *spawned*. In a multiplayer
    environment, an AActor is the base type that can be replicated during networking
    and it will provide information for any Component that will need synchronization.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UObject** 是 UE 的基类，提供了 UE 中大部分主要功能，例如**垃圾回收**（**GC**）（是的，UE 提供了它！），网络支持，属性和方法反射等。**AActor**
    是一种可以添加到游戏关卡中的 UObject，可以从编辑器或运行时添加：在后一种情况下，我们说 Actor 被已**生成**。在多人环境中，AActor 是可以在网络中复制的基类型，它将为需要同步的任何组件提供信息。'
- en: A **UActorComponent** is the basic class for defining Components that will be
    attached to an Actor or to another Component belonging to the Actor itself.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UActorComponent** 是定义将附加到 Actor 或 Actor 自身的另一个组件的组件的基本类。'
- en: 'Additionally, you’ll be using these entities:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将使用以下实体：
- en: A **UStruct** is used to create plain data structures and does not extend from
    any particular class
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UStruct** 用于创建平面数据结构，并且不扩展自任何特定类'
- en: A **UEnum** is used to represent enumerations of elements
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UEnum** 用于表示元素枚举'
- en: 'As a final note, throughout this book, you will notice that class names start
    with some letters that will not be visible once the class is used in the Editor.
    UE makes use of prefixes to point out the class type. The main prefixes used are
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，在这本书中，你会发现类名以一些字母开头，一旦在编辑器中使用这些类，这些字母将不可见。UE 使用前缀来指明类类型。主要使用的前缀如下：
- en: '`UObject` (for instance, components)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UObject`（例如，组件）'
- en: '`AActor`) and that can be added to a level'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （**AActor**）并且可以添加到关卡中
- en: '`FColor` structure'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FColor` 结构'
- en: '`TArray` or `TMap`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TArray` 或 `TMap`'
- en: '**I** is used for interfaces'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I** 用于接口'
- en: '**E** is used for enums'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E** 用于枚举'
- en: '`bool` or `uint8` (which may be used instead of `bool`)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool` 或 `uint8`（可以用来代替 `bool`）'
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please keep in mind that most of these prefixes are mandatory; if you try to
    name a class deriving from Actor without the `A` prefix, you will get an error.
    UE will hide the prefix once in the Editor. This rule applies only to C++ classes;
    Blueprints can be named without such prefixes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，大多数这些前缀是强制性的；如果你尝试命名一个没有 `A` 前缀的从 Actor 继承的类，你会得到一个错误。UE 会在编辑器中隐藏前缀。此规则仅适用于
    C++ 类；Blueprints 可以没有这样的前缀命名。
- en: Now that you are familiar with the main types available in UE, it’s time to
    explore the main features of a class header in order to understand its core functionalities.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 UE 中可用的主要类型，是时候探索类头文件的主要功能，以便理解其核心功能了。
- en: Anatomy of a UE C++ header
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UE C++ 头文件的解剖
- en: 'The C++ header of an Actor in UE5 will look like the following piece of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: UE5中Actor的C++头文件将类似于以下代码片段：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, there are a lot of things going on here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里有很多事情在进行中。
- en: First of all, you will notice a `#include "APickup.generated.h"` declaration.
    This mandatory line of code is autogenerated by the `include` file declared in
    your header or the compiler will throw an error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到一个`#include "APickup.generated.h"`声明。这一行代码是自动生成的，由你的头文件中声明的`include`文件或编译器抛出错误。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The UHT is a custom parsing and code generation tool that supports the UObject
    system in Unreal Engine. The UHT is used to parse C++ headers for Unreal and generate
    the boilerplate code required for the engine to work with the user-created classes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: UHT是一个自定义解析和代码生成工具，它支持Unreal Engine中的UObject系统。UHT用于解析Unreal的C++头文件，并生成引擎与用户创建的类一起工作所需的样板代码。
- en: The class constructor (in this case, `APickup()`) is used to set default values
    for properties as you may do with a regular C++ class; what’s more, you will be
    using it to create and add Components to the Actor itself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数（在这种情况下，`APickup()`）用于设置属性默认值，就像你在常规C++类中做的那样；更重要的是，你将使用它来创建和添加组件到Actor本身。
- en: Next, you will find some declarations, such as `UCLASS()`, `GENERATED_BODY()`,
    `UPROPERTY()`, and `UFUNCTION()`, that are used by UE and each has a precise function.
    If you are wondering about the meaning of the attributes called `BlueprintReadOnly`,
    `VisibleAnywhere`, and similar, don’t be afraid! I’ll be explaining their meaning
    in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107), *Managing Actors in a* *Multiplayer
    Environment*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会找到一些声明，例如`UCLASS()`、`GENERATED_BODY()`、`UPROPERTY()`和`UFUNCTION()`，这些是由UE使用的，并且每个都有精确的功能。如果你想知道名为`BlueprintReadOnly`、`VisibleAnywhere`等属性的含义，不要害怕！我将在[*第五章*](B18203_05.xhtml#_idTextAnchor107)中解释它们的含义，*在多人游戏环境中管理Actor*。
- en: In the next subsection, I’ll show you the exact meaning of each of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我将向你展示它们的精确含义。
- en: The Unreal Engine Reflection System
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unreal Engine反射系统
- en: The term **Reflection** specifies the capability that allows a program to inspect
    its own structure at runtime. This feature is immensely valuable and serves as
    one of the core technologies employed by UE, supporting a variety of systems such
    as detail panels in the Editor, serialization, garbage collection, network replication,
    and communication between Blueprint and C++.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**反射**指定了允许程序在运行时检查其自身结构的特性。这个特性非常有价值，并作为UE的核心技术之一，支持编辑器中的详细面板、序列化、垃圾回收、网络复制以及蓝图与C++之间的通信等众多系统。
- en: As there is no native support for Reflection in C++, Epic Games has developed
    its own system for gathering, examining, and altering data related to C++ classes,
    structs, and so on in UE.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++没有对反射的原生支持，Epic Games为其在UE中开发了自己的系统，用于收集、检查和修改与C++类、结构等相关数据。
- en: In order to use Reflection, you will need to annotate any type or property that
    you want to make visible to the system by marking them with annotations such as
    `UCLASS()`, `UFUNCTION()`, or `UPROPERTIES()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用反射，你需要使用注释（如`UCLASS()`、`UFUNCTION()`或`UPROPERTIES()`）来标记任何你希望使系统可见的类型或属性。
- en: To enable such annotations, you’ll be using the `#include "APickup.generated.h"`
    declaration I introduced in the last subsection (this declaration is autogenerated
    when you create a class with the Unreal Class Wizard, so you won’t have to worry
    about it).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这些注释，你将使用我在上一个子节中介绍的`#include "APickup.generated.h"`声明（当你使用Unreal Class
    Wizard创建类时，此声明会自动生成，因此你不必担心它）。
- en: 'The following list provides the fundamental markup elements accessible within
    the Reflection System:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了在反射系统中可访问的基本标记元素：
- en: '`UCLASS()`: Used to generate reflection data for a class that needs to derive
    from `UObject`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UCLASS()`: 用于为需要从`UObject`派生的类生成反射数据'
- en: '`USTRUCT()`: Used to generate reflection data for a struct'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USTRUCT()`: 用于为结构生成反射数据'
- en: '`GENERATED_BODY()`: This markup will be replaced with all the needed boilerplate
    code for the type'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GENERATED_BODY()`: 此标记将被替换为所需的所有类型样板代码'
- en: '`UPROPERTY()`: Used to tell the engine that the associated member variable
    will have some additional features, such as Blueprint accessibility or replication
    across the network (and this will mean a lot to you later on!)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPROPERTY()`: 用于通知引擎，关联的成员变量将具有一些附加功能，例如蓝图可访问性或跨网络复制（这对你来说在以后会非常重要！）'
- en: '`UFUNCTION()`: Allows, among other things, to call this function from an extending
    Blueprint Class or override the function from the Blueprint itself'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UFUNCTION()`: 允许（以及其他事情）从扩展的 Blueprint 类或从 Blueprint 本身覆盖此函数'
- en: The Reflection System is also used by the garbage collector so you don’t have
    to worry about memory management, as you will see in the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反射系统也被垃圾回收器使用，所以你不必担心内存管理，正如你将在下一小节中看到的。
- en: Memory management and garbage collection
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理和垃圾回收
- en: With thousands (sometimes tens of thousands!) of active objects in a game level,
    GC is an essential part of programming. It’s like the janitor of your running
    code – it helps keep everything tidy and organized by automatically collecting
    and disposing of objects that are no longer needed. It’s a great way to make sure
    your program runs smoothly without any memory leaks or performance issues, so
    you can focus on creating awesome features instead.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏级别中有成千上万个（有时是数万个！）活跃对象时，GC 是编程的一个基本部分。它就像你运行代码的清洁工——通过自动收集和处置不再需要的对象，帮助保持一切整洁有序。这是一个确保你的程序运行顺畅、没有内存泄漏或性能问题的好方法，这样你就可以专注于创建令人惊叹的功能。
- en: 'C++ does not natively implement GC, so UE implements its own system: you will
    just need to ensure that valid references to the objects are maintained. In order
    to enable GC for your classes, you need to assure that they inherit from `UObject`;
    then the system will keep a list of objects (also called **root**) that should
    not be garbage-collected. As long as an object is listed in the root, it will
    be preserved from deletion; once it is removed from this list, it will be deleted
    from memory the next time the garbage collector is called (i.e., at certain intervals).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 没有原生实现垃圾回收（GC），因此 UE 实现了自己的系统：你只需确保对象的合法引用得到维护。为了使你的类启用 GC，你需要确保它们继承自 `UObject`；然后系统会保留一个对象列表（也称为
    **root**），这些对象不应该被垃圾回收。只要对象在 root 列表中，它就不会被删除；一旦它从列表中移除，它将在下一次垃圾回收器被调用时（即，在特定间隔）从内存中删除。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Actors are only destroyed at the level’s shutdown unless you call the `Destroy()`
    method on them: in this case, they will be immediately removed from the game and
    deleted by the garbage collector when activated.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你调用它们的 `Destroy()` 方法，否则演员仅在级别关闭时被销毁：在这种情况下，它们将立即从游戏中移除并由垃圾回收器删除。
- en: In this section, I have introduced you to the main features that distinguish
    an Unreal Engine project from a regular C++ one. In the next section, you will
    begin to apply this knowledge by creating an empty project and extending the main
    Unreal GF classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我向你介绍了区分 Unreal Engine 项目和常规 C++ 项目的核心功能。在下一节中，你将通过创建空白项目并扩展主要的 Unreal
    GF 类来开始应用这些知识。
- en: Starting your Unreal multiplayer project
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始你的 Unreal 多人游戏项目
- en: In this section, you are finally going to start developing the multiplayer project
    (I know you are eager to begin it!). You’ll be creating an Unreal C++ blank project
    and adding the already packaged assets I will provide you. Then, you’ll be creating
    the GF classes needed to manage a multiplayer session. So, let’s get started.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你终于要开始开发多人游戏项目了（我知道你迫不及待地想要开始它！）！你将创建一个 Unreal C++ 空白项目，并添加我提供的已打包的资产。然后，你将创建管理多人会话所需的
    GF 类。那么，让我们开始吧。
- en: Creating your project file
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的项目文件
- en: 'Let’s start by creating a blank project:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个空白项目：
- en: Open the Epic Games Launcher and launch the Unreal Editor.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Epic Games Launcher 并启动 Unreal 编辑器。
- en: From the **Games** section, select the **Blank** template.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Games** 部分选择 **Blank** 模板。
- en: In **Project Defaults**, select **C++** as the project type.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project Defaults** 中，选择 **C++** 作为项目类型。
- en: Make sure the **Starter Content** field is unselected as you won’t be using
    it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保未选中 **Starter Content** 字段，因为你不会使用它。
- en: Give the project a meaningful name (for example, `UnrealShadows_LOTL`).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给项目一个有意义的名称（例如，`UnrealShadows_LOTL`）。
- en: Click the **Create** button.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Create** 按钮。
- en: Once the UE project has been created, get the `UnrealShadows-StarterContent.zip`
    file you downloaded at the beginning of this chapter and unzip it in your computer.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 UE 项目后，获取你在本章开头下载的 `UnrealShadows-StarterContent.zip` 文件，并将其解压到你的电脑上。
- en: Navigate to your project `Content` folder located at `[Your Project Path]` |
    `UnrealShadows_LOTL` | `Content`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的项目 `Content` 文件夹，位于 `[Your Project Path]` | `UnrealShadows_LOTL` | `Content`。
- en: Copy the content of the unzipped file (`_ExternalActors_`, `Blueprints`, `KayKit`,
    and `Maps` folders) into the `Content` folder to add all the needed assets to
    your project.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解压文件的文件内容（`_ExternalActors_`、`Blueprints`、`KayKit` 和 `Maps` 文件夹）复制到 `Content`
    文件夹中，以将所有需要的资产添加到你的项目中。
- en: Once you have copied the files, they should appear in the UE Editor and be available
    in your project. If the files do not pop up in the Content Browser, simply close
    the Editor and open it again to let UE update the `Content` folder.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦复制了文件，它们应该出现在 UE 编辑器中，并在你的项目中可用。如果文件没有在内容浏览器中弹出，只需关闭编辑器并重新打开，让 UE 更新 `Content`
    文件夹。
- en: 'You will notice that I have already added two levels (`Maps` folder: these
    levels will be used during the book and have been created for ease of development.
    You are free to create your own maps or add additional assets. which can be located
    at **Content** | **KayKit** | **Dungeon Elements**.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我已经添加了两个级别（`Maps` 文件夹：这些级别将在本书中使用，并且为了便于开发而创建。你可以自由创建自己的地图或添加额外的资产，这些资产可以位于
    **内容** | **KayKit** | **Dungeon Elements**）。
- en: 'Just to check that everything went as expected, open the `Level_01` map and
    you should see the level shown in *Figure 4**.3*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了确认一切如预期进行，打开 `Level_01` 地图，你应该能看到 *图 4**.3* 中显示的关卡：
- en: '![Figure 4.3 – The Level 01 map](img/Image96388.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – Level 01 地图](img/Image96388.jpg)'
- en: Figure 4.3 – The Level 01 map
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Level 01 地图
- en: It’s time to add some of the main classes used in any UE5 project, the ones
    that extend the GF elements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加任何 UE5 项目中使用的某些主要类了，这些类扩展了 GF 元素。
- en: Creating the project game instance
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目游戏实例
- en: As you probably already know, in UE5, a **GameInstance** is a class responsible
    for managing high-level data that needs to persist across level changes or game
    sessions. It is essentially a globally accessible UObject that can store any data
    you want to keep across the entire game, such as the player score, and other information
    that needs to be shared across different levels or game sessions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经知道的，在 UE5 中，**GameInstance** 是一个负责管理需要在关卡变化或游戏会话之间持久化的高级数据的类。它本质上是一个全局可访问的
    UObject，可以存储你想要在整个游戏中保持的数据，例如玩家得分，以及其他需要在不同关卡或游戏会话之间共享的信息。
- en: A class extending a GameInstance can be created as a Blueprint Class or in C++
    and is instantiated when the game is started and is only destroyed when the game
    is shut down.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个扩展 GameInstance 的类作为蓝图类或 C++，它在游戏启动时实例化，并且仅在游戏关闭时销毁。
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As with most C++ Unreal Engine projects, you will be working with a mix of C++
    classes and Blueprints. C++ classes are located in the **All | C++ classes | UnrealShadows_LOTL**
    folder and can only be added there (or in a subfolder). If you can’t find this
    folder, you have probably created a Blueprint-only project. Don’t despair, once
    the first C++ has been created (more on this in a minute), the Unreal Engine Editor
    will take care of it, transforming your Blueprint-only project into a C++ one
    and everything will be in place!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 C++ Unreal Engine 项目一样，你将使用 C++ 类和蓝图混合工作。C++ 类位于 **所有 | C++ 类 | UnrealShadows_LOTL**
    文件夹中，并且只能添加到那里（或子文件夹中）。如果你找不到这个文件夹，你可能创建了一个仅蓝图的项目。不要绝望，一旦创建了第一个 C++（稍后将有更多介绍），Unreal
    Engine 编辑器将负责将其转换为 C++ 项目，一切都将就绪！
- en: 'To create your project GameInstance, follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的项目 GameInstance，请按照以下步骤操作：
- en: On the main menu, select **Tools** | **New** **C++ Class...**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中，选择 **工具** | **新建** **C++ 类...**。
- en: The `game instance`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`游戏实例`。'
- en: 'Select the **GameInstance** class, as shown in *Figure 4**.4*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **GameInstance** 类，如图 *图 4**.4*：
- en: '![Figure 4.4 – The class creation wizard](img/Figure_04.4_B18203.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 类创建向导](img/Figure_04.4_B18203.jpg)'
- en: Figure 4.4 – The class creation wizard
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 类创建向导
- en: Click **Next** to access the **NAME YOUR NEW GAME** **INSTANCE** panel.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 进入 **命名新游戏** **实例** 面板。
- en: 'In the `US_GameInstance`. You can leave the other fields as they are so that
    the panel looks like *Figure 4**.5*:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `US_GameInstance`。你可以保留其他字段不变，这样面板看起来就像 *图 4**.5*：
- en: '![Figure 4.5 – Naming your class](img/Figure_04.5_B18203.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 命名你的类](img/Figure_04.5_B18203.jpg)'
- en: Figure 4.5 – Naming your class
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 命名你的类
- en: Click the **Create Class** button to generate your class files.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建类** 按钮以生成你的类文件。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'I’ll be using the `US_` prefix for most of the classes in the project extending
    the main GF elements: this is just a shorthand for UnrealShadows and will let
    us see that these files are from our project.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在项目中扩展主要 GF 元素的大部分类中使用 `US_` 前缀：这只是一个 UnrealShadows 的简称，将使我们能够看到这些文件来自我们的项目。
- en: 'Once the creation process has ended, you will get two new files: `US_GameInstance.h`
    and `US_GameInstance.cpp`. Congratulations – you have just created your first
    Unreal C++ class!'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建过程结束，您将获得两个新文件：`US_GameInstance.h` 和 `US_GameInstance.cpp`。恭喜您——您刚刚创建了您的第一个
    Unreal C++ 类！
- en: 'Opening the header file, you will see the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 打开头文件，您将看到以下代码：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The source file will be empty, apart from the header `#``include` declaration:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件将保持为空，除了头文件中的 `#``include` 声明：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this class extends the base `GameInstance` class (i.e., `UGameInstance`)
    and it currently does nothing apart from the macro declarations that were introduced
    in the previous section. However, as the project progresses, new features such
    as data collection or online services management will be added to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类扩展了基础 `GameInstance` 类（即 `UGameInstance`），目前除了在上一节中引入的宏声明之外，它没有任何功能。然而，随着项目的进展，将添加新的功能，例如数据收集或在线服务管理。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you named your project with a name other than mine (i.e., `UnrealShadows_LOTL`),
    you will get a different API export name in your class declaration; as you can
    see from the previous code, mine is `UNREALSHADOWS_LOTL_API`. Please keep this
    in mind throughout the book, as my code will reference this name and you may get
    a compilation error. To fix this, you should change the `UNREALSHADOWS_LOTL_API`
    text with `YOUR_PROJECT_NAME` (in all caps), with the `_API` suffix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将项目命名为不同于我的名称（例如，`UnrealShadows_LOTL`），您将在类声明中获得不同的 API 导出名称；正如您从前面的代码中看到的，我的名称是
    `UNREALSHADOWS_LOTL_API`。请记住这一点，因为我的代码将引用此名称，您可能会遇到编译错误。为了修复这个问题，您应该将 `UNREALSHADOWS_LOTL_API`
    文本更改为 `YOUR_PROJECT_NAME`（全部大写），并带有 `_API` 后缀。
- en: 'This game instance needs to be added to the project settings so it will be
    the one instantiated at runtime. To do so, follow these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏实例需要添加到项目设置中，以便在运行时被实例化。为此，请按照以下步骤操作：
- en: From the main menu, open **Project Settings**. Then click on the **Project**
    | **Maps &** **Modes** section.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单打开 **项目设置**。然后点击 **项目** | **地图与模式** 部分。
- en: 'In the **Game Instance Class** drop-down menu, select **UG_GameInstance**,
    as depicted in *Figure 4**.6*:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **游戏实例类** 下拉菜单中，选择 **UG_GameInstance**，如图 *4**.6* 所示：
- en: '![Figure 4.6 – The game instance assigned to the project](img/Figure_04.6_B18203.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 分配给项目的游戏实例](img/Figure_04.6_B18203.jpg)'
- en: Figure 4.6 – The game instance assigned to the project
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 分配给项目的游戏实例
- en: Now that we have a game instance assigned to the project, it’s time to create
    a Game Mode for the menu and lobby levels.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将游戏实例分配给了项目，是时候为菜单和大厅关卡创建一个游戏模式了。
- en: Creating the Game Mode and the Game State
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏模式和游戏状态
- en: In UE, a **Game Mode** is a class that controls the game rules, such as how
    a player joins the game, how to transition between levels, and other game-specific
    settings. The Game Mode is typically paired with a **Game State** class, which
    manages the current state of the game, such as the score, time remaining, and
    other important information. Together, the Game Mode and Game State classes allow
    developers to create complex and customized game mechanics in UE.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE 中，**游戏模式** 是一个控制游戏规则的类，例如玩家如何加入游戏，如何在不同关卡之间过渡，以及其他游戏特定设置。游戏模式通常与 **游戏状态**
    类配对，该类管理游戏的当前状态，例如得分、剩余时间和其他重要信息。游戏模式和游戏状态类一起允许开发者创建复杂和定制的游戏机制。
- en: If you check your `C++ Classes` folder, you will notice that there is already
    a Game Mode named `UnrealShadowsLOTLGameModeBase` (the name may differ slightly
    if you named your project differently from mine). This is an autogenerated class
    extending `AGameModeBase` from the GF.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查您的 `C++ Classes` 文件夹，您会注意到已经有一个名为 `UnrealShadowsLOTLGameModeBase` 的游戏模式（如果您的项目名称与我的不同，名称可能会有所不同）。这是一个从
    GF 自动生成的类，扩展了 `AGameModeBase`。
- en: 'You won’t be using this because you need to create a class from `AGameMode`;
    this class extends `AGameModeBase` by adding some features that will enhance the
    multiplayer system, such as game rules and win/lose conditions. To extend the
    Game Mode with your own settings, follow these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不会使用这个，因为你需要从`AGameMode`创建一个类；这个类通过添加一些增强多人游戏系统的功能来扩展`AGameModeBase`，例如游戏规则和胜负条件。要使用自己的设置扩展游戏模式，请按照以下步骤操作：
- en: Create a new C++ class just like you did for the game instance in the previous
    sections.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与之前章节中为游戏实例创建的类相同的新的C++类。
- en: From the **All Classes** section, select **GameMode** and click **Next**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**所有类**部分选择**GameMode**并点击**下一步**。
- en: Name your class `US_GameMode` and click the **CreateClass** button.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的类命名为`US_GameMode`并点击**创建类**按钮。
- en: Once the class has been created, it’s time to set it as the default Game Mode
    for all your levels. To do this, open **Project Settings** and select the **Maps
    &** **Modes** section.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了类，就需要将其设置为所有级别的默认游戏模式。为此，打开**项目设置**并选择**地图与模式**部分。
- en: 'Then, click on the **Default GameMode** drop-down menu and select **US_GameMode**,
    as shown in *Figure 4**.7*:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**默认游戏模式**下拉菜单并选择**US_GameMode**，如图4.7所示：
- en: '![Figure 4.7 – The default game mode](img/Figure_04.7_B18203.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 默认游戏模式](img/Figure_04.7_B18203.jpg)'
- en: Figure 4.7 – The default game mode
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 默认游戏模式
- en: Close the **Project** **Settings** window.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**项目设置**窗口。
- en: 'Now that the Game Mode has been defined, it’s time to create a Game State:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏模式已经定义，是时候创建一个游戏状态了：
- en: Create another C++ class that will extend from `GameState` (from the **All**
    **Classes** section).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个从`GameState`（来自**所有类**部分）扩展的C++类。
- en: After clicking `US_GameState` and click the **CreateClass** button.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击`US_GameState`后，点击**创建类**按钮。
- en: Now, declare `US_GameMode` files by double-clicking on the corresponding icon
    in the `C++ Classes` folder of the Unreal Editor. This will open the header and
    source files inside your IDE.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在Unreal编辑器的`C++类`文件夹中双击相应的图标来声明`US_GameMode`文件。这将打开IDE内的头文件和源文件。
- en: 'Declare a constructor inside `US_GameMode.h` by adding these two lines of code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`US_GameMode.h`中声明一个构造函数，添加以下两行代码：
- en: '[PRE3]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the constructor inside `US_GameMode.cpp` by adding this piece of
    code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`US_GameMode.cpp`中实现构造函数，添加以下代码：
- en: '[PRE5]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous code essentially declares the Game State class for `US_GameMode`
    to be the previously created `US_GameState`. Keep in mind that this declaration
    can be performed also in child Blueprints; this will enable class switching through
    a drop-down menu in the Editor. Ultimately, this is a matter of personal taste
    as you may be more code-oriented and prefer the code solution or you may want
    to take advantage of the impressive interplay between native code and the Editor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码实际上声明了`US_GameMode`的Game State类为之前创建的`US_GameState`。请注意，此声明也可以在子蓝图中进行；这将允许在编辑器中通过下拉菜单切换类。最终，这取决于个人喜好，你可能更倾向于代码导向，并偏好代码解决方案，或者你可能想利用原生代码和编辑器之间令人印象深刻的交互。
- en: In this section, you have created the main classes that will be used by the
    system to handle a multiplayer session. At the moment, these are just empty containers
    waiting for some game logic to be added; be patient, we still have so many chapters
    to fill this void!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已创建了系统将用于处理多人会话的主要类。目前，这些只是等待添加一些游戏逻辑的空容器；请耐心等待，我们还有许多章节要填补这个空白！
- en: In the next section, you’ll be creating the classes needed to handle the character
    input and presence in the game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建处理游戏中的角色输入和存在的类。
- en: Adding the player classes
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加玩家类
- en: 'You are now ready to create some more main classes used by almost any UE game:
    those dedicated to managing the input from the player and showing the character
    in-game, along with its state.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好创建一些几乎任何UE游戏都会使用的主要类：那些用于管理玩家输入并在游戏中显示角色及其状态的类。
- en: The **Player Controller** is responsible for managing input from the player’s
    input devices (such as keyboard and mouse), and for sending commands to the player’s
    character so it will perform the corresponding actions. The Player Controller
    class is typically used to control a **Pawn** class or a **Character** class that
    represents the player in a game.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家控制器**负责管理来自玩家输入设备（如键盘和鼠标）的输入，并向玩家的角色发送命令，使其执行相应的动作。玩家控制器类通常用于控制**Pawn**类或**Character**类，这些类代表游戏中玩家的角色。'
- en: Finally, the **Player State** is a class that holds information about a player’s
    game state, such as experience points, score, and other relevant data. It exists
    on both the server and clients to ensure that all players have access to the same
    information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**玩家状态** 是一个包含有关玩家游戏状态信息的类，例如经验点、分数和其他相关数据。它在服务器和客户端上存在，以确保所有玩家都能访问相同的信息。
- en: 'Let’s create these three classes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这三个类：
- en: Create a C++ class extending `PlayerController` and name it `US_PlayerController`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展 `PlayerController` 的 C++ 类，并将其命名为 `US_PlayerController`。
- en: Create another C++ class extending `Character` and name it `US_Character`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个扩展 `Character` 的 C++ 类，并将其命名为 `US_Character`。
- en: Finally, create a C++ class extending `PlayerState` and call it `US_PlayerState`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个扩展 `PlayerState` 的 C++ 类，并将其命名为 `US_PlayerState`。
- en: These three classes should be added to the Game Mode, the same way the Game
    State was added, but to get a bit more flexibility to our `Character` class, you’ll
    be creating a Blueprint from it. To get a Blueprint out of a newly created C++
    class, you need to compile the project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类应该像添加游戏状态一样添加到游戏模式中，但为了给我们的 `Character` 类提供更多灵活性，你将从中创建一个 Blueprint。要从新创建的
    C++ 类中获取 Blueprint，你需要编译项目。
- en: You are now going to compile your source code for the first time to check that
    everything has been properly set.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将第一次编译你的源代码，以检查一切是否已正确设置。
- en: Compiling your source code
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译你的源代码
- en: Compiling in an Unreal Engine project refers to the process of converting human-readable
    code written in C++ and Blueprint into executable code that the computer can understand
    and run – this is an essential step in the development process. UE provides tools
    to streamline the compiling process and improve the development experience.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 项目中编译是指将用 C++ 编写的可读代码转换为计算机可以理解和运行的可执行代码的过程 – 这是开发过程中的一个重要步骤。UE
    提供了工具来简化编译过程并提高开发体验。
- en: In Unreal Engine, you can leverage **Live Coding**, a feature that enables your
    application’s C++ code to be rebuilt and its binaries patched while the UE engine
    is running.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 中，你可以利用 **Live Coding** 功能，该功能允许在 UE 引擎运行时重建应用程序的 C++ 代码并修补其二进制文件。
- en: With Live Coding, you can modify C++ classes, compile them, and observe the
    changes taking effect while the Editor is running – all without interrupting the
    play-testing sessions or work in progress. This feature boasts enormous advantages
    for iterative development, especially when using C++ runtime logic such as gameplay
    code or frontend user interactions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Live Coding，你可以修改 C++ 类，编译它们，并在编辑器运行时观察更改生效 – 所有这些都不需要中断游戏测试会话或正在进行的工作。这个特性为迭代开发带来了巨大的优势，尤其是在使用
    C++ 运行时逻辑，如游戏代码或前端用户交互时。
- en: Live coding is enabled by default, and you can initiate a Live Coding build
    by pressing *Ctrl* +*Alt* + *F11* on your keyboard when utilizing your IDE or
    Unreal Engine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Live Coding 默认启用，当使用 IDE 或 Unreal Engine 时，你可以通过按键盘上的 *Ctrl* + *Alt* + *F11*
    来启动 Live Coding 构建。
- en: 'Alternatively, to start the compilation process with Live Coding disabled,
    you can click the **Compile** button at the bottom right of the Unreal Engine
    Editor, as depicted in *Figure 4**.8*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要禁用 Live Coding 并开始编译过程，你可以点击 Unreal Engine 编辑器右下角的 **编译** 按钮，如图 *图 4.8*
    所示：
- en: '![Figure 4.8 – The Compile button](img/Figure_04.8_B18203.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 编译按钮](img/Figure_04.8_B18203.jpg)'
- en: Figure 4.8 – The Compile button
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 编译按钮
- en: Once the source code has been compiled, you should get a success message. Otherwise,
    you will get the usual errors or warnings from a failed compilation; in this case,
    it is essential to ensure that your code is written correctly and free from errors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，你应该会收到成功消息。否则，你将收到失败的编译产生的通常错误或警告；在这种情况下，确保你的代码编写正确且无错误至关重要。
- en: Once your project has been successfully compiled, it’s time to create a Blueprint
    out of your `Character` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的项目成功编译，就是时候从你的 `Character` 类创建一个 Blueprint 了。
- en: Creating the Character Blueprint Class
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建角色 Blueprint 类
- en: As you’ll be working on some customization for your character later on, it’s
    essential to have the extra flexibility provided by a Blueprint Class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将在稍后对角色进行一些定制，因此拥有由 Blueprint 类提供的额外灵活性是至关重要的。
- en: 'As you have successfully compiled your code, you may expect that the classes
    you created will now be ready to be available in the Blueprint creation wizard.
    This is a correct assumption and you are going to test it right now. Let’s do
    so:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已成功编译代码，您可能会期望您创建的类现在将准备好在蓝图创建向导中可用。这是一个正确的假设，您现在将测试它。让我们这样做：
- en: Navigate to the `Content` | `Blueprints` folder.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`内容` | `蓝图`文件夹。
- en: Create a Blueprint Class that will inherit from `US_Character` and name it `BP_Character`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自`US_Character`的蓝图类，命名为`BP_Character`。
- en: 'Save and close the Blueprint: you are not going to do anything yet on it.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭蓝图：您现在不会对它做任何事情。
- en: This new Blueprint should be added to the Game Mode as the default Pawn to be
    used during a game session. Unfortunately, a Blueprint Class cannot be directly
    referenced in a C++ class. This means you’ll have to find it through a method
    called `FClassFinder` available in the `ConstructorHelpers` utility class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的蓝图应该被添加到游戏模式中，作为游戏会话期间使用的默认Pawn。不幸的是，蓝图类不能直接在C++类中引用。这意味着您必须通过`ConstructorHelpers`实用类中可用的`FClassFinder`方法来找到它。
- en: Adding the Player classes to the Game Mode
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家类添加到游戏模式
- en: 'You are now going to declare the newly created classes to the Game Mode. Let’s
    open again the `US_GameMode.cpp` file and add some code logic. In the `declarations`
    section, add the following block of code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将声明新创建的类到游戏模式中。让我们再次打开`US_GameMode.cpp`文件并添加一些代码逻辑。在`声明`部分，添加以下代码块：
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will declare all the GF classes you will be declaring, and the `ConstructorHelpers`
    utility class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将声明您将要声明的所有GF类以及`ConstructorHelpers`实用类。
- en: 'Then, before the closing bracket of the constructor, add the following block
    of code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数的闭合括号之前，添加以下代码块：
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the first two lines of code declare `PlayerStateClass` and `PlayerControllerClass`
    in a similar way as you did in the previous section for `GameStateClass`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码的前两行以与您在上一节中为`GameStateClass`所做的类似方式声明了`PlayerStateClass`和`PlayerControllerClass`。
- en: 'Meanwhile, retrieving a Blueprint reference (i.e., `PlayerPawnBPClass`) from
    a C++ class works differently from how it works for a regular C++ class: you need
    to hardcode a path to your project. This may be not an ideal solution because
    files can be moved around or deleted but, well... it works!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，从C++类中检索蓝图引用（例如`PlayerPawnBPClass`）的方式与常规C++类不同：您需要硬编码一个路径到您的项目。这可能不是一个理想的解决方案，因为文件可能会被移动或删除，但...它确实有效！
- en: Just keep in mind that my file path (i.e., `"/Game/Blueprints/BP_Character"`)
    may be slightly different from yours, depending on your folder organization.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我的文件路径（即`"/Game/Blueprints/BP_Character"`）可能因您的文件夹组织方式而略有不同。
- en: Now that the Game Mode class has been modified, click the **Compile** button
    in the Unreal Editor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏模式类已经被修改，点击Unreal编辑器中的**编译**按钮。
- en: 'Once you get a successful result, it’s time to look at the Game Mode instance
    to check that everything is correct. To do this, follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦得到成功的结果，就是时候查看游戏模式实例，以确保一切正确。为此，请按照以下步骤操作：
- en: Open the **Project Settings** | **Maps &** **Modes** section.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**项目设置** | **地图与模式**部分。
- en: Locate the **Selected GameMode** field and expand it by clicking the small arrow
    next to it.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**选定的游戏模式**字段，通过点击其旁边的箭头将其展开。
- en: 'Check that the GF classes we have created are all correctly allocated, as shown
    in *Figure 4**.9*:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们创建的GF类是否都正确分配，如图*图4.9*所示：
- en: '![Figure 4.9 – The updated default Game Mode](img/Figure_04.9_B18203.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 更新的默认游戏模式](img/Figure_04.9_B18203.jpg)'
- en: Figure 4.9 – The updated default Game Mode
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 更新的默认游戏模式
- en: In this last section, you have completed the Game Mode setup by adding all the
    GF classes you’ll be expanding in the next chapters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节最后，您已经通过添加下一章中将要扩展的所有GF类，完成了游戏模式的设置。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you were briefed about the project you’ll be developing through
    the rest of the book: a multiplayer stealth game involving thieves, secret treasures,
    and a ton of undead minions. The road is still long, but the Lichlord must be
    stopped!'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您被简要介绍了您将在本书的其余部分开发的项目：一款涉及盗贼、秘密宝藏和大量不死小弟的多人潜行游戏。道路仍然漫长，但必须阻止巫妖王！
- en: 'After that, you were introduced to the main topics of the Unreal Engine C++
    “dialect.” There are a lot of additional features involved and many more will
    be discovered throughout the rest of the book. One of the most exciting things
    is that, if things are set up properly, you won’t have to worry about memory management:
    Unreal Engine flawlessly handles it. What’s more, by adding decorations to your
    classes, variables, and functions, you can expose them to the Blueprint system,
    letting your project be more flexible and accessible to non-code-oriented developers.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你了解了Unreal Engine C++“方言”的主要主题。涉及了许多额外的功能，书中剩余部分还将发现更多。其中最令人兴奋的事情之一是，如果设置得当，你不必担心内存管理：Unreal
    Engine完美地处理它。更重要的是，通过向你的类、变量和函数添加装饰，你可以将它们暴露给Blueprint系统，让你的项目对非代码导向的开发者更加灵活和易于访问。
- en: Lastly, you created the main classes that will be used by your game and that
    extend those offered by the GF. Starting from the persistent GameInstance, you
    went to the Game Mode, and then to all the player-oriented elements. You now have
    a solid base to start developing your multiplayer project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建了将用于你的游戏的主要类，这些类扩展了GF提供的类。从持久的GameInstance开始，你进入了Game Mode，然后是所有面向玩家的元素。你现在有一个坚实的基础来开始开发你的多人游戏项目。
- en: In the next chapter, I will guide you through the creation of the player character
    by presenting how to manage it in a multiplayer environment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将通过展示如何在多人环境中管理它来引导你创建玩家角色。
