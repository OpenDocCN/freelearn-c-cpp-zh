["```cpp\ntemplate<class SrcIt, class DstIt, class Func>\nauto transform(SrcIt first, SrcIt last, DstIt dst, Func func) {\n  while (first != last) {\n      *dst++ = func(*first++);\n  }\n} \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Func>\nauto par_transform_naive(SrcIt first, SrcIt last, DstIt dst, Func f) {\n  auto n = static_cast<size_t>(std::distance(first, last));\n  auto n_cores = size_t{std::thread::hardware_concurrency()};\n  auto n_tasks = std::max(n_cores, size_t{1});\n  auto chunk_sz = (n + n_tasks - 1) / n_tasks;\n  auto futures = std::vector<std::future<void>>{};\n  // Process each chunk on a separate\n  for (auto i = 0ul; i < n_tasks; ++i) {\n    auto start = chunk_sz * i;\n    if (start < n) {\n      auto stop = std::min(chunk_sz * (i + 1), n);\n      auto fut = std::async(std::launch::async,\n         [first, dst, start, stop, f]() {\n          std::transform(first + start, first + stop, dst + start, f);\n      });\n      futures.emplace_back(std::move(fut));\n    }\n  }\n  // Wait for each task to finish\n  for (auto&& fut : futures) {\n    fut.wait();\n  }\n} \n```", "```cpp\nauto setup_fixture(int n) {\n  auto src = std::vector<float>(n);\n  std::iota(src.begin(), src.end(), 1.0f); // Values from 1.0 to n\n  auto dst = std::vector<float>(src.size());\n  auto transform_function = [](float v) { \n    auto sum = v;\n    for (auto i = 0; i < 500; ++i) {\n      sum += (i * i * i * sum);\n    }\n    return sum;\n  };\n  return std::tuple{src, dst, transform_function};\n} \n```", "```cpp\nvoid bm_sequential(benchmark::State& state) {\n  auto [src, dst, f] = setup_fixture(state.range(0));\n  for (auto _ : state) {\n    std::transform(src.begin(), src.end(), dst.begin(), f);\n  }\n}\nvoid bm_parallel(benchmark::State& state) {\n  auto [src, dst, f] = setup_fixture(state.range(0));\n  for (auto _ : state) {\n    par_transform_naive(src.begin(), src.end(), dst.begin(), f);\n  }\n} \n```", "```cpp\nvoid CustomArguments(benchmark::internal::Benchmark* b) {\n  b->Arg(50)->Arg(10'000)->Arg(1'000'000)  // Input size\n      ->MeasureProcessCPUTime()            // Measure all threads\n      ->UseRealTime()                      // Clock on the wall \n      ->Unit(benchmark::kMillisecond);     // Use ms\n} \n```", "```cpp\nBENCHMARK(bm_sequential)->Apply(CustomArguments);\nBENCHMARK(bm_parallel)->Apply(CustomArguments);\nBENCHMARK_MAIN(); \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Func>\nauto par_transform(SrcIt first, SrcIt last, DstIt dst,\n                   Func func, size_t chunk_sz) {\n  const auto n = static_cast<size_t>(std::distance(first, last));\n  if (n <= chunk_sz) {\n    std::transform(first, last, dst, func);\n    return;\n  }\n  const auto src_middle = std::next(first, n / 2);\n  // Branch of first part to another task\n  auto future = std::async(std::launch::async, [=, &func] {\n    par_transform(first, src_middle, dst, func, chunk_sz);\n  });\n  // Recursively handle the second part\n  const auto dst_middle = std::next(dst, n / 2);\n  par_transform(src_middle, last, dst_middle, func, chunk_sz);\n  future.wait(); \n} \n```", "```cpp\nauto setup_fixture(int n) {\n  auto src = std::vector<float>(n);\n  std::iota(src.begin(), src.end(), 1.0f);  // From 1.0 to n\n  auto dst = std::vector<float>(src.size());\n  auto transform_function = [](float v) { \n    auto sum = v;\n    auto n = v / 20'000;                  // The larger v is, \n    for (auto i = 0; i < n; ++i) {        // the more to compute\n      sum += (i * i * i * sum);\n    }\n    return sum;\n  };\n  return std::tuple{src, dst, transform_function};\n} \n```", "```cpp\n// Divide and conquer version\nvoid bm_parallel(benchmark::State& state) {\n  auto [src, dst, f] = setup_fixture(10'000'000);\n  auto n = state.range(0);        // Chunk size is parameterized\n  for (auto _ : state) {\n    par_transform(src.begin(), src.end(), dst.begin(), f, n);\n  }\n}\n// Naive version\nvoid bm_parallel_naive(benchmark::State& state) {\n  auto [src, dst, f] = setup_fixture(10'000'000);\n  for (auto _ : state) {\n    par_transform_naive(src.begin(), src.end(), dst.begin(), f);\n  }\n}\nvoid CustomArguments(benchmark::internal::Benchmark* b) {\n  b->MeasureProcessCPUTime()\n    ->UseRealTime()\n    ->Unit(benchmark::kMillisecond);\n}\nBENCHMARK(bm_parallel)->Apply(CustomArguments)\n  ->RangeMultiplier(10)           // Chunk size goes from \n  ->Range(1000, 10'000'000);      // 1k to 10M\nBENCHMARK(bm_parallel_naive)->Apply(CustomArguments);\nBENCHMARK_MAIN(); \n```", "```cpp\ntemplate <typename It, typename Pred> \nauto par_count_if(It first, It last, Pred pred, size_t chunk_sz) { \n  auto n = static_cast<size_t>(std::distance(first, last)); \n  if (n <= chunk_sz) \n    return std::count_if(first, last, pred);\n  auto middle = std::next(first, n/2); \n  auto fut = std::async(std::launch::async, [=, &pred] { \n    return par_count_if(first, middle, pred, chunk_sz); \n  }); \n  auto num = par_count_if(middle, last, pred, chunk_sz); \n  return num + fut.get(); \n} \n```", "```cpp\ntemplate <typename It, typename Pred> \nauto par_count_if(It first, It last, Pred pred) { \n  auto n = static_cast<size_t>(std::distance(first, last));\n  auto n_cores = size_t{std::thread::hardware_concurrency()};\n  auto chunk_sz = std::max(n / n_cores * 32, size_t{1000});\n\n  return par_count_if(first, last, pred, chunk_sz);\n} \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Pred> \nauto copy_if(SrcIt first, SrcIt last, DstIt dst, Pred pred) { \n  for (auto it = first; it != last; ++it) { \n    if (pred(*it)) { \n      *dst = *it; \n      ++dst;\n    }\n  }\n  return dst;\n} \n```", "```cpp\nconst auto src = {1, 2, 3, 4}; \nauto dst = std::vector<int>(src.size(), -1); \nauto new_end = std::copy_if(src.begin(), src.end(), dst.begin(), \n                            [](int v) { return (v % 2) == 1; }); \n// dst is {1, 3, -1, -1}\ndst.erase(new_end, dst.end()); // dst is now {1, 3} \n```", "```cpp\n// Warning: Undefined behavior\ntemplate <typename SrcIt, typename DstIt, typename Func> \nauto par_copy_if(SrcIt first, SrcIt last, DstIt dst, Func func) { \n  auto n = std::distance(first, last);\n  auto middle = std::next(first, n / 2); \n  auto fut0 = std::async([=]() { \n    return std::copy_if(first, middle, dst, func); }); \n  auto fut1 = std::async([=]() { \n    return std::copy_if(middle, last, dst, func); });\n  auto dst0 = fut0.get();\n  auto dst1 = fut1.get();\n  return *std::max(dst0, dst1); // Just to return something...\n} \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Pred>\nvoid inner_par_copy_if_sync(SrcIt first, SrcIt last, DstIt dst,\n                            std::atomic_size_t& dst_idx,\n                            Pred pred, size_t chunk_sz) {\n  const auto n = static_cast<size_t>(std::distance(first, last));\n  if (n <= chunk_sz) {\n    std::for_each(first, last, [&](const auto& v) {\n      if (pred(v)) {\n        auto write_idx = dst_idx.fetch_add(1);\n        *std::next(dst, write_idx) = v;\n      }\n    });\n    return;\n  }\n  auto middle = std::next(first, n / 2);\n  auto future = std::async([first, middle, dst, chunk_sz, &pred, &dst_idx] {\n    inner_par_copy_if_sync(first, middle, dst, dst_idx, pred, chunk_sz);\n  });\n  inner_par_copy_if_sync(middle, last, dst, dst_idx, pred, chunk_sz);\n  future.wait();\n} \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Pred>\nauto par_copy_if_sync(SrcIt first,SrcIt last,DstIt dst,\n                      Pred p, size_t chunk_sz) {\n  auto dst_write_idx = std::atomic_size_t{0};\n  inner_par_copy_if_sync(first, last, dst, dst_write_idx, p, chunk_sz);\n  return std::next(dst, dst_write_idx);\n} \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Pred>\nauto par_copy_if_split(SrcIt first, SrcIt last, DstIt dst, \n                       Pred pred, size_t chunk_sz) -> DstIt {\n  auto n = static_cast<size_t>(std::distance(first, last));\n  auto futures = std::vector<std::future<std::pair<DstIt, DstIt>>>{};\n  futures.reserve(n / chunk_sz);\n  for (auto i = size_t{0}; i < n; i += chunk_sz) {\n    const auto stop_idx = std::min(i + chunk_sz, n);\n    auto future = std::async([=, &pred] {\n      auto dst_first = dst + i;\n      auto dst_last = std::copy_if(first+i, first+stop_idx,                                   dst_first, pred);\n      return std::make_pair(dst_first, dst_last);\n    });\n    futures.emplace_back(std::move(future));\n  }\n  // To be continued ... \n```", "```cpp\n // ...continued from above... \n  // Part #2: Perform merge of resulting sparse range sequentially \n  auto new_end = futures.front().get().second; \n  for (auto it = std::next(futures.begin()); it != futures.end(); ++it)  { \n    auto chunk_rng = it->get(); \n    new_end = std::move(chunk_rng.first, chunk_rng.second, new_end);\n  } \n  return new_end; \n} // end of par_copy_if_split \n```", "```cpp\nauto is_odd = [](unsigned v) { \n  return (v % 2) == 1; \n}; \n```", "```cpp\nauto is_prime = [](unsigned v) {\n  if (v < 2) return false;\n  if (v == 2) return true;\n  if (v % 2 == 0) return false;\n  for (auto i = 3u; (i * i) <= v; i+=2) {\n    if ((v % i) == 0) {\n      return false; \n     }\n  }\n  return true;\n}; \n```", "```cpp\nauto v = std::vector<std::string>{ \n  \"woody\", \"steely\", \"loopy\", \"upside_down\" \n};\n// Parallel sort\nstd::sort(std::execution::par, v.begin(), v.end()); \n```", "```cpp\ntemplate <typename SrcIt, typename DstIt, typename Pred> \nauto copy_if(SrcIt first, SrcIt last, DstIt dst, Pred pred) { \n  for (auto it = first; it != last; ++it) \n  {                            // Start of loop body\n    if (pred(*it)) {           // Call predicate\n      *dst = *it;              // Copy construct \n      ++dst;\n    }\n  }                            // End of loop body \n  return dst;\n} \n```", "```cpp\nauto v = std::vector<std::string>{\"Ada\", \"APL\" /* ... */ }; \n```", "```cpp\nauto tot_size = size_t{0};\nstd::for_each(std::execution::par, v.begin(), v.end(),\n              [&](const auto& s) { \n  tot_size += s.size(); // Undefined behavior, data race!\n}); \n```", "```cpp\nauto tot_size = std::reduce(std::execution::par, v.begin(), v.end(),                             size_t{0}, [](auto i, const auto& s) { \n  return i + s.size();   // OK! Thread safe\n}); \n```", "```cpp\nauto v = std::vector<std::string>{\"Ada\", \"APL\" /* ... */ };\nauto tot_size = size_t{0};\nauto mut = std::mutex{};\nstd::for_each(std::execution::par, v.begin(), v.end(),\n              [&](const auto& s) { \n    auto lock = std::scoped_lock{mut}; // Lock\n    tot_size += s.size(); \n  }                                    // Unlock\n); \n```", "```cpp\n{ // Iteration 1\n  const auto& s = *it++;\n  mut.lock();\n  tot_size += s.size();\n  mut.unlock();\n}\n{ // Iteration 2\n  const auto& s = *it++;\n  mut.lock();\n  tot_size += s.size();\n  mut.unlock();\n} \n```", "```cpp\n{ // Iteration 1 & 2 merged\n  const auto& s1 = *it++;\n  const auto& s2 = *it++;\n  mut.lock();\n  mut.lock();                // Deadlock!\n  tot_size += s1.size();     // Replace these operations\n  tot_size += s2.size();     // with vectorized instructions\n  mut.unlock();\n  mut.unlock();\n} \n```", "```cpp\nauto v = {1, 2, 3, 4};\nauto f = [](auto) { throw std::exception{}; };\ntry {\n  std::for_each(v.begin(), v.end(), f);\n} catch (...) {\n  std::cout << \"Exception caught\\n\";\n} \n```", "```cpp\ntry {\n  std::for_each(std::execution::seq, v.begin(), v.end(), f);\n} catch (...) {\n  // The thrown std:::exception never reaches us.\n  // Instead, std::terminate() has been called \n} \n```", "```cpp\nconst auto r = {1, 2, 3, 4}; \n```", "```cpp\nauto sum = \n  std::accumulate(r.begin(), r.end(), 0, std::plus<int>{});\n\nauto product = \n  std::accumulate(r.begin(), r.end(), 1, std::multiplies<int>{}); \n```", "```cpp\nauto v = std::vector<std::string>{\"A\", \"B\", \"C\"};\nauto acc = std::accumulate(v.begin(), v.end(), std::string{});\nstd::cout << acc << '\\n'; // Prints \"ABC\" \n```", "```cpp\nauto red = std::reduce(v.begin(), v.end(), std::string{}); \nstd::cout << red << '\\n'; \n// Possible output: \"CBA\" or \"ACB\" etc \n```", "```cpp\nauto v = std::vector<std::string>{\"Ada\",\"Bash\",\"C++\"}; \nauto num_chars = std::transform_reduce( \n  v.begin(), v.end(), size_t{0}, \n  [](size_t a, size_t b) { return a + b; },     // Reduce\n  [](const std::string& s) { return s.size(); } // Transform \n); \n// num_chars is 10 \n```", "```cpp\nstruct Func {\n  void operator()(const std::string& s) {\n    res_ += s;\n  };\n  std::string res_{};    // State\n};\nauto v = std::vector<std::string>{\"A\", \"B\", \"C\"};\nauto s = std::for_each(v.begin(), v.end(), Func{}).res_;\n// s is \"ABC\" \n```", "```cpp\nauto v = std::vector<std::string>{\"A\", \"B\", \"C\"};\nfor (auto i = 0u; i < v.size(); ++i) { \n  v[i] += std::to_string(i+1); \n} \n// v is now { \"A1\", \"B2\", \"C3\" } \n```", "```cpp\nauto v = std::vector<std::string>{\"A\", \"B\", \"C\"};\nauto r = std::views::iota(size_t{0}, v.size()); \nstd::for_each(r.begin(), r.end(), [&v](size_t i) { \n  v[i] += std::to_string(i + 1); \n}); \n// v is now { \"A1\", \"B2\", \"C3\" } \n```", "```cpp\nstd::for_each(std::execution::par, r.begin(), r.end(), [&v](size_t i) { \n  v[i] += std::to_string(i + 1); \n}); \n```", "```cpp\ntemplate <typename Policy, typename Index, typename F>\nauto parallel_for(Policy&& p, Index first, Index last, F f) {\n  auto r = std::views::iota(first, last);\n  std::for_each(p, r.begin(), r.end(), std::move(f));\n} \n```", "```cpp\nauto v = std::vector<std::string>{\"A\", \"B\", \"C\"};\nparallel_for(std::execution::par, size_t{0}, v.size(),\n              [&](size_t i) { v[i] += std::to_string(i + 1); }); \n```"]