- en: Chapter 13. Advanced OOP – Inheritance and Polymorphism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。高级OOP-继承和多态
- en: 'In this chapter, we will further extend our knowledge of OOP by looking at
    the slightly more advanced concepts of **inheritance** and **polymorphism**. We
    will then be able to use this new knowledge to implement the star characters of
    our game, Thomas and Bob. Here is what we will cover in this chapter in a little
    more detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过学习稍微更高级的**继承**和**多态**概念来进一步扩展我们对OOP的知识。然后，我们将能够使用这些新知识来实现我们游戏的明星角色，Thomas和Bob。在本章中，我们将更详细地介绍以下内容：
- en: How to extend and modify a class using inheritance?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用继承扩展和修改类？
- en: Treating an object of a class as if it is more than one type of class by using
    polymorphism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多态将一个类的对象视为多种类型的类
- en: Abstract classes and how designing classes that are never instantiated can actually
    be useful
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类以及设计永远不会实例化的类实际上可以很有用
- en: Building an abstract `PlayableCharacter` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个抽象的`PlayableCharacter`类
- en: Puting inheritance to work with `Thomas` and `Bob` classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Thomas`和`Bob`类来实现继承
- en: Adding Thomas and Bob to the game project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Thomas和Bob添加到游戏项目中
- en: Inheritance
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We have seen how we can use other people's hard work by instantiating/creating
    objects from the classes of the SFML library. But this whole OOP thing goes even
    further than that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过实例化/创建对象来使用SFML库的类的其他人的辛勤工作。但是，这整个面向对象的东西甚至比那更深入。
- en: What if there is a class that has loads of useful functionality in it, but is
    not quite what we want? In this situation we can **inherit** from the other class.
    Just like it sounds, **inheritance** means we can harness all the features and
    benefits of other people's classes, including the encapsulation, while further
    refining or extending the code specifically to our situation. In this project,
    we will inherit from and extend some SFML classes. We will also do so with our
    own classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个类中有大量有用的功能，但不完全符合我们的要求怎么办？在这种情况下，我们可以**继承**自其他类。就像它听起来的那样，**继承**意味着我们可以利用其他人的类的所有特性和好处，包括封装，同时进一步完善或扩展代码，使其特别适合我们的情况。在这个项目中，我们将继承并扩展一些SFML类。我们也会用我们自己的类来做同样的事情。
- en: Let's look at some code that uses inheritance,
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用继承的代码，
- en: Extending a class
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展一个类
- en: With all this in mind, let's look at an example class and see how we can extend
    it, just to see the syntax and as a first step.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们看一个示例类，并看看我们如何扩展它，只是为了看看语法并作为第一步。
- en: 'First, we define a class to inherit from. This is no different from how we
    created any of our other classes. Take a look at this hypothetical `Soldier` class
    declaration:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个要继承的类。这与我们创建任何其他类没有什么不同。看一下这个假设的`Soldier`类声明：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, we define a `Soldier` class. It has four private variables,
    `m_Health`, `m_Armour`, `m_Range`, and `m_ShotPower`. It has four public functions
    `setHealth`, `setArmour`, `setRange`, and `setShotPower`. We don't need to see
    the definition of the functions, they will simply initialize the appropriate variable
    that their name makes obvious.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个`Soldier`类。它有四个私有变量，`m_Health`，`m_Armour`，`m_Range`和`m_ShotPower`。它有四个公共函数`setHealth`，`setArmour`，`setRange`和`setShotPower`。我们不需要看到函数的定义，它们只是简单地初始化它们的名字明显的适当变量。
- en: We can also imagine that a fully implemented `Soldier` class would be much more
    in-depth than this. It would probably have functions such as `shoot`, `goProne`,
    and others. If we implemented a `Soldier` class in an SFML project, it would likely
    have a `Sprite` object, as well as an `update` and a `getPostion` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以想象，一个完全实现的`Soldier`类会比这更加深入。它可能有函数，比如`shoot`，`goProne`等。如果我们在一个SFML项目中实现了`Soldier`类，它可能会有一个`Sprite`对象，以及一个`update`和一个`getPostion`函数。
- en: 'The simple scenario presented here is suitable for learning about inheritance.
    Now let''s look at something new, actually inheriting from the `Soldier` class.
    Look at this code, especially the highlighted part:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现的简单场景适合学习继承。现在让我们看看一些新东西，实际上是从`Soldier`类继承。看看这段代码，特别是突出显示的部分：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By adding the `: public Soldier` code to the `Sniper` class declaration, `Sniper`
    inherits from `Soldier`. But what does this mean, exactly? `Sniper` is a `Soldier`.
    It has all the variables and functions of `Soldier`. Inheritance is more than
    this, however.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '通过将`: public Soldier`代码添加到`Sniper`类声明中，`Sniper`继承自`Soldier`。但这到底意味着什么？`Sniper`是一个`Soldier`。它拥有`Soldier`的所有变量和函数。然而，继承不仅仅是这样。'
- en: Notice also that in the previous code, we declare a `Sniper` constructor. This
    constructor is unique to `Sniper`. We have not only inherited from `Soldier`,
    we have **extended ** `Soldier`. All the functionality (definitions) of the `Soldier`
    class are handled by the `Soldier` class, but the definition of the `Sniper` constructor
    must be handled by the `Sniper` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在前面的代码中，我们声明了一个`Sniper`构造函数。这个构造函数是`Sniper`独有的。我们不仅继承了`Soldier`，还**扩展了**`Soldier`。`Soldier`类的所有功能（定义）都由`Soldier`类处理，但`Sniper`构造函数的定义必须由`Sniper`类处理。
- en: 'This is what the hypothetical `Sniper` constructor definition might look like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是假设的`Sniper`构造函数定义可能是这样的：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We could go ahead and write a bunch of other classes that are an extension of
    the `Soldier` class, perhaps `Commando` and `Infantryman`. Each would have the
    exact same variables and functions, but each could also have a unique constructor
    that initializes those variables appropriate to the type of `Soldier`. `Commando`
    might have very high `m_Health` and `m_ShotPower` but really puny `m_Range`. `Infantryman`
    might be in between `Commando` and `Sniper`, with mediocre values for each variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写一堆其他类，这些类是`Soldier`类的扩展，也许是`Commando`和`Infantryman`。每个类都有完全相同的变量和函数，但每个类也可以有一个独特的构造函数，用于初始化适合`Soldier`类型的变量。`Commando`可能有非常高的`m_Health`和`m_ShotPower`，但是`m_Range`非常小。`Infantryman`可能介于`Commando`和`Sniper`之间，每个变量的值都是中等水平。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As if OOP were not useful enough already, we can now model real-world objects,
    including their hierarchies. We achieve this by sub-classing, extending, and inheriting
    from other classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好像面向对象编程已经足够有用了，现在我们可以模拟现实世界的对象，包括它们的层次结构。我们通过子类化、扩展和继承其他类来实现这一点。
- en: The terminology we might like to learn here is that the class that is extended
    from is the **super-class**, and the class that inherits from the super-class
    is the **sub-class**. We can also say **parent** and **child** class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要学习的术语是从中扩展的类是**超类**，从超类继承的类是**子类**。我们也可以说**父**类和**子**类。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You might find yourself asking this question about inheritance: Why? The reason
    is something like this: we can write common code once; in the parent class, we
    can update that common code and all classes that inherit from it are also updated.
    Furthermore, a sub-class only gets to use public and **protected** instance variables
    and functions. So, designed properly, this also further enhances the goals of
    encapsulation.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于继承，您可能会问这样一个问题：为什么？原因是这样的：我们可以编写一次通用代码；在父类中，我们可以更新该通用代码，所有继承自它的类也会被更新。此外，子类只能使用公共和**受保护**实例变量和函数。因此，如果设计得当，这也进一步增强了封装的目标。
- en: 'Did you say protected? Yes. There is an access specifier for class variables
    and functions called **protected**. You can think of protected variables as being
    somewhere between public and private. Here is a quick summary of access specifiers,
    along with more details about the protected specifier:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你说受保护？是的。有一个称为**受保护**的类变量和函数的访问限定符。您可以将受保护的变量视为介于公共和私有之间。以下是访问限定符的快速摘要，以及有关受保护限定符的更多详细信息：
- en: '`Public` variables and functions can be accessed and used by anyone.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`公共`变量和函数可以被任何人访问和使用。'
- en: '`Private` variables and functions can only be accessed/used by the internal
    code of the class. This is good for encapsulation, and when we need to access/change
    private variables, we can provide public `getter` and `setter` functions (such
    as `getSprite` and so on). If we extend a class that has `private` variables and
    functions, that child class *cannot* directly access the private data of its parent.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`私有`变量和函数只能被类的内部代码访问/使用。这对封装很有用，当我们需要访问/更改私有变量时，我们可以提供公共的`getter`和`setter`函数（如`getSprite`等）。如果我们扩展了一个具有`私有`变量和函数的类，那么子类*不能*直接访问其父类的私有数据。'
- en: '`Protected` variables and functions are almost the same as private. They cannot
    be accessed/used directly by an instance of the class. However, they *can* be
    used directly by any class that extends the class they are declared in. So it
    is like they are private, except to child classes.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`受保护`变量和函数几乎与私有变量和函数相同。它们不能被类的实例直接访问/使用。但是，它们*可以*被扩展它们所声明的类的任何类直接使用。因此，它们就像是私有的，只不过对子类是可见的。'
- en: To fully understand what protected variables and functions are and how they
    can be useful, let's look at another topic first and then we can see them in action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分理解受保护的变量和函数以及它们如何有用，让我们先看看另一个主题，然后我们可以看到它们的作用。
- en: Polymorphism
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: '**Polymorphism** allows us to write code that is less dependent on the types
    we are trying to manipulate. This can make our code clearer and more efficient.
    Polymorphism means different forms. If the objects that we code can be more than
    one type of thing, then we can take advantage of this.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**允许我们编写的代码不那么依赖于我们试图操作的类型。这可以使我们的代码更清晰和更高效。多态意味着不同的形式。如果我们编写的对象可以是多种类型的东西，那么我们就可以利用这一点。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'What does polymorphism mean to us? Boiled down to its simplest definition,
    polymorphism is this: any sub-class can be used as part of the code that uses
    the super-class. This means we can write code that is simpler and easier to understand
    and also easier to modify or change. Also, we can write code for the super-class
    and rely on the fact that no matter how many times it is sub-classed, within certain
    parameters, the code will still work.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多态对我们意味着什么？简而言之，多态就是：任何子类都可以作为使用超类的代码的一部分。这意味着我们可以编写更简单、更易于理解的代码，也更容易修改或更改。此外，我们可以为超类编写代码，并依赖于这样一个事实：在一定的参数范围内，无论它被子类化多少次，代码仍然可以正常工作。
- en: Let's discuss an example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个例子。
- en: Suppose we want to use polymorphism to help write a zoo management game where
    we have to feed and tend to the needs of animals. We will probably want to have
    a function such as `feed`. We will also probably want to pass an instance of the
    Animal to be fed into the `feed` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想利用多态来帮助编写一个动物园管理游戏，我们需要喂养和照顾动物的需求。我们可能会想要有一个名为`feed`的函数。我们可能还想将要喂养的动物的实例传递给`feed`函数。
- en: A zoo, of course, has lots of types of animal—`Lion`, `Elephant`, and `ThreeToedSloth`.
    With our new knowledge of C++ inheritance, it will make sense to code an `Animal`
    class and have all the different types of animal inherit from it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，动物园有很多种类的动物——`狮子`、`大象`和`三趾树懒`。有了我们对C++继承的新知识，编写一个`Animal`类并让所有不同类型的动物从中继承就会有意义。
- en: 'If we want to write a function (`feed`) that we can pass Lion, Elephant, and
    ThreeToedSloth into as a parameter, it might seem like we need to write a `feed`
    function for each and every type of `Animal`. However, we can write polymorphic
    functions, with polymorphic return types and arguments. Take a look at this definition
    of the hypothetical `feed` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编写一个函数（`feed`），我们可以将狮子、大象和三趾树懒作为参数传递进去，似乎需要为每种类型的`Animal`编写一个`feed`函数。但是，我们可以编写多态函数，具有多态返回类型和参数。看一下这个假设的`feed`函数的定义：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding function has the `Animal` reference as a parameter, meaning that
    any object that is built from a class that extends `Animal` can be passed into
    it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将`Animal`引用作为参数，这意味着可以将任何从扩展`Animal`的类构建的对象传递给它。
- en: So, you can even write code today and make another sub-class in a week, month,
    or year, and the very same functions and data structures will still work. Also,
    we can enforce upon our sub-classes a set of rules for what they can and cannot
    do, as well as how they do it. So, good design in one stage can influence it at
    other stages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，今天你甚至可以编写代码，然后在一周、一个月或一年后创建另一个子类，相同的函数和数据结构仍然可以工作。此外，我们可以对子类强制执行一组规则，规定它们可以做什么，不能做什么，以及如何做。因此，一个阶段的良好设计可以影响其他阶段。
- en: But will we ever really want to instantiate an actual Animal?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真的会想要实例化一个真正的动物吗？
- en: Abstract classes - virtual and pure virtual functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类 - 虚拟和纯虚拟函数
- en: An **abstract class** is a class that cannot be instantiated and therefore cannot
    be made into an object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**是一个不能被实例化的类，因此不能被制作成对象。'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some terminology we might like to learn here is **concrete** class. A **concrete
    class** is any class that isn't abstract. In other words, all the classes we have
    written so far have been concrete classes and can be instantiated into usable
    objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可能想学习的一些术语是**具体**类。**具体**类是任何不是抽象的类。换句话说，到目前为止我们编写的所有类都是具体类，可以实例化为可用的对象。
- en: So, it's code that will never be used, then? But that's like paying an architect
    to design your home and then never building it!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这段代码永远不会被使用了吗？但这就像付钱给一个建筑师设计你的房子，然后永远不建造它！
- en: If we, or the designer of a class, want to force its users to inherit it before
    using their class, they can make a class **abstract**. Then, we cannot make an
    object from it; therefore, we must extend it first and make an object from the
    sub-class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们或一个类的设计者想要强制其用户在使用他们的类之前继承它，他们可以将一个类**抽象化**。然后，我们就不能从中创建一个对象；因此，我们必须首先扩展它，然后从子类创建一个对象。
- en: To do so, we can make a function **pure virtual** and not provide any definition.
    Then that function must be **overridden** (re-written) in any class that extends
    it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以创建一个**纯虚拟**函数并不提供任何定义。然后，任何扩展它的类都必须**覆盖**（重新编写）该函数。
- en: 'Let''s look at an example; it will help. We make a class abstract by adding
    a pure virtual function such as this abstract `Animal` class that can only perform
    the generic action of makeNoise:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子；这会有所帮助。我们通过添加一个纯虚拟函数使一个类变成抽象类，比如这个只能执行通用动作`makeNoise`的抽象`Animal`类：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we add the C++ keyword, `virtual`, before, and `= 0` after the
    function declaration. Now, any class that extends/inherits from `Animal` must
    override the `makeNoise` function. This might make sense, since different types
    of animal make very different types of noise. We could perhaps have assumed that
    anybody who extends the `Animal` class is smart enough to notice that the `Animal`
    class cannot make a noise and that they will need to handle it, but what if they
    don't notice? The point is that by making a pure virtual function we guarantee
    that they will, because they have to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在函数声明之前添加了C++关键字`virtual`，之后添加了`= 0`。现在，任何扩展/继承自`Animal`的类都必须覆盖`makeNoise`函数。这是有道理的，因为不同类型的动物发出的声音非常不同。也许我们可以假设任何扩展`Animal`类的人都足够聪明，能够注意到`Animal`类不能发出声音，他们需要处理它，但如果他们没有注意到呢？关键是通过创建一个纯虚拟函数，我们保证他们会注意到，因为他们必须注意到。
- en: Abstract classes are also useful because sometimes, we want a class that can
    be used as a polymorphic type, but we need to guarantee it can never be used as
    an object. For example, `Animal` doesn't really make sense on its own. We don't
    talk about animals; we talk about types of animal. We don't say, *"Ooh, look at
    that lovely, fluffy, white animal!"* or, *"Yesterday we went to the pet shop and
    got an animal and an animal bed"*. It's just too, well, abstract.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类也很有用，因为有时我们需要一个可以用作多态类型的类，但需要保证它永远不能用作对象。例如，`Animal`单独使用并没有太多意义。我们不谈论动物；我们谈论动物的类型。我们不会说，“哦，看那只可爱的、蓬松的、白色的动物！”或者，“昨天我们去宠物店买了一只动物和一个动物床”。这太抽象了。
- en: So, an abstract class is kind of like a **template** to be used by any class
    that extends it (inherits from it). If we were building an *Industrial Empire*-type
    game where the player manages businesses and their employees, we might want a
    `Worker` class, for example, and extend it to make `Miner`, `Steelworker`, `OfficeWorker`,
    and, of course, `Programmer`. But what exactly does a plain `Worker` do? Why would
    we ever want to instantiate one?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抽象类有点像一个**模板**，可以被任何扩展它的类使用（继承自它）。如果我们正在构建一个*工业帝国*类型的游戏，玩家管理企业和员工，我们可能需要一个`Worker`类，并将其扩展为`Miner`、`Steelworker`、`OfficeWorker`，当然还有`Programmer`。但是一个普通的`Worker`到底是做什么的呢？我们为什么要实例化一个？
- en: The answer is we wouldn't want to instantiate one, but we might want to use
    it as a polymorphic type so we can pass multiple `Worker` sub-classes between
    functions and have data structures that can hold all types of workers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们不想实例化一个，但我们可能想将其用作多态类型，以便在函数之间传递多个`Worker`子类，并且有可以容纳所有类型的工人的数据结构。
- en: All pure virtual functions must be overridden by any class that extends the
    parent class that contains the pure virtual function. This means that the abstract
    class can provide some of the common functionality that would be available in
    all its sub-classes. For example, the `Worker` class might have the `m_AnnualSalary`,
    `m_Productivity`, and `m_Age` member variables. It might also have the `getPayCheck`
    function, which is not pure virtual and is the same in all the sub-classes, but
    it might have a `doWork` function, which is pure virtual and must be overridden,
    because all the different types of `Worker` will `doWork` very differently.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有纯虚拟函数必须被扩展父类的任何类覆盖，该父类包含纯虚拟函数。这意味着抽象类可以提供一些在所有子类中都可用的公共功能。例如，`Worker`类可能有`m_AnnualSalary`、`m_Productivity`和`m_Age`成员变量。它可能还有`getPayCheck`函数，这不是纯虚拟的，并且在所有子类中都是相同的，但它可能有一个`doWork`函数，这是纯虚拟的，必须被覆盖，因为所有不同类型的`Worker`都会以非常不同的方式`doWork`。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By the way, **virtual**, as opposed to pure virtual, is a function that can
    be **optionally overridden**. You declare a virtual function the same way as a
    pure virtual function, but leave the `= 0` off the end. In the current game project,
    we will use a pure virtual function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，**virtual**与纯虚函数相反，是一个**可选重写**的函数。你声明一个虚函数的方式与声明纯虚函数的方式相同，但是最后不加上`= 0`。在当前的游戏项目中，我们将使用一个纯虚函数。
- en: If any of this virtual, pure virtual, or abstract stuff is unclear, using it
    is probably the best way to understand it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对虚拟、纯虚拟或抽象的任何内容不清楚，使用它可能是理解它的最佳方式。
- en: Building the PlayableCharacter class
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建PlayableCharacter类
- en: Now we know the basics about inheritance, polymorphism, and pure virtual functions,
    we will put them to use. We will build a `PlayableCharacter` class that has the
    vast majority of the functionality that any character from our game is going to
    need. It will have one pure virtual function, `handleInput`. The `handleInput`
    function will need to be quite different in the sub-classes, so this makes sense.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了继承、多态和纯虚函数的基础知识，我们将把它们应用起来。我们将构建一个`PlayableCharacter`类，它将拥有我们游戏中任何角色大部分功能所需的功能。它将有一个纯虚函数，`handleInput`。`handleInput`函数在子类中需要有很大的不同，所以这是有道理的。
- en: As `PlayableCharacter` will have a pure virtual function, it will be an abstract
    class and no objects of it will be possible. We will then build both `Thomas`
    and `Bob` classes, which will inherit from `PlayableCharacter`, implement the
    definition of the pure virtual function, and allow us to instantiate `Bob` and
    `Thomas` objects in our game.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PlayableCharacter`将有一个纯虚函数，它将是一个抽象类，不可能有它的对象。然后我们将构建`Thomas`和`Bob`类，它们将继承自`PlayableCharacter`，实现纯虚函数的定义，并允许我们在游戏中实例化`Bob`和`Thomas`对象。
- en: Coding PlayableCharacter.h
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写PlayableCharacter.h
- en: As usual, when creating a class, we will start off with the header file that
    will contain the member variables and function declarations. What is new is that
    in this class, we will declare some **protected** member variables. Remember that
    protected variables can be used as if they are `Public` by classes, which inherit
    from the class with the protected variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在创建一个类时，我们将从包含成员变量和函数声明的头文件开始。新的是，在这个类中，我们将声明一些**protected**成员变量。请记住，受保护的变量可以被继承自具有受保护变量的类的类使用，就好像它们是`Public`一样。
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `PlayableCharacter.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `PlayableCharacter` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件（**
    `.h` **）**突出显示，然后在**名称**字段中键入`PlayableCharacter.h`。最后，单击**添加**按钮。我们现在准备为`PlayableCharacter`类编写头文件。
- en: We will add and discuss the contents of the `PlayableCharacter.h` file in three
    sections. First, the **protected** section, followed by **private**, then **public**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个部分中添加和讨论`PlayableCharacter.h`文件的内容。首先是**protected**部分，然后是**private**，最后是**public**。
- en: 'Add the code shown next to the `PlayableCharacter.h` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayableCharacter.h`文件旁边添加下面显示的代码：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing to notice in the code we just wrote is that all the variables
    are `protected`. This means that when we extend the class, all the variables we
    just wrote will be accessible to those classes that extend it. We will extend
    this class with `Thomas` and `Bob` classes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的代码中要注意的第一件事是所有变量都是`protected`的。这意味着当我们扩展类时，我们刚刚编写的所有变量将对扩展它的类可访问。我们将用`Thomas`和`Bob`类扩展这个类。
- en: Apart from the `protected` access specification, there is nothing new or complicated
    about the previous code. It is worth paying attention to some of the details,
    however. Then it will be easy to understand how the class works as we progress.
    So, let's run through those `protected` variables, one at a time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`protected`访问规范之外，先前的代码没有什么新的或复杂的。然而，值得注意的是一些细节。然后随着我们的进展，理解类的工作原理将变得容易。因此，让我们逐个运行这些`protected`变量。
- en: We have our somewhat predictable `Sprite`, `m_Sprite`. We have a float called
    `m_JumpDuration`, which will hold a value representing the time that the character
    is able to jump for. The greater the value, the further/higher the character will
    be able to jump.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相对可预测的`Sprite`，`m_Sprite`。我们有一个名为`m_JumpDuration`的浮点数，它将保存代表角色能够跳跃的时间值。数值越大，角色就能够跳得越远/高。
- en: Next, we have a Boolean, `m_IsJumping`, which is `true` when the character is
    jumping and `false` otherwise. This will be useful for making sure that the character
    can't jump while in mid-air.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个布尔值，`m_IsJumping`，当角色跳跃时为`true`，否则为`false`。这将有助于确保角色在空中时无法跳跃。
- en: The `m_IsFalling` variable has a similar use to `m_IsJumping`. It will be useful
    to know when a character is falling.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_IsFalling`变量与`m_IsJumping`有类似的用途。它将有助于知道角色何时下落。'
- en: Next, we have two Booleans that will be true if the character's left or right
    keyboard buttons are currently being pressed. These are relative depending upon
    the character (*A* and *D* for Thomas, Left and Right arrow keys for Bob). How
    we respond to these Booleans will be seen in the `Thomas` and `Bob` classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个布尔值，如果角色的左或右键盘按钮当前被按下，则为`true`。这取决于角色（*A*和*D*为Thomas，左右箭头键为Bob）。我们将在`Thomas`和`Bob`类中看到如何响应这些布尔值。
- en: The `m_TimeThisJump` float variable is updated each and every frame that `m_IsJumping`
    is `true`. We can then know when `m_JumpDuration` has been reached.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_TimeThisJump`浮点变量在每一帧`m_IsJumping`为`true`时更新。然后我们就可以知道`m_JumpDuration`何时被达到。'
- en: The final `protected` variable is the Boolean `m_JustJumped`. This will be `true`
    if a jump was initiated in the current frame. It will be useful for knowing when
    to play a jump sound effect.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`protected`变量是布尔值`m_JustJumped`。如果在当前帧中启动了跳跃，它将为`true`。这对于知道何时播放跳跃音效将很有用。
- en: 'Next, add the following `private` variables to the `PlayableCharacter.h` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下`private`变量添加到`PlayableCharacter.h`文件中：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code, we have some interesting `private` variables. Remember
    that these variables will only be directly accessible to the code in the `PlayableCharacter`
    class. The `Thomas` and `Bob` classes will not be able to access them directly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们有一些有趣的`private`变量。请记住，这些变量只能被`PlayableCharacter`类中的代码直接访问。`Thomas`和`Bob`类将无法直接访问它们。
- en: The `m_Gravity` variable will hold the number of pixels per second that the
    character will fall. The `m_Speed` variable will hold the number of pixels per
    second that the character can move left or right.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_Gravity`变量将保存角色下落的每秒像素数。`m_Speed`变量将保存角色每秒可以向左或向右移动的像素数。'
- en: The `Vector2f`, `m_Position` variable is the position in the world (not the
    screen) where the center of the character is.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector2f`，`m_Position`变量是角色在世界中（而不是屏幕上）的位置，即角色的中心位置。'
- en: The next four `FloatRect` objects are important to discuss. When we did collision
    detection in the *Zombie Arena* game, we simply checked to see if two `FloatRect`
    objects intersected. Each `FloatRect` object represented an entire character,
    a pick-up, or a bullet. For the non-rectangular shaped objects (zombies and the
    player), this was a little bit inaccurate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个`FloatRect`对象很重要。在*Zombie Arena*游戏中进行碰撞检测时，我们只是检查两个`FloatRect`对象是否相交。每个`FloatRect`对象代表整个角色、拾取物或子弹。对于非矩形形状的对象（僵尸和玩家），这有点不准确。
- en: In this game, we will need to be more precise. The `m_Feet`, `m_Head`, `m_Right`,
    and `m_Left` `FloatRect` objects will hold the coordinates of the different parts
    of a character's body. These coordinates will be updated in each and every frame.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们需要更加精确。`m_Feet`，`m_Head`，`m_Right`和`m_Left` `FloatRect`对象将保存角色身体不同部位的坐标。这些坐标将在每一帧中更新。
- en: Through these coordinates, we will be able to tell exactly when a character
    lands on a platform, bumps his head during a jump, or rubs shoulders with a tile
    to his side.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些坐标，我们将能够准确地判断角色何时落在平台上，跳跃时是否碰到头部，或者与侧面的瓷砖擦肩而过。
- en: Lastly, we have `Texture`. `Texture` is `private` as it is not used directly
    by the `Thomas` or `Bob` classes but, as we saw, `Sprite` is `protected` because
    it is used directly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`Texture`。`Texture`是`private`的，因为它不会被`Thomas`或`Bob`类直接使用，但正如我们所看到的，`Sprite`是`protected`的，因为它被直接使用。
- en: 'Now add all the `public` functions to the `PlayableCharacter.h` file and then
    we will discuss them:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有`public`函数添加到`PlayableCharacter.h`文件中，然后我们将讨论它们：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's talk about each of the function declarations that we just added. This
    will make coding their definitions easier to follow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈我们刚刚添加的每个函数声明。这将使编写它们的定义更容易跟踪。
- en: The `spawn` function receives a `Vector2f` called `startPosition` and a `float`
    called `gravity`. As the names suggest, `startPosition` will be the coordinates
    in the level at which the character will start and `gravity` will be the number
    of pixels per second at which the character will fall.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn`函数接收一个名为`startPosition`的`Vector2f`和一个名为`gravity`的`float`。顾名思义，`startPosition`将是角色在关卡中开始的坐标，`gravity`将是角色下落的每秒像素数。'
- en: The `bool virtual handleInput() = 0` is, of course, our pure virtual function.
    As `PlayableCharacter` has this function, any class that extends it, if we want
    to instantiate it, must provide a definition for this function. Therefore, when
    we write all the function definitions for `PlayableCharacter` in a minute, we
    will not provide a definition for `handleInput`. There will of course need to
    be definitions in both the `Thomas` and `Bob` classes.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool virtual handleInput() = 0`当然是我们的纯虚函数。由于`PlayableCharacter`有这个函数，任何扩展它的类，如果我们想要实例化它，必须为这个函数提供定义。因此，当我们在一分钟内为`PlayableCharacter`编写所有函数定义时，我们将不为`handleInput`提供定义。当然，`Thomas`和`Bob`类中也需要有定义。'
- en: The `getPosition` function returns a `FloatRect` that represents the position
    of the whole character.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPosition`函数返回一个代表整个角色位置的`FloatRect`。'
- en: The `getFeet()` function, as well as `getHead`, `getRight`, and `getLeft`, each
    return a `FloatRect` that represents the location of a specific part of the character's
    body. This is just what we need for detailed collision detection.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFeet()`函数，以及`getHead`，`getRight`和`getLeft`，每个都返回一个代表角色身体特定部位位置的`FloatRect`。这正是我们需要进行详细的碰撞检测。'
- en: The `getSprite` function, as usual, returns a copy of `m_Sprite` to the calling
    code.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSprite`函数像往常一样，将`m_Sprite`的副本返回给调用代码。'
- en: The `stopFalling`, `stopRight`, `stopLeft`, and `stopJump` function receive
    a single `float` value, which the function will use to reposition the character
    and stop it walking or jumping through a solid tile.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopFalling`，`stopRight`，`stopLeft`和`stopJump`函数接收一个`float`值，函数将使用它来重新定位角色并阻止它在实心瓷砖上行走或跳跃。'
- en: The `getCenter` function returns a `Vector2f` to the calling code to let it
    know exactly where the center of the character is. This value is, of course, held
    in `m_Position`. We will see later that it is used by the `Engine` class to center
    the appropriate `View` around the appropriate character.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCenter`函数将一个`Vector2f`返回给调用代码，让它准确地知道角色的中心在哪里。这个值当然保存在`m_Position`中。我们将在后面看到，它被`Engine`类用来围绕适当的角色中心适当地居中适当的`View`。'
- en: The `update` function we have seen many times before and as usual, it takes
    a `float` parameter, which is the fraction of a second that the current frame
    has taken. This `update` function will need to do more work than previous `update`
    functions (from other projects), however. It will need to handle jumping, as well
    as updating the `FloatRect` objects that represent the head, feet, left, and right.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前多次见过的`update`函数和往常一样，它接受一个`float`参数，表示当前帧所花费的秒数的一部分。然而，这个`update`函数需要做的工作比以前的`update`函数（来自其他项目）更多。它需要处理跳跃，以及更新代表头部、脚部、左侧和右侧的`FloatRect`对象。
- en: Now we can write the definitions for all the functions, except, of course, `handleInput`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为所有函数编写定义，当然，除了`handleInput`。
- en: Coding PlayableCharacter.cpp
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写PlayableCharacter.cpp
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `PlayableCharacter.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `PlayableCharacter` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**`.cpp`**）**，然后在**名称**字段中键入`PlayableCharacter.cpp`。最后，单击**添加**按钮。现在我们准备为`PlayableCharacter`类编写`.cpp`文件。
- en: 'We will break up the code and discussion into a number of chunks. First, add
    the include directives and the definition of the `spawn` function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把代码和讨论分成几个部分。首先，添加包含指令和`spawn`函数的定义：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `spawn` function initializes `m_Position` with the passed-in position, as
    well as initializing `m_Gravity`. The final line of code moves `m_Sprite` to its
    starting position.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`函数使用传入的位置初始化`m_Position`，并初始化`m_Gravity`。代码的最后一行将`m_Sprite`移动到其起始位置。'
- en: 'Next, add the definition for the `update` function, immediately after the preceding
    code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在前面的代码之后立即添加`update`函数的定义：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two parts of the code check whether `m_RightPressed` or `m_LeftPressed`
    is `true`. If either of them is, `m_Position` is changed using the same formula
    as the previous project (elapsed time multiplied by speed).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前两部分检查`m_RightPressed`或`m_LeftPressed`是否为`true`。如果其中任何一个是，`m_Position`将使用与上一个项目相同的公式（经过的时间乘以速度）进行更改。
- en: 'Next, we see whether or not the character is currently executing a jump. We
    know this from `if(m_IsJumping)`. If this `if` statement is `true`, these are
    the steps the code takes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看角色当前是否正在执行跳跃。我们从`if(m_IsJumping)`知道这一点。如果这个`if`语句为`true`，代码将执行以下步骤：
- en: Update `m_TimeThisJump` with `elapsedTime`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`elapsedTime`更新`m_TimeThisJump`。
- en: Check if `m_TimeThisJump` is still less than `m_JumpDuration`. If it is, change
    the y coordinate of `m_Position` by twice gravity multiplied by the elapsed time.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`m_TimeThisJump`是否仍然小于`m_JumpDuration`。如果是，则通过重力乘以经过的时间两倍来改变`m_Position`的y坐标。
- en: In the `else` clause that executes when `m_TimeThisJump` is not lower than `m_JumpDuration`,
    then `m_Falling` is set to `true`. The effect of doing this will be seen next.
    Also, `m_Jumping` is set to `false`. This prevents the code we have just been
    discussing from executing, because `if(m_IsJumping)` is now false.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`else`子句中，当`m_TimeThisJump`不低于`m_JumpDuration`时，`m_Falling`被设置为`true`。这样做的效果将在下面看到。此外，`m_Jumping`被设置为`false`。这样做是为了防止我们刚刚讨论的代码执行，因为`if(m_IsJumping)`现在为false。
- en: The `if(m_IsFalling)` block moves `m_Position` down each frame. It is moved
    using the current value of `m_Gravity` and the elapsed time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(m_IsFalling)`块每帧将`m_Position`向下移动。它使用`m_Gravity`的当前值和经过的时间进行移动。'
- en: 'The following code (almost all of the remaining code) updates the body parts
    of the character, relative to the current position of the sprite as a whole. Take
    a look at the following diagram to see how the code calculates the position of
    the virtual head, feet, left, and right sides of the character:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（几乎所有剩余的代码）相对于精灵的当前位置更新角色的身体部位。看一下下面的图表，看看代码如何计算角色的虚拟头部、脚部、左侧和右侧的位置：
- en: '![Coding PlayableCharacter.cpp](img/image_13_001.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![编写PlayableCharacter.cpp](img/image_13_001.jpg)'
- en: The final line of code uses the `setPosition` function to move the sprite to
    its correct location after all of the possibilities of the `update` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行使用`setPosition`函数将精灵移动到`update`函数的所有可能性之后的正确位置。
- en: 'Now add the definition for the `getPosition`, `getCenter`, `getFeet`, `getHead`,
    `getLeft`, `getRight`, and `getSprite` functions, immediately after the previous
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在立即在上一个代码之后添加`getPosition`、`getCenter`、`getFeet`、`getHead`、`getLeft`、`getRight`和`getSprite`函数的定义：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getPosition` function returns a `FloatRect` that wraps the entire sprite,
    and `getCenter` returns a `Vector2f`, which contains the center of the sprite.
    Notice that we divide the height and width of the sprite by two in order to dynamically
    arrive at this result. This is because Thomas and Bob will be of different heights.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosition`函数返回包装整个精灵的`FloatRect`，`getCenter`返回一个包含精灵中心的`Vector2f`。请注意，我们将精灵的高度和宽度除以二，以便动态地得到这个结果。这是因为Thomas和Bob的身高不同。'
- en: The `getFeet`, `getHead`, `getLeft`, and `getRight` functions return the `FloatRect`
    objects that represent the body parts of the character that we update each frame
    in the `update` function. We will write the **collision detection code** that
    uses these functions in the following chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFeet`、`getHead`、`getLeft`和`getRight`函数返回表示角色各个身体部位的`FloatRect`对象，我们在`update`函数中每帧更新它们。我们将在下一章中编写使用这些函数的**碰撞检测代码**。'
- en: The `getSprite` function, as usual, returns a copy of `m_Sprite`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSprite`函数像往常一样返回`m_Sprite`的副本。'
- en: 'Finally, for the `PlayableCharacter` class, add the definitions for the `stopFalling`,
    `stopRight`, `stopLeft`, and `stopJump` functions. Do so immediately after the
    previous code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`PlayableCharacter`类，立即在上一个代码之后添加`stopFalling`、`stopRight`、`stopLeft`和`stopJump`函数的定义：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each of the previous functions receives a value as a parameter that is used
    to reposition either the top, bottom, left, or right of the sprite. Exactly what
    these values are and how they are obtained will be seen in the following chapter.
    Each of the previous functions also repositions the sprite.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个前面的函数都接收一个值作为参数，用于重新定位精灵的顶部、底部、左侧或右侧。这些值是什么以及如何获得它们将在下一章中看到。每个前面的函数也重新定位精灵。
- en: The final function is the `stopJump` function that will also be used in collision
    detection. It sets the necessary values for `m_IsJumping` and `m_IsFalling` to
    end a jump.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是`stopJump`函数，它也将在碰撞检测中使用。它设置了`m_IsJumping`和`m_IsFalling`的必要值来结束跳跃。
- en: Building the Thomas and Bob classes
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Thomas和Bob类
- en: Now we get to use inheritance for real. We will build a class for Thomas and
    a class for Bob. They will both inherit from the `PlayableCharacter` class we
    just coded. They will then have all the functionality of the `PlayableCharacter`
    class, including direct access to its `protected` variables. We will also add
    the definition for the pure virtual function `handleInput`. You will notice that
    the `handleInput` functions for `Thomas` and `Bob` will be different.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们真正要使用继承了。我们将为Thomas建立一个类，为Bob建立一个类。它们都将继承我们刚刚编写的`PlayableCharacter`类。然后它们将拥有`PlayableCharacter`类的所有功能，包括直接访问其`protected`变量。我们还将添加纯虚函数`handleInput`的定义。您会注意到，`Thomas`和`Bob`的`handleInput`函数将是不同的。
- en: Coding Thomas.h
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Thomas.h
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `Thomas.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `Thomas`
    class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件**（`.h`）并在**名称**字段中键入`Thomas.h`。最后，单击**添加**按钮。现在我们准备好为`Thomas`类编写头文件了。
- en: 'Now add this code to the `Thomas.h` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此代码添加到`Thomas.h`类中：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code is very short and sweet. We can see that we have a constructor
    and that we are going to implement the pure virtual `handleInput` function, so
    let's do that now.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码非常简短而简洁。我们可以看到我们有一个构造函数，我们将要实现纯虚的`handleInput`函数，所以现在让我们来做吧。
- en: Coding Thomas.cpp
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Thomas.cpp
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** (`.cpp`) and then in the **Name** field, type `Thomas.cpp`. Finally,
    click the **Add** button. We are now ready to code the `.cpp` file for the `Thomas`
    class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件**（`.cpp`）并在**名称**字段中键入`Thomas.cpp`。最后，单击**添加**按钮。现在我们准备好为`Thomas`类编写`.cpp`文件了。
- en: 'Add the `Thomas` constructor to the `Thomas.cpp` file, as shown in the following
    snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Thomas`构造函数添加到`Thomas.cpp`文件中，如下面的片段所示：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All we need to do is load the `thomas.png` graphic and set the duration of a
    jump (`m_JumpDuration`) to `.45` (nearly half a second).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要加载`thomas.png`图形并将跳跃持续时间（`m_JumpDuration`）设置为`.45`（几乎半秒）。
- en: 'Add the definition of the `handleInput` function, as shown in the following
    snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`handleInput`函数的定义，如下面的片段所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code should look quite familiar. We are using the SFML `isKeyPressed` function
    to see whether any of the *W, A,* or *D* keys are pressed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来很熟悉。我们使用SFML的`isKeyPressed`函数来查看*W*、*A*或*D*键是否被按下。
- en: When *W* is pressed, the player is attempting to jump. The code then uses the
    `if(!m_IsJumping && !m_IsFalling)` code, which checks that the character is not
    already jumping and that it is not falling either. When these tests are both true,
    `m_IsJumping` is set to `true`, `m_TimeThisJump` is set to zero, and `m_JustJumped`
    is set to true.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下*W*键时，玩家正在尝试跳跃。然后代码使用`if(!m_IsJumping && !m_IsFalling)`代码，检查角色是否已经在跳跃，而且也没有在下落。当这些测试都为真时，`m_IsJumping`被设置为`true`，`m_TimeThisJump`被设置为零，`m_JustJumped`被设置为true。
- en: When the previous two tests don't evaluate to `true`, the `else` clause is executed
    and `m_Jumping` is set to `false` and `m_IsFalling` is set to true.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当前两个测试不为“true”时，执行“else”子句，并将“m_Jumping”设置为“false”，将“m_IsFalling”设置为true。
- en: The handling of the *A* and *D* keys being pressed is as simple as setting `m_LeftPressed`
    and/or `m_RightPressed` to `true` or ` false`. The `update` function will now
    be able to handle moving the character.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*A*和*D*键的处理就是简单地将`m_LeftPressed`和/或`m_RightPressed`设置为`true`或`false`。`update`函数现在将能够处理移动角色。
- en: The last line of code in the function returns the value of `m_JustJumped`. This
    will let the calling code know if it needs to play a jumping sound effect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后一行代码返回`m_JustJumped`的值。这将让调用代码知道是否需要播放跳跃音效。
- en: We will now code the `Bob` class, although this is nearly identical to the `Thomas`
    class, except it has different jumping abilities, a different `Texture`, and uses
    different keys on the keyboard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写`Bob`类，尽管这几乎与`Thomas`类相同，但它具有不同的跳跃能力，不同的`Texture`，并且在键盘上使用不同的键。
- en: Coding Bob.h
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Bob.h
- en: The `Bob` class is identical in structure to the `Thomas` class. It inherits
    from `PlayableCharacter`, it has a constructor, and it provides the definition
    of the `handleInput` function. The difference compared to `Thomas` is that we
    initialize some of Bob's member variables differently and we handle input (in
    the `handleInput` function) differently as well. Let's code the class and see
    the details.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bob`类的结构与`Thomas`类相同。它继承自`PlayableCharacter`，有一个构造函数，并提供`handleInput`函数的定义。与`Thomas`相比的区别是，我们以不同的方式初始化了一些Bob的成员变量，并且我们也以不同的方式处理输入（在`handleInput`函数中）。让我们编写这个类并看看细节。'
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `Bob.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `Bob`
    class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件**（`.h`）并在**名称**字段中键入`Bob.h`。最后，单击**添加**按钮。现在我们准备好为`Bob`类编写头文件了。
- en: 'Add the following code to the `Bob.h` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Bob.h`文件中：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code is identical to the `Thomas.h` file apart from the class name,
    and therefore, the constructor name.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码与`Thomas.h`文件相同，除了类名和构造函数名。
- en: Coding Bob.cpp
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Bob.cpp
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Thomas.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `Bob` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**`.cpp`**）**突出显示，然后在**名称**字段中键入`Thomas.cpp`。最后，单击**添加**按钮。我们现在准备为`Bob`类编写`.cpp`文件。
- en: 'Add the code for the `Bob` constructor to the `Bob.cpp` file. Notice that the
    texture is different (`bob.png`) and that `m_JumpDuration` is initialized to a
    significantly smaller value. Bob is now his own, unique self:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Bob`构造函数的代码添加到`Bob.cpp`文件中。注意纹理不同（`bob.png`），并且`m_JumpDuration`初始化为一个显着较小的值。Bob现在是他自己独特的自己：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `handleInput` code immediately after the `Bob` constructor:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bob`构造函数之后立即添加`handleInput`代码：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the code is nearly identical to the code in the `handleInput` function
    of the `Thomas` class. The only difference is that we respond to different keys
    (**Left** arrow key, **Right** arrow key, and **Up** arrow key for jump.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码几乎与`Thomas`类的`handleInput`函数中的代码相同。唯一的区别是我们对不同的键（**左**箭头键，**右**箭头键和**上**箭头键用于跳跃）做出响应。
- en: Now we have a `PlayableCharacter` class that has been extended by `Bob` and
    `Thomas`, we can add a `Bob` and a `Thomas` instance to the game.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`PlayableCharacter`类，它已经被`Bob`和`Thomas`扩展，我们可以在游戏中添加一个`Bob`和一个`Thomas`实例。
- en: Updating the game engine to use Thomas and Bob
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新游戏引擎以使用Thomas和Bob
- en: In order to be able to run the game and see our new characters, we have to declare
    instances of them, call their `spawn` functions, update them each frame, and draw
    them each frame. Let's do that now.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行游戏并看到我们的新角色，我们必须声明它们的实例，调用它们的`spawn`函数，每帧更新它们，并每帧绘制它们。现在让我们来做这个。
- en: Updating Engine.h to add an instance of Bob and Thomas
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Engine.h以添加Bob和Thomas的实例
- en: 'Open up the `Engine.h` file and add the highlighted lines of code, as shown
    in the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件并添加下面突出显示的代码行，如下所示：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we have an instance of both `Thomas` and `Bob`, which are derived from `PlayableCharacter`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Thomas`和`Bob`的实例，它们都是从`PlayableCharacter`派生出来的。
- en: Updating the input function to control Thomas and Bob
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新输入函数以控制Thomas和Bob
- en: 'Now we will add the ability to control the two characters. This code will go
    in the input part of the code. Of course, for this project, we have a dedicated
    `input` function. Open up `Input.cpp` and add this highlighted code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加控制这两个角色的能力。这段代码将放在代码的输入部分。当然，对于这个项目，我们有一个专门的`input`函数。打开`Input.cpp`并添加这段突出显示的代码：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how simple the previous code is, as all the functionality is contained
    within the `Thomas` and `Bob` classes. All the code has to do is add an include
    directive for each of the `Thomas` and `Bob` classes. Then, within the `input`
    function, the code just calls the pure virtual `handleInput` functions on `m_Thomas`
    and `m_Bob`. The reason we wrap each of the calls in an `if` statement is because
    they return `true` or `false` based upon whether a new jump has just been successfully
    initiated. We will handle playing the jump sound effects in [Chapter 15](ch15.html
    "Chapter 15. Sound Spatialization and HUD"), *Sound Spacialization and HUD*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以前的代码是多么简单，因为所有功能都包含在`Thomas`和`Bob`类中。所有代码只需为`Thomas`和`Bob`类添加一个包含指令。然后，在`input`函数中，代码只需在`m_Thomas`和`m_Bob`上调用纯虚拟的`handleInput`函数。我们将每个调用包装在`if`语句中的原因是因为它们基于刚刚成功启动的新跳跃返回`true`或`false`。我们将在[第15章](ch15.html
    "第15章。声音空间化和HUD")中处理播放跳跃音效，*声音空间化和HUD*。
- en: Updating the update function to spawn and update the PlayableCharacter instances
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新更新函数以生成和更新PlayableCharacter实例
- en: This is broken down into two parts. First, we need to spawn Bob and Thomas at
    the start of a new level, and second, we need to update (by calling their `update`
    functions) each frame.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这被分成两部分。首先，我们需要在新级别开始时生成Bob和Thomas，其次，我们需要每帧更新（通过调用它们的`update`函数）。
- en: Spawning Thomas and Bob
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成Thomas和Bob
- en: 'We need to call the spawn functions of our `Thomas` and `Bob` objects in a
    few different places as the project progresses. Most obviously, we need to spawn
    the two characters when a new level begins. In the following chapter, as the number
    of tasks we need to perform at the beginning of a level increases, we will write
    a `loadLevel` function. For now, lets just call `spawn` on `m_Thomas` and `m_Bob`
    in the `update` function, as shown in the following highlighted code. Add the
    code, but keep in mind that this code will eventually be deleted and replaced:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的进展，我们需要在几个不同的地方调用我们的`Thomas`和`Bob`对象的生成函数。最明显的是，当新级别开始时，我们需要生成这两个角色。在接下来的章节中，随着我们需要在级别开始时执行的任务数量增加，我们将编写一个`loadLevel`函数。现在，让我们在`update`函数中调用`m_Thomas`和`m_Bob`的`spawn`函数，如下所示的突出显示的代码。添加这段代码，但请记住，这段代码最终将被删除并替换：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code simply calls `spawn` and passes in a location in the game
    world, along with the gravity. The code is wrapped in an `if` statement that checks
    whether a new level is required. The actual spawning code will be moved to a dedicated
    `loadLevel` function, but the `if` condition will be part of the finished project.
    Also, `m_TimeRemaining` is set to a somewhat arbitrary 10 seconds.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码只是调用`spawn`并传入游戏世界中的位置以及重力。该代码包裹在一个`if`语句中，检查是否需要新的级别。实际的生成代码将被移动到一个专门的`loadLevel`函数中，但`if`条件将成为完成项目的一部分。此外，`m_TimeRemaining`被设置为一个相当任意的10秒。
- en: Updating Thomas and Bob each frame
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每帧更新Thomas和Bob
- en: Next, we will update Thomas and Bob. All we need to do is call their `update`
    functions and pass in the time this frame has taken.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新Thomas和Bob。我们只需要调用它们的`update`函数并传入本帧所花费的时间。
- en: 'Add the following highlighted code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面突出显示的代码：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that the characters can move, we need to update the appropriate `View` objects
    to center around the characters and make them the center of attention. Of course,
    until we have some objects in our game world, the sensation of actual movement
    will not be achieved.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在角色可以移动了，我们需要更新适当的`View`对象，使其围绕角色居中并使其成为关注的中心。当然，直到我们的游戏世界中有一些物体，才能实现实际移动的感觉。
- en: 'Add the highlighted code, as shown in the following snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面片段中显示的突出代码：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous code handles the two possible situations. First, the `if(mSplitScreen)` condition
    positions the left-hand view around `m_Thomas` and the right-hand view around
    `m_Bob`. The `else` clause that executes when the game is in fullscreen mode tests
    to see if `m_Character1` is `true`. If it is, then the fullscreen view (`m_MainView`)
    is centered around Thomas, otherwise it is centered around Bob. You probably remember
    that the player can use the *E* key to toggle split screen mode and the *Q* key
    to toggle between Bob and Thomas, in fullscreen mode. We coded this in the `input`
    function of the `Engine` class, back in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    - Making Better Use of OOP*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码处理了两种可能的情况。首先，`if(mSplitScreen)`条件将左侧视图定位在`m_Thomas`周围，右侧视图定位在`m_Bob`周围。当游戏处于全屏模式时执行的`else`子句测试`m_Character1`是否为`true`。如果是，则全屏视图（`m_MainView`）围绕Thomas居中，否则围绕Bob居中。您可能还记得玩家可以使用*E*键在分屏模式和全屏模式之间切换，使用*Q*键在全屏模式下切换Bob和Thomas。我们在`Engine`类的`input`函数中编写了这些内容，回到[第12章](ch12.html
    "第12章。抽象和代码管理-更好地利用OOP")。
- en: Drawing Bob and Thomas
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制Bob和Thomas
- en: 'Make sure the `Draw.cpp` file is open and add the highlighted code, as shown
    in the following snippet:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`Draw.cpp`文件已打开，并添加下面片段中显示的突出代码：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we draw both Thomas and Bob for the full screen, the left, and the
    right. Also note the very subtle difference in the way that we draw the characters
    in split screen mode. When drawing the left side of the screen, we switch the
    order the characters are drawn and draw Thomas after Bob. So, Thomas will always
    be on top on the left, and Bob on the right. This is because the player controlling
    Thomas is catered for on the left and Bob the right.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在全屏、左侧和右侧都绘制了Thomas和Bob。还要注意在分屏模式下绘制角色的微妙差异。在绘制屏幕的左侧时，我们改变了角色的绘制顺序，并在Bob之后绘制Thomas。因此，Thomas将始终位于左侧的顶部，Bob位于右侧。这是因为左侧是为控制Thomas的玩家而设计的，右侧是为控制Bob的玩家而设计的。
- en: 'You can run the game and see Thomas and Bob in the center of the screen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行游戏，看到Thomas和Bob位于屏幕中央：
- en: '![Drawing Bob and Thomas](img/image_13_002.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![绘制Bob和Thomas](img/image_13_002.jpg)'
- en: If you press the *Q* key to switch focus from Thomas to Bob, you will see the
    `View` make the slight adjustment. If you move either of the characters left or
    right (Thomas with *A* and *D*, Bob with the arrow keys) you will see them move
    relative to each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下*Q*键从Thomas切换到Bob，您将看到`View`进行了轻微调整。如果移动任何一个角色向左或向右（Thomas使用*A*和*D*，Bob使用箭头键），您将看到它们相对移动。
- en: 'Try pressing the *E* key to toggle between fullscreen and split-screen. Then
    try moving both characters again to see the effect. In the following screenshot,
    you can see that Thomas is always centered in the left-hand window and Bob is
    always centered in the right-hand window:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按下*E*键在全屏和分屏模式之间切换。然后尝试再次移动两个角色以查看效果。在下面的截图中，您可以看到Thomas始终位于左侧窗口的中心，Bob始终位于右侧窗口的中心：
- en: '![Drawing Bob and Thomas](img/image_13_003.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![绘制Bob和Thomas](img/image_13_003.jpg)'
- en: If you leave the game running long enough, the characters will re-spawn in their
    original positions every ten seconds. This is the beginnings of the functionality
    we will need for the finished game. This behavior is caused by `m_TimeRemaining`
    going below zero and then setting the `m_NewLevelRequired` variable to `true`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您让游戏运行足够长的时间，角色将每十秒重新生成在它们的原始位置。这是我们在完成游戏时需要的功能的开端。这种行为是由`m_TimeRemaining`变为负值，然后将`m_NewLevelRequired`变量设置为`true`引起的。
- en: Also note that we can't see the full effect of movement until we draw the details
    of the level. In fact, although it can't be seen, both characters are continuously
    falling at 300 pixels per second. As the camera is centering around them every
    frame and there are no other objects in the game-world, we cannot see this downward
    movement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，直到我们绘制了关卡的细节，我们才能看到移动的完整效果。实际上，虽然看不到，但两个角色都在以每秒300像素的速度持续下落。由于摄像机每帧都围绕它们居中，并且游戏世界中没有其他物体，我们看不到这种向下运动。
- en: 'If you want to demonstrate this to yourself, just change the call to `m_Bob.spawn`,
    as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己演示这一点，只需按照以下代码中所示更改对`m_Bob.spawn`的调用：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that Bob has no gravitational effect, Thomas will visibly fall away from
    him. This is shown in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Bob没有重力效果，Thomas会明显远离他。如下截图所示：
- en: '![Drawing Bob and Thomas](img/image_13_004.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![绘制Bob和Thomas](img/image_13_004.jpg)'
- en: We will add some playable levels to interact with in the following chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将添加一些可玩的关卡进行交互。
- en: FAQ
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) We learned about polymorphism, but I didn't notice anything polymorphic in
    the game code so far.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Q）我们学习了多态性，但到目前为止，我没有注意到游戏代码中有任何多态性。
- en: A) We will see polymorphism in action in the following chapter, when we write
    a function that takes a `PlayableCharacter` as a parameter. We will see how we
    can pass either Bob or Thomas to this new function and it will work the same with
    either of them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: A）在接下来的章节中，当我们编写一个以`PlayableCharacter`作为参数的函数时，我们将看到多态性的实际应用。我们将看到如何可以将Bob或Thomas传递给这个新函数，并且无论使用哪个，它都能正常工作。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some new C++ concepts. First, Inheritance allows
    us to extend a class and gain all of its functionality. We also learned that we
    can declare variables as protected, and that will give the child class access
    to them, but they will still be encapsulated (hidden) from all other code. We
    also used pure virtual functions, which make a class abstract, meaning that the
    class cannot be instantiated and must therefore be inherited/extended from. We
    were also introduced to the concept of polymorphism, but will need to wait until
    the following chapter to use it in our game.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些新的C++概念。首先，继承允许我们扩展一个类并获得其所有功能。我们还学到，我们可以将变量声明为受保护的，这将使子类可以访问它们，但它们仍将被封装（隐藏）在所有其他代码之外。我们还使用了纯虚函数，这使得一个类成为抽象类，意味着该类不能被实例化，因此必须从中继承/扩展。我们还介绍了多态的概念，但需要等到下一章才能在我们的游戏中使用它。
- en: Next up, we will add some major functionality to the game. By the end of the
    following chapter, Thomas and Bob will be walking, jumping, and falling. They
    will even be able to jump on each other's heads, as well as explore some level
    designs that are loaded from a text file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为游戏添加一些重要功能。在接下来的一章中，Thomas和Bob将会行走、跳跃和下落。他们甚至可以跳在彼此的头上，以及探索从文本文件加载的一些关卡设计。
