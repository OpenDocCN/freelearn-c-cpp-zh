- en: '*Chapter 6*: IR Generation for High-Level Language Constructs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：高级语言构造的IR生成'
- en: High-level languages today usually make use of aggregate data types and **object-oriented
    programming** (**OOP**) constructs. **LLVM IR** has some support for aggregate
    data types, and we must implement OOP constructs such as classes on our own. Adding
    aggregate types gives rise to the question of how parameters of an aggregate type
    are passed. Different platforms have different rules, and this is also reflected
    in the IR. Being compliant with the calling convention ensures that system functions
    can be called.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的高级语言通常使用聚合数据类型和**面向对象编程**（**OOP**）构造。**LLVM IR**对聚合数据类型有一定支持，我们必须自行实现类似类的OOP构造。添加聚合类型引发了一个问题，即如何传递聚合类型的参数。不同的平台有不同的规则，这也反映在IR中。遵守调用约定可确保可以调用系统函数。
- en: In this chapter, you will learn how to translate aggregate data types and pointers
    to LLVM IR, and how to pass parameters to a function in a system-compliant way.
    You'll also learn how to implement classes and virtual functions in LLVM IR.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何将聚合数据类型和指针转换为LLVM IR，以及如何以符合系统的方式传递函数的参数。您还将学习如何在LLVM IR中实现类和虚函数。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Working with arrays, structs, and pointers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组、结构和指针
- en: Getting the application binary interface right
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确获取应用程序二进制接口
- en: Creating IR code for classes and virtual functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类和虚函数创建IR代码
- en: By the end of the chapter, you will have acquired the knowledge to create LLVM
    IR for aggregate data types and OOP. You will also know how to pass aggregate
    data types according to the rules of the platform.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将掌握创建LLVM IR的聚合数据类型和OOP的知识。您还将了解如何根据平台规则传递聚合数据类型。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在以下网址找到：[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang)
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到代码的操作视频：[https://bit.ly/3nllhED](https://bit.ly/3nllhED)
- en: Working with arrays, structs, and pointers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组、结构和指针
- en: For almost all applications, basic types such as `INTEGER` are not sufficient.
    For example, to represent mathematical objects such as a matrix or a complex number,
    you must construct new data types based on existing data types. These new data
    types are generally called **aggregate** or **composite types**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有应用程序，诸如`INTEGER`之类的基本类型是不够的。例如，要表示数学对象，如矩阵或复数，必须基于现有数据类型构造新的数据类型。这些新数据类型通常称为**聚合**或**复合类型**。
- en: '`tinylang` type of `ARRAY [10] OF INTEGER`, or the C type of `long[10]`, is
    expressed in IR as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`tinylang`类型为`ARRAY [10] OF INTEGER`，或C类型为`long[10]`，在IR中表示如下：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Structures are composites of different types. In programming languages, they
    are often expressed with named members. For example, in `tinylang`, a structure
    is written as `RECORD x, y: REAL; color: INTEGER; END;` and the same structure
    in C is `struct { float x, y; long color; };`. In LLVM IR, only the type names
    are listed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '结构是不同类型的组合。在编程语言中，它们通常用具有命名成员的方式表示。例如，在`tinylang`中，结构写为`RECORD x, y: REAL;
    color: INTEGER; END;`，在C中相同的结构为`struct { float x, y; long color; };`。在LLVM IR中，只列出类型名称：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To access a member, a numerical index is used. Like arrays, the first element
    has the index number `0`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问成员，使用数字索引。与数组一样，第一个元素的索引号为`0`。
- en: 'The members of this structure are laid out in memory according to the specification
    in the data layout string. If necessary, unused padding bytes are inserted. If
    you need to take control of the memory layout, then you can use a packed structure,
    in which all elements have a 1-byte alignment. The syntax is slightly different:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的成员根据数据布局字符串中的规范在内存中布局。如果需要，将插入未使用的填充字节。如果需要控制内存布局，则可以使用紧凑结构，其中所有元素具有1字节对齐。语法略有不同：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Loaded into a register, arrays and structs are treated as a unit. It is not
    possible to refer to a single element of the `%x` array-valued register as `%x[3]`,
    for example. This is due to the `%x[i]` and `%x[j]` refer to the same element
    or not. Instead, we need special instructions to extract and insert single-element
    values into an array. To read the second element, we use the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 加载到寄存器中，数组和结构被视为一个单元。例如，不可能将`%x`数组值寄存器的单个元素表示为`%x[3]`。这是因为`%x[i]`和`%x[j]`是否引用相同的元素。相反，我们需要特殊指令来提取和插入单个元素值到数组中。要读取第二个元素，我们使用以下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also update an element, for example, the first one:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更新一个元素，例如第一个元素：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Both instructions work on the structure, too. For example, to access the `color`
    member from the `%pt` register, you write the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令也适用于结构。例如，要从`%pt`寄存器中访问`color`成员，可以编写以下内容：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is an important limitation on both instructions: the index must be a
    constant. For structures, this is easily explainable. The index number is only
    a substitute for the name, and languages such as C have no notion of dynamically
    computing the name of a struct member. For arrays, it is simply that it can''t
    be implemented efficiently. Both instructions have value in specific cases when
    the number of elements is small and known. For example, a complex number could
    be modeled as an array of two floating-point numbers. It''s reasonable to pass
    this array around and it is always clear which part of the array must be accessed
    during a computation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令都有一个重要的限制：索引必须是一个常数。对于结构，这很容易解释。索引号只是名称的替代，诸如C的语言没有动态计算结构成员名称的概念。对于数组，这只是它无法有效实现。这两个指令在特定情况下具有价值，当元素数量较少且已知时。例如，复数可以建模为两个浮点数的数组。传递这个数组是合理的，并且在计算过程中始终清楚数组的哪一部分必须被访问。
- en: 'For general use in the frontend, we have to resort to pointers to memory. All
    global values in LLVM are expressed as pointers. Let''s declare a global variable,
    `@arr`, as an array of eight `i64` elements, the equivalent of the `long arr[8]`
    C declaration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在前端通用，我们必须使用指向内存的指针。LLVM 中的所有全局值都表示为指针。让我们声明一个全局变量 `@arr`，作为包含八个 `i64` 元素的数组，相当于
    C 声明的 `long arr[8]`：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To access the second element of the array, an address calculation must be performed
    to determine the address of the indexed element. Then, the value can then be loaded
    from that address. Put into a `@second` function, this looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组的第二个元素，必须执行地址计算以确定索引元素的地址。然后，可以从该地址加载值。放入 `@second` 函数中，看起来像这样：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `getelementptr` instruction is the workhorse for address calculations.
    As such, it needs some more explanation. The first operand, `[8 x i64]`, is the
    base type the instruction is operating on. The second operand, `[8 x i64]* @arr`,
    specifies the base pointer. Please note the subtle difference here: we declared
    an array of eight elements, but because all global values are treated as pointers,
    we have a pointer to the array. In C syntax, we work with `long (*arr)[8]`! The
    consequence is that we first have to dereference the pointer before we can index
    the element, such as `arr[0][1]` in C. The third operand, `i64 0`, dereferences
    the pointer and the fourth operand, `i64 1`, is the element index. The result
    of this computation is the address of the indexed element. Please note that no
    memory is touched by this instruction.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`getelementptr` 指令是地址计算的主要工具。因此，它需要更多的解释。第一个操作数 `[8 x i64]` 是指令操作的基本类型。第二个操作数
    `[8 x i64]* @arr` 指定了基本指针。请注意这里的细微差别：我们声明了一个包含八个元素的数组，但因为所有的全局值都被视为指针，所以我们有一个指向数组的指针。在
    C 语法中，我们使用 `long (*arr)[8]`！这意味着我们首先必须解引用指针，然后才能索引元素，比如在 C 中的 `arr[0][1]`。第三个操作数
    `i64 0` 解引用指针，第四个操作数 `i64 1` 是元素索引。这个计算的结果是索引元素的地址。请注意，这个指令不会触及任何内存。'
- en: 'Except for structs, the index parameters do not need to be constant. Therefore,
    the `getelementptr` instruction can be used in a loop to retrieve the elements
    of an array. Structs are treated differently here: only constants can be used,
    and the type must be `i32`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构体，索引参数不需要是常量。因此，`getelementptr` 指令可以在循环中用于检索数组的元素。这里对待结构体的方式不同：只能使用常量，并且类型必须是
    `i32`。
- en: 'With this knowledge, arrays are easily integrated into the code generator from
    [*Chapter 5*](B15647_05_ePub_RK.xhtml#_idTextAnchor079), *Basics of IR Generation*.
    The `convertType()` method must be extended to create the type. If the `Arr` variable
    holds the type denoter of an array, then we can add the following to the method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，数组很容易从[*第5章*](B15647_05_ePub_RK.xhtml#_idTextAnchor079)，*IR 生成基础* 中集成到代码生成器中。`convertType()`
    方法必须扩展以创建类型。如果 `Arr` 变量保存了数组的类型标识符，那么我们可以在方法中添加以下内容：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This type can be used to declare global variables. For local variables, we
    need to allocate memory for the array. We do this in the first basic block of
    the procedure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型可以用来声明全局变量。对于局部变量，我们需要为数组分配内存。我们在过程的第一个基本块中进行这个操作：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To read and write an element, we have to generate the `getelemtptr` instruction.
    This is added to the `emitExpr()` (reading a value) and `emitAssign()` (writing
    a value) methods. To read an element of an array, the value of the variable is
    read first. Then the selectors of the variable are processed. For each index,
    the expression is evaluated and the value is stored. Based on this list, the address
    of the referenced element is calculated and the value is loaded:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取和写入一个元素，我们必须生成 `getelemtptr` 指令。这被添加到 `emitExpr()`（读取值）和 `emitAssign()`（写入值）方法中。要读取数组的元素，首先读取变量的值。然后处理变量的选择器。对于每个索引，计算表达式并存储值。基于这个列表，计算引用元素的地址并加载值：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Writing to an array element uses the same code, with the exception that you
    do not generate a `load` instruction. Instead, you use the pointer as the target
    in a `store` instruction. For records, you use a similar approach. The selector
    for a record member contains the constant field index, named `Idx`. You convert
    this constant into a constant LLVM value with the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 写入数组元素使用相同的代码，唯一的区别是不生成 `load` 指令。而是使用指针作为 `store` 指令的目标。对于记录，使用类似的方法。记录成员的选择器包含常量字段索引，称为
    `Idx`。将这个常量转换为常量 LLVM 值，如下所示：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, you can use value in the `Builder.CreateGEP()` methods as for arrays.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像数组一样在 `Builder.CreateGEP()` 方法中使用值。
- en: Now you have the knowledge to translate aggregate data types to LLVM IR. Passing
    values of those types in a system-compliant way requires some care, and you will
    learn how to implement it correctly in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了将聚合数据类型转换为 LLVM IR 的知识。以系统兼容的方式传递这些类型的值需要一些小心，你将在下一节中学习如何正确实现它。
- en: Getting the application binary interface right
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确理解应用二进制接口
- en: 'With the latest addition of arrays and records to the code generator, you may
    notice that sometimes the generated code does not execute as expected. The reason
    is that we have ignored the calling conventions of the platform so far. Each platform
    defines its own rules for how one function can call another function in the same
    program or a library. These rules are summarized in the **application binary interface**
    (**ABI**) documentation. Typical information includes the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数组和记录被添加到代码生成器中，你可能会注意到有时生成的代码并不按预期执行。原因是到目前为止我们忽略了平台的调用约定。每个平台都定义了如何一个函数可以调用同一程序或库中的另一个函数的规则。这些规则在**应用二进制接口**（**ABI**）文档中进行了总结。典型的信息包括以下内容：
- en: Are machine registers used for parameter passing? If yes, which?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器寄存器用于参数传递吗？如果是，使用哪些？
- en: How are aggregates such as arrays and structs passed to a function?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将数组和结构等聚合类型传递给函数？
- en: How are return values handled?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是如何处理的？
- en: There is a wide variety of rules in use. On some platforms, aggregates are always
    passed indirectly, meaning that a copy of the aggregate is placed on the stack
    and only a pointer to the copy is passed as a parameter. On other platforms, a
    small aggregate (say 128- or 256-bit-wide) is passed in registers and only above
    that threshold is indirect parameter passing used. Some platforms also use floating-point
    and vector registers for parameter passing, while others demand that floating-point
    values are passed in integer registers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的规则种类繁多。在某些平台上，聚合始终以间接方式传递，这意味着在堆栈上放置聚合的副本，然后只传递该副本的指针作为参数。在其他平台上，小型聚合（例如128位或256位宽）在寄存器中传递，只有超过该阈值才使用间接参数传递。一些平台还使用浮点和矢量寄存器进行参数传递，而其他平台要求浮点值在整数寄存器中传递。
- en: Of course, this is all interesting, low-level stuff. Unfortunately, it leaks
    into LLVM IR. At first, this is surprising. After all, we define the types of
    all parameters of a function in LLVM IR! It turns out that this is not enough.
    To understand this, let's consider complex numbers. Some languages have built-in
    data types for complex numbers; for example, C99 has `float _Complex` (among others).
    Older versions of C do not have complex number types, but you can easily define
    `struct Complex { float re, im; }` and create arithmetic operations on this type.
    Both types can be mapped to the `{ float, float }` LLVM IR type. If the ABI now
    states that values of a built-in complex number type are passed in two floating-point
    registers, but user-defined aggregates are always passed indirectly, then the
    information given with the function is not enough for LLVM to decide how to pass
    this particular parameter. The unfortunate consequence is that we need to provide
    more information to LLVM, and this information is highly ABI-specific.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这都是有趣的低级内容。不幸的是，这些内容泄漏到了LLVM IR中。起初，这让人感到惊讶。毕竟，我们在LLVM IR中定义了函数所有参数的类型！事实证明这是不够的。为了理解这一点，让我们考虑复数。一些语言具有内置的复数数据类型；例如，C99具有`float
    _Complex`（等等）。较早版本的C没有复数类型，但您可以轻松地定义`struct Complex { float re, im; }`并在此类型上创建算术运算。这两种类型都可以映射到`{
    float，float }`LLVM IR类型。如果ABI现在规定内置复数类型的值在两个浮点寄存器中传递，但用户定义的聚合始终以间接方式传递，那么函数提供的信息对于LLVM来说不足以决定如何传递此特定参数。不幸的后果是我们需要向LLVM提供更多信息，而这些信息是高度特定于ABI的。
- en: 'There are two ways to specify this information to LLVM: parameter attributes
    and type rewriting. What you need to use depends on the target platform and the
    code generator. The most commonly used parameter attributes are the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以向LLVM指定此信息：参数属性和类型重写。您需要使用的方法取决于目标平台和代码生成器。最常用的参数属性如下：
- en: '`inreg` specifies that the parameter is passed in a register.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inreg`指定参数在寄存器中传递。'
- en: '`byval` specifies that the parameter is passed by value. The parameter must
    be a pointer type. A hidden copy is made of the pointed-to data and this pointer
    is passed to the called function.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byval`指定参数按值传递。参数必须是指针类型。将指向数据的隐藏副本制作，并将此指针传递给被调用的函数。'
- en: '`zeroext` and `signext` specify that the passed integer value should be zero-
    or sign-extended.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeroext`和`signext`指定传递的整数值应该是零扩展或符号扩展。'
- en: '`sret` specifies that this parameter holds a pointer to memory that is used
    to return an aggregate type from the function.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sret`指定此参数保存一个指向用于从函数返回聚合类型的内存的指针。'
- en: 'While all code generators support the `zeroext`, `signext`, and `sret` attributes,
    only some support `inreg` and `byval`. An attribute can be added to the argument
    of a function with the `addAttr()` method. For example, to set the `inreg` attribute
    on the `Arg` argument, you call the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有代码生成器都支持`zeroext`、`signext`和`sret`属性，但只有一些支持`inreg`和`byval`。可以使用`addAttr()`方法将属性添加到函数的参数中。例如，要在`Arg`参数上设置`inreg`属性，可以调用以下方法：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To set multiple attributes, you can use the `llvm::AttrBuilder` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置多个属性，可以使用`llvm::AttrBuilder`类。
- en: 'The other way to provide additional information is to use type rewriting. With
    this approach, you disguise the original types. You can do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 提供额外信息的另一种方法是使用类型重写。通过这种方法，您可以伪装原始类型。您可以执行以下操作：
- en: Split the parameter; for example, instead of passing one complex argument, you
    can pass two floating-point arguments.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分参数；例如，不要传递一个复数参数，而是传递两个浮点参数。
- en: Cast the parameter into a different representation, for example, a struct of
    size 64 bits or less into an `i64` integer.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数转换为不同的表示形式，例如，将大小为64位或更小的结构体转换为`i64`整数。
- en: 'To cast between types without changing the bits of the value, you use the `bitcast`
    instruction. The `bitcast` instruction does not operate on aggregate types, but
    this is not a restriction as you can always use pointers. If a point is modeled
    as a struct with two `int` members, expressed as type `{ i32, i32 }` in LLVM,
    then this can be `bitcast` to `i64` in the following way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不改变值的位的情况下在类型之间转换，可以使用`bitcast`指令。`bitcast`指令不适用于聚合类型，但这并不是限制，因为您总是可以使用指针。如果将一个点建模为具有两个`int`成员的结构，在LLVM中表示为类型`{
    i32，i32 }`，那么可以以以下方式将其`bitcast`为`i64`：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This converts the pointer to the struct into a pointer to an `i64` integer value.
    Subsequently, you can load this value and pass it as a parameter. You must only
    make sure that both types have the same size.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指针转换为结构体的指针，然后可以加载此值并将其作为参数传递。您只需确保两种类型的大小相同即可。
- en: Adding attributes to an argument or changing the type is not complicated. But
    how do you know what you need to implement? First of all, you should get an overview
    of the calling convention used on your target platform. For example, the ELF ABI
    on Linux is documented for each supported CPU platform. Just look up the document
    and make yourself comfortable with it. There is documentation about the requirements
    of the LLVM code generators. The source of information is the Clang implementation,
    in the [https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp)
    file. This single file contains the ABI-specific actions for all supported platforms.
    It is also the single place where all information is collected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向参数添加属性或更改类型并不复杂。但是你怎么知道你需要实现什么？首先，你应该了解目标平台上使用的调用约定。例如，Linux上的ELF ABI针对每个支持的CPU平台都有文档记录。只需查阅文档并熟悉它。有关LLVM代码生成器的要求也有文档记录。信息来源是Clang实现，在[https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp)文件中。这个单一文件包含了所有支持平台的ABI特定操作。这也是所有信息被收集的唯一地方。
- en: In this section, you learned how to generate the IR for function calls to be
    compliant with the ABI of your platform. The next section covers the different
    ways to create IR for classes and virtual functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何生成符合平台ABI的函数调用的IR。下一节将介绍为类和虚函数创建IR的不同方法。
- en: Creating IR code for classes and virtual functions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为类和虚函数创建IR代码
- en: Many modern programming languages support object orientation using classes.
    A **class** is a high-level language construct, and in this section, we explore
    how we can map a class construct into LLVM IR.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言使用类支持面向对象编程。**类**是一个高级语言构造，在本节中，我们将探讨如何将类构造映射到LLVM IR中。
- en: Implementing single inheritance
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单继承
- en: 'A class is a collection of data and methods. A class can inherit from another
    class, potentially adding more data fields and methods or overriding existing
    virtual methods. Let''s illustrate this with classes in Oberon-2, which is also
    a good model for `tinylang`. A `Shape` class defines an abstract shape with a
    color and an area:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类是数据和方法的集合。一个类可以继承自另一个类，可能添加更多的数据字段和方法，或者覆盖现有的虚拟方法。让我们用Oberon-2中的类来说明这一点，这也是“tinylang”的一个很好的模型。一个“Shape”类定义了一个带有颜色和面积的抽象形状：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `GetColor` method only returns the color number:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “GetColor”方法只返回颜色编号：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The area of an abstract shape cannot be calculated, so this is an abstract
    method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象形状的面积无法计算，因此这是一个抽象方法：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Shape` type can be extended to represent a `Circle` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “Shape”类型可以扩展为表示“Circle”类：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For a circle, the area can be calculated:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个圆，可以计算出面积：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The type can also be queried at runtime. If `shape` is a variable of the `Shape`
    type, then we can formulate a type test in this way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类型也可以在运行时查询。如果“shape”是“Shape”类型的变量，那么我们可以这样制定类型测试：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The different syntax aside, this works much like in C++. One notable difference
    to C++ is that the Oberon-2 syntax makes the implicit `this` pointer explicit,
    calling it the receiver of a method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不同的语法之外，这与C++中的工作方式非常相似。与C++的一个显着区别是，Oberon-2的语法使隐式的“this”指针变得显式，称之为方法的接收者。
- en: 'The basic problems to solve are how to lay out a class in memory and how to
    implement the dynamic call of methods and runtime type checking. For the memory
    layout, this is quite easy. The `Shape` class has only one data member, and we
    can map it to a corresponding LLVM structure type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决的基本问题是如何在内存中布局一个类，以及如何实现方法的动态调用和运行时类型检查。对于内存布局来说，这是相当容易的。“Shape”类只有一个数据成员，我们可以将它映射到相应的LLVM结构类型：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Circle` class adds another data member. The solution is to append the
    new data member at the end:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: “Circle”类添加了另一个数据成员。解决方案是将新的数据成员追加到末尾：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The reason is that a class can have many subclasses. With this strategy, the
    data member of the common base class always has the same memory offset and also
    uses the same index to access the field via the `getelementptr` instruction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是一个类可以有许多子类。采用这种策略，共同基类的数据成员始终具有相同的内存偏移量，并且还使用相同的索引通过“getelementptr”指令访问字段。
- en: 'To implement a dynamic call of a method, we must further extend the LLVM structure.
    If the `Area()` function is called on a `Shape` object, then the abstract method
    is called, causing the application to halt. If it is called on a `Circle` object,
    then the corresponding method to calculate the area of a circle is called. The
    `GetColor()` function can be called for objects of both classes. The basic idea
    to implement this is to associate a table with function pointers with each object.
    Here, the table would have two entries: one for the `GetColor()` method and one
    for the `Area()` function. The `Shape` class and the `Circle` class each have
    such a table. The tables differ in the entry for the `Area()` function, which
    calls different code depending on the type of the object. This table is called
    the **virtual method table**, often abbreviated as the **vtable**.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现方法的动态调用，我们必须进一步扩展LLVM结构。如果在“Shape”对象上调用“Area()”函数，那么将调用抽象方法，导致应用程序停止。如果在“Circle”对象上调用它，那么将调用计算圆形面积的相应方法。“GetColor()”函数可以用于两个类的对象。实现这一点的基本思想是为每个对象关联一个带有函数指针的表。在这里，表将有两个条目：一个是“GetColor()”方法，另一个是“Area()”函数。“Shape”类和“Circle”类都有这样的表。这些表在“Area()”函数的条目上有所不同，根据对象的类型调用不同的代码。这个表被称为**虚方法表**，通常缩写为**vtable**。
- en: 'The vtable alone is not useful. We must connect it with an object. To do so,
    we add a pointer to the vtable always as the first data member to the structure.
    At the LLVM level, the `@Shape` type then becomes the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有vtable是没有用的。我们必须将其与对象连接起来。为此，我们将一个指向vtable的指针始终添加为结构的第一个数据成员。在LLVM级别上，“@Shape”类型然后变成了以下形式：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `@Circle` type is similarly extended. The resulting memory structure is
    shown in *Figure 6.1*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Circle`类型也类似扩展。结果的内存结构显示在*图6.1*中：'
- en: '![Figure 6.1 – Memory layout of the classes and the virtual method tables'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1-类和虚拟方法表的内存布局'
- en: '](img/Figure_6.1_B15647.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B15647.jpg)'
- en: Figure 6.1 – Memory layout of the classes and the virtual method tables
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1-类和虚拟方法表的内存布局
- en: LLVM does not have void pointers and pointers to bytes are used instead. With
    the introduction of the hidden `vtable` field, there is now also the need to have
    a way to initialize it. In C++, this is part of calling the constructor. In Oberon-2,
    the field is initialized automatically when the memory is allocated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM没有void指针，而是使用字节指针。引入隐藏的`vtable`字段后，现在也需要一种初始化它的方法。在C++中，这是调用构造函数的一部分。在Oberon-2中，当分配内存时，该字段会自动初始化。
- en: 'A dynamic call to a method is then executed with the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行动态调用方法的步骤如下：
- en: Calculate the offset of the vtable pointer via the `getelementptr` instruction.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`getelementptr`指令计算vtable指针的偏移量。
- en: Load the pointer to the vtable.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载vtable的指针。
- en: Calculate the offset of the function in the vtable.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算函数在vtable中的偏移量。
- en: Load the function pointer.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载函数指针。
- en: Indirectly call the function via the pointer with the `call` instruction.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`call`指令间接调用函数。
- en: This does not sound very efficient, but in fact, most CPU architectures can
    perform this dynamic call in just two instructions. So, it is really the LLVM
    level that is verbose.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来并不是很高效，但事实上，大多数CPU架构可以在只有两条指令的情况下执行这个动态调用。因此，这实际上是LLVM级别的冗长。
- en: To turn a function into a method, a reference to the object's data is required.
    This is implemented by passing the pointer to the data as the first parameter
    of the method. In Oberon-2, this is the explicit receiver. In languages similar
    to C++, it is the implicit `this` pointer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数转换为方法，需要对象数据的引用。这是通过将数据指针作为方法的第一个参数来实现的。在Oberon-2中，这是显式的接收者。在类似于C++的语言中，这是隐式的`this`指针。
- en: With the vtable, we have a unique address in memory for each class. Does this
    help with the runtime type test, too? The answer is that it helps only in a limited
    way. To illustrate the problem, let's extend the class hierarchy with an `Ellipse`
    class, which inherits from the `Circle` class. (This is not the classical *is-a*
    relationship in the mathematical sense.) If we have the `shape` variable of the
    `Shape` type, then we could implement the `shape IS Circle` type test as a comparison
    of the vtable pointer stored in the `shape` variable with the vtable pointer of
    the `Circle` class. This comparison only results in `true` if `shape` has the
    exact `Circle` type. But if `shape` is indeed of the `Ellipse` type, then the
    comparison returns `false`, even if an object of the `Ellipse` type can be used
    in all places where only an object of the `Circle` type is required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有了vtable，我们对每个类在内存中都有一个唯一的地址。这对运行时类型测试有帮助吗？答案是只有在有限的范围内有帮助。为了说明问题，让我们通过一个`Ellipse`类扩展类层次结构，它继承自`Circle`类。（这不是数学意义上的经典*is-a*关系。）如果我们有`Shape`类型的`shape`变量，那么我们可以将`shape
    IS Circle`类型测试实现为将存储在`shape`变量中的vtable指针与`Circle`类的vtable指针进行比较。只有当`shape`确实具有`Circle`类型时，比较才会返回`true`。但如果`shape`确实是`Ellipse`类型，那么比较会返回`false`，即使`Ellipse`类型的对象可以在只需要`Circle`类型的对象的所有地方使用。
- en: 'Clearly, we need to do more. The solution is to extend the virtual method table
    with runtime type information. How much information you need to store depends
    on the source language. To support the runtime type check, it is enough to store
    a pointer to the vtable of the base class, which then looks as in *Figure 6.2*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要做更多的工作。解决方案是使用运行时类型信息扩展虚拟方法表。需要存储多少信息取决于源语言。为了支持运行时类型检查，只需存储指向基类vtable的指针，然后看起来像*图6.2*：
- en: '![Figure 6.2 – Class and vtable layout supporting simple type tests'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2-支持简单类型测试的类和vtable布局'
- en: '](img/Figure_6.2_B15647.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B15647.jpg)'
- en: Figure 6.2 – Class and vtable layout supporting simple type tests
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2-支持简单类型测试的类和vtable布局
- en: If the test fails as described earlier, then the test is repeated with the pointer
    to the vtable of the base class. This is repeated until the test yields `true`
    or, if there is no base class, `false`. In contrast to calling a dynamic function,
    the type test is a costly operation, because in the worst case, the inheritance
    hierarchy is walked up to the root class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像之前描述的那样测试失败，那么就会用基类的vtable指针重复测试。这将重复进行，直到测试产生`true`，或者如果没有基类，则产生`false`。与调用动态函数不同，类型测试是一个昂贵的操作，因为在最坏的情况下，继承层次结构会一直向上走到根类。
- en: 'If you know the whole class hierarchy, then an efficient approach is possible:
    you number each member of the class hierarchy in depth-first order. Then, the
    type test becomes a comparison against a number or an interval, which can be done
    in constant time. In fact, that is the approach of LLVM''s own runtime type test,
    which we learned about in the previous chapter.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道整个类层次结构，那么可以采用高效的方法：对类层次结构的每个成员进行深度优先编号。然后，类型测试变成了与数字或区间的比较，可以在常数时间内完成。事实上，这就是LLVM自己的运行时类型测试的方法，我们在上一章中了解到了。
- en: Coupling runtime type information with the vtable is a design decision, either
    mandated by the source language or just an implementation detail. For example,
    if you need detailed runtime type information, because the source language supports
    reflection at runtime, and you have data types without a vtable, then coupling
    both is not a good idea. In C++, the coupling results in the fact that a class
    with virtual functions (and therefore no vtable) has no runtime type data attached
    to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将运行时类型信息与vtable耦合是一个设计决策，要么是源语言规定的，要么只是一个实现细节。例如，如果你需要详细的运行时类型信息，因为源语言支持运行时反射，并且你有没有vtable的数据类型，那么耦合两者并不是一个好主意。在C++中，耦合导致一个具有虚函数（因此没有vtable）的类没有附加的运行时类型数据。
- en: Often, programming languages support interfaces, which are a collection of virtual
    methods. Interfaces are important because they add a useful abstraction. We will
    look at possible implementations of interfaces in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编程语言支持接口，它们是一组虚拟方法。接口很重要，因为它们增加了一个有用的抽象。我们将在下一节中看看接口的可能实现。
- en: Extending single inheritance with interfaces
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过接口扩展单一继承
- en: Languages such as **Java** support interfaces. An interface is a collection
    of abstract methods, comparable to a base class with no data members and only
    abstract methods defined. Interfaces pose an interesting problem because each
    class implementing an interface can have the corresponding method at a different
    position in the vtable. The reason is simply that the order of function pointers
    in the vtable is derived from the order of the functions in the class definition
    in the source language. The definition in the interface is independent of this,
    and different orders are the norm.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如**Java**之类的语言支持接口。接口是一组抽象方法，类似于没有数据成员且只定义了抽象方法的基类。接口提出了一个有趣的问题，因为实现接口的每个类可以在vtable中的不同位置具有相应的方法。原因很简单，vtable中函数指针的顺序是从源语言中类定义中函数的顺序派生的。接口中的定义与此无关，不同的顺序是正常的。
- en: 'Because the methods defined in an interface can have a different order, we
    attach a table for each implemented interface to the class. For each method of
    the interface, this table can specify either the index of the method in the vtable
    or can be a copy of the function pointer stored in the vtable. If a method is
    called on the interface, then the corresponding vtable of the interface is searched,
    then the pointer to the function is fetched and the method is called. Adding two
    interfaces, `I1` and `I2`, to the `Shape` class results in the following layout:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为接口中定义的方法可以有不同的顺序，我们将每个实现的接口附加到类上。对于接口的每个方法，此表可以指定vtable中方法的索引，或者可以是存储在vtable中的函数指针的副本。如果在接口上调用方法，那么将搜索接口的相应vtable，然后获取函数指针并调用方法。将两个接口`I1`和`I2`添加到`Shape`类中会得到以下布局：
- en: '![Figure 6.3 – Layout of vtables for interfaces'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 接口vtable的布局'
- en: '](img/Figure_6.3_B15647.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B15647.jpg)'
- en: Figure 6.3 – Layout of vtables for interfaces
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 接口vtable的布局
- en: 'The caveat lies in the fact that we have to find the right vtable. We can use
    an approach similar to the *runtime type test*: we can perform a linear search
    through the list of interface vtables. We can assign a unique number to each interface
    (for example, a memory address) and identify the vtable using this number. The
    disadvantage of this scheme is obvious: calling a method through an interface
    takes much more time than calling the same method on the class. There is no easy
    mitigation for this problem.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 警告在于我们必须找到正确的vtable。我们可以使用类似于*运行时类型测试*的方法：我们可以通过接口vtable列表执行线性搜索。我们可以为每个接口分配一个唯一的数字（例如，内存地址），并使用此数字来识别vtable。这种方案的缺点是显而易见的：通过接口调用方法比在类上调用相同的方法需要更多的时间。对于这个问题并没有简单的缓解方法。
- en: A good approach is to replace the linear search with a hash table. At compile
    time, the interface that a class implements is known. Therefore, we can construct
    a perfect hash function, which maps the interface number to the vtable for the
    interface. A known unique number identifying an interface may be needed for the
    construction, so memory does not help. But there are other ways to compute a unique
    number. If the symbol names in the source are unique, then it is always possible
    to compute a cryptographic hash such as the `MD5` of the symbol and use the hash
    as the number. The calculation occurs at compile time and therefore has no runtime
    cost.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的方法是用哈希表替换线性搜索。在编译时，已知类实现的接口。因此，我们可以构造一个完美的哈希函数，将接口号映射到接口的vtable。可能需要一个已知的唯一标识接口的数字来进行构造，以便内存不会有帮助。但是还有其他计算唯一数字的方法。如果源中的符号名称是唯一的，那么总是可以计算出诸如`MD5`之类的加密哈希，并将哈希用作数字。计算发生在编译时，因此没有运行时成本。
- en: The result is much faster than the linear search and only takes constant time.
    Still, it involves several arithmetic operations on a number and is slower than
    the method call of a class type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果比线性搜索快得多，只需要常数时间。但是，它涉及对数字进行多次算术运算，比类类型的方法调用慢。
- en: Usually, interfaces also take part in runtime type tests, making the list to
    search even longer. Of course, if the hash table approach is implemented, then
    it can also be used for the runtime type test.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，接口也参与运行时类型测试，使得搜索列表变得更长。当然，如果实现了哈希表方法，那么它也可以用于运行时类型测试。
- en: Some languages allow more than one parent class. This has some interesting challenges
    for the implementation, and we master this in the next section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言允许有多个父类。这对实现有一些有趣的挑战，我们将在下一节中掌握这些挑战。
- en: Adding support for multiple inheritance
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对多重继承的支持
- en: 'Multiple inheritance adds another challenge. If a class inherits from two or
    more base classes, then we need to combine the data members in such a way that
    they are still accessible from the methods. Like in the single inheritance case,
    the solution is to append all data members, including the hidden vtable pointers.
    The `Circle` class is not only a geometric shape but also a graphic object. To
    model this, we let the `Circle` class inherit from the `Shape` class and the `GraphicObj`
    class. In the class layout, the fields from the `Shape` class come first. Then,
    we append all fields of the `GraphicObj` class, including the hidden vtable pointer.
    After that, we add the new data members of the `Circle` class, resulting in the
    overall structure shown in *Figure 6.4*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承增加了另一个挑战。如果一个类从两个或更多的基类继承，那么我们需要以这样的方式组合数据成员，以便它们仍然可以从方法中访问。就像单一继承的情况一样，解决方案是追加所有数据成员，包括隐藏的vtable指针。`Circle`类不仅是一个几何形状，还是一个图形对象。为了模拟这一点，我们让`Circle`类继承自`Shape`类和`GraphicObj`类。在类布局中，`Shape`类的字段首先出现。然后，我们追加`GraphicObj`类的所有字段，包括隐藏的vtable指针。之后，我们添加`Circle`类的新数据成员，得到了*图6.4*中显示的整体结构：
- en: '![Figure 6.4 – Layout of classes and vtables with multiple inheritance'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 - 具有多重继承的类和vtable的布局'
- en: '](img/Figure_6.4_B15647.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B15647.jpg)'
- en: Figure 6.4 – Layout of classes and vtables with multiple inheritance
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 - 具有多重继承的类和vtable的布局
- en: This approach has several implications. There can now be several pointers to
    the object. A pointer to the `Shape` or `Circle` class points to the top of the
    object, while a pointer to a `GraphicObj` class points to inside this object,
    to the beginning of the embedded `GraphicObj` object. This has to be taken into
    account when comparing pointers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个影响。现在可以有几个指向对象的指针。指向`Shape`或`Circle`类的指针指向对象的顶部，而指向`GraphicObj`类的指针指向对象的内部，指向嵌入的`GraphicObj`对象的开头。在比较指针时必须考虑到这一点。
- en: 'Calling a virtual method is also affected. If a method is defined in the `GraphicObj`
    class, then this method expects the class layout of the `GraphicObj` class. If
    this method is not overridden in the `Circle` class, then there are two possibilities.
    The easy case is if the method call is done with a pointer to a `GraphicObj` instance:
    in this case, you look up the address of the method in the vtable of the `GraphicObj`
    class and call the function. The more complicated case is if you call the method
    with a pointer to the `Circle` class. Again, you can look up the address of the
    method in the vtable of the `Circle` class. The called method expects a `this`
    pointer to an instance of the `GraphicObj` class, so we have to adjust that pointer,
    too. We can do this because we know the offset of the `GraphicObj` class inside
    the `Circle` class.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 调用虚方法也会受到影响。如果一个方法在`GraphicObj`类中定义，那么这个方法期望`GraphicObj`类的类布局。如果这个方法在`Circle`类中没有被覆盖，那么有两种可能性。简单的情况是，如果方法调用是通过指向`GraphicObj`实例的指针完成的：在这种情况下，你在`GraphicObj`类的vtable中查找方法的地址并调用该函数。更复杂的情况是，如果你用指向`Circle`类的指针调用该方法。同样，你可以在`Circle`类的vtable中查找方法的地址。被调用的方法期望一个指向`GraphicObj`类实例的`this`指针，所以我们也必须调整该指针。我们可以做到这一点，因为我们知道`GraphicObj`类在`Circle`类内部的偏移量。
- en: 'If a method of `GrapicObj` is overridden in the `Circle` class, then nothing
    special needs to be done if the method is called through a pointer to the `Circle`
    class. However, if the method is called through a pointer to a `GraphicObj` instance,
    then we need to make another adjustment because the method needs a `this` pointer
    pointing to a `Circle` instance. At compile time, we cannot compute this adjustment,
    because we do not know whether this `GraphicObj` instance is part of a multiple
    inheritance hierarchy or not. To solve this, we store the adjustment we need to
    make to the `this` pointer before calling the method together with each function
    pointer in the vtable, as in *Figure 6.5*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`GrapicObj`的方法在`Circle`类中被覆盖，那么如果通过指向`Circle`类的指针调用该方法，则不需要做任何特殊处理。然而，如果通过指向`GraphicObj`实例的指针调用该方法，那么我们需要进行另一个调整，因为该方法需要一个指向`Circle`实例的`this`指针。在编译时，我们无法计算这个调整，因为我们不知道这个`GraphicObj`实例是否是多重继承层次结构的一部分。为了解决这个问题，我们在vtable中的每个函数指针一起存储我们需要对`this`指针进行的调整，在*图6.5*中显示。
- en: '![Figure 6.5 – vtable with adjustments to the this pointer'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 - 具有对this指针的调整的vtable'
- en: '](img/Figure_6.5_B15647.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.5_B15647.jpg)'
- en: Figure 6.5 – vtable with adjustments to the this pointer
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - 具有对this指针的调整的vtable
- en: 'The method call now becomes the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方法调用变成了以下形式：
- en: Look up the function pointer in the vtable.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在vtable中查找函数指针。
- en: Adjust the `this` pointer.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`this`指针。
- en: Call the method.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法。
- en: 'This approach can also be used for implementing interfaces. Because an interface
    has only methods, each implemented interface adds a new vtable pointer to the
    object. This is easier to implement and most likely faster, but it adds overhead
    to each object instance. In the worst case, if your class has a single 64-bit
    data field but implements 10 interfaces, then your object requires 96 bytes in
    memory: 8 bytes for the vtable pointer of the class itself, 8 bytes for the data
    member, and 10 * 8 bytes for the vtable pointers of each interface.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也可以用于实现接口。因为接口只有方法，每个实现的接口都会向对象添加一个新的vtable指针。这样做更容易实现，而且很可能更快，但它会给每个对象实例增加开销。在最坏的情况下，如果你的类有一个单独的64位数据字段，但实现了10个接口，那么你的对象在内存中需要96字节：8字节用于类本身的vtable指针，8字节用于数据成员，以及每个接口的10
    * 8字节的vtable指针。
- en: To support meaningful comparisons to objects and to perform runtime type tests,
    it is needed to normalize a pointer to an object first. If we add an additional
    field to the vtable, containing an offset at the top of the object, then we can
    always adjust the pointer to point to the real object. In the vtable of the `Circle`
    class, this offset is `0`, but not in the vtable of the embedded `GraphicObj`
    class. Of course, whether this needs to be implemented depends on the semantics
    of the source language.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持与对象的有意义比较并执行运行时类型测试，需要首先将指针规范化为对象。如果我们在vtable中添加一个额外的字段，其中包含对象顶部的偏移量，那么我们就可以始终调整指针指向真正的对象。在`Circle`类的vtable中，这个偏移量是`0`，但在嵌入的`GraphicObj`类的vtable中不是。当然，是否需要实现这一点取决于源语言的语义。
- en: LLVM itself does not favor a special implementation of object-oriented features.
    As seen in this section, we can implement all approaches with the available LLVM
    data types. If you want to try a new approach, then a good way is to do a prototype
    in C first. The required pointer manipulations are quickly translated to LLVM
    IR, but reasoning about the functionality is easier in a higher-level language.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM本身不偏向于面向对象特性的特殊实现。正如在本节中所看到的，我们可以使用现有的LLVM数据类型来实现所有方法。如果你想尝试一种新的方法，那么一个好的方式是先在C中做一个原型。所需的指针操作很快就能转换为LLVM
    IR，但在高级语言中推理功能更容易。
- en: With the knowledge acquired in this section, you can implement the lowering
    of all OOP constructs commonly found in programming languages into LLVM IR in
    your own code generator. You have recipes on how to represent single inheritance,
    single inheritance with an interface, or multiple inheritance in memory, and also
    how to implement type tests and how to look up virtual functions, which are the
    core concepts of OOP languages.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节学到的知识，你可以在自己的代码生成器中将编程语言中常见的所有面向对象编程构造降低为LLVM IR。你已经知道了如何表示内存中的单继承、带接口的单继承或多重继承，以及如何实现类型测试和查找虚拟函数，这些都是面向对象语言的核心概念。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to translate aggregate data types and pointers
    to LLVM IR code. You also learned about the intricacies of the ABI. Finally, you
    learned about the different approaches to translating classes and virtual functions
    to LLVM IR. With the knowledge of this chapter, you will be able to create an
    LLVM IR code generator for most real programming languages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将聚合数据类型和指针转换为LLVM IR代码。你还了解了ABI的复杂性。最后，你了解了将类和虚拟函数转换为LLVM IR的不同方法。有了本章的知识，你将能够为大多数真实编程语言创建一个LLVM
    IR代码生成器。
- en: In the next chapter, you will learn about some advanced techniques. Exception
    handling is fairly common in modern programming languages, and LLVM has some support
    for it. Attaching type information to pointers can help with certain optimizations,
    so we will add this, too. Last but not least, the ability to debug an application
    is essential for many developers, so we will add the generation of debug metadata
    to our code generator.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习一些高级技术。异常处理在现代编程语言中非常常见，LLVM对此提供了一些支持。将类型信息附加到指针可以帮助进行某些优化，所以我们也会添加这个功能。最后但同样重要的是，调试应用程序的能力对许多开发人员来说是至关重要的，因此我们将为我们的代码生成器添加调试元数据的生成。
