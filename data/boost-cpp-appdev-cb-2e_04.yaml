- en: Compile-Time Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时技巧
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Checking sizes at compile time
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时检查大小
- en: Enabling function template usage for integral types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为整数类型启用函数模板使用
- en: Disabling function template usage for real types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用真实类型的函数模板使用
- en: Creating a type from a number
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数字创建一个类型
- en: Implementing a type trait
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个类型特征
- en: Selecting an optimal operator for a template parameter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模板参数选择最佳操作符
- en: Getting a type of expression in C++03
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++03中获取表达式的类型
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll see some basic examples on how the Boost libraries can
    be used in compile-time checking, for tuning algorithms, and in other metaprogramming
    tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些基本的例子，说明Boost库如何在编译时检查、调整算法和其他元编程任务中使用。
- en: Some readers may ask, *"Why should we care about compile-time things?"* That's
    because the released version of the program is compiled once and runs multiple
    times. The more we do at compile time, the less work remains for runtime, resulting
    in much faster and reliable programs. Runtime checks are executed only if a part
    of the code with the check is executed. Compile-time checks will prevent your
    program from compiling, ideally with a meaningful compiler error message.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会问，"为什么我们要关心编译时的事情？"那是因为程序的发布版本只编译一次，运行多次。我们在编译时做的越多，运行时剩下的工作就越少，从而产生更快速和可靠的程序。运行时检查只有在执行带有检查的代码部分时才会执行。编译时检查将阻止您的程序编译，理想情况下会有有意义的编译器错误消息。
- en: This chapter is possibly one of the most important. Understanding Boost sources
    and other Boost-like libraries is impossible without it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章可能是最重要的之一。如果没有理解Boost源码和其他类似Boost的库，是不可能的。
- en: Checking sizes at compile time
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译时检查大小
- en: 'Let''s imagine that we are writing some serialization function that stores
    values in a buffer of a specified size:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一些序列化函数，将值存储在指定大小的缓冲区中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code has the following problems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有以下问题：
- en: The size of the buffer is not checked, so it may overflow
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区的大小没有被检查，所以可能会溢出
- en: This function can be used with **non-trivially copyable** types, which would
    lead to incorrect behavior
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数可以用于**非平凡可复制**类型，这可能导致不正确的行为
- en: 'We may partially fix it by adding some asserts, for example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一些断言来部分修复它，例如：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But, this is a bad solution. Runtime checks do not trigger the assert during
    testing in the debug mode if the function was not called. Runtime checks may even
    be optimized out in the release mode, so very bad things may happen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是一个不好的解决方案。如果函数没有被调用，调试模式下的运行时检查不会触发断言。在发布模式下，运行时检查甚至可能被优化掉，所以可能会发生非常糟糕的事情。
- en: '`BufSizeV` and `sizeof(value)` values are known at compile time. It means that,
    instead of having a runtime assert, we can force this code to fail compilation
    if the buffer is too small.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufSizeV`和`sizeof(value)`的值在编译时是已知的。这意味着，我们可以强制这段代码在缓冲区太小的情况下失败编译，而不是有一个运行时断言。'
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires some knowledge of C++ templates and the `Boost.Array` library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法需要一些关于C++模板和`Boost.Array`库的知识。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s use `Boost.StaticAssert` and `Boost.TypeTraits` libraries to correct
    the solution. Here''s how:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Boost.StaticAssert`和`Boost.TypeTraits`库来纠正解决方案。下面是方法：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BOOST_STATIC_ASSERT` macro can be used only if an assert expression can
    be evaluated at compile time and is implicitly convertible to `bool`. It means
    that you may only use `sizeof()`, static constants, constexpr variables, constexpr
    functions with parameters known at compile time, and other constant expressions
    in `BOOST_STATIC_ASSERT`. If assert expression evaluates to `false`, `BOOST_STATIC_ASSERT`
    will stop compilation. In the case of a `serialize` function, if the first static
    assertion fails, it means that the user misused the `serialize` function and provided
    a very small buffer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSERT`宏只能在断言表达式可以在编译时评估并且可以隐式转换为`bool`时使用。这意味着您只能在`BOOST_STATIC_ASSERT`中使用`sizeof()`、静态常量、constexpr变量、在编译时已知参数的constexpr函数和其他常量表达式。如果断言表达式评估为`false`，`BOOST_STATIC_ASSERT`将停止编译。在`serialize`函数的情况下，如果第一个静态断言失败，这意味着用户错误使用了`serialize`函数并提供了一个非常小的缓冲区。'
- en: 'Here are some more examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the `BOOST_STATIC_ASSERT` macro's assert expression has a comma sign in it,
    we must wrap the whole expression in additional brackets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BOOST_STATIC_ASSERT`宏的断言表达式中有逗号，我们必须用额外的括号将整个表达式包起来。
- en: The last example is very close to what we can see on the second line of the
    `serialize()` function. So now, it is time to discover more about the `Boost.TypeTraits`
    library. This library provides a large number of compile-time metafunctions that
    allow us to get information about types and modify types. The metafunctions usages
    look like `boost::function_name<parameters>::value` or `boost::function_name<parameters>::type`.
    The metafunction `boost::has_trivial_copy<T>::value` returns `true` only if `T`
    is a simple copyable type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子非常接近我们在`serialize()`函数的第二行看到的内容。现在是时候更多地了解`Boost.TypeTraits`库了。这个库提供了大量的编译时元函数，允许我们获取有关类型的信息并修改类型。元函数的用法看起来像`boost::function_name<parameters>::value`或`boost::function_name<parameters>::type`。元函数`boost::has_trivial_copy<T>::value`只有在`T`是一个简单可复制的类型时才返回`true`。
- en: 'Let''s take a look at some more examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一些例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Some compilers may compile this code even without the `typename` keyword, but
    such behavior violates the C++ standard, so it is highly recommended to write
    `typename`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器甚至可以在没有`typename`关键字的情况下编译这段代码，但这种行为违反了C++标准，因此强烈建议写上`typename`。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `BOOST_STATIC_ASSSERT` macro has a more verbose variant called `BOOST_STATIC_ASSSERT_MSG`
    that tries hard to output an error message in the compiler log (or in the IDE
    window) if assertion fails. Take a look at the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSSERT`宏有一个更冗长的变体，称为`BOOST_STATIC_ASSSERT_MSG`，如果断言失败，它会尝试在编译器日志（或IDE窗口）中输出错误消息。看一下下面的代码：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code will give the following result during compilation on the
    g++ compiler in the C++11 mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 模式下，使用 g++ 编译器编译上述代码将得到以下结果：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Neither `BOOST_STATIC_ASSSERT`, nor `BOOST_STATIC_ASSSERT_MSG`, nor any of the
    type traits entity implies a runtime penalty. All these functions are executed
    at compile time and do not add a single assembly instruction to the resulting
    binary file. The C++11 standard has `static_assert(condition, "message")` that
    is equivalent to Boost's `BOOST_STATIC_ASSSERT_MSG`. The `BOOST_STATIC_ASSERT`
    functionality of asserting at compile time without a user provided message is
    available in C++17 as `static_assert(condition)`. You do not have to include header
    files to be able to use your compiler built in `static_assert`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_ASSSERT`，`BOOST_STATIC_ASSSERT_MSG` 或任何类型特征实体都不会导致运行时惩罚。所有这些函数都在编译时执行，不会向生成的二进制文件添加任何汇编指令。C++11
    标准具有`static_assert(condition, "message")`，它等效于 Boost 的 `BOOST_STATIC_ASSSERT_MSG`。C++17
    中提供了在编译时断言而无需用户提供消息的`BOOST_STATIC_ASSERT`功能。您不必包含头文件即可使用编译器内置的`static_assert`。'
- en: The `Boost.TypeTraits` library was partially accepted into the C++11 standard.
    You may thus find traits in the `<type_traits>` header in the `std::` namespace.
    C++11 `<type_traits>` has some functions that do not exist in `Boost.TypeTraits`,
    but some other metafunctions exist only in Boost. Metafunctions that have a name
    starting with `has_` are renamed in the standard library to metafunctions with
    names starting with `is_`. Thus, `has_trivial_copy` became `is_trivially_copyable`
    and so forth.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.TypeTraits` 库部分被接受到 C++11 标准中。因此，您可以在 `std::` 命名空间的 `<type_traits>`
    头文件中找到特征。C++11 `<type_traits>` 具有一些在 `Boost.TypeTraits` 中不存在的函数，但是一些其他元函数只存在于
    Boost 中。以`has_`开头的元函数在标准库中被重命名为以`is_`开头的元函数。因此，`has_trivial_copy` 变成了 `is_trivially_copyable`
    等等。'
- en: 'C++14 and Boost 1.65 have shortcuts for all the type traits that have a `::type`
    member. Those shortcuts allow you to write `remove_const_t<T1>` instead of `typename
    remove_const<T1>::type`. Note that, in the case of Boost 1.65, the shortcuts require
    a C++11 compatible compiler as they could be implemented only using **type aliases**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++14 和 Boost 1.65 为所有具有 `::type` 成员的类型特征提供了快捷方式。这些快捷方式允许您编写 `remove_const_t<T1>`
    而不是 `typename remove_const<T1>::type`。请注意，在 Boost 1.65 的情况下，这些快捷方式需要一个兼容 C++11
    的编译器，因为它们只能使用**类型别名**来实现：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'C++17 added `_v` shortcuts for type traits that have `::value`. Since C++17,
    you can just write `std::is_unsigned_v<T1>` instead of `std::is_unsigned<T1>::value`.
    This trick is usually implemented using `variable templates`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 为具有 `::value` 的类型特征添加了 `_v` 快捷方式。自 C++17 起，您可以只写 `std::is_unsigned_v<T1>`
    而不是 `std::is_unsigned<T1>::value`。这个技巧通常是使用`变量模板`来实现的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When there is a similar trait in Boost and in the standard library, do opt for
    the Boost version if you are writing a project that must work on a pre-C++11 compilers.
    Otherwise, the standard library version may work slightly better, in rare cases.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Boost 和标准库中存在类似的特征时，如果您正在编写必须在 C++11 之前的编译器上工作的项目，请选择 Boost 版本。否则，在极少数情况下，标准库版本可能效果稍好。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipes in this chapter will give you more examples and ideas of how
    static asserts and type traits may be used.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的下一个示例将为您提供更多示例和想法，说明静态断言和类型特征可以如何使用。
- en: 'Read the official documentation of `Boost.StaticAssert` for more examples at:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读`Boost.StaticAssert`的官方文档，了解更多示例：
- en: '[http://boost.org/libs/static_assert.](http://boost.org/libs/static_assert)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://boost.org/libs/static_assert.](http://boost.org/libs/static_assert)'
- en: Enabling function template usage for integral types
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为整数类型启用函数模板使用
- en: 'It''s a common situation, when we have a class template that implements some
    functionality:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的情况，当我们有一个实现某些功能的类模板时：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, imagine that we have two additional versions of that class, one for integral,
    and another for real types:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，我们有该类的另外两个版本，一个用于整数，另一个用于实数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the question: How to make the compiler to automatically choose the correct
    class for a specified type?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：如何使编译器自动为指定类型选择正确的类？
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires some knowledge of C++ templates.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例需要一些 C++ 模板知识。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll be using `Boost.Core` and `Boost.TypeTraits` to resolve the problem:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Boost.Core` 和 `Boost.TypeTraits` 来解决这个问题：
- en: 'Let''s start by including headers:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包含头文件开始：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s add an additional template parameter with a default value to our generic
    implementation:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向我们的通用实现添加一个带有默认值的额外模板参数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Modify optimized versions in the following way, so that now they will now be
    treated by the compiler as template partial specializations:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改优化版本如下，现在它们将被编译器视为模板部分特化：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And, that''s it! Now, the compiler will automatically choose the correct class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！现在，编译器将自动选择正确的类：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::enable_if_c` template is a tricky one. It makes use of the **Substitution
    Failure Is Not An Error** (**SFINAE**) principle, which is used during **template
    instantiation**. This is how the principle works; if an invalid argument or return
    type is formed during the instantiation of a function or class template, the instantiation
    is removed from the overload resolution set and does not cause a compilation error.
    Now the tricky part, `boost::enable_if_c<true>` has a member type accessible via
    `::type`, but `boost::enable_if_c<false>` has no `::type`. Let's get back to our
    solution and see how the SFINAE works with different types passed to the `data_processor`
    class as the `T` parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::enable_if_c` 模板是一个棘手的模板。它利用了**替换失败不是错误**（**SFINAE**）原则，该原则在**模板实例化**期间使用。这就是原则的工作方式；如果在函数或类模板的实例化过程中形成了无效的参数或返回类型，则该实例化将从重载解析集中移除，并且不会导致编译错误。现在棘手的部分是，`boost::enable_if_c<true>`
    有一个通过 `::type` 访问的成员类型，但 `boost::enable_if_c<false>` 没有 `::type`。让我们回到我们的解决方案，看看
    SFINAE 如何与作为 `T` 参数传递给 `data_processor` 类的不同类型一起使用。'
- en: If we pass an `int` as the `T` type, first the compiler will try to instantiate
    template partial specializations from *step 3*, before using our nonspecialized
    generic version. When it tries to instantiate a `float` version, the `boost::is_float<T>::value`
    metafunction returns `false`. The `boost::enable_if_c<false>::type` metafunction
    cannot be correctly instantiated because `boost::enable_if_c<false>` has no `::type`,
    and that is the place where SFINAE acts. Because the class template cannot be
    instantiated, this must be interpreted as not an error, compiler skips this template
    specialization. The next partial specialization is the one that is optimized for
    integral types. The `boost::is_integral<T>::value` metafunction returns `true`,
    and `boost::enable_if_c<true>::type` can be instantiated, which makes it possible
    to instantiate the whole `data_processor` specialization. The compiler found a
    matching partial specialization, so it does not need to try to instantiate the
    nonspecialized method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `int` 作为 `T` 类型传递，首先编译器将尝试从 *步骤 3* 实例化模板部分特化，然后再使用我们的非特定通用版本。当它尝试实例化一个
    `float` 版本时，`boost::is_float<T>::value` 元函数返回 `false`。`boost::enable_if_c<false>::type`
    元函数无法正确实例化，因为 `boost::enable_if_c<false>` 没有 `::type`，这就是 SFINAE 起作用的地方。因为无法实例化类模板，这必须被解释为不是错误，编译器跳过这个模板特化。下一个部分特化是针对整数类型进行优化的。`boost::is_integral<T>::value`
    元函数返回 `true`，并且可以实例化 `boost::enable_if_c<true>::type`，这使得整个 `data_processor` 特化可以实例化。编译器找到了匹配的部分特化，因此不需要尝试实例化非特定方法。
- en: Now, let's try to pass some nonarithmetic type (for example, `const char *`),
    and let's see what the compiler will do. First, the compiler tries to instantiate
    template partial specializations. The specializations with `is_float<T>::value`
    and `is_integral<T>::value` fail to instantiate, so the compiler tries to instantiate
    our generic version and succeeds.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试传递一些非算术类型（例如 `const char *`），看看编译器会做什么。首先，编译器尝试实例化模板部分特化。具有 `is_float<T>::value`
    和 `is_integral<T>::value` 的特化无法实例化，因此编译器尝试实例化我们的通用版本并成功。
- en: Without `boost::enable_if_c<>`, all the partially specialized versions may be
    instantiated at the same time for any type, which leads to ambiguity and failed
    compilation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `boost::enable_if_c<>`，所有部分特化版本可能会同时实例化为任何类型，这会导致模糊和编译失败。
- en: If you are using templates and compiler reports that cannot choose between two
    template classes of methods, you probably need `boost::enable_if_c<>`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用模板，并且编译器报告无法在两个模板类或方法之间进行选择，那么您可能需要 `boost::enable_if_c<>`。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another version of this method is called `boost::enable_if` without `_c` at
    the end. The difference between them is that `enable_if_c` accepts constant as
    a template parameter; the short version accepts an object that has a `value` static
    member. For example, `boost::enable_if_c<boost::is_integral<T>::value >::type`
    is equal to `boost::enable_if<boost::is_integral<T> >::type`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的另一个版本称为 `boost::enable_if`，末尾没有 `_c`。它们之间的区别在于 `enable_if_c` 接受常量作为模板参数；短版本接受具有
    `value` 静态成员的对象。例如，`boost::enable_if_c<boost::is_integral<T>::value >::type` 等于
    `boost::enable_if<boost::is_integral<T> >::type`。
- en: Before Boost 1.56 the `boost::enable_if` metafunctions were defined in the header
    `<boost/utility/enable_if.hpp>` instead of `<boost/core/enable_if.hpp>`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost 1.56 之前，`boost::enable_if` 元函数定义在头文件 `<boost/utility/enable_if.hpp>`
    中，而不是 `<boost/core/enable_if.hpp>`。
- en: C++11 has `std::enable_if` defined in the `<type_traits>` header, which behaves
    exactly like `boost::enable_if_c`. No difference between them exists, except that
    Boost's version works on non C++11 compilers too, providing better portability.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 在 `<type_traits>` 头文件中定义了 `std::enable_if`，它的行为与 `boost::enable_if_c`
    完全相同。它们之间没有区别，只是 Boost 的版本也适用于非 C++11 编译器，提供更好的可移植性。
- en: 'C++14 has a shortcut `std::enable_if_t` that must be used without `typename`
    and `::type`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C++14 中有一个快捷方式 `std::enable_if_t`，它必须在没有 `typename` 和 `::type` 的情况下使用：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the enabling functions are executed only at compile time and do not add
    a performance overhead at runtime. However, adding an additional template parameter
    may produce a bigger classname in `typeid(your_class).name()`, and add an extremely
    tiny performance overhead while comparing two `typeid()` results on some platforms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有启用函数仅在编译时执行，不会在运行时增加性能开销。但是，添加额外的模板参数可能会在 `typeid(your_class).name()` 中产生更大的类名，并在某些平台上比较两个
    `typeid()` 结果时增加极小的性能开销。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipes will give you more examples of the `enable_if` usage.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一篇文章将为您提供更多关于 `enable_if` 使用的示例。
- en: You may also consult the official documentation of `Boost.Core`. It contains
    many examples and a lot of useful classes (which are used widely in this book).
    Follow the link [http://boost.org/libs/core](http://boost.org/libs/core) to read
    about it.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以查阅 `Boost.Core` 的官方文档。其中包含许多示例和许多有用的类（在本书中广泛使用）。请访问链接 [http://boost.org/libs/core](http://boost.org/libs/core)
    了解更多信息。
- en: You may also read some articles about template partial specializations at [http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以阅读一些关于模板部分特化的文章 [http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx)。
- en: Disabling function template usage for real types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用真实类型的函数模板使用
- en: We continue working with Boost metaprogramming libraries. In the previous recipe,
    we saw how to use `enable_if_c` with classes; now it is time to take a look at
    its usage in template functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 Boost 元编程库。在上一个示例中，我们看到了如何在类中使用 `enable_if_c`；现在是时候看看它在模板函数中的用法了。
- en: 'Imagine that, in your project, you have a template function that works with
    all the available types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在您的项目中，您有一个可以处理所有可用类型的模板函数：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That function exist for a long time. You have written a lot of code that uses
    it. Suddenly, you came up with an optimized version of the `process_data` function
    but only for types that do have an `T::operator+=(const T&)`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数存在已经很长时间了。你已经写了很多使用它的代码。突然间，你想到了`process_data`函数的一个优化版本，但只适用于具有`T::operator+=(const
    T&)`的类型：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You've got a huge code base and it may take months to manually change `process_data`
    to the `process_data_plus_assign` for types that have the right operators. So,
    you do not want to change the already written code. Instead, you want to force
    the compiler to automatically use an optimized function in place of the default
    one if that's possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个庞大的代码库，可能需要几个月的时间才能手动将`process_data`更改为具有正确运算符的`process_data_plus_assign`。因此，你不想改变已经编写的代码。相反，你希望强制编译器在可能的情况下自动使用优化函数来替代默认函数。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe to get an idea of what `boost::enable_if_c` does and
    for an understanding of the concept of SFINAE. A basic knowledge of templates
    is still required.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的配方，了解`boost::enable_if_c`的作用，并理解SFINAE的概念。仍然需要基本的模板知识。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Template magic can be done using the Boost libraries. Let''s see how to do
    it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Boost库进行模板魔术。让我们看看如何做：
- en: 'We will need the `boost::has_plus_assign<T>` metafunction and the `<boost/enable_if.hpp>`
    header:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要`boost::has_plus_assign<T>`元函数和`<boost/enable_if.hpp>`头文件：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we disable default implementation for types with the `plus assign` operator:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们禁用具有`plus assign`运算符的类型的默认实现：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Enable the optimized version for types with the `plus assign` operator:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为具有`plus assign`运算符的类型启用优化版本：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the optimized version is used wherever possible:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，优化版本在可能的情况下被使用：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::disable_if_c<bool_value>::type` metafunction disables the method,
    if `bool_value` equals `true`. It works just like `boost::enable_if_c<!bool_value>::type`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::disable_if_c<bool_value>::type`元函数在`bool_value`等于`true`时禁用该方法。它的工作方式与`boost::enable_if_c<!bool_value>::type`相同。'
- en: A class passed as the second parameter for `boost::enable_if_c` or `boost::disable_if_c`
    is returned via `::type` in the case of successful substitution. In other words,
    `boost::enable_if_c<true, T>::type` is the same as `T`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`boost::enable_if_c`或`boost::disable_if_c`的第二个参数传递的类在成功替换的情况下通过`::type`返回。换句话说，`boost::enable_if_c<true,
    T>::type`与`T`相同。
- en: Let's go through the `process_data(i, i, i)` case, step by step. We pass an
    `int` as `T` type and the compiler searches for function `process_data(int, int,
    int)`. Because there is no such function, the next step is to instantiate a template
    version of `process_data`. However, there are two template `process_data` functions.
    For example, the compiler starts instantiating the templates from our second (optimized)
    version; in that case, it successfully evaluates the `typename boost::enable_if_c<boost::has_plus_assign<T>::value,
    T>::type` expression, and gets the `T` return type. But, the compiler does not
    stop; it continues instantiation attempts and tries to instantiate our first version
    of the function. During substitution of `typename boost::disable_if_c<boost::has_plus_assign<T>::value`
    a failure happens, which is not treated as an error due to the SFINAE rule. There
    are no more template `process_data` functions, so the compiler stops instantiating.
    As you can see, without `enable_if_c` and `disable_if_c`, the compiler would be
    able to instantiate both templates and there will be an ambiguity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步进行`process_data(i, i, i)`的案例。我们将`int`作为`T`类型传递，编译器搜索函数`process_data(int,
    int, int)`。因为没有这样的函数，下一步是实例化`process_data`的模板版本。然而，有两个模板`process_data`函数。例如，编译器开始实例化我们的第二个（优化）版本的模板；在这种情况下，它成功地评估了`typename
    boost::enable_if_c<boost::has_plus_assign<T>::value, T>::type`表达式，并得到了`T`返回类型。但是，编译器并没有停止；它继续实例化尝试，并尝试实例化我们函数的第一个版本。在替换`typename
    boost::disable_if_c<boost::has_plus_assign<T>::value`时发生了失败，由于SFINAE规则，这不被视为错误。没有更多的模板`process_data`函数，所以编译器停止实例化。如你所见，如果没有`enable_if_c`和`disable_if_c`，编译器将能够实例化两个模板，并且会产生歧义。
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As in the case of `enable_if_c` and `enable_if`, there is a `disable_if` version
    of the disabling function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与`enable_if_c`和`enable_if`一样，还有一个禁用函数的`disable_if`版本：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: C++11 has neither `disable_if_c` nor `disable_if`, but you are free to use `std::enable_if<!bool_value>::type`
    instead.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C++11中没有`disable_if_c`或`disable_if`，但你可以自由使用`std::enable_if<!bool_value>::type`。
- en: Before Boost 1.56 the `boost::disable_if` metafunctions were defined in the
    header `<boost/utility/enable_if.hpp>` instead of `<boost/core/enable_if.hpp>`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Boost 1.56之前，`boost::disable_if`元函数被定义在`<boost/utility/enable_if.hpp>`头文件中，而不是`<boost/core/enable_if.hpp>`。
- en: As it was mentioned in the previous recipe, all the enabling and disabling functions
    are executed only at compile time and do not add performance overhead at runtime.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中提到，所有的启用和禁用函数都只在编译时执行，并且不会在运行时增加性能开销。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read this chapter from the beginning to get more examples of compile-time tricks.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章，以获取更多编译时技巧的示例。
- en: Consider reading the `Boost.TypeTraits` official documentation for more examples
    and a full list of metafunctions at [http://boost.org/libs/type_traits.](http://boost.org/libs/type_traits)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑阅读`Boost.TypeTraits`官方文档，了解更多示例和元函数的完整列表，网址为[http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)。
- en: The `Boost.Core` library may provide you with more examples of `boost::enable_if`
    usage; read about it at [http://boost.org/libs/core.](http://boost.org/libs/core)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Core`库可能会为你提供更多关于`boost::enable_if`的用法示例；在[http://boost.org/libs/core](http://boost.org/libs/core)上了解更多信息。'
- en: Creating a type from a number
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数字创建类型
- en: 'We have now seen examples of how we can choose between functions using `boost::enable_if_c`.
    Let''s forget about that technique for this chapter and use a different approach.
    Consider the following example, where we have a generic method for processing
    POD datatypes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`boost::enable_if_c`来在函数之间进行选择的示例。让我们在本章中忘记这种技术，使用一种不同的方法。考虑以下示例，我们有一个用于处理POD数据类型的通用方法：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also have some processing functions optimized for sizes 1, 4, and 8 bytes.
    How do we rewrite the `process` function so that it can dispatch calls to optimized
    processing functions?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些针对1、4和8字节大小进行优化的处理函数。我们如何重写`process`函数，以便它可以分派调用到优化处理函数？
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading at least the first recipe from this chapter is highly recommended, so
    that you will not be confused by all the things that are happening here. Templates
    and metaprogramming will not scare you (or just get ready to see a lot of them).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议阅读本章至少第一个配方，这样您就不会被这里发生的一切搞糊涂。模板和元编程不会吓到您（或者只是准备好看到很多这样的东西）。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are going to see how the size of a template type can be converted to a variable
    of some type, and how that variable can be used for deducing the right function
    overload.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到模板类型的大小如何转换为某种类型的变量，以及该变量如何用于推断正确的函数重载。
- en: 'Let''s define our generic and optimized versions of the `process_impl` function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义我们的`process_impl`函数的通用版本和优化版本：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we are ready to write a process function:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备编写一个处理函数：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The most interesting part here is that `boost::mpl::int_<sizeof(T)>()`. `sizeof(T)`
    executes at compile time, so its output can be used as a template parameter. The
    class `boost::mpl::int_<>` is just an empty class that holds a compile-time value
    of integral type. In the `Boost.MPL` library, such classes are called **integral
    constants**. It can be implemented as shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最有趣的部分是`boost::mpl::int_<sizeof(T)>()`。`sizeof(T)`在编译时执行，因此其输出可以用作模板参数。类`boost::mpl::int_<>`只是一个空类，它保存了一个整数类型的编译时值。在`Boost.MPL`库中，这样的类被称为**整数常量**。可以按照以下代码实现：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We need an instance of this class, which is why we have a round parentheses
    at the end of `boost::mpl::int_<sizeof(T)>()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个类的一个实例，这就是为什么在`boost::mpl::int_<sizeof(T)>()`末尾有一个圆括号的原因。
- en: Now, let's take a closer look at how the compiler will decide which `process_impl`
    function to use. First of all, the compiler tries to match functions that have
    a non-template second parameter . If `sizeof(T)` is 4, the compiler tries to search
    the function with signatures like `process_impl(T, boost::mpl::int_<4>)` and finds
    our 4 bytes optimized version from the `detail` namespace. If `sizeof(T)` is 34,
    the compiler can not find the function with a signature like `process_impl(T,
    boost::mpl::int_<34>)`, and uses a template function `process_impl(const T& val,
    Tag /*ignore*/)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看编译器将如何决定使用哪个`process_impl`函数。首先，编译器尝试匹配具有非模板第二参数的函数。如果`sizeof(T)`为4，编译器尝试搜索具有类似`process_impl(T,
    boost::mpl::int_<4>)`签名的函数，并从`detail`命名空间中找到我们的4字节优化版本。如果`sizeof(T)`为34，编译器找不到具有类似`process_impl(T,
    boost::mpl::int_<34>)`签名的函数，并使用模板函数`process_impl(const T& val, Tag /*ignore*/)`。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.MPL` library has several data structures for metaprogramming. In
    this recipe, we only scratched the tip of the iceberg. You may find the following
    integral constant classes from MPL useful:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL`库有几种用于元编程的数据结构。在这个配方中，我们只是触及了冰山一角。您可能会发现MPL中的以下整数常量类有用：'
- en: '`bool_`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool_`'
- en: '`int_`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int_`'
- en: '`long_`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long_`'
- en: '`size_t`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_t`'
- en: '`char_`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char_`'
- en: All the `Boost.MPL` functions (except the `for_each` runtime function) are executed
    at compile time and won't add runtime overhead.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Boost.MPL`函数（除了`for_each`运行时函数）都在编译时执行，不会增加运行时开销。
- en: 'The `Boost.MPL` library is not a part of C++. However, C++ reuses many tricks
    from that library. C++11 in the header file `type_traits` has an `std::integral_constant<type,
    value>` class that could be used in the same way as in the preceding example.
    You could even define your own **type aliases** using it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL`库不是C++的一部分。然而，C++从该库中重用了许多技巧。C++11在头文件`type_traits`中有一个`std::integral_constant<type,
    value>`类，可以像前面的示例中那样使用。您甚至可以使用它定义自己的**类型别名**：'
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes from [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, will give you more examples of the `Boost.MPL` library usage.
    If you feel confident, you may also try to read the library documentation at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
    link.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第8章的配方，“元编程”，将为您提供更多`Boost.MPL`库用法的示例。如果您感到自信，您也可以尝试阅读[http://boost.org/libs/mpl](http://boost.org/libs/mpl)链接的库文档。
- en: Read more examples of tags usage at [http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/fill.html](http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/fill.html)
    and [http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/copy.html](http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/copy.html).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/fill.html](http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/fill.html)和[http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/copy.html](http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/copy.html)上阅读标签用法的更多示例。
- en: Implementing a type trait
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现类型特性
- en: We need to implement a type trait that returns `true` if the `std::vector` type
    is passed to it as a template parameter and `false` otherwise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个类型特性，如果将`std::vector`类型作为模板参数传递给它，则返回`true`，否则返回`false`。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basic knowledge of the `Boost.TypeTrait` or standard library type traits
    is required.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些关于`Boost.TypeTrait`或标准库类型特性的基本知识。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to implement a type trait:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现类型特性：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Almost all the work is done by the `boost::true_type` and `boost::false_type`
    classes. The `boost::true_type` class has a boolean `::value` static constant
    in it that equals `true`. The `boost::false_type` class has a boolean `::value`
    static constant in it that equals `false`. These two classes also have some `typedef`s
    to cooperate well with the `Boost.MPL` library.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的工作都是由`boost::true_type`和`boost::false_type`类完成的。`boost::true_type`类中有一个布尔`::value`静态常量，其值为`true`。`boost::false_type`类中有一个布尔`::value`静态常量，其值为`false`。这两个类还有一些`typedef`，以便与`Boost.MPL`库很好地配合。
- en: Our first `is_stdvector` structure is a generic structure that will be used
    always when a template specialized version of such structure is not found. Our
    second `is_stdvector` structure is a template specialization for the `std::vector`
    types (note that it is derived from `true_type`). So, when we pass `std::vector`
    type to the `is_stdvector` structure, a template specialized version is chosen
    by the compiler. If we pass a data type other than `std::vector`, then the generic
    version is used which is derived from `false_type`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`is_stdvector`结构是一个通用结构，当找不到模板专门化版本时将始终使用它。我们的第二个`is_stdvector`结构是`std::vector`类型的模板专门化（注意它是从`true_type`派生的）。因此，当我们将`std::vector`类型传递给`is_stdvector`结构时，编译器会选择模板专门化版本。如果我们传递的数据类型不是`std::vector`，那么就会使用从`false_type`派生的通用版本。
- en: There is no public keyword before `boost::false_type` and, `boost::true_type`
    in our trait, because we use `struct` keyword, and by default, it uses public
    inheritance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特性中，在`boost::false_type`和`boost::true_type`之前没有public关键字，因为我们使用了`struct`关键字，并且默认情况下它使用公共继承。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Those readers who use the C++11 compatible compilers may use the `true_type`
    and `false_type` types declared in the `<type_traits>` header for creating their
    own type traits. Since C++17, the standard library has a `bool_constant<true_or_false>`
    type alias that you may use for convenience.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那些使用C++11兼容编译器的读者可以使用`<type_traits>`头文件中声明的`true_type`和`false_type`类型来创建自己的类型特征。自C++17以来，标准库有一个`bool_constant<true_or_false>`类型别名，您可以方便地使用它。
- en: As usual, the Boost versions of the classes and functions are more portable
    because they can be used on pre-C++11 compilers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Boost版本的类和函数更具可移植性，因为它们可以在C++11之前的编译器上使用。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Almost all the recipes from this chapter use type traits. Refer to the `Boost.TypeTraits`
    documentation for more examples and information at [http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中几乎所有的示例都使用了类型特征。请参考`Boost.TypeTraits`文档，了解更多示例和信息，网址为[http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
- en: See the previous recipe to get more information on integral constants and how
    the `true_type` and `false_type` may be implemented from scratch.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看前面的示例以获取有关整数常量以及如何从头开始实现`true_type`和`false_type`的更多信息。
- en: Selecting an optimal operator for a template parameter
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模板参数选择最佳操作符
- en: 'Imagine that we are working with classes from different vendors that implement
    different numbers of arithmetic operations and have constructors from integers.
    We do want to make a function that increments by any one class that is passed
    to it. Also, we want this function to be effective! Take a look at the following
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用来自不同供应商的类，这些类实现了不同数量的算术操作，并且具有从整数构造函数。我们确实希望制作一个函数，它可以递增任何一个传递给它的类。而且，我们希望这个函数是有效的！请看下面的代码：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basic knowledge of the C++ templates, and the `Boost.TypeTrait` or standard
    library type traits is required.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些关于C++模板和`Boost.TypeTrait`或标准库类型特征的基本知识。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'All the selecting can be done at compile time. This can be achieved using the
    `Boost.TypeTraits` library, as shown in the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的选择都可以在编译时完成。这可以通过使用`Boost.TypeTraits`库来实现，如下所示：
- en: 'Let''s start by making correct functional objects:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建正确的函数对象：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, we will need a bunch of type traits:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将需要一堆类型特征：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are ready to deduce the correct functor and use it:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好推断出正确的函数对象并使用它：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All the magic is done via the `conditional<bool Condition, class T1, class T2>`
    metafunction. When `true` is passed into the metafunction as a first parameter,
    it returns `T1` via the `::type` `typedef`. When `false` is passed into the metafunction
    as a first parameter, it returns `T2` via the `::type` `typedef`. It acts like
    some kind of compile-time `if` statement.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的魔法都是通过`conditional<bool Condition, class T1, class T2>`元函数完成的。当`true`作为第一个参数传递给元函数时，它通过`::type`
    `typedef`返回`T1`。当`false`作为第一个参数传递给元函数时，它通过`::type` `typedef`返回`T2`。它的作用类似于一种编译时的`if`语句。
- en: So, `step0_t` holds a `detail::plus_functor` metafunction and `step1_t` holds
    `step0_t` or `detail::plus_assignable_functor`. The `step2_t` type holds `step1_t`
    or `detail::post_inc_functor`. The `step3_t` type holds `step2_t` or `detail::pre_inc_functor`.
    What each `step*_t` `typedef` holds is deduced using type trait.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`step0_t`保存了`detail::plus_functor`元函数，`step1_t`保存了`step0_t`或`detail::plus_assignable_functor`。`step2_t`类型保存了`step1_t`或`detail::post_inc_functor`。`step3_t`类型保存了`step2_t`或`detail::pre_inc_functor`。每个`step*_t`
    `typedef`保存的内容是通过类型特征推断出来的。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is a C++11 version of this function, which can be found in the `<type_traits>`
    header in the `std::` namespace. Boost has multiple versions of this function
    in different libraries; for example, `Boost.MPL` has function `boost::mpl::if_c`,
    which acts exactly like `boost::conditional`. It also has a version `boost::mpl::if_`
    (without `c` at the end), which calls `::type` for its first template argument;
    and if it is derived from `boost::true_type`, it returns its second argument during
    the `::type` call. Otherwise, it returns the last template parameter. We can rewrite
    our `inc()` function to use `Boost.MPL`, as shown in the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::`命名空间的`<type_traits>`头文件中有这个函数的C++11版本。Boost在不同的库中有多个版本的这个函数；例如，`Boost.MPL`有函数`boost::mpl::if_c`，它的行为与`boost::conditional`完全相同。它还有一个版本`boost::mpl::if_`（末尾没有`c`），它对其第一个模板参数调用`::type`；如果它是从`boost::true_type`派生的，则在`::type`调用期间返回其第二个参数。否则，它返回最后一个模板参数。我们可以重写我们的`inc()`函数以使用`Boost.MPL`，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'C++17 has an `if constexpr` construction that makes the preceding example much
    simpler:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C++17有一个`if constexpr`结构，使前面的示例变得更简单：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Integral constants in the standard library, `Boost.MPL` and `Boost.TypeTraits`
    have a constexpr conversion operator. For example, it means that an instance of
    `std::true_type` can be converted to `true` value. In the preceding example, `boost::has_pre_increment<T>`
    denotes a type, appending `()`, or C++11 curly brackets `{}` make an instance
    of that type, that is convertible to `true` or `false` values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的整数常量，`Boost.MPL`和`Boost.TypeTraits`具有constexpr转换运算符。例如，这意味着`std::true_type`的实例可以转换为`true`值。在前面的例子中，`boost::has_pre_increment<T>`表示一种类型，附加`()`，或者C++11的大括号`{}`创建该类型的实例，可以转换为`true`或`false`值。
- en: See also
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Enabling template functions usage for integral types.*
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用整数类型的模板函数使用。*'
- en: The recipe *Disabling template functions usage for real types.*
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*禁用实数类型的模板函数使用。*'
- en: The `Boost.TypeTraits` documentation has a full list of available metafunctions.
    Follow the link [http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
    to read about it.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.TypeTraits`文档中列出了所有可用的元函数。点击链接[http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)阅读更多信息。'
- en: The recipes from [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, will give you more examples of the `Boost.MPL` library usage.
    If you feel confident, you may also try to read its documentation at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
    link.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第8章](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd)的示例，*元编程*，将为您提供更多`Boost.MPL`库的使用示例。如果您感到自信，您也可以尝试阅读其文档，链接为[http://boost.org/libs/mpl](http://boost.org/libs/mpl)。
- en: Getting a type of expression in C++03
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++03中获取表达式的类型
- en: In the previous recipes, we saw some examples of `boost::bind` usage. It may
    be a useful tool in pre-C++11 word, but it is hard to store `boost::bind` result
    as a variable in C++03.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们看到了一些`boost::bind`的使用示例。它可能是C++11之前的一个有用工具，但是在C++03中很难将`boost::bind`的结果存储为变量。
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In C++11, we can use `auto` keyword instead of `???` and that will work. Is
    there a way to do it in C++03?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，我们可以使用`auto`关键字代替`???`，这样就可以工作了。在C++03中有没有办法做到这一点呢？
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A knowledge of the C++11 `auto` and `decltype` keywords may help you to understand
    this recipe.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 了解C++11的`auto`和`decltype`关键字可能有助于您理解这个示例。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will need a `Boost.Typeof` library for getting a return type of expression:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`Boost.Typeof`库来获取表达式的返回类型：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It just creates a variable with the name `var`, and the value of the expression
    is passed as a second argument. The type of `var` is detected from the type of
    expression.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是创建一个名为`var`的变量，表达式的值作为第二个参数传递。`var`的类型是从表达式的类型中检测出来的。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An experienced C++ reader will note that there are more keywords in the C++11
    for detecting the types of expression. Maybe `Boost.Typeof` has a macro for them
    too. Let''s take a look at the following C++11 code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的C++读者会注意到，在C++11中有更多用于检测表达式类型的关键字。也许`Boost.Typeof`也有一个宏。让我们看一下以下的C++11代码：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using `Boost.Typeof`, the preceding code can be written in the following way:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Boost.Typeof`，前面的代码可以这样写：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: C++11 version's `decltype(expr)` deduces and returns the type of `expr`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: C++11版本的`decltype(expr)`推断并返回`expr`的类型。
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using `Boost.Typeof`, the preceding code can be written like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Boost.Typeof`，前面的代码可以这样写：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: C++11 has a special syntax for specifying return type at the end of the function
    declaration. Unfortunately, this cannot be emulated in C++03, so we cannot use
    `t1` and `t2` variables in a macro.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: C++11在函数声明的末尾有一种特殊的语法来指定返回类型。不幸的是，这在C++03中无法模拟，所以我们不能在宏中使用`t1`和`t2`变量。
- en: 'You can freely use the results of the `BOOST_TYPEOF()` functions in templates
    and in any other compile-time expressions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模板和任何其他编译时表达式中自由使用`BOOST_TYPEOF()`函数的结果：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Unfortunately, however this magic does not always work without help. For example,
    user-defined classes are not always detected, so the following code may fail on
    some compilers:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种魔法并不总是能够自行完成。例如，用户定义的类并不总是被检测到，因此以下代码可能在某些编译器上失败：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In such situations, you may give `Boost.Typeof` a helping hand and register
    a template:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以给`Boost.Typeof`一点帮助并注册一个模板：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, the three most popular compilers correctly detected the type even without
    `BOOST_TYPEOF_REGISTER_TEMPLATE` and without C++11.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，三个最流行的编译器在没有`BOOST_TYPEOF_REGISTER_TEMPLATE`的情况下，甚至没有C++11的情况下也能正确检测到类型。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Typeof` has more examples. Follow the link
    [http://boost.org/libs/typeof](http://boost.org/libs/typeof) to read about it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Typeof`的官方文档有更多示例。点击链接[http://boost.org/libs/typeof](http://boost.org/libs/typeof)阅读更多信息。'
