- en: '*Chapter 13*: Working with Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用模板'
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts, with the continued goal of writing more extensible code.
    We will next explore creating generic code using C++ templates – both **template
    functions** and **template classes**. We will learn how template code, when written
    correctly, is the pinnacle of code reuse. We will explore how to create both template
    functions and template classes, as well as understanding the how appropriate use
    of operator overloading can make a template function reusable for nearly any type
    of data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续追求扩展您的C++编程技能，超越面向对象编程概念，继续编写更具可扩展性的代码。我们将探索使用C++模板创建通用代码 - 包括**模板函数**和**模板类**。我们将学习如何编写正确的模板代码，以实现代码重用的最高境界。我们将探讨如何创建模板函数和模板类，以及理解适当使用运算符重载如何使模板函数可重用于几乎任何类型的数据。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring template basics to genericize code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模板基础知识以通用化代码
- en: Understanding how to create and use template functions and template classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何创建和使用模板函数和模板类
- en: Understanding how operator overloading can make templates more extensible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解运算符重载如何使模板更具可扩展性
- en: By the end of this chapter, you will be able to design more generic code by
    building both template functions and template classes. You will understand how
    operator overloading can ensure that a template function can become highly extensible
    for any data type. By pairing together well-designed template member functions
    with operator overloading, you will be able to create highly reusable and extensible
    template classes in C++.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够通过构建模板函数和模板类来设计更通用的代码。您将了解运算符重载如何确保模板函数对任何数据类型都具有高度可扩展性。通过将精心设计的模板成员函数与运算符重载配对使用，您将能够在C++中创建高度可重用和可扩展的模板类。
- en: Let's increase our understanding of C++ by expanding your programming repertoire
    by exploring templates.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索模板来扩展您的编程技能，从而增进对C++的理解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the `Chapter13`
    subdirectory in a file named `Chp13-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下，文件名与所在章节编号对应，后跟破折号，再跟上所在章节中示例编号。例如，本章的第一个完整程序可以在`Chapter13`子目录中的名为`Chp13-Ex1.cpp`的文件中找到，位于上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OUaLrb](https://bit.ly/2OUaLrb).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/2OUaLrb](https://bit.ly/2OUaLrb)。
- en: Exploring template basics to genericize code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模板基础知识以通用化代码
- en: Templates allow code to be generically specified in a manner that is abstracted
    from the data types primarily used within relevant functions or classes. The motivation
    for creating templates is to generically specify the definition of functions and
    classes that we repeatedly want to utilize, but with varying data types. The individualized
    versions of these components would otherwise differ only in the core data type
    utilized; these key data types can then be extracted and written generically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许以一种抽象的方式对代码进行通用指定，这种方式与主要用于相关函数或类中的数据类型无关。创建模板的动机是为了通用指定我们反复想要使用的函数和类的定义，但使用不同的数据类型。这些组件的个性化版本在核心数据类型上会有所不同；这些关键数据类型可以被提取并以通用方式编写。
- en: When we then opt to utilize such a class or function with a specific type, rather
    than copying and pasting existing code from a similar class or function (with
    preset data types) and changing it slightly, the preprocessor instead would take
    the template code and *expand* it for our requested, bonified type. This template
    *expansion* capability allows the programmer to write and maintain only one version
    of the genericized code, versus the many type-specific versions of code that would
    otherwise need to be written. The benefit is also that the preprocessor will do
    a more accurate expansion of the template code to a bonified type than we might
    have done using a copy, paste, and slight modification method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择使用特定类型的类或函数时，而不是复制和粘贴现有代码（带有预设数据类型）并稍作修改，预处理器会取代模板代码并为我们请求的类型进行*扩展*。这种模板*扩展*能力使程序员只需编写和维护通用化代码的一个版本，而不是需要编写许多特定类型版本的代码。另一个好处是，预处理器将更准确地将模板代码扩展为请求的类型，而不是我们可能使用复制、粘贴和轻微修改方法所做的扩展。
- en: Let's take a moment to further investigate the motivation for using templates
    in our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间进一步探讨在我们的代码中使用模板的动机。
- en: Examining the motivation for templates
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审视使用模板的动机
- en: Imagine that we wish to create a class to safely handle dynamically allocated
    arrays for the data type `int`, such as what we have created in the solution for
    *Question 3* of [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Operator Overloading and Friends*. Our motivation may be to have an array type
    that can grow or shrink to any size (unlike native, fixed-sized arrays), yet have
    bounds checking for safe usage (unlike the raw manipulation of a dynamic array
    implemented using `int *`, which would unscrupulously allow us to access elements
    well beyond the length of our dynamic array allocation).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望创建一个类来安全地处理动态分配的`int`数据类型的数组，就像我们在[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)的*问题3*解决方案中创建的那样，*运算符重载和友元*。我们的动机可能是要有一个数组类型，可以增长或缩小到任何大小（不像本地的固定大小数组），但对于安全使用有边界检查（不像使用`int
    *`实现的动态数组的原始操作，它会肆意地允许我们访问远远超出我们动态数组分配长度的元素）。
- en: 'We may decide to create an `ArrayInt` class with the following beginning framework:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能决定创建一个以下开始框架的`ArrayInt`类：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code segment, notice that our `ArrayInt` class models the data
    comprising the array using `int *contents;`, which is dynamically allocated to
    the desired size in the constructor. We have overloaded `operator[]` to safely
    return only indexed values in the array that are within the proper range. We can
    add methods to `Resize()` and `ArrayInt` and so on. Overall, we love the safety
    and flexibility of this class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，请注意我们的`ArrayInt`类使用`int *contents;`来模拟数组的数据，它在构造函数中动态分配到所需的大小。我们已经重载了`operator[]`，以安全地返回数组中范围内的索引值。我们可以添加`Resize()`和`ArrayInt`等方法。总的来说，我们喜欢这个类的安全性和灵活性。
- en: Now, we may want to have an `ArrayFloat` class (or later, an `ArrayStudent`
    class). Rather than copying our baseline `ArrayInt` class and modifying it slightly
    to create an `ArrayFloat` class, for example, we may ask if there is a more automated
    way to make this substitution. After all, what would we change in creating an
    `ArrayFloat` class using an `ArrayInt` class as a starting point? We would change
    the *type* of the data member `contents` – from an `int *` to a `float *`. We
    would change the *type* in the memory allocation in the constructor from `contents
    = new int [size];` to utilize `float` instead of `int` (and similarly so in any
    reallocation, such as in a `Resize()` method).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可能想要有一个`ArrayFloat`类（或者以后是`ArrayStudent`类）。例如，我们可能会问是否有一种更自动化的方法来进行这种替换，而不是复制我们的基线`ArrayInt`类并稍微修改它以创建一个`ArrayFloat`类。毕竟，如果我们使用`ArrayInt`类作为起点创建`ArrayFloat`类，我们会改变什么呢？我们会改变数据成员`contents`的*类型*
    - 从`int *`到`float *`。我们会在构造函数中改变内存分配中的*类型*，从`contents = new int [size];`到使用`float`而不是`int`（以及在任何重新分配中也是如此，比如在`Resize()`方法中）。
- en: Rather than copying, pasting, and slightly modifying an `ArrayInt` class to
    create an `ArrayFloat` class, we can simply use a **template class** to genericize
    the *type* associated with the data manipulated within this class. Similarly,
    any functions relying on the specific data type will become **template functions**.
    We will examine the syntax for creating and utilizing templates shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与其复制、粘贴和稍微修改`ArrayInt`类以创建`ArrayFloat`类，我们可以简单地使用**模板类**来泛型化与该类中操作的数据相关联的*类型*。同样，依赖于特定数据类型的任何函数将成为**模板函数**。我们将很快研究创建和使用模板的语法。
- en: Using templates, we can instead create just one template class called `Array`
    where the type is genericized. At compile time, should the preprocessor detect
    that we have utilized this class for `int` or `float` type in our code, the preprocessor
    will then provide the necessary template *expansions* for us. That is, by copying
    and pasting (behind the scenes) each template class (and its methods) and substituting
    in the data types that the preprocessor identifies we are using.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板，我们可以创建一个名为`Array`的模板类，其中类型是泛型化的。在编译时，如果预处理器检测到我们在代码中使用了这个类来处理`int`或`float`类型，那么预处理器将为我们提供必要的模板*扩展*。也就是说，通过复制和粘贴（在幕后）每个模板类（及其方法）并替换预处理器识别出我们正在使用的数据类型。
- en: The resulting code, once expanded under the hood, is no smaller than had we
    written the code for each individual class ourselves. But the point is that we
    did not have to tediously create, modify, test, and later maintain each minorly
    different class ourselves. This is done on our behalf by C++. This is the noteworthy
    purpose of template classes and template functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展后的代码在幕后并不比我们自己为每个单独的类编写代码要小。但关键是，我们不必费力地创建、修改、测试和后续维护每个略有不同的类。这是C++代表我们完成的。这就是模板类和模板函数的值得注意的目的。
- en: Templates are not restricted for use with primitive data types. For example,
    we may wish to create an `Array` of a user-defined type, such as `Student`. We
    will need to ensure that all of our template member functions are meaningful for
    the data types that we actually expand the template class to utilize. We may need
    to overload selected operators so that our template member functions can work
    seamlessly with user defined types, just as they do with primitive types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模板不仅限于与原始数据类型一起使用。例如，我们可能希望创建一个用户定义类型的`Array`，比如`Student`。我们需要确保我们的模板成员函数对我们实际扩展模板类以利用的数据类型是有意义的。我们可能需要重载选定的运算符，以便我们的模板成员函数可以与用户定义的类型无缝地工作，就像它们与原始类型一样。
- en: We will later see in this chapter an example illustrating how we may need to
    overload selected operators if we choose to expand a template class for user defined
    types, so that the member functions of a class can work fluidly with any data
    type. Fortunately, we know how to overload operators!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到一个例子，说明如果我们选择扩展模板类以适用于用户定义的类型，我们可能需要重载选定的运算符，以便类的成员函数可以与任何数据类型流畅地工作。幸运的是，我们知道如何重载运算符！
- en: Let's move forward to explore the mechanics of specifying and utilizing template
    functions and template classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索指定和利用模板函数和模板类的机制。
- en: Understanding template functions and classes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板函数和类
- en: '**Templates** provide the ability to create generic functions and classes by
    abstracting the data types associated with those functions and classes. Template
    functions and classes can both be carefully written in such a way as to genericize
    the relevant data types that underly these functions and classes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**通过抽象与这些函数和类相关的数据类型，提供了创建通用函数和类的能力。模板函数和类都可以被精心编写，以使这些函数和类的相关数据类型通用化。'
- en: Let's begin by examining how to create and utilize template functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看看如何创建和利用模板函数。
- en: Creating and using template functions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用模板函数
- en: '**Template functions** parameterize the types of arguments in a function in
    addition to the arguments themselves. Template functions require the body of the
    function to be applicable to most any data type. Template functions can be member
    or non-member functions. Operator overloading can help ensure that the bodies
    of template functions are applicable to user defined types – we''ll see more of
    that shortly.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板函数**将函数中的参数类型参数化，除了参数本身。模板函数要求函数体适用于大多数任何数据类型。模板函数可以是成员函数或非成员函数。运算符重载可以帮助确保模板函数的函数体适用于用户定义的类型
    - 我们很快会看到更多。'
- en: The keyword `template`, along with angle brackets `<` `>` and placeholders for
    the *type* names, are used to specify a template function and its prototype.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`template`，以及尖括号`<` `>`和*类型*名称的占位符，用于指定模板函数及其原型。
- en: 'Let''s take a look at a template function that is not a member of a class (we
    will see examples of template member functions shortly). This example can be found,
    as a full working program, in our GitHub repository as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个不是类成员的模板函数（我们将很快看到模板成员函数的例子）。这个例子可以在我们的GitHub仓库中找到，作为一个完整的工作程序，如下所示：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex1.cpp)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex1.cpp)'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking at the previous function example, we first see a template function prototype.
    The preamble `template <class Type1, class Type 2>` indicates that the prototype
    will be a template prototype and that the placeholders `Type1` and `Type2` will
    be used instead of actual data types. The placeholders `Type1` and `Type2` may
    be (nearly) any name, following the rules of creating identifiers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的函数示例，我们首先看到一个模板函数原型。前言`template <class Type1, class Type 2>`表示原型将是一个模板原型，并且占位符`Type1`和`Type2`将被用来代替实际数据类型。占位符`Type1`和`Type2`可以是（几乎）任何名称，遵循创建标识符的规则。
- en: Then, to complete the prototype we see `Type2 ChooseFirst(Type1, Type2);`, which
    indicates that the return type from this function will be of `Type2` and that
    the arguments of the `ChooseFirst()` function will be of `Type1` and `Type2` (which
    are certainly allowed to expand to be the same type).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了完成原型，我们看到`Type2 ChooseFirst(Type1, Type2);`，这表明这个函数的返回类型将是`Type2`，`ChooseFirst()`函数的参数将是`Type1`和`Type2`（它们肯定可以扩展为相同的类型）。
- en: Next, we see the function definition. It, too, begins with a preamble of `template
    <class Type1, class Type 2>`. Similar to the prototype, the function header `Type2
    ChooseFirst(Type1 x, Type2 y)` indicates that formal parameters `x` and `y` are
    of types `Type1` and `Type2`, respectively. The body of this function is rather
    straightforward. We simply determine which of the two parameters should be ranked
    first in an ordering of the two values by using a simple comparison with the `<`
    operator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到函数定义。它也以`template <class Type1, class Type 2>`开头。与原型类似，函数头`Type2 ChooseFirst(Type1
    x, Type2 y)`表示形式参数`x`和`y`分别是类型`Type1`和`Type2`。这个函数的主体非常简单。我们只需使用`<`运算符进行简单比较，确定这两个参数中哪一个应该在这两个值的排序中排在第一位。
- en: Now, in `main()`, when the preprocessor portion of the compiler sees a call
    to `ChooseFirst()` with actual parameters `int value1` and `float value3`, the
    preprocessor notices that `ChooseFirst()` is a template function. If no such version
    of `ChooseFirst()` yet exists to handle an `int` and a `float`, the preprocessor
    copies this template function and replaces `Type1` with `int` and `Type2` with
    `float` – creating on our behalf the appropriate version of this function to fit
    our needs. Notice that when `ChooseFirst(value2, value1)` is called and the types
    are both integers, the placeholder types of `Type1` and `Type2` will both be replaced
    with `int` when the template function is again expanded (under the hood) in our
    code by the preprocessor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main()`中，当编译器的预处理部分看到对`ChooseFirst()`的调用，实际参数为`int value1`和`float value3`时，预处理器注意到`ChooseFirst()`是一个模板函数。如果还没有这样的`ChooseFirst()`版本来处理`int`和`float`，预处理器将复制这个模板函数，并用`int`替换`Type1`，用`float`替换`Type2`
    - 为我们创建适合我们需求的函数的适当版本。请注意，当调用`ChooseFirst(value2, value1)`并且类型都是整数时，当预处理器再次扩展（在代码底层）模板函数时，占位符类型`Type1`和`Type2`将都被`int`替换。
- en: Though `ChooseFirst()` is a simple function, with it we can see the straightforward
    mechanics of creating a template function that genericizes key data types. We
    can also see how the preprocessor notices how the template function is used and
    takes on the effort on our behalf to expand this function, as needed, for our
    specific type usage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ChooseFirst()`是一个简单的函数，但通过它，我们可以看到创建通用关键数据类型的模板函数的简单机制。我们还可以看到预处理器注意到模板函数的使用方式，并代表我们扩展这个函数，根据我们特定的类型使用需求。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个程序的输出：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have seen the basic mechanics of template functions, let us move
    forward to understand how we can expand this process to include template classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了模板函数的基本机制，让我们继续了解如何将这个过程扩展到包括模板类。
- en: Creating and using template classes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用模板类
- en: '**Template classes** parameterize the ultimate type of a class definition,
    and will additionally require template member functions for any methods that need
    to know the core data type being manipulated.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板类**参数化类定义的最终类型，并且还需要模板成员函数来处理需要知道被操作的核心数据类型的任何方法。'
- en: The keywords `template` and `class`, along with angle brackets `<` `>` and placeholders
    for the *type* names, are used to specify a template class definition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`template`和`class`，以及尖括号`<``>`和*type*名称的占位符，用于指定模板类定义。
- en: 'Let''s take a look at a template class definition and its supporting template
    member functions. This example can be found, as a complete program, in our GitHub
    repository as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个模板类定义及其支持的模板成员函数。这个例子可以在我们的GitHub存储库中找到，作为一个完整的程序。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex2.cpp)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex2.cpp)'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding class definition, let's first notice the template class preamble
    of `template <class Type>`. This preamble specifies that the impending class definition
    will be that of a template class and that the placeholder `Type` will be used
    to genericize the data types primarily used within this class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，让我们首先注意`template <class Type>`的模板类前言。这个前言指定了即将到来的类定义将是一个模板类，占位符`Type`将用于泛型化主要在这个类中使用的数据类型。
- en: We then see the class definition for `Array`. Data member `contents` will be
    of the placeholder type of `Type`. Of course, not all data types will need to
    be genericized. Data member `int numElements` is perfectly reasonable as an integer.
    Next, we see an assortment of member functions prototyped, and some defined inline,
    including the overloaded `operator[]`. For the member functions defined inline,
    a template preamble is not necessary in front of the function definition. The
    only thing we need to do for inline functions is genericize the data type using
    our placeholder, `Type`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到了`Array`的类定义。数据成员`contents`将是占位符类型`Type`。当然，并不是所有的数据类型都需要泛型化。数据成员`int
    numElements`作为整数是完全合理的。接下来，我们看到了一系列成员函数的原型，以及一些内联定义的成员函数，包括重载的`operator[]`。对于内联定义的成员函数，在函数定义前不需要模板前言。我们唯一需要做的是使用我们的占位符`Type`泛型化数据类型。
- en: Let's now take a look at selected member functions. In the constructor, we now
    notice that the memory allocation of `contents = new Type [size];` merely uses
    the placeholder `Type` in lieu of an actual data type. Similarly, for the overloaded
    `operator[]`, the return type of this method is `Type`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下选定的成员函数。在构造函数中，我们现在注意到`contents = new Type [size];`的内存分配仅仅使用了占位符`Type`而不是实际的数据类型。同样，对于重载的`operator[]`，这个方法的返回类型是`Type`。
- en: However, looking at a member function that is not inline, we notice that the
    template preamble `template <class Type>` must precede the member function definition.
    For example, let's consider the member function definition for `void Array<Type>::operator+(Type
    item);`. In addition to the preamble, the class name (preceding the member function
    name and scope resolution operator `::`) in the function definition must be augmented
    to include the placeholder type `<Type>` in angle brackets. Also, any generic
    function parameters must use the placeholder type of `Type`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看一个不是内联的成员函数，我们注意到模板前言`template <class Type>`必须在成员函数定义之前。例如，让我们考虑`void Array<Type>::operator+(Type
    item);`的成员函数定义。除了前言之外，在函数定义中类名（在成员函数名和作用域解析运算符`::`之前）必须增加占位符类型`<Type>`在尖括号中。此外，任何通用函数参数必须使用占位符类型`Type`。
- en: Now, in our `main()` function, we merely use the data type of `Array<int>` to
    instantiate a safe, easily resizable array of integers. We could have alternatively
    used `Array<float>` had we instead wanted to instantiate an array of floating-point
    numbers. Under the hood, when we create an instance of a specific array type,
    the preprocessor notices if we have previously expanded this class for that *type*.
    If not, the class definition and applicable template member functions are copied
    for us and the placeholder types are replaced with the type that we need. This
    is no fewer lines of code than had we copied, pasted, and slightly modified the
    code ourselves; however, the point is that we only have one version to specify
    and maintain ourselves. This is less error-prone and is easier for long-term maintenance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`main()`函数中，我们仅使用`Array<int>`的数据类型来实例化一个安全、易于调整大小的整数数组。如果我们想要实例化一个浮点数数组，我们可以选择使用`Array<float>`。在幕后，当我们创建特定数组类型的实例时，预处理器会注意到我们是否先前为该*type*扩展了这个类。如果没有，类定义和适用的模板成员函数将被复制，占位符类型将被替换为我们需要的类型。这并不比我们自己复制、粘贴和稍微修改代码少一行；然而，重点是我们只需要指定和维护一个版本。这样做更不容易出错，更容易进行长期维护。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个程序的输出：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's next take a look at a different, full program example, to pull together
    template functions and template classes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看一个不同的完整程序例子，来整合模板函数和模板类。
- en: Examining a full program example
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查一个完整的程序例子
- en: It is useful to see an additional example that illustrates template functions
    and template classes. Let us expand on a `LinkList` program we reviewed most recently
    in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453), *Operator Overloading
    and Friends*; we will upgrade this program to utilize templates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要看一个额外的例子，说明模板函数和模板类。让我们扩展我们最近在[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)中审查的`LinkList`程序，*运算符重载和友元*；我们将升级这个程序以利用模板。
- en: 'This complete program can be found in our GitHub repository as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的程序可以在我们的GitHub存储库中找到。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex3.cpp)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter13/Chp13-Ex3.cpp)'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's examine the preceding template class definitions for `LinkListElement`
    and `LinkList`. Initially, we notice that the forward declaration of the `LinkList`
    class contains the necessary template preamble of `template class <Type>`. We
    also should notice that each class definition itself contains the same template
    preamble to dually specify that the class will be a template class and that the
    placeholder for the data type will be the identifier `Type`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查`LinkListElement`和`LinkList`的前面的模板类定义。最初，我们注意到`LinkList`类的前向声明包含了必要的`template
    class <Type>`的模板前言。我们还应该注意到每个类定义本身都包含相同的模板前言，以双重指定该类将是一个模板类，并且数据类型的占位符将是标识符`Type`。
- en: In the `LinkListElement` class, notice that the data type will be `Type` (the
    placeholder type). Also, notice that the placeholder for the type will be necessary
    in the friend class specification of `LinkList`, that is, `friend class LinkList<Type>;`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LinkListElement`类中，注意到数据类型将是`Type`（占位符类型）。另外，注意到类型的占位符在`LinkList`的友元类规范中是必要的，即`friend
    class LinkList<Type>;`。
- en: In the `LinkList` class, notice that any reference to the associated class of
    `LinkListElement` will include the type placeholder of `<Type>`. Notice, for example,
    this placeholder usage in the data member declaration of `LinkListElement<Type>
    *head;` or the return type of `RemoveAtFront()`, which is `LinkListElement<Type>`.
    Additionally, notice that the inline function definitions do not require a template
    preamble before each method; we are still covered by the preamble occurring before
    the class definition itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LinkList`类中，注意到任何与`LinkListElement`的关联类的引用都将包括`<Type>`的类型占位符。例如，在`LinkListElement<Type>
    *head;`的数据成员声明中或者`RemoveAtFront()`的返回类型中，都使用了占位符。此外，注意到内联函数定义不需要在每个方法之前加上模板前言；我们仍然受到类定义本身之前的前言的覆盖。
- en: 'Now, let''s move forward to take a look at the three non-inline member functions
    of the `LinkList` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续来看看`LinkList`类的三个非内联成员函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we examine the preceding code, we can see that in the non-inline methods
    of `LinkList`, the template preamble of `template <class Type>` appears before
    each member function definition. We also see that the class name tied with the
    scope resolution operator to the member function name is augmented with `<Type>`;
    for example, `void LinkList<Type>::Print()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查前面的代码时，我们可以看到在`LinkList`的非内联方法中，`template <class Type>`的模板前言出现在每个成员函数定义之前。我们还看到与作用域解析运算符相关联的类名被增加了`<Type>`；例如，`void
    LinkList<Type>::Print()`。
- en: We notice that the aforementioned template member functions require some part
    of their method to utilize the placeholder type, `Type`. For example, the `InsertAtFront(Type
    *theItem)` method uses the placeholder `Type` both as the data type of the formal
    parameter `theItem`, and to specify the associated class `LinkListElement<Type>`
    when declaring a local pointer variable `temp`. The `RemoveAtFront()` method similarly
    utilizes a local variable of the type `LinkListElement<Type>`, hence necessitating
    its use as a template function. Similarly, `Print()` introduces a local variable
    of the type `Type` to assist with output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到前面提到的模板成员函数需要利用占位符类型`Type`的一部分来实现它们的方法。例如，`InsertAtFront(Type *theItem)`方法将占位符`Type`用作形式参数`theItem`的数据类型，并在声明一个本地指针变量`temp`时指定关联类`LinkListElement<Type>`。`RemoveAtFront()`方法类似地利用了类型为`LinkListElement<Type>`的本地变量，因此需要将其用作模板函数。同样，`Print()`引入了一个类型为`Type`的本地变量来辅助输出。
- en: 'Let''s now take a look at our `main()` function to see how we can utilize our
    template classes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们的`main()`函数，看看我们如何利用我们的模板类：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our preceding `main()` function, we utilize our template classes to create
    two types of linked lists, that is, a `LinkList` of integers with the declaration
    `LinkList<int> list1;` and a `LinkList` of floating-point numbers with the declaration
    `LinkList<float> list2;`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的`main()`函数中，我们利用我们的模板类创建了两种类型的链表，即整数的`LinkList`声明为`LinkList<int> list1;`和浮点数的`LinkList`声明为`LinkList<float>
    list2;`。
- en: In each case, we instantiate the various link lists, then add elements and print
    the respective lists. In the case of the first `LinkList` instance, we also demonstrate
    how elements can be successively removed from the list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们实例化各种链表，然后添加元素并打印相应的列表。在第一个`LinkList`实例的情况下，我们还演示了如何连续从列表中删除元素。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Overall, we see that creating a `LinkList<int>` and a `LinkList<float>` is very
    easy. The template code is simply expanded behind the scenes to accommodate each
    data type we desire. We may then ask ourselves, how easy is it to create a linked
    list of `Student` instances? Very easy! We could simply instantiate `LinkList<Student>
    list3;` and call appropriate `LinkList` methods, such as `list3.InsertAtFront(new
    Student("George", "Katz"``, 'C', "Mr.", 3.2, "C++", "123GWU"));`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们看到创建`LinkList<int>`和`LinkList<float>`非常容易。模板代码在幕后被简单地扩展，以适应我们所需的每种数据类型。然后我们可能会问自己，创建`Student`实例的链表有多容易？非常容易！我们可以简单地实例化`LinkList<Student>
    list3;`并调用适当的`LinkList`方法，比如`list3.InsertAtFront(new Student("George", "Katz",
    'C', "Mr.", 3.2, "C++", "123GWU"));`。
- en: Perhaps we would like to include a means to order our elements in the template
    `LinkList` class, such as by adding an `OrderedInsert()` method (which typically
    relies on `operator<` or `operator>` for the comparison of elements). Would that
    work for all data types? That's a good question. It could, provided the code written
    in the method is generic to work for all data types. Can operator overloading
    help with this endeavor? Yes!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们想在模板`LinkList`类中包含一种方法来对我们的元素进行排序，比如添加一个`OrderedInsert()`方法（通常依赖于`operator<`或`operator>`来比较元素）。这对所有数据类型都适用吗？这是一个很好的问题。只要方法中的代码是通用的，可以适用于所有数据类型，它就可以，运算符重载可以帮助实现这个目标。是的！
- en: Now that we have seen the mechanics of template classes and functions in action,
    let's consider how we can ensure that our template classes and functions are fully
    extensible to work for any data type. To do this, let's consider how operator
    overloading can be of value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了模板类和函数的工作原理，让我们考虑如何确保我们的模板类和函数能够完全扩展以适用于任何数据类型。为了做到这一点，让我们考虑运算符重载如何有价值。
- en: Making templates more flexible and extensible
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使模板更灵活和可扩展
- en: The addition of templates in C++ gives us the ability to make certain types
    of classes and functions generically specified a single time by the programmer,
    while behind the scenes, the preprocessor generates many versions of that code
    on our behalf. However, in order for a class to truly be extensible to expand
    for many different user defined types, code written within member functions must
    be universally applicable to any type of data. To help with this endeavor, operator
    overloading can be used to extend operations that may easily exist for standard
    types to include definitions for user defined types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中添加模板使我们能够让程序员一次性地指定某些类型的类和函数，而在幕后，预处理器会代表我们生成许多版本的代码。然而，为了使一个类真正可扩展以适用于许多不同的用户定义类型，成员函数中编写的代码必须普遍适用于任何类型的数据。为了帮助实现这个目标，可以使用运算符重载来扩展可能轻松存在于标准类型的操作，以包括对用户定义类型的定义。
- en: To recap, we know operator overloading can allow simple operators to work not
    only with standard types, but also with user defined types. By overloading operators
    in our template code, we can ensure that our template code is highly reusable
    and extensible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们知道运算符重载可以使简单的运算符不仅适用于标准类型，还适用于用户定义的类型。通过在模板代码中重载运算符，我们可以确保模板代码具有高度的可重用性和可扩展性。
- en: Let's consider how we can strengthen templates with the use of operator overloading.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何通过运算符重载来加强模板。
- en: Adding operator overloading to further genericize template code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过添加运算符重载来进一步泛化模板代码。
- en: Recall, when overloading an operator, it is important to promote the same meaning
    that the operator has for standard types. Imagine that we would like to add an
    `OrderedInsert()` method to our `LinkList` class. The body of this member function
    might rely on comparing two elements to see which one should go before the other.
    The easiest way to do this is using `operator<`. This operator is easily defined
    to work with standard types, but will it work with user defined types? It can,
    provided we overload the operator to work with the desired types.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当重载运算符时，重要的是要促进与标准类型相同的含义。想象一下，我们想要在我们的`LinkList`类中添加一个`OrderedInsert()`方法。这个成员函数的主体可能依赖于比较两个元素，以确定哪个应该排在另一个之前。最简单的方法是使用`operator<`。这个运算符很容易定义为与标准类型一起使用，但它是否适用于用户定义的类型？只要我们重载运算符以适用于所需的类型，它就可以适用。
- en: 'Let''s take a look at an example where we will need to overload an operator
    to make the member function code universally applicable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们需要重载一个运算符，使成员函数代码普遍适用：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding template member function, we rely on `operator<` to be able
    to work with any data type in which we would like to utilize this template class.
    That is, when the preprocessor expands this code for a specific, user defined
    type, the `<` operator must work for whatever data type this method has been specifically
    expanded for.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板成员函数中，我们依赖于`operator<`能够与我们想要使用这个模板类的任何数据类型一起工作。也就是说，当预处理器为特定的用户定义类型扩展这段代码时，`<`运算符必须适用于此方法特定扩展的任何数据类型。
- en: Should we wish to create a `LinkList` of `Student` instances and apply an `OrderedInsert()`
    of one `Student` versus another, we then need to ensure that the comparison with
    `operator<` is defined for two `Student` instances. Of course, by default, `operator<`
    is only defined for standard types. But, if we simply overload `operator<` for
    `Student`, we can ensure that the `LinkList<Type>::OrderedInsert()` method will
    work for `Student` data types as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望创建一个`LinkList`的`Student`实例，并对一个`Student`与另一个`Student`进行`OrderedInsert()`，那么我们需要确保为两个`Student`实例定义了`operator<`的比较。当然，默认情况下，`operator<`仅适用于标准类型。但是，如果我们简单地为`Student`重载`operator<`，我们就可以确保`LinkList<Type>::OrderedInsert()`方法也适用于`Student`数据类型。
- en: 'Let''s take a look at how we can overload `operator<` for `Student` instances,
    both as a member function or as a non-member function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为`Student`实例重载`operator<`，无论是作为成员函数还是非成员函数：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we can recognize `operator<` implemented as either a
    member function of `Student`, or as a non-member function. If you have access
    to the class definition for `Student`, the preferred approach would be to utilize
    the member function definition for this operator function. However, sometimes,
    we do not have access to modify a class. In such cases, we must utilize the non-member
    function approach. Nonetheless, in either implementation, we simply compare the
    `gpa` of the two `Student` instances, and return `true` if the first instance
    has a lower `gpa` than the second `Student` instance, and `false` otherwise.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以识别`operator<`被实现为`Student`的成员函数，或者作为非成员函数。如果你可以访问`Student`类的定义，首选的方法是利用成员函数定义来实现这个运算符函数。然而，有时我们无法访问修改一个类。在这种情况下，我们必须使用非成员函数的方法。无论如何，在任何一种实现中，我们只是比较两个`Student`实例的`gpa`，如果第一个实例的`gpa`低于第二个`Student`实例，则返回`true`，否则返回`false`。
- en: Now that `operator<` has been defined for two `Student` instances, we can return
    to our prior template function of `LinkList<Type>::OrderedInsert(Type *)`, which
    utilizes operator `<` for a comparison of two objects of the type `Type` in the
    `LinkList`. When a `LinkList<Student>` is made somewhere in our code, the template
    code for `LinkList` and `LinkListElement` will be expanded by the preprocessor
    for `Student`; `Type` will be replaced with `Student`. When the expanded code
    is then compiled, the code in the expanded `LinkList<Student>::OrderedInsert()`
    will compile without error, as `operator<` has been defined for two `Student`
    objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`operator<`已经为两个`Student`实例定义了，我们可以回到我们之前的`LinkList<Type>::OrderedInsert(Type
    *)`模板函数，它利用`LinkList`中类型为`Type`的两个对象进行比较。当我们的代码中某处创建了`LinkList<Student>`时，`LinkList`和`LinkListElement`的模板代码将被预处理器为`Student`进行扩展；`Type`将被替换为`Student`。然后编译扩展后的代码时，扩展的`LinkList<Student>::OrderedInsert()`中的代码将会无错误地编译，因为`operator<`已经为两个`Student`对象定义了。
- en: What happens if we neglect to overload `operator<` for a given type, however,
    `OrderedInsert()` (or another method relying on `operator<`) is never called in
    our code on an object of that same expended template type? Believe it or not,
    the code will compile and work without issue. In this case, we are not actually
    calling a function (that is, `OrderedInsert()`) that would require `operator<`
    to be implemented for that type. Because the function is never called, the template
    expansion for that member function is skipped. The compiler has no reason to discover
    that `operator<` should have been overloaded for the type in question (in order
    for the method to compile successfully). The uncalled method has simply not been
    expanded for the compiler to verify.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们忽略为给定类型重载`operator<`会发生什么，然而，`OrderedInsert()`（或者另一个依赖于`operator<`的方法）在我们的代码中对该扩展模板类型的对象从未被调用？信不信由你，代码将会编译并且正常工作。在这种情况下，我们实际上并没有调用一个需要为该类型实现`operator<`的函数（即`OrderedInsert()`）。因为这个函数从未被调用，该成员函数的模板扩展被跳过。编译器没有理由去发现`operator<`应该为该类型重载（为了使方法成功编译）。未被调用的方法只是没有被扩展，以供编译器验证。
- en: By using operator overloading to complement template classes and functions,
    we can make template code even further extensible by ensuring that typical operators
    used within method bodies can be applied to any type we would want to utilize
    in the template expansion. Our code becomes more widely applicable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运算符重载来补充模板类和函数，我们可以通过确保在方法体中使用的典型运算符可以应用于模板扩展中我们想要使用的任何类型，使模板代码变得更具可扩展性。我们的代码变得更加普适。
- en: We have now seen how to utilize template functions and classes, and how operator
    overloading can enhance templates to create even more extensible code. Let us
    now briefly recap these concepts before moving forward to our next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用模板函数和类，以及如何运算符重载可以增强模板，创建更具可扩展性的代码。在继续前进到下一章之前，让我们简要回顾一下这些概念。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have furthered our C++ programming knowledge beyond OOP
    language features to include additional language features that will enable us
    to write more extensible code. We have learned how to utilize template functions
    and template classes and how operator overloading nicely supports these endeavors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们进一步加强了我们的C++编程知识，超越了面向对象编程语言特性，包括了额外的语言特性，使我们能够编写更具可扩展性的代码。我们学会了如何利用模板函数和模板类，以及运算符重载如何很好地支持这些努力。
- en: We have seen that templates can allow us to generically specify a class or function
    with respect to the data type primarily used within that class or function. We
    have seen that template classes inevitably utilize template functions because
    those methods generally need to generically use the data upon which the class
    is built. We have seen that by taking advantage of operator overloading for user
    defined types, we can take advantage of method bodies written using simple operators
    to accommodate usage by more complex data types, making the template code much
    more useful and extensible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，模板可以让我们以泛型方式指定一个类或函数，与该类或函数中主要使用的数据类型相关。我们已经看到，模板类不可避免地利用模板函数，因为这些方法通常需要泛型地使用构建类的数据。我们已经看到，通过利用用户定义类型的运算符重载，我们可以利用使用简单运算符编写的方法体来适应更复杂的数据类型的使用，使模板代码变得更加有用和可扩展。
- en: We now understand that using templates can allow us to specify a class or function
    just one time more abstractly and allow the preprocessor to generate many versions
    of that class or function for us, based upon specific data types that may be needed
    within the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，使用模板可以让我们更抽象地指定一个类或函数，让预处理器为我们生成许多该类或函数的版本，基于应用程序中可能需要的特定数据类型。
- en: By allowing the preprocessor to expand many versions of a template class or
    set of template functions for us based on types needed in an application, the
    work of creating many similar classes or functions (and maintaining those versions)
    is passed to C++, rather than the programmer. In addition to having less code
    for the user to maintain, changes made in the template classes or functions need
    only be made in one place – the preprocessor will re-expand the code without errors
    when needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许预处理器根据应用程序中需要的类型来扩展模板类或一组模板函数的许多版本，创建许多类似的类或函数（并维护这些版本）的工作被传递给了C++，而不是程序员。除了减少用户需要维护的代码外，模板类或函数中所做的更改只需要在一个地方进行
    – 预处理器在需要时将重新扩展代码而不会出错。
- en: We have added additional, useful features to our C++ repertoire through examining
    templates, which, combined with operator overloading, will ensure we can write
    highly extensible and reusable code for nearly any data type. We are now ready
    to continue forward with [*Chapter 14*](B15702_14_Final_NM_ePub.xhtml#_idTextAnchor518),
    *Understanding STL Basics*, so that we can continue extending our C++ programming
    skills with useful C++ library features that will make us better programmers.
    Let's move forward!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过研究模板为我们的C++技能库增加了额外的有用功能，结合运算符重载，这将确保我们可以为几乎任何数据类型编写高度可扩展和可重用的代码。我们现在准备继续进行[*第14章*](B15702_14_Final_NM_ePub.xhtml#_idTextAnchor518)，*理解STL基础*，以便我们可以继续扩展我们的C++编程技能，使用有用的C++库功能，这将使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Convert your `ArrayInt` class from [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Operator Overloading and Friends*, to a template `Array` class to support a dynamically
    allocated array of any data type that can be easily resized and have built-in
    bounds checking.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`ArrayInt`类从[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)，*运算符重载和友元*，转换为一个模板`Array`类，以支持可以轻松调整大小并具有内置边界检查的任何数据类型的动态分配数组。
- en: a. Consider what operators, if any, you will need to overload to allow generic
    code within each method to support any user defined types you may wish to store
    in the template's `Array` type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: a. 考虑一下，如果需要的话，您将需要重载哪些运算符，以支持模板的`Array`类型中存储的任何用户定义类型的通用代码。
- en: b. Using your template's `Array` class, create an array of `Student` instances.
    Utilize various member functions to demonstrate that various template functions
    operate correctly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: b. 使用您的模板的`Array`类，创建`Student`实例的数组。利用各种成员函数来演示各种模板函数是否正确运行。
- en: Using the template's `LinkList` class, complete the implementation for `LinkList<Type>::OrderedInsert()`.
    Create a `LinkList` of `Student` instances in `main()`. After several `Student`
    instances have been inserted in the list using `OrderedInsert()`, verify that
    this method works correctly by displaying each `Student` and their `gpa`. The
    `Student` instances should be ordered from the lowest to the highest `gpa`. You
    may wish to use the online code as a starting point.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模板的`LinkList`类，完成`LinkList<Type>::OrderedInsert()`的实现。在`main()`中创建`Student`实例的`LinkList`。在列表中使用`OrderedInsert()`插入了几个`Student`实例后，通过显示每个`Student`及其`gpa`来验证该方法是否正确工作。`Student`实例应按`gpa`从低到高排序。您可能希望使用在线代码作为起点。
