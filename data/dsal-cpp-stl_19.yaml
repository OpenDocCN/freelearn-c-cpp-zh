- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Exception Safety
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常安全性
- en: This chapter will guide you through the complexities of exception safety. It
    demystifies the levels of exception safety, distinguishing between basic and strong
    guarantees, underscoring their significance, and offering proven strategies to
    achieve them. Mastering these advanced topics allows you to create more resilient,
    efficient, and adaptable C++ applications and data structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你了解异常安全性的复杂性。它揭示了异常安全性的级别，区分了基本和强保证，强调了它们的重要性，并提供了实现它们的经过验证的策略。掌握这些高级主题使你能够创建更健壮、高效和适应性强的高性能C++应用程序和数据结构。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic exception safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的异常安全性
- en: Strong exception safety
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强异常安全性
- en: The effect of `noexcept` on STL containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noexcept` 对 STL 容器的影响'
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Basic exception safety
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的异常安全性
- en: '**Basic exception safety**, colloquially termed the *guarantee*, pledges that
    your program won’t leak resources when an exception occurs and its invariants
    are preserved. Simply put, the software won’t devolve into chaos. When unforeseen
    exceptions occur, the operation might fail, but your application continues functioning,
    and no data gets mangled.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本的异常安全性**，俗称为**保证**，承诺当发生异常且其不变性得到保留时，你的程序不会泄露资源。简单来说，软件不会陷入混乱。当发生未预见的异常时，操作可能会失败，但你的应用程序将继续运行，并且没有数据被损坏。'
- en: 'Two real-world examples of unforeseen exceptions that can be effectively managed
    without causing resource leaks or data corruption include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个现实世界的例子展示了可以有效地管理未预见的异常，而不会导致资源泄露或数据损坏：
- en: '**File operation failure during data processing**: Consider an application
    that processes large data files. During this process, the application might encounter
    an unexpected exception, such as a failure to read a portion of the file due to
    disk I/O errors. In this case, basic exception safety ensures the application
    does not leak resources (such as file handles or memory allocated for data processing).
    It maintains the integrity of any data structures involved. The application might
    not complete the intended file processing. Still, it will handle the exception
    gracefully, freeing up any resources and leaving the application in a stable state
    to continue functioning.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理过程中的文件操作失败**：考虑一个处理大型数据文件的应用程序。在这个过程中，应用程序可能会遇到意外的异常，例如由于磁盘I/O错误而无法读取文件的一部分。在这种情况下，基本的异常安全性确保应用程序不会泄露资源（如文件句柄或为数据处理分配的内存）。它维护任何涉及的数据结构的完整性。应用程序可能无法完成预期的文件处理。然而，它将优雅地处理异常，释放任何资源，并使应用程序处于稳定状态以继续运行。'
- en: '**Network communication interruption in a client-server application**: In a
    client-server application, an unforeseen exception might occur if the network
    connection is suddenly lost during a critical data exchange. Basic exception safety
    in this scenario ensures that the application does not end up with partial or
    corrupted data states. The system might fail to complete the current operation
    (such as updating a record or retrieving data), but it will effectively manage
    resources such as network sockets and memory buffers. The application will catch
    the exception, clean up resources, and ensure its core functionality remains intact
    and ready for subsequent operations.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器应用程序中的网络通信中断**：在一个客户端-服务器应用程序中，如果在关键数据交换过程中网络连接突然丢失，可能会发生意外的异常。在这种情况下，基本的异常安全性确保应用程序不会最终处于部分或损坏的数据状态。系统可能无法完成当前操作（如更新记录或检索数据），但它将有效地管理资源，如网络套接字和内存缓冲区。应用程序将捕获异常，清理资源，并确保其核心功能保持完整并准备好进行后续操作。'
- en: The pivotal role of program invariants in the STL
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序不变量在STL中的关键作用
- en: Imagine you’re crafting a sophisticated application, and at its heart lies the
    C++ `std::vector`, `std::map`, or any other, operates under specific invariants.
    A `std::vector` container, for instance, guarantees contiguous memory. If any
    operation disrupts these invariants, the results can range from performance penalties
    to insidious bugs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个复杂的应用程序，其核心是C++的`std::vector`、`std::map`或其他，它们在特定的不变性下运行。例如，`std::vector`容器保证连续的内存。如果任何操作破坏了这些不变性，结果可能从性能损失到隐秘的bug。
- en: To ensure basic exception safety with the STL, you need to ascertain that operations
    on these containers either succeed or, if they throw an exception, leave the container
    in its original state without violating its invariants. For instance, if a `push_back`
    operation on `std::vector` throws an exception, the vector should remain untouched.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保STL的基本异常安全性，你需要确保对这些容器的操作要么成功，要么在抛出异常时，不违反其不变性，使容器保持其原始状态。例如，如果`std::vector`上的`push_back`操作抛出异常，向量应该保持不变。
- en: 'Let’s look at an example of how we could use basic exception safety when pushing
    data into `std::vector`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用基本异常安全性将数据推入`std::vector`的例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, if an exception occurs (i.e., due to `bad_alloc` if the system
    runs out of memory), the `catch` block handles it. Importantly, if `push_back`
    throws an exception, it guarantees that the state of the vector (`vec`) remains
    unchanged, thus preserving the container’s invariants.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果发生异常（例如，由于系统内存不足导致的`bad_alloc`），`catch`块将处理它。重要的是，如果`push_back`抛出异常，它保证向量的状态（`vec`）保持不变，从而保持容器的不变性。
- en: Resource integrity – the guardian of robust software
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源完整性——稳健软件的守护者
- en: An exception thrown during a memory allocation or other resource-intensive tasks
    can spell disaster if not managed correctly. The STL, however, offers tools that,
    when used aptly, ensure that resources remain intact, even when exceptions loom.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在内存分配或其他资源密集型任务期间抛出异常，如果没有正确管理，可能会造成灾难。然而，STL提供了工具，当适当使用时，确保资源保持完整，即使异常即将发生。
- en: STL containers such as `std::vector` and `std::string` handle their memory.
    If an exception arises during an operation, the container ensures no memory leaks
    occur. Moreover, the idiom **Resource Acquisition Is Initialization** (**RAII**),
    a hallmark of C++ design, assures that resources are acquired upon object creation
    and released when they go out of scope. The RAII principle is a sentinel against
    resource leaks, particularly during exceptions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器，如`std::vector`和`std::string`，处理它们的内存。如果在操作期间出现异常，容器确保不会发生内存泄漏。此外，**资源获取即初始化**（**RAII**），C++设计的标志，确保资源在对象创建时获取，并在它们超出作用域时释放。RAII原则是防止资源泄漏的哨兵，尤其是在异常期间。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: RAII, is a programming idiom used in C++ to manage resource allocation and deallocation.
    In RAII, resources (such as memory, file handles, and network connections) are
    acquired and released by objects. When an object is created (initialized), it
    acquires a resource, and when the object is destroyed (its lifetime ends), it
    releases the resource. This ensures automatic and exception-safe resource management,
    preventing resource leaks and ensuring clean resource release even in the face
    of exceptions. RAII is a fundamental concept in C++ for effective resource management.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是C++中用于管理资源分配和释放的编程习惯。在RAII中，资源（如内存、文件句柄和网络连接）由对象获取和释放。当对象创建（初始化）时，它获取资源，当对象销毁（其生命周期结束）时，它释放资源。这确保了自动和异常安全的资源管理，防止资源泄漏，即使在面对异常的情况下也能确保资源干净释放。RAII是C++中有效资源管理的基本概念。
- en: Harnessing the STL for basic exception safety
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用STL实现基本异常安全性
- en: 'With the STL at your disposal and knowledge of its intricacies, achieving basic
    exception safety becomes less daunting. Consider the following best practices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有STL及其复杂性的知识后，实现基本异常安全性变得不那么令人畏惧。考虑以下最佳实践：
- en: '**Leveraging the copy-and-swap idiom**: When modifying STL containers, a common
    technique to ensure exception safety is to create a copy of the container, perform
    the operations on the copy, and then swap the contents with the original. If an
    exception arises, the original remains unaffected.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用复制和交换习惯用法**：在修改STL容器时，确保异常安全的一种常见技术是创建容器的副本，在副本上执行操作，然后与原始内容交换。如果出现异常，原始容器不受影响。'
- en: '`std::shared_ptr` and `std::unique_ptr` not only manage memory but also guarantee
    no leaks during exceptions.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`和`std::unique_ptr`不仅管理内存，而且在异常期间保证没有泄漏。'
- en: '**Guarded operations**: Before any irreversible operation on an STL container,
    always ensure that any operation that can throw an exception has already been
    executed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的操作**：在STL容器上进行任何不可逆操作之前，始终确保任何可能抛出异常的操作已经执行。'
- en: '**Staying informed with STL documentation**: Familiarize yourself with the
    exception guarantees of STL functions and methods. Awareness of what exceptions
    a particular STL function might throw aids in crafting resilient software.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过STL文档保持信息更新**：熟悉STL函数和方法的异常保证。了解特定STL函数可能抛出的异常有助于构建健壮的软件。'
- en: Embracing basic exception safety with the STL sets the stage for more resilient,
    reliable, and robust software. With this foundational understanding, you’re equipped
    to tackle the intricacies of STL, ensuring that even when the unexpected occurs,
    your software stands unyielding. But this is just the beginning, as the next level,
    strong exception safety, beckons, offering even more robust guarantees and strategies
    to wield the STL with finesse.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用STL拥抱基本的异常安全性为构建更具有弹性、可靠和健壮的软件奠定了基础。有了这种基础理解，你将能够应对STL的复杂性，确保即使遇到意外情况，你的软件也能坚定不移。但这只是开始，因为下一个层次，强大的异常安全性，在召唤，提供更多稳健的保证和策略，以优雅地运用STL。
- en: Strong exception safety
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的异常安全性
- en: As you immerse yourself further into the intricate world of C++ and the STL,
    you’ll encounter the term *strong exception safety*. This is not just fancy jargon
    but also the gold standard in the STL’s exception handling. It guarantees developers
    an assurance like no other – operations will either complete successfully or revert
    to their previous state without any side effects. It’s like having a safety net
    that ensures, come what may, your application’s integrity remains unscathed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进一步沉浸在C++和STL错综复杂的领域中时，你会遇到术语*强大的异常安全性*。这不仅是一句华丽的辞藻，而且是STL异常处理的黄金标准。它向开发者提供了一种前所未有的保证——操作要么成功完成，要么在没有副作用的情况下恢复到之前的状态。这就像有一个安全网，确保无论发生什么情况，你的应用程序的完整性都完好无损。
- en: Navigating STL containers with strong guarantees
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带着强大保证导航STL容器
- en: Remember those dynamic days spent with `std::vector`, `std::map`, and other
    STL containers? Now, think of adding elements, resizing, or even modifying them.
    When these operations succeed, it is business as usual. But if they falter and
    throw an exception, strong exception safety guarantees that the container remains
    as it was, untouched and unaltered.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那些与`std::vector`、`std::map`和其他STL容器共度的动态日子吗？现在，想象一下添加元素、调整大小，甚至修改它们。当这些操作成功时，一切照常进行。但如果它们失败并抛出异常，强大的异常安全性保证容器保持原样，未受影响且未更改。
- en: Achieving this with STL containers, fortunately, doesn’t demand Herculean efforts.
    Many STL container operations naturally provide strong exception safety. But when
    they don’t, techniques such as the *copy-and-swap* idiom rescue them. By operating
    on a copy and swapping the contents with the original only when sure of success,
    you can guarantee no changes to the original container if an exception is thrown.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用STL容器实现这一点并不需要超人的努力。许多STL容器操作自然提供强大的异常安全性。但当他们不提供时，像*复制和交换*这样的技巧可以拯救它们。通过在副本上操作，并在确定成功后才将内容与原始内容交换，你可以保证如果抛出异常，原始容器不会发生变化。
- en: Crafting custom STL containers with strong guarantees
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带着强大保证定制STL容器
- en: 'When venturing into the territory of creating custom STL containers, the responsibility
    to ensure strong exception safety rests squarely on your shoulders. Key strategies
    to achieve this include the following practices:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进入创建自定义STL容器的领域时，确保强大异常安全性的责任就完全落在了你的肩上。实现这一目标的关键策略包括以下实践：
- en: '**Localized commit points**: By delaying any changes that affect the container’s
    state until the very last moment and ensuring that these changes are exception-free
    once started, you solidify a strong guarantee.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地化提交点**：通过将影响容器状态的任何更改推迟到最后时刻，并确保一旦开始这些更改就无异常，你可以巩固强大的保证。'
- en: '**RAII to the forefront**: Harnessing the might of RAII, especially with resource
    management, is pivotal. This ensures that resources are appropriately managed
    and cleaned up if there are exceptions, leaving the container unchanged.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAII的重要性**：利用RAII的力量，特别是与资源管理相结合，至关重要。这确保了资源得到适当的处理，如果发生异常，容器保持不变。'
- en: '**Immutable operations**: Whenever possible, design operations that don’t modify
    the container until they’re sure of success.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变操作**：尽可能设计不修改容器直到成功为止的操作。'
- en: To illustrate the concept of creating custom STL containers with strong guarantees,
    let’s consider the example of a custom container that manages a dynamic array.
    The code will demonstrate localized commit points, the RAII idiom, and immutable
    operations to provide strong exception safety.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明创建具有强保证的自定义 STL 容器的概念，让我们考虑一个管理动态数组的自定义容器的例子。代码将演示局部提交点、RAII 习语和不可变操作，以提供强异常安全性。
- en: First, we are going to create the `CustomArray` class. The `CustomArray` class
    is a template class designed to manage dynamic arrays of a specified data type,
    `T`. It provides essential functionalities for creating, copying, moving, and
    managing dynamic arrays with a strong exception guarantee. The class uses RAII
    principles and leverages `std::unique_ptr` for resource management, ensuring efficient
    and safe memory handling. It supports both copy and move semantics, making it
    suitable for use in various scenarios, such as dynamic array manipulation and
    container reallocation. Let’s walk through this in sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 `CustomArray` 类。`CustomArray` 类是一个模板类，旨在管理指定数据类型 `T` 的动态数组。它提供了创建、复制、移动和管理动态数组的基本功能，并具有强异常保证。该类使用
    RAII 原则，并利用 `std::unique_ptr` 进行资源管理，确保高效且安全的内存处理。它支持复制和移动语义，使其适用于各种场景，如动态数组操作和容器重新分配。让我们分部分来探讨这个问题。
- en: 'We will break this example up into several sections to discuss here. For the
    full code example, please refer to the GitHub repository. First, we will look
    at the constructors:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个例子分成几个部分在这里讨论。对于完整的代码示例，请参阅 GitHub 仓库。首先，我们将查看构造函数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We provided three constructors for our class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的类提供了三个构造函数：
- en: '`explicit CustomArray(size_t size)`: This is the primary constructor of the
    `CustomArray` class. It allows you to create an instance of the class by specifying
    the desired size for the dynamic array. It initializes the `size` member variable
    with the provided size and allocates memory for the dynamic array, using `std::make_unique`.
    It also initializes the elements of the array with default values (assuming that
    type `T` can be safely default-constructed), using `std::fill`. This constructor
    is marked as `explicit`, meaning it cannot be used for implicit type conversions.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`explicit CustomArray(size_t size)`: 这是 `CustomArray` 类的主要构造函数。它允许您通过指定动态数组的大小来创建类的实例。它将
    `size` 成员变量初始化为提供的大小，并使用 `std::make_unique` 为动态数组分配内存。它还使用 `std::fill` 初始化数组的元素为默认值（假设类型
    `T` 可以安全地进行默认构造），此构造函数被标记为 `explicit`，意味着它不能用于隐式类型转换。'
- en: '`CustomArray(const CustomArray &other)`: This is the copy constructor of the
    `CustomArray` class. It allows you to create a new `CustomArray` object that is
    a copy of an existing `CustomArray` object, `other`. It initializes the `size`
    member with the size of `other`, allocates memory for the dynamic array, and then
    uses the `safeCopy` function to perform a deep copy of the data from `other` to
    the new object. This constructor is used when you want to create a new copy of
    an existing object.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomArray(const CustomArray &other)`: 这是 `CustomArray` 类的复制构造函数。它允许您创建一个新的
    `CustomArray` 对象，该对象是现有 `CustomArray` 对象 `other` 的副本。它将 `size` 成员初始化为 `other`
    的大小，为动态数组分配内存，然后使用 `safeCopy` 函数从 `other` 到新对象执行深拷贝。当您想要创建现有对象的副本时，将使用此构造函数。'
- en: '`CustomArray(CustomArray &&other)noexcept`: This is the move constructor of
    the `CustomArray` class. It enables you to efficiently transfer ownership of the
    data from one `CustomArray` object (typically `rvalue`) to another. It transfers
    the ownership of the dynamically allocated array from `other` to the current object
    using `std::move`, updates the `size` member, and sets `size` of `other` to zero
    to indicate that it no longer owns the data. This constructor is marked `noexcept`
    to ensure a strong guarantee during container reallocation, meaning it won’t throw
    exceptions. It’s used when you want to move the contents of one object into another,
    typically for optimization purposes.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomArray(CustomArray &&other)noexcept`：这是 `CustomArray` 类的移动构造函数。它使你能够高效地将数据的所有权从一
    `CustomArray` 对象（通常是 `rvalue`）转移到另一个对象。它使用 `std::move` 将动态分配的数组所有权从 `other` 转移到当前对象，更新
    `size` 成员，并将 `other` 的 `size` 设置为零，以表示它不再拥有数据。此构造函数标记为 `noexcept`，以确保在容器重新分配期间提供强保证，意味着它不会抛出异常。它用于将一个对象的内容移动到另一个对象中，通常用于优化目的。'
- en: 'Next, let’s look at the assignment operator overloads:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看赋值运算符的重载：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we provided two overloads of the assignment operator. These two member
    functions are assignment operators for the `CustomArray` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了赋值运算符的两个重载。这两个成员函数是 `CustomArray` 类的赋值运算符：
- en: '`CustomArray &operator=(const CustomArray &other)`: This is the copy assignment
    operator. It allows you to assign the contents of one `CustomArray` object to
    another of the same type. It performs a deep copy of the data from `other` to
    the current object, ensuring that both objects have independent copies of the
    data. It also updates the `size` member and transfers ownership of the new data
    using `std::move`. The operator returns a reference to the current object, allowing
    for chaining assignments.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomArray &operator=(const CustomArray &other)`：这是复制赋值运算符。它允许你将一个 `CustomArray`
    对象的内容赋值给另一个相同类型的对象。它从 `other` 到当前对象执行数据的深度复制，确保两个对象都有数据的独立副本。它还更新 `size` 成员，并使用
    `std::move` 转移新数据的所有权。运算符返回当前对象的引用，允许链式赋值。'
- en: '`CustomArray &operator=(CustomArray &&other) noexcept`: This is the move assignment
    operator. It allows you to efficiently transfer ownership of the data from one
    `CustomArray` object (typically `rvalue`) to another. It moves `std::unique_ptr`
    containing the data from `other` to the current object, updates the `size` member,
    and sets `size` of `other` to zero to indicate that it no longer owns the data.
    This operator is marked `noexcept` to ensure a strong guarantee during container
    reallocation, meaning it won’t throw exceptions. Like the copy assignment operator,
    it returns a reference to the current object:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomArray &operator=(CustomArray &&other) noexcept`：这是移动赋值运算符。它允许你高效地将数据的所有权从一
    `CustomArray` 对象（通常是 `rvalue`）转移到另一个对象。它将包含数据的 `std::unique_ptr` 从 `other` 移动到当前对象，更新
    `size` 成员，并将 `other` 的 `size` 设置为零，以表示它不再拥有数据。此运算符标记为 `noexcept`，以确保在容器重新分配期间提供强保证，意味着它不会抛出异常。像复制赋值运算符一样，它返回当前对象的引用：'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To summarize this example, the `CustomArray` class demonstrates the following
    principles:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这个例子，`CustomArray` 类展示了以下原则：
- en: '`data`) is only changed at commit points, such as at the end of the copy assignment
    operator, after the success of all operations that could potentially throw an
    exception.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`) 只在提交点改变，例如在复制赋值运算符的末尾，在所有可能抛出异常的操作成功之后。'
- en: '`std::unique_ptr` manages the dynamic array, ensuring that memory is automatically
    deallocated when the `CustomArray` object goes out of scope or an exception occurs.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr` 管理动态数组，确保当 `CustomArray` 对象超出作用域或发生异常时，内存会自动释放。'
- en: '**Immutable operations**: Operations that could throw exceptions, such as memory
    allocation and copying, are performed on temporary objects. The container’s state
    is modified only when these operations are guaranteed to have succeeded.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变操作**：可能抛出异常的操作，如内存分配和复制，是在临时对象上执行的。只有当这些操作保证成功时，容器状态才会被修改。'
- en: This example follows C++ and STL best practices and uses modern C++ features,
    ensuring a custom container that respects strong exception safety guarantees.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例遵循 C++ 和 STL 最佳实践，并使用现代 C++ 功能，确保自定义容器遵守强异常安全性保证。
- en: Infusing exception safety into custom STL algorithms
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将异常安全性引入自定义 STL 算法
- en: Algorithms dance in harmony with data. In the STL, ensuring that custom algorithms
    provide strong exception safety guarantees can be the difference between an efficient
    application and one riddled with unpredictable behaviors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 算法与数据和谐共舞。在 STL 中，确保自定义算法提供强异常安全性保证可能是高效应用程序和充满不可预测行为的应用程序之间的区别。
- en: 'To ensure this, you should keep the following in mind:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这一点，你应该牢记以下几点：
- en: '**Operate on copies**: Wherever feasible, operate on a copy of the data, ensuring
    the original remains unmodified if exceptions are thrown.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作副本**：在可能的情况下，操作数据的副本，确保如果抛出异常，原始数据保持未修改。'
- en: '**Atomic operations**: Design algorithms where operations, once started, are
    completed successfully or can be rolled back without side effects.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子操作**：设计算法，其中操作一旦开始，要么成功完成，要么可以无副作用地回滚。'
- en: Exception safety is the path to robust applications
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常安全性是构建健壮应用程序的途径
- en: Strong exception safety is more than just a tenet – it is a commitment to the
    reliability and robustness of your application. When wielding the STL, its containers,
    and its algorithms or venturing into creating your own, this guarantee stands
    as a bulwark against unforeseen exceptions and unpredictable behaviors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 强异常安全性不仅仅是一个原则——它是对您应用程序可靠性和健壮性的承诺。当使用 STL、其容器和其算法或尝试创建自己的算法时，这一保证就像一道防线，抵御未预见的异常和不可预测的行为。
- en: By ensuring that operations either see through to their successful completion
    or restore the original state, strong exception safety not only elevates the reliability
    of applications but also imbues developers with confidence that their software
    can weather the storms of exceptions, leaving the integrity of their data and
    resources intact.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保操作要么看到其成功完成，要么恢复到原始状态，强异常安全性不仅提高了应用程序的可靠性，而且使开发者对其软件能够经受异常风暴的考验充满信心，保持其数据和资源的完整性。
- en: With this, we wrap up our exploration of exception safety in the STL. As we
    explored basic and strong guarantees, the hope is that you’re now equipped with
    the knowledge and tools to craft resilient and dependable C++ applications. And
    remember that in the dynamic world of software development, it is not just about
    preventing exceptions but also ensuring we’re prepared when they arise. Next,
    we will examine the use of `noexcept` on STL operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们就结束了我们对 STL 中异常安全性的探索。在我们探讨了基本和强保证之后，希望你现在已经具备了构建健壮和可靠的 C++ 应用程序的知识和工具。并且记住，在软件开发的动态世界中，不仅是要防止异常，还要确保我们准备好应对它们的出现。接下来，我们将检查
    STL 操作中使用 `noexcept` 的情况。
- en: The effect of noexcept on STL operations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: noexcept 对 STL 操作的影响
- en: The C++ STL gives a rich assortment of data structures and algorithms that greatly
    simplify programming in C++. Exception safety is a critical aspect of robust C++
    programming, and the `noexcept` specifier plays a pivotal role in achieving it.
    This section elucidates the impact of noexcept on STL operations and how its correct
    application can enhance the reliability and performance of STL-based code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL 提供了丰富的数据结构和算法，极大地简化了 C++ 的编程。异常安全性是健壮 C++ 编程的关键方面，`noexcept` 指定符在实现它方面发挥着关键作用。本节阐述了
    noexcept 对 STL 操作的影响以及其正确应用如何提高基于 STL 的代码的可靠性和性能。
- en: An introduction to noexcept
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: noexcept 简介
- en: Introduced in C++11, `noexcept` is a specifier that can be added to function
    declarations to indicate that the function is not expected to throw exceptions.
    When a function is declared with `noexcept`, it enables specific optimizations
    and guarantees that make exception handling more predictable. For instance, when
    an exception is thrown from a `noexcept` function, the program calls `std::terminate`,
    as the function violated its contract of not throwing exceptions. Hence, `noexcept`
    is a commitment that a function promises to uphold.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 中引入的 `noexcept` 是一个可以添加到函数声明中的指定符，表示该函数不期望抛出异常。当一个函数用 `noexcept` 声明时，它启用特定的优化并确保异常处理更加可预测。例如，当从
    `noexcept` 函数抛出异常时，程序会调用 `std::terminate`，因为该函数违反了其不抛出异常的合同。因此，`noexcept` 是一个函数承诺遵守的承诺。
- en: Application to STL data types
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于 STL 数据类型
- en: Using `noexcept` with STL data types primarily affects the move operations –
    move constructors and move assignment operators. These operations are fundamental
    to the performance of STL containers, since they allow the transfer of resources
    from one object to another without costly deep copies. When these operations are
    `noexcept`, STL containers can safely perform optimizations, such as reallocating
    buffers more efficiently during resizing operations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL数据类型中使用`noexcept`主要影响移动操作——移动构造函数和移动赋值运算符。这些操作对于STL容器的性能至关重要，因为它们允许在不进行昂贵的深拷贝的情况下将资源从一个对象转移到另一个对象。当这些操作是`noexcept`时，STL容器可以安全地进行优化，例如在调整大小操作期间更有效地重新分配缓冲区。
- en: Consider a scenario with `std::vector`, an STL container that dynamically resizes
    itself as elements are added. Suppose the vector holds objects of a type whose
    move constructor is `noexcept`. In that case, the vector can reallocate its internal
    array by moving the objects to the new array without the overhead of handling
    potential exceptions. If the move constructor is not `noexcept`, the vector must
    use the copy constructor instead, which is less efficient and might throw exceptions,
    leading to a potential partial state and loss of strong exception safety.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个使用`std::vector`的场景，这是一个STL容器，它会在添加元素时动态调整大小。假设向量包含的对象类型具有`noexcept`的移动构造函数。在这种情况下，向量可以通过将对象移动到新数组来重新分配其内部数组，而无需处理潜在异常的开销。如果移动构造函数不是`noexcept`，则向量必须使用复制构造函数，这效率较低，可能会抛出异常，导致潜在的部分状态和强异常安全性的损失。
- en: Application to STL algorithms
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于STL算法
- en: The impact of `noexcept` extends beyond data types to algorithms. STL algorithms
    can offer stronger guarantees and perform better when working with functions that
    are `noexcept`. For example, `std::sort` can execute more efficiently if its comparison
    function does not throw exceptions. The algorithm can optimize its implementation,
    knowing that it does not need to account for the complications that arise from
    exception handling.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`的影响不仅限于数据类型，还扩展到算法。当与`noexcept`函数一起工作时，STL算法可以提供更强的保证并表现出更好的性能。例如，如果`std::sort`的比较函数不抛出异常，则它可以更有效地执行。算法可以优化其实施，因为它知道它不需要考虑由异常处理引起的复杂情况。'
- en: Let’s take the `std::for_each` algorithm, which applies a function to a range
    of elements. If the used function is marked as `noexcept`, `std::for_each` can
    operate with the understanding that exceptions will not interrupt the iteration.
    This can lead to better inlining and reduced overhead, as the compiler does not
    need to generate additional code to handle exceptions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`std::for_each`算法为例，该算法将一个函数应用于一系列元素。如果使用的函数被标记为`noexcept`，则`std::for_each`可以在理解异常不会中断迭代的情况下操作。这可以导致更好的内联和减少开销，因为编译器不需要生成额外的代码来处理异常。
- en: 'Consider the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the lambda function passed to `std::for_each` is declared `noexcept`.
    This informs the compiler and the algorithm that the function is guaranteed not
    to throw any exceptions, allowing potential performance optimizations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，传递给`std::for_each`的lambda函数被声明为`noexcept`。这通知编译器和算法该函数保证不会抛出任何异常，从而允许潜在的性能优化。
- en: The `noexcept` specifier is a powerful tool for C++ developers, providing performance
    optimizations and semantic guarantees about exception safety. When applied judiciously
    to STL operations, `noexcept` enables STL containers and algorithms to operate
    more efficiently and reliably. Understanding and using `noexcept` appropriately
    is essential for intermediate-level C++ developers looking to write high-quality,
    exception-safe code with STL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`指定符是C++开发者的一项强大工具，它提供了性能优化和关于异常安全的语义保证。当明智地应用于STL操作时，`noexcept`使STL容器和算法能够更高效、更可靠地操作。对于希望编写高质量、异常安全代码的中级C++开发者来说，理解和适当地使用`noexcept`是至关重要的。'
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked to understand the crucial concept of exception safety
    with the STL. We explored the different levels of exception safety, namely basic
    and strong guarantees, and outlined strategies to ensure that your programs are
    resilient to exceptions. We learned how to maintain program invariants and resource
    integrity through detailed discussions, mainly focusing on RAII principles and
    guarded operations to prevent resource leaks and maintain container states during
    exceptions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图通过STL来理解异常安全性的关键概念。我们探讨了不同级别的异常安全性，即基本和强保证，并概述了确保您的程序能够抵抗异常的策略。我们通过详细的讨论学习了如何维护程序不变性和资源完整性，主要关注RAII原则和受保护操作，以防止资源泄露并在异常期间保持容器状态。
- en: Understanding exception safety is indispensable for writing robust C++ applications.
    It ensures that, even in the face of errors, your software’s integrity remains
    intact, preventing resource leaks and preserving the validity of data structures.
    This knowledge is the backbone of reliable and maintainable code, as it allows
    us to uphold strong guarantees that our applications will behave predictably under
    exceptional conditions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 理解异常安全性对于编写健壮的C++应用程序至关重要。它确保即使在出现错误的情况下，您的软件的完整性保持完好，防止资源泄露并保持数据结构的有效性。这种知识是可靠和可维护代码的基石，因为它使我们能够保持强有力的保证，即我们的应用程序在异常情况下将表现出可预测的行为。
- en: In the next chapter, titled *Thread Safety and Concurrency with the STL*, we
    will build upon the foundation of exception safety to tackle the intricacies of
    concurrent programming in C++.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，标题为《使用STL的线程安全和并发》，我们将基于异常安全性的基础来处理C++中并发编程的复杂性。
