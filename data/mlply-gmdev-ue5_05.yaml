- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing Actors in a Multiplayer Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多人环境中管理Actor
- en: To properly set up a multiplayer environment in UE5, it’s important that you
    understand how an Actor’s connection is managed, as well as how its attributes
    are relevant during a game session.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中正确设置多人环境时，了解Actor的连接管理方式以及其属性在游戏会话中的相关性非常重要。
- en: In this chapter, you will begin enhancing the player character (which currently
    is just an empty shell) to gain a comprehensive understanding of the previously
    mentioned concepts. To do this, you’ll add more components to the Character class
    (a camera is something you will absolutely need!) and implement the player input
    logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将开始增强玩家角色（目前只是一个空壳），以全面理解之前提到的概念。为此，您将为Character类添加更多组件（相机是您绝对需要的！）并实现玩家输入逻辑。
- en: Additionally, you will learn why it is important to know who owns an Actor in
    a multiplayer environment and how it behaves depending on how it is relevant in
    the level.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还将了解在多人环境中知道谁拥有Actor的重要性，以及它如何根据其在关卡中的相关性而表现不同。
- en: By the end of the chapter, you will have solid knowledge of how to manage an
    Actor within an Unreal multiplayer game, allowing you to create more robust and
    efficient multiplayer experiences.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备如何管理Unreal多人游戏中的Actor的扎实知识，这将使您能够创建更稳健和高效的多人体验。
- en: 'So, in this chapter, I will present you with the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我将向您介绍以下主题：
- en: Setting up the character
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置角色
- en: Controlling the connection of an Actor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制Actor的连接
- en: Understanding Actor relevancy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Actor的相关性
- en: Introducing authority
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍权限
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous chapter and understood its content.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，您应该已完成上一章，并理解其内容。
- en: Additionally, if you would prefer to begin with the code from the companion
    repository for this book, you can download the `.zip` project files at [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您希望从本书的配套仓库开始编写代码，您可以下载`.zip`项目文件，链接为[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)。
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 04``End` link.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击`Unreal Shadows –` `第四章` `结束`链接下载与上一章结尾同步的文件。
- en: Setting up the character
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置角色
- en: Before I start writing about topics such as connections, authority, and roles,
    I need you to properly set up the player character – at the moment, our poor hero
    is just represented by an empty class!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始撰写关于连接、权限和角色等主题之前，我需要您正确设置玩家角色——目前，我们可怜的英雄只是一个空类！
- en: So, in this section, you will add a camera and some user input and set up the
    main functionalities that will allow the thief character to move around the level
    in search of treasures and gold!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，您将添加一个相机和一些用户输入，并设置允许盗贼角色在关卡中移动以寻找宝藏和金子的主要功能！
- en: Adding basic settings to the character
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为角色添加基本设置
- en: 'In the next few steps, you’ll add the components that will make up the third-person
    camera behavior and implement their logic. After that, you’ll set some default
    values for the components that are already available in the Character class: the
    Arrow, Capsule, and SkeletalMesh components.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，您将添加构成第三人称相机行为的组件，并实现它们的逻辑。之后，您将为Character类中已存在的组件设置一些默认值：箭头、胶囊和骨骼网格组件。
- en: Adding a Camera component to the character
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为角色添加相机组件
- en: 'To get started, open the `US_Character.h` header class. You will be adding
    a Camera component and a Spring component that will connect the camera to the
    Capsule component available in the Character class. To do this, add these two
    component declarations after the `GENERATED_BODY()` macro:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开`US_Character.h`头文件。您将添加一个相机组件和一个弹簧组件，将相机连接到Character类中可用的胶囊组件。为此，在`GENERATED_BODY()`宏之后添加这两个组件声明：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous code block, we are declaring a Camera component and a Spring
    component that will create the camera system. First, you will notice the `UPROPERTY()`
    declaration on both variables with some property specifiers. Let me explain them:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们正在声明一个相机组件和一个弹簧组件，这将创建相机系统。首先，你会注意到两个变量上都有`UPROPERTY()`声明和一些属性指定符。让我来解释一下：
- en: The `VisibleAnywhere` property indicates that this property is visible in all
    related windows of the Unreal Engine Editor but cannot be edited
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibleAnywhere`属性表示这个属性在所有相关的虚幻引擎编辑器窗口中都是可见的，但不能被编辑'
- en: The `BlueprintReadOnly` property indicates that this property can be read by
    Blueprints but not modified
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintReadOnly`属性表示这个属性可以被蓝图读取但不能修改'
- en: The `Category` property specifies the category of the property when displayed
    in the **Blueprint** **Details** panel
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category`属性指定了当在**蓝图****详情**面板中显示属性时的类别'
- en: 'You will also notice a `meta` declaration that lets you control how the property
    interacts with various aspects of Unreal Engine and the Editor: in this case,
    `AllowPrivateAccess` indicates that a private member should be accessible from
    a Blueprint. We need this as these properties’ accessibility is not explicitly
    declared, and so they default to `private`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到一个`meta`声明，它让你可以控制属性如何与虚幻引擎和编辑器的各个方面交互：在这种情况下，`AllowPrivateAccess`表示私有成员应该可以从蓝图访问。我们需要这个声明，因为这些属性的访问性没有明确声明，因此它们默认为`private`。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For an exhaustive list of property specifiers, please check the official Epic
    Games documentation, which can be found here: [https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/](https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性指定符的详尽列表，请查看官方Epic Games文档，可以在以下链接找到：[https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/](https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/)。
- en: Next, look at the `class` keyword before the type – this is a C++ **class forward
    declaration**. If you are unfamiliar with this, it is a way to declare the class
    name and its members without providing the full class definition. This can be
    useful in situations where you want to use a class in a header file but do not
    want to include the entire class definition, which can make compilation slower
    and create unnecessary dependencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看类型之前的`class`关键字——这是一个C++的**类前向声明**。如果你不熟悉这个概念，它是一种在不提供完整类定义的情况下声明类名及其成员的方法。这在你想在头文件中使用一个类但不想包含整个类定义的情况下很有用，这可能会使编译变慢并创建不必要的依赖。
- en: Lastly, you will notice the `TObjectPtr<T>` template – this is a new addition
    in UE5 and has been introduced to replace raw pointers (for example, `USpringComponent*`)
    in header files with UProperties. The `TObjectPtr<T>` template is intended only
    for member properties declared in the headers of your code. For functions and
    short-lived scope within your C++ code in `.cpp` files, using `TObjectPtr<T>`
    provides no additional advantages over using raw pointers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会注意到`TObjectPtr<T>`模板——这是UE5中的一个新特性，它被引入来替换头文件中的原始指针（例如，`USpringComponent*`）与UProperties。`TObjectPtr<T>`模板仅适用于在代码头文件中声明的成员属性。对于`.cpp`文件中的函数和短生命周期范围，使用`TObjectPtr<T>`与使用原始指针相比没有提供额外的优势。
- en: 'As the Camera and Spring components are private, you need to add two getter
    methods for them. Inside the `public` declaration of the header, locate this line
    of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相机和弹簧组件是私有的，你需要为它们添加两个getter方法。在头文件的`public`声明中，找到以下代码行：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, below this line, add the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这行代码下面添加以下内容：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two methods will let you access the pointer components, and the `FORCEINLINE`
    macro forces the code to be inlined; this is going to give your code some performance
    benefits as you will avoid a function call when using this method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法将允许你访问指针组件，并且`FORCEINLINE`宏强制代码内联；这将给你的代码带来一些性能优势，因为当你使用这种方法时，你将避免函数调用。
- en: Implementing the camera behavior
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现相机行为
- en: 'Now that your properties have been added, it’s time to add some code logic
    to handle them. Open the `.cpp` file and add the following includes at its top:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的属性已经添加好了，是时候添加一些代码逻辑来处理它们了。打开`.cpp`文件，并在其顶部添加以下包含：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, inside the constructor (i.e., `AUS_Character::AUS_Character()`), add
    this code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数（即`AUS_Character::AUS_Character()`）中添加以下代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `CreateDefaultSubobject()<T>` is a function that is used to create a new
    subobject of a class that will be owned by another object. A **Subobject** is
    essentially a component or a member variable of an object, and the method is typically
    called within an object’s constructor to initialize its subobjects (in this case,
    the components).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CreateDefaultSubobject()<T>`是一个用于创建一个新子对象的功能，该子对象将由另一个对象拥有。**子对象**本质上是一个对象的组件或成员变量，该方法通常在对象的构造函数中调用以初始化其子对象（在这种情况下，是组件）。
- en: The `SetupAttachment()` method will reparent a component to another one. In
    this case, you are attaching the Camera component to `RootComponent`, which is
    actually the Capsule component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupAttachment()`方法会将一个组件重新父化到另一个组件。在这种情况下，你将相机组件附加到`RootComponent`，实际上它是胶囊组件。'
- en: 'Let’s give the camera a similar treatment. Add this code block just after the
    previous lines of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给相机同样的处理。在之前的代码行之后添加此代码块：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only real difference here is that you are reparenting the camera to the
    Spring component instead of the root one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一真正区别是，你将相机重新父化到弹簧组件而不是根组件。
- en: You have just created some sort of “chain of command” where the camera is connected
    to the Spring component that is connected to the root of the Actor – this will
    let the camera follow the character with a “springy” behavior whenever the camera
    hits an obstacle and provide a better feel for the player.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一种“命令链”，其中相机连接到与Actor根连接的弹簧组件——这将在相机撞击障碍物时让相机以“弹簧”行为跟随角色，并为玩家提供更好的感觉。
- en: Setting up the default component properties
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认组件属性
- en: 'As a last step, you’ll be modifying some properties to create a default setup
    for your Character class. In the constructor, add these lines of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，你将修改一些属性以创建Character类的默认设置。在构造函数中添加以下代码行：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you are just changing some of the default values of the character Actor
    and its components. The only thing to note is that you are getting the character
    model and assigning it to `SkeletalMeshComponent` by means of the `FObjectFinder()`
    utility method available in the `ConstructorHelpers` class you’ve used before.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只是更改了角色Actor及其组件的一些默认值。需要注意的是，你通过`FObjectFinder()`实用方法（在之前使用的`ConstructorHelpers`类中可用）获取角色模型并将其分配给`SkeletalMeshComponent`。
- en: Updating the Character Blueprint
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新角色蓝图
- en: Now it’s time to compile your project, just to check that you don’t have any
    syntax errors and that the character has been properly set up. To do this, save
    your files, go back to the Unreal Editor, and click the **Compile** button.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编译你的项目了，只是为了检查你没有语法错误，并且角色已经正确设置。为此，保存你的文件，回到Unreal编辑器，并点击**编译**按钮。
- en: 'Once the compilation phase has finished, open the **BP_Character** Blueprint,
    and you should notice that your changes didn’t show up. This happens because the
    Blueprint has not been updated. To fix this, select **File** | **Refresh All nodes**.
    You should now see the **Camera Boom** and **Follow Camera** elements added to
    the hierarchy in the **Components** panel, as depicted in *Figure 5**.1*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译阶段完成，打开**BP_Character**蓝图，你应该注意到你的更改没有显示出来。这是因为蓝图尚未更新。要修复这个问题，选择**文件** |
    **刷新所有节点**。现在你应该在**组件**面板中看到添加到层次结构中的**相机吊杆**和**跟随相机**元素，如图*图5.1*所示：
- en: '![Figure 5.1 – The newly added character components](img/Figure_05_01_B18203.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 新增的角色组件](img/Figure_05_01_B18203.jpg)'
- en: Figure 5.1 – The newly added character components
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 新增的角色组件
- en: 'You probably still won’t see the updated mesh in the SkeletalMesh component.
    To fix this, take the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能仍然看不到更新后的网格在骨骼网格组件中。要修复这个问题，请执行以下步骤：
- en: Select the **Mesh** elements in the **Components** panel and look for the **Skeletal
    Mesh Asset** field in the **Details** panel.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中选择**网格**元素，并在**细节**面板中查找**骨骼网格资产**字段。
- en: 'If **Skeletal Mesh Asset** shows a value of **None**, click on the **Reset
    Property** arrow next to it, as shown in *Figure 5**.2*:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**骨骼网格资产**显示为**None**，点击它旁边的**重置属性**箭头，如图*图5.2*所示：
- en: '![Figure 5.2 – The Reset Property button](img/Figure_05_02_B18203.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 重置属性按钮](img/Figure_05_02_B18203.jpg)'
- en: Figure 5.2 – The Reset Property button
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 重置属性按钮
- en: Double-check the **Use Controller Rotation Yaw Y** property, as it may also
    need a reset.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细检查**使用控制器旋转偏航Y**属性，因为它可能也需要重置。
- en: 'Now you should be able to see the viewport updated with the selected mesh added
    to it, as shown in *Figure 5**.3*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够看到视口已经更新，并添加了选定的网格，如图 *图 5**.3* 所示：
- en: '![Figure 5.3 – The updated character Blueprint](img/Figure_05_03_B18203.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 更新的角色蓝图](img/Figure_05_03_B18203.jpg)'
- en: Figure 5.3 – The updated character Blueprint
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 更新的角色蓝图
- en: With your character set up, it’s time to make it move by adding some user interaction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的角色设置完成后，就是时候通过添加一些用户交互来让它动起来了。
- en: Adding interaction to the character
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为角色添加交互
- en: Now we will add input settings for the character. To do this, we will be using
    the new **Enhanced Input System** that has been introduced in UE5\. This new system
    provides developers with more advanced features than the previous one (known simply
    as the Input System), such as complex input handling and runtime control remapping.
    As the old system is being deprecated, it will probably be removed from Unreal
    Engine sooner or later, so it is best to stay updated on the changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为角色添加输入设置。为此，我们将使用 UE5 中引入的新 **增强输入系统**。这个新系统为开发者提供了比之前一个（简单地称为输入系统）更高级的功能，例如复杂的输入处理和运行时控制重映射。由于旧系统正在被弃用，它可能迟早会被从
    Unreal Engine 中移除，因此最好保持对变化的关注。
- en: 'The most important thing to know about the Enhanced Input System is how it
    communicates with your code: this is achieved through **Input Actions** that represent
    what the character can do during play (i.e., walk, jump, or attack). A group of
    Input Actions can be collected inside an **Input Mapping Context** that represents
    a set of rules for what will trigger the included actions.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于增强输入系统，最重要的是了解它与你的代码如何通信：这是通过表示角色在游戏过程中可以做什么的 **输入动作** 来实现的（即，行走、跳跃或攻击）。一组输入动作可以收集在一个
    **输入映射上下文** 中，它代表了一组触发包含动作的规则。
- en: At runtime, UE5 will check a list of **Input Triggers** to determine how user
    input activated an Input Action, validating patterns such as long presses, release
    events, or double-clicks. Before triggering inputs, the system can pre-process
    the raw input through a list of **Input Modifiers** that will alter the data,
    such as setting a custom dead zone for the thumbstick or getting a negative value
    from the input itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，UE5 将检查一个输入触发器列表，以确定用户输入如何激活输入动作，验证如长按、释放事件或双击等模式。在触发输入之前，系统可以通过一系列 **Input
    Modifiers** 预处理原始输入，这些修改器将改变数据，例如为摇杆设置自定义的死区或从输入本身获取负值。
- en: In this section, you’ll create some basic interaction for your character, which
    needs to move, sprint, and interact with objects (we’ll leave the attack actions
    to later chapters). The sprint and interact actions will be activated by pressing
    a button, while the move action will be controlled by a keyboard/mouse combo or
    by the controller thumbsticks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为你的角色创建一些基本的交互，包括移动、冲刺和与物体交互（我们将攻击动作留到后面的章节）。冲刺和交互动作将通过按下一个按钮来激活，而移动动作将由键盘/鼠标组合或控制器摇杆控制。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to explore the full range of possibilities offered by the Enhanced
    Input System, you can check the official documentation by visiting this web page:
    [https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要探索增强输入系统提供的全部可能性，你可以通过访问这个网页来查看官方文档：[https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/)。
- en: Creating Input Actions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建输入动作
- en: 'To start creating Input Actions, take the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建输入动作，请按照以下步骤操作：
- en: Open your `Input`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `Input`。
- en: Inside the folder, right-click and select **Input** | **Input Action** to create
    an Input Action asset.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹内，右键单击并选择 **Input** | **Input Action** 来创建一个输入动作资产。
- en: Name it `IA_Interact`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `IA_Interact`。
- en: Create three other Input Actions and name them `IA_Look`, `IA_Move`, and `IA_Sprint`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另外三个输入动作，并将它们命名为 `IA_Look`、`IA_Move` 和 `IA_Sprint`。
- en: 'Let’s begin editing the **IA_Interact** action – we need it to be activated
    by a single press of a button (or key), and this action should be dispatched the
    moment the button has been pressed. To do so, double-click on the asset to open
    it and do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编辑 **IA_Interact** 动作 – 我们需要它通过单次按钮（或按键）按下激活，并且这个动作应该在按钮按下的一瞬间被触发。为此，双击资产以打开它，并执行以下操作：
- en: Click on the **+** button next to the **Triggers** field to add a trigger.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Triggers** 字段旁边的 **+** 按钮，添加一个触发器。
- en: Click the dropdown that should have been created and select **Pressed** – this
    option will avoid dispatching multiple events if the player holds the button.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建的下拉菜单并选择 **按下** – 此选项将避免在玩家按住按钮时触发多个事件。
- en: Leave the rest as it is – just check that **Value Type** has been set to the
    default value of **Digital (bool)**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他保持不变 - 只需确保 **值类型** 已设置为默认值 **数字（bool）**。
- en: 'The final result of the interact action asset is shown in *Figure 5**.4*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 交互动作资产的最终结果如图 *图 5**.4* 所示：
- en: '![Figure 5.4 – The interact action settings](img/Figure_05_04_B18203.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 交互动作设置](img/Figure_05_04_B18203.jpg)'
- en: Figure 5.4 – The interact action settings
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 交互动作设置
- en: The **IA_Sprint** action is pretty similar to the interact one but needs to
    trigger a press event when the character starts sprinting and trigger a release
    event when the character stops sprinting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**IA_Sprint** 动作与交互动作非常相似，但需要在角色开始冲刺时触发一个按下事件，在角色停止冲刺时触发一个释放事件。'
- en: 'Double-click on the **IA_Sprint** asset to open it and change the settings
    as described here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 **IA_Sprint** 资产以打开它并按以下说明更改设置：
- en: Add two triggers by clicking the **+** button next to the **Triggers** field
    twice.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **Triggers** 字段旁边的 **+** 按钮两次添加两个触发器。
- en: Click the first dropdown that should have been created and select **Pressed**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建的第一个下拉菜单并选择 **按下**。
- en: Click the second dropdown and select **Released**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第二个下拉菜单并选择 **已释放**。
- en: Leave the rest as it is, checking that **Value Type** has been set to the default
    value of **Digital (bool)**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他保持不变，确保 **值类型** 已设置为默认值 **数字（bool）**。
- en: 'The final result of the sprint action asset is shown in *Figure 5**.5*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 冲刺动作资产的最终结果如图 *图 5**.5* 所示：
- en: '![Figure 5.5 – The sprint action settings](img/Figure_05_05_B18203.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 冲刺动作设置](img/Figure_05_05_B18203.jpg)'
- en: Figure 5.5 – The sprint action settings
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 冲刺动作设置
- en: 'It’s time to set up the **IA_Move** asset, so open it and simply change **Value
    Type** to **Axis2D (Vector2D)** as shown in *Figure 5**.6*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候设置 **IA_Move** 资产了，所以打开它并将 **值类型** 更改为如图 *图 5**.6* 所示：
- en: '![Figure 5.6 – The move action settings](img/Figure_05_06_B18203.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 移动动作设置](img/Figure_05_06_B18203.jpg)'
- en: Figure 5.6 – The move action settings
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 移动动作设置
- en: 'As a last step, open the **AI_Look** asset and change **Value Type** to **Axis2D
    (Vector2D)**, as shown in *Figure 5**.7*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，打开 **AI_Look** 资产并将 **值类型** 更改为 **Axis2D (Vector2D)**，如图 *图 5**.7* 所示：
- en: '![Figure 5.7 – The look action settings](img/Figure_05_07_B18203.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 查看动作设置](img/Figure_05_07_B18203.jpg)'
- en: Figure 5.7 – The look action settings
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 查看动作设置
- en: Now that the basic actions have been defined, it’s time to create the Mapping
    Context and set its properties.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本动作已经定义，是时候创建映射上下文并设置其属性了。
- en: Setting up the Input Mapping Context
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置输入映射上下文
- en: 'As explained already, a Mapping Context refers to a set of Input Actions that
    identifies a specific situation in which the player may find themselves. The “context”
    you need to create here is the base actions a character can do (move, look around,
    and interact), so it’s time to open the **Content Browser** and create this asset:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，映射上下文指的是一组输入动作，它标识玩家可能遇到的具体情况。这里需要创建的是角色可以执行的基本动作（移动、环顾四周和交互），因此是时候打开 **内容浏览器**
    并创建此资产：
- en: Right-click on the `Input` folder and select **Input** | **Input** **Mapping
    Context**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Input` 文件夹并选择 **Input** | **Input Mapping Context**。
- en: Name the newly created asset `IMC_Default` and double-click on it to start editing.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为 `IMC_Default` 并双击它以开始编辑。
- en: Click the **+** button next to the **Mappings** field. In the drop-down menu,
    select **IA_Interact**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Mappings** 字段旁边的 **+** 按钮。在下拉菜单中，选择 **IA_Interact**。
- en: Repeat this step three more times to add **IA_Sprint**, **IA_Move**, and **IA_Look**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此步骤三次以添加 **IA_Sprint**、**IA_Move** 和 **IA_Look**。
- en: 'By the end of these steps, you should have something similar to *Figure 5**.8*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到这些步骤结束时，你应该会有类似于 *图 5**.8* 的内容：
- en: '![Figure 5.8 – The Input Mapping Context panel](img/Figure_05_08_B18203.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 输入映射上下文面板](img/Figure_05_08_B18203.jpg)'
- en: Figure 5.8 – The Input Mapping Context panel
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 输入映射上下文面板
- en: Now that the context has been created, it’s time to map the input the player
    will be using. As I have stated before, we’ll let them use a controller or a mix
    of keyboard and mouse interaction. At the moment, all mappings should be set to
    **None**; this means that no input will pass through this context.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上下文已经创建，是时候映射玩家将使用的输入了。正如我之前所述，我们将允许他们使用控制器或键盘和鼠标交互的混合。目前，所有映射都应该设置为**无**；这意味着没有输入将通过此上下文。
- en: 'Let’s solve this by starting with the **IA_Interact** mapping:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过从**IA_Interact**映射开始解决这个问题：
- en: Click on the keyboard icon below **IA_Interact** and press the *I* (for Interact)
    key on your keyboard.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**IA_Interact**下面的键盘图标，并按下键盘上的*I*（交互）键。
- en: Then click on the **+** button to the right of the **IA_Interact** field to
    add another mapping.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**IA_Interact**字段右侧的**+**按钮以添加另一个映射。
- en: From the drop-down menu, select **Gamepad** | **Gamepad Face Button Bottom**.
    Alternatively, if you have a game controller connected to your PC, you can simply
    click on the keyboard icon and then press the corresponding button (for instance,
    the *A* button for an Xbox controller).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**游戏手柄** | **游戏手柄面按钮底部**。或者，如果你有一个连接到你的PC的游戏控制器，你可以简单地点击键盘图标，然后按下相应的按钮（例如，Xbox控制器的*A*按钮）。
- en: 'Now we are going to set the mapping for **IA_Sprint**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置**IA_Sprint**的映射：
- en: Set **Left Shift** for if the player is using the keyboard.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家使用键盘，则设置**左Shift**。
- en: Set **Gamepad** | **Gamepad Left Thumbstick Button** for if the player is using
    the controller (this second option will allow the player to press the thumbstick
    to sprint).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家使用控制器，则设置**游戏手柄** | **游戏手柄左摇杆按钮**（此第二个选项将允许玩家按下摇杆以冲刺）。
- en: 'Next, **IA_Move** will let the player use the left thumbstick controller or
    the usual WASD keys – this means you will add five interactions: one for the thumbstick
    and then four for the up, down, left, and right directions. Let’s add them to
    the Mapping Context, starting with the thumbstick settings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**IA_Move**将允许玩家使用左摇杆控制器或常用的WASD键——这意味着你需要添加五个交互：一个用于摇杆，然后是上、下、左和右方向的四个交互。让我们将它们添加到映射上下文中，从摇杆设置开始：
- en: Add **Gamepad** | **Gamepad Left Thumbstick 2D-Axis** to the mappings. Additionally,
    add a modifier from the **Modifiers** list with the value **Dead Zone**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**游戏手柄** | **游戏手柄左摇杆2D轴**添加到映射中。此外，从**修饰符**列表中添加一个具有值**Dead Zone**的修饰符。
- en: Moving on to the directions, for the right direction (mapped on your keyboard
    as *D*), add a **Keyboard** | **D** mapping with no modifiers.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是方向，对于右方向（在键盘上映射为*D*），添加一个没有修饰符的**键盘** | **D** 映射。
- en: For the left direction (mapped on your keyboard as *A*), add a **Keyboard**
    | **A** mapping. Then add a modifier with the value **Negate**. This will grant
    negative values from this interaction (i.e., movements to the right are positive,
    while movements to the left are negative).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于左方向（在键盘上映射为*A*），添加一个**键盘** | **A** 映射。然后添加一个具有值**Negate**的修饰符。这将从这个交互中赋予负值（即，向右移动是正值，而向左移动是负值）。
- en: For the forward direction (mapped on your keyboard as *W*), add a **Keyboard**
    | **W** mapping. Then, add a modifier with the value **Swizzle Input Axis Values**,
    which will convert *x* values into *y* (and vice versa), so you’ll get a “forward”
    value for your character.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于前进方向（在键盘上映射为*W*），添加一个**键盘** | **W** 映射。然后，添加一个具有值**Swizzle Input Axis Values**的修饰符，这将把*x*值转换为*y*（反之亦然），因此你会为你的角色获得一个“前进”值。
- en: Lastly, for the backward direction (mapped on your keyboard as *S*), add a **Keyboard**
    | **S** mapping. Then, add a modifier with the value **Swizzle Input Axis Values**
    and an additional one with the value **Negate**. This will grant negative values
    from this interaction in a similar way to the left movement explained for the
    *A* key.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于后退方向（在键盘上映射为*S*），添加一个**键盘** | **S** 映射。然后，添加一个具有值**Swizzle Input Axis Values**的修饰符和一个具有值**Negate**的附加修饰符。这将以与*A*键中解释的左移动类似的方式，从这个交互中赋予负值。
- en: 'Finally, the **IA_Look** mapping is going to be controlled by the right thumbstick
    of the controller or by the movement of the mouse. To add such settings, take
    these steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**IA_Look**映射将由控制器的右摇杆或鼠标的移动控制。要添加这些设置，请执行以下步骤：
- en: From the drop-down menu, select **Gamepad** | **Gamepad Right Thumbstick 2D-Axis**
    for the controller. Additionally, add a modifier from the **Modifiers** list with
    a value of **Dead Zone**, so the thumbstick won’t send data when in the rest position.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择控制器为 **Gamepad** | **Gamepad Right Thumbstick 2D-Axis**。此外，从 **Modifiers**
    列表中添加一个值为 **Dead Zone** 的修饰符，这样摇杆在静止位置时不会发送数据。
- en: Select a **Mouse** | **Mouse XY 2D-Axis** interaction for the mouse. Then add
    a modifier from the **Modifiers** list with the value **Negate** and uncheck the
    **X** and **Z** checkboxes, leaving just the **Y** value selected. This will grant
    negative values for the mouse interaction – for instance, moving it forward will
    let the character move the camera down, and moving it backward will move the camera
    up.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为鼠标选择 **Mouse** | **Mouse XY 2D-Axis** 交互。然后从 **Modifiers** 列表中添加一个值为 **Negate**
    的修饰符，并取消选择 **X** 和 **Z** 复选框，只保留 **Y** 值被选中。这将赋予鼠标交互负值 – 例如，向前移动将使角色向下移动相机，向后移动将使相机向上移动。
- en: 'You should now have a Mapping Context similar to the one shown in *Figure 5**.9*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有一个类似于 *图 5.9* 中所示的映射上下文：
- en: '![Figure 5.9 – The complete Mapping Context](img/Figure_05_09_B18203.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 完整的映射上下文](img/Figure_05_09_B18203.jpg)'
- en: Figure 5.9 – The complete Mapping Context
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 完整的映射上下文
- en: Now that the Mapping Context has been defined, it’s time to set up the character
    so that it can receive input from the player.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在映射上下文已经定义好了，是时候设置角色以便它能接收来自玩家的输入了。
- en: Importing the Enhanced Input Module
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入增强型输入模块
- en: Let’s get back to the IDE, as you are now ready to add some components and code
    logic to your character. As we are using the Enhanced Input System, the first
    thing you will need to do is to add it to the module declaration in the `Build.cs`
    file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 IDE，因为你现在已经准备好为你的角色添加一些组件和代码逻辑了。由于我们使用的是增强型输入系统，你首先需要做的是将它添加到 `Build.cs`
    文件中的模块声明中。
- en: 'To do so, open `UnrealShadows_LOTL.Build.cs` in the `Source` folder of your
    C++ project (the name may vary slightly if your project was named in a different
    way). Then locate the following line of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，打开你的 C++ 项目的 `Source` 文件夹中的 `UnrealShadows_LOTL.Build.cs` 文件（如果你的项目名称不同，名称可能会有所不同）。然后找到以下代码行：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change it by adding the Enhanced Input module:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加增强型输入模块来更改它：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will make the Enhanced Input module available to your project, and you’ll
    be ready to start implementing the user interaction, something that you’ll do
    right now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使增强型输入模块可用于你的项目，你将准备好开始实现用户交互，这正是你现在要做的。
- en: Adding user interaction to the character
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向角色添加用户交互
- en: To add user interaction to the character, you will need to declare the Enhanced
    Input assets you created just a few moments ago.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要向角色添加用户交互，你需要声明你刚刚创建的增强型输入资产。
- en: In the next steps, you will declare the Mapping Context and action references
    to your code, along with the corresponding methods. After that, you’ll implement
    the code logic needed to handle all actions. Finally, you’ll declare these actions
    inside the character Blueprint.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，你将声明映射上下文和动作引用到你的代码中，以及相应的函数。之后，你将实现处理所有动作所需的代码逻辑。最后，你将在角色蓝图内部声明这些动作。
- en: Declaring input properties and functions
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明输入属性和函数
- en: 'The first thing to do is to add the needed asset references for the Mapping
    Context and the actions that should be added to the `US_Character.h` header file.
    Open the header file, which should already include the following lines of code
    (if not, add it as a public declaration):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是为映射上下文和要添加到 `US_Character.h` 头文件中的动作添加所需的资产引用。打开头文件，它应该已经包含了以下代码行（如果没有，则添加为公共声明）：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, declare a pointer to the Input Mapping Context and a pointer for each
    Input Action. To do this, add the following code in the class implicit `private`
    section (i.e., just after the `GENERATED_BODY()` macro), just after the components
    declarations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明一个指向输入映射上下文的指针以及每个输入动作的指针。为此，在类的隐式 `private` 部分中（即 `GENERATED_BODY()`
    宏之后，组件声明之后）添加以下代码：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a last step for the header declarations, add the following methods in the
    `protected` section, just after the `BeginPlay()` method declaration:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为头声明步骤的最后一步，在 `protected` 部分中，在 `BeginPlay()` 方法声明之后添加以下方法：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, you added a method for each of the interactions you defined
    before. Just remember that in the `SprintStart()` and `SprintEnd()`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你为之前定义的每个交互添加了一个方法。只需记住，在 `SprintStart()` 和 `SprintEnd()` 中。
- en: Implementing the Mapping Context for the character
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现角色的映射上下文
- en: In the next steps, you’ll implement the Mapping Context by initializing it and
    binding each input action to the corresponding methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，你将通过初始化它并将每个输入动作绑定到相应的方法来实现映射上下文。
- en: 'Open `US_Character.ccp` and add the following block of code, which includes
    all the classes you’ll be using in the next steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`US_Character.ccp`并添加以下代码块，其中包含了你在接下来的步骤中将使用的所有类：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, look for the `BeginPlay()` method and, after the `Super` declaration,
    add this block of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，查找`BeginPlay()`方法，并在`Super`声明之后添加此代码块：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first line of code checks that the Controller is a `PlayerController` by
    means of a `Cast<T>` template.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码通过`Cast<T>`模板检查控制器是否为`PlayerController`。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working in Unreal Engine, it is common to perform casts to specific classes
    frequently (as you already did in the previous chapters with Blueprints). You
    may already be used to casts in pure C++, but you should be aware that Unreal
    has slightly different behavior, as it is possible to safely cast to types that
    may not be valid. If you are used to regular C++ crashes in such cases, you’ll
    be happy to know that Unreal will simply return a safer `nullptr`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine中工作，频繁地对特定类进行转换是很常见的（就像你在之前的章节中用蓝图所做的那样）。你可能已经习惯了纯C++中的转换，但你应该知道Unreal的行为略有不同，因为它可以安全地将类型转换为可能不合法的类型。如果你习惯于在这种情况下出现常规C++崩溃，你可能会很高兴地知道Unreal将简单地返回一个更安全的`nullptr`。
- en: Then, the code will try to get an Enhanced Input Subsystem from the player and,
    if successful, will add a Mapping Context to it. From this point on, all the actions
    declared inside the context will be “tracked” by the input system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将尝试从玩家那里获取增强输入子系统，如果成功，将映射上下文添加到它上面。从这一点开始，上下文中声明的所有动作都将由输入系统“跟踪”。
- en: 'Of course, you will need to bind these actions to a corresponding method implementation
    (i.e., move, sprint, interact, etc.). To do this, look for the `SetupPlayerInputComponent()`
    method and, after the `Super()` declaration, add this block of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要将这些动作绑定到相应的方法实现（即移动、冲刺、交互等）。为此，查找`SetupPlayerInputComponent()`方法，并在`Super()`声明之后添加此代码块：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we are calling the `BindAction()` method on the input component
    pointer to bind each action to the corresponding method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在调用输入组件指针上的`BindAction()`方法来将每个动作绑定到相应的方法。
- en: Implementing the actions
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现动作
- en: 'Now you are ready to implement the methods for each action. Let’s start with
    the `Move` method. Add the following block of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好实现每个动作的方法。让我们从`Move`方法开始。添加以下代码块：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the first thing that this code does is to get the 2D vector
    from the `Value` parameter. This vector contains the *x* and *y* directions for
    the left thumbstick (or the keyboard) and indicates the direction in which the
    character should move. I have added an onscreen message to keep track of this
    value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码首先做的事情是从`Value`参数获取一个二维向量。这个向量包含了左摇杆（或键盘）的*x*和*y*方向，并指示角色应该移动的方向。我添加了一个屏幕上的消息来跟踪这个值。
- en: Next, if there is a Controller possessing this Actor, we compute the forward
    and right directions of the Character and move it in the corresponding direction
    (this is something you should already be familiar with if you’ve ever tried the
    Unreal Third Person template).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果有控制器拥有这个Actor，我们将计算角色的前向和右向方向，并将其移动到相应的方向（如果你曾经尝试过Unreal第三人称模板，你应该已经熟悉这个过程）。
- en: 'The next method you’ll be implementing is the `Look()` one, so add these lines
    just after the `Move()` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要实现的方法是`Look()`，所以就在`Move()`函数之后添加这些行：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we are getting the 2D vector from the `Value` parameter that,
    this time, will come from the right thumbstick or the mouse. After that, we add
    a yaw/pitch to the Controller; this will cause the Spring component and, consequently,
    the Camera component, to rotate around the character.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在从`Value`参数获取一个二维向量，这次它将来自右摇杆或鼠标。之后，我们向控制器添加偏航/俯仰；这将导致弹簧组件以及随之而来的相机组件围绕角色旋转。
- en: 'For the sprint action, the character has two methods available – one for starting
    the sprint and one for ending it. Add this code block after the previous function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于冲刺动作，角色有两个可用方法——一个用于开始冲刺，另一个用于结束冲刺。在之前的函数之后添加此代码块：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code simply increases the maximum speed of the character when it is sprinting.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码简单地在角色冲刺时增加其最大速度。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The walk and sprint values are hardcoded; we will need to get these values from
    a dataset later on as we progress through the book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 步行和冲刺的值是硬编码的；随着我们通过本书的进展，我们将在稍后从数据集中获取这些值。
- en: 'The last method you need to implement is the `Interact()` one but, at the moment,
    we don’t have anything to interact with! So, you’ll just add an onscreen message
    inside the function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要实现的最后一个方法是`Interact()`，但截至目前，我们还没有任何可以与之交互的东西！所以，你只需在函数内添加一个屏幕上的消息：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last thing you need to do to make the character fully functional is to add
    the input assets to the Blueprint.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要使角色完全功能化，你需要做的最后一件事是将输入资产添加到蓝图。
- en: Updating the character Blueprint
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新角色蓝图
- en: 'To update the Blueprint, take the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新蓝图，请执行以下步骤：
- en: Save all the files you have modified and get back to the Unreal Editor.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你修改的所有文件，并返回到Unreal编辑器。
- en: Click the **Compile** button and wait for the success message.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编译**按钮，等待成功消息。
- en: Open your **BP_Character** Blueprint and select the **Class** **Defaults** section.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的**BP_Character**蓝图，并选择**类****默认**部分。
- en: Search for the **Input** category in the **Details** panel. You should get the
    **Default Mapping Context** property along with the four actions that have been
    created.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中搜索**输入**类别。你应该会得到**默认映射上下文**属性以及创建的四个动作。
- en: Click the drop-down button for **Default Mapping Context** and select the corresponding
    asset (there should be only one to choose).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**默认映射上下文**下拉按钮，并选择相应的资产（应该只有一个可供选择）。
- en: For each action property, select the corresponding action asset from the drop-down
    menu.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个动作属性，从下拉菜单中选择相应的动作资产。
- en: 'The result of the previous steps is depicted in *Figure 5**.10*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前一步骤的结果在*图5.10*中展示：
- en: '![Figure 5.10 – The Blueprint input settings](img/Figure_05_10_B18203.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 蓝图输入设置](img/Figure_05_10_B18203.jpg)'
- en: Figure 5.10 – The Blueprint input settings
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 蓝图输入设置
- en: The character is finally complete! It’s been hard, but you are now ready to
    test it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 角色终于完成了！虽然很艰难，但你现在可以开始测试它了。
- en: Testing the character’s movement
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试角色的移动
- en: 'Now that the base user interaction has been implemented, it’s time to start
    testing it on a playable level. Open the **Level_01** map and do the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础用户交互已经实现，是时候开始在可玩级别上测试它了。打开**Level_01**地图，并执行以下操作：
- en: Look for the **SP 1** (for *SpawnPoint 1*) label in the level and add a **Player
    Start** Actor near it.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在级别中寻找**SP 1**（代表*SpawnPoint 1*）标签，并在其附近添加一个**玩家开始**演员。
- en: Set **Net Mode** to **Listen Server** with **3** players.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**网络模式**设置为**监听服务器**，并包含**3**名玩家。
- en: Hit the **Play** button to test the game.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**播放**按钮来测试游戏。
- en: You should be able to move the characters and make them sprint and look around.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够移动角色，并让他们冲刺和四处张望。
- en: You may be wondering how it is possible that you are already playing a networked
    game even though you did not add any multiplayer code logic. The answer is in
    the Character class, which is already set to be replicated – just open the `true`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，尽管你没有添加任何多人游戏代码逻辑，你为什么已经玩起了网络游戏。答案在角色类中，它已经被设置为可复制的——只需打开`true`。
- en: You may also have noticed that while the character on the server window moves
    and sprints smoothly, on the client’s window, movements seem a bit jumpy when
    you are running. This is happening because you are trying to execute the sprint
    action on the client, but the server is the one who is actually in command – as
    a result, the client will make the character move faster, but the server will
    bring it back to its move position. Basically, at the moment, we are trying to
    “cheat” on the client, but the server, which is authoritative, will forbid you
    from doing this. Obviously, this is a bug in our code, but we still have to understand
    the full meaning of replication and how to execute functions from the server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，虽然服务器窗口中的角色移动和冲刺很顺畅，但在客户端窗口中，当你跑步时，动作看起来有点跳跃。这是因为在客户端尝试执行冲刺动作，但服务器实际上是控制者——结果，客户端会让角色移动得更快，但服务器会将其带回移动位置。基本上，目前我们正在尝试在客户端“作弊”，但权威的服务器会禁止你这样做。显然，这是我们代码中的错误，但我们仍然需要理解复制的完整含义以及如何从服务器执行函数。
- en: To fix this bug, you will need to know more about replication. Just be patient
    – I will give you more detailed information about this topic in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties* *O**ver the Network*, and [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147),
    *Using Remote Procedure* *Calls (RPCs)*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个错误，你需要了解更多关于复制的知识。请耐心等待——我将在[*第6章*](B18203_06.xhtml#_idTextAnchor125)，*通过网络复制属性*
    *O**ver the Network*，和[*第7章*](B18203_07.xhtml#_idTextAnchor147)，*使用远程过程调用* *Calls
    (RPCs)*中提供更多关于这个主题的详细信息。
- en: 'Now that you have created your own hero character from scratch, it’s time to
    get some knowledge on how an Actor connection is controlled: I will introduce
    this topic in the next section.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从头开始创建了自己的英雄角色，是时候了解如何控制Actor连接了：我将在下一节介绍这个主题。
- en: Controlling the connection of an Actor
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制Actors的连接
- en: Now that you have created a fully working character, it’s time to understand
    how a connection is handled inside Unreal Engine (to quickly refresh your understanding
    of how connections work, you can refer back to [*Chapter 2*](B18203_02.xhtml#_idTextAnchor041),
    *Understanding* *Networking Basics*).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个完全工作的角色，是时候了解在虚幻引擎内部如何处理连接了（为了快速刷新你对连接工作原理的理解，你可以参考[*第2章*](B18203_02.xhtml#_idTextAnchor041)，*理解*
    *网络基础*）。
- en: Each connection has its own `PlayerController` that has been created expressly
    for it; in this case, we say that the `PlayerController` is “owned” by that connection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接都有自己的`PlayerController`，它是专门为该连接创建的；在这种情况下，我们说`PlayerController`“属于”该连接。
- en: In Unreal Engine, Actors can have an `PlayerController`, then the `PlayerController`
    becomes the Owner of that Actor. This means that the first Actor is also owned
    by the same connection that owns the `PlayerController`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，Actors可以有一个`PlayerController`，然后`PlayerController`就成为了该Actor的所有者。这意味着第一个Actor也由拥有`PlayerController`的相同连接拥有。
- en: 'The concept of ownership is used during Actor replication to determine which
    connections receive updates for each Actor: for instance, an Actor may be flagged
    so that only the connection that owns that Actor will be sent property updates
    for it.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Actor复制过程中使用所有权的概念来确定哪些连接接收每个Actor的更新：例如，一个Actor可能会被标记，以便只有拥有该Actor的连接才会收到其属性更新。
- en: 'As an example, let’s imagine that your thief character (which is basically
    an Actor) is possessed by a `PlayerController` – this `PlayerController` will
    be the Owner of the character. During gameplay, the thief gets a pickup that grants
    a magical dagger: once equipped, this weapon will be owned by the Character. This
    means that the `PlayerController` will also own the dagger. In the end, both the
    thief Actor and the dagger will be owned by the `PlayerController` connection.
    As soon as the thief Actor is no longer possessed by the Player Controller, it
    will cease to be owned by the connection, and so will the weapon.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一下你的盗贼角色（基本上是一个Actor）被`PlayerController`控制——这个`PlayerController`将是角色的所有者。在游戏过程中，盗贼获得了一个可以赋予魔法匕首的拾取物品：一旦装备，这件武器将属于角色。这意味着`PlayerController`也将拥有这把匕首。最终，盗贼Actor和匕首都将由`PlayerController`连接拥有。一旦盗贼Actor不再被Player
    Controller控制，它将不再由连接拥有，武器也是如此。
- en: If you have developed standalone games, you may be used to retrieving the Player
    Controller or the character by using nodes such as `Get Player Controller` or
    `Get Player Character` (or their corresponding C++ versions, `UGameplayStatics::GetPlayerController()`
    and `UGameplayStatics::GetPlayerCharacter()`). Using these functions in a networked
    environment may be the cause of many issues if you don’t know what you are doing,
    as you will get different results depending on the context.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开发过独立游戏，你可能习惯于通过使用诸如`Get Player Controller`或`Get Player Character`（或它们对应的C++版本，`UGameplayStatics::GetPlayerController()`和`UGameplayStatics::GetPlayerCharacter()`）这样的节点来检索玩家控制器或角色。如果你不知道自己在做什么，在网络环境中使用这些函数可能会导致许多问题，因为根据上下文，你将得到不同的结果。
- en: 'As an example, calling the `Get Player Controller` function with `Player Index`
    equal to `0` will give you the following results:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`Player Index`等于`0`时调用`Get Player Controller`函数将给出以下结果：
- en: The listen server’s `PlayerController` if you are calling it from a listen server
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是从监听服务器调用它，监听服务器的`PlayerController`
- en: The first client’s `PlayerController` if you are calling it from a dedicated
    server
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是从专用服务器调用它，第一个客户端的`PlayerController`
- en: The client’s `PlayerController` if you are calling it from a client
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是从客户端调用它，客户端的`PlayerController`
- en: If things seem confusing, they will become even more so, considering that the
    index will not be consistent across the server and different clients.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情看起来很混乱，考虑到索引在服务器和不同的客户端之间可能不一致，它们将变得更加混乱。
- en: 'That’s why, when developing multiplayer games in Unreal Engine, you will most
    probably use some of the following functions (or their corresponding nodes):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，当在Unreal Engine中开发多人游戏时，你很可能会使用以下一些函数（或它们相应的节点）：
- en: '`AActor::GetOwner()`, which returns the Owner of an Actor instance'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetOwner()`，它返回一个Actor实例的所有者'
- en: '`APawn::GetController()`, which returns the Controller for the Pawn or Character
    instance'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APawn::GetController()`，它返回Pawn或角色实例的控制器'
- en: '`AController::GetPawn()`, which returns the Pawn possessed by the Controller'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AController::GetPawn()`，它返回控制器所拥有的Pawn'
- en: '`APlayerState::GetPlayerController()`, which will return the Player Controller
    that created the Player State instance (remote clients will return a null value)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APlayerState::GetPlayerController()`，它将返回创建Player State实例的Player Controller（远程客户端将返回null值）'
- en: Regarding components, you should be aware that they have their own way of determining
    their owning connection – they will start by following the component’s outer chain
    until they find the Actor that owns them. From there, the system will proceed,
    as explained previously, to determine the owning connection of that Actor. To
    get the Owner of the component, you’ll use the `UActorComponent::GetOwner()` method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组件，你应该知道它们有自己确定拥有连接的方式——它们将从遵循组件的外部链开始，直到找到拥有它们的Actor。从那里开始，系统将像之前解释的那样继续确定该Actor的拥有连接。要获取组件的所有者，你将使用`UActorComponent::GetOwner()`方法。
- en: 'In this section, we have just “scratched the surface” of what an Owner is and
    how to get info about it, but you should be aware that connection ownership is
    so important that it will be pervasive throughout the rest of the book: in other
    words, the idea of owning a connection is deemed crucial enough to be addressed
    throughout the multiplayer project we are developing.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们刚刚“触及”了所有者的概念以及如何获取有关它的信息，但你应该知道连接所有权非常重要，它将在本书的其余部分无处不在：换句话说，拥有连接的想法被认为足够重要，以至于将在我们正在开发的多玩家项目中得到处理。
- en: 'In the next section, I’m going to introduce a topic that is deeply connected
    with connection ownership: relevancy.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将介绍一个与连接所有权紧密相关的话题：相关性。
- en: Understanding Actor relevancy
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Actor相关性
- en: Relevancy is the process of determining which objects in a scene should be visible
    or updated based on their importance to the player. This is an important concept
    in Unreal Engine, and by understanding how it works, you can make sure your game
    runs efficiently. In this section, we will explore this topic and show an example
    of how it works depending on its settings.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性是确定场景中哪些对象应该根据其对玩家的重要性可见或更新的过程。这是Unreal Engine中的一个重要概念，通过理解它是如何工作的，你可以确保你的游戏运行得高效。在本节中，我们将探讨这个主题，并展示一个根据其设置如何工作的示例。
- en: Understanding relevancy
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解相关性
- en: In Unreal Engine, the term **relevancy** refers to how the Engine determines
    which Actors in the game world should be replicated to which clients, based on
    their current locations, and which Actors are relevant to the player’s current
    view or area.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine中，**相关性**这个术语指的是引擎如何根据Actor在游戏世界中的当前位置来确定应该将哪些Actor复制到哪些客户端，以及哪些Actor对玩家的当前视图或区域是相关的。
- en: A game level can have a size varying from very small to really huge. This may
    pose a problem in updating everything on the network and for every client connected
    to the server. As the playing character may not need to know every single thing
    that’s happening in the level, most of the time, it’s just enough to let it know
    what is near.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个游戏关卡的大小可以从非常小到非常大不等。这可能会在更新网络上所有内容以及连接到服务器的每个客户端时引起问题。由于游戏角色可能不需要知道关卡中发生的每一件事，大多数时候，只需让它知道附近发生的事情就足够了。
- en: 'As a consequence, the Engine uses several factors to let the player know if
    something has changed on an Actor: these factors span from the distance to the
    Actor itself, its visibility, and whether the Actor is currently active in the
    game world. An Actor that is deemed irrelevant will not be replicated to the player’s
    client, and this will reduce network traffic and improve game performance.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，引擎使用几个因素来让玩家知道一个Actor上是否发生了变化：这些因素包括Actor本身的距离、其可见性以及Actor是否在游戏世界中当前处于活动状态。被认为无关紧要的Actor将不会被复制到玩家的客户端，这将减少网络流量并提高游戏性能。
- en: 'Unreal uses a virtual function named `AActor::IsNetRelevantFor()` to test the
    relevancy of an Actor. This test evaluates a set of properties that is intended
    to provide a reliable estimate of the Actors that can actually influence a client.
    The tests can be summarized as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal使用一个名为`AActor::IsNetRelevantFor()`的虚函数来测试演员的相关性。这个测试评估一组旨在提供对能够真正影响客户端的演员的可靠估计的属性。测试可以总结如下：
- en: '`bAlwaysRelevant` flag is set to `true`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bAlwaysRelevant`标志设置为`true`'
- en: Or, it is owned by the `Pawn` or `PlayerController`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，它属于`Pawn`或`PlayerController`
- en: Or, it is the `Pawn` object
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，它是`Pawn`对象
- en: Or, the `Pawn` object is the instigator of an action such as noise or damage
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，`Pawn`对象是诸如噪音或伤害等动作的发起者
- en: '`bNetUseOwnerRelevancy` property is `true` and the Actor itself has an Owner,
    the owner’s relevancy will be used.*   `bOnlyRelevantToOwner` property set to
    `true` and does not pass the first check, then it is not relevant.*   **Fourth
    Check**: If the Actor is attached to another Actor’s skeleton, then its relevancy
    is determined by the relevancy of its parent.*   `bHidden` property is set to
    `true` and the root component is not colliding with the checking Actor, then the
    Actor is not relevant.*   `AGameNetworkManager` is set to use distance-based relevancy,
    the Actor is relevant if it is closer than the net cull distance.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bNetUseOwnerRelevancy`属性设置为`true`，并且演员本身有一个所有者，所有者的相关性将被使用。*   `bOnlyRelevantToOwner`属性设置为`true`并且未通过第一次检查，那么它就不相关。*   **第四次检查**：如果演员附着在另一个演员的骨骼上，那么其相关性由其父级的相关性决定。*   `bHidden`属性设置为`true`并且根组件没有与检查演员发生碰撞，那么演员就不相关。*   `AGameNetworkManager`设置为使用基于距离的相关性，如果演员比网络裁剪距离更近，则演员是相关的。'
- en: Note
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Pawn`/`Character` and `PlayerController` classes have slightly different
    relevancy checks as they need to consider additional information, such as the
    movement component.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pawn`/`Character`和`PlayerController`类在相关性检查上略有不同，因为它们需要考虑额外的信息，例如运动组件。'
- en: It should be noted that this system is not perfect, as the distance check may
    give a false negative when dealing with large Actors. Additionally, the system
    does not take into account sound occlusion or other complexities related to ambient
    sounds. Nevertheless, the approximation is precise enough to get good results
    during gameplay.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这个系统并不完美，因为在处理大型演员时，距离检查可能会给出错误的否定结果。此外，该系统没有考虑声音遮挡或其他与环境声音相关的复杂性。尽管如此，这个近似值足够精确，在游戏过程中可以得到良好的结果。
- en: After presenting all this theory, it is time to shift our focus back to the
    project and begin implementing a tangible example. In the following subsection,
    you will see relevancy in action by testing your character.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完所有这些理论之后，现在是时候将我们的注意力转回到项目上，开始实现一个有形的示例。在下面的子节中，你将通过测试你的角色来看到相关性在实际中的应用。
- en: Testing relevancy
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试相关性
- en: To test the effect of relevancy during gameplay, you’ll create a simple pickup
    and play around with its settings.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试游戏过程中的相关性效果，你将创建一个简单的拾取并对其设置进行操作。
- en: Creating the Pickup Actor
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建拾取演员
- en: 'Start by creating a new C++ class inheriting from `US_BasePickup`. Then, open
    the generated header file and add these two component declarations in the `private`
    section:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的从`US_BasePickup`继承的C++类。然后，打开生成的头文件，在`private`部分添加这两个组件声明：
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should be familiar with the previous code – we are just declaring the Collision
    component for triggering the pickup and the Mesh component for its visual aspect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉之前的代码——我们只是在声明用于触发拾取的碰撞组件和用于其视觉外观的网格组件。
- en: 'Next, in the `protected` section, just after the `BeginPlay()` declaration,
    add a declaration that will handle the character overlap with the Actor:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`protected`部分，在`BeginPlay()`声明之后，添加一个将处理角色与演员重叠的声明：
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Immediately after that, add the declaration for the pickup action:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，添加拾取动作的声明：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We need this function to be callable inside a Blueprint, so we use the `BlueprintCallable`
    specifier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个函数在蓝图内部可调用，所以我们使用`BlueprintCallable`指定符。
- en: Then, the `BlueprintNativeEvent` specifier states that the function can be overwritten
    by a Blueprint, but it also has a default native C++ implementation that will
    be called if the Blueprint does not implement anything.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`BlueprintNativeEvent`指定符表示该函数可以被蓝图覆盖，但它也具有一个默认的本地C++实现，如果蓝图没有实现任何内容，则会调用该实现。
- en: To natively implement the method, in the `US_BasePickup.cpp` file, we will need
    to implement a C++ function with the same name as the primary function but with
    `_Implementation` added to the end.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了原生实现方法，在`US_BasePickup.cpp`文件中，我们需要实现一个与主函数同名但末尾添加`_Implementation`的C++函数。
- en: 'Finally, to the `public` section – and after the corresponding properties,
    in order to avoid forward declarations – add two getters for the components we
    declared previously:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进入`public`部分 - 在相应的属性之后，为了避免前向声明 - 为之前声明的组件添加两个获取器：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that the header has been fully declared, open the `US_BasePickup.cpp` file
    to start adding code logic to your Actor. First of all, add the necessary includes
    at the top of the file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完全声明了头文件，打开`US_BasePickup.cpp`文件以开始向Actors添加代码逻辑。首先，在文件顶部添加必要的包含：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, inside the constructor, add the following block of code, which creates
    the two components and attaches them to the Actor:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中添加以下代码块，它创建两个组件并将它们附加到Actors上：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Immediately after that, set `bReplicates` to `true` (as Actors do not replicate
    by default):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 立即之后，将`bReplicates`设置为`true`（因为默认情况下Actors不会复制）：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the `BeginPlay()` function, add a dynamic multi-cast delegate for the
    overlap event:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BeginPlay()`函数内部，为重叠事件添加一个动态多播委托：
- en: '[PRE26]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To give proper attention and focus to replication, I have designated [*Chapter
    6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties* *O**ver the Network*,
    for an in-depth exploration of this topic.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对复制给予适当的关注和重点，我已将[*第6章*](B18203_06.xhtml#_idTextAnchor125)，*通过网络复制属性* *O**ver
    the Network*，指定为对这一主题的深入探讨。
- en: 'Now add the overlap handler just after the closing bracket of the `BeginPlay()`
    function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`BeginPlay()`函数的括号关闭后添加重叠处理程序：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous block of code is quite straightforward: after having checked that
    the overlapping Actor is `AUS_Character` (i.e., our multiplayer hero), we simply
    call the `Pickup()` method.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块相当直接：在检查重叠Actors是`AUS_Character`（即我们的多人游戏英雄）之后，我们简单地调用`Pickup()`方法。
- en: 'To complete the pickup logic, you will now add the `Pickup()` C++ implementation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成拾取逻辑，你现在将添加`Pickup()`的C++实现：
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code logic of this method can be implemented inside the inheriting Blueprints,
    but for the sake of demonstration, we are just setting the Owner of this Actor
    to the overlapping one: this is an important step in making things work in the
    next relevancy tests.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的代码逻辑可以在继承的蓝图中实现，但为了演示，我们只是将此Actors的所有者设置为重叠的Actors：这是在下一个相关性测试中使事物正常工作的一个重要步骤。
- en: It’s now time to get back to the Unreal Engine Editor and do some “magic” –
    after all, this is a book about creating a fantasy game!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到虚幻引擎编辑器并做一些“魔法”了 - 毕竟，这是一本关于创建幻想游戏的书！
- en: Creating a pickup Blueprint class
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建拾取蓝图类
- en: To test the effects of relevancy in action, you’ll create a Blueprint pickup...
    Well, sort of. Upon first examination, relevancy can exhibit some peculiar tendencies.
    This is precisely why we’ll be conjuring up a marvelously mystical tome that hovers
    in mid-air!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试相关性在实际操作中的效果，你将创建一个蓝图拾取... 嗯，差不多吧。初步检查时，相关性可能会表现出一些奇特的趋势。这正是我们将召唤一本神奇神秘的书籍悬浮在半空中的原因！
- en: 'Open the Unreal Engine Editor and take the following steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打开虚幻引擎编辑器，按照以下步骤操作：
- en: Compile your project to add the pickup to the available classes of your Blueprints.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目以将拾取添加到蓝图的可用类中。
- en: In your `Blueprints` folder, create a new `BP_SpellBook`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Blueprints`文件夹中，创建一个新的`BP_SpellBook`。
- en: In the **Blueprint Details** panel, select a mesh for the **Static Mesh** property
    – I opted for the **spellBook** model.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**蓝图详情**面板中，选择**静态网格**属性的网格 - 我选择了**spellBook**模型。
- en: 'To make the book float, we are going to move the mesh up and down by using
    a **Timeline** node. To do so, follow these steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要使书本漂浮，我们将通过使用**时间轴**节点上下移动网格。为此，请按照以下步骤操作：
- en: Open the Blueprint Event Graph, right-click on the canvas, and add a `Float`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图事件图，在画布上右键单击，并添加一个`Float`。
- en: Double-click on the node to open the corresponding editor.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击节点以打开相应的编辑器。
- en: 'Click the `Alpha`. The button is shown in *Figure 5**.11*:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Alpha`。按钮在*图5**.11*中显示：
- en: '![Figure 5.11 – The Track button](img/Figure_05_11_B18203.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – 跟踪按钮](img/Figure_05_11_B18203.jpg)'
- en: Figure 5.11 – The Track button
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 跟踪按钮
- en: 'Click on the **Loop** button to enable the loop mode. The button is shown in
    *Figure 5**.12*:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**循环**按钮以启用循环模式。按钮在*图5**.12*中显示：
- en: '![Figure 5.12 – The Loop button](img/Figure_05_12_B18203.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 循环按钮](img/Figure_05_12_B18203.jpg)'
- en: Figure 5.12 – The Loop button
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 循环按钮
- en: Right-click on the curve panel and select the **Add key to...** option. Then,
    set **Time** to **0** and **Value** to **0**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击曲线面板，并选择**添加键到...**选项。然后，将**时间**设置为**0**，将**值**设置为**0**。
- en: Create another key, but this time set **Time** to **2.5** and **Value** to **0.5**.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个键，但这次将**时间**设置为**2.5**，将**值**设置为**0.5**。
- en: Create one last key, this time with **Time** equal to **5** and **Value** equal
    to **0**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最后一个键，这次将**时间**设置为**5**，将**值**设置为**0**。
- en: Right-click on each of the keys and set the **Key Interpolation** value to **Auto**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击每个键，并将**键插值**值设置为**自动**。
- en: 'The final result of the **Timeline** node is shown in *Figure 5**.13*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间轴**节点的最终结果在*图 5.13*中显示：'
- en: '![Figure 5.13 – The Timeline node settings](img/Figure_05_13_B18203.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 时间轴节点设置](img/Figure_05_13_B18203.jpg)'
- en: Figure 5.13 – The Timeline node settings
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 时间轴节点设置
- en: 'You have just created a sinusoidal value that will indefinitely loop between
    0 and 1 values; you’ll use this floating value to move the book up and down. To
    implement this floating movement, return to the Event Graph and do the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个在 0 和 1 之间无限循环的正弦值；你将使用这个浮动值来移动书籍上下。要实现这种浮动运动，返回到事件图，并执行以下操作：
- en: Connect the **Event Begin Play** node to the **Timeline** node.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**事件开始播放**节点连接到**时间轴**节点。
- en: Drag the **Mesh** component from the **Components** panel onto the Event Graph
    canvas. Click and drag from its outgoing pin to add a **Set Relative** **Location**
    node.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**组件**面板中的**网格**组件拖动到事件图画布上。从其输出引脚点击并拖动以添加一个**设置相对位置**节点。
- en: Connect the **Set Relative Location** incoming execution pin to the **Update**
    execution pin of the **Timeline** node.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**设置相对位置**的输入执行引脚连接到**时间轴**节点的**更新**执行引脚。
- en: Connect the **Timeline** node **Alpha** pin to a **Multiply** node and set the
    second parameter of this last node to **100**.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**时间轴**节点的**Alpha**引脚连接到一个**乘法**节点，并将此最后一个节点的第二个参数设置为**100**。
- en: Right-click on the **New Location** pin of the **Set Relative Location** node
    and select **Split Struct Pin** to expose the X, Y, and Z values.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**设置相对位置**节点的**新位置**引脚，并选择**拆分结构引脚**以暴露 X、Y 和 Z 值。
- en: Connect the **Result** pin of the **Multiply** node to **New Location Z** of
    the **Set Relative** **Location** node.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**乘法**节点的**结果**引脚连接到**设置相对位置**节点的**新位置 Z**。
- en: 'The complete graph is shown in *Figure 5**.14*:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的图示在*图 5.14*中显示：
- en: '![Figure 5.14 – The floating book graph](img/Figure_05_14_B18203.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 浮动书籍图](img/Figure_05_14_B18203.jpg)'
- en: Figure 5.14 – The floating book graph
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 浮动书籍图
- en: Please note that this floating animation is purely a visual effect, so we just
    won’t worry about whether it is synchronized over the network.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个浮动动画纯粹是视觉效果，所以我们不会担心它是否在网络中同步。
- en: Now that the Blueprint item has been created, it’s time to add it to the level
    and test its pickup functionality – something we are going to do in the next subsection.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在蓝图项目已经创建，是时候将其添加到关卡中并测试其拾取功能了——我们将在下一小节中这样做。
- en: Testing the relevancy settings
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试相关性设置
- en: It’s now time to test how the spell book behaves in a multiplayer environment
    when relevancy settings are changed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试当相关性设置更改时，魔法书在多人环境中的行为如何了。
- en: First of all, drag an instance of the **BP_SpellBook** Blueprint into the level,
    near the PlayerStart Actor, so that the player will be in the line of sight once
    it has been spawned.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将**BP_SpellBook**蓝图的一个实例拖动到关卡中，靠近**PlayerStart**演员，以便玩家在它被生成时处于视线范围内。
- en: 'Open the **PB_SpeelBook** Blueprint and, with the **Class Defaults** panel
    selected, look for the **Replication** category. The default settings should be
    similar to the ones shown in *Figure 5**.15*:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**PB_SpeelBook**蓝图，并选择**类默认值**面板，查找**复制**类别。默认设置应类似于*图 5.15*中显示的设置：
- en: '![Figure 5.15 – The Replication category](img/Figure_05_15_B18203.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 复制类别](img/Figure_05_15_B18203.jpg)'
- en: Figure 5.15 – The Replication category
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 复制类别
- en: Try playing the game as a listen server with three players, and every player
    should see the book as expected. Things are going to get a bit trickier in a moment...
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以监听服务器的形式玩游戏，有三个玩家，每个玩家都应该看到预期的书籍。接下来事情会变得有点复杂...
- en: Stop the application from playing and get back to the **BP_SpellBook** Blueprint.
    Look for the **Net Load on Client** property and uncheck it. As this property
    will load the Actor during map loading, we need to disable it, so the Actor will
    be loaded only when it becomes relevant for the client.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 停止应用程序播放，回到**BP_SpellBook**蓝图。查找**Net Load on Client**属性并取消选中。由于这个属性将在地图加载期间加载角色，我们需要禁用它，以便角色仅在它对客户端相关时才被加载。
- en: You are now ready to test different situations, depending on the properties
    you change in the next steps.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好根据你在下一步中更改的属性测试不同的情况。
- en: Setting the net cull distance
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置网络剔除距离
- en: 'The first situation you will be testing is about distance culling – at the
    moment, your object is set to be relevant at a very far distance. To check this,
    run the game again, and you should see no difference since your last gameplay.
    But what happens if you lower **Net Cull Distance Squared** to a very low number,
    for instance, **500**? You will get really “weird” behavior: the server window
    will show the book, while the two clients will not!'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要测试的第一个情况是关于距离剔除 - 目前，你的对象被设置为在非常远的距离上相关。为了检查这一点，再次运行游戏，你应该看到与上次游戏没有区别。但是，如果你将**Net
    Cull Distance Squared**降低到一个非常低的数字，例如，**500**，会发生什么？你将得到非常“奇怪”的行为：服务器窗口将显示这本书，而两个客户端则不会！
- en: With one of the client windows active, try walking near the zone where the book
    should be, and it will immediately pop up! Didn’t I already warn you that this
    book was nothing short of magical?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个客户端窗口激活的情况下，尝试走到书应该所在的区域附近，它将立即弹出！我没有已经警告过你这本书几乎就是魔法般的存在吗？
- en: The property you just changed sets the square of the distance that will be used
    to make the Actor relevant to the client. This means that the spell book will
    “magically” appear as soon as the character is within the square root of this
    distance. As the server is authoritative (i.e., knows everything), it will always
    show the Actor.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才更改的属性设置了用于使角色对客户端相关的距离的平方。这意味着法术书将在角色位于这个距离的平方根内时“神奇”地出现。由于服务器是权威的（即，知道一切），它将始终显示角色。
- en: Let’s now test a way to set the Actor as always relevant and, as such, always
    visible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试一种设置角色始终相关并且始终可见的方法。
- en: Setting the Actor as always relevant
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置角色始终相关
- en: Return to the spell book Blueprint and set the **Always Relevant** property
    to **True**, leaving the rest as it was in the previous example. When you play
    the game, you will notice that every client will be able to see the book from
    the start. This happens because the book has now been marked as something that
    should be relevant no matter where the character is in the level; as a consequence,
    it will be immediately loaded by the client and visible to the players.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到法术书蓝图，并将**Always Relevant**属性设置为**True**，其余的保持与上一个示例相同。当你玩游戏时，你会注意到每个客户端都会从开始就能看到这本书。这是因为这本书现在被标记为无论角色在关卡中的任何位置都应该是相关的；因此，它将立即被客户端加载并对玩家可见。
- en: This is obviously not a desirable situation – getting a continuous update for
    every Actor in the level is something we don’t want to happen, considering that
    there could be a multitude of moving elements in our game. But you probably already
    imagined that, didn’t you?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是我们想要的情况 - 考虑到我们的游戏中可能有无数移动元素，我们不想对关卡中的每个角色都进行连续更新。但你可能已经想象到了这一点，不是吗？
- en: Let’s avoid this issue by setting relevancy based on the Owner of the Actor.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过设置基于角色的所有者来避免这个问题。
- en: Setting the relevancy for the Owner
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置所有者的相关性
- en: 'You may remember that the C++ code for the `Pickup()` function assigns the
    Owner of the pickup to the character overlapping it. Instead, in this Blueprint,
    we’ll see what happens if the Actor is relevant only to the Owner:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，`Pickup()`函数的C++代码将拾取的所有者的所有权分配给与之重叠的角色。相反，在这个蓝图里，我们将看到如果角色只对所有者相关会发生什么：
- en: Set the **Only Relevant to Owner** property to **True**.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Only Relevant to Owner**属性设置为**True**。
- en: Set the **Always Relevant** property to **False**.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Always Relevant**属性设置为**False**。
- en: Set **Net Cull Distance Squared** to a really low number, say **10**.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Net Cull Distance Squared**设置为一个非常低的数字，比如说**10**。
- en: With the last step, we are setting the spell book so that it won’t be relevant
    to any client unless it is directly on the object; this will let us test who is
    the Owner of the Actor.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们正在设置法术书，使其不会对任何客户端相关，除非它直接位于对象上；这将使我们能够测试谁是该角色的所有者。
- en: The clients won’t be able to see the book unless they enter its collision zone,
    which is when the character becomes the Owner of the pickup. Once another character
    enters the pickup zone, it will become the new Owner and the book will become
    relevant. After a few moments, the first client will see the book disappear as
    the character is no longer the Owner of the pickup, and so it is no longer relevant
    to it!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端除非进入其碰撞区域，否则无法看到这本书，这时角色成为拾取物的所有者。一旦另一个角色进入拾取区域，它将成为新的所有者，这本书将变得相关。几分钟后，第一个客户端会看到这本书消失，因为角色不再是拾取物的所有者，因此它不再与它相关！
- en: 'As a final note, there is one last property you should be aware of: **Net Use
    Owner Relevancy** will return the relevancy of an Actor depending on its owner
    relevancy. This will come in handy once you assign a weapon to a character or
    to an enemy!'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的注意事项，还有一个属性你应该知道：**Net Use Owner Relevancy**将根据其所有者的相关性返回Actor的相关性。当你将武器分配给角色或敌人时，这将会很有用！
- en: In this section, you have now unlocked the mystical secrets of relevancy and
    witnessed it in action. This concept will prove invaluable as you begin optimizing
    your game, but it’s always best to lay a strong foundation and set the right course
    from the very beginning. The following section will introduce another significant
    concept, namely authority.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经揭开了相关性的神秘秘密，并见证了它的实际应用。当你开始优化游戏时，这个概念将非常有价值，但始终最好从一开始就打下坚实的基础，并设定正确的方向。下一节将介绍另一个重要的概念，即权限。
- en: Introducing authority
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍权限
- en: 'As we mentioned in [*Chapter 2*](B18203_02.xhtml#_idTextAnchor041), *Understanding
    Networking Basics*, the term **authority** refers to which instance of the game
    has the final say over certain aspects of the game state. In an Unreal Engine
    multiplayer environment, the server is authoritative over the game state: this
    means that the server makes the final decisions about things such as player movement,
    damage calculation, and other game mechanics.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所述的[*第二章*](B18203_02.xhtml#_idTextAnchor041)，*理解网络基础*，术语**权限**指的是游戏状态中哪个实例具有对某些方面的最终决定权。在虚幻引擎的多玩家环境中，服务器对游戏状态具有权限：这意味着服务器对诸如玩家移动、伤害计算和其他游戏机制等事项做出最终决定。
- en: When a client requests to perform an action that affects the game state, it
    sends a message to the server requesting permission to perform that action. The
    server then determines whether the action is valid and, if so, updates the game
    state accordingly. Once the server has updated the game state, it sends a message
    to all clients to inform them of the updated state.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求执行影响游戏状态的操作时，它会向服务器发送一条消息，请求执行该操作的权限。服务器随后确定该操作是否有效，如果是的话，相应地更新游戏状态。一旦服务器更新了游戏状态，它就会向所有客户端发送消息，告知他们更新的状态。
- en: In Unreal Engine, Actors can be either locally or remotely controlled, and the
    concept of authority is important in determining which controls are valid. Actors
    that are locally controlled have authority over their own actions, while those
    that are remotely controlled receive commands from the server and follow those
    commands.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，Actor可以是本地控制或远程控制，权限的概念在确定哪些控制有效时很重要。本地控制的Actor对其自己的动作具有权限，而远程控制的Actor则从服务器接收命令并遵循这些命令。
- en: Overall, the concept of authority ensures that all players see a consistent
    game state and that no one player has an unfair advantage.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，权限的概念确保所有玩家看到一致的游戏状态，并且没有玩家拥有不公平的优势。
- en: Controlling authority with the Role and Remote Role properties of an Actor
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Actor的Role和Remote Role属性控制权限
- en: 'In Unreal Engine, there are two properties that return important information
    about Actor replication: **Role** and **Remote Role**. These two properties provide
    information about who has authority over the Actor, whether the Actor is replicated
    or not, and the method of replication.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，有两个属性返回关于Actor复制的 重要信息：**角色**和**远程角色**。这两个属性提供了有关谁对Actor具有权限、Actor是否被复制以及复制方式的信息。
- en: 'In Unreal Engine, an Actor can have one of four possible roles during network
    play:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，Actor在网络游戏中可以具有四种可能的角色之一：
- en: '`ROLE_Authority`: The running instance has authoritative control over the Actor'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_Authority`：运行实例对Actor具有权威控制'
- en: '`ROLE_AutonomousProxy`: The running instance is an autonomous proxy of the
    Actor'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_AutonomousProxy`：运行实例是Actor的自主代理'
- en: '`ROLE_SimulatedProxy`: The running instance is a locally simulated proxy of
    the Actor'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_SimulatedProxy`：运行实例是 Actor 的本地模拟代理'
- en: '`ROLE_None`: In this case, the role is not relevant'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_None`：在这种情况下，角色无关紧要'
- en: Overall, the `Role` and `RemoteRole` properties are used to control how an Actor
    behaves during network play in Unreal Engine, and their values can differ depending
    on the Actor’s ownership and replication settings. In particular, the `Role` property
    specifies the Actor’s role on the local machine, while the `RemoteRole` property
    specifies the Actor’s role on the remote machine.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`Role` 和 `RemoteRole` 属性用于控制 Actor 在 Unreal Engine 网络游戏中的行为，它们的值可能根据 Actor
    的所有权和复制设置而有所不同。特别是，`Role` 属性指定了 Actor 在本地机器上的角色，而 `RemoteRole` 属性指定了 Actor 在远程机器上的角色。
- en: As an example, if `Role` is set to `ROLE_Authority` and `RemoteRole` is set
    to either `ROLE_SimulatedProxy` or `ROLE_AutonomousProxy`, then the current instance
    of the game is responsible for replicating this Actor to remote connections.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将 `Role` 设置为 `ROLE_Authority` 并且 `RemoteRole` 设置为 `ROLE_SimulatedProxy`
    或 `ROLE_AutonomousProxy` 中的任何一个，那么当前游戏实例将负责将此 Actor 复制到远程连接。
- en: It should be noted that only the server replicates Actors to connected clients
    as clients will never replicate Actors to the server. This means that only the
    server will have `Role` set to `ROLE_Authority` and `RemoteRole` set to `ROLE_SimulatedProxy`
    or `ROLE_AutonomousProxy`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，只有服务器将 Actor 复制到连接的客户端，因为客户端永远不会将 Actor 复制到服务器。这意味着只有服务器会将 `Role` 设置为
    `ROLE_Authority`，并将 `RemoteRole` 设置为 `ROLE_SimulatedProxy` 或 `ROLE_AutonomousProxy`。
- en: Autonomous and simulated proxy
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自主和模拟代理
- en: While testing the spell book pickup (well, it was not strictly a “pickup,” but
    you get the point), you may have noticed that once the Actor’s Owner changed,
    the book did seem to stay relevant to both the old and the new Owner for a moment.
    To avoid using excessive amounts of CPU resources and bandwidth, the server does
    not replicate Actors during every update but at a frequency that is determined
    by the `AActor::NetUpdateFrequency` property.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试法术书拾取（好吧，这严格来说不是一个“拾取”，但你应该明白这个意思）时，你可能注意到，一旦 Actor 的所有者发生变化，这本书似乎在一段时间内对旧所有者和新所有者都保持相关。为了避免使用过多的
    CPU 资源和带宽，服务器不会在每次更新时复制 Actor，而是在由 `AActor::NetUpdateFrequency` 属性确定的频率下进行复制。
- en: The same thing will happen when updating any Actor during movement, and the
    client will receive data at predefined intervals; as a consequence, the player
    may get seemingly erratic updates on an Actor. To avoid these kinds of issues,
    the Engine will try to extrapolate movement based on the latest data available.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新任何 Actor 的移动过程中，也会发生同样的事情，客户端将在预定义的间隔内接收数据；因此，玩家可能会在 Actor 上收到看似不规律更新。为了避免这些问题，引擎将尝试根据最新的数据外推移动。
- en: The default behavior relies on predicting the movement and is governed by a
    `ROLE_SimulatedProxy`. In this mode, the client continuously updates the location
    of the Actor based on the latest velocity received from the server.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为依赖于预测移动，并由 `ROLE_SimulatedProxy` 管理。在这种模式下，客户端会根据从服务器接收到的最新速度持续更新 Actor
    的位置。
- en: When an Actor is controlled by a `PlayerController` object, you may use an `ROLE_AutonomousProxy`.
    In this case, the system will receive additional information directly from the
    human player, making the process of predicting future actions smoother.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Actor 由 `PlayerController` 对象控制时，你可以使用 `ROLE_AutonomousProxy`。在这种情况下，系统将直接从人类玩家那里接收额外信息，使预测未来动作的过程更加平滑。
- en: In this section, you’ve gained some insight into the realms of authority and
    Actor roles. These notions shall undoubtedly come in handy in future chapters,
    especially as you delve into the complexities of topics such as character weaponry
    and enemy AI.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你对权限和 Actor 角色领域有了一些了解。这些概念无疑将在未来的章节中派上用场，尤其是在你深入研究诸如角色武器和敌人 AI 等复杂主题时。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you made further progress in developing your multiplayer project
    by updating your character with the required movement and interaction features
    – this was achieved with the help of the Enhanced Input System provided by Unreal
    Engine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过更新你的角色所需的移动和交互功能，进一步推进了你的多人项目开发——这得益于 Unreal Engine 提供的增强输入系统。
- en: Next, you gained some clarity on who’s pulling the strings of an Actor in a
    multiplayer environment by understanding what an Owner is.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你通过理解什么是所有者，对多人环境中谁在操纵 Actor 有了一些清晰的认识。
- en: After that, you started to see the light on the all-important role of relevancy
    in gaming. As you discovered for yourself, it’s crucial to know how properties
    are set, or things will start to take a big turn for the weird.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你开始意识到在游戏中相关性至关重要的角色。正如你亲自发现的，了解属性是如何设置的至关重要，否则事情将开始出现大转变，变得奇怪起来。
- en: Lastly, you gained some valuable insights into the different roles that make
    up an Unreal Engine multiplayer game and why they play a crucial role in replicating
    an Actor’s behavior across multiple clients.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你对组成虚幻引擎多人游戏的不同角色以及为什么它们在跨多个客户端复制演员行为中扮演关键角色有了宝贵的见解。
- en: 'This brings us to a final question: what does “replicating” an object mean
    exactly? Well, I guess it’s time to take a stroll or indulge in a cup of coffee
    to recharge your batteries. You will need to summon all your energy and focus,
    for I will unveil (almost) all the secrets of replication in the next chapter!'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了最后一个问题：究竟“复制”一个对象意味着什么？嗯，我想是时候散步或享受一杯咖啡来充电了。你需要调动你所有的能量和注意力，因为我在下一章将揭露（几乎）所有复制的秘密！
