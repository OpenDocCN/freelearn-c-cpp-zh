- en: Chapter 7. Applications, Tiles, Tasks, and Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。应用程序、磁贴、任务和通知
- en: Windows Store applications are different from traditional desktop applications
    in a number of aspects. Store apps live inside a secure container, with well-defined
    ways of interacting with the outside world, such as other applications, the operating
    system, or something on the network. These apps are also imposed by several restrictions,
    unlike anything in the desktop app world. Knowing these restrictions and ways
    to handle them by cooperation with Windows, is key to a successful and well-behaving
    Windows Store application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Windows商店应用程序在许多方面与传统桌面应用程序不同。商店应用程序位于一个安全容器中，与外部世界的交互方式是明确定义的，如其他应用程序、操作系统或网络上的内容。这些应用程序还受到多项限制，与桌面应用程序世界中的任何限制都不同。了解这些限制，并通过与Windows的合作来处理它们的方式，是成功和行为良好的Windows商店应用程序的关键。
- en: We'll start by examining the execution model of Store apps, and the way it differs
    from classic desktop apps. Then we'll take a look at some of the unique features
    of Store apps, such as live tiles and other notification mechanisms. Finally,
    we'll look at ways in which an application can do work even if it's not the currently
    running app, by using various forms of background tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究商店应用程序的执行模型，以及它与经典桌面应用程序的不同之处。然后我们将看一些商店应用程序的独特特性，如动态磁贴和其他通知机制。最后，我们将探讨应用程序即使不是当前运行的应用程序也可以执行工作的方式，通过使用各种形式的后台任务。
- en: Application lifecycle
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序生命周期
- en: 'Store applications are managed by the Windows operating system with strict
    rules that need to be considered when developing apps:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 商店应用程序由Windows操作系统管理，开发应用程序时需要考虑严格的规则：
- en: 'Only one app can be in the foreground at any single time (the notable exception
    being the "snap view": one app takes most of the screen, while another takes a
    width of 320 pixels; this is discussed in [Chapter 9](ch09.html "Chapter 9. Packaging
    and the Windows Store"), *Packaging and the Windows Store*).'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能有一个应用程序处于前台（一个显著的例外是“快照视图”：一个应用程序占据大部分屏幕，而另一个占据320像素的宽度；这在[第9章](ch09.html
    "第9章。打包和Windows商店")中讨论，*打包和Windows商店*）。
- en: Other apps are automatically suspended by Windows, meaning they get no CPU time;
    the memory they occupy, however, is preserved.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他应用程序会被Windows自动挂起，意味着它们不会获得CPU时间；但它们占用的内存会被保留。
- en: If Windows detects shortage of memory, it may terminate the first suspended
    app; if memory is still tight, it will terminate the second suspended app, and
    so on.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Windows检测到内存不足，它可能会终止第一个挂起的应用程序；如果内存仍然紧张，它将终止第二个挂起的应用程序，依此类推。
- en: 'These rules are there to ensure that the foreground application has full access
    to the CPU and other resources, while also conserving battery power as much as
    possible. The complete app lifecycle can be illustrated with the following state
    diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则旨在确保前台应用程序完全访问CPU和其他资源，同时尽可能节省电池电量。完整的应用程序生命周期可以用以下状态图表示：
- en: '![Application lifecycle](img/5022_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序生命周期](img/5022_07_01.jpg)'
- en: At first, an app is not running. Then the user launches the application, typically
    by clicking or tapping on its tile on the Start Screen. This causes the `Application::OnLaunched`
    virtual method to be invoked; this is where the app should initialize and present
    the main user interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，应用程序不在运行状态。然后用户启动应用程序，通常是通过在开始屏幕上点击或轻触其磁贴。这会导致调用`Application::OnLaunched`虚拟方法；这是应用程序应该初始化并呈现主用户界面的地方。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default code provided by Visual Studio for the `OnLaunched` method creates
    a `Frame` element that becomes the `Content` of the current `Window` (the one
    and only application window). Then a call is made to `Frame::Navigate` with the
    type name of `MainPage`, which causes `MainPage` to appear as expected.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio提供的`OnLaunched`方法的默认代码创建了一个`Frame`元素，它成为当前`Window`（唯一的应用程序窗口）的`Content`。然后调用`Frame::Navigate`并传入`MainPage`的类型名称，这会导致`MainPage`按预期出现。
- en: The application is now in the running state, and the user can interact with
    the app. If the user switches to another application by pressing *Alt* + *Tab*,
    or going to the Start Screen and activating another app tile (or switches to another
    app by swiping from the left), our app is no longer in the foreground. If after
    5 seconds, the user does not switch back to the app, it's suspended by the OS.
    Before that happens, the `Application::Suspended` event is fired. This is a chance
    for the app to save state, in case the app is terminated later. The app is given
    no more than 5 seconds to save state; if it takes longer, the app is terminated.
    Assuming all is well, the app is suspended.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在处于运行状态，用户可以与应用程序交互。如果用户通过按*Alt* + *Tab*切换到另一个应用程序，或者转到开始屏幕并激活另一个应用程序磁贴（或通过从左侧滑动切换到另一个应用程序），我们的应用程序不再处于前台。如果5秒后用户没有切换回应用程序，它将被操作系统挂起。在此之前，`Application::Suspended`事件将被触发。这是应用程序在稍后终止时保存状态的机会。应用程序最多有5秒钟来保存状态；如果时间超过了，应用程序将被终止。假设一切正常，应用程序被挂起。
- en: 'The current state of the app can be viewed in **Task Manager**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的当前状态可以在**任务管理器**中查看：
- en: '![Application lifecycle](img/5022_07_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序生命周期](img/5022_07_02.jpg)'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To view the application's status in **Task Manager**, first select the **View**
    menu and then **Status Values,** and click on **Show suspended status** (it's
    off by default).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**任务管理器**中查看应用程序的状态，首先选择**查看**菜单，然后选择**状态值**，并单击**显示挂起状态**（默认情况下是关闭的）。
- en: Once suspended, the application may be resumed because the user switched back
    to it. This causes the `Resuming` event to fire on the `Application` object. In
    most cases, the app has nothing to do, because the app was retained in memory,
    so nothing has been lost. In cases where the UI should refresh due to stale data,
    the `Resuming` event can be used for that (for example, an RSS reader would refresh
    data because the app could have been suspended for hours, or even days).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦暂停，应用程序可能会恢复，因为用户切换回应用程序。这会导致`Application`对象上的`Resuming`事件触发。在大多数情况下，应用程序无需做任何操作，因为应用程序已保留在内存中，因此没有丢失任何内容。在UI应该因过时数据而刷新的情况下，可以使用`Resuming`事件进行操作（例如，RSS阅读器会刷新数据，因为应用程序可能已经暂停了几个小时，甚至几天）。
- en: While suspended, the application may be terminated by Windows because of low
    memory resources. The application gets no notification that this happened; this
    makes sense, as the app cannot use any CPU cycles while it's suspended. If the
    user activates the app again, `OnLaunched` is called, providing the opportunity
    to restore state with the help of the `LaunchActivatedEventArgs::PreviousExecutionState`
    property. One possible value is `ApplicationExecutionState::Terminated`, indicating
    the app was closed from the suspended state, and so state restoration should be
    attempted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停状态下，由于内存资源不足，应用程序可能会被Windows终止。应用程序不会收到此事件的通知；这是有道理的，因为应用程序在暂停状态下无法使用任何CPU周期。如果用户再次激活应用程序，将调用`OnLaunched`，从而有机会使用`LaunchActivatedEventArgs::PreviousExecutionState`属性恢复状态。一个可能的值是`ApplicationExecutionState::Terminated`，表示应用程序是从暂停状态关闭的，因此应尝试恢复状态。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Individual pages within the app may want to be notified when the app is about
    to be suspended or resumed. This can be done in a constructor of `Page` by accessing
    the global `Application` object with `Application::Current`. A typical suspension
    registration may look like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的单个页面可能希望在应用程序即将暂停或恢复时收到通知。这可以在`Page`的构造函数中通过访问全局`Application`对象`Application::Current`来完成。典型的暂停注册可能如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Saving and restoring the state
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和恢复状态
- en: If, and when, the application is suspended, it's the application's responsibility
    to save whatever state is needed, in case Windows decides to terminate the application
    before it's resumed. This is done in response to the `Application::Suspending`
    event that can be handled on the application level and/or the page level.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序被暂停，那么在应用程序恢复之前，应用程序有责任保存所需的任何状态。这是响应`Application::Suspending`事件完成的，该事件可以在应用程序级别和/或页面级别处理。
- en: 'Suppose we have a movie review application that allows users to review movies.
    A simple UI may exist that looks something like the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个电影评论应用程序，允许用户评论电影。可能存在一个简单的UI，看起来像下面这样：
- en: '![Saving and restoring the state](img/5022_07_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![保存和恢复状态](img/5022_07_03.jpg)'
- en: 'If the user switches to another app, the app will be suspended after 5 seconds
    have elapsed and the user does not switch back. We can use the `Windows::Storage::ApplicationData`
    class to access a local settings store or a local folder (for more complex storage
    requirements) to save the state of the preceding `TextBox` elements so that it
    can be restored should the application be terminated unexpectedly by Windows.
    First, we need to register for the `Suspending` event in the `MainPage` constructor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户切换到另一个应用程序，应用程序将在5秒后暂停，如果用户不切换回，则应用程序将被暂停。我们可以使用`Windows::Storage::ApplicationData`类来访问本地设置存储或本地文件夹（对于更复杂的存储需求），以保存前述`TextBox`元素的状态，以便在应用程序被Windows意外终止时可以恢复。首先，我们需要在`MainPage`构造函数中注册`Suspending`事件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `MovieReview` class represents a review (implements `INotifyPropertyChanged`
    as discussed in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*),
    and the `TextBox` elements bind to its three properties. If the app is suspended,
    the following is executed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovieReview`类表示评论（实现了`INotifyPropertyChanged`，如[第5章](ch05.html "第5章。数据绑定")*数据绑定*中讨论的那样），`TextBox`元素绑定到它的三个属性。如果应用程序被暂停，将执行以下操作：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code uses the `ApplicationData::LocalSettings` property (an `ApplicationDataContainer`
    object), which manages a collection of key/value pairs (with optional inner containers),
    exposed through the `Values` property.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`ApplicationData::LocalSettings`属性（一个`ApplicationDataContainer`对象），它管理一组键/值对（可选的内部容器），通过`Values`属性公开。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The types that can be stored in this way are limited to the basic WinRT types,
    and do not include custom types, such as `MovieReview`. It's possible to create
    some code that serializes such an object to XML or JSON and then saves it as a
    string.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式存储的类型仅限于基本的WinRT类型，并不包括自定义类型，比如`MovieReview`。可以创建一些代码，将这样的对象序列化为XML或JSON，然后将其保存为字符串。
- en: 'If the application is indeed terminated, state needs to be restored. This can
    be done on the `Page::OnNavigatedTo` override, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序确实被终止，需要恢复状态。可以在`Page::OnNavigatedTo`覆盖中执行此操作，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To test this, we can run the app without the Visual Studio debugger. However,
    if we need to debug the code, there is a slight problem. When the app is being
    debugged, it will never enter a suspended state. This is to allow the developer
    to switch to Visual Studio and look at code while the app is in the background
    and still be able to switch to it at any time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以在没有Visual Studio调试器的情况下运行应用程序。但是，如果需要调试代码，会有一个小问题。当应用程序正在调试时，它永远不会进入暂停状态。这是为了让开发人员能够切换到Visual
    Studio并查看代码，同时应用程序在后台仍然可以随时切换到它。
- en: 'We can force the app to go into suspension by using the Visual Studio toolbar
    button that allows suspending, resuming, and terminating the app (and invoking
    background tasks, as we''ll see in the section *Background tasks* later in this
    chapter):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Visual Studio工具栏按钮来强制应用程序进入暂停状态，该按钮允许暂停、恢复和终止应用程序（以及调用后台任务，我们将在本章后面的*后台任务*部分中看到）：
- en: '![Saving and restoring the state](img/5022_07_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![保存和恢复状态](img/5022_07_04.jpg)'
- en: Determining application execution states
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定应用程序执行状态
- en: When the application is activated, it may be because it's being launched by
    the user (there are other options, such as implemented contracts, as we'll see
    in the next chapter). It's usually important to learn why the application has
    been closed the last time around. If it was terminated, state should have restored.
    If, on the other hand, it was closed by the user, perhaps the state should have
    cleared, as the user is expecting the app to start afresh.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序被激活时，可能是因为用户启动了它（还有其他选项，比如实现的合同，我们将在下一章中看到）。通常很重要了解应用程序上次关闭的原因。如果是被终止，状态应该已经恢复。另一方面，如果是用户关闭的，也许状态应该已经清除，因为用户期望应用程序重新开始。
- en: 'We can determine this previous state using the `LaunchActivatedEventArgs::PreviousExecutionState`
    property available on the application''s `OnLaunched` method override:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用应用程序的 `OnLaunched` 方法重写中可用的 `LaunchActivatedEventArgs::PreviousExecutionState`
    属性来确定上一个状态：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s useful to write the state to the `LocalSettings` container so that other
    entities (typically pages) can access this information after `OnLaunched` is done.
    This allows our restore code to query this state and act accordingly:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态写入 `LocalSettings` 容器是有用的，这样其他实体（通常是页面）可以在 `OnLaunched` 完成后访问这些信息。这允许我们的恢复代码查询这个状态并相应地行动：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Enums are also forbidden from being stored directly, but can be cast to an `int`
    and then stored.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也禁止直接存储，但可以转换为 `int` 然后存储。
- en: State store options
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态存储选项
- en: The previous code samples used the `ApplicationData::LocalSettings` property.
    This uses a store local to the machine (and the current user and application),
    meaning that on another device running Windows 8, even if the same user is logged
    in, the same state will not be available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例使用了 `ApplicationData::LocalSettings` 属性。这使用了一个存储在本地机器上（当前用户和应用程序）的存储，这意味着在运行
    Windows 8 的另一台设备上，即使相同的用户登录，相同的状态也不可用。
- en: WinRT provides an alternative, which allows settings to roam across devices
    by being stored within the Microsoft cloud service using the `ApplicationData::RoamingSettings`
    property. Working with this property is exactly the same as with `LocalSettings`;
    it's automatically synchronized with the cloud.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT 提供了一种替代方案，允许设置通过使用 `ApplicationData::RoamingSettings` 属性存储在 Microsoft
    云服务中在设备之间漫游。使用这个属性的方式与 `LocalSettings` 完全相同；它会自动与云同步。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Synchronization with the cloud can only work if the user has logged in to the
    system with his Microsoft ID (formerly Live ID), and not a "normal" username/password.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与云同步只有在用户使用他的 Microsoft ID（以前是 Live ID）登录系统时才能工作，而不是“普通”的用户名/密码。
- en: '`LocalSettings` and `RoamingSettings` are useful for simple key/value pairs.
    If more complex data needs to be stored, we can create a folder (`StorageFolder`
    object) that we can use by creating `StorageFile` objects, more folders, and so
    on, as needed. This is available by accessing other `ApplicationData` properties:
    `LocalFolder`, `RoamingFolder`, and `TemporaryFolder` (`TemporaryFolder` stores
    information until the app terminates, and is not usually useful for application
    state management).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalSettings` 和 `RoamingSettings` 对于简单的键/值对非常有用。如果需要存储更复杂的数据，我们可以创建一个文件夹（`StorageFolder`
    对象），然后可以通过创建 `StorageFile` 对象、更多文件夹等等来使用。这可以通过访问其他 `ApplicationData` 属性实现：`LocalFolder`、`RoamingFolder`
    和 `TemporaryFolder`（`TemporaryFolder` 存储信息直到应用程序终止，通常不适用于应用程序状态管理）。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Files stored in the local application store (`ApplicationData::LocalFolder`)
    can be accessed with a URI that starts with `ms-appdata:///local/` followed by
    the relative path of the file; replace `local` with `roaming` to access the roaming
    store. These URIs can be used in XAML, as well as in code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在本地应用程序存储中（`ApplicationData::LocalFolder`）的文件可以通过以 `ms-appdata:///local/`
    开头的 URI 访问，后面跟着文件的相对路径；将 `local` 替换为 `roaming` 可以访问漫游存储。这些 URI 可以在 XAML 中使用，也可以在代码中使用。
- en: Helper classes
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助类
- en: 'Some of the Visual Studio 2012 project templates, such as Grid App, provide
    two classes that can help in state management: `SuspensionManager` and `LayoutAwarePage`.
    These provide the following features:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Visual Studio 2012 项目模板，如 Grid App，提供了两个类，可以帮助进行状态管理：`SuspensionManager`
    和 `LayoutAwarePage`。它们提供了以下功能：
- en: Can manage a navigation pages stack, saved as XML in a local folder
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以管理导航页面堆栈，保存为本地文件夹中的 XML
- en: '`LayoutAwarePage` must be used as the base page class'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LayoutAwarePage` 必须用作基本页面类'
- en: Can save/restore this state automatically
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动保存/恢复此状态
- en: The interested readers should refer to the source code for more information
    on these classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者应该参考源代码以获取有关这些类的更多信息。
- en: Live tiles
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态磁贴
- en: One of the unique characteristics of Windows Store apps is the use of tiles
    on the Start Screen. These tiles can contain images and text, but these need not
    be constant and can change. Through various mechanisms to provide live and meaningful
    information, draw the user to tapping/clicking on the tile, to access the app
    itself. In this section, we'll take a look at creating and manipulating tiles.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Store 应用程序的一个独特特性是在开始屏幕上使用磁贴。这些磁贴可以包含图像和文本，但这些不需要是恒定的，可以改变。通过各种机制提供实时和有意义的信息，吸引用户点击磁贴，访问应用程序本身。在本节中，我们将看看如何创建和操作磁贴。
- en: Setting application tile defaults
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用磁贴默认值
- en: 'The defaults of an application tile can be set in the application manifest,
    which is easily accessible through the Visual Studio user interface:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应用磁贴的默认设置可以在应用清单中设置，通过 Visual Studio 用户界面很容易访问：
- en: '![Setting application tile defaults](img/5022_07_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用磁贴默认值](img/5022_07_05.jpg)'
- en: 'Two sizes of tiles are available, the standard and the wide. If a wide logo
    image is available, it will be shown by default and the user will be able to change
    that to a standard tile (and vice versa) by right clicking on the tile (or swiping
    from the bottom) and selecting the relevant option:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种大小的磁贴可用，标准和宽。如果有宽标志图像可用，默认会显示，并且用户可以通过右键单击磁贴（或从底部滑动）并选择相关选项来将其更改为标准磁贴（反之亦然）。
- en: '![Setting application tile defaults](img/5022_07_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用程序磁贴默认值](img/5022_07_06.jpg)'
- en: The standard tile image should be 150 px x 150 px and the wide tile image should
    be 310 px x 150 px. If these sizes are not supplied, Visual Studio will issue
    a warning and the images will be stretched/shrunk as needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 标准磁贴图像应为150像素x150像素，宽磁贴图像应为310像素x150像素。如果未提供这些尺寸，Visual Studio将发出警告，并且图像将根据需要进行拉伸/缩小。
- en: The **Short name** will appear on top of the tiles selected within the **Show
    name** combobox (**All Logos**, **No logos**, **Standard logo only**, and **Wide
    logo only**). The **Foreground text** option selects light or dark text and the
    background color selected will be used for transparent images (PNG files) and
    for some other dialogs, as the default background color.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**短名称**将显示在**显示名称**组合框（**所有标志**、**无标志**、**仅标准标志**和**仅宽标志**）中选择的磁贴顶部。**前景文本**选项选择浅色或深色文本，所选的背景颜色将用于透明图像（PNG文件）和一些其他对话框，作为默认背景颜色。'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An application should not define a wide tile unless the app plans to provide
    meaningful and interesting content within that tile. Just using a large static
    image is a bad idea; users will expect the tile to provide something more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不应定义宽磁贴，除非应用程序计划在该磁贴中提供有意义且有趣的内容。仅使用大型静态图像是一个坏主意；用户会期望磁贴提供更多内容。
- en: Updating the tile's contents
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新磁贴的内容
- en: A tile can be updated by the running application. The updated tile will retain
    its contents even if the application is closed. Updating a tile involves creating
    some XML that specifies parts of the tile, which can include images and text in
    various layouts. There are also peek tile options that alternate between two tile
    sets. The first thing we need to do is select an appropriate tile template from
    an extensive, predefined set of templates. Each template is represented by an
    XML string that needs to be sent as the actual update.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以更新正在运行的磁贴。即使应用程序关闭，更新后的磁贴也会保留其内容。更新磁贴涉及创建一些指定磁贴部分的XML，其中可以包括各种布局的图像和文本。还有可以在两个磁贴集之间交替的窥视磁贴选项。我们需要做的第一件事是从一组广泛的预定义模板中选择一个合适的磁贴模板。每个模板由一个XML字符串表示，需要作为实际更新发送。
- en: 'Tile templates exist for standard and wide tiles; these are represented by
    the `Windows::UI::Notifications::TileTemplateType` enumeration. Here''s an example
    of the generic XML needed for a wide tile with one text item, known as `TileWideImageAndText01`
    (the enum value):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标准磁贴和宽磁贴都有模板；这些由`Windows::UI::Notifications::TileTemplateType`枚举表示。以下是一个宽磁贴的通用XML示例，其中包含一个文本项，称为`TileWideImageAndText01`（枚举值）：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The highlighted element and inner text need to be updated with the required
    new content.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用所需的新内容更新突出显示的元素和内部文本。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete template list and XML schemas can be found at [http://msdn.microsoft.com/EN-US/library/windows/apps/hh761491(v=vs.10).aspx](http://msdn.microsoft.com/EN-US/library/windows/apps/hh761491(v=vs.10).aspx).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模板列表和XML模式可以在[http://msdn.microsoft.com/EN-US/library/windows/apps/hh761491(v=vs.10).aspx](http://msdn.microsoft.com/EN-US/library/windows/apps/hh761491(v=vs.10).aspx)找到。
- en: 'After selecting the required template, we can retrieve the associated XML with
    the following code (no need to build the whole XML manually):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所需的模板后，可以使用以下代码检索相关的XML（无需手动构建整个XML）：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The returned value is a `Windows::Data::Xml::Dom::XmlDocument`, representing
    the resulting XML. Now, we need to tweak the XML with the required updates. In
    this example, we''ll change the image and text:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值是一个`Windows::Data::Xml::Dom::XmlDocument`，表示生成的XML。现在，我们需要使用所需的更新调整XML。在这个例子中，我们将更改图像和文本：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code uses the WinRT XML DOM API to manipulate the XML. The image is set
    to a local image, but remote images (`http://...`) work just as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用WinRT XML DOM API来操作XML。图像设置为本地图像，但远程图像（`http://...`）同样有效。
- en: 'The last step would be to create a tile updater for the app, build the tile
    notification and do the actual update:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为应用程序创建磁贴更新程序，构建磁贴通知并进行实际更新：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s the resulting wide tile:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的宽磁贴：
- en: '![Updating the tile''s contents](img/5022_07_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![更新磁贴的内容](img/5022_07_07.jpg)'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code updates the wide tile only, leaving the standard tile unchanged.
    To change the standard tile as well, we can add another `<binding>` element to
    the `<visual>` element, with the appropriate XML for the required standard tile.
    This will make both changes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅更新宽磁贴，保持标准磁贴不变。要同时更改标准磁贴，我们可以向`<visual>`元素添加另一个`<binding>`元素，其中包含所需标准磁贴的适当XML。这将使两个更改都生效。
- en: Enabling cycle updates
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用循环更新
- en: 'One interesting feature of live tiles is the ability to cycle up to five tile
    updates, working with the last five by default. The following code will enable
    tile cycling:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 磁贴的一个有趣特性是能够循环最多五次磁贴更新，默认情况下与最后五个一起工作。以下代码将启用磁贴循环：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If a particular tile should be replaced (instead of the first update being dropped),
    a tile may be tagged with a unique value, using the `TileNotification::Tag` property,
    identifying the exact tile to replace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应该替换特定磁贴（而不是丢弃第一个更新），可以使用`TileNotification::Tag`属性为磁贴打上唯一值，以标识要替换的确切磁贴。
- en: Tile expiration
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁贴过期
- en: A tile can be set to expire at some point in the future, by setting the `TileNotification::ExpirationTime`
    property. When the time comes, the tile reverts to its default state.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置`TileNotification::ExpirationTime`属性，使磁贴在将来某个时间点过期。到时候，磁贴将恢复到默认状态。
- en: Badge updates
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 徽章更新
- en: A **badge** is a small notification symbol, located at the lower-right part
    of a tile. It can be a number in the range 1 to 99, or one of a set of predefined
    glyphs. It's typically used to show a status, such as network connectivity (if
    applicable for the app) or the number of pending messages (in a messaging app).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**徽章**是位于磁贴右下角的小通知符号。它可以是1到99的数字，也可以是一组预定义的图形。通常用于显示状态，例如网络连接（如果适用于应用程序）或待处理消息的数量（在消息应用程序中）。'
- en: 'Updating a badge is very similar to updating a tile—it''s based on an XML string
    that contains a single element (`<badge>`), manipulated to get the desired result.
    Here''s the required code that updates a badge with a numeric value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更新徽章与更新磁贴非常相似-它基于包含单个元素（`<badge>`）的XML字符串，通过操作来获得所需的结果。以下是更新具有数字值的徽章所需的代码：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The variable `count` is used as the numeric value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`count`用作数字值。
- en: Creating secondary tiles
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建辅助磁贴
- en: The application tile (primary tile) can be accompanied by secondary tiles. These
    typically represent deep links into the application. For example, a weather app
    may use secondary tiles for extra locations where weather is important to update
    or a Store app can use secondary tiles as links to specific products.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序磁贴（主磁贴）可以附带辅助磁贴。这些通常代表应用程序中的深层链接。例如，天气应用程序可以使用辅助磁贴来更新天气重要的额外位置，或者商店应用程序可以使用辅助磁贴作为指向特定产品的链接。
- en: In any case, the user is the only entity that can allow secondary tiles to actually
    be pinned to the Start Screen or unpinned from the Start Screen. Usually, some
    UI within the app allows the user to pin a secondary tile, but this can only happen
    if the user provides consent—otherwise the tile is not pinned.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，只有用户才能允许将辅助磁贴固定到开始屏幕上或从开始屏幕上取消固定。通常，应用程序内的一些用户界面允许用户固定辅助磁贴，但只有在用户提供同意的情况下才能发生这种情况-否则磁贴将不会被固定。
- en: 'The following code snippet creates a secondary tile and asks the user if he/she
    wants it pinned to the Start Screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建一个辅助磁贴，并询问用户是否要将其固定到开始屏幕上：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `SecondaryTile` constructor used by the preceding code accepts the following
    arguments in order (they can also be set using properties):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中使用的`SecondaryTile`构造函数按顺序接受以下参数（也可以使用属性设置）：
- en: A unique tile ID that can later be used to identify the tile (for unpinning
    purposes, for example)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以后可以用来识别磁贴的唯一磁贴ID（例如，用于取消固定）
- en: A short name (required) that will show in the system-provided consent dialog
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统提供的同意对话框中显示的必需的短名称
- en: A display name (recommended)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示名称（推荐）
- en: Tile activation arguments that help in determining what to do if the application
    is invoked through the secondary tile (more on that in a moment)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确定应用程序是否通过辅助磁贴调用时有助于的磁贴激活参数（稍后会详细介绍）
- en: Logo URI
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logo URI
- en: 'Calling `SecondaryTile::RequestCreateAsync` presents a standard system dialog
    (based on the tile''s creation arguments), asking the user''s permission to actually
    create and pin the tile:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`SecondaryTile::RequestCreateAsync`会呈现一个标准的系统对话框（基于磁贴的创建参数），询问用户是否实际上要创建和固定磁贴。
- en: '![Creating secondary tiles](img/5022_07_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建辅助磁贴](img/5022_07_08.jpg)'
- en: A secondary tile can be retrieved given its unique ID, by using a `SecondaryTile`
    constructor that accepts an ID only. Other options include calling the static
    `SecondaryTile::FindAllAsync` to get a list of all secondary tiles created by
    the app.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用仅接受ID的`SecondaryTile`构造函数来检索辅助磁贴的唯一ID。其他选项包括调用静态的`SecondaryTile::FindAllAsync`来获取应用程序创建的所有辅助磁贴的列表。
- en: The `SecondaryTile::RequestDeleteAsync` method shows a system dialog, requesting
    the user to consent to a tile deletion.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondaryTile::RequestDeleteAsync`方法显示一个系统对话框，请求用户同意删除磁贴。'
- en: Updating a secondary tile is done in much the same way as it is with the primary
    tile (tile and badge). The only difference is with the updater, created with `TileUpdateManager::CreateTileUpdaterForSecondaryTile`
    (for tile updates) and `BadgeUpdateManager::CreateBadgeUpdaterForSecondaryTile`
    (for badge updates).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更新辅助磁贴与更新主磁贴（磁贴和徽章）的方式基本相同。唯一的区别在于更新器，使用`TileUpdateManager::CreateTileUpdaterForSecondaryTile`（用于磁贴更新）和`BadgeUpdateManager::CreateBadgeUpdaterForSecondaryTile`（用于徽章更新）创建。
- en: Activating a secondary tile
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活辅助磁贴
- en: 'When a secondary tile is tapped or clicked, the application launches as usual.
    Since a secondary tile is supposed to provide a shortcut to a specific location
    within the app, this scenario must be recognized and handled in the `Application::OnLanuched`
    override. Here''s an example code that looks for arguments passed at launch time:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击辅助磁贴时，应用程序会像平常一样启动。由于辅助磁贴应该提供对应用程序内特定位置的快捷方式，因此必须在`Application::OnLanuched`重写中识别和处理这种情况。以下是一个在启动时查找传递参数的示例代码：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code assumes that `DeepPage.xaml` is the relevant page to show, in case
    a secondary tile activation is detected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假定`DeepPage.xaml`是相关页面，以防检测到辅助磁贴激活。
- en: Using toast notifications
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Toast通知
- en: '**Toasts** are small pop-up windows that show important information pertaining
    to an application that may or may not be running at the time. It appears at the
    top-right corner of the screen—the user can tap (or click) on it to run or switch
    to the application, or the user can close (dismiss) the toast as being unimportant
    now, or if the user is not in front of the computer right now, the toast will
    be gone after a few seconds, making the user miss the toast altogether.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Toast**是小弹出窗口，显示与应用程序相关的重要信息，可能在此时正在运行，也可能不在运行。它出现在屏幕的右上角-用户可以点击（或点击）它来运行或切换到应用程序，或者用户可以关闭（解散）Toast，因为现在不重要，或者如果用户现在不在电脑前，Toast将在几秒钟后消失，使用户错过Toast。'
- en: Toasts are somewhat intrusive, as they pop up regardless of the currently executing
    application (the current app can be the classic desktop or even the lock screen).
    This means toasts should be used sparingly, where they really make sense. A typical
    usage is to notify the user for an incoming message in a chat app or a new e-mail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Toast通知有些具有侵入性，因为它们会弹出，而不管当前执行的应用程序是什么（当前应用程序可以是经典桌面，甚至是锁定屏幕）。这意味着Toast应该谨慎使用，只有在真正有意义的地方才应该使用。典型的用法是在聊天应用程序中通知用户有新消息或新电子邮件。
- en: Toast notifications can be turned off on an app by app basis, by selecting the
    **Settings** charm and then selecting **Permissions**. Toasts can also be disabled
    globally, by going to the **Windows PC** settings and selecting **Notifications**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按应用程序基础关闭应用程序的提示通知，方法是选择**设置**魅力，然后选择**权限**。也可以通过转到**Windows PC**设置并选择**通知**来全局禁用提示通知。
- en: 'To make toast notifications work, the app should declare in its manifest that
    it''s toast capable (the **Application UI** tab in the manifest view in Visual
    Studio):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要使提示通知起作用，应用程序应在其清单中声明其具有提示功能（在Visual Studio的清单视图中的**应用程序UI**选项卡）：
- en: '![Using toast notifications](img/5022_07_16.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用提示通知](img/5022_07_16.jpg)'
- en: Raising a toast notification is somewhat similar to tiles. First, we select
    a predefined template using the `ToastTemplateType` enumeration and then build
    an appropriate XML based on that template (the content is available through the
    `ToastNotificationManager::GeTemplateContent` method). Next, we create a `ToastNotification`
    object, passing the final XML. Finally, we call `ToastNotificationManager::CreateToastNotifier()->Show`,
    passing the `ToastNotification` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 引发提示通知与磁贴有些类似。首先，我们使用`ToastTemplateType`枚举选择一个预定义的模板，然后基于该模板构建一个适当的XML（内容可通过`ToastNotificationManager::GeTemplateContent`方法获得）。接下来，我们创建一个`ToastNotification`对象，传递最终的XML。最后，我们调用`ToastNotificationManager::CreateToastNotifier()->Show`，传递`ToastNotification`对象。
- en: Toast options
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示选项
- en: Toasts can be scheduled to a future point in time by using the `ScheduledToastNotification`
    class instead of `ToastNotification`. The second argument to the constructor is
    a `DateTime` value indicating when the toast should be raised. The `Show` method
    must be replaced with `AddToSchedule` for this to compile and work correctly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ScheduledToastNotification`类将提示通知安排到将来的时间点，而不是使用`ToastNotification`。构造函数的第二个参数是一个`DateTime`值，指示何时引发提示。为了使其编译并正确工作，`Show`方法必须替换为`AddToSchedule`。
- en: A second constructor to `ScheduledToastNotification` provides a way to show
    a recurring toast, with a time interval between pop ups (between 1 minute and
    60 minutes) and a number of times to show the toast (1 to 5).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScheduledToastNotification`的第二个构造函数提供了一种显示定期提示的方法，弹出之间有时间间隔（1分钟到60分钟之间），并且显示提示的次数（1到5次）。'
- en: Toasts can be standard (showing for 7 seconds) or long (showing for 25 seconds).
    Long toasts are appropriate when there is a human on the other side of the toast,
    such as an incoming call. To set it up, a `duration` attribute must be set to
    `long` within the toast XML.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提示可以是标准的（显示7秒）或长的（显示25秒）。当提示的另一端有人时，例如来电时，长提示是合适的。要设置它，必须在提示XML中设置`duration`属性为`long`。
- en: Toasts play a default sound effect when shown. This effect can be changed to
    one of the set of predefined sounds available in Windows for this purpose. Again,
    this is accomplished by adding an `audio` element, with an `src` attribute set
    to one of the predefined sound strings (check the documentation for a complete
    list).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 提示在显示时会播放默认的声音效果。这个效果可以更改为Windows提供的一组预定义声音中的一个。同样，这是通过添加一个`audio`元素来实现的，其中`src`属性设置为预定义的声音字符串之一（查看完整列表的文档）。
- en: Push notifications
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送通知
- en: As we've seen, an application can set its tile (and optional secondary tiles)
    in any way that's reasonable; it can even update the tiles if new information
    is received. But what happens if the application is suspended? How can it update
    its tile? Worse, the application may not be running at all. How would its tile
    get updated? Imagine a news app that may want its tile to reflect recent news.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，应用程序可以以任何合理的方式设置其磁贴（和可选的辅助磁贴）；如果收到新信息，甚至可以更新磁贴。但是，如果应用程序被挂起会发生什么？它如何更新其磁贴？更糟糕的是，应用程序可能根本没有运行。它的磁贴如何更新？想象一下一个新闻应用程序可能希望其磁贴反映最近的新闻。
- en: One way to do this is with push notifications. As the name suggests, the notifications
    are pushed by a server onto the device that may or may not be running the app
    at the time. This is in contrast to a pull model, where some part of the app polls
    some server for new information. Push notifications are energy efficient and don't
    require the app to do anything special (apart from first registering for notifications
    as we'll see in a moment) to get the notifications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用推送通知。顾名思义，通知是由服务器推送到设备上的，该设备可能正在运行应用程序，也可能没有。这与拉模型相反，其中应用程序的某个部分轮询某个服务器以获取新信息。推送通知是节能的，并且不需要应用程序做任何特殊的事情（除了首先注册通知，我们马上就会看到）来获取通知。
- en: Push notification architecture
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送通知架构
- en: Push notifications involve several participants, the application being just
    one of them. The push notification itself is sent from a Microsoft-provided service,
    the **Windows Notification Service** (**WNS**) hosted on Windows Azure. The other
    major entity is an application server that has the logic, or is controlled appropriately,
    to actually initiate push notifications. In the news app example, this would be
    a server that receives news updates and then spreads them around using push notifications
    to all registered client apps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知涉及多个参与者，应用程序只是其中之一。推送通知本身是从由微软提供的服务发送的，即托管在Windows Azure上的**Windows通知服务**（**WNS**）。另一个主要实体是一个应用程序服务器，它具有逻辑或适当地受控以实际发起推送通知。在新闻应用程序示例中，这将是一个接收新闻更新然后使用推送通知向所有注册的客户端应用程序传播它们的服务器。
- en: 'The push notifications architecture is summarized in the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知架构总结在以下图表中：
- en: '![Push notification architecture](img/5022_07_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![推送通知架构](img/5022_07_09.jpg)'
- en: 'The basic steps to set up push notifications are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设置推送通知的基本步骤如下：
- en: The Windows Store application must register to receive notifications. It uses
    a WinRT API to call WNS and request a unique channel URI that identifies this
    app (technically the primary tile) for this user on this device.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows Store应用程序必须注册以接收通知。它使用WinRT API调用WNS并请求一个唯一的通道URI，该URI标识了此应用程序（技术上是主要磁贴）在此设备上的此用户。
- en: WNS returns a unique channel URI to the application.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WNS向应用程序返回一个唯一的通道URI。
- en: The app needs to pass the unique channel URI and some unique client identifier
    to the application server. A unique client ID is usually required because the
    channel URI can expire and will have to be renewed. The client ID remains the
    identity as far as the app server is concerned.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序需要将唯一的通道URI和一些唯一的客户端标识符传递给应用服务器。通常需要一个唯一的客户端ID，因为通道URI可能会过期并且需要更新。客户端ID在应用服务器看来仍然是身份。
- en: The application server stores a list of all registered clients with their channel
    URIs. Later, when a notification needs to be sent, it will loop over the list
    and send the notifications.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用服务器存储了所有已注册客户端的URI列表。稍后，当需要发送通知时，它将遍历列表并发送通知。
- en: The application server needs to authenticate with WNS and get an authentication
    token in return, to be used as part of the push notification payload. This is
    a one-time operation, but may need to repeat as the token may expire in the future.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用服务器需要与WNS进行身份验证，并获得身份验证令牌以供使用作为推送通知有效负载的一部分。这是一次性操作，但可能需要重复，因为令牌可能在将来过期。
- en: Finally, when the application server logic decides to send a push notification
    (or is instructed by some external management app), it sends the notification
    as an HTTP POST request.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当应用服务器逻辑决定发送推送通知（或者由某个外部管理应用程序指示时），它将通知作为HTTP POST请求发送。
- en: WNS receives the request and does the actual push notification to the client
    device.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WNS接收请求并对客户端设备执行实际的推送通知。
- en: A push notification can change a live tile (the primary tile or a secondary
    tile), change the badge, or make a toast notification appear. It can even send
    raw, application-specific notifications that can run a background task registered
    for the app (background tasks will be discussed later in this chapter).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知可以更改动态磁贴（主磁贴或辅助磁贴），更改徽章，或使弹出式通知出现。它甚至可以发送原始的、特定于应用程序的通知，可以运行为应用程序注册的后台任务（后台任务将在本章后面讨论）。
- en: In the next section, we'll see examples for implementing the preceding steps
    to get push notifications up and running.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到实现前述步骤以启动推送通知的示例。
- en: Building a push notification application
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建推送通知应用程序
- en: 'The first step for receiving push notifications is to get a unique URI from
    WNS. This is a fairly simple operation, involving a single method call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接收推送通知的第一步是从WNS获取唯一的URI。这是一个相当简单的操作，涉及单个方法调用：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The call to returns a `PushNoticationChannel` object that is stored for later
    use in the `_channel` member variable. These types reside in the `Windows::Networking::PushNotifications`
    namespace.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 调用返回一个`PushNoticationChannel`对象，该对象存储在`_channel`成员变量中以供以后使用。这些类型位于`Windows::Networking::PushNotifications`命名空间中。
- en: The next step is to register this URI with the application server, so let's
    take a look at that server first.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此URI注册到应用服务器，因此让我们首先看看该服务器。
- en: The application server
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用服务器
- en: The application server can be built with any server-side technology, within
    the Microsoft stack or outside it. A typical server will expose some kind of service
    that clients can connect to and register their unique URIs for push notification
    (and perhaps other) purposes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器可以使用任何服务器端技术构建，可以在Microsoft堆栈内部或外部。典型的服务器将公开某种服务，客户端可以连接到该服务并注册其用于推送通知（也许还有其他用途）的唯一URI。
- en: 'As an example, we''ll build a WCF service hosted in IIS that will expose an
    appropriate operation for this purpose. The example assumes that the server manages
    movie information and wants to notify registered clients that a new movie is available.
    The WCF service interface would be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将构建一个托管在IIS中的WCF服务，该服务将公开一个适当的操作以实现此目的。该示例假定服务器管理电影信息并希望通知已注册的客户端有新电影可用。WCF服务接口将如下所示：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `IMoviesService` has two operations (modelled as methods):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMoviesService`有两个操作（建模为方法）：'
- en: '`RegisterForPushNotification` is used to enlist an interested client as a target
    for push notifications. It passes a `ClientInfo` object that has the unique channel
    URI (obtained from the previous step) and some unique client ID.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterForPushNotification`用于将感兴趣的客户端注册为推送通知的目标。它传递了一个`ClientInfo`对象，其中包含了唯一的通道URI（从上一步获取）和一些唯一的客户端ID。'
- en: The `AddNewMovie` operation will be called later by some controller application
    to indicate that a new movie is available and consequently to invoke the push
    operation (we'll look at that in a moment).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddNewMovie`操作稍后将由某个控制器应用程序调用，以指示有新电影可用，并因此调用推送操作（我们稍后会看到）。'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**WCF** (**Windows Communication Foundation**) is a .NET-based technology for
    writing services and service clients and is beyond the scope of this book, as
    it has no direct relation to Windows 8 Store apps. WCF will be used for the server-side
    code, as it''s fairly well-known and easy enough to use, at least for these purposes;
    the code, naturally, is written in C#.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: WCF（Windows Communication Foundation）是一种基于.NET的技术，用于编写服务和服务客户端，超出了本书的范围，因为它与Windows
    8商店应用没有直接关系。 WCF将用于服务器端代码，因为它相当知名且易于使用，至少对于这些目的来说；代码自然是用C#编写的。
- en: 'The first thing such a service must do is obtain an authentication token from
    WNS, so it can actually perform push notifications. The first step to achieve
    this is to register the Windows 8 application and obtain two pieces of information:
    a security ID and a secret key. With these information in hand, we can contact
    WNS and request a token. To register the app we have to browse to [https://manage.dev.live.com](https://manage.dev.live.com),
    log in with our Microsoft ID (formerly Live ID), click on **Create application**,
    enter some unique application name, and then click on **Yes**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的服务必须首先从WNS获取身份验证令牌，以便实际执行推送通知。实现这一点的第一步是注册Windows 8应用程序并获取两个信息：安全ID和秘钥。有了这些信息，我们可以联系WNS并请求一个令牌。要注册应用程序，我们必须浏览到[https://manage.dev.live.com](https://manage.dev.live.com)，使用我们的Microsoft
    ID（以前是Live ID）登录，点击**创建应用程序**，输入一些唯一的应用程序名称，然后点击**是**。
- en: '![The application server](img/5022_07_10.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![应用服务器](img/5022_07_10.jpg)'
- en: 'The result is a **security ID** (**SID**) and a secret key:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个**安全ID**（**SID**）和一个秘密密钥：
- en: '![The application server](img/5022_07_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序服务器](img/5022_07_11.jpg)'
- en: 'We''ll copy these and store them as simple constant or static fields in the
    service class implementation. The application name itself must be copied to the
    application manifest (in the **Packaging** tab), with some other details outlined
    on the web page. To make some of this easier, right-click on the project, select
    **Store**, and then select **Associate App with Store**. This will enter most
    information to the correct locations:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制这些并将它们存储为服务类实现中的简单常量或静态字段。应用程序名称本身必须复制到应用程序清单（在**打包**选项卡中），网页上概述了其他一些详细信息。为了使其中一些工作更容易，右键单击项目，选择**商店**，然后选择**将应用与商店关联**。这将把大部分信息输入到正确的位置：
- en: '![The application server](img/5022_07_22.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序服务器](img/5022_07_22.jpg)'
- en: 'The code to obtain the authentication token would be as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 获取身份验证令牌的代码如下：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code is fairly uninteresting. It uses the specific format required for the
    authentication procedure. The `WebClient` class provides a simple way in .NET
    to make HTTP calls. The result of the call is a string representation of a JSON
    object, which is deserialized by the `Newtonsoft.Json.JsonConvert` class. Finally,
    the `access_token` field is the actual token we need, saved in the static variable
    `_token`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当无聊。它使用所需的身份验证过程的特定格式。`WebClient`类提供了在.NET中进行HTTP调用的简单方法。调用的结果是JSON对象的字符串表示，由`Newtonsoft.Json.JsonConvert`类进行反序列化。最后，`access_token`字段是我们需要的实际令牌，保存在静态变量`_token`中。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`JsonConvert` is part of the free `Json.NET` package, which can easily be installed
    using Nuget (right-click on the project in Visual Studio, select **Manage Nuget
    packages…**, search for `Json.Net`, and click on **Install**.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonConvert`是免费的`Json.NET`包的一部分，可以使用Nuget轻松安装（在Visual Studio中右键单击项目，选择**管理Nuget包...**，搜索`Json.Net`，然后单击**安装**。'
- en: The `dynamic` C# keyword allows (among other things) untyped access to objects,
    by late binding to the actual member (if it exists). The compiler is happy to
    defer type checking to runtime, thus an unrecognized member throws a runtime exception,
    as opposed to the usual compile time error.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` C#关键字允许（除其他功能外）对对象进行无类型访问，通过延迟绑定到实际成员（如果存在）。编译器乐意将类型检查推迟到运行时，因此未识别的成员会引发运行时异常，而不是通常的编译时错误。'
- en: Now that a token is obtained, it can be used to send push notifications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经获得了令牌，可以用它来发送推送通知。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The authentication token can actually expire, which can be discovered by examining
    the response from an actual push notification `POST` request, looking for the
    `Token expired` value for the `WWW-Authenticate` header. In that case, just call
    `GetToken` again to get a new token.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证令牌实际上可能会过期，可以通过检查实际推送通知的`POST`请求的响应来发现，查找`WWW-Authenticate`标头的`Token expired`值。在这种情况下，只需再次调用`GetToken`以获取新令牌。
- en: Now that the server is ready, the client app needs to register its unique channel
    URI with the application service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器已经准备好了，客户端应用程序需要使用应用程序服务注册其唯一的通道URI。
- en: Registering for push notifications
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册推送通知
- en: Theoretically, this step is easy. Just call the `RegisterForPushNotification`
    method on the service, pass the required arguments, and you're done. Unfortunately,
    this is not as easy as we would liked in C++.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这一步很容易。只需调用服务上的`RegisterForPushNotification`方法，传递所需的参数，然后完成。不幸的是，在C++中这并不像我们希望的那样容易。
- en: The app needs to make the correct network call (typically over HTTP) to the
    service. The simplest HTTP calls are based on REST, so it will be simpler if our
    service is configured to accept REST over HTTP.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要对服务进行正确的网络调用（通常通过HTTP）。最简单的HTTP调用基于REST，因此如果我们的服务配置为接受REST over HTTP，那么它将更简单。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**REST** (**Representational State Transfer**) is beyond the scope of this
    book. For our purposes, it means encoding the information on the HTTP URL as simple
    strings, with more complex information passed with the request body. This is in
    contrast to more complicated protocols, such as SOAP.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（**表述状态转移**）超出了本书的范围。对于我们的目的，它意味着将信息编码为HTTP URL上的简单字符串，并使用请求正文传递更复杂的信息。这与更复杂的协议（如SOAP）形成对比。'
- en: 'The WCF service we created is configured to accept REST calls because of the
    `[WebInvoke]` attributes, setting the URL suffix for each request. This also requires
    configuring a service host to use the `WebHttpBinding` WCF binding and the `WebHttp`
    behavior. This is accomplished via the `MovieWorld.svc` file, where the service
    is declared:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的WCF服务配置为接受REST调用，因为使用了`[WebInvoke]`属性，为每个请求设置了URL后缀。这还需要配置服务主机以使用`WebHttpBinding`
    WCF绑定和`WebHttp`行为。这是通过`MovieWorld.svc`文件完成的，其中声明了服务：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Factory` attribute is the important (non-default) part.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factory`属性是重要的（非默认）部分。'
- en: The next challenge is to make a REST (or any HTTP) call from the C++ client
    application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个挑战是从C++客户端应用程序中进行REST（或任何HTTP）调用。
- en: Unfortunately, at the time of writing, there is no easy way to use a WinRT class
    that can make HTTP calls, something along the lines of `WebClient` and `HttpClient`
    in .NET. The documentation recommends using the low-level `IXMLHTTPRequest2` COM
    interface for this purpose.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，没有简单的方法可以使用WinRT类进行HTTP调用，类似于.NET中的`WebClient`和`HttpClient`。文档建议使用低级别的`IXMLHTTPRequest2`
    COM接口来实现此目的。
- en: Although it's certainly possible, it's not easy. Fortunately, Microsoft created
    a C++ wrapper class, `HttpRequest`, which does most of the work for us. I've copied
    the class into the project almost as it is (made one slight modification), so
    now it's much easier to make HTTP calls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这肯定是可能的，但并不容易。幸运的是，微软创建了一个C++包装类`HttpRequest`，它为我们大部分工作。我将该类复制到项目中，现在更容易进行HTTP调用。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`HttpRequest` is implemented in the `HttpRequest.h` or `HttpRequest.cpp` files,
    part of the `MovieApp` project, available with the downloadable source for this
    chapter.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest` 实现在 `HttpRequest.h` 或 `HttpRequest.cpp` 文件中，属于 `MovieApp` 项目的一部分，可在本章可下载的源代码中找到。'
- en: 'Here''s the HTTP request to register the app for push notifications:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注册应用程序接收推送通知的 HTTP 请求：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The body consists of a `ClientInfo` object, serialized as XML with the `Uri`
    element having the unique channel URI obtained in the first step. The client ID
    here is encoded as a constant `123` as an example; in a real app, this would be
    generated as something unique for the app on this machine for this user. The strange
    port number is the local port IIS that is listening on where my service is hosted.
    Again, in a real app, this would be over port 80 (regular HTTP) or 443 (HTTPS).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 主体由一个 `ClientInfo` 对象组成，以 XML 格式序列化，其中 `Uri` 元素包含在第一步获取的唯一通道 URI。这里的客户端 ID 被编码为常量
    `123` 作为示例；在真实的应用程序中，这将作为此用户在此设备上的应用程序的唯一标识生成。奇怪的端口号是本地 IIS 监听的端口，我的服务托管在那里。同样，在真实的应用程序中，这将在端口
    80（常规 HTTP）或 443（HTTPS）上进行。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative way to issue an HTTP request is by using the C++ REST SDK (Casablanca)
    library; this was published to CodePlex at the time these lines were written.
    This library allows (among other things) working with HTTP requests in an easy
    and customizable way, somewhat similar to the .NET `HttpClient` class. The SDK
    can be found at [http://casablanca.codeplex.com/](http://casablanca.codeplex.com/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 发出 HTTP 请求的另一种方法是使用 C++ REST SDK（Casablanca）库；这是在编写这些行时发布到 CodePlex 的。该库允许（除其他功能外）以一种简单和可定制的方式处理
    HTTP 请求，与 .NET `HttpClient` 类有些相似。该 SDK 可以在 [http://casablanca.codeplex.com/](http://casablanca.codeplex.com/)
    找到。
- en: Issuing the push notification
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布推送通知
- en: 'When the application server gets a call to its `AddNewMovie` method (as part
    of some logic in the server itself, or because some management application invoked
    the operation), it needs to send push notifications to all registered clients:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序服务器收到对其 `AddNewMovie` 方法的调用时（作为服务器本身的某些逻辑的一部分，或者因为某个管理应用程序调用了该操作），它需要向所有注册的客户端发送推送通知：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `SendPushTileNotification` method looks like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendPushTileNotification` 方法如下所示：'
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The body of the message is a regular XML tile. In this case, it includes two
    lines of text:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的主体是一个常规的 XML 磁贴。在这种情况下，它包括两行文本：
- en: The first contains the year the movie was published
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个包含电影发布年份
- en: The second includes the movie name
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个包括电影名称
- en: The notification is an HTTP `POST` request, based on the unique channel URI,
    with some specific headers that must be set correctly. Also, notice the use of
    the authentication token obtained earlier from WNS.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是基于唯一通道 URI 的 HTTP `POST` 请求，具有一些必须正确设置的特定标头。还要注意之前从 WNS 获取的身份验证令牌的使用。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `await` C# keyword allows waiting for an asynchronous operation without
    blocking the calling thread. This is similar to our use of the task`<T>` class
    with the `then` method. C# still looks easier to use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` C# 关键字允许等待异步操作而不阻塞调用线程。这类似于我们使用 `task`<T>` 类和 `then` 方法。C# 看起来仍然更容易使用。'
- en: The type of notification can change to toast or badge by changing the `X-WNS-Type`
    header to `wns/toast` and `wns/badge` respectively. The body, naturally, must
    be modified accordingly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `X-WNS-Type` 标头更改为 `wns/toast` 和 `wns/badge`，通知类型可以更改为 toast 或 badge。主体自然也必须相应地修改。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sample code for this chapter includes a project named `MovieManager` that
    is used to add new movies that generate push notifications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码包括一个名为 `MovieManager` 的项目，用于添加生成推送通知的新电影。
- en: 'Here''s the original application tile (left) and the tile after a push notification
    of a new movie:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始应用程序磁贴（左）和推送通知新电影后的磁贴：
- en: '![Issuing the push notification](img/5022_07_12.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![发布推送通知](img/5022_07_12.jpg)'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The recently available Windows Azure Mobile Services provide easier ways of
    maintaining push notification clients and sending the notifications themselves
    (and other useful capabilities). Mobile Services are outside the scope of this
    book, but more information can be found at [http://www.windowsazure.com/en-us/develop/mobile/](http://www.windowsazure.com/en-us/develop/mobile/).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最近提供的 Windows Azure 移动服务提供了更简单的方式来维护推送通知客户端并发送通知本身（以及其他有用的功能）。移动服务不在本书的范围之内，但可以在
    [http://www.windowsazure.com/en-us/develop/mobile/](http://www.windowsazure.com/en-us/develop/mobile/)
    找到更多信息。
- en: Push notifications for secondary tiles
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助磁贴的推送通知
- en: Secondary tiles can also be targets for push notifications. The main difference
    is the way a unique channel URI is obtained by the client app. It uses `CreatePushNotificationChannelForSecondaryTileAsync`
    with the tile ID, instead of `CreatePushNotificationChannelForApplicationAsync`
    (both static methods of the `PushNotificationChannelManager` class).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助磁贴也可以成为推送通知的目标。主要区别在于客户端应用程序获取唯一通道 URI 的方式。它使用 `CreatePushNotificationChannelForSecondaryTileAsync`
    与磁贴 ID，而不是 `CreatePushNotificationChannelForApplicationAsync`（`PushNotificationChannelManager`
    类的两个静态方法）。
- en: Background tasks
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台任务
- en: Windows Store applications may be suspended when the user switches to another
    app. The app may still want some work to happen even while the app is suspended
    and even terminated. This is the job of background tasks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户切换到另一个应用程序时，Windows Store 应用程序可能会被挂起。即使应用程序被挂起甚至终止，应用程序可能仍然希望发生一些工作。这是后台任务的工作。
- en: What is a task?
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是任务？
- en: A **task** is just a class that implements the `Windows::ApplicationModel::Background::IBackgroundTask`
    interface, having just one method, `Run`. This class must be placed in a separate
    project from the main application, in a **Windows Runtime Component** type project.
    This is essential, as tasks run in a separate process, and thus cannot be bound
    with the main app (so they are not suspended if the main app is suspended).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务** 只是实现 `Windows::ApplicationModel::Background::IBackgroundTask` 接口的类，只有一个方法
    `Run`。这个类必须放在与主应用程序不同的项目中，即 **Windows Runtime Component** 类型的项目中。这是必不可少的，因为任务在一个单独的进程中运行，因此不能与主应用程序绑定（因此，如果主应用程序被挂起，它们也不会被挂起）。'
- en: The main application needs to reference the project where the task(s) are located,
    and indicate via its manifest that these are indeed its tasks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序需要引用包含任务的项目，并通过其清单指示这些确实是其任务。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An application can have any number of tasks implemented in one or more Windows
    Runtime Component projects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以在一个或多个Windows Runtime组件项目中实现任意数量的任务。
- en: A task must have exactly one trigger, specifying what triggers the task execution.
    A task can also have zero or more conditions that must be specified for the trigger
    to be usable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 任务必须有一个触发器，指定触发任务执行的条件。任务还可以具有零个或多个必须为触发器指定的条件。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only one trigger can be associated with a task, but it's possible to register
    another task that runs the same code, but configured with a different trigger.
    This effectively creates a task that can run with multiple triggers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 只能将一个触发器与任务关联，但可以注册另一个使用相同代码运行的任务，但配置了不同的触发器。这有效地创建了一个可以使用多个触发器运行的任务。
- en: Creating and registering a task
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和注册任务
- en: 'The first step for creating a task is to create a Windows Runtime Component
    project with a class that implements the `IBackgroundTask` interface, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任务的第一步是创建一个实现`IBackgroundTask`接口的类的Windows Runtime组件项目，如下所示：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to add a reference to the task component from the main application
    project. The last prerequisite is to add the task to the main application''s manifest.
    This is done in the **Declarations** tab:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从主应用程序项目中添加对任务组件的引用。最后一个前提是将任务添加到主应用程序的清单中。这是在**声明**选项卡中完成的：
- en: '![Creating and registering a task](img/5022_07_13.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![创建和注册任务](img/5022_07_13.jpg)'
- en: A background task declaration is selected with the appropriate task type, which
    roughly means trigger type, as will be used later for actual registration in code.
    We'll discuss triggers in a moment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择适当的任务类型选择了后台任务声明，这大致意味着触发器类型，稍后将在实际代码中使用。我们将在稍后讨论触发器。
- en: The **Entry point** field must be set to the full class name implementing the
    background task (`Tasks::SimpleTask` in this case).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**入口点**字段必须设置为实现后台任务的完整类名（在本例中为`Tasks::SimpleTask`）。'
- en: 'The result is an entry in the manifest XML in the `<extensions>` section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是清单XML中`<extensions>`部分的一个条目：
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The main application must do the actual task registration on startup and it
    must do so only once. Registering a task with an existing task name throws an
    exception.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序必须在启动时进行实际任务注册，并且只能执行一次。使用现有任务名称注册任务会引发异常。
- en: 'Registration involves the `BackgroundTaskBuilder` class and a trigger class
    with optional conditions. Here''s a piece of code registering the `SimpleTask`
    defined in the preceding code snippet to execute whenever an Internet connection
    is available:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注册涉及`BackgroundTaskBuilder`类和一个带有可选条件的触发器类。这是注册在上述代码片段中定义的`SimpleTask`以在Internet连接可用时执行的一段代码：
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A trigger must be selected for a task; in this case, it's the generic `SystemTrigger`,
    based on a `SystemTriggerType` enumeration, which has values such as `InternetAvailable`,
    `UserPresent`, `UserAway`, `SmsReceived`, `TimeZoneChange`, and more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 必须为任务选择一个触发器；在本例中，它是通用的`SystemTrigger`，基于`SystemTriggerType`枚举，其值包括`InternetAvailable`、`UserPresent`、`UserAway`、`SmsReceived`、`TimeZoneChange`等。
- en: Conditions are optional; `SystemCondition` is currently the only one available,
    but it's generic as well, using the `SystemConditionType` enumeration. Values
    include `InternetAvailable`, `InternetUnavailable`, `UserPresent`, `UserNotPresent`,
    and others.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是可选的；`SystemCondition`目前是唯一可用的条件，但它也是通用的，使用`SystemConditionType`枚举。值包括`InternetAvailable`、`InternetUnavailable`、`UserPresent`、`UserNotPresent`等。
- en: '`BackgroundTaskBuilder` holds the trigger and condition information, along
    with the task name and entry point. Then a call to `Register` does the actual
    registration with the system (returning a `BackgroundTaskRegistration` object).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundTaskBuilder`保存了触发器和条件信息，以及任务名称和入口点。然后调用`Register`实际上向系统注册（返回一个`BackgroundTaskRegistration`对象）。'
- en: Implementing a task
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现任务
- en: Let's use an application that allows the user to enter data, and that data is
    saved in the local folder. If the user is connected to the Internet, a background
    task should do some processing on the resulting files, such as uploading them
    to a server, doing some calculations, and so on. Eventually, the task will delete
    the files after being processed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个允许用户输入数据并将数据保存在本地文件夹中的应用程序。如果用户连接到互联网，后台任务应该对生成的文件进行一些处理，例如将它们上传到服务器，进行一些计算等。最终，任务将在处理后删除文件。
- en: 'Here''s some simple code that the main app uses to save some data to files:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是主应用程序用于将一些数据保存到文件的简单代码：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The files are saved to a subfolder named `Movies` under the `LocalFolder`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存在`LocalFolder`下名为`Movies`的子文件夹中。
- en: 'Tasks share the application''s local folder, effectively making it a communication
    mechanism. Here''s the task''s `Run` method implementation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 任务共享应用程序的本地文件夹，有效地使其成为一种通信机制。这是任务的`Run`方法实现：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The task begins by obtaining the `LocalFolder` location. Before the actual process
    begins, it obtains a *deferral* object by calling `IBackgroundTaskInstance::GetDeferral`.
    Why?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 任务首先获取`LocalFolder`位置。在实际处理开始之前，它通过调用`IBackgroundTaskInstance::GetDeferral`获取了一个*延期*对象。为什么？
- en: A task is normally considered done when the `Run` method terminates. If, however,
    the implementation invokes any asynchronous operations, the method will return
    to its caller sooner, making the task complete. Obtaining a deferral effectively
    holds off task completion until that time when a call to `BackgroundTaskDeferral::Complete`
    is made.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Run`方法终止时，任务通常被视为已完成。但是，如果实现调用任何异步操作，则该方法会更早地返回给其调用者，使任务完成。获得延期实际上会推迟任务完成，直到调用`BackgroundTaskDeferral::Complete`时。
- en: Next, comes the actual file processing. All the files in the `Movies` folder
    are enumerated using `StorageFolder::GetFilesAsync` and after each dummy processing,
    the file is deleted. Only then the entire task is done, and the deferral's `Complete`
    method can be invoked to indicate that the task is complete.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实际的文件处理。使用`StorageFolder::GetFilesAsync`枚举`Movies`文件夹中的所有文件，并在每次虚拟处理后删除文件。只有在整个任务完成后，才能调用延迟的`Complete`方法来指示任务已完成。
- en: Task debugging
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务调试
- en: The available triggers and conditions are not easily satisfied in a development
    environment. We don't want to disconnect and reconnect the Internet; nor do we
    want to wait 15 minutes until a task with a `TimeTrigger` is executed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中，可用的触发器和条件并不容易满足。我们不想断开并重新连接互联网；也不想等待15分钟直到`TimeTrigger`的任务被执行。
- en: 'Visual Studio provides a way to invoke a task at any point for debugging purposes.
    This functionality is located in the same toolbar button as suspension and resumption:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio提供了一种在任何时候调用任务以进行调试的方法。这个功能位于与暂停和恢复相同的工具栏按钮中：
- en: '![Task debugging](img/5022_07_14.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![任务调试](img/5022_07_14.jpg)'
- en: If we place a breakpoint within the task's `Run` method, we can debug the task
    as usual. The `BackgroundTaskHost.exe` is the process instance that is hosting
    the application's tasks. This fact can be viewed in the debugger **Process** toolbar
    button or in Windows Task Manager.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在任务的`Run`方法中设置断点，我们可以像平常一样调试任务。`BackgroundTaskHost.exe`是托管应用程序任务的进程实例。这个事实可以在调试器的**进程**工具栏按钮或Windows任务管理器中查看。
- en: Task progress and cancellation
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务进度和取消
- en: A background task can run when the main app is running as well. One thing that's
    possible to do is indicate its progress from the background task's perspective.
    This is done using the `IBackgroundTaskInstance::Progress` property. If the main
    app is not running, nobody cares. If it is running, it can register for the `Progress`
    event (part of `IBackgroundTaskRegistration` that's returned upon successful registration
    of the task) and update the UI based on that progress.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 后台任务可以在主应用程序运行时运行。其中一件可能做的事情是从后台任务的角度指示其进度。这是使用`IBackgroundTaskInstance::Progress`属性完成的。如果主应用程序没有运行，没有人在乎。如果它正在运行，它可以注册`Progress`事件（作为成功注册任务时返回的`IBackgroundTaskRegistration`的一部分）并根据进度更新UI。
- en: When the task finishes, the `IBackgoundTaskRegistration::Completed` event fires
    so that the main app knows the task is done. If the main app is currently suspended,
    it will be notified when it resumes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务完成时，`IBackgoundTaskRegistration::Completed`事件触发，以便主应用程序知道任务已完成。如果主应用程序当前被挂起，它将在恢复时收到通知。
- en: In some situations, Windows may cancel a running task. The `IBackgroundTaskInstance`
    exposes a `Canceled` event that a task can register for. If the task is cancelled,
    it must return within 5 seconds, or it will be terminated. The `Canceled` event
    provides a `BackgroundTaskCancellationReason` that specifies why the task was
    cancelled. Examples include `ServiceUpdate` (the main app is being updated) and
    `LoggingOff` (the user is logging off the system).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Windows可能会取消正在运行的任务。`IBackgroundTaskInstance`公开了一个`Canceled`事件，任务可以注册。如果任务被取消，必须在5秒内返回，否则将被终止。`Canceled`事件提供了一个指定任务被取消原因的`BackgroundTaskCancellationReason`。示例包括`ServiceUpdate`（主应用正在更新）和`LoggingOff`（用户正在注销系统）。
- en: 'For example, we can use a Win32 event to notify our task that cancellation
    has been requested. First, we create the event object and register for the `Canceled`
    event:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用Win32事件通知我们的任务已经被请求取消。首先，我们创建事件对象并注册`Canceled`事件：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`_hCancelEvent` is a `HANDLE` type, created with `CreateEventEx`. Then the
    `Canceled` event is associated with a private `OnCancelled` method.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`_hCancelEvent`是一个`HANDLE`类型，使用`CreateEventEx`创建。然后`Canceled`事件与一个私有的`OnCancelled`方法相关联。'
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The classic Win32 API `CreateEvent` can't be used, as it's illegal in WinRT.
    `CreateEventEx` was introduced in Windows Vista, and can be considered as a superset
    of `CreateEvent`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的Win32 API `CreateEvent`不能使用，因为在WinRT中是非法的。`CreateEventEx`是在Windows Vista中引入的，并且可以被视为`CreateEvent`的超集。
- en: 'If the task is being cancelled, we set the Win32 event:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务被取消，我们设置Win32事件：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The task main processing code should examine the Win32 event and bail out as
    quickly as possible, if it''s signaled:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的主要处理代码应该尽快检查Win32事件并退出：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Calling `WaitForSingleObject` with a zero timeout just examines the state of
    the event. If it's signaled, the return value is `WAIT_OBJECT_0` (otherwise, the
    return value is `WAIT_TIMEOUT`).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用零超时调用`WaitForSingleObject`只是检查事件的状态。如果它被标记，返回值是`WAIT_OBJECT_0`（否则，返回值是`WAIT_TIMEOUT`）。
- en: Playing background audio
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放后台音频
- en: Some applications play audio, and users expect the audio to keep playing even
    if the user switches to another app; for example, a music playing app is expected
    to continue playing until told to stop by the user. A voice over IP app (such
    as Skype) is expected to maintain the other party's audio even if the user switches
    to another app. This is where the background audio task comes in.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序播放音频，用户期望即使用户切换到另一个应用程序，音频也能继续播放；例如，音乐播放应用程序应该一直播放，直到用户要求停止。语音通话应用程序（如Skype）应该在用户切换到另一个应用程序时保持对方的音频。这就是后台音频任务的用武之地。
- en: Playing audio
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放音频
- en: Audio playing can be easily achieved by using the `MediaElement` control (which
    can also play video). It should be placed somewhere in XAML so that it's part
    of a visual tree, although it has no visible parts when playing audio.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`MediaElement`控件（也可以播放视频），可以轻松实现音频播放。它应该放置在XAML的某个位置，以便它成为可视树的一部分，尽管在播放音频时它没有可见部分。
- en: Actual playing is done by setting a URI to play using the `Source` property
    (or for files obtained from a `FileOpenPicker` by calling the `SetSource` method).
    Playing starts immediately unless the `AutoPlay` property is set to `false`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置要使用`Source`属性播放的URI（或通过调用`SetSource`方法从`FileOpenPicker`获取的文件），可以实现实际的播放。除非将`AutoPlay`属性设置为`false`，否则播放会立即开始。
- en: 'Controlling playback is done with the `Play`, `Pause`, and `Stop` methods of
    `MediaElement`. Here''s an example of an audio file obtained from a `FileOpenPicker`.
    First, some basic UI for the `MediaElement` and playback control:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 控制播放是通过`MediaElement`的`Play`、`Pause`和`Stop`方法完成的。以下是从`FileOpenPicker`获取的音频文件的示例。首先是`MediaElement`和播放控制的基本UI：
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `OnSelectedMediaFile` is implemented as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSelectedMediaFile`的实现如下：'
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Most of the code should be familiar by now. The filter of `FileOpenPicker` is
    set for MP3 files, and once selected, the call to `MediaElement::SetSource` readies
    the audio stream for playback.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大部分代码应该是熟悉的。`FileOpenPicker`的过滤器设置为MP3文件，一旦选择，调用`MediaElement::SetSource`准备好音频流进行播放。
- en: 'Playing the stream is just a matter of calling `MediaElement::Play` at the
    `Play` button''s `Click` handler:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 播放流只是调用`MediaElement::Play`在`Play`按钮的`Click`处理程序中的问题：
- en: '[PRE31]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`OnPause` and `OnStop` are similarly implemented by calling `MediaElement::Pause`
    and `MediaElement::Stop` respectively.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`MediaElement::Pause`和`MediaElement::Stop`来实现`OnPause`和`OnStop`。
- en: Running the application now allows for selecting an MP3 file and playing it.
    Switching to another app, however, immediately stops playback.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序可以选择一个MP3文件并播放它。然而，切换到另一个应用程序会立即停止播放。
- en: Maintaining background audio
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护背景音频
- en: Making the application continue to play automatically in the background requires
    several steps.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序在后台继续自动播放需要几个步骤。
- en: 'First, the app manifest must be modified to indicate background audio is needed;
    this is done by adding a **Background Task** declaration and setting the **Audio**
    checkbox:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须修改应用程序清单以指示需要背景音频；这是通过添加**后台任务**声明并设置**音频**复选框来完成的：
- en: '![Maintaining background audio](img/5022_07_20.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![维护背景音频](img/5022_07_20.jpg)'
- en: 'The other required step is setting the **Start** page, as shown in the preceding
    screenshot. The next steps require adding some code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必需的步骤是设置**开始**页面，如前面的屏幕截图所示。下一步需要添加一些代码：
- en: The `MediaElement::AudioCategory` property must be set to `AudioCategory::BackgroundCapableMedia`
    (for general background playback) or `AudioCategory::Communications` (for peer
    to peer communications, such as a chat).
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaElement::AudioCategory`属性必须设置为`AudioCategory::BackgroundCapableMedia`（用于一般背景播放）或`AudioCategory::Communications`（用于点对点通信，如聊天）。'
- en: Register for static events of the `Windows::Media::MediaControl` class that
    indicate changes that may result from other applications using audio playback.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册`Windows::Media::MediaControl`类的静态事件，指示可能由其他应用程序使用音频播放而导致的更改。
- en: 'First, we''ll change the `AudioCategory` property of the `MediaElement`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更改`MediaElement`的`AudioCategory`属性：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result of this setting makes the app never enter suspension.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置的结果使应用程序永远不会进入暂停状态。
- en: 'Next, we''ll register for the required events:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将注册所需的事件：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These events are fired by the system when the playback state changes due to
    a system-provided media control that is accessible with some keyboards and perhaps
    other gestures:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件是由系统触发的，当播放状态由于系统提供的媒体控制而发生变化时，可以通过某些键盘和其他手势访问：
- en: '![Maintaining background audio](img/5022_07_21.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![维护背景音频](img/5022_07_21.jpg)'
- en: 'Reacting to these events is not difficult. Here''s the code for the `PlayPressed`
    and `PlayPauseTogglePressed` events:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些事件的反应并不困难。以下是`PlayPressed`和`PlayPauseTogglePressed`事件的代码：
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The notifications are handled as commands for the app to play or pause playback
    as needed; correct implementation ensures consistent behavior across all audio
    playbacks on the system.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通知被处理为应用程序播放或暂停播放所需的命令；正确的实现确保系统上所有音频播放的一致行为。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the events arrive on a thread pool thread, and since the `MediaElement`
    needs to be touched, the call must be marshalled to the UI thread using the `CoreDispatcher::RunAsync`
    method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，事件在线程池线程上到达，由于需要触摸`MediaElement`，因此调用必须使用`CoreDispatcher::RunAsync`方法调度到UI线程。
- en: Handling the `PausePressed` and `StopPressed` events is similar.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`PausePressed`和`StopPressed`事件是类似的。
- en: Other events from the `MediaControl` class can be handled if appropriate, such
    as `NextTrackPressed` and `PreviousTrackPressed` .
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适当的话，`MediaControl`类的其他事件也可以被处理，例如`NextTrackPressed`和`PreviousTrackPressed`。
- en: Sound-level notifications
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音级别通知
- en: 'If a background app is playing audio and another foreground app starts playing
    audio, the system sends a `MediaControl::SoundLevelChanged` event to the background
    app. This event indicates what happened to the background app''s sound by looking
    at the `MediaControl::SoundLevel` property. Possible values are:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后台应用程序正在播放音频，另一个前台应用程序开始播放音频，系统会向后台应用程序发送`MediaControl::SoundLevelChanged`事件。此事件通过查看`MediaControl::SoundLevel`属性指示了后台应用程序的声音发生了什么。可能的值有：
- en: '`Muted`: The app''s sound has been muted, so the app should pause its playback.
    This usually means a foreground app is playing audio.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Muted`：应用程序的声音已被静音，因此应用程序应该暂停其播放。这通常意味着前台应用程序正在播放音频。'
- en: '`Low`: The app''s sound level has gone low. This indicates a VoIP call came
    in, decreasing the app''s sound level. The app may want to pause playback until
    another `SoundLevelChanged` event fires that indicates full volume.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Low`：应用程序的声音级别已经降低。这表明VoIP呼叫进来，降低了应用程序的声音级别。应用程序可能希望暂停播放，直到另一个`SoundLevelChanged`事件触发，指示完全音量。'
- en: '`Full`: The app''s sound is at full volume. If the app was playing audio and
    had to pause it, now it''s time to resume playing.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Full`：应用程序的声音是最大音量。如果应用程序正在播放音频并且必须暂停它，现在是恢复播放的时候了。'
- en: Registering for this event is optional, but can enhance the user experience
    and it indicates a well-behaving app.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注册参加此活动是可选的，但可以增强用户体验，并且表明应用程序行为良好。
- en: Lock screen apps
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁屏应用程序
- en: 'The lock screen (before a user logs in, or when the device is locked) allows
    for up to seven applications to be on it—these can have an icon (and even a text
    message); these apps are known as lock screen apps. The seven possible apps can
    be configured via control panel | **PC Settings** | **Personalize**:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 锁屏（在用户登录之前或设备被锁定时）最多可以容纳七个应用程序 - 这些应用程序可以有一个图标（甚至一个文本消息）；这些应用程序被称为锁屏应用程序。可以通过控制面板|**PC设置**|**个性化**来配置七个可能的应用程序：
- en: '![Lock screen apps](img/5022_07_15.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![锁屏应用](img/5022_07_15.jpg)'
- en: 'Lock screen apps are considered more important by the system (because they
    are more important to the user), and consequently have some capabilities that
    cannot be obtained by non-lock screen apps. For example, some trigger types only
    work with lock screen apps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 系统认为锁屏应用程序更重要（因为它们对用户更重要），因此具有一些非锁屏应用程序无法获得的功能。例如，某些触发器类型只适用于锁屏应用程序：
- en: '`TimeTrigger` can be used to do periodic work (minimum is 15 minutes).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeTrigger`可用于定期执行任务（最短间隔为15分钟）。'
- en: '`PushNotificationTrigger` can be used to get a raw push notification that causes
    the task to execute (raw means any string, unrelated to tile, toast, or badge).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PushNotificationTrigger`可用于接收导致任务执行的原始推送通知（原始意味着任何字符串，与磁贴、弹出通知或徽章无关）。'
- en: '`ControlChannelTrigger` can be used to keep a live connection to a remote server,
    even when the application is suspended; useful for Instant Messaging or video
    chat applications.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlChannelTrigger`可用于与远程服务器保持实时连接，即使应用程序被挂起；对即时通讯或视频聊天应用程序很有用。'
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This last two trigger types make the task actually run inside the app process
    and not in the standard task hosting process.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两种触发器类型使任务实际上在应用程序进程中运行，而不是在标准任务托管进程中运行。
- en: There is actually another time-related trigger, `MaintenanceTrigger`. This one
    does not require a lock screen app, but it only functions if the device is connected
    to AC power. If it's disconnected, the task will not run. If it's disconnected
    while the task executes, the task will be cancelled.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上还有另一个与时间相关的触发器，`MaintenanceTrigger`。这个不需要锁屏应用程序，但只有在设备连接到交流电源时才起作用。如果断开连接，任务将不会运行。如果在任务执行时断开连接，任务将被取消。
- en: 'To make an application lock screen capable, a few things need to be set up:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序具有锁屏功能，需要设置一些事项：
- en: A wide logo must be set for the app.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须为应用程序设置一个宽标志。
- en: A badge logo must be set up as well; this is the default image that appears
    on the lock screen for the app.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 徽章标志也必须设置好；这是在应用程序的锁屏上显示的默认图像。
- en: At least one background task must be declared (using the manifest's **Declarations**
    tab in Visual Studio) that uses a push notification trigger, a time trigger or
    a control channel trigger.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须声明至少一个后台任务（使用Visual Studio中的清单**声明**选项卡），该任务使用推送通知触发器、时间触发器或控制通道触发器。
- en: The **Lock screen notifications** option must be set to **Badge** or **Badge
    with Tile Text**:![Lock screen apps](img/5022_07_17.jpg)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁屏通知**选项必须设置为**徽章**或**带有磁贴文本的徽章**：![锁屏应用](img/5022_07_17.jpg)'
- en: Requesting to set a lock screen app
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求设置锁屏应用
- en: Although the user can go to the app's settings and set it as a locked screen
    app, or go to the Windows personalization section and do the same. It's easier
    if the app asks the user (via a system-provided dialog), if it's ok for the app
    to become a lock screen app. This is accomplished with the `BackgroundExecutionManager::RequestAccessAsync`
    static method call. The result of the asynchronous call specifies whether the
    user accepted the suggestion or not (`BackgroundAccessStatus` enumeration).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户可以转到应用程序的设置并将其设置为锁定屏幕应用程序，或者转到Windows个性化部分并执行相同操作。如果应用程序通过系统提供的对话框询问用户是否可以成为锁屏应用程序，这样更容易。这是通过`BackgroundExecutionManager::RequestAccessAsync`静态方法调用来实现的。异步调用的结果指定用户是否接受了建议（`BackgroundAccessStatus`枚举）。
- en: Note
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the user denies, the dialog won't pop up when the application is run again;
    it will pop up again if the app is reinstalled.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户拒绝，当应用程序再次运行时对话框不会弹出；如果重新安装应用程序，它将再次弹出。
- en: Other common operations for lock screen apps
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁屏应用的其他常见操作
- en: 'Lock screen apps typically perform the following operations during the app''s
    lifetime:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 锁屏应用程序通常在应用程序的生命周期内执行以下操作：
- en: Sending badge updates (shown on the lock screen)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送徽章更新（显示在锁屏上）
- en: Sending tile updates
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送磁贴更新
- en: Receiving and processing raw push notifications that are used to execute app-specific
    logic
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收和处理用于执行特定应用程序逻辑的原始推送通知
- en: Raising a toast notification (that's shown even on the lock screen)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹出通知（即使在锁屏上也显示）
- en: The exact details of these operations are beyond the scope of this book (although
    the badge, tile, and toast update mechanisms are similar to those already discussed);
    more details can be found in the MSDN documentation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的确切细节超出了本书的范围（尽管徽章、磁贴和弹出通知的更新机制与已经讨论过的类似）；更多细节可以在MSDN文档中找到。
- en: Background tasks limits
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后台任务限制
- en: 'When executing, background tasks compete for CPU and network resources with
    the currently running foreground application, so they cannot run for an arbitrary
    length of time; the foreground app is the most important. Tasks are subject to
    the following constraints:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，后台任务与当前运行的前台应用程序竞争CPU和网络资源，因此它们不能以任意长度的时间运行；前台应用程序是最重要的。任务受以下约束条件的约束：
- en: Lock screen app tasks get 2 seconds of CPU time every 15 minutes (actual running
    time, not wall clock time).
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁屏应用程序每15分钟获得2秒的CPU时间（实际运行时间，而不是挂钟时间）。
- en: Non-lock screen apps receive 1 second of CPU time every 2 hours (again, actual
    running time).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非锁屏应用程序每2小时接收1秒的CPU时间（实际运行时间）。
- en: Network resources are unlimited when the device is running on AC power. Otherwise,
    some limitations may be in place depending on energy consumption.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设备运行在交流电源上时，网络资源是无限的。否则，根据能源消耗可能会有一些限制。
- en: Tasks configured with `ChannelControlTrigger` or `PushNotificationTrigger` receive
    some resource guarantees, as they are deemed more important.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ChannelControlTrigger`或`PushNotificationTrigger`配置的任务会收到一些资源保证，因为它们被认为更重要。
- en: Additionally, there is a global pool of CPU and network resources that can be
    used by any application. This pool is refilled every 15 minutes. This means that
    even if a task needs more than 1 second to run (non-lock screen app), it may get
    the extra CPU time, provided the pool is not exhausted. Naturally, the task can't
    rely on this pool, as other tasks may have already exhausted it.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有一个全局的CPU和网络资源池，可以被任何应用程序使用。这个池每15分钟重新填充一次。这意味着即使一个任务需要超过1秒的时间来运行（非锁屏应用程序），它也可能获得额外的CPU时间，前提是池没有耗尽。当然，任务不能依赖这个池，因为其他任务可能已经耗尽了它。
- en: Background transfers
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台传输
- en: It should be clear at this point that a suspended application can't do anything
    by itself, unless it has some background tasks working on its behalf. One of the
    operations that an app may need to perform is a lengthy download or upload of
    files. If the app becomes suspended, the download or upload operations cannot
    proceed. If the app is terminated, whatever was already downloaded goes away.
    Clearly, there must be a better way.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上应该很清楚，一个挂起的应用程序本身无法做任何事情，除非它有一些代表它工作的后台任务。应用程序可能需要执行的操作之一是下载或上传文件。如果应用程序被挂起，下载或上传操作无法继续。如果应用程序被终止，已经下载的内容会消失。显然，必须有更好的方法。
- en: WinRT provides a way to do background transfers (downloads and uploads) even
    if the app is suspended, by using a separate process to do the actual transfers
    (`BackgroundTransferHost.exe`). This capability allows the app to make a lengthy
    transfer without requiring the user to stay with the app for the entire transfer
    time.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT提供了一种进行后台传输（下载和上传）的方法，即使应用程序被挂起，也可以使用一个单独的进程来执行实际的传输（`BackgroundTransferHost.exe`）。这种能力允许应用程序进行长时间的传输，而不需要用户在整个传输时间内一直待在应用程序中。
- en: Example – downloading a file
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 下载文件
- en: 'Here''s a simple example that starts a download operation targeted to a file
    in the user''s documents location (error handling omitted):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，它启动了一个针对用户文档位置中的文件的下载操作（省略了错误处理）：
- en: '[PRE35]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The code assumes `_url` is a `TextBox` where the user entered a URL for a file
    that he/she wants to download. First, the filename is created based on the end
    phrase of the URL after the last slash. Then, the file is created in the documents
    folder of the user. Note that to get this capability, it must be declared in the
    manifest, and for the documents library, at least one file extension must be selected:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设`_url`是一个`TextBox`，用户在其中输入了要下载的文件的URL。首先，根据URL的最后一个斜杠后的短语创建文件名。然后，在用户的文档文件夹中创建文件。请注意，要获得这个功能，必须在清单中声明，并且对于文档库，至少必须选择一个文件扩展名：
- en: '![Example – downloading a file](img/5022_07_18.jpg)![Example – downloading
    a file](img/5022_07_19.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![示例 - 下载文件](img/5022_07_18.jpg)![示例 - 下载文件](img/5022_07_19.jpg)'
- en: Note
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the `Video`, `Music`, and `Pictures` libraries, declaring file associations
    is not needed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Video`、`Music`和`Pictures`库，不需要声明文件关联。
- en: Next, a `BackgroundDownloader` instance is created, and a call to its `CreateDownload`
    is made, passing the URL to download and the target file. This call returns a
    `DownloadOperation` object, without the download actually being started. To start
    the download, `DownloadOperation::StartAsync` is called.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`BackgroundDownloader`实例，并调用其`CreateDownload`方法，传递要下载的URL和目标文件。这个调用返回一个`DownloadOperation`对象，而不会实际开始下载。要开始下载，调用`DownloadOperation::StartAsync`。
- en: 'While the download is away, it''s useful to know how it progresses. Here''s
    a revised code that sets up progress reporting (the difference is from the `StartAsync`
    call):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载进行时，了解其进度是很有用的。以下是一个修改后的代码，用于设置进度报告（与`StartAsync`调用的区别在于）：
- en: '[PRE36]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, we''re actually looking at the result of `StartAsync`, returning
    an object implementing `IAsyncOperationWithProgress<DownloadOperation, DownloadOperation>`
    and we set up the `Progress` property with an appropriate delegate:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实际上是在查看`StartAsync`的结果，它返回一个实现`IAsyncOperationWithProgress<DownloadOperation,
    DownloadOperation>`的对象，并且我们使用适当的委托设置了`Progress`属性：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `DownloadOperation::Progress` property returns a simple structure (`BackgroundDownloadProgress`)
    with fields such as `TotalBytesToReceive`, `BytesReceived`, and `Status` (`Running`,
    `Completed`, `Cancelled`, and so on). The preceding code uses these values for
    a `ProgressBar` control (`_progress`) and `TextBlock` (`_status`).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadOperation::Progress`属性返回一个简单的结构（`BackgroundDownloadProgress`），其中包括`TotalBytesToReceive`、`BytesReceived`和`Status`（`Running`、`Completed`、`Cancelled`等）。前面的代码使用这些值来控制`ProgressBar`控件（`_progress`）和`TextBlock`（`_status`）。'
- en: Note that the notification is not arriving on the UI thread, so any updates
    to the UI must be marshalled to the UI thread by using the `Page::Dispatcher`
    property (of the type `Windows::UI::Core::CoreDispatcher`) with a call to `RunAsync`
    that accepts a delegate that is guaranteed to execute on the UI thread.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通知不会到达UI线程，因此对UI的任何更新都必须通过使用`Page::Dispatcher`属性（类型为`Windows::UI::Core::CoreDispatcher`）将其调度到UI线程，方法是使用接受在UI线程上执行的委托的`RunAsync`调用。
- en: If the app is terminated, the transfer stops as well, but the data downloaded
    so far is not lost. When the app is started again, its job is to look up all its
    incomplete transfers and resume them. This can be done by calling the static `BackgroundDownloader::GetCurrentDownloadsAsync`,
    getting back a list of those incomplete downloads, and then attaching to each
    one (for example, progress report) and, of course, resuming the downloads.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序被终止，传输也会停止，但到目前为止下载的数据不会丢失。当应用程序再次启动时，它的工作是查找所有未完成的传输并恢复它们。这可以通过调用静态的`BackgroundDownloader::GetCurrentDownloadsAsync`来实现，获取一个未完成下载的列表，然后附加到每一个（例如，进度报告），当然，恢复下载。
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a complete example of this in the Background Transfer sample available
    at [http://code.msdn.microsoft.com/windowsapps/Background-Transfer-Sample-d7833f61](http://code.msdn.microsoft.com/windowsapps/Background-Transfer-Sample-d7833f61).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://code.msdn.microsoft.com/windowsapps/Background-Transfer-Sample-d7833f61](http://code.msdn.microsoft.com/windowsapps/Background-Transfer-Sample-d7833f61)找到这方面的完整示例。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Windows Store applications are unlike desktop applications in many ways. This
    chapter dealt with the application lifecycle—the app may get suspended and even
    terminated, all controlled by the OS.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Windows商店应用程序在许多方面都不同于桌面应用程序。本章涉及应用程序的生命周期 - 应用程序可能会被暂停甚至终止，所有这些都由操作系统控制。
- en: Live tiles, badge updates, and toast notifications are some of the more unique
    features of Windows Store apps—desktop apps don't have these powers (although
    desktop apps can create their own toast-like pop ups). Used wisely, these can
    add a lot of traction to a Store app, luring the user into the app frequently.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 磁贴、徽章更新和弹出通知是Windows商店应用程序的一些更独特的功能，桌面应用程序没有这些功能（尽管桌面应用程序可以创建自己的类似弹出通知）。明智地使用这些功能，可以为商店应用程序增加很多吸引力，频繁地吸引用户进入应用程序。
- en: Background tasks provide a way around the involuntary suspension/termination
    scenarios, so that some control is maintained even when the app is not in the
    foreground. Still, this is pretty restricted, to keep the main app responsive
    and maintain good battery life. Tasks are an important ingredient in non-trivial
    apps, and so should be used wisely.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 后台任务提供了一种绕过非自愿暂停/终止情况的方法，以便即使应用程序不在前台时也能保持一定的控制。不过，这是相当受限制的，以保持主要应用程序的响应性和良好的电池寿命。任务是非常重要的非平凡应用程序的重要组成部分，因此应该明智地使用。
- en: In the next chapter, we'll take a look at ways a Windows Store app can better
    integrate with Windows and indirectly communicate with other applications by implementing
    contracts and extensions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Windows商店应用程序如何通过实现合同和扩展与Windows更好地集成，并间接地与其他应用程序进行通信。
