- en: Developing for Embedded Linux and Similar Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发嵌入式Linux和类似系统
- en: Small, SoC-based systems are everywhere these days, from smartphones, video
    game consoles, and smart television sets, to infotainment systems in cars and
    airplanes. Consumer devices relying on such systems are extremely common.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于SoC的小型系统随处可见，从智能手机、视频游戏机、智能电视机，到汽车和飞机上的信息娱乐系统。依赖这些系统的消费类设备非常普遍。
- en: In addition to consumer devices, they're also found as part of industrial and
    building-level controller systems, where they monitor equipment, respond to input,
    and execute scheduled tasks for whole networks of sensors and actuators. Compared
    to MCUs, SoCs are not as resource-limited, usually running a full **operating
    system** (**OS**) such as a Linux-derived OS, VxWorks, or QNX.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消费类设备，它们也作为工业和建筑级控制系统的一部分，用于监控设备、响应输入，并执行整个传感器和执行器网络的定时任务。与MCU相比，SoC的资源限制没有那么严格，通常运行完整的操作系统（OS），如基于Linux的操作系统、VxWorks或QNX。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to develop drivers for OS-based embedded systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为基于操作系统的嵌入式系统开发驱动程序
- en: Ways to integrate peripherals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成外围设备的方法
- en: How to handle and implement real-time performance requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理和实现实时性能要求
- en: Recognizing and dealing with resource limitations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和处理资源限制
- en: Embedded operating systems
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式操作系统
- en: An OS is typically used with an embedded system when you're writing your application
    directly for the system's hardware, which is an unrealistic proposal. What an
    OS provides to the application is a number of APIs that abstract away the hardware
    and functionality implemented using this hardware, such as network communications
    or video output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在为嵌入式系统编写应用程序时，通常会使用操作系统，这是一个不切实际的建议。操作系统为应用程序提供了许多抽象硬件的API，以及使用这些硬件实现的功能，如网络通信或视频输出。
- en: The trade-off here is between convenience and both code size and complexity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的权衡在于便利性和代码大小以及复杂性。
- en: Whereas a bare metal implementation ideally implements only those features it
    needs, an operating system comes with a task scheduler, along with functionality
    that the application being run may not ever need. For this reason, it's important
    to know when to use an OS instead of developing directly for the hardware, understanding
    the complications that come with either.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 而裸机实现理想上只实现它需要的功能，操作系统则带有任务调度器，以及应用程序可能永远不需要的功能。因此，重要的是要知道何时使用操作系统而不是直接为硬件开发，了解随之而来的复杂性。
- en: Good reasons to use an OS are if you have to be able to run different tasks
    simultaneously (multitasking, or multithreading). Implementing your own scheduler
    from scratch is generally not worth the effort. Having the need to run a non-fixed
    number of applications, and being able to remove and add them at will, is also
    made significantly easier by using an OS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用操作系统的好处在于，如果必须能够同时运行不同的任务（多任务或多线程）。从头开始实现自己的调度器通常不值得。通过使用操作系统，可以更轻松地运行非固定数量的应用程序，并且可以随意删除和添加它们。
- en: Finally, features such as advanced graphics output, graphics acceleration (such
    as OpenGL), touch screens, and advanced network functionality (for example, SSH
    and encryption) can be made much easier to implement when you have access to an
    OS and readily accessible drivers, and the APIs related to them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您可以访问操作系统和易于访问的驱动程序以及与其相关的API时，高级图形输出、图形加速（如OpenGL）、触摸屏和高级网络功能（例如SSH和加密）的实现会变得更加容易。
- en: 'Commonly used embedded operating systems include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的嵌入式操作系统包括以下内容：
- en: '| **Name** | **Vendor** | **License** | **Platforms** | **Details** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **供应商** | **许可证** | **平台** | **详情** |'
- en: '| Raspbian | Community-based | Mainly GPL, similar | ARM (Raspberry Pi) | Debian
    Linux-based OS |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Raspbian | 社区为基础 | 主要GPL，类似 | ARM（树莓派） | 基于Debian Linux的操作系统 |'
- en: '| Armbian | Community-based | GPLv2 | ARM (various boards) | Debian Linux-based
    OS |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Armbian | 社区为基础 | GPLv2 | ARM（各种开发板） | 基于Debian Linux的操作系统 |'
- en: '| Android | Google | GPLv2, Apache | ARM, x86, x86_64 | Linux-based |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Android | Google | GPLv2，Apache | ARM，x86，x86_64 | 基于Linux |'
- en: '| VxWorks | Wind River (Intel) | Proprietary | ARM, x86, MIPS, PowerPC, SH-4
    | RTOS, monolithic kernel |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| VxWorks | Wind River（英特尔） | 专有 | ARM，x86，MIPS，PowerPC，SH-4 | RTOS，单片内核 |'
- en: '| QNX | BlackBerry | Proprietary | ARMv7, ARMv8, x86 | RTOS, microkernel |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| QNX | BlackBerry | 专有 | ARMv7，ARMv8，x86 | RTOS，微内核 |'
- en: '| Windows IoT | Microsoft | Proprietary | ARM, x86 | Formerly known as Windows
    Embedded |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Windows IoT | 微软 | 专有 | ARM，x86 | 以前称为Windows嵌入式 |'
- en: '| NetBSD | NetBSD Foundation | 2-clause BSD | ARM, 68k, MIPS, PowerPC, SPARC,
    RISC-V, x86, and so on | Most portable BSD-based OS |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| NetBSD | NetBSD基金会 | 2条款BSD | ARM，68k，MIPS，PowerPC，SPARC，RISC-V，x86等 | 最具可移植性的基于BSD的操作系统
    |'
- en: What all of these OSes have in common is that they handle basic functionality
    such as memory and task management, while offering access to hardware and OS functionality
    using programming interfaces (APIs).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作系统的共同之处在于它们处理基本功能，如内存和任务管理，同时使用编程接口（API）提供对硬件和操作系统功能的访问。
- en: In this chapter, we will specifically focus on SoC and SBC-based systems, which
    reflects in the preceding list of operating systems. Each of these OSes is meant
    to be used on a system with at least a few megabytes of RAM and in the order of
    megabytes to gigabytes of storage.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专门关注基于SoC和SBC的系统，这反映在前述操作系统列表中。这些操作系统中的每一个都旨在用于至少具有几兆字节RAM和几兆字节到几千兆字节存储的系统。
- en: If the target SoC or SBC is not yet targeted by an existing Linux distribution,
    or one wishes to heavily customize the system, one can use the tools from the
    Yocto Project ([http://www.yoctoproject.org/](http://www.yoctoproject.org/)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标SoC或SBC尚未被现有的Linux发行版所针对，或者希望大量定制系统，可以使用Yocto Project的工具（[http://www.yoctoproject.org/](http://www.yoctoproject.org/)）。
- en: Linux-based embedded OSes are quite prevalent, with Android being a well-known
    example. It is mostly used on smartphones, tablets, and similar devices, which
    heavily rely on graphical user interaction, while relying on the Android application
    infrastructure and related APIs. Due to this level of specialization, it is not
    well-suited to other use cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Linux的嵌入式操作系统非常普遍，Android就是一个著名的例子。它主要用于智能手机、平板电脑和类似设备，这些设备严重依赖图形用户交互，同时依赖于Android应用程序基础设施和相关API。由于这种专业化水平，它不适合其他用例。
- en: Raspbian is based on the very common Debian Linux distribution, aimed at basically
    just the Raspberry Pi series of SBCs. Armbian is similar, but covers a far wider
    range of SBCs. Both of these are community efforts. This is similar to the Debian
    project, which can also be used directly for embedded systems. The main advantage
    of the Raspbian, Armbian, and other similar projects is that they provide ready-made
    images to be used with the target SBC.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Raspbian基于非常常见的Debian Linux发行版，主要针对树莓派系列的SBC。Armbian类似，但覆盖了更广泛的SBC范围。这两者都是社区努力的成果。这类似于Debian项目，也可以直接用于嵌入式系统。Raspbian、Armbian和其他类似项目的主要优势在于它们提供了与目标SBC一起使用的现成镜像。
- en: Like Linux-based OSes, NetBSD has the advantage of being open source, meaning
    that you have full access to the source code and can heavily customize any aspect
    of the operating system, including support for custom hardware. One big advantage
    NetBSD and similar BSD-based OSes have is that the OS is built from a single codebase,
    and managed by a single group of developers. This often simplifies the development
    and maintenance of an embedded project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于Linux的操作系统一样，NetBSD的优势在于它是开源的，这意味着您可以完全访问源代码，并且可以对操作系统的任何方面进行大量定制，包括对自定义硬件的支持。NetBSD和类似的基于BSD的操作系统的一个重大优势是，操作系统是从单一代码库构建的，并由一组开发人员管理。这通常简化了嵌入式项目的开发和维护。
- en: The BSD license (three- or two-clause) offers a major benefit for commercial
    projects, as this license only requires one to provide attribution instead of
    requiring the manufacturer to provide the full source code of the OS on request.
    This can be very relevant if one makes certain modifications to the source code,
    adding code modules that one wants to keep closed source.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BSD许可证（三或两条款）对商业项目有重大好处，因为该许可证只要求提供归属，而不要求制造商在请求时提供操作系统的全部源代码。如果对源代码进行某些修改，添加希望保持闭源的代码模块，这可能非常相关。
- en: Recent PlayStation gaming consoles, for example, use a modified version of FreeBSD,
    allowing Sony to heavily optimize the OS for the hardware and its use as a gaming
    console without having to release this code together with the rest of the OS's
    source code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最近的PlayStation游戏机使用了FreeBSD的修改版本，使得索尼能够对硬件和游戏机的使用进行大幅优化，而无需与操作系统的其余部分一起发布此代码。
- en: Proprietary options also exist, such as the offerings from BlackBerry (QNX)
    and Microsoft (Windows IoT, formerly Windows Embedded, formerly Windows CE). These
    tend to require a license fee per device and require the assistance of the manufacturer
    for any customization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在专有选项，例如来自黑莓（QNX）和微软（Windows IoT，以前是Windows嵌入式，以前是Windows CE）的产品。这些产品通常需要按设备收取许可费，并要求制造商提供任何定制的帮助。
- en: Real-time OSes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时操作系统
- en: The basic requirement for a real-time OS (RTOS) is that it can guarantee that
    tasks will be executed and finished within a certain time span. This allows one
    to use them for real-time applications where variability (jitter) between the
    execution times of a batch of the same task is not acceptable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实时操作系统（RTOS）的基本要求是能够保证任务在一定时间范围内被执行和完成。这使得可以将它们用于实时应用，其中同一任务批次的执行时间变化（抖动）是不可接受的。
- en: 'From this, we can draw the basic distinction between hard and soft real-time
    OSes: with low jitter, the OS is hard real-time, as it can guarantee that a given
    task will always be executed with practically the same delay. With higher jitter,
    the OS can usually but not always execute a task with the same delay.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们可以得出硬实时和软实时操作系统之间的基本区别：低抖动的操作系统是硬实时的，因为它可以保证给定任务总是以几乎相同的延迟执行。有更高抖动的操作系统通常但并非总是能以相同的延迟执行任务。
- en: Within these two categories, we can again distinguish between event-driven and
    time-sharing schedulers. The former switches tasks based on priority (priority
    scheduling), whereas the latter uses a timer to regularly switch tasks. Which
    design is better depends on what one uses the system for.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个类别中，我们可以再次区分事件驱动和时间共享调度器。前者根据优先级切换任务（优先级调度），而后者使用定时器定期切换任务。哪种设计更好取决于系统的使用目的。
- en: The main thing that time sharing has over event-driven schedulers is that since
    it gives far more CPU time to lower-priority tasks as well, it can make a multitasking
    system seem to run much smoother.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 时间共享比事件驱动的调度器更重要的一点是，它不仅给予了低优先级任务更多的CPU时间，还使多任务系统看起来更加流畅。
- en: Generally, one would only use an RTOS if your project requirements are such
    that one must be able to guarantee that inputs can be handled within a strictly
    defined time window. For applications such as robotics and industrial applications,
    it can be crucial that an action is performed in exactly the same time span every
    time, with failure to do so resulting in the disruption of a production line or
    an inferior product.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有在项目要求必须能够保证输入在严格定义的时间窗口内处理时，才会使用实时操作系统。对于机器人技术和工业应用等应用，确保每次都在完全相同的时间范围内执行动作可能至关重要，否则可能导致生产线中断或产品质量下降。
- en: With the example project that we will be looking at later in this chapter, we
    do not use an RTOS, but a regular Linux-based OS, as no hard timing requirements
    exist. Using an RTOS would impose an unneeded burden and likely increase complexity
    and costs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后将要讨论的示例项目中，我们不使用实时操作系统，而是使用常规基于Linux的操作系统，因为没有硬实时要求。使用实时操作系统将增加不必要的负担，可能增加复杂性和成本。
- en: One way to regard an RTOS is to get as close to the real-time nature of programming
    directly for the hardware (bare metal) without having to give up all of the conveniences
    of using a full-blown OS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将RTOS视为尽可能接近直接为硬件（裸机）编程的实时性质，而无需放弃使用完整OS的所有便利之一。
- en: Custom peripherals and drivers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义外围设备和驱动程序
- en: A peripheral is defined as an ancillary device that adds I/O or other functionality
    to a computer system. This can be anything from an I2C, SPI, or SD card controller
    to an audio or graphics device. Most of those are part of the physical SoC, with
    others added via interfaces that the SoC exposes to the outside world. Examples
    of external peripherals would be RAM (via the RAM controller) and a **real-time
    clock** (**RTC**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 外围设备被定义为向计算机系统添加I/O或其他功能的辅助设备。这可以是从I2C、SPI或SD卡控制器到音频或图形设备的任何东西。其中大多数是SoC的一部分，其他通过SoC向外部世界暴露的接口添加。外部外围设备的例子包括RAM（通过RAM控制器）和**实时时钟**（**RTC**）。
- en: One issue that one will likely encounter when using cheaper SBCs such as the
    Raspberry Pi, Orange Pi, and countless similar systems is that they usually lack
    an RTC, meaning that when they are powered off, they no longer keep track of the
    time. The thought behind this is usually that those boards will be connected to
    the internet anyway, so the OS can use an online time service (**Network Time
    Protocol**, or **NTP**) to synchronize the system time, thus saving board space.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用廉价的SBC时，例如树莓派、橙子派和无数类似系统时，可能会遇到的一个问题是它们通常缺乏RTC，这意味着当它们关闭电源时，它们不再跟踪时间。通常的想法是这些板子无论如何都会连接到互联网，因此OS可以使用在线时间服务（**网络时间协议**，或**NTP**）来同步系统时间，从而节省板子空间。
- en: One might end up using an SBC in a situation where no internet connection is
    available, or where the delay before online time synchronization is unacceptable,
    or any of a myriad of other reasons. In this case, one may want to add an RTC
    peripheral to the board and configure the OS to make use of it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有互联网连接的情况下，或者在线时间同步之前的延迟是不可接受的情况下，或者其他无数原因之一，可能会使用SBC。在这种情况下，可能需要向板上添加RTC外围设备并配置OS以利用它。
- en: Adding an RTC
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加RTC
- en: 'One can cheaply get RTCs as a ready-to-use module, often based around the DS1307
    chip. This is a 5V module, which connects to the SBC (or MCU) via the I2C bus:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以以低廉的价格获得RTC模块，通常基于DS1307芯片。这是一个5V模块，通过I2C总线连接到SBC（或MCU）：
- en: '![](img/5881b3bf-15ed-4189-ab38-619ca08aa8c8.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5881b3bf-15ed-4189-ab38-619ca08aa8c8.png)'
- en: This image is of a small DS1307-based RTC module. As one can see, it has the
    RTC chip, a crystal, and an MCU. The last of these is used to communicate with
    the host system, regardless of whether it is an SoC or MCU-based board. All that
    one requires is the ability to provide the desired voltage (and current) the RTC
    module operates on, along with an I2C bus.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片是一个基于DS1307的小型RTC模块。正如人们可以看到的，它有RTC芯片、晶体和MCU。最后一个用于与主机系统通信，无论它是SoC还是MCU-based
    board。所有人需要的是能够提供RTC模块操作所需的所需电压（和电流）的能力，以及一个I2C总线。
- en: After connecting the RTC module to the SBC board, the next goal is to have the
    OS also use it. For this, we must make sure that the I2C kernel module is loaded
    so that we can use I2C devices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将RTC模块连接到SBC板后，下一个目标是让OS也使用它。为此，我们必须确保加载I2C内核模块，以便我们可以使用I2C设备。
- en: Linux distributions for SBCs, such as Raspbian and Armbian, usually come with
    drivers for a number of RTC modules. This allows us to relatively quickly set
    up the RTC module and integrate it with the OS. With the module we looked at earlier,
    we require the I2C and DS1307 kernel modules. For a Raspbian OS on a first-generation
    Raspberry Pi SBC, these modules would be called `i2c-dev`, `2cbcm2708`, and `rtc-ds1307`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 针对SBC的Linux发行版，如Raspbian和Armbian，通常带有多个RTC模块的驱动程序。这使我们可以相对快速地设置RTC模块并将其与OS集成。对于我们之前看过的模块，我们需要I2C和DS1307内核模块。对于第一代树莓派SBC上的Raspbian
    OS，这些模块将被称为`i2c-dev`、`2cbcm2708`和`rtc-ds1307`。
- en: First, you have to enable these modules so that they are loaded when the system
    starts. For Raspbian Linux, one can edit the `/etc/modules` file to do so, as
    well as other configuration tools made available for this platform. After a reboot,
    we should be able to detect the RTC device on the I2C bus using an I2C scanner
    tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须启用这些模块，以便它们在系统启动时加载。对于Raspbian Linux，可以编辑`/etc/modules`文件来实现这一点，以及其他为该平台提供的配置工具。重新启动后，我们应该能够使用I2C扫描工具在I2C总线上检测RTC设备。
- en: With the RTC device working, we can remove the fake-hwclock package on Raspbian.
    This is a simple module that fakes an RTC, but merely stores the current time
    in a file before the system is shut down so that on the next boot the filesystem
    dates and similar will be consistent due to resuming from that stored date and
    time, without any new files one creates suddenly being *older* than the existing
    files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有了RTC设备工作，我们可以在Raspbian上删除fake-hwclock软件包。这是一个简单的模块，用于伪造RTC，但仅在系统关闭之前将当前时间存储在文件中，以便在下次启动时，由于从存储的日期和时间恢复，文件系统的日期和类似内容将保持一致，而不会创建任何新文件突然变得*更旧*。
- en: 'Instead, we''ll be using the hwclock utility, which will use any real RTC to
    synchronize the system time with. This requires one to modify the way the OS starts,
    with the location of the RTC module passed as boot parameters in the following
    form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用hwclock实用程序，它将使用任何真实的RTC来同步系统时间。这需要修改OS启动的方式，将RTC模块的位置作为引导参数传递，格式如下：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will initialize an RTC (`/dev/rtc0`) device on the I2C bus, with address
    0x68.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在I2C总线上初始化一个RTC（`/dev/rtc0`）设备，地址为0x68。
- en: Custom drivers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义驱动程序
- en: The exact format and integration of drivers (kernel modules) with the OS kernel
    differs for each OS and thus would be impossible to fully cover here. We will,
    however, look at how the driver for the RTC module we used earlier is implemented
    for Linux.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序（内核模块）的确切格式和集成与OS内核的方式因每个OS而异，因此在这里不可能完全涵盖。然而，我们将看一下我们之前使用的RTC模块的Linux驱动程序是如何实现的。
- en: In addition, we will look at how to use an I2C peripheral from user space later
    in this chapter, in the club room monitoring example. Using a user space-based
    driver (library) is often a good alternative to implementing it as a kernel module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在本章后面看看如何从用户空间使用I2C外设，在俱乐部房间监控示例中。使用基于用户空间的驱动程序（库）通常是将其实现为内核模块的良好替代方案。
- en: The RTC functionality is integrated into the Linux kernel, with the code for
    it found in the `/drivers/rtc` folder (on GitHub, at [https://github.com/torvalds/linux/tree/master/drivers/rtc](https://github.com/torvalds/linux/tree/master/drivers/rtc)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: RTC功能已集成到Linux内核中，其代码位于`/drivers/rtc`文件夹中（在GitHub上可以找到，网址为[https://github.com/torvalds/linux/tree/master/drivers/rtc](https://github.com/torvalds/linux/tree/master/drivers/rtc)）。
- en: 'The `rtc-ds1307.c` file contains two functions we need to read and set the
    RTC, respectively: `ds1307_get_time()` and `ds1307_set_time()`. The basic functionality
    of these functions is very similar to what we''ll be using in the club room monitoring
    example later in this chapter, where we simply integrate I2C device support into
    our application.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`rtc-ds1307.c`文件包含我们需要读取和设置RTC的两个函数：`ds1307_get_time()`和`ds1307_set_time()`。这些函数的基本功能与我们将在本章后面的俱乐部房间监控示例中使用的功能非常相似，我们只是将I2C设备支持集成到我们的应用程序中。'
- en: A major advantage of communicating with I2C, SPI, and other such peripherals
    from user space is that we are not limited by the compile environment supported
    by the OS kernel. Taking the Linux kernel as an example, it is written mostly
    in C with some assembly. Its APIs are C-style APIs and thus we would have to use
    a distinctly C-style coding approach to writing our kernel modules.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间与I2C、SPI和其他外设通信的一个主要优势是，我们不受OS内核支持的编译环境的限制。以Linux内核为例，它主要用C语言编写，还有一些汇编语言。其API是C风格的API，因此我们必须使用明显的C风格编码方法来编写我们的内核模块。
- en: Obviously, this would negate most of the advantages, not to mention the point,
    of attempting to write these modules in C++ to begin with. When moving our module
    code to user space and using it either as part of an application or as a shared
    library, we have no such limitations and can freely use any and all C++ concepts
    and functionality.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这将抵消大部分优势，更不用说尝试一开始就用C++编写这些模块的意义了。当将我们的模块代码移至用户空间并将其用作应用程序的一部分或共享库时，我们就没有这样的限制，可以自由使用任何和所有C++概念和功能。
- en: 'For completeness'' sake, the basic template for a Linux kernel module looks
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，Linux内核模块的基本模板如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the requisite Hello World example, written in C++-style.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个必需的Hello World示例，以C++风格编写。
- en: One final consideration when considering kernel- and user space-based driver
    modules is that of context switches. From an efficiency point of view, kernel
    modules are faster and have lower latency because the CPU does not have to switch
    from a user to kernel space context and back repeatedly to communicate with a
    device and pass messages from it back to the code communicating with it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑基于内核和用户空间的驱动程序模块时的最后一个考虑因素是上下文切换。从效率的角度来看，内核模块更快，延迟更低，因为CPU不必反复从用户空间切换到内核空间上下文，然后再次与设备通信，并将消息从设备传递回与其通信的代码。
- en: For high bandwidth devices (such as storage and capturing), this could make
    the difference between a smoothly functioning system and one that severely lags
    and struggles to perform its tasks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高带宽设备（如存储和捕获），这可能会导致系统顺畅运行与严重滞后和难以执行其任务之间的差异。
- en: However, when considering the club room monitoring example in this chapter and
    its occasional use of an I2C device, it should be obvious that a kernel module
    would be severe overkill without any tangible benefits.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在考虑本章中的俱乐部房间监控示例及其偶尔使用I2C设备时，很明显，内核模块将是严重过度的，没有任何实质性的好处。
- en: Resource limitations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源限制
- en: Even though SBCs and SoCs tend to be fairly powerful, they are still no direct
    comparison to a modern desktop system or server. They have distinct limits in
    terms of RAM, storage size, and lack of expansion options.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SBC和SoC往往非常强大，但它们仍无法与现代台式机系统或服务器进行直接比较。它们在RAM、存储大小和缺乏扩展选项方面有明显的限制。
- en: With wildly varying amounts of (permanently installed) RAM, you have to consider
    the memory needs of the applications one wishes to run on the system before even
    considering the relatively sluggish CPU performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（永久安装的）RAM容量差异很大的情况，您必须在考虑相对缓慢的CPU性能之前，考虑系统上希望运行的应用程序的内存需求。
- en: As SBCs tend to not have any, or significant amounts of, storage with a high
    endurance rate (meaning it can be written to often without limited write cycles
    to take into account), they generally do not have swap space and keep everything
    in the available RAM. Without the fallback of swap, any memory leaks and excessive
    memory usage will rapidly lead to a non-functioning or constantly restarting system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SBC通常没有或只有少量具有高耐久率的存储空间（意味着可以经常写入而不受限制的写入周期），它们通常不具有交换空间，并将所有内容保存在可用的RAM中。没有交换的支持，任何内存泄漏和过度内存使用将迅速导致系统无法正常工作或不断重启。
- en: Even though CPU performance on SBCs has increased significantly over the years
    for commonly available models, it is generally still advisable to use a cross-compiler
    to produce code for the SBC on a fast desktop system or server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来SBC的CPU性能已经显著提高，但通常仍建议使用交叉编译器在快速的台式机系统或服务器上为SBC生成代码。
- en: More on development issues and solutions will be covered in [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml),
    *Testing OS-Based Applications*, and [Appendix](ddead19d-4726-49ec-b780-34689efdd0b7.xhtml),
    *Best Practices*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于开发问题和解决方案的内容将在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml) *测试基于OS的应用程序*和[附录](ddead19d-4726-49ec-b780-34689efdd0b7.xhtml)
    *最佳实践*中进行讨论。
- en: Example – club room monitoring
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 俱乐部房间监控
- en: 'In this section, we will be looking at a practical implementation of an SBC-based
    solution that performs the following functionality for a club room:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到一个基于SBC的实际实现，为俱乐部房间执行以下功能：
- en: Monitors the status of the club door's lock
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控俱乐部门锁的状态
- en: Monitors the club status switch
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控俱乐部状态开关
- en: Sends status change notifications over MQTT
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过MQTT发送状态更改通知
- en: Provides a REST API for the current club status
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为当前俱乐部状态提供REST API
- en: Controls status lights
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制状态灯
- en: Controls the power in the club room
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制俱乐部房间的电源
- en: The basic use case here is that we have a club room for which we want to be
    able to monitor the status of its lock, and have a switch inside the club to regulate
    whether the non-permanent power outlets in the club are powered on or not. Turning
    the club status switch to *on* would provide power to those outlets. We also want
    to send out a notification over MQTT so that other devices in the club room or
    elsewhere can update their status.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本用例是，我们有一个俱乐部房间，我们希望能够监控其门锁的状态，并在俱乐部内部有一个开关来调节俱乐部非永久电源插座的通电状态。将俱乐部状态开关调至*on*将为这些插座供电。我们还希望通过MQTT发送通知，以便俱乐部房间或其他地方的其他设备可以更新它们的状态。
- en: 'MQTT is a simple, binary publish/subscribe protocol on top of TCP/IP. It offers
    a lightweight communication protocol, suitable for resource-restricted applications
    such as sensor networks. Each MQTT client communicates with a central server:
    the MQTT broker.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是基于TCP/IP的简单的二进制发布/订阅协议。它提供了一种轻量级的通信协议，适用于资源受限的应用程序，如传感器网络。每个MQTT客户端与中央服务器通信：MQTT代理。
- en: Hardware
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: 'The block diagram of the `clubstatus` system looks as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: “clubstatus”系统的框图如下所示：
- en: '![](img/bfb888d8-bf9f-4dab-9366-d473d1c7dd7f.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfb888d8-bf9f-4dab-9366-d473d1c7dd7f.png)'
- en: 'For the SBC platform, we use a Raspberry Pi, either the Raspberry Pi B+ model
    or a newer member of the B-series, such as the Raspberry Pi 3 Model B:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SBC平台，我们使用树莓派，要么是树莓派B+型号，要么是B系列的新成员，比如树莓派3型B：
- en: '![](img/97073e5a-4311-4381-bf99-025dc76193c3.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97073e5a-4311-4381-bf99-025dc76193c3.png)'
- en: The main features we are looking for in the SBC system are an Ethernet connection
    and, of course, the Raspberry Pi-compatible **general-purpose input/output** (**GPIO**)
    header.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在SBC系统中寻找的主要功能是以太网连接，当然还有与树莓派兼容的**通用输入/输出**（**GPIO**）引脚。
- en: With this board, we'll use a standard Raspbian OS installation on the μSD card.
    No special configuration is needed beyond this. The primary reason for choosing
    the B+ model or similar is that these have a standard mounting hole pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这块板子时，我们将在μSD卡上安装标准的Raspbian操作系统。除此之外不需要任何特殊配置。选择B+型号或类似型号的主要原因是它们具有标准的安装孔图案。
- en: Relays
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继电器
- en: 'To control the status lights and the non-permanent power outlets in the room,
    we use a number of relays, in this case four relays:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制房间中的状态灯和非永久电源插座，我们使用了一些继电器，这种情况下是四个继电器：
- en: '| **Relay** | **Function** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **继电器** | **功能** |'
- en: '| 0 | Power status of non-permanent outlets |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 非永久插座的电源状态 |'
- en: '| 1 | Green status light |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 绿色状态灯 |'
- en: '| 2 | Yellow status light |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 黄色状态灯 |'
- en: '| 3 | Red status light |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 红色状态灯 |'
- en: The idea here is that the power status relay is connected to a switch that controls
    the mains power to outlets that are not powered when the club status is off. The
    status lights indicate the current club status. The next section provides the
    details on the implementation of this concept.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，电源状态继电器连接到一个开关，控制着俱乐部状态关闭时未供电的插座的主电源。状态灯指示当前的俱乐部状态。接下来的部分将提供这个概念的实现细节。
- en: 'To simplify the design, we will use a ready-made relay board containing four
    relays, which are driven by an NXP PCAL9535A I/O port chip (GPIO expander) connected
    to the I2C bus of the Raspberry Pi SBC:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设计，我们将使用一个包含四个继电器的现成继电器板，由NXP PCAL9535A I/O端口芯片（GPIO扩展器）驱动，连接到树莓派SBC的I2C总线上：
- en: '![](img/5853c932-146d-46f6-abc9-8537243bc361.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5853c932-146d-46f6-abc9-8537243bc361.png)'
- en: 'This particular board is the Seeed Studio Raspberry Pi Relay Board v1.0: [http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/](http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/).
    It offers the four relays we require, allowing us to switch lights and switches
    up to 30 VDC (direct current) or 250 VAC (alternating current). This allows one
    to connect practically any type of lighting and further relays and kin.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这块特定的板子是Seeed Studio Raspberry Pi继电器板v1.0：[http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/](http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/)。它提供了我们需要的四个继电器，允许我们切换高达30V直流或250V交流的灯和开关。这使得我们可以连接几乎任何类型的照明和进一步的继电器和开关。
- en: The connection with the SBC is made by stacking the relay board on top of the
    SBC using its GPIO header, which allows us to add further boards on top of the
    relay board. This allows us to add the debounce functionality to the system, as
    indicated in the wiring plan diagram.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与SBC的连接是通过将继电器板叠放在SBC的GPIO引脚上实现的，这使我们可以在继电器板的顶部添加更多的板子。这使我们可以向系统添加去抖动功能，如接线计划图所示。
- en: Debounce
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去抖动
- en: 'The debounce board has the debouncing of switch signals as a requirement, as
    well as providing the Raspberry Pi board with power. The theory and reason behind
    the debouncing of mechanical switches is that the signal provided by those switches
    is not clean, meaning that they don''t immediately switch from open to closed.
    They will briefly close (make contact) before the springiness of the metal contacts
    causes them to open again and rapidly move between these two states, before finally
    settling into its final position, as we can see in the following diagram from
    an oscilloscope connected to a simple switch:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 去抖动板需要去抖动开关信号，并为树莓派提供电源。去抖动机械开关的理论和原因是，这些开关提供的信号不干净，意味着它们不会立即从开到闭。它们会在短暂地闭合（接触）之后，弹簧金属触点的弹性会导致它们再次打开，并在这两种状态之间快速移动，最终定格在最终位置，正如我们可以从连接到简单开关的示波器的下图中看到的：
- en: '![](img/279f998d-afcf-427d-aeae-3b6f2fcc04e6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/279f998d-afcf-427d-aeae-3b6f2fcc04e6.png)'
- en: The result of this property is that the signal that arrives at the SBC's GPIO
    pins will rapidly change for a number of milliseconds (or worse). Performing any
    kind of action based upon these switch input changes would therefore lead to immense
    problems, as one cannot easily distinguish between a desired switch change and
    the rapid bouncing of the switch contacts during this change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性的结果是，到达SBC的GPIO引脚的信号会在几毫秒内迅速变化（或更糟）。基于这些开关输入变化进行任何操作都会导致巨大问题，因为人们很难区分所需的开关变化和在这种变化过程中开关触点的快速跳动。
- en: It is possible to debounce a switch either in hardware or software. The latter
    solution involves the starting of a timer when the state of the switch first changes.
    The assumption behind this is that after a certain time (in milliseconds) has
    expired, the switch is in a stable state and can be safely read out. This approach
    has disadvantages in that it puts an extra burden on the system by taking up one
    or more timers, or pausing the program's execution. Also, using interrupts on
    the input for the switch requires one to disable interrupts while the timer is
    running, adding further complexity to the code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 消除抖动可以通过硬件或软件来实现。后者的解决方案涉及在开关状态首次改变时启动计时器。这种方法的假设是，在一定时间（以毫秒为单位）过去后，开关处于稳定状态，可以安全地读取。这种方法的缺点在于它给系统增加了额外的负担，占用了一个或多个计时器，或者暂停了程序的执行。此外，在开关输入上使用中断需要在计时器运行时禁用中断，这会给代码增加进一步的复杂性。
- en: 'Debouncing in hardware can be done using discrete components, or using an SR
    latch (consisting of two NAND gates). For this application, we will use the following
    circuit, which works well with the most commonly used SPST (single-pole, single-throw)
    type of switch:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中进行消抖可以使用离散元件，或者使用SR触发器（由两个与非门组成）。对于这种应用，我们将使用以下电路，它与最常用的SPST（单极单刀）类型的开关配合良好：
- en: '![](img/78c9ed38-dcb3-4eb3-85a1-733bf19c5bd6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78c9ed38-dcb3-4eb3-85a1-733bf19c5bd6.png)'
- en: The concept behind this circuit is that when the switch is open, the capacitor
    is charged via R1 (and D1), causing the input on the inverting Schmitt trigger
    circuit (U1) to go high, resulting in the GPIO pin of the SBC connected to the
    output of U1 to read low. When the switch closes, the capacitor is discharged
    to the ground over R2.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路的概念是，当开关打开时，电容通过R1（和D1）充电，导致反相施密特触发器电路（U1）上的输入变高，导致连接到U1输出的SBC的GPIO引脚读取低电平。当开关关闭时，电容通过R2放电到地面。
- en: 'Both the charging and discharging will take a certain amount of time, which
    adds latency before a change is registered on the input of U1\. The charging and
    discharging rates are determined by the values of R1 and R2, the formulas for
    which are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 充电和放电都需要一定的时间，在U1输入上发生变化之前会增加延迟。充电和放电速率由R1和R2的值决定，其公式如下：
- en: Charging: ![](img/0ec96986-b5cd-4e73-9ad3-38681f477c37.png)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充电：![](img/0ec96986-b5cd-4e73-9ad3-38681f477c37.png)
- en: Discharging: ![](img/6472a5a6-f642-45ee-89c1-8826d4387364.png)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放电：![](img/6472a5a6-f642-45ee-89c1-8826d4387364.png)
- en: Here, *V(t)* is the voltage at time *t* (in seconds). *V[S]* is the source voltage
    and *t* is the time in seconds after the source voltage has been applied. R is
    the circuit resistance in Ohm and C the capacitance in farads. Finally, *e* is
    a mathematical constant with the value of 2.71828 (approximately), also known
    as Euler's number.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*V(t)*是时间*t*（以秒为单位）时的电压。*V[S]*是源电压，*t*是源电压施加后的时间（以秒为单位）。R是电路电阻（欧姆），C是电容（法拉）。最后，*e*是一个数学常数，其值为2.71828（约），也称为欧拉数。
- en: 'For the charging and discharging of capacitors, the RC time constant, tau (τ),
    is used, which is defined as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电容器的充电和放电，使用了RC时间常数τ（tau），其定义如下：
- en: '![](img/4c70f6d7-152d-44d3-a793-6c3786e82007.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c70f6d7-152d-44d3-a793-6c3786e82007.png)'
- en: This defines the time it takes for the capacitor to be charged up to 63.2% (1τ),
    then 86% (2τ). The discharging of a capacitor for 1τ from fully charged will reduce
    its charge to 37%, and 13.5% after 2τ. One of the things one notices here is that
    a capacitor is never fully charged or discharged; the process of charging or discharging
    just slows down to the point where it becomes almost imperceptible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了电容器充电到63.2%（1τ）所需的时间，然后是86%（2τ）。电容器放电1τ后从完全充电状态下降到37%，2τ后为13.5%。这里注意到的一件事是，电容器永远不会完全充电或放电；充电或放电的过程只是减慢到几乎不可察觉的程度。
- en: 'With the values that we used for our debounce circuit, we get the following
    charge time constant for charging:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的消抖电路的数值，我们得到了以下充电的时间常数：
- en: '![](img/32b180c1-b53b-4bb7-82ed-e324fb5f3094.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32b180c1-b53b-4bb7-82ed-e324fb5f3094.png)'
- en: 'The discharge time is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 放电时间如下：
- en: '![](img/5f7819ea-e9e2-461d-a593-c4fdd7ba7a39.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f7819ea-e9e2-461d-a593-c4fdd7ba7a39.png)'
- en: This corresponds to 51 and 22 microseconds, respectively.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 分别对应51和22微秒。
- en: 'Like any Schmitt trigger, it has so-called hysteresis, meaning that it has
    dual thresholds. This effectively adds a dead zone in the output response above
    and below, which the output will not change:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何施密特触发器一样，它具有所谓的滞后特性，这意味着它具有双阈值。这有效地在输出响应上方和下方添加了一个死区，输出不会改变：
- en: '![](img/bc437d21-ffee-4425-9d2f-3184fc28df6d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc437d21-ffee-4425-9d2f-3184fc28df6d.png)'
- en: The hysteresis from a Schmitt trigger is usually used to remove noise from an
    incoming signal by setting explicit trigger levels. Even though the RC circuit
    we are already using should filter out practically all noises, adding a Schmitt
    trigger adds that little bit more insurance without any negative repercussions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 施密特触发器的滞后通常用于通过设置明确的触发电平来消除传入信号的噪音。尽管我们已经在使用的RC电路应该能够滤除几乎所有的噪音，但添加施密特触发器可以增加一点额外的保险，而不会产生任何负面影响。
- en: When available, it is also possible to use the hysteresis functionality of an
    SBC's GPIO pins. For this project and the chosen debounce circuit, we also want
    the inverting property of the chip so that we get the expected high/low response
    for the connected switch instead of having to invert the meaning in software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当可用时，也可以使用SBC的GPIO引脚的滞后功能。对于这个项目和选择的去抖电路，我们还希望芯片具有反转属性，这样我们就可以得到连接开关的预期高/低响应，而不必在软件中反转含义。
- en: Debounce HAT
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去抖HAT
- en: 'Using the information and debounce circuit from the previous section, a prototype
    board is assembled:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节的信息和去抖电路，组装了一个原型板：
- en: '![](img/3c655ae5-9b38-479e-8178-6676cf9e0cd9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c655ae5-9b38-479e-8178-6676cf9e0cd9.png)'
- en: This prototype implements two debounce channels for the two switches that are
    required by the project. It also adds a screw terminal to connect the SBC power
    connection to. This allows one to power the SBC via the 5V header pins instead
    of having to use the micro-USB connector of the Raspberry Pi. For integration
    purposes, it's usually easier to just run the wires directly from the power supply
    into a screw terminal or similar than to bodge on a micro-USB plug.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原型实现了两个去抖通道，这是项目所需的两个开关。它还添加了一个螺钉端子，用于连接SBC电源连接。这样可以通过5V引脚为SBC供电，而不必使用树莓派的微型USB连接器。为了集成的目的，通常更容易直接从电源供应器运行导线到螺钉端子或类似的地方，而不是在微型USB插头上进行调整。
- en: 'This prototype is, of course, not a proper HAT, as defined by the Raspberry
    Pi Foundation''s rules. These require the following features:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个原型不是树莓派基金会规定的合适的HAT。这些要求以下功能：
- en: It has a valid EEPROM containing vendor information, GPIO map, and device information
    connected to the `ID_SC` and `ID_SD` I2C bus pins on the Raspberry Pi SBC
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有包含供应商信息、GPIO映射和设备信息的有效EEPROM，连接到树莓派SBC上的`ID_SC`和`ID_SD` I2C总线引脚
- en: It has the modern 40-pin (female) GPIO connector, also spacing the HAT from
    the SBC by at least 8 millimeters
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有现代的40针（女）GPIO连接器，还将HAT与SBC的间距至少8毫米
- en: It follows the mechanical specification
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循机械规格
- en: If providing power to the SBC via the 5V pins, the HAT has to be able to provide
    at least 1.3 amperes continuously
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过5V引脚为SBC提供电源，HAT必须能够持续提供至少1.3安培
- en: 'With the required I2C EEPROM (CAT24C32) and other features added, we can see
    what a full version using the six channels offered by the inverting hex Schmitt
    trigger IC (40106) looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加所需的I2C EEPROM（CAT24C32）和其他功能，我们可以看到使用倒置六通道提供的倒置六通道施密特触发器IC（40106）的完整版本是什么样子的：
- en: '![](img/f94f1673-7d99-4eb5-b684-35e094620374.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f94f1673-7d99-4eb5-b684-35e094620374.png)'
- en: The files for this KiCad project can be found at the author's GitHub account
    at [https://github.com/MayaPosch/DebounceHat](https://github.com/MayaPosch/DebounceHat).
    With the extended number of channels, it would be relatively easy to integrate
    further switches, relays, and other elements into the system, possibly monitoring
    things like windows and such with various sensors that output a high/low signal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此KiCad项目的文件可以在作者的GitHub帐户[https://github.com/MayaPosch/DebounceHat](https://github.com/MayaPosch/DebounceHat)中找到。通过扩展的通道数量，相对容易地集成更多的开关、继电器和其他元素到系统中，可能使用各种传感器来监视诸如窗户之类的东西，输出高/低信号。
- en: Power
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电源
- en: For our project, the required voltages we need are 5V for the Raspberry Pi board
    and a second voltage for the lights that we switch on and off via the relays.
    The power supply we pick has to be able to provide sufficient power to the SBC
    and the lights. For the former, 1-2 A should suffice, with the latter depending
    on the lights being used and their power requirements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们需要的所需电压是树莓派板的5V和通过继电器开关的灯的第二电压。我们选择的电源必须能够为SBC和灯提供足够的电力。对于前者，1-2 A应该足够，后者取决于所使用的灯和它们的功率要求。
- en: Implementation
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: The monitoring service will be implemented as a basic `systemd` service, meaning
    that it will be started by the operating system when the system starts, and the
    service can be monitored and restarted using all the regular systemd tools.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 监控服务将作为基本的`systemd`服务实现，这意味着它将在系统启动时由操作系统启动，并且可以使用所有常规的systemd工具来监视和重新启动服务。
- en: 'We will have the following dependencies:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有以下依赖项：
- en: POCO
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POCO
- en: WiringPi
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WiringPi
- en: libmosquittopp (and libmosquitto)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libmosquittopp（和libmosquitto）
- en: The libmosquitto dependency ([https://mosquitto.org/man/libmosquitto-3.html](https://mosquitto.org/man/libmosquitto-3.html))
    is used to add MQTT support. The libmosquittopp dependency is a wrapper around
    the C-based API to provide a class-based interface, which makes integration into
    C++ projects easier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用libmosquitto依赖项（[https://mosquitto.org/man/libmosquitto-3.html](https://mosquitto.org/man/libmosquitto-3.html)）用于添加MQTT支持。
    libmosquittopp依赖项是围绕基于C的API的包装器，提供了基于类的接口，这使得集成到C++项目中更容易。
- en: The POCO framework ([https://pocoproject.org/](https://pocoproject.org/)) is
    a highly portable set of C++ APIs, which provides everything from network-related
    functions (including HTTP) to all common low-level functions. In this project,
    its HTTP server will be used, along with its support for handling configuration
    files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: POCO框架（[https://pocoproject.org/](https://pocoproject.org/)）是一组高度可移植的C++ API，提供从网络相关功能（包括HTTP）到所有常见的低级功能。在这个项目中，它的HTTP服务器将被使用，以及它对处理配置文件的支持。
- en: Finally, WiringPi ([http://wiringpi.com/](http://wiringpi.com/)) is the de facto
    standard header for accessing and using the GPIO header features on the Raspberry
    Pi and compatible systems. It implements APIs to communicate with I2C devices
    and UARTs, and uses PWM and digital pins. In this project, it allows us to communicate
    with the relay board and the debounce board.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，WiringPi（[http://wiringpi.com/](http://wiringpi.com/)）是访问和使用树莓派和兼容系统上的GPIO头部特性的事实标准头文件。它实现了与I2C设备和UART的通信API，并使用PWM和数字引脚。在这个项目中，它允许我们与继电器板和去抖板进行通信。
- en: 'The current version of this code can also be found at the author''s GitHub
    account: [https://github.com/MayaPosch/ClubStatusService](https://github.com/MayaPosch/ClubStatusService).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的当前版本也可以在作者的GitHub帐户上找到：[https://github.com/MayaPosch/ClubStatusService](https://github.com/MayaPosch/ClubStatusService)。
- en: 'We will start with the main file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主文件开始：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we include some basic STL functionality, along with the HTTP server and
    `ini` file support from POCO. The listener header is for our MQTT class, with
    the `httprequestfactory` and club headers being for the HTTP server and the main
    monitoring logic, respectively:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包括一些基本的STL功能，以及来自POCO的HTTP服务器和`ini`文件支持。监听器头文件是为我们的MQTT类，`httprequestfactory`和club头文件是为HTTP服务器和主要的监控逻辑，分别是：
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this section, we initialize the MQTT library (libmosquittopp) and try to
    open the configuration file, using the default path and name if nothing is specified
    in the command-line parameters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们初始化MQTT库（libmosquittopp）并尝试打开配置文件，如果在命令行参数中没有指定任何内容，则使用默认路径和名称。
- en: POCO's `IniFileConfiguration` class is used to open and read in the configuration
    file, throwing an exception if it cannot be found or opened. POCO's `AutoPtr`
    is equivalent to C++11's `unique_ptr`, allowing us to create a new heap-based
    instance without having to worry about disposing of it later.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: POCO的`IniFileConfiguration`类用于打开和读取配置文件，如果找不到或无法打开配置文件，则会抛出异常。POCO的`AutoPtr`相当于C++11的`unique_ptr`，允许我们创建一个新的基于堆的实例，而不必担心以后处理它。
- en: 'Next, we read out the values that we are interested in for the MQTT and relay
    board functionality, specifying defaults where it makes sense to do so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们读取我们对MQTT和继电器板功能感兴趣的值，指定默认值是有意义的地方：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we start the MQTT class, providing it with the parameters it
    needs to connect to the MQTT broker. Next, the HTTP server's configuration details
    are read out and a new `HTTPServer` instance is created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们启动MQTT类，并为其提供连接到MQTT代理所需的参数。接下来，读取HTTP服务器的配置详细信息，并创建一个新的`HTTPServer`实例。
- en: The server instance is configured with the provided port and some limits for
    the maximum number of threads the HTTP server is allowed to use, as well as for
    the maximum queued connections it can keep. These parameters are useful to optimize
    system performance and fit code like this into systems with fewer resources to
    spare.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实例使用提供的端口和一些限制进行配置，用于HTTP服务器允许使用的最大线程数，以及它可以保持的最大排队连接数。这些参数对于优化系统性能并将这样的代码适应到资源更少的系统中是有用的。
- en: 'New client connections are handled by the custom `RequestHandlerFactory` class,
    which we will look at later:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 新的客户端连接由自定义的`RequestHandlerFactory`类处理，我们稍后会看到：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we assign a reference to the Listener instance we created to the static
    `Club` class's `mqtt` member. This will allow the `Listener` object to be used
    more easily later on, as we will see.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建的`Listener`实例的引用分配给静态的`Club`类的`mqtt`成员。这将使`Listener`对象更容易在以后使用，我们将看到。
- en: With calling `start()` on `Club`, the monitoring and configuring of the connected
    hardware will be handled and we are done with that aspect in the main function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Club`上调用`start()`，将处理连接硬件的监视和配置，并且在主函数中完成了这个方面。
- en: Finally, we enter a loop for the MQTT class, ensuring that it remains connected
    to the MQTT broker. Upon leaving the loop, we will clean up resources and stop
    the HTTP server and others. However, since we are in an infinite loop here, this
    code will not be reached with this implementation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入了一个MQTT类的循环，确保它保持与MQTT代理的连接。离开循环时，我们将清理资源并停止HTTP服务器等。然而，由于我们在这里是一个无限循环，这个代码不会被执行到。
- en: Since this implementation would be run as a service that runs 24/7, a way to
    terminate the service cleanly is not an absolute requirement. A relatively easy
    way to do this would be to add a signal handler that would interrupt the loop
    once triggered. For simplicity's sake, this has been left out of this project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现将作为一个24/7运行的服务，以一种干净的方式终止服务并不是绝对必要的。一个相对简单的方法是添加一个信号处理程序，一旦触发就会中断循环。为了简单起见，这在这个项目中被省略了。
- en: Listener
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听器
- en: 'The class declaration for the `Listener` class looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listener`类的类声明如下：'
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This class provides a simple API to connect to an MQTT broker and send messages
    to said broker. We inherit from the `mosquittopp` class, re-implementing a number
    of callback methods to handle the events of connecting newly received messages
    and completed subscriptions to MQTT topics.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个简单的API来连接到MQTT代理并向该代理发送消息。我们从`mosquittopp`类继承，重新实现了一些回调方法来处理连接新接收的消息和完成对MQTT主题的订阅的事件。
- en: 'Next, let''s have a look at the implementation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下实现：
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the constructor, we assign the unique MQTT client identification string using
    the mosquittopp class's constructor. We use a default value for the keep alive
    setting of 60 seconds, meaning the time for which we will keep a connection open
    to the MQTT broker without any side sending a control or other message.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用mosquittopp类的构造函数分配唯一的MQTT客户端标识字符串。我们使用默认值为60秒的保持活动设置，这意味着我们将保持与MQTT代理的连接开放的时间，而不会发送任何控制或其他消息。
- en: 'After setting a username and password, we connect to the MQTT broker:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户名和密码后，我们连接到MQTT代理：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This callback function is called whenever a connection attempt has been made
    with the MQTT broker. We check the value of `rc` and if the value is zero—indicating
    success—we start subscribing to any desired topics. Here, we subscribe to just
    one topic: /club/status. If any other MQTT clients send a message to this topic,
    we will receive it in the following callback function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每当尝试与MQTT代理建立连接时，都会调用此回调函数。我们检查`rc`的值，如果值为零，表示成功，我们开始订阅任何所需的主题。在这里，我们只订阅一个主题：/club/status。如果任何其他MQTT客户端向此主题发送消息，我们将在下一个回调函数中收到它：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this callback function, we receive a struct with the MQTT topic and payload.
    We then compare the topic to the topic strings we subscribed to, which in this
    case is just the /club/status topic. Upon receiving a message for this topic,
    we publish a new MQTT message with a topic and payload. The last parameter is
    the **quality of service** (**QoS**) value, with in this case setting is the *deliver
    at least once* flag. This guarantees that at least one other MQTT client will
    receive our message.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调函数中，我们接收一个带有MQTT主题和负载的结构体。然后我们将主题与我们订阅的主题字符串进行比较，这种情况下只是/club/status主题。收到此主题的消息后，我们将发布一个新的MQTT消息，其中包含主题和负载。最后一个参数是**服务质量**（**QoS**）值，在这种情况下设置为*至少一次传递*标志。这保证至少有另一个MQTT客户端会接收到我们的消息。
- en: The MQTT payload is always a binary, that is, `1` in this example. To make it
    reflect the status of the club room (opened or closed), we would have to integrate
    the response from the static `Club` class, which we will be looking at in the
    next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT负载始终是二进制的，例如在这里是`1`。要使其反映俱乐部房间的状态（打开或关闭），我们需要集成来自静态`Club`类的响应，我们将在下一节中讨论这个。
- en: 'First, we look at the remaining functions for the `Listener` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下`Listener`类的其余函数：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The callback function for a new subscription is left empty here, but could be
    used to add logging or such functionality. Furthermore, we have an overloaded
    `sendMessage()` function, which allows other parts of the application to also
    publish MQTT messages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 新订阅的回调函数在这里为空，但可以用于添加日志记录或类似功能。此外，我们还有一个重载的`sendMessage()`函数，允许应用程序的其他部分也发布MQTT消息。
- en: The main reason to have these two different functions is that sometimes it's
    easier to use a `char*` array to send, for example, an array of 8-bit integers
    as part of a binary protocol, whereas other times an STL string is more convenient.
    This way, we get the best of both worlds, without having to convert one or the
    other whenever we wish to send an MQTT message anywhere in our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有这两个不同函数的主要原因是，有时使用`char*`数组发送更容易，例如，作为二进制协议的一部分发送8位整数数组，而其他时候STL字符串更方便。这样，我们可以同时获得两种方式的最佳效果，而不必在代码中的任何位置发送MQTT消息时转换其中一种。
- en: The first parameter to `publish()` is the message ID, which is a custom integer
    we can assign ourselves. Here, we leave it at zero. We also make use of the *retain* flag
    (last parameter), setting it to true. This implies that whenever a new MQTT client
    subscribes to the topic we published a retained message on, this client will always
    receive the last message that was published on that particular topic.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish()`的第一个参数是消息ID，这是一个我们可以自己分配的自定义整数。在这里，我们将其保留为零。我们还使用了*retain*标志（最后一个参数），将其设置为true。这意味着每当一个新的MQTT客户端订阅我们发布保留消息的主题时，该客户端将始终接收到在该特定主题上发布的最后一条消息。'
- en: Since we will be publishing the status of the club rooms on an MQTT topic, it
    is desirable that the last status message is retained by the MQTT broker so that
    any client that uses this information will immediately receive the current status
    the moment it connects to the broker, instead of having to wait for the next status
    update.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在MQTT主题上发布俱乐部房间的状态，因此希望MQTT代理保留最后的状态消息，以便使用此信息的任何客户端在连接到代理时立即接收到当前状态，而不必等待下一个状态更新。
- en: Club
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 俱乐部
- en: 'The club header declares the classes that form the core of the project, and
    is responsible for dealing with the inputs from the switches, controlling the
    relays, and updating the status of the club room:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 俱乐部头文件声明了构成项目核心的类，并负责处理开关输入、控制继电器和更新俱乐部房间的状态：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing of note in this header file are the includes. They add the
    basic WiringPi GPIO functionality to our code, as well as those for I2C usage.
    Further WiringPi one could include for other projects requiring such functionality
    would be SPI, UART (serial), software PWM, Raspberry Pi (Broadcom SoC) specific
    functionality, and others:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个头文件中值得注意的第一件事是包含的内容。它们为我们的代码添加了基本的WiringPi GPIO功能，以及用于I2C使用的功能。进一步的WiringPi可以包括其他需要这种功能的项目，比如SPI、UART（串行）、软件PWM、树莓派（Broadcom
    SoC）特定功能等等：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We define the different log levels we will be using as an `enum`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`enum`定义我们将使用的不同日志级别：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We forward declare the `Listener` class, as we will be using it in the implementation
    for these classes, but don''t want to include the entire header for it yet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提前声明`Listener`类，因为我们将在这些类的实现中使用它，但暂时不想包含整个头文件：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ClubUpdater` class is responsible for configuring the I2C-based GPIO expander,
    which controls the relays, as well as handling any updates to the club status.
    A `Timer` instance from the POCO framework is used to add a delay to the power
    status relay, as we will see when we look at the implementation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClubUpdater`类负责配置基于I2C的GPIO扩展器，控制继电器，并处理俱乐部状态的任何更新。POCO框架中的`Timer`实例用于向电源状态继电器添加延迟，我们将在实现中看到。'
- en: This class inherits from the POCO `Runnable` class, which is the base class
    that's expected by the POCO `Thread` class, which is a wrapper around native threads.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自POCO `Runnable`类，这是POCO `Thread`类所期望的基类，它是围绕本地线程的包装器。
- en: 'The two `uint8_t` member variables mirror two registers on the I2C GPIO expander
    device, allowing us to set the direction and value of the output pins on the device,
    which effectively controls the attached relays:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`uint8_t`成员变量镜像了I2C GPIO扩展器设备上的两个寄存器，允许我们设置设备上输出引脚的方向和值，从而有效地控制附加的继电器：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Club` class can be regarded as the input side of the system, setting up
    and handling the ISRs (interrupt handlers), as well as acting as the central (static)
    class with all of the variables pertaining to the club status, such as the status
    of the lock switch, status switch, and status of the power system (club open or
    closed).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Club`类可以被视为系统的输入端，设置和处理ISR（中断处理程序），并作为所有与俱乐部状态相关的变量（如锁定开关状态、状态开关状态和电源系统状态（俱乐部开放或关闭））的中央（静态）类。'
- en: This class is made fully static so that it can be used freely by different parts
    of the program to inquire about the room status.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被完全静态化，以便它可以被程序的不同部分自由使用来查询房间状态。
- en: 'Moving on, here is the implementation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是实现：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we include the `Listener` header so that we can use it. We also include
    the POCO `NumberFormatter` class to allow us to format integer values for logging
    purposes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了`Listener`头文件，以便我们可以使用它。我们还包括了POCO `NumberFormatter`类，以便我们可以格式化整数值以进行日志记录。
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we define all of the registers of the target GPIO expander device, the
    NXP PCAL9535A. Even though we only use two of these registers, it''s generally
    a good practice to add the full list to simplify later expansion of the code.
    A separate header can be used as well to allow one to easily use different GPIO
    expanders without significant changes to your code, or any at all:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了目标GPIO扩展器设备NXP PCAL9535A的所有寄存器。即使我们只使用其中的两个寄存器，将完整列表添加是一个很好的做法，以简化以后代码的扩展。也可以使用单独的头文件，以便轻松使用不同的GPIO扩展器，而不需要对代码进行重大更改，甚至根本不需要。
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we define which functionality is connected to which relay, corresponding
    to a specific output pin of the GPIO expander chip. Since we have four relays,
    four pins are used. These are connected to the first bank (of two in total) of
    eight pins on the chip.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了哪些功能连接到哪个继电器，对应于GPIO扩展芯片的特定输出引脚。由于我们有四个继电器，因此使用了四个引脚。这些连接到芯片上的第一个（总共两个）八个引脚的银行。
- en: 'Naturally, it is important that these definitions match up with what is physically
    hooked up to those relays. Depending on the use case, one could make this configurable
    as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，重要的是这些定义与实际连接到这些继电器的内容相匹配。根据使用情况，这也可以是可配置的。
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As `Club` is a fully static class, we initialize all of its member variables
    before we move into the `ClubUpdater` class''s implementation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Club`是一个完全静态的类，我们在进入`ClubUpdater`类的实现之前初始化了它的所有成员变量。
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we start an instance of this class, its `run()` function gets called. Here,
    we set a number of defaults. The direction and output register variables are initially
    set to zero. The club room power status is set to false, and the power timer-related
    Booleans are set to false, as the power timer is not active yet. This timer is
    used to set a delay before the power is turned on or off, as we will see in more
    detail in a moment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动这个类的一个实例时，它的`run()`函数被调用。在这里，我们设置了一些默认值。方向和输出寄存器变量最初设置为零。俱乐部房间电源状态设置为false，与电源计时器相关的布尔变量设置为false，因为电源计时器尚未激活。这个计时器用于在打开或关闭电源之前设置延迟，我们稍后将会详细介绍。
- en: 'By default, the delay on this timer is ten seconds. This can, of course, also
    be made configurable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个计时器的延迟是十秒。当然，这也可以是可配置的。
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we set up the I2C GPIO expander. This requires the I2C device address,
    which we passed to the `Club` class earlier on. What this setup function does
    is ensure that there is an active I2C device at this address on the I2C bus. After
    this, it should be ready to communicate with. It is also possible to skip this
    step via setting the relayActive variable to false. This is done by setting the
    appropriate value in the configuration file, which is useful when running integration
    tests on a system without an I2C bus or connected device.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置I2C GPIO扩展器。这需要I2C设备地址，我们之前传递给了`Club`类。这个设置函数的作用是确保在I2C总线上的这个地址上有一个活动的I2C设备。之后，它应该准备好进行通信。也可以通过将relayActive变量设置为false来跳过这一步。这是通过在配置文件中设置适当的值来完成的，当在没有I2C总线或连接设备的系统上运行集成测试时非常有用。
- en: 'With the setup complete, we write the initial values of the direction and output
    registers for the first bank. Both are written with null bytes so that all eight
    pins they control are set to both output mode and to a binary zero (low) state.
    This way, all relays connected to the first four pins are initially off:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们写入了第一个银行的方向和输出寄存器的初始值。两者都写入了空字节，以便它们控制的所有八个引脚都设置为输出模式和二进制零（低）状态。这样，连接到前四个引脚的所有继电器最初都是关闭的。
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After completing these configuration steps, we run the first update of the club
    room status, using the same function that will also be called later on when the
    inputs change. This results in all of the inputs being checked and the outputs
    being set to a corresponding status.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些配置步骤后，我们运行了俱乐部房间状态的第一次更新，使用相同的函数，以后当输入发生变化时也会调用。这导致所有输入被检查，并且输出被设置为相应的状态。
- en: Finally, we enter a waiting loop. This loop is controlled by the `Club::running`
    Boolean variable, allowing us to break out of it via a signal handler or similar.
    The actual waiting is performed using a condition variable, which we wait for
    here until either a time-out occurs on the one-minute wait (after which, we return
    to waiting after a quick check), or we get signaled by one of the interrupts that
    we will set later on for the inputs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入一个等待循环。这个循环由`Club::running`布尔变量控制，允许我们通过信号处理程序或类似方法中断它。实际的等待是使用条件变量进行的，在这里我们等待，直到一分钟等待超时发生（之后，我们经过快速检查后返回等待），或者我们被设置为输入的其中一个中断信号。
- en: 'Moving on, we look at the function that''s used to update the status of the
    outputs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看一下用于更新输出状态的函数：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do when we enter this update function is to ensure that the
    `Club::clubChanged` Boolean is set to false so that it can be set again by one
    of the interrupt handlers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入此更新函数时，我们首先确保`Club::clubChanged`布尔值设置为false，以便可以由其中一个中断处理程序再次设置。
- en: After this, we check what has changed exactly on the inputs. If the lock switch
    got triggered, its Boolean variable will have been set to true, or the variable
    for the status switch will likely have been triggered. If this is the case, we
    reset the variable and compare the newly read value with the last known value
    for that input.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查输入发生了什么变化。如果锁定开关被触发，它的布尔变量将被设置为true，或者状态开关的变量可能已被触发。如果是这种情况，我们将重置变量，并将新读取的值与该输入的上次已知值进行比较。
- en: As a sanity check, we ignore the triggering if the value hasn't changed. This
    could happen if the interrupt got triggered due to noise, such as when the signal
    wire for a switch runs near power lines. Any fluctuation in the latter would induce
    a surge in the former, which can trigger the GPIO pin's interrupt. This is one
    obvious example of both the reality of dealing with a non-ideal physical world
    and a showcase for the importance of both the hardware and software in how they
    affect the reliability of a system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种合理检查，如果值没有发生变化，我们会忽略触发。如果中断由于噪音而被触发，例如开关的信号线靠近电源线，这种情况可能会发生。后者的任何波动都会引起前者的激增，这可能会触发GPIO引脚的中断。这是处理非理想物理世界的现实的一个明显例子，也展示了硬件和软件对系统可靠性的影响的重要性。
- en: In addition to this check, we log the event using our central logger, and update
    the buffered input value for use in the next run.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个检查之外，我们还使用我们的中央记录器记录事件，并更新缓冲输入值，以便在下一次运行中使用。
- en: 'The last two cases in the if/else statement deal with the initial run, as well
    as a default handler. When we initially run this function the way we saw earlier,
    no interrupt will have been triggered, so obviously we have to add a third situation
    to the first two for the status and lock switches:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: if/else语句中的最后两种情况处理了初始运行，以及默认处理程序。当我们最初运行此函数时，就像我们之前看到的那样，没有中断会被触发，因此显然我们必须为状态和锁定开关添加第三种情况：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we check whether we have to change the status of the club room from closed
    to open, or the other way around. This is determined by checking whether the club
    status (`Club::clubOff`) Boolean has changed relative to the `Club::clubIsClosed`
    Boolean, which stores the last known status.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否必须将俱乐部房间的状态从关闭更改为打开，或者反之亦然。这是通过检查俱乐部状态（`Club::clubOff`）布尔值相对于存储的上次已知状态的`Club::clubIsClosed`布尔值来确定的。
- en: Essentially, if the status switch is changed from on to off or the other way
    around, this will be detected and a change to the new status will be started.
    This means that a power timer will be started, which will turn the non-permanent
    power in the club room on or off after the preset delay.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果状态开关从打开到关闭或反之亦然，这将被检测到，并且将开始更改为新状态。这意味着将启动电源定时器，该定时器将在预设延迟后打开或关闭俱乐部房间中的非永久电源。
- en: The POCO `Timer` class requires that we first stop the timer before starting
    it if it has been started previously. This requires us to add one additional check.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: POCO `Timer`类要求我们在启动之前先停止定时器，如果之前已经启动过。这要求我们添加一个额外的检查。
- en: In addition, we also use our reference to the MQTT client class to send a message
    to the MQTT broker with the updated club room status, here as either an ASCII
    1 or 0\. This message can be used to trigger other systems, which could update
    an online status for the club room, or be put to even more creative uses.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还使用对MQTT客户端类的引用，向MQTT代理发送消息，其中包括更新后的俱乐部房间状态，这里可以是ASCII 1或0。此消息可用于触发其他系统，这些系统可以更新俱乐部房间的在线状态，或者可以用于更多创造性的用途。
- en: Naturally, the exact payload of the message could be made configurable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，消息的确切有效载荷可以进行可配置。
- en: 'In the next section, we will update the colors on the status light, taking
    into account the state of power in the room. For this, we use the following table:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将根据房间内电源的状态更新状态灯的颜色。为此，我们使用以下表格：
- en: '| **Color** | **Status switch** | **Lock switch** | **Power status** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | **状态开关** | **锁定开关** | **电源状态** |'
- en: '| Green | On | Unlocked | On |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | 打开 | 解锁 | 打开 |'
- en: '| Yellow | Off | Unlocked | Off |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | 关闭 | 解锁 | 关闭 |'
- en: '| Red | Off | Locked | Off |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | 关闭 | 锁定 | 关闭 |'
- en: '| Yellow and red | On | Locked | On |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 黄色和红色 | 打开 | 锁定 | 打开 |'
- en: 'Here is the implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We first check the state of the club room power, which tells us what value to
    use for the first bit of the output register. If the power timer is active, we
    have to invert the power state, as we want to write the current power state, not
    the future state that is stored in the power state Boolean.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查俱乐部房间电源的状态，这告诉我们要使用输出寄存器的第一个位的值。如果电源定时器处于活动状态，我们必须反转电源状态，因为我们要写入当前的电源状态，而不是存储在电源状态布尔变量中的未来状态。
- en: If the club room's status switch is in the off position, then the state of the
    lock switch determines the final color. With the club room locked, we trigger
    the red relay, otherwise we trigger the yellow one. The latter would indicate
    the intermediate state, where the club room is off but not yet locked.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果俱乐部房间的状态开关处于关闭位置，则锁定开关的状态决定最终的颜色。当俱乐部房间被锁定时，我们触发红色继电器，否则我们触发黄色继电器。后者表示中间状态，即俱乐部房间关闭但尚未锁定。
- en: 'The use of a mutex here is to ensure that the writing of the I2C device''s
    output register—as well as updating the local register variable—is done in a synchronized
    manner:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用互斥锁是为了确保I2C设备输出寄存器的写入以及更新本地寄存器变量是以同步的方式进行的：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the club room's status switch is set to on, we get two other color options,
    with green being the usual one, which sees both the club room unlocked and the
    status switch enabled. If, however, the latter is on but the room is locked, we
    would get yellow and red.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果俱乐部房间的状态开关设置为开，我们会得到另外两个颜色选项，绿色是通常的选项，表示俱乐部房间解锁并且状态开关启用。然而，如果后者打开但房间被锁上，我们会得到黄色和红色。
- en: 'After finishing the new contents of the output register, we always use the
    `writeRelayOutputs()` function to write our local version to the remote device,
    thus triggering the new relay state:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 完成输出寄存器的新内容后，我们总是使用`writeRelayOutputs()`函数将我们的本地版本写入远程设备，从而触发新的继电器状态：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function is very simple, and uses WiringPi''s I2C API to write a single
    8-bit value to the connected device''s output register. We also log the written
    value here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能非常简单，使用WiringPi的I2C API向连接的设备输出寄存器写入一个8位值。我们也在这里记录写入的值：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this function, we set the club room power state to whatever value its Boolean
    variable contains. We use the same mutex as we used when updating the club room
    status colors. However, we do not create the contents of the output register from
    scratch here, instead opting to toggle the first bit in its variable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将俱乐部房间的电源状态设置为其布尔变量包含的任何值。我们使用与更新俱乐部房间状态颜色时相同的互斥体。然而，在这里我们不是从头开始创建输出寄存器的内容，而是选择切换其变量中的第一个位。
- en: After toggling this bit, we write to the remote device as usual, which will
    cause the power in the club room to toggle state.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 切换完这个位后，我们像往常一样向远程设备写入，这将导致俱乐部房间的电源切换状态。
- en: 'Next, we look at the static `Club` class, starting with the first function
    we call to initialize it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看一下静态的`Club`类，从我们调用的第一个函数开始初始化它：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this function, we start the entire club monitoring system, as we saw earlier
    in the application entry point. It accepts a few parameters, allowing us to turn
    the relay functionality on or off, the relay's I2C address (if using a relay),
    and the MQTT topic on which to publish changes to the club room status.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个功能，我们启动整个俱乐部监控系统，就像我们在应用程序入口点中看到的那样。它接受一些参数，允许我们打开或关闭继电器功能，设置继电器的I2C地址（如果使用继电器），以及要发布俱乐部房间状态更改的MQTT主题。
- en: After setting the values for member variables using those parameters, we initialize
    the WiringPi framework. There are a number of different initialization functions
    offered by WiringPi, which basically differ in how one can access the GPIO pins.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些参数设置成员变量的值后，我们初始化WiringPi框架。WiringPi提供了许多不同的初始化函数，基本上是在如何访问GPIO引脚上有所不同。
- en: The `wiringPiSetup()` function we use here is generally the most convenient
    one to use, as it will use virtual pin numbers that map to the underlying Broadcom
    SoC pins. The main advantage of the WiringPi numbering is that it remains constant
    between different revisions of the Raspberry Pi SBCs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的`wiringPiSetup()`函数通常是最方便的函数，因为它将使用虚拟引脚号，这些虚拟引脚号映射到底层的Broadcom SoC引脚。WiringPi编号的主要优势在于它在不同版本的树莓派SBC之间保持不变。
- en: With the use of either Broadcom (BCM) numbers or the physical position of the
    pins in the header on the SBC's circuit board, we risk that this changes between
    board revisions, but the WiringPi numbering scheme can compensate for this.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Broadcom（BCM）编号或SBC电路板上引脚排列的物理位置，我们冒着在板子版本之间发生变化的风险，但WiringPi编号方案可以弥补这一点。
- en: 'For our purposes, we use the following pins on the SBC:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们在SBC上使用以下引脚：
- en: '|  | **Lock switch** | **Status switch** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: 锁定开关 | 状态开关
- en: '| BCM | 17 | 4 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| BCM | 17 | 4 |'
- en: '| Physical position | 11 | 7 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 物理位置 | 11 | 7 |'
- en: '| WiringPi | 0 | 7 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| WiringPi | 0 | 7 |'
- en: After initializing the WiringPi library, we set the desired pin mode, making
    both of our pins into inputs. We then enable a pull-down on each of these pins.
    This enables a built-in pull-down resistor in the SoC, which will always try to
    pull the input signal low (referenced to ground). Whether or not one needs a pull-down
    or pull-up resistor enabled for an input (or output) pin depends on the circumstances,
    especially the connected circuit.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化WiringPi库之后，我们设置所需的引脚模式，将我们的两个引脚都设置为输入。然后我们在每个引脚上启用下拉。这将启用SoC中的内置下拉电阻，它将始终尝试将输入信号拉低（相对于地面）。是否需要为输入（或输出）引脚启用下拉电阻或上拉电阻取决于情况，特别是连接的电路。
- en: It's important to look at the behavior of the connected circuit; if the connected
    circuit has a tendency to "float" the value on the line, this would cause undesirable
    behavior on the input pin, with the value randomly changing. By pulling the line
    either low or high, we can be certain that what we read on the pin is not just
    noise.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要观察连接电路的行为；如果连接电路有使线路上的值“浮动”的倾向，这将导致输入引脚上的不良行为，值会随机变化。通过将线路拉低或拉高，我们可以确保我们在引脚上读取的不仅仅是噪音。
- en: With the mode set on each of our pins, we read out the values on them for the
    first time, which allows us to run the update function from the `ClubUpdater`
    class with the current values in a moment. Before we do that, however, we first
    register our interrupt methods for both pins.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的每个引脚上设置模式后，我们首次读取它们的值，这使我们能够在稍后使用`ClubUpdater`类中的当前值运行更新函数。然而，在这之前，我们首先为两个引脚注册我们的中断方法。
- en: An interrupt handler is little more than a callback that gets called whenever
    the specified event occurs on the specified pin. The WiringPi ISR function accepts
    the pin number, the type of event, and a reference to the handler function we
    wish to use. For the event type we picked here, we will have our interrupt handler
    triggered every time the value on the input pin goes from high to low, or the
    other way around. This means that it will be triggered when the connected switch
    goes from on to off, or off to on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序只不过是一个回调函数，每当指定的事件发生在指定的引脚上时就会被调用。WiringPi的ISR函数接受引脚编号、事件类型和我们希望使用的处理程序函数的引用。对于我们选择的事件类型，在输入引脚上的值从高变低，或者从低变高时，我们的中断处理程序将被触发。这意味着当连接的开关从开到关，或者从关到开时，它将被触发。
- en: 'Finally, we started the update thread by using the `ClubUpdater` class instance
    and pushing it into its own thread:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用`ClubUpdater`类实例并将其推送到自己的线程中来启动更新线程：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling this function will allow the loop in the `run()` function of `ClubUpdater`
    to end, which will terminate the thread it runs in, allowing the rest of the application
    to safely shut down as well:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数将允许`ClubUpdater`的`run()`函数中的循环结束，这将终止它运行的线程，也允许应用程序的其余部分安全关闭：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both of our interrupt handlers are pretty simple. When the OS receives the interrupt,
    it triggers the respective handler, which results in them reading the current
    value of the input pin, inverting the value as needed. The `statusChanged` or
    `lockChanged` variable is set to true to indicate to the update function which
    of the interrupts got triggered.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的中断处理程序都非常简单。当操作系统接收到中断时，它会触发相应的处理程序，这导致它们读取输入引脚的当前值，并根据需要反转该值。在中断触发时，`statusChanged`或`lockChanged`变量被设置为true，以指示更新函数中的哪个中断被触发。
- en: We do the same for the `clubChanged` Boolean variable before signaling the condition
    variable on which the `run` loop of `ClubUpdate` is waiting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在向`ClubUpdate`的`run`循环等待的条件变量上发出信号之前，我们也对`clubChanged`布尔变量执行相同的操作。
- en: 'The last part of this class is the logging function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最后一部分是日志函数：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use another mutex here to synchronize the log outputs in the system log (or
    console) and to prevent concurrent access to the MQTT class when different parts
    of the application call this function simultaneously. As we will see in a moment,
    this logging function is used in other classes as well.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用另一个互斥体来同步系统日志（或控制台）中的日志输出，并防止应用程序的不同部分同时调用此函数时发生并发访问MQTT类。正如我们将在一会儿看到的，这个日志函数也被用在其他类中。
- en: With this logging function, we can log both locally (system log) and remotely
    using MQTT.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个日志函数，我们可以在本地（系统日志）和远程使用MQTT进行日志记录。
- en: HTTP request handler
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求处理程序
- en: 'Whenever POCO''s HTTP server receives a new client connection, it uses a new
    instance of our `RequestHandlerFactory` class to get a handler for the specific
    request. Because it''s such a simple class, it''s fully implemented in the header:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每当POCO的HTTP服务器接收到一个新的客户端连接时，它都会使用我们的`RequestHandlerFactory`类的一个新实例来获取特定请求的处理程序。因为它是一个如此简单的类，它完全在头文件中实现：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our class doesn't do a whole lot more than compare the URL that the HTTP server
    was provided to determine which type of handler to instantiate and return. Here,
    we can see that if the URL string starts with `/clubstatus`, we return the status
    handler, which implements the REST API.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类并不比较HTTP服务器提供的URL，以确定要实例化和返回哪种类型的处理程序。在这里，我们可以看到，如果URL字符串以“/clubstatus”开头，我们将返回状态处理程序，该处理程序实现了REST
    API。
- en: The default handler is a simple file server, which attempts to interpret the
    request as a filename, as we will see in a moment.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 默认处理程序是一个简单的文件服务器，它尝试将请求解释为文件名，我们将在一会儿看到。
- en: Status handler
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态处理程序
- en: This handler implements a simple REST API, returning a JSON structure containing
    the current club status. This can be used by an external application to show real-time
    information on the system, which is useful for a dashboard or website.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序实现了一个简单的REST API，返回一个包含当前俱乐部状态的JSON结构。这可以被外部应用程序用来显示系统的实时信息，这对于仪表板或网站非常有用。
- en: 'Due to its simplicity, this class is also fully implemented in its header:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它的简单性，这个类也完全在它的头文件中实现：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the central logger function from the `Club` class here to register details
    on incoming requests. Here, we just log the IP address of the client, but one
    could use the POCO `HTTPServerRequest` class's API to request even more detailed
    information.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`Club`类的中央日志函数来注册有关传入请求的详细信息。在这里，我们只记录客户端的IP地址，但可以使用POCO `HTTPServerRequest`类的API来请求更详细的信息。
- en: Next, the URI is obtained from the request and we split the path section of
    the URL into a vector instance. After setting the content type and a transfer
    encoding setting on the response object, we check that we did indeed get the expected
    REST API call, at which point we compose the JSON string, obtain the club room
    status information from the `Club` class, and return this.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从请求中获取URI，并将URL的路径部分拆分为一个向量实例。在为响应对象设置内容类型和传输编码设置之后，我们检查我们确实得到了预期的REST API调用，此时我们组成JSON字符串，从`Club`类获取俱乐部房间状态信息，并返回。
- en: In the JSON object, we include information about the club room's status in general,
    inverting its Boolean variable, as well as the status of the lock and the power
    status, with a 1, indicating that the lock is closed or the power is on, respectively.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON对象中，我们包括有关俱乐部房间状态的一般信息，反转其布尔变量，以及锁的状态和电源状态，其中1表示锁已关闭或电源已打开。
- en: If the URL path had further segments, it would be an unrecognized API call,
    which would lead us to return an HTTP 400 (Bad Request) error instead.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL路径有更多的段，它将是一个无法识别的API调用，这将导致我们返回一个HTTP 400（错误请求）错误。
- en: Data handler
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据处理程序
- en: 'The data handler is called whenever no REST API call is recognized by the request
    handler factory. It tries to find the specified file, read it from disk, and return
    it, along with the proper HTTP headers. This class is also implemented in its
    header:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求处理程序工厂无法识别REST API调用时，数据处理程序被调用。它尝试找到指定的文件，从磁盘中读取它，并返回它，以及适当的HTTP标头。这个类也在它的头文件中实现：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We make the assumption here that any files to be served can be found in a subfolder
    of the folder in which this service is running. The filename (and path) is obtained
    from the request URL. If the path was empty, we assign it a default index file
    to be served instead:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里假设要提供的任何文件都可以在运行此服务的文件夹的子文件夹中找到。文件名（和路径）从请求URL中获取。如果路径为空，我们将分配一个默认的索引文件来代替提供：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We first check that the resulting file path is valid and that it is a regular
    file, not a directory. If this check fails, we return an HTTP 404 File Not Found
    error.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查生成的文件路径是否有效，并且它是一个常规文件，而不是一个目录。如果此检查失败，我们将返回HTTP 404文件未找到错误。
- en: 'After passing this check, we try to obtain the file extension from the file
    path to try and determine a specific MIME type for the file. If this fails, we
    use a default MIME type for plain text:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个检查后，我们尝试从文件路径中获取文件扩展名，以确定文件的特定MIME类型。如果失败，我们将使用纯文本的默认MIME类型：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As the final step, we use the response object's `sendFile()` method to send
    the file to the client, along with the MIME type we determined earlier.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们使用响应对象的`sendFile()`方法将文件发送给客户端，以及我们之前确定的MIME类型。
- en: We also handle the two exceptions this method can throw. The first one occurs
    when the file cannot be found for some reason. This results in us returning another
    HTTP 404 error.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还处理了此方法可能抛出的两个异常。第一个异常发生在由于某种原因找不到文件时。这会导致我们返回另一个HTTP 404错误。
- en: If the file cannot be opened for some reason, we return an HTTP 500 Internal
    Server Error instead, along with the text from the exception.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因无法打开文件，我们将返回HTTP 500内部服务器错误，以及异常中的文本。
- en: Service configuration
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务配置
- en: 'With the Raspbian Linux distribution for Raspberry Pi SBCs, system services
    are usually managed with `systemd`. This uses a simple configuration file, with
    our club monitoring service using something like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于树莓派SBC的Raspbian Linux发行版，系统服务通常使用`systemd`进行管理。这使用一个简单的配置文件，我们的俱乐部监控服务使用类似以下内容的配置文件：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This service configuration specifies the name of the service, with the service
    being started from the "`user`" user account's folder, and the configuration file
    for the service being found in the same folder. We set the working directory for
    the service, also enabling the automatic restarting of the service after five
    seconds if it were to fail for whatever reason.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务配置指定了服务的名称，服务是从“`user`”用户帐户的文件夹启动的，并且服务的配置文件也在同一个文件夹中找到。我们设置了服务的工作目录，还启用了服务在失败后自动重新启动的功能，间隔为五秒。
- en: Finally, the service will be started after the system has started to the point
    where a user can log in to the system. This way, we are sure that networking and
    other functionality has been started already. If one starts a system service too
    soon, it could fail due to missing functionality on account of things not having
    been initialized yet.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务将在系统启动到用户可以登录系统的地步后启动。这样，我们可以确保网络和其他功能已经启动。如果一个系统服务启动得太早，可能会因为尚未初始化的功能缺失而失败。
- en: 'Next, here is the INI file configuration file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是INI文件配置文件：
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The configuration file is divided into three sections, MQTT, HTTP, and Relay,
    with each section containing the relevant variables.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件分为三个部分，MQTT、HTTP和Relay，每个部分包含相关变量。
- en: For MQTT, we have the expected options for connecting to the MQTT broker, including
    password-based authentication. We also specify the topic regarding which club
    status updates will be published here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MQTT，我们有连接到MQTT代理的预期选项，包括基于密码的身份验证。我们还指定了俱乐部状态更新将在此发布的主题。
- en: The HTTP section just contains the port we will be listening on, with the server
    listening on all interfaces by default. If necessary, one could make the network
    interface a used configurable as well by making this property configurable before
    starting the HTTP server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP部分只包含我们将监听的端口，默认情况下服务器在所有接口上监听。如果需要，可以通过在启动HTTP服务器之前使此属性可配置来使网络接口可配置。
- en: Finally, the Relay section allows us to turn the relay board feature on or off,
    as well as configure the I2C device address if we are making use of this feature.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继电器部分允许我们打开或关闭继电器板功能，并配置I2C设备地址（如果我们正在使用此功能）。
- en: Permissions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限
- en: 'Since both the GPIO and I2C are treated as common Linux devices, they come
    with their own set of permissions. Assuming one wishes to avoid running the service
    as root, we need to add an account that runs the service to both the `gpio` and
    `i2c` user groups:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GPIO和I2C都被视为常见的Linux设备，它们都有自己的权限集。假设希望避免以root身份运行服务，我们需要将运行服务的帐户添加到`gpio`和`i2c`用户组中：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After this, we need to restart the system (or log out and in again) for the
    changes to take effect. We should now be able to run the service without any issues.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要重新启动系统（或注销并再次登录）以使更改生效。现在我们应该能够无问题地运行服务了。
- en: Final results
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终结果
- en: With the application and `systemd` service configured and installed on the target
    SBC, it will automatically start and configure itself. To complete the system,
    you could install it along with a suitable power supply into an enclosure, into
    which you would run the signal wires from the switches, the network cable, and
    so on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在目标SBC上配置和安装应用程序和`systemd`服务，它将自动启动和配置自身。为了完成系统，您可以将其与合适的电源供应一起安装到一个外壳中，从开关运行信号线、网络电缆等。
- en: 'One implementation of this system was installed at the Entropia hackerspace
    in Karlsruhe, Germany. This setup uses a real traffic light (legally obtained)
    outside the club door with 12 volt LED lights for status indication. The SBC,
    relay board, debounce board, and power supply (5V and 12V MeanWell industrial
    PSU) are all integrated into a single, laser-cut wooden enclosure:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的一个实现安装在德国卡尔斯鲁厄的Entropia黑客空间。这个设置在俱乐部门外使用了一个真实的交通灯（合法获得）来指示状态，使用12伏LED灯。SBC、继电器板、去抖板和电源（5V和12V
    MeanWell工业电源）都集成在一个单一的激光切割木制外壳中：
- en: '![](img/fdcc5ed3-6f1c-4c43-a51e-d14a36225368.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdcc5ed3-6f1c-4c43-a51e-d14a36225368.png)'
- en: However, you are free to integrate the components any way you wish. The main
    thing to consider here is that the electronics are all safely protected from harm
    and accidental contact as the relay board could be switching mains voltage, along
    with possibly the mains voltage line for the power supply.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以自由地以任何您希望的方式集成组件。这里需要考虑的主要事项是，电子设备都受到安全保护，以免受到损害和意外接触，因为继电器板可能会切换主电压，以及可能是电源供应的主电压线。
- en: Example – basic media player
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 基本媒体播放器
- en: Another basic example of an SBC-based embedded system is a media player. This
    can involve both audio and audio-visual (AV) media formats. The difference between
    an SBC-based system being used to play back media with regular keyboard and mouse
    input, and an embedded SBC-based media player, is that in the latter's case the
    system can only ever be used for that purpose, with the software and user interface
    (physical- and software-wise) both optimized for media player use.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 基于SBC的嵌入式系统的另一个基本示例是媒体播放器。这可以涉及音频和音频-视觉（AV）媒体格式。使用SBC的系统用于播放媒体与常规键盘和鼠标输入的区别，以及嵌入式SBC媒体播放器的区别在于，后者的系统只能用于该目的，软件和用户界面（物理和软件方面）都经过优化，用于媒体播放器使用。
- en: To this end, a software-based frontend has to be developed, along with a physical
    interface peripheral, using which the media player can be controlled. This could
    be something as simple as a series of switches connected to the GPIO pins, with
    a regular HDMI display for output. Alternatively, one could use a touch screen,
    although this would require a more complex driver setup.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，必须开发一个基于软件的前端，以及一个物理接口外设，用于控制媒体播放器。这可以是一系列连接到GPIO引脚的开关，输出到常规HDMI显示器。或者，也可以使用触摸屏，尽管这将需要更复杂的驱动程序设置。
- en: Since our media player system stores media files locally, we want to use an
    SBC that supports external storage beyond the SD card. Some SBCs come with a SATA
    connection, allowing us to connect a hard disk drive (HDD) of capacities far exceeding
    those of SD cards. Even if we stick to compact 2.5" HDDs, which are roughly the
    same size as many popular SBCs, we can easily and fairly cheaply get multiple
    terabytes worth of storage.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的媒体播放器系统在本地存储媒体文件，我们希望使用支持SD卡以外的外部存储的SBC。一些SBC配备了SATA连接，允许我们连接容量远远超过SD卡的硬盘驱动器（HDD）。即使我们坚持使用紧凑的2.5英寸HDD，这些HDD的尺寸与许多流行的SBC大致相同，我们可以轻松而相对便宜地获得数TB的存储空间。
- en: Beyond the storage requirement, we also need to have a digital video output,
    and we want to either use the GPIO or the USB side for the user interface buttons.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储要求，我们还需要具有数字视频输出，并且我们希望使用GPIO或USB端口进行用户界面按钮的操作。
- en: 'A very suitable board for this purpose is the LeMaker Banana Pro, which comes
    with the H3 ARM SoC, hardware SATA, and Gigabit Ethernet support, as well as a
    full-sized HDMI output with 4k video decoding support:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目的非常适合的板子是LeMaker Banana Pro，它配备了H3 ARM SoC、硬件SATA和千兆以太网支持，以及支持4k视频解码的全尺寸HDMI输出：
- en: '![](img/74a1aea9-04a3-4e25-9ac3-f4bc3020306d.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74a1aea9-04a3-4e25-9ac3-f4bc3020306d.png)'
- en: After going through the basics of installing Armbian or similar OSes on the
    SBC, we can set up a media player application on the system, having it start together
    with the OS and configuring it to both load a playlist and to listen to events
    on a number of GPIO pins. These GPIO pins would be connected to a number of control
    switches, allowing us to scroll through the playlist and start, pause, and stop
    playlist items.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Armbian或类似操作系统到SBC的基础知识之后，我们可以在系统上设置一个媒体播放器应用程序，使其与操作系统一起启动，并配置它加载播放列表，并监听一些GPIO引脚上的事件。这些GPIO引脚将连接到一些控制开关，允许我们浏览播放列表，并启动、暂停和停止播放列表项。
- en: Other interaction methods are possible, such as an infrared or radio-based remote
    control, each of which come with their own advantages and disadvantages.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 其他交互方法也是可能的，例如红外线或基于无线电的遥控器，每种方法都有其优缺点。
- en: 'We will be working through the creation of this media player system and turning
    it into an infotainment system in the following chapters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中通过创建这个媒体播放器系统并将其转变为信息娱乐系统来进行工作：
- en: '[Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)，*测试基于操作系统的应用*'
- en: '[Chapter 8](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Linux-Based
    Infotainment System*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)，*示例-基于Linux的信息娱乐系统*'
- en: '[Chapter 11](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml), *Developing Embedded
    Systems with Qt*'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml)，*使用Qt开发嵌入式系统*'
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at OS-based embedded systems, exploring the many
    operating systems available to us, with the most significant differences, especially
    those of real-time operating systems. We also saw how one would integrate an RTC
    peripheral into an SBC-based Linux system and explored user space- and kernel
    space-based driver modules, along with their advantages and disadvantages.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了基于操作系统的嵌入式系统，探索了我们可以使用的许多操作系统，尤其是实时操作系统的显着差异。我们还看到了如何将RTC外设集成到基于SBC的Linux系统中，并探索了基于用户空间和内核空间的驱动程序模块，以及它们的优缺点。
- en: Along with the example project in this chapter, the reader should now have a
    good idea of how to translate a set of requirements into a functioning OS-based
    embedded system. The reader will know how to add external peripherals and use
    them from the OS.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章的示例项目，读者现在应该对如何将一组需求转化为一个功能正常的基于操作系统的嵌入式系统有了一个很好的想法。读者将知道如何添加外部外设并从操作系统中使用它们。
- en: In the next chapter, we will be looking at developing for resource-restricted
    embedded systems, including 8-bit MCUs and their larger brethren.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究为资源受限的嵌入式系统开发，包括8位MCU及其更大的兄弟。
