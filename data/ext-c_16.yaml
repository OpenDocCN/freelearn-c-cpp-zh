- en: Chapter 16
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章
- en: Thread Synchronization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步
- en: 'In the previous chapter, we explained how to create and manage a POSIX thread.
    We also demonstrated two of the most common concurrency issues: race conditions
    and data races.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们解释了如何创建和管理 POSIX 线程。我们还演示了两种最常见的并发问题：竞态条件和数据竞争。
- en: In this chapter, we are going to complete our discussion about multithreaded
    programming using the POSIX threading library and give you the required skills
    to control a number of threads.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续讨论使用 POSIX 线程库进行多线程编程，并为您提供控制多个线程所需的技术。
- en: If you remember from *Chapter 14*, *Synchronization*, we showed that concurrency-related
    problems are not actually issues; rather, they are consequences of the fundamental
    properties of a concurrent system. Therefore, you are likely to encounter them
    in any concurrent system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得第 14 章“同步”，我们展示了与并发相关的问题实际上并不是问题；相反，它们是并发系统基本属性的后果。因此，您很可能在任何并发系统中都会遇到它们。
- en: We showed in the previous chapter that we could indeed produce such issues with
    the POSIX threading library as well. *Examples 15.2* and *15.3* from the previous
    chapter demonstrated the race condition and data race issues. Therefore, they
    will be our starting point to use the synchronization mechanisms provided by the
    pthread library in order to synchronize a number of threads.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中展示了我们确实可以使用 POSIX 线程库产生这些问题。上一章的*示例 15.2*和*15.3*演示了竞态条件和数据竞争问题。因此，它们将成为我们使用
    pthread 库提供的同步机制来同步多个线程的起点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using POSIX mutexes to protect critical sections accessing a shared resource.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POSIX 互斥锁来保护访问共享资源的临界区。
- en: Using POSIX condition variables to wait for a specific condition.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POSIX 条件变量等待特定条件。
- en: Using various types of locks together with mutexes and condition variables.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种类型的锁与互斥锁和条件变量一起使用。
- en: Using POSIX barriers and the way they can help synchronize a number of threads.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POSIX 障碍（barriers）及其如何帮助同步多个线程。
- en: 'The concept of the semaphore and its counterpart object in the pthread library:
    the POSIX semaphore. You are going to find out that mutexes are just binary semaphores.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号量的概念及其在 pthread 库中的对应对象：POSIX 信号量。您将发现互斥锁实际上是二进制信号量。
- en: The memory structure of a thread and how this structure can affect memory visibility
    in a multi-core system.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的内存结构和这种结构如何影响多核系统中的内存可见性。
- en: We start this chapter with a general talk about concurrency control. The following
    sections give you the necessary tools and constructs to write well-behaved multithreaded
    programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章开始，先对并发控制进行一般性讨论。接下来的几节将为您提供编写良好行为的多线程程序所需的工具和结构。
- en: POSIX concurrency control
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX 并发控制
- en: In this section, we are going to have a look at possible control mechanisms
    that are offered by the pthread library. Semaphores, mutexes, and condition variables
    alongside different types of locks are used in various combinations to bring determinism
    to multithreaded programs. First, we start with POSIX mutexes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 pthread 库提供的可能控制机制。信号量、互斥锁和条件变量以及不同类型的锁以各种组合使用，以使多线程程序具有确定性。首先，我们从
    POSIX 互斥锁开始。
- en: POSIX mutexes
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX 互斥锁
- en: The mutexes introduced in the pthread library can be used to synchronize both
    processes and threads. In this section, we are going to use them in a multithreaded
    C program in order to synchronize a number of threads.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: pthread 库中引入的互斥锁可以用于同步进程和线程。在本节中，我们将使用它们在多线程 C 程序中同步多个线程。
- en: As a reminder, a mutex is a semaphore that only allows one thread at a time
    to enter the critical section. Generally, a semaphore has the potential to let
    more than one thread enter its critical section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，互斥锁是一种信号量，它一次只允许一个线程进入临界区。通常，信号量有让多个线程进入其临界区的潜力。
- en: '**Note**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Mutexes are also called *binary semaphores* because they are semaphores that
    accept only two states.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁也被称为*二进制信号量*，因为它们是只接受两种状态的信号量。
- en: 'We start this section by resolving the data race issue observed as part of
    *example 15.3* in the previous chapter, using a POSIX mutex. The mutex only allows
    one thread at a time to enter the critical section and performs read and write
    operations on the shared variable. This way, it guarantees the data integrity
    of the shared variable. The following code box contains the solution to the data
    race issue:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从解决前一章中作为*示例15.3*一部分观察到的数据竞争问题开始本节，使用POSIX互斥锁。互斥锁一次只允许一个线程进入临界区，并对共享变量执行读写操作。这样，它保证了共享变量的数据完整性。以下代码框包含了解决数据竞争问题的解决方案：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 16-1 [ExtremeC_examples_chapter15_3_mutex.c]: Using a POSIX mutex
    to resolve the data race issue found as part of example 15.3 in the previous chapter'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框16-1 [ExtremeC_examples_chapter15_3_mutex.c]：使用POSIX互斥锁解决前一章中作为示例15.3一部分发现的数据竞争问题
- en: If you compile the preceding code and run it as many times as you like, you
    will see only `1 3` or `2 3` in the output. That's because we are using a POSIX
    mutex object to synchronize the critical sections in the preceding code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译前面的代码并运行多次，你将只看到输出中的`1 3`或`2 3`。那是因为我们正在使用POSIX互斥锁对象来同步前面代码中的临界区。
- en: At the beginning of the file, we have declared a global POSIX mutex object as
    `mtx`. Then inside the `main` function, we have initialized the mutex with default
    attributes using the function `pthread_mutex_init`. The second argument, which
    is `NULL`, could be custom attributes specified by the programmer. We will go
    through an example of how to set these attributes in the upcoming sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件开头，我们已声明一个全局POSIX互斥锁对象作为`mtx`。然后在`main`函数中，我们使用`pthread_mutex_init`函数使用默认属性初始化互斥锁。第二个参数是`NULL`，可以是程序员指定的自定义属性。我们将在接下来的章节中通过一个示例来了解如何设置这些属性。
- en: The mutex is used in both threads to protect the critical sections embraced
    between the the `pthread_mutex_lock(&mtx)` and `pthread_mutex_unlock(&mtx)` statements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁在两个线程中都被用来保护由`pthread_mutex_lock(&mtx)`和`pthread_mutex_unlock(&mtx)`语句包围的临界区。
- en: Finally, before leaving the `main` function, we destroy the mutex object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在离开`main`函数之前，我们销毁互斥锁对象。
- en: The first pair of `pthread_mutex_lock(&mtx)` and `pthread_mutex_unlock(&mtx)`
    statements, in the companion function `thread_body_1`, is making up the critical
    section for the first thread. Also, the second pair in the companion function
    `thread_body_2` is making up the critical section for the second thread. Both
    critical sections are protected by the mutex, and at each time, only one of the
    threads can be in its critical section and the other thread should wait outside
    of its critical section until the busy thread leaves.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在伴随函数`thread_body_1`中的第一对`pthread_mutex_lock(&mtx)`和`pthread_mutex_unlock(&mtx)`语句，构成了第一个线程的临界区。同样，伴随函数`thread_body_2`中的第二对构成了第二个线程的临界区。这两个临界区都由互斥锁保护，并且每次只有一个线程可以在其临界区中，而其他线程应该在临界区外等待，直到忙线程离开。
- en: As soon as a thread enters the critical section, it locks the mutex, and the
    other thread should wait behind the `pthread_mutex_lock(&mtx)` statement to have
    the mutex unlocked again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个线程进入临界区，它就会锁定互斥锁，而其他线程应该在`pthread_mutex_lock(&mtx)`语句后面等待，直到互斥锁再次解锁。
- en: By default, a thread waiting for a mutex to become unlocked goes into sleeping
    mode and doesn't do a *busy-wait*. But what if we wanted to do *busy-waiting*
    instead of going to sleep? Then we could use a *spinlock*. It would be enough
    to use the following functions instead of all the preceding mutex-related functions.
    Thankfully, pthread uses a consistent convention in naming the functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，等待互斥锁解锁的线程会进入睡眠模式，并且不会进行*忙等待*。但如果我们想进行*忙等待*而不是进入睡眠状态呢？那么我们可以使用*自旋锁*。只需要使用以下函数代替所有前面的互斥锁相关函数即可。幸运的是，pthread在函数命名上使用了一致的约定。
- en: The spinlock-related types and functions are as follows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与自旋锁相关的类型和函数如下。
- en: '`pthread_spin_t`: The type used for creating a spinlock object. It is similar
    to the `pthread_mutex_t` type.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_t`：用于创建自旋锁对象的类型。它类似于`pthread_mutex_t`类型。'
- en: '`pthread_spin_init`: Initializes a spinlock object. It is similar to `pthread_mutex_init`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_init`：初始化一个自旋锁对象。它类似于`pthread_mutex_init`。'
- en: '`pthread_spin_destroy`: Similar to `pthread_mutex_destory`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_destroy`：类似于`pthread_mutex_destory`。'
- en: '`pthread_spin_lock`: Similar to `pthread_mutex_lock`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_lock`：类似于`pthread_mutex_lock`。'
- en: '`pthread_spin_unlock`: Similar to `pthread_mutex_unlock`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_unlock`：类似于`pthread_mutex_unlock`。'
- en: As you see, it's pretty easy to just replace the preceding mutex types and functions
    with spinlock types and functions to have a different behavior, busy-waiting in
    this case, while waiting for a mutex object to become released.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只需用自旋锁类型和函数替换前面的互斥锁类型和函数，就可以很容易地实现不同的行为，在等待互斥锁对象释放时进行忙等待。
- en: In this section, we introduced POSIX mutexes and how they can be used to resolve
    a data race issue. In the next section, we will demonstrate how to use a condition
    variable in order to wait for a certain event to occur. We will be addressing
    the race condition that occurred in *example 15.2*, but we will make some modifications
    to the original example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了POSIX互斥锁及其如何用于解决数据竞争问题。在下一节中，我们将演示如何使用条件变量来等待某个事件的发生。我们将解决在**示例15.2**中发生的竞争条件，但我们将对原始示例进行一些修改。
- en: POSIX condition variables
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX条件变量
- en: If you remember from *example 15.2* in the previous chapter, we faced a race
    condition. Now, we want to bring up a new example that is very similar to *example
    15.2*, but one where it would be simpler to use a condition variable. *Example
    16.1* has two threads instead of three (which was the case for *example 15.2*),
    and they are required to print the characters `A` and `B` to the output, but we want
    them to be always in a specific order; first `A` and then `B`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章中的**示例15.2**，我们遇到了竞争条件。现在，我们想要提出一个新的例子，它与**示例15.2**非常相似，但在这个例子中，使用条件变量会更简单。*示例16.1*有两个线程而不是三个（这是**示例15.2**的情况），它们需要将字符`A`和`B`打印到输出，但我们希望它们始终按照特定的顺序；首先`A`然后是`B`。
- en: 'Our invariant constraint for this example is to *see first A and then B in
    the output* (plus data integrity for all shared states, no bad memory access,
    no dangling pointer, no crashes, and other obvious constraints). The following
    code demonstrates how we use a condition variable to come up with a working solution
    written in C for this example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个例子中的不变约束是要在输出中**首先看到A然后看到B**（以及所有共享状态的数据完整性，没有坏内存访问，没有悬垂指针，没有崩溃，以及其他明显的约束）。以下代码演示了我们如何使用条件变量来为这个例子提供一个用C语言编写的解决方案：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 16-2 [ExtremeC_examples_chapter16_1_cv.c]: Using a POSIX condition
    variable to dictate a specific order between two threads'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框16-2 [ExtremeC_examples_chapter16_1_cv.c]：使用POSIX条件变量来指定两个线程之间的特定顺序
- en: In the preceding code, it's good to use a structure in order to encapsulate
    the shared mutex, the shared condition variable, and the shared flag into a single
    entity. Note that we are only able to pass a single pointer to each thread. Therefore,
    we had to stack up the needed shared variables into a single structure variable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用一个结构体来封装共享互斥锁、共享条件变量和共享标志是一个好主意。请注意，我们只能为每个线程传递一个指针。因此，我们必须将所需的共享变量堆叠到一个单独的结构体变量中。
- en: 'As the second type definition (after `bool_t`) in the example, we have defined
    a new type, `shared_state_t`, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中的第二个类型定义（在`bool_t`之后），我们定义了一个新的类型，`shared_state_t`，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 16-3: Putting all shared variables required for example 16.1 into
    one structure'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框16-3：将示例16.1所需的所有共享变量放入一个结构体中
- en: After the type definitions, we defined two functions in order to initialize
    and destroy the `shared_state_t` instances. They can be thought of as the *constructor*
    and *destructor* functions for the type `shared_state_t` respectively. To read
    more about constructor and destructor functions, please refer to *Chapter 6*,
    *OOP and Encapsulation*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型定义之后，我们定义了两个函数来初始化和销毁`shared_state_t`实例。它们可以被认为是类型`shared_state_t`的**构造函数**和**析构函数**。要了解更多关于构造函数和析构函数的信息，请参阅*第6章*，*面向对象编程和封装*。
- en: This is how we use a condition variable. A thread can *wait* (or *sleep*) on
    a condition variable, and then in the future, it becomes notified to wake up.
    More than that, a thread can *notify* (or *wake up*) all other threads waiting
    (or sleeping) on a condition variable. All these operations *must* be protected
    by a mutex, and that's why you should always use a condition variable together
    with a mutex.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用条件变量的方法。一个线程可以在条件变量上**等待**（或**睡眠**），然后在将来，它会被通知醒来。不仅如此，一个线程还可以**通知**（或**唤醒**）所有其他在条件变量上等待（或睡眠）的线程。所有这些操作**必须**由互斥锁保护，这就是为什么你应该始终将条件变量与互斥锁一起使用。
- en: We did the very same in the preceding code. In our shared state object, we have
    a condition variable, together with a companion mutex that is supposed to protect
    the condition variable. To emphasize again, a condition variable is supposed to
    be used only in critical sections protected by its companion mutex.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面代码中也做了同样的事情。在我们的共享状态对象中，我们有一个条件变量，以及一个应该保护条件变量的伴随互斥锁。再次强调，条件变量应该只在由其伴随互斥锁保护的临界区中使用。
- en: So, what happens in the preceding code? In the thread that is supposed to print
    `A`, it tries to lock the `mtx` mutex using a pointer to the shared state object.
    When the lock is acquired, the thread prints `A`, it sets the flag `done`, and
    it finally notifies the other thread, which could be waiting on the condition
    variable `cv`, by calling the `pthread_cond_signal` function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，前面的代码中发生了什么？在应该打印 `A` 的线程中，它尝试使用指向共享状态对象的指针来锁定 `mtx` 互斥锁。当锁被获取后，线程打印 `A`，设置标志
    `done`，并最终通过调用 `pthread_cond_signal` 函数通知其他线程，该线程可能正在等待条件变量 `cv`。
- en: On the other hand, if in the meantime the second thread becomes active and the
    first thread has not printed `A` yet, the second thread tries to acquire the lock
    over `mtx`. If it succeeds, it checks the flag `done`, and if it's false, it simply
    means that the first thread has not entered its critical section yet (otherwise
    the flag should have been true). Therefore, the second thread waits on the condition
    variable and immediately releases the CPU by calling the `pthread_cond_wait` function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在此时第二个线程变得活跃，而第一个线程还没有打印 `A`，第二个线程将尝试获取 `mtx` 上的锁。如果成功，它会检查标志 `done`，如果它是假的，这仅仅意味着第一个线程还没有进入其临界区（否则标志应该是真的）。因此，第二个线程在条件变量上等待，并通过调用
    `pthread_cond_wait` 函数立即释放 CPU。
- en: It is very important to note that upon waiting on a condition variable, the
    associated mutex becomes released and the other thread can continue. Also, upon
    becoming active and exiting the waiting state, the associated mutex should be
    acquired again. For some good practice in condition variables, you could go through
    other possible interleavings.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，在等待条件变量时，相关的互斥锁被释放，其他线程可以继续。同样，在变得活跃并退出等待状态后，应该再次获取相关的互斥锁。对于条件变量的良好实践，你可以查看其他可能的交错情况。
- en: '**Note**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The function `pthread_cond_signal` can only be used to notify just one single
    thread. If you're going to notify all the threads waiting for a condition variable,
    you have to use the `pthread_cond_broadcast` function. We are going to give an
    example of this shortly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `pthread_cond_signal` 只能用来通知单个线程。如果你要通知所有等待条件变量的线程，你必须使用 `pthread_cond_broadcast`
    函数。我们很快就会给出一个例子。
- en: But why did we use a `while` loop for checking the flag `done` when it could
    be a simple `if` statement? That's because the second thread can be notified by
    other sources rather than just the first thread. In those cases, if the thread
    could obtain the lock over its mutex upon exiting the wait and become active again,
    it could check the loop's condition, and if it is not met yet, it should wait
    again. It is an accepted technique to wait for a condition variable inside a loop,
    until its condition matches what we are waiting for.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们使用 `while` 循环来检查标志 `done`，而不是一个简单的 `if` 语句呢？那是因为第二个线程可以由其他来源而不是仅仅由第一个线程通知。在这些情况下，如果线程在退出等待状态并再次变得活跃时能够获取其互斥锁，它可以检查循环的条件，如果条件尚未满足，它应该再次等待。在循环中等待条件变量是一种可接受的技术，直到其条件匹配我们等待的内容。
- en: The preceding solution satisfies the memory visibility constraint too. As we've
    explained in the previous chapters, all locking and unlocking operations are liable
    to trigger a memory coherence among various CPU cores; therefore, the values seen
    in different cached versions of the flag `done` are always recent and equal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案也满足了内存可见性约束。正如我们在前面的章节中解释的，所有锁定和解锁操作都可能触发各个 CPU 核之间的内存一致性；因此，在标志 `done`
    的不同缓存版本中看到的值总是最新且相同的。
- en: The race condition issue observed in examples 15.2 and 16.1 (in case of having
    no control mechanism in place), could also be resolved using POSIX barriers. In
    the next section, we are going to talk about them and rewrite *example 16.1* using
    a different approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子 15.2 和 16.1 中观察到的竞争条件问题（在没有控制机制的情况下），也可以使用 POSIX 障碍来解决。在下一节中，我们将讨论它们，并使用不同的方法重写
    *例子 16.1*。
- en: POSIX barriers
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX 障碍
- en: POSIX barriers use a different approach for synchronizing a number of threads.
    Just like a group of people who are planning to do some tasks in parallel and
    at some points need to rendezvous, reorganize, and continue, the same thing can
    happen for threads (or even processes). Some threads do their tasks faster, and
    others are slower. But there can be a checkpoint (or rendezvous point) at which
    all threads must stop and wait for the others to join them. These checkpoints
    can be simulated by using *POSIX barriers*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX屏障使用不同的方法来同步多个线程。就像一群人计划并行执行一些任务，并在某些时刻需要会合、重组并继续一样，线程（甚至进程）也可能发生类似的情况。有些线程完成任务更快，而有些则较慢。但是，可以有一个检查点（或会合点），所有线程都必须停止并等待其他线程加入。这些检查点可以通过使用*POSIX屏障*来模拟。
- en: 'The following code uses barriers to propose a solution to the issues seen in
    *example 16.1*. As a reminder, in *example 16.1*, we had two threads. One of them
    was to `print A`, and the other thread was to `print B`, and we wanted to always
    see `A` first and `B` second in the output, regardless of various interleavings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用屏障来解决在*示例16.1*中看到的问题。作为提醒，在*示例16.1*中，我们有两个线程。其中一个线程是`打印A`，另一个线程是`打印B`，我们希望无论各种交错如何，输出中总是先看到`A`然后是`B`：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 16-4 [ExtremeC_examples_chapter16_1_barrier.c]: A solution for example
    16.1 using POSIX barriers'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框16-4 [ExtremeC_examples_chapter16_1_barrier.c]：使用POSIX屏障解决示例16.1的解决方案
- en: As you can see, the preceding code is much smaller than the code we wrote using
    condition variables. Using POSIX barriers, it would be very easy to synchronize
    some threads at some certain points during their execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码比我们使用条件变量编写的代码要小得多。使用POSIX屏障，在执行过程中的一些特定点同步一些线程会非常容易。
- en: First, we have declared a global barrier object of type `pthread_barrier_t`.
    Then, inside the `main` function, we have initialized the barrier object using
    the function `pthread_barrier_init`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了一个全局屏障对象，其类型为`pthread_barrier_t`。然后，在`main`函数内部，我们使用`pthread_barrier_init`函数初始化了屏障对象。
- en: The first argument is a pointer to the barrier object. The second argument is
    the custom attributes of the barrier object. Since we are passing `NULL`, it means
    that the barrier object will be initialized using the default values for its attributes.
    The third argument is important; it is the number of threads that should become
    waiting on the same barrier object by calling the function `pthread_barrier_wait`
    and only after that are all of them released and allowed to continue.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是屏障对象的指针。第二个参数是屏障对象的自定义属性。由于我们传递了`NULL`，这意味着屏障对象将使用其属性的默认值进行初始化。第三个参数很重要；它是通过调用`pthread_barrier_wait`函数应该等待在同一个屏障对象上的线程数，只有在这之后，它们才会全部释放并被允许继续。
- en: For the preceding example, we set it to 2\. Therefore, only when there are two
    threads waiting on the barrier object, both of them are unblocked and they can
    continue. The rest of the code is pretty similar to previous examples, and has
    been explained in the previous section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的例子，我们将其设置为2。因此，只有当有两个线程在等待屏障对象时，它们才会被解锁并继续执行。其余的代码与前面的例子非常相似，并在上一节中进行了解释。
- en: A barrier object can be implemented using a mutex and a condition variable similar to
    what we did in the previous section. In fact, a POSIX-compliant operating system
    doesn't provide such a thing as a barrier in its system call interface, and most
    implementations are made using a mutex and a condition variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用互斥锁和条件变量来实现屏障对象，就像我们在上一节中所做的那样。事实上，符合POSIX规范的操作系统在其系统调用接口中并不提供屏障这样的东西，而大多数实现都是使用互斥锁和条件变量来完成的。
- en: That's basically why some operating systems like macOS does not provide implementations
    for POSIX barriers. The preceding code cannot be compiled in a macOS machine since
    the POSIX barrier functions are not defined. The preceding code is tested both
    in Linux and FreeBSD and works on both of them. Therefore, be careful about using
    barriers, because using them makes your code less portable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是为什么像macOS这样的操作系统不提供POSIX屏障的实现。前面的代码在macOS机器上无法编译，因为POSIX屏障函数未定义。前面的代码已在Linux和FreeBSD上测试，并在两者上都能正常工作。因此，在使用屏障时要小心，因为使用它们会使你的代码的可移植性降低。
- en: The fact that macOS doesn't provide POSIX barrier functions simply means that
    it is partially POSIX-compliant and the programs using barriers (which is standard
    of course) cannot be compiled on macOS machines. This is against the C philosophy,
    which is *to write once, and compile anywhere*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: macOS不提供POSIX屏障函数的事实仅仅意味着它是部分符合POSIX标准的，使用屏障的程序（当然，这是标准）无法在macOS机器上编译。这与C哲学相悖，即*一次编写，到处编译*。
- en: As the final note in this section, POSIX barriers guarantee memory visibility.
    Similarly to lock and unlock operations, waiting on barriers ensures that all
    the cached versions of the same variable are synchronized throughout various threads
    while they are going to leave the barrier point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一条注释，POSIX屏障保证了内存可见性。与锁定和解锁操作类似，等待屏障确保在离开屏障点时，各个线程中相同变量的所有缓存版本都同步。
- en: In the next section, we will be giving an example of semaphores. They are not
    used often in concurrent development, but they have their own special usages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将给出一个关于信号量的示例。它们在并发开发中并不常用，但它们有自己的特殊用途。
- en: A specific type of semaphore, binary semaphores (interchangeably referred to
    as mutexes), is used often and you have seen a number of examples relating to
    that in the previous sections.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特定的信号量类型，二进制信号量（可以互换地称为互斥锁），经常被使用，你已经在前面的章节中看到了许多相关的例子。
- en: POSIX semaphores
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX信号量
- en: In most cases, mutexes (or *binary semaphores*) are enough to synchronize a
    number of threads accessing a shared resource. That's because, in order to make
    read and write operations sequentially, only one thread should be able to enter
    the critical section at a time. It's known as *mutual exclusion*, hence, "mutex."
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，互斥锁（或*二进制信号量*）足以同步访问共享资源的多个线程。这是因为，为了使读写操作顺序进行，一次只能允许一个线程进入临界区。这被称为*互斥*，因此称为“mutex”。
- en: In some scenarios however, you might want to have more than one thread to enter
    the critical section and operate on the shared resource. This is the scenario
    in which you should use *general semaphores*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能希望有多个线程进入临界区并操作共享资源。这就是你应该使用*通用信号量*的场景。
- en: Before we go into an example regarding general semaphores, let's bring up an
    example regarding a binary semaphore (or a mutex). We won't be using the `pthread_mutex_*`
    functions in this example; instead, we will be using `sem_*` functions which are
    supposed to expose semaphore-related functionalities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入关于通用信号量的示例之前，让我们先举一个关于二进制信号量（或互斥锁）的例子。在这个例子中，我们不会使用`pthread_mutex_*`函数；相反，我们将使用`sem_*`函数，这些函数旨在公开与信号量相关的功能。
- en: Binary semaphores
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二进制信号量
- en: 'The following code is the solution made using semaphores for *example 15.3*.
    As a reminder, it involved two threads; each of them incrementing a shared integer
    by a different value. We wanted to protect the data integrity of the shared variable.
    Note that we won''t be using POSIX mutexes in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用信号量解决*示例15.3*的解决方案。提醒一下，它涉及两个线程；每个线程以不同的值递增共享整数。我们想要保护共享变量的数据完整性。注意，在以下代码中我们不会使用POSIX互斥锁：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 16-5 [ExtremeC_examples_chapter15_3_sem.c]: A solution for example
    15.3 using POSIX semaphores'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框16-5 [ExtremeC_examples_chapter15_3_sem.c]：使用POSIX信号量解决示例15.3的解决方案
- en: The first thing you might notice in the preceding code is the different semaphore
    functions that we've used in Apple systems. In Apple operating systems (macOS,
    OS X, and iOS), *unnamed semaphores* are not supported. Therefore, we couldn't
    just use `sem_init` and `sem_destroy` functions. Unnamed semaphores don't have
    names (surprisingly enough) and they can only be used inside a process, by a number
    of threads. Named semaphores, on the other hand, are system-wide and can be seen
    and used by various processes in the system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会首先注意到前面代码中我们使用的不同信号量函数。在Apple操作系统（macOS、OS X和iOS）中，*未命名信号量*不受支持。因此，我们无法直接使用`sem_init`和`sem_destroy`函数。未命名信号量没有名称（令人惊讶的是），它们只能在进程内部，由多个线程使用。另一方面，命名信号量是系统范围的，可以在系统中的各个进程中看到和使用。
- en: In Apple systems, the functions required for creating unnamed semaphores are
    marked as deprecated, and the semaphore object won't get initialized by `sem_init`.
    So, we had to use `sem_open` and `sem_close` functions in order to define named
    semaphores instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apple系统中，创建未命名信号量所需的函数已被标记为已弃用，并且信号量对象不会被`sem_init`初始化。因此，我们不得不使用`sem_open`和`sem_close`函数来定义命名信号量。
- en: Named semaphores are used to synchronize processes, and we will explain them
    in *Chapter 18*, *Process Synchronization*. In other POSIX-compliant operating
    systems, Linux specifically, we still can use unnamed semaphores and have them
    initialized and destroyed by using the `sem_init` and `sem_destroy` functions
    respectively.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 命名信号量用于同步进程，我们将在*第18章*，*进程同步*中解释它们。在其他POSIX兼容的操作系统上，特别是Linux，我们仍然可以使用无名称信号量，并使用`sem_init`和`sem_destroy`函数分别初始化和销毁它们。
- en: In the preceding code, we have included an extra header file, `semaphore.h`.
    As we've explained before, semaphores have been added as an extension to the POSIX
    threading library, and therefore, they are not exposed as part of the `pthread.h`
    header file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们包含了一个额外的头文件，`semaphore.h`。正如我们之前解释的，信号量作为POSIX线程库的扩展被添加，因此它们不是作为`pthread.h`头文件的一部分公开。
- en: After the header inclusion statements, we have declared a global pointer to
    a semaphore object. This pointer is going to point to a proper address addressing
    the actual semaphore object. We have to use a pointer here because, in Apple systems,
    we have to use the `sem_open` function, which returns a pointer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件包含语句之后，我们声明了一个指向信号量对象的全局指针。这个指针将指向一个适当的地址，该地址指向实际的信号量对象。在这里我们必须使用指针，因为在Apple系统中，我们必须使用`sem_open`函数，该函数返回一个指针。
- en: Then, inside the `main` function, and in Apple systems, we create a named semaphore
    `sem0`. In other POSIX-compliant operating systems, we initialize the semaphore
    using `sem_init`. Note that in this case the pointer `semaphore` points to the
    variable `local_sempahore` allocated on top of the main thread's Stack. The pointer
    `semaphore` won't become a dangling pointer because the main thread doesn't exit
    and waits for the threads to get complete by joining them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main`函数内部，在Apple系统中，我们创建了一个命名的信号量`sem0`。在其他POSIX兼容的操作系统上，我们使用`sem_init`初始化信号量。请注意，在这种情况下，指针`semaphore`指向在主线程栈上分配的变量`local_semaphore`。由于主线程不会退出并等待线程通过连接它们来完成，因此`semaphore`指针不会成为悬空指针。
- en: Note that we could distinguish between Apple and not - Apple systems by using
    the macro `__APPLE__`. This is a macro that is defined by default in C preprocessors
    being used in Apple systems. Therefore, we can rule out the code that is not supposed
    to be compiled on Apple systems by using this macro.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用宏`__APPLE__`来区分Apple和非Apple系统。这是一个在Apple系统中默认由C预处理器定义的宏。因此，我们可以通过使用这个宏来排除不应该在Apple系统上编译的代码。
- en: Let's look inside the threads. In companion functions, the critical sections
    are protected by `sem_wait` and `sem_post` functions which correspond to `pthread_mutex_lock`
    and `pthread_mutex_unlock` functions in the POSIX mutex API respectively. Note
    that `sem_wait` may allow more than one thread to enter the critical section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看线程内部的情况。在伴随函数中，关键部分由`sem_wait`和`sem_post`函数保护，这些函数分别对应于POSIX互斥锁API中的`pthread_mutex_lock`和`pthread_mutex_unlock`函数。请注意，`sem_wait`可能允许多个线程进入关键部分。
- en: The maximum number of threads that are allowed to be in the critical section
    is determined when initializing the semaphore object. We have passed the value
    `1` for the maximum number of threads as the last argument to the `sem_open` and
    `sem_init` functions; therefore, the semaphore is supposed to behave like a mutex.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在关键部分中的最大线程数是在初始化信号量对象时确定的。我们将`1`作为最大线程数传递给`sem_open`和`sem_init`函数的最后一个参数；因此，信号量应该表现得像互斥锁。
- en: To get a better understanding of semaphores, let's dive a bit more into the
    details. Each semaphore object has an integer value. Whenever a thread waits for
    a semaphore by calling the `sem_wait` function, if the semaphore's value is greater
    than zero, then the value is decreased by 1 and the thread is allowed to enter
    the critical section. If the semaphore's value is 0, the thread must wait until
    the semaphore's value becomes positive again. Whenever a thread exits the critical
    section by calling the `sem_post` function, the semaphore's value is incremented
    by 1\. Therefore, by specifying the initial value `1`, we will eventually get
    a binary semaphore.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解信号量，让我们更深入地探讨一下细节。每个信号量对象都有一个整数值。每当一个线程通过调用`sem_wait`函数等待信号量时，如果信号量的值大于零，则该值减1，线程被允许进入关键部分。如果信号量的值为0，线程必须等待直到信号量的值再次变为正数。每当一个线程通过调用`sem_post`函数退出关键部分时，信号量的值增加1。因此，通过指定初始值`1`，我们最终会得到一个二进制信号量。
- en: We end the preceding code by calling `sem_destroy` (or `sem_close` in Apple
    systems) which effectively releases the semaphore object with all its underlying
    resources. Regarding the named semaphores, since they can be shared among a number
    of processes, more complex scenarios can occur when closing a semaphore. We will
    cover these scenarios in *Chapter 18*, *Process Synchronization*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`sem_destroy`（或在Apple系统中使用`sem_close`）来结束前面的代码，这实际上释放了信号量对象及其所有底层资源。至于命名信号量，由于它们可以在多个进程之间共享，关闭信号量时可能会出现更复杂的场景。我们将在第18章*进程同步*中讨论这些场景。
- en: General semaphores
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用信号量
- en: Now, it's time to give a classic example that uses general semaphores. The syntax
    is pretty similar to the preceding code, but the scenario in which multiple threads
    are allowed to enter the critical section could be interesting.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候给出一个使用通用信号量的经典例子了。其语法与前面的代码非常相似，但允许多个线程进入临界区的场景可能很有趣。
- en: This classic example involves the creation of 50 water molecules. For 50 water
    molecules, you need to have 50 oxygen atoms and 100 hydrogen atoms. If we simulate
    each atom using a thread, we require two hydrogen threads, and one oxygen thread
    to enter their critical sections, in order to generate one water molecule and
    have it counted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个经典例子涉及了50个水分子的创建。对于50个水分子，你需要有50个氧原子和100个氢原子。如果我们用线程模拟每个原子，我们需要两个氢线程和一个氧线程进入它们的临界区，以便生成一个水分子并对其进行计数。
- en: In the following code, we firstly create 50 oxygen threads and 100 hydrogen
    threads. For protecting the oxygen thread's critical section, we use a mutex,
    but for the hydrogen threads' critical sections, we use a general semaphore that allows
    two threads to enter the critical section simultaneously.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们首先创建了50个氧线程和100个氢线程。为了保护氧线程的临界区，我们使用互斥锁，但对于氢线程的临界区，我们使用允许两个线程同时进入临界区的通用信号量。
- en: 'For signaling purposes, we use POSIX barriers, but since barriers are not implemented
    in Apple systems, we need to implement them using mutexes and condition variables.
    The following code box contains the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于信号量，我们使用POSIX屏障，但由于屏障在Apple系统中没有实现，我们需要使用互斥锁和条件变量来实现它们。下面的代码框包含了相应的代码：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 16-6 [ExtremeC_examples_chapter16_2.c]: Using a general semaphore
    to simulate the process of creating 50 water molecules out of 50 oxygen atoms
    and 100 hydrogen atoms'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框16-6 [ExtremeC_examples_chapter16_2.c]：使用通用信号量模拟从50个氧原子和100个氢原子中创建50个水分子的过程
- en: In the beginning of the code, there are a number of lines that are surrounded
    by `#ifdef __APPLE__` and `#endif`. These lines are only compiled in Apple systems.
    These lines are mainly the implementation and variables required for simulating
    POSIX barrier behavior. In other POSIX-compliant systems other than Apple, we
    use an ordinary POSIX barrier. We won't go through the details of the barrier
    implementation on Apple systems here, but it is worthwhile to read the code and understand
    it thoroughly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始部分，有一些被`#ifdef __APPLE__`和`#endif`包围的行。这些行只在Apple系统中编译。这些行主要是模拟POSIX屏障行为的实现和变量。在其他除了Apple之外的POSIX兼容系统中，我们使用普通的POSIX屏障。在这里我们不会深入讲解Apple系统中屏障实现的细节，但阅读并彻底理解代码是很有价值的。
- en: As part of a number of global variables defined in the preceding code, we have
    declared the mutex `oxygen_mutex`, which is supposed to protect the oxygen threads'
    critical sections. At each time, only one oxygen thread (or oxygen atom) can enter
    the critical section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面代码中定义的多个全局变量的一部分，我们声明了互斥锁`oxygen_mutex`，它应该保护氧线程的临界区。在任何时候，只有一个氧线程（或氧原子）可以进入临界区。
- en: Then in its critical section, an oxygen thread waits for two other hydrogen
    threads to join and then it continues to increment the water molecule counter.
    The increment happens within the oxygen's critical section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在它的临界区中，一个氧线程等待两个其他氢线程加入，然后它继续增加水分子计数器。增加操作发生在氧的临界区内部。
- en: To elaborate more on the things that happen inside the critical sections, we
    need to explain the role of the general semaphore. In the preceding code, we have
    also declared the general semaphore `hydrogen_sem`, which is supposed to protect
    hydrogen threads' critical sections. At each time, only a maximum of two hydrogen
    threads can enter their critical sections, and they wait on the barrier object
    shared between the oxygen and hydrogen threads.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地解释在关键部分内部发生的事情，我们需要解释通用信号量的作用。在前面的代码中，我们已声明了通用信号量 `hydrogen_sem`，它应该用来保护氢线程的关键部分。在任何时候，最多只能有两个氢线程进入它们的关键部分，并且它们在氧气和氢线程之间共享的屏障对象上等待。
- en: 'When the number of waiting threads on the shared barrier object reaches two,
    it means that we have got one oxygen and two hydrogens, and then voilà: a water
    molecule is made, and all waiting threads can continue. Hydrogen threads exit
    immediately, but the oxygen thread exists only after incrementing the water molecules
    counter.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待在共享屏障对象上的线程数量达到两个时，这意味着我们有一个氧原子和两个氢原子，然后 voilà：一个水分子就形成了，所有等待的线程都可以继续。氢线程立即退出，但氧线程只有在增加水分子计数器之后才会退出。
- en: We close this section with this last note. In *example 16.2*, we used the `pthread_cond_broadcast`
    function when implementing the barriers for Apple systems. It signals all threads
    waiting on the barrier's condition variable that are supposed to continue after
    having other threads joining them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这个最后的笔记结束本节。在 *示例 16.2* 中，我们在为苹果系统实现屏障时使用了 `pthread_cond_broadcast` 函数。它向所有等待屏障条件变量的线程发出信号，这些线程在其他线程加入后应该继续执行。
- en: In the next section, we are going to talk about the memory model behind POSIX
    threads and how they interact with their owner process's memory. We will also
    look at examples about using the Stack and Heap segments and how they can lead
    to some serious memory-related issues.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 POSIX 线程背后的内存模型以及它们如何与它们所属进程的内存交互。我们还将查看使用栈和堆段的示例以及它们如何导致一些严重的内存相关问题。
- en: POSIX threads and memory
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX 线程和内存
- en: This section is going to talk about the interactions between the threads and
    the process's memory. As you know, there are multiple segments in a process's
    memory layout. The Text segment, Stack segment, Data segment, and Heap segment
    are all part of this memory layout, and we covered them in *Chapter 4*, *Process
    Memory Structure*. Threads interact differently with each of these memory segments.
    As part of this section, we only discuss Stack and Heap memory regions because
    they are the most used and problematic areas when writing multithreaded programs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论线程与进程内存之间的交互。正如你所知，进程的内存布局中有多个段。文本段、栈段、数据段和堆段都是这个内存布局的一部分，我们在 *第 4 章*，*进程内存结构*
    中讨论了它们。线程与这些内存段中的每一个都有不同的交互。作为本节的一部分，我们只讨论栈和堆内存区域，因为它们是在编写多线程程序时最常用且最容易出现问题的区域。
- en: In addition, we discuss how thread synchronization and a true understanding
    of the memory model behind a thread can help us develop better concurrent programs.
    These concepts are even more evident regarding the Heap memory because the memory
    management is manual there and in a concurrent system, threads are responsible
    for allocating and releasing Heap blocks. A trivial race condition can cause serious
    memory issues, therefore proper synchronization should be in place to avoid such
    disasters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们讨论了线程同步以及真正理解线程背后的内存模型如何帮助我们开发更好的并发程序。这些概念在堆内存方面尤为明显，因为那里的内存管理是手动的，并且在并发系统中，线程负责分配和释放堆块。一个简单的竞态条件可能导致严重的内存问题，因此必须实施适当的同步以避免此类灾难。
- en: In the next subsection, we are going to explain how the Stack segment is accessed
    by different threads and what precautions should be taken.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将解释不同的线程如何访问栈段以及应该采取哪些预防措施。
- en: Stack memory
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈内存
- en: Each thread has its own Stack region that is supposed to be private to that
    thread only. A thread's Stack region is part of the owner process's Stack segment
    and all threads, by default, should have their Stack regions allocated from the
    Stack segment. It is also possible that a thread has a Stack region that is allocated
    from the Heap segment. We will show in future examples how to do this, but for
    now, we assume that a thread's Stack is part of the process's Stack segment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的栈区域，这个区域应该是仅对该线程私有的。线程的栈区域是所属进程的栈段的一部分，并且默认情况下，所有线程都应该从栈段分配其栈区域。也有可能线程有一个从堆段分配的栈区域。我们将在未来的例子中展示如何做到这一点，但到目前为止，我们假设线程的栈是进程的栈段的一部分。
- en: Since all threads within the same process can read and modify the process's
    Stack segment, they can effectively read and modify each other's Stack regions,
    but they *should not*. Note that working with other threads' Stack regions is
    considered dangerous behavior because the variables defined on top of the various
    Stack regions are subject to deallocation at any time, especially when a thread
    exits or a function returns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同一进程中的所有线程都可以读取和修改进程的栈段，因此它们可以有效地读取和修改彼此的栈区域，但它们*不应该*这样做。请注意，与其他线程的栈区域一起工作被认为是一种危险的行为，因为定义在各个栈区域顶部的变量可能随时被释放，尤其是在线程退出或函数返回时。
- en: That's why we try to assume that a Stack region is only accessible by its owner
    thread and not by the other threads. So, *local variables* (those variables declared
    on top the Stack) are considered to be private to the thread and should not be
    accessed by other threads.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们试图假设一个栈区域只能被其所属线程访问，而不能被其他线程访问。因此，*局部变量*（那些在栈顶部声明的变量）被认为是线程私有的，不应该被其他线程访问。
- en: In single-threaded applications, we have always one thread which is the main
    thread. Therefore, we use its Stack region like we use the process's Stack segment.
    That's because, in a single-threaded program, there is no boundary between the
    main thread and the process itself. But the situation is different for a multithreaded
    program. Each thread has its own Stack region which is different from another
    thread's Stack region.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程应用程序中，我们始终只有一个线程，即主线程。因此，我们像使用进程的栈段一样使用其栈区域。这是因为，在单线程程序中，主线程和进程本身之间没有界限。但对于多线程程序来说，情况就不同了。每个线程都有自己的栈区域，这个区域与其他线程的栈区域不同。
- en: When creating a new thread, a memory block is allocated for the Stack region.
    If not specified by the programmer upon creation, the Stack region will have a default
    Stack Size, and it will be allocated from the Stack segment of the process. The
    default Stack size is platform dependent and varies from one architecture to another.
    You can use the command `ulimit -s` to retrieve the default Stack size in a POSIX-compliant
    system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新线程时，会为栈区域分配一个内存块。如果程序员在创建时没有指定，栈区域将具有默认的栈大小，并且它将从进程的栈段中分配。默认栈大小是平台相关的，并且因架构而异。您可以使用命令`ulimit
    -s`在POSIX兼容系统中检索默认栈大小。
- en: 'On my current platform, which is macOS on an Intel 64-bit machine, the default
    Stack size is 8 MB:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我当前的平台上，这是一个基于Intel 64位机器的macOS，默认栈大小是8 MB：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 16-1: Reading the default Stack size'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 16-1：读取默认栈大小
- en: 'The POSIX threading API allows you to set the Stack region for a new thread.
    In the following example, *example 16.3*, we have two threads. For one of them,
    we use the default Stack settings, and for the other one, we will allocate a buffer
    from the Heap segment and set it as the Stack region of that thread. Note that,
    when setting the Stack region, the allocated buffer should have a minimum size;
    otherwise it cannot be used as a Stack region:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX线程API允许你为新的线程设置栈区域。在下面的例子，*示例16.3*中，我们有两个线程。对于其中一个线程，我们使用默认的栈设置，而对于另一个线程，我们将从堆段分配一个缓冲区并将其设置为该线程的栈区域。请注意，在设置栈区域时，分配的缓冲区应该有一个最小大小；否则它不能用作栈区域：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 16-7 [ExtremeC_examples_chapter16_3.c]: Setting a Heap block as a
    thread''s Stack region'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 16-7 [ExtremeC_examples_chapter16_3.c]：将堆块设置为线程的栈区域
- en: To start the program, we create the first thread with the default Stack settings.
    Therefore, its Stack should be allocated from the Stack segment of the process.
    After that, we create the second thread by specifying the memory address of a buffer
    supposed to be the Stack region of the thread.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动程序，我们使用默认的堆栈设置创建第一个线程。因此，其堆栈应该从进程的堆栈段分配。之后，我们通过指定一个缓冲区的内存地址来创建第二个线程，该缓冲区应作为线程的堆栈区域。
- en: Note that the specified size is `100` bytes more than the already defined minimum
    Stack size indicated by the `PTHREAD_STACK_MIN` macro. This constant has different
    values on different platforms, and it is included as part of the header file `limits.h`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，指定的尺寸比由`PTHREAD_STACK_MIN`宏指示的已定义最小堆栈大小多`100`字节。这个常量在不同的平台上有不同的值，它包含在头文件`limits.h`中。
- en: 'If you build the preceding program and run it on a Linux device, you will see
    something like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建前面的程序并在Linux设备上运行它，你将看到以下类似的内容：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 16-2: Building and running example 16.3'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 16-2：构建和运行示例 16.3
- en: As is clear from the output seen in *Shell Box 16-2*, the address of the local
    variable `local_var` that is allocated on top of the second thread's Stack belongs
    to a different address range (the range of the Heap space). This means that the
    Stack region of the second thread is within the Heap. This is not true for the
    first thread, however.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Shell Box 16-2*中看到的输出所示，分配在第二个线程堆栈顶部的局部变量`local_var`的地址属于不同的地址范围（堆空间的范围）。这意味着第二个线程的堆栈区域在堆内。然而，这并不适用于第一个线程。
- en: As the output shows, the address of the local variable in the first thread falls
    within the address range of the Stack segment of the process. As a result, we
    could successfully set a new Stack region allocated from the Heap segment, for a newly
    created thread.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，第一个线程中局部变量的地址位于进程堆栈段的地址范围内。因此，我们可以成功地为新创建的线程分配一个从堆段分配的新堆栈区域。
- en: The ability to set the Stack region of a thread can be crucial in some use cases.
    For example, in memory-constrained environments where the total amount of memory
    is low for having big Stacks, or in high-performance environments in which the
    cost of allocating the Stack for each thread cannot be tolerated, using some preallocated
    buffers can be useful and the preceding procedure can be employed to set a preallocated
    buffer as the Stack region of a newly created thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 设置线程堆栈区域的能力在某些用例中可能至关重要。例如，在内存受限的环境中，由于总内存量低，无法拥有大的堆栈，或者在性能要求高的环境中，无法容忍为每个线程分配堆栈的成本，使用一些预分配的缓冲区可能很有用，并且可以使用前面的过程将预分配的缓冲区设置为新创建线程的堆栈区域。
- en: The following example demonstrates how sharing an address in one thread's Stack
    can lead to some memory issues. When an address from a thread is shared, the thread
    should remain alive otherwise all pointers keeping that address become dangling.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在某个线程的堆栈中共享一个地址如何导致一些内存问题。当一个线程的地址被共享时，该线程应该保持活动状态，否则所有保持该地址的指针都将悬空。
- en: 'The following code is not thread-safe, therefore we expect to see crashes from
    time to time in successive runs. The threads also have the default Stack settings
    which means their Stack regions are allocated from the process''s Stack segment:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码不是线程安全的，因此我们预计在连续运行中会不时出现崩溃。线程也有默认的堆栈设置，这意味着它们的堆栈区域是从进程的堆栈段分配的：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 16-8 [ExtremeC_examples_chapter16_4.c]: Trying to read a variable
    allocated from another thread''s Stack region'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 16-8 [ExtremeC_examples_chapter16_4.c]：尝试读取从另一个线程的堆栈区域分配的变量
- en: At the beginning, we have declared a global shared pointer. Since it is a pointer,
    it can accept any address regardless of where the address points to in the process's
    memory layout. It could be from the Stack segment or the Heap segment or even
    the Data segment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们声明了一个全局共享指针。由于它是一个指针，它可以接受任何地址，无论该地址指向进程内存布局中的哪个位置。它可能来自堆栈段、堆段，甚至是数据段。
- en: In the preceding code, inside the `t1_body` companion function, we store the
    address of a local variable in the shared pointer. This variable belongs to the
    first thread, and it is allocated on top of the first thread's Stack.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`t1_body`伴随函数内部，我们将局部变量的地址存储在共享指针中。这个变量属于第一个线程，并且它是在第一个线程的堆栈顶部分配的。
- en: From now on, if the first thread exits, the shared pointer becomes dangling,
    and any dereferencing probably leads to a crash, a logical error, or a hidden
    memory issue in the best case. In some interleavings, this would happen, and you
    see crashes from time to time if you run the preceding program multiple times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果第一个线程退出，共享指针就会变成悬垂指针，任何解引用可能都会导致崩溃、逻辑错误或最坏情况下的隐藏内存问题。在某些交错中，这可能会发生，如果你多次运行前面的程序，你可能会时不时地看到崩溃。
- en: As an important note, proper synchronization techniques should be employed if
    one thread is willing to use a variable allocated from another thread's Stack
    region. Since the lifetime of a Stack variable is bound to its scope, the synchronization
    should aim at keeping the scope alive until the consumer thread is done with the
    variable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个重要的注意事项，如果某个线程打算使用从另一个线程的栈区域分配的变量，应该采用适当的同步技术。由于栈变量的生命周期与其作用域绑定，同步应该旨在保持作用域活跃，直到消费者线程完成对该变量的使用。
- en: Note that for simplicity we didn't check the results of the pthread functions.
    It is always advised to do so and check the return values. Not all pthread functions
    behave the same on different platforms; if something goes wrong, you will become
    aware by checking the return values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了简单起见，我们没有检查pthread函数的结果。始终建议这样做并检查返回值。并非所有pthread函数在不同平台上的行为都相同；如果出现问题，通过检查返回值你会意识到这一点。
- en: In this section, generally speaking, we showed why the addresses belonging to
    Stack regions shouldn't be shared, and why shared states better not be allocated
    from Stack regions. The next section talks about Heap memory, which is the most
    common place for storing shared states. As you might have guessed, working with
    the Heap is also tricky, and you should be careful about memory leaks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，一般来说，我们展示了为什么栈区域所属的地址不应该共享，以及为什么最好不要从栈区域分配共享状态。下一节将讨论堆内存，这是存储共享状态最常见的地方。正如你可能已经猜到的，与堆一起工作也很棘手，你应该小心内存泄漏。
- en: Heap memory
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆内存
- en: The Heap segment and the Data segment are accessible by all threads. Unlike
    the Data segment, which is generated at compile time, the Heap segment is dynamic,
    and it is shaped at runtime. Threads can both read and modify the contents of
    the Heap. In addition, the contents of the Heap can stay as long as the process
    lives, and stay independent of the lifetime of the individual threads. Also, big
    objects can be put inside the Heap. All these factors together have caused the
    Heap to be a great place for storing states that are going to be shared among
    some threads.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 堆段和数据段对所有线程都是可访问的。与在编译时生成的数据段不同，堆段是动态的，它在运行时形成。线程可以读取和修改堆的内容。此外，堆的内容可以持续到进程的生命周期，并且与单个线程的生命周期独立。此外，大对象可以放入堆中。所有这些因素共同导致堆成为存储将要由一些线程共享的状态的绝佳地方。
- en: Memory management becomes a nightmare when it comes to Heap allocation, and
    that is because of the fact that allocated memory should be deallocated at some
    point by one of the running threads otherwise it could lead to memory leaks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到堆分配时，内存管理变得像噩梦一样，这是因为分配的内存应该在某个时刻由运行中的某个线程释放，否则可能会导致内存泄漏。
- en: Regarding concurrent environments, interleavings can easily produce dangling
    pointers; hence crashes show up. The critical role of synchronization is to put
    things in a specific order where no dangling pointer can be produced, and this
    is the hard part.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于并发环境，交错很容易产生悬垂指针；因此会出现崩溃。同步的关键作用是将事物置于特定的顺序，这样就不会产生悬垂指针，这是难点。
- en: Let's look at the following example, *example 16.5*. There are five threads
    in this example. The first thread allocates an array from the Heap. The second
    and third threads populate the array in this form. The second thread populates
    the even indices in the array with the capital alphabet letters starting from
    *Z* and moving backward to *A*, and the third thread populates the odd indices
    with small alphabet letters starting from *a* and moving forward to *z*. The fourth
    thread prints the array. And finally, the fifth thread deallocates the array and
    reclaims the Heap memory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看以下示例，*示例16.5*。在这个例子中有五个线程。第一个线程从堆中分配一个数组。第二个和第三个线程以这种形式填充数组。第二个线程将数组中的偶数索引填充为大写字母，从*Z*开始向后移动到*A*，第三个线程将奇数索引填充为小写字母，从*a*开始向前移动到*z*。第四个线程打印数组。最后，第五个线程释放数组并回收堆内存。
- en: 'All the techniques described in the previous sections about POSIX concurrency
    control should be employed in order to keep these threads from misbehaving within
    the Heap. The following code has no control mechanism in place, and obviously,
    it is not thread-safe. Note that the code is not complete. The complete version
    with the concurrency control mechanisms in place will come in the next code box:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些线程在堆空间中表现不当，应使用前几节中描述的所有关于 POSIX 并发控制的技巧。以下代码没有设置任何控制机制，显然，它不是线程安全的。请注意，代码并不完整。带有并发控制机制的完整版本将在下一个代码块中给出：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 16-9 [ExtremeC_examples_chapter16_5_raw.c]: Example 16.5 without any
    synchronization mechanism in place'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 16-9 [ExtremeC_examples_chapter16_5_raw.c]：没有同步机制的 16.5 示例
- en: It is easy to see that the preceding code is not thread-safe and it causes serious
    crashes because of the interference of the deallocator thread in deallocating
    the array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，前面的代码不是线程安全的，并且由于分配器线程在释放数组时发生干扰，导致严重的崩溃。
- en: Whenever the deallocator thread obtains the CPU, it frees the Heap-allocated
    buffer immediately, and after that the pointer `shared_array` becomes dangling,
    and other threads start to crash. Proper synchronization techniques should be
    used to ensure that the deallocation thread runs last and the proper order of
    logic in different threads are run.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配器线程获得 CPU 时，它会立即释放堆分配的缓冲区，之后指针 `shared_array` 变得悬空，其他线程开始崩溃。应使用适当的同步技术来确保分配器线程最后运行，并且不同线程的逻辑顺序正确。
- en: 'In the following code block, we decorate the preceding code with POSIX concurrency
    control objects to make it thread-safe:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们使用 POSIX 并发控制对象装饰前面的代码，使其线程安全：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 16-10 [ExtremeC_examples_chapter16_5.c]: Example 16.5 with synchronization
    mechanisms in place'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 16-10 [ExtremeC_examples_chapter16_5.c]：带有同步机制的 16.5 示例
- en: To make the code found in *Code Box 16-9* thread-safe, we have only used the
    POSIX barriers in the new code. It is the easiest approach to form a sequential
    execution order between a number of threads.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 *代码框 16-9* 中的代码线程安全，我们只使用了新的代码中的 POSIX 障碍。这是在多个线程之间形成顺序执行顺序的最简单方法。
- en: If you compare *Code Boxes 16-9* and *16-10*, you see how POSIX barriers are
    used to impose an order between various threads. The only exception is between
    two filler threads. The filler threads can be running independently without blocking
    each other, and since they are changing odd and even indices separately, no concurrent
    issue can be raised. Note that the preceding code cannot be compiled on Apple
    systems. You need to simulate the barrier behavior using mutexes and condition
    variables in these systems (as we did for *example 16.2*).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较 *代码框 16-9* 和 *16-10*，你会看到 POSIX 障碍是如何在各个线程之间强加顺序的。唯一的例外是在两个填充线程之间。填充线程可以独立运行而不会相互阻塞，并且由于它们分别改变奇数和偶数索引，不会引发并发问题。请注意，前面的代码不能在苹果系统上编译。你需要在这些系统中使用互斥锁和条件变量来模拟障碍行为（就像我们在
    *示例 16.2* 中做的那样）。
- en: 'The following is the output of the preceding code. No matter how many times
    you run the program, it never crashes. In other words, the preceding code is guarded
    against the various interleavings, and it is thread-safe:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应代码的输出。无论你运行程序多少次，它都不会崩溃。换句话说，前面的代码可以防止各种交错，并且是线程安全的：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Shell Box 16-3: Building and running example 16.5'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本框 16-3：构建和运行 16.5 示例
- en: In this section, we gave an example of using the Heap space as a place holder
    for shared states. Unlike the Stack memory, where memory deallocation happens
    automatically, Heap space deallocation should be performed explicitly. Otherwise,
    memory leaks are an imminent side effect.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们给出了使用堆空间作为共享状态占位符的示例。与自动进行内存释放的栈内存不同，堆空间的内存释放应显式执行。否则，内存泄漏将是一个不可避免的副作用。
- en: The easiest and sometimes the best available place to keep the shared states,
    in terms of least memory management effort for the programmer, is the Data segment
    in which both allocation and deallocation happen automatically. Variables residing
    in the Data segment are considered global, and have the longest possible lifetime,
    from the very beginning moments of the process's birth until its very last moments.
    But this long lifetime can be considered negative in certain use cases, especially
    when you're going to keep a big object in the Data segment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员最少的内存管理努力的角度来看，最容易且有时也是最佳的可共享状态存储位置是数据段，其中分配和释放都是自动发生的。位于数据段中的变量被认为是全局的，并且具有可能的最长生命周期，从进程诞生的最初时刻到其最后的时刻。但这个长生命周期在某些用例中可能被视为负面因素，尤其是在你打算在数据段中保持一个大对象时。
- en: In the next section, we will talk about memory visibility and how POSIX functions
    guarantee that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论内存可见性以及POSIX函数如何保证这一点。
- en: Memory visibility
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存可见性
- en: We explained *memory visibility* and *cache coherency* in the previous chapters,
    regarding the systems with more than one CPU core. In this section, we want to look
    at the pthread library and see how it guarantees memory visibility.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中解释了*内存可见性*和*缓存一致性*，涉及具有多个CPU核心的系统。在本节中，我们想看看pthread库，看看它是如何保证内存可见性的。
- en: As you know, a cache coherency protocol among CPU cores ensures that all cached
    versions of a single memory address in all CPU cores remain synchronized and updated
    regarding the latest changes made in one of the CPU cores. But this protocol should
    be triggered somehow.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，CPU核心之间的缓存一致性协议确保所有CPU核心中单个内存地址的所有缓存版本都保持同步并更新，以反映其中一个CPU核心所做的最新更改。但这个协议需要以某种方式触发。
- en: There are APIs in the system call interface to trigger the cache coherency protocol
    and make the memory visible to all CPU cores. In pthread also, there are a number
    of functions that guarantee the memory visibility before their execution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用接口中存在API来触发缓存一致性协议，并使内存对所有CPU核心可见。在pthread中，也有许多函数在执行前保证内存可见性。
- en: 'You may have encountered some of these functions before. A list of them is
    presented below:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前遇到过一些这些函数。下面列出了它们的一些列表：
- en: '`pthread_barrier_wait`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_barrier_wait`'
- en: '`pthread_cond_broadcast`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_cond_broadcast`'
- en: '`pthread_cond_signal`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_cond_signal`'
- en: '`pthread_cond_timedwait`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_cond_timedwait`'
- en: '`pthread_cond_wait`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_cond_wait`'
- en: '`pthread_create`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_create`'
- en: '`pthread_join`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_join`'
- en: '`pthread_mutex_lock`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_lock`'
- en: '`pthread_mutex_timedlock`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_timedlock`'
- en: '`pthread_mutex_trylock`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_trylock`'
- en: '`pthread_mutex_unlock`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_unlock`'
- en: '`pthread_spin_lock`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_lock`'
- en: '`pthread_spin_trylock`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_trylock`'
- en: '`pthread_spin_unlock`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_spin_unlock`'
- en: '`pthread_rwlock_rdlock`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_rdlock`'
- en: '`pthread_rwlock_timedrdlock`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_timedrdlock`'
- en: '`pthread_rwlock_timedwrlock`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_timedwrlock`'
- en: '`pthread_rwlock_tryrdlock`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_tryrdlock`'
- en: '`pthread_rwlock_trywrlock`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_trywrlock`'
- en: '`pthread_rwlock_unlock`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_unlock`'
- en: '`pthread_rwlock_wrlock`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_rwlock_wrlock`'
- en: '`sem_post`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sem_post`'
- en: '`sem_timedwait`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sem_timedwait`'
- en: '`sem_trywait`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sem_trywait`'
- en: '`sem_wait`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sem_wait`'
- en: '`semctl`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semctl`'
- en: '`semop`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semop`'
- en: Other than local caches in CPU cores, the compilers can also introduce caching
    mechanisms for the frequently used variables. For this to happen, the compiler
    needs to analyze the code and optimize it in a way that means frequently used
    variables are written to and read from the compiler caches. These are software
    caches that are put in the final binary by the compiler in order to optimize and
    boost the execution of the program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CPU核心中的本地缓存之外，编译器还可以为常用变量引入缓存机制。为了实现这一点，编译器需要分析代码并以一种方式优化它，即频繁使用的变量被写入和读取到编译器缓存中。这些是由编译器放入最终二进制文件中的软件缓存，以优化和提升程序的执行。
- en: While these caches can be beneficial, they potentially add another headache
    while writing multithreaded code and raise some memory visibility issues. Therefore,
    sometimes these caches must be disabled for specific variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些缓存可能有益，但它们在编写多线程代码时可能会增加另一个头疼的问题，并引发一些内存可见性问题。因此，有时必须禁用特定变量的这些缓存。
- en: 'The variables that are not supposed to be optimized by the compiler via caching
    can be declared as *volatile*. Note that a volatile variable still can be cached
    at the CPU level, but the compiler won''t optimize it by keeping it in compiler
    caches. A variable can be declared as volatile using the keyword `volatile`. Following
    is a declaration of an integer that is volatile:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该被编译器通过缓存优化的变量可以声明为 *易失性*。请注意，易失性变量仍然可以在 CPU 级别被缓存，但编译器不会通过将其保留在编译器缓存中来进行优化。可以使用关键字
    `volatile` 声明一个易失性变量。以下是一个易失性整型变量的声明：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 16-11: Declaring a volatile integer variable'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 16-11：声明一个易失性整型变量
- en: The important thing about volatile variables is that they don't solve the memory
    visibility problems in multi-threaded systems. In order to solve this issue, you
    need to use the preceding POSIX functions in their proper places in order to ensure
    memory visibility.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 易失性变量的重要之处在于它们并不能解决多线程系统中的内存可见性问题。为了解决这个问题，你需要正确地使用前面提到的 POSIX 函数，以确保内存可见性。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we covered the concurrent control mechanisms provided by the
    POSIX threading API. We have discussed:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 POSIX 线程 API 提供的并发控制机制。我们讨论了：
- en: POSIX mutexes and how they should be used
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 互斥锁及其使用方法
- en: POSIX condition variables and barriers and how they should be used
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 条件变量和屏障及其使用方法
- en: POSIX semaphores, and how binary semaphores and general semaphores differ
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 信号量和它们如何与二进制信号量和通用信号量不同
- en: How threads interact with the Stack region
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程如何与栈区域交互
- en: How to define a new Heap-allocated Stack region for a thread
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为线程定义一个新的堆分配的栈区域
- en: How threads interact with the Heap space
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程如何与堆空间交互
- en: Memory visibility and POSIX functions that guarantee memory visibility
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存可见性和保证内存可见性的 POSIX 函数
- en: Volatile variables and compiler caches
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易失性变量和编译器缓存
- en: 'In the next chapter, we will continue our discussion and we will talk about
    another approach for having concurrency in a software system: multi-processing.
    We will discuss how a process can be executed and how it is different from a thread.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的讨论，我们将讨论在软件系统中实现并发性的另一种方法：多进程。我们将讨论进程的执行方式以及它与线程的不同之处。
