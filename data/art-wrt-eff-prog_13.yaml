- en: '*Chapter 10*: Compiler Optimizations in C++'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：C++中的编译器优化'
- en: In the last chapter, we have learned about the major sources of inefficiency
    in C++ programs. The burden of removing these inefficiencies mostly falls on the
    programmer. However, there is also much that can be done by the compiler to make
    your programs faster. That is what we are going to explore now.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经了解了C++程序中效率低下的主要原因。消除这些低效性的责任大部分落在程序员身上。然而，编译器也可以通过许多方式使您的程序运行更快。这就是我们现在要探讨的内容。
- en: This chapter will cover the very important matter of compiler optimizations
    and how the programmer can help the compiler to generate more efficient code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖编译器优化的非常重要的问题，以及程序员如何帮助编译器生成更高效的代码。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: How the compilers approach optimizing the code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器优化代码的方法
- en: Restrictions on compiler optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器优化的限制
- en: How to get the best optimizations from the compiler
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从编译器获得最佳优化
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Again, you will need a C++ compiler and a micro-benchmarking tool, such as the
    **Google Benchmark** library we used in the previous chapter (found at [https://github.com/google/benchmark](https://github.com/google/benchmark)).
    The code accompanying this chapter can be found at [https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter10](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter10).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您将需要一个C++编译器和一个微基准测试工具，比如我们在上一章中使用的**Google Benchmark**库（在[https://github.com/google/benchmark](https://github.com/google/benchmark)找到）。本章附带的代码可以在[https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter10](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter10)找到。
- en: You will also need a way to examine the assembly code generated by the compiler.
    Many development environments have an option to display assembly, GCC and Clang
    can write out the assembly instead of the object code, debuggers and other tools
    can generate assembly from the object code (disassemble it). It's a matter of
    personal preference which tool you use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一种方法来检查编译器生成的汇编代码。许多开发环境都有显示汇编代码的选项，GCC和Clang可以写出汇编而不是目标代码，调试器和其他工具可以从目标代码生成汇编（反汇编）。您可以根据个人偏好选择使用哪种工具。
- en: Compilers optimizing code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器优化代码
- en: 'The optimizing compiler is critically important for achieving high performance.
    Just try running a program compiled with no optimization at all to appreciate
    the role of the compiler: it is not uncommon for an unoptimized program (optimization
    level zero) to run an order of magnitude slower than the program compiled with
    all optimizations enabled.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 优化编译器对于实现高性能至关重要。只需尝试运行一个完全没有优化的程序，就能体会到编译器的作用：未经优化的程序（优化级别为零）的运行速度通常比启用所有优化的程序慢一个数量级。
- en: Very often, however, it is the case that the optimizer can use some help from
    the programmer. This help can take the form of very subtle and often counter-intuitive
    changes. Before we look at some specific techniques to improve the optimization
    of your code, it helps to understand how the compiler sees your program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，优化器可能需要程序员的一些帮助。这种帮助可能采取非常微妙且常常反直觉的变化形式。在我们查看一些特定的技术来改进代码优化之前，了解编译器如何看待您的程序会有所帮助。
- en: Basics of compiler optimizations
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器优化基础
- en: 'The most important thing you must understand about optimization is that any
    code that is correct must remain correct. *Correct* here has nothing to do with
    your view of what is correct: the program may have bugs and give an answer you
    consider wrong, but the compiler must preserve this answer. The only exception
    is a program that is ill-defined or invokes undefined behavior: if the program
    is incorrect in the eyes of the Standard, the compiler is free to do whatever
    it wants. We will examine the implications of this in the next chapter. For now,
    we are going to assume that the program is well defined and uses only valid C++.
    The compiler, of course, is restricted in what changes it can make by the requirement
    that the answers must not change for any combination of inputs. The latter is
    very important: you may know that a certain input value is always positive or
    a certain string is never more than 16 characters long, but the compiler does
    not know that (unless you find a way to tell it). The compiler can only make the
    optimizing transformation if it can be proven that this transformation results
    in a perfectly equivalent program: a program that produces the same outputs for
    any inputs. In practice, the compiler is also limited in how complex of a proof
    it can manage before it gives up.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于优化，您必须理解的最重要的一点是，任何正确的代码都必须保持正确。*正确*在这里与您对正确的看法无关：程序可能存在错误并给出您认为错误的答案，但编译器必须保留这个答案。唯一的例外是一个程序是不明确的或者调用了未定义的行为：如果程序在标准的眼中是不正确的，编译器可以随意做任何事情。我们将在下一章中探讨这一点的影响。目前，我们将假设程序是明确定义的，并且仅使用有效的C++。当然，编译器在进行更改时受到限制，要求答案在任何输入组合下都不得改变。后者非常重要：您可能知道某个输入值始终为正，或者某个字符串永远不会超过16个字符长，但编译器不知道（除非您找到一种告诉它的方法）。只有在可以证明此转换会导致完全等效的程序时，编译器才能进行优化转换：一个对于任何输入都产生相同输出的程序。实际上，编译器在放弃之前能够管理多复杂的证明也是受限的。
- en: This understanding that *it's not what you know, it's what you can prove* is
    the key to successfully interacting with the compiler through code to achieve
    better optimizations. Basically, the rest of this chapter shows different ways
    in which you can make it easier to prove that certain desirable optimizations
    do not alter the result of the program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 理解*重要的不是你知道什么，而是你能证明什么*是成功与编译器通过代码进行交互以实现更好优化的关键。基本上，本章的其余部分展示了您可以使得更容易证明某些理想的优化不会改变程序结果的不同方法。
- en: A compiler is also restricted with regard to what information it has about the
    program. It has to work with only what is known at **compile-time**, has no knowledge
    of any runtime data, and has to assume that any legal state is possible at runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在程序方面也受到限制。它必须仅使用**编译时**已知的信息，对任何运行时数据一无所知，并且必须假设在运行时可能出现任何合法状态。
- en: 'Here is a simple example that illustrates this. First, consider this code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，用来说明这一点。首先，考虑这段代码：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The focus of our attention is the last line, the loop. The performance may
    be better if the loop is manually unrolled: as written, there is one branch (loop
    termination condition) for every increment. Unrolling the loop reduces this overhead.
    In a simple case of a vector with, say, only two elements, it is even better to
    remove the loop completely and just increment both elements. However, the size
    of the vector is an example of runtime information. The compiler may be able to
    generate a partially unrolled loop with some extra branches to handle all possible
    vector sizes, but it cannot optimize the code for a particular size.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的重点是最后一行，循环。如果手动展开循环，性能可能会更好：如写的那样，每次增量都有一个分支（循环终止条件）。展开循环可以减少这种开销。在一个简单的情况下，比如一个只有两个元素的向量，甚至最好完全去掉循环，只增加两个元素。然而，向量的大小是运行时信息的一个例子。编译器可能能够生成一个部分展开的循环，带有一些额外的分支来处理所有可能的向量大小，但它无法为特定大小优化代码。
- en: 'Contrast it with this code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与此代码形成对比：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the compiler knows exactly how many integers are processed in the loop.
    It can unroll the loop and even replace single integer increments with vector
    instructions that operate on several numbers at once (AVX2 instruction set on
    x86, for example, can add 8 integers at once).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器确切地知道循环中处理了多少个整数。它可以展开循环，甚至用操作多个数字的向量指令替换单个整数的增量（例如，x86上的AVX2指令集可以一次添加8个整数）。
- en: 'What if you know that the vector always has 16 elements? Probably does not
    matter. What matters is whether the compiler knows this and can prove it with
    certainty. This is harder than you think. For example, consider this code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道向量始终有16个元素，可能并不重要。重要的是编译器是否知道这一点，并且能够确定地证明。这比你想象的要困难。例如，考虑这段代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The programmer went out of their way to make it obvious that the vector size
    is a compile-time constant. Is the compiler going to optimize the loop? Possibly.
    It all depends on whether the compiler can prove that the vector size does not
    change. How would it change? Ask yourself, what could be hiding in the code that
    fills the vector? Not what you know to be there, but what can be learned from
    the code itself? If all the code is written between the two lines, the construction
    and the increment loop, the compiler can, in theory, know everything (in practice,
    the compiler will give up if this code fragment is too long and assume that *anything
    is possible* otherwise compilation times will explode). But if you call a function
    and that function has access to the vector object, the compiler has no way of
    knowing whether that function changes the size of the vector unless the function
    is inlined. A helpful function name like `fill_vector_without_resizing()` is only
    helpful to the programmer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员费尽心思明确表示向量大小是编译时常量。编译器会优化循环吗？可能。这完全取决于编译器能否证明向量大小不会改变。它会如何改变？问问自己，代码中填充向量的部分可能隐藏了什么？不是你知道的，而是可以从代码本身中学到的。如果所有代码都写在两行之间，构造和增量循环，理论上编译器可以知道一切（实际上，如果这段代码片段太长，编译器会放弃，并假设*任何事情都有可能*，否则编译时间会爆炸）。但如果调用一个函数，而该函数可以访问向量对象，编译器无法知道该函数是否改变了向量的大小，除非该函数被内联。像`fill_vector_without_resizing()`这样的有用函数名称只对程序员有用。
- en: Even if there are no function calls that take `v` as an argument, we are still
    not in the clear. How else might the function get access to the vector object?
    If the vector `v` is a local variable declared in a function scope, it probably
    cannot. But if `v` is a global variable, then any function can have access to
    it. Similarly, if `v` is a class member variable, any member function or friend
    function can have access to it. So, if we call a non-inlined function that does
    not get direct access to `v` through its argument list, it may still be able to
    access `v` through other means (and the less is said about the truly evil practice
    of creating global pointers to local variables, the better).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有函数调用以`v`作为参数，我们仍然不能确定。函数如何可能访问向量对象？如果向量`v`是在函数作用域中声明的局部变量，它可能无法。但如果`v`是一个全局变量，那么任何函数都可以访问它。同样，如果`v`是一个类成员变量，任何成员函数或友元函数都可以访问它。因此，如果我们调用一个非内联函数，它没有通过参数列表直接访问`v`，它可能仍然能够通过其他方式访问`v`（至于创建全局指针指向局部变量的真正邪恶的做法，我们最好不要谈）。
- en: 'From the programmer''s point of view, it is easy to overestimate the knowledge
    the compiler has, based on the knowledge the programmer has about what is really
    going on in the program. Also, remember that *puzzling things out* is not one
    of the compiler''s strengths, most of the time. For example, you can add an `assert`
    just before the loop:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，很容易高估编译器的知识，基于程序员对程序实际运行情况的了解。还要记住，*解谜*通常不是编译器的长处。例如，您可以在循环之前添加一个`assert`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some compilers, at the highest optimization level and in simple contexts, will
    deduce that the execution flow cannot get to the loop unless the vector has exactly
    16 elements and will optimize for that size. Most will not. By the way, we are
    assuming that the asserts are enabled (`NDEBUG` is undefined), or you use your
    own assert.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高优化级别和简单的上下文中，一些编译器会推断除非向量恰好有16个元素，否则执行流程不会到达循环，并且会针对这个大小进行优化。大多数不会。顺便说一句，我们假设断言已启用（`NDEBUG`未定义），或者您使用自己的断言。
- en: 'The basic example we have considered already has the key elements of the techniques
    used to assist the compiler with optimizing the code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑的基本例子已经包含了用于帮助编译器优化代码的关键技术元素：
- en: Non-inlined functions disrupt most optimizations because the compiler has to
    assume that a function whose code it does not see can do anything it is legally
    allowed to do.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非内联函数会破坏大多数优化，因为编译器必须假设它看不到代码的函数可以做任何它合法允许的事情。
- en: Global and shared variables are terrible for optimization.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局和共享变量对优化非常不利。
- en: The compiler is more likely to optimize a short and simple code fragment than
    a long and complex one.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器更有可能优化短小简单的代码片段，而不是长而复杂的代码片段。
- en: 'The first and the last notions are somewhat in conflict with each other. Most
    optimizations in the compilers are limited to what''s known as basic blocks of
    code: these are blocks with only one entry point and only one exit point. They
    serve as nodes in the flow control graph of a program. The reason basic blocks
    are important is that the compiler can see everything that is going on inside
    the block, so it can reason about code transformations that do not change the
    output. The advantage of inlining is that it increases the size of the basic blocks.
    The compiler does not know what a non-inlined function does, so it has to assume
    the worst. But if the function is inlined, the compiler knows exactly what it''s
    doing (and, more importantly, what it''s not doing). The disadvantage of inlining
    is also that it increases the size of the basic blocks: the compiler can analyze
    only so much code without making compilation time unreasonable. Inlining is really
    important for compiler optimizations for reasons we are going to explore now.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和最后一个概念在某种程度上存在冲突。编译器中的大多数优化都限于所谓的基本代码块：这些是只有一个入口点和一个出口点的代码块。它们在程序的流程控制图中充当节点。基本代码块之所以重要是因为编译器可以看到代码块内部发生的一切，因此可以推断不会改变输出的代码转换。内联的优势在于它增加了基本代码块的大小。编译器不知道非内联函数的具体操作，因此必须做出最坏的假设。但是如果函数被内联，编译器就知道它在做什么（更重要的是，它不在做什么）。内联的缺点也在于它增加了基本代码块的大小：编译器只能分析有限量的代码，否则编译时间会变得不合理。内联对于编译器优化非常重要，我们现在将探讨其中的原因。
- en: Function inlining
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数内联
- en: 'Inlining is done by the compiler when it replaces a function call with a copy
    of the body of the function. In order for this to happen, the inlining must be
    possible: the definition of the function must be visible during the compilation
    of the calling code, and the function that is being called must be known at compile
    time. The first requirement is relaxed in some compilers that do whole-program
    optimizations (still uncommon). The second requirement rules out virtual function
    calls and indirect calls through function pointers. Not every function that can
    be inlined ends up inlined: the compiler has to weigh the code bloat against the
    benefits of inlining. Different compilers have different heuristics for inlining.
    The `inline` keyword of C++ is only a suggestion, and the compiler can disregard
    it.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内联是编译器在用函数体的副本替换函数调用时进行的。为了实现这一点，内联必须是可能的：在调用代码的编译过程中，函数的定义必须是可见的，并且在编译时必须知道被调用的函数。第一个要求在一些进行整体程序优化的编译器中有所放宽（仍然不常见）。第二个要求排除了虚函数调用和通过函数指针进行的间接调用。并非每个可以内联的函数最终都会被内联：编译器必须权衡代码膨胀与内联的好处。不同的编译器对内联有不同的启发式。C++的`inline`关键字只是一个建议，编译器可以忽略它。
- en: 'The most obvious benefit of function call inlining is that it eliminates the
    cost of the function call itself. This is also the least important benefit in
    most cases: the function calls are not that expensive. The main benefit is that
    the compiler is very limited in what optimizations it can do across the function
    calls. Consider this simple example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用内联的最明显好处是消除了函数调用本身的成本。在大多数情况下，这也是最不重要的好处：函数调用并不那么昂贵。主要好处在于编译器在函数调用之间可以做的优化非常有限。考虑这个简单的例子：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Is the following a valid optimization?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个有效的优化吗？
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you answered *yes*, you are still looking at this through the programmer's
    eyes instead of the compiler's eyes. There are so many ways in which this optimization
    can break the code (none of which are probably true for any reasonable program
    you would write, but the one assumption the compiler cannot make is that of a
    reasonable programmer).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回答*是*，那么你仍然是从程序员的角度来看待这个问题，而不是从编译器的角度来看。这种优化可能会破坏代码的方式有很多（对于您可能编写的任何合理程序来说，这些方式可能都不成立，但编译器不能做出的假设是程序员是合理的）。
- en: First, the functions `g()` and `h()` can produce output, in which case eliminating
    the repeated function calls would change the observable behavior.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，函数`g()`和`h()`可以产生输出，如果消除重复的函数调用会改变可观察的行为。
- en: Second, a call to `g()` might lock some mutex, and the call to `h()` might unlock
    it, in which case the order of execution – call `g()` to lock, increment `i`,
    call `h()` to unlock – is really important.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，对`g()`的调用可能会锁定某个互斥量，对`h()`的调用可能会解锁它，这种情况下执行的顺序——调用`g()`来锁定，增加`i`，调用`h()`来解锁——非常重要。
- en: 'Third, the results of `g()` and `h()` may be different even with the same arguments:
    they could, for example, use random numbers inside.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，即使使用相同的参数，`g()`和`h()`的结果可能不同：例如，它们可能在内部使用随机数。
- en: 'Finally (and this possibility is most often missed by programmers), the variable
    `i` is passed by reference, so we don''t know what else the caller might have
    done with it: it could be a global variable, or some object might store a reference
    to it, so, one way or another, the functions `g()` and `h()` might operate on
    `i` even though we don''t see it being passed into these functions.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后（这种可能性程序员经常忽视），变量`i`是通过引用传递的，因此我们不知道调用者可能对它做了什么：它可能是一个全局变量，或者某个对象可能存储了对它的引用，因此，`g()`和`h()`函数可能会对`i`进行操作，尽管我们看不到它被传递到这些函数中。
- en: 'On the other hand, if the functions `g()` and `h()` are inlined, the compiler
    can see exactly what is going on, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果函数`g()`和`h()`被内联，编译器可以清楚地看到发生了什么，例如：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The entire function `f()` is now one basic block, and the compiler has only
    one restriction: preserve the returned value. This is a valid optimization:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数`f()`现在是一个基本块，编译器只有一个限制：保留返回值。这是一个有效的优化：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The effect of the inlining on the optimization can *trickle down* quite far.
    Consider the destructor of an STL container, say, `std::vector<T>`. One of the
    steps it must do is to invoke the destructors on all objects in the container:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 内联对优化的影响可以*传递得很远。考虑STL容器的析构函数，比如`std::vector<T>`。它必须做的步骤之一是调用容器中所有对象的析构函数：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The execution time of the destructor is, therefore, proportional to the size
    `N` of the vector. Unless it isn''t: consider a vector of integers, `std::vector<int>`.
    The compiler knows very well what the destructor does in this case: absolutely
    nothing. The compiler can also see that the calls to `crbegin()` and `crend()`
    do not modify the vector (if you are concerned about destroying an object through
    a `const_iterator`, think how `const` objects are destroyed). This entire loop,
    therefore, can be eliminated.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，析构函数的执行时间与向量的大小`N`成正比。除非不是：考虑一个整数向量，`std::vector<int>`。在这种情况下，编译器非常清楚析构函数的作用：绝对什么都不做。编译器还可以看到对`crbegin()`和`crend()`的调用不会修改向量（如果您担心通过`const_iterator`销毁对象，请考虑`const`对象是如何被销毁的）。因此，整个循环可以被消除。
- en: 'Now consider using a vector of simple aggregates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑使用简单聚合的向量：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, the type `T` has a destructor, and again the compiler knows what
    it does (the compiler did generate it, after all). Again, the destructor does
    nothing, and the entire destruction loop is eliminated. The same goes for a `default`
    destructor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，类型`T`有一个析构函数，编译器再次知道它的作用（毕竟编译器生成了它）。再一次，析构函数什么都不做，整个销毁循环被消除。对于`default`析构函数也是一样的：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The compiler should be able to do the same optimization for an empty destructor,
    but only if it''s inlined:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器应该能够对空析构函数进行相同的优化，但只有在内联的情况下才能这样做：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the other hand, if the class declaration only declares the destructor like
    the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果类声明只声明了析构函数如下：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: and the definition is provided in a separate compilation unit, then the compiler
    has to generate a function call for each vector element. The function still does
    nothing, but it still takes time to run the loop and do `N` function calls. Inlining
    allows the compiler to optimize this time to nothing, zero.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义在单独的编译单元中，那么编译器必须为每个向量元素生成一个函数调用。函数仍然什么都不做，但运行循环和进行`N`个函数调用仍然需要时间。内联允许编译器将这段时间优化为零。
- en: 'This is the key to inlining and its effect on optimization: inlining allows
    the compiler to see what is *not* happening inside the otherwise mysterious function.
    Inlining has another important role: it creates a unique clone of the inlined
    function''s body that can be optimized with the specific inputs as given by the
    caller. Within this unique clone, some optimization-friendly conditions may be
    observed that are not true in general for this function. Again, here is an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内联及其对优化的影响的关键：内联允许编译器看到在否则神秘的函数内部发生了什么*不*。内联还有另一个重要的作用：它创建了内联函数体的唯一克隆，可以根据调用者给定的特定输入进行优化。在这个唯一的克隆中，可能观察到一些对优化友好的条件，这些条件对于这个函数来说通常是不成立的。再次举个例子：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Assuming the definition of the function `pred()` is in the same compilation
    unit as the call to `std::find_if()`, will the call to `pred()` be inlined? The
    answer is *maybe*, and it critically depends on whether or not the call to `find_if()`
    is inlined first. Now, `find_if()` is a template, so the compiler always sees
    the function definition. It may decide not to inline the function, regardless.
    If `find_if()` is not inlined, then we have a function generated from the template
    for the specific types. Within this function, the type of the third argument is
    known: it''s `bool (*)(int)`, a pointer to a function that takes an `int` and
    returns a `bool`. But the value of this pointer is not known at compile time:
    the same `find_if()` function can be called with many different predicates, so
    none of them can be inlined. Only if the compiler generates a unique clone of
    `find_if()` for this particular call can the predicate function be inlined. Compilers
    will sometimes do just that; it is called, unsurprisingly, **cloning**. Most of
    the time, however, the only way to inline the predicate, or any other inner function
    that is passed in as a parameter, is to inline the outer function first.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设函数`pred()`的定义与对`std::find_if()`的调用在同一个编译单元中，那么对`pred()`的调用会被内联吗？答案是*可能*，这在很大程度上取决于对`find_if()`是否首先进行内联。现在，`find_if()`是一个模板，所以编译器总是能看到函数定义。它可能决定不内联该函数。如果`find_if()`没有内联，那么我们就会得到一个从特定类型生成的模板函数。在这个函数内部，第三个参数的类型是已知的：它是`bool
    (*)(int)`，一个接受`int`并返回`bool`的函数指针。但是这个指针的值在编译时是未知的：同一个`find_if()`函数可以用许多不同的谓词调用，因此它们中的任何一个都不能被内联。只有当编译器为这个特定的调用生成`find_if()`的唯一克隆时，谓词函数才能被内联。编译器有时会这样做；这被称为**克隆**。然而，大多数情况下，内联谓词或作为参数传递的任何其他内部函数的唯一方法是首先内联外部函数。
- en: 'This particular example produces different results on different compilers:
    for example, GCC will inline both `find_if()` and `pred()` at the highest optimization
    setting only. Other compilers won''t do it even then. However, there is another
    way to encourage the compiler to inline a function call, and it does seem counter-intuitive
    because it adds more code to the program and makes the chain of nested function
    calls longer:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子在不同的编译器上产生不同的结果：例如，GCC只会在最高优化设置下内联`find_if()`和`pred()`。其他编译器即使在那时也不会这样做。然而，还有另一种方法可以鼓励编译器内联函数调用，尽管这似乎有些反直觉，因为它会向程序添加更多的代码，并使嵌套函数调用链变得更长：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The paradox here is that we have added an extra layer of indirection, a lambda
    expression, around the same indirect function call (by the way, we assume that
    there is a reason the programmer does not want to simply duplicate the body of
    the predicate directly into the lambda). This call to `pred()` is actually much
    easier to inline, even if the compiler does not inline the `find_if()` function.
    The reason is that this time, the type of the predicate is unique: every lambda
    expression has a unique type, so there is only one instantiation of the `find_if()`
    template for these particular type parameters. The compiler is more likely to
    inline a function that is called only once: after all, doing so does not generate
    any more code. But even if the call to `find_if()` is not inlined, within that
    function, there is only one possible value of the third argument, this value is
    known at compile time to be `pred()` and, therefore, the call to `pred()` can
    be inlined.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的悖论是，我们在同一个间接函数调用周围增加了一个额外的间接层，即lambda表达式（顺便说一句，我们假设程序员不想直接将谓词的主体简单地复制到lambda中有其原因）。这次对`pred()`的调用实际上更容易内联，即使编译器没有内联`find_if()`函数。原因是这次，谓词的类型是唯一的：每个lambda表达式都有唯一的类型，因此对于这些特定的类型参数，`find_if()`模板只有一个实例化。编译器更有可能内联只调用一次的函数：毕竟，这样做不会生成任何额外的代码。但即使`find_if()`的调用没有被内联，在该函数内部，第三个参数只有一个可能的值，这个值在编译时已知为`pred()`，因此`pred()`的调用可以被内联。
- en: 'As an aside, we can finally clarify the answers to the question we asked all
    the way back in [*Chapter 1*](B16229_01_Epub_AM.xhtml#_idTextAnchor014), *Introduction
    to Performance and Concurrency*: what is the cost of a virtual function call?
    First of all, the compiler typically implements a virtual call using a table of
    function pointers, so the call itself involves an extra layer of indirection:
    the CPU has to read one more pointer and do one more jump compared to a non-virtual
    call. This adds several more instructions to the function call, making the code
    of the function call about twice as expensive (with a large variation depending
    on the hardware and cache state). However, we usually call a function to have
    some work done, so the machinery of the function call is only a part of the total
    function execution time. Even for simple functions, it is rare to have the virtual
    function cost more than 10-15% of the non-virtual one.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们最终可以澄清我们在[*第1章*](B16229_01_Epub_AM.xhtml#_idTextAnchor014)中提出的问题的答案，即《性能和并发简介》：虚函数调用的成本是多少？首先，编译器通常使用函数指针表来实现虚拟调用，因此调用本身涉及额外的间接层：CPU必须读取一个额外的指针，并与非虚拟调用相比进行一次跳转。这会在函数调用中添加几个额外的指令，使函数调用的代码大约贵两倍（具体取决于硬件和缓存状态的变化）。然而，我们通常调用函数是为了完成一些工作，因此函数调用的机制只是总函数执行时间的一部分。即使对于简单的函数，虚函数的成本很少超过非虚函数的10-15%。
- en: 'However, before we spend too much time counting instructions, we should question
    the validity of the original question: if a non-virtual function call is sufficient,
    that is, if we know at compile time which function will be called, why would we
    use a virtual function in the first place? Conversely, if we find out which function
    to call only at runtime, then a non-virtual function cannot be used at all, so
    its speed is irrelevant. Following this logic, we should compare a virtual function
    call against a functionally equivalent runtime solution: conditionally call one
    of several functions using some runtime information to choose. Using an `if-else`
    or a `switch` statement usually results in slower execution, at least if there
    are more than two versions of the function to call. The most efficient implementation
    is a table of function pointers, which is precisely what the compiler does with
    virtual functions.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们花费太多时间计算指令之前，我们应该质疑原始问题的有效性：如果非虚函数调用足够，也就是说，如果我们在编译时知道将调用哪个函数，那么我们为什么要首先使用虚函数呢？相反，如果我们只在运行时找出要调用的函数，那么根本不能使用非虚函数，因此它的速度是无关紧要的。按照这种逻辑，我们应该将虚函数调用与功能上等效的运行时解决方案进行比较：使用一些运行时信息来有条件地调用多个函数中的一个。使用`if-else`或`switch`语句通常会导致较慢的执行，至少如果有两个以上的函数版本要调用的话。最有效的实现是一个函数指针表，这正是编译器用虚函数做的。
- en: 'Of course, the original question was not, in truth, entirely meaningless: what
    if we have a polymorphic class with a virtual function but, in some cases, we
    know the actual type at compile time? In this case, comparing a virtual function
    call with a non-virtual one makes sense. We should also mention an interesting
    compiler optimization that applies: if the compiler can figure out the real type
    of the object at compile time and, thus, knows which override of the virtual function
    will be called, it will convert the call to non-virtual in what is known as **devirtualization**.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，原始问题实际上并非毫无意义：如果我们有一个多态类，其中有一个虚函数，但在某些情况下，我们在编译时知道实际类型是什么呢？在这种情况下，比较虚函数调用和非虚函数调用是有意义的。我们还应该提到一个有趣的编译器优化：如果编译器可以在编译时找出对象的真实类型，并因此知道将调用虚函数的哪个重写，它将把调用转换为非虚函数，这就是所谓的**去虚拟化**。
- en: 'Why, though, is this discussion taking place in a section dedicated to inlining?
    Because we are missing the elephant in the room: the greatest impact of virtual
    functions on performance is that (unless the compiler can devirtualize the call)
    they cannot be inlined. A simple function such as `int f() { return x; }` results
    in one or even zero instructions after inlining, but the non-inlined version has
    the regular function call machinery, which is orders of magnitude slower. Now
    add the fact that without inlining, the compiler cannot know what''s going on
    inside the virtual function and has to make the worst assumptions about every
    externally accessible piece of data, and you can see how, in the worst-case scenario,
    a virtual function call can be thousands of times more expensive.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这个讨论发生在一个专门讨论内联的部分呢？因为我们忽略了一个重要因素：虚函数对性能的最大影响是（除非编译器可以去虚拟化调用）它们无法被内联。一个简单的函数，比如`int
    f() { return x; }`在内联后可能只有一条甚至零条指令，但非内联版本则有常规的函数调用机制，速度慢了几个数量级。现在再加上没有内联的情况下，编译器无法知道虚函数内部发生了什么，并且必须对每个外部可访问的数据做出最坏的假设，你就能看到，在最坏的情况下，虚函数调用可能会昂贵数千倍。
- en: Both effects of inlining, exposing the content of the functions, and creating
    a unique, specialized copy of the function, help the optimizer because they increase
    the amount of knowledge the compiler has about the code. As we already mentioned,
    it is very important to understand what the compiler really knows if you want
    to help it do a better job of optimizing your code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 内联的两个效果，暴露函数的内容和创建一个独特的、专门的函数副本，都有助于优化器，因为它们增加了编译器对代码的了解程度。正如我们已经提到的，如果你想帮助编译器更好地优化你的代码，了解编译器真正知道什么是非常重要的。
- en: 'We will now explore different restrictions the compiler operates under, so
    you can develop an eye for recognizing the *false constraints*: something you
    know to be true but the compiler does not.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨编译器所遵循的不同限制，这样你就可以培养出识别*错误约束*的眼光：你知道是真的，但编译器不知道。
- en: What does the compiler really know?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器真正知道什么？
- en: 'Perhaps the greatest constraint on the optimization is the knowledge of what
    can change during the execution of this code. Why is this important? Again, here
    is an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的最大限制可能是在代码执行期间可能发生的变化。为什么这很重要？再举一个例子：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, only the declaration of `g()` is available. Can the compiler
    optimize the `if()` statement and eliminate the repeated evaluation of the condition?
    After all the surprises and gotchas of this chapter, you may be looking for a
    reason why not. There isn''t one, and it''s a perfectly valid optimization:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有`g()`的声明是可用的。编译器能够优化`if()`语句并消除条件的重复评估吗？在这一章节的所有意外和陷阱之后，你可能在寻找为什么不能的原因。其实没有，这是一个完全有效的优化：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let us modify the example slightly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们稍微修改一下例子：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Why would you ever pass a `bool` parameter by `const` reference? The most common
    reason is templates: if you have a template function that doesn''t need to make
    a copy of the argument, it has to declare the parameter as `const T&`, assuming
    `T` can be anything. If `T` is deduced as `bool`, you now have a `const bool&`
    parameter. The change may be minimal, but the effect on the optimization is profound.
    If you think that the optimization we made earlier is still valid, consider our
    example in a larger context. Now you can see everything (assume that the compiler
    still cannot):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会通过`const`引用传递`bool`参数？最常见的原因是模板：如果你有一个不需要复制参数的模板函数，它必须将参数声明为`const T&`，假设`T`可以是任何类型。如果`T`被推断为`bool`，那么现在你有了一个`const
    bool&`参数。这个改变可能很小，但对优化的影响是深远的。如果你认为我们之前做的优化仍然有效，那么考虑一下我们的例子在更大的上下文中。现在你可以看到一切（假设编译器仍然不能）：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that by calling `g()`, we can change `b` because `b` is a reference bound
    to a global variable that is also accessible inside `g()`. On the first iteration,
    `b` is `false`, but the call to `g()` has a side effect: `b` changes to `true`.
    If the parameter were passed by value, it would not have happened: the value is
    captured at the very beginning of the function and does not track the caller''s
    variable. But with pass-by-reference, it does happen, and the second iteration
    of the loop is no longer dead code. On every iteration, the condition must be
    evaluated, and optimization is not possible. We want to stress, once again, the
    difference between what the programmer may know and what the compiler can prove:
    you may know for sure that you don''t have any global variables in your code,
    or you may know exactly what the function `g()` does. The compiler cannot make
    any such guesses and has to assume that the program does (or at some point in
    the future will do) something like we demonstrated in the previous example, and
    that makes the optimization potentially unsafe.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过调用`g()`，我们可以改变`b`，因为`b`是一个绑定到全局变量的引用，在`g()`内部也是可访问的。在第一次迭代中，`b`是`false`，但调用`g()`会产生副作用：`b`变为`true`。如果参数是按值传递的，这是不会发生的：值在函数开始时被捕获，不会跟踪调用者的变量。但是通过引用传递，它确实发生了，循环的第二次迭代不再是死代码。在每次迭代中，条件必须被评估，优化是不可能的。我们要再次强调，程序员可能知道的和编译器可以证明的之间的差异：你可能确信你的代码中没有任何全局变量，或者你可能确切地知道函数`g()`做了什么。编译器无法做出这样的猜测，并且必须假设程序（或将来的某个时刻）会做出我们在前面的例子中展示的类似行为，这使得优化潜在地不安全。
- en: 'Again, this would not have happened if the function `g()` was inlined and the
    compiler could see that it does not modify any global variables. But you cannot
    expect your entire code to be inlined, so at some point, you have to consider
    how to help the compiler determine what it doesn''t know on its own. In the current
    example, the easiest way to do this is to introduce a temporary variable (of course,
    in this simple example, you can just do the optimization by hand, but this is
    not practical in more complex, real-life code). To make the example slightly more
    realistic, we are going to remember that the function `f()` probably came from
    a template instantiation. We do not want to make a temporary copy of the parameter
    `b` of an unknown type, but we do know that it must be convertible to `bool`,
    so that can be our temporary variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果函数`g()`被内联并且编译器可以看到它不修改任何全局变量，这种情况就不会发生。但你不能期望你的整个代码都被内联，所以在某个时候，你必须考虑如何帮助编译器确定它自己不知道的东西。在当前的例子中，最简单的方法是引入一个临时变量（当然，在这个简单的例子中，你可以手动进行优化，但在更复杂的现实代码中，这是不切实际的）。为了使这个例子稍微更加现实，我们将记住函数`f()`可能来自一个模板实例化。我们不想复制一个未知类型的参数`b`，但我们知道它必须可以转换为`bool`，所以这可以是我们的临时变量。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The compiler still has to assume that the function `g()` might change the value
    of `t`. But that no longer matters: the condition uses the temporary variable
    `b`, which definitely cannot be changed because it is not visible outside of the
    function `f()`. Of course, if the function `g()` did have access to a global variable
    that changed the second argument of `f()`, our transformation has changed the
    result of the program. By creating this temporary variable, we are telling the
    compiler that this situation does not happen. This is the additional information
    that the compiler cannot come up with on its own.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器仍然必须假设函数`g()`可能会改变`t`的值。但这已经不重要了：条件使用了临时变量`b`，因为它在`f()`函数之外是不可见的，所以肯定不会被更改。当然，如果函数`g()`确实可以访问更改`f()`的第二个参数的全局变量，我们的转换就改变了程序的结果。通过创建这个临时变量，我们告诉编译器这种情况不会发生。这是编译器无法自行想出的额外信息。
- en: 'The lesson here is simple, in theory, but quite hard in practice: if you know
    something about your program that the compiler cannot know to be true, you must
    assert it in a way the compiler can use. One reason this is hard to do is that
    we don''t normally think about our program the way the compiler does, and it is
    very difficult to let go of the implicit assumptions you know with certainty to
    be absolutely true.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训很简单，理论上是这样的，但在实践中却相当困难：如果你知道关于你的程序的一些信息，而编译器无法知道这些信息是真实的，你必须以编译器可以使用的方式来断言它。这样做之所以难，是因为我们通常不会像编译器那样思考我们的程序，而且很难放弃你确信绝对正确的隐含假设。
- en: 'By the way, did you notice that we declared the temporary variable `b` to be
    `const`? This is mostly for our own benefit, to prevent any bugs arising from
    accidentally modifying it. But it also helps the compiler. You may wonder why:
    the compiler should be able to see that nothing changes the value of `b`. Unlike
    the earlier tricky situation, this case is simple: the compiler sees everything
    done to `b`. However, you cannot be certain that the compiler knows something
    just because the knowledge is available: analyzing the program takes time, and
    the programmer is willing to wait only so long for the compiler to do its job.
    On the other hand, syntax checking is mandatory: if we declare the variable `const`
    and try to change it, the program will not compile, and we will never get to the
    optimization step. So the optimizer can assume that any `const` variable indeed
    does not change. There is yet another reason to declare objects `const` whenever
    possible, but we will get to that in the next chapter.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你有没有注意到我们声明临时变量`b`为`const`？这主要是为了我们自己的利益，以防止因意外修改它而产生任何错误。但它也有助于编译器。你可能会想为什么：编译器应该能够看到没有任何东西改变`b`的值。与早期棘手的情况不同，这种情况很简单：编译器看到了对`b`的所有操作。然而，你不能确定编译器知道某些东西只是因为这些知识是可用的：分析程序需要时间，程序员只愿意等待编译器完成工作的时间有限。另一方面，语法检查是强制性的：如果我们声明变量为`const`并尝试更改它，程序将无法编译，我们将永远无法进行优化步骤。因此，优化器可以假设任何`const`变量确实不会改变。还有另一个原因可以尽可能地声明对象为`const`，但我们将在下一章中讨论。
- en: 'So here is the second lesson, right on the heels of the first one: if you know
    something about your program that you can easily communicate to the compiler,
    do so. This advice does go against a very common recommendation: don''t create
    temporary variables unless they make the program easier to read – the compiler
    will just get rid of them anyway. The compiler might indeed get rid of them, but
    it does keep (and use) the additional information expressed by their presence.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是第二个教训，紧随第一个教训之后：如果你知道关于你的程序的一些信息，可以轻松地传达给编译器，那就这样做。这个建议确实违反了一个非常常见的建议：不要创建临时变量，除非它们使程序更易读
    - 编译器无论如何都会摆脱它们。编译器确实可能会摆脱它们，但它确实保留（并使用）它们的存在所表达的附加信息。
- en: 'Another very common situation that prevents the compiler from doing optimizations
    is the possibility of aliasing. Here is an example of a function that initializes
    two C-style strings:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个阻止编译器进行优化的非常常见的情况是可能的别名。这是一个初始化两个C风格字符串的函数的示例：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Writing memory one byte at a time is rather inefficient. There are much better
    ways to initialize all characters to the same value. This version will be much
    faster:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一次写一个字节的内存是相当低效的。有更好的方法来将所有字符初始化为相同的值。这个版本会快得多：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can write this code by hand, but the compiler will never do this optimization
    for you, and it is important to understand why. When you see this function, you
    expect it to be used as intended, that is, to initialize two character arrays.
    But the compiler has to consider the possibility that the two pointers `a` and
    `b` point to the same array or overlapping parts of one array. To you, it probably
    makes no sense to call `init()` this way: the two initializations will overwrite
    each other. The compiler has just one concern, though: how to not change the behavior
    of your code, whatever that may be.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动编写此代码，但编译器永远不会为您执行此优化，了解原因很重要。当您看到此函数时，您期望它被按预期使用，即初始化两个字符数组。但是编译器必须考虑两个指针`a`和`b`指向同一个数组或重叠部分的可能性。对您来说，以这种方式调用`init()`可能毫无意义：两个初始化将互相覆盖。然而，编译器只关心一件事：如何不改变您代码的行为，无论那是什么。
- en: 'The same problem can happen in any function that takes multiple parameters
    by reference or by a pointer. For example, consider this function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的问题可能会发生在任何通过引用或指针接受多个参数的函数中。例如，考虑这个函数：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The compiler cannot do any optimizations that would be invalid if `a` and `b`
    and `x` are bound to the same variable. This is known as `x` from memory after
    incrementing `a`. Why? Because `a` and `x` could refer to the same value and the
    compiler cannot make the assumption that `x` remains unchanged.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器无法进行任何优化，如果`a`和`b`和`x`绑定到同一个变量，那么这些优化就是无效的。这被称为在递增`a`之后从内存中读取`x`。为什么？因为`a`和`x`可能指向相同的值，编译器无法假设`x`保持不变。
- en: 'How do you address this problem if you know for sure that the aliasing is not
    going to happen? In C, there is a keyword `restrict` that informs the compiler
    that a particular pointer is the only way to access the value within the scope
    of the current function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确定别名不会发生，您如何解决这个问题？在C中，有一个关键字`restrict`，它通知编译器特定指针是在当前函数范围内访问值的唯一方式：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Inside the `init()` function, the compiler can assume that the entire array
    `a` can be accessed only through this pointer. This applies to scalar variables
    as well. The `restrict` keyword is not, so far, a part of the C++ standard. Nonetheless,
    many compilers support this feature, although using different syntaxes (`restrict`,
    `__restrict`, `__restrict__`). For singular values (in particular, references),
    creating a temporary variable often solves the problem as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`函数内部，编译器可以假定整个数组`a`只能通过这个指针访问。这也适用于标量变量。`restrict`关键字目前还不是C++标准的一部分。尽管如此，许多编译器支持此功能，尽管使用不同的语法（`restrict`，`__restrict`，`__restrict__`）。对于单个值（特别是引用），创建临时变量通常可以解决问题，如下所示：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The compiler will likely eliminate the temporary variable (not allocate any
    memory for it), but now it has the guarantee that both `a` and `b` are incremented
    by the same amount. Would the compiler actually do the optimization? The easiest
    way is to compare the assembly output as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能会消除临时变量（不为其分配任何内存），但现在它保证`a`和`b`都增加了相同的量。编译器是否会实际执行这种优化？最简单的方法是比较汇编输出如下：
- en: '![Figure 10.1 – x86 assembly output before (left) and after (right) the aliasing
    optimization'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - x86汇编输出在别名优化之前（左）和之后（右）'
- en: '](img/Figure_12.1_B16229.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B16229.jpg)'
- en: Figure 10.1 – x86 assembly output before (left) and after (right) the aliasing
    optimization
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - x86汇编输出在别名优化之前（左）和之后（右）
- en: '*Figure 10.1* shows the x86 assembly generated by GCC for the increment operations
    (we omit the function call and the branch, which are identical in both cases).
    With the aliasing, the compiler has to do two reads from memory (`mov` instructions).
    With the manual optimization, there is only one read.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1*显示了由GCC生成的x86汇编，用于增量操作（我们省略了函数调用和分支，这两种情况下是相同的）。使用别名，编译器必须从内存中进行两次读取（`mov`指令）。使用手动优化，只有一次读取。'
- en: How important are these optimizations? It depends on many factors, so you should
    not embark on a project to eliminate all aliasing in your code without doing some
    measurements first. Profiling your code will tell you which parts are performance-critical;
    there, you have to examine all optimization opportunities. Optimizations that
    end up helping the compiler by supplying it with additional knowledge are often
    some of the easiest to implement (the compiler does the hard work).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优化有多重要？这取决于许多因素，因此在着手消除代码中的所有别名之前，您不应该进行一些测量。对代码进行分析将告诉您哪些部分是性能关键的；在那里，您必须检查所有优化机会。最终帮助编译器提供额外知识的优化通常是最容易实现的（编译器做了艰苦的工作）。
- en: 'The flipside of the recommendation to supply the compiler with hard-to-discover
    information about your program is this: don''t worry about things the compiler
    can figure out easily. This issue comes up in different contexts, but one of the
    more common scenarios is using functions that validate their inputs. In your library,
    you have a swap function that works on pointers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 向编译器提供关于程序的难以发现的信息的建议的反面是：不要担心编译器可以轻松解决的问题。这个问题出现在不同的上下文中，但其中一个更常见的情景是使用验证其输入的函数。在您的库中，您有一个在指针上工作的交换函数：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The function accepts null pointers but doesn''t do anything with them. In your
    own code, for some reason, you have to check the pointers anyway, and you call
    `my_swap()` only if both are non-null (maybe you need to do something else if
    they are null, so you have to check). Ignoring all the other work you may do,
    the calling code looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受空指针，但不对其进行任何操作。在您自己的代码中，出于某种原因，您仍然必须检查指针，并且只有在两者都非空时才调用`my_swap()`（也许如果它们为空，您需要做其他事情，因此您必须检查）。忽略您可能做的所有其他工作，调用代码如下：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An inordinate amount of time is spent by C++ programmers arguing whether the
    redundant check affects the performance. Should we try to remove the check at
    the call site? Assuming we cannot, should we create another version of `my_swap()`
    that does not test its inputs? The key observation here is that the function `my_swap()`
    is a template (and a small function), so it is almost certainly going to be inlined.
    The compiler has all the necessary information to determine that the second test
    for null is redundant. Does it? Instead of trying to benchmark the possible performance
    difference (which would be very small in any case), we will compare the assembly
    output of both programs. If the compiler generates identical machine code with
    and without the redundant `if()` statement, we can be certain that there is no
    performance difference. Here is the assembly output on x86 generated by GCC:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员花费了大量时间争论多余的检查是否会影响性能。我们应该尝试在调用站点删除检查吗？假设我们不能，我们应该创建另一个不测试其输入的`my_swap()`版本吗？关键观察是`my_swap()`函数是一个模板（和一个小函数），所以几乎肯定会被内联。编译器具有确定第二次对null的测试是多余的所有必要信息。它会吗？与其尝试基准测试可能的性能差异（在任何情况下都会非常小），我们将比较两个程序的汇编输出。如果编译器生成具有和不具有多余`if()`语句的相同机器代码，我们可以肯定没有性能差异。这是由GCC生成的x86汇编输出：
- en: '![Figure 10.2 – Assembly output with (left) and without (right) redundant pointer
    test'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - 带有（左）和不带（右）多余指针测试的汇编输出'
- en: '](img/Figure_12.2_B16229.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B16229.jpg)'
- en: Figure 10.2 – Assembly output with (left) and without (right) redundant pointer
    test
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 带有（左）和不带（右）多余指针测试的汇编输出
- en: On the left in *Figure 10.2* is the code generated for the program with two
    `if()` statements, one inside `my_swap()` and one outside. On the right is the
    code for the program with a special non-testing version of `my_swap()`. You can
    see that the machine code is absolutely identical (if you can read x86 assembly,
    you will also notice that there are only two comparisons in both cases, not four).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.2*的左侧是带有两个`if()`语句的程序生成的代码，一个在`my_swap()`内部，一个在外部。右侧是具有特殊的不测试版本`my_swap()`的程序的代码。您可以看到机器代码是完全相同的（如果您能阅读x86汇编，您还会注意到两种情况下只有两次比较，而不是四次）。
- en: 'As we already said, the inlining plays the crucial role here: if `my_swap()`
    wasn''t inlined, the first test, in function `f()`, is good because it avoids
    the unnecessary function call and allows the compiler to optimize the calling
    code better for the case when one of the pointers is null. The test inside `my_swap()`
    is now redundant, but the compiler will generate it anyway because it doesn''t
    know whether `my_swap()` is called elsewhere, maybe without any guarantees on
    inputs. It is still highly unlikely that the performance difference would be measurable
    because the second test is 100% predictable by the hardware (we talked about this
    in [*Chapter 3*](B16229_03_Epub_AM.xhtml#_idTextAnchor047), *CPU Architecture,
    Resources, and Performance Implications*).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经说过的，内联在这里起着至关重要的作用：如果`my_swap()`没有被内联，那么在函数`f()`中的第一个测试是好的，因为它避免了不必要的函数调用，并允许编译器更好地优化调用代码，以便在其中一个指针为空时更好地进行优化。现在`my_swap()`内部的测试是多余的，但是编译器将生成它，因为它不知道`my_swap()`是否在其他地方被调用，也许没有对输入的任何保证。性能差异仍然极不可能是可测量的，因为硬件对第二次测试是100%可预测的（我们在[*第3章*](B16229_03_Epub_AM.xhtml#_idTextAnchor047)中讨论过这一点，*CPU架构、资源和性能影响*）。
- en: 'By the way, the most common example of this situation is probably the operator
    `delete`: C++ allows deleting a null pointer (nothing happens). However, many
    programmers still write code like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这种情况最常见的例子可能是`delete`运算符：C++允许删除空指针（什么也不会发生）。然而，许多程序员仍然编写这样的代码：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Does it impact the performance, even in theory? No: you can look at the assembly
    output and convince yourself that, with or without the extra check, there is only
    one comparison with null.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在理论上，它会影响性能吗？不会：你可以查看汇编输出，并确信，无论是否有额外的检查，只有一次与null的比较。
- en: Now that you have a better understanding of how the compiler sees your program,
    let us see one more useful technique for getting better optimization out of the
    compiler.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对编译器如何看待您的程序有了更好的理解，让我们看看如何通过另一种有用的技术来获得更好的编译器优化。
- en: Lifting knowledge from runtime to compile time
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从运行时到编译时的知识提升
- en: 'The method we are about to discuss here boils down to one thing: give the compiler
    more information about the program, in this case, by converting runtime information
    into compile-time information. In the following example, we need to process a
    lot of geometric objects represented by the `Shape` class. They are stored in
    a container (if the type is polymorphic, it would be a container of pointers).
    The processing consists of doing one of two operations: we either shrink each
    object or grow it. Let''s see how:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的方法归结为一件事：通过将运行时信息转换为编译时信息，为编译器提供有关程序的更多信息。在以下示例中，我们需要处理由`Shape`类表示的大量几何对象。它们存储在一个容器中（如果类型是多态的，它将是指针的容器）。处理包括执行两种操作之一：我们要么收缩每个对象，要么增长它。让我们看看：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To generalize, we have a function whose behavior is controlled by one or more
    configuration variables at runtime. Often, these variables are Boolean (for readability,
    we chose an `enum`). We have already seen that if the configuration parameter
    `op` is passed by reference, the compiler has to leave the comparison inside the
    loop and evaluate it for every shape. Even if the parameter is passed by value,
    many compilers will not hoist the branch out of the loop: it requires duplicating
    the body of the loop (one loop for shrink and one for grow), and the compilers
    are wary of bloating the code too much.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们有一个函数，其行为由一个或多个配置变量在运行时控制。通常，这些变量是布尔值（为了可读性，我们选择了一个`enum`）。我们已经看到，如果配置参数`op`是通过引用传递的，编译器必须在循环内保留比较，并为每个形状评估它。即使参数是按值传递的，许多编译器也不会将分支提升出循环：它需要复制循环体（一个用于收缩和一个用于增长），编译器对膨胀代码过多持谨慎态度。
- en: 'This concern should be taken seriously: a larger executable takes longer to
    load, and more code increases the stress on the instruction cache (i-cache, used
    to cache the upcoming instructions the same way as the data caches cache the data
    that is about to be used by the CPU). However, in some cases, this optimization
    is still the right choice: often, you know that a lot of data is processed without
    changing the configuration variables. Maybe these variables are even constant
    for the entire run of the program (you load the configuration once and use it).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题应该被认真对待：一个更大的可执行文件加载时间更长，而更多的代码会增加指令缓存（i-cache）的压力（i-cache用于缓存即将被CPU使用的指令，就像数据缓存缓存即将被CPU使用的数据一样）。然而，在某些情况下，这种优化仍然是正确的选择：通常情况下，您知道很多数据在不改变配置变量的情况下被处理。也许这些变量甚至对整个程序的运行都是常量（您加载配置一次并使用它）。
- en: 'It is easy to rewrite our simple example to move the branch out of the loop,
    but if the code is complex, so is the refactoring. We can get some assistance
    from the compiler if we are willing to give it assistance in turn. The idea is
    to convert the runtime value into the compile-time one:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将分支移出循环对于我们简单的例子来说很容易重写，但如果代码很复杂，重构也是复杂的。如果我们愿意给予编译器帮助，我们可以从编译器那里得到一些帮助。这个想法是将运行时值转换为编译时值：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The entire (potentially large) old function `process()` is converted to a template,
    but other than that, there are no changes. Specifically, we did not move the branch
    out of the loop. However, the condition controlling the branch is now a compile-time
    constant (the template parameter). The compiler will eliminate the branch, and
    the corresponding dead code, in each template instantiation. In the rest of our
    program, the configuration variable is still a runtime value, just one that doesn't
    change very often (or not at all). So we still need a runtime test, but it is
    used only to decide which template instantiation to call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 整个（可能很大）的旧函数`process()`被转换为一个模板，但除此之外，没有其他改变。具体来说，我们没有将分支移出循环。然而，控制分支的条件现在是一个编译时常量（模板参数）。编译器将消除每个模板实例化中的分支和相应的死代码。在我们程序的其余部分，配置变量仍然是一个运行时值，只是很少（或根本不）改变。因此，我们仍然需要运行时测试，但它只用于决定调用哪个模板实例化。
- en: 'This approach can be generalized. Imagine that we need to compute some properties
    for each shape, like volume, dimensions, weight, and so on. This is all done by
    a single function because a lot of the calculations are shared between different
    properties. But it takes time to compute properties we do not need, so we may
    implement a function like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以泛化。想象一下，我们需要为每个形状计算一些属性，比如体积、尺寸、重量等等。这一切都是由一个单一的函数完成的，因为很多计算在不同的属性之间是共享的。但是计算我们不需要的属性会花费时间，所以我们可以实现一个像这样的函数：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A null pointer is valid and indicates that we do not need that result. Inside
    the function, we write the code optimally for a particular combination of requested
    values: we do common computations only once, and we don''t compute anything we
    do not need. However, this check is done inside the loop over shapes, and this
    time, it is a pretty complex set of conditions. If we need to process a lot of
    shapes for the same set of measurements, hoisting the conditions out of the loop
    makes sense, but the compiler is unlikely to do it, even if it can. Again, we
    can write a template with many non-type parameters: they will be Boolean values
    like `need_length`, `need_width`, and so on. Inside that template, the compiler
    will eliminate all the branches that never get executed for a particular combination
    of measurements because now this is compile-time information. The function that
    is called at runtime has to forward the call to the correct template instantiation
    based on which pointers are non-null. One of the most efficient implementations
    of this is a lookup table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 空指针是有效的，并且表示我们不需要该结果。在函数内部，我们为请求的值的特定组合编写了最佳代码：我们只进行一次常见的计算，并且不计算任何我们不需要的东西。然而，这个检查是在形状循环内部进行的，这次是一个相当复杂的条件集。如果我们需要处理大量形状以获取相同的测量集合，那么将条件提升出循环是有意义的，但即使编译器可以做到这一点，它也不太可能这样做。同样，我们可以编写一个具有许多非类型参数的模板：它们将是布尔值，比如`need_length`、`need_width`等等。在该模板内部，编译器将消除所有对于特定测量组合从未执行的分支，因为现在这是编译时信息。在运行时调用的函数必须根据哪些指针是非空来将调用转发到正确的模板实例化。其中一个最有效的实现是查找表：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This generates a great deal of code: each variant of the measurement is a new
    function. The effect of such a significant transformation should always be validated
    by profiling. However, in cases where the measurements are relatively simple (say,
    many shapes are a cube) and the same set of measurements is requested for many
    (millions) of shapes, this change can yield substantial performance gains.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成大量的代码：每个测量的变体都是一个新的函数。这种重大转变的影响应该始终通过性能分析来验证。然而，在测量相对简单的情况下（比如，许多形状都是立方体），并且对许多（数百万）形状请求相同的测量集合时，这种改变可以带来显著的性能提升。
- en: When working with a particular compiler, it pays to know its capabilities, including
    the optimizations. Such level of detail is beyond the scope of this book, and
    it is volatile knowledge – the compilers evolve quickly. Instead, this chapter
    lays the foundation for the understanding of compiler optimizations and gives
    you, the reader, the frame of reference to advance your understanding. Let us
    recap the main points of what we learned.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用特定编译器时，了解其功能和优化是很重要的。这种细节超出了本书的范围，而且这是易变的知识——编译器发展迅速。相反，本章为理解编译器优化奠定了基础，并为您读者提供了进一步理解的参考框架。让我们回顾一下我们学到的主要要点。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have explored the second of the main areas of C++ efficiency:
    helping the compiler generate more efficient code.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C++效率的主要领域之一：帮助编译器生成更高效的代码。
- en: The goal of this book is to arm you with the understanding of the interaction
    between your code, the computer, and the compiler so that you can make these determinations
    with good judgment and solid understanding.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是让你了解代码、计算机和编译器之间的交互，以便你能够凭借良好的判断力和扎实的理解做出这些决定。
- en: 'The easiest way to help the compiler optimize your code is to follow the general
    *rules of thumb* for effective optimization, many of which are also rules of good
    design: minimize the interfaces and interactions between different sections of
    the code, organize the code into blocks, functions, and modules, each of which
    has simple logic and well-defined interface boundaries, avoid global variables
    and other *hidden* interactions, and so on. The fact that these are also best
    design practices is not coincidental: generally, code that is easy for a programmer
    to read is also easy for the compiler to analyze.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助编译器优化你的代码最简单的方法是遵循有效优化的一般*经验法则*，其中许多也是良好设计的规则：最小化代码不同部分之间的接口和交互，将代码组织成块、函数和模块，每个模块都有简单的逻辑和明确定义的接口边界，避免全局变量和其他*隐藏*的交互等。这些也是最佳设计实践并非巧合：通常，对程序员易读的代码也易于编译器分析。
- en: 'More advanced optimizations often require examining the code produced by the
    compiler. If you notice the compiler not doing some optimization, consider whether
    there is a scenario where that optimization is invalid: think not what happens
    in your program but what can happen in a given fragment of code (for example,
    you may know that you never use global variables, but the compiler has to assume
    that you might).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的优化通常需要检查编译器生成的代码。如果你注意到编译器没有进行某些优化，考虑一下是否存在某种情况下该优化是无效的：不要考虑你的程序中发生了什么，而是考虑在给定的代码片段中可能发生了什么（例如，你可能知道你从不使用全局变量，但编译器必须假设你可能会使用）。
- en: In the next chapter, we are going to explore a very subtle area of C++ (as well
    as software design in general) that can have unexpected overlap with the study
    of performance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C++（以及软件设计一般）中一个非常微妙的领域，它可能与性能研究产生意想不到的重叠。
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What constrains the compiler optimizations?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么限制了编译器的优化？
- en: Why is function inlining so important for compiler optimizations?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么函数内联对编译器优化如此重要？
- en: Why doesn't the compiler make an *obvious* optimization?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么编译器不进行*显而易见*的优化？
- en: Why is inlining an effective optimization?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么内联是一种有效的优化？
