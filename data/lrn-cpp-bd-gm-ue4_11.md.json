["```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Monster.generated.h\"\n\nUCLASS()\nclass GOLDENEGG_API AMonster : public ACharacter\n{\n    GENERATED_BODY()\npublic:\n    AMonster(const FObjectInitializer& ObjectInitializer);\n\n        // How fast he is \n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n            MonsterProperties)\n        float Speed;\n\n    // The hitpoints the monster has \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        MonsterProperties)\n        float HitPoints;\n\n    // Experience gained for defeating \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        MonsterProperties)\n        int32 Experience;\n\n    // Blueprint of the type of item dropped by the monster \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        MonsterProperties)\n        UClass* BPLoot;\n\n    // The amount of damage attacks do \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        MonsterProperties)\n        float BaseAttackDamage;\n\n    // Amount of time the monster needs to rest in seconds \n    // between attacking \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        MonsterProperties)\n        float AttackTimeout;\n\n    // Time since monster's last strike, readable in blueprints \n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =\n        MonsterProperties)\n        float TimeSinceLastStrike;\n\n    // Range for his sight \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n        Collision)\n        USph.ereComponent* SightSphere;\n\n    // Range for his attack. Visualizes as a sphere in editor, \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n        Collision)\n        USphereComponent* AttackRangeSphere;\n};\n```", "```cpp\nAMonster::AMonster(const FObjectInitializer& ObjectInitializer)\n : Super(ObjectInitializer)\n{\n Speed = 20;\n HitPoints = 20;\n Experience = 0;\n BPLoot = NULL;\n BaseAttackDamage = 1;\n AttackTimeout = 1.5f;\n TimeSinceLastStrike = 0;\n\n SightSphere = ObjectInitializer.CreateDefaultSubobject<USphereComponent>\n (this, TEXT(\"SightSphere\"));\n SightSphere->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\n AttackRangeSphere = ObjectInitializer.CreateDefaultSubobject\n <USphereComponent>(this, TEXT(\"AttackRangeSphere\"));\n AttackRangeSphere->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n}\n```", "```cpp\nvirtual void Tick(float DeltaSeconds) override; \n```", "```cpp\nvoid AMonster::Tick(float DeltaSeconds) {\n    Super::Tick(DeltaSeconds); \n\n    //basic intel : move the monster towards the player \n    AAvatar *avatar = Cast<AAvatar>(\n            UGameplayStatics::GetPlayerPawn(GetWorld(), 0)); \n    if (!avatar) return;\n    FVector toPlayer = avatar->GetActorLocation() - GetActorLocation(); \n    toPlayer.Normalize(); // reduce to unit vector \n                        // Actually move the monster towards the player a bit\n    AddMovementInput(toPlayer, Speed*DeltaSeconds); // At least face the target\n    // Gets you the rotator to turn something // that looks in the `toPlayer`direction \n    FRotator toPlayerRotation = toPlayer.Rotation();\n    toPlayerRotation.Pitch = 0; // 0 off the pitch\n    RootComponent->SetWorldRotation(toPlayerRotation);\n}\n```", "```cpp\n#include \"Avatar.h\"\n\n#include \"Kismet/GameplayStatics.h\"\n```", "```cpp\nvoid AMonster::Tick(float DeltaSeconds) \n{ \n  Super::Tick( DeltaSeconds ); \n  AAvatar *avatar = Cast<AAvatar>(  \n   UGameplayStatics::GetPlayerPawn(GetWorld(), 0) ); \n  if( !avatar ) return; \n    FVector toPlayer = avatar->GetActorLocation() -  \n     GetActorLocation(); \n  float distanceToPlayer = toPlayer.Size(); \n  // If the player is not in the SightSphere of the monster, \n  // go back \n  if( distanceToPlayer > SightSphere->GetScaledSphereRadius() ) \n  { \n    // If the player is out of sight, \n    // then the enemy cannot chase \n    return; \n  } \n\n  toPlayer /= distanceToPlayer;  // normalizes the vector \n  // Actually move the monster towards the player a bit \n  AddMovementInput(toPlayer, Speed*DeltaSeconds); \n  // (rest of function same as before (rotation)) \n} \n```", "```cpp\ninline bool isInSightRange( float d ) \n{ return d < SightSphere->GetScaledSphereRadius(); } \ninline bool isInAttackRange( float d ) \n{ return d < AttackRangeSphere->GetScaledSphereRadius(); } \n```", "```cpp\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"MeleeWeapon.generated.h\"\n\nclass AMonster;\n\nUCLASS()\nclass GOLDENEGG_API AMeleeWeapon : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMeleeWeapon(const FObjectInitializer& ObjectInitializer);\n\n    // The amount of damage attacks by this weapon do \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n        MeleeWeapon)\n        float AttackDamage;\n\n    // A list of things the melee weapon already hit this swing \n    // Ensures each thing sword passes thru only gets hit once \n    TArray<AActor*> ThingsHit;\n\n    // prevents damage from occurring in frames where \n    // the sword is not swinging \n    bool Swinging;\n\n    // \"Stop hitting yourself\" - used to check if the  \n    // actor holding the weapon is hitting himself \n    AMonster *WeaponHolder;\n\n    // bounding box that determines when melee weapon hit \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n        MeleeWeapon)\n        UBoxComponent* ProxBox;\n\n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n        MeleeWeapon)\n        UStaticMeshComponent* Mesh;\n\n    UFUNCTION(BlueprintNativeEvent, Category = Collision)\n        void Prox(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n            int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    // You shouldn't need this unless you get a compiler error that it can't find this function.\n    virtual int Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n        int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    void Swing();\n    void Rest();\n};\n```", "```cpp\n#include \"MeleeWeapon.h\"\n#include \"Monster.h\"\n\nAMeleeWeapon::AMeleeWeapon(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    AttackDamage = 1;\n    Swinging = false;\n    WeaponHolder = NULL;\n\n    Mesh = ObjectInitializer.CreateDefaultSubobject<UStaticMeshComponent>(this,\n        TEXT(\"Mesh\"));\n    RootComponent = Mesh;\n\n    ProxBox = ObjectInitializer.CreateDefaultSubobject<UBoxComponent>(this,\n        TEXT(\"ProxBox\"));  \n    ProxBox->OnComponentBeginOverlap.AddDynamic(this,\n            &AMeleeWeapon::Prox);\n    ProxBox->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n}\n\nint AMeleeWeapon::Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n    int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    // don't hit non root components \n    if (OtherComp != OtherActor->GetRootComponent())\n    {\n        return -1;\n    }\n\n    // avoid hitting things while sword isn't swinging, \n    // avoid hitting yourself, and \n    // avoid hitting the same OtherActor twice \n    if (Swinging && OtherActor != (AActor *) WeaponHolder &&\n        !ThingsHit.Contains(OtherActor))\n    {\n        OtherActor->TakeDamage(AttackDamage + WeaponHolder->BaseAttackDamage, FDamageEvent(), NULL, this);\n        ThingsHit.Add(OtherActor);\n    }\n\n    return 0;\n}\n\nvoid AMeleeWeapon::Swing()\n{\n    ThingsHit.Empty();  // empty the list \n    Swinging = true;\n}\n\nvoid AMeleeWeapon::Rest()\n{\n    ThingsHit.Empty();\n    Swinging = false;\n}\n```", "```cpp\n// The MeleeWeapon class the monster uses \n// If this is not set, he uses a melee attack \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  \n   MonsterProperties) \nUClass* BPMeleeWeapon; \n\n// The MeleeWeapon instance (set if the character is using \n// a melee weapon) \nAMeleeWeapon* MeleeWeapon; \n```", "```cpp\nvirtual void PostInitializeComponents() override; \n```", "```cpp\nvoid AMonster::PostInitializeComponents()\n{\n    Super::PostInitializeComponents();\n\n    // instantiate the melee weapon if a bp was selected \n    if (BPMeleeWeapon)\n    {\n        MeleeWeapon = GetWorld()->SpawnActor<AMeleeWeapon>(\n            BPMeleeWeapon, FVector(), FRotator());\n\n        if (MeleeWeapon)\n        {\n            const USkeletalMeshSocket *socket = GetMesh()->GetSocketByName(\n                FName(\"RightHandSocket\")); // be sure to use correct \n                                    // socket name! \n            socket->AttachActor(MeleeWeapon, GetMesh());\n            MeleeWeapon->WeaponHolder = this;\n        }\n    }\n}\n```", "```cpp\nif(   Monster.isInAttackRangeOfPlayer() )   \n{   \n    Monster.Animation = The Attack Animation;   \n}   \n```", "```cpp\n// in Monster.h: \nUFUNCTION( BlueprintCallable, Category = Collision ) \nvoid SwordSwung(); \n```", "```cpp\n// in Monster.cpp \nvoid AMonster::SwordSwung() \n{ \n  if( MeleeWeapon ) \n  { \n    MeleeWeapon->Swing(); \n  } \n} \n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Bullet.generated.h\"\n\nUCLASS()\nclass GOLDENEGG_API ABullet : public AActor\n{\n GENERATED_BODY()\n\npublic:\n // Sets default values for this actor's properties\n ABullet(const FObjectInitializer& ObjectInitializer);\n\n // How much damage the bullet does. \n UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =\n Properties)\n float Damage;\n\n // The visible Mesh for the component, so we can see \n // the shooting object \n UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n Collision)\n UStaticMeshComponent* Mesh;\n\n // the sphere you collide with to do impact damage \n UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =\n Collision)\n USphereComponent* ProxSphere;\n\n UFUNCTION(BlueprintNativeEvent, Category = Collision)\n void Prox(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n // You shouldn't need this unless you get a compiler error that it can't find this function.\n virtual int Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult); };\n```", "```cpp\nABullet::ABullet(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    Mesh = ObjectInitializer.CreateDefaultSubobject<UStaticMeshComponent>(this,\n        TEXT(\"Mesh\"));\n    RootComponent = Mesh;\n\n    ProxSphere = ObjectInitializer.CreateDefaultSubobject<USphereComponent>(this,\n        TEXT(\"ProxSphere\"));\n    ProxSphere->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\n    ProxSphere->OnComponentBeginOverlap.AddDynamic(this,\n        &ABullet::Prox);\n    Damage = 1;\n}\n```", "```cpp\nint ABullet::Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n    int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (OtherComp != OtherActor->GetRootComponent())\n    {\n        // don't collide w/ anything other than \n        // the actor's root component \n        return -1;\n    }\n\n    OtherActor->TakeDamage(Damage, FDamageEvent(), NULL, this);\n    Destroy();\n    return 0;\n}\n```", "```cpp\n// The blueprint of the bullet class the monster uses \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  \n   MonsterProperties) \nUClass* BPBullet; \n// Thrust behind bullet launches \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  \n   MonsterProperties) \nfloat BulletLaunchImpulse; \n```", "```cpp\nvoid AMonster::Tick(float DeltaSeconds) \n{ \n  Super::Tick( DeltaSeconds ); \n\n  // move the monster towards the player \n  AAvatar *avatar = Cast<AAvatar>(  \n   UGameplayStatics::GetPlayerPawn(GetWorld(), 0) ); \n  if( !avatar ) return; \n\n  FVector playerPos = avatar->GetActorLocation(); \n  FVector toPlayer = playerPos - GetActorLocation(); \n  float distanceToPlayer = toPlayer.Size(); \n\n  // If the player is not the SightSphere of the monster, \n  // go back \n  if( distanceToPlayer > SightSphere->GetScaledSphereRadius() ) \n  { \n    // If the player is OS, then the enemy cannot chase \n    return; \n  } \n\n  toPlayer /= distanceToPlayer;  // normalizes the vector \n\n  // At least face the target \n  // Gets you the rotator to turn something \n  // that looks in the `toPlayer` direction \n  FRotator toPlayerRotation = toPlayer.Rotation(); \n  toPlayerRotation.Pitch = 0; // 0 off the pitch \n  RootComponent->SetWorldRotation( toPlayerRotation ); \n\n  if( isInAttackRange(distanceToPlayer) ) \n  { \n    // Perform the attack \n    if( !TimeSinceLastStrike ) \n    { \n      Attack(avatar); \n    } \n\n    TimeSinceLastStrike += DeltaSeconds; \n    if( TimeSinceLastStrike > AttackTimeout ) \n    { \n      TimeSinceLastStrike = 0; \n    } \n\n    return;  // nothing else to do \n  } \n  else \n  { \n    // not in attack range, so walk towards player \n    AddMovementInput(toPlayer, Speed*DeltaSeconds); \n  } \n} \n```", "```cpp\nvoid Attack(AActor* thing); \n```", "```cpp\nvoid AMonster::Attack(AActor* thing) \n{ \n  if( MeleeWeapon ) \n  { \n    // code for the melee weapon swing, if  \n    // a melee weapon is used \n    MeleeWeapon->Swing(); \n  } \n  else if( BPBullet ) \n  { \n    // If a blueprint for a bullet to use was assigned, \n    // then use that. Note we wouldn't execute this code \n    // bullet firing code if a MeleeWeapon was equipped \n    FVector fwd = GetActorForwardVector(); \n    FVector nozzle = GetMesh()->GetBoneLocation( \"RightHand\" ); \n    nozzle += fwd * 155;// move it fwd of the monster so it  \n     doesn't \n    // collide with the monster model \n    FVector toOpponent = thing->GetActorLocation() - nozzle; \n    toOpponent.Normalize(); \n    ABullet *bullet = GetWorld()->SpawnActor<ABullet>(  \n     BPBullet, nozzle, RootComponent->GetComponentRotation()); \n\n    if( bullet ) \n    { \n      bullet->Firer = this; \n      bullet->ProxSphere->AddImpulse(  \n        toOpponent*BulletLaunchImpulse ); \n    } \n    else \n    { \n      GEngine->AddOnScreenDebugMessage( 0, 5.f,  \n      FColor::Yellow, \"monster: no bullet actor could be spawned.  \n       is the bullet overlapping something?\" ); \n    } \n  } \n} \n```", "```cpp\nABullet *bullet = GetWorld()->SpawnActor<ABullet>(BPBullet,  \n   nozzle, RootComponent->GetComponentRotation() );\n```", "```cpp\nAMonster *Firer;\n```", "```cpp\nFVector knockback; // in class AAvatar\n```", "```cpp\nvirtual float TakeDamage(float DamageAmount, struct FDamageEvent const& DamageEvent, class AController* EventInstigator, AActor* DamageCauser) override;\n```", "```cpp\nfloat AAvatar::TakeDamage(float DamageAmount, struct FDamageEvent const& DamageEvent, class AController* EventInstigator, AActor* DamageCauser)\n{\n    // add some knockback that gets applied over a few frames \n    knockback = GetActorLocation() - DamageCauser->GetActorLocation();\n    knockback.Normalize();\n    knockback *= DamageAmount * 500; // knockback proportional to damage \n    return AActor::TakeDamage(DamageAmount, DamageEvent, EventInstigator, DamageCauser);\n}\n```", "```cpp\nvoid AAvatar::Tick( float DeltaSeconds ) \n{ \n  Super::Tick( DeltaSeconds ); \n\n  // apply knockback vector \n  AddMovementInput( -1*knockback, 1.f ); \n\n  // half the size of the knockback each frame \n  knockback *= 0.5f; \n} \n```"]