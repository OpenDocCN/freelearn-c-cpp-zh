- en: '*Chapter 1*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*'
- en: Antithesis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反面
- en: Telling an Object What to Do
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 告诉对象要做什么
- en: '*The big idea is "messaging" – that is, what the kernal [sic] of Smalltalk/Squeak
    is all about (and it''s something that was never quite completed in our Xerox
    PARC phase). The Japanese have a small word – ma – for "that which is in between"
    – perhaps the nearest English equivalent is "interstitial." The key in making
    great and growable systems is much more to design how its modules communicate
    rather than what their internal properties and behaviors should be.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个大思想是“消息传递”——这正是Smalltalk/Squeak的核心所在（而且这是我们Xerox PARC阶段从未完全完成的事情）。日本人有一个小词——ma——表示“介于两者之间”——也许最接近的英语对应词是“interstitial”。在构建伟大且可扩展的系统时，关键更多地在于设计模块之间的通信方式，而不是它们的内部属性和行为应该是什么。*'
- en: '*Alan Kay, (squeak-dev mailing list —* [http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html](http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html)*)*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*艾伦·凯，（squeak-dev邮件列表 —* [http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html](http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html)*)*'
- en: 'A huge amount of complexity is wrapped up in that most common of operations:
    invoking an object''s method. In many programming languages – C++, Java, Python,
    and others – this takes the form `anObject.methodName()`, which means "there will
    be a method on the class that `anObject` is an instance of, or some antecedent
    class, where the method is called `methodName`, please find it and run it, with
    the `self` or `this` value aliased to `anObject`." So, for example, in Java we
    would expect to find a (non-abstract) `public void methodName() { /* ... */ }`
    somewhere in `anObject`''s class or parent.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中（如C++、Java、Python等），调用对象的方法通常采用`anObject.methodName()`的形式，这意味着“在`anObject`实例所属的类或其祖先类中，将存在一个名为`methodName`的方法，请找到它并运行它，其中`self`或`this`值被别名替换为`anObject`。”例如，在Java中，我们期望在`anObject`的类或父类中找到（非抽象的）`public
    void methodName() { /* ... */ }`。
- en: 'This guarantee introduces a lot of coupling between the caller and the object
    that holds the method:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个保证在调用者和持有方法的对象之间引入了大量的耦合：
- en: The caller knows that the object is an instance of some class (there are so
    many issues bound up with inheritance that it gets its own chapter, later).
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者知道该对象是某个类的实例（与继承相关的问题如此之多，以至于它将在后面的章节中单独讨论）。
- en: The caller knows that the object's class, or some ancestor of it, provides a
    method with the given name.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者知道对象的类或其祖先类提供了一个具有给定名称的方法。
- en: The method will run to completion in this context, then give control back to
    the caller (this is not particularly evident from the syntax in isolation, but
    nonetheless is assumed).
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法将在当前上下文中运行到完成，然后控制权将返回给调用者（这并不是从孤立的角度看语法就能特别明显，但确实是被假设的）。
- en: What would it mean to lift those assumptions? It would make the object a truly
    independent computer program, communicating from a distance over an agreed protocol
    based on message passing. What that object does, how it does it, even what programming
    language it's implemented in, are all private to the object. Does it collaborate
    with a class to find out how to respond to the message? Does that class have one
    parent or multiple parents?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃这些假设意味着什么？这将使该对象成为一个真正独立的计算机程序，通过基于消息传递的协议从远处进行通信。该对象做什么，它是如何做的，甚至它实现的是哪种编程语言，所有这些都是该对象的私有信息。它是与一个类协作来找出如何响应消息吗？那个类有一个父类还是多个父类？
- en: 'The *idea* behind message-passing is exactly that arms-length separation of
    concerns, but even programming languages that are based on the message-passing
    scheme usually treat it as a special case of "look up a method," to be followed
    only if the usual method-resolution fails. These languages typically have a particular
    named method that will be run when the requested method isn''t found. In Smalltalk,
    it''s called `doesNotUnderstand:`, while in Ruby it''s called `method_missing()`.
    Each one receives the *selector* (that is, the unique name of the method the caller
    was hoping to invoke) to decide what to do with it. This gets us a higher level
    of decoupling: objects can send messages to one another without having to peek
    at the others'' implementations to discover whether they implement a method matching
    the message.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递背后的*理念*正是这种关注点的分离，但即使是基于消息传递方案构建的编程语言，通常也将其视为“查找方法”的特殊情况，只有在常规方法解析失败时才会遵循。这些语言通常有一个特定的命名方法，当请求的方法找不到时将会执行。在Smalltalk中，它被称为`doesNotUnderstand:`，而在Ruby中则称为`method_missing()`。每个方法都接收*选择器*（即调用者希望调用的方法的唯一名称）来决定如何处理它。这使我们获得更高层次的解耦：对象可以相互发送消息，而无需查看其他对象的实现以确定它们是否实现了匹配该消息的方法。
- en: Why is that decoupling valuable? It lets us build our objects as truly standalone
    programs, considering only what their contract is with the outside world and how
    their implementation supports that contract. By requiring, for example, that an
    object will only receive a message if it is an instance of a class that contains
    a Java function of the same name that can be pushed onto the call stack, even
    if via a Java interface (a list of methods that a Java class can provide), we
    adopt a lot of assumptions about the implementation of the message receiver, turning
    them into constraints that the programmer must deal with when building the sender.
    We do not have independent, decoupled programs collaborating over a message interface,
    but a rigid system with a limited amount of modularity. Understanding one object
    means pulling in information about other parts of the system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这种解耦有价值呢？它让我们能够将对象构建成真正的独立程序，只考虑它们与外部世界的合同以及它们的实现如何支持该合同。例如，要求一个对象只有在它是包含具有相同名称的Java函数的类的实例时才会接收消息，即使是通过Java接口（Java类可以提供的方法列表），我们就对消息接收者的实现做出了一系列假设，将它们转化为程序员在构建发送者时必须处理的约束。我们没有独立、解耦的程序通过消息接口协作，而是一个具有有限模块化的刚性系统。理解一个对象意味着引入关于系统其他部分的信息。
- en: '*This is not merely an academic distinction, as it constrains the design of
    real systems. Consider an application to visualize some information about a company''s
    staff, which is located in a key-value store. If I need every object between the
    view and the store to know about all of the available methods, then I either duplicate
    my data schema everywhere in the app by defining methods like* `salary()` *or*
    `payrollNumber()`*, or I provide meaningless generic interfaces like* `getValue(String
    key)` *that remove the useful information that I''m working with representations
    of people in the company.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个学术上的区别，因为它限制了真实系统的设计。考虑一个用于可视化公司员工某些信息的应用程序，这些信息存储在键值存储中。如果需要视图和存储之间的每个对象都知道所有可用的方法，那么我必须在应用程序的每个地方重复我的数据模式，通过定义像`salary()`或`payrollNumber()`这样的方法，或者提供无意义的通用接口，如`getValue(String
    key)`，这些接口移除了我正在处理的人的表示的有用信息。
- en: Conversely, I could say to my `Employee` object "if you get a message you do
    not recognize, but it looks like a key in the key-value store, reply with the
    value you find for that key." I could say to my view object "if you get a message
    you do not recognize, but the `Employee` gives you a value in response to it,
    prepare that value for display and use the selector name as the label for that
    value." The behavior – looking up arbitrary values in the key-value store – remains
    the same but the message network tells us more about *why* the application is
    doing what it does.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我可以说对我的`Employee`对象：“如果你收到一个你不认识的消息，但它看起来像键值存储中的一个键，就回复你找到的那个键的值。”我可以说对我的视图对象：“如果你收到一个你不认识的消息，但`Employee`在响应它时给你一个值，准备那个值以供显示，并使用选择器名称作为该值的标签。”行为——在键值存储中查找任意值——保持不变，但消息网络告诉我们更多关于*为什么*应用程序正在做什么的信息。
- en: By providing lazy resolution paths like `method_missing`, systems like Ruby
    partially lift these assumptions and provide tools to enable greater decoupling
    and independence of objects in the network. To fully take advantage of this, we
    must change the language used and the way we think about these features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供像`method_missing`这样的延迟解析路径，像Ruby这样的系统部分地消除了这些假设，并提供了工具来启用更大的解耦和网络中对象的独立性。为了充分利用这一点，我们必须改变使用的语言和思考这些功能的方式。
- en: 'A guide to OOP in Ruby will probably tell you that methods are looked up by
    name, but if that fails, the class can optionally implement `method_missing` to
    supply custom behavior. This is exactly backwards: saying that objects are bags
    of named methods until that stops working, when they gain some autonomy.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于Ruby中面向对象编程（OOP）的指南可能会告诉你，方法是通过名称查找的，但如果失败了，类可以可选地实现`method_missing`来提供自定义行为。这完全相反：说对象是一系列命名方法，直到它们不再起作用，这时它们获得了一些自主性。
- en: 'Flip this language: an object is responsible for deciding how it handles messages,
    and one particular convenience is that they automatically run methods that match
    a received selector without any extra processing. Now your object truly is an
    autonomous actor responding to messages, rather than a place to store particular
    named routines in a procedural program.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转这种语言：一个对象负责决定如何处理消息，一个特别的便利之处是它们会自动运行与接收到的选择器匹配的方法，而无需任何额外处理。现在你的对象真正成为一个自主的演员，响应消息，而不是在程序性程序中存储特定命名例程的地方。
- en: There are object systems that expose this way of thinking about objects, a good
    example being the CMU Mach system. Mach is an operating system kernel that supplies
    communication between threads (in the same or different tasks) using message passing.
    A sender need know nothing about the receiver other than its port (the place to
    put outgoing messages) and how to arrange a message to be put in the port. The
    receiver knows nothing about the sender; just that a message has appeared on its
    port and can be acted on. The two could be in the same task, or not even on the
    same computer. They do not even need to be written in the same language, they
    just need to know what the messages are and how to put them on a port.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些对象系统公开了这种关于对象的想法，一个好的例子是CMU Mach系统。Mach是一个操作系统内核，它通过消息传递在（相同或不同的任务）线程之间提供通信。发送者不需要知道接收者除了其端口（放置输出消息的地方）以及如何安排消息放入端口之外的信息。接收者对发送者一无所知；只知道在其端口上出现了一条消息，可以对其进行处理。这两个对象可以在同一个任务中，或者甚至不在同一台计算机上。它们甚至不需要用同一种语言编写，只需要知道消息的内容以及如何将它们放入端口。
- en: In the world of service-oriented architecture, a microservice is an independent
    program that collaborates with peers over a loosely coupled interface comprised
    of messages sent over some implementation-independent transport mechanism – often
    HTTPS or protocol buffers. This sounds a lot like OOP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向服务的架构世界中，一个微服务是一个独立的程序，它通过一个松散耦合的接口与同伴协作，该接口由通过某些实现无关的传输机制发送的消息组成——通常是HTTPS或协议缓冲区。这也听起来很像OOP。
- en: Microservice adopters are able to implement different services in different
    technologies, to think about changes to a given service only in terms of how they
    satisfy the message contract, and to independently replace individual services
    without disrupting the whole system. This, too, sounds a lot like OOP.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务的用户能够使用不同的技术实现不同的服务，仅从它们如何满足消息合同的角度来考虑给定服务的变更，并且可以独立替换单个服务，而不会影响整个系统。这也听起来很像面向对象编程（OOP）。
- en: Designing an Object
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个对象
- en: '*The object-oriented approach attempts to manage the complexity inherent in
    real-world problems by abstracting out knowledge and encapsulating it within objects.
    Finding or creating these objects is a problem of structuring knowledge and activities.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象的方法试图通过抽象出知识并将其封装在对象中来管理现实世界问题中固有的复杂性。找到或创建这些对象是结构知识和活动的问题。*'
- en: '*Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener, Designing Object-Oriented
    Software*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*丽贝卡·维夫斯-布洛克、布莱恩·威尔克森和劳伦·维纳，面向对象软件设计*'
- en: An early goal of OOP was to simplify the work of software system design by reducing
    the big problem "design this large system to solve these problems" into the small
    problems "design these small systems" and "combine these small systems such that
    they solve these problems in concert". Brad Cox, an object technologist who built
    the Objective-C language and cofounded a company to exploit it, wrote an article
    "*What if there's a Silver Bullet...And the Competition Gets It First?*" in which
    he asserted that OOP represented a significant reduction in software complexity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的早期目标是通过将大问题“设计这个大型系统来解决这些问题”分解为小问题“设计这些小系统”以及“将这些小系统组合起来以共同解决问题”，从而简化软件系统设计的工作。布拉德·科克斯，这位构建了Objective-C语言并共同创立了一家利用该语言的公司面向对象技术专家，撰写了一篇名为“如果有一个银弹...而竞争者先得到了它？*”的文章，他在文章中声称面向对象代表了软件复杂性的显著降低。
- en: '*In the broadest sense, "object-oriented" refers to the war and not the weapons,
    the ends and not the means, an objective rather than technologies for achieving
    it. It means orienting on objects rather than on processes for building them;
    wielding all the tools programmers can muster, from well-proven antiques like
    Cobol to as-yet missing ones like specification/testing languages, to enable software
    consumers, letting them reason about software products with the common-sense skills
    we all use to understand the tangible objects of everyday experience.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在最广泛的意义上，“面向对象”指的是战争而不是武器，是目的而不是手段，是目标而不是实现它的技术。这意味着以对象为导向而不是以过程为导向来构建它们；运用程序员可以调动的所有工具，从经过充分验证的古董如Cobol到尚未出现的如规格/测试语言，以使软件消费者能够使用我们所有人都用来理解日常经验中可触摸对象的常识技能来推理软件产品。
- en: '*It means relinquishing the traditional process-centered paradigm with the
    programmer-machine relationship at the center of the software universe in favor
    of a product-centered paradigm with the producer-consumer relationship at the
    center.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着放弃传统的以程序员-机器关系为中心的过程中心范式，转而采用以产品为中心的范式，其中生产者-消费者关系处于中心。
- en: 'Nonetheless, many "object-oriented" design techniques still rely on considering
    the system as a whole, building artisanal, bespoke objects from scratch that will
    comprise the system that satisfies the customer''s needs. In this sense, Cox''s
    vision has not come to pass: he hoped for the "software industrial revolution"
    in which standardized components (software-ICs, analogous with integrated circuits
    in electronics design) could be specified based on their externally visible behavior
    and composed into a system relevant to the task at hand. Rather, we still have
    a craft industry, but now the application-specific components we build every time
    are called "objects."'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，许多“面向对象”的设计技术仍然依赖于将系统作为一个整体来考虑，从头开始构建定制的、手工制作的对象，这些对象将构成满足客户需求的系统。从这个意义上说，科克斯的愿景尚未实现：他希望有“软件工业革命”，其中标准化的组件（软件-集成电路，类似于电子设计中的集成电路）可以根据其外部可见的行为进行指定，并组合成与当前任务相关的系统。相反，我们仍然有一个手工艺行业，但现在我们每次构建的应用特定组件被称为“对象”。
- en: 'This approach – designing a whole system as a single software product but calling
    the bits "objects" – goes under the name of **Object-Oriented Analysis and Design**.
    Typically, it is expressed as a way to decompose big problems according to the
    *data* used to solve the problem, so that OOP becomes an "alternative" to functional
    programming, in which the big problem is decomposed according to the *operations*
    used in its solution. An uncaptioned table in "Using Functions for Easier Programming"
    by Neil Savage — [https://dl.acm.org/citation.cfm?id=3193776](https://dl.acm.org/citation.cfm?id=3193776)
    from 2018 describes the term Object-Oriented:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法——将整个系统设计为一个单一的软件产品，但将各个部分称为“对象”——被称为**面向对象分析与设计**。通常，它被表达为根据解决问题的数据分解大问题的方法，因此面向对象编程成为功能编程的“替代品”，在功能编程中，大问题是根据其解决方案中使用的操作来分解的。尼尔·萨维奇在2018年的“使用函数简化编程”中未标注标题的表格——[https://dl.acm.org/citation.cfm?id=3193776](https://dl.acm.org/citation.cfm?id=3193776)——描述了面向对象的术语：
- en: '*The central mode for abstraction is the data itself, thus the value of a term
    isn''t always predetermined by the input (stateful approach).*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的核心模式是数据本身，因此一个术语的价值并不总是由输入（有状态方法）预先决定的。
- en: 'The term Functional programming is described as:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程这个术语被描述为：
- en: '*The central mode for abstraction is the function, not the data structure,
    thus the value of a term is always predetermined by the input (stateless approach).*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象的中心模式是函数，而不是数据结构，因此一个术语的值总是由输入（无状态方法）预先确定的。*'
- en: Never mind that "functional" languages like Haskell have mechanisms designed
    for handling state, or that plenty of problems we might want to solve in the world
    have both stateful and stateless aspects!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不要理会像 Haskell 这样的“功能性”语言有处理状态的机制，或者我们可能想要解决的世界上的许多问题既有有状态和无状态方面！
- en: 'This idea of objects-as-data does have its roots in the OOP movement. In his
    textbook "*A Touch of Class*" from 2009, in Section 2.3 "*What is an object*?",
    Bertrand Meyer uses the following definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对象作为数据的思想确实有其根源在面向对象编程运动中。在他的2009年教科书“*A Touch of Class*”的第2.3节“*什么是对象*？”中，Bertrand
    Meyer 使用了以下定义：
- en: '*An object is a software machine allowing programs to access and modify a collection
    of data.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象是一个软件机器，允许程序访问和修改数据集合。*'
- en: This is in exact opposition to the usual goals of "encapsulation" or "data hiding"
    that we have heard about, in which we try to *forbid* programs from accessing
    and modifying our data! In this view, we have the object as a "software machine,"
    which is good as it suggests some kind of independent, autonomous function, but
    unfortunately, we get the idea that the purpose of this machine is to look after
    some slice of our data from the overall collection used throughout the program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们所听说的“封装”或“数据隐藏”的通常目标正好相反，我们试图*禁止*程序访问和修改我们的数据！在这个观点中，我们将对象视为“软件机器”，这很好，因为它暗示了一种独立、自主的功能，但不幸的是，我们得到了这样一个观点：这个机器的目的是照顾程序中使用的整体数据集合中的一小部分数据。
- en: 'It is this mindset that leads to objects as "active structures," like this
    typical example in C#:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种心态导致了对象作为“活跃结构”，如下面的典型 C# 示例：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This satisfies our requirement for encapsulation (the field is private), and
    our requirement that an object allows programs to access and modify a collection
    of data. What we have ended up with is no different from a plain old data structure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这满足了我们对封装的要求（字段是私有的），以及我们需要对象允许程序访问和修改数据集合的要求。我们最终得到的结果与一个普通的数据结构没有区别：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The exception is that the C# example requires a function call on each access
    of the field. There is no *real* encapsulation; objects with their own fields
    can make no guesses about the status of those fields, and a system including such
    objects can only be understood by considering the whole system. The hoped-for
    advantage that we could turn our big problem into a composition of small problems
    has been lost.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例外的是，C# 示例要求在每次访问字段时进行函数调用。这并不是真正的封装；拥有自己字段的物体无法猜测这些字段的状态，而包含此类物体的系统只能通过考虑整个系统来理解。我们原本希望将大问题分解为小问题的优势已经丧失。
- en: A contributor to this objects-as-data approach seems to have been the attempt
    to square object-oriented programming with **Software Engineering**, a field of
    interest launched in 1968 that aimed to bring product design and construction
    skills to computer scientists by having very clever computer scientists think
    about what product design and construction might be like and not ask anybody.
    Process-heavy and design-artefact-heavy systems, approaches, and "methodologies"
    (a word that used to mean "the study of method" until highfalutin software engineers
    took it to mean "method, but a longer word") recommended deciding on the objects,
    their methods, and properties; the data involved; and the presentation and storage
    of that data in excruciating detail, all in the name of satisfying a **Use Case**,
    which is Software Engineering speak for "a thing somebody might want to do."
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对象作为数据方法的贡献者似乎是对将面向对象编程与**软件工程**相结合的尝试，这是一个始于1968年的研究领域，旨在通过让非常聪明的计算机科学家思考产品设计与构建可能是什么样子，而不去询问任何人，将产品设计与构建技能带给计算机科学家。过程密集型和设计工件密集型的系统、方法和“方法论”（这个词曾经意味着“方法的研究”，直到自负的软件工程师将其用作“方法，但更长的词”）推荐决定对象、它们的方法和属性；涉及的数据；以及数据的展示和存储的细节，所有这些都在满足**用例**的名义下进行，这是软件工程术语，意为“某人可能想要做的事情”。
- en: The inside cover of "*Applying UML and Patterns*" by Craig Larman (1997) has
    22 detailed steps to follow before **Construction** when constructing a product.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Craig Larman（1997年）的“*Applying UML and Patterns*”的内部封面有22个详细的步骤，在构建产品之前需要遵循。
- en: 'Objects can be thought of as *simulations* of some part of the problem we''re
    trying to solve, and a great way to learn from a simulation is to *interact* with
    it. If our objects are just active structures that hold some data on behalf of
    a program, then we don''t get that benefit: we can''t interact with the simulation
    without building out all of the rest of the program. And indeed that is the goal
    behind a lot of the "engineering" processes that use objects: while they may pay
    lip service to iterative and incremental development, they still talk about building
    a system at once, with each object being a jigsaw puzzle piece that satisfactorily
    fits its given gap in the puzzle.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将对象视为我们试图解决的某个问题的**模拟**，而与模拟互动是学习的好方法。如果我们的对象仅仅是代表程序持有一些数据的活跃结构，那么我们就无法获得这种好处：我们无法与模拟互动，除非构建出整个程序的其他部分。实际上，这正是许多使用对象的“工程”过程背后的目标：虽然他们可能口头上支持迭代和增量开发，但他们仍然谈论一次性构建一个系统，每个对象都是一个拼图碎片，能够满意地填补拼图中的特定空隙。
- en: 'So, let''s go back to Bertrand Meyer''s definition, and remove the problematic
    bit about letting a program access an object''s data:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到Bertrand Meyer的定义，并移除让程序访问对象数据的那个有问题的部分：
- en: '*An object is a software machine*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象是一个软件机器**'
- en: A machine is a useful analogy. It's a device (so something that was built by
    people) that uses energy to produce some effect. Notice the absence of any statement
    about *how* the machine produces that effect, *how* the machine consumes its materials,
    or *how* the machine's output is supplied. We've got a thing that does a thing,
    but if we're going to compose these things together to do other things, we're
    going to need to know how to do that composition. Adding a constraint takes us
    from "it's a machine" to "it's a machine that we can use like this".
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 机器是一个有用的类比。它是一个设备（所以是人们建造的东西），它使用能量产生某种效果。注意，没有任何关于机器如何产生这种效果、如何消耗其材料或如何提供机器输出的陈述。我们有一个执行某种操作的东西，但如果我们想要将这些事物组合起来执行其他操作，我们就需要知道如何进行这种组合。添加一个约束使我们从“它是一个机器”转变为“我们可以这样使用这个机器”。
- en: '*An object is a software machine that can collaborate with other software machines
    by sending and receiving messages.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象是一个可以通过发送和接收消息与其他软件机器协作的软件机器**。'
- en: 'Now we''ve got things that do things and can be used together. We don''t restrict
    the level of complexity of the things that are done by each machine (so booking
    a flight and representing a number are both things that we could build machines
    to do); just how we would combine them. This has parallels with Brad Cox''s software
    ICs analogy, too. An "integrated circuit" could be anything from a **NAND** gate
    to an **UltraSPARC T2**. We can use any of the IC''s together, of any size, if
    we just know how to deal with their inputs and outputs: what voltage should appear
    on each pin and what that represents.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以执行操作并且可以一起使用的东西。我们不限制每个机器执行的操作的复杂程度（所以预订航班和表示数字都是我们可以构建机器来执行的操作）；只是我们如何将它们结合起来。这也与Brad
    Cox的软件IC类比有相似之处。一个“集成电路”可以是任何东西，从**NAND门**到**UltraSPARC T2**。如果我们知道如何处理它们的输入和输出：每个引脚上应该出现什么电压以及它代表什么，我们就可以将任何IC组合在一起，无论大小。
- en: This analogy tells us that our software system is like a big machine that does
    something useful by composing, powering, and employing smaller component machines.
    It tells us to worry about whether the things coming out of one machine are useful
    as inputs to another machine, but not to worry about what's going on inside each
    machine except in the restricted context of the maintenance of those machines.
    It tells us to consider at each point whether the machine we have is more useful
    than not having that machine, rather than tracking the progress toward the construction
    of some all-powerful supermachine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比告诉我们，我们的软件系统就像一个大型机器，通过组合、供电和使用较小的组件机器来完成有用的操作。它告诉我们关注一个机器输出的东西是否可以作为另一个机器的输入是有用的，但不需要担心每个机器内部发生的事情，除非是在维护这些机器的受限环境中。它告诉我们，在每个点上考虑我们拥有的机器是否比没有这个机器更有用，而不是追踪构建一个全能超级机器的进度。
- en: It even tells us that building an **assembly line** in which input of a certain
    type is transformed into output of a certain type is a thing we might want to
    do; something that, otherwise, we might believe is solely the domain of the functional
    programmer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至告诉我们，建立一个将某种类型的输入转换为某种类型输出的**装配线**是我们可能想要做的事情；否则，我们可能认为这是功能程序员的专属领域。
- en: Drawing an Object
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制一个对象
- en: '*I see a red door and I want to paint it black. No colors any more I want them
    to turn black.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*我看到一扇红门，我想把它漆成黑色。不再需要任何颜色，我想要它们变成黑色。*'
- en: '*Rolling Stones, Paint it Black*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*滚石乐队，漆它黑色*'
- en: 'If object-oriented programming is the activity of modelling a problem in software,
    then the kinds of diagrams (and verbal descriptions) that software teams use to
    convey the features and behavior of those objects are metamodeling – the modeling
    of models. The rules, for example, the constraints implied when using `metametamodels`:
    the models that describe how the models of the models of the problems will work.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果面向对象编程是建模软件中问题的活动，那么软件团队用来传达这些对象特性和行为的图表（和口头描述）就是元建模——模型的建模。例如，规则，使用`元元模型`时隐含的约束：描述模型模型的模型如何工作的模型。
- en: Unified Modeling Language
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统一建模语言
- en: 'Plenty of such systems (I will avoid the word `metametamodels` from now on)
    have been used over time to describe object systems. The **UML** (**Unified Modeling
    Language**) is the result of combining three prior techniques: the three Elven
    Kings, Grady Booch, Ivar Jacobson, and James Rumbaugh bent their rings of power
    (respectively, the **Booch Method**, **Object-Oriented Software Engineering**,
    and the **Object Modelling Technique** – the latter mostly recognized today because
    the majority of diagrams in the famous *Design Patterns* book are drawn to its
    rules) to the *One Rational Ring*, wielded by Mike Devlin.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的时间里，许多这样的系统（从现在起我将避免使用“元元模型”这个词）被用来描述对象系统。**UML（统一建模语言**）是结合三种先前技术的结果：三位精灵国王，Grady
    Booch，Ivar Jacobson和James Rumbaugh弯曲他们的力量戒指（分别代表**Booch方法**，**面向对象软件工程**和**对象建模技术**——后者今天主要因为著名的*设计模式*书中大多数图表都是按照其规则绘制的）到*一个理性的戒指*，由Mike
    Devlin掌握。
- en: '*As an aside, Rational started as a company making better Ada applications
    and tools for other Ada programmers to make better Ada applications, including
    the R1000 workstation, optimized for running Ada programs and featuring an integrated
    development environment. The R1000 did not take off but the idea of an IDE did,
    and through a couple of iterations of their Rose product (as well as the UML and
    Rational Unified Process), made significant inroads into changing the way organizations
    planned, designed, and built software.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一下，Rational最初是一家制造更好的Ada应用程序和其他Ada程序员工具的公司，以便他们制造更好的Ada应用程序，包括R1000工作站，优化运行Ada程序，并具有集成开发环境。R1000没有起飞，但IDE的想法确实如此，通过他们Rose产品的几代迭代（以及UML和Rational统一流程），在改变组织规划、设计和构建软件的方式上取得了重大进展。*'
- en: The UML and, to differing extents, its precursor modelling techniques, represent
    a completist approach to object modelling in which all aspects of the implementation
    can be represented diagrammatically. Indeed, tools exist to "round-trip" convert
    UML into compatible languages like Java and back again into the UML representation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: UML及其前身建模技术，代表了一种全面的方法来处理对象建模，其中所有实现方面都可以用图表表示。实际上，存在将UML转换为兼容语言（如Java）以及反过来将UML表示转换回UML的工具。
- en: The model you create that both encapsulates enough of the "business" aspects
    of the system to demonstrate that you have solved a problem and enough of the
    implementation aspects to generate the executable program is not really a model,
    it *is* the program source. In shooting for completeness, the UML family of modelling
    tools have missed "modelling" completely and simply introduced another implementation
    language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的模型，既要包含足够多的系统“业务”方面的内容以展示你已经解决了问题，又要包含足够多的实现方面的内容以生成可执行程序，这实际上不是一个模型，*它就是程序源代码*。在追求完整性的过程中，UML建模工具系列完全忽略了“建模”，而只是引入了另一种实现语言。
- en: 'If the goal of message-passing is to solve our big problem through the concerted
    operation of lots of small, independent computer programs loosely coupled by the
    communications protocol, then we should be able to look at each object through
    one of two lenses: internal or external. In fact, the boundary itself deserves
    special consideration, so there are three views:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息传递的目标是通过众多小型、独立计算机程序的协同操作来解决我们的重大问题，这些程序通过通信协议松散耦合，那么我们应该能够通过两种透镜之一来看待每个对象：内部或外部。实际上，边界本身也值得特别考虑，因此有三个视角：
- en: 'The "external" lens: What messages can I send to this object? What do I need
    to arrange in order to send them? What can I expect as a result?'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “外部”透镜：我能向这个对象发送什么消息？我需要安排什么才能发送它们？我能期待什么结果？
- en: 'The "internal" lens: What does this object do in response to its messages?'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “内部”透镜：这个对象对其消息有何反应？
- en: 'The "boundary" lens: Does the behavior of this object satisfy the external
    expectations?'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “边界”透镜：这个对象的行为是否满足外部期望？
- en: The final two of these things are closely intertwingled. Indeed some popular
    implementation disciplines, such as **Test-Driven Development** lead you to implement
    the object internals only through the boundary lens, by saying "I need this to
    happen when this message is received," then arranging the object's internals so
    that it does, indeed, happen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后两点紧密相连。确实，一些流行的实施学科，如**测试驱动开发**，引导你只通过边界透镜实现对象内部，通过说“当收到这个消息时，我需要这样做”，然后安排对象的内部结构，使其确实发生。
- en: The first is separated from the others, though. From the outside of an object
    I *only* need to know what I can ask it to do; if I also need to know how it does
    it or what goes on inside, then I have not decomposed my big problem into independent,
    small problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分与其他部分是分开的。从对象的外部来看，我*只需要*知道我可以要求它做什么；如果我还需要知道它是如何做到的或者内部发生了什么，那么我就没有将我的大问题分解成独立的小问题。
- en: 'UML class diagrams include all class features at all levels of visibility:
    public, package, protected, and private; simultaneously. Either they show a lot
    of redundant information (which is not to a diagram''s benefit) or they expect
    the modeler to take the completist approach and solve the whole big problem at
    once, using the word "objects" to give some of that 1980s high-technology feel
    to their solution. This is a downhill development from Booch''s earlier method,
    in which objects and classes were represented as fluffy cloud-shaped things, supporting
    the idea that there''s probably some dynamism and complexity inside there but
    that it''s not relevant right now.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: UML类图包括所有级别的可见性：公共、包、受保护的和私有的类特征；同时显示。要么它们显示了大量的冗余信息（这对图表没有好处），要么它们期望模型者采取全面的方法，一次解决整个大问题，使用“对象”这个词给他们的解决方案增添一些1980年代高科技的感觉。这是从波奇早期方法中的下降发展，其中对象和类被表示为蓬松的云形状的东西，支持这样的想法：里面可能有一些动态和复杂性，但当前并不相关。
- en: Interestingly, as with Bertrand Meyer's statement that "an object is a software
    machine allowing programs to access and modify a collection of data," explored
    in the section on *analysis and design*, we can find the point at which Grady
    Booch overshot the world of modelling tools in a single sentence in *Chapter One
    of his 1991 book Object-Oriented Design with Applications*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，正如在“分析和设计”部分中探讨的，贝特朗·梅耶的声明“一个对象是一个软件机器，允许程序访问和修改一组数据”，我们可以在格雷迪·波奇1991年出版的《面向对象设计与应用》的第一章中找到他一句话就超越了建模工具世界的点。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Perhaps there is a general principle in which the left half of a sentence about
    making software is always more valuable than the right half. If so, then the (**Agile
    Manifesto** — [http://agilemanifesto.org/](http://agilemanifesto.org/)) is the
    most insightfully-designed document in our history.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或许有一个普遍原则，即关于制作软件的句子左半部分总是比右半部分更有价值。如果是这样，那么（**敏捷宣言** — [http://agilemanifesto.org/](http://agilemanifesto.org/))就是我们的历史上最具洞察力的设计文件。
- en: 'The sentence runs thus:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话是这样的：
- en: '*Object-oriented design''s underlying concept is that one should model software
    systems as collections of cooperating objects...*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象设计的根本概念是应该将软件系统建模为协作对象的集合...*'
- en: So far, so good.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。
- en: '*... treating individual objects as instances of a class ...*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*...将单个对象视为类的实例...*'
- en: I would suggest that this is not necessary, and that classes, and particularly
    inheritance, deserve their own section in this part of the book (see *Finding
    a Method to Run* section).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议这并不必要，并且类，尤其是继承，在这个书的这部分应该有自己的一节（参见*找到运行方法*部分）。
- en: '*... within a hierarchy of classes.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*...在类的层次结构中。*'
- en: And here we just diverge completely. By situating his objects within "a hierarchy
    of classes," Booch *is* encouraging us to think about the whole system, relating
    objects taxonomically and defining shared features. This comes from a good intention
    – inheritance was long seen as the object-oriented way to achieve reuse – but
    promotes thinking about reuse over thinking about *use*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这里，我们完全分道扬镳。通过将他的对象置于“类的层次结构”中，波奇*确实*鼓励我们思考整个系统，按分类法关联对象并定义共享特征。这源于一个良好的意图——继承长期以来被视为面向对象实现重用的方式——但促进了关于重用的思考，而不是关于*使用*的思考。
- en: Class-Responsibility-Collaborator
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类-责任-协作者
- en: Just as the UML represents a snapshot in the development of a way of describing
    objects, so do CRC cards, introduced by Kent Beck and Ward Cunningham in 1989,
    and propagated by Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener in their
    textbook *Designing Object-Oriented Software*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如UML代表了一种描述对象的方式的发展快照一样，CRC卡片也是由Kent Beck和Ward Cunningham在1989年引入，并由Rebecca
    Wirfs-Brock、Brian Wilkerson和Lauren Wiener在他们合著的《面向对象软件设计》一书中传播的。
- en: 'The CRC card describes three aspects of an object, none of which is a cyclic
    redundancy check:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CRC卡片描述了对象的三个方面，其中没有一个是对称冗余检查：
- en: The *Class* names
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**名称'
- en: The *Responsibilities* of the object
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的**责任**
- en: The *Collaborators* that the object will need to work with
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象将需要与之协作的**协作者**
- en: Not only does this school of design focus on the messaging aspect of objects
    (the responsibilities will be things I can ask it to do and the collaborators
    will be other objects it asks to do things), but it introduces a fun bit of *anthropomorphism*.
    You and I can each pick up a card and "play object," having a conversation to
    solve a problem, and letting that drive our understanding of what messages will
    be exchanged.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计方法不仅关注对象的通信方面（责任将是我可以要求它做的事情，而协作者将是它要求做事的其他对象），而且还引入了一种有趣的**拟人化**元素。你和我可以各自拿一张卡片，扮演“对象”，通过对话解决问题，并以此推动我们对将要交换的消息的理解。
- en: 'David West, in his 2004 book, *Object Thinking*, presents the object cube,
    which extends the CRC card into three dimensions by adding five more faces:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: David West在他的2004年著作《面向对象思考》中提出了对象立方体，通过增加五个面将CRC卡片扩展到三维：
- en: A textual description of instances of the class
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例的文本描述
- en: A list of named contracts (these are supposed to indicate "the intent of the
    class creator as to who should be able to send particular messages," and in his
    examples are all either "public" or "private")
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名契约的列表（这些应该表明“类创建者的意图，即谁应该能够发送特定的消息”，在他的例子中都是“公共”或“私有”）
- en: The "knowledge required" by an object and an indication of where it will get
    that knowledge
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象所需的“知识”以及它将获得这些知识的指示
- en: The message protocol is a list of messages the object will respond to
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息协议是对象将响应的消息列表
- en: Events generated by the objects
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象生成的事件
- en: 'Some bad news: you can''t make a cube out of 3x5 index cards; and you can''t
    buy 5x5 index cards. But that''s just an aside. Again, as with using the UML,
    we''ve got to record the internals and externals of our object in the same place,
    and now we need to use large shelves rather than index boxes to store them.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一些坏消息：你不能用3x5索引卡片做一个立方体；你也买不到5x5索引卡片。但这只是个插曲。同样，就像使用UML一样，我们必须在同一个地方记录我们对象的内情和外情，而现在我们需要用大架子而不是索引盒来存储它们。
- en: With both of these techniques, the evolution seems to have been one of additive
    complexity. Yes, you can draw out the network of objects and messages, oh and
    while you're here you can also...
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种技术，其演变似乎是一种累加的复杂性。是的，你可以绘制出对象和消息的网络，哦，而且当你在这里的时候，你还可以做……
- en: And rationally, each part of each of these metamodels seems to make sense. Of
    course, at some point, I need to think about the internals of this object; at
    some point, I need to consider its instance variables; and at some point, I need
    to plan the events emitted by the object. Yes, but not at the *same* point, so
    they don't need to be visible at the same time on the same model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从理性上讲，这些元模型中的每一部分似乎都有意义。当然，在某个时候，我需要考虑这个对象的内情；在某个时候，我需要考虑它的实例变量；在某个时候，我需要规划对象发出的事件。是的，但不是在**同一个**时候，所以它们不需要在同一模型上同时可见。
- en: Jelly Donuts and Soccer Balls
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 果冻甜甜圈和足球
- en: 'Ironically, there *is* a form of object diagram that makes this separation
    between the externals and internals clear, though I have only seen it in one place:
    The NeXT (and subsequently Apple) **jelly-donut model** — [http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html](http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html)
    This isn''t a tool that programmers use for designing objects, though: it''s an
    analogy used in some documentation.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，确实有一种对象图的形式可以清楚地区分外部和内部，尽管我只在一个地方见过：NeXT（以及随后的苹果）的**果冻甜甜圈模型** — [http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html](http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html)
    这不是一个程序员用来设计对象的工具：它是一些文档中使用的类比。
- en: It's an analogy that some authors disagree with. In *Object Thinking*, David
    West says that the jelly donut model (which he calls the **soccer-ball model**,
    after Ken Auer) is the model of choice of the "traditional developer," while "an
    object thinker" would represent an object anthropomorphically, using a person.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种一些作者不认同的类比。在《面向对象思考》一书中，大卫·韦斯特说，松露甜甜圈模型（他称之为**足球模型**，以肯·奥厄的名字命名）是“传统开发者”的选择模型，而“面向对象思考者”则会将对象拟人化，使用人作为代表。
- en: 'West may well argue that the jelly donut/soccer ball model represents traditional
    thinking because it reflects the Meyer-ish view that your system is designed by
    working out what data it needs and then carving that up between different objects.
    Ironically, Bertrand Meyer would probably also reject the soccer ball model, for
    an unrelated reason: Eiffel follows the **Principle of Uniform Reference**, in
    which an object field or a member function (method) is accessed using the same
    notation. To an Eiffel programmer, the idea that the data is "surrounded" by the
    methods is superfluous; the jelly donut indicates the use of a broken language
    that allows the sweet jelly to escape and make everything else sticky.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 韦斯特可能会争辩说，松露甜甜圈/足球模型代表了传统思维，因为它反映了梅耶式的观点，即你的系统是通过确定它需要哪些数据，然后在不同对象之间划分这些数据来设计的。具有讽刺意味的是，伯特兰·梅耶可能会因为一个无关的原因而拒绝足球模型：Eiffel遵循**统一引用原则**，其中对象字段或成员函数（方法）使用相同的符号访问。对于Eiffel程序员来说，数据“被方法包围”的想法是多余的；甜甜圈表明了使用一种允许甜味果冻逃逸并使其他一切变得粘稠的破损语言。
- en: Opposing Functional Programming
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反对函数式编程
- en: '*[An] important aspect of functional programming is that functions do not change
    the data with which they work [...] Object-oriented imperative languages such
    as C, Java, or Python change their state as they run.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**[功能编程的一个]重要方面是函数不会改变它们工作的数据 [...] 面向对象的命令式语言，如C、Java或Python，在运行时会改变它们的状态。**'
- en: '*Neil Savage, (Using Functions for Easier Programming —* [https://dl.acm.org/citation.cfm?id=3193776](https://dl.acm.org/citation.cfm?id=3193776)*)*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*尼尔·萨维奇，（使用函数进行更简单的编程——* [https://dl.acm.org/citation.cfm?id=3193776](https://dl.acm.org/citation.cfm?id=3193776)*)*'
- en: Many programmers define themselves through their tools, and therefore define
    themselves as *against* certain other tools. If you are a .NET programmer, then
    you do not use Java. If you are a native mobile programmer, then you do not use
    JavaScript. If you are a React programmer, then you do not use Angular. An affiliation
    with one tool automatically means a disaffiliation with others.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员通过他们的工具来定义自己，因此将自己定义为**反对**某些其他工具。如果你是.NET程序员，那么你不会使用Java。如果你是原生移动程序员，那么你不会使用JavaScript。如果你是React程序员，那么你不会使用Angular。与一个工具的关联自动意味着与其他工具的疏远。
- en: 'Such partisanship is a confirming example of Sayre''s law: the arguments are
    so fierce because the stakes are so low. For people who supposedly work in a field
    of rationality and science, we''re really good at getting emotionally brittle
    when somebody wants to use a different library, language, text editor, or whitespace
    symbol than the one we have chosen.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种党派性是Sayre定律的一个确认性例子：因为赌注很低，所以争论如此激烈。对于那些据说在理性和科学领域工作的人来说，当有人想要使用与我们选择的不同的库、语言、文本编辑器或空白符号时，我们真的很擅长变得情绪脆弱。
- en: This fierce disagreement over strongly defended similarities extends to the
    programming paradigm, too. If you are an object-oriented programmer, then your
    mortal enemy is the functional programmer—[http://www.sicpers.info/2015/03/inspired-by-swift/](http://www.sicpers.info/2015/03/inspired-by-swift/),
    and vice versa.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关于强烈捍卫的相似性的激烈分歧也扩展到了编程范式。如果你是一个面向对象的程序员，那么你的宿命之敌就是函数式程序员——[http://www.sicpers.info/2015/03/inspired-by-swift/](http://www.sicpers.info/2015/03/inspired-by-swift/)，反之亦然。
- en: Messages Are Just Requests
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息只是请求
- en: 'Not so fast! Recall the working definition of objects I have used throughout
    the antithesis: an object is an isolated, independent computer program that communicates
    with other programs by passing messages. This tells us nothing about *how* to
    build those isolated, independent computer programs. Particularly, there is no
    *mandate* to have mutable state anywhere. The following interface works as a messaging
    interface for a time-varying list:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 别急！回想一下我在对立面中使用的对象的工作定义：对象是一个孤立的、独立的计算机程序，通过传递消息与其他程序进行通信。这并没有告诉我们**如何**构建那些孤立的、独立的计算机程序。特别是，没有**强制**在任何地方都有可变状态。以下接口作为一个时间变化的列表的消息接口工作：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And so, does this one:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以及这个：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the first, time in the list''s lifespan is modeled using successive states
    of the computer memory. In the second, time in the list''s lifespan is modeled
    explicitly, and the history of the list is preserved. Another option is to model
    evolution using *different objects*, turning time into space:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表生命周期的第一个阶段，使用计算机内存的连续状态来模拟时间。在第二个阶段，列表生命周期的模拟是显式的，并且保留了列表的历史记录。另一个选项是使用*不同的对象*来模拟演化，将时间转化为空间：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the list looks a lot like a sort of a functional programming list. But it's
    still an object. In each case, we have defined what *messages* the object responds
    to but, remembering the section on *Telling an Object What to Do*, we have not
    said *anything* about what methods exist on that object, and certainly not how
    they are implemented. The `MutableList` and `TemporalList` interfaces use Bertrand
    Meyer's principle of `Datalog` programs, or SQL programs, or be stored as a chain
    of events that is replayed when a query message is received.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表看起来很像一种函数式编程列表。但它仍然是一个对象。在每种情况下，我们都定义了对象响应的*消息*，但记住*告诉对象做什么*的部分，我们没有说*任何*关于该对象上存在哪些方法的事情，当然也没有说它们是如何实现的。《MutableList》和《TemporalList》接口使用Bertrand
    Meyer的`Datalog`程序原则，或者SQL程序，或者存储为一系列事件链，当接收到查询消息时重新播放。
- en: In the `ImmutableList` interface, commands are replaced by transforms, which
    ask for a new list that reflects the result of applying a change to the existing
    list. Again, no restriction on *how* you implement those transforms is stated
    (I could imagine building `addObject()` by having a new list that delegates every
    call to the original list, adding 1 to the result of `count()` and supplying its
    own value for `at(originalCount)`; or I could just build a new list with all of
    the existing elements and the new element), but in this case, it's clear to see
    that every method can be a pure function based on the content of the object and
    the message parameters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ImmutableList`接口中，命令被转换操作取代，这些操作要求提供一个新列表，该列表反映了将更改应用于现有列表的结果。再次强调，没有对*如何*实现这些转换的限制（我可以想象通过创建一个新的列表，该列表将每个调用委托给原始列表，将`count()`的结果加1，并为`at(originalCount)`提供自己的值来实现`addObject()`；或者我可以简单地创建一个新的列表，包含所有现有元素和新元素），但在这个例子中，很明显每个方法都可以基于对象内容和消息参数的纯函数。
- en: 'We can see that "pure function based on the content of the object and the message
    parameters" is the same as "pure function" more clearly by rewriting the interface
    in Python syntax (skipping the implementations):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用Python语法重写接口（跳过实现），我们可以更清楚地看到“基于对象内容和消息参数的纯函数”与“纯函数”是相同的：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's now easier to see that each of these methods is a pure function in its
    parameters, where `this`/`self` is a parameter that's automatically prepared in
    other languages (or a part of the method's environment that's automatically closed
    over in others).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更容易看出，这些方法中的每一个在其参数上都是一个纯函数，其中`this`/`self`是其他语言中自动准备好的参数（或在其他语言中自动封闭的方法环境的一部分）。
- en: Nothing about message-passing says, "please do not use functional programming
    techniques."
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递机制并没有说，“请不要使用函数式编程技术。”
- en: An Object's Boundary is Just a Function
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个对象的边界只是一个函数
- en: 'The following subsections were deeply informed by the article Objects as Closures:
    abstract semantics of object-oriented languages — [https://dl.acm.org/citation.cfm?id=62721](https://dl.acm.org/citation.cfm?id=62721),
    which builds this view of objects much more rigorously.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的子部分深受文章《Objects as Closures: abstract semantics of object-oriented languages》的启发——[https://dl.acm.org/citation.cfm?id=62721](https://dl.acm.org/citation.cfm?id=62721)，该文章更严格地构建了这种对象观。'
- en: 'The interface to an object is the collection of messages it responds to. In
    many cases, this is backed by a collection of methods, each with the same name
    as the message selector that will invoke it. Not only is this the easiest thing
    to do, it''s also an implementation constraint in many programming languages.
    The preceding Python implementation of `ImmutableList` can be visualized in this
    table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的接口是它响应的消息集合。在许多情况下，这背后是一个方法集合，每个方法的名字与将调用它的消息选择器相同。这不仅是最容易做到的事情，而且在许多编程语言中也是一个实现约束。前述`ImmutableList`的Python实现可以在这个表中可视化：
- en: '![](img/B15099_01_01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15099_01_01.jpg)'
- en: 'Figure 3.1: Visualization of ImmutableList after implementation'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：实现后的ImmutableList的可视化
- en: 'This table can equivalently be replaced by a pure function of type `Message
    Selector->Method to Invoke`. A trivial implementation of the function would look
    up its input in the left-hand column of the table and return the value it finds
    in the same row in the right-hand column. An implementation of `ImmutableList`
    doesn''t need to have any methods at all, choosing functions based on the message
    selector:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表可以等价地替换为一个类型为`Message Selector->Method to Invoke`的纯函数。该函数的平凡实现会在表的左侧列中查找其输入，并返回它在右侧列相同行中找到的值。`ImmutableList`的实现不需要有任何方法，而是根据消息选择器选择函数：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using this object works the same way as using an object where the methods were
    defined in the usual way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个对象的方式与使用在常规方式下定义方法的对象相同：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, whichever way you write out an object, its methods are functions that have
    access to (close over) the object's internals, and its message interface is one
    such function that uses the message selector to choose which method to invoke.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你如何编写对象，其方法都是可以访问（闭包）对象内部结构的函数，其消息接口是这样的一个函数，它使用消息选择器来选择要调用的方法。
- en: Freed from the fetters of the language's idea of where methods live, we see
    that the function to look up implementations from selectors can use *any* information
    available to it. If the object knows about another object, it can send the message
    on to the other object, send a different method in its place, or it could compile
    a new function and use that. The important idea is that *an object is a function
    for finding other functions*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 释放了语言关于方法所在位置的想法的束缚，我们发现用于从选择器中查找实现的函数可以使用*任何*可用的信息。如果对象了解另一个对象，它可以向另一个对象发送消息，发送一个不同的方法，或者它可以编译一个新的函数并使用它。重要的思想是*一个对象是查找其他函数的函数*。
- en: That Function-Like Boundary? Actually, a Closure Over the Constructor Arguments
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那个类似函数的边界？实际上，是构造函数参数的闭包
- en: Our `ImmutableList` has a constructor method called `__init__`, which sets up
    the initial state of the object using its arguments, and then the message-finding
    `__getattr__` function, which chooses functions to respond to the messages that
    are sent to the object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ImmutableList`有一个名为`__init__`的构造方法，它使用其参数设置对象的初始状态，然后是消息查找的`__getattr__`函数，它选择响应发送给对象的那些消息的函数。
- en: 'An equivalent way to arrange this is to have the constructor function return
    the message-finding function as a closure over the constructor''s arguments (and
    any transformation implied in "setting up the initial state of the object" can
    be arranged using local variables that are captured in the closure, too). So,
    all in all, an object is a single higher-order function: a function that captures
    its arguments and returns a closure over those arguments that accept messages
    and then chooses a method to execute the code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 安排这种方式的等效方法是让构造函数返回一个消息查找函数，作为构造函数参数的闭包（并且“设置对象初始状态”中暗示的任何转换也可以通过在闭包中捕获的局部变量来安排）。因此，总的来说，一个对象是一个单一的高阶函数：一个捕获其参数并返回一个闭包的函数，该闭包接受消息并选择一个方法来执行代码：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sticking with Python, and using this insight, `ImmutableList` is reduced to
    a single expression:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持使用Python，并利用这个洞察，`ImmutableList`可以简化为一个单一的表达式：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By the way, this demonstrates why so many object-oriented languages don't seem
    to have a type system. If "*everything is an object*," then even in the most stringent
    of type systems, everything is a `message->method` function, so everything has
    the same type, and everything type checks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这说明了为什么许多面向对象的语言似乎没有类型系统。如果“*一切皆对象*”，那么即使在最严格的类型系统中，一切也是一个`message->method`函数，所以一切都有相同的类型，一切都会通过类型检查。
- en: The preceding definition of `ImmutableList` does escape the "everything is an
    object" type scheme by ending with the phrase `else False`, meaning "if I didn't
    find a method, return something that isn't callable, so the user gets a `TypeError`."
    A more complete object system would have the object send itself a `doesNotRespond`
    message here, and no breaking out into Python's usual world of computation would
    occur.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableList`的前一个定义通过以`else False`结束来避开“一切皆对象”的类型方案，这意味着“如果没有找到方法，返回一个不可调用的东西，这样用户就会得到一个`TypeError`。”一个更完整的对象系统会在这里让对象发送一个`doesNotRespond`消息，并且不会跳出Python的常规计算世界。'
- en: Capturing Elements of Reusable Design
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获可重用设计的元素
- en: '*A pattern for increased monitoring for intellectual property theft by departing
    insiders*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*一种针对离职内部人员知识产权盗窃增加监控的模式*'
- en: '*Title of (an article in the Proceedings of the 18th Conference of Pattern
    Languages of Programs —* [https://dl.acm.org/citation.cfm?id=2579157](https://dl.acm.org/citation.cfm?id=2579157)*),
    PLoP''11*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*《第18届模式语言程序会议论文集》中的一篇文章的标题—— [https://dl.acm.org/citation.cfm?id=2579157](https://dl.acm.org/citation.cfm?id=2579157)*，PLoP''11*'
- en: Christopher Alexander, while evidently seminal in the field of built architecture,
    seems pretty lazy as architects go. Why? Because rather than designing a building
    or even a town *himself*, he expects the people who will live, work, shop, and
    play there to do that for him, and even to build its prototype.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Christopher Alexander虽然在建筑领域具有开创性，但与其他建筑师相比似乎相当懒惰。为什么？因为他不是自己设计建筑或甚至城镇，而是期望将居住、工作、购物和娱乐在那里的人们为他做这件事，甚至建造其原型。
- en: In fact, this has little to do with laziness; it's because he believes that
    they are the best people to do the designing as they are the people who best know
    the uses to which the structure will be put and the problems it will solve. What
    does he know about that? Not much; what he knows is the expertise architects have
    gained in solving problems that crop up when designing and constructing towns
    and buildings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这与懒惰无关；这是因为他认为他们是做设计最好的，因为他们是最了解结构将用于何种用途以及将解决何种问题的人。他对此了解多少？不多；他所了解的是，建筑师在设计和建造城镇和建筑时遇到的问题的解决经验。
- en: 'In *A Pattern Language: Towns, Buildings and Construction*, Alexander and his
    coauthors and reviewers sought to encapsulate that professional knowledge in a
    grammar that would allow a user to solve their own construction problems by taking
    advantage of the solutions known to work by the expert architects. Each pattern
    describes the problem it solves, the context in which it solves it, and the advantages
    and limitations of the solution. Some represent instant decisions to be made –
    the placement of columns in a building construction; others represent experiences
    to be nurtured gradually – the opening of street cafes to facilitate relaxed interaction
    between people and their environment. The grammar developed in *A Pattern Language*
    is additive, so each pattern develops ideas that have been introduced previously
    without depending on patterns that will be seen later, and there are no cyclic
    references. Each pattern is hyperlinked (old-school and using page numbers) to
    the preceding patterns it builds upon.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在《*模式语言：城镇、建筑与建造*》中，Alexander及其合作作者和审稿人试图将那种专业知识封装在一种语法中，使用户能够通过利用专家建筑师已知有效的解决方案来解决他们自己的建筑问题。每个模式都描述了它解决的问题、解决该问题的上下文以及解决方案的优点和局限性。有些代表需要即时做出的决定——建筑中柱子的位置；而另一些则代表需要逐渐培养的经验——开设街头咖啡馆以促进人们与其环境之间的轻松互动。《模式语言》中开发的语法是累加的，因此每个模式都发展了之前引入的思想，而不依赖于之后将看到的模式，并且没有循环引用。每个模式都通过超链接（老式使用页码）与前一个构建在其上的模式相连接。
- en: We could expect that, in taking inspiration from *A Pattern Language*, software
    designers and builders would create a pattern language that allowed users of computers
    to design and build their own software, by elucidating the problems the users
    are facing and expressing known approaches to solving those problems. And indeed,
    that is exactly what happened when Kent Beck and Ward Cunningham published *Using
    Pattern Languages for Object-Oriented Programs* — [http://c2.com/doc/oopsla87.html](http://c2.com/doc/oopsla87.html).
    The five Smalltalk UI patterns listed in that report are like a microcosm of a
    **Human Interface Guidelines** document, written for the *people who will use
    the interface*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预期，在从《*模式语言*》中汲取灵感时，软件设计师和构建者将创建一种模式语言，允许计算机用户通过阐明用户面临的问题和表达解决这些问题的已知方法来设计和构建自己的软件。确实，当Kent
    Beck和Ward Cunningham发表《*使用模式语言进行面向对象程序设计*》—— [http://c2.com/doc/oopsla87.html](http://c2.com/doc/oopsla87.html)
    时，就是这样发生的。报告中列出的五个Smalltalk UI模式就像一份**人机界面指南**文档的缩影，是为**将使用该界面的人**编写的。
- en: 'However, what most of us will find when looking for examples of a pattern language
    for software construction are the 23 patterns in the 1994 "Gang of Four" book
    *Design Patterns: Elements of Reusable Design* by Gamma, Helm, Johnson, and Vlissides.
    Compared with the 253 architectural design patterns documented by Alexander et
    al., the software pattern language seems positively anemic. Compared with practice,
    the situation looks even worse. Here are the three patterns that see regular use
    in modern development:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们寻找软件构建模式语言的示例时，我们大多数人会发现的是1994年“四人帮”的书籍《设计模式：可复用设计元素》中提到的23个模式，作者为Gamma、Helm、Johnson和Vlissides。与亚历山大等人记录的253个架构设计模式相比，软件模式语言似乎显得非常瘦弱。与实际应用相比，情况看起来更糟。以下是现代开发中经常使用的三个模式：
- en: '`Iterator` pattern yourself; it''s the one that programming language designers
    have worked out how to supply for you, via the `for (element in collection)` construct.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己实现`迭代器`模式；这是编程语言设计者已经想出如何为你提供的，通过`for (element in collection)`结构。
- en: '**Singleton**: You''ll have only built *Singleton* so that you could write
    that blog post about why *Singleton* is "Considered Harmful."'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：你之所以构建**单例**，只是为了写那篇关于为什么**单例**是“被认为有害的”博客文章。'
- en: '**Abstract Factory**: The butt of all jokes about Java frameworks by people
    who haven''t used Java frameworks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂**：所有关于Java框架的笑话的靶子，这些笑话是由没有使用过Java框架的人说的。'
- en: 'Here''s the thing: the *Gang of Four* book is actually very good, and the patterns
    are genuinely repeatable patterns that can be identified in software design and
    that solve common problems. But as Brian Marick argued in Patterns Failed. Why?
    Should we care?—[https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care](https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care),
    the 23 patterns discussed therein are *implementation* patterns, and software
    implementors (that''s us) don''t want repeatable patterns; we want *abstraction*.
    Don''t tell me "Oh, I''ve seen that before, what you do is..."; tell me "Oh, I''ve
    seen that before, here''s the `npm` module I wrote."'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：*四人帮*的书实际上非常好，这些模式确实是可重复的模式，可以在软件设计中识别出来，并解决常见问题。但正如布赖恩·马里克在《模式失败。为什么？我们应该关心吗》一书中所争论的——[https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care](https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care)，其中讨论的23个模式是**实现**模式，软件实现者（也就是我们）不想要可重复的模式；我们想要**抽象**。不要告诉我“哦，我以前见过这个，你做的是...”；告诉我“哦，我以前见过这个，这是我的`npm`模块。”
- en: The big winner for software reuse was not information that could be passed from
    one programmer to another, but information that could be passed from one *lawyer*
    to another, which allowed other information to be passed from one programmer to
    *another's program*. The free software license (particularly, due to the conservative
    nature of technologists in business, the non-copyleft free software licenses like
    the MIT or BSD) permitted some programmers to publish libraries to CTAN and its
    spiritual successors, and permitted a whole lot of other programmers to incorporate
    those libraries into their works.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 软件重用的最大赢家不是可以从一个程序员传递给另一个程序员的那些信息，而是可以从一个律师传递给另一个律师的信息，这允许其他信息可以从一个程序员传递给另一个程序员的程序。免费软件许可证（尤其是由于商业技术人员的保守性质，非copyleft的免费软件许可证，如MIT或BSD）允许一些程序员将库发布到CTAN及其精神继承者，并允许大量其他程序员将这些库纳入他们的作品中。
- en: 'In that sense, the end situation for software reuse has been incredibly similar
    to the "software ICs" that Brad Cox described, for example, in *Object-Oriented
    Programming: An Evolutionary Approach*. He proposed that we would browse the catalogue
    (the `npm` repository) for software ICs that look like they do what we want, compare
    their data sheets (the `README.md` or Swagger docs), then pick one and download
    it for integration into our applications (`npm install`).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，软件重用的最终情况与布拉德·考克斯在《面向对象编程：一种进化方法》中描述的“软件集成电路”极其相似。他提出，我们将浏览目录（即`npm`仓库）以寻找看起来能完成我们想要的功能的软件集成电路，比较它们的数据表（`README.md`或Swagger文档），然后选择一个并下载以集成到我们的应用程序中（`npm
    install`）。
- en: Anyway, back to design patterns. Marick suggested that the way we work means
    that we can't benefit from implementation patterns because we don't rely on repeated
    practice in implementation. Some programmers do participate in **Code Kata** —
    [http://codekata.com/](http://codekata.com/), a technique for instilling repeated
    practice in programming, but by and large we try to either incorporate an existing
    solution or try something new, not find existing solutions and solve problems
    in similar ways.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，回到设计模式。马里克建议，我们工作的方式意味着我们不能从实现模式中受益，因为我们不依赖于实现中的重复实践。一些程序员确实参与了**代码 kata**——[http://codekata.com/](http://codekata.com/)，这是一种在编程中培养重复实践的技术，但总的来说，我们试图要么采用现有的解决方案，要么尝试新的方法，而不是寻找现有的解决方案并以类似的方式解决问题。
- en: Indeed, we could vastly shrink the Gang of Four book by introducing **Strategy
    (315)** and describing all of the other problems in its terms. Abstract Factory?
    A **Strategy (315)** for creating objects. Factory Method? The same. Adapter?
    A **Strategy (315)** for choosing integration technologies. State? A **Strategy
    (315)** for dealing with time. But we don't do that, because we think of these
    as different problems, so describe them in different terms and look for different
    solutions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以通过引入**策略（315**）并以其术语描述所有其他问题来大大缩减《设计模式》这本书。抽象工厂？创建对象的**策略（315**）。工厂方法？同样。适配器？选择集成技术的**策略（315**）。状态？处理时间的**策略（315**）。但我们没有这样做，因为我们认为这些问题是不同的，所以用不同的术语描述它们，并寻找不同的解决方案。
- en: So, abstraction has to stop somewhere. Particularly, it has to stop by the time
    we're talking to the product owners or sponsors, as we're typically building specific
    software tools to support specific tasks. Built architecture has techniques for
    designing residences, offices, shops, and hotels, rather than "buildings," A house
    for a young single worker is different from a house for a retired widow, although
    both are residences with one occupant. So, this points us, as Brian Marick concludes,
    to having design patterns in our software's problem domain, telling us how domain
    experts address the problems they encounter. We might have good abstractions for
    stateful software, or desktop application widgets, or microservice-based service
    architecture, but we have to put them to specific ends, and the people who know
    the field know the problems they're trying to solve.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抽象必须在某个地方停止。特别是，当我们与产品所有者或赞助者交谈时，抽象必须停止，因为我们通常在构建特定的软件工具来支持特定的任务。建筑架构有设计住宅、办公室、商店和酒店的技术，而不是“建筑”。一个年轻单身工人的房子与一个退休寡妇的房子不同，尽管两者都是只有一个居住者的住宅。所以，正如布赖恩·马里克总结的那样，这表明我们的软件问题域中需要有设计模式，告诉我们领域专家如何解决他们遇到的问题。我们可能对有状态的软件、桌面应用程序小部件或基于微服务的服务架构有很好的抽象，但我们必须将它们用于特定的目的，而了解该领域的人知道他们试图解决的问题。
- en: 'And indeed, that is one of the modern goals of the Pattern Language of Programming
    conference series and the software patterns community. I expected that, on first
    reading, the pull quote chosen for this section ("A pattern for increased monitoring
    for intellectual property theft by departing insiders") would raise a few cynical
    laughs: "Wow, the patterns folks are so far down the rabbit hole that they''re
    writing patterns for *that*?" Well, yes, they are, because it''s a problem that
    is encountered multiple times by multiple people and where knowledge of the common
    aspects of the solution can help designers. Any enterprise IT architect, CISO,
    or small company HR person is going to know that leavers, particularly those who
    left due to disagreements with management or being poached by competitors, represent
    an increased risk of IP theft and will want a way to solve that problem. Here,
    the pattern language shows the important dimensions of the problem, the facets
    of the solution, and the benefits and drawbacks of the solution.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这正是编程模式语言系列会议和软件模式社区的现代目标之一。我原本以为，在第一次阅读时，本节所选的引用（“一种用于增加离职内部人员知识产权盗窃监控的模式”）会引发一些讽刺的笑声：“哇，模式专家们已经深入兔子洞，他们甚至为*那*编写模式？”是的，他们确实如此，因为这是一个多次被多人遇到的问题，而且对解决方案的共同方面的了解可以帮助设计师。任何企业IT架构师、CISO或小型公司的人力资源人员都知道，离职者，尤其是那些因与管理层意见不合或被竞争对手挖角而离职的人，代表了知识产权盗窃风险的增加，并希望有一种方法来解决这个问题。在这里，模式语言显示了问题的关键维度、解决方案的方面以及解决方案的利弊。
- en: 'A quote from the pattern description is revealing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 模式描述中的一句话揭示了真相：
- en: '*The authors are unaware of any implementation of the pattern in a production
    environment.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*作者们不知道有任何在生产环境中实现该模式的情况。*'
- en: This means that, while the solution does (presumably and hopefully) capture
    expert knowledge about the problem and how to solve it, it is not tested. The
    design patterns from the Beck and Cunningham paper (and Beck's later *Smalltalk
    Best Practice Patterns*), and indeed the Gang of Four book, were all based on
    *observation* of how problems had commonly been solved. There were not lots of
    C++ or Smalltalk programs that all had classes called `AbstractFactory`, but there
    *were* lots of C++ or Smalltalk programs that solved the "We need to create families
    of related or dependent objects without specifying their concrete classes" problem.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，虽然这个解决方案（可能和希望）捕捉到了关于问题及其解决方法的专业知识，但它尚未经过测试。Beck和Cunningham论文中的设计模式（以及Beck后来的*Smalltalk最佳实践模式*），以及《四人帮》的书，都是基于*观察*问题通常是如何解决的。并不是有很多C++或Smalltalk程序都有名为`AbstractFactory`的类，但确实有很多C++或Smalltalk程序解决了“我们需要创建一系列相关或依赖的对象，而不指定它们的具体类”的问题。
- en: On the other hand, there is nobody outside of an SEI lab who has used "Increased
    Monitoring for Intellectual Property Theft by Departing Insiders" as their solution
    to, well, that. So, perhaps patterns have gotten out of hand.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，除了SEI实验室之外，没有人使用“通过离职内部人员增加知识产权盗窃监控”作为解决那个问题的方案。所以，也许模式已经失控了。
- en: Finding a Method to Run
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到运行方法
- en: '*Don''t go out of your way to justify stuff that''s obviously cool. Don''t
    ridicule ideas merely because they''re not the latest and greatest. Pick your
    own fashions. Don''t let someone else tell you what you should like.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要为了证明明显很酷的东西而费尽心机。不要仅仅因为它们不是最新和最棒的而嘲笑想法。选择你自己的时尚。不要让别人告诉你你应该喜欢什么。*'
- en: '*Larry Wall, (Perl, the first postmodern computer language—*[https://www.perl.com/pub/1999/03/pm.html/](https://www.perl.com/pub/1999/03/pm.html/))'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*拉里·沃恩，(Perl，第一种后现代计算机语言——*[https://www.perl.com/pub/1999/03/pm.html/](https://www.perl.com/pub/1999/03/pm.html/))'
- en: 'The Perl community has a mantra: *TIMTOWTDI* (pronounced "Tim Toady"). It stands
    for "There Is More Than One Way to Do It" and reflects the design principle that
    the language should enable its users to write programs in the way in which they
    are thinking and not in the way that the language designer thought about it. Of
    course, TIMTOWTDI is not the only way to do it, and the **Zen of Python**—[http://wiki.c2.com/?PythonPhilosophy](http://wiki.c2.com/?PythonPhilosophy)
    takes a different (though not incompatible) tack:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Perl社区有一个格言：“TIMTOWTDI”（发音为“Tim Toady”）。它代表“有不止一种方法可以做到”（There Is More Than
    One Way to Do It），反映了设计原则，即语言应该允许用户以他们思考的方式编写程序，而不是语言设计者思考的方式。当然，TIMTOWTDI不是唯一的方法，Python的**禅宗**——[http://wiki.c2.com/?PythonPhilosophy](http://wiki.c2.com/?PythonPhilosophy)采取了不同的（尽管不是不兼容的）方法：
- en: '*There should be one-- and preferably only one --obvious way to do it.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*应该只有一个——最好是只有一个——明显的方法来做这件事。*'
- en: 'So, how is a method found? There is more than one way to do it. The first,
    and easiest to understand, is that an object has a method with the same name as
    the message selector, and the language assumes that when you send that message,
    it''s because you want to invoke that method. That''s how this looks in Javascript:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何找到方法呢？有多种方法可以做到。第一种，也是最容易理解的，是一个对象有一个与消息选择器同名的方法，语言假设当你发送那个消息时，是因为你想调用那个方法。这就是JavaScript中的样子：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next way is the most general, and doesn''t exist in all languages and is
    made difficult to use in some. The idea is to have the object *itself* decide
    what to do in response to a message. In Javascript that looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种方法是最通用的，并不是所有语言都有，而且在某些语言中很难使用。想法是让对象*本身*决定对消息做出什么反应。在JavaScript中，它看起来像这样：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While there are many languages that don't have *syntax* for finding methods
    in this way, it's actually very easy to write yourself. We saw in the section
    on functional programming that an object is just a function that turns a message
    into a method, and so any language that lets you write functions returning functions
    will let you write objects that work the way you want them to. This argument is
    also pursued in the talk Object-Oriented Programming in Functional Programming
    in Swift—[https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift](https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多语言没有以这种方式查找方法的*语法*，但实际上自己编写它非常简单。我们在功能编程的部分中看到，对象只是一个将消息转换为方法的函数，因此任何允许你编写返回函数的函数的语言都将允许你编写按你想要的方式工作的对象。这个论点在
    Swift 中的面向对象编程谈话中也得到了追求——[https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift](https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift)。
- en: 'Almost all programming languages that have objects have a fall-through mechanism,
    in which an object that does not have a method matching the message selector will
    look by default at *another* object to find the method. In Javascript, fully bought
    into the worldview of Tim Toady, there are two ways to do this (remember that
    this is already the *third* way to find methods in Javascript). The first, classic,
    original recipe Javascript way, is to look at the object''s prototype:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有具有对象的编程语言都有一个回退机制，即如果一个对象没有与消息选择器匹配的方法，它将默认查看*另一个*对象以找到方法。在 JavaScript 中，完全接受了
    Tim Toady 的世界观，有两种方式来做这件事（记住，这已经是 JavaScript 中找到方法的*第三种*方式了）。第一种，经典、原始的 JavaScript
    方法，是查看对象的原型：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the second way, which in some other languages is the *only* way to define
    a method, is to have the object look at its class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式，在有些其他语言中是定义方法的*唯一*方式，是让对象查看其类：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A little bit of honesty at the expense of clarity here: these last two are
    actually just different syntax for the same thing; the method ends up being defined
    on the object''s prototype and is found there. The mental model is different,
    and that''s what is important.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们牺牲了一些清晰度以换取一点诚实：这最后两点实际上只是同一件事的不同语法；方法最终是在对象的原型上定义的，并在那里找到。心智模型是不同的，这才是重要的。
- en: 'But we can''t stop there. What if *that* object can''t find the method? In
    the prototype case, the answer is clear: it could look at its prototype, and so
    on, until the method is found, or we run out of prototypes. To an external user
    of an object, it looks like the object has all of the behavior of its prototype
    *and* the things it defines (which may be other, distinct features, or they may
    be replacements for things that the prototype already did). We could say that
    the object *inherits* the behavior of its prototype.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不能止步于此。如果那个对象找不到方法怎么办？在原型案例中，答案很明确：它可以查看其原型，以此类推，直到找到方法，或者原型用尽。对于一个对象的外部用户来说，看起来这个对象拥有其原型及其定义的所有行为（这可能是一些其他、不同的特征，或者它们可能是原型的替代品）。我们可以说，对象*继承*了其原型的行为。
- en: The situation with inheritance when it comes to classes is muddier. If my object's
    class doesn't implement a method to respond to a message, where do we look next?
    A common approach, used in early object environments such as Simula and Smalltalk,
    and in Objective-C, Java, C#, and others, is to say that a class is a refinement
    of a *single* other class, often called the superclass, and to have instances
    of a class inherit the behavior defined for instances of the superclass, and its
    superclass, until we run out of `superclasses`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到类时，继承的情况更为复杂。如果我的对象类没有实现响应消息的方法，我们接下来该看哪里？一个常见的方法，在早期的对象环境（如 Simula 和 Smalltalk）以及
    Objective-C、Java、C# 等语言中使用，是说一个类是对*单个*其他类的细化，通常称为超类，并且类实例将继承为超类实例及其超类定义的行为，直到我们用完`superclasses`。
- en: But that's quite limiting. What if there are two different classes of object
    that one object can be seen as a refinement of? Or two different classes that
    describe distinct behaviors it would make sense for this object to inherit? Python,
    C++, and others allow a class to inherit from *multiple* other classes. When a
    message is sent to an object, it will look for a method implementation in its
    class, then in...
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但这相当有限。如果有一个对象可以被视为两种不同类别的对象的一种改进，或者有两个不同的类描述了它应该继承的不同行为，那会怎样呢？Python、C++和其他语言允许一个类从多个其他类中继承。当一个消息发送给一个对象时，它将在其类中寻找方法实现，然后在其...
- en: '...and now we get confused. It could look breadth-first up the tree, considering
    each of its parents, then each of *their* parents, and so on. Or it could look
    depth-first, considering its first superclass, and *its* first superclass, and
    so on. If there are multiple methods that match a single selector, then which
    is found will depend on the search strategy. And of course, if there are two matching
    methods but with different behavior, then the presence of one may break features
    that depend on the behavior of the other.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '...现在我们感到困惑。它可能从树的广度优先搜索开始，考虑每个父类，然后是每个父类的父类，依此类推。或者它可能从深度优先搜索开始，考虑其第一个超类，然后是其第一个超类的超类，依此类推。如果有多个方法与单个选择器匹配，那么找到的是哪一个将取决于搜索策略。当然，如果有两个匹配的方法但具有不同的行为，那么一个方法的存在可能会破坏依赖于另一个方法行为的特性。'
- en: Attempts have been made to get the benefits of multiple inheritance without
    the confusion. **Mixins**—[https://dl.acm.org/citation.cfm?id=97982](https://dl.acm.org/citation.cfm?id=97982)
    represent "abstract subclasses," which can be attached to any superclass. This
    turns a single-superclass inheritance system into one that's capable of supporting
    a limited form of multiple inheritance, by delegating messages to the superclass
    *and any mixins*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 人们已经尝试在不引起混淆的情况下获得多重继承的好处。**混入（Mixins**）——[https://dl.acm.org/citation.cfm?id=97982](https://dl.acm.org/citation.cfm?id=97982)代表了“抽象子类”，可以被附加到任何超类上。这把单超类继承系统转变为能够支持有限形式的多重继承的系统，通过将消息委派给超类和任何混入。
- en: However, this does not address the problem that conflicts will arise if multiple
    mixins, or a superclass and a mixin, supply the same method. A refinement to the
    idea of mixins, called **traits**, introduces additional rules that avoid the
    conflicts. Each trait exposes the features it provides, and the features it requires,
    on the class into which it is mixed. If the same feature is provided by two traits,
    it must either be renamed in one or be removed from both and turned into a requirement.
    In other words, the programmer can choose to resolve the conflict themselves by
    building a method that does what both of the traits need to do.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有解决如果多个混入（mixins）或一个超类和一个混入提供了相同的方法时，将会出现的冲突问题。对混入（mixins）这一想法的改进，称为**特质（traits**），引入了额外的规则来避免冲突。每个特质都会在它被混入的类中暴露其提供的功能和所需的功能。如果两个特质提供了相同的功能，那么必须要么在其中一个中重命名该功能，要么从两个特质中移除并将其转换为需求。换句话说，程序员可以选择通过构建一个方法来解决这个问题，这个方法能够完成两个特质都需要做的事情。
- en: 'So, inheritance is a great tool for code reuse, allowing one object to borrow
    features from another to complete its task. In "*Smalltalk-80: The Language and
    its Implementation*," that is the justification for inheritance:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，继承是代码重用的一个伟大工具，允许一个对象从另一个对象那里借用特性来完成其任务。在"*Smalltalk-80: The Language and
    its Implementation*"中，这是对继承的辩护：'
- en: '*Lack of intersection in class membership is a limitation on design in an object-oriented
    system since it does not allow any sharing between class descriptions. We might
    want two objects to be substantially similar, but to differ in some particular
    way.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*在面向对象系统中，类成员资格的缺乏是对设计的限制，因为它不允许类描述之间的任何共享。我们可能希望两个对象在实质上相似，但在某些特定方面有所不同。*'
- en: 'Over time, inheritance came to have stronger implications for the intention
    of the designer. While there was always an "is-a" relationship between an instance
    and its class (as in, an instance of the `OrderedCollection` class *is* an `OrderedCollection`),
    there came to be a subset relationship between a class and its subclasses (as
    in, `SmallInteger` is a subclass of `Number`, so any instance of `SmallInteger`
    is also an instance of `Number`). This then evolved into a subtype relationship
    (as in, you have only used inheritance correctly if any program that expects an
    instance of a class also works correctly when given an instance of any subclass
    of that class), which led to the restrictions that tied object-oriented developers
    in knots and led to "favor composition over inheritance": you can only get reuse
    through inheritance if you also conform to these other, unrelated requirements.
    The rules around subtypes are perfectly clear, and mathematically sound, but the
    premise that a subclass *must* be a subtype does not need to be upheld.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，继承对设计者的意图产生了更强的暗示。虽然实例与其类之间始终存在“是”的关系（例如，`OrderedCollection` 类的实例 *是*
    一个 `OrderedCollection`），但类与其子类之间出现了子集关系（例如，`SmallInteger` 是 `Number` 的子类，因此 `SmallInteger`
    的任何实例也是 `Number` 的实例）。这进而演变为子类型关系（例如，只有当任何期望类实例的程序在给定该类任何子类的实例时也能正确运行时，你才正确地使用了继承），这导致了将面向对象开发者搞得团团转的限制，并导致了“优先使用组合而非继承”：只有当你也符合这些其他无关的要求时，你才能通过继承获得复用。关于子类型的规则非常明确，并且在数学上是合理的，但一个子类**必须**是子类型的假设并不需要得到坚持。
- en: 'Indeed, there''s another assumption commonly made that implies a lot of design
    intent: the existence of classes. We have seen that Javascript gets on fine without
    classes, and when classes were added to the language, they were implemented in
    such a way that there is really no "class-ness" at all, with classes being turned
    into prototypes behind the scenes. But the *presence* of classes in the design
    of a system implies, well, the presence of classes: that there is some set of
    objects that share common features and are defined in a particular way.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，还有一个常见的假设，它隐含了大量的设计意图：类的存在。我们已经看到，JavaScript 没有类也能正常运行，而当类被添加到语言中时，它们是以一种方式实现的，以至于实际上根本不存在“类性”，类在幕后被转换成了原型。但是，在系统的设计中**存在**类，意味着，类的存在：存在一些具有共同特征的对象，并且以特定方式定义。
- en: 'But what if your object truly is a hand-crafted, artisanal one-off? Well, the
    class design community has a solution for that: Singleton – the design pattern
    that says, "class of one." But why have a *class* at all? At this point, it''s
    just additional work, when all you want is an *object*. Your class is now responsible
    for three aspects of the system''s behavior: the object''s work, the work of making
    the object, and the work of making sure that there is only one of those objects.
    This is a less cohesive design than if you just made one object that did the work.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你的对象确实是一个手工制作的、独特的单例呢？嗯，类设计社区为此有一个解决方案：单例——这个设计模式说，“一个类的存在。”但是为什么要有一个**类**呢？在这个时候，这只是额外的劳动，当你只想有一个**对象**时。你的类现在负责系统的三个方面的行为：对象的工作、制作对象的工作，以及确保只有一个这样的对象的工作。这比仅仅制作一个执行工作的对象的设计要松散。
- en: If it were possible (as it is in Javascript) to first make an object, then make
    another, similar object, then more, then notice the similarities and differences
    and encapsulate that knowledge in the design of a class that encompasses all of
    those objects, then that one-off object would not need to be anything more than
    an object that was designed once and used multiple times. There would be no need
    to make a class of all objects that are similar to that one, only to constrain
    class membership again to ensure that the singleton instance cannot be joined
    by any compatriots.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话（就像在 JavaScript 中那样），首先创建一个对象，然后创建另一个类似的对象，然后更多，然后注意到相似之处和不同之处，并在包含所有这些对象的类的设计中封装这种知识，那么这个一次性对象就不需要是任何比一次设计并多次使用更多的东西。就没有必要创建一个包含所有与该对象相似的对象的类，只是为了再次约束类成员，以确保单例实例不能被任何同伴加入。
- en: But as you've probably experienced, most programming languages only give you
    one kind of inheritance, and *that* is often the "single inheritance, which we
    also assume to mean subtyping" variety. It's easy to construct situations where
    multiple inheritance makes sense (a book is both a *publication* that can be catalogued
    and shelved and it is a *product* that can be priced and sold); situations where
    single inheritance makes sense (a *bag* has all the operations of a *set*, but
    adding the same object twice means it's in the *bag* twice); and situations where
    customizing a prototype makes sense (our hypothesis is that simplifying the **Checkout**
    interaction by applying a fixed shipping cost instead of letting the customer
    choose from a range of options will increase completion among customers attempting
    to check out). It's easy to consider situations in which all three of those cases
    would simultaneously apply (an online bookstore could easily represent books,
    bags, and checkouts in a single system), so why is it difficult to model all of
    those in the same object system?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你可能已经体验到的，大多数编程语言只提供一种继承方式，而且*那*通常是“单一继承，我们假设它也意味着子类型”。很容易构造出多继承有意义的场景（一本书既是可以被编目和上架的*出版物*，也是可以被定价和销售的*产品*）；单一继承有意义的场景（一个*包*具有*集合*的所有操作，但添加同一个对象两次意味着它在*包*中出现了两次）；以及定制原型有意义的场景（我们的假设是，通过应用固定的运费而不是让客户从一系列选项中选择，简化**结账**交互将增加尝试结账的客户完成率）。很容易考虑所有这三种情况同时适用的情况（一个在线书店可以轻松地在单一系统中表示书籍、包和结账）；那么为什么在同一个对象系统中建模所有这些情况这么困难呢？
- en: When it comes down to it, inheritance is just a particular way to introduce
    delegation – one object finding another to forward a message on to. The fact that
    inheritance is constrained to specific forms doesn't stop us from delegating messages
    to whatever objects we like, but it does stop us from making the *reasons* for
    doing so obvious in our designs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到头来，继承只是引入代理的一种特定方式——一个对象找到另一个对象来转发消息。继承被限制在特定形式的事实并不阻止我们将消息委托给任何我们喜欢的对象，但它确实阻止我们在设计中使这样做的原因明显。
- en: Building Objects
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建对象
- en: '*What then is a personal computer? One would hope that it would be both a medium
    for containing and expressing arbitrary symbolic notions, and also a collection
    of useful tools for manipulating these structures, with ways to add new tools
    to the repertoire.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么什么是个人电脑呢？我们希望它能同时作为包含和表达任意符号概念的中介，以及一组用于操作这些结构的实用工具，并且有方法向工具库中添加新工具。*'
- en: '*Alan C. Kay, "A Personal Computer for Children of All Ages"*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*艾伦·C·凯，《面向所有年龄段儿童的电脑》*'
- en: Smalltalk is both a very personal and a very live system. This affected the
    experience of using, building, and sharing objects built in the system, which
    were all done in a way very different from the edit-compile-assemble-link-run
    workflow associated with COBOL and later languages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk既是一个非常个性化的系统，也是一个非常活跃的系统。这影响了使用、构建和共享系统中构建的对象的体验，这些都是在与COBOL和后来的语言相关的编辑-编译-汇编-链接-运行工作流程非常不同的方式下完成的。
- en: '*As an aside, I''m mostly using "Smalltalk" here to mean "Smalltalk-80 and
    later things that derived from it without changing the experience much." Anything
    that looks and feels "quite a lot like" a Smalltalk environment, such as Pharo
    or Squeak, is included. Things that involve a clearly more traditional workflow,
    like Java or Objective-C, are excluded. Where to draw the line is left intentionally
    ambiguous: try out* **GNU Smalltalk***—*[http://smalltalk.gnu.org/](http://smalltalk.gnu.org/)*)
    and decide whether you think it is "a Smalltalk" or not.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一下，我这里主要用“Smalltalk”来指代“Smalltalk-80及其后来没有改变体验太多的衍生版本”。任何看起来和感觉“非常像”Smalltalk环境的，如Pharo或Squeak，都被包括在内。任何涉及明显更传统工作流程的，如Java或Objective-C，都被排除在外。如何划线是故意模糊的：尝试使用**GNU
    Smalltalk**—*[http://smalltalk.gnu.org/](http://smalltalk.gnu.org/)*)并决定你是否认为它“是Smalltalk”*'
- en: 'A Smalltalk environment is composed of two parts: the virtual machine can execute
    Smalltalk bytecode, and the image contains Smalltalk sources, bytecode, and the
    definitions of classes and objects.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk环境由两部分组成：虚拟机可以执行Smalltalk字节码，而映像包含Smalltalk源代码、字节码以及类和对象的定义。
- en: 'So, the image is both personal and universal. Personal in the sense that it
    is unique to me, containing the objects that I have created or acquired from others;
    universal in the sense that it contains the whole system: there are no private
    frameworks, no executables that contain the Directory Services objects but not
    the GUI objects, and no libraries to link before I can use networking.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个图像既是个人化的，也是普遍性的。个人化在于它对我而言是独一无二的，包含了我自己创造的或从他人那里获得的物体；普遍性在于它包含了整个系统：没有私人框架，没有只包含目录服务对象而不包含GUI对象的可执行文件，也没有在使用网络之前需要链接的库。
- en: 'This makes it very easy to build things: I make the objects I need, and I find
    and use the objects that I can already take advantage of. On the other hand, it
    makes sharing quite fraught: if I need to make a change to a system object for
    some reason, you cannot take in my change without considering the impact that
    change will have on everything else in your image. If you want to add my class
    to your image, you have to make sure that you don''t already have a class with
    that name. We cannot both use the same key on the `Smalltalk` dictionary for different
    purposes.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得构建事物变得非常容易：我创建我需要的对象，我找到并使用我可以利用的对象。另一方面，它使得共享变得相当复杂：如果出于某种原因我需要更改系统对象，你不能接受我的更改而不考虑这个更改将对你的图像中的其他一切产生的影响。如果你想将我的类添加到你的图像中，你必须确保你还没有一个具有该名称的类。我们不能在`Smalltalk`字典中为不同的目的使用相同的键。
- en: It's also live, in that the way you modify the image is by interacting with
    it. Methods are implemented as Smalltalk bytecode (though that bytecode may simply
    be a request to execute a "primitive method" stored on the virtual machine) by
    writing the method into a text field and sending a message to the compiler object
    asking it to compile the method. Classes are added by sending a message to an
    existing class, asking it to create a subclass. Objects are created by sending
    a `new` message to a class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它也是动态的，因为你修改图像的方式是通过与之交互。方法通过将方法写入文本字段并发送消息给编译器对象，请求它编译该方法，以Smalltalk字节码的形式实现（尽管这种字节码可能只是一个请求在虚拟机上执行存储的“原始方法”）。类是通过向现有类发送消息，请求它创建一个子类来添加的。对象是通过向类发送`new`消息来创建的。
- en: 'While there is editing, compilation and debugging, this all takes place within
    the image. This makes for a very rapid prototype and feedback experience (unsurprising,
    as one vision behind Smalltalk was to let children explore the world and computers
    in tandem — [https://mprove.de/diplom/gui/kay72.html](https://mprove.de/diplom/gui/kay72.html).
    Any change you make affects the system you are using, and its effects can be seen
    without rebuilding or quitting an application to launch it again. Similarly, the
    system you are using affects the changes you are making: if an object encounters
    a message to which it does not respond or an assertion is not satisfied, then
    the debugger is brought up, so you can correct your code and carry on.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有编辑、编译和调试，但这些都是在图像内进行的。这使得原型和反馈体验非常快速（毫不奇怪，Smalltalk背后的一个愿景是让孩子们同时探索世界和计算机——[https://mprove.de/diplom/gui/kay72.html](https://mprove.de/diplom/gui/kay72.html)。你做的任何更改都会影响你正在使用的系统，并且其影响可以在不重新构建或退出应用程序重新启动的情况下看到。同样，你正在使用的系统也会影响你正在做的更改：如果一个对象遇到它没有响应的消息或者断言没有得到满足，那么调试器就会被调出，这样你就可以纠正你的代码并继续。
- en: The fast feedback afforded by building UIs out of the objects that represent
    UI widgets was used by lots of **Rapid Application Development** tools, such as
    NeXT's Interface Builder, Borland's Delphi and Microsoft's Visual Basic. These
    tools otherwise took a very different position to the trade-offs described previously.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代表UI小部件的对象构建UI所提供的快速反馈被许多**快速应用开发**工具所使用，例如NeXT的Interface Builder、Borland的Delphi和Microsoft的Visual
    Basic。这些工具在之前描述的权衡方面采取了非常不同的立场。
- en: While an IDE like Eclipse might be made out of Java, a Java developer using
    Eclipse is not writing Java that modifies the Eclipse environment, even where
    the Java package they are writing is an Eclipse plugin. Instead, they use the
    IDE to host tools that produce *another* program containing their code, along
    with references to other packages and libraries needed for the code to work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像Eclipse这样的IDE可能是由Java编写的，但使用Eclipse的Java开发者并不是在编写修改Eclipse环境的Java代码，即使他们正在编写的Java包是Eclipse插件。相反，他们使用IDE来托管生成*另一个*程序的工具，该程序包含他们的代码，以及代码运行所需的其他包和库的引用。
- en: This approach is generic rather than personal (anyone with the same collection
    of packages and libraries can make the standalone code work without any step integrating
    things into their image) and specific rather than universal (the resulting program
    – mistakes aside – contains only the things needed by that program).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更偏向于通用而非个人化（任何拥有相同集合的包和库的人都可以使独立代码工作，而无需任何步骤将它们集成到他们的镜像中）并且更具体而非通用（结果程序——不考虑错误——只包含该程序所需的所有内容）。
- en: This one key difference – that there is a "build phase" separating the thing
    you're making from the thing you're making it in – is the big distinction between
    the two ways of building objects, and one of the ways in which the transfer of
    ideas in either direction remains imperfect.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个关键的区别——有一个“构建阶段”将你正在制作的东西与你制作它的东西分开——是两种构建对象方式之间的主要区别，也是两种方式中思想传递不完美的一种方式。
- en: 'Those Rapid Application Development tools with their GUI builders let you set
    up the UI widgets from the vendor framework and configure their properties, by
    working with live objects rather than writing static code to construct a UI. In
    practice, the limitations on being able to do so are:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些带有GUI构建器的快速应用程序开发工具让你可以从供应商框架中设置UI小部件并配置它们的属性，通过操作实时对象而不是编写静态代码来构建UI。在实践中，能够这样做的能力受到以下限制：
- en: To understand the quality of a UI, you need to work with the real information
    and workflows the interface exposes, and that is all in the program source that's
    sat around in the editor panes and code browsers, waiting to be compiled and integrated
    with the UI layout into the (currently dormant) application.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解UI的质量，你需要与界面暴露的真实信息和工作流程一起工作，所有这些都在编辑器窗格和代码浏览器中等待编译和与UI布局集成到（目前处于休眠状态的）应用程序中。
- en: Changes outside the capability of the UI editor tool cannot be reflected within
    it. Changing the font on a label is easily tested; writing a new text transform
    to be applied to the label's contents is not.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI编辑器工具之外的变化无法反映在其中。更改标签上的字体很容易测试；编写应用于标签内容的新的文本转换则不然。
- en: The bits of a UI that you can test within a UI builder are usually well-defined
    by the platform's interface guidelines anyway, so you never *want* to change the
    font on a label.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在UI构建器中测试的UI部分通常由平台的接口指南明确定义，所以你永远不会*想要*更改标签上的字体。
- en: In practice, even with a UI builder you still have an edit-build-debug workflow.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，即使有UI构建器，你仍然有一个编辑-构建-调试的工作流程。
- en: A similar partial transfer of ideas can be seen in test-driven development.
    A quick summary (obviously, if you want the long version, you could always *buy
    my book*—[https://qualitycoding.org/test-driven-ios-development-book/](https://qualitycoding.org/test-driven-ios-development-book/))
    is that you create an object incrementally by thinking of the messages you want
    to send it, then what it should do in response, then you send those messages and
    record whether you get the expected responses. You probably do not get the expected
    response, as you have not told the object how to behave yet, so you add the bit
    of behavior that yields the correct response and move on to the next message,
    after doing a bit of tidying up.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的思想部分传递也可以在测试驱动开发中看到。简要总结（显然，如果你想看详细版本，你总是可以*购买我的书*——[https://qualitycoding.org/test-driven-ios-development-book/](https://qualitycoding.org/test-driven-ios-development-book/))是，你通过考虑你想发送给对象的哪些消息，然后它应该如何响应，然后发送这些消息并记录是否得到预期的响应来增量地创建一个对象。你可能不会得到预期的响应，因为你还没有告诉对象如何行为，所以你添加一段产生正确响应的行为，然后继续到下一个消息，之后进行一些整理。
- en: In the world of Smalltalk, we have already seen that something unexpected happening
    leaves you in the debugger, where you can patch up the thing that's broken. So,
    the whole of the preceding process can be resummarised as "think of a message,
    type it in, hit *do it*, edit the source until the debugger stops showing up,"
    and now you have an increment of working software in your image.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Smalltalk的世界里，我们已经看到，一些意外事件会让你陷入调试器中，在那里你可以修复出错的组件。因此，前面的整个过程可以总结为“想一个消息，输入它，点击*执行*，编辑源代码直到调试器停止显示”，现在你已经在你的镜像中增加了一个工作软件的增量。
- en: 'In the world of Java, even though the same person wrote both the SUnit and
    JUnit testing tools, the process is (assuming you already have a test project
    with the relevant artefacts):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的世界里，即使同一个人编写了SUnit和JUnit测试工具，过程也是（假设你已经有一个包含相关工件的项目）：
- en: Write the code to send the message
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写发送消息的代码
- en: Appease the compiler
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 满足编译器
- en: Build and run the test target
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行测试目标
- en: Use the output to guide changes, back in the editor
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输出结果来指导编辑器中的更改
- en: Repeat 3 and 4 until the test passes
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复3和4，直到测试通过
- en: So, there's a much longer feedback loop. That applies to any kind of feedback,
    from acceptance testing to correctness testing. You can't build the thing you're
    building from within itself, so there's always a pause as you and your computer
    switch context.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存在一个更长的反馈循环。这适用于任何类型的反馈，从验收测试到正确性测试。你不能从你正在构建的东西内部构建它，所以当你和你的电脑切换上下文时，总是会有一个暂停。
- en: 'The reason for this context switch is only partly due to technology: in 2003,
    when Apple introduced Xcode, they made a big deal of "fix and continue," a facility
    also available in Java environments, amongst others: when the source code is changed,
    within certain limits, the associated object file can be rebuilt and injected
    into the running application without having to terminate and re-link it. However,
    that is typically not how programmers *think* about their activities. The worldview
    that lends us words like "toolchain" and "pipeline" is one of sequential activities,
    where a program may *end up* "in production" but certainly doesn''t *start* there.
    People using the programs happens at the end, when the fun is over.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种上下文切换的原因只有部分是由于技术：在2003年，当苹果公司推出Xcode时，他们大肆宣传“修复并继续”，这个功能在Java环境等其他环境中也可用：当源代码更改时，在一定的范围内，相关的目标文件可以被重新构建并注入到正在运行的应用程序中，而无需终止和重新链接它。然而，这通常不是程序员*思考*他们活动的方式。赋予我们“工具链”和“流水线”等词汇的世界观是一种顺序活动，其中程序可能*最终*“在生产中”，但肯定不是*开始*在那里。使用程序的人发生在乐趣结束之后。
- en: Conclusion to Part One
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分结论
- en: 'We have seen that Object-Oriented Programming is indeed, as many detractors
    suggest, a complex paradigm with many moving parts. We have also seen that this
    complexity is not essential: at its core is a single idea that a problem can be
    modeled as lots of distinct, interacting agents, and that each of those agents
    can be modeled as a small, isolated computer program. The solution to the original
    problem is found in the interaction between those agents, which is mediated by
    message passing.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，面向对象编程确实，正如许多批评者所建议的，是一个具有许多移动部件的复杂范例。我们还看到，这种复杂性不是必要的：其核心是一个单一的想法，即问题可以被建模为许多不同的、相互作用的代理，并且每个代理都可以被建模为一个小的、孤立的计算机程序。原始问题的解决方案在于这些代理之间的交互，这种交互是通过消息传递来介导的。
- en: 'Some of the incidental complexity seems to have been added by people wanting
    to make their mark: the proliferation in design patterns appears to have occurred
    because it is always easier to add a new pattern than to consolidate existing
    ones; however much some people might like to erase Singleton from history. Objects
    are not "just" decomposition and message-passing, they are that *and* providing
    access to a program''s data, or that *and* a hierarchy of classes.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 部分偶然的复杂性似乎是由于人们想要留下自己的印记而添加的：设计模式的激增似乎是因为添加新模式总是比巩固现有模式更容易；尽管有些人可能喜欢从历史上抹去Singleton。对象不仅仅是分解和消息传递，它们是*并且*提供对程序数据的访问，或者*并且*一个类层次的体系结构。
- en: 'Much of the complexity associated with objects comes from another source: trying
    to treat object-oriented programming as much like the structured, procedural,
    imperative processes that came before, and map its terminology onto the thought
    structures and workflows of the established ways of writing software. This is
    the "structured on-ramp" of this section''s introduction, in which OOP is seen
    as an extension to existing ideas, and programs are made "better" by adding objects
    in the same way that food is made "better" by sprinkling paprika on top. Thus,
    it is that Ann Weintz could say that "A NeXT Object is simply a piece of C code"
    in *Writing NeXT Applications.* Thus, object-oriented software engineering is
    about building complex software systems by careful, top-down analysis of the procedures
    (or bottom-up analysis of the data and its manipulations), while also as a side
    activity creating a hierarchy of classes with particular relationships.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象相关的大部分复杂性都源于另一个原因：试图将面向对象编程与之前出现的结构化、过程式、命令式流程相类似，并将它的术语映射到既定软件编写方式的思维结构和工作流程中。这就是本节引言中提到的“结构化入门”，其中面向对象编程被视为现有思想的扩展，通过添加对象使程序“更好”，就像在食物上撒上辣椒粉使其“更好”一样。因此，Ann
    Weintz 在《编写 NeXT 应用程序》一书中可以说：“NeXT 对象仅仅是 C 代码的一部分”。因此，面向对象软件工程是通过仔细的、自上而下的分析程序（或自下而上的分析数据和其操作）来构建复杂的软件系统，同时作为一个附带活动创建具有特定关系的类层次结构。
- en: If objects are something you do *as well as* writing software, then no wonder
    it is harder than not using the objects! OOP seems to have failed, but it may
    not even have been attempted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将对象视为与编写软件一样需要去做的事情，那么难怪这比不使用对象要难！面向对象编程似乎失败了，但也许它甚至都没有真正尝试过。
