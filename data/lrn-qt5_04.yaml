- en: Style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: It’s generally a good idea to aim for function before form in the development
    process, but the UI is the part of the application our users interact with and
    is a key ingredient of a successful solution. In this chapter, we will introduce
    a CSS-like style resource and build on the responsive design principles we introduced
    in the last chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，通常最好先考虑功能，然后再考虑形式，但UI是我们的用户与之交互的应用程序的一部分，也是成功解决方案的关键因素。在本章中，我们将介绍类似CSS的样式资源，并在上一章介绍的响应式设计原则的基础上进行构建。
- en: We will create custom QML components and modules to maximize code reuse. We
    will integrate Font Awesome into our solution to provide us with a suite of scalable
    icons and help give our UI a modern graphical look. We will tidy up the navigation
    bar, introduce the concept of commands, and build the framework for a dynamic,
    context-sensitive command bar.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自定义的QML组件和模块，以最大程度地重用代码。我们将集成Font Awesome到我们的解决方案中，为我们提供一套可扩展的图标，并帮助我们的UI呈现出现代的图形外观。我们将整理导航栏，引入命令的概念，并构建一个动态的、上下文敏感的命令栏的框架。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Custom style resource
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义样式资源
- en: Font Awesome
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体真棒
- en: Custom components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义组件
- en: Navigation bar styling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航栏样式
- en: Commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Style resource
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式资源
- en: 'First off, let’s create a new resource file to contain the non-QML visual elements
    we will need. In the `cm-ui` project, Add New... > Qt > Qt Resource File:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的资源文件，以包含我们需要的非QML视觉元素。在`cm-ui`项目中，添加新... > Qt > Qt资源文件：
- en: '![](img/98aae715-a183-4b20-a955-8370098aad56.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98aae715-a183-4b20-a955-8370098aad56.png)'
- en: Name the file `assets.qrc` and place it in `cm/cm-ui`. Your new file will automatically
    open in the Resource Editor, which I don’t find to be a particularly helpful editor,
    so close it. You will see that the `assets.qrc` file has been added to the Resources
    section of the `cm-ui` project. Right-click on it and select Add New… > Qt > QML
    File. Call the file `Style.qml` and save it to `cm/cm-ui/assets`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件命名为`assets.qrc`，并将其放置在`cm/cm-ui`中。您的新文件将自动在资源编辑器中打开，我发现这个编辑器并不是特别有用，所以关闭它。您将看到`assets.qrc`文件已添加到`cm-ui`项目的资源部分。右键单击它，然后选择添加新...
    > Qt > QML文件。将文件命名为`Style.qml`，并将其保存到`cm/cm-ui/assets`。
- en: 'Edit the `assets.qrc` file in the Plain Text Editor in the same way we did
    for the views:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯文本编辑器中编辑`assets.qrc`文件，方式与我们为视图所做的方式相同：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, edit `Style.qml` and we’ll add a single style property to use for the
    background color of our views:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`Style.qml`，我们将添加一个用于视图背景颜色的单个样式属性：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What we are doing here in C++ terms is creating a singleton class with a public
    member variable of type const color called `colourBackground` with an initialized
    value of a hex RGB code for (very) light grey.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++术语中，我们正在创建一个具有名为`colourBackground`的const颜色类型的公共成员变量的单例类，并初始化为（非常）浅灰色的十六进制RGB代码的值。
- en: Now, we need to perform a little bit of a manual fudge to wire this up. We need
    to create a Module Definition file named `qmldir` (with no file extension) in
    the same folder as `Style.qml` (`cm/cm-ui/assets`). There is no built-in template
    for this type of file, so we need to create it ourselves. File Explorer in older
    versions of Windows used to make this a painful exercise as it always insisted
    on a file extension. A console command was required to forcibly rename the file.
    Windows 10 will happily create the file without an extension. In the Unix world,
    files without an extension are more common.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进行一点手动的调整。我们需要在与`Style.qml`（`cm/cm-ui/assets`）相同的文件夹中创建一个名为`qmldir`的模块定义文件（没有文件扩展名）。对于这种类型的文件，没有内置模板，因此我们需要自己创建它。在旧版本的Windows中，文件资源管理器总是坚持要求文件扩展名，因此这总是一个痛苦的练习。需要使用控制台命令强制重命名文件。Windows
    10将愉快地创建没有扩展名的文件。在Unix世界中，没有扩展名的文件更常见。
- en: 'With the `qmldir` file created, edit `assets.qrc` and insert a new entry for
    it right next to `Style.qml` inside the `/assets` prefix:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`qmldir`文件后，编辑`assets.qrc`，并在`/assets`前缀内的`Style.qml`旁边插入一个新条目：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Double-click on the newly added `qmldir` file and enter the following lines:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 双击新添加的`qmldir`文件，并输入以下行：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have already seen modules when we **import QtQuick 2.9**. This makes version
    2.9 of the QtQuick module available for use in our views. In our `qmldir` file,
    we are defining a new module of our own called `assets` and telling Qt that there
    is a **Style** object within version 1.0 of that module, for which the implementation
    is in our `Style.qml` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在**导入QtQuick 2.9**时看到了模块。这使得QtQuick模块的2.9版本可以在我们的视图中使用。在我们的`qmldir`文件中，我们正在定义一个名为`assets`的新模块，并告诉Qt该模块的1.0版本中有一个**Style**对象，其实现在我们的`Style.qml`文件中。
- en: 'With our new style module created and wired up, let’s now put that modern off-white
    color to use. Start with the first child view we see, `SplashView`, and add the
    following to get access to our new module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并连接了我们的新样式模块后，现在让我们开始使用这种现代的米白色。从我们看到的第一个子视图`SplashView`开始，并添加以下内容以访问我们的新模块：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll note that we’re presented with an angry red underline, suggesting that
    all is not well. Hover over the line with the mouse pointer, and a tooltip will
    tell us that we need to add the import path to our new `qmldir` definition file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们被呈现出愤怒的红色下划线，表明一切并不顺利。将鼠标指针悬停在该行上，工具提示会告诉我们，我们需要将导入路径添加到我们的新`qmldir`定义文件中。
- en: 'There are a couple of ways to do this. The first option is to go to the Projects
    mode and select the current kit’s Build settings and then Debug mode. At the bottom
    in the Build Environment section, click on Details. Here, you can see a list of
    all the environment variables for the current kit and configuration. Add a new
    variable called QML2_IMPORT_PATH and set its value to the `cm-ui` folder:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点。第一种选择是转到“项目”模式，选择当前“工具包”的构建设置，然后选择调试模式。在“构建环境”部分的底部，单击“详细信息”。在这里，您可以看到当前工具包和配置的所有环境变量的列表。添加一个名为QML2_IMPORT_PATH的新变量，并将其值设置为`cm-ui`文件夹：
- en: '![](img/15b22f72-580d-476a-bc12-0b56ead7901c.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15b22f72-580d-476a-bc12-0b56ead7901c.png)'
- en: This adds the project working directory of the `cm-ui` project (`/projects/qt/cm/cm-ui`)
    to the QML Import Path. Note that our module name must reflect the relative path
    to the `qmldir` file from this import path.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`cm-ui`项目的工作目录(`/projects/qt/cm/cm-ui`)添加到QML导入路径。请注意，我们的模块名必须反映到`qmldir`文件相对于此导入路径的相对路径。
- en: The problem with this approach is that this environment variable is tied to
    the `cm.pro.user` file. If you share the project with other developers, they will
    have their own `cm.pro.user` files, and they will have to remember to add this
    variable too. Furthermore, it's tied to an absolute path and if you copy the project
    code to another machine, it may not be at that location.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，这个环境变量与`cm.pro.user`文件绑定。如果您与其他开发人员共享项目，他们将拥有自己的`cm.pro.user`文件，并且他们必须记住也要添加这个变量。此外，它与绝对路径绑定，如果您将项目代码复制到另一台机器上，它可能不在那个位置。
- en: 'The second, and preferred, option is to add the following line to `main.cpp`
    immediately after instantiating **QQmlApplicationEngine**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种，也是首选的选项是在实例化**QQmlApplicationEngine**之后立即在`main.cpp`中添加以下行：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So why `qrc:/` and not the absolute path to our `qmldir` file? You''ll remember
    that we added our `views.qrc` resource bundle to a `RESOURCES` variable in `cm-ui.pro`. 
    What this does is it takes all the files from `views.qrc` and compiles them into
    the application binary in a kind of virtual filesystem, where the prefixes act
    as virtual folders.  The root of this virtual filesystem is referenced as `qrc:/`
    and by using this in the import path, we are essentially asking Qt to look inside
    all of our bundled resource files for any modules. Head over to `cm-ui.pro` and
    ensure that our new `assets.qrc` has also been added to `RESOURCES`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么是`qrc:/`而不是我们`qmldir`文件的绝对路径？您会记得我们在`cm-ui.pro`中的`RESOURCES`变量中添加了我们的`views.qrc`资源包。这样做的作用是将`views.qrc`中的所有文件编译到应用程序二进制文件中，形成一种虚拟文件系统，其中前缀充当虚拟文件夹。这个虚拟文件系统的根目录被引用为`qrc:/`，通过在导入路径中使用这个，我们实质上是在要求Qt在我们的所有捆绑资源文件中查找任何模块。转到`cm-ui.pro`，确保我们的新`assets.qrc`也已添加到`RESOURCES`中：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This can be a bit confusing, so to reiterate, we have added the following folder
    to search for new modules, either using the QML2_IMPORT_PATH environment variable
    to search our `cm-ui` project folder on our local physical filesystem, or the
    `addImportPath()` method to search the root of our virtual resource filesystem
    at runtime.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点令人困惑，所以重申一下，我们已经添加了以下文件夹来搜索新的模块，可以使用QML2_IMPORT_PATH环境变量在本地物理文件系统上搜索我们的`cm-ui`项目文件夹，或者使用`addImportPath()`方法在运行时搜索我们虚拟资源文件系统的根目录。
- en: In both cases, our `qmldir` file that defines our new module is in a folder
    called `assets` a level below that, that is, either `<Qt Projects>/cm/cm-ui/assets` in
    the physical filesystem or `qrc:/assets` in the virtual.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，定义我们的新模块的`qmldir`文件位于一个名为`assets`的文件夹中，即在物理文件系统中的`<Qt Projects>/cm/cm-ui/assets`或虚拟文件系统中的`qrc:/assets`。
- en: This gives us the module name `assets`. If our folder structure was deeper,
    like stuff/badgers/assets, then our module would need to be called `stuff.badgers.assets`,
    as that is the path relative to our defined import path. Similarly, if we wanted
    to add another module for our existing views, we would create a `qmldir` file
    in `cm-ui/views` and call the module `views`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们模块名`assets`。如果我们的文件夹结构更深，比如stuff/badgers/assets，那么我们的模块需要被称为`stuff.badgers.assets`，因为这是相对于我们定义的导入路径的路径。同样，如果我们想为现有视图添加另一个模块，我们将在`cm-ui/views`中创建一个`qmldir`文件，并称模块为`views`。
- en: If you see that Qt Creator is still a bit confused and the red line still persists,
    ensure that `cm-ui.pro` contains the `QML_IMPORT_PATH += $$PWD` line.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现Qt Creator仍然有点困惑，红线仍然存在，请确保`cm-ui.pro`包含`QML_IMPORT_PATH += $$PWD`行。
- en: 'With all this in place, we can now use our new module. Including the module
    means we can now access our singleton `Style` object and read properties from
    it. Replace the `color` property of our `SplashView`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们现在可以使用我们的新模块。包括模块意味着我们现在可以访问我们的单例`Style`对象并从中读取属性。替换我们的`SplashView`的`color`属性：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Repeat this to set the background color for all of our views except `MasterView`.
    Remember to `include ui.assets 1.0` in each view too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此操作，为除`MasterView`之外的所有视图设置背景颜色。记得在每个视图中也包含`include ui.assets 1.0`。
- en: When you build and run the application, you may wonder why we’ve gone through
    all of that rigmarole when the views look exactly the same as they did before.
    Well, let’s say that we’ve just had a meeting with the guys from marketing where
    they told us that yellowy orange is not a good fit for the brand any more, and
    we need to change all the views to be a clean off-white color. We would previously
    have had to go into every view and change the color from `#f4c842` to `#efefef`.
    Now, there are only seven of them, so it’s not a big deal, but imagine if we had
    to change all the colors for all the components in 50 complex views; that would
    be a very painful exercise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建和运行应用程序时，您可能会想知道为什么我们要经历所有这些麻烦，而视图看起来与以前完全相同。好吧，假设我们刚刚与营销部的人开了个会，他们告诉我们，橙黄色不再适合品牌，我们需要将所有视图更改为干净的米白色。以前，我们必须进入每个视图，并将颜色从`#f4c842`更改为`#efefef`。现在，只有七个，所以这没什么大不了的，但是想象一下，如果我们不得不为50个复杂的视图中的所有组件更改所有颜色，那将是一个非常痛苦的过程。
- en: However, go to `Style.qml` and change the `colourBackground` property from `#f4c842`
    to `#efefef`. Build and run the application and bask in the glory of our rebranded
    app! By setting up our shared style component early, we can add the properties
    as we go and then restyling our app later becomes much easier. We can add properties
    of all types here, not just colors, so we’ll be adding sizes, fonts, and other
    things as we progress further through our development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，转到`Style.qml`并将`colourBackground`属性从`#f4c842`更改为`#efefef`。构建和运行应用程序，沐浴在我们重新品牌的应用程序的荣耀中！通过尽早设置我们的共享样式组件，我们可以在进行的过程中添加属性，然后稍后重新设计我们的应用程序变得更容易。我们可以在这里添加所有类型的属性，不仅仅是颜色，所以随着我们进一步开发，我们将添加大小、字体和其他东西。
- en: Font Awesome
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Font Awesome
- en: 'With our styling framework in place, let’s review what our navigation bar looks
    like and figure out what we want to achieve:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的样式框架，让我们来看看我们的导航栏是什么样子的，然后想想我们想要实现什么：
- en: '![](img/5ff42490-1ab9-4573-88bc-ac1e8e9af10c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ff42490-1ab9-4573-88bc-ac1e8e9af10c.png)'
- en: The buttons we want to display on our navigation bar are Dashboard View (the
    Home view), New Client View, and Find Client View, along with a toggle button
    at the top to expand and collapse the bar.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在导航栏上显示的按钮是仪表板视图（主页视图）、新客户视图和查找客户视图，以及顶部的切换按钮，用于展开和折叠栏。
- en: A common UI design pattern is to represent simple commands with icons. Further
    information about the command can be obtained by a variety of means; for example,
    when you hover over the button, information can be displayed in a tooltip or a
    status bar at the bottom of the screen. Our approach will be to have a collapsible
    bar. The default state of the bar will be collapsed and will display an icon representing
    each command. In expanded state, the bar will display both the icon and a textual
    description of the command. The user will be able to toggle the states with an
    additional button. This is a pattern particularly prevalent in mobile application
    development, where you want to consume as little screen space as possible by default.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的UI设计模式是使用图标表示简单的命令。有多种方式可以获取有关命令的更多信息；例如，当您悬停在按钮上时，可以在工具提示中或屏幕底部的状态栏中显示信息。我们的方法是拥有一个可折叠的栏。栏的默认状态将是折叠的，并显示代表每个命令的图标。在展开状态下，栏将显示图标和命令的文本描述。用户可以使用额外的按钮切换状态。这是一种在移动应用程序开发中特别普遍的模式，因为您希望默认情况下尽可能少地占用屏幕空间。
- en: There are a few options for displaying the icons for our buttons. Older desktop
    applications would more than likely use image files of some description. This
    gives you full artistic control over how your icons look, but carries several
    drawbacks. Image files tend to be comparatively large in size, and they are a
    fixed size. If you need to draw them at a different size, then they can look bad,
    particularly if they are scaled up or if the aspect ratio changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选项可以显示按钮的图标。较旧的桌面应用程序很可能会使用某种图像文件。这样可以完全控制图标的外观，但也带来了一些缺点。图像文件往往比较大，并且是固定大小的。如果需要以不同的大小绘制它们，它们可能会看起来很糟糕，特别是如果它们被放大或者纵横比发生变化。
- en: '**Scalable Vector Graphics** (**SVG**) are much smaller files and scale very
    well. They are more difficult to create and can be a bit more limited artistically,
    but they can be very useful for the purpose of icons. However, from experience,
    they can be quite tricky to work with in Qt/QML.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**可缩放矢量图形**（**SVG**）文件要小得多，并且缩放效果非常好。它们更难创建，在艺术上可能有一些限制，但对于图标的用途非常有用。然而，根据经验，它们在Qt/QML中可能会很棘手。'
- en: The third option that gives you the small file size and scalability benefits
    of SVG but are much easier to work with are symbol font files. This is a very
    common solution in web development, and this is the approach we will take.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选项可以让您获得SVG的小文件大小和可伸缩性优势，但更容易使用的是符号字体文件。这是Web开发中非常常见的解决方案，也是我们将采取的方法。
- en: There are numerous symbol fonts available but perhaps the most popular for development
    is **Font Awesome**. It provides a wide range of terrific symbols and has a very
    helpful website; check out: [http://fontawesome.io/](http://fontawesome.io/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多符号字体可用，但也许最受欢迎的是**Font Awesome**。它提供了各种精彩的符号，并且有一个非常有帮助的网站；请查看：[http://fontawesome.io/](http://fontawesome.io/)。
- en: Check any licensing applicable for fonts you choose to use, especially if you
    are using them commercially.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您选择使用的字体的任何许可证，特别是如果您要商业使用它们。
- en: Download the kit and open up the archive file. The file we are interested in
    is `fonts`/`fontawesome-webfont.ttf`. Copy this file into our project folder in
    `cm/cm-ui/assets`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下载工具包并打开存档文件。我们感兴趣的文件是`fonts`/`fontawesome-webfont.ttf`。将此文件复制到我们项目文件夹中的`cm/cm-ui/assets`中。
- en: 'In our `cm-ui` project, edit `assets.qrc` and add the font to our resources:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`cm-ui`项目中，编辑`assets.qrc`并将字体添加到我们的资源中：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember that our alias doesn’t have to be the same as the original filename,
    and we’ve taken the opportunity to shorten it a bit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的别名不一定要与原始文件名相同，我们已经有机会将其缩短一点。
- en: 'Next up, edit `Style.qml` and we''ll wire the font up to our custom style for
    easy use. We first need the font to be loaded and made available for use, which
    we achieve using a `FontLoader` component. Add the following inside the root **Item**
    element:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`Style.qml`，我们将把字体与我们的自定义样式连接起来，以便轻松使用。我们首先需要加载字体并使其可用，我们使用`FontLoader`组件来实现这一点。在根**Item**元素内添加以下内容：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `source` property, we use the `/assets` prefix (or virtual folder) we
    defined in our `assets.qrc` file along with the `fontawesome.ttf` alias. Now,
    we have loaded the font but as it stands, we won’t be able to reference it from
    outside of `Style.qml`. This is because only properties at root component level
    are accessible outside of the file. Child components are deemed effectively private.
    The way we get around this is by creating a `property alias` for the element we
    want to expose:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`source`属性中，我们使用了我们在`assets.qrc`文件中定义的`/assets`前缀（或虚拟文件夹），以及`fontawesome.ttf`的别名。现在，我们已经加载了字体，但是就目前而言，我们无法从`Style.qml`之外引用它。这是因为只有根组件级别的属性可以在文件之外访问。子组件被视为私有的。我们绕过这个问题的方法是为我们想要公开的元素创建一个`property
    alias`：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This creates a publicly available property called `fontAwesome`, which when
    called, simply redirects the caller to the `name` property of the internal `fontAwesomeLoader`
    element.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`fontAwesome`的公共可用属性，当调用时，它会简单地将调用者重定向到内部`fontAwesomeLoader`元素的`name`属性。
- en: 'With the wiring done, let’s find the icons we want to use. Back on the Font
    Awesome website, navigate to the Icons page. Here, you can see all the available
    icons. Clicking on one will display further information about it, and it is from
    here that we can get the key piece of information we need in order to display
    it, and that is the unicode character. I’ll select the following icons for our
    menu, but feel free to choose whichever icons you want:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成连接后，让我们找到我们想要使用的图标。回到Font Awesome网站，转到图标页面。在这里，您可以看到所有可用的图标。单击其中一个将显示有关它的更多信息，我们可以从中获取需要显示它的关键信息，即Unicode字符。我将为我们的菜单选择以下图标，但请随意选择任何您想要的图标：
- en: '| **Command** | **Icon** | **Unicode character** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **图标** | **Unicode字符** |'
- en: '| Toggle Menu | bars | f0c9 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Toggle Menu | bars | f0c9 |'
- en: '| Dashboard | home | f015 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Dashboard | home | f015 |'
- en: '| New Client | user-plus | f234 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| New Client | user-plus | f234 |'
- en: '| Find Client | search | f002 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Find Client | search | f002 |'
- en: 'Now, let’s replace the `Button` components on our `MasterView` with a `Text`
    component for each of our icons:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用每个图标的`Text`组件替换`MasterView`上的`Button`组件：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will also need to add the **assets 1.0** import if you haven’t already:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有添加**assets 1.0**导入，则还需要添加它：
- en: '![](img/0f8f95a5-e2a7-4511-986b-f772c7d125d3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f8f95a5-e2a7-4511-986b-f772c7d125d3.png)'
- en: 'Next, we’ll add the descriptive text for the client commands. Wrap each of
    the `Text` components in a `Row` and add a further `Text` component for the description,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为客户命令添加描述性文本。将每个`Text`组件包装在`Row`中，并添加一个描述的`Text`组件，如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Row` component will lay out its children horizontally—first the icon and
    then the descriptive text. Repeat this for the other commands. Add the descriptions
    Dashboard and Find Client for the other buttons and simply an empty string for
    the toggle command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`组件将水平布置其子元素——首先是图标，然后是描述性文本。对其他命令重复此操作。为其他按钮添加Dashboard和Find Client的描述，对于切换命令只需添加空字符串：'
- en: '![](img/877075bc-0bc9-4813-8ba1-dd98326e65dd.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/877075bc-0bc9-4813-8ba1-dd98326e65dd.png)'
- en: Before we get too carried away making further changes, we’ll take a breath,
    do some refactoring, and look at introducing components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行更改之前，我们将停下来，进行一些重构，并开始引入组件。
- en: Components
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: The QML, what we’ve just written, is functional enough, but it's already becoming
    difficult to maintain. Our `MasterView` is getting a little long and difficult
    to read. When we come to change how our command buttons look, for example, aligning
    the icon and text, we will have to change it in four places. If we want to add
    a fifth button, we have to copy, paste, and edit a whole bunch of QML to do so.
    This is where reusable components come into play.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的QML已经足够功能，但已经变得难以维护。我们的`MasterView`变得有点长，难以阅读。例如，当我们要更改命令按钮的外观时，例如对齐图标和文本，我们将不得不在四个地方进行更改。如果我们想要添加第五个按钮，我们必须复制、粘贴和编辑大量的QML。这就是可重用组件发挥作用的地方。
- en: Components are exactly the same as the views we have already created—just snippets
    of QML. The difference is purely semantic. Throughout this book, views represent
    screens that lay out content while components are the content.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组件与我们已经创建的视图完全相同——只是QML的片段。区别纯粹是语义上的。在本书中，视图代表布局内容的屏幕，而组件是内容。
- en: The easiest way to create a new component is when you have already written the
    QML that you want to form the basis for your component, which we have done. Right-click
    on any of the `Row` elements we added for our commands and select **Refactoring
    > Move Component into Separate File**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新组件的最简单方法是当您已经编写了要形成组件基础的QML时。右键单击我们为命令添加的任何`Row`元素，并选择**重构 > 将组件移动到单独的文件中**。
- en: 'Name the new component `NavigationButton` and save it to a new folder—`cm/cm-ui/components`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将新组件命名为`NavigationButton`并将其保存到一个新文件夹`cm/cm-ui/components`中：
- en: '![](img/4b37e410-961d-4855-b235-5b6102bea245.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b37e410-961d-4855-b235-5b6102bea245.png)'
- en: 'The Row element will be moved to our new file and in `MasterView`, you will
    be left with an empty `NavigationButton` component:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`元素将移动到我们的新文件中，在`MasterView`中，您将得到一个空的`NavigationButton`组件：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, it comes with a big red squiggly, and our app will no longer
    run.  While the refactoring step has happily created a new `NavigationButton.qml`
    file for us, it''s not actually included in our project anywhere, so Qt doesn''t
    know where it is. It’s easy enough to resolve though, and we just need to set
    up our resources bundle as we did with our views and assets:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它带有一个大大的红色波浪线，我们的应用程序将不再运行。虽然重构步骤已经为我们创建了一个新的`NavigationButton.qml`文件，但它实际上并没有包含在我们的项目中，所以Qt不知道它在哪里。不过，解决起来很容易，我们只需要像我们对视图和资产所做的那样设置我们的资源包：
- en: Create a new `Qt Resource File` called `components.qrc` in the `cm/cm-ui` folder
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`components.qrc`的新的`Qt Resource File`，放在`cm/cm-ui`文件夹中
- en: Create an empty `qmldir` file in `cm/cm-ui/components` as we did for our assets
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cm/cm-ui/components`中创建一个空的`qmldir`文件，就像我们为我们的资产所做的那样
- en: 'Edit `components.qrc` to include both of our new files within a `/components`
    prefix:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`components.qrc`以在`/components`前缀下包含我们的两个新文件：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Edit `qmldir` to set up our module and add our `NavigationButton` component
    to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`qmldir`以设置我们的模块并将我们的`NavigationButton`组件添加到其中：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ensure that `components.qrc` has been added to the `RESOURCES` variable in `cm-ui.pro`
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`components.qrc`已添加到`cm-ui.pro`中的`RESOURCES`变量中
- en: 'In `MasterView`, include our new components module to get access to our new
    component:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MasterView`中，包含我们的新组件模块，以便访问我们的新组件：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sometimes, getting our module to be fully recognized and banishing the red squigglies
    may only be accomplished by restarting Qt Creator, as that forces the reload of
    all the QML modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，要使我们的模块得到完全识别并消除红色波浪线，可能只能通过重新启动Qt Creator来实现，因为这样可以强制重新加载所有的QML模块。
- en: We now have a reusable component that hides away the implementation details,
    reduces code duplication, and makes it much easier to add new commands and maintain
    the old ones. However, there are a few changes we need to make to it before we
    can leverage it for our other commands.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可重用的组件，隐藏了实现细节，减少了代码重复，并且更容易添加新的命令和维护旧的命令。然而，在我们可以为其他命令利用它之前，还有一些改变需要做。
- en: 'Currently, our `NavigationButton` has hard-coded icon and description text
    values that will be the same whenever we use the component. We need to expose
    both the text properties so that we can set them to be different for each of our
    commands. As we saw, we can achieve this using property aliases, but we need to
    add unique identifiers to our `Text` elements for that to work. Let’s set the
    default values to be something generic and also implement advice from earlier
    in the book to have an `Item` component as the root element:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`NavigationButton`有硬编码的图标和描述文本值，无论何时我们使用组件，它们都将是相同的。我们需要公开文本属性，以便我们可以为我们的每个命令设置不同的值。正如我们所看到的，我们可以使用属性别名来实现这一点，但我们需要为此添加唯一的标识符到我们的`Text`元素中。让我们将默认值设置为一些通用的内容，并且还要实现本书早期的建议，将`Item`组件作为根元素：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that our component is configurable with properties, we can replace our
    commands in `MasterView`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的组件可以通过属性进行配置，我们可以替换`MasterView`中的命令：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is much more concise and manageable than all of the duplicated QML we
    had earlier. Now, if you run the application, you’ll see that while we’ve taken
    a couple of steps forward, and that we’ve also taken one step back:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们之前拥有的所有重复的QML要简洁和易于管理得多。现在，如果你运行应用程序，你会看到虽然我们已经向前迈出了一小步，但我们也后退了一步：
- en: '![](img/2cc949e0-1300-4208-b473-ab860a09c420.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cc949e0-1300-4208-b473-ab860a09c420.png)'
- en: As you can see, all of our components are drawn on top of each other. The root
    cause of this is the issue we’ve touched on previously regarding sizing. We have
    a visual component with a root `Item` element, and we haven’t explicitly defined
    its size. Another thing we are neglecting is our custom style. Let’s fix those
    next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们所有的组件都是叠加在一起的。这个问题的根本原因是我们之前提到的关于大小的问题。我们有一个带有根`Item`元素的可视组件，并且我们没有明确定义它的大小。我们忽视的另一件事是我们的自定义样式。让我们接下来修复这些问题。
- en: Styling the navigation bar
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化导航栏
- en: 'Starting with the easy part, let’s first move our hard-coded colors and icon
    pixel size from `NavigationButton` into `Style.qml`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的部分开始，让我们首先将`NavigationButton`中的硬编码颜色和图标像素大小移到`Style.qml`中：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now need to think about how we want to size the elements of our button.
    We have an icon which we want to be square, so the width and height will be the
    same. Next, to that, we have a text description that will be the same height as
    the icon but will be wider:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要考虑我们想要调整按钮元素的大小。我们有一个图标，我们希望它是正方形的，所以宽度和高度将是相同的。接下来，我们有一个文本描述，它的高度将与图标相同，但宽度会更宽：
- en: '![](img/1a0d5ede-e554-4bff-8009-5485a5757630.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a0d5ede-e554-4bff-8009-5485a5757630.png)'
- en: 'The width of the entire component is the width of the icon plus the width of
    the description. The height of the entire component is the same as both the height
    of the icon and description; however, it gives us more flexibility to make the
    height the same as whichever is the larger of the two. That way, if we ever decide
    to make one item larger than the other, we know that the component will be large
    enough to contain them both. Let’s pick starter sizes of 80 x 80 for the icon
    and 80 x 240 for the description and define the properties:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 整个组件的宽度是图标的宽度加上描述的宽度。整个组件的高度与图标和描述的高度相同；然而，这样做可以让我们更灵活地将高度设置为两者中较大的一个。这样，如果我们决定将一个项目变大，我们知道组件将足够大以容纳它们。让我们选择图标的起始尺寸为80
    x 80，描述的尺寸为80 x 240，并定义这些属性：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are a couple of things to note here. Properties can be bound directly
    to other properties, which reduces the amount of duplication and makes the whole
    setup much more dynamic. We know that we want our icon to be square, so by binding
    the height to be the same as the width, if we want to change the total size of
    the icon, we just need to update the width, and the height will automatically
    update. QML also has strong integration with a JavaScript engine, so we can use
    the `Math.max()` function to help us figure out which is the larger height.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意。属性可以直接绑定到其他属性，这样可以减少重复的数量，使整个设置更加动态。我们知道我们希望我们的图标是正方形的，所以通过将高度绑定为与宽度相同，如果我们想要改变图标的总大小，我们只需要更新宽度，高度将自动更新。QML还与JavaScript引擎有很强的集成，所以我们可以使用`Math.max()`函数来帮助我们找出哪个高度更大。
- en: Another thing we would like the navigation buttons to do is to provide some
    kind of visual cue when the user hovers the mouse over a button to indicate that
    it is an interactive element. To do that, we need each button to have its own
    background rectangle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望导航按钮提供一些视觉提示，当用户将鼠标悬停在按钮上时，指示它是一个交互元素。为了做到这一点，我们需要每个按钮都有自己的背景矩形。
- en: 'In the `NavigationButton`, wrap the `Row` element in a new `Rectangle` and
    plug the sizes into our component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NavigationButton`中，将`Row`元素包装在一个新的`Rectangle`中，并将尺寸插入到我们的组件中：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run again, and you’ll see a slight improvement:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行，你会看到略微的改进：
- en: '![](img/4ea8081d-d28b-40e7-9335-9a31e0c02f7c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ea8081d-d28b-40e7-9335-9a31e0c02f7c.png)'
- en: 'We’re getting part of the description cut off because our navigation bar is
    hard-coded to be 100 pixels wide. We need to change this and also implement the
    toggle expanded/collapsed functionality. We have already calculated the sizes
    we need, so let’s prepare by adding a couple of new properties to `Style.qml`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导航栏被硬编码为100像素宽，导致部分描述被切断。我们需要改变这一点，并且还要实现切换展开/折叠的功能。我们已经计算出了我们需要的尺寸，所以让我们通过向`Style.qml`添加一些新属性来做好准备：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The collapsed state will be just wide enough for the icon, while the expanded
    state will contain the entire button, including description.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠状态将刚好宽到足够容纳图标，而展开状态将包含整个按钮，包括描述。
- en: Next, let’s encapsulate our navigation bar in a new component. There won’t be
    any reuse benefits in this case as there will only ever be one, but it helps keep
    our QML organized and makes `MasterView` more concise and easy to read.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的导航栏封装在一个新的组件中。在这种情况下，不会有任何重用的好处，因为只会有一个，但这有助于保持我们的QML组织有序，并使`MasterView`更简洁和易于阅读。
- en: 'You can right-click on the `Rectangle` component in `MasterView` and refactor
    our navigation bar into a new QML file, as we did for our `NavigationButton`.
    However, let’s do it manually so that you are comfortable with both approaches.
    Right-click on `components.qrc` and select Add New… > Qt > QML File. Add `NavigationBar.qml`
    to `cm/cm-ui/components`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以右键单击`MasterView`中的`Rectangle`组件，并将我们的导航栏重构为一个新的QML文件，就像我们为我们的`NavigationButton`所做的那样。然而，让我们手动操作，这样你就可以熟悉这两种方法。右键单击`components.qrc`，然后选择添加新内容...
    > Qt > QML文件。将`NavigationBar.qml`添加到`cm/cm-ui/components`中：
- en: '![](img/0c4e1ac6-4818-49d8-8118-07d9ecf603b6.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c4e1ac6-4818-49d8-8118-07d9ecf603b6.png)'
- en: 'Edit `components.qrc` and move our new `NavigationBar` into the `/components`
    prefix section with an alias:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`components.qrc`，将我们的新`NavigationBar`移动到`/components`前缀部分，并使用别名：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the component to our components module by editing `qmldir`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件添加到我们的组件模块中，编辑`qmldir`：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Cut the `Rectangle` and its child elements from `MasterView` and paste it into
    `NavigationBar.qml` inside the root `Item` element. Update the `QtQuick` module
    import to version 2.9 if it has been initialized to some older version. Add an
    import for our assets module to gain access to our Style object. Move the Rectangle''s
    `anchors` and `width` properties to the root `Item` and set the `Rectangle` to
    fill its parent:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从`MasterView`中剪切`Rectangle`及其子元素，并将其粘贴到`NavigationBar.qml`中的根`Item`元素内。如果已经初始化为较旧的版本，请将`QtQuick`模块导入更新为版本2.9。添加一个导入我们资产模块的导入，以获得对我们Style对象的访问。将`Rectangle`的`anchors`和`width`属性移到根`Item`，并设置`Rectangle`以填充其父元素：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Back in `MasterView`, you can now add the new `NavigationBar` component in
    where the `Rectangle` used to be:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MasterView`，现在可以在原来的`Rectangle`位置添加新的`NavigationBar`组件：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although you get the dreaded red squigglies again, you will actually be able
    to run the application and verify that the refactoring hasn’t broken anything.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你会再次看到可怕的红色波浪线，但你实际上可以运行应用程序并验证重构没有出现任何问题。
- en: 'The anchoring of our new `NavigationBar` component is fine, but the `width`
    is a little more complicated—how do we know whether it should be `Style.widthNavigationBarCollapsed`
    or `Style.heightNavigationBarExpanded`? We’ll control this with a publicly accessible
    Boolean property that indicates whether the bar is collapsed or not. We can then
    use the value of this property to decide which width we want using the conditional
    `?` operator syntax. Set the property to be true initially, so the bar will render
    in its collapsed state by default:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`NavigationBar`组件的定位是好的，但`width`要复杂一些——我们怎么知道它应该是`Style.widthNavigationBarCollapsed`还是`Style.heightNavigationBarExpanded`？我们将通过一个公开访问的布尔属性来控制这一点，该属性指示栏是否已折叠。然后我们可以使用这个属性的值来决定我们想要使用哪个宽度，使用条件`?`操作符语法。最初将属性设置为true，这样栏将默认以折叠状态呈现：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With that in place, replace the hard-coded `width` of 100, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，替换100的硬编码`width`如下：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, update the `color` property of `Rectangle` to `Style.colourNavigationBarBackground`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`Rectangle`的`color`属性为`Style.colourNavigationBarBackground`：
- en: '![](img/d9041acb-28ab-4c99-99bb-b7c7b247be84.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9041acb-28ab-4c99-99bb-b7c7b247be84.png)'
- en: We’re getting there now, but one key thing we’ve missed along the way is that
    clicking on the buttons now doesn’t actually do anything anymore. Let’s fix that
    next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经接近了，但我们一路上错过的一个关键点是，现在点击按钮实际上什么都不做了。让我们下一步修复这个问题。
- en: Clicking
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击
- en: Early on in this book, we looked at a component called `MouseArea`. This was
    soon superseded by our use of `Button` components, which provide the clicking
    functionality for us. However, now that we are rolling our own form of buttons,
    we need to implement the clicking functionality ourselves. Much like the `Button`
    components, our `NavigationButton` shouldn’t really do anything when they are
    clicked on, other than informing their parent that the event has occurred. Components
    should be as generic and ignorant about context as possible so that you can use
    them in multiple places. What we need to do is add a `MouseArea` component and
    simply pass on the `onClicked` event via a custom signal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们看过一个叫做`MouseArea`的组件。这很快被我们使用的`Button`组件所取代，它为我们提供了点击功能。然而，现在我们正在开发自己的按钮形式，我们需要自己实现点击功能。与`Button`组件类似，我们的`NavigationButton`在被点击时实际上不应该做任何事情，除了通知其父组件事件已发生。组件应尽可能地通用和无知于上下文，以便您可以在多个地方使用它们。我们需要做的是添加一个`MouseArea`组件，并通过自定义信号简单地传递`onClicked`事件。
- en: 'In `NavigationButton`, we first add the signal that we want to emit whenever
    the component has been clicked on. Add this just after the properties:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NavigationButton`中，我们首先添加我们希望在组件被点击时发出的信号。在属性之后添加这个：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Try and give the signals quite specific names, even if they are a little long.
    If you simply call everything `clicked()`, then things can get a little confusing
    and sometimes you may find yourself referencing a different signal to the one
    you intended.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量给信号起相当具体的名称，即使有点长。如果你简单地把一切都叫做`clicked()`，那么事情可能会变得有点混乱，有时你可能会发现自己引用了一个不同于你打算的信号。
- en: 'Next, we’ll add another property to support some mouse hover magic we’ll implement.
    This will be a `color` type, and we’ll default it to be the regular background
    color:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一个属性来支持我们将要实现的鼠标悬停效果。这将是一个`color`类型，并且我们将默认它为常规背景颜色：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’ll use this color in conjunction with the `states` property of `Rectangle`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将与`Rectangle`的`states`属性一起使用这个颜色：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Think of each state in the array as a named configuration. The default configuration
    has no name ("") and consists of the properties we have already set within the
    `Rectangle` element. The “hover” state applies changes to the properties specified
    in the `PropertyChanges` element, that is, it will change the `color` property
    of the element with ID `background` to be whatever the value of `hoverColour`
    is.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组中的每个状态视为一个命名配置。默认配置没有名称（""），由我们已经在`Rectangle`元素中设置的属性组成。 “悬停”状态应用于`PropertyChanges`元素中指定的属性的更改，也就是说，它将把ID为`background`的元素的`color`属性更改为`hoverColour`的值。
- en: 'Next, inside the `Rectangle` but below the `Row`, add our `MouseArea`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Rectangle`内但在`Row`下方，添加我们的`MouseArea`：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use the `anchors` property to fill the whole button background area, including
    icon and description. Next, we’ll jazz things up a bit by changing the mouse cursor
    to a pointing hand when it enters the button area and enabling hovering with the
    `hoverEnabled` flag. When enabled, the **entered** and **exited** signals are
    emitted when the cursor enters and exits the area, and we can use the corresponding
    slots to change the appearance of our background `Rectangle` by switching between
    the hover state we’ve just implemented and the default (""). Finally, we respond
    to the `clicked()` signal of `MouseArea` with the `onClicked()` slot and simply
    emit our own signal.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`anchors`属性来填充整个按钮背景区域，包括图标和描述。接下来，我们将通过将鼠标光标更改为指向手指，当它进入按钮区域时启用悬停`hoverEnabled`标志来使事情变得有趣一些。启用后，当光标进入和退出区域时会发出**entered**和**exited**信号，我们可以使用相应的插槽通过在刚刚实现的悬停状态和默认（""）之间切换来改变我们的背景`Rectangle`的外观。最后，我们通过`MouseArea`的`clicked()`信号响应`onClicked()`插槽并简单地发出我们自己的信号。
- en: 'We can now react to the `navigationButtonClicked()` signal in our `NavigationBar`
    component and add some hover colors while we’re at it. Implement the toggle button
    first:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对`NavigationBar`组件中的`navigationButtonClicked()`信号做出反应，并在此过程中添加一些悬停颜色。首先实现切换按钮：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We implement the `<MyCapitalisedSignalName>` convention to create a slot for
    our signal and when it fires, we simply toggle the value of `isCollapsed` between
    `true` and `false`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`<MyCapitalisedSignalName>`约定来为我们的信号创建一个插槽，当它触发时，我们只需在`true`和`false`之间切换`isCollapsed`的值。
- en: 'You can now run the application. Click on the Toggle button to expand and collapse
    the navigation bar:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以运行应用程序。单击切换按钮以展开和折叠导航栏：
- en: '![](img/180bd707-01e0-487d-a7c1-3e63e5c47372.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/180bd707-01e0-487d-a7c1-3e63e5c47372.png)'
- en: Note how because of our use of `anchors`, the child views dynamically resize
    themselves to accommodate the navigation bar. You will also see the pointing hand
    cursor and a flash of color when you hover over the button, which helps the user
    understand that it is an interactive element and visualizes the boundaries.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用了`anchors`，子视图会动态调整大小以适应导航栏。当您悬停在按钮上时，还会看到指向手指光标和一道闪烁的颜色，这有助于用户理解它是一个交互式元素并可视化边界。
- en: For the remaining navigation buttons, what we want to do in reaction to the
    clicked event is to emit the `goDashboardView()`, `goCreateClientView()`, and
    `goFindClientView()` signals on the `NavigationCoordinator`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的导航按钮，我们希望在点击事件发生时发出`NavigationCoordinator`上的`goDashboardView()`，`goCreateClientView()`和`goFindClientView()`信号。
- en: 'Add the `onNavigationButtonClicked` slots to the other buttons and drill down
    through the `masterController` object to get to the signals we want to call. Add
    some fancy colors of your choice too:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将`onNavigationButtonClicked`插槽添加到其他按钮，并通过`masterController`对象深入到我们想要调用的信号。也可以添加一些自己喜欢的花哨颜色：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can now click on the buttons to navigate to the different child views.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以单击按钮导航到不同的子视图。
- en: A few last little tweaks to finish the navigation bar are to align the content
    of our buttons a little better and resize a few things.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成导航栏的最后一些微调，我们需要更好地对齐按钮的内容并调整一些大小。
- en: 'The description text should align vertically with the center of the icon rather
    than the top, and our icons should be centered rather than pinned up against the
    edge of the window. The first issue is easy to solve, because we’ve already been
    consistent and explicit with our sizings. Simply add the following property to
    both the `Text` components in `NavigationButton`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 描述文本应该垂直对齐到图标的中心而不是顶部，我们的图标应该居中而不是紧贴窗口边缘。第一个问题很容易解决，因为我们已经在大小上保持了一致并且明确。只需将以下属性添加到`NavigationButton`中的两个`Text`组件中：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both the `Text` elements were sized to take up the full height of the button,
    so we simply need to align the text vertically within that space.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`Text`元素的大小被调整为占据整个按钮的高度，因此我们只需要在该空间内垂直对齐文本。
- en: 'Fixing the alignment of the icons is just the same, but this time in the horizontal
    axis. Add the following to the `Text` component of the icon:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 修复图标的对齐方式与之前一样，但这次是在水平轴上。在图标的`Text`组件中添加以下内容：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As for the sizings, our description text is a little small and there is a lot
    of empty space after the text. Add a new property to our `Style` object:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 至于大小，我们的描述文本有点小，文本后面有很多空白。向我们的`Style`对象添加一个新属性：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the new property in the description `Text` element:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述`Text`元素中使用新属性：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, reduce the `widthNavigationButtonDescription` property in `Style` to 160.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`Style`中的`widthNavigationButtonDescription`属性减小到160。
- en: 'Run the app and we’re nearly there. The sizing and alignment is much better
    now:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们几乎到达目标了。大小和对齐现在好多了：
- en: '![](img/d011ffc4-fc00-4900-9347-f7f6ae385647.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d011ffc4-fc00-4900-9347-f7f6ae385647.png)'
- en: However, one thing you may not note is that when the bar is collapsed and only
    the icon is displayed, the `MouseArea` is still the full width of the button including
    the description. Try moving the mouse where the description would be, and you
    can see the pointing hand cursor appear. You can even click on the components
    and the transition happens. What we need to do to fix this is rather than the
    root `Item` element in `NavigationButton` being a fixed width (`Style.widthNavigationButton`),
    we need to make it dynamic and set it to `parent.width` instead. In order for
    that to work, we then need to walk up the QML hierarchy and ensure that its parent
    has a width too. Its parent is the `Column` element in `NavigationBar`. Set the
    `width` property of `Column` to be `parent.width` too.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能没有注意到的一件事是，当栏被折叠并且只显示图标时，`MouseArea`仍然是包括描述的整个按钮的宽度。尝试将鼠标移动到描述的位置，您会看到指向手光标出现。您甚至可以单击组件，然后进行过渡。我们需要做的是，而不是`NavigationButton`中的根`Item`元素是一个固定宽度（`Style.widthNavigationButton`），我们需要使其动态，并将其设置为`parent.width`。为了使其工作，我们需要沿着QML层次结构向上走，并确保其父级也有宽度。其父级是`NavigationBar`中的`Column`元素。将`Column`的`width`属性设置为`parent.width`。
- en: With those changes in place, the navigation bar now behaves as expected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些改变，导航栏现在的行为符合预期。
- en: Commands
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: The next thing on our to-do list is to implement a context-sensitive command
    bar. While our navigation bar is a constant presence with the same buttons regardless
    of what the user is doing, the command bar will come and go and will contain different
    buttons depending on the context. For example, if the user is adding or editing
    a client, we will need a Save button to commit any changes to the database. However,
    if we are searching for a client, then saving makes no sense and a Findbutton
    is more relevant. While the techniques for creating our command bar are broadly
    similar to the navigation bar, the additional flexibility required poses more
    of a challenge.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们待办事项清单上的下一件事是实现一个上下文敏感的命令栏。虽然我们的导航栏是一个恒定的存在，无论用户在做什么，都有相同的按钮，但是命令栏会出现和消失，并且会根据上下文包含不同的按钮。例如，如果用户正在添加或编辑客户，我们将需要一个保存按钮来提交对数据库的任何更改。然而，如果我们正在搜索客户，那么保存就没有意义，而查找按钮更相关。虽然创建命令栏的技术与导航栏大致相似，但所需的额外灵活性提出了更大的挑战。
- en: To help us overcome these obstacles, we will implement commands. An additional
    benefit of this approach is that we get to move the logic out of the UI layer
    and into the business logic layer. I like the UI to be as dumb and as generic
    as possible. This makes your application more flexible, and bugs in C++ code are
    easier to identify and resolve than those in QML.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们克服这些障碍，我们将实现命令。这种方法的额外好处是，我们可以将逻辑从UI层移出，并移到业务逻辑层。我喜欢UI尽可能愚蠢和通用。这样可以使您的应用程序更加灵活，而且C++代码中的错误比QML中的错误更容易识别和解决。
- en: A command object will encapsulate an icon, descriptive text, a function to determine
    whether the button is enabled or not, and finally, an `executed()` signal that
    will be emitted when the related button is pressed. Each button in our command
    bar will then be bound to a command object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 命令对象将封装一个图标，描述性文本，一个用于确定按钮是否启用的函数，最后，一个在相关按钮被按下时将被发射的`executed()`信号。然后我们的命令栏中的每个按钮将绑定到一个命令对象上。
- en: Each of our child view may have a list of commands and an associated command
    bar. For the views that do, we will present the list of commands to the UI via
    a command controller.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个子视图可能都有一个命令列表和一个关联的命令栏。对于具有这些功能的视图，我们将通过命令控制器向UI呈现命令列表。
- en: 'Create two new `C++` classes in the `cm-lib` project, both of which should
    inherit from QObject:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-lib`项目中创建两个新的`C++`类，两者都应该继承自QObject：
- en: '**Command** in a new folder `cm-lib/source/framework`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在新文件夹`cm-lib/source/framework`中的命令**'
- en: '**Command Controller** in the existing folder `cm-lib/source/controllers`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有文件夹`cm-lib/source/controllers`中的命令控制器**'
- en: '`command.h`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`command.h`：'
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`command.cpp`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`command.cpp`：'
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The QObject, namespaces, and dll export code should be familiar by now. We represent
    the icon character and description values we want to display on the UI buttons
    as strings. We hide the member variables away in the private implementation and
    provide `accessor` methods for them. We could have represented the `canExecute`
    member as a simple `bool` member that calling code could set to `true` or `false`
    as required; however, a much more elegant solution is to pass in a method that
    calculates the value for us on the fly. By default, we set it to a lambda that
    returns `true`, which means that the button will be enabled. We provide a `canExecuteChanged()`
    signal to go along with this, which we can fire whenever we want the UI to reassess
    whether the button is enabled or not. The last element is the `executed()` signal
    that will be fired by the UI when the corresponding button is pressed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，QObject，命名空间和dll导出代码应该是熟悉的。我们将要在UI按钮上显示的图标字符和描述值表示为字符串。我们将成员变量隐藏在私有实现中，并为它们提供`访问器`方法。我们可以将`canExecute`成员表示为一个简单的`bool`成员，调用代码可以根据需要将其设置为`true`或`false`；然而，一个更加优雅的解决方案是传入一个方法，让它在运行时为我们计算值。默认情况下，我们将其设置为返回`true`的lambda，这意味着按钮将被启用。我们提供了一个`canExecuteChanged()`信号来配合使用，我们可以在需要UI重新评估按钮是否启用时触发它。最后一个元素是`executed()`信号，当相应的按钮被按下时将被UI触发。
- en: '`command-controller.h`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`command-controller.h`：'
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`command-controller.cpp`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`command-controller.cpp`：'
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we introduce a new type—`QQmlListProperty`. It is essentially a wrapper
    that enables QML to interact with a list of custom objects. Remember that we need
    to fully qualify the templated type in the `Q_PROPERTY` statements. The private
    member that actually holds the data is a QList, and we have implemented an `accessor`
    method that takes the QList and converts it into a `QQmlListProperty` of the same
    templated type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了一个新类型——`QQmlListProperty`。它本质上是一个包装器，使QML能够与自定义对象列表进行交互。请记住，我们需要在`Q_PROPERTY`语句中完全限定模板化类型。实际保存数据的私有成员是一个QList，并且我们已经实现了一个将QList取出并将其转换为相同模板化类型的`QQmlListProperty`的`访问器`方法。
- en: As per the documentation for `QQmlListProperty`, this method of object construction
    should not be used in production code, but we’ll use it to keep things simple.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`QQmlListProperty`的文档，这种对象构造方法不应该在生产代码中使用，但我们将使用它来保持简单。
- en: We have created a single command list for our `CreateClientView`. We’ll add
    command lists for other views later. Again, we’ll keep things simple for now;
    we just create a single command to save a newly created client. When creating
    the command, we parent it to the command coordinator so that we don’t have to
    worry about memory management. We assign it a floppy disk icon (unicode f0c7)
    and the Save label. We leave the `canExecute` function as the default for now
    so it will always be enabled. Next, we connect the `executed()` signal of the command
    to the `onCreateClientSaveExecuted()` slot of the `CommandController`. With the
    wiring done, we then add the command to the list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`CreateClientView`创建了一个单一的命令列表。稍后我们将为其他视图添加命令列表。同样，现在我们会保持简单；我们只创建一个用于保存新创建客户的命令。在创建命令时，我们将其父级设置为命令协调器，这样我们就不必担心内存管理。我们为其分配了一个软盘图标（unicode
    f0c7）和`Save`标签。我们暂时将`canExecute`函数保持为默认值，这样它将始终处于启用状态。接下来，我们将`command`的`executed()`信号连接到`CommandController`的`onCreateClientSaveExecuted()`槽。连接完成后，我们将命令添加到列表中。
- en: The intention is that we present the user with a command button bound to a `Command`
    object. When the user presses the button, we will fire the `executed()` signal
    from the UI. The connection we’ve set up will cause the slot on the command controller
    to be called, and we will execute our business logic. For now, we’ll simply print
    out a line to the console when the button is pressed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图是向用户呈现一个绑定到`Command`对象的命令按钮。当用户按下按钮时，我们将从UI触发`executed()`信号。我们设置的连接将导致命令控制器上的槽被调用，然后我们将执行我们的业务逻辑。现在，当按钮被按下时，我们将简单地在控制台上打印一行。
- en: 'Next, let’s register both of our new types in `main.cpp` (remember the `#includes`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`main.cpp`中注册我们的两种新类型（记住`#includes`）：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we need to add the `CommandCoordinator` property to `MasterController`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`CommandCoordinator`属性添加到`MasterController`中：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we add an `accessor` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`accessor`方法：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, in `master-controller.cpp`, instantiate the object in the private implementation
    and implement the `accessor` method in exactly the same way as we did for `NavigationController`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`master-controller.cpp`中，实例化私有实现中的对象，并以与我们为`NavigationController`做的方式完全相同的方式实现`accessor`方法。
- en: We now have a (very short!) list of commands ready for our `CreateClientView`
    to consume.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为我们的`CreateClientView`准备好了一个（非常简短的！）命令列表。
- en: Command bar
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令栏
- en: 'Let’s begin by adding some more properties to Style for our command components:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为我们的命令组件的样式添加一些属性：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, create two new QML components in our UI project: `CommandBar.qml` and
    `CommandButton.qml` in `cm-ui/components`. Update `components.qrc` and move the
    new components into the `/components` prefix with aliases. Edit `qmldir` and append
    the new components:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的UI项目中创建两个新的QML组件：在`cm-ui/components`中创建`CommandBar.qml`和`CommandButton.qml`。更新`components.qrc`并将新组件移动到带有别名的`/components`前缀中。编辑`qmldir`并追加新组件：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For our button design, we want to lay out the description below the icon. The
    icon should be positioned slightly above centre. The component should be square,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的按钮设计，我们希望在图标下方布置描述。图标应该略微位于中心位置之上。组件应该是正方形的，如下所示：
- en: '![](img/1bf95587-1026-463f-91b3-cfb511bdf1c2.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bf95587-1026-463f-91b3-cfb511bdf1c2.png)'
- en: '`CommandButton.qml`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandButton.qml`：'
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is largely similar to our `NavigationButton` component. We pass in a `Command`
    object, which is where we will obtain the icon character and description to display
    in the **Text** elements as well as the signal to emit when the button is pressed,
    so long as the command can execute.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的`NavigationButton`组件非常相似。我们传入一个`Command`对象，从中我们将获取图标字符和描述以显示在**Text**元素中，以及在按钮被按下时发出的信号，只要命令可以执行。
- en: We use an alternative to the **Row/Column** based layout and use anchors to
    position our icon and description instead. We center the icon in the parent `Rectangle`
    and then apply a vertical offset to move it up and allow space for the description.
    We anchor the top of the description to the bottom of the icon.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一种替代**Row/Column**布局的方法，并使用锚点来定位我们的图标和描述。我们将图标居中放置在父`Rectangle`中，然后应用垂直偏移将其向上移动，以便为描述留出空间。我们将描述的顶部锚定到图标的底部。
- en: Rather than propagating a signal when the button is pressed, we emit the `executed()`
    signal of the `Command` object, first verifying that the command can execute.
    We also use this flag to selectively color our text elements, using a paler grey
    font if the command is disabled.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在按钮被按下时传播信号，而是首先验证命令是否可以执行，然后发出`Command`对象的`executed()`信号。我们还使用这个标志有选择地为我们的文本元素着色，如果命令被禁用，我们使用较浅的灰色字体。
- en: We implement some more hover functionality with our `MouseArea`, but rather
    than exposing a property to pass in the hover color, we simply take the default
    and darken it a few shades using the built-in `Qt.darker()` method. We also only
    apply the state change in the `onEntered()` slot of the `MouseArea` if the command
    can be executed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`MouseArea`实现了一些更多的悬停功能，但我们不是暴露一个属性来传递悬停颜色，而是使用内置的`Qt.darker()`方法将默认颜色变暗几个色调。如果命令可以执行，我们也只在`MouseArea`的`onEntered()`槽中应用状态更改。
- en: '`CommandBar.qml`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandBar.qml`：'
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Again, this is largely the same as `NavigationBar`, but with a dynamic list
    of commands rather than hard-coded QML buttons. We introduce another new component—the
    `Repeater`. Given a list of objects via the `model` property, `Repeater` will
    instantiate a QML component defined in the `delegate` property for each item in
    the list. The object from the list is made available via the built-in `modelData`
    variable. Using this mechanism, we can automatically generate a `CommandButton`
    element for each command we have in a given list. We use another property alias
    so that the caller can set the command list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与`NavigationBar`相同，但是使用动态命令列表而不是硬编码的QML按钮。我们引入了另一个新组件——`Repeater`。通过`model`属性提供的对象列表，`Repeater`将为列表中的每个项目实例化在`delegate`属性中定义的QML组件。列表中的对象可通过内置的`modelData`变量获得。使用这种机制，我们可以为给定列表中的每个命令自动生成一个`CommandButton`元素。我们使用另一个属性别名，以便调用者可以设置命令列表。
- en: 'Let’s put this to use in `CreateClientView`. First, `import components 1.0`,
    and then add the following inside the root `Item` and after the `Rectangle`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`CreateClientView`中使用它。首先，`import components 1.0`，然后在根`Item`内以及`Rectangle`之后添加以下内容：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We drill down through our property hierarchy to get the command list for the
    create client view and pass that list to the command bar which takes care of the
    rest. Don’t worry if the `CommandBar` has red squiggles, Qt Creator just needs
    to catch up with our blistering pace.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过属性层次结构深入到创建客户端视图的命令列表，并将该列表传递给负责处理其余部分的命令栏。如果`CommandBar`有红色波浪线，不要担心，Qt
    Creator只是需要跟上我们的快速步伐。
- en: 'Run the app and navigate to Create Client View:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并导航到创建客户端视图：
- en: '![](img/093cca1f-f222-4039-a734-70488a159adc.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/093cca1f-f222-4039-a734-70488a159adc.png)'
- en: Click on the button, and you will see the message output to the console. Adding
    new commands is as simple as appending a new `Command` object to the QList inside
    `CommandController`—no UI changes needed! The command bar will automatically create
    a new button for every command it finds in the list. Also note that this command
    bar is only present on the `CreateClientView`, so it is context sensitive. We
    can easily add command bars to other views by simply adding extra lists and properties
    to the `CommandController`, as we will later.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮，您将看到消息输出到控制台。添加新命令就像将新的`Command`对象附加到`CommandController`内的QList一样简单——不需要UI更改！命令栏将自动为列表中找到的每个命令创建一个新按钮。还要注意，此命令栏仅出现在`CreateClientView`上，因此它是上下文敏感的。我们可以通过简单地向`CommandController`添加额外的列表和属性来轻松地将命令栏添加到其他视图中，就像我们稍后将要做的那样。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gave the navigation bar a much needed overhaul. We added
    our first few components and leveraged our new custom style object, with Font
    Awesome providing some lovely scalable graphics for us. We also introduced commands
    and have the framework in place to be able to add context-sensitive command buttons
    to our views.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对导航栏进行了急需的改进。我们添加了我们的前几个组件，并利用了我们的新自定义样式对象，Font Awesome为我们提供了一些可爱的可伸缩图形。我们还引入了命令，并且已经准备好能够向我们的视图添加上下文敏感的命令按钮。
- en: In [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we’ll get
    stuck into the business logic layer and flesh out our first data models.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml) *数据*中，我们将深入研究业务逻辑层，并完善我们的第一个数据模型。
