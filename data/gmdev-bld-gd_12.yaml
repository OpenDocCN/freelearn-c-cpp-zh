- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Interacting with the World through Camera and Character Controllers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过相机和角色控制器与世界交互
- en: You have been preparing little bits and pieces for the game world, especially
    in the last two chapters. In [*Chapter 10*](B17473_10.xhtml#_idTextAnchor165),
    *Making Things Look Better with Lights and Shadows*, you added **Light** objects
    to sconces and candles. You even placed a script to adjust these objects’ lit
    state. Then, in [*Chapter 11*](B17473_11.xhtml#_idTextAnchor186), *Creating the
    User Interface*, you built a new scene by introducing **Control** nodes. This
    effort was for simulating a note from Clara’s uncle, Bert.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在为游戏世界准备一些零散的东西，尤其是在前两章中。在[*第10章*](B17473_10.xhtml#_idTextAnchor165) *使用光影使事物看起来更好*中，你向烛台和蜡烛添加了**灯光**对象。你甚至放置了一个脚本以调整这些对象的点亮状态。然后，在[*第11章*](B17473_11.xhtml#_idTextAnchor186)
    *创建用户界面*中，你通过引入**控制**节点创建了一个新的场景。这项工作是为了模拟克拉拉叔叔伯特的一张便条。
- en: Although we’ve been taking steps to make things more sophisticated, pretty much
    everything feels static. In this chapter, we’ll show you a collection of practices
    that will build a connection between game objects and the player. This will make
    the project look live and feel more like a game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们一直在努力使事物更加复杂，但几乎一切感觉都是静态的。在本章中，我们将向您展示一系列实践，这些实践将建立游戏对象和玩家之间的连接。这将使项目看起来更加生动，感觉更像是一款游戏。
- en: The first thing we’ll look at is the **Camera** node and its settings. Godot’s
    viewport has been letting you see different scenes via a temporary construct so
    that you could work with the software. Such a transitory concept won’t be enough,
    so we’ll work with our camera system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨的是**相机**节点及其设置。Godot的视口一直允许你通过一个临时的结构来查看不同的场景，以便你可以使用该软件。这样的临时概念是不够的，因此我们将使用我们的相机系统。
- en: Next, we’ll focus on building a connection between some of the game objects
    in the world and the player. This involves detecting mouse events on a 2D surface
    and projecting these events into a 3D space. There might be different interactions
    such as hovering, clicking, pressing, and likewise, so we’ll look into ways to
    detect the action we want. For example, we will click a parchment left on the
    pier to bring up the note we worked on in the previous chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于在世界上的一些游戏对象和玩家之间建立连接。这涉及到在2D表面上检测鼠标事件并将这些事件投影到3D空间中。可能会有不同的交互，如悬停、点击、按下等，因此我们将探讨检测我们想要执行的动作的方法。例如，我们将点击留在码头上的羊皮纸，以调出我们在上一章中工作的便条。
- en: Similarly, if the click happens to be on one of the areas where we would want
    to move Clara, we need a system that can do the pathfinding for us. To that end,
    we’ll investigate new Godot nodes, **Navigation** and **NavigationMeshInstance**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果点击发生在我们希望移动克拉拉的区域之一，我们需要一个能够为我们进行路径查找的系统。为此，我们将研究新的Godot节点，**导航**和**导航网格实例**。
- en: Lastly, why not add a bit of animation? After we discover how to move a game
    object between two points in the world, we could instruct this object to trigger
    the appropriate animation cycle. In our case, Clara will switch between her idle
    state to her walking state. As a result, we’ll revisit some of the notions we
    got to know in the *Importing animations* section of [*Chapter 7*](B17473_07.xhtml#_idTextAnchor112),
    *Importing Blender Assets into Godot*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为什么不添加一点动画呢？在我们发现如何在世界中的两个点之间移动游戏对象之后，我们可以指示该对象触发适当的动画循环。在我们的例子中，克拉拉将在她的空闲状态和行走状态之间切换。因此，我们将回顾在[*第7章*](B17473_07.xhtml#_idTextAnchor112)
    *将Blender资产导入Godot*的*导入动画*部分中了解的一些概念。
- en: 'As you can see, we are going to utilize a lot of the topics we have already
    visited, yet there is still a lot of new stuff to discover and learn. If we could
    enumerate it, it would look like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将利用我们已经探讨过的许多主题，但仍有许多新内容等待我们去发现和学习。如果我们能将其列举出来，它将看起来像这样：
- en: Understanding the camera system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解相机系统
- en: Detecting user input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测用户输入
- en: Moving the player around
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动玩家
- en: Triggering animations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发动画
- en: By the end of this chapter, you’ll have a much better understanding of camera
    settings in general, and you’ll be able to detect your player’s intentions and
    relate them to actions in the game. Thanks to an easy method of pathfinding, you’ll
    move Clara around the level to a location you want, and—finally—trigger the appropriate
    action to simulate her walking.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将对相机设置有更深入的理解，你将能够检测玩家的意图并将它们与游戏中的动作联系起来。多亏了路径查找的简便方法，你将能够将克拉拉移动到你想去的地点，并最终触发适当的动作来模拟她行走。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We’ll continue where we left off in the previous chapter. This means you can
    keep working on your existing copy. Alternatively, you can start with the `Finish`
    folder of `Chapter 12` in this book’s GitHub repo: [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在上一章结束的地方继续。这意味着你可以继续工作在你现有的副本上。或者，你也可以从本书GitHub仓库中的`Chapter 12`的`Finish`文件夹开始：[https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot)。
- en: We have several new assets that are necessary to do the work in this chapter.
    These assets are in the `Resources` folder next to the `Finish` folder. As usual,
    merge these with your project files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个在本章工作中必需的新资产。这些资产位于`Finish`文件夹旁边的`Resources`文件夹中。像往常一样，将它们与你的项目文件合并。
- en: Understanding the camera system
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解相机系统
- en: In [*Chapter 4*](B17473_04.xhtml#_idTextAnchor060), *Adjusting Cameras and Lights*,
    we briefly touched on the concept of a camera in Blender. We learned that we couldn’t
    render a scene without one. Although we took a render in the end by introducing
    a camera, we never talked about the different settings a camera can have. That
    was done intentionally because the know-how we would attain in Blender would not
    directly transfer to Godot. Fortunately, now is the right time to study in detail
    what a camera can do for enhancing the gameplay experience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17473_04.xhtml#_idTextAnchor060)，*调整相机和灯光*中，我们简要介绍了Blender中相机的概念。我们了解到没有相机就无法渲染场景。尽管我们最终通过引入相机进行了渲染，但我们从未谈论过相机可以拥有的不同设置。这是故意为之，因为我们将在Blender中获得的知识不会直接转移到Godot上。幸运的是，现在是深入研究相机如何增强游戏体验的最佳时机。
- en: Not only are we going to get to know how to set up a camera that suits our game,
    but we are also going to discover different types of cameras Godot has in its
    inventory. As usual, or as it is something you might hear as a joke on internet
    forums and memes, there must be a node for this type of thing in Godot.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将了解如何设置适合我们游戏的相机，还将发现Godot库存中不同类型的相机。像往常一样，或者就像你可能在互联网论坛和梗图上听到的笑话一样，Godot中肯定有一个节点用于此类事物。
- en: 'Yes, there is. In fact, there are four camera nodes, as outlined here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有。事实上，正如这里概述的那样，有四个相机节点：
- en: '**Camera**: This is the core class that serves as the base for all the other
    camera types. Even though you can have multiple **Camera** nodes in your scene,
    there can only be one active camera. And, similar to Blender, no camera means
    nothing to see here.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**: 这是作为所有其他相机类型基础的核心类。尽管你可以在场景中拥有多个**相机**节点，但只能有一个活动相机。而且，类似于Blender，没有相机在这里就什么也看不到。'
- en: '**InterpolatedCamera**: This is an enhanced version of the **Camera** node.
    It comes with three extra properties that turn a regular **Camera** node into
    a mechanism that tracks and follows a target. It’s quite handy if you are developing
    a game with an over-the-shoulder camera look. If the game character is the target,
    when the target moves, the camera will catch up.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插值相机**: 这是**相机**节点的增强版本。它增加了三个额外属性，将一个普通的**相机**节点转变为一个跟踪和跟随目标的机制。如果你正在开发一个肩上视角的游戏，这会非常方便。如果游戏角色是目标，当目标移动时，相机会跟上。'
- en: Unfortunately, this node will be removed in Godot 4\. Luckily, it’s not difficult
    to recreate its functionality by attaching a short script to a **Camera** node.
    In other words, if you remove the fancy bits of an **InterpolatedCamera** node,
    you get the **Camera** node, hence the decision to drop it in future versions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个节点将在Godot 4中删除。幸运的是，通过将一个简短的脚本附加到一个**相机**节点上，可以轻松地重新创建其功能。换句话说，如果你移除了**插值相机**节点的花哨部分，你得到的就是**相机**节点，这就是为什么决定在未来版本中删除它的原因。
- en: '**ClippedCamera**: This is another type of special **Camera** node, and fortunately,
    it will be kept in Godot 4 since it’s an advanced camera system. Our game is currently
    not using **PhysicsBody** nodes that are responsible for determining which objects
    can pass through each other or bump and bounce back when the bodies in motion
    connect with a colliding surface. For that reason, we won’t investigate this type
    of camera, but you might want to check this one out if you don’t want your cameras
    to travel through walls. It will behave like an object respecting physics rules.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClippedCamera**：这是另一种特殊的**Camera**节点，幸运的是，它将被保留在Godot 4中，因为它是一个高级相机系统。我们的游戏目前没有使用负责确定哪些对象可以相互穿过或在运动体与碰撞表面接触时弹跳回的**PhysicsBody**节点。因此，我们不会调查这种类型的相机，但如果你不希望你的相机穿过墙壁，你可能想检查一下这个。它将像遵守物理规则的对象一样表现。'
- en: '**ARVRCamera**: You might have guessed it: this is used for **virtual reality**
    (**VR**) projects. It isn’t something you’d utilize as a standalone node since
    it depends on a lot of other nodes that have **augmented reality/virtual reality**
    (**ARVR**) at the beginning of their names. Building a VR project is an advanced
    topic that deserves probably a whole book dedicated to the subject. For that reason,
    we’ll skip this node too.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARVRCamera**：你可能已经猜到了：这是用于**虚拟现实**（**VR**）项目的。由于它依赖于很多以**增强现实/虚拟现实**（**ARVR**）开头的其他节点，所以它不是一个作为独立节点使用的工具。构建VR项目是一个高级话题，可能需要一本专门介绍这个主题的书。因此，我们也会跳过这个节点。'
- en: Besides the camera nodes for 3D workflows, there is also the **Camera2D** node
    that is used in 2D projects. Thus, there are five types of cameras in total.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于3D工作流程的相机节点外，还有用于2D项目的**Camera2D**节点。因此，总共有五种类型的相机。
- en: Out of all these types we presented, the most promising candidate is the **InterpolatedCamera**
    node. Why? Because an **InterpolatedCamera** node is essentially a **Camera**
    node with extra pizazz such as target and track functionality. So, in your Godot
    3 projects, you can start with **InterpolatedCamera** and treat it like a **Camera**
    node until you need that extra functionality.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示的所有这些类型中，最有希望的候选者是**InterpolatedCamera**节点。为什么？因为**InterpolatedCamera**节点本质上是一个带有额外功能，如目标和跟踪功能的**Camera**节点。所以，在你的Godot
    3项目中，你可以从**InterpolatedCamera**开始，将其视为一个**Camera**节点，直到你需要那些额外功能。
- en: Since we are continuing our work from the previous chapter, it makes sense to
    tidy up some loose ends. Let’s start with that first, then we can move on to introducing
    camera settings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在继续上一章的工作，整理一些松散的尾巴是有意义的。让我们先从这一点开始，然后我们可以继续介绍相机设置。
- en: Tidying things up for interactivity
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整理交互性相关的事宜
- en: 'The last thing we did in the `UI.tscn` scene was skinning UI components. During
    that effort, we had already turned off the visibility of the **Panel** node that
    was responsible for displaying the note from Clara’s uncle. Then, we introduced
    a series of UI nodes, all grouped under an **HBoxContainer** node. We’ll turn
    that container off too, but let’s run the project first by pressing *F5*. You
    might see something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UI.tscn`场景中我们最后做的是对UI组件进行皮肤化。在这个过程中，我们已经关闭了负责显示克拉拉的叔叔笔记的**Panel**节点的可见性。然后，我们引入了一系列UI节点，所有这些节点都归在一个**HBoxContainer**节点下。我们也会关闭这个容器，但首先让我们通过按*F5*来运行项目。你可能会看到类似这样的内容：
- en: '![Figure 12.1 – The first run of our game ](img/Figure_12.1_17473.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 我们游戏的第一运行](img/Figure_12.1_17473.jpg)'
- en: Figure 12.1 – The first run of our game
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 我们游戏的第一运行
- en: The UI decisions we have made are visible in the top-left corner of the game.
    We don’t need those for the moment. So, bring up the `UI.tscn` if you have it
    closed, turn off the **HBoxContainer** node, and run the game again. We’ll look
    into some UI concerns in the *Detecting user input* section soon.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出的UI决策在游戏的右上角是可见的。目前我们不需要这些。所以，如果你已经关闭了`UI.tscn`，请打开它，关闭**HBoxContainer**节点，再次运行游戏。我们将在*检测用户输入*部分很快探讨一些UI问题。
- en: Perhaps you’ve already noticed from the screenshots we have used in previous
    chapters or simply by looking at the project files that there has already been
    a `Game.tscn` scene configured as the main scene for the project. That’s why Godot
    did not ask you to pick the main scene when you pressed *F5* since we had already
    assigned one to the project for you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经从我们在前几章中使用的截图或者简单地通过查看项目文件中注意到，已经有一个`Game.tscn`场景被配置为项目的默认场景。这就是为什么当你按下*F5*时，Godot没有要求你选择主场景，因为我们已经为你分配了一个。
- en: Open `Game.tscn`, and let’s see how this scene is structured. Everything might
    look self-evident, but there is the root node labeled as `Game.tscn`. The other
    node, **Camera**, will be our main study area in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Game.tscn`，让我们看看这个场景是如何构建的。一切可能看起来都很明显，但有一个标记为 `Game.tscn` 的根节点。另一个节点，**Camera**，将是本章的主要研究区域。
- en: We’ll split the rest of our efforts in understanding how cameras work mainly
    into two distinct areas. The most important topic is the projection type, which
    fundamentally changes the whole experience. We suggest this be something you decide
    early on in your own projects since any other tweaking can be done after this
    choice has been made. So, before we tackle individual camera settings, let’s see
    what kinds of projections there are.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把剩余的努力主要分为两个不同的领域来理解相机的工作原理。最重要的主题是投影类型，这从根本上改变了整个体验。我们建议你在自己的项目中尽早决定这一点，因为在此选择之后，任何其他调整都可以进行。因此，在我们处理单个相机设置之前，让我们看看有哪些类型的投影。
- en: Deciding on a type of projection
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定投影类型
- en: 'If you took an art class on learning how to draw architecture, this might be
    a topic you are already familiar with. The Godot version we are using comes with
    three types of projections. Although we will mainly focus on the first two, we’ll
    give a brief definition of all projection types, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上过学习如何绘制建筑的美术课程，这可能是一个你已经熟悉的主题。我们使用的 Godot 版本提供了三种类型的投影。尽管我们将主要关注前两种，但我们会简要定义所有投影类型，如下所示：
- en: '**Perspective**: This is the default camera projection where the farther objects
    are from the camera, the smaller they will look. Hence, two objects of the exact
    same dimensions will look like they are differently sized when one of these objects
    is placed away from the camera. This is also how human beings perceive the world,
    so if you don’t, get a check-up.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透视**：这是默认的相机投影，其中距离相机越远的物体看起来越小。因此，两个尺寸完全相同的物体，当其中一个物体放置在远离相机的地方时，看起来就像它们的大小不同。这也是人类感知世界的方式，所以如果你不这样，可能需要检查一下。'
- en: '**Orthogonal**: Also known as **Orthographic**, this type of projection renders
    objects of the same dimensions without altering their size, regardless of the
    distance to the camera. This type could give your game the dramatic look it needs.
    Also, there are some types of games—roleplaying (*Fallout* series) and **Explore,
    Expand, Exploit, Exterminate** (**4X**) (*Civilization*)—where this kind of projection
    is preferred.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正交**：也称为 **正交投影**，这种投影方式在不改变物体大小的情况下渲染相同尺寸的物体，无论其距离相机有多远。这种投影类型可以为你的游戏带来所需的戏剧性外观。此外，还有一些类型的游戏——角色扮演（*Fallout*
    系列）和 **探索、扩张、开发、灭绝**（**4X**）（*文明*）——更倾向于使用这种投影。'
- en: '**Frustum**: This is a relatively new type of projection that has its uses
    in some types of games—for example, to get that 2.5D look some old-school games
    used to have where the visuals looked stretched. If you want to know more, [https://zdoom.org/wiki/Y-shearing](https://zdoom.org/wiki/Y-shearing)
    has some information about this topic.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视锥体**：这是一种相对较新的投影类型，在某些类型的游戏中有其用途——例如，为了获得一些老式游戏曾经使用的 2.5D 外观，其中视觉效果看起来被拉伸。如果你想了解更多信息，[https://zdoom.org/wiki/Y-shearing](https://zdoom.org/wiki/Y-shearing)
    有一些关于这个主题的信息。'
- en: 'In most cases, the first two projections we listed here will be enough. Maybe
    it would be better if we investigated their differences by experimenting. Since
    we’ve already seen the **Perspective** projection type, it makes sense to try
    the **Orthogonal** projection type, so follow these next steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们列出的前两种投影就足够了。也许通过实验来调查它们之间的差异会更好。因为我们已经看到了 **透视** 投影类型，所以尝试 **正交**
    投影类型是有意义的，所以请按照以下步骤进行：
- en: Select the `Game.tscn` scene.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Game.tscn` 场景。
- en: Change its `6`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 `6` 改变。
- en: Press *F5* to run the game and notice a different artistic style.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F5* 运行游戏，并注意其不同的艺术风格。
- en: 'After we make these changes, this is what we have:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做出这些更改后，这就是我们得到的结果：
- en: '![Figure 12.2 – Orthographic camera view from the same location ](img/Figure_12.2_17473.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 从同一位置的正交相机视图](img/Figure_12.2_17473.jpg)'
- en: Figure 12.2 – Orthographic camera view from the same location
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 从同一位置的正交相机视图
- en: We picked a `12`. Most PC monitors, however, follow a landscape orientation.
    That’s why **Keep Height** is the default option, but if you are working on a
    mobile game, you might want to mix and match the correct **Size** value with the
    **Keep Width** option selected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了`12`。然而，大多数PC显示器都遵循横向布局。这就是为什么**保持高度**是默认选项，但如果你正在制作移动游戏，你可能想将正确的**大小**值与选中的**保持宽度**选项混合使用。
- en: Camera-specific environment
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相机特定环境
- en: While we are looking at different properties of the **Camera** node in the **Inspector**
    panel, now might be a good time to get a refresher on the **Environment** topic.
    In the *Creating post-processing effects* section of [*Chapter 10*](B17473_10.xhtml#_idTextAnchor165),
    *Making Things Look Better with Lights and Shadows*, we discovered how to create
    an environment that changed the look of the level. If you want to override some
    of the environment settings, you can do so by assigning a separate **Environment**
    object to the camera. The effects of both the level-wide and camera-specific environments
    will be combined.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在**检查器**面板中查看**相机**节点的不同属性时，现在可能是复习**环境**主题的好时机。在[*第10章*](B17473_10.xhtml#_idTextAnchor165)的*创建后处理效果*部分，*用光和阴影使事物看起来更好*，我们发现了如何创建一个改变关卡外观的环境。如果你想覆盖一些环境设置，你可以通过为相机分配一个单独的**环境**对象来实现。全局和相机特定环境的效应将会结合。
- en: No matter which values you pick for the right platform, one thing is obvious.
    Even though we didn’t move the camera’s position and rotation in the world, the
    effect we get is utterly different. Whereas we used to see the door in the back
    of the cave in the **Perspective** projection as depicted in *Figure 12.1*, the
    **Orthographic** view doesn’t permit us to see that far, as seen in *Figure 12.2*.
    When you compare both screenshots, the near elements are pretty much the same,
    but the **Orthographic** view simulates a more top-down look to the scene than
    looking far ahead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你为哪个平台选择什么值，有一点是明显的。尽管我们没有在世界上移动相机的位置和旋转，但我们得到的效果却完全不同。而我们在*图12.1*中看到的后面的洞穴门在**透视**投影中，**正交**视图不允许我们看得那么远，如*图12.2*所示。当你比较这两个截图时，近处的元素几乎相同，但**正交**视图模拟了一个比向前看更顶部的视角。
- en: 'Altering stuff in the **Inspector** panel and hitting *F5* to see your changes
    in effect might get tiring quickly. While the **Camera** node is still selected,
    if you turn on the **Preview** checkbox, as seen in the following screenshot,
    you can speed up your workflow when you are editing your camera’s attributes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**面板中更改内容并按*F5*键查看你的更改效果可能会很快感到疲倦。当**相机**节点仍然被选中时，如果你打开**预览**复选框，如以下截图所示，你可以在编辑相机属性时加快你的工作流程：
- en: '![Figure 12.3 – Previewing what your camera sees is handy, and it’s one checkbox
    away ](img/Figure_12.3_17473.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 预览相机所看到的内容很方便，只需一个复选框即可](img/Figure_12.3_17473.jpg)'
- en: Figure 12.3 – Previewing what your camera sees is handy, and it’s one checkbox
    away
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 预览相机所看到的内容很方便，只需一个复选框即可
- en: This will let you preview what your camera is seeing while you are still adjusting
    its settings. Mind you, during preview, you cannot move around your scene freely.
    In fact, you can’t even select objects. So, remember to turn it off when you want
    to go back to editing your scene.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让你在调整相机设置的同时预览相机所看到的内容。请注意，在预览期间，你无法自由地在场景中移动。实际上，你甚至无法选择对象。所以，当你想回到编辑场景时，记得将其关闭。
- en: In light of what we have presented so far, what kind of projection type should
    we choose? We’re going to go with the **Perspective** mode. So, for now, revert
    your **Camera** node’s **Projection** setting to its default value. Since Godot
    decorates the **Inspector** panel with the relevant properties, the **Size** property
    will be replaced with the **Fov** property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止所展示的内容，我们应该选择哪种投影类型？我们将选择**透视**模式。因此，现在，将你的**相机**节点的**投影**设置恢复到默认值。由于Godot用相关属性装饰了**检查器**面板，**大小**属性将被**Fov**属性取代。
- en: Let’s focus on this new property and some of the other changes we want to apply
    to the **Camera** node in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于这个新属性以及我们想要应用到**相机**节点上的其他一些更改，在下一节中。
- en: Adjusting the camera settings for our game
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整游戏中的相机设置
- en: In this section, we are going to discuss a new term you have just been introduced
    to, **Fov**, and show which other settings we should apply to the camera. If you
    have been working on your own level design since the beginning, then the position
    and rotation of the camera we mention here will be meaningless. That’s why we’ll
    give you general directions to convey the spirit of the exercise. Also, hopefully,
    the screenshots you’ll see will help you align our level’s conditions to yours
    better.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论你刚刚接触到的这个新术语**Fov**，并展示我们应该应用到相机上的其他设置。如果你从开始就在制作自己的关卡设计，那么我们提到的相机位置和旋转将毫无意义。这就是为什么我们会给你一些一般性的指导，以传达练习的精神。同时，希望你看到的截图能帮助你更好地将我们的关卡条件与你的条件对齐。
- en: First, a quick definition of the new term. **Field of view** (**fov**) is the
    angle, measured in degrees, through which a device perceives the world. Actually,
    if you consider your eyes as the device, your eyes also have a fov value. This
    is a highly technical domain, so we’ll offer you a few links in the *Further reading*
    section to discover it on your own.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们快速定义一下这个新术语。**视场角**（**fov**）是以度为单位测量的设备感知世界的角度。实际上，如果你把你的眼睛当作设备，你的眼睛也有一个fov值。这是一个高度技术性的领域，所以我们将在**进一步阅读**部分提供一些链接，让你自己探索。
- en: For the time being, we’re much more interested in the practical applications
    of this subject since it’s pertinent to whether your game is running in portrait
    or landscape mode, or whether the game is for PC or consoles. The default value,
    **70**, that Godot uses is a decent average value that will suit most cases. However,
    this default value also assumes you are going to run your game in landscape mode
    as it’s dictated by the **Keep Aspect** property, which is set to **Keep Height**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们对这个主题的实用应用更感兴趣，因为它与你游戏的横竖屏模式或游戏是为PC还是游戏机而设计的相关。Godot使用的默认值**70**是一个相当合理的平均值，适用于大多数情况。然而，这个默认值也假设你将以横屏模式运行你的游戏，因为它由**保持宽高比**属性决定，该属性设置为**保持高度**。
- en: Since players might have different monitor sizes and resolutions, the application
    has to pick either the height or the width as the **source of truth** (**SOT**)
    and then apply the other necessary transformations accordingly for the sake of
    not distorting the visuals. Sometimes, this practice will yield a result such
    as having a black band above and below the visuals. This method, known as **letterboxing**,
    is also used in the cinema industry for converting movies shot with a squarer
    aspect ratio to modern wider (from 4:3 to 16:9 or 16:10 ratio) screens.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家可能拥有不同尺寸和分辨率的显示器，应用程序必须选择高度或宽度作为**真实来源**（**SOT**）并相应地应用其他必要的转换，以避免视觉扭曲。有时，这种做法会导致在视觉上方和下方出现黑色条带。这种方法被称为**信箱模式**，在电影行业中也被用来将具有方形宽高比的电影转换为现代更宽的屏幕（从4:3到16:9或16:10的比率）。
- en: 'If you hover over the **Fov** property in the **Inspector** panel and read
    the tooltip, you’ll see that there are multiple values you can set for this property
    depending on the aspect ratio your game will use. Thus, we’ll let you choose the
    best value for your condition. Nevertheless, we’re providing the following screenshot
    to demonstrate the permutations of different **Keep Aspect** and **Fov** values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在**检查器**面板中的**Fov**属性上并阅读工具提示，你会看到你可以根据游戏将使用的宽高比设置多个值。因此，我们将让你选择最适合你条件的最优值。不过，我们提供了以下截图来展示不同**保持宽高比**和**Fov**值的排列组合：
- en: '![Figure 12.4 – Same camera position with different aspect-ratio constraints
    and fov values ](img/Figure_12.4_17473.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 相机位置相同，不同宽高比约束和fov值](img/Figure_12.4_17473.jpg)'
- en: Figure 12.4 – Same camera position with different aspect-ratio constraints and
    fov values
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 相机位置相同，不同宽高比约束和fov值
- en: What a big difference! Without changing a single thing for the camera, different
    permutations will yield lots of distinct results. Let’s wrap up the **Fov** topic
    by discussing what higher and lower values for **Fov** means so that you can make
    better decisions in your own projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 差异真是太大了！在不改变相机设置的情况下，不同的排列组合会产生大量不同的结果。让我们通过讨论**Fov**（视场角）的更高和更低值来结束**Fov**这个话题，以便你在自己的项目中做出更好的决策。
- en: At the end of the day, the **Fov** value you should pick will depend on the
    player’s viewing distance, which isn’t something you can really know ahead of
    time. However, there are conventions you can follow. For example, console games
    use a lower **Fov** value since it provides a zoomed-in-like view that compensates
    for the distance between the screen and the player. Most typically, a console
    game player will be sitting on a couch a few meters away from a screen that is
    usually large.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该选择的**Fov**值将取决于玩家的观看距离，这并不是你事先就能真正了解的事情。然而，你可以遵循一些惯例。例如，控制台游戏使用较低的**Fov**值，因为它提供了一个类似缩放的视图，以补偿屏幕和玩家之间的距离。通常，控制台游戏玩家会坐在距离屏幕几米远的沙发上，而屏幕通常很大。
- en: On the other hand, a PC player is usually less than one meter away from a monitor,
    thus it might be better to use higher **Fov** values. This increases immersion
    since players feel they get to see more of the world by virtue of having this
    view a bit zoomed out compared to lower **Fov** values. That being said, it’s
    known that really high **Fov** values also create motion sickness. When your brain
    is forced to process too much of the world, you get that churning stomach feeling,
    especially in **first-person shooter** (**FPS**) games.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，PC玩家通常距离显示器不到一米，因此可能最好使用更高的**Fov**值。这增加了沉浸感，因为玩家会感觉到通过这种稍微缩小的视角，他们能够看到更多的世界。然而，众所周知，过高的**Fov**值也会造成晕动症。当你的大脑被迫处理过多的世界信息时，你会感到胃部不适，尤其是在**第一人称射击**（**FPS**）游戏中。
- en: Fov calculator
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Fov计算器
- en: 'There is a handy calculator for finding ideal **Fov** values: [https://themetalmuncher.github.io/fov-calc/](https://themetalmuncher.github.io/fov-calc/).
    Select the aspect ratio and orientation of your screen, and the calculator will
    eliminate some of the guesswork. Obviously, if you let your players change their
    screen resolution in the game’s settings, you’ve got to programmatically update
    the **Fov** value the game uses.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方便的计算器可以帮助找到理想的**Fov**值：[https://themetalmuncher.github.io/fov-calc/](https://themetalmuncher.github.io/fov-calc/)。选择你的屏幕的宽高比和方向，计算器将消除一些猜测。显然，如果你允许玩家在游戏设置中更改屏幕分辨率，你必须通过编程更新游戏使用的**Fov**值。
- en: 'To finish off this section, we’ll stick with the value of `97` for **Fov**
    and choose **Keep Width** for the aspect ratio since it works out better artistically.
    Also, since this level is so small, having the camera follow the game character
    won’t be necessary. Still, we could try to pick the best angle and position of
    the **Camera** node to see most of the scene. As already mentioned, our values
    won’t mean much. However, try to change the **Translation** and **Rotation Degrees**
    values for the **Camera** node to match what you see here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本节内容，我们将保持**Fov**的值为`97`，并选择**Keep Width**作为画面的宽高比，因为这从艺术角度来看效果更好。此外，由于这个级别非常小，因此不需要让摄像机跟随游戏角色。不过，我们仍然可以尝试选择**Camera**节点的最佳角度和位置，以便看到大部分场景。正如之前提到的，我们的值并不会意味着太多。然而，尝试更改**Camera**节点的**Translation**和**Rotation
    Degrees**值，以匹配这里所看到的：
- en: '![Figure 12.5 – The camera’s final resting position ](img/Figure_12.5_17473.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 摄像机的最终位置](img/Figure_12.5_17473.jpg)'
- en: Figure 12.5 – The camera’s final resting position
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 摄像机的最终位置
- en: What this view will give us are a few things. First, it covers the most crucial
    angles. Clara can only walk to certain spots on this level. Also, not every walkable
    location is important. Still, there doesn’t seem to be anything significant left
    out from this perspective.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视角将给我们带来一些东西。首先，它覆盖了最关键的角度。克拉拉只能在这个级别上走到某些地方。此外，并非每个可通行的地方都是重要的。尽管如此，从这个角度看，似乎没有遗漏任何重要的东西。
- en: Second, referring to her uncle’s note, there is a backpack behind the broken
    cart. It’s hard to see it from here because the sconce’s light in that corner
    is not enough to make the backpack all that obvious. All of this is intentional
    because we’ll want Clara to hold a torch in her hand, so that extra bit of light
    will be enough for her or the player to notice an important object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，根据她叔叔的笔记，破碎的手推车后面有一个背包。从这里看很难看到它，因为那个角落的壁灯光线不足以使背包非常明显。所有这些都是故意的，因为我们希望克拉拉手里拿着火把，这样额外的光线就足以让她或玩家注意到一个重要的物品。
- en: Eventually, we expect the player to see and interact with the objects in the
    world, especially the backpack since it holds the key to the upstairs. A common
    instrument game designers use for player-to-world interaction is mouse events,
    which is what we’ll discover next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望玩家能够看到并交互世界中的对象，特别是背包，因为它持有通往楼上的钥匙。游戏设计师常用的玩家与世界交互的常见工具是鼠标事件，这是我们接下来将要发现的。
- en: Detecting user input
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测用户输入
- en: Mouse events are one of the many types of user input you can detect in a video
    game. Other most common types are keyboard or game controller events, which won’t
    be covered in this book. Still, the principles in detecting what the mouse is
    doing are similar to how you can treat other types of events. The reason why we
    are focusing more on mouse events is that there is an extra layer of complexity
    you’ve got to deal with, which is what this section will be about. Let’s dive
    right in.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件是你在视频游戏中可以检测到的许多用户输入类型之一。其他最常见类型是键盘或游戏控制器事件，这些内容本书不会涉及。然而，检测鼠标动作的原则与其他类型事件的处理方式相似。我们之所以更关注鼠标事件，是因为你还需要处理一个额外的复杂层，这正是本节将要讨论的内容。让我们直接深入探讨。
- en: In a conventional desktop application such as text- or video-editing software,
    the interface is usually populated with a lot of buttons, menus, and likewise.
    The natural behavior you’d expect from the users of such software is to click
    these designated spots, which is something the creators of the application anticipate
    and prepare for you. How would you go about this in a 3D game, though?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的桌面应用程序，如文本或视频编辑软件中，界面通常充满了许多按钮、菜单等。你期望此类软件的用户点击这些指定的位置，这是应用程序的制作者预期并为你准备的。那么在3D游戏中，你该如何处理这个问题呢？
- en: See, when you click anywhere on your screen, you are essentially clicking on
    a 2D surface. Thus, it originally makes sense to define the click’s coordinates
    based on the *x* and *y* axes. Let’s make the case even simpler. We are not clicking
    anything fancy but just the middle of the screen. By knowing the monitor’s resolution,
    we can do the calculation and come up with coordinates that are half the resolution
    in both axes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，当你点击屏幕上的任何位置时，你实际上是在点击一个2D表面。因此，基于*x*和*y*轴定义点击的坐标原本是有意义的。让我们使情况更简单。我们不是点击任何复杂的东西，只是屏幕的中间。通过知道显示器的分辨率，我们可以进行计算，并得出两个轴上都是分辨率一半的坐标。
- en: Let’s imagine, in this special case where we keep clicking right in the middle
    of the screen, we have the game world we see in *Figure 12.5*. Where does that
    click correspond in our level? Even more interestingly, if you implemented a camera
    that moved elsewhere, perhaps even rotated due to gameplay reasons, how do you
    map the same *x* and *y* coordinates to a different position in the 3D space?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，在这个特殊情况下，我们一直在屏幕中央点击，我们看到的是*图12.5*中的游戏世界。这个点击在我们的关卡中对应的位置在哪里？更有趣的是，如果你实现了一个可以移动到其他位置的摄像机，甚至因为游戏原因而旋转，你如何将相同的*x*和*y*坐标映射到3D空间中的不同位置？
- en: This is a challenging topic that is not always straightforward to resolve, but
    let’s see which techniques we can use to discern mouse events.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有挑战性的主题，并不总是容易解决，但让我们看看我们可以使用哪些技术来识别鼠标事件。
- en: Knowing where the player interacts
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知道玩家在哪里交互
- en: There is a common technique in the industry for detecting where the player is
    pointing in a 3D world. It’s called **raycasting**, and YouTube is awash with
    tutorials dedicated to this particular topic, not just for Godot Engine but for
    other game engines as well. It assumes that you are casting a ray from where you
    clicked on your screen to a position in the 3D world. Since the game engine is
    already capable of rendering the game by considering the game objects’ positions
    in relation to the camera, which happens to be your screen, then the calculations
    are already done for you, to a certain extent.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中有一个常见的检测玩家在3D世界中指向位置的技巧。这被称为**光线投射**，YouTube上充斥着针对这一特定主题的教程，不仅限于Godot引擎，还包括其他游戏引擎。它假设你从屏幕上点击的位置向3D世界中的某个位置投射一条光线。由于游戏引擎已经能够通过考虑游戏对象相对于摄像机的位置来渲染游戏，而摄像机恰好是你的屏幕，因此计算已经为你完成，在一定程度上。
- en: Although this technique puts you in the right direction, you still have no idea
    which object in the path of that ray is the one you want to select. Perhaps an
    unfortunate analogy for a ray might be a strong enough bullet that’s traversing
    through all objects it connects with. So, if raycasting brings up many results,
    you’ve got to eliminate the ones you don’t want. Fortunately, there is a more
    direct way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术把你引向了正确的方向，但你仍然不知道路径上的哪个对象是你想要选择的。也许射线的一个不幸的类比可能是一个足够强大的子弹，它穿越了它所连接的所有对象。所以，如果射线投射产生了许多结果，你必须消除你不需要的。幸运的是，有一个更直接的方法。
- en: 'It would be convenient to only assign detection logic to the objects we want.
    For example, we can introduce a new model to our scene—a parchment, to be specific—right
    on the wooden slats of the pier. Once the player clicks this object, we’ll trigger
    the note currently hidden in the `UI.tscn` scene. Via this effort, you will also
    practice some of the methods you used in earlier chapters too. Here are the steps
    to take:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只为我们要的对象分配检测逻辑会方便得多。例如，我们可以在我们的场景中引入一个新的模型——具体来说，是一张羊皮纸——直接放在码头上的木条上。一旦玩家点击这个对象，我们就会触发隐藏在`UI.tscn`场景中的笔记。通过这项工作，你也将练习一些你在早期章节中使用过的方法。以下是需要采取的步骤：
- en: Make a new scene out of `Parchment.glb` and save it as `Parchment.tscn` in the
    same folder.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Parchment.glb`创建一个新的场景，并将其保存为与同一文件夹中的`Parchment.tscn`。
- en: Since there is a default environment in effect, the scene will be dark, and
    it will be hard to follow the succeeding steps. To disable it, open `Parchment.tscn`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于有一个默认的环境正在生效，场景将会很暗，很难跟随接下来的步骤。要禁用它，打开`Parchment.tscn`。
- en: Add a **StaticBody** node under the root node.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根节点下添加一个**StaticBody**节点。
- en: Add a **CollisionShape** node under this last node you introduced and assign
    a **New BoxShape** to its **Shape** field in the **Inspector** panel.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚引入的最后一个节点下添加一个**CollisionShape**节点，并在**Inspector**面板中将一个**New BoxShape**分配给其**Shape**字段。
- en: Expand this new shape by clicking it. Type `0.15`, `0.14`, and `0.06` in the
    **Extents** section’s **X**, **Y**, and **Z** fields respectively. This shape
    should encapsulate the model.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击此新形状来扩展它。在**Extents**部分的**X**、**Y**和**Z**字段中分别输入`0.15`、`0.14`和`0.06`。这个形状应该包含模型。
- en: Still for the `0.05` in the **Z** field under its **Translation** section.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在它的**Translation**部分的**Z**字段下的`0.05`。
- en: We are not done yet with the parchment scene, but let’s take a break and explain
    what’s happened.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成羊皮纸场景，但让我们休息一下，解释一下发生了什么。
- en: We have added our first **PhysicsBody** type of node to our workflow with a
    **StaticBody** node. There are other types too, such as **KinematicBody**, **RigidBody**,
    and likewise, if you would like to offer physics-based gameplay. Since the parchment
    object we will place in the world won’t go anywhere, we chose **StaticBody**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的工作流程中添加了第一个**PhysicsBody**类型的节点，使用了一个**StaticBody**节点。还有其他类型，例如**KinematicBody**、**RigidBody**，等等，如果你想要提供基于物理的游戏玩法。由于我们将放置在世界的羊皮纸对象不会移动，我们选择了**StaticBody**。
- en: Then, we assigned a collision shape to the **StaticBody** node. Adding collision
    to game objects is necessary if you want the engine to detect when your objects
    collide with each other. By doing so, the game engine can determine these objects’
    future trajectory and speed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将一个碰撞形状分配给了**StaticBody**节点。如果你想让引擎检测到你的对象相互碰撞，那么在游戏对象中添加碰撞是必要的。通过这样做，游戏引擎可以确定这些对象的未来轨迹和速度。
- en: One type of collision the game engine can detect is when players interact with
    objects using input devices. For instance, the player might move the mouse over
    an object, click this object, or even want to drag and move it somewhere else.
    Out of all these possibilities, we are only interested in detecting when the player
    clicks the parchment model. We’ll learn how to distinguish the exact event we
    want in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎可以检测的一种碰撞类型是当玩家使用输入设备与对象交互时。例如，玩家可能将鼠标移到对象上，点击此对象，甚至想要将其拖动到其他地方。在所有这些可能性中，我们只对检测玩家何时点击羊皮纸模型感兴趣。我们将在下一节中学习如何区分我们想要的精确事件。
- en: Distinguishing useful mouse events
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分有用的鼠标事件
- en: We’ve constructed all the necessary mechanisms to start detecting collisions.
    The basic shape we wrapped the parchment model in will act like a sensor to know
    if collisions are occurring. Out of so many different types of collisions, we
    are mainly interested in listening to mouse events, and—more specifically—detecting
    mouse clicks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了所有必要的机制来开始检测碰撞。我们包裹 parchment 模型的基本形状将充当传感器，以了解是否发生碰撞。在众多不同类型的碰撞中，我们主要对监听鼠标事件感兴趣，并且——更具体地说——检测鼠标点击。
- en: 'We’ll treat this click on the parchment as a precursor to bringing up the currently
    hidden `UI.tscn` scene. Ultimately, we will build a communication line between
    the parchment and the `UI.tscn` scene. First, let’s see how we capture a collision
    and filter out the right type so that we can later trigger the chain of events
    we want. Here’s what to do:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个对 parchment 的点击视为打开当前隐藏的 `UI.tscn` 场景的先兆。最终，我们将在 parchment 和 `UI.tscn`
    场景之间建立一个通信线路。首先，让我们看看我们如何捕获碰撞并过滤出正确的类型，以便我们可以在以后触发我们想要的连锁事件。以下是操作步骤：
- en: Attach a script to the root node in `Parchment.tscn` and save it as `Parchment.gd`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本附加到 `Parchment.tscn` 的根节点，并将其保存为 `Parchment.gd`。
- en: Select the **StaticBody** node and turn on the **Node** panel.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **StaticBody** 节点并打开 **Node** 面板。
- en: Double-click the **input_event** entry under the **CollisionObject** header.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **CollisionObject** 头下的 **input_event** 项。
- en: 'Press the `Parchment.gd` script to what you see here:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 `Parchment.gd` 脚本，如下所示：
- en: '[PRE0]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’re now, in theory, tracking the input event on the **StaticBody** node.
    However, in practice, since the collision shape for generating this event is positioned
    precisely over the parchment, our setup will behave as though you are detecting
    clicks on the parchment itself. The following screenshot shows our progress in
    the editor:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们现在正在跟踪 **StaticBody** 节点上的输入事件。然而，在实践中，由于生成此事件的碰撞形状正好位于 parchment 上，我们的设置将表现得好像你正在检测
    parchment 本身的点击。以下截图显示了我们在编辑器中的进度：
- en: '![Figure 12.6 – We are attaching input events to the parchment object ](img/Figure_12.6_17473.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 我们正在将输入事件附加到 parchment 对象](img/Figure_12.6_17473.jpg)'
- en: Figure 12.6 – We are attaching input events to the parchment object
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 我们正在将输入事件附加到 parchment 对象
- en: 'The input event we are capturing is generic enough, but we are filtering it
    out so that it will be valid only in mouse-click conditions. Then, we transformed
    the meaning of this click by emitting a `show_note` signal, but who is listening
    to this call? Some construct out there could make sense of this signal—more specifically,
    the `UI.tscn` scene. Let’s connect them next, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们捕获的输入事件足够通用，但我们正在过滤它，以便它仅在鼠标点击条件下有效。然后，我们通过发射 `show_note` 信号来转换这个点击的意义，但谁在监听这个调用？某个构造体可能能够理解这个信号——更具体地说，是
    `UI.tscn` 场景。让我们接下来按照以下方式连接它们：
- en: 'Open `UI.tscn` and attach a script to the root. Save it as `UI.gd` and add
    the following line of code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `UI.tscn` 并将脚本附加到根节点。将其保存为 `UI.gd` 并添加以下代码行：
- en: '[PRE1]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open `Level-01.tscn` and create an instance of `Parchment.tscn` in the **Props**
    group. Position this new node on the wooden slats of the pier so that it sits
    relatively close to the boat.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Level-01.tscn` 并在 **Props** 组中创建 `Parchment.tscn` 的实例。将这个新节点放置在码头木条上，使其相对靠近船只。
- en: Select the **UI** node in the **Scene** panel. There is going to be a **Note
    Trigger** field for this node in the **Inspector** panel. Press **Assign…** and
    select **Parchment** among the options that come up in the pop-up menu.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Scene** 面板中选择 **UI** 节点。在 **Inspector** 面板中，这个节点将有一个 **Note Trigger** 字段。按
    **Assign…** 并在弹出菜单中选择 **Parchment**。
- en: 'Go back to the `UI.gd` script and add the following lines of code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `UI.gd` 脚本，并添加以下代码行：
- en: '[PRE2]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is a lot going on here with a few lines of basic code. First, we prepared
    a field for the `show_note` signal—so that it could trigger the `on_show_note`
    function. When this function runs as a result of the player’s click on the parchment,
    the **Panel** node, which is essentially Bert’s note, will become visible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，只有几行基本代码。首先，我们为 `show_note` 信号准备了一个字段——以便它可以触发 `on_show_note` 函数。当这个函数作为玩家点击
    parchment 的结果运行时，本质上代表伯特笔记的 **Panel** 节点将变得可见。
- en: 'When you were building the UI in [*Chapter 11*](B17473_11.xhtml#_idTextAnchor186),
    *Creating the User Interface*, if you didn’t center the **Panel** perfectly, you
    can do so now by using the **Layout** button in the header of the 3D viewport.
    If you prefer, you can position the **Panel** anywhere you want. Ultimately, when
    you press *F5* and run the game, after you click the parchment on the pier, you
    will see something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[*第11章*](B17473_11.xhtml#_idTextAnchor186)“创建用户界面”中构建UI时，如果你没有完美地居中**面板**，你现在可以通过使用3D视图中标题栏的**布局**按钮来实现。如果你愿意，你可以将**面板**放置在任何你想要的位置。最终，当你按下*F5*并运行游戏，在你点击码头上的羊皮纸后，你会看到如下内容：
- en: '![Figure 12.7 – Bert’s note to Clara was opened when the player clicked the
    parchment ](img/Figure_12.7_17473.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 伯特给克拉拉的笔记在玩家点击羊皮纸时打开](img/Figure_12.7_17473.jpg)'
- en: Figure 12.7 – Bert’s note to Clara was opened when the player clicked the parchment
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 伯特给克拉拉的笔记在玩家点击羊皮纸时打开
- en: Remember that the **Close** button is already wired, so it’ll close the note
    when you press it. If you do so, you can open the note again by clicking the parchment.
    Who knew that a simple mouse click could mean different things? In one context,
    it’s pressing on a flat surface that translates to clicking a 3D object, which
    then triggers other game systems. In another, it’s pressing a UI element like
    a button.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**关闭**按钮已经连接好了，所以当你按下它时，会关闭笔记。如果你这样做，你可以通过点击羊皮纸再次打开笔记。谁知道一个简单的鼠标点击可以意味着不同的东西呢？在一个上下文中，按下平面表面相当于点击一个3D对象，然后触发其他游戏系统。在另一个上下文中，它是按下UI元素，如按钮。
- en: Sconces and candles
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 灯台和蜡烛
- en: If the player is able to click the parchment, can’t they click the sconces and
    candles around the level? They can, but they won’t get a reaction out of it right
    now since you have to construct a collision structure, just as we did for the
    parchment. This is something you can work on as an exercise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家能够点击羊皮纸，他们不能点击周围级别的灯台和蜡烛吗？他们可以，但他们现在不会得到任何反应，因为你必须构建一个碰撞结构，就像我们对羊皮纸所做的那样。这是一项你可以作为练习来完成的任务。
- en: We’re not planning to have an inventory system in our game. However, in games
    that employ that kind of functionality, it’s common to see that parchment disappear
    from the world and find a place for itself in the player’s inventory. Then, the
    player can later click an icon that represents the note in their inventory to
    bring up the note UI again. In this extra case, your UI structure would also have
    to listen to a `show_note` signal emitted from a different structure, but it’s
    a similar principle.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在我们的游戏中实现库存系统。然而，在那些采用此类功能的游戏中，常常会看到羊皮纸从世界中消失，并在玩家的库存中找到自己的位置。然后，玩家可以稍后点击代表他们库存中笔记的图标，再次调出笔记用户界面。在这种情况下，你的用户界面结构也必须监听来自不同结构的`show_note`信号，但原理是相似的。
- en: Not having an inventory system is not a real detriment to our workflow at this
    point since we have more pressing issues such as helping the player move around.
    Although we have a level where there is a solid floor, we have no game character
    that can stand on it. We’ll look at how to introduce one and move it in the upcoming
    section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有库存系统并不会真正损害我们的工作流程，因为我们有更紧迫的问题，比如帮助玩家移动。尽管我们有一个有坚实地板的级别，但我们没有能够在上面站立的玩家角色。我们将在下一节中探讨如何引入一个角色并移动它。
- en: Moving the player around
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动玩家
- en: You might have heard that context is important in real life because context
    can make an ordinary word or statement look especially bad or fun. This is consistently
    true in most technical areas—more specifically when we try to describe visual
    or artistic aspects. Sometimes, it’s alright to use words interchangeably, but
    making a distinction might be crucial—even necessary every now and then. For example,
    at the end of the last section, we claimed that we’d move a character. It might
    be an absurd attempt to do mind-reading via the pages of a book, but would we
    be wrong if you imagined a biped creature such as Clara walking around using her
    legs and swinging her arms?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过，在现实生活中上下文很重要，因为上下文可以使一个普通的词或陈述显得特别糟糕或有趣。这在大多数技术领域都是一致的——更具体地说，当我们试图描述视觉或艺术方面时。有时，使用同义词是可以的，但区分可能至关重要——甚至有时是必要的。例如，在上一个部分的结尾，我们声称我们将移动一个角色。这可能是一种通过书本页面进行心灵感应的荒谬尝试，但如果你想象一个像克拉拉这样的两足生物用腿走路，挥动双臂，我们会错吗？
- en: Chances are you did think about it that way, but you’ll have to wait for that
    at this moment since we haven’t even moved an object between two spots on the
    level. Referring to the analogy of context, not every move has to involve a fully-fledged
    animation. Clara’s model, or an ordinary cube for that matter, could also move
    by following a path. Therefore, it might be more appropriate to think of movement
    and animation as two distinct topics. That’s why we will introduce animation into
    moving objects later in the *Triggering animations* section after we first tackle
    movement in this section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你已经这样想过，但在这个时候你必须等待，因为我们甚至还没有在关卡上的两个位置之间移动一个对象。从上下文类比的角度来看，并不是每一次移动都必须涉及完整的动画。克拉拉的模型，或者更不用说一个普通的立方体，也可以通过遵循路径来移动。因此，将运动和动画视为两个不同的主题可能更为合适。这就是为什么我们将在本节首先处理运动之后，在*触发动画*部分稍后介绍动画。
- en: 'Now that you know there is a difference between an object traversing a scene
    and doing so with an animation, the big question is: *How to detect where to move
    an object?* Let’s be more specific in terms of our level design. We have a pier
    where we have just recently placed a parchment. The basic expectation is that
    our player character will be standing right by this parchment. Once the player
    is done reading the note, we expect them to reach the backpack to acquire a key
    to unlock the door that leads upstairs. Therefore, we need a mechanism to do the
    following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道对象穿越场景和带有动画穿越之间的区别，那么一个重要的问题就是：*如何检测移动对象的位置？*让我们在关卡设计方面更加具体。我们有一个码头，我们最近在上面放置了一张羊皮纸。基本预期是玩家角色将站在这张羊皮纸旁边。一旦玩家读完笔记，我们希望他们能够到达背包，获取一把钥匙来解锁通往楼上的门。因此，我们需要一个机制来完成以下任务：
- en: Detect clicks
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测点击
- en: Find a possible path
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找一个可能的路径
- en: Move the player to their desired spot
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家移动到他们想要的位置
- en: 'Before we can start working on these items, we first need two vital ingredients:
    **Navigation** and **NavigationMeshInstance**. These two nodes work hand in hand
    to designate some areas in the level to be walkable. After all, we wouldn’t want
    the player to walk everywhere or through objects, hence the importance of some
    of the props we placed around the level.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理这些项目之前，我们首先需要两个关键成分：**导航**和**导航网格实例**。这两个节点携手合作，指定关卡中的一些区域为可通行区域。毕竟，我们不想让玩家到处走动或穿过物体，这就是我们在关卡周围放置的一些道具的重要性。
- en: Interchangeability for the sake of brevity
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，可以互换使用
- en: Although we’ve pointed out a major difference between movement and animation
    and claimed that we can’t use these two concepts interchangeably, we are in luck
    when it comes to the two nodes we are going to peruse in this section. You’ll
    soon see that a **Navigation** node is practically incapable of doing its work
    without depending on **NavigationMeshInstance**. We’ll use **Navigation** as a
    general concept (unless otherwise specified) to talk about navigation, while technically,
    we might be describing the attributes of the **NavigationMeshInstance** node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经指出了运动和动画之间的主要区别，并声称我们不能互换使用这两个概念，但在我们即将在本节中探讨的两个节点方面，我们却很幸运。你很快就会看到，一个**导航**节点实际上无法在没有依赖**导航网格实例**的情况下完成其工作。我们将使用**导航**作为一个通用概念（除非另有说明）来讨论导航，而在技术上，我们可能正在描述**导航网格实例**节点的属性。
- en: With that said, let’s create areas that are traversable by the player.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们创建玩家可以通行的区域。
- en: Creating walkable areas with a Navigation node
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导航节点创建可通行区域
- en: The level we started to design in [*Chapter 9*](B17473_09.xhtml#_idTextAnchor146),
    *Designing the Level* has some nice, but also troubling features. From a visual
    perspective, the props and their placement in the world look organic. Even bulkier
    objects such as the broken cart and the stag statue are out of the way but still
    in the line of sight when a person walks between the pier and the door. There
    is an element of usefulness mixed with clutter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第9章*](B17473_09.xhtml#_idTextAnchor146) *设计关卡*中开始设计的关卡有一些不错但也很令人烦恼的特点。从视觉角度来看，道具及其在世界的放置看起来很自然。即使是像破损的手推车和鹿雕像这样体积较大的物体，当人们走在码头和门之间时，也都在视线范围内。有用性和杂乱无章的元素混合在一起。
- en: 'Speaking of clutter, when we introduce a `Level-01.tscn` and follow along with
    these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 说到杂乱无章，当我们引入`Level-01.tscn`并按照以下步骤进行时：
- en: Add a **Navigation** node in the root node. Then, add a **NavigationMeshInstance**
    node right under this last node you’ve introduced.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根节点中添加一个**Navigation**节点。然后，在刚刚引入的最后一个节点下面添加一个**NavigationMeshInstance**节点。
- en: Drag and drop the **Floor**, **Columns**, **Rails**, **Props**, and **Dock**
    groups under the **NavigationMeshInstance** node.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Floor**、**Columns**、**Rails**、**Props**和**Dock**组拖放到**NavigationMeshInstance**节点下。
- en: Select the **NavigationMeshInstance** node and assign a **New NavigationMesh**
    to its **Navmesh** field in the **Inspector** panel.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**NavigationMeshInstance**节点，并在**Inspector**面板中将一个新的**NavigationMesh**分配给其**Navmesh**字段。
- en: 'Click and expand this new property so that you can do the following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并展开这个新属性，以便你可以执行以下操作：
- en: Type `0.18` in the `0.1` in the **Height** field under its **Cell** section.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**Cell**部分的**Height**字段中输入`0.18`。
- en: Type `0.4` in the `0.2` in the **Max Climb** field under its **Agent** section.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**Agent**部分的**Max Climb**字段中的`0.2`处输入`0.4`。
- en: Turn on the **Ledge Spans** option under its **Filter** section.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**Filter**部分下打开**Ledge Spans**选项。
- en: Press *7* on your numeric keypad to switch to the **Top Orthogonal** view.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下你的数字键盘上的*7*键以切换到**Top Orthogonal**视图。
- en: Press the **Bake NavMesh** button at the top part of the 3D viewport.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在3D视口的顶部按下**Bake NavMesh**按钮。
- en: 'If your level design is different than ours, please try to follow the steps
    we have presented in the spirit they are given. This is especially important if
    you directly transfer our values to your system, which might not fit. In the end,
    you’ll see something similar to this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的关卡设计与我们不同，请尽量按照我们提供的步骤进行，特别是在你直接将我们的值转移到你的系统上时，这可能不适合。最终，你会看到类似这样的东西：
- en: '![Figure 12.8 – We have introduced a NavigationMeshInstance node and configured
    it ](img/Figure_12.8_17473.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 我们已经引入了一个NavigationMeshInstance节点并对其进行了配置](img/Figure_12.8_17473.jpg)'
- en: Figure 12.8 – We have introduced a NavigationMeshInstance node and configured
    it
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 我们已经引入了一个NavigationMeshInstance节点并对其进行了配置
- en: Notice the light-blue overlay introduced by the **Navigation** node. That is
    all walkable as far as the engine is concerned. There is something awkward going
    on, though. When you dragged the **Dock** group into the **Navigation** node,
    the **Water** node came with it. So, it was also considered a candidate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由**Navigation**节点引入的浅蓝色叠加。从引擎的角度来看，所有这些都可以通行。不过，有些地方有些尴尬。当你将**Dock**组拖入**Navigation**节点时，**Water**节点也随之而来。因此，它也被考虑为一个候选者。
- en: 'If this were a *Dungeons & Dragons* game, your player might know the *Water
    Walk* spell and be able to walk on the water mesh. There is no such spell in Clara’s
    world, but it’s something you might want to consider if your game allows for such
    a mechanism and flavor. Therefore, instead of removing the water altogether, it’s
    best if we changed its place in the hierarchy by doing the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个**Dungeons & Dragons**游戏，你的玩家可能知道**Water Walk**咒语，并且能够在水网格上行走。在Clara的世界中没有这样的咒语，但如果你允许游戏有这样的机制和风味，这可能是一个需要考虑的因素。因此，我们最好通过以下方式改变其在层次结构中的位置，而不是完全移除水：
- en: Move the **Water** node somewhere other than the **NavigationMeshInstance**
    node—for example, above the **SpotLight** node.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Water**节点移动到**NavigationMeshInstance**节点以外的其他地方——例如，在**SpotLight**节点上方。
- en: Similarly, drag and drop **Parchment** out of the **Props** group.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将**Parchment**从**Props**组中拖出。
- en: Select the **NavigationMeshInstance** node and press the **Bake NavMesh** button
    again.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**NavigationMeshInstance**节点并再次按下**Bake NavMesh**按钮。
- en: 'With a different hierarchy, the newly baked traversable area should look like
    this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的层次结构中，新烘焙的可通行区域应该看起来像这样：
- en: '![Figure 12.9 – The water is no longer walkable thanks to being in a different
    hierarchy ](img/Figure_12.9_17473.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 由于处于不同的层次结构，水不再可通行](img/Figure_12.9_17473.jpg)'
- en: Figure 12.9 – The water is no longer walkable thanks to being in a different
    hierarchy
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 由于处于不同的层次结构，水不再可通行
- en: By determining which areas should be included in the **NavigationMeshInstance**
    node and adjusting values in the **Inspector** panel, you can come up with a more
    precise layout. Ultimately, if you can throw a few obstacles in the player’s way
    before they reach important places instead of following a perfectly straight line,
    you will create more engaging gameplay.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确定哪些区域应包含在**NavigationMeshInstance**节点中，并在**Inspector**面板中调整值，你可以得到一个更精确的布局。最终，如果你能在玩家到达重要地点之前在他们面前放置一些障碍物，而不是让他们沿着一条完美的直线前进，你将创造更多引人入胜的游戏玩法。
- en: If the layout in your level doesn’t look traversable in some key areas, such
    as the backpack near the cart, then move some of those props around and bake a
    new map. This is going to be important when we introduce movement logic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的关卡布局在某些关键区域（如购物车附近的背包）看起来不可穿越，那么就移动一些这些道具并烘焙一个新的地图。当我们介绍移动逻辑时，这将非常重要。
- en: You might want to rotate the view to **Perspective** if you want to get a better
    feeling of which areas are reachable. Speaking of which, who is going to walk
    these areas? Next, we should introduce the most basic player character before
    we get into more advanced character models such as Clara.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更好地感觉哪些区域是可到达的，你可能想要将视图旋转到 **Perspective**。说到这一点，谁将走过这些区域？在我们深入研究更高级的角色模型（如
    Clara）之前，我们应该先介绍最基本的玩家角色。
- en: Introducing a basic player character
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍基本玩家角色
- en: 'Earlier in this chapter, in the *Knowing where the player interacts* section
    when we were inquiring about how the player could interact with the parchment,
    we introduced a **StaticBody** node because the object wasn’t going anywhere.
    We also mentioned that **StaticBody** was one of many **PhysicsBody** options
    available to you besides two other commonly used nodes, as described here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，在 *了解玩家交互的位置* 部分，当我们询问玩家如何与羊皮纸交互时，我们引入了一个 **StaticBody** 节点，因为该物体不会移动。我们还提到，**StaticBody**
    是除了两个其他常用节点之外，你可以使用的许多 **PhysicsBody** 选项之一，如以下所述：
- en: '**RigidBody**: Bodies that don’t have control over themselves fall under this
    category. The word *rigid* might be confusing at first since it conveys a feeling
    of how strong or flexible an object is. On the contrary, you can use a **RigidBody**
    node for simulating the motion of a soccer ball or a cannonball. You usually apply
    forces to objects that have this node, which will instruct how the physics engine
    will calculate their trajectory, collisions, and likewise.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RigidBody**：没有对自己有控制的物体属于这一类别。一开始，“rigid”这个词可能有些令人困惑，因为它传达了物体强度或灵活性的感觉。相反，你可以使用
    **RigidBody** 节点来模拟足球或炮弹的运动。你通常会对具有此节点的物体施加力，这将指导物理引擎如何计算它们的轨迹、碰撞等。'
- en: '**KinematicBody**: Bodies that actually have control over how they will behave
    in the world fall into this category. Most typically, player characters use this
    node, but any system that creates its own motion—such as an actual engine or rocket—needs
    to use this.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KinematicBody**：实际上可以控制自己在世界中如何行为的物体属于这一类别。通常，玩家角色使用此节点，但任何创建自己运动的系统（如真正的引擎或火箭）都需要使用此节点。'
- en: 'Consequently, the best option we have is to use a **KinematicBody** node to
    simulate a player character. We’ll now follow the next steps to create a very
    simple one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最好的选择是使用 **KinematicBody** 节点来模拟玩家角色。我们现在将遵循以下步骤来创建一个非常简单的角色：
- en: Create a new scene and save it as `Player.tscn` under the `Scenes` folder.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并将其保存为 `Player.tscn`，位于 `Scenes` 文件夹下。
- en: Start with a **KinematicBody** node as its root. Then, add a **CollisionShape**
    node and a **MeshInstance** node under the root.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 **KinematicBody** 节点作为其根节点。然后，在根节点下添加一个 **CollisionShape** 节点和一个 **MeshInstance**
    节点。
- en: Select the `0.4` for its **Radius** property.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其 **Radius** 属性选择 `0.4`。
- en: Type `90` in the **X** field in **Rotation Degrees** under the **Transform**
    section.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Transform** 部分的 **Rotation Degrees** 下的 **X** 字段中输入 `90`。
- en: Select the `0.4` for its **Radius** property.*   Type `90` in the **X** field
    in **Rotation Degrees** under the **Transform** section.*   Select the `0.9` in
    the `Player`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其 **Radius** 属性选择 `0.4`。在 **Transform** 部分的 **Rotation Degrees** 下的 **X** 字段中输入
    `90`。在 `Player` 中选择 `0.9`。
- en: 'This will create a capsule shape, which is a quick way to simulate player characters.
    Also, we picked a collision shape that would go well with the mesh we created.
    Since there isn’t much to look at in the `Player.tscn` scene, it may be best if
    we show you where to place it in the world. Create an instance of it in `Level-01.tscn`,
    and position it as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个胶囊形状，这是一种模拟玩家角色的快速方法。我们还选择了一个与我们所创建的网格很好地配合的碰撞形状。由于在 `Player.tscn` 场景中没有什么可看的，所以我们最好向您展示它在世界中的放置位置。在
    `Level-01.tscn` 中创建其实例，并按照以下截图所示进行定位：
- en: '![Figure 12.10 – An upright pill-shaped player character ](img/Figure_12.10_17473.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 一个直立的长条形玩家角色](img/Figure_12.10_17473.jpg)'
- en: Figure 12.10 – An upright pill-shaped player character
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 一个直立的长条形玩家角色
- en: 'The player character, although it looks like a pill standing up right now,
    is now part of the world and ready to move around. It just needs to be told where
    to go. How can we give it instructions before even we know where it’s supposed
    to go? To solve this mystery, we will have to prepare a structure to catch clicks.
    All this will eventually lead us to revisit a topic we dismissed earlier in the
    *Detecting user input* section: raycasting. After all, it will help us know where
    the player clicked in the world.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色，尽管现在看起来像是一个站立的小药丸，但现在它是世界的一部分，可以移动。它只需要被告知去哪里。在我们甚至不知道它应该去哪里之前，我们如何给它指令？为了解决这个谜团，我们不得不准备一个结构来捕捉点击。所有这些最终都会让我们重新审视在**检测用户输入**部分之前忽略的一个主题：射线投射。毕竟，它将帮助我们了解玩家在世界中的点击位置。
- en: Preparing a clickable area for raycasting
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备射线投射的点击区域
- en: When you know exactly which objects should be interactive and receive mouse
    events, the method we applied in the *Distinguishing useful mouse events* section
    is still valid. It entails anticipation on the game designer’s end, so the essential
    bindings could be done early on, as we saw. However, what if it wasn’t always
    possible to foresee this, or how viable would that method be on a larger scale?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当您确切知道哪些对象应该是交互式的并接收鼠标事件时，我们在**区分有用的鼠标事件**部分应用的方法仍然有效。它涉及到游戏设计师的预期，因此基本绑定可以在早期完成，就像我们看到的。然而，如果这种情况并不总是可以预见，或者这种方法在更大规模上有多可行？
- en: For example, if we were to add a **StaticBody** node to each floor model we
    have used so far, we could certainly detect mouse clicks. That being said, sometimes,
    it’s a bit too late for that. Right now, our level has all the floor pieces as
    model instances instead of scene instances because, back then, it was convenient
    to drop the models and be done with the level design. We could still try to create
    a scene out of a floor model, but you’d still have to swap all the floor assets
    in the level. It’s a lot of work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们给到目前为止使用的每个楼层模型都添加一个**静态体**节点，我们当然可以检测鼠标点击。然而，有时这已经有点太晚了。现在，我们的关卡中所有的地板块都是模型实例而不是场景实例，因为当时放下模型并完成关卡设计很方便。我们仍然可以尝试从地板模型中创建一个场景，但您仍然需要交换关卡中的所有地板资产。这是一项大量工作。
- en: 'Since we already know that a **StaticBody** node is necessary to initiate an
    input response, we may yet use it to our advantage. Instead of attaching it to
    every single floor piece, we could designate an area as large as what all the
    floor pieces occupy, and detect the clicks on this large piece. Here’s how to
    do this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道需要一个**静态体**节点来启动输入响应，我们还可以利用它。我们不必将其附加到每一块地板上，而可以指定一个与所有地板块占据的面积一样大的区域，并检测这个大块上的点击。以下是这样做的方法：
- en: Add a **StaticBody** node to the level and place a **CollisionShape** node inside
    this **StaticBody** node.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中添加一个**静态体**节点，并在其中放置一个**碰撞形状**节点。
- en: Assign a **New BoxShape** to the **Shape** field in the **Inspector** panel.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板的**形状**字段中分配一个**新盒子形状**。
- en: Expand this new property and adjust its `9`, `1`, and `8` but you might want
    to adjust these values after you finish the next step.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开这个新属性并调整其`9`、`1`和`8`，但您可能希望在完成下一步后再调整这些值。
- en: Position the `-1.05`. Adjust it to a value so that its top almost aligns with
    the floor but just below the parchment. We’ll discuss this after we finish moving
    the player.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`-1.05`的位置调整到其顶部几乎与地板对齐，但略低于羊皮纸。我们将在移动玩家后讨论这个问题。
- en: Its **X** and **Z** values are at a point where its child, **CollisionShape**,
    encompasses the floor pieces and the walkable areas on the pier.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其**X**和**Z**值位于其子节点**碰撞形状**包围地板块和码头上的可通行区域的位置。
- en: 'It might be easier to decide on the measurements if you switch to the **Top
    Orthographic** view. The blue square in the following screenshot represents the
    area we want to use as a click detector:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您切换到**俯视图**，可能更容易决定测量。以下截图中的蓝色正方形代表我们想要用作点击检测器的区域：
- en: '![Figure 12.11 – The StaticBody node covers all walkable areas ](img/Figure_12.11_17473.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 静态体节点覆盖所有可通行区域](img/Figure_12.11_17473.jpg)'
- en: Figure 12.11 – The StaticBody node covers all walkable areas
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 静态体节点覆盖所有可通行区域
- en: You might be wondering if we overdid it with the detection area since *Figure
    12.11* clearly shows it is way larger than the walkable areas. A short explanation
    is that when you click on areas outside the traversable field, the pathfinding
    algorithm will take the player to a nearby spot but never to the exact position
    the player clicked. For example, if you click in the water, then the player character
    will move to the clicked spot as close as possible but still stay within the limits.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们是否过度了检测区域，因为*图12.11*清楚地显示它比可通行区域大得多。简短的解释是，当你点击在可通行区域外的区域时，路径查找算法会将玩家带到附近的地点，但永远不会到达玩家点击的确切位置。例如，如果你在水里点击，那么玩家角色将移动到点击位置尽可能接近，但仍然保持在限制范围内。
- en: 'When you get to see the code, things might make more sense from a technical
    point of view. With that said, let’s attach some code to the player character
    so that it can move around, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到代码时，从技术角度来看可能会更清晰。话虽如此，让我们将一些代码附加到玩家角色上，以便它可以四处移动，如下所示：
- en: Open `Player.tscn` and select the root node.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Player.tscn`并选择根节点。
- en: Attach `Player.gd` from the `Scripts` folder to the **Script** field in the
    **Inspector** panel.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Scripts`文件夹中的`Player.gd`文件附加到**Inspector**面板中的**Script**字段。
- en: 'Let’s explain the most important parts of the code we have just applied. You
    can refer to this code block at [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.gd](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.gd).
    The first 10 lines are for storing some of the startup values and structures we
    are going to use. Three of those variables are worth a thorough explanation since
    the rest is self-explanatory. Let’s look at them in more detail here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们刚刚应用代码的最重要部分。你可以参考这个代码块：[https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.gd](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.gd)。前10行用于存储我们将要使用的一些启动值和结构。其中三个变量值得详细解释，因为其余的都是不言自明的。让我们更详细地看看它们：
- en: '`camera`: The player scene has no **Camera** node, but it needs to access a
    camera to do the raycasting. So, we appropriate the currently used camera as a
    workaround.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camera`：玩家场景没有**Camera**节点，但它需要访问一个相机来进行光线投射。因此，我们作为权宜之计使用了当前使用的相机。'
- en: '`space_state`: This is our entryway to Godot’s **PhysicsServer** node that
    monitors which objects collide or intersect with each other. We’re going to use
    this variable to know if a click connects with the floor.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space_state`：这是我们进入Godot的**PhysicsServer**节点的入口，该节点监控哪些对象相互碰撞或相交。我们将使用这个变量来知道点击是否与地面连接。'
- en: '`nav`: Since the `Level-01.tscn` scene that also holds the **Navigation** node,
    we use a mechanism like this to inject the **Navigation** node into the **Player**
    node. This way, the **Player** node can query the **Navigation** node to find
    a possible path.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav`：由于`Level-01.tscn`场景也包含**Navigation**节点，我们使用这种机制将**Navigation**节点注入到**Player**节点中。这样，**Player**节点就可以查询**Navigation**节点以找到可能的路径。'
- en: 'The rest of the script consists of four functions. Despite that, two of those
    functions are doing the heavy lifting because the `_input` and `_physics_process`
    methods are essentially offloading their tasks to two other functions: `find_path`
    and `move_along` respectively. We could have ignored these latter functions, but
    when you are able to separate distinct functionality into their own functions,
    you should do this to keep your code clean.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的其余部分由四个函数组成。尽管如此，其中两个函数承担了主要工作，因为`_input`和`_physics_process`方法本质上是将任务卸载到两个其他函数：`find_path`和`move_along`。我们本可以忽略这些后置函数，但当你能够将不同的功能分离到它们自己的函数中时，你应该这样做以保持代码整洁。
- en: All of this was done so that we could do a raycasting that is implemented in
    the `find_path` function, which is what we are going to study next.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是为了在`find_path`函数中实现光线投射，这是我们接下来要研究的。
- en: Using Navigation node for pathfinding
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导航节点进行路径查找
- en: The large **StaticBody** node we’ve added to the scene is still not enough to
    know at which point on the floor the click happened. Having just that will only
    let us know that the player clicked somewhere in that area. So, in the end, we
    are still going to use raycasting for finding the precise location so that we
    can begin constructing a path toward this position.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到场景中的大型**StaticBody**节点仍然不足以知道点击发生在地板上的哪个点。仅仅这样只能让我们知道玩家在那个区域点击了某个地方。所以，最终，我们仍然会使用射线投射来找到精确的位置，这样我们就可以开始构建通向该位置的路径。
- en: 'To that end, the `find_path` function in the `Player.gd` script is going to
    use the following two techniques:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，`Player.gd`脚本中的`find_path`函数将使用以下两种技术：
- en: First is raycasting, to know exactly where the player clicked
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一是射线投射，以确切知道玩家点击的位置
- en: Second is whether there is a possible path toward that position
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个问题是是否存在通向该位置的可能路径
- en: 'The first three lines of code in the `find_path` function, as shown here, are
    what raycasting is about:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，`find_path`函数中的前三行代码，如所示，就是关于射线投射的内容：
- en: '[PRE3]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, we ask the camera system to tell us from where the ray is going to
    originate. Hence, we store it in the `from` variable. This happens to be where
    the mouse event happened. Keep in mind, though that this event is still on our
    monitor’s 2D surface. There is still no notion of where we are clicking in the
    3D world.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求相机系统告诉我们射线将从哪里发出。因此，我们将其存储在`from`变量中。这恰好是鼠标事件发生的地方。记住，尽管这个事件仍然在我们的监视器的2D表面上，但我们仍然没有关于我们在3D世界中点击位置的概念。
- en: Secondly, we ask the camera system to let us know where a ray would go if we
    projected it `100` units `from` into the world. Now, we know where `to` stretch
    the ray. Still, there is no guarantee that this ray will hit anything. Thus, we
    check if anything is intersecting the ray, and store it in the `result` variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们要求相机系统告诉我们，如果我们从世界中的`100`单位处投射射线，它会去哪里。现在，我们知道要将射线拉伸到哪个位置。然而，这并不能保证这个射线会击中任何东西。因此，我们检查是否有任何东西与射线相交，并将其存储在`result`变量中。
- en: So, in just three lines of code, we determined a line between where we clicked
    on our screen and a position in the world. The result of this raycasting might
    be empty, so it would be prudent to check if there is an object colliding with
    our ray. Only then can we proceed with finding a path.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅仅三行代码，我们就确定了我们点击屏幕上的位置和世界中的某个位置之间的直线。这次射线投射的结果可能是空的，所以明智的做法是检查是否有物体与我们的射线发生碰撞。只有在这种情况下，我们才能继续寻找路径。
- en: This is where the `nav` variable comes into play. Since it’s a reference to
    the `path` array.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`nav`变量发挥作用的地方。因为它是对`path`数组的引用。
- en: Separation issues
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 分离问题
- en: In a situation such as the pathfinding operation requiring a raycasting done
    in the `find_path` function—in other words, when two systems are closely related
    to each other—it might be okay not to separate the raycasting logic into its own
    function. We’ll revisit this concept later when we work on a more advanced game
    character in the *Triggering animations* section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在像在`find_path`函数中进行的寻路操作需要射线投射的情况——换句话说，当两个系统彼此紧密相关时——可能不需要将射线投射逻辑分离成单独的函数。我们将在*触发动画*部分处理更高级的游戏角色时再次回顾这个概念。
- en: Sooner or later, you’ll have a walkable path, although this doesn’t automatically
    make the player character follow a path. We’ll need several more lines of code
    to do that.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，你会得到一条可通行的路径，尽管这并不自动使玩家角色遵循路径。我们需要更多的代码来实现这一点。
- en: Moving the player to their desired spot
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家移动到他们想要的位置
- en: We have used raycasting to detect a spot where the player wants to go and queried
    the **Navigation** node to find the closest path to this desired spot. We are
    now ready to instruct the **Player** node to move between different points along
    the path.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用射线投射来检测玩家想要去的位置，并查询了**导航**节点以找到到达该位置的最近路径。我们现在准备指示**玩家**节点沿着路径的不同点移动。
- en: The `move_along` function in the `Player.gd` script receives a path and processes
    it one step at a time. Since it’s unlikely to have a straightforward path between
    the start and end points, the path will be composed of a series of midpoints before
    the player reaches their last stop. It’s like walking in real life where you make
    course corrections before you arrive at your destination. Naturally, if the path
    is empty or all of its steps have been processed, we terminate the function early.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player.gd` 脚本中的 `move_along` 函数接收一个路径并逐个步骤处理它。由于起点和终点之间不太可能有直接的路径，路径将由一系列中点组成，直到玩家到达他们的最后一个停靠点。这就像现实生活中走路，在到达目的地之前你需要进行路线修正。自然地，如果路径为空或所有步骤都已处理，我们提前终止函数。'
- en: 'Otherwise, we move the player between two stops by checking if the distance
    to the next step is within a certain threshold. Speaking of this threshold, this
    might be a good moment to talk about a caveat. During the writing and testing
    of this code, we had moments where the threshold value should have been `3`, or
    sometimes, `1`. You might want to experiment with a different value if you notice
    the player character is behaving awkwardly. This is something that will be remedied
    in later versions of Godot, as is noted in the official documentation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们通过检查到下一步的距离是否在某个特定阈值内来在两个停靠点之间移动玩家。说到这个阈值，这可能是一个讨论注意事项的好时机。在编写和测试此代码的过程中，我们有时阈值值应该是
    `3`，有时则是 `1`。如果你注意到玩家角色行为古怪，你可能想尝试不同的值。这将在 Godot 的后续版本中得到修复，正如官方文档中所述：
- en: The current navigation system has many known issues and will not always return
    optimal paths as expected. These issues will be fixed in Godot 4.0.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当前导航系统存在许多已知问题，并且不会总是返回预期的最优路径。这些问题将在 Godot 4.0 中得到解决。
- en: 'After all this hard work, we are now one step away from having the player character
    move around, so let’s carry on with this, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些艰苦的工作，我们现在离玩家角色移动只剩一步之遥，所以让我们继续，如下所示：
- en: Switch to `Level-01.tscn` and select the **Player** node.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Level-01.tscn` 并选择 **Player** 节点。
- en: Using the **Inspector** panel, click the **Assign…** button in its **Nav** field
    to select the **Navigation** node in the upcoming pop-up screen.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **检查器** 面板，在其 **Nav** 字段中点击 **分配…** 按钮，在即将出现的弹出窗口中选择 **Navigation** 节点。
- en: Press *F5* and click on different spots in the level.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F5* 并在关卡中的不同位置点击。
- en: 'When we test the scene and move the character away from the pier, this is what
    it looks like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试场景并将角色从码头移开时，看起来是这样的：
- en: '![Figure 12.12 – The player character can now move in the world ](img/Figure_12.12_17473.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 玩家角色现在可以在世界中移动](img/Figure_12.12_17473.jpg)'
- en: Figure 12.12 – The player character can now move in the world
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 玩家角色现在可以在世界中移动
- en: You now must be able to move the player character around by pressing on the
    floor or even in the water. The nearest spot will be picked as a destination.
    Also, while you are moving around, try to click the parchment on the pier. If
    it is placed just so it’s below the catch-all **StaticBody** node, then you won’t
    be able to trigger the note. If that’s the case, either adjust the **Y** position
    you set in the *Preparing a clickable area for raycasting* section for the **StaticBody**
    node or move the **Parchment** node up in the **Y** direction.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在必须能够通过在地板上或甚至在水中按下按钮来移动玩家角色。最近的点将被选为目标。此外，当你四处移动时，尝试点击码头上的羊皮纸。如果它放置得恰到好处，位于
    **StaticBody** 节点的下方，那么你将无法触发音符。如果是这种情况，请调整在 *为射线投射准备可点击区域* 部分为 **StaticBody**
    节点设置的 **Y** 位置，或者将 **Parchment** 节点在 **Y** 方向上向上移动。
- en: As long as the clicks are not competing, the parchment will trigger the note.
    If the player character is away, it will then move near the parchment as soon
    as the note is open. You might notice odd behavior at this point if you click
    the **Close** button. The note will close as expected, but the player character
    will suddenly move just under where the **Close** button was. It’s as if the note
    UI is letting some of our clicks through and the pathfinding logic picks up that
    call.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 只要点击不相互竞争，羊皮纸就会触发音符。如果玩家角色不在附近，音符打开后它将立即移动到羊皮纸附近。如果你此时点击 **关闭** 按钮，你可能会注意到奇怪的行为。音符将按预期关闭，但玩家角色会突然移动到
    **关闭** 按钮下方。这就像笔记 UI 允许我们的某些点击通过，而路径查找逻辑则捕捉到那个调用。
- en: 'Fortunately, there is a quick fix for this kind of behavior. If you replace
    the `_input` function with `_unhandled_input`, then all will be well. If these
    two look alike and unclear, you might want to find their nuances in the manual:
    [https://docs.godotengine.org/en/3.4/classes/class_node.xhtml](https://docs.godotengine.org/en/3.4/classes/class_node.xhtml).
    It might be worth remembering its use for quickly fixing a lot of UI headaches.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于这种行为有一个快速的解决方案。如果你将`_input`函数替换为`_unhandled_input`，那么一切都会好起来。如果这两个看起来相似且不清楚，你可能想在手册中找到它们的细微差别：[https://docs.godotengine.org/en/3.4/classes/class_node.xhtml](https://docs.godotengine.org/en/3.4/classes/class_node.xhtml)。记住它的用途，以便快速解决许多UI问题可能是有价值的。
- en: Wrapping up
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: If you have been developing video games for a while, you might already be familiar
    with the notion of iterative and incremental workflow. For example, it’s been
    okay to have indestructible crates so far. Let’s examine a scenario where you
    now want these crates to be destructible.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开发了一段时间的视频游戏，你可能已经熟悉了迭代和增量工作流程的概念。例如，到目前为止，拥有不可摧毁的箱子是可以接受的。让我们考察一个你现在想要这些箱子可摧毁的场景。
- en: Not only do you have to account for certain conditions to happen, such as if
    the player has the right item to break the said crates, but you will also have
    to prepare animations to be triggered at the moment of destruction. These are
    both programmatical and artistic changes, and they can definitely be done with
    ease to a certain extent. When you *baked* the walkable areas, the **Navigation**
    node believed the crates were solid obstacles. However, in this new dynamic situation,
    you also have to update the **NavigationMeshInstance** node with the new conditions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅必须考虑某些条件发生，例如玩家是否有正确的物品来摧毁这些箱子，而且你还需要准备在摧毁时刻触发的动画。这些既是程序性的也是艺术性的变化，并且在某种程度上可以轻松完成。当你*烘焙*可通行区域时，**Navigation**节点认为箱子是固体障碍物。然而，在这种新的动态情况下，你还需要更新**NavigationMeshInstance**节点以适应新的条件。
- en: If a crate the player has just destroyed is no longer part of the world, and
    that particular area should indeed be walkable, you have to update the walkable
    areas by baking a new map. Fortunately, it’s possible to create multiple **NavigationMeshInstance**
    resources and save them on the disk so that you can swap them to accommodate dynamic
    cases as needed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家刚刚摧毁的箱子不再是世界的一部分，而那个特定区域确实应该是可通行的，你必须通过烘焙一个新的地图来更新可通行区域。幸运的是，可以创建多个**NavigationMeshInstance**资源并将它们保存到磁盘上，以便根据需要交换它们以适应动态情况。
- en: Sometimes, it makes more sense to move ahead with prototypes. For instance,
    it was good enough to have our player character look like a capsule to test movement
    logic. It would be nice to have our avatar look more like a person than a white
    pill. Let’s see how we can accomplish that next.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，先进行原型设计更有意义。例如，我们的玩家角色看起来像一个胶囊来测试移动逻辑已经足够好了。让我们的头像看起来更像一个人而不是一个白色药丸会更好。让我们看看我们如何能够实现这一点。
- en: Triggering animations
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发动画
- en: In [*Chapter 5*](B17473_05.xhtml#_idTextAnchor075), *Setting Up Animation and
    Rigging*, we tackled the creation of animations in Blender. Then, in [*Chapter
    7*](B17473_07.xhtml#_idTextAnchor112), *Importing Blender Assets into Godot*,
    we saw how to import a model into Godot Engine and use the **AnimationPlayer**
    node to test the model’s different actions. The steps we’ll present in this section
    should be enough to introduce Clara to the game, but if you need a reminder on
    how to create and import animations, you might want to seek out those two chapters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B17473_05.xhtml#_idTextAnchor075) *设置动画和绑定*中，我们探讨了在Blender中创建动画。然后，在[*第七章*](B17473_07.xhtml#_idTextAnchor112)
    *将Blender资源导入Godot*中，我们看到了如何将模型导入Godot引擎，并使用**AnimationPlayer**节点测试模型的不同动作。本节中我们将展示的步骤应该足以将克拉拉引入游戏，但如果你需要提醒如何创建和导入动画，你可能需要查阅这两章。
- en: Since we are done with the player’s movement, what is missing is to introduce
    Clara to our workflow and play the proper actions, such as idling while she’s
    standing and walking while she is moving around.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了玩家的移动，那么缺少的就是将克拉拉引入我们的工作流程，并播放适当的动作，比如当她站立时闲置，当她移动时行走。
- en: 'We’ve already created a basic player character when we constructed `Player.tscn`
    and attached a script to this scene. It’s primitive but the scene structure is
    a good starting point. Follow these steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建`Player.tscn`并给这个场景附加脚本时，我们已经创建了一个基本的玩家角色。它很简单，但场景结构是一个很好的起点。按照以下步骤进行：
- en: Click `Clara.glb` in **FileSystem**, then bring up the **Import** panel.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**FileSystem**中点击`Clara.glb`，然后打开**Import**面板。
- en: Select **Files (.anim)** in the **Storage** dropdown under the **Animation**
    header. Refer to the *Separating actions* section from [*Chapter 7*](B17473_07.xhtml#_idTextAnchor112),
    *Importing Blender Assets into Godot*, to remember the need for this step.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Animation**标题下的**Storage**下拉菜单中选择**Files (.anim)**。参考[*第7章*](B17473_07.xhtml#_idTextAnchor112)的*分离动作*部分，*将Blender资产导入Godot*，以记住这一步骤的需要。
- en: Press **Reimport** to set up Clara’s dependencies properly. Switch to the **Scene**
    panel.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**Reimport**设置克拉拉的依赖项。切换到**Scene**面板。
- en: Open `Player.tscn` and delete the **MeshInstance** node.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Player.tscn`并删除**MeshInstance**节点。
- en: Drag `Clara.glb` from **FileSystem** onto the **Player** node. Thus, the old
    **MeshInstance** node will be replaced with a **Clara** node.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Clara.glb`从**FileSystem**拖到**Player**节点上。这样，旧的**MeshInstance**节点将被**Clara**节点替换。
- en: Click the root node and zero its **Translation** values since the values that
    applied to the basic capsule-shaped player are no longer valid.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击根节点并将**Translation**值归零，因为应用于基本胶囊形状玩家的值现在不再有效。
- en: Adjust the `1.2`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`1.2`。
- en: 'The main goal here is to replace the old **MeshInstance** node with Clara and
    adjust the **CollisionShape** node so that collision detection is done correctly.
    The editor should now look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要目标是用克拉拉替换旧的**MeshInstance**节点，并调整**CollisionShape**节点，以便正确进行碰撞检测。编辑器现在应该看起来像这样：
- en: '![Figure 12.13 – Clara has replaced the boring MeshInstance node ](img/Figure_12.13_17473.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 克拉拉替换了无聊的MeshInstance节点](img/Figure_12.13_17473.jpg)'
- en: Figure 12.13 – Clara has replaced the boring MeshInstance node
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 克拉拉替换了无聊的MeshInstance节点
- en: With this method, you can easily test your code for a player character, and
    then replace the test model with the actual model later. This might be useful
    if you are the main developer and you are still waiting for the artwork from your
    colleagues.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以轻松测试玩家的代码，然后稍后用实际模型替换测试模型。如果你是主要开发者，并且还在等待同事的艺术作品，这可能很有用。
- en: 'Improving the looks of the avatar was a good step forward. It’s looking much
    more appealing. We will do the same for its movement because you might notice
    odd behavior if you run the game now. Clara will be moving around like the old
    capsule mesh because it’s missing two major qualities, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 改善角色的外观是一个很好的进步。它看起来更加吸引人。我们将对其运动做同样的处理，因为如果你现在运行游戏，你可能会注意到一些奇怪的行为。克拉拉将会像旧胶囊网格一样移动，因为它缺少两个主要特性，如下所示：
- en: Looking in the direction it’s currently moving
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向它当前移动的方向
- en: Showing signs of walking instead of looking like a stick sliding on surfaces
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示出走路的迹象，而不是看起来像一根在表面上滑动的棍子
- en: There is also another problem but it’s so minor you can fix it without needing
    much discussion and explanation. The **Player** node, which used to hold the simple
    **MeshInstance** node, had to be moved slightly higher in the world. You can lower
    this new **Player** node to the level of the pier so that Clara’s feet are connecting
    with it. If you don’t make any changes, Clara will look like she’s hovering and
    then moving diagonally as soon as her movement logic kicks in.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题，但这个问题很小，你可以在不需要太多讨论和解释的情况下修复它。曾经持有简单**MeshInstance**节点的**Player**节点，不得不在世界上稍微提高一点。你可以将这个新的**Player**节点降低到码头的高度，这样克拉拉的脚就能与之连接。如果你不做任何更改，克拉拉看起来就像是在悬浮，然后一旦她的运动逻辑启动，就会以对角线移动。
- en: 'For the other two major concerns, we’ll have to dig deeper than just changing
    an object’s position. We’ve got to first update the script we are using for the
    **Player** node, though, so here’s what we need to do:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他两个主要问题，我们不得不比仅仅改变对象位置更深入地挖掘。不过，我们首先需要更新用于**Player**节点的脚本，所以我们需要做以下事情：
- en: Select the root node in `Player.tscn`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player.tscn`中选择根节点。
- en: Swap its script with `Clara.gd` from the `Scripts` folder.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其脚本与`Scripts`文件夹中的`Clara.gd`交换。
- en: Press *F5* and enjoy seeing Clara walking around as a normal person should.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F5*键，享受看到克拉拉像普通人一样四处走动的场景。
- en: Rejoice—she’s walking!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼——她开始走路了！
- en: How did it happen so quickly? We will devote the rest of this section to discovering
    which changes the `Player.gd` script has received to accommodate the new behavior
    we are experiencing and—undoubtedly—enjoying.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它怎么会这么快就发生了？我们将在本节的剩余部分致力于发现`Player.gd`脚本接收了哪些更改以适应我们正在经历并无疑享受的新行为。
- en: Understanding how Clara looks around
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解克拉拉如何四处张望
- en: An incremental and iterative workflow is the short and non-technical answer
    to understanding how Clara looks around, and it’s something we advise you to keep
    in mind when tasks seem monumentally big at first. For example, we were initially
    concerned with basic movement, which was achieved within the `Player.gd` script.
    At some point, when you know basic test systems are working, it’s time to take
    things to the next level. That’s what happened with the `Clara.gd` script.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 递增和迭代的工作流程是理解克拉拉如何环顾四周的简短且非技术性的答案，这是我们建议你在任务最初看起来巨大无比时牢记在心的事情。例如，我们最初关注的是基本移动，这在`Player.gd`脚本中实现。在某个时候，当你知道基本测试系统正在工作时，就是将事情提升到下一个层次的时候了。这就是`Clara.gd`脚本发生的事情。
- en: 'We’ll now explain the steps we have taken to turn the basic sliding movement
    into a more elaborate walking animation. As far as having new variables is concerned,
    we are using a simple flag: `is_moving`. We keep track of this flag in order to
    understand whether Clara is moving or not. The use of this new variable will soon
    be discussed in the context of some other changes we have made.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将解释我们将基本滑动动作转变为更复杂的行走动画所采取的步骤。就引入新变量而言，我们使用了一个简单的标志：`is_moving`。我们跟踪这个标志，以便了解克拉拉是否在移动。这个新变量的使用将在我们做出的其他一些更改的背景下进行讨论。
- en: New term – flag
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 新术语 - 标志
- en: In the programming world, a flag is a variable that means a certain condition
    has been satisfied. It’s often used to determine a system’s behavior, like an
    electric switch with a false/true or off/on states, hence they are often called
    **Boolean** flags. However, it is possible for a flag to have different kinds
    of predetermined values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，标志是一个表示特定条件已满足的变量。它通常用于确定系统的行为，就像一个具有假/真或开/关状态的电开关，因此它们通常被称为**布尔**标志。然而，标志可能具有不同种类的预定值。
- en: A natural behavior for Clara would be to look in the direction the mouse cursor
    is. Let us remind you, once more, that although the cursor is moving over our
    monitor’s 2D surface, we need to do essential projections into the 3D space to
    find the proper direction. We were already doing that in the `find_path` function
    inside the `Player.gd` script. Since we now want a similar raycasting done for
    determining where Clara is supposed to look, we extracted those common lines from
    `find_path` to its own function, `get_destination`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 克拉拉的自然行为是朝向鼠标光标的方向看。让我们再次提醒你，尽管光标正在我们的显示器2D表面上移动，但我们需要将基本投影到3D空间中，以找到正确的方向。我们在`Player.gd`脚本中的`find_path`函数中已经做了这件事。既然我们现在想要为确定克拉拉应该朝向哪里进行类似的射线投射，我们就从`find_path`中提取了那些常见的行，将其放入自己的函数`get_destination`中。
- en: Hence, the more common uses and repetitions you can find in your code, the better
    it is to separate them into their own functions. This was something we intentionally
    ignored in the `Player.gd` case for simplicity’s sake. However, we now have both
    the `find_path` and `turn_to` functions depending on `get_destination`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你在代码中能找到的更常见用途和重复，将它们分离成它们自己的函数会更好。在`Player.gd`案例中，为了简化，我们故意忽略了这一点。然而，我们现在既有`find_path`函数，也有`turn_to`函数依赖于`get_destination`。
- en: 'Just as `find_path` is piggybacking on the `_unhandled_input` function, the
    `turn_to` function is also using the same mouse `event`. Speaking of the `turn_to`
    function, let’s take a closer look at it here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`find_path`依赖于`_unhandled_input`函数一样，`turn_to`函数也在使用相同的鼠标`event`。说到`turn_to`函数，让我们在这里更仔细地看看它：
- en: '[PRE4]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First of all, although we haven’t yet seen where the `moving` flag is set, if
    Clara is moving, we wouldn’t want her to keep looking around. So, we have an early
    `return` statement to terminate the turning behavior. Then, once we determine
    a suitable direction via the `get_destination` function, we trigger Godot’s built-in
    `look_at` method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尽管我们还没有看到`moving`标志被设置在哪里，如果克拉拉在移动，我们不想让她继续四处张望。因此，我们有一个早期的`return`语句来终止转向行为。然后，一旦我们通过`get_destination`函数确定了一个合适的方向，我们就触发Godot的内置`look_at`方法。
- en: The logic is simple, but the math to determine the `direction` vector in `turn_to`
    might need a bit more explanation. Normally, the value from `get_destination`
    would have been enough, but we seem to be multiplying the return value with another
    vector and then adding it to another vector. This is because the destination given
    by `get_destination` also includes the *y* axis in the 3D space. We want Clara
    to keep her posture the same; in other words, we don’t want her to look up or
    down. Those two vector operations are required so that she doesn’t rotate in an
    awkward way.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单，但确定`turn_to`中的`direction`向量的数学可能需要更多的解释。通常，`get_destination`的值就足够了，但看起来我们似乎是将返回值与另一个向量相乘，然后将其添加到另一个向量中。这是因为`get_destination`给出的目的地也包含了3D空间中的*y*轴。我们希望克拉拉保持她的姿势不变；换句话说，我们不想让她向上或向下看。这两个向量操作是必要的，这样她就不会以一种尴尬的方式旋转。
- en: You can see the weird behavior yourself by removing the vector operations and
    only keeping the `get_destination` function. When you move your mouse cursor near
    Clara’s body, she may suddenly pivot around her feet and sometimes even flip upside
    down or sideways. The intricacies due to projections between 2D and 3D are something
    you’ll have to account for in the future, and it’s a common occurrence in controlling
    game characters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过移除向量操作并仅保留`get_destination`函数来亲自看到这种奇怪的行为。当你将鼠标光标移到克拉拉的身体附近时，她可能会突然围绕自己的脚旋转，有时甚至翻转过来或侧身。由于2D和3D之间的投影而产生的复杂性，你将来必须考虑到这一点，这在控制游戏角色时是一个常见的问题。
- en: It’s nice that Clara is facing where the mouse cursor is. It’s also a separate
    mechanism because she can do so without moving, as you may have already tested
    with the preceding code block. It would be nice if she kept looking where she
    was going while walking. This will be done in the enhanced version of the `move_along`
    function. Let’s see how we improved it in this new version.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，克拉拉正面对着鼠标光标所在的位置。这还是一个独立的机制，因为她可以在不移动的情况下做到这一点，正如你可能已经通过前面的代码块测试过了。如果她在行走时也能保持看向目的地，那就更好了。这将在`move_along`函数的增强版本中实现。让我们看看在这个新版本中我们是如何改进的。
- en: Adding a looking behavior to moving functionality
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向移动功能添加观察行为
- en: It is nice to see Clara looking around while she’s standing still, but we will
    also want her to face the destination she’s walking to. For example, if you click
    near the crates by the wall (more like the right-hand side of the screen), she
    should walk straight until she clears the pier, then turn and look right, and
    then keep walking. Similarly, while she’s in this new spot, if you click somewhere
    far away such as near the stag statue or the pier again, she should turn around
    and walk back in a natural way.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当克拉拉静止站立时，看到她四处张望是件好事，但我们还希望她面对她要走的目的地。例如，如果你在墙边的板条箱附近（更像是屏幕的右侧）点击，她应该一直走到她清除了码头，然后转向向右看，然后继续前进。同样，当她在这个新位置时，如果你在远处点击某个地方，比如鹿雕像附近或码头再次，她应该转身并以自然的方式走回来。
- en: This kind of behavior can easily be added inside the `move_along` function.
    The way it is, that function already determines how many steps there are left
    along the path Clara should take. As she’s walking toward the point on the path,
    she may as well look at where she is going. That’s why we have a simple `look_at`
    function call after `move_and_slide` in the `move_along` function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可以很容易地添加到`move_along`函数中。按照现在的样子，该函数已经决定了克拉拉应该沿着路径走的剩余步数。当她朝着路径上的点走去时，她不妨看看她要去哪里。这就是为什么我们在`move_along`函数中的`move_and_slide`之后有一个简单的`look_at`函数调用。
- en: Other useful KinematicBody functions
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的KinematicBody函数
- en: 'We have been using the built-in `move_and_slide` function of the `KinematicBody`
    class. There is a useful function in the same class that might be helpful in levels
    where the player would like to reach an elevated location by following a slope:
    `move_and_slide_with_snap`. Similarly, you might want to check whether the player
    should perform the next move. If that is the case, the `test_move` method might
    be handy.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用`KinematicBody`类的内置`move_and_slide`函数。在同一个类中有一个有用的函数，可能在玩家想要通过跟随斜坡到达更高位置的场景中很有帮助：`move_and_slide_with_snap`。同样，你可能想要检查玩家是否应该执行下一步。如果是这样，`test_move`方法可能很有用。
- en: 'Also, the fate of `is_moving` gets decided in the following lines of code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`is_moving`的状态在以下代码行中确定：
- en: '[PRE5]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that, similar to how we do it in `Player.gd`, the `if` block checks whether
    there are steps left along the path. It’s exactly at this point we can set the
    state of the `is_moving` flag. Consequently, unlike the original version, the
    new `move_along` function’s `if` block is making sure the moving logic is turned
    off when there is no path left for Clara to walk.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与我们在`Player.gd`中做的那样，`if`块检查路径上是否还有剩余的步数。正是在这一点上，我们可以设置`is_moving`标志的状态。因此，与原始版本不同，新的`move_along`函数的`if`块确保当克拉拉没有剩余路径可走时，移动逻辑被关闭。
- en: If the player clicks a different spot and there is a new path determined, then
    we turn on the moving flag. As long as there are midpoints for Clara to follow,
    she’ll follow the same steps we’ve described—face the right direction, walk the
    necessary distance, face the next direction, walk, rinse, and repeat—until she
    no longer has any more steps to take.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家点击不同的位置并且确定了一条新路径，那么我们将打开移动标志。只要克拉拉有中间点可以跟随，她就会遵循我们描述的相同步骤——面向正确的方向，走必要的距离，面向下一个方向，走，清洗，重复——直到她不再有任何步骤可走。
- en: Besides deciding on the state of the `is_moving` flag, there is something else
    going on in that `if` block in regard to animations. Let’s focus on that in the
    next part.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 除了决定`is_moving`标志的状态外，在`if`块中还有关于动画的其他一些事情在进行。让我们在下一部分中关注这一点。
- en: Playing the right action for Clara
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为克拉拉播放正确的动作
- en: We’ve already seen how actions are related to animations in the *Separating
    actions* section of [*Chapter 7*](B17473_07.xhtml#_idTextAnchor112), *Importing
    Blender Assets into Godot*. They are like what atoms are to molecules. So, when
    we want to trigger an animation for a model, we actually mean to trigger a particular
    action. We’ll finally utilize this notion and put Clara in action.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第7章*](B17473_07.xhtml#_idTextAnchor112)的*分离动作*部分中看到动作与动画之间的关系，*将Blender资产导入Godot*。它们就像原子对分子一样。因此，当我们想要触发一个模型的动画时，我们实际上意味着要触发一个特定的动作。我们将最终利用这个概念，让克拉拉行动起来。
- en: We have seen how the improvements we made to the `Player.gd` script have added
    extra flavor to Clara’s behavior. That being said, she could also benefit from
    a touch-up in the animation department. That’s precisely what’s also happening
    inside the `move_along` function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们对`Player.gd`脚本所做的改进如何为克拉拉的行为增添了额外的风味。话虽如此，她也可以从动画部门的微调中受益。这正是`move_along`函数内部正在发生的事情。
- en: We already know how to determine whether Clara should move or not, and we are
    keeping track of that with the `is_moving` flag. Subsequently, that’s the right
    moment to trigger the required action for her. Thus, when she’s no longer supposed
    to move, we trigger her `is_moving` is set to `true`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何确定克拉拉是否应该移动，并且我们通过`is_moving`标志来跟踪这一点。因此，这是触发她所需动作的正确时机。因此，当她不再应该移动时，我们触发她的`is_moving`设置为`true`。
- en: When we made `Clara.glb` part of the `Player.tscn` scene, and it turned into
    a **Clara** node, an **AnimationPlayer** node already came within it with all
    of Clara’s actions set up. The code we have written so far is aware of exactly
    where this **AnimationPlayer** node is in the internal structure. Should you import
    a different model with a different **Scene** tree, then you might have to alter
    your code to find the right path to the **AnimationPlayer** node.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Clara.glb`作为`Player.tscn`场景的一部分，并变成一个**克拉拉**节点时，一个**AnimationPlayer**节点已经包含在内，并且已经设置了克拉拉的所有动作。我们迄今为止编写的代码已经知道这个**AnimationPlayer**节点在内部结构中的确切位置。如果您导入了一个具有不同**Scene**树的模型，那么您可能需要修改您的代码以找到到达**AnimationPlayer**节点的正确路径。
- en: 'It’s hard to convey an animation via the static pages of a book, but when we
    move Clara near the column approaching our camera, this is what it looks like:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过书籍的静态页面传达动画是困难的，但当我们把克拉拉移到靠近相机的柱子附近时，这就是它的样子：
- en: '![Figure 12.14 – Clara can now move around the level ](img/Figure_12.14_17473.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 克拉拉现在可以在关卡中移动](img/Figure_12.14_17473.jpg)'
- en: Figure 12.14 – Clara can now move around the level
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 克拉拉现在可以在关卡中移动
- en: Also, notice how the light conditions in the scene are affecting her model when
    she walks in darker and brighter spots. In the next chapter, we’ll turn off some
    of the light sources. So, as she or the player is walking around, we can use the
    torch she’s holding to illuminate the scene.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意场景中的光线条件是如何影响她在暗淡和明亮的地方行走时的模型的。在下一章中，我们将关闭一些光源。因此，当她或玩家在周围行走时，我们可以使用她持有的火炬来照亮场景。
- en: 'We couldn’t finish the animation topic without mentioning an advanced subject:
    blending animations. We will not cover it in great detail, but it is worth mentioning
    it for more advanced cases of animations you would like to use in your projects.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在动画主题中不能不提到一个高级主题：混合动画。我们不会详细讨论它，但对于您想在项目中使用的更高级的动画案例来说，它值得提及。
- en: Blending animations or actions
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合动画或动作
- en: After a while, the names that are used in most computer-related things may start
    to seem like they have something to do with each other. We used Blender in the
    first several chapters to build assets, textures, animations, and likewise. The
    blending we are now going to talk about has nothing to do with Blender itself.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，大多数与计算机相关的事物中使用的名称可能开始看起来像它们之间有某种联系。在前几章中，我们使用了Blender来构建资产、纹理、动画等等。我们现在将要讨论的混合与Blender本身无关。
- en: Our point-and-click adventure game is very simple so far. Clara plays the `Clara.gd`
    script and incorporate these other actions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的点按式冒险游戏目前非常简单。Clara运行`Clara.gd`脚本并整合这些其他动作。
- en: At some point, when you have a much more complex system where the actions you
    are triggering come to an end to give room to another action, you may notice that
    these actions abruptly start and end. Then, imagine how the crossfade functionality
    in an audio player makes the whole experience more pleasant when a song track
    changes to another. What if you had a way to transition the end of an action smoothly
    to the beginning of the next action? You can easily achieve that for animations
    with the **AnimationTree** node.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，当您拥有一个更复杂的系统，其中您触发的动作结束时为另一个动作腾出空间时，您可能会注意到这些动作会突然开始和结束。然后，想象一下音频播放器中的交叉淡入功能如何使歌曲曲目切换时整个体验更加愉快。如果您有一种方法可以平滑地将一个动作的结束过渡到下一个动作的开始，那会怎么样？您可以使用**AnimationTree**节点轻松实现这一点。
- en: Unfortunately, the page count is limited for us to cover such an advanced topic.
    That being said, the official documentation has a nice and long tutorial page
    dedicated to this very subject. It also comes with plenty of animated GIFs that
    you can’t possibly experience on the static pages of a book. So, in the end, you
    might be better off exploring how to blend animations by following the instructions
    at [https://docs.godotengine.org/en/3.4/tutorials/animation/animation_tree.xhtml](https://docs.godotengine.org/en/3.4/tutorials/animation/animation_tree.xhtml).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的页面数量有限，无法涵盖如此高级的主题。尽管如此，官方文档有一个关于这个主题的非常棒且内容丰富的教程页面。它还附带了许多动画GIF，这些动画在书籍的静态页面上是无法体验到的。因此，最终，您可能更倾向于通过遵循[https://docs.godotengine.org/en/3.4/tutorials/animation/animation_tree.xhtml](https://docs.godotengine.org/en/3.4/tutorials/animation/animation_tree.xhtml)上的说明来探索如何混合动画。
- en: Blending animations is heavily used in high-pace action games when transitioning
    between different attack and run states should look more seamless. In our current
    situation, we are not missing out much by not having this kind of functionality.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在高速动作游戏中，混合动画被广泛用于在不同攻击和奔跑状态之间过渡时，应该看起来更加流畅。在我们当前的情况下，我们没有这种功能并不会损失太多。
- en: We have made great strides so far in our point-and-click adventure game. Let’s
    wrap up and count our victories.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在点按式冒险游戏中取得了很大的进展。让我们总结一下，数一数我们的胜利。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter finally covered the long-due camera topic we’ve been waiting to
    tackle since [*Chapter 4*](B17473_04.xhtml#_idTextAnchor060), *Adjusting Cameras
    and Lights*. You now have multiple options to choose from, from a simple **Camera**
    type to an **InterpolatedCamera** type that follows a target. Should you want
    to get fancy and dip your toes in VR, you also have **ARVRCamera** at your disposal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章终于涵盖了我们期待已久的相机主题，即从[*第4章*](B17473_04.xhtml#_idTextAnchor060)的*调整相机和灯光*开始。现在您有多种选择，从简单的**相机**类型到跟随目标的**插值相机**类型。如果您想尝试一些高级功能并涉足VR，您还可以使用**ARVRCamera**。
- en: 'As you now had a proper camera showing you the game world as opposed to seeing
    things within the editor, it was the right time to investigate how to interact
    with the world itself. To that end, we presented **raycasting** as a possible
    solution but quickly dismissed it in favor of using collision detection, which
    provides more flexibility and precision. We used this technique to detect a click
    on a specific game object: a parchment. During this effort, you used **signals**
    as a way of interpreting the player’s click as a trigger to turn on the note.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你现在有了合适的相机，可以展示游戏世界，而不是在编辑器内看到事物，现在是调查如何与世界本身互动的合适时机。为此，我们提出了**光线投射**作为可能的解决方案，但很快又放弃了它，转而使用碰撞检测，这提供了更大的灵活性和精度。我们使用这种技术来检测特定游戏对象（羊皮纸）上的点击。在这个过程中，你使用**信号**作为解释玩家点击作为触发器来打开音符的方式。
- en: Next, you looked into creating a simple game character and moving it around
    the level. Sometimes, the game design is missing key elements, and other times,
    the level might need some more help. Once you, as a solo developer or as a team,
    are happy with the direction the game is going, then you can up the ante by introducing
    more complex systems.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你研究了创建一个简单的游戏角色并在关卡中移动它。有时，游戏设计可能缺少关键元素，而有时关卡可能需要更多帮助。一旦你作为一个独立开发者或作为团队对游戏的方向感到满意，你就可以通过引入更复杂的系统来提高难度。
- en: That’s exactly what happened in between testing `Player.gd` and improving it
    with the more advanced `Clara.gd` script. In the end, you were able to find a
    suitable position in the world for Clara to move and do this by using the proper
    animation cycle. Since you’ve covered the essentials, it’s now up to you to enhance
    the script if you want to use more actions and special conditions for player interaction
    with the world.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是测试`Player.gd`并在更高级的`Clara.gd`脚本中改进它之间发生的事情。最终，你能够找到适合Clara在世界中移动的位置，并通过使用适当的动画周期来实现这一点。既然你已经掌握了基础知识，现在如果你想使用更多动作和特殊条件来与玩家进行世界交互，那么就需要你自己来增强脚本。
- en: In the next chapter, we’ll introduce a few more tools that will add to the interactivity
    we have been building, such as playing sounds, conditionally triggering certain
    events, and switching to another level.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些额外的工具，这些工具将增加我们一直在构建的交互性，例如播放声音、有条件地触发某些事件以及切换到另一个关卡。
- en: Further reading
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Although we taught you how to technically set up a camera, there is a whole
    other artistic side to picking the best camera settings. You might want to check
    out online courses and books that cover topics such as composition and storytelling.
    A few examples are provided here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们教了你如何从技术上设置相机，但在选择最佳相机设置方面还有一个完整的艺术层面。你可能想查看涵盖诸如构图和叙事等主题的在线课程和书籍。这里提供了一些例子：
- en: '[https://www.udemy.com/course/composition-and-perspective-for-stunning-visual-art/](https://www.udemy.com/course/composition-and-perspective-for-stunning-visual-art/)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.udemy.com/course/composition-and-perspective-for-stunning-visual-art/](https://www.udemy.com/course/composition-and-perspective-for-stunning-visual-art/)'
- en: '[https://www.learnsquared.com/courses/visual-storytelling](https://www.learnsquared.com/courses/visual-storytelling)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.learnsquared.com/courses/visual-storytelling](https://www.learnsquared.com/courses/visual-storytelling)'
- en: '[https://www.learnsquared.com/courses/production-concept-art](https://www.learnsquared.com/courses/production-concept-art)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.learnsquared.com/courses/production-concept-art](https://www.learnsquared.com/courses/production-concept-art)'
- en: '[https://www.cgmasteracademy.com/courses/93-composition-for-concept-art-and-illustration/](https://www.cgmasteracademy.com/courses/93-composition-for-concept-art-and-illustration/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.cgmasteracademy.com/courses/93-composition-for-concept-art-and-illustration/](https://www.cgmasteracademy.com/courses/93-composition-for-concept-art-and-illustration/)'
- en: 'If the code in the `Player.gd` and `Clara.gd` files look very similar, and
    if it’s hard to compare line by line, there is an online tool you can use that
    can help you see and highlight the differences: http://www.tareeinternet.com/scripts/comparison-tool/.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Player.gd`和`Clara.gd`文件中的代码看起来非常相似，并且很难逐行比较，那么你可以使用一个在线工具来帮助你查看和突出显示差异：http://www.tareeinternet.com/scripts/comparison-tool/。
- en: Our game doesn’t involve enemy characters that follow our player, but it will
    follow a similar approach. For example, once the enemy detects the player, it
    will also have to do pathfinding for finding the player’s position and moving
    toward it. A lot of video-game AI books cover player detection and seeking topics
    such as the example we gave. So, since most AI topics are generally universal,
    don’t shy away from reading a wide variety of material. You can always apply the
    insight you gain elsewhere later in your Godot projects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏不涉及跟随玩家的敌人角色，但它将采用类似的方法。例如，一旦敌人检测到玩家，它也必须进行路径查找以找到玩家的位置并向其移动。许多视频游戏AI书籍都涵盖了玩家检测和寻找等主题，例如我们给出的例子。因此，由于大多数AI主题通常是通用的，所以不要害怕阅读各种材料。你总是可以在你的Godot项目中稍后应用你在其他地方获得的见解。
