- en: Error – Handling with Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: In this final chapter, we will learn how to perform error handling while system
    programming. Specifically, three different methods will be presented. The first
    method will demonstrate how to use POSIX-style error handling, while the second
    method will demonstrate how to use the standard C-style set jump exceptions. The
    third method will demonstrate how to use C++ exceptions, and the pros and cons
    of each approach will be discussed. Finally, this chapter will conclude with an
    example that demonstrates how C++ exceptions outperform POSIX-style error handling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们将学习如何在系统编程时执行错误处理。具体来说，将介绍三种不同的方法。第一种方法将演示如何使用 POSIX 风格的错误处理，而第二种方法将演示如何使用标准的
    C 风格的 set jump 异常。第三种方法将演示如何使用 C++ 异常，并讨论每种方法的优缺点。最后，本章将以一个示例结束，演示了 C++ 异常如何优于
    POSIX 风格的错误处理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: POSIX-style error handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 风格的错误处理
- en: Exception support in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中的异常支持
- en: An example with Exception Benchmark
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带异常基准的示例
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行 C++17 的基于 Linux 的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples, and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter13).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请参见以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter13)。
- en: Error handling POSIX-style
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理 POSIX 风格
- en: 'POSIX-style error handling provides the most basic form of error handling possible,
    capable of being leveraged on almost any system, in almost any program. Written
    with standard C in mind, POSIX-style error handling takes the following form:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 风格的错误处理提供了可能的最基本的错误处理形式，几乎可以在任何系统的几乎任何程序中使用。以标准 C 为基础编写，POSIX 风格的错误处理采用以下形式：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Generally, each function called either returns `0` on `success` or `-1` on
    failure, and stores the error code into a global (non-thread safe) implementation-defined
    macro, called `errno`. The reason `0` is used for `success` is that on most CPUs,
    comparing a variable to `0` is faster than comparing a variable to any other value,
    and the `success` case is the expected case. The following example demonstrates
    how this pattern is used:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个调用的函数要么在 `success` 时返回 `0`，要么在失败时返回 `-1`，并将错误代码存储在一个全局（非线程安全）的实现定义的宏中，称为
    `errno`。使用 `0` 作为 `success` 的原因是，在大多数 CPU 上，将变量与 `0` 进行比较比将变量与任何其他值进行比较更快，而 `success`
    情况是预期的情况。以下示例演示了如何使用这种模式：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we create a function called `myfunc()`, which takes an integer
    and returns an integer. The function accepts any value as its parameter as *valid* except
    for `42`. If `42` is provided as the input function, the function returns `-1`
    and sets `errno` to `EINVAL`, which states that the function was provided an invalid
    argument.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `myfunc()` 的函数，它接受一个整数并返回一个整数。该函数接受任何值作为其参数，除了 `42`。如果将 `42`
    作为输入函数，函数将返回 `-1` 并将 `errno` 设置为 `EINVAL`，表示函数提供了一个无效的参数。
- en: 'In the `main` function, we call `myfunc()`, both with a valid input, and an
    invalid input and test, to see whether an error has occurred, resulting in `success` for
    the valid input and `failure: Invalid argument` for the invalid input. It should
    be noted that we leverage the `strerror()` function, which converts POSIX-defined
    error codes into their string equivalent. It should also be noted that this simple
    example will be leveraged throughout this chapter as we build and improve upon
    it.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `main` 函数中，我们调用 `myfunc()`，分别使用有效输入和无效输入进行测试，以查看是否发生了错误，有效输入返回 `success`，无效输入返回
    `failure: Invalid argument`。值得注意的是，我们利用了 `strerror()` 函数，将 POSIX 定义的错误代码转换为它们的字符串等价物。还应该注意的是，这个简单的例子将在本章中被利用，并在此基础上进行改进。'
- en: 'The first issue that arises from this simple example is that the output of
    the function is leverage for error handling, but what if the function needs to
    output a value other than an error code? There are two ways to handle this. The
    first way to handle this is to constrain valid output of the function (that is,
    not all outputs are considered valid). This is generally how POSIX handles this
    problem. The following example demonstrates this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的例子中出现的第一个问题是函数的输出被用于错误处理，但如果函数需要输出除错误代码以外的值怎么办？有两种处理方法。处理这个问题的第一种方法是限制函数的有效输出（即，并非所有输出都被认为是有效的）。这通常是
    POSIX 处理这个问题的方式。以下示例演示了这一点：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we create a `myfunc()` function that returns a `handle` given
    valid input, and `0` given invalid input. This is similar to a lot of POSIX functions
    that return file handles. In this case, the notion of `success` is reversed, and,
    in addition, a handle may never take on a value of `0`, as this is used to represent
    an error. Another possible method for providing error handling while also providing
    function output is to return more than one value, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个 `myfunc()` 函数，给定有效输入返回一个 `handle`，给定无效输入返回 `0`。这类似于很多返回文件句柄的
    POSIX 函数。在这种情况下，`success` 的概念被颠倒了，此外，句柄可能永远不会取值为 `0`，因为这用于表示错误。另一种同时提供错误处理和函数输出的可能方法是返回多个值，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we return `std::pair{}` (which is really just a struct
    with two values). The first value in the pair is our handle, while the second
    value in our pair determines whether the handle is valid. Using this mechanism,
    `0` could be a valid handle as we have a way to tell the user of this function
    whether it is valid. Another way to do this is to provide the function with an
    argument that acts as an *output* and not as an *input*, a practice that is discouraged
    by the C++ Core Guidelines. This is depicted by means of the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们返回了`std::pair{}`（实际上只是一个具有两个值的结构体）。对中的第一个值是我们的句柄，而对中的第二个值确定了句柄是否有效。使用这种机制，`0`可能是一个有效的句柄，因为我们有一种方法告诉这个函数的用户它是否有效。另一种方法是为函数提供一个作为*输出*而不是*输入*的参数，这种做法是C++核心指南不推荐的。这通过以下代码表示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `myfunc()` takes two arguments, with the second argument accepting
    an integer intended to store an error. If the error integer remains at `0`, no
    error has occurred. If, however, the error integer is set, an error has occurred,
    which we detect and output the failure as a result. Although this method is discouraged
    by the C++ Core Guidelines (mainly because there are better ways to perform error
    handling in C++), this method has the added benefit that the error integer is
    thread-safe, unlike the use of `errno`, which is not thread-safe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`myfunc()`接受两个参数，第二个参数接受一个整数，用于存储错误。如果错误整数保持为`0`，则表示没有发生错误。然而，如果错误整数被设置，就表示发生了错误，我们会检测并输出失败的结果。尽管这种方法不被C++核心指南推荐（主要是因为在C++中有更好的方法来处理错误），但这种方法的额外好处是错误整数是线程安全的，而不像`errno`的使用那样不是线程安全的。
- en: 'Besides the verbosity of POSIX-style error handling and a tendency for error
    values to be ignored, the biggest issue with POSIX-style error handling is the
    numerous branch statements that must be executed continuously in the unlikely
    event that an error might occur. The following example demonstrates this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了POSIX风格错误处理的冗长和错误值被忽略的倾向之外，最大的问题是必须持续执行大量分支语句，以防错误可能发生的情况。下面的例子演示了这一点：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we create the same `myfunc()` function that returns an error
    if the input provided is `42`. We then call this function from a function that
    is called by another function (that is, we are making nested calls to our `myfunc()`,
    a practice that is highly likely to occur while system programming). Since `myfunc()`
    might return an error, and our nested functions are unable to handle the error,
    they must also return an error code, which, in turn, must also be checked. The
    bulk of the code in this example provides nothing more than error handling logic,
    designed to forward the results of an error to the next function in the hope that
    the next function is capable of handling the error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了相同的`myfunc()`函数，如果输入为`42`，则返回一个错误。然后我们从另一个函数中调用这个函数（也就是说，我们在`myfunc()`中进行了嵌套调用，这在系统编程中很可能会发生）。由于`myfunc()`可能返回一个错误，而我们的嵌套函数无法处理错误，它们也必须返回一个错误代码，然后必须对其进行检查。在这个例子中，大部分代码只提供了错误处理逻辑，旨在将错误的结果转发给下一个函数，希望下一个函数能够处理错误。
- en: This nested error forwarding may be referred to as `stack unwinding`. Each time
    we call a function that could return an error, we check whether an error has occurred
    and we return the result to the next function in the stack. This process of unwinding
    the call stack is repeated until we get to a function in the call stack that is
    capable of handling the error. In our case, this is the `main()` function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套的错误转发可能被称为“堆栈展开”。每次调用可能返回错误的函数时，我们都会检查是否发生了错误，并将结果返回给堆栈中的下一个函数。这个展开调用堆栈的过程会重复，直到我们到达堆栈中能够处理错误的函数为止。在我们的情况下，这是`main()`函数。
- en: The problem with POSIX-style error handling is that stack unwinding must be
    performed manually, and thus, this code is executed continuously in the `success` case,
    resulting in poor-performing, verbose code, as demonstrated by the preceding example,
    which checks a simple integer value in only three nested calls.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX风格的错误处理存在的问题是必须手动执行堆栈展开，因此，在“成功”情况下，这段代码会持续执行，导致性能不佳、代码冗长，正如前面的示例所示，该示例仅在三个嵌套调用中检查了一个简单的整数值。
- en: 'Finally, it should be noted that POSIX-style error handling does support **Resource
    Acquisition Is Initialization** (**RAII**), meaning objects defined in the scope
    of a function are destroyed properly the function exits in both the `success`
    case and the error case, as demonstrated in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该指出，POSIX风格的错误处理确实支持**资源获取即初始化**（**RAII**），这意味着在函数范围内定义的对象在函数退出时会被正确销毁，无论是在“成功”情况下还是错误情况下，如下例所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we create a simple class that outputs a string to
    `stdout` on destruction and creates an instance of this class in our `myfunc()`
    function. When `myfunc()` is called, both on `success` and failure, the destructor
    of the class is called properly on exit. In our next error handling mechanism,
    called set jump, we will demonstrate how a lot of the issues with POSIX-style
    error handling are addressed while also demonstrating that the key limitation
    with set jump is a lack of RAII support, possibly resulting in undefined behavior.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个简单的类，在销毁时向`stdout`输出一个字符串，并在我们的`myfunc()`函数中创建了这个类的一个实例。当调用`myfunc()`时，无论是在“成功”还是失败时，类的析构函数都会在退出时被正确调用。在我们下一个错误处理机制中，称为设置跳转，我们将演示如何解决POSIX风格错误处理的许多问题，同时也演示了设置跳转的关键限制是缺乏RAII支持，可能导致未定义的行为。
- en: Learning about set jump exceptions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于设置跳转异常
- en: 'Set jump exceptions may be viewed as C-style exceptions. Like C++-style exceptions,
    set jump exceptions provide the user with the ability to set a place in the code
    to return to in the event of an error, and a method for generating the exception
    that performs the jump. The following code example demonstrates this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Set jump异常可以看作是C风格的异常。与C++风格的异常一样，set jump异常提供了在出现错误时设置返回代码的位置以及执行跳转的异常生成方法。以下代码示例演示了这一点：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we create our `myfunc()` function, but instead of returning
    an error code, we execute a long jump, which acts like a *goto*, jumping to the
    last place in the call stack that a call to `setjmp()` was made. In our `main`
    function, we first call `setjmp()` to place our return point, and then we make
    calls to our `myfunc()` function with both a valid input and an invalid input.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了`myfunc()`函数，但是不返回错误代码，而是执行了long jump，它像*goto*一样，跳转到调用`setjmp()`的调用栈中最后一次调用的位置。在我们的`main`函数中，我们首先调用`setjmp()`来设置返回点，然后使用有效输入和无效输入调用我们的`myfunc()`函数。
- en: 'Immediately, we have addressed several issues with POSIX-style error handling.
    As can be seen in the preceding example, the code is far less complicated, removing
    the need to check for error conditions. In addition, `myfunc()` returns a void,
    as no error code needs to be returned, meaning there is no longer a need to constrain
    the output of a function to support an error case, as can be seen in the following
    example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了POSIX风格错误处理的几个问题。如前面的例子所示，代码变得简单得多，不再需要检查错误条件。此外，`myfunc()`返回一个void，不再需要返回错误代码，这意味着不再需要限制函数的输出以支持错误情况，如下例所示：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `myfunc()` returns a *handle*, and the error case is handled
    using a set jump exception. As a result, `myfunc()` may return any value, and
    the user of the function knows whether a handle is valid based on whether a long
    jump was called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`myfunc()`返回一个*handle*，并且使用set jump异常处理错误情况。因此，`myfunc()`可能返回任何值，函数的使用者根据是否调用了long
    jump来判断handle是否有效。
- en: 'Since a return value of `myfunc()` is no longer needed, we also no longer need
    to check the return value of `myfunc()`, meaning our nested example is greatly
    simplified, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不再需要`myfunc()`的返回值，我们也不再需要检查`myfunc()`的返回值，这意味着我们的嵌套示例大大简化，如下所示：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As can be seen, the only error logic in this example exists in `myfunc()` checking
    to ensure the input is valid. The remaining error logic has been removed. Not
    only does this result in code that is easier to read and maintain, but the resulting
    code also performs better, as we are no longer executing branch statements, but
    manually unwinding the call stack by hand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，这个例子中唯一的错误逻辑存在于`myfunc()`中，用于确保输入有效。其余的错误逻辑已经被移除。这不仅使得代码更易于阅读和维护，而且由于不再执行分支语句，而是手动展开调用栈，因此结果代码的性能也更好。
- en: 'Another benefit of using set jump exceptions is that it is possible to create
    thread-safe error handling. In our previous example, we set `errno` in the event
    of an error, which is then read when we reach the code that is capable of handling
    the error. With set jump, `errno` is no longer needed as we can return the error
    code in the long jump itself, using the following approach:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用set jump异常的另一个好处是可以创建线程安全的错误处理。在我们之前的例子中，我们在出现错误时设置了`errno`，然后在到达能够处理错误的代码时读取它。使用set
    jump，不再需要`errno`，因为我们可以在long jump本身中返回错误代码，采用以下方法：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, instead of setting `errno` and returning `-1` in our
    long jump, we return the error code in our long jump, and, using the C++17 syntax,
    store the value from the long jump in our call to set jump and make sure this
    value is greater than `0`. The first time set jump is called, it returns `0` as
    no error has occurred yet, meaning the branch is not taken. If, however, set jump
    is called a second time (when our long jump is called), the value that is placed
    in the call to our long jump is returned instead, resulting in the branch being
    taken and an error reported in a thread-safe manner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不再在long jump中设置`errno`并返回`-1`，而是在long jump中返回错误代码，并且使用C++17语法，在调用set
    jump时存储long jump的值，并确保这个值大于`0`。第一次调用set jump时，由于尚未发生错误，它返回`0`，意味着不会执行分支。然而，如果第二次调用set
    jump（当我们的long jump被调用时），则返回long jump中放置的值，导致执行分支并以线程安全的方式报告错误。
- en: Note that the only modification we need to make to our example is that we must
    pass the jump buffer of every function, which is highly inconvenient, especially
    in the case of nested function calls. In our previous examples, the jump buffer
    was stored globally, which is not thread-safe, but is more convenient, and results
    in cleaner code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要对我们的例子进行的唯一修改是必须传递每个函数的跳转缓冲区，这非常不方便，特别是在嵌套函数调用的情况下。在我们之前的例子中，跳转缓冲区是全局存储的，这不是线程安全的，但更方便，代码更清晰。
- en: In addition to an awkward mechanism for providing thread safety, the main disadvantage
    to using set jump for error handling is a lack of support for RAII, meaning objects
    created in the scope of a function may not have their destructors called on exit
    (a problem that is actually implementation-specific). The reason destructors are
    not called is that the function never technically exits. set jump/long jump stores
    the instruction pointer and non-volatile registers in the jump buffer on a call
    to set jump.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供线程安全的笨拙机制之外，使用set jump进行错误处理的主要缺点是不支持RAII，这意味着在函数范围内创建的对象在退出时可能不会调用它们的析构函数（这实际上是特定于实现的问题）。析构函数不会被调用的原因是函数从技术上讲从未退出。set
    jump/long jump在调用set jump时将指令指针和非易失性寄存器存储在跳转缓冲区中。
- en: 'When a long jump is performed, the application overwrites the instruction pointer
    and CPU registers with the values stored in the jump buffer and then continues
    execution as if the code after the call to `setjump()` was never executed. For
    this reason, the destructors of an object are never executed, as demonstrated
    in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行长跳转时，应用程序会用跳转缓冲区中存储的值覆盖指令指针和CPU寄存器的值，然后继续执行，就好像调用`setjump()`后的代码从未执行过一样。因此，对象的析构函数永远不会被执行，就像下面的例子中所示的那样：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we create a simple class that outputs a string to `stdout`
    when the class is destroyed. We then create an instance of this class in `myfunc()`.
    In the `success` case, the destructor is called as `myfunc()` exits, resulting
    in the destructor being called. In the failure case, however, `myfunc()` never
    exits, resulting in the destructor not being called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个简单的类，在类被销毁时向`stdout`输出一个字符串。然后我们在`myfunc()`中创建了这个类的一个实例。在`success`情况下，当`myfunc()`退出时，析构函数被调用，导致析构函数被调用。然而，在失败的情况下，`myfunc()`永远不会退出，导致析构函数不会被调用。
- en: In the next section, we will talk about C++ exceptions that build upon set jump
    exceptions to not only provide support for RAII, but also provide the ability
    to return complex data types in the event of an error.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论C++异常，它建立在set jump异常的基础上，不仅提供了对RAII的支持，还提供了在发生错误时返回复杂数据类型的能力。
- en: Understanding exception support in C++
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解C++中的异常支持
- en: 'C++ exceptions provide a mechanism for reporting errors in a thread-safe manner,
    without the need to manually unwind the call stack, while also providing support
    for RAII and complex data types. To better understand this, refer to the following
    example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C++异常提供了一种在线程安全的方式报告错误的机制，无需手动展开调用堆栈，同时还支持RAII和复杂数据类型。要更好地理解这一点，请参考以下例子：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, our `myfunc()` function has been greatly simplified
    compared to its POSIX-style equivalent. Just like our previous examples, if the
    input provided to the function is `42`, the error is returned (in this case, it
    is actually thrown). If the input provided is not `42`, the function returns successfully.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们的`myfunc()`函数相对于其POSIX风格的等效函数大大简化了。就像我们之前的例子一样，如果提供给函数的输入是`42`，则返回错误（在这种情况下实际上是抛出）。如果提供的输入不是`42`，则函数成功返回。
- en: Like set jump, calls to `myfunc()` no longer need to check the return value
    of the function as no return value is provided. To handle the error case, we wrap
    our call to `myfunc()` in a `try...catch` block. If any of the code in the `try{}`
    block results in an exception being thrown, the `catch[}` block will be executed.
    As with most C++, the `catch` block is type-safe, meaning you must state what
    type of return data you plan to receive in the event of an exception being thrown.
    In this case, we throw `EINVAL`, which is an integer, so we catch an integer and
    output the result to `stdout`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与set jump一样，调用`myfunc()`不再需要检查函数的返回值，因为没有提供返回值。为了处理错误情况，我们将对`myfunc()`的调用包装在`try...catch`块中。如果`try{}`块中的任何代码导致抛出异常，将执行`catch{}`块。与大多数C++一样，`catch`块是类型安全的，这意味着你必须声明在抛出异常时要接收的返回数据的类型。在这种情况下，我们抛出`EINVAL`，它是一个整数，所以我们捕获一个整数并将结果输出到`stdout`。
- en: 'Similar to set jump, `myfunc()` no longer needs to return an error code, which
    means it is free to output any value it wants (meaning the output is not constrained),
    as shown in the next example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与set jump类似，`myfunc()`不再需要返回错误代码，这意味着它可以输出任何它想要的值（意味着输出不受限制），就像下一个例子中所示的那样：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, `myfunc()` returns a handle, which may take on any
    value, since the user of this function will know whether the handle is valid if
    an exception has been thrown.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`myfunc()`返回一个句柄，它可以取任何值，因为如果抛出异常，这个函数的用户将知道句柄是否有效。
- en: 'Similar to set jump, our nested case is greatly simplified compared to our
    POSIX-style error handling example, as we no longer need to manually unwind the
    call stack:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与set jump不同，我们的嵌套情况大大简化，因为我们不再需要手动展开调用堆栈：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example is similar to our set jump example, the main difference
    being that we throw an exception instead of performing a long jump, and we catch
    the exception using the `try...catch` block.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子类似于我们的set jump例子，主要区别在于我们抛出异常而不是执行长跳转，并且我们使用`try...catch`块捕获异常。
- en: 'Unlike set jump, C++ exceptions support RAII, meaning objected defined within
    the scope of a function are properly destroyed as the function exits:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与set jump不同，C++异常支持RAII，这意味着在函数范围内定义的对象在函数退出时会被正确销毁：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As can be seen in the preceding example, the destructor is called in both the
    `success` case and the failure case. To accomplish this, C++ includes a stack
    unwinder, which is capable of automatically unwinding the stack, similar to how
    we manually unwound the call stack using POSIX-style error handling, but automatically
    and without the need to execute branch statements through the code, resulting
    in optimal performance (as if error checking was not taking place). This is called
    **zero-overhead exception handling**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在上面的例子中所看到的，析构函数在`success`情况和失败情况下都被调用。为了实现这一点，C++包括一个堆栈展开器，它能够自动展开堆栈，类似于我们使用POSIX风格的错误处理手动展开调用堆栈，但是自动进行，而不需要通过代码执行分支语句，从而实现最佳性能（就好像没有进行错误检查一样）。这被称为**零开销异常处理**。
- en: The details of how the unwinder automatically unwinds the call stack without
    incurring any performance overhead, while still supporting RAII in a thread-safe
    manner, is outside the scope of this book, since this process is extremely complicated.
    However, a brief explanation follows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自动展开器如何在不产生任何性能开销的情况下自动展开调用堆栈的细节，同时仍以线程安全的方式支持RAII，这超出了本书的范围，因为这个过程非常复杂。然而，下面是一个简要的解释。
- en: When C++ exceptions are enabled and your code is compiled, a set of stack-unwinding
    instructions are also compiled for each function and placed the executable in
    a place where the C++ exception unwinder can find them. The compiler then compiles
    the code as if error handling is not taking place, and the code executes as such.
    If an exception is thrown, a thread-safe object is created that wraps the data
    being thrown and is stored. From there, the execution of the function is reversed
    using the call stack-unwinding instructions that were previously saved in the
    executable, eventually resulting in the function that threw the exception being
    exited to its caller. Before the function exits, all destructors are executed,
    and this process is continued for each function that was called in the call stack
    until a `catch{}` block is encountered that is capable of handling the data that
    was thrown.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用C++异常并编译代码时，每个函数还会为堆栈解开指令编译一组指令，并将其放置在可执行文件中，以便C++异常解开器可以找到它们。然后编译器会编译代码，就好像没有进行错误处理一样，代码会按照这样执行。如果抛出异常，将创建一个线程安全的对象来包装被抛出的数据，并将其存储。然后，使用之前保存在可执行文件中的调用堆栈解开指令来逆转函数的执行，最终导致抛出异常的函数退出到其调用者。在函数退出之前，将执行所有析构函数，并且对调用堆栈中调用的每个函数都会继续执行这个过程，直到遇到一个能够处理被抛出的数据的`catch{}`块。
- en: 'Here are some key points to keep in mind:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要记住的关键点：
- en: The unwind instructions are stored in a table in the executable. Each time a
    function's execution needs to be reversed (from a register point of view), the
    unwinder must look up these instructions for the next function in the table. This
    operation is slow (although some optimizations have been added, including the
    use of a hash table). For this reason, exceptions should never be used for control
    flow as they are slow and inefficient in the error case, while extremely efficient
    in the `success` case. C++ exceptions should only be used for error handling.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解开指令存储在可执行文件的表中。每当需要从寄存器的角度逆转函数的执行时，解开器必须在表中查找下一个函数的这些指令。这个操作很慢（尽管已经添加了一些优化，包括使用哈希表）。因此，异常不应该用于控制流，因为它们在错误情况下很慢且低效，而在`成功`情况下非常高效。C++异常应该只用于错误处理。
- en: The more functions you have in a program, or the larger the functions are (that
    is, the more the function touches the CPUs registers), the more information that
    must be stored in the unwind instructions table, resulting in a larger program.
    If C++ exceptions are never used in your program, this information is still compiled
    and stored in the application. For this reason, exceptions should be disabled
    if they are not used.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序中的函数越多，或者函数越大（即函数接触CPU寄存器越多），就需要在解开指令表中存储更多的信息，从而导致程序更大。如果程序中从未使用C++异常，这些信息仍然会被编译并存储在应用程序中。因此，如果不使用异常，应该禁用异常。
- en: 'In addition to being thread-safe, performant, and capable of supporting RAII,
    C++ exceptions all support complex data types. The typical data type that is used
    by C++ includes strings, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线程安全、高性能和支持RAII之外，C++异常还支持复杂的数据类型。C++使用的典型数据类型包括字符串，如下所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we throw a `std::runtime_error{}` exception. This
    exception is one of many, provided by C++, that inherits `std::exception`, which
    supports the ability to store a string in addition to the exception type itself.
    In the preceding example, we store `invalid val`. The preceding code is capable
    of not only detecting the provided string but also the fact that `std::runtime_exception{}`
    was thrown.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们抛出了一个`std::runtime_error{}`异常。这个异常是C++提供的许多异常之一，它继承了`std::exception`，支持除异常类型本身之外的字符串存储能力。在前面的例子中，我们存储了`invalid
    val`。前面的代码不仅能够检测到提供的字符串，还能检测到抛出了`std::runtime_exception{}`。
- en: 'In some cases, you might not know what type of exception is being thrown. This
    is usually the case when an exception that doesn''t inherit `std::exception` is
    thrown, such as raw strings and integers. To catch any exception, use the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能不知道抛出的异常类型是什么。当抛出一个不继承`std::exception`的异常时，比如原始字符串和整数，通常就会出现这种情况。要捕获任何异常，请使用以下方法：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding example, we throw an integer and we catch it using the `...` syntax,
    which states that we wish to catch all exceptions. It''s always good practice
    to have this type of catch statement at least somewhere in your code to ensure
    that all exceptions are being caught. In all of our examples throughout this book,
    we have included this `catch` statement for that very reason. The major disadvantage
    to this type of `catch{}` block is that we must use `std::current_exception()`
    to get the exception, for example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们抛出一个整数，并使用`...`语法来捕获它，表示我们希望捕获所有异常。在代码中至少有这种类型的`catch{}`语句是一个很好的做法，以确保捕获所有异常。在本书的所有示例中，我们都包含了这种`catch`语句，就是为了这个原因。这种类型的`catch{}`块的主要缺点是我们必须使用`std::current_exception()`来获取异常，例如：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we throw `std::runtime_error()` from `myfunc1()`.
    In `myfunc2()`, we catch the exception using the `...` syntax, stating that we
    wish to catch all exceptions. To get the exception, we must use `std::current_exception()`,
    which returns `std::exception_ptr{}`. `std::exception_ptr{}` is an implementation-specific
    pointer type that can be re-thrown using `std::rethrow_exception()`. Using this
    function, we can then catch the exception using the preceding standard method
    and output the message within. It should be noted that if you wish to catch an
    exception, `std::current_exception()` is not the recommended way, as you would
    need to re-throw the exception to get the `what()` from it since `std::exception_ptr`
    does not provide an interface for getting `what()`. It should also be noted that
    `std::current_exception()` will not help if an exception was thrown that is not
    a subclass of `std::exception{}`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们从`myfunc1()`抛出`std::runtime_error()`。在`myfunc2()`中，我们使用`...`语法捕获异常，表示我们希望捕获所有异常。要获取异常，我们必须使用`std::current_exception()`，它返回`std::exception_ptr{}`。`std::exception_ptr{}`是一个特定于实现的指针类型，可以使用`std::rethrow_exception()`重新抛出。使用这个函数，我们可以使用前面的标准方法捕获异常并输出消息。值得注意的是，如果您希望捕获异常，`std::current_exception()`不是推荐的方法，因为您需要重新抛出异常才能从中获取`what()`，因为`std::exception_ptr`不提供获取`what()`的接口。还应该注意，如果抛出的异常不是`std::exception{}`的子类，`std::current_exception()`也无济于事。
- en: 'Finally, it''s possible to replace `subclass std::exception` with your own,
    custom data. To do this, refer to the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以用自定义数据替换`subclass std::exception`。要做到这一点，请参考以下示例：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we subclass `std::exception` to create our own exception
    that is capable of storing an error number. As with all subclasses of `std::exception{}`,
    the `what()` function should be overloaded to provide a message that uniquely
    identifies your custom exception. In our case, we also provide a function to retrieve
    the error code that was stored when the exception was created and thrown.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们对`std::exception`进行子类化，以创建我们自己的异常，该异常能够存储错误编号。与所有`std::exception{}`的子类一样，`what()`函数应该被重载，以提供一个能够唯一标识你自定义异常的消息。在我们的情况下，我们还提供了一个函数来检索在创建和抛出异常时存储的错误代码。
- en: 'Another common task is to create a custom string for your exception. This,
    however, can lead to a common mistake, which is to return a constructed string
    in the `what()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的任务是为您的异常创建自定义字符串。然而，这可能会导致一个常见的错误，即在`what()`函数中返回一个构造的字符串：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code produced undefined behavior, and a hard-to-find bug. In the
    preceding code, we store an error code just like we did in the previous example,
    but instead of returning it, we return the error code in a string in the `what()`
    function. To do this, we leverage the `std::to_string()` function to convert our
    error code into a `std::string`. We then prepend `error:`, and return the resulting
    standard C string.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了未定义的行为和难以发现的错误。在前面的代码中，我们存储错误代码，就像在前面的例子中一样，但是我们不是返回错误代码，而是在`what()`函数中返回一个字符串中的错误代码。为此，我们利用`std::to_string()`函数将我们的错误代码转换为`std::string`。然后我们添加`error:`，并返回生成的标准C字符串。
- en: The problem with the preceding example is that a pointer to the standard C string
    is returned and then `std::string{}` is destroyed when the `what()` function exits.
    The code that attempts to use the string returned by this function will end up
    reading deleted memory. The reason this is hard to find is that in some cases,
    this code will execute as expected, only because the contents of memory likely
    didn't change fast enough. Given enough time, however, this code will likely lead
    to corruption.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的问题在于返回了指向标准C字符串的指针，然后在`what()`函数退出时销毁了`std::string{}`。试图使用此函数返回的字符串的代码最终会读取已删除的内存。这很难发现的原因是在某些情况下，这段代码会按预期执行，只是因为内存的内容可能没有变化得足够快。然而，经过足够长的时间，这段代码很可能会导致损坏。
- en: 'Instead, to create a string that outputs the same message, put the resulting
    error code in the constructor of an existing exception:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要创建输出相同消息的字符串，请将生成的错误代码放在现有异常的构造函数中：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we subclass `std::runtime_error{}` instead of `std::exception`
    directly, and create our `what()` message during the construction of the exception.
    This way, when `what()` is called, the exception information is available without
    corruption.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们对`std::runtime_error{}`进行子类化，而不是直接对`std::exception`进行子类化，并在异常构造期间创建我们的`what()`消息。这样，当调用`what()`时，异常信息就可以在没有损坏的情况下使用。
- en: 'We will end this chapter with a note about the only real addition to C++17
    with respect to exception support. Throwing an exception while an exception is
    already thrown is generally discouraged. To accomplish this, you must throw an
    exception from the destructor of a class that has been marked as `except()`, and
    that is destroyed during stack-unwinding. Prior to C++17, a destructor could detect
    whether this was about to happen by leveraging the `std::uncaught_exception()`
    function, which would return true if an exception was in the process of being
    thrown. To support throwing an exception while an exception is already being thrown,
    C++17 changed this function to return an integer that represents the total number
    of exceptions currently being thrown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以关于C++17唯一真正的异常支持方面的说明结束本章。通常不鼓励在已经抛出异常时抛出异常。要实现这一点，您必须从已标记为`except()`的类的析构函数中抛出异常，并且在堆栈展开期间销毁。在C++17之前，析构函数可以通过利用`std::uncaught_exception()`函数来检测是否即将发生这种情况，该函数在正在抛出异常时返回true。为了支持在已经抛出异常时抛出异常，C++17将此函数更改为返回一个整数，该整数表示当前正在抛出的异常的总数：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we create a class that outputs to `stdout`, the total
    number of exceptions currently being thrown. This class is then instantiated in
    `myfunc()`. In the success case, no exceptions are in the process of being thrown
    when the class is destroyed. In the error case, one exception is reported as being
    thrown when the class is destroyed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个类，输出当前正在抛出的异常总数到`stdout`。然后在`myfunc()`中实例化这个类。在成功案例中，当销毁类时，没有异常正在被抛出。在错误案例中，当销毁类时，报告有一个异常被抛出。
- en: Studying an example on exception benchmark
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究异常基准测试的示例
- en: In this final example, we will demonstrate that C++ exceptions outperform POSIX-style
    exceptions (a claim that is largely dependent on the hardware you're executing
    on, as compiler optimizations and aggressive branch prediction can improve the
    performance of POSIX-style error handling).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们将演示C++异常优于POSIX风格异常（这一说法在很大程度上取决于您执行的硬件，因为编译器优化和激进的分支预测可以提高POSIX风格错误处理的性能）。
- en: POSIX-style error handling requires the user to check the result of a function
    each time it is executed. When function nesting occurs (which will almost certainly
    happen), this issue is exacerbated even further. In this example, we will take
    this case to the extreme, creating a recursive function that checks the results
    of itself thousands of times, while executing the test hundreds of thousands of
    times. Each test will be benchmarked and the results will be compared.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX风格的错误处理要求用户每次执行函数时都要检查结果。当函数嵌套发生时（这几乎肯定会发生），这个问题会进一步恶化。在这个示例中，我们将把这种情况推向极端，创建一个递归函数，检查自身的结果数千次，同时执行测试数十万次。每个测试都将进行基准测试，并比较结果。
- en: There are a lot of factors that could change the results of this test, including
    branch prediction, optimizations, and the operating system. The goal of this test
    is to take the example so far to the extreme that most of these issues are washed
    out in the noise, and any performance-related issues with any approach are easily
    identifiable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多因素可能会改变这个测试的结果，包括分支预测、优化和操作系统。这个测试的目标是将示例推向极端，以便大部分这些问题都在噪音中消失，任何方法的性能相关问题都很容易识别。
- en: 'To start, we will need the following includes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要以下包含：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will also need the following globally-defined jump buffer, as we will be
    comparing C++ exceptions to set jump and POSIX-style error handling:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下全局定义的跳转缓冲区，因为我们将比较C++异常和set jump以及POSIX风格的错误处理：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also use the same benchmark code we have used in previous chapters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用我们在之前章节中使用过的相同基准测试代码：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our first recursive function will return an error using POSIX-style error handling:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个递归函数将使用POSIX风格的错误处理返回错误：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As shown, the return value of the function is compared as expected. The second
    function will return an error using set jump:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，函数的返回值与预期相比。第二个函数将使用set jump返回错误：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As expected, this function is less complicated, since no return value needs
    to be returned or compared. Finally, the third function will return an error using
    C++ exceptions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这个函数不那么复杂，因为不需要返回或比较返回值。最后，第三个函数将使用C++异常返回错误：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As expected, this function is almost identical to set jump, with the use of
    C++ exceptions being the only difference. Since we are not testing RAII, we would
    expect C++ exceptions to be as fast to execute as set jump, since both do not
    need to perform a comparison.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这个函数与set jump几乎相同，唯一的区别是使用了C++异常。由于我们不测试RAII，我们期望C++异常的执行速度与set jump一样快，因为两者都不需要进行比较。
- en: 'Finally in our protected `main` function, we will execute each function the
    same way we have in our previous examples, to demonstrate that each function executes
    as expected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的protected `main`函数中，我们将以与之前示例相同的方式执行每个函数，以演示每个函数的执行结果如预期。
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first test function tests the C-style error handling logic to ensure that
    the function returns both success and failure as expected. We then execute the
    success case several times and time how long it takes to execute, outputting the
    results to `stdout`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试函数测试C风格的错误处理逻辑，以确保函数按预期返回成功和失败。然后，我们执行成功案例多次，并计算执行所需的时间，将结果输出到`stdout`：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As shown, we also ensure that the second, C-style exceptions example also returns
    success and failure as expected. Then, we execute the success case several times
    to see how long it takes to execute:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们还确保第二个C风格异常示例也按预期返回成功和失败。然后，我们执行成功案例多次，以查看执行所需的时间：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We do the same thing with our C++ exceptions example. We complete our `protected_main()`
    function by executing each test, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对C++异常示例做同样的事情。我们通过执行每个测试来完成我们的`protected_main()`函数，如下所示：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The results of the benchmark are output to `stdout`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的结果将输出到`stdout`：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As with all of our examples, the `protected_main()` function is executed by
    the `main()` function, which catches exceptions should they occur.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的所有示例一样，`protected_main()`函数由`main()`函数执行，如果发生异常，则捕获异常。
- en: Compiling and testing
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter13/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter13/CMakeLists.txt).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们利用了我们之前示例中使用的相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter13/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter13/CMakeLists.txt)。
- en: 'With this in place, we can compile this code using the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以使用以下命令编译这段代码：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To execute the example, run the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行示例，请运行以下代码：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As shown in the preceding code snippet, C++ exceptions outperformed POSIX-style
    error handling, and set jump exceptions were comparable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，C++异常优于POSIX风格的错误处理，并且set jump异常是可比较的。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned three different methods for performing error handling
    when system programming. The first method was POSIX-style error handling, which
    involves returning an error code from every function executed and the results
    of each function being checked to detect an error. The second method involved
    the use of standard C-style exceptions (that is, set jump), demonstrating how
    this form of exception-handling solves a lot of issues with POSIX-style error
    handling, but introduces issues with RAII support and thread safety. The third
    example discussed the use of C++ exceptions for error handling, and how this form
    of error handling solves most of the issues discussed in this chapter, with the
    only disadvantage being an increase in the size of the resulting executable. Finally,
    this chapter concluded with an example that demonstrated how C++ exceptions outperform
    POSIX-style error handling.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了三种不同的方法来进行系统编程时的错误处理。第一种方法是 POSIX 风格的错误处理，它涉及从每个执行的函数返回一个错误代码，并检查每个函数的结果以检测错误。第二种方法涉及使用标准的
    C 风格异常（即 set jump），演示了这种形式的异常处理如何解决了 POSIX 风格错误处理的许多问题，但引入了 RAII 支持和线程安全的问题。第三个例子讨论了使用
    C++ 异常进行错误处理，以及这种错误处理形式如何解决了本章讨论的大部分问题，唯一的缺点是导致生成的可执行文件大小增加。最后，本章以一个示例结束，演示了 C++
    异常如何优于 POSIX 风格的错误处理。
- en: Questions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do C++ exceptions outperform POSIX-style error handling?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 C++ 异常优于 POSIX 风格的错误处理？
- en: How does a function return an output with POSIX-style error handling?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 POSIX 风格的错误处理，函数如何返回输出？
- en: Why doesn't set jump support RAII?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 set jump 不支持 RAII？
- en: How do you catch any exception using a `catch{}` block?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 `catch{}` 块捕获任何异常？
- en: Why do C++ exceptions increase the size of an executable?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 C++ 异常会增加可执行文件的大小？
- en: Why should C++ exceptions not be used for control flow?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不应该将 C++ 异常用于控制流？
- en: Further reading
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
