- en: User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'In this chapter, we will take a more detailed look at QML and sketch out our
    user interface layout. We’ll create placeholder views for all of our screens and
    implement a framework to navigate between them. We will also discuss the content
    within those views, specifically how to anchor and size elements in a flexible
    and responsive way. We will cover these topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地了解QML并勾勒出我们的用户界面布局。我们将为所有屏幕创建占位视图，并实现一个在它们之间导航的框架。我们还将讨论这些视图中的内容，特别是如何以灵活和响应的方式锚定和调整元素的大小。我们将涵盖以下主题：
- en: User interface design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面设计
- en: Creating views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视图
- en: The StackView component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StackView组件
- en: Anchoring elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锚定元素
- en: Sizing elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整元素大小
- en: Navigating between views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图之间导航
- en: UX
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UX
- en: If you’ve ever worked with other declarative UI technologies like HTML and XAML,
    they often take a parent/child approach to UI, that is, there is a parent or root
    view that is ever present and contains global functionality, such as top-level
    navigation. It then has dynamic content or child views, which switch in and out
    as needed and present context sensitive commands where necessary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过其他声明性UI技术，如HTML和XAML，它们通常采用父/子方法来处理UI，即存在一个父视图或根视图，其中包含全局功能，例如顶级导航。然后有动态内容或子视图，根据需要切换并呈现上下文相关的命令。
- en: We will take the same approach, with our MasterView being the root of our UI.
    We will add a global navigation bar and a content pane where we can add and remove
    content as needed. Child views will optionally present a command bar for performing
    actions, for example, saving a record to a database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用相同的方法，将我们的MasterView作为UI的根。我们将添加一个全局导航栏和一个内容窗格，我们可以根据需要添加和删除内容。子视图将可选择地呈现命令栏以执行操作，例如将记录保存到数据库。
- en: 'Let’s take a look at the basic layout we are aiming for:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的基本布局目标：
- en: '![](img/9f05c5d3-5098-498d-8980-8d761e081b46.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f05c5d3-5098-498d-8980-8d761e081b46.png)'
- en: The Navigation Bar (**1**) will be ever present and contain buttons that will
    navigate the user to key areas within the application. By default, the bar will
    be narrow and the commands associated with the buttons will be represented by
    icons; however, pressing a toggle button will expand the bar to display accompanying
    descriptive text for each button.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏（**1**）将一直存在，并包含按钮，这些按钮将引导用户进入应用程序中的关键区域。默认情况下，该栏将很窄，并且与按钮相关的命令将由图标表示；然而，按下切换按钮将展开该栏，以显示每个按钮的附带描述文本。
- en: The Content Pane (**2**) will be a stack of child views. Navigating to different
    areas of the application will be achieved by replacing the child view in the content
    pane. For example, if we add a New Client button on the navigation bar and press
    it, we will push the **New Client View** onto the content frame stack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内容窗格（**2**）将是一堆子视图。通过在内容窗格中替换子视图来导航到应用程序的不同区域。例如，如果我们在导航栏上添加一个新客户按钮并按下它，我们将把**新客户视图**推送到内容框架堆栈上。
- en: The Command Bar (**3**) is an optional element that will be used to present
    further command buttons to the user. The key difference to the navigation bar
    is that these commands will be context sensitive relating to the current view.
    For example, when creating a new client, we will need a Save button, but when
    we are searching for clients, a Save button makes no sense. Each child view will
    optionally present its own command bar. The commands will be presented by icons
    with a short description underneath.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '命令栏（**3**）是一个可选元素，将用于向用户呈现更多的命令按钮。与导航栏的关键区别在于，这些命令将与当前视图相关，与上下文相关。例如，当创建新客户时，我们将需要一个保存按钮，但当我们搜索客户时，保存按钮就没有意义。每个子视图将可选择地呈现自己的命令栏。命令将由图标呈现，并在下面有一个简短的描述。 '
- en: 'Now let’s plan the flow of screens, or views as we’ll call them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们规划屏幕的流程，或者我们称之为视图：
- en: '![](img/88cb4886-bef2-4acf-8fec-17b997c55f39.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88cb4886-bef2-4acf-8fec-17b997c55f39.png)'
- en: Creating views
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'In **cm-ui**, right-click on `views.qrc` and select Add New…. Select Qt > QML
    File and click on Choose...:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在**cm-ui**中，右键单击`views.qrc`，然后选择添加新项…. 选择Qt > QML文件，然后单击选择…：
- en: '![](img/ccb03d0d-cb3b-4bd8-ae67-41aa6e02c9c6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccb03d0d-cb3b-4bd8-ae67-41aa6e02c9c6.png)'
- en: 'Create the `SplashView.qml` file in `cm-ui/ui/views`. Repeat this process until
    you’ve created all the following views:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-ui/ui/views`中创建`SplashView.qml`文件。重复此过程，直到创建了以下所有视图为止：
- en: '| **File** | **Purpose** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **文件** | **目的** |'
- en: '| `SplashView.qml` | Placeholder view displayed while the UI is loading. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `SplashView.qml` | 在加载UI时显示的占位视图。 |'
- en: '| `DashboardView.qml` | The central “home” view. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `DashboardView.qml` | 中央的“主页”视图。 |'
- en: '| `CreateClientView.qml` | View for entering details of a new client. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `CreateClientView.qml` | 用于输入新客户详细信息的视图。 |'
- en: '| `EditClientView.qml` | View for reading/updating the existing client details.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `EditClientView.qml` | 用于阅读/更新现有客户详细信息的视图。 |'
- en: '| `FindClientView.qml` | View for searching for the existing clients. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `FindClientView.qml` | 用于搜索现有客户的视图。 |'
- en: 'Edit `views.qrc` in the Plain Text Editor as we have done previously. You will
    see that our new views have been added to a new `qresource` block with the default
    prefix of the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样在纯文本编辑器中编辑`views.qrc`。您会看到我们的新视图已经添加到了一个新的`qresource`块中，并且具有以下默认前缀：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also note that the Projects navigator is a bit of a mess:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，项目导航器有点混乱：
- en: '![](img/6a8cda8d-a97a-4137-9b5e-b475274183ae.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a8cda8d-a97a-4137-9b5e-b475274183ae.png)'
- en: 'Move all the new files into the `“/views”` prefix block and remove the `“/”`
    block. Add an alias for each of the new files:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有新文件移动到`“/views”`前缀块中，并删除`“/”`块。为每个新文件添加别名：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As soon as you save these changes, you should see the navigator clean right
    up:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了这些更改，您应该看到导航器变得整洁了：
- en: '![](img/e95063e4-88c2-4ce9-8d72-943414f8359e.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e95063e4-88c2-4ce9-8d72-943414f8359e.png)'
- en: StackView
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StackView
- en: Our child views will be presented via a **StackView** component, which provides
    a stack-based navigation model with built-in history. New views (and views in
    this context means pretty much any QML) are pushed onto the stack when they are
    to be displayed and can be popped off the stack in order to go back to the previous
    view. We won’t need to use the history capabilities, but they are a very useful
    feature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的子视图将通过**StackView**组件呈现，它提供了一个基于堆栈的导航模型，并内置了历史记录。当要显示新视图（在这种情况下，视图几乎可以是任何QML）时，它们被推送到堆栈上，并且可以从堆栈中弹出，以返回到上一个视图。我们不需要使用历史记录功能，但它们是一个非常有用的功能。
- en: 'To gain access to the component, we first need to reference the module, so
    add the import to **MasterView**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问组件，我们首先需要引用该模块，因此在**MasterView**中添加导入：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With that done, let’s replace our **Text** element containing our welcome message
    with a `StackView`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们用`StackView`替换包含欢迎消息的**Text**元素：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We assign the component a unique identifier `contentFrame` so that we can reference
    it elsewhere in the QML, and we specify which child view we want to load by default—the
    new `SplashView`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为组件分配一个唯一标识符`contentFrame`，这样我们就可以在QML的其他地方引用它，并指定我们要默认加载的子视图——新的`SplashView`。
- en: Next, edit `SplashView`. Update the `QtQuick` module version to 2.9 so that
    it matches **MasterView** (do this for all further QML files if not explicitly
    stated). This is not strictly necessary, but it's a good practice to avoid inconsistencies
    across views. There is generally not much in the way of breaking changes in minor
    releases of Qt, but the same code on two views referencing different versions
    of QtQuick may exhibit different behavior that can cause problems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`SplashView`。将`QtQuick`模块版本更新为2.9，以便与**MasterView**匹配（如果没有明确说明，对所有后续的QML文件都要这样做）。这并不是严格必要的，但避免视图之间的不一致是一个好习惯。Qt的次要版本发布通常不会有太多破坏性的变化，但是在两个引用不同版本QtQuick的视图上运行相同的代码可能会表现出不同的行为，这可能会引起问题。
- en: 'All we’ll do with this view, for now, is to make a rectangle 400 pixels wide
    by 200 pixels high, which has a “vibrant” background color so that we can see
    that it has loaded:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对这个视图所做的就是让一个矩形的宽度为400像素，高度为200像素，具有“充满活力”的背景颜色，这样我们就可以看到它已经加载了：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Colors can be specified using hexadecimal RGB values as we did here, or named
    SVG colors. I generally find hex easier as I can never remember the names of the
    colors!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色可以使用十六进制RGB值或命名的SVG颜色来指定，就像我们在这里做的一样。我通常觉得十六进制更容易，因为我永远记不住颜色的名称！
- en: If you hover your cursor over the hex string in Qt Creator, you get a really
    useful little pop-up color swatch.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在Qt Creator中的十六进制字符串上，你会得到一个非常有用的小弹出颜色样本。
- en: Now run the application, and you should see that the welcome message no longer
    displays and instead, you are presented with a glorious orange-yellow rectangle,
    which is our **SplashView**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，你会看到欢迎消息不再显示，取而代之的是一个绚丽的橙黄色矩形，这就是我们的**SplashView**。
- en: '![](img/95abb8ea-4155-403a-85f6-5cd98845a7d4.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95abb8ea-4155-403a-85f6-5cd98845a7d4.png)'
- en: Anchors
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点
- en: One slight problem with our wonderful new **SplashView** is that it doesn’t
    actually fill the window. Sure, we can change the 400 x 200 dimensions to 1024
    x 768 so that it matches **MasterView**, but then what happens if the user resizes
    the window? Modern UI is all about responsive design—dynamic content that can
    adapt to the display it’s being presented on, so hard-coding properties appropriate
    for only one platform aren’t ideal. Fortunately, anchors come to our rescue.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们美妙的新**SplashView**有一个小问题，那就是它实际上并没有填满窗口。当然，我们可以将400 x 200的尺寸改为1024 x 768，这样它就与**MasterView**匹配了，但是如果用户调整窗口大小会发生什么呢？现代UI都是响应式设计——动态内容可以适应呈现的显示器，因此为只适用于一个平台的硬编码属性并不理想。幸运的是，锚点来拯救我们了。
- en: Let’s put our trusty old **scratchpad** project to use and take a look at anchors
    in action.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们可靠的旧**scratchpad**项目，看看锚点是如何运作的。
- en: Right-click on `qml.qrc` and add a new `AnchorsDemo.qml` QML file alongside
    the existing `main.qml` file in the `scratchpad` folder. Don’t worry about subfolders
    or `.qrc` prefixes, aliases, or any of that jazz.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`qml.qrc`，在`scratchpad`文件夹中的`main.qml`文件旁边添加一个新的`AnchorsDemo.qml` QML文件。不要担心子文件夹、`.qrc`前缀、别名或任何其他东西。
- en: 'Dip into `main.cpp` and load our new file instead of `main.qml`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`main.cpp`，加载我们的新文件，而不是`main.qml`：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, paste the following code into `AnchorsDemo`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下代码粘贴到`AnchorsDemo`中：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build and run the application, and you’ll be presented with this rather bewildering
    sight:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行应用程序，你会看到这个相当令人困惑的景象：
- en: '![](img/d9a0d9a2-5955-42c5-9096-0b79882dc347.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9a0d9a2-5955-42c5-9096-0b79882dc347.png)'
- en: 'This may all look a bit confusing at first and I apologize if your color perception
    is suboptimal, but all we’ve done is draw a sequence of gaudily colored rectangles
    with differing anchors values. Let’s walk through each rectangle one by one and
    see what is going on:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切乍一看可能有点令人困惑，如果你的颜色感知不够理想，我很抱歉，但我们所做的只是用不同的锚点值绘制一系列花哨的彩色矩形。让我们逐个矩形地走一遍，看看发生了什么：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our first rectangle is the dull yellow brown background; `anchors.fill: parent`
    tells the rectangle to fill its parent, however big that may be. The parent of
    any given QML component is the QML component that contains it—the next level up
    in the hierarchy. In this case, it is the **Window** element. The **Window** element
    is 1024 x 768 pixels, so that’s how big the rectangle is. Note that we don’t need
    to specify width and height properties for the rectangle because they are inferred
    from the anchors.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一个矩形是沉闷的黄褐色背景；`anchors.fill: parent`告诉矩形填充其父级，无论大小如何。任何给定的QML组件的父级是包含它的QML组件——在层次结构中的下一个级别。在这种情况下，它是**Window**元素。**Window**元素是1024
    x 768像素，所以矩形就是这么大。请注意，我们不需要为矩形指定宽度和高度属性，因为它们是从锚点中推断出来的。'
- en: 'This is exactly the behavior we want for our **SplashView**, but let’s look
    at some other capabilities of anchors before we return to our main project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的**SplashView**的行为，但在我们回到主项目之前，让我们看看锚点的一些其他功能：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll look at the next two rectangles together. First, we have a black rectangle
    that is 120 pixels square; `anchors.centerIn: parent` positions it at the center
    of its parent. We must specify the **width** and **height** because we are only
    positioning it, not sizing it.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将一起看接下来的两个矩形。首先是一个边长为120像素的黑色矩形；`anchors.centerIn: parent`将其定位在其父元素的中心。我们必须指定**width**和**height**，因为我们只是定位它，而不是调整大小。'
- en: Next, we have a slightly smaller green rectangle, also centered in its parent.
    We then use the `anchors.verticalCenterOffset` property to move it 20 pixels further
    down the screen. The *x*, *y* coordinate system used for positioning has its root
    (0, 0) at the top-left of the screen; `verticalCenterOffset` adds to the y coordinate.
    Positive numbers move the item down the screen, and negative numbers move the
    item up the screen. Its sister property—`horizontalCenterOffset`—is used for adjustments
    in the *x* axis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个稍小一点的绿色矩形，也是在其父元素中居中。然后我们使用`anchors.verticalCenterOffset`属性将其向下移动20像素。用于定位的*x*，*y*坐标系统的根（0,
    0）位于屏幕的左上角；`verticalCenterOffset`会增加y坐标。正数会将项目向下移动，负数会将项目向上移动。它的姐妹属性`horizontalCenterOffset`用于*x*轴的调整。
- en: 'One last thing to note here is that the rectangles overlap, and it is the green
    rectangle that wins out and is displayed in full. The black rectangle is pushed
    back and obscured. Similarly, all of our small rectangles sit in front of the
    large background rectangle. QML is rendered in a top-down fashion, so when the
    root element (**Window**) gets painted, its children are processed one by one
    from the top of the file to the bottom. So, items at the bottom of the file will
    be rendered in front of those rendered at the top of the file. The same is true
    if you paint a wall white and then paint it black, the wall will appear black
    because that’s what was painted (rendered) last:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的最后一件事是，矩形重叠，显示的是绿色矩形，黑色矩形被推到后面并被遮挡。同样，我们所有的小矩形都在大背景矩形的前面。QML以自上而下的方式呈现，因此当根元素（**Window**）被绘制时，其子元素会从文件顶部到底部依次处理。因此，文件底部的项目将呈现在文件顶部的项目前面。如果你先把墙涂成白色，然后再涂成黑色，墙会变成黑色，因为那是最后涂的（呈现的）：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we draw a red rectangle and rather than positioning or sizing the whole
    rectangle at once, we just anchor certain sides. We take the anchor on its **top**
    side and align it to the anchor on the **top** side of its parent (**Window**).
    We anchor its l**eft** side to its parent’s **left** side. Hence, it becomes “attached”
    to the top-left corner.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们画一个红色矩形，而不是一次性定位或调整整个矩形，我们只是锚定某些边。我们将其**top**边的锚点与其父元素（**Window**）的**top**边的锚点对齐。我们将其**left**边锚定到其父元素的**left**边。因此，它变成了与左上角“连接”起来。
- en: 'We have to type the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须输入以下内容：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another helpful piece of syntactic sugar at work here is rather than doing
    that, we can remove the duplication and set the subproperties of the `anchors`
    group within curly braces:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有用的语法糖，我们可以去掉重复的部分，并在花括号内设置`anchors`组的子属性：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, the blue rectangle:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是蓝色矩形：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This follows the same pattern, though this time rather than attaching only
    to its parent, we also anchor to a sibling (the red rectangle), which we can reference
    though the `id` property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循相同的模式，不过这次我们不仅仅附加到其父元素，还要锚定到一个兄弟元素（红色矩形），我们可以通过`id`属性引用它：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The purple rectangle anchors to the bottom of the blue rectangle and to the
    left-hand side of the Window, but here we introduce our first margin. Each side
    has its own margin and in this case, we use `leftMargin` to give us an offset
    from the left anchor in exactly the same way as we saw with `verticalCenterOffset`
    earlier:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色矩形锚定在蓝色矩形的底部和窗口的左侧，但这里我们引入了第一个边距。每一边都有自己的边距，在这种情况下，我们使用`leftMargin`来给我们一个从左锚点的偏移，就像我们之前在`verticalCenterOffset`中看到的一样：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, our turquoise rectangle uses some of that empty space over on the right-hand
    side of the screen and demonstrates how we can set the margin on all four sides
    simultaneously using the `margins` property.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的青绿色矩形利用了屏幕右侧的一些空白空间，并演示了如何使用`margins`属性同时设置四个边的边距。
- en: Note that all of these bindings are dynamic. Try resizing the window, and all
    the rectangles will adapt automatically. Anchors are a great tool for responsive
    UI design.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些绑定都是动态的。尝试调整窗口大小，所有的矩形都会自动适应。锚点是响应式UI设计的好工具。
- en: 'Let’s head back to our `SplashView` in our `cm-ui` project and apply what we’ve
    just learned. Replace the fixed **width** and **height** attributes with the more
    dynamic `anchors.fill` property:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`cm-ui`项目中的`SplashView`，并应用我们刚学到的知识。用更动态的`anchors.fill`属性替换固定的**width**和**height**属性：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, the `SplashView` will fill whatever its parent element is. Build and run,
    and you’ll see that rather than our lovely colorful rectangle filling the screen
    as we expected, it has disappeared altogether. Let’s take a look at why that is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`SplashView`将填充其父元素。构建并运行，你会发现，我们原本期望的可爱多彩的矩形已经完全消失了。让我们看看为什么会这样。
- en: Sizing
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小
- en: 'Our rectangle will fill its parent, so the size of the rectangle depends entirely
    on the size of its parent. Walking up the QML hierarchy, the component that contains
    the rectangle is the `StackView` element back in **MasterView**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的矩形将填满其父元素，因此矩形的大小完全取决于其父元素的大小。沿着QML层次结构向上走，包含矩形的组件是**MasterView**中的`StackView`元素：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Often, QML components are clever enough to size themselves based on their children.
    Previously, we had set our rectangle to a fixed size of 400 x 200\. The `StackView`
    could look at that and say “I need to contain a single **Rectangle** that is 400
    x 200, so I’ll make myself 400 x 200 too. Easy!”. We can always overrule that
    and set it to some other size using its **width** and **height** properties, but
    it can work out what size it wanted to be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，QML组件足够聪明，可以根据它们的子元素自行调整尺寸。以前，我们将矩形设置为固定尺寸的400 x 200。`StackView`可以查看并说：“我需要包含一个尺寸为400
    x 200的**Rectangle**，所以我也会把自己做成400 x 200。简单！”我们总是可以通过它的**width**和**height**属性来覆盖它，并将其设置为其他尺寸，但它可以计算出它想要的尺寸。
- en: 'Back in `scratchpad`, create a new `SizingDemo.qml` view and edit `main.cpp`
    to load it on startup, just like we did with `AnchorsDemo`. Edit `SizingDemo`
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`scratchpad`，创建一个新的`SizingDemo.qml`视图，并编辑`main.cpp`以在启动时加载它，就像我们在`AnchorsDemo`中所做的那样。编辑`SizingDemo`如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run this, and you’ll get another screen full of nonsense:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个，你会得到另一个充满无意义的屏幕：
- en: '![](img/464111c3-4326-4a22-bf0e-9c51aed169f8.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/464111c3-4326-4a22-bf0e-9c51aed169f8.png)'
- en: 'Of far more interest to us here is what is output to the console:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，更有趣的是控制台输出的内容：
- en: '`qml: Text1 - implicitWidth:30 implicitHeight:13 width:30 height:13`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text1 - implicitWidth:30 implicitHeight:13 width:30 height:13`'
- en: '`qml: Text2 - implicitWidth:30 implicitHeight:13 width:300 height:20`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text2 - implicitWidth:30 implicitHeight:13 width:300 height:20`'
- en: '`qml: Text3 - implicitWidth:1218 implicitHeight:13 width:1218 height:13`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text3 - implicitWidth:1218 implicitHeight:13 width:1218 height:13`'
- en: '`qml: Text4 - implicitWidth:1218 implicitHeight:13 width:300 height:13`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text4 - implicitWidth:1218 implicitHeight:13 width:300 height:13`'
- en: '`qml: Text5 - implicitWidth:1218 implicitHeight:65 width:300 height:65`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text5 - implicitWidth:1218 implicitHeight:65 width:300 height:65`'
- en: '`qml: ColumnWithText - implicitWidth:1218 implicitHeight:124 width:1218 height:124`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: ColumnWithText - implicitWidth:1218 implicitHeight:124 width:1218 height:124`'
- en: '`qml: Rectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Rectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
- en: '`qml: ColumnWithRectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: ColumnWithRectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
- en: So, what’s going on? We’ve created two **Column** elements, which are invisible
    layout components that arrange their child elements vertically. We’ve stuffed
    the first column with various **Text** elements and added a single **Rectangle**
    to the second. At the bottom of the view is a JavaScript function that will execute
    when the **Window** component has completed (that is, finished loading). All the
    function does is write out the `implicitWidth`, `implicitHeight`, `width`, and
    `height` properties of various elements on the view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？我们创建了两个**Column**元素，这是不可见的布局组件，可以垂直排列它们的子元素。我们用各种**Text**元素填充了第一个列，并在第二个列中添加了一个**Rectangle**。视图底部是一个JavaScript函数，当**Window**组件完成（即加载完成）时将执行。函数所做的就是写出视图上各个元素的`implicitWidth`、`implicitHeight`、`width`和`height`属性。
- en: 'Let’s walk through the elements and the corresponding console lines:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个浏览元素和相应的控制台行：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`qml: Text1 - implicitWidth:30 implicitHeight:13 width:30 height:13`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text1 - implicitWidth:30 implicitHeight:13 width:30 height:13`'
- en: 'This Text element contains a short piece of text, and we have not specified
    any sizes. Its `implicitWidth` and `implicitHeight` properties are the sizes the
    element wants to be based on its content. Its `width` and `height` properties
    are the sizes the element actually is. In this case, it will size itself however
    it wants to, because we haven’t specified otherwise, so its `width`/`height` are
    the same as its `implicitWidth`/`implicitHeight`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文本元素包含了一小段文本，我们没有指定任何尺寸。它的`implicitWidth`和`implicitHeight`属性是基于其内容所需的尺寸。它的`width`和`height`属性是元素实际的尺寸。在这种情况下，它会根据自己的需求调整尺寸，因为我们没有另外指定，所以它的`width`/`height`与`implicitWidth`/`implicitHeight`相同：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`qml: Text2 - implicitWidth:30 implicitHeight:13 width:300 height:20`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text2 - implicitWidth:30 implicitHeight:13 width:300 height:20`'
- en: 'With `text2`, the implicit sizes are the same as `text1` as the content is
    virtually identical. However, this time, we have explicitly told it to be 300
    wide and 20 high. The console tells us that the element is doing as it’s told
    and is indeed that size:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`text2`，隐式尺寸与`text1`相同，因为内容几乎相同。然而，这次，我们明确告诉它宽度为300，高度为20。控制台告诉我们，元素按照指示进行，并且确实是那个尺寸：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`qml: Text3 - implicitWidth:1218 implicitHeight:13 width:1218 height:13`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text3 - implicitWidth:1218 implicitHeight:13 width:1218 height:13`'
- en: 'This `text3` takes the same hands-off approach as `text1`, but with a much
    longer piece of text as its content. This time, `implicitWidth` is much larger
    as that is the amount of space it needs to fit the long text in. Note that this
    is actually wider than the window and the text gets cut off. Again, we haven’t
    instructed it otherwise, so it sizes itself:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`text3`采取了与`text1`相同的不干涉方式，但内容是一段更长的文本。这次，`implicitWidth`要大得多，因为它需要适应长文本的空间。请注意，这实际上比窗口还要宽，文本被截断了。同样，我们没有另外指示，所以它自行调整尺寸：'
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`qml: Text4 - implicitWidth:1218 implicitHeight:13 width:300 height:13`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text4 - implicitWidth:1218 implicitHeight:13 width:300 height:13`'
- en: 'The `text4` has the same lengthy block of text, but we’ve told it what width
    we want this time. You’ll notice on screen that even though the element is only
    300 pixels wide, the text is visible all the way across the window. The content
    is overflowing the bounds of its container. You can set the `clip` property to
    `true` to prevent this, but we’re not too concerned with that here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`text4`有相同的冗长文本块，但这次我们告诉它我们想要的宽度。你会注意到，即使元素只有300像素宽，文本也能在整个窗口上都可见。内容溢出了容器的边界。你可以将`clip`属性设置为`true`来防止这种情况，但我们在这里并不太关心：'
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`qml: Text5 - implicitWidth:1218 implicitHeight:65 width:300 height:65`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Text5 - implicitWidth:1218 implicitHeight:65 width:300 height:65`'
- en: The `text5` repeats the same long block of text and constrains the width to
    300, but this time, we bring a bit of order to proceedings by setting the `wrapMode`
    property to `Text.Wrap`. With this setting, the enabled behavior is much more
    like what you would expect from a block of text—it fills up the available width
    and then wraps onto the next line. The `implicitHeight` and, consequently, the
    `height` of the element has increased to accommodate the contents. Note, however,
    that the `implicitHeight` is still the same as earlier; this is still the width
    the control wants to be in order to fit all of its content in, given the constraints
    we have defined, and we have defined no height constraint.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`text5`重复了相同的长文本块，并将宽度限制为300，但这次，我们通过将`wrapMode`属性设置为`Text.Wrap`来使事情更有条理。通过这个设置，启用的行为更像是你从一个文本块中期望的——它填满了可用的宽度，然后换行到下一行。元素的`implicitHeight`和因此`height`已增加以容纳内容。然而，请注意，`implicitHeight`仍然与之前相同；这仍然是控件希望的宽度，以便根据我们定义的约束来容纳其所有内容，而我们没有定义高度约束。'
- en: 'We then print out the properties of the column containing all this text:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打印出包含所有这些文本的列的属性：
- en: '`qml: ColumnWithText - implicitWidth:1218 implicitHeight:124 width:1218 height:124`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: ColumnWithText - implicitWidth:1218 implicitHeight:124 width:1218 height:124`'
- en: The important thing to note is that the column is able to figure out how wide
    and high it needs to be to accommodate all of its children.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，列能够计算出需要多宽和多高才能容纳所有子元素。
- en: 'Next, we get to the issue we encountered back in `SplashView`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了在`SplashView`中遇到的问题：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have a chicken and egg scenario. The `Column` tries to work out how
    large it needs to be to contain its children, so it takes a look at `Rectangle`.
    `Rectangle` has no explicit size information and no children of its own, it is
    just set to fill its parent, the `Column`. Neither element can figure out how
    big they are supposed to be, so they both default to 0x0, which renders them invisible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了一个鸡生蛋蛋生鸡的情况。`Column`试图计算出容纳其子元素所需的大小，因此它查看了`Rectangle`。`Rectangle`没有显式的大小信息，也没有自己的子元素，它只是设置为填充其父元素`Column`。两个元素都无法确定自己应该有多大，因此它们都默认为0x0，这使它们变得不可见。
- en: '`qml: Rectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: Rectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
- en: '`qml: ColumnWithRectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`qml: ColumnWithRectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
- en: Sizing of elements is probably the thing that has caught me out the most with
    QML over the years. As a general guideline, if you write some QML but then can’t
    see it rendered on screen, it’s probably a sizing issue. I usually find that giving
    everything an arbitrary fixed **width** and **height** is a good start when debugging,
    and then one by one, make the sizes dynamic until you recreate the problem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，元素的大小调整可能是我在QML中遇到的最困扰的问题。作为一般指导方针，如果您编写了一些QML但无法在屏幕上看到它呈现，那可能是一个大小问题。我通常发现，当调试时，给每个元素一个任意的固定**宽度**和**高度**是一个好的开始，然后逐个使尺寸动态化，直到重新创建问题。
- en: Armed with this knowledge, let’s head back to `MasterView` and fix our earlier
    problem.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识，让我们回到`MasterView`并解决之前的问题。
- en: 'Add `anchors.fill: parent` to the `StackView` component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '将`anchors.fill: parent`添加到`StackView`组件：'
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `StackView` will now fill its parent **Window**, which we have explicitly
    given a fixed size of 1024 x 768\. Run the app again, and you should now have
    a lovely orange-yellow `SplashView` that fills the screen and happily resizes
    itself if you resize the window:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackView`现在将填充其父级**Window**，我们已经明确给定了固定大小为1024 x 768。再次运行应用程序，现在您应该有一个可爱的橙黄色的`SplashView`，它填满了屏幕，并且在调整窗口大小时可以愉快地调整大小：'
- en: '![](img/39e7344e-d964-43d5-ad69-841e8612c143.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e7344e-d964-43d5-ad69-841e8612c143.png)'
- en: Navigation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: 'Lets make a quick addition to our `SplashView`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速在我们的`SplashView`中添加一个内容：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This just adds the name of the view to the screen, so when we start moving between
    views, we know which one we are looking at. With that done, copy the content of
    `SplashView` into all the other new views, updating the text in each to reflect
    the name of the view, for example, in `DashboardView`, the text could say “Dashboard
    View”.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将视图的名称添加到屏幕上，因此当我们开始在视图之间移动时，我们知道我们正在查看哪一个。完成后，将`SplashView`的内容复制到所有其他新视图中，并更新每个视图中的文本以反映视图的名称，例如，在`DashboardView`中，文本可以说“Dashboard
    View”。
- en: The first piece of navigation we want to do is when the `MasterView` has finished
    loading and we’re ready for action, load the `DashboardView`. We achieve this
    using one of the QML component slots we’ve just seen—`Component.onCompleted()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要进行的第一次导航是当`MasterView`加载完成并且我们准备好进行操作时，加载`DashboardView`。我们可以使用我们刚刚看到的QML组件插槽之一`Component.onCompleted()`来实现这一点。
- en: 'Add the following line to the root `Window` component in `MasterView`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MasterView`中的根`Window`组件中添加以下行：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now when you build and run, as soon as the `MasterView` has finished loading,
    it switches the child view to `DashboardView`. This probably happens so fast that
    you no longer even see `SplashView`, but it is still there. Having a splash view
    like this is great if you’ve got an application with quite a lot of initialization
    to do, and you can’t really have non-blocking UI. It’s a handy place to put the
    company logo and a “Reticulating splines...” loading message. Yes, that was a
    Sims reference!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建和运行时，一旦`MasterView`加载完成，它就会将子视图切换到`DashboardView`。这可能发生得如此之快，以至于您甚至不再看到`SplashView`，但它仍然存在。如果您的应用程序需要进行大量初始化，并且无法使用非阻塞UI，那么拥有这样的启动视图是非常好的。这是一个方便的地方，可以放置公司标志和“Reticulating
    splines...”加载消息。是的，这是一个模拟人生的参考！
- en: The StackView is just like the history in your web browser.  If you visit [www.google.com](http://www.google.com)
    and then [www.packtpub.com](http://www.packtpub.com), you are *pushing* [www.packtpub.com](http://www.packtpub.com)
    onto the stack.  If you click on Back on the browser, you return to [www.google.com](http://www.google.com). 
    This history can consist of several pages (or views), and you can navigate backward
    and forward through them. Sometimes you don't need the history and sometimes you
    actively don't want users to be able to go back. The `replace()` method we called,
    as its name suggests, pushes a new view onto the stack and clears any history
    so that you can't go back.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: StackView就像是你的网络浏览器中的历史记录。如果你访问[www.google.com](http://www.google.com)，然后访问[www.packtpub.com](http://www.packtpub.com)，你就是在将[www.packtpub.com](http://www.packtpub.com)
    *推送*到堆栈上。如果你在浏览器上点击返回，你就会回到[www.google.com](http://www.google.com)。这个历史记录可以包含多个页面（或视图），你可以通过它们向后和向前导航。有时你不需要历史记录，有时你甚至不希望用户能够返回。我们调用的`replace()`方法，正如其名称所示，会将一个新视图推送到堆栈上，并清除任何历史记录，这样你就无法返回。
- en: 'In the `Component.onCompleted` slot, we''ve seen an example of how to navigate
    between views directly from QML. We can use this approach for all of our application
    navigation. For example, we can add a button for the user to create a new client
    and when it’s clicked on, push the `CreateClientView` straight on to the stack,
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Component.onCompleted`槽中，我们已经看到了如何直接从QML中导航到视图的示例。我们可以使用这种方法来进行应用程序的所有导航。例如，我们可以添加一个按钮，让用户创建一个新的客户，当点击时，直接将`CreateClientView`推送到堆栈上，如下所示：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For UX designs or simple UI heavy applications with little business logic, this
    is a perfectly valid approach. The trouble is that your QML views and components
    become very tightly coupled, and the business logic layer has no visibility of
    what the user is doing. Quite often, moving to a new screen of the application
    isn’t as simple as just displaying a new view. You may need to update a state
    machine, set some models up, or clear out some data from the previous view. By
    routing all of our navigation requests through our **MasterController** switchboard,
    we decouple our components and gain an intercept point for our business logic
    to take any actions it needs to as well as validate that the requests are appropriate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UX设计或简单的UI重型应用程序，这是一个完全有效的方法。问题在于你的QML视图和组件变得非常紧密地耦合，而业务逻辑层对用户的操作一无所知。很多时候，移动到应用程序的新屏幕并不像只是显示一个新视图那么简单。你可能需要更新状态机，设置一些模型，或者清除前一个视图中的一些数据。通过将所有的导航请求都通过我们的**MasterController**中转站，我们解耦了我们的组件，并获得了业务逻辑拦截点，以便执行任何必要的操作，并验证请求是否合适。
- en: 'We will request navigation to these views by emitting signals from our business
    logic layer and having our **MasterView** respond to them and perform the transition.
    Rather than cluttering up our **MasterController**, we’ll delegate the responsibility
    for navigation to a new controller in `cm-lib`, so create a new header file (there
    is no implementation as such, so we don’t need a `.cpp` file) called `navigation-controller.h`
    in `cm/cm-lib/source/controllers` and add the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从业务逻辑层发出信号并让我们的**MasterView**对其做出响应并执行过渡来请求导航到这些视图。我们不会在**MasterController**中添加这些功能，而是将导航的责任委托给`cm-lib`中的一个新控制器，因此在`cm/cm-lib/source/controllers`中创建一个名为`navigation-controller.h`的新头文件（没有实际的实现，所以我们不需要一个`.cpp`文件），并添加以下代码：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have created a minimal class that inherits from `QObject` and implements
    a signal for each of our new views. Note that we don’t need to navigate to the
    **MasterView** or the **SplashView**, so there is no corresponding signal for
    those. When we navigate to the `EditClientView`, we will need to inform the UI
    which **Client** we want to edit, so we will pass it through as a parameter. Calling
    one of these methods from anywhere within our business logic code fires a request
    into the ether saying “I want to go to the so-and-so view, please”. It is then
    up to the **MasterView** over in the UI layer to monitor those requests and respond
    accordingly. Note that the business logic layer still knows nothing about the
    UI implementation. It's fine if nobody responds to the signal; it is not a two-way
    communication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个最小的类，它继承自`QObject`，并为我们的新视图实现了一个信号。请注意，我们不需要导航到**MasterView**或**SplashView**，因此没有相应的信号。当我们导航到`EditClientView`时，我们需要通知UI我们想要编辑哪个**Client**，因此我们将其作为参数传递。从业务逻辑代码的任何地方调用这些方法会向外界发出一个请求，说“我想去某个视图，请”。然后由UI层的**MasterView**来监视这些请求并做出相应的响应。请注意，业务逻辑层仍然对UI实现一无所知。如果没有人响应这个信号，也没关系；这不是双向通信。
- en: Whenever you inherit from `QObject`, always remember the `Q_OBJECT` macro and
    also an overloaded constructor that takes a `QObject` parent. As we want to use
    this class outside of this project (in the UI project), we must also remember
    the CMLIBSHARED_EXPORT macro.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你从`QObject`继承时，一定要记住`Q_OBJECT`宏，还有一个接受`QObject`父对象的重载构造函数。由于我们希望在这个项目之外（在UI项目中）使用这个类，我们还必须记住CMLIBSHARED_EXPORT宏。
- en: 'We''ve looked forward a little bit here and assumed that our Client class will
    be in the `cm::models` namespace, but the default `Client` class that Qt added
    for us when we created the project is not, so let''s fix that before we move on:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里稍微展望了一下，并假设我们的Client类将在`cm::models`命名空间中，但Qt在我们创建项目时为我们添加的默认`Client`类并不在这个命名空间中，所以在继续之前让我们先修复这个问题。
- en: '**client.h**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**client.h**：'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`client.cpp`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.cpp`：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to be able to create an instance of a NavigationController and have
    our UI interact with it. For unit testing reasons, it is good practice to hide
    object creation behind some sort of object factory interface, but we’re not concerned
    with that at this stage, so we''ll simply create the object in **MasterController**.
    Let’s take this opportunity to add the Private Implementation (PImpl) idiom to
    our **MasterController** too. If you haven''t come across PImpl before, it is
    simply a technique to move all private implementation details out of the header
    file and into the definition. This helps keep the header file as short and clean
    as possible, with only the includes necessary for consumers of the public API.
    Replace the declaration and implementation as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够创建一个NavigationController的实例，并让我们的UI与它交互。出于单元测试的原因，将对象创建隐藏在某种对象工厂接口后面是一个很好的做法，但在这个阶段我们不关心这个，所以我们将简单地在**MasterController**中创建对象。让我们趁机在**MasterController**中添加私有实现（PImpl）习惯用法。如果你以前没有接触过PImpl，它只是一种将所有私有实现细节从头文件中移出并放入定义中的技术。这有助于保持头文件尽可能短和干净，只包含对公共API的消费者必要的包含。将声明和实现替换为以下内容：
- en: '`master-controller.h`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`master-controller.h`：'
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`master-controller.cpp`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`master-controller.cpp`：'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You may have noted that we don’t specify the cm::controllers namespace for the
    NavigationController accessor method, but we do for the `Q_PROPERTY`. This is
    because the property is accessed by the UI QML, which is not executing within
    the scope of the `cm` namespace, so we have to explicitly specify the fullyqualified
    name. As a general rule of thumb, be explicit about namespaces for anything that
    QML interacts with directly, including parameters in signals and slots.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，对于NavigationController的访问器方法，我们没有指定cm::controllers命名空间，但对于`Q_PROPERTY`我们做了。这是因为属性是由UI
    QML访问的，它不在`cm`命名空间的范围内执行，所以我们必须明确指定完全限定的名称。作为一个一般的经验法则，对于QML直接交互的任何东西，包括信号和插槽中的参数，都要明确指定命名空间。
- en: 'Next, we need to register the new `NavigationController` class with the QML
    system in the **cm-ui** project, so in `main.cpp`, add the following registration
    next to the existing one for **MasterController**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在**cm-ui**项目中使用`main.cpp`注册新的`NavigationController`类，所以在现有的**MasterController**旁边添加以下注册：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’re now ready to wire up **MasterView** to react to these navigation signals.
    Add the following element before the `StackView`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好让**MasterView**对这些导航信号做出反应。在`StackView`之前添加以下元素：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are creating a connection component bound to our new instance of **NavigationController**,
    which reacts to each of the go signals we added and navigates to the relevant
    view via the `contentFrame`, using the same `replace()` method we used previously
    to move to the Dashboard. So whenever the `goCreateClientView()` signal gets fired
    on the **NavigationController**, the `onGoCreateClientView()` slot gets called
    on our `Connections` component and the `CreateClientView` is loaded into the **StackView**
    named `contentFrame`. In the case of `onGoEditClientView` where a `client` parameter
    is passed from the signal, we pass that object along to a property named `selectedClient`, which
    we will add to the view later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个连接组件，绑定到我们的新**NavigationController**实例，它对我们添加的每个go信号做出反应，并通过`contentFrame`导航到相关视图，使用我们之前用于移动到仪表板的`replace()`方法。因此，每当**NavigationController**上触发`goCreateClientView()`信号时，我们的`Connections`组件上的`onGoCreateClientView()`插槽将被调用，并且`CreateClientView`将加载到名为`contentFrame`的**StackView**中。在`onGoEditClientView`的情况下，从信号传递了一个`client`参数，我们将该对象传递给一个名为`selectedClient`的属性，稍后我们将在视图中添加该属性。
- en: Some signals and slots in QML components are automatically generated and connected
    for us and are convention based. Slots are named `on[CapitalisedNameOfRelatedSignal]`.
    So, for example, if you have a signal called `mySplendidSignal()`, then the corresponding
    slot will be named `onMySplendidSignal`. These conventions are in play with our
    `NavigationController` and `Connections` components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML组件中，一些信号和插槽是自动生成并连接的，遵循约定。插槽的命名方式是`on[CapitalisedNameOfRelatedSignal]`。例如，如果有一个名为`mySplendidSignal()`的信号，那么相应的插槽将被命名为`onMySplendidSignal`。这些约定适用于我们的`NavigationController`和`Connections`组件。
- en: Next, let’s add a navigation bar to **MasterView** with some placeholder buttons
    so that we can try these signals out.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在**MasterView**中添加一个导航栏，带有一些占位按钮，以便我们可以尝试这些信号。
- en: 'Add a `Rectangle` to form the background for our bar:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`Rectangle`来形成我们条的背景：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This draws a black strip 100 pixels wide anchored to the left-hand side of the
    view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在视图的左侧绘制一个宽度为100像素的黑色条。
- en: 'We also need to adjust our `StackView` so that it allows some space for our
    bar. Rather than filling its parent, let’s anchor three of its four sides to its
    parent, but attach the left-hand side to the right-hand side of our bar:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整我们的`StackView`，以便为我们的条留出一些空间。我们不是填充其父级，而是将其四个边的三个边锚定到其父级，但将左侧与我们的条的右侧连接起来：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let’s add some buttons to our navigation `Rectangle`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的导航`Rectangle`中添加一些按钮：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We use the `Column` component to lay out our buttons for us, rather than having
    to individually anchor the buttons to each other. Each button displays some text
    and when clicked on, calls a signal on the **NavigationController**. Our `Connection`
    component reacts to the signals and performs the view transition for us:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Column`组件来为我们布局按钮，而不是必须单独将按钮锚定到彼此。每个按钮显示一些文本，当点击时，调用**NavigationController**上的一个信号。我们的`Connection`组件对信号做出反应，并为我们执行视图转换：
- en: '![](img/aad6160f-75eb-4122-a0f4-1b1e6e5790dd.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aad6160f-75eb-4122-a0f4-1b1e6e5790dd.png)'
- en: Great stuff, we have a functional navigation framework! However, when you click
    on one of the navigation buttons, the navigation bar disappears momentarily and
    comes back again. We are also getting “conflicting anchors” messages in our **Application
    Output** console, which suggest that we’re doing something that’s not quite right.
    Let’s address those issues before we move on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们有一个功能完善的导航框架！然而，当你点击导航按钮时，导航栏会短暂消失然后再次出现。我们的**应用输出**控制台中也出现了“冲突的锚点”消息，这表明我们做了一些不太对的事情。在继续之前，让我们解决这些问题。
- en: Fixing conflicts
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决冲突
- en: The navigation bar problem is a simple one. As explained previously, QML is
    hierarchical in structure. This bears out in the way the elements are rendered—child
    elements that appear first are rendered first. In our case, we draw the navigation
    bar and then we draw the content frame. When the **StackView** component loads
    new content, by default it applies funky transitions to make it look nice. Those
    transitions can result in content moving out of bounds of the control and drawing
    over any content below it. There are a couple of ways to address this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏的问题很简单。如前所述，QML的结构是分层的。这体现在元素的渲染方式上——首先出现的子元素首先被渲染。在我们的情况下，我们先绘制导航栏，然后再绘制内容框架。当**StackView**组件加载新内容时，默认情况下会应用花哨的过渡效果，使其看起来很漂亮。这些过渡效果可能导致内容移出控件的边界并覆盖在其下方的任何内容上。有几种方法可以解决这个问题。
- en: 'Firstly, we can rearrange the order that the components are rendered in and
    put the navigation bar after the content frame. This will draw the navigation
    bar over the top of the `StackView`, regardless of what was going on with it.
    The second option and the one we will implement is to simply set the `clip` property
    of the **StackView**:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以重新排列组件的渲染顺序，并将导航栏放在内容框架之后。这将在`StackView`的顶部绘制导航栏，而不管它的情况如何。第二个选项，也是我们将实现的选项，就是简单地设置**StackView**的`clip`属性：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This clips any content that overlaps the boundary of the control and doesn’t
    render it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这会裁剪任何超出控件边界的内容，并且不会渲染它。
- en: The next problem is a little more esoteric. As we’ve discussed, the number one
    cause of confused head scratching I’ve encountered over the past few years of
    QML development is the sizing of components. Some components we’ve used, such
    as **Rectangle**, are intrinsically visual elements. If their size is not defined,
    either directly with the `width/height` properties or indirectly with **anchors**,
    then they will not render. Other elements such as **Connections** are not visual
    at all and size properties are redundant. Layout elements such as **Column** may
    have a fixed size in one axis, but be dynamic in the other by nature.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题有点更加深奥。正如我们讨论过的，QML开发过去几年中我遇到的最令人困惑的问题之一是组件的大小。我们使用的一些组件，比如**Rectangle**，本质上是视觉元素。如果它们的大小没有被定义，要么是直接使用`width/height`属性，要么是间接使用**anchors**，那么它们就不会被渲染。其他元素，比如**Connections**，根本不是视觉元素，大小属性是多余的。布局元素，比如**Column**，可能在一个轴上有固定的大小，但在另一个轴上是动态的。
- en: One thing that most components have in common is that they inherit from **Item**,
    which in turn inherits directly from **QtObject**, which is just a plain **QObject**.
    In much the same way that the Qt Framework on the C++ side implements a lot of
    default behavior for plain old **QObject***, QML components often implement default
    behavior for **Item** components that we can leverage here.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件共同的一点是它们都继承自**Item**，而**Item**又直接继承自**QtObject**，它只是一个普通的**QObject**。就像C++端的Qt框架为普通的**QObject**实现了很多默认行为一样，QML组件通常为我们可以在这里利用的**Item**组件实现了默认行为。
- en: In our child views, we have used **Rectangle** as our root object. This makes
    sense as we want to display a rectangle of a fixed size and color. However, this
    causes problems for the **StackView** as it doesn’t know what size it should be.
    To provide this information, we try and anchor it to its parent (the **StackView**),
    but then that causes problems of its own by conflicting with the transitions the
    **StackView** is trying to perform when we switch views.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的子视图中，我们使用**Rectangle**作为根对象。这是有道理的，因为我们想要显示一个固定大小和颜色的矩形。然而，这对**StackView**造成了问题，因为它不知道自己应该有多大。为了提供这些信息，我们尝试将其锚定到其父级（**StackView**），但这又会引发自己的问题，与我们切换视图时**StackView**正在执行的过渡效果发生冲突。
- en: 'Our way out of this dilemma is to instead have the root of our child views
    be a plain old **Item**. **StackView** components have internal logic to handle
    **Item** components and will just size it for us. Our **Rectangle** component
    then becomes the child of an **Item** component that has already been sized automatically,
    and we can anchor to that instead:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们摆脱这个困境的方法是，将子视图的根改为普通的**Item**。**StackView**组件具有处理**Item**组件的内部逻辑，并且会自动调整大小。然后，我们的**Rectangle**组件就成为了已经自动调整大小的**Item**组件的子组件，我们可以将其锚定到这个组件上：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is all a bit confusing and feels like Voodoo, but the takeaway here is
    that having **Item** as the root element in your custom QML is often a good thing.
    Go ahead and add a root **Item** component in this way to all the child views
    (but not **MasterView**).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点令人困惑，感觉像巫术一样，但这里的要点是，在你的自定义QML中，将**Item**作为根元素通常是一个好主意。继续在所有子视图中以这种方式添加根**Item**组件（但不包括**MasterView**）。
- en: Run the application again, and you should now have nice smooth transitions and
    no warning messages in the console.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，现在你应该有流畅的过渡效果，并且控制台中没有警告消息。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have a flexible, decoupled navigation mechanism in place and are successfully
    transitioning between different views. We have the basics of a navigation bar
    in place and a working content pane as designed at the beginning of the chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个灵活的、解耦的导航机制，并成功地在不同的视图之间进行了过渡。我们已经建立了导航栏的基本结构，并且在本章开头设计的工作内容窗格中工作。
- en: Having the UI call the business logic layer to emit a signal that the UI then
    reacts to may seem like a bit of a roundabout way of navigating between views,
    but this business logic signal/UI slot design brings benefits. It keeps the UI
    modular as the views don't need to know about each other. It keeps the logic for
    navigation in the business logic layer and enables that layer to request that
    the UI navigate the user to a particular view without needing to know anything
    about the UI or the view itself. Crucially, it also gives us intercept points
    so that when the user requests navigation to a given view, we can handle it and
    perform any additional processing we need, such as state management or cleanup.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让UI调用业务逻辑层发出信号，然后UI对此做出反应，可能看起来有点绕弯，但这种业务逻辑信号/UI插槽设计带来了好处。它使UI模块化，因为视图不需要相互了解。它将导航逻辑保留在业务逻辑层，并使该层能够请求UI将用户导航到特定视图，而无需了解UI或视图本身的任何信息。关键是，它还为我们提供了拦截点，因此当用户请求导航到特定视图时，我们可以处理它并执行任何我们需要的额外处理，比如状态管理或清理。
- en: In [Chapter 4](c3be84d8-850d-4171-9c8a-eb4042d904c9.xhtml)*, Style*, we will
    introduce a shared style component, and QML modules and icons before we complete
    our UI design with a dynamic command bar.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](c3be84d8-850d-4171-9c8a-eb4042d904c9.xhtml)*“样式”*中，我们将介绍共享样式组件，以及在完成动态命令栏的UI设计之前，介绍QML模块和图标。
