- en: Network Monitoring and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络监控和安全
- en: In this chapter, we will look at common tools and techniques for **network monitoring**.
    These techniques can be useful to both alert us to developing problems, and to
    help troubleshoot existing problems. Network monitoring can be important from
    a network security standpoint, where it may be useful to detect, log, or even
    prevent network intrusions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨网络监控的常见工具和技术。这些技术既可以提醒我们注意潜在的问题，也可以帮助我们解决现有的问题。从网络安全的角度来看，网络监控可能有助于检测、记录甚至防止网络入侵。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Checking host reachability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查主机可达性
- en: Displaying a connection route
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示连接路由
- en: Showing open ports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示打开的端口
- en: Listing open connections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出打开的连接
- en: Packet sniffing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包嗅探
- en: Firewalls and packet filtering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙和数据包过滤
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains no C code. Instead, it focuses on useful tools and utilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含C代码。相反，它侧重于有用的工具和实用程序。
- en: The utilities and tools used in this chapter are either built in to your operating
    system or are available as free, open source software. We'll provide instructions
    for each tool as it is introduced.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的工具和实用程序要么是操作系统内置的，要么是免费的开源软件。我们将为每个工具在介绍时提供说明。
- en: The purpose of network monitoring
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络监控的目的
- en: Network monitoring is a common IT term that has a broad implication. Network
    monitoring can refer to the practice, techniques, and tools used to provide insight
    into the status of a network. These techniques are used to monitor the availability
    and performance of networked systems and troubleshoot problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络监控是一个常见的IT术语，具有广泛的含义。网络监控可以指用于深入了解网络状态的实践、技术和工具。这些技术用于监控网络化系统的可用性和性能，并解决网络问题。
- en: 'Some reasons you may want to practice network monitoring include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要练习网络监控的一些原因包括以下：
- en: To detect the reachability of networked systems
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测网络化系统的可达性
- en: To measure the availability of networked systems
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了衡量网络化系统的可用性
- en: To determine the performance of networked systems
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确定网络化系统的性能
- en: To inform decisions about network resource allocation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了告知关于网络资源分配的决定
- en: To aid in troubleshooting
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助故障排除
- en: To benchmark performance
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了基准测试性能
- en: To reverse engineer a protocol
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了逆向工程一个协议
- en: To debug a program
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了调试程序
- en: In this chapter, we look at a small subset of conventional network monitoring
    techniques that may be useful when implementing networked programs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一小部分传统的网络监控技术，这些技术可能在实现网络程序时有用。
- en: When developing or deploying networked programs, it is often the case that you
    run into problems. When this happens, you are faced with two possibilities. The
    first possibility is that your program could have a bug in it. The second possibility
    is that your problem is caused by a network issue. The methods covered in this
    chapter help to identify and troubleshoot network problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发或部署网络程序时，你经常会遇到问题。当这种情况发生时，你面临两种可能性。第一种可能性是程序中可能存在错误。第二种可能性是问题是由网络问题引起的。本章中介绍的方法有助于识别和解决网络问题。
- en: One of the most fundamental questions you could ask is, can this system reach
    that system? The **Ping** utility, which is perhaps the most elementary network
    tool, is designed to answer just that question. Let's consider its usage next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能问的最基本的问题之一是，这个系统能否到达那个系统？**Ping**实用程序，可能是最基础的网络工具，旨在回答正是这个问题。让我们接下来考虑它的用法。
- en: Testing reachability
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试可达性
- en: Perhaps the most basic network monitoring tool is Ping. Ping uses the **Internet
    Control Message Protocol **(**ICMP**) to check whether a host is reachable. It
    also commonly reports the total round-trip time (latency). Ping is available as
    a built-in command or utility for all common operating systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最基本网络监控工具是Ping。Ping使用**互联网控制消息协议**(**ICMP**)来检查主机是否可达。它还通常报告往返总时间（延迟）。Ping在所有常见的操作系统中都作为内置命令或实用程序提供。
- en: 'The ICMP defines a set of special IP messages that are typically useful for
    diagnostic and control purposes. Ping works by using two of these messages: **echo
    request** and **echo reply**. The Ping utility sends an echo request ICMP message
    to a destination host. When that host receives the echo request, it should respond
    with an echo reply message.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 定义了一组特殊的 IP 消息，这些消息通常对诊断和控制目的非常有用。Ping 通过使用这些消息中的两个：**回显请求**和**回显响应**。Ping
    实用程序向目标主机发送一个回显请求 ICMP 消息。当该主机接收到回显请求时，它应该用一个回显响应消息进行响应。
- en: When the echo reply is received, Ping knows that the destination host is reachable.
    Ping can also report the round-trip time from when the echo request was sent to
    when the echo reply was received. ICMP echo messages are usually small and easy
    to process, so this round-trip time often serves as a best-case estimate of network
    latency.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到回显响应时，Ping 就知道目标主机可达。Ping 还可以报告从发送回显请求到接收到回显响应的往返时间。ICMP 回显消息通常很小且易于处理，因此这个往返时间通常作为网络延迟的最佳估计。
- en: 'The Ping utility takes one argument: the hostname or address you''re requesting
    a response from. Ping on Unix-based systems will send packets continuously. On
    Windows, pass in the `-t` flag for this behavior. Press *Ctrl +C* to stop.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ping 实用程序接受一个参数：你请求响应的主机名或地址。基于 Unix 的系统上的 Ping 会持续发送数据包。在 Windows 上，使用 `-t`
    标志来启用此行为。按 *Ctrl +C* 停止。
- en: 'The following screenshot shows using the Ping utility on `example.com`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 `example.com` 上使用 Ping 实用程序：
- en: '![](img/55e7638f-2e39-4d66-b4da-d49420c7b877.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55e7638f-2e39-4d66-b4da-d49420c7b877.png)'
- en: In the preceding screenshot, you can see that several ping messages were sent,
    and each received a response. The round-trip time is reported for each ping message,
    and a summary of all sent packets is also reported. The summary includes the minimum,
    average, and maximum round-trip message time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到发送了几个 ping 消息，并且每个都收到了响应。每个 ping 消息都会报告往返时间，并且还会报告所有发送数据包的摘要。摘要包括最小、平均和最大往返消息时间。
- en: It is also possible to use ping to send larger messages. On Linux and macOS,
    the `-s` flag specifies packet size. On Windows, the `-l` flag is used. It is
    sometimes interesting to see how packet size affects latency and reliability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ping 发送更大的消息也是可能的。在 Linux 和 macOS 上，`-s` 标志指定数据包大小。在 Windows 上，使用 `-l` 标志。有时，观察数据包大小如何影响延迟和可靠性是有趣的。
- en: 'The following screenshot shows pinging `example.com` with a larger 1,000-byte
    ping message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用更大的 1,000 字节 ping 消息ping `example.com`：
- en: '![](img/a0e42745-2d51-47f7-a959-2c7e76163b4c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0e42745-2d51-47f7-a959-2c7e76163b4c.png)'
- en: If ping fails to receive an echo reply, it does not necessarily mean that the
    target host is unreachable. It only means that ping did not receive the expected
    reply. This could be because the target machine ignored the echo request. However,
    most systems *are* set up to respond to ping requests properly, and an echo request
    timeout usually means the target system is unreachable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ping 没有收到回显响应，这并不一定意味着目标主机不可达。这只意味着 ping 没有收到预期的回复。这可能是因为目标机器忽略了回显请求。然而，大多数系统
    *确实* 设置为正确响应 ping 请求，回显请求超时通常意味着目标系统不可达。
- en: Sometimes, just knowing that a host is reachable is enough, but sometimes you'll
    want more information. It can be useful to know the exact path an IP packet takes
    through the network. The **traceroute** utility provides this information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅仅知道主机可达就足够了，但有时候你可能需要更多信息。了解 IP 数据包在网络中确切路径可能很有用。**traceroute** 实用程序提供了这些信息。
- en: Checking a route
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查路由
- en: Although we briefly introduced traceroute in [Chapter 1](e3e07fa7-ff23-4871-b897-c0d4551e6422.xhtml),
    *Introducing Networks and Protocols*, it is worth revisiting in more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在 [第 1 章](e3e07fa7-ff23-4871-b897-c0d4551e6422.xhtml)，“介绍网络和协议”中简要介绍了 traceroute，但更详细地回顾它是有价值的。
- en: While Ping can tell us whether a network path exists between two systems, traceroute
    can reveal what this path actually is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ping 可以告诉我们两个系统之间是否存在网络路径，但 traceroute 可以揭示这个路径实际上是什么。
- en: 'Traceroute is used with one argument: the hostname or address you want to map
    a route to.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Traceroute 使用一个参数：你想要映射路由的主机名或地址。
- en: On Windows, traceroute is called **tracert**. Tracert works in a very similar
    way to the traceroute utility found on Linux and macOS.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，traceroute 被称为 **tracert**。Tracert 的工作方式与 Linux 和 macOS 上找到的 traceroute
    实用程序非常相似。
- en: 'The following screenshot shows the traceroute utility printing the routers
    used to deliver data to `example.com`. The `-n` flag tells `traceroute` not to
    perform reverse-DNS lookups for each hop. These lookups are rarely useful and
    omitting them saves a bit of time and screen space:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了跟踪路由实用程序打印出用于将数据发送到`example.com`的路由器。`-n`标志告诉`traceroute`不要对每个跳数执行反向DNS查找。这些查找很少有用，省略它们可以节省一点时间和屏幕空间：
- en: '![](img/67a51c03-0005-4370-8e1a-c606550380f5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67a51c03-0005-4370-8e1a-c606550380f5.png)'
- en: The preceding screenshot shows that there are four or five routers (or hops)
    between us and the destination system at `example.com`. Traceroute also shows
    the round-trip time to each intermediate router.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示，在我们和`example.com`的目标系统之间有四个或五个路由器（或跳数）。跟踪路由还显示了到达每个中间路由器的往返时间。
- en: Traceroute sends three messages to each router. This often exposes multiple
    network paths, and there is no guarantee that any two messages will take precisely
    the same path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪路由向每个路由器发送三条消息。这通常揭示了多个网络路径，并且不能保证任何两条消息会精确地走相同的路径。
- en: In the preceding example, we see that the message must first pass through `23.92.28.3`.
    From there, it goes to one of three different systems, which are listed. The message
    continues until it reaches the destination at hop five or six, depending on the
    exact path it takes through the network.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到消息必须首先通过`23.92.28.3`。从那里，它到达列出的三个不同系统中的一个。消息继续传递，直到它到达第五或第六个跳数，具体取决于它通过网络的确切路径。
- en: 'This illustrates an interesting point: you shouldn''t assume that two consecutive
    packets take the same network path.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了一个有趣的观点：你不应该假设两个连续的数据包会走相同的网络路径。
- en: How traceroute works
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪路由的工作原理
- en: To understand how traceroute works, we must understand a detail of the **Internet
    Protocol** (**IP**). Each IP packet header contains a field called **Time to Live**
    (**TTL**). TTL is the maximum number of seconds that a packet should live on the
    network before being discarded. This is important to keep an IP packet from simply
    persisting (which is, going in an endless loop) over the network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解跟踪路由是如何工作的，我们必须了解**互联网协议**（**IP**）的一个细节。每个IP数据包头部都包含一个称为**生存时间**（**TTL**）的字段。TTL是数据包在网络中存活的最大秒数，在此之后将被丢弃。这对于防止IP数据包简单地持续存在（即进入无限循环）在网络中非常重要。
- en: TTL time intervals under one second are rounded up. This means that, in practice,
    each router that handles an IP packet decrements the TTL field by `1`. Therefore,
    TTL is often used as a hop-count. That is to say that the TTL field simply represents
    the number of hops a packet can still take over the network.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一秒以下的TTL时间间隔会被向上取整。这意味着在实践中，每个处理IP数据包的路由器都会将TTL字段减`1`。因此，TTL通常用作跳数计数。也就是说，TTL字段仅仅代表了数据包在网络中还可以走的跳数。
- en: The traceroute utility uses TTL to identify intermediate routers in a network.
    Traceroute begins by addressing a message (for example, a UDP datagram or an ICMP
    echo request) to the destination host. However, traceroute sets the TTL field
    to a value of `1`. When the very first router in the connection path receives
    this message, it decrements TTL to zero. The router then realizes that the message
    has expired and discards it. A well-behaved router then sends an ICMP **Time Exceeded**
    message back to the original sender. Traceroute uses this **Time Exceeded** message
    to identify the first router in the connection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪路由实用程序使用TTL来识别网络中的中间路由器。跟踪路由首先将一个消息（例如，UDP数据报或ICMP回显请求）发送到目标主机。然而，跟踪路由将TTL字段设置为`1`。当连接路径中的第一个路由器接收到这条消息时，它会将TTL减到零。然后路由器意识到消息已过期并丢弃它。一个表现良好的路由器随后会向原始发送者发送一个ICMP
    **时间超限**消息。跟踪路由使用这个**时间超限**消息来识别连接中的第一个路由器。
- en: Traceroute repeats this same process with additional messages. The second message
    is sent using a TTL of `2`, and that message identifies the second hop in the
    network path. The third message is sent using a TTL of `3`, and so on. Eventually,
    the message reaches its final destination and traceroute has mapped the entire
    network path.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪路由会重复使用相同的流程，并附加额外的消息。第二条消息使用TTL为`2`发送，这条消息标识了网络路径中的第二个跳数。第三条消息使用TTL为`3`发送，以此类推。最终，消息到达最终目的地，跟踪路由就映射了整个网络路径。
- en: 'The following diagram illustrates the method used by traceroute:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了跟踪路由使用的方法：
- en: '![](img/8b3283b5-c84d-4807-b5e5-627730ea76f1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b3283b5-c84d-4807-b5e5-627730ea76f1.png)'
- en: In the preceding diagram, the first message is sent with a TTL of 1\. Router
    1 doesn't forward this message, but instead returns an ICMP **Time Exceeded**
    message. The second message is sent with a TTL of 2\. It makes it to the second
    router before timing out. The third message makes it to the destination, which
    replies with an **Echo Reply** message. (If this traceroute were UDP-based, it
    would expect to receive an ICMP **Port Unreachable** message instead.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第一条消息的 TTL 为 1。路由器 1 不会转发这条消息，而是返回一个 ICMP **超时** 消息。第二条消息的 TTL 为 2，在超时之前到达第二个路由器。第三条消息到达目的地，目的地回复一个
    **回显应答** 消息。（如果这个 traceroute 是基于 UDP 的，它将期望收到一个 ICMP **端口不可达** 消息。）
- en: Not all routers return an ICMP **Time Exceeded** message, and some networks
    filter out these messages. In these cases, traceroute will have no way to know
    these routers' addresses. Traceroute prints an asterisk instead. Theoretically,
    if a router exists in the connection path that doesn't decrement the TTL field,
    then traceroute has no way of knowing that this router exists.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有路由器都会返回 ICMP **超时** 消息，有些网络会过滤掉这些消息。在这些情况下，traceroute 将无法知道这些路由器的地址。traceroute
    会打印一个星号代替。理论上，如果连接路径中存在一个不递减 TTL 字段的路由器，那么 traceroute 将无法知道这个路由器的存在。
- en: Now that we've covered the way ping and traceroute work, you may be wondering
    how they could be implemented in C code. Unfortunately, despite their simple algorithms,
    this is easier said than done. Keep reading to learn more.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 ping 和 traceroute 的工作方式，你可能想知道它们如何用 C 语言实现。不幸的是，尽管它们的算法很简单，但说起来容易做起来难。继续阅读以了解更多信息。
- en: Raw sockets
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始套接字
- en: You may be interested in implementing your own network testing tools. The ping
    tool seems pretty simple, and it is. Unfortunately, the socket programming APIs
    we've been working with do not provide access at the IP level that the ICMP is
    built on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对实现自己的网络测试工具感兴趣。ping 工具看起来很简单，确实很简单。不幸的是，我们一直在使用的套接字编程 API 并没有提供对 ICMP 所基于的
    IP 层的访问。
- en: The socket programming API does provide access to **raw sockets**, in theory.
    With raw sockets, a C program can construct the exact IP packet to send. That
    is, a C programmer could construct an ICMP packet from scratch and send it over
    the network. Raw sockets also allow for programs to receive uninterpreted packets
    from the network directly. In this case, the user program would be responsible
    for deconstructing and interpreting the ICMP packet, not the operating system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程 API 理论上提供了对 **原始套接字** 的访问。使用原始套接字，C 程序可以构建要发送的确切 IP 数据包。也就是说，C 程序员可以从头开始构建一个
    ICMP 数据包并将其发送到网络上。原始套接字还允许程序直接从网络接收未经解释的数据包。在这种情况下，用户程序将负责分解和解释 ICMP 数据包，而不是操作系统。
- en: 'On systems with raw socket support, getting started can be as simple as changing
    your `socket()` function invocation to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持原始套接字的系统上，开始使用可能就像将你的 `socket()` 函数调用更改为以下内容一样简单：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the problem is that raw sockets aren't universally supported. It is
    a difficult subject to approach in a cross-platform way. Windows, in particular,
    has varying support for raw sockets depending on the OS version. Recent versions
    of Windows have virtually no support for raw sockets. For this reason, we won't
    cover raw sockets in any more detail here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题是原始套接字并不在所有平台上都得到支持。这是一个难以跨平台处理的主题。特别是 Windows，它对原始套接字的支持因操作系统版本而异。Windows
    的最新版本几乎不支持原始套接字。因此，我们在这里不会更详细地介绍原始套接字。
- en: Now that we've covered two basic tools for network troubleshooting, let's next
    look at tools that inform us about our own system's relationship to the network.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了两个基本的网络故障排除工具，接下来让我们看看那些能告诉我们自己的系统与网络关系的工具。
- en: Checking local connections
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查本地连接
- en: It is often useful to know what connections are being made on your local machine.
    The `netstat` command can help with that. **Netstat** is available on Linux, macOS,
    and Windows. Each version differs a little in the command-line options and output,
    but the general usage principles are the same.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你本地机器上正在建立哪些连接通常很有用。`netstat` 命令可以帮助你做到这一点。**Netstat** 在 Linux、macOS 和 Windows
    上都可用。每个版本在命令行选项和输出上都有一些差异，但一般的使用原则是相同的。
- en: I recommend running `netstat` with the `-n` flag. This flag prevents `netstat`
    from doing reverse-DNS lookups on each address and has the effect of speeding
    it up significantly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 `-n` 标志来运行 `netstat`。此标志阻止 `netstat` 对每个地址进行反向 DNS 查询，并且可以显著加快其速度。
- en: 'On Linux, we can use the following command to show open TCP connections:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们可以使用以下命令来显示打开的TCP连接：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the result of running this command on Linux:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Linux上运行此命令的结果：
- en: '![](img/811160a7-9fda-404b-800c-113f9b13dd74.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/811160a7-9fda-404b-800c-113f9b13dd74.png)'
- en: In the preceding screenshot, you can see that `netstat` shows six columns. These
    columns display the protocol, the sending and receiving queue, the local address,
    the foreign address, and the connection state. In this example, we see that there
    are three connections to port `80`. It is likely that this computer is loading
    up three web pages (as HTTP uses port `80`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到`netstat`显示了六列。这些列显示了协议、发送和接收队列、本地地址、远程地址和连接状态。在这个例子中，我们看到有三个连接到端口`80`。这很可能表明这台电脑正在加载三个网页（因为HTTP使用端口`80`）。
- en: On Windows, the `netstat -n -p TCP` command shows the same information, except
    it omits the socket queue information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，`netstat -n -p TCP`命令显示相同的信息，但省略了套接字队列信息。
- en: The queue information, displayed on Unix-based systems, represents how many
    bytes the kernel has queued up waiting for the program to read, or the number
    of bytes sent but not acknowledged by the foreign host. Small numbers are healthy,
    but if these numbers became large, it could indicate a problem with the network
    or a bug in the program.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 队列信息，在基于Unix的系统上显示，表示内核已排队等待程序读取的字节数，或者尚未被远程主机确认发送的字节数。小数字是健康的，但如果这些数字变得很大，可能表明网络有问题或程序中存在错误。
- en: It is also useful to see which program is responsible for each connection. Use
    the `-p` flag on Unix-based systems for this. On Windows, the `-o` flag shows
    PID and the `-b` flag shows executable names.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看看哪个程序负责每个连接也是有用的。在基于Unix的系统上使用`-p`标志。在Windows上，`-o`标志显示PID，而`-b`标志显示可执行文件名。
- en: 'If you''re working on a server, it is often useful to see which listening sockets
    are open. The `-l` flag instructs Unix-based `netstat` to show only listening
    sockets. The following screenshot shows listening TCP server sockets, including
    the program name:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一台服务器上工作，查看哪些监听套接字是打开的通常很有用。`-l`标志指示基于Unix的`netstat`仅显示监听套接字。以下截图显示了监听的TCP服务器套接字，包括程序名称：
- en: '![](img/2e60aa53-efa0-4a2a-bd87-08a2826f856c.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e60aa53-efa0-4a2a-bd87-08a2826f856c.png)'
- en: In the preceding screenshot, we can see that this system is running a DNS resolver
    (`systemd-resolve` on port `53`, IPv4 only), an SSH daemon (`sshd` on port `22`),
    a printer service (`cupsd` on port `631`), and a web server (`apache2` on port
    `80`, IPv6 only).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到这个系统正在运行DNS解析器（`systemd-resolve`在端口`53`，仅IPv4），SSH守护进程（`sshd`在端口`22`），打印机服务（`cupsd`在端口`631`），以及一个Web服务器（`apache2`在端口`80`，仅IPv6）。
- en: 'On Windows, `netstat` doesn''t have an easy way to display only listening sockets.
    Instead, you can use the `-a` flag to display everything. Filtering out only listening
    TCP sockets can be accomplished with the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，`netstat`没有简单的方法来显示仅监听的套接字。相反，你可以使用`-a`标志来显示所有内容。使用以下命令可以过滤出仅监听的TCP套接字：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows using `netstat` on Windows to show only listening
    TCP sockets:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了在Windows上使用`netstat`来仅显示监听TCP套接字：
- en: '![](img/3b0bcc65-a611-4de6-a19c-c2bdbc4314be.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b0bcc65-a611-4de6-a19c-c2bdbc4314be.png)'
- en: With an idea of what programs are communicating from our machine, it may also
    be useful to see what they are communicating. Tools such as `tcpdump` and `tshark`
    specialize in this, and we will cover them next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解我们的机器上程序在通信什么，也许查看它们实际在通信什么也是有用的。像`tcpdump`和`tshark`这样的工具就专门用于此，我们将在下一节介绍它们。
- en: Snooping on connections
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听连接
- en: In addition to seeing which sockets are open on our computer, we can also capture
    the exact data being sent and received.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看我们电脑上打开的套接字外，我们还可以捕获发送和接收的确切数据。
- en: 'We have a few tooling options for this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个工具选项可供选择：
- en: '**tcpdump** is a commonly used program for packet capture on Unix-based systems.
    It is not available on modern Windows systems, however.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tcpdump**是在基于Unix的系统上用于数据包捕获的常用程序。然而，它在现代Windows系统上不可用。'
- en: '**Wireshark** is a very popular network protocol analyzer that includes a very
    nice GUI. Wireshark is free software, released under the GNU GPL license, and
    available on many platforms (including Windows, Linux, and macOS).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wireshark**是一个非常流行的网络协议分析器，它包含一个非常好的图形用户界面。Wireshark是免费软件，在GNU GPL许可下发布，可在许多平台上使用（包括Windows、Linux和macOS）。'
- en: Included with Wireshark is Tshark, a command-line-based tool that allows us
    to dump and analyze network traffic. Programmers often prefer command-line tools
    for their simple interfaces and ease of scripting. They have the additional benefit
    on being usable on systems where GUIs may not be available. For these reasons,
    we focus on using Tshark in this section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 包含 Tshark，这是一个基于命令行的工具，允许我们转储和分析网络流量。程序员通常更喜欢命令行工具，因为它们的界面简单且易于脚本化。它们还有额外的优势，即在没有
    GUI 的系统上也能使用。出于这些原因，我们在这个部分专注于使用 Tshark。
- en: Tshark can be obtained from [https://www.wireshark.org](https://www.wireshark.org).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Tshark 可以从 [https://www.wireshark.org](https://www.wireshark.org) 获取。
- en: 'If you''re running Linux, it is likely that your distro provides a package
    for Tshark. For example, on Ubuntu Linux, the following commands will install
    Tshark:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 Linux，你的发行版可能提供了 Tshark 的软件包。例如，在 Ubuntu Linux 上，以下命令将安装 Tshark：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once installed, Tshark is very easy to use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Tshark 非常易于使用。
- en: You first need to decide which network interface(s) you want to use to capture
    traffic. The desired interface or interfaces are passed to `tshark` with the `-i`
    flag. On Linux, you can listen to all interfaces by passing `-i any`. However,
    Windows doesn't provide the `any` interface. To listen on multiple interfaces
    with Windows, you need to enumerate them separately, for example, `-i 1 -i 2 -i
    3`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要决定你想要使用哪个或哪些网络接口来捕获流量。所需的接口或接口通过 `-i` 标志传递给 `tshark`。在 Linux 上，你可以通过传递
    `-i any` 来监听所有接口。然而，Windows 不提供 `any` 接口。要在 Windows 上监听多个接口，你需要单独枚举它们，例如，`-i 1
    -i 2 -i 3`。
- en: 'Tshark lists the available interfaces with the `-D` flag. The following screenshot
    shows Tshark on Windows enumerating the available network interfaces:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Tshark 使用 `-D` 标志列出可用的接口。以下截图显示了 Tshark 在 Windows 上枚举可用的网络接口：
- en: '![](img/22846afd-df30-4644-8a21-7b7d3047f7b8.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22846afd-df30-4644-8a21-7b7d3047f7b8.png)'
- en: If you want to monitor local traffic (that is., where the communication is between
    two programs on the same computer), you will want to use the `Loopback` adapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要监控本地流量（即，通信发生在同一台计算机上的两个程序之间），你将想要使用 `Loopback` 适配器。
- en: 'Once you''ve identified the network interface you would like to monitor, you
    can start Tshark with the `-i` flag and begin capturing traffic. Use *Ctrl* +
    *C* to stop capturing. The following screenshot shows Tshark in use:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了想要监控的网络接口，你可以使用 `-i` 标志启动 Tshark 并开始捕获流量。使用 *Ctrl* + *C* 停止捕获。以下截图显示了
    Tshark 的使用情况：
- en: '![](img/bac22f5b-e23a-49ce-9a1a-430a09f497e4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bac22f5b-e23a-49ce-9a1a-430a09f497e4.png)'
- en: The preceding screenshot represents only a few seconds of running Tshark on
    a typical Windows desktop. As you can see, there is a lot of traffic into and
    out of an even relatively idle system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图仅代表在典型 Windows 桌面上运行 Tshark 的几秒钟。正如你所见，即使是相对空闲的系统，也有大量的进出流量。
- en: To cut down on the noise, we need to use a capture filter. Tshark implements
    a small language that allows easy specification of which packets to capture and
    which to ignore.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少噪音，我们需要使用一个捕获过滤器。Tshark 实现了一种小型语言，允许轻松指定要捕获哪些数据包以及要忽略哪些数据包。
- en: Explaining filters may be easiest by way of example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例解释过滤器可能最为简单。
- en: For example, if we want to capture only traffic to or from the IP address `8.8.8.8`,
    we will use the `host 8.8.8.8` filter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们只想捕获到或从 IP 地址 `8.8.8.8` 的流量，我们将使用 `host 8.8.8.8` 过滤器。
- en: 'In the following screenshot, we''ve run Tshark with the `host 8.8.8.8` filter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们使用 `host 8.8.8.8` 过滤器运行了 Tshark：
- en: '![](img/b8db829c-454e-44f3-8074-a4d9971cd674.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8db829c-454e-44f3-8074-a4d9971cd674.png)'
- en: You can see that while Tshark was running, it captured two packets. The first
    packet is a DNS request sent to `8.8.8.8`. Tshark informs us that this DNS request
    is for the A record of `example.com`. The second packet is the DNS response received
    from `8.8.8.8`. Tshark shows that the DNS query response indicators that the A
    record for `example.com` is `93.184.216.34`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当 Tshark 运行时，它捕获了两个数据包。第一个数据包是发送到 `8.8.8.8` 的 DNS 请求。Tshark 通知我们这个 DNS
    请求是针对 `example.com` 的 A 记录。第二个数据包是从 `8.8.8.8` 收到的 DNS 响应。Tshark 显示 DNS 查询响应指示
    `example.com` 的 A 记录是 `93.184.216.34`。
- en: Tshark filters also support the Boolean operators `and`, `or`, and `not`. For
    example, to capture only traffic involving the IP addresses `8.8.8.8` and `8.8.4.4`
    you can use the `host 8.8.8.8` filter or the `host 8.8.4.4` filter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Tshark 过滤器还支持布尔运算符 `and`、`or` 和 `not`。例如，要捕获仅涉及 IP 地址 `8.8.8.8` 和 `8.8.4.4`
    的流量，你可以使用 `host 8.8.8.8` 过滤器或 `host 8.8.4.4` 过滤器。
- en: 'Filtering by port number is also very useful and can be done with `port`. For
    example, the following screenshot shows Tshark being used to capture traffic to
    `93.184.216.34` on port `80`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过端口号进行过滤也非常有用，可以使用 `port` 来实现。例如，以下截图展示了 Tshark 被用来捕获到 `93.184.216.34` 端口 `80`
    的流量：
- en: '![](img/e212f568-aa24-40a2-be4b-220bae29dcf0.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e212f568-aa24-40a2-be4b-220bae29dcf0.png)'
- en: In the preceding screenshot, we see that Tshark was run with the `tshark -i
    5 host 93.184.216.34 and port 80` command. This has the effect of capturing all
    traffic on network interface `5` that is to or from `93.184.216.34` port `80`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们看到 Tshark 使用了 `tshark -i 5 host 93.184.216.34 and port 80` 命令。这会捕获网络接口
    `5` 上所有到或来自 `93.184.216.34` 端口 `80` 的流量。
- en: TCP connections are sent as a series of packets. Although Tshark reports capturing
    11 packets, these are all associated with only one TCP connection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接以一系列数据包的形式发送。尽管 Tshark 报告捕获了 11 个数据包，但这些数据包都与单个 TCP 连接相关联。
- en: So far, we've been using Tshark in a way that causes it to display a summary
    of each packet. Often this is enough, but sometimes you will want to be able to
    see the entire contents of a packet.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在以使 Tshark 显示每个数据包摘要的方式使用它。这通常足够了，但有时你可能会想看到数据包的完整内容。
- en: Deep packet inspection
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度数据包检查
- en: 'If we pass `tshark` the `-x` flag, it displays an ASCII and hex dump of every
    packet captured. The following screenshot shows this usage:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给 `tshark` 传递 `-x` 标志，它会显示每个捕获的数据包的 ASCII 和十六进制转储。以下截图展示了这种用法：
- en: '![](img/7f999317-cb19-4d34-9cd1-daeeba517952.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f999317-cb19-4d34-9cd1-daeeba517952.png)'
- en: In the preceding screenshot, you can see that entire IP packets are being dumped.
    In this case, we see the first three packets represent a new TCP connection's
    three-way handshake. The fourth packet contains an HTTP request.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到整个 IP 数据包正在被转储。在这种情况下，我们看到前三个数据包代表了一个新的 TCP 连接的三次握手。第四个数据包包含一个
    HTTP 请求。
- en: This direct insight into each packet's contents isn't always convenient. It's
    often more practical to capture packets to a file and do the analysis later. The
    `-w` option is used with `tshark` to capture packets to a file. You may also want
    to use the `-c` option to limit the number of packets captured. This simple precaution
    protects against accidentally filling your entire hard drive with network traffic.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个数据包内容的直接洞察并不总是方便的。通常，将数据包捕获到文件中并在稍后进行分析更为实际。使用 `tshark` 的 `-w` 选项可以将数据包捕获到文件。你可能还希望使用
    `-c` 选项来限制捕获的数据包数量。这种简单的预防措施可以防止意外用网络流量填满你的整个硬盘。
- en: 'The following screenshot shows using Tshark to capture 50 packets to a file
    named `capture.pcap`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何使用 Tshark 将 50 个数据包捕获到名为 `capture.pcap` 的文件中：
- en: '![](img/b616fc51-0e9a-47c6-b223-7df752700d39.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b616fc51-0e9a-47c6-b223-7df752700d39.png)'
- en: Once the traffic is written to a file, we can use Tshark to analyze it at our
    leisure. Simply run `tshark -r capture.pcap` to get started. For text-based protocols
    (such as HTTP or SMTP), it is also often useful to open the capture file in a
    text editor for analysis.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦流量被写入文件，我们就可以在方便的时候使用 Tshark 来分析它。只需运行 `tshark -r capture.pcap` 即可开始。对于基于文本的协议（如
    HTTP 或 SMTP），在文本编辑器中打开捕获文件进行分析也常常很有用。
- en: The ultimate way to analyze captured traffic is with **Wireshark**. Wireshark
    allows you to load a `capture` file produced with `tshark` or `tcpdump` and analyze
    it with a very nice GUI. Wireshark is also able to understand many standard protocols.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分析捕获流量的最终方式是使用 **Wireshark**。Wireshark 允许你加载由 `tshark` 或 `tcpdump` 生成的 `capture`
    文件，并使用一个非常友好的图形用户界面进行分析。Wireshark 还能够理解许多标准协议。
- en: 'The following screenshot shows using Wireshark to display the traffic captured
    from Tshark:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了使用 Wireshark 显示从 Tshark 捕获的流量：
- en: '![](img/5e9becfa-3a7f-4954-a686-6a8d861a5bfc.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e9becfa-3a7f-4954-a686-6a8d861a5bfc.png)'
- en: If the system you need to capture traffic on has a GUI, you can also use Wireshark
    to capture your traffic directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要捕获流量的系统有一个图形用户界面，你也可以使用 Wireshark 直接捕获你的流量。
- en: If you play around with `tshark` and Wireshark, you will quickly see that it
    is easy to inspect network protocols at a deep level. You may even find some questionable
    security choices made by software running on your own system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用 `tshark` 和 Wireshark，你会很快发现深入检查网络协议非常容易。你甚至可能会发现一些在你自己的系统上运行的软件做出的有疑问的安全选择。
- en: Although we've been focusing on monitoring only network traffic on our local
    system, it is also possible to monitor all local network traffic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们一直专注于监控我们本地系统上的网络流量，但也可以监控所有本地网络流量。
- en: Capturing all network traffic
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获所有网络流量
- en: '`tshark` is only able to see traffic that arrives on your machine. This usually
    means you can only use it to monitor traffic from applications on your computer.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`tshark`只能看到到达你机器的流量。这通常意味着你只能用它来监控你电脑上的应用程序的流量。'
- en: To capture all internet traffic on your network, you must somehow arrange for
    that traffic to arrive at your system, even though it usually wouldn't. There
    are two basic methods to do this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获你网络上的所有互联网流量，你必须以某种方式安排这些流量到达你的系统，尽管通常不会这样。有两种基本方法可以做到这一点。
- en: The first method is by using a router that supports mirroring. This feature
    makes it mirror all traffic to a given Ethernet port. If you are using such a
    router, you can configure it to mirror all network traffic to a particular port,
    and then plug your computer into that port. From that point, any traffic capturing
    tool, such as `tcpdump` or `tshark`, can be used to record this traffic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用支持镜像功能的路由器。这个功能使得它可以将所有流量镜像到指定的以太网端口。如果你正在使用这样的路由器，你可以配置它将所有网络流量镜像到特定的端口，然后把你电脑连接到那个端口。从那时起，任何流量捕获工具，如`tcpdump`或`tshark`，都可以用来记录这个流量。
- en: The second way to sniff all internet traffic is to install a hub (or a switch
    with port mirroring) between your router and internet modem. Hubs work by mirroring
    all traffic to all ports. Hubs used to be a common way to build a network. However,
    they have mostly been replaced by more efficient switches.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种嗅探所有互联网流量的方法是，在你的路由器和互联网调制解调器之间安装一个集线器（或具有端口镜像功能的交换机）。集线器通过将所有流量镜像到所有端口来工作。集线器曾经是构建网络的一种常见方式。然而，它们已经被更高效的交换机所取代。
- en: With a hub installed between your router and Internet modem, you can then connect
    your system directly to this hub. With that setup, you can receive all the internet
    traffic into or out of the network.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的路由器和互联网调制解调器之间安装集线器后，你就可以直接将你的系统连接到这个集线器。有了这样的设置，你可以接收所有进入或离开网络的互联网流量。
- en: To monitor all network traffic (such as, even traffic between devices on the
    same network), you need to build your network with either a hub or a switch that
    supports port mirroring.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要监控所有网络流量（例如，甚至同一网络设备之间的流量），你需要使用支持端口镜像的集线器或交换机来构建你的网络。
- en: It should also be noted, that with the right modem, you can potentially capture
    all Wi-Fi traffic wirelessly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意的是，有了合适的调制解调器，你有可能无线捕获所有Wi-Fi流量。
- en: From a security perspective, let this be instructive. You should never consider
    any network traffic to be secret. Only traffic which is secured appropriately
    using encryption is resistant to monitoring.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，这是一个值得注意的教训。你不应该认为任何网络流量都是秘密的。只有使用加密适当保护的数据流量才能抵抗监控。
- en: Now that we've shown several tools and techniques for testing and monitoring
    network traffic, let's consider the important topic of network security next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了几个用于测试和监控网络流量的工具和技术，接下来让我们考虑重要的网络安全话题。
- en: Network security
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络安全
- en: '**Network security** encompasses the tools, techniques, and practices to protect
    a network from threats. These tools include both hardware and software and can
    protect against a variety of threats.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络安全**包括保护网络免受威胁的工具、技术和实践。这些工具包括硬件和软件，可以抵御各种威胁。'
- en: Although the topic is too broad for much detail here, we will cover a few topics
    that you are likely to encounter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个话题在这里过于宽泛，无法详细讨论，但我们将涵盖你可能会遇到的一些话题。
- en: '**Firewalls** are one of the most common network security techniques. Firewalls
    act as a barrier between one network and another. As commonly used, they monitor
    network traffic and allow or block traffic based on a defined set of rules.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**防火墙**是网络安全中最常见的技巧之一。防火墙在两个网络之间充当屏障。通常情况下，它们监控网络流量，并根据定义的一系列规则允许或阻止流量。'
- en: 'Firewalls come in two types: software and hardware. Most operating systems
    provide software firewalls now. Software firewalls are typically configured to
    deny incoming connections unless a rule is set up to allow it explicitly.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙有两种类型：软件和硬件。现在大多数操作系统都提供了软件防火墙。软件防火墙通常配置为拒绝传入连接，除非设置了规则明确允许它。
- en: It is also possible to configure software firewalls to deny outgoing traffic
    by default. In this case, programs aren't allowed to establish new connections
    unless a specific rule is added to the firewall configuration first.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将软件防火墙配置为默认拒绝传出流量。在这种情况下，除非首先在防火墙配置中添加特定规则，否则程序不允许建立新的连接。
- en: Do be careful about assuming that firewalls catch all traffic. For example,
    the Windows 10 firewall can be configured to deny all outgoing traffic by default,
    but it still lets DNS requests through. An attacker could take advantage of this
    by using DNS requests to exfiltrate data even though the user thinks that they
    are protected via the Windows firewall.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要小心，不要假设防火墙可以捕获所有流量。例如，Windows 10防火墙默认情况下可以配置为拒绝所有出站流量，但它仍然允许DNS请求通过。攻击者可以利用这一点通过DNS请求窃取数据，尽管用户认为他们通过Windows防火墙得到了保护。
- en: Hardware firewalls come with various capabilities. Often, they are configured
    to block any incoming connections that don't match predefined rules. On networks
    without firewalls, routers often implicitly serve this same purpose. If your router
    provides network address translation, then it wouldn't even know what to do with
    an incoming connection unless a port forwarding rule has been pre-established
    for it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件防火墙具有各种功能。通常，它们被配置为阻止任何不符合预定义规则的入站连接。在没有防火墙的网络中，路由器通常隐式地提供相同的服务。如果你的路由器提供网络地址转换，那么除非为它预先建立了端口转发规则，否则它甚至不知道如何处理入站连接。
- en: Although it is important to understand the basics of network security on a wide
    level, as C programmers, we are often more concerned with the security of our
    own programs. Security is not something that the C language makes easy, so let's
    consider application-level security in more detail now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解网络安全的广泛基础很重要，但作为C程序员，我们通常更关心我们自己的程序的安全性。C语言并没有使安全性变得容易，所以现在让我们更详细地考虑应用程序级的安全性。
- en: Application security and safety
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全和可靠性
- en: When programming in C, special consideration must be given to security. This
    is because C is a low-level programming language that gives direct access to system
    resources. Memory management, for example, must be done manually in C, and a mistake
    in memory management could allow a network attacker to write and execute arbitrary
    code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在用C语言编程时，必须特别关注安全问题。这是因为C语言是一种低级编程语言，它可以直接访问系统资源。例如，内存管理在C语言中必须手动完成，内存管理中的错误可能会允许网络攻击者写入和执行任意代码。
- en: With C, it is vital to ensure that allocated memory buffers aren't written past
    the end. That is, whenever you copy data from the network into memory, you must
    ensure that enough memory was allocated to store the data. If your program misses
    this even once, it potentially allows a window for an attacker to gain control
    of your program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C语言时，确保分配的内存缓冲区不会被写入到末尾至关重要。也就是说，每次从网络复制数据到内存时，你必须确保分配了足够的内存来存储数据。如果你的程序错过这一点，哪怕只有一次，也可能为攻击者打开一个窗口，从而控制你的程序。
- en: Memory management, from a security perspective, isn't a concern with many higher-level
    programming languages. In many programming languages, it isn't even possible to
    write outside of allocated memory. Of course, these languages also can't provide
    the precise control of memory layout and data structures that C programmers enjoy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，内存管理在许多高级编程语言中并不是一个关注点。在许多编程语言中，甚至无法编写超出分配内存的操作。当然，这些语言也无法提供C程序员所享受的精确控制内存布局和数据结构的能力。
- en: Even if you are careful to manage memory perfectly, there are still many more
    security gotchas to be on the lookout for. When implementing any network protocol,
    you should never assume that the data your program receives will adhere to the
    protocol specification. If your program does make these assumptions, it will be
    open to attack by a rogue program that doesn't. These protocol bugs are a concern
    in any programming language, not just C. Again, though, the thing about C is that
    these protocol implementation errors can quickly lead to memory errors, and memory
    errors quickly become serious.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你小心翼翼地完美管理内存，仍然有许多安全陷阱需要留意。在实现任何网络协议时，你绝不应该假设程序接收到的数据会遵循协议规范。如果你的程序确实做出了这些假设，它就会对那些不遵循协议的恶意程序开放攻击。这些协议错误在任何编程语言中都是一个关注点，而不仅仅是C语言。然而，关于C语言，这些协议实现错误可以迅速导致内存错误，而内存错误很快就会变得严重。
- en: If you're implementing a C program intended to run as a server, you should employ
    a **defense in depth** approach. That is, you should set up your program in such
    a manner that multiple defenses must be overcome before an attacker could cause
    damage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个作为服务器运行的C程序，你应该采用**多层次防御**的方法。也就是说，你应该以这种方式设置你的程序，使得攻击者在造成损害之前必须克服多个防御措施。
- en: The first layer of defense is writing your program without bugs. Whenever dealing
    with received network data, carefully consider what would happen if the received
    data was not at all what you're expecting. Make sure your program does the appropriate
    thing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层防御是编写没有错误的程序。在处理接收到的网络数据时，仔细考虑如果接收到的数据根本不是你所期望的会发生什么。确保你的程序做正确的事情。
- en: Also, don't run your program with any more privileges than needed for its functionality.
    If your program doesn't need access to a sensitive set of files, make sure your
    operating system doesn't allow it to access those files. Never run server software
    as root.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要以超出程序功能所需的任何更多权限运行你的程序。如果你的程序不需要访问一组敏感文件，确保你的操作系统不允许它访问这些文件。永远不要以root身份运行服务器软件。
- en: If you're implementing an HTTP or HTTPS server, consider not connecting your
    program directly to the internet. Instead, use a reverse proxy server as the first
    point of contact to the internet, and have your software interface only with the
    proxy server. This provides an additional layer of isolation against attacks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个HTTP或HTTPS服务器，考虑不要直接将你的程序连接到互联网。相反，使用反向代理服务器作为与互联网的第一个接触点，并让你的软件仅与代理服务器接口。这为攻击提供了额外的隔离层。
- en: Finally, consider not writing networked code in C at all, if you can find an
    alternative. Many C servers can be rewritten as CGI programs that don't directly
    interact with the network at all. TCP or UDP servers can often be rewritten to
    use `inetd`, and thus avoid the socket programming interface altogether. If your
    program needs to load web pages, consider using a well-tested library, such as
    `libcurl`, for that purpose instead of rolling your own.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你能找到替代方案，考虑完全不要用C编写网络代码。许多C服务器可以被重写为不直接与网络交互的CGI程序。TCP或UDP服务器通常可以被重写为使用`inetd`，从而完全避免套接字编程接口。如果你的程序需要加载网页，考虑使用经过良好测试的库，如`libcurl`，而不是自己编写。
- en: We've covered a few network testing techniques so far. When deploying these
    techniques on live networks, it is important to be considerate. Let's finish with
    a note on etiquette.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些网络测试技术。当在实时网络上部署这些技术时，重要的是要考虑周到。让我们以礼仪的注意事项结束。
- en: Network-testing etiquette
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络测试礼仪
- en: When network testing, it is always important to behave responsibly and ethically.
    Generally speaking, don't test someone else's network without their explicit permission.
    Doing otherwise could cause embarrassment at best, and land you in serious legal
    trouble at worst.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行网络测试时，始终要负责任和道德。一般来说，未经明确许可不要测试他人的网络。否则，最坏的情况可能会让你陷入严重的法律麻烦。
- en: You should also be aware that some network testing techniques can set off alarms.
    For example, many network administrators monitor their network's load and performance
    characteristics. If you decide to load-test these networks without notice, you
    might set off automated alarms causing inconvenience.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该意识到，一些网络测试技术可能会触发警报。例如，许多网络管理员监控他们网络的负载和性能特征。如果你决定在不通知的情况下对这些网络进行负载测试，可能会触发自动警报，造成不便。
- en: Some other testing techniques can look like attacks. Port scanning, for example,
    is a useful technique where a tester tries establishing many connections on different
    ports. It's used to discover which ports on a system are open. However, it is
    a common technique used by malicious attackers to find weaknesses. Some system
    administrators consider port scans to be an attack, and you should never port
    scan a system without permission.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他测试技术可能看起来像攻击。例如，端口扫描是一种有用的技术，其中测试者尝试在不同的端口上建立许多连接。它用于发现系统上哪些端口是开放的。然而，这是一种恶意攻击者用来寻找弱点的常用技术。一些系统管理员认为端口扫描是一种攻击，你永远不应该在没有许可的情况下对系统进行端口扫描。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground over the broad topics of network
    monitoring and security. We looked at tools useful for testing the reachability
    of networked devices. We learned how to trace a path through the network, and
    how to monitor connections made on our local machine. We also discovered how to
    log and inspect network traffic.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了网络监控和安全性的广泛主题。我们探讨了用于测试网络设备可达性的工具。我们学习了如何在网络中追踪路径，以及如何在本地机器上监控连接。我们还发现了如何记录和检查网络流量。
- en: We discussed network security and how it may impact the C developer. By showing
    how network traffic can be directly inspected, we learned first-hand the importance
    of encryption for communication privacy. The importance of security at the application
    level was also discussed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了网络安全及其可能对C语言开发者产生的影响。通过展示如何直接检查网络流量，我们亲身体验了加密对于通信隐私的重要性。还讨论了在应用层进行安全的重要性。
- en: In the next chapter, we take a closer look at how our coding practices affect
    program behavior. We also discuss many essential odds and ends for writing robust
    network applications in C.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨我们的编码实践如何影响程序行为。我们还将讨论在C语言中编写健壮网络应用的一些基本要点。
- en: Questions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您对本章知识的掌握：
- en: Which tool would you use to test the reachability of a target system?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个工具来测试目标系统的可达性？
- en: Which tool lists the routers to a destination system?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个工具列出了到达目标系统的路由器？
- en: What are raw sockets used for?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始套接字用于什么？
- en: Which tools list the open TCP sockets on your system?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个工具列出了您系统上的打开TCP套接字？
- en: What is one of the biggest concerns with security for networked C programs?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于网络化的C程序，最大的安全担忧是什么？
- en: The answers to these questions can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题答案*中找到。
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about the topics covered in this chapter, please refer
    to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖主题的更多信息，请参考以下内容：
- en: '**RFC 792**: *Internet Control Message Protocol* ([https://tools.ietf.org/html/rfc792](https://tools.ietf.org/html/rfc792))'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 792**: *互联网控制消息协议* ([https://tools.ietf.org/html/rfc792](https://tools.ietf.org/html/rfc792))'
- en: Wireshark ([https://www.wireshark.org](https://www.wireshark.org))
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark ([https://www.wireshark.org](https://www.wireshark.org))
