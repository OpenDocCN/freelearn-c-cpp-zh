- en: Monsters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怪物
- en: In this chapter, we will be adding opponents for the player. We'll be creating
    a new landscape to roam around in, with monsters that will start walking toward
    the player when they are close enough to detect them. They will also attack once
    they get within range of the player, giving you some basic gameplay.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为玩家添加对手。我们将创建一个新的景观供其漫游，并且当怪物足够接近以侦测到它们时，它们将开始朝玩家走去。一旦它们进入玩家的射程范围，它们还将发动攻击，为您提供一些基本的游戏玩法。
- en: '![](img/099dee92-144b-4d95-8154-49031935ac34.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/099dee92-144b-4d95-8154-49031935ac34.png)'
- en: 'Let''s take a look at the topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本章涵盖的主题：
- en: Landscape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 景观
- en: Creating Monsters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建怪物
- en: Monster attacks on the player
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 怪物对玩家的攻击
- en: Landscape
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 景观
- en: 'We haven''t covered how to sculpt the landscape in this book yet, so we''ll
    do that here. First, you must have a landscape to work with. To do that, follow
    these steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中尚未涵盖如何雕刻景观，所以我们将在这里进行。首先，您必须有一个景观可供使用。要做到这一点，请按照以下步骤进行：
- en: Start a new file by navigating to File | New Level.... You can choose an empty
    level or a level with a sky. I chose the one without the sky in this example.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到文件|新建级别...开始一个新文件。您可以选择一个空的级别或一个带有天空的级别。在这个例子中，我选择了没有天空的那个。
- en: 'To create a landscape, we have to work from the Modes panel. Make sure that
    the Modes panel is displayed by navigating to Window | Modes:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建景观，我们必须从模式面板中工作。确保通过导航到窗口|模式显示模式面板：
- en: '![](img/8a3fa3b5-85bb-480e-a634-504b05e0fe5e.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a3fa3b5-85bb-480e-a634-504b05e0fe5e.png)'
- en: 'A landscape can be created in three steps, which are shown in the following
    screenshot:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 景观可以通过三个步骤创建，如下面的屏幕截图所示：
- en: '![](img/94d517c5-c8a8-4b22-af61-ae788248c780.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94d517c5-c8a8-4b22-af61-ae788248c780.png)'
- en: 'The three steps are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 三个步骤如下：
- en: Click on the landscape icon (the picture of the mountains) in the Modes panel
  id: totrans-15
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击模式面板中的景观图标（山的图片）
- en: Click on the Manage button
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击管理按钮
- en: Click on the Create button in the lower right-hand corner of the screen
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击屏幕右下角的创建按钮
- en: 'You should now have a landscape to work with. It will appear as a gray, tiled
    area in the main window:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您应该有一个景观可以使用。它将显示为主窗口中的灰色瓷砖区域：
- en: '![](img/7a6f7cb0-afd0-4851-ac58-07423d5fd68e.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a6f7cb0-afd0-4851-ac58-07423d5fd68e.png)'
- en: The first thing you will want to do with your landscape scene is add some color
    to it. What's a landscape without colors?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您在景观场景中要做的第一件事是为其添加一些颜色。没有颜色的景观算什么？
- en: 'Click anywhere on your gray, tiled landscape object. In the Details panel on
    the right, you will see that it is populated with information, as shown in the
    following screenshot:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的灰色瓷砖景观对象的任何位置单击。在右侧的详细信息面板中，您将看到它填充了信息，如下面的屏幕截图所示：
- en: '![](img/d385810c-148a-4e9e-8c31-ac63d7f20a8b.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d385810c-148a-4e9e-8c31-ac63d7f20a8b.png)'
- en: Scroll down until you see the Landscape Material property. You can select the M_Ground_Grass
    material for a realistic-looking ground.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动，直到看到景观材料属性。您可以选择M_Ground_Grass材料，使地面看起来更逼真。
- en: Add a light to the scene. You should probably use a directional light so that
    all of the ground has some light on it. We went over how to do this in [Chapter
    8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml), *Actors and Pawns*.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向场景添加光。您可能应该使用定向光，以便所有地面都有一些光线。我们在[第8章](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml)中已经介绍了如何做到这一点，*演员和棋子*。
- en: Sculpting the landscape
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 雕刻景观
- en: 'A flat landscape can be boring. We should at least add some curves and hills
    to the place. To do so, perform the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平坦的景观可能会很无聊。我们至少应该在这个地方添加一些曲线和山丘。要这样做，请执行以下步骤：
- en: 'Click on the Sculpt button in the Modes panel:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击模式面板中的雕刻按钮：
- en: '![](img/08ac4743-6ac4-4870-951b-963bf391d7e9.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08ac4743-6ac4-4870-951b-963bf391d7e9.png)'
- en: The strength and size of your brush are determined by the Brush Size and Tool
    Strength parameters in the Modes window.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您的刷子的强度和大小由模式窗口中的刷子大小和工具强度参数确定。
- en: Click on your landscape and drag the mouse to change the height of the turf.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击您的景观并拖动鼠标以改变草皮的高度。
- en: 'Once you''re happy with what you''ve got, click on the Play button to try it
    out. The resultant output can be seen in the following screenshot:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您对您所拥有的内容感到满意，请单击播放按钮进行尝试。结果输出如下屏幕截图所示：
- en: '![](img/1930fd27-8065-41f2-ba2c-671e3ad97354.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1930fd27-8065-41f2-ba2c-671e3ad97354.png)'
- en: 'Play around with your landscape and create a scene. What I did was lower the
    landscape around a flat ground plane so that the player has a well-defined flat
    area to walk on, as shown in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩弄您的景观并创建一个场景。我所做的是将景观降低到一个平坦的地面平面周围，以便玩家有一个明确定义的平坦区域可以行走，如下面的屏幕截图所示：
- en: '![](img/cdb0d0a7-010b-4ffc-93f4-7aaeeed000db.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdb0d0a7-010b-4ffc-93f4-7aaeeed000db.png)'
- en: Feel free to do whatever you like with your landscape. You can use what I'm
    doing here as inspiration, if you like.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随意处理您的景观。如果愿意，您可以将我在这里所做的作为灵感。
- en: I recommend that you import assets from ContentExamples or from StrategyGame
    so that you can use them inside your game. To do this, refer to the *Importing
    assets* section in [Chapter 10](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml), *Inventory
    System and Pickup Items*. When you're done importing assets, we can proceed to
    bringing monsters into our world.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您从ContentExamples或StrategyGame导入资产，以便在游戏中使用它们。要做到这一点，请参考[第10章](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml)中的*导入资产*部分，*库存系统和拾取物品*。导入资产完成后，我们可以继续将怪物带入我们的世界。
- en: Creating Monsters
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建怪物
- en: 'We''ll start programming monsters in the same way we programmed NPCs and `PickupItem`.
    We will write a base class (by deriving from character) to represent the `Monster`
    class, then derive a bunch of blueprints for each monster type. Each monster will
    have a couple of properties in common that determine its behavior. The following are
    the common properties:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与我们编程NPC和`PickupItem`相同的方式开始编程怪物。我们将编写一个基类（通过派生自character）来表示`Monster`类，然后为每种怪物类型派生一堆蓝图。每个怪物都将有一些共同的属性，这些属性决定了它的行为。以下是共同的属性：
- en: It will have a `float` variable for speed.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个用于速度的`float`变量。
- en: It will have a `float` variable for the `HitPoints` value (I usually use floats
    for HP, so we can easily model HP leeching effects such as walking through a pool
    of lava).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个用于`HitPoints`值的`float`变量（我通常使用浮点数来表示HP，这样我们可以轻松地模拟HP流失效果，比如走过一片熔岩池）。
- en: It will have an `int32` variable for the experience gained in defeating the
    monster.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个用于击败怪物所获得的经验值的`int32`变量。
- en: It will have a `UClass` function for the loot dropped by the monster.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个用于怪物掉落的战利品的`UClass`函数。
- en: It will have a `float` variable for the `BaseAttackDamage` done by each attack.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个用于每次攻击造成的`BaseAttackDamage`的`float`变量。
- en: It will have a `float` variable for `AttackTimeout`, which is the amount of
    time for which the monster rests between attacking
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个用于`AttackTimeout`的`float`变量，这是怪物在攻击之间休息的时间。
- en: 'It will have two `USphereComponents` objects: one of them is `SightSphere`—how
    far the monster can see. The other is `AttackRangeSphere`, which is how far its
    attack reaches. The `AttackRangeSphere` object is always smaller than `SightSphere`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有两个`USphereComponents`对象：其中一个是`SightSphere`——怪物能看到的距离。另一个是`AttackRangeSphere`，这是它的攻击范围。`AttackRangeSphere`对象始终小于`SightSphere`。
- en: 'Follow these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: Derive from the `Character` class to create your class for `Monster`. You can
    do this in UE4 by going to File | New C++ Class... and then selecting the Character
    option from the menu for your base class.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Character`类派生你的`Monster`类。你可以在UE4中通过转到文件 | 新建C++类...，然后从菜单中选择你的基类的Character选项来完成这个操作。
- en: Fill out the `Monster` class with the base properties.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写`Monster`类的基本属性。
- en: 'Make sure that you declare `UPROPERTY(EditAnywhere, BlueprintReadWrite, Category
    = MonsterProperties)` so that the properties of the monsters can be changed in
    the blueprints. This is what you should have in `Monster.h`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保声明`UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MonsterProperties)`，以便可以在蓝图中更改怪物的属性。这是你应该在`Monster.h`中拥有的内容：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will need some bare minimum code in your `Monster` constructor to get the
    monster''s properties initialized. Use the following code in the `Monster.cpp`
    file (this should replace the default constructor):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在`Monster`构造函数中添加一些最基本的代码，以初始化怪物的属性。在`Monster.cpp`文件中使用以下代码（这应该替换默认构造函数）：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and run the code.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码。
- en: Open Unreal Editor and derive a blueprint based on your `Monster` class (call
    it `BP_Monster`).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开虚幻编辑器，并基于你的`Monster`类派生一个蓝图（称之为`BP_Monster`）。
- en: Now, we can start configuring our monster's `Monster` properties. For the skeletal
    mesh, we won't use the same model for the monster because we need the monster
    to be able to do melee attacks, and the same model does not come with a melee
    attack. However, some of the models in the Mixamo Animation Pack file have melee
    attack animations.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始配置我们怪物的`Monster`属性。对于骨骼网格，我们不会使用相同的模型，因为我们需要怪物能够进行近战攻击，而相同的模型没有近战攻击。然而，Mixamo动画包文件中的一些模型具有近战攻击动画。
- en: 'So, download the Mixamo Animation Pack file from the UE4 marketplace (free):'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，从UE4市场（免费）下载Mixamo动画包文件：
- en: '![](img/362f9aaa-ae15-478b-b496-a3508975a84b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/362f9aaa-ae15-478b-b496-a3508975a84b.png)'
- en: Inside the pack are some pretty gross models that I'd avoid, but others are
    quite good.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 包中有一些相当恶心的模型，我会避免使用，但其他一些模型非常好。
- en: 'You should add the Mixamo Animation Pack file to your project. It hasn''t been
    updated for a while, but you can add it by checking Show all projects and selecting
    version 4.10 from the drop-down list, as shown in the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该将Mixamo动画包文件添加到你的项目中。它已经有一段时间没有更新了，但你可以通过勾选显示所有项目并从下拉列表中选择4.10版本来添加它，如下面的截图所示：
- en: '![](img/0e166f02-471a-4ebc-a3ef-148acd63bdc0.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e166f02-471a-4ebc-a3ef-148acd63bdc0.png)'
- en: 'Edit the `BP_Monster` blueprint''s class properties and select Mixamo_Adam
    (it is actually typed as Maximo_Adam in the current issue of the package) as the
    skeletal mesh. Make sure that you line it up with the capsule component. Also,
    select MixamoAnimBP_Adam as the animation blueprint:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`BP_Monster`蓝图的类属性，并选择Mixamo_Adam（实际上在包的当前版本中是Maximo_Adam）作为骨骼网格。确保将其与胶囊组件对齐。同时，选择MixamoAnimBP_Adam作为动画蓝图：
- en: '![](img/ca4ed3fc-b5ba-466d-9847-8cf08e780dae.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca4ed3fc-b5ba-466d-9847-8cf08e780dae.png)'
- en: We'll modify the animation blueprint to correctly incorporate the melee attack
    animation later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后修改动画蓝图，以正确地包含近战攻击动画。
- en: While you're editing your `BP_Monster` blueprint, change the sizes of the `SightSphere`
    and `AttackRangeSphere` objects to values that make sense to you. I made my monster's
    `AttackRangeSphere` object just big enough to be about an arm's reach (60 units)
    and his `SightSphere` object to be 25 times bigger than that (about 1,500 units).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑`BP_Monster`蓝图时，将`SightSphere`和`AttackRangeSphere`对象的大小更改为你认为合理的值。我让我的怪物的`AttackRangeSphere`对象足够大，大约是手臂长度（60个单位），他的`SightSphere`对象是这个值的25倍大（大约1500个单位）。
- en: 'Remember that the monster will start moving toward the player once he enters
    the monster''s `SightSphere`, and the monster will start attacking the player
    once he is inside the monster''s `AttackRangeSphere` object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一旦玩家进入怪物的`SightSphere`，怪物就会开始朝玩家移动，一旦玩家进入怪物的`AttackRangeSphere`对象，怪物就会开始攻击玩家：
- en: '![](img/ebed74f3-72a6-4d98-80f4-72c22542739a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebed74f3-72a6-4d98-80f4-72c22542739a.png)'
- en: Place a few of your `BP_Monster` instances inside your game; compile and run.
    Without any code to drive the `Monster` character to move, your monsters should
    just stand there idly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中放置一些`BP_Monster`实例；编译并运行。没有任何驱动`Monster`角色移动的代码，你的怪物应该只是闲置在那里。
- en: Basic monster intelligence
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本怪物智能
- en: 'In our game, we''ll add only basic intelligence to the `Monster` characters.
    The monsters will know how to do two basic things:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们只会为`Monster`角色添加基本智能。怪物将知道如何做两件基本的事情：
- en: Track the player and follow him
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪玩家并跟随他
- en: Attack the player
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击玩家
- en: The monster won't do anything else. You can have the monster taunt the player
    when the player is first seen as well, but we'll leave that as an exercise for
    you.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物不会做其他事情。当玩家首次被发现时，你可以让怪物嘲讽玩家，但我们会把这留给你作为练习。
- en: Moving the monster – steering behavior
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动怪物-转向行为
- en: Monsters in very basic games don't usually have complex motion behaviors. Usually,
    they just walk toward the target and attack it. We'll program that type of monster
    in this game, but you can get more interesting play with monsters that position
    themselves advantageously on the terrain to perform ranged attacks and so on.
    We're not going to program that here, but it's something to think about.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 非常基本的游戏中的怪物通常没有复杂的运动行为。通常，它们只是朝着目标走去并攻击它。我们将在这个游戏中编写这种类型的怪物，但你可以通过让怪物在地形上占据有利位置进行远程攻击等方式获得更有趣的游戏体验。我们不会在这里编写，但这是值得考虑的事情。
- en: In order to get the `Monster` character to move toward the player, we need to
    dynamically update the direction of the `Monster` character moving in each frame.
    To update the direction that the monster is facing, we write code in the `Monster::Tick()`
    method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让“怪物”角色朝向玩家移动，我们需要在每一帧动态更新“怪物”角色移动的方向。为了更新怪物面对的方向，我们在“Monster::Tick()”方法中编写代码。
- en: 'The `Tick` function runs in every frame of the game. The signature of the `Tick`
    function is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: “Tick”函数在游戏的每一帧中运行。Tick函数的签名如下：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You need to add this function''s prototype to your `AMonster` class in your
    `Monster.h` file. If we override `Tick`, we can place our own custom behavior
    that the `Monster` character should do in each frame. Here''s some basic code
    that will move the monster toward the player during each frame:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在“Monster.h”文件中的“AMonster”类中添加这个函数的原型。如果我们重写了“Tick”，我们可以在每一帧中放置我们自己的自定义行为，这样“Monster”角色就应该做。下面是一些基本的代码，将在每一帧中将怪物移向玩家：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You also have to add the following includes at the top of the file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在文件顶部添加以下包含：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For `AddMovementInput` to work, you must have a controller selected under the
    AIController Class panel in your blueprint, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使“AddMovementInput”起作用，你必须在蓝图中的AIController类面板下选择一个控制器，如下图所示：
- en: '![](img/65466d23-e455-432a-b7e6-7cf73d2f5dd2.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65466d23-e455-432a-b7e6-7cf73d2f5dd2.png)'
- en: If you have selected `None`, calls to `AddMovementInput` won't have any effect.
    To prevent this, select either the `AIController` class or the `PlayerController`
    class as your AIController Class. Make sure that you check this for every monster
    you've placed on the map.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了“None”，对“AddMovementInput”的调用将不会产生任何效果。为了防止这种情况发生，请选择“AIController”类或“PlayerController”类作为你的AIController类。确保你对地图上放置的每个怪物都进行了检查。
- en: 'The preceding code is very simple. It comprises the most basic form of enemy
    intelligence—simply move toward the player by an incrementally small amount in
    each frame:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码非常简单。它包括了敌人智能的最基本形式-每一帧向玩家移动一小部分：
- en: '![](img/b7ef6c0c-c7db-4051-a3c5-9dd6eb8a64c8.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7ef6c0c-c7db-4051-a3c5-9dd6eb8a64c8.png)'
- en: If your monsters are facing away from the player, try changing the rotation
    of the mesh -90 degrees in the Z direction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的怪物面向玩家的反方向，请尝试在Z方向上将网格的旋转角度减少90度。
- en: 'The result, after a series of frames, will be that the monster tracks and follows
    the player around the level. To understand how this works, you must remember that
    the `Tick` function is called on average about 60 times per second. What this
    means is that, in each frame, the monster moves a tiny bit closer to the player.
    Since the monster moves in very small steps, its action looks smooth and continuous
    (while in reality, it is making small jumps and leaps in each frame):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一系列帧后，怪物将跟踪并围绕关卡追随玩家。要理解这是如何工作的，你必须记住“Tick”函数平均每秒调用约60次。这意味着在每一帧中，怪物都会离玩家更近一点。由于怪物以非常小的步伐移动，它的动作看起来平滑而连续（实际上，它在每一帧中都在做小跳跃）：
- en: '![](img/90504cda-d36b-4541-b6f1-7d83149666b3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90504cda-d36b-4541-b6f1-7d83149666b3.png)'
- en: Discrete nature of tracking—a monster's motion over three superimposed frames
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的离散性-怪物在三个叠加帧上的运动
- en: The reason why the monster moves about 60 times a second is because of a hardware
    constraint. The refresh rate of a typical monitor is 60 Hz, so it acts as a practical
    limiter on how many updates per second are useful. Updating at a frame rate faster
    than the refresh rate is possible, but it is not necessarily useful for games
    since you will only see a new picture once every 1/60 of a second on most hardware.
    Some advanced physics modeling simulations do almost 1,000 updates a second, but
    arguably, you don't need that kind of resolution for a game and you should reserve
    the extra CPU time for something that the player will enjoy instead, such as better
    AI algorithms. Some newer hardware boasts of a refresh rate of up to 120 Hz (look
    up gaming monitors, but don't tell your parents I asked you to blow all your money
    on one).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物每秒移动约60次的原因是硬件限制。典型显示器的刷新率为60赫兹，因此它作为每秒有用的更新次数的实际限制器。以高于刷新率的帧率进行更新是可能的，但对于游戏来说并不一定有用，因为在大多数硬件上，你每1/60秒只能看到一张新图片。一些高级的物理建模模拟几乎每秒进行1,000次更新，但可以说，你不需要那种分辨率的游戏，你应该将额外的CPU时间保留给玩家会喜欢的东西，比如更好的AI算法。一些新硬件宣称刷新率高达120赫兹（查找游戏显示器，但不要告诉你的父母我让你把所有的钱都花在上面）。
- en: The discrete nature of monster motion
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怪物运动的离散性
- en: Computer games are discrete in nature. In the preceding screenshot of superimposed
    sequences of frames, the player is seen as moving straight up the screen, in tiny
    steps. The motion of the monster is also in small steps. In each frame, the monster
    takes one small discrete step toward the player. The monster is following an apparently
    curved path as it moves directly toward where the player is in each frame.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机游戏是离散的。在前面的截图中，玩家被视为沿着屏幕直线移动，以微小的步骤。怪物的运动也是小步骤。在每一帧中，怪物朝玩家迈出一个小的离散步骤。怪物在移动时遵循一条明显的曲线路径，直接朝向每一帧中玩家所在的位置。
- en: 'To move the monster toward the player, follow these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将怪物移向玩家，按照以下步骤进行：
- en: We have to get the player's position. Since the player is accessible in a global
    function, `UGameplayStatics::GetPlayerPawn`, we simply retrieve our pointer to
    the player using this function.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须获取玩家的位置。由于玩家在全局函数`UGameplayStatics::GetPlayerPawn`中可访问，我们只需使用此函数检索指向玩家的指针。
- en: We find the vector pointing from the `Monster` function (`GetActorLocation()`)
    that points to the player (`avatar->GetActorLocation()`).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到了从`Monster`函数(`GetActorLocation()`)指向玩家(`avatar->GetActorLocation()`)的向量。
- en: 'We need to find the vector that points from the monster to the avatar. To do
    this, you have to subtract the location of the monster from the location of the
    avatar, as shown in the following screenshot:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要找到从怪物指向avatar的向量。为此，您必须从怪物的位置中减去avatar的位置，如下面的截图所示：
- en: '![](img/ba693371-ca92-4022-a37f-db4bafa740c2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba693371-ca92-4022-a37f-db4bafa740c2.png)'
- en: 'It''s a simple math rule to remember, but often easy to get wrong. To get the
    right vector, always subtract the source (the starting point) vector from the
    target (the terminal point) vector. In our system, we have to subtract the `Monster`
    vector from the `Avatar` vector. This works because subtracting the `Monster`
    vector from the system moves the `Monster` vector to the origin, and the `Avatar`
    vector will be to the lower left-hand side of the `Monster` vector:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的数学规则，但往往容易出错。要获得正确的向量，始终要从目标（终点）向量中减去源（起点）向量。在我们的系统中，我们必须从`Monster`向量中减去`Avatar`向量。这是因为从系统中减去`Monster`向量会将`Monster`向量移动到原点，而`Avatar`向量将位于`Monster`向量的左下方：
- en: '![](img/28a26f5a-99e2-4765-b5d9-d592214bbbec.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28a26f5a-99e2-4765-b5d9-d592214bbbec.png)'
- en: 'Be sure to try out your code. At this point, the monsters will be running toward
    your player and crowding around him. With the preceding code that is outlined,
    they won''t attack; they''ll just follow him around, as shown in the following
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 确保尝试你的代码。此时，怪物将朝向你的玩家奔跑并围拢在他周围。通过上述代码的设置，它们不会攻击，只会跟随他，如下面的截图所示：
- en: '![](img/57fafe09-5b16-444e-82e9-518cebc00290.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57fafe09-5b16-444e-82e9-518cebc00290.png)'
- en: Monster SightSphere
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monster SightSphere
- en: Right now, the monsters are not paying attention to the `SightSphere` component.
    That is, wherever the player is in the world, the monsters will move toward him
    in the current setup. We want to change that now.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，怪物并未注意`SightSphere`组件。也就是说，在世界中无论玩家在哪里，怪物都会朝向他移动。我们现在想要改变这一点。
- en: To do so, all we have to do is have `Monster` respect the `SightSphere` restriction.
    If the player is inside the monster's `SightSphere` object, the monster will give
    chase. Otherwise, the monsters will be oblivious to the player's location and
    not chase the player.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要让`Monster`遵守`SightSphere`的限制。如果玩家在怪物的`SightSphere`对象内，怪物将进行追击。否则，怪物将对玩家的位置视而不见，不会追击玩家。
- en: 'Checking to see if an object is inside a sphere is simple. In the following
    screenshot, the point **p** is inside the sphere if the distance **d** between
    **p** and the center **c** is less than the sphere radius, **r**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象是否在球体内很简单。在下面的截图中，如果点**p**和中心**c**之间的距离**d**小于球体半径**r**，则点**p**在球体内：
- en: '![](img/9cc450f6-dc51-49ea-aa6c-e85521cf4c98.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cc450f6-dc51-49ea-aa6c-e85521cf4c98.png)'
- en: P is inside the sphere when d is less than r
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当d小于r时，P在球体内
- en: 'So, in our code, the preceding screenshot translates to the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的代码中，前面的截图翻译成以下内容：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code adds additional intelligence to the `Monster` character.
    The `Monster` character can now stop chasing the player if the player is outside
    the monster''s `SightSphere` object. This is how the result will look:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码为`Monster`角色添加了额外的智能。`Monster`角色现在可以在玩家超出怪物的`SightSphere`对象范围时停止追逐玩家。结果如下：
- en: '![](img/5cf683b3-17bb-4e80-b390-fe36c15f53e8.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cf683b3-17bb-4e80-b390-fe36c15f53e8.png)'
- en: 'A good thing to do here will be to wrap up the distance comparison into a simple
    inline function. We can provide these two inline member functions in the `Monster`
    header, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要做的一个好事情是将距离比较封装到一个简单的内联函数中。我们可以在`Monster`头文件中提供这两个内联成员函数，如下所示：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These functions return the value `true` when the passed parameter, `d`, is inside
    the spheres in question.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在传递的参数`d`在相关的球体内时返回值`true`。
- en: An inline function means that the function is more like a macro than a function.
    Macros are copied and pasted to the calling location, while functions are jumped
    to by C++ and executed at their location. Inline functions are good because they
    give good performance while keeping the code easy to read. They are reusable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数意味着该函数更像是一个宏而不是函数。宏被复制并粘贴到调用位置，而函数则由C++跳转并在其位置执行。内联函数很好，因为它们能够提供良好的性能，同时保持代码易于阅读。它们是可重用的。
- en: Monster attacks on the player
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怪物对玩家的攻击
- en: There are a few different types of attacks that monsters can do. Depending on
    the type of the `Monster` character, a monster's attack might be melee (close
    range) or ranged (projectile weapon).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物可以进行几种不同类型的攻击。根据`Monster`角色的类型，怪物的攻击可能是近战或远程攻击。
- en: The `Monster` character will attack the player whenever the player is in its `AttackRangeSphere`
    object. If the player is out of the range of the monster's `AttackRangeSphere` object
    but the player is in the `SightSphere` object of the monster, then the monster
    will move closer to the player until the player is in the monster's `AttackRangeSphere`
    object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monster`角色将在玩家进入其`AttackRangeSphere`对象时攻击玩家。如果玩家超出怪物的`AttackRangeSphere`对象的范围，但玩家在怪物的`SightSphere`对象中，则怪物将向玩家靠近，直到玩家进入怪物的`AttackRangeSphere`对象。'
- en: Melee attacks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近战攻击
- en: The dictionary definition of *melee* is a confused mass of people. A melee attack
    is one that is done at a close range. Picture a bunch of *zerglings* battling
    it out with a bunch of *ultralisks* (if you're a StarCraft player, you'll know
    that both zerglings and ultralisks are melee units). Melee attacks are basically
    close range, hand-to-hand combat. To do a melee attack, you need a melee attack
    animation that turns on when the monster begins its melee attack. To do this,
    you need to edit the animation blueprint in UE4's animation editor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*melee*的词典定义是一群混乱的人。近战攻击是在近距离进行的攻击。想象一群*zerglings*与一群*ultralisks*激烈战斗（如果你是星际争霸玩家，你会知道zerglings和ultralisks都是近战单位）。近战攻击基本上是近距离的肉搏战。要进行近战攻击，您需要一个近战攻击动画，当怪物开始近战攻击时，它会打开。为此，您需要在UE4的动画编辑器中编辑动画蓝图。'
- en: 'Zak Parrish''s series is an excellent place to get started with programming
    animations in blueprints: [https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8](https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Zak Parrish的系列是学习在蓝图中编程动画的绝佳起点：[https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8](https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8)。
- en: For now, we'll just program the melee attack and then worry about modifying
    the animation in blueprints later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只会编写近战攻击，然后担心以后在蓝图中修改动画。
- en: Defining a melee weapon
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义近战武器
- en: 'There are going to be three parts to defining our melee weapon. They are as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有三个部分来定义我们的近战武器。它们如下：
- en: The C++ code that represents it
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表它的C++代码
- en: The model
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: A UE4 blueprint that connects the code and model together
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接代码和模型的UE4蓝图
- en: Coding for a melee weapon in C++
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用C++编写近战武器
- en: 'We''ll define a new class, `AMeleeWeapon` (derived from `AActor`), to represent
    hand-held combat weapons (as you might have figured out by now, the A is added
    automatically to the name you use). I will attach a couple of blueprint-editable
    properties to the `AMeleeWeapon` class, and the `AMeleeWeapon` class will look
    as shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个新类`AMeleeWeapon`（派生自`AActor`），代表手持战斗武器（您现在可能已经猜到，A会自动添加到您使用的名称中）。我将附加一些蓝图可编辑的属性到`AMeleeWeapon`类，并且`AMeleeWeapon`类将如下所示：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how I used a bounding box for `ProxBox` and not a bounding sphere. This
    is because swords and axes will be better approximated by boxes rather than spheres.
    There are two member functions, `Rest()` and `Swing()`, which let `MeleeWeapon`
    know what state the actor is in (resting or swinging). There's also a `TArray<AActor*>
    ThingsHit` property inside this class that keeps track of the actors hit by this
    melee weapon on each swing. We are programming it so that the weapon can only
    hit each thing once per swing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在`ProxBox`中使用了边界框，而不是边界球。这是因为剑和斧头更适合用盒子而不是球来近似。这个类内部还有两个成员函数`Rest()`和`Swing()`，让`MeleeWeapon`知道演员处于什么状态（休息或挥舞）。这个类内还有一个`TArray<AActor*>
    ThingsHit`属性，用于跟踪每次挥舞时被这个近战武器击中的演员。我们正在编程，以便武器每次挥舞只能击中每个事物一次。
- en: 'The `AMeleeWeapon.cpp` file will contain just a basic constructor and some
    simple code to send damages to `OtherActor` when our sword hits it. We''ll also
    implement the `Rest()` and `Swing()` functions to clear the list of things hit.
    The `MeleeWeapon.cpp` file has the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMeleeWeapon.cpp`文件将只包含一个基本构造函数和一些简单的代码，用于在我们的剑击中`OtherActor`时发送伤害。我们还将实现`Rest()`和`Swing()`函数以清除被击中的事物列表。`MeleeWeapon.cpp`文件包含以下代码：'
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Downloading a sword
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载一把剑
- en: 'To complete this exercise, we need a sword to put into the model''s hand. I
    added a sword to the project called *Kilic* from [http://tf3dm.com/3d-model/sword-95782.html](http://tf3dm.com/3d-model/sword-95782.html)
    by Kaan Gülhan. The following is a list of other places where you will get free
    models:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，我们需要一把剑放在模型的手中。我从[Kaan Gülhan](http://tf3dm.com/3d-model/sword-95782.html)添加了一个名为*Kilic*的剑到项目中。以下是您可以获得免费模型的其他地方的列表：
- en: '[http://www.turbosquid.com/](http://www.turbosquid.com/)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.turbosquid.com/](http://www.turbosquid.com/)'
- en: '[http://tf3dm.com/](http://tf3dm.com/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://tf3dm.com/](http://tf3dm.com/)'
- en: '[http://archive3d.net/](http://archive3d.net/)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://archive3d.net/](http://archive3d.net/)'
- en: '[http://www.3dtotal.com/](http://www.3dtotal.com/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.3dtotal.com/](http://www.3dtotal.com/)'
- en: Secret tip
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 秘诀
- en: 'It might appear at first on [TurboSquid.com](http://TurboSquid.com) that there
    are no free models. In fact, the secret is that you have to select free under
    Price:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 乍看之下，在[TurboSquid.com](http://TurboSquid.com)上似乎没有免费模型。实际上，秘诀在于您必须在价格下选择免费：
- en: '![](img/a490b27f-7f26-432b-b5aa-42cc31a5c2f0.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a490b27f-7f26-432b-b5aa-42cc31a5c2f0.png)'
- en: 'I had to edit the kilic sword mesh slightly to fix the initial sizing and rotation.
    You can import any mesh in the **Filmbox** (**FBX**) format into your game. The
    kilic sword model is in the sample code package for this chapter. To import your
    sword into the UE4 editor, perform the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不稍微编辑kilic剑网格，以修复初始大小和旋转。您可以将任何**Filmbox**（**FBX**）格式的网格导入到您的游戏中。kilic剑模型包含在本章的示例代码包中。要将您的剑导入UE4编辑器，请执行以下步骤：
- en: Right-click on any folder you want to add the model to
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击要将模型添加到的任何文件夹
- en: Navigate to New Asset | Import to (path)...
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新资产|导入到（路径）...
- en: From the file explorer that pops up, select the new asset you want to import.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的文件资源管理器中，选择要导入的新资产。
- en: If a Models folder doesn't exist, you can create one by simply right-clicking
    on the tree view at the left and selecting New Folder in the pane on the left-hand
    side of the Content Browser tab
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Models文件夹不存在，您可以通过在左侧的树视图上右键单击并在内容浏览器选项卡的左侧窗格中选择新文件夹来创建一个。
- en: 'I selected the `kilic.fbx` asset from my desktop:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我从桌面上选择了`kilic.fbx`资产：
- en: '![](img/45784dd7-4728-40b3-9c87-5ac514e17acb.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45784dd7-4728-40b3-9c87-5ac514e17acb.png)'
- en: Creating a blueprint for your melee weapon
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为近战武器创建蓝图
- en: 'The steps to create a blueprint for your melee weapon are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建近战武器蓝图的步骤如下：
- en: Inside the UE4 editor, create a blueprint based off of `AMeleeWeapon` called
    `BP_MeleeSword`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4编辑器中，创建一个基于`AMeleeWeapon`的蓝图，名为`BP_MeleeSword`。
- en: 'Configure `BP_MeleeSword` to use the kilic blade model (or any blade model
    you choose), as shown in the following screenshot:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`BP_MeleeSword`以使用kilic刀片模型（或您选择的任何刀片模型），如下截图所示：
- en: '![](img/cca72232-e787-4af8-b8df-e39c6920a0e5.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cca72232-e787-4af8-b8df-e39c6920a0e5.png)'
- en: 'The `ProxBox` class will determine whether something was hit by the weapon,
    so we''ll modify the `ProxBox` class so that it just encloses the blade of the
    sword, as shown in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProxBox`类将确定武器是否击中了某物，因此我们将修改`ProxBox`类，使其仅包围剑的刀片，如下截图所示：'
- en: '![](img/557119be-e6aa-4e96-98b5-2f2afe4b1341.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/557119be-e6aa-4e96-98b5-2f2afe4b1341.png)'
- en: 'Under the Collision Presets panel, it is important to select the NoCollision
    option for the mesh (not BlockAll). This is illustrated in the following screenshot:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在碰撞预设面板下，对于网格（而不是BlockAll），选择NoCollision选项非常重要。如下截图所示：
- en: '![](img/bd4c4809-0985-44e7-91bc-afe6a6e32a7d.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4c4809-0985-44e7-91bc-afe6a6e32a7d.png)'
- en: If you select BlockAll, then the game engine will automatically resolve all
    the interpenetration between the sword and the characters by pushing away things
    that the sword touches whenever it is swung. The result is that your characters
    will appear to go flying whenever a sword is swung.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果选择BlockAll，则游戏引擎将自动解决剑和角色之间的所有相互穿透，通过推开剑触碰到的物体。结果是，每当挥动剑时，您的角色将似乎飞起来。
- en: Sockets
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插座
- en: A socket in UE4 is a receptacle on one skeletal mesh for another `Actor`. You
    can place a socket anywhere on a skeletal mesh body. After you have correctly
    placed the socket, you can attach another `Actor` to this socket in UE4 code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，插座是一个骨骼网格上的插座，用于另一个“Actor”。您可以在骨骼网格身上的任何地方放置插座。在正确放置插座后，您可以在UE4代码中将另一个“Actor”连接到此插座。
- en: For example, if we want to put a sword in our monster's hand, we'd just have
    to create a socket in our monster's hand. We can attach a helmet to the player
    by creating a socket on his head.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要在怪物的手中放一把剑，我们只需在怪物的手上创建一个插座。我们可以通过在玩家的头上创建一个插座，将头盔连接到玩家身上。
- en: Creating a skeletal mesh socket in the monster's hand
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在怪物的手中创建一个骨骼网格插座
- en: 'To attach a socket to the monster''s hand, we have to edit the skeletal mesh
    that the monster is using. Since we used the Mixamo_Adam skeletal mesh for the
    monster, we have to open and edit this skeletal mesh. To do so, perform the following
    steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要将插座连接到怪物的手上，我们必须编辑怪物正在使用的骨骼网格。由于我们使用了Mixamo_Adam骨骼网格用于怪物，我们必须打开并编辑此骨骼网格。为此，请执行以下步骤：
- en: Double-click on the Mixamo_Adam skeletal mesh in the Content Browser tab (this
    will appear as the T-pose) to open the skeletal mesh editor.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击内容浏览器选项卡中的Mixamo_Adam骨骼网格（这将显示为T形），以打开骨骼网格编辑器。
- en: 'If you don''t see Mixamo Adam in your Content Browser tab, make sure that you
    have imported the Mixamo Animation Pack file into your project from the Unreal
    Launcher app:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在内容浏览器选项卡中看不到Mixamo Adam，请确保已经从Unreal Launcher应用程序将Mixamo动画包文件导入到项目中：
- en: '![](img/38214ed6-eb3e-41ec-9713-af15d7a21f2f.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38214ed6-eb3e-41ec-9713-af15d7a21f2f.png)'
- en: Click on Skeleton at the top-right corner of the screen.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击屏幕右上角的Skeleton。
- en: Scroll down the tree of bones in the left-hand side panel until you find the
    RightHand bone.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板的骨骼树中向下滚动，直到找到RightHand骨骼。
- en: 'We''ll attach a socket to this bone. Right-click on the RightHand bone and
    select Add Socket, as shown in the following screenshot:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在此骨骼上添加一个插座。右键单击RightHand骨骼，然后选择Add Socket，如下截图所示：
- en: '![](img/8804beca-cfb9-4430-b55d-a345d5a9b4fc.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8804beca-cfb9-4430-b55d-a345d5a9b4fc.png)'
- en: 'You can leave the default name (RightHandSocket) or rename the socket if you
    like, as shown in the following screenshot:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以保留默认名称（RightHandSocket），或者根据需要重命名插座，如下截图所示：
- en: '![](img/ef650814-b14d-40e9-9416-df4685a222ff.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef650814-b14d-40e9-9416-df4685a222ff.png)'
- en: Next, we need to add a sword to the actor's hand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将剑添加到角色的手中。
- en: Attaching the sword to the model
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将剑连接到模型
- en: 'The steps to attach the sword are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 连接剑的步骤如下：
- en: With the Adam skeletal mesh open, find the RightHandSocket option in the tree
    view. Since Adam swings with his right hand, you should attach the sword to his
    right hand.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Adam骨骼网格，找到树视图中的RightHandSocket选项。由于Adam用右手挥舞，所以应该将剑连接到他的右手上。
- en: 'Right-click on the RightHandSocket option, select Add Preview Asset, and find
    the skeletal mesh for the sword in the window that appears:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击RightHandSocket选项，选择Add Preview Asset，并在出现的窗口中找到剑的骨骼网格：
- en: '![](img/4fef8179-57ae-4873-926e-6151ac4dd213.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fef8179-57ae-4873-926e-6151ac4dd213.png)'
- en: 'You should see Adam grip the sword in the image of the model, on the right-hand
    side of the following screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在模型的图像中看到Adam握着剑，如下截图所示：
- en: '![](img/4f3f2584-be87-4dc2-9467-423e25a01453.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f3f2584-be87-4dc2-9467-423e25a01453.png)'
- en: Now, click on RightHandSocket and zoom in on Adam's hand. We need to adjust
    the positioning of the socket in the preview so that the sword fits in it correctly.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击RightHandSocket并放大Adam的手。我们需要调整预览中插座的位置，以便剑能正确放入其中。
- en: 'Use the move and rotate manipulators or manually change the socket parameters
    in the Details window to line the sword up so that it fits in his hand correctly:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用移动和旋转操作器或手动更改详细窗口中的插座参数，使剑正确放入他的手中：
- en: '![](img/35148bf0-82e2-46c0-9c75-6e6e48946a84.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35148bf0-82e2-46c0-9c75-6e6e48946a84.png)'
- en: A real-world tip
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实世界的提示
- en: If you have several sword models that you want to switch in and out of the same
    `RightHandSocket`, you will need to ensure quite a bit of uniformity (lack of
    anomalies) between the different swords that are supposed to go in that same socket.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有几个剑模型，想要在同一个`RightHandSocket`中切换，您需要确保这些不同的剑之间有相当的一致性（没有异常）。
- en: 'You can preview your animations with the sword in the hand by going to the
    Animation tab in the top-right corner of the screen:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过转到屏幕右上角的动画选项卡来预览手中拿着剑的动画：
- en: '![](img/d85e7871-26ca-400d-900a-882e7f37f0df.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d85e7871-26ca-400d-900a-882e7f37f0df.png)'
- en: However, if you launch your game, Adam won't be holding a sword. That's because
    adding the sword to the socket in Persona is for preview purposes only.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您启动游戏，Adam将不会拿着剑。这是因为在Persona中将剑添加到插槽仅用于预览目的。
- en: Code to equip the player with a sword
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给玩家装备剑的代码
- en: To equip your player with a sword from the code and permanently bind it to the
    actor, instantiate an `AMeleeWeapon` instance and attach it to `RightHandSocket`
    after the monster instance is initialized. We do this in `PostInitializeComponents()`
    since, in this function, the `Mesh` object will have been fully initialized already.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要从代码中为玩家装备一把剑并将其永久绑定到角色，需要在怪物实例初始化后实例化一个`AMeleeWeapon`实例，并将其附加到`RightHandSocket`。我们在`PostInitializeComponents()`中执行此操作，因为在这个函数中，`Mesh`对象已经完全初始化。
- en: 'In the `Monster.h` file, add a hook to select the `Blueprint` class name (`UClass`)
    of a melee weapon to use. Also, add a hook for a variable to actually store the
    `MeleeWeapon` instance using the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Monster.h`文件中，添加一个选择要使用的近战武器的`Blueprint`类名称（`UClass`）的挂钩。此外，使用以下代码添加一个变量的挂钩来实际存储`MeleeWeapon`实例：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also, make sure that you add `#include "MeleeWeapon.h"` at the top of the file.
    Now, select the `BP_MeleeSword` blueprint in your monster's blueprint class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保在文件顶部添加`#include "MeleeWeapon.h"`。现在，在怪物的蓝图类中选择`BP_MeleeSword`蓝图。
- en: 'In the C++ code, you need to instantiate the weapon. To do so, we need to declare
    and implement a `PostInitializeComponents` function for the `Monster` class. In
    `Monster.h`, add a prototype declaration:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++代码中，您需要实例化武器。为此，我们需要为`Monster`类声明和实现一个`PostInitializeComponents`函数。在`Monster.h`中，添加原型声明：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`PostInitializeComponents` runs after the monster object''s constructor has
    completed and all of the components of the object are initialized (including the
    blueprint construction). So, it is the perfect time to check whether the monster
    has a `MeleeWeapon` blueprint attached to it or not and to instantiate this weapon
    if it does. The following code is added to instantiate the weapon in the `Monster.cpp`
    implementation of `AMonster::PostInitializeComponents()`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostInitializeComponents`在怪物对象的构造函数完成并且对象的所有组件都初始化（包括蓝图构造）之后运行。因此，现在是检查怪物是否附加了`MeleeWeapon`蓝图的完美时机，并在有的情况下实例化这个武器。以下代码被添加到`Monster.cpp`的`AMonster::PostInitializeComponents()`实现中以实例化武器：'
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, make sure to put `#include "Engine/SkeletalMeshSocket.h"` at the top
    of the file. The monsters will now start with swords in hand if `BPMeleeWeapon`
    is selected for that monster''s blueprint:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保在文件顶部添加`#include "Engine/SkeletalMeshSocket.h"`。如果为怪物的蓝图选择了`BPMeleeWeapon`，那么怪物现在将会从一开始就拿着剑：
- en: '![](img/c8ca07fb-67ea-4ec5-bc93-e6994e0512ef.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8ca07fb-67ea-4ec5-bc93-e6994e0512ef.png)'
- en: Triggering the attack animation
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发攻击动画
- en: By default, there is no connection between our C++ `Monster` class and triggering
    the attack animation; in other words, the `MixamoAnimBP_Adam` class has no way
    of knowing when the monster is in the attack state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的C++ `Monster`类与触发攻击动画之间没有连接；换句话说，`MixamoAnimBP_Adam`类无法知道怪物何时处于攻击状态。
- en: Therefore, we need to update the animation blueprint of the Adam skeleton (`MixamoAnimBP_Adam`)
    to include a query in the `Monster` class variable listing and check whether the
    monster is in an attacking state. We haven't worked with animation blueprints
    (or blueprints in general) in this book before, but follow these instructions
    step by step and you should see it come together.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要更新Adam骨骼的动画蓝图（`MixamoAnimBP_Adam`），以包括在`Monster`类变量列表中查询并检查怪物是否处于攻击状态。我们在本书中之前没有使用过动画蓝图（或者一般的蓝图），但是按照这些说明一步一步来，你应该能够看到它的实现。
- en: I'll introduce blueprints terminology gently here, but I'll encourage you to
    have a look at Zak Parrish's tutorial series at [https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH](https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH)
    for your first introduction to blueprints.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里温和地介绍蓝图术语，但我鼓励您去看一下Zak Parrish的教程系列，了解蓝图的初步介绍。
- en: Blueprint basics
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图基础知识
- en: A UE4 blueprint is a visual realization of the code (not to be confused with
    how sometimes people say that a C++ class is a metaphorical blueprint of a class
    instance). In UE4 blueprints, instead of actually writing code, you drag and drop
    elements onto a graph and connect them to achieve the desired play. By connecting
    the right nodes to the right elements, you can program anything you want in your
    game.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: UE4蓝图是代码的视觉实现（不要与有时人们说C++类是类实例的比喻蓝图混淆）。在UE4蓝图中，您不需要实际编写代码，而是将元素拖放到图表上并连接它们以实现所需的播放。通过将正确的节点连接到正确的元素，您可以在游戏中编写任何您想要的东西。
- en: This book does not encourage the use of blueprints since we are trying to encourage
    you to write your own code instead. Animations, however, are best worked with
    blueprints, because that is what artists and designers will know.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不鼓励使用蓝图，因为我们试图鼓励您编写自己的代码。然而，动画最好使用蓝图，因为这是艺术家和设计师所熟悉的。
- en: 'Let''s start writing a sample blueprint to get a feel of how they work:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一个示例蓝图，以了解它们的工作原理：
- en: 'Click on the Blueprints menu bar at the top and select Open Level Blueprint,
    as shown in the following screenshot:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击顶部的蓝图菜单栏，选择“打开级别蓝图”，如下图所示：
- en: '![](img/30c64367-3938-4bd3-9bff-a4ab5a4d36ea.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30c64367-3938-4bd3-9bff-a4ab5a4d36ea.png)'
- en: 'The Level Blueprint option executes automatically when you begin the level.
    Once you open this window, you should see a blank slate to create your gameplay
    on, as shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 级别蓝图选项在开始级别时会自动执行。打开此窗口后，您应该看到一个空白的画布，可以在上面创建游戏玩法，如下图所示：
- en: '![](img/69ea554d-fcca-457e-9d6c-c9918fbb4acd.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ea554d-fcca-457e-9d6c-c9918fbb4acd.png)'
- en: Right-click anywhere on the graph paper.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图纸上的任何位置右键单击。
- en: Start typing `begin` and click on the Event Begin Play option from the drop-down
    list that appears.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始键入“begin”，然后从下拉列表中选择“事件开始播放”选项。
- en: 'Ensure that the Context Sensitive checkbox is checked, as shown in the following
    screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选中上下文敏感复选框，如下图所示：
- en: '![](img/09a8efff-e8c0-4d7b-a7e2-66fe5ebd1646.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a8efff-e8c0-4d7b-a7e2-66fe5ebd1646.png)'
- en: 'Immediately after you click on the Event Begin Play option, a red box will
    appear on your screen. It has a single white pin on the right-hand side. This
    is called the execution pin, as shown here:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单击“事件开始播放”选项后，屏幕上会出现一个红色框。右侧有一个白色引脚。这被称为执行引脚，如下所示：
- en: '![](img/856e15bb-4a78-448d-a1a5-2f62f37d9da2.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/856e15bb-4a78-448d-a1a5-2f62f37d9da2.png)'
- en: 'The first thing that you need to know about animation blueprints is the white
    pin execution path (the white line). If you''ve seen a blueprint graph before,
    you must have noticed a white line going through the graph, as shown in the following
    diagram:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动画蓝图，您需要了解的第一件事是白色引脚执行路径（白线）。如果您以前见过蓝图图表，您一定会注意到白线穿过图表，如下图所示：
- en: '![](img/8afd6b4b-eab7-435c-837a-957a1427358a.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8afd6b4b-eab7-435c-837a-957a1427358a.png)'
- en: The white pin execution path is pretty much equivalent to having lines of code
    lined up and run one after the other. The white line determines which nodes will
    get executed and in what order. If a node does not have a white execution pin
    attached to it, then that node will not get executed at all.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 白色引脚执行路径基本上相当于将代码排成一行并依次运行。白线确定了将执行哪些节点以及执行顺序。如果一个节点没有连接白色执行引脚，那么该节点将根本不会被执行。
- en: Drag the white execution pin off Event Begin Play.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将白色执行引脚拖出“事件开始播放”。
- en: Start by typing `draw debug box` in the Executable actions dialog.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在“可执行操作”对话框中键入“draw debug box”。
- en: 'Select the first thing that pops up (fDraw Debug Box), as shown here:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择弹出的第一项（fDraw Debug Box），如下图所示：
- en: '![](img/44282d51-4c34-4c01-bd77-187c8efa5ab9.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44282d51-4c34-4c01-bd77-187c8efa5ab9.png)'
- en: 'Fill in some details for how you want the box to look. Here, I selected the
    color blue for the box, the center of the box at (0, 0, 100), the size of the
    box to be (200, 200, 200), and a duration of 180 seconds (be sure to enter a duration
    that is long enough that you can see the result), as shown in the following screenshot:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写一些关于盒子外观的细节。在这里，我选择了蓝色的盒子，盒子的中心在（0, 0, 100），盒子的大小为（200, 200, 200），持续时间为180秒（请确保输入足够长的持续时间，以便您可以看到结果），如下图所示：
- en: '![](img/83031d3b-4f34-4633-9969-fbc4a60e86fe.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83031d3b-4f34-4633-9969-fbc4a60e86fe.png)'
- en: Now, click on the Play button to realize the graph. Remember that you have to
    find the world's origin to see the debug box.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，单击“播放”按钮以实现图表。请记住，您必须找到世界原点才能看到调试框。
- en: 'Find the world''s origin by placing a golden egg at (`0, 0`, (some `z` value)),
    as shown in the following screenshot, or try increasing the line thickness to
    make it more visible:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在（0, 0，（某个z值））放置一个金色蛋来找到世界原点，如下图所示，或者尝试增加线条粗细以使其更加可见：
- en: '![](img/0847a7b9-141e-4370-828b-fffb37162f92.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0847a7b9-141e-4370-828b-fffb37162f92.png)'
- en: 'This is how the box will look in the level:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在级别中盒子的样子：
- en: '![](img/ec1eee36-0d8a-4f42-a3ad-ab2455b7b498.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec1eee36-0d8a-4f42-a3ad-ab2455b7b498.png)'
- en: Modifying the animation blueprint for Mixamo Adam
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Mixamo Adam的动画蓝图
- en: To integrate our attack animation, we have to modify the blueprint. Under Content
    Browser, open up `MixamoAnimBP_Adam`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成我们的攻击动画，我们必须修改蓝图。在内容浏览器中，打开“MixamoAnimBP_Adam”。
- en: 'The first thing you''ll notice is that the graph has two sections above the
    Event Notifies section:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的第一件事是，图表在事件通知部分上方有两个部分：
- en: The top section is marked as Basic Character movement....
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部标有“基本角色移动...”。
- en: The bottom section says Mixamo Example Character Animation....
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部显示“Mixamo示例角色动画...”。
- en: 'Basic character movement is in charge of the walking and running movements
    of the model. We''ll be working in the Mixamo Example Character Animation with
    Attack and Jump section, which is responsible for the attack animation. We''ll
    be working in the latter section of the graph, as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 基本角色移动负责模型的行走和奔跑动作。我们将在负责攻击动画的Mixamo示例角色动画部分进行工作。我们将在图表的后半部分进行工作，如下图所示：
- en: '![](img/ebebd7b4-e25e-4b79-859c-395edd3b50d9.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebebd7b4-e25e-4b79-859c-395edd3b50d9.png)'
- en: When you first open the graph, it starts out by zooming in on a section near
    the bottom. To scroll up, right-click the mouse and drag it upwards. You can also
    zoom out using the mouse wheel or by holding down the *Alt* key and the right
    mouse button while moving the mouse up.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次打开图表时，它会首先放大到靠近底部的部分。要向上滚动，右键单击鼠标并向上拖动。您还可以使用鼠标滚轮缩小，或者按住*Alt*键和右键同时向上移动鼠标来缩小。
- en: 'Before proceeding, you might want to duplicate the MixamoAnimBP_Adam resource
    so that you don''t damage the original, in case you need to go back and change
    something later. This allows you to easily go back and correct things if you find
    that you''ve made a mistake in one of your modifications, without having to reinstall
    a fresh copy of the whole animation package into your project:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能希望复制MixamoAnimBP_Adam资源，以防需要稍后返回并进行更改而损坏原始资源。这样可以让您轻松返回并纠正问题，如果发现您在修改中犯了错误，而无需重新安装整个动画包的新副本到您的项目中：
- en: '![](img/b1e64964-84fe-4a34-8d19-cac80acc6293.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1e64964-84fe-4a34-8d19-cac80acc6293.png)'
- en: When assets are added to a project from the Unreal Launcher, a copy of the original
    asset is made, so you can modify MixamoAnimBP_Adam in your project now and get
    a fresh copy of the original assets in a new project later.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当从虚幻启动器向项目添加资产时，会复制原始资产，因此您现在可以在项目中修改MixamoAnimBP_Adam，并在以后的新项目中获得原始资产的新副本。
- en: 'We''re going to do only a few things to make Adam swing the sword when he is
    attacking. Let''s do it in this order:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的只是让Adam在攻击时挥动剑。让我们按照以下顺序进行：
- en: 'Delete the node that says Attacking?:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除说“正在攻击”的节点：
- en: '![](img/a854e233-ab67-4e0f-9f14-5235f6478623.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a854e233-ab67-4e0f-9f14-5235f6478623.png)'
- en: 'Rearrange the nodes, as follows, with the Enable Attack node by itself at the
    bottom:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新排列节点，如下所示，使Enable Attack节点单独位于底部：
- en: '![](img/c60e121a-d732-400c-8326-59e9c536c342.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c60e121a-d732-400c-8326-59e9c536c342.png)'
- en: 'We''re going to handle the monster that this animation is animating. Scroll
    up the graph a bit and drag the blue dot marked as Return Value in the Try Get
    Pawn Owner dialog. Drop it into your graph and, when the pop-up menu appears,
    select Cast to Monster (ensure that Context Sensitive is checked, or the Cast
    to Monster option will not appear). The Try Get Pawn Owner option gets the `Monster`
    instance that owns the animation, which is just the `AMonster` class object, as
    shown in the following screenshot:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将处理此动画正在播放的怪物。向上滚动一点图表，并拖动标有Try Get Pawn Owner对话框中的Return Value的蓝点。将其放入图表中，当弹出菜单出现时，选择Cast
    to Monster（确保已选中上下文敏感，否则Cast to Monster选项将不会出现）。Try Get Pawn Owner选项获取拥有动画的`Monster`实例，这只是`AMonster`类对象，如下图所示：
- en: '![](img/af2cf342-af78-4cff-b678-654390089ac3.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af2cf342-af78-4cff-b678-654390089ac3.png)'
- en: 'Click on + in the Sequence dialog and drag another execution pin from the Sequence
    group to the Cast to Monster node instance, as shown in the following screenshot.
    This ensures that the Cast to Monster instance actually gets executed:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Sequence对话框中的+，并从Sequence组将另一个执行引脚拖动到Cast to Monster节点实例，如下图所示。这确保了Cast to
    Monster实例实际上被执行：
- en: '![](img/bbee93c5-cb1f-435a-bbc1-cd9b4d36e413.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbee93c5-cb1f-435a-bbc1-cd9b4d36e413.png)'
- en: 'The next step is to pull out the pin from the As Monster terminal of the Cast
    to Monster node and look for the Is in Attack Range property:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从Cast to Monster节点的As Monster端口拉出引脚，并查找Is in Attack Range属性：
- en: 'For this to show up, you need to go back to `Monster.h` and add the following
    line before the is in Attack Range function and compile the project (this will
    be explained a little later):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示这一点，您需要回到`Monster.h`并在is in Attack Range函数之前添加以下行，并编译项目（稍后将对此进行解释）：
- en: '`UFUNCTION(BlueprintCallable, Category = Collision)`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION(BlueprintCallable, Category = Collision)`'
- en: '![](img/17dac8e2-421b-4e46-933a-76910aa82edc.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17dac8e2-421b-4e46-933a-76910aa82edc.png)'
- en: 'There should automatically be a line from the white execution pin from the
    Cast to Monster node on the left-hand side of the Is in Attack Range node on the
    right-hand side. Next, drag another line from As Monster and this time look for
    Get Distance To:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该自动从左侧Cast to Monster节点的白色执行引脚到右侧Is in Attack Range节点有一条线。接下来，从As Monster再拖出一条线，这次查找Get
    Distance To：
- en: '![](img/d6c28419-9dd2-4087-964b-a534901f7447.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6c28419-9dd2-4087-964b-a534901f7447.png)'
- en: 'You need to add a node to get the Player character to send to the Other Actor
    node of Get Distance To. Just right-click anywhere and look for Get Player Character:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要添加一个节点来获取玩家角色并将其发送到Get Distance To的Other Actor节点。只需右键单击任何位置，然后查找Get Player
    Character：
- en: '![](img/b4197cef-65b9-4ab1-a66b-2b2223366a1b.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4197cef-65b9-4ab1-a66b-2b2223366a1b.png)'
- en: 'Connect the Return Value node from Get Player Character to Other Actor, and
    Return Value from Get Distance To to D in Is In Attack Range:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Get Player Character的返回值节点连接到Other Actor，将Get Distance To的返回值连接到Is In Attack
    Range的D：
- en: '![](img/a346fb6f-3da4-4e9c-baf1-ad7ef4f63973.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a346fb6f-3da4-4e9c-baf1-ad7ef4f63973.png)'
- en: 'Pull the white and red pins over to the SET node, as shown here:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将白色和红色引脚拖到SET节点上，如图所示：
- en: '![](img/35f5c1f6-8cbe-45e6-a86e-324565b2024b.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35f5c1f6-8cbe-45e6-a86e-324565b2024b.png)'
- en: 'The equivalent pseudocode of the preceding blueprint is something similar to
    the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 前面蓝图的等效伪代码类似于以下内容：
- en: '[PRE12]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Test your animation. The monster should swing only when it's within the player's
    range. If it doesn't work and you created a duplicate, make sure that you switched
    the `animBP` to the duplicate. Also, the default animation is shooting, not swinging
    a sword. We will be fixing that later.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的动画。怪物应该只在玩家范围内挥动。如果不起作用并且您创建了副本，请确保将`animBP`切换到副本。此外，默认动画是射击，而不是挥动剑。我们稍后会修复这个问题。
- en: Code to swing the sword
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挥动剑的代码
- en: 'We want to add an animation notify event when the sword is swung:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在挥动剑时添加动画通知事件：
- en: 'Declare and add a blueprint callable C++ function to your `Monster` class:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并向您的`Monster`类添加一个蓝图可调用的C++函数：
- en: '[PRE13]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `BlueprintCallable` statement means that it will be possible to call this
    function from blueprints. In other words, `SwordSwung()` will be a C++ function
    that we can invoke from a blueprints node, as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlueprintCallable`语句意味着可以从蓝图中调用此函数。换句话说，`SwordSwung()`将是一个我们可以从蓝图节点调用的C++函数，如下所示：'
- en: '[PRE14]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Open the Mixamo_Adam_Sword_Slash animation by double-clicking on it from your
    Content Browser (it should be in MixamoAnimPack/Mixamo_Adam/Anims/Mixamo_Adam_Sword_Slash).
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击Content Browser中的Mixamo_Adam_Sword_Slash动画（应该在MixamoAnimPack/Mixamo_Adam/Anims/Mixamo_Adam_Sword_Slash中）打开。
- en: Find the point where Adam starts swinging his sword.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到Adam开始挥动剑的地方。
- en: 'Right-click that point on the Notifies bar and select New Notify under Add
    Notify..., as shown in the following screenshot:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击Notifies栏上的那一点，然后在Add Notify...下选择New Notify，如下截图所示：
- en: '![](img/b8e6713c-cf27-4651-b2d0-95376742a1e6.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8e6713c-cf27-4651-b2d0-95376742a1e6.png)'
- en: 'Name the notification `SwordSwung`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通知命名为`SwordSwung`：
- en: '![](img/40f7087a-a2a0-49da-99d7-7ac61a68c4d9.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40f7087a-a2a0-49da-99d7-7ac61a68c4d9.png)'
- en: 'The notification name should appear in your animation''s timeline, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通知名称应出现在动画的时间轴上，如下所示：
- en: '![](img/0f5f2318-f089-4e65-abb2-28e50f1f3ce4.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f5f2318-f089-4e65-abb2-28e50f1f3ce4.png)'
- en: Save the animation and then open up your version of MixamoAnimBP_Adam again.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存动画，然后再次打开您的MixamoAnimBP_Adam版本。
- en: 'Underneath the SET group of nodes, create the following graph:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SET节点组下面，创建以下图表：
- en: '![](img/e70c5fcf-6cba-47f1-bacd-2174d596cd80.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e70c5fcf-6cba-47f1-bacd-2174d596cd80.png)'
- en: The AnimNotify_SwordSwung node appears when you right-click in the graph (with
    Context Sensitive turned on) and start typing `SwordSwung`. The Cast To Monster
    node is again fed in from the Try Get Pawn Owner node, as in step 2 of the *Modifying
    the animation blueprint for Mixamo Adam* section.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您右键单击图表（打开上下文敏感）并开始输入`SwordSwung`时，将出现AnimNotify_SwordSwung节点。Monster节点再次从Try
    Get Pawn Owner节点中输入，就像*修改Mixamo Adam动画蓝图*部分的第2步一样。
- en: Sword Swung is our blueprint-callable C++ function in the `AMonster` class (you
    will need to compile the project for this to show up).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sword Swung是`AMonster`类中可调用的蓝图C++函数（您需要编译项目才能显示）。
- en: You also need to go into the AnimGraph tab of MaximoAnimBP_Adam.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要进入MaximoAnimBP_Adam的AnimGraph选项卡。
- en: Double-click on State Machine to open that graph.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击状态机以打开该图表。
- en: Double-click on the attacking state to open that.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击攻击状态以打开。
- en: Select the one on the left that says Play Mixamo_Adam Shooting.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择左侧的Play Mixamo_Adam Shooting。
- en: 'Shooting is the default animation, but that''s clearly not what we want to
    happen. So, delete that and right-click and look for Play Mixamo_Adam_Sword_Slash.
    Then, click from the little icon of a person and drag it the Result of Final Animation
    Pose:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 射击是默认动画，但显然这不是我们想要发生的。因此，删除它，右键单击并查找Play Mixamo_Adam_Sword_Slash。然后，从一个人的小图标拖动到最终动画姿势的结果：
- en: '![](img/a5be2291-79fe-4c79-946c-cbebc67ae619.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5be2291-79fe-4c79-946c-cbebc67ae619.png)'
- en: 'If you start the game now, your monsters will execute their attack animation
    whenever they actually attack. If you also override `TakeDamage` in the `AAvatar`
    class to reduce HP when the sword''s bounding box comes into contact with you,
    you will see your HP bar go down a bit (recall that the HP bar was added at the
    end of [Chapter 8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml), *Actors and Pawns*,
    as an exercise):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在开始游戏，您的怪物将在实际攻击时执行它们的攻击动画。如果您还在`AAvatar`类中重写`TakeDamage`以在剑的边界框与您接触时减少HP，您将看到您的HP条减少一点（请回忆，HP条是在[第8章](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml)的最后添加的，*Actors
    and Pawns*，作为一个练习）：
- en: '![](img/e4885b2d-6c9b-4228-9cec-1e4a0e84cf1f.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4885b2d-6c9b-4228-9cec-1e4a0e84cf1f.png)'
- en: Projectile or ranged attacks
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投射或远程攻击
- en: Ranged attacks usually involve a projectile of some sort. Projectiles are things
    such as bullets, but they can also include things such as lightning magic attacks
    or fireball attacks. To program a projectile attack, you should spawn a new object
    and only apply the damage to the player if the projectile reaches the player.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 远程攻击通常涉及某种抛射物。抛射物可以是子弹之类的东西，但也可以包括闪电魔法攻击或火球攻击之类的东西。要编写抛射物攻击，您应该生成一个新对象，并且只有在抛射物到达玩家时才对玩家造成伤害。
- en: 'To implement a basic bullet in UE4, we should derive a new object type. I derived
    an `ABullet` class from the `AActor` class, as shown in the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UE4中实现基本的子弹，我们应该派生一个新的对象类型。我从`AActor`类派生了一个`ABullet`类，如下所示：
- en: '[PRE15]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ABullet` class has a couple of important members in it, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABullet`类中有一些重要的成员，如下所示：'
- en: A `float` variable for the damage that a bullet does on contact
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`float`变量，用于表示子弹接触时造成的伤害
- en: A `Mesh` variable for the body of the bullet
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Mesh`变量，用于表示子弹的主体
- en: A `ProxSphere` variable to detect when the bullet finally hits something
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ProxSphere`变量，用于检测子弹最终击中物体的情况
- en: A function to be run when `Prox` is detected near an object
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`Prox`检测到靠近物体时运行的函数
- en: 'The constructor for the `ABullet` class should have the initialization of the
    `Mesh` and `ProxSphere` variables. In the constructor, we set `RootComponent` as
    the `Mesh` variable and then attached the `ProxSphere` variable to the `Mesh`
    variable. The `ProxSphere` variable will be used for collision checking. Collision
    checking for the `Mesh` variable should be turned off, as shown in the following
    code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABullet`类的构造函数应该初始化`Mesh`和`ProxSphere`变量。在构造函数中，我们将`RootComponent`设置为`Mesh`变量，然后将`ProxSphere`变量附加到`Mesh`变量上。`ProxSphere`变量将用于碰撞检查。应该关闭`Mesh`变量的碰撞检查，如下所示：'
- en: '[PRE16]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We initialized the `Damage` variable to `1` in the constructor, but this can
    be changed in the UE4 editor once we create a blueprint out of the `ABullet` class.
    Next, the `ABullet::Prox_Implementation()` function should deal damage to the
    actor if we collide with the other actor''s `RootComponent.` We can implement
    this by code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中将`Damage`变量初始化为`1`，但一旦我们从`ABullet`类创建蓝图，可以在UE4编辑器中更改这个值。接下来，`ABullet::Prox_Implementation()`函数应该在我们与其他角色的`RootComponent`碰撞时对角色造成伤害。我们可以通过代码实现这一点：
- en: '[PRE17]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Bullet physics
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子弹物理
- en: To make bullets fly through the level, you can use UE4's physics engine.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要使子弹飞过关卡，您可以使用UE4的物理引擎。
- en: Create a blueprint based on the `ABullet` class. I selected Shape_Sphere for
    the mesh and scaled it down to a more appropriate size. The bullet's mesh should
    have collision physics enabled, but the bullet's bounding sphere will be used
    to calculate damage.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基于`ABullet`类的蓝图。我选择了Shape_Sphere作为网格，并将其缩小到更合适的大小。子弹的网格应启用碰撞物理，但子弹的包围球将用于计算伤害。
- en: 'Configuring the bullet to behave properly is mildly tricky, so we''ll cover
    this in four steps, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 配置子弹的行为是有点棘手的，所以我们将在四个步骤中进行介绍，如下所示：
- en: Select Mesh (Inherited) in the Components tab. The `ProxSphere` variable should
    be under the Mesh.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件选项卡中选择Mesh（继承）。`ProxSphere`变量应该在Mesh下面。
- en: In the Details tab, check both Simulate Physics and Simulation Generates Hit
    Events.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息选项卡中，勾选模拟物理和模拟生成碰撞事件。
- en: From the Collision Presets drop-down list, select Custom....
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从碰撞预设下拉列表中选择自定义....
- en: 'Select Collision Enabled (Query and Physics) from the Collision Enabled dropdown.
    Also, check the Collision Responses boxes, as shown; check Block for most types
    (WorldStatic, WorldDynamic, and so on) and check Overlap, but only for Pawn:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从碰撞启用下拉菜单中选择碰撞启用（查询和物理）。同时，勾选碰撞响应框，如图所示；对于大多数类型（WorldStatic、WorldDynamic等），勾选Block，但只对Pawn勾选Overlap：
- en: '![](img/d6763116-289f-4124-b346-e15ac551212a.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6763116-289f-4124-b346-e15ac551212a.png)'
- en: The Simulate Physics checkbox makes the `ProxSphere` property experience gravity
    and the impulse forces exerted on it. An impulse is a momentary thrust of force,
    which we'll use to drive the shot of the bullet. If you do not check the Simulation
    Generate Hit Events checkbox, then the ball will drop to the floor. What Blocking
    All Collision does is ensure that the ball can't pass through anything.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟物理复选框使`ProxSphere`属性受到重力和对其施加的冲量力的影响。冲量是瞬时的力量推动，我们将用它来驱动子弹的射击。如果不勾选模拟生成碰撞事件复选框，那么球体将掉到地板上。阻止所有碰撞的作用是确保球体不能穿过任何物体。
- en: 'If you drag and drop a couple of these `BP_Bullet` objects from the Content
    Browser tab directly into the world now, they will simply fall to the floor. You
    can kick them once they are on the floor. The following screenshot shows the ball
    object on the floor:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在直接从内容浏览器选项卡将几个`BP_Bullet`对象拖放到世界中，它们将简单地掉到地板上。当它们在地板上时，你可以踢它们。下面的截图显示了地板上的球体对象：
- en: '![](img/28db3eff-f0db-4e40-af94-d77fa0d03978.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28db3eff-f0db-4e40-af94-d77fa0d03978.png)'
- en: However, we don't want our bullets falling on the floor. We want them to be
    shot. So, let's put our bullets in the `Monster` class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不希望子弹掉在地板上。我们希望它们被射出。因此，让我们把子弹放在`Monster`类中。
- en: Adding bullets to the monster class
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将子弹添加到怪物类
- en: 'Let''s look at a step-by-step way to do this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步来看一下如何做到这一点：
- en: 'Add a member to the `Monster` class that receives a blueprint instance reference.
    That''s what the `UClass` object type is for. Also, add a blueprint configurable
    `float` property to adjust the force that shoots the bullet, as shown in the following
    code:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Monster`类添加一个接收蓝图实例引用的成员。这就是`UClass`对象类型的用途。此外，添加一个蓝图可配置的`float`属性来调整射出子弹的力量，如下所示：
- en: '[PRE18]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile and run the C++ project and open your `BP_Monster` blueprint.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行C++项目，打开你的`BP_Monster`蓝图。
- en: 'You can now select a blueprint class under `BPBullet`, as shown in the following
    screenshot:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以在`BPBullet`下选择一个蓝图类，如下图所示：
- en: '![](img/7bcb73ca-41ea-41f4-8b58-b8002a16b82c.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bcb73ca-41ea-41f4-8b58-b8002a16b82c.png)'
- en: Once you've selected a blueprint class type to instantiate when the monster
    shoots, you have to program the monster to shoot when the player is in its range.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了怪物射击时要实例化的蓝图类类型，就必须编写代码让怪物在玩家处于其射程范围内时进行射击。
- en: Where does the monster shoot from? Actually, it should shoot from a bone. If
    you're not familiar with this terminology, bones are just reference points in
    the model's mesh. A model mesh is usually made up of many "bones."
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物从哪里射击？实际上，它应该从一个骨骼中射击。如果你对这个术语不熟悉，骨骼只是模型网格中的参考点。模型网格通常由许多“骨骼”组成。
- en: 'To see some bones, open up the Mixamo_Adam mesh by double-clicking on the asset
    in the Content Browser tab, as shown in the following screenshot:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看一些骨骼，通过在内容浏览器选项卡中双击资产打开Mixamo_Adam网格，如下截图所示：
- en: '![](img/4bab18f9-4d0a-41ae-9488-852cb695ec28.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bab18f9-4d0a-41ae-9488-852cb695ec28.png)'
- en: Go to the Skeleton tab and you will see all the monster's bones in a tree view
    list in the left-hand side. What we want to do is select a bone from which bullets
    will be emitted. Here, I've selected the `LeftHand` option.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到骨架选项卡，你将在左侧看到所有怪物骨骼的树形视图列表。我们要做的是选择一个骨骼从中发射子弹。在这里，我选择了`LeftHand`选项。
- en: An artist will normally insert an additional bone into the model mesh to emit
    the particle, which is likely to be on the tip of the nozzle of a gun.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家通常会在模型网格中插入一个额外的骨骼来发射粒子，这可能在枪口的尖端。
- en: Working from the base model mesh, we can get the `Mesh` bone's location and
    have the monster emit the `Bullet` instances from that bone in the code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础模型网格开始，我们可以获取`Mesh`骨骼的位置，并在代码中让怪物从该骨骼发射`Bullet`实例。
- en: 'The complete monster `Tick` and `Attack` functions can be obtained using the
    following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码获得完整的怪物`Tick`和`Attack`函数：
- en: '[PRE19]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `AMonster::Attack` function is relatively simple. Of course, we first need
    to add a prototype declaration in the `Monster.h` file in order to write our function
    in the `.cpp` file:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMonster::Attack`函数相对简单。当然，我们首先需要在`Monster.h`文件中添加原型声明，以便在`.cpp`文件中编写我们的函数：'
- en: '[PRE20]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In `Monster.cpp`, we implement the `Attack` function, as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Monster.cpp`中，我们实现`Attack`函数，如下所示：
- en: '[PRE21]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Also, make sure that you add `#include "Bullet.h"` at the top of the file. We
    leave the code that implements the melee attack as it is. Assuming that the monster
    is not holding a melee weapon, we then check whether the `BPBullet` member is
    set. If the `BPBullet` member is set, it means that the monster will create and
    fire an instance of the `BPBullet` blueprinted class.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在文件顶部添加`#include "Bullet.h"`。我们将实现近战攻击的代码保持不变。假设怪物没有持有近战武器，然后我们检查`BPBullet`成员是否已设置。如果`BPBullet`成员已设置，则意味着怪物将创建并发射`BPBullet`蓝图类的实例。
- en: 'Pay special attention to the following line:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意以下行：
- en: '[PRE22]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is how we add a new actor to the world. The `SpawnActor()` function puts
    an instance of `UCLASS` that you pass in `spawnLoc`, with some initial orientation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们向世界添加新角色的方式。`SpawnActor()`函数将`UCLASS`的一个实例放在您传入的`spawnLoc`中，并具有一些初始方向。
- en: After we spawn the bullet, we call the `AddImpulse()` function on its `ProxSphere`
    variable to rocket it forward.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们生成子弹之后，我们调用`AddImpulse()`函数来使其`ProxSphere`变量向前发射。
- en: 'Also, add the following line to Bullet.h:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在Bullet.h中添加以下行：
- en: '[PRE23]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Player knockback
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家击退
- en: 'To add a knockback to the player, I added a member variable to the `Avatar`
    class called `knockback`. A knockback happens whenever the avatar gets hurt:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给玩家添加击退效果，我在`Avatar`类中添加了一个名为`knockback`的成员变量。每当avatar受伤时就会发生击退：
- en: '[PRE24]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To figure out the direction to knock the player back when he gets hit, we need
    to add some code to `AAvatar::TakeDamage`. This overrides the version in the `AActor`
    class, so first, add this to Avatar.h:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚击中玩家时将其击退的方向，我们需要在`AAvatar::TakeDamage`中添加一些代码。这将覆盖`AActor`类中的版本，因此首先将其添加到Avatar.h中：
- en: '[PRE25]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compute the direction vector from the attacker toward the player and store
    this vector in the `knockback` variable:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 计算从攻击者到玩家的方向向量，并将该向量存储在`knockback`变量中：
- en: '[PRE26]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `AAvatar::Tick`, we apply the knockback to the avatar''s position:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AAvatar::Tick`中，我们将击退应用到avatar的位置：
- en: '[PRE27]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since the knockback vector reduces in size with each frame, it becomes weaker
    over time, unless the knockback vector gets renewed with another hit.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于击退向量会随着每一帧而减小，所以随着时间的推移它会变得越来越弱，除非击退向量在受到另一次打击时得到更新。
- en: For the bullets to work, you need to set BPMelee Weapon to None. You should
    also increase the size of AttackRangeSphere and adjust Bullet Launch Impulse to
    a value that works.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使子弹起作用，您需要将BPMelee Weapon设置为None。您还应该增加AttackRangeSphere的大小，并调整子弹发射冲量到一个有效的值。
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to instantiate monsters on the screen that
    run after the player and attack him. We used different spheres to detect whether
    the monster was in sight or attack range, and added the ability to have either
    melee or shooting attacks, depending on whether or not the monster has a melee
    weapon. If you want to experiment further, you can try changing animations for
    shooting, or add an extra sphere and have the monster fire while still moving
    and switch to melee when in attack range. In the next chapter, we'll expand the
    capabilities of the monsters further by looking into advanced Artificial Intelligence
    techniques.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在屏幕上实例化怪物，让它们追逐玩家并攻击他。我们使用不同的球体来检测怪物是否在视线范围或攻击范围内，并添加了具有近战或射击攻击能力的能力，具体取决于怪物是否有近战武器。如果您想进一步实验，可以尝试更改射击动画，或者添加额外的球体，并使怪物在移动时继续射击，并在攻击范围内切换到近战。在下一章中，我们将通过研究先进的人工智能技术来进一步扩展怪物的能力。
