- en: Working with Different Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的架构
- en: The developers of desktop applications usually pay little attention to the hardware
    architecture. First, they often use high-level programming languages that hide
    these complexities at the cost of performance. Second, in most cases, their code
    runs on the x86 architecture, and they often take its features for granted. For
    example, they may assume that the size of int is 32 bits, but that is not true
    in many cases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序的开发人员通常很少关注硬件架构。首先，他们经常使用高级编程语言，隐藏这些复杂性，以牺牲性能为代价。其次，在大多数情况下，他们的代码在x86架构上运行，并且他们经常认为其功能是理所当然的。例如，他们可能假设`int`的大小为32位，但在许多情况下这是不正确的。
- en: Embedded developers deal with a much wider variety of architectures. Even if
    they do not write code in an assembly language that's native to the target platform,
    they should be aware that all C and C++ fundamental types are architecture-dependent;
    the standard only guarantees that int is at least 16-bit. They should also know the
    traits of particular architectures, such as endianness and alignment, and take
    into account that operations that are performed with the floating-point or 64-bit
    numbers, which are relatively cheap on the x86 architecture, can be much more
    expensive on other architectures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发人员处理更广泛的架构。即使他们不使用与目标平台本地的汇编语言编写代码，他们也应该知道所有C和C++基本类型都是依赖于架构的；标准只保证int至少为16位。他们还应该了解特定架构的特性，如字节顺序和对齐，并考虑到在其他架构上执行浮点或64位数字的操作，这在x86架构上相对便宜，但在其他架构上可能更昂贵。
- en: Since they aim to achieve maximal possible performance from embedded hardware,
    they should understand how to organize data in memory to get the most efficient
    use out of the CPU cache and operating system paging mechanisms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他们的目标是从嵌入式硬件中实现最大可能的性能，他们应该了解如何组织内存中的数据，以最有效地利用CPU缓存和操作系统分页机制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring fixed-width integer types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索固定宽度整数类型
- en: Working with the `size_t` type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`size_t`类型
- en: Detecting the endianness of the platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测平台的字节顺序
- en: Converting the endianness
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换字节顺序
- en: Working with data alignment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据对齐
- en: Working with packed structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用紧凑结构
- en: Aligning data with cache lines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存行对齐数据
- en: By looking at these topics, we will learn how to tailor our code to target platforms
    to achieve maximum performance and portability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究这些主题，我们将学习如何调整我们的代码以针对平台实现最大性能和可移植性。
- en: Exploring fixed-width integer types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索固定宽度整数类型
- en: C and C++ developers often forget that the size of fundamental data types such
    as char, short, and int are architecture-dependent. At the same time, most of
    the hardware peripherals define specific requirements regarding the size of the
    fields that are used for data exchanges. To make the code working with the external
    hardware or communication protocols portable, embedded developers use fixed-size
    integer types, which explicitly specify the size of a data field.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++开发人员经常忘记基本数据类型如char、short和int的大小是依赖于架构的。与此同时，大多数硬件外设定义了关于用于数据交换的字段大小的特定要求。为了使代码与外部硬件或通信协议一起工作具有可移植性，嵌入式开发人员使用固定大小的整数类型，明确指定数据字段的大小。
- en: 'Some of the most commonly used data types are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的数据类型如下：
- en: '| **Width** | **Signed** | **Unsigned** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **宽度** | **有符号** | **无符号** |'
- en: '| 8-bit | `int8_t` | `uint8_t` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 8位 | `int8_t` | `uint8_t` |'
- en: '| 16-bit | `int16_t` | `uint16_t` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 16位 | `int16_t` | `uint16_t` |'
- en: '| 32-bit | `int32_t` | `uint32_t` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 32位 | `int32_t` | `uint32_t` |'
- en: The pointer size also depends on the architecture. Developers often need to
    address the elements of arrays, and since arrays are internally represented as
    pointers, the offset representation depends on the pointer's size. `size_t` is
    a special data type as it represents the offset and data sizes in an architecture-independent
    way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 指针大小也取决于架构。开发人员经常需要处理数组的元素，由于数组在内部表示为指针，偏移表示取决于指针的大小。`size_t`是一种特殊的数据类型，因为它以与架构无关的方式表示偏移和数据大小。
- en: In this recipe, we will learn how to use fixed-size data types in our code to
    make it portable across architectures. This way, we can make our application work
    with other target platforms faster and with fewer code modifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在代码中使用固定大小的数据类型，使其在不同架构之间可移植。这样，我们可以使我们的应用程序更快地在其他目标平台上运行，并减少代码修改。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We are going to create an application that emulates data exchange with a peripheral
    device. Follow these steps to do so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个模拟与外围设备进行数据交换的应用程序。按照以下步骤操作：
- en: In your working directory, that is, `~/test`, create a subdirectory called `fixed_types`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`fixed_types`的子目录。
- en: 'Use your favorite text editor to create a file called `fixed_types.cpp` in
    the `fixed_types` subdirectory. Copy the following code snippet into the `fixed_types.cpp` file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`fixed_types`子目录中创建名为`fixed_types.cpp`的文件。将以下代码片段复制到`fixed_types.cpp`文件中：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在loop子目录中创建一个名为`CMakeLists.txt`的文件，并包含以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml),
    *Setting Up the Environment*, to do so.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的步骤*设置环境*来完成。
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。如有需要，请使用您的用户凭据登录。
- en: Run the binary to see how it works.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件以查看其工作原理。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When you run the binary, you will see the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行二进制文件时，您将看到以下输出：
- en: '![](img/b2a222c6-a006-4c01-ad57-fa2463d6e63f.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2a222c6-a006-4c01-ad57-fa2463d6e63f.png)'
- en: In this simple program, we're simulating communication with an external device.
    Since we don't have a real device, the `SendDataToDevice` function just prints
    the size of the data it is supposed to send to the target device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的程序中，我们正在模拟与外部设备的通信。由于我们没有真正的设备，`SendDataToDevice`函数只是打印它应该发送到目标设备的数据的大小。
- en: 'Suppose the device can operate on chunks of data of a variable size. Each chunk
    of data is prepended by its size and encoded as a 32-bit unsigned integer. This
    can be described as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设设备可以处理可变大小的数据块。每个数据块都以其大小作为前缀，并编码为32位无符号整数。可以描述如下：
- en: '| **Size** | **Payload** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **有效载荷** |'
- en: '| 0-4 bytes | 5 - N bytes, where N is Size |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 0-4字节 | 5 - N字节，其中N是大小 |'
- en: 'In our code, we declare `size` as `uint32_t`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将`size`声明为`uint32_t`：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that it will take 32 bits exactly on every platform – 16-, 32-, or
    64-bit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它将在每个平台上都占用32位 - 16位、32位或64位。
- en: 'Now, we will send the size to the device:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将大小发送到设备：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`SendDataToDevice` doesn''t send the actual data; instead, it reports the size
    of the data to be sent. As we can see, the size is `4` bytes, as expected:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendDataToDevice`不会发送实际数据；相反，它会报告要发送的数据大小。正如我们所看到的，大小为`4`字节，正如预期的那样：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Suppose that we declare the `int` data type, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们声明`int`数据类型，如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, this code can only work on 32- and 64-bit systems, and silently
    produce incorrect results on 16-bit systems, since `sizeof(int)` is 16 here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这段代码只能在32位和64位系统上工作，并且在16位系统上悄悄地产生不正确的结果，因为`sizeof(int)`在这里是16。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The code we implemented in this recipe is not fully portable since it doesn't
    take the order of bytes in a 32-bit word into account. This order is called **endianness**,
    and its implications will be discussed later in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中实现的代码并不是完全可移植的，因为它没有考虑32位字中字节的顺序。这个顺序被称为**字节序**，它的影响将在本章后面讨论。
- en: Working with the size_t type
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`size_t`类型
- en: The pointer size also depends on the architecture. Developers often need to
    address the elements of arrays, and, since arrays are internally represented as
    pointers, the offset representation depends on the pointer's size.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 指针大小也取决于体系结构。开发人员经常需要处理数组的元素，由于数组在内部表示为指针，偏移量表示取决于指针的大小。
- en: For example, in a 32-bit system, pointers are 32-bit, the same as `int`. However,
    in a 64-bit system, the size of `int` is still 32-bit, while pointers are 64-bit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在32位系统中，指针是32位，与`int`相同。然而，在64位系统中，`int`的大小仍然是32位，而指针是64位。
- en: '`size_t` is a special data type since it represents offset and data sizes in
    an architecture-independent way.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_t`是一种特殊的数据类型，因为它以与体系结构无关的方式表示偏移量和数据大小。'
- en: In this recipe, we will learn how to use `size_t` when working with arrays.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在处理数组时使用`size_t`。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that handles a data buffer of a variable size.
    We need an ability to access any address of memory provided by a target platform
    if needed. Follow these steps to do so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个处理可变大小数据缓冲区的应用程序。如果需要，我们需要能够访问目标平台提供的任何内存地址。按照以下步骤操作：
- en: In your working directory, that is, `~/test`, create a subdirectory called `sizet`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录，即`~/test`，创建一个名为`sizet`的子目录。
- en: 'Use your favorite text editor to create a file called `sizet.cpp` in the `sizet` subdirectory.
    Copy the following code snippet into the `sizet.cpp` file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`sizet`子目录中创建一个名为`sizet.cpp`的文件。将以下代码片段复制到`sizet.cpp`文件中：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子目录中创建一个名为`CMakeLists.txt`的文件，并包含以下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的示例，*设置环境*来完成。
- en: Switch to the target system's Terminal. Log in using your user credentials if
    needed.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。根据需要使用您的用户凭据登录。
- en: Run the `sizet` application executable file.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sizet`应用程序可执行文件。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we're emulating a function that stores arbitrary data in a
    file or a database. The function accepts a pointer to the data and data size.
    But what type should we use to represent the size? If we use an unsigned int in
    a 64-bit system, we're artificially limiting the capability of our function to
    handle only up to 4 GB of data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在模拟一个将任意数据存储在文件或数据库中的函数。该函数接受数据指针和数据大小。但是我们应该使用什么类型来表示大小？如果我们在64位系统中使用无符号整数，我们就会人为地限制我们的函数处理的数据最多只能达到4GB。
- en: 'To avoid such limitations, we use `size_t` as a data type for `size`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种限制，我们使用`size_t`作为`size`的数据类型：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Most standard library APIs that accept indices and sizes also deal with `size_t`
    parameters. For example, the `memcpy` C function, which copies a chunk of data
    from the source buffer to the destination buffer, is declared as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准库API接受索引和大小参数，也处理`size_t`参数。例如，`memcpy` C函数，它将数据块从源缓冲区复制到目标缓冲区，声明如下：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会产生以下输出：
- en: '![](img/79d7eb07-66fc-465b-b089-36506a38e18d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79d7eb07-66fc-465b-b089-36506a38e18d.png)'
- en: As we can see, the size of the pointer on the target system is 64-bit, despite
    the size of `int` being 32-bit. Using `size_t` in our program allows it to use
    all the memory of the embedded board.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在目标系统上指针的大小是64位，尽管`int`的大小是32位。在我们的程序中使用`size_t`允许它使用嵌入式板的所有内存。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++ standard defines an `std::size_t` type. It is identical to the plain
    C `size_t`, except it is defined in the `std` namespace. Usage of `std::size_t`
    is preferable in your C++ code since it is part of the standard, but both `std::size_t`
    and `size_t` are interchangeable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准定义了一个`std::size_t`类型。它与普通的C `size_t`相同，只是它是在`std`命名空间中定义的。在你的C++代码中使用`std::size_t`是更可取的，因为它是标准的一部分，但`std::size_t`和`size_t`都是可以互换的。
- en: Detecting the endianness of the platform
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测平台的字节顺序
- en: Endianness defines the order in which bytes that represent large numerical values
    are stored in memory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 字节顺序定义了表示大数值的字节在内存中存储的顺序。
- en: 'There are two types of endianness:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种字节顺序：
- en: '**Big-endian**: The most significant byte is stored first. A 32-bit value, *0x01020304*, is
    stored at the `ptr` address, as follows:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大端**：最重要的字节被先存储。一个32位的值，*0x01020304*，被存储在`ptr`地址上，如下所示：'
- en: '| **Offset in memory (byte)** | **Value** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **内存偏移（字节）** | **值** |'
- en: '| ptr | 0x01 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| ptr | 0x01 |'
- en: '| ptr + 1 | 0x02 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| ptr + 1 | 0x02 |'
- en: '| ptr + 2 | ox03 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| ptr + 2 | ox03 |'
- en: '| ptr + 3 | 0x04 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| ptr + 3 | 0x04 |'
- en: Examples of big-endian architectures include AVR32 and Motorola 68000.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大端架构的例子包括AVR32和Motorola 68000。
- en: '**Little-endian**: The least significant byte is stored first. A 32-bit value, *0x01020304*,
    is stored at the `ptr` address, as follows:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小端**：最不重要的字节被先存储。一个32位的值，*0x01020304*，被存储在`ptr`地址上，如下所示：'
- en: '| **Offset in memory (byte)** | **Value** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **内存偏移（字节）** | **值** |'
- en: '| ptr | 0x04 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| ptr | 0x04 |'
- en: '| ptr + 1 | 0x03 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| ptr + 1 | 0x03 |'
- en: '| ptr + 2 | 0x02 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| ptr + 2 | 0x02 |'
- en: '| ptr + 3 | 0x01 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ptr + 3 | 0x01 |'
- en: The x86 architecture is little-endian.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构是小端的。
- en: Taking care of endianness is especially essential when exchanging data with
    other systems. If a developer sends a 32-bit integer, say, 0x01020304, as it is,
    it may be read as 0x04030201 if the endianness of the receiver does not match
    the endianness of the sender. That is why data should be serialized.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在与其他系统交换数据时，处理字节顺序尤为重要。如果开发人员将一个32位整数，比如0x01020304，原样发送，如果接收者的字节顺序与发送者的字节顺序不匹配，它可能被读取为0x04030201。这就是为什么数据应该被序列化的原因。
- en: In this recipe, we will learn how to determine the endianness of our target
    system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何确定目标系统的字节顺序。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a simple program that can detect the endianness of the target
    platform. Follow these steps to do so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的程序，可以检测目标平台的字节顺序。按照以下步骤来做：
- en: In your working directory, that is, `~/test`, create a subdirectory called `endianness`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的工作目录，即`~/test`，创建一个名为`endianness`的子目录。
- en: 'Use your favorite text editor to create a file called `loop.cpp` in the loop
    subdirectory. Copy the following code snippet into the `endianness.cpp` file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器在循环子目录中创建一个名为`loop.cpp`的文件。将以下代码片段复制到`endianness.cpp`文件中：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Build the application and copy the resulting executable binary to the target
    system. Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的配方，*设置环境*，来完成这个过程。
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。如果需要，使用你的用户凭据登录。
- en: Run the binary.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we utilized the capability of C's `union` function to map the
    representation of different data types to the same memory space.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们利用了C语言的`union`函数的能力，将不同数据类型的表示映射到相同的内存空间。
- en: 'We define a union with two data fields – an array of 8-bit integers and a single
    32-bit integer. These data fields share the same memory, so changes that are made
    in one field are automatically reflected in another field:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个包含两个数据字段的联合体 - 一个8位整数数组和一个32位整数。这些数据字段共享相同的内存，因此对一个字段所做的更改会自动反映在另一个字段中：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we assign the 32-bit integer field a specially crafted value, where each
    byte is known in advance and different from any of the others. We used bytes with
    values of one, two, three, and four to compose the target value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给32位整数字段赋予一个特别设计的值，其中每个字节都是事先知道的，并且与其他任何字节都不同。我们使用值为一、二、三和四的字节来组成目标值。
- en: When the value is assigned to the 32-bit field, `i`, it automatically rewrites
    all the fields into the `c` byte array field. Now, we can read the first element
    of the array, and, depending on what we read, we can infer the endianness of the
    hardware platform.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当值被赋给32位字段`i`时，它会自动将所有字段重写为`c`字节数组字段。现在，我们可以读取数组的第一个元素，并根据我们读取的内容推断硬件平台的字节顺序。
- en: 'If the value is one, this means that the first byte contains the most significant
    byte, and hence the architecture is big-endian. Otherwise, it is little-endian.
    When we run the binary, it produces the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值为一，这意味着第一个字节包含最重要的字节，因此架构是大端的。否则，它是小端的。当我们运行二进制文件时，它会产生以下输出：
- en: '![](img/dca32ea5-56bc-4cb2-9515-285e8f26f7a2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dca32ea5-56bc-4cb2-9515-285e8f26f7a2.png)'
- en: As we can see, the program detected our system as little-endian. This technique
    can be used to detect the endianness in our runtime and adjust the application
    logic accordingly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，该程序检测到我们的系统是小端的。这种技术可以用来检测我们运行时的字节顺序，并相应地调整应用程序逻辑。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Nowadays, most widespread platforms, such as x86 and **Acorn RISC Machine** (**ARM**),
    are little-endian. However, your code should never assume the endianness of the
    system implicitly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数广泛使用的平台，如x86和**Acorn RISC Machine**（**ARM**），都是小端的。然而，你的代码不应该隐式地假设系统的字节顺序。
- en: If you need to exchange data between applications running on the same system,
    it is safe to stick with the target platform's endianness. However, if your application
    needs to exchange data with other systems, either via network protocols or common
    data storage, consider converting your binary data into the common endianness.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在同一系统上运行的应用程序之间交换数据，可以安全地使用目标平台的字节序。但是，如果您的应用程序需要与其他系统交换数据，无论是通过网络协议还是常见数据存储，都应考虑将二进制数据转换为通用字节序。
- en: Text-based data formats do not have issues with endianness. Use JSON format
    for platform-independent and human-readable representations of your data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文本的数据格式不会受到字节序的影响。使用JSON格式进行数据表示，这样可以实现平台无关和人类可读的数据表示。
- en: '**Note**: Converting from a binary representation and back can be costly for
    your target embedded platform.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在目标嵌入式平台上进行二进制表示和反向转换可能会很昂贵。'
- en: Converting the endianness
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换字节序
- en: While serialization libraries deal with the endianness under the hood, there
    are situations where developers might want to implement a lightweight communication
    protocol themselves.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然序列化库处理字节序，但有时开发人员可能希望自己实现轻量级通信协议的情况。
- en: While the C++ Standard Library does not provide functions for serialization,
    developers may utilize the fact that, in binary network protocols, byte order
    is defined and is always big-endian.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++标准库没有提供序列化函数，但开发人员可以利用这样一个事实：在二进制网络协议中，字节顺序是被定义的，并且始终是大端序。
- en: 'The Standard Library provides a set of functions that can be used for conversion
    between the current platform (hardware) and big-endian (network) byte orders:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一组函数，可用于在当前平台（硬件）和大端序（网络）字节顺序之间进行转换：
- en: '`uint32_t` htonl (`uint32_t` value): Converts `uint32_t` from hardware to network
    order'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32_t` htonl (`uint32_t` value): 将`uint32_t`从硬件顺序转换为网络顺序'
- en: '`uint32_t` ntohl (`uint32_t` value): Converts `uint32_t` from network to hardware
    order'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32_t` ntohl (`uint32_t` value): 将`uint32_t`从网络顺序转换为硬件顺序'
- en: '`uint16_t` htons (`uint16_t` value): Converts `uint16_t` from hardware to network
    order'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16_t` htons (`uint16_t` value): 将`uint16_t`从硬件顺序转换为网络顺序'
- en: '`uint16_t` ntohl (`uint16_t` value): Converts `uint16_t` from network to hardware
    order'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16_t` ntohl (`uint16_t` value): 将`uint16_t`从网络顺序转换为硬件顺序'
- en: Developers can use these functions to exchange binary data between applications
    running on different platforms.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以使用这些函数在不同平台上运行的应用程序之间交换二进制数据。
- en: In this recipe, we will learn how to encode strings so that they can be exchanged
    between two systems that may have the same or different endianness.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何对字符串进行编码，以便在可能具有相同或不同字节序的两个系统之间进行交换。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we are going to create two applications: a sender and a receiver.
    The sender will write data for the receiver, thus encoding them in a platform-independent
    way. Follow these steps to do so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建两个应用程序：发送方和接收方。发送方将为接收方编写数据，以平台无关的方式对其进行编码。按照以下步骤进行操作：
- en: In your working directory, that is, `~/test`, create a subdirectory called `enconv`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`enconv`的子目录。
- en: 'Use your favorite text editor to create and edit a file called `sender.cpp`
    in the `enconv` subdirectory. Include the required header files, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`enconv`子目录中创建并编辑名为`sender.cpp`的文件。包括所需的头文件，如下所示：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, define a function that writes data to the file descriptor:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个将数据写入文件描述符的函数：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to define a function that formats and writes messages, along with
    the main function that invokes it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个格式化并写入消息的函数，以及调用它的主函数：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, create a file called `receiver.cpp` with the same set of includes:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建一个名为`receiver.cpp`的文件，并包含相同的头文件：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code, which reads data from a file descriptor:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，从文件描述符中读取数据：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, define a function that will read messages, along with the main function
    that invokes it:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个将消息读取出来的函数，以及调用它的主函数：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在loop子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Build the application and copy the two resulting executable binaries, `sender`
    and `receiver`, to the target system. Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的两个可执行二进制文件`sender`和`receiver`复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的设置环境的方法。
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。如果需要，使用您的用户凭据登录。
- en: 'Run the `sender` binary and pass two command-line arguments: `Hello` and `Worlds`.
    This won''t generate any output.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sender`二进制文件，并传递两个命令行参数：`Hello`和`Worlds`。这不会生成任何输出。
- en: Then, run the receiver.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行接收方。
- en: 'Now, check the content of the file for both the `sender` and `receiver` that
    were used for data exchange. It will be in binary format, so we need to use the `xxd`
    tool to convert it into hexadecimal format:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查用于数据交换的`sender`和`receiver`文件的内容。它将以二进制格式呈现，因此我们需要使用`xxd`工具将其转换为十六进制格式：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The file contains two strings, `hello` and `world`, prepended by their sizes.
    The `size` fields are always stored in big-endian byte order, independent of the architecture.
    This allows the sender and the receiver to be run on two different machines with
    different endianness.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件包含两个字符串`hello`和`world`，前面是它们的大小。`size`字段总是以大端序存储，与体系结构无关。这允许发送方和接收方在具有不同字节序的两台不同计算机上运行。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created two binaries, sender and receiver, that emulate data
    exchange between two hosts. We can't make any assumptions regarding their endianness,
    which is why the data exchange format has to be unambiguous.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了两个二进制文件，sender和receiver，模拟了两个主机之间的数据交换。我们不能对它们的字节序做出任何假设，这就是为什么数据交换格式必须是明确的原因。
- en: The sender and receiver exchange data blocks of variable size. We encoded each
    block as a 4-byte integer in order to define the upcoming block size, followed
    by the block content.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方和接收方交换可变大小的数据块。我们将每个块编码为4字节的整数，以定义即将到来的块大小，然后是块内容。
- en: 'While the sender does not generate any output on the screen, it saves an encoded
    block of data in a file. When we run the receiver, it is able to read, decode,
    and display any information that was saved by the sender, as shown in the following
    screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送方不在屏幕上生成任何输出时，它会将编码的数据块保存在文件中。当我们运行接收方时，它能够读取、解码并显示发送方保存的任何信息，如下面的屏幕截图所示：
- en: '![](img/2a6bdbd6-7451-47f5-8926-0ceaa8b67dcc.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a6bdbd6-7451-47f5-8926-0ceaa8b67dcc.png)'
- en: 'While we keep the block size in the platform format locally, we need to convert
    it into a unified representation when sending it out. We use the `htonl` function
    to do so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本地以平台格式保留块大小，但在发送时需要将其转换为统一表示。我们使用`htonl`函数来实现这一点：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, we can write the encoded size to the output stream:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以将编码后的大小写入输出流：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The block''s content is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 块的内容如下：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The receiver, in turn, reads the size from the input stream:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者反过来从输入流中读取大小：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The size is encoded and cannot be used directly until the receiver converts
    it into a platform representation using the `ntohl` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大小被编码，直到接收者使用`ntohl`函数将其转换为平台表示形式才能直接使用：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Only after doing this, will it know the size of the block that follows and
    can allocate and read it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在这样做之后，它才会知道接下来的块的大小，并且可以分配和读取它：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since the serialized `data` size is always represented as big-endian, the read
    function doesn't need to make assumptions about the endianness of the platform
    where the data was written. It can deal with data coming from any processor architecture.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于序列化的`data`大小始终表示为大端，读取函数不需要对数据写入的平台的字节顺序做出假设。它可以处理来自任何处理器架构的数据。
- en: Working with data alignment
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据对齐
- en: Processors read and write data not in bytes, but in memory words – chunks that
    match their data address size. 32-bit processors work with 32-bit words, 64-bit
    processors with 64-bit words, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不是按字节而是按内存字-与其数据地址大小匹配的块-读写数据。32位处理器使用32位字，64位处理器使用64位字，依此类推。
- en: 'Reads and writes are most efficient when words are aligned – the data address
    is a multiple of the word size. For example, for 32-bit architectures, the address
    0x00000004 is aligned, while 0x00000005 is unaligned. On x86 platform, access
    to unaligned data is slower that to aligned. On ARM, however, access to unaligned
    data generates a hardware exception and lead to program termination:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当字对齐时，读写效率最高-数据地址是字大小的倍数。例如，对于32位架构，地址0x00000004是对齐的，而0x00000005是不对齐的。在x86平台上，访问不对齐的数据比对齐的数据慢。然而，在ARM上，访问不对齐的数据会生成硬件异常并导致程序终止：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What is the output of the preceding code snippet? `sizeof(uint8_t)` is 1, while `sizeof(uint32_t)`
    is 4\. A developer may expect the size of the structure to be the sum of the individual
    sizes; however, the result highly depends on the target architecture.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段的输出是什么？`sizeof(uint8_t)`是1，而`sizeof(uint32_t)`是4。开发人员可能期望结构的大小是各个大小的总和；然而，结果高度取决于目标架构。
- en: 'For x86, the result is `8`. Let''s add one more `uint8_t` field before `i`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x86，结果是`8`。在`i`之前添加一个`uint8_t`字段：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result is still 8! The compiler optimizes the placement of the data fields
    within a structure according to the alignment rules by adding padding bytes. The
    rules are architecture-dependent, and the result may be different for other architectures.
    As a result, structures cannot be exchanged directly between two different systems
    without *serialization, *which will be explained in depth in [Chapter 8](24063f32-0b00-46d8-a65d-12e09b599ade.xhtml), *Communication
    and Serialization*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 结果仍然是8！编译器通过添加填充字节根据对齐规则优化结构内的数据字段的放置。这些规则依赖于架构，对于其他架构，结果可能不同。因此，结构不能在两个不同的系统之间直接交换，而需要*序列化*，这将在[第8章](24063f32-0b00-46d8-a65d-12e09b599ade.xhtml)中深入解释*通信和序列化*。
- en: In this recipe, we will learn how to use the rules that compilers implicitly
    apply to align data to write more memory-efficient code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用编译器隐式应用的规则来对齐数据以编写更节省内存的代码。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a program that allocates an array of structures and check how
    the order of the fields affects memory consumption. Follow these steps to do so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个程序，该程序分配一个结构数组，并检查字段顺序如何影响内存消耗。按照以下步骤执行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `alignment`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`alignment`的子目录。
- en: 'Use your favorite text editor to create a file called `alignment.cpp` in the
    loop subdirectory. Add the required header and define two data types, that is, `Category`
    and `ObjectMetadata1`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在循环子目录中创建一个名为`alignment.cpp`的文件。添加所需的头文件并定义两种数据类型，即`Category`和`ObjectMetadata1`：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s define another data type, called `ObjectMetadata2`, along with
    the code that uses all of them:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义另一个数据类型，称为`ObjectMetadata2`，以及使用所有这些的代码：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环子目录中创建一个名为`CMakeLists.txt`的文件，并添加以下内容：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的配方*设置环境*来执行此操作。
- en: Switch to the target system's Terminal. Log in using your user credentials if
    needed.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。如果需要，使用您的用户凭据登录。
- en: Run the binary.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In our sample application, we defined two data structures, `ObjectMetadata1` and
    `ObjectMetadata2`, that will hold some metadata about file objects. We defined
    four fields that represent an object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们定义了两个数据结构，`ObjectMetadata1`和`ObjectMetadata2`，它们将保存有关文件对象的一些元数据。我们定义了代表对象的四个字段：
- en: '**Access flags**: A combination of bits representing a type of file access,
    such as read, write, or execute. All bit fields are packed into a single `uint8_t`
    field.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问标志**：代表文件访问类型的位的组合，例如读取、写入或执行。所有位字段都打包到一个单独的`uint8_t`字段中。'
- en: '**Size**: Object size as a 32-bit unsigned integer. It limits the supported
    object size to 4 GB, but it is sufficient for our goal to demonstrate the importance
    of proper data alignment.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：作为32位无符号整数的对象大小。它将支持的对象大小限制为4GB，但对于我们展示适当数据对齐的重要性来说是足够的。'
- en: '**Owner ID**: A 32-bit integer that identifies a user in our system.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有者ID**：在我们系统中标识用户的32位整数。'
- en: '**Category**: The category of the object. This can be a file, a directory,
    or a socket. Since we''ve only defined three categories, the `uint8_t` data type
    is sufficient to represent all of them. This is why we declare them using the `enum`
    class:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：对象的类别。这可以是文件、目录或套接字。由于我们只定义了三个类别，`uint8_t`数据类型足以表示它们所有。这就是为什么我们使用`enum`类来声明它们的原因：'
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Both `ObjectMetadata1` and `ObjectMetadata2` contain exactly the same fields;
    the only difference is how they are ordered within their structures.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectMetadata1`和`ObjectMetadata2`都包含完全相同的字段；唯一的区别是它们在其结构中的排序方式。'
- en: 'Now, we declare two pools of objects. Both pools contain 1,000 objects; `object_pool1`
    holds metadata in `ObjectMetadata1` structures, while `object_pool2` uses `ObjectMetadata2`
    structures. Now, let''s check the output of the application:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们声明了两个对象池。两个池都包含1,000个对象；`object_pool1`中包含`ObjectMetadata1`结构中的元数据，而`object_pool2`使用`ObjectMetadata2`结构。现在，让我们检查应用程序的输出：
- en: '![](img/b9ba5450-5659-4cb2-a383-bd4285356c9a.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9ba5450-5659-4cb2-a383-bd4285356c9a.png)'
- en: 'Both object pools are identical in terms of functionality and performance.
    However, if we check how much memory they occupy, we can see a significant difference:
    `object_pool1` is 4 KB larger than `object_pool2`. Given the size of `object_pool2`
    is 12 KB, we wasted 33% of memory by not paying attention to data alignment. Be
    aware of alignment and padding when working on your data structures, as improper
    field ordering may lead to inefficient memory usage, as in the case of `object_pool2`.
    Use these simple rules to organize your data fields in order to keep them properly
    aligned:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象池在功能和性能方面是相同的。但是，如果我们检查它们占用了多少内存，我们可以看到一个显著的差异：`object_pool1`比`object_pool2`大4KB。鉴于`object_pool2`的大小为12KB，我们浪费了33%的内存，因为没有注意数据对齐。在处理数据结构时要注意对齐和填充，因为不正确的字段排序可能导致内存使用效率低下，就像`object_pool2`的情况一样。使用这些简单的规则来组织数据字段，以保持它们正确对齐：
- en: Group them by their size.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照它们的大小对它们进行分组。
- en: Order the groups from largest to smallest data types.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照从最大到最小的数据类型对组进行排序。
- en: Well-aligned data structures are fast, memory-efficient, and do not require
    any additional code to be implemented.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 良好对齐的数据结构速度快、内存效率高，并且不需要实现任何额外的代码。
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Each hardware platform has its own alignment requirements, and some of them
    are tricky. You might need to consult the target platform compiler documentation
    and best practices to get the most out of the hardware. If your target platform
    is ARM, consider reading the ARM technical article at [http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15414.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15414.html)
    on alignment expectations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个硬件平台都有自己的对齐要求，其中一些是棘手的。您可能需要查阅目标平台编译器文档和最佳实践，以充分利用硬件。如果您的目标平台是ARM，请考虑阅读ARM技术文章[http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15414.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15414.html)上的对齐期望。
- en: While the proper alignment of data fields within a structure can result in a
    more compact data representation, be aware of performance implications. Keeping
    data that's used together in the same memory region is called **data locality**
    and may significantly improve data access performance. Data elements that fit
    into the same cache line can be read or written much faster than elements that
    span the cache line boundaries. In many cases, it is preferable to get a performance
    gain at the cost of additional memory use. We will review this technique in more
    detail in the *Aligning data with cache lines* recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结构体内数据字段的正确对齐可以导致更紧凑的数据表示，但要注意性能影响。将一起使用的数据保持在同一内存区域中称为**数据局部性**，可能会显著提高数据访问性能。适合放入同一缓存行的数据元素可以比跨越缓存行边界的元素读取或写入得快得多。在许多情况下，更倾向于通过额外的内存使用来获得性能提升。我们将在*使用缓存行对齐数据*配方中更详细地讨论这种技术。
- en: Working with packed structures
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用打包结构
- en: In this recipe, we will learn how to define structures that do not have any
    padding bytes between their data members. This may significantly reduce the amount
    of memory that's used by your application if it works with a large number of objects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何定义结构，使其在数据成员之间没有填充字节。如果应用程序处理大量对象，这可能会显著减少应用程序使用的内存量。
- en: Note, though, that this has a cost. Unaligned memory access is slower, which
    results in sub-optimal performance. For some architectures, unaligned access is
    forbidden, thus requiring the C++ compiler to generate much more code to access
    the data fields than for aligned access.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是有代价的。未对齐的内存访问速度较慢，导致性能不佳。对于某些架构，未对齐访问是被禁止的，因此需要C++编译器生成比对齐访问更多的代码来访问数据字段。
- en: Although packing your structs may result in more efficient memory usage, avoid
    using this technique unless it's really necessary. It has too many implied limitations
    that may lead to obscure, hard-to-find issues in your application later.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打包结构体可能会导致更有效的内存使用，但除非真的必要，否则避免使用这种技术。它有太多暗含的限制，可能会导致应用程序中难以发现的模糊问题。
- en: Consider packed structures as transport encoding and only use them to store,
    load, or exchange data outside of your application. But, even in these cases,
    using a proper data serialize is a better solution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将紧凑结构视为传输编码，并仅在应用程序外部存储、加载或交换数据时使用它们。但是，即使在这些情况下，使用适当的数据序列化也是更好的解决方案。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this simple application, we will define an array of packed structures and
    see how this affects the amount of memory it requires. Follow these steps to do
    so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的应用程序中，我们将定义一个紧凑结构的数组，并查看这如何影响它所需的内存量。按照以下步骤操作：
- en: In your working directory, that is, `~/test`, create a copy of the `alignment` subdirectory.
    Name it `packed_alignment`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录`~/test`中，创建`alignment`子目录的副本。将其命名为`packed_alignment`。
- en: 'Modify the `alignment.cpp` file by adding `__attribute__((packed))` to the
    definition of each structure:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向每个结构的定义添加`__attribute__((packed))`来修改`alignment.cpp`文件：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的教程*设置环境*来操作。
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。如果需要，使用您的用户凭据登录。
- en: Run the binary.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we modified the code from the *Working with data alignment* recipe
    by adding a packed attribute to each struct:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们通过向每个结构添加一个紧凑属性来修改了*使用数据对齐*教程中的代码：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This attribute instructs the compiler to not add padding bytes to the structs
    in order to conform to the alignment requirements of the target platform.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指示编译器不要向结构添加填充字节，以符合目标平台的对齐要求。
- en: 'Running the preceding code gives us the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会给我们以下输出：
- en: '![](img/521bd29e-1012-4d5a-b7fc-08a360183077.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/521bd29e-1012-4d5a-b7fc-08a360183077.png)'
- en: If the compiler does not add padding bytes, the order of the data fields becomes
    insignificant. Given that the `ObjectMetadata1` and `ObjectMetadata2` structs
    have exactly the same data fields, their size in packed form becomes identical.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器不添加填充字节，数据字段的顺序变得不重要。鉴于`ObjectMetadata1`和`ObjectMetadata2`结构具有完全相同的数据字段，它们在紧凑形式中的大小变得相同。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `GNU Compiler Collection` (**GCC**) gives developers lots of control over
    data layout using its attributes. You can find out about all of the supported
    attributes and their meaning by going to the [GCC Type Attributes](https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Type-Attributes.html#Type-Attributes) page.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`GNU编译器集合`（**GCC**）通过其属性为开发人员提供了对数据布局的大量控制。您可以通过访问[GCC类型属性](https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Type-Attributes.html#Type-Attributes)页面了解所有支持的属性及其含义。'
- en: Other compilers provide similar functionality, but their APIs might differ.
    For example, Microsoft compilers define the `#pragma pack` compiler directive
    to declare packed structures. More details can be found on the [Pragma Pack Reference](https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019)
    page.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编译器提供类似的功能，但它们的API可能不同。例如，Microsoft编译器定义了`#pragma pack`编译器指令来声明紧凑结构。更多细节可以在[Pragma
    Pack Reference](https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019)页面找到。
- en: Aligning data with cache lines
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存行对齐数据
- en: In this recipe, we will learn how to align data structures with cache lines.
    Data alignment can significantly affect the performance of your system, especially
    in the case of a multithreaded application that works in a multicore system.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何将数据结构与缓存行对齐。数据对齐可以显著影响系统的性能，特别是在多核系统中运行多线程应用程序的情况下。
- en: Firstly, frequently accessing data that's used together is much faster if they
    live in the same cache line. If you program accesses variable A and then variable
    B consistently, a processor has to invalidate and reload its cache every time,
    if they are not in the same line.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果数据结构在同一个缓存行中，频繁访问一起使用的数据会更快。如果你的程序一直访问变量A和变量B，处理器每次都需要使缓存失效并重新加载，如果它们不在同一行中。
- en: Secondly, you don't want to keep data that's used independently by different
    threads in the same cache line. If the same cache line is modified by different
    CPU cores, this requires cache synchronization, which affects the overall performance
    of a multithreaded application that uses shared data, since in this scenario memory
    access time significantly increases.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您不希望将不同线程独立使用的数据放在同一个缓存行中。如果同一个缓存行被不同的CPU核修改，这就需要缓存同步，这会影响使用共享数据的多线程应用程序的整体性能，因为在这种情况下，内存访问时间显著增加。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to create an application that allocates four buffers using four
    different methods to learn how to align statically and dynamically allocated memory.
    Follow these steps to do so:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，使用四种不同的方法分配四个缓冲区，以学习如何对齐静态和动态分配的内存。按照以下步骤操作：
- en: In your working directory, that is, `~/test`, create a subdirectory called `cache_align`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录`~/test`中创建一个名为`cache_align`的子目录。
- en: 'Use your favorite text editor to create a file called `cache_align.cpp` in
    the `cache_align` subdirectory. Copy the following code snippet into the `cache_align.cpp` file
    to define the necessary constants and a function that detects the alignment:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`cache_align`子目录中创建一个名为`cache_align.cpp`的文件。将以下代码片段复制到`cache_align.cpp`文件中，以定义必要的常量和检测对齐的函数：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, define several buffers that are allocated in different ways:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义几个以不同方式分配的缓冲区：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following code, which uses them:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码来使用它们：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在loop子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的配方，*设置环境*，来完成此操作。
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统的终端。如果需要，使用您的用户凭据登录。
- en: Run the binary.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first code snippet, we created two pairs of memory buffers. In each pair,
    the first buffer is allocated to the stack, while the second one is allocated
    to the heap.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码片段中，我们创建了两对内存缓冲区。在每对中，第一个缓冲区分配给堆栈，而第二个缓冲区分配给堆。
- en: 'The first pair is created using the standard C++ technique. The static buffer
    on the stack is declared as an array:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一对是使用标准C++技术创建的。堆栈上的静态缓冲区声明为数组：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To create a dynamic buffer, we use the `new` C++ keyword:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建动态缓冲区，我们使用`new` C++关键字：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the second pair, we create memory-aligned buffers. Declaring the static
    buffer on the stack is similar to the regular static buffer. We use an additional
    attribute, `alignas`, which was introduced in C++11 as a standardized and platform-independent
    way to align data in memory:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二对中，我们创建了内存对齐的缓冲区。在堆栈上声明静态缓冲区与常规静态缓冲区类似。我们使用了一个额外的属性`alignas`，这是C++11中引入的一种标准化和平台无关的内存对齐方式：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This attribute requires an alignment size as a parameter. We want to have data
    aligned by the cache line boundaries. Depending on the platform, the cache line
    size may differ. The most common sizes are 32, 64, and 128 bytes. Using 128 bytes
    makes our buffer aligned for any of them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性需要一个对齐大小作为参数。我们希望数据按缓存行边界对齐。根据平台的不同，缓存行大小可能不同。最常见的大小是32、64和128字节。使用128字节可以使我们的缓冲区对任何缓存行大小都对齐。
- en: 'There is no standard way to do the same for a dynamic buffer. To allocate memory
    on the heap, we use a C function called `posix_memalign`. This is available only
    in **Portable Operating System** **Interface** (**POSIX**) systems (mostly Unix-like),
    but this doesn''t require the support of the C++11 standard:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准的方法来为动态缓冲区做同样的事情。为了在堆上分配内存，我们使用一个名为`posix_memalign`的C函数。这仅在**可移植操作系统接口**（**POSIX**）系统（大多是类Unix系统）中可用，但这并不需要C++11标准的支持：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`posix_memalign` is similar to `malloc`, but has three parameters instead of
    one. The second parameter is an alignment size, the same as it is for the align
    attribute. The third is the size of the memory to allocate. The first parameter
    is used to return a pointer to the allocated memory. Unlike `malloc`, `posix_memalign`
    may fail not only if it can''t allocate memory, but also if the alignment size
    passed to the function is not a power of two. `posix_memalign` returns an error
    code as its result value to help developers differentiate between these two cases.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`posix_memalign`类似于`malloc`，但有三个参数而不是一个。第二个参数是对齐大小，与对齐属性相同。第三个是要分配的内存大小。第一个参数用于返回分配内存的指针。与`malloc`不同，`posix_memalign`可能会失败，不仅是因为无法分配内存，还因为传递给函数的对齐大小不是2的幂。`posix_memalign`返回一个错误代码作为其结果值，以帮助开发人员区分这两种情况。'
- en: 'We define function overlap to calculate an unaligned part of a pointer by masking
    out all the aligned bits:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了函数overlap来计算指针的非对齐部分，通过屏蔽所有对齐位：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we run the application, we can see the difference:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们可以看到区别：
- en: '![](img/007b6140-8b16-49a8-b066-43024d936300.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/007b6140-8b16-49a8-b066-43024d936300.png)'
- en: The addresses of both buffers in the first pair have unaligned parts, while
    the addresses of the second pair are aligned – the unaligned part is zero. As
    a result, random access to the elements of the second pair of buffers is faster,
    because all of them are available in the cache at the same time.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一对中两个缓冲区的地址有非对齐部分，而第二对的地址是对齐的-非对齐部分为零。因此，对第二对缓冲区的元素进行随机访问更快，因为它们都同时在缓存中可用。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: CPU access data alignment is also crucial for efficiently mapping memory through
    a hardware address translation mechanism. Modern operating systems operate 4 KB
    memory blocks or pages to map a process' virtual address space to physical memory.
    Aligning data structures on 4 KB boundaries can lead to performance gains.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: CPU访问数据对齐对于通过硬件地址转换机制高效映射内存也至关重要。现代操作系统操作4 KB内存块或页面，以将进程的虚拟地址空间映射到物理内存。将数据结构对齐到4
    KB边界可以带来性能提升。
- en: The same technique we described in this recipe can be applied to align data
    to the memory page boundaries. Note, however, that `posix_memalign` may require
    twice as much memory than what was requested to fulfill this request. This memory
    overhead growth may be significant for larger alignment blocks.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中描述的相同技术可以应用于将数据对齐到内存页边界。但是，请注意，`posix_memalign`可能需要比请求的内存多两倍。对于较大的对齐块，这种内存开销增长可能是显著的。
