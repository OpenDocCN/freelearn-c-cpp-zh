- en: Chapter 3. Making an Entire 2D Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 制作完整的2D游戏
- en: 'In this chapter, we will finally make our first game. In fact, we will build
    two games, as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将最终制作我们的第一个游戏。实际上，我们将构建两个游戏，如下所示：
- en: We will build our first game, an Asteroid clone game, by improving our actual
    application of SFML
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过提高我们对SFML的实际应用来构建我们的第一个游戏，一个类似小行星的游戏。
- en: Our next game will be a Tetris clone game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接下来的游戏将是一个类似俄罗斯方块的克隆游戏
- en: 'We will also learn some skills such as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习一些技能，例如：
- en: Entity models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体模型
- en: Board management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 板块管理
- en: We are all fans of old school games, so let's get loaded to create some of them
    right away. In addition, each of these two games has a completely different architecture.
    It's really interesting as far as the learning process is concerned.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都是复古游戏的粉丝，所以让我们立即开始创建一些游戏。此外，这两个游戏的结构完全不同。从学习过程的角度来看，这真的很有趣。
- en: Turning our application to an Asteroid clone
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用程序转换为小行星克隆
- en: '**Asteroid** is an arcade "shoot ''em up" game created in 1979 by Atari Inc.,
    and is considered a classic. The player controls a spaceship in an asteroid field
    with some flying saucers appearing on the screen from time to time, attacking
    it. The goal of this game is to destroy all the asteroids and saucers by shooting
    at them. Each level increases the number of asteroids in the field, and the game
    becomes harder and harder.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**小行星**是由Atari Inc.于1979年创建的街机“射击”游戏，被认为是经典之作。玩家控制一艘宇宙飞船在星云中，有时屏幕上会出现飞碟攻击它。这个游戏的目标是通过射击摧毁所有的星云和飞碟。每个关卡都会增加星云的数量，游戏难度也会逐渐增加。'
- en: To build this game, we will use our actual application as a base, but we need
    to add a lot of things to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个游戏，我们将以我们的实际应用为基础，但我们需要添加很多东西。
- en: The Player class
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家类
- en: The player is represented as a spaceship. The spaceship has the ability to rotate
    left and right, to shoot, and the spaceship can also give itself a boost. The
    player can also send the ship into hyperspace, causing it to disappear and reappear
    in a random location on the screen, at the risk of self-destructing or appearing
    on top of an asteroid.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家被表示为一艘宇宙飞船。宇宙飞船可以左右旋转，射击，并且宇宙飞船还可以给自己加速。玩家还可以将飞船送入超空间，使其消失并在屏幕上的随机位置重新出现，但存在自我毁灭或出现在小行星上的风险。
- en: The player starts with three lives, and on every 10,000 points, a new life is
    won. If the player crashes into something, it will be destroyed and the player
    will lose one life. It will reappear at the starting point, that is, the middle
    of the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家开始时有三条生命，每获得10,000分，就会赢得一条新生命。如果玩家撞到某个东西，它将被摧毁，玩家将失去一条生命。它将在起点重新出现，即屏幕的中间。
- en: The levels
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关卡
- en: Each level starts with some big asteroids in random places that are drifting
    in various directions. Each level will have an increased number of asteroids.
    This number is four for the first level and eleven starting from the fifth level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关卡开始时，在随机位置有一些大流星，它们以各种方向漂移。每个关卡都会增加流星的数量。这个数量对于第一关是四个，从第五关开始是十一个。
- en: 'The board is a bit special because it''s a Euclidean torus (see the definition
    on Wikipedia for more detail: [http://en.wikipedia.org/wiki/Torus](http://en.wikipedia.org/wiki/Torus)).
    The top and the bottom of the screen wrap to meet each other, as do the left and
    right sides, except that the top right meets the bottom left, and vice versa.
    The level is finished when there are no more meteors on the screen.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 板块有点特殊，因为它是一个欧几里得环面（更多细节请参考维基百科的定义：[http://en.wikipedia.org/wiki/Torus](http://en.wikipedia.org/wiki/Torus)）。屏幕的顶部和底部会相互包裹，左右两侧也是如此，除了右上角与左下角相遇，反之亦然。当屏幕上没有流星时，关卡结束。
- en: The enemies
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人
- en: 'There are two kinds of enemies: meteors and flying saucers. Both of them can
    destroy you if you crash into them, and both add some points when you destroy
    them by shooting at them.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种敌人：流星和飞碟。如果你撞到它们，它们都会摧毁你，并且当你射击摧毁它们时，它们都会增加一些分数。
- en: The meteors
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流星
- en: 'There are three types of meteors. Each one has its own size, speed, and a points
    number that differs from the others. Here is a table that summarizes the different
    meteors'' properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的流星。每种流星都有其自己的大小、速度和与其它不同的分数。以下是一个总结不同流星特性的表格：
- en: '| Size | Big | Medium | Small |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 大 | 中等 | 小 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Speed | Slow | Medium | Fast |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 慢 | 中等 | 快 |'
- en: '| Split | 2~3 medium | 2~3 smalls | - |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 分割 | 2~3 中型 | 2~3 小型 | - |'
- en: '| Base Points | 20 | 60 | 100 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 基础分数 | 20 | 60 | 100 |'
- en: Each time a meteor is hit, it is split into a smaller meteor, except for the
    small ones. The big meteors are also those that represent the starting meteor
    field of each level.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每当流星撞击时，它会被分裂成更小的流星，除了那些小的流星。大流星也是代表每个等级起始流星场的那些流星。
- en: The flying saucers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 飞碟
- en: Time to time! A flying saucer appears and tries to disturb the player. There
    are two saucers, a big one, which does nothing apart from moving, and a small
    one, that shoots at the player. The higher the score of the player, the higher
    is the chance that a small saucer appears instead of a big one. Starting from
    40,000, only small saucers appear. In addition, the more points the player has,
    the higher is the precision of the saucers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不时地！一个飞碟出现并试图干扰玩家。有两种飞碟，一个大飞碟，除了移动外什么都不做，还有一个小飞碟，它会向玩家射击。玩家的分数越高，小飞碟出现而不是大飞碟的机会就越高。从40,000分开始，只有小飞碟出现。此外，玩家拥有的分数越高，飞碟的精度就越高。
- en: Modifying our application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我们的应用程序
- en: 'Now that we have all the information required to build our game, let''s start
    to change it. The first step is to change our world to a Euclidean torus with
    a fixed size. Here is a representation of a torus taken from the Wikipedia page:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建游戏所需的所有信息，让我们开始对其进行修改。第一步是将我们的世界改变为一个具有固定大小的欧几里得环面。以下是从维基百科页面中获取的环面的表示：
- en: '![Modifying our application](img/8477OS_03_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![修改我们的应用程序](img/8477OS_03_04.jpg)'
- en: 'To do this, we will need some information from inside the game, such as the
    world size. We will add the information inside the `Game` class as two integer
    values, `height` and `width`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要从游戏内部获取一些信息，例如世界大小。我们将在`Game`类内部添加两个整数值，`height`和`width`：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will initialize them with the constructor. So now, we need parameters for
    this class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用构造函数来初始化它们。所以现在，我们需要为这个类提供参数：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will need to change our constructor implementation a bit, as shown in the
    following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要稍微修改我们的构造函数实现，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, now we can choose the size of the world, but how do we make it a torus?
    In reality, it's not complicated. We only need to check the position of each entity
    after moving them; and if they are out of the world, we correct their positions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们可以选择世界的大小，但如何将其变成一个环面呢？在现实中，这并不复杂。我们只需要在移动每个实体后检查它们的位置；如果它们超出了世界范围，我们就纠正它们的位置。
- en: 'Let''s try this with the player, as shown in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用下面的代码片段尝试一下玩家：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see here, firstly, we call the `update()` method on the player, and
    then we correct its position if it's out of the world range. We now have an infinite
    world.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，首先，我们在玩家上调用`update()`方法，然后如果它超出了世界范围，我们就纠正其位置。我们现在有一个无限的世界。
- en: 'The `Player::getPosition()` method used is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的`Player::getPosition()`方法如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only sad thing with this is that we modify the player's position inside
    the `Game` class. It will be better if the player could manage its position itself,
    isn't it? Wrong! If you think a bit about this, you will understand that the player
    doesn't care about the world's shape. It's the world's work to be able to adapt
    the position of its entity, not the contrary.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一令人难过的是，我们在`Game`类中修改了玩家的位置。如果玩家能自己管理其位置会更好，不是吗？错误！如果你稍微思考一下，你会理解玩家并不关心世界的形状。适应其实体位置的工作是世界的责任，而不是相反。
- en: 'Here we have two options: keep our code as it is or establish a more flexible
    system. If we quickly think about what will be required for the managements of
    the meteors and saucers, the second option seems best. So let''s build a more
    flexible system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个选择：保持我们的代码不变或者建立一个更灵活的系统。如果我们快速思考一下管理流星和飞碟所需的要素，第二个选择似乎最好。所以让我们构建一个更灵活的系统。
- en: 'In game development, there are two major design patterns that answer to this.
    They are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，有两种主要的设计模式可以回答这个问题。它们如下：
- en: The hierarchical entity system
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次实体系统
- en: The entity component system
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体组件系统
- en: Each of these patterns answer the problem in a different way. We will see them
    right after the world class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式中的每一个都以不同的方式回答了这个问题。我们将在世界类之后看到它们。
- en: The World class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界类
- en: All our logic is actually made in the `Game` class. This is a good way, but
    we can do better. If we think about it, the `Game` class has to not only process
    events, create the window, and delegate other classes to the pause and menu systems,
    but also perform all the entity management.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的逻辑实际上都是在 `Game` 类中实现的。这是一个好方法，但我们还可以做得更好。如果我们仔细想想，`Game` 类不仅要处理事件、创建窗口并将其他类委托给暂停和菜单系统，还要执行所有的实体管理。
- en: To be more explicit, the game doesn't have to manage any entity, but can create
    a world and populate it. Then, all the work is done by the world class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更明确，游戏不需要管理任何实体，但它可以创建一个世界并填充它。然后，所有的工作都由世界类来完成。
- en: 'The world is a container of entities but also of sounds effects. It has a specific
    size, shape, and rules (such as physics). It can also be displayed on screen.
    Finally, the class looks similar to the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 世界是一个实体的容器，同时也是音效的容器。它具有特定的尺寸、形状和规则（如物理规则）。它还可以在屏幕上显示。最后，这个类的代码片段看起来如下：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like the other classes, we make the `World` class non-replicable. We add some
    functions to add an entity to the world, and some functions to remove them all
    as well. Because it's possible to have some sounds in the world, we also add a
    method to add them. It takes an ID from the `Configuration` class, exactly like
    the IDs for `Textures`. We also add some functions to get information such as
    the number of entities, the size of the world, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类一样，我们使 `World` 类不可复制。我们添加了一些函数来向世界添加实体，以及一些函数来移除它们。因为世界上可能有一些音效，所以我们还添加了一个方法来添加它们。它需要一个来自
    `Configuration` 类的 ID，这与 `Textures` 的 ID 完全一样。我们还添加了一些函数来获取信息，例如实体的数量、世界的尺寸等等。
- en: Now if we take a look at the attributes, we can see two containers for the entities.
    This is a trick that will make our lives easier. I will explain it in the implementation.
    The other container is for `sf::Sound` that can be added to the world. I will
    also explain it in the implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看属性，我们可以看到两个用于实体的容器。这是一个会使我们的生活更简单的技巧。我将在实现中解释它。另一个容器用于可以添加到世界中的 `sf::Sound`。我将在实现中解释它。
- en: 'Now, take a look at the implementation. This class is a bit long, and some
    functions have been reduced to not take a lot of space in this chapter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现。这个类有点长，并且在这个章节中一些函数被简化以节省空间：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is no difficulty in these functions. The constructor simply sets the
    size of the world, and the destructor clears it; as shown in the following code
    snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数没有难度。构造函数只是设置世界的尺寸，析构函数则清除它；如下代码片段所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is another simple function, but we don''t add an entity directly to the
    `_entites` container. Instead, we add it to a temporary container that contains
    only the entities created during a particular time frame. The reason for doing
    this will be explained in the `update()` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，但我们并没有直接将实体添加到 `_entites` 容器中。相反，我们将其添加到一个临时容器中，该容器只包含在特定时间段内创建的实体。这样做的原因将在
    `update()` 函数中解释：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we clean the entire world by deleting all its entities and sounds. Because
    we use raw pointers for the entities, we need to delete them explicitly unlike
    `sf::Sound`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过删除所有实体和音效来清理整个世界。因为我们使用原始指针来处理实体，所以我们需要显式地删除它们，与 `sf::Sound` 不同：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function creates a `sf::Sound` parameter from a `sf::SoundBuffer` parameter
    contained in the `Configuration` class, initialize it, and play it. Because each
    `sf::Sounds` has its own thread, the `sf::Sound::play()` parameter will not interrupt
    our main thread. And then, we store it in the appropriate container:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从 `Configuration` 类中包含的 `sf::SoundBuffer` 参数创建一个 `sf::Sound` 参数，初始化它并播放。因为每个
    `sf::Sound` 都有自己的线程，所以 `sf::Sound::play()` 参数不会中断我们的主线程。然后，我们将它存储在适当的容器中：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `World::isCollide()` function is a helper to check whether an entity is
    colliding with another one. This will be used to place the meteors at the beginning
    of the game:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`World::isCollide()` 函数是一个辅助函数，用于检查一个实体是否与另一个实体发生碰撞。这将在游戏开始时用于放置流星：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These functions are pretty simple. There are just some getters. The only thing
    that is particular is `size()` because it returns the total number of entities:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数相当简单。它们只是包含一些获取器。唯一特别的是 `size()` 函数，因为它返回实体的总数：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function is a bit more complicated than the previous version of it. Let''s
    explain it in detail:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数比之前的版本要复杂一些。让我们详细解释一下：
- en: We merge the entities' container together into the main container.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实体的容器合并到主容器中。
- en: We update all entities, and then verify that their positions are correct. If
    this is not the case, we correct them.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新所有实体，然后验证它们的位置是否正确。如果不正确，我们会纠正它们。
- en: We check the collision between all the entities and dead entities are removed.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查所有实体和已死亡实体的碰撞，并移除已死亡的实体。
- en: Sounds that have been played are removed from the container.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已播放的声音从容器中移除。
- en: 'In the update and collision loops, some entities can create others. That''s
    the reason for the `_entities_tmp` container. In this way, we are sure that our
    iterator is not broken at any time, and we do not update/collide entities that
    have not experienced a single frame, as shown in the following code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新和碰撞循环中，一些实体可以创建其他实体。这就是 `_entities_tmp` 容器存在的原因。这样我们就能确保我们的迭代器在任何时候都不会损坏，并且我们不会更新/碰撞那些还没有经历过一个帧的实体，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function is simple, and forwards its job to all the entities. As you can
    see, the `World` class is not really complicated, and manages any kind of entities
    and all sounds. By doing this, we can remove a lot of tasks from the `Game` class,
    and delegate it to the `World` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单，并将它的任务转发给所有实体。如您所见，`World`类并不复杂，管理任何类型的实体和所有声音。通过这样做，我们可以从`Game`类中移除很多任务，并将其委托给`World`类。
- en: The hierarchical entity system
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层实体系统
- en: 'This system is the most intuitive. Each kind of entity is a different class
    in your code, and all of them are extended from a common virtual class, most of
    the time called **Entity**. All the logic is made inside the class in the `Entity::update()`
    function. For our project, the hierarchical tree could be similar to the following
    figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统是最直观的。每种实体在您的代码中都是一个不同的类，并且它们都扩展自一个共同的虚拟类，通常称为**Entity**。所有的逻辑都在`Entity::update()`函数内部完成。对于我们的项目，层次树可能类似于以下图示：
- en: '![The hierarchical entity system](img/8477OS_03_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![分层实体系统](img/8477OS_03_01.jpg)'
- en: As you can see, there are several abstraction layers. For this project, and
    because we don't have a lot of different kind of entities, we will use this solution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有几个抽象层。对于这个项目，因为我们没有很多不同种类的实体，我们将使用这个解决方案。
- en: The entity component system
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体组件系统
- en: 'This is a totally different approach. Instead of having each type of entity
    represented as a class, there is only one class: entity. To this entity, we attach
    some property such as the position, ability to be draw, a gun, and whatever you
    want. This system is really powerful, and is a great solution in video games,
    but is also difficult to build. I will not get into more detail about this system,
    because I will come back to it in the next chapter. So even if we don''t use it
    right now, don''t be frustrated, we will build and use it in the next project.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全不同的方法。不是将每种类型的实体表示为一个类，而只有一个类：实体。我们给这个实体附加一些属性，如位置、可绘制的能力、一把枪，以及您想要的任何东西。这个系统非常强大，是视频游戏中的一个很好的解决方案，但构建起来也很困难。我不会对这个系统进行更详细的介绍，因为我在下一章会回到它。所以即使我们现在不使用它，也不要沮丧，我们将在下一个项目中构建并使用它。
- en: Designing our game
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的游戏
- en: 'Now that we have chosen the entity component system approach and created a
    world that will be populated by them, let''s think about the needs. Following
    table summarizes the needs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经选择了实体组件系统方法并创建了一个将由它们填充的世界，让我们考虑一下需求。以下表格总结了需求：
- en: '| Entity | Parent | Specificities |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| Entity | Parent | 特性 |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Entity` |   | This can moveThis can be drawnThis can collide with another
    entity |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Entity` |   | 这个可以移动，可以被绘制，可以与其他实体相撞 |'
- en: '| `Player` | Entity | This can shootThis is controlled by inputsThis can collide
    with everything except the one it shoots |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Player` | Entity | 这个可以射击，由输入控制，可以与除了它射击的目标之外的所有东西相撞 |'
- en: '| `Enemy` | Entity | This can be destroyed by shootingThis gets the player
    some points when destroyed by shooting |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Enemy` | Entity | 这个可以通过射击被摧毁，当被射击摧毁时，会给玩家一些分数 |'
- en: '| `Saucer` | Enemy | This has a bigger chance to spawn a small saucer when
    the point number increasesThis can collide with everything except saucer shoots
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `Saucer` | Enemy | 当分数增加时，这个有更大的几率生成一个小飞碟，这可以与除了飞碟射击之外的所有东西相撞 |'
- en: '| `BigSaucer` | Saucer | This has a special skin |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `BigSaucer` | Saucer | 这有一个特殊的皮肤 |'
- en: '| `SmallSaucer` | Saucer | This can shoot the `Player` entityThis has a special
    skin |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `SmallSaucer` | Saucer | 这个可以射击`Player`实体，它有一个特殊的皮肤 |'
- en: '| `Meteors` | Enemy | This can collide with everything except other meteors
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Meteors` | Enemy | 这个可以与除了其他陨石之外的所有东西相撞 |'
- en: '| `BigMeteor` | Meteors | This splits into some `MediumMeteor` when destroyedThis
    has a special skin |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `BigMeteor` | 流星 | 在被摧毁时分裂成一些 `MediumMeteor`，并且具有特殊皮肤 |'
- en: '| `MediumMeteor` | Meteors | This splits into `SmallMetors` when destroyedThis
    has a special skin |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `MediumMeteor` | 流星 | 在被摧毁时分裂成 `SmallMeteor`，并且具有特殊皮肤 |'
- en: '| `SmallMeteor` | Meteors | This has a special skin |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `SmallMeteor` | 流星 | 具有特殊皮肤 |'
- en: '| `Shoot` | Entity | This lives for a specific time |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Shoot` | 实体 | 这存在特定的时间 |'
- en: '| `ShootPlayer` | Shoot | This can only collide with enemiesThis has a specific
    skin |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `ShootPlayer` | 射击 | 这只能与敌人发生碰撞，并且具有特定皮肤 |'
- en: '| `ShootSaucer` | Shoot | This can collide with `Meteor` and `Player`This has
    a special skin |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ShootSaucer` | 射击飞碟 | 这可以与 `Meteor` 和 `Player` 发生碰撞，并且具有特殊皮肤 |'
- en: 'Now that we have all the information needed for each class, let''s build them.
    The final result will look similar to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了每个类所需的所有信息，让我们开始构建它们。最终结果将类似于以下内容：
- en: '![Designing our game](img/8477OS_03_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的游戏](img/8477OS_03_05.jpg)'
- en: Prepare the collisions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备碰撞
- en: 'In this project we will use a simple collision detection: collision between
    circles. As just said this is very basic and can be improved a lot, but is sufficient
    for now. Take a look to the class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用简单的碰撞检测：圆形之间的碰撞。正如刚才所说的，这非常基础，可以大幅改进，但就目前而言是足够的。看看这个类：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The is no member here, and the class can't be instantiate. The aim of the class
    is to group some helper function used by other classes. So here, only one collision
    test is describe that take two `sf::Sprite` as parameters. Take a look to the
    implementation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有成员，该类不能被实例化。该类旨在将其他类使用的某些辅助函数分组。因此，这里只描述了一个碰撞测试，它接受两个 `sf::Sprite` 作为参数。看看实现。
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function first computes the radius for each of the sprite. Then it checks
    if the distance between the two sprites (computed using the Pythagoras theorem)
    is less than the sum of the tow radius. If it's verify, then there is no collision,
    on the other side, there is one, even if we don't exactly know the exact point.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先计算每个精灵的半径。然后它检查两个精灵之间的距离（使用勾股定理计算）是否小于两个半径之和。如果是的话，则没有碰撞，否则，存在碰撞，即使我们不知道确切的碰撞点。
- en: The Entity class
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体类
- en: 'To build our system, we need the base class, so let''s start with the `Entity`
    class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的系统，我们需要基类，所以让我们从 `Entity` 类开始：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s discuss this class step by step:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地讨论这个类：
- en: Firstly, we make the class noncopyable.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使该类不可复制。
- en: Then we make the destructor virtual. This is a really important point because
    the `Entity` class will be used as a polymorphic class. So we need to set the
    destructor as virtual to be able to destruct the real object and not only it's
    `Entity` base.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将析构函数设置为虚拟。这是一个非常重要的点，因为 `Entity` 类将被用作多态类。因此，我们需要将析构函数设置为虚拟，以便能够销毁真实对象，而不仅仅是它的
    `Entity` 基类。
- en: We also define some helper functions to know if the entity is alive and also
    to set/get its position. The code is the same as we have in the `Player` class.
    We also define some virtual methods that will be overridden in other classes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一些辅助函数，以确定实体是否存活，以及设置/获取其实体位置。代码与我们在 `Player` 类中使用的代码相同。我们还定义了一些将在其他类中重写的虚拟方法。
- en: The virtual function `onDestroy()` is important. Its goal is to execute some
    code before the destruction on the entity by shooting it or whatever. For example,
    the ability of a `Meteor` entity to be split will be put in this function, and
    so will all kind of sounds caused by the destruction of the object.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟函数 `onDestroy()` 非常重要。它的目的是在实体被销毁之前执行一些代码，例如通过射击或其他方式。例如，`Meteor` 实体的分裂能力将被放入这个函数中，以及所有由对象摧毁引起的各种声音。
- en: 'Now take a look to the implementation of the `Entity` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 `Entity` 类的实现：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The constructor sets the texture to the internal `sf::Sprite` function, and
    then center the origin of it. We also set the world of the entity, and the alive
    value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将纹理设置为内部的 `sf::Sprite` 函数，然后将其原点居中。我们还设置了实体的世界和存活值：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These two functions are the exact same as those in the `Player` class. So no
    surprises here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数与 `Player` 类中的函数完全相同。所以这里没有惊喜：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These two functions are new. It's simply a helper function. `IsAlive()` is used
    to know if an entity have to be removed from the world, and the `onDestroy()`
    function is a method that will be called when a collision is detected with another
    `Entity`. Nothing complicated for now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数是新的。它只是一个辅助函数。`IsAlive()`用于确定实体是否需要从世界中移除，而`onDestroy()`函数是在检测到与其他`Entity`的碰撞时将被调用的方法。目前还没有什么复杂的事情。
- en: The Player class
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家类
- en: 'Now that we have the `Entity` class, let''s change the `Player` class to extend
    it from `Entity`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Entity`类，让我们将`Player`类更改为从`Entity`扩展：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, we removed all the functions and attributes related to the
    position and the display. The `Entity` class already does it for us. And now the
    implementation of this class is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们移除了所有与位置和显示相关的函数和属性。`Entity`类已经为我们做了这些。现在这个类的实现如下：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here we remove all the code that initializes the `_sprite` function, and delegate
    the job to the `Entity` constructor. We also add two new abilities, to shoot and
    to go to hyperspace:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们移除了初始化`_sprite`函数的所有代码，并将任务委托给`Entity`构造函数。我们还添加了两个新能力，射击和进入超空间：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We set the default behavior of the collision. We need to know the real type
    of the `Entity` as a parameter. To do this we use the virtual table lookup by
    trying to convert the `Entity` class to a specific pointer type. If this is not
    possible, `nullptr` is returned by `dynamic_cast()`. There are other approaches
    to do this, such as double dispatch. But the one used here is the simplest and
    easy to understand but is a slow operation. Once the real type of entity is known,
    the collision test is made. In this project, the hit box of each entity is the
    circle inscribed in its sprite. This is a pretty good approximation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了碰撞的默认行为。我们需要知道`Entity`的实际类型作为参数。为此，我们使用虚拟表查找，尝试将`Entity`类转换为特定的指针类型。如果这不可能，`dynamic_cast()`将返回`nullptr`。还有其他方法可以做到这一点，例如双重分派。但这里使用的是最简单、最容易理解的方法，但操作较慢。一旦知道了实体的实际类型，就会进行碰撞测试。在这个项目中，每个实体的碰撞框是其精灵内切圆。这是一个相当好的近似：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function creates a `ShootPlayer` instance and adds it to the world. Because
    we don''t want that the player to create a shoot in every frame, we add a timer
    that is updated in the `Player::update()` method, as shown:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建一个`ShootPlayer`实例并将其添加到世界中。因为我们不希望玩家在每一帧都创建射击，所以我们添加了一个计时器，它在`Player::update()`方法中更新，如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method teleports the player to a random place in the world. It also removes
    all the impulsion, so the player will not continue to move in its previous direction
    after a teleportation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将玩家传送到世界中的随机位置。它还移除了所有推力，因此玩家在传送后不会继续以之前的方向移动：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method updates the position and the rotation of a `Player` according to
    the different action made by the user. It also updates the time since the last
    shoot to be able to shoot again.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法根据用户的不同操作更新`Player`的位置和旋转。它还更新自上次射击以来的时间，以便能够再次射击。
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To better understand the `Entity::onDestroy()` method, remember that this function
    is called before the destruction (and the call of the destructor) of an `Entity`
    instance when a collision occurs. So here we call the `onDestroy()` function of
    the `Entity` base of the class, and then do the special things of the player,
    such as reduce the number of lives, set the player value to `nullptr`, and finally,
    add an explosion sound to the world. The other methods of the `Player` class have
    not changed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`Entity::onDestroy()`方法，请记住，当发生碰撞时，这个函数在`Entity`实例的销毁（以及析构函数的调用）之前被调用。因此，在这里我们调用类的`Entity`基类的`onDestroy()`函数，然后执行玩家的特殊操作，例如减少生命值、将玩家值设置为`nullptr`，最后，向世界中添加爆炸声音。`Player`类的其他方法没有改变。
- en: The Enemy class
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人类
- en: 'We will now create the Enemy class as we have already described, in the table
    at the beginning of the `Design our game part`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建敌人类，正如我们在`设计我们的游戏部分`开头的表中已经描述的那样：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class is pretty small because it doesn't need a lot of new logic compared
    to the `Player` class. We only need to briefly specify the `onDestroy()` method
    by adding points to the global score of the game. So we create a `getPoints()`
    method that will simply return the number of points for an enemy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Player`类相比，这个类相当小，因为它不需要很多新的逻辑。我们只需要简要指定`onDestroy()`方法，通过向游戏的全球得分添加分数来实现。因此，我们创建了一个`getPoints()`方法，它将简单地返回敌人的分数。
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The constructor simply initializes the `_impulse` vector to a random one, but
    with the length as `1`. This vector will be multiplied by the speed of the `Saucers`/`Meteor`
    entity in their respective constructors:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数简单地初始化`_impulse`向量到一个随机的值，但长度为`1`。这个向量将在它们各自的构造函数中乘以`Saucers`/`Meteor`实体的速度：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method simply calls the `onDestroy()` function from the `Entity` base of
    the object, and then adds the points won by destroying the object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地从对象的`Entity`基类中调用`onDestroy()`函数，然后添加摧毁对象所获得的分数。
- en: The Saucer class
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 飞盘类
- en: 'Now that we have the `Enemy` class made, we can build the `Saucer` base class
    corresponding to our expectations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Enemy`类，我们可以构建符合我们预期的`Saucer`基类：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This class is pretty simple; we just have to specify the method already built
    in the `Entity` and `Enemy` class. Because the class will not specify the constructor,
    we use the using-declaration to refer to the one from `Enemy`. Here, we introduce
    a new function, `newSaucer()`. This function will randomly create a saucer depending
    on the player's score and add it to the world.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类相当简单；我们只需指定已经构建在`Entity`和`Enemy`类中的方法。因为类没有指定构造函数，所以我们使用using-declaration来引用`Enemy`中的那个。在这里，我们引入了一个新函数，`newSaucer()`。这个函数将根据玩家的分数随机创建一个飞盘并将其添加到世界中。
- en: 'Now, take a look to the implementation of this class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个类的实现：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The same technique as in `Player::isCollide()` is used here, so no surprises.
    We specify this function in the `Saucer` base class because the collisions are
    the same for any of the saucers. It avoids code duplication as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了与`Player::isCollide()`相同的技巧，所以没有惊喜。我们在`Saucer`基类中指定这个函数，因为任何飞盘的碰撞都是相同的。这避免了代码重复，如下所示：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function is pretty long but not really complicated. It manages the movement
    of the saucer. Let''s explain it step by step:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当长，但并不复杂。它管理着飞盘的运动。让我们一步一步地解释它：
- en: We look for the nearest object of the saucer into which it may crash.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们寻找飞盘可能与之碰撞的最近的对象。
- en: If there is an object found too close, we add an impulse to the saucer in the
    opposite direction of this object. The goal is to avoid a crash.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发现一个太靠近的对象，我们向飞盘添加一个与该对象相反方向的推力。目的是避免碰撞。
- en: Let's now continue with the other functions.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们继续其他函数。
- en: '[PRE33]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function is simple. We simply call the `onDestroy()` method from the `Enemy`
    base of the class, and then add an explosion sound to the world:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数很简单。我们只是从类的`Enemy`基类中调用`onDestroy()`方法，然后向世界添加一个爆炸声：
- en: '[PRE34]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As previously mentioned, this function creates a saucer randomly and adds it
    to the world. The more the points the player has, the greater the chance to create
    a `SmallSaucer` entity. When the score reaches 40,000 `SmallSaucer` is created
    as explained in the description of the game.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，这个函数随机创建一个飞盘并将其添加到世界中。玩家拥有的分数越高，创建`SmallSaucer`实体的机会就越大。当分数达到40,000时，就像游戏描述中解释的那样创建`SmallSaucer`。
- en: 'Now that we have created the `Saucer` base class, let''s make the `SmallSaucer`
    class. I''ll not explain the `BigSaucer` class because this is the same as the
    `SmallSaucer` class but simpler (no shooting), as shown in the following code
    snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Saucer`基类，让我们创建`SmallSaucer`类。我不会解释`BigSaucer`类，因为这个类与`SmallSaucer`类相同，但更简单（没有射击），如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because we know the skin of the `SmallSaucer` entity, we don't need the texture
    ID as a parameter, so we remove it from the constructor parameter. We also add
    an attribute to the class that will store the elapsed time since the last shoot
    was made, as in `Player` entity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道`SmallSaucer`实体的皮肤，所以我们不需要将纹理ID作为参数，所以我们将其从构造函数参数中删除。我们还添加了一个属性，用于存储自上次射击以来经过的时间，就像在`Player`实体中一样。
- en: 'Now take a look at the implementation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看实现：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This constructor is simple because a great part of the job is already done
    in the base of the class. We just initialize the impulsion and add a sound to
    the world when the saucer appears. This will alert the player of the enemy and
    add some fun to the game:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数很简单，因为大部分工作已经在类的基类中完成了。我们只需初始化推力，并在飞盘出现时向世界添加一个声音。这将警告玩家敌人，并为游戏增添一些乐趣：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This function simply sets the number of points that are won when the `SmallSaucer`
    entity is destroyed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地设置了当`SmallSaucer`实体被摧毁时获得的分数：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function is fairly simple. Firstly, we just move the saucer by calling
    the `update()` function from the `Saucer` base, then shoot the player as soon
    as we can, and that's all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当简单。首先，我们通过从`Saucer`基类调用`update()`函数来移动碟子，然后尽可能快地射击玩家，这就是全部。
- en: 'Here is a screenshot of the saucer behavior:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是碟子行为的截图：
- en: '![The Saucer class](img/8477OS_03_06.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![碟子类](img/8477OS_03_06.jpg)'
- en: The Meteor class
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**流星类**'
- en: 'Now it''s time to build the main enemies of the game: the meteors. We will
    start by the virtual `Meteor` class. Here is its definition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建游戏的主要敌人：流星了。我们将从虚拟的`Meteor`类开始。以下是它的定义：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, this class is very short. We only specify the collision rules
    and the update function that will manage its move. Now, take a look at its implementation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类非常短。我们只指定碰撞规则和将管理其移动的更新函数。现在，看看它的实现：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The collisions are tested with all `Entity` except the `Meteors` as it was
    specified. Here again, we use the `circleTest()` function to test the collision
    with the other objects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据指定，碰撞测试是用所有`Entity`对象进行的，除了`Meteors`。在这里，我们再次使用`circleTest()`函数来测试与其他对象的碰撞：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function couldn't be more simple. We only move the `meteor` entity by computing
    the distance traveled since the last frame. There is nothing complicated to do
    here because a meteor is straight all the time, so there is no change in its direction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我们只通过计算自上一帧以来移动的距离来移动`meteor`实体。这里没有复杂的事情要做，因为流星始终是直的，所以它的方向没有变化。
- en: 'Now that we have the base of all the meteors, let''s make the big one. I will
    not explain the others because the logic is the same. The following code snippet
    explains it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有流星的基础，让我们来制作大流星。我不会解释其他的，因为逻辑是相同的。下面的代码片段解释了它：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can see this class is also very concise. We only need to define the constructor,
    the number of points earned, and the destruction. And now, the implementation
    of this class is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个类也非常简洁。我们只需要定义构造函数、得分数量和破坏。现在，这个类的实现如下：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The constructor is not difficult, but the choice of the texture ID is. Because
    there are several textures possible for a `BigMeteor`, we choose one of them randomly,
    as shown in the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不难，但纹理ID的选择是。因为对于`BigMeteor`有几种可能的纹理，我们随机选择其中之一，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method is the most important one. It creates some other meteors when a
    big one is destroyed, and adds them to the world. We also add an explosion sound
    for more fun during the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是最重要的一个。当一个大流星被摧毁时，它会创建一些其他流星并将它们添加到世界中。我们还添加了一个爆炸声，以增加游戏中的趣味性。
- en: The Shoot class
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**射击类**'
- en: 'Now that all the enemies are made, let''s build the last entity class, the
    `Shoot`. A Shoot is very simple. It''s nothing but an entity that goes straight,
    and lives only for a specific time:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有敌人都已经制作好了，让我们构建最后一个实体类，`Shoot`。射击非常简单。它只是一个直线移动的实体，并且只在特定时间内存在：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Nothing surprising here, we only add a `_duration` attribute that will store
    the elapsed time since the creation of the `Shoot` class. Now, the implementation
    of the update function is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么令人惊讶的，我们只添加了一个`_duration`属性，它将存储自`Shoot`类创建以来的经过时间。现在，更新函数的实现如下：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function moves the shoot and adjusts the `_duration` attribute by removing
    the elapsed time. If the shoot live time reaches zero, we set it to dead, and
    the world will do the rest.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数移动射击并调整`_duration`属性，通过减去经过的时间。如果射击的生命时间达到零，我们将其设置为死亡，世界将完成剩余的工作。
- en: 'Now, let''s build the `ShootPlayer` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建`ShootPlayer`类：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, the constructor has changed here. There is no more a `World`
    instance as a parameter apart from the source that creates the shoot. Let''s take
    a look at the implementation to better understand the reason for this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的构造函数已经改变。除了创建射击的源之外，不再有`World`实例作为参数。让我们看看实现，以便更好地理解原因：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the world instance is copied from the source. Moreover, the
    initial position of the bullet is set to the position of the `Player` class when
    it is created. We also rotate the bullet as needed, and set its direction. I will
    not explain the collision function because there is nothing new compared to the
    previously explained functions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，世界实例是从源复制的。此外，子弹的初始位置设置为创建`Player`类时的位置。我们还需要根据需要旋转子弹，并设置其方向。我不会解释碰撞函数，因为没有与之前解释的函数相比的新内容。
- en: 'The `ShootSaucer` class uses the same logic as the `ShootPlayer` class, but
    there is a change. The accuracy of the saucers changes with the number of points
    of the player. So we need to add a bit of randomness. Let''s take a look to the
    constructor:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShootSaucer`类使用与`ShootPlayer`类相同的逻辑，但有一个变化。飞碟的准确性会随着玩家得分的增加而变化。所以我们需要添加一点随机性。让我们看看构造函数：'
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s explain this function step by step:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地解释这个函数：
- en: We compute the direction vector of the bullet.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算子弹的方向向量。
- en: We add to it a little loss of accuracy depending of the current score.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据当前得分添加一点精度损失。
- en: We set the `_impulsion` vector depending on the computed direction.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据计算出的方向设置`_impulsion`向量。
- en: We set the position and the rotation of the sprite as needed.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据需要设置精灵的位置和旋转。
- en: And finally, we release it to the world.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将它发布到世界上。
- en: 'Now that all the classes have been made, you will be able to play the game.
    The final result should look like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有类都已经创建，你将能够玩游戏。最终结果应该看起来像这样：
- en: '![The Shoot class](img/8477OS_03_02.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![射击类](img/8477OS_03_02.jpg)'
- en: Pretty nice, isn't it?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 很不错，不是吗？
- en: Building a Tetris clone
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建俄罗斯方块克隆
- en: 'Now that we''ve created a complete game, let''s build another one, a **Tetris**
    clone. This game is simpler than the previous one and will take less time to build,
    but is still very interesting. In fact, the internal architecture of this game
    is really different from the others. This is due to the kind of game that it is:
    a puzzle. The aim of the game is to fill lines of a grid with pieces made of four
    squares. Each time a line in completed, it''s destroyed, and points are added
    to the player. Because this is a different kind of game, there are several implications
    as there is no player or no enemies in this game, only pieces and a board (grid).
    For this game, I will focus on the game logic only. So I will not reuse the previously
    made classes such as `Action`, `ActionMap`, `ActionTarget`, `Configuration`, and
    `ResourceManager` to be more concise. Of course, you can use them to improve the
    proposed source code.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个完整的游戏，让我们再创建另一个，一个**俄罗斯方块**克隆。这个游戏比之前的游戏简单，并且构建时间会更短，但仍然非常有趣。实际上，这个游戏的内部架构与其他游戏真的很不同。这是因为这种游戏类型：一个拼图。游戏的目标是用由四个方块组成的拼图填满网格的行。每次完成一行，它就会被销毁，并且会给玩家加分。因为这是一种不同类型的游戏，所以有一些影响，因为在这个游戏中没有玩家或敌人，只有拼图和棋盘（网格）。对于这个游戏，我将只关注游戏逻辑。所以，我将不会重用之前制作的类，如`Action`、`ActionMap`、`ActionTarget`、`Configuration`和`ResourceManager`，以使代码更简洁。当然，你可以使用它们来改进提出的源代码。
- en: 'So, to build this game we will need to build some classes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了构建这个游戏，我们需要构建一些类：
- en: '`Game`: This class will be very similar to the `Game` class from the previous
    project and will manage the rendering'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game`：这个类将与之前项目的`Game`类非常相似，并将管理渲染。'
- en: '`Board`: This class will manage all the logic of the game'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Board`：这个类将管理游戏的所有逻辑'
- en: '`Piece`: This class will represent all the different kinds of tetrimino (pieces
    formed by four squares)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Piece`：这个类将代表所有不同类型的四联体（由四个方块组成的拼图）'
- en: '`Stats`: This class will be used to show different information to the player'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stats`：这个类将用于向玩家显示不同的信息'
- en: 'The final game will look like the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的游戏将看起来像以下截图：
- en: '![Building a Tetris clone](img/8477OS_03_03.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![构建俄罗斯方块克隆](img/8477OS_03_03.jpg)'
- en: Now that we know how to structure a game, we will directly think about the need
    of each class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何构建一个游戏，我们将直接考虑每个类的需求。
- en: The Stats class
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计类
- en: 'This class will be used to display the game information to the player such
    as the level, the number of rows, and the score. We will also use this class to
    display the **Game Over** message if it''s needed. Because this class will display
    some information to the screen and can be put anywhere on the render space, we
    will extend it from `sf::Drawable` and `sf::Transformable`. Here is the header
    of this class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将用于向玩家显示游戏信息，如关卡、行数和得分。我们还将使用这个类来显示**游戏结束**信息，如果需要的话。因为这个类将在屏幕上显示一些信息，并且可以被放置在渲染空间的任何位置，我们将从`sf::Drawable`和`sf::Transformable`扩展它。以下是这个类的头文件：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There is no real surprise for this class. We have some `sf::Text` that will
    be used to display information, and their values as numbers. We also add the point
    calculation to this class with the `addLines()` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有真正的惊喜。我们有一些`sf::Text`将用于显示信息，以及它们的数值。我们还添加了点计算到这个类中，使用`addLines()`函数。
- en: As previously mentioned, for the Tetris game, we need to focus on the game logic,
    so we are not going to use any manager for the font.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于俄罗斯方块游戏，我们需要关注游戏逻辑，因此我们不会使用任何字体管理器。
- en: 'Now take a look at the implementation of this class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个类的实现：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The constructor of the class set all the attributes to no surprise:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数将所有属性设置为默认值：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here again, there are no surprises. We just assigned the `_isGameOver` value
    to true:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里同样没有惊喜。我们只是将 `_isGameOver` 的值设置为 true：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function is a bit more interesting. Its aim is to add points to the global
    score depending on the number of lines completed. It also corrects the drawable
    text value and the level. Because a piece is composed of four squares, the maximum
    number of lines that can be suppressed with one piece is the number four. So in
    the switch statement, we only need to check these four possibilities:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有点意思。它的目的是根据完成的行数数量向全局得分添加分数。它还会纠正可绘制文本值和关卡。因为一个方块由四个方块组成，所以一个方块最多可以消除的行数是四行。所以在switch语句中，我们只需要检查这四种可能性：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As all the other `sf::Drawable::draw()` functions, this function draws the object
    on the screen. If the game is complete, we print the **Game Over** message, in
    other cases, we print the game score, number of completed rows, and the current
    level.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有其他的 `sf::Drawable::draw()` 函数一样，这个函数会在屏幕上绘制对象。如果游戏结束，我们会打印出**游戏结束**的信息；在其他情况下，我们会打印游戏得分、完成行数和当前关卡。
- en: In conclusion, this class is very simple and its job is to display all the game
    information on the screen.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这个类非常简单，它的任务是显示屏幕上的所有游戏信息。
- en: The Piece class
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方块类
- en: Now, let's build the first important class of this game, the `Piece` class.
    In Tetris, there are seven different tetrimino. I will not build seven different
    classes but only one. The idea is to show you another way to make your entities.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建这个游戏中的第一个重要类，即 `Piece` 类。在俄罗斯方块中，有七种不同的 tetrimino。我不会构建七个不同的类，而只构建一个。目的是展示另一种创建实体的方法。
- en: 'But, what is a piece exactly? If you think about it, you will find that a piece
    can be represented as an array of numbers. Moreover, a piece can be rotated. There
    are three ways to do this: calculate the rotation at runtime, pre-calculate the
    rotation at the startup or predefine them in the code. Because in our game, each
    piece is known when we create the game, we will choose the last way: hard code
    all the rotation. It could look bad, but in reality it''s not, and it will simplify
    a lot our implementation as you will see later in this chapter, but keep in mind
    that it''s not a fantastic idea to hard code items in every game.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，方块究竟是什么呢？如果你这么想，你会发现方块可以用数字数组来表示。此外，方块可以旋转。有三种方法来做这件事：在运行时计算旋转、在启动时预先计算旋转或在代码中预先定义它们。因为在我们游戏中，每个方块在创建游戏时都是已知的，所以我们将选择最后一种方法：硬编码所有旋转。这看起来可能不好，但实际上并非如此，它将大大简化我们后面的实现，但请记住，在每款游戏中硬编码项目并不是一个好主意。
- en: 'Now let''s take a look at the class:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个类：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This class is a bit long. Let''s explain it step by step:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有点长。让我们一步一步地解释它：
- en: We will define some constant variables that will be used for configuration purposes.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一些常量变量，这些变量将用于配置目的。
- en: We will define an `enum` function with all the different tetrimino pieces.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个包含所有不同 tetrimino 方块的 `enum` 函数。
- en: We will define an array of color. Each cell will represent the color of a tetrimino
    previously defined in the `enum` function.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个颜色数组。每个单元格将代表在 `enum` 函数中先前定义的 tetrimino 的颜色。
- en: The next line is particular. This defines all the different tetrimino rotations.
    Because each piece is a 2D array, we also need this information.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行是特别的。它定义了所有不同的 tetrimino 旋转。因为每个方块是一个二维数组，我们还需要这些信息。
- en: 'The other functions are more common: constructor, getter, and setter.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他函数更常见：构造函数、获取器和设置器。
- en: We will define some private attributes that store the state of the piece.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一些私有属性来存储方块的状态。
- en: 'Now is the funny part, the implementation of all of this. Because of the choices
    made, the implementation will differ a lot with the previous entity in the **Asteroid**
    game:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是这部分有趣的地方，所有这些功能的实现。由于做出的选择不同，与**小行星**游戏中的前一个实体相比，实现方式会有很大差异：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This array stores all the different colors for each tetrimino defined by the
    `TetriminoTypes` enum:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组存储了所有由 `TetriminoTypes` 枚举定义的 tetrimino 的不同颜色：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: At first glance, this is a very special array but turns out it's not really.
    In fact, each different piece is defined in the first cell of the array, the second
    cell represents all the different rotations of this piece and the rest is the
    representation of the piece rotation as a 2D array. The `0` value represents empty,
    `2` represents the center of the piece, and `1` represents the other piece of
    the tetrimino. I've not put all the code because it is pretty long, but you can
    take a look at it if needed at `03_Simple_2D_game/Tetris/src/SFML-Book/Piece.cpp`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个非常特殊的数组，但结果并非如此。实际上，每个不同的棋子在数组的第一个单元格中定义，第二个单元格表示这个棋子的所有不同旋转，其余的是棋子旋转的二维数组表示。`0`
    值表示空白，`2` 表示棋子的中心，`1` 表示四连珠的另一个棋子。我没有放所有代码，因为代码相当长，但如果需要，您可以在 `03_Simple_2D_game/Tetris/src/SFML-Book/Piece.cpp`
    中查看它。
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `assert` function is a macro that will raise an error and exit the program
    if the expression such as parameter is false. You can remove it by adding `#define
    NDEBUG` to your code/compiler option to disable this function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 函数是一个宏，如果表达式（如参数）为假，它将引发错误并退出程序。您可以通过在代码/编译器选项中添加 `#define NDEBUG`
    来删除它，以禁用此功能。'
- en: The `assert()` function is useful to do checks in the debug mode only. Use it
    when you want to be sure that a specific case is respected at run time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert()` 函数仅在调试模式下有用。当您想要确保在运行时遵循特定情况时使用它。'
- en: 'The constructor of the `Piece` class is simple, but we can easily send wrong
    parameter values to it. So I decided to show you the assert functionality, as
    follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Piece` 类的构造函数很简单，但我们很容易向它发送错误的参数值。因此，我决定向您展示断言功能，如下所示：'
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All of these functions are getters and setters, and they are simple. The only
    particular thing is the `setPosition`/`Rotation()` functions because it also resets
    the internal clock. Since the clock stores the time since the last movement of
    the piece, in reality it should not sock you.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是获取器和设置器，它们很简单。唯一特别的是 `setPosition`/`Rotation()` 函数，因为它们还会重置内部时钟。由于时钟存储自上次移动棋子以来的时间，实际上它不应该让您感到惊讶。
- en: The Board class
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Board` 类'
- en: Now, that all the pieces are made, let's build the class that will manage them,
    the **Board**.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的棋子都制作好了，让我们构建一个将管理它们的类，即 **Board**。
- en: 'This class will be represented as a grid (array) that stores colors (piece).
    So internally, this class is nothing but an array of integers. Each cell will
    store the kind of piece because the kind of piece determines its color (see the
    `Piece` class). Now take a look at the header of this class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将表示为一个存储颜色的网格（数组）。因此，从内部来看，这个类只是一个整数数组。每个单元格将存储棋子的类型，因为棋子的类型决定了它的颜色（参见 `Piece`
    类）。现在看看这个类的头文件：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the Board class we firstly define some configuration variable. This class
    is drawable and transformable, so we extend it from the corresponding SFML class.
    Then we create the constructor that take the size of the board as parameters and
    some methods to add, move and manage a Piece. We also add some private methods
    that will help use to in the implementation of the publics, and we store the size
    of the board internally, such as the grid. Because the size is not known at compile
    time, we need to build the grid at runtime, so the grid is a pointer to an array.
    We also add a sf::VertexArray that will contain the graphical grid to display
    on the screen.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Board` 类中，我们首先定义了一些配置变量。这个类是可绘制的和可变换的，所以我们从相应的 SFML 类扩展它。然后我们创建了一个构造函数，它接受棋板的大小作为参数，以及一些添加、移动和管理棋子的方法。我们还添加了一些私有方法，这些方法将帮助我们实现公共方法，并且我们在内部存储棋板的大小，例如网格。因为大小在编译时是未知的，我们需要在运行时构建网格，所以网格是一个指向数组的指针。我们还添加了一个
    `sf::VertexArray`，它将包含要在屏幕上显示的图形网格。
- en: Now that the class has been explained, let's implement it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经解释了类，让我们来实现它。
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The constructor initialize all the attributes but also create the grids content
    and border. Because the grid content and border are a one dimension arrays, we
    need to make some trick to access to the right cell instead of using the usual
    "[][]" operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化所有属性，但还创建网格内容和边框。因为网格内容和边框是一维数组，我们需要一些技巧来访问正确的单元格，而不是使用常规的 "[][]" 操作符。
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The draw method is not complex. For each cell, there is some data in it, we
    construct a rectangle of the right size at the right place, with the right color,
    and display it. And then we display the grid border.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图方法并不复杂。对于每个单元格，其中有一些数据，我们在正确的位置构造一个正确大小的矩形，用正确的颜色显示它，然后显示网格边框。
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This function simply sets the initial position of a piece on the board, and
    adds it to the grid. It also checks if the game is over or not, by the following
    code snippet:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地设置棋子在板上的初始位置，并将其添加到网格中。它还通过以下代码片段检查游戏是否结束：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This function is a bit more complicated, so let''s explain it step by step:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数稍微复杂一些，所以让我们一步一步地解释它：
- en: We will delete the `Piece` class from the board so that it doesn't collide with
    itself.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从板上删除 `Piece` 类，以防止它与自己碰撞。
- en: We will check if we can move the piece and set its new position if we can.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查是否可以移动棋子，并在可以的情况下设置其新位置。
- en: We will read the piece to the board
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将读取棋子到板上。
- en: 'The flood algorithm will be explained later:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水算法将在后面解释：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This functionality works as the previously mentioned function with just one
    exception. It only checks if the piece can move down and not in all directions,
    as shown in the previous code snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能与之前提到的功能类似，只有一个例外。它只检查棋子是否可以向下移动，而不是所有方向，如下面的代码片段所示：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This function is a special action that moves the piece as we can to the down.
    This is a special action in the Tetris game, called "Hard drop".
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个特殊动作，将棋子尽可能向下移动。这是俄罗斯方块游戏中的一个特殊动作，称为“硬降”。
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'These two functions rotate the piece to a specific direction. As there are
    only four different rotations (`NB_ROTATIONS`), we need to adjust the new rotation
    value using a circular check:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将棋子旋转到特定的方向。由于只有四种不同的旋转（`NB_ROTATIONS`），我们需要使用循环检查来调整新的旋转值：
- en: '[PRE68]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Like the other functions, this one checks whether we can rotate a piece or
    not, and return the value. This function does not change the content of the grid:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他函数一样，这个函数检查是否可以旋转棋子，并返回值。这个函数不会改变网格的内容：
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'These two functions are very close. Each one modifies the grid with a specific
    value, to set or remove a piece from the internal grid:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数非常相似。每个函数都使用特定值修改网格，以设置或从内部网格中移除一个棋子：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This `flood` function is an implementation of the `flood` algorithm. It allows
    us to fill the array with a value, depending of another array. The second array
    is the shape to fill in the first one. In our case, the first array is the grid,
    and the second the piece, as shown in the following code snippet:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `flood` 函数是 `flood` 算法的实现。它允许我们根据另一个数组填充数组中的值。第二个数组是要填充的第一个数组的形状。在我们的例子中，第一个数组是网格，第二个是棋子，如下面的代码片段所示：
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This function simply removes all the completed lines, and lowers all the upper
    lines to simulate gravity.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地移除所有完成的行，并将所有上方的行降低以模拟重力。
- en: Now, the `board` class is made, and we have all that we need to build the game.
    So let's do it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`board` 类已经创建，我们拥有了构建游戏所需的一切。所以，让我们开始吧。
- en: The Game class
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Game` 类'
- en: 'The `Game` class is very similar to the `Game` class from Asteroid. Its purpose
    is the same and all the internal logic is similar as well, as shown in the following
    code snippet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类与 Asteroid 中的 `Game` 类非常相似。它的目的是相同的，所有内部逻辑也相似，如下面的代码片段所示：'
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, we don't change the logic of the `Game` class, but we add it
    some private functions and attributes to correspond to the different kind of games.
    A window is still required, but we add the current piece reference, the board
    (that replaces the world), and a stats printer. We also need a way to store the
    next fall of a piece.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们没有改变 `Game` 类的逻辑，但添加了一些私有函数和属性来对应不同的游戏类型。仍然需要一个窗口，但我们添加了当前棋子引用、板（取代世界）和状态打印器。我们还需要一种方式来存储下一个棋子的落下。
- en: 'Now take a look at the implementation of this class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个类的实现：
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The constructor initializes the different attributes of the class, and sets
    the position of the different drawable object. It also creates the first piece
    to start the game. We don''t manage any menu here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化类的不同属性，并设置不同可绘制对象的位置。它还创建了第一块来开始游戏。在这里我们不管理任何菜单：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This function is not complicated but is interesting, because all the logic
    of the game is here. Let''s see this in the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并不复杂，但很有趣，因为所有游戏逻辑都在这里。让我们在以下步骤中看看：
- en: The first step is to clear lines and update the score.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是清除行并更新分数。
- en: Then, we will check whether we need to spawn another piece or not
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查是否需要生成另一个棋子。
- en: We will calculate the time needed by the current level to force a movement downward
    and apply it if necessary.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将计算当前级别需要的时间来强制向下移动，并在必要时应用它。
- en: 'Of course, if the game is over, we don''t do all this stuff, but tell the stats
    printer that the game is over:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，如果游戏结束了，我们就不做所有这些事情，而是告诉状态打印器游戏已经结束：
- en: '[PRE75]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here again, there is nothing new. We just draw all that can be drawn depending
    on the situation:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，同样没有什么新东西。我们只是根据情况画出所有能画的东西：
- en: '[PRE76]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This last function creates a piece at random, and adds it to the grid, which
    will set its default position.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个最后的函数会随机创建一个方块，并将其添加到网格中，这将设置其默认位置。
- en: And here we are. The game is finished!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们到了这里。游戏完成了！
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you surely noticed, there are some common points with the previous game we
    made, but not a lot. The main idea of showing you this game, is that there is
    no "super technique" that will work in every kind of game. You have to adapt your
    internal architecture and logic depending on the kind of game you want to build.
    I hope you understand that.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如你肯定注意到的，与之前我们制作的那个游戏有一些共同点，但并不多。展示这个游戏的主要想法是，没有一种“超级技巧”能在所有类型的游戏中都有效。你必须根据你想要构建的游戏类型来调整你的内部架构和逻辑。我希望你能理解这一点。
- en: In the next chapter, you will learn how to use a physics engine, and add it
    in the Tetris game to build a new kind of game.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习如何使用物理引擎，并将其添加到俄罗斯方块游戏中，以构建一种新的游戏。
