- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Linking Executables and Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接可执行文件和库
- en: You might assume that once we’ve successfully compiled the source code into
    a binary file, our role as build engineers is complete. However, that’s not entirely
    true. While binary files do contain all the necessary code for a CPU to execute,
    this code can be distributed across multiple files in a complex manner. We wouldn’t
    want the CPU to scour different files searching for individual code snippets.
    Instead, our goal is to consolidate these separate units into a single file. To
    achieve this, we use a process known as linking.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，一旦我们成功地将源代码编译成二进制文件，我们作为构建工程师的角色就完成了。然而，事实并非完全如此。尽管二进制文件确实包含了CPU执行所需的所有代码，但这些代码可能会以复杂的方式分布在多个文件中。我们不希望CPU在不同的文件中寻找单独的代码片段。相反，我们的目标是将这些分散的单元合并为一个文件。为了实现这一目标，我们使用了一个称为链接的过程。
- en: 'A quick look shows that CMake has few linking commands, with `target_link_libraries()`
    being the main one. Why dedicate a whole chapter to a single command then? Unfortunately,
    almost nothing is ever easy in computer science, and linking is no exception:
    to get the right results, we need to understand the whole story – we need to know
    how exactly a linker works and get the basics right. We’ll talk about the internal
    structure of object files, how the relocation and reference resolution mechanisms
    work, and what are they for. We’ll discuss how the final executable differs from
    its components and how the process image is constructed by the system when loading
    the program into memory.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 快速观察可以发现，CMake有很少的链接命令，其中`target_link_libraries()`是主要命令。那么，为什么要专门用一整章来讲解这个命令呢？不幸的是，计算机科学几乎没有什么事情是简单的，链接也不例外：为了获得正确的结果，我们需要了解整个过程——我们需要知道链接器是如何工作的，并掌握基本知识。我们将讨论目标文件的内部结构，重定位和引用解析机制的工作原理，以及它们的用途。我们还会讨论最终的可执行文件与其组成部分之间的区别，以及在将程序加载到内存时，系统如何构建进程镜像。
- en: 'Then, we’ll introduce all kinds of libraries to you: static, shared, and shared
    modules. Even though they’re all called “libraries,” they’re quite different.
    Creating a well-linked executable relies on having the right configuration and
    addressing specific details like **position-independent code** (**PIC**).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍各种类型的库：静态库、共享库和共享模块。尽管它们都叫做“库”，但实际上差异很大。创建一个正确链接的可执行文件依赖于正确的配置，并处理一些具体的细节，例如**位置无关代码**（**PIC**）。
- en: We’ll learn about another nuisance of linking – the **One Definition Rule**
    (**ODR**). It’s crucial to have the exact number of definitions. Managing duplicate
    symbols can be particularly challenging, especially with shared libraries. Additionally,
    we’ll explore why linkers occasionally fail to locate external symbols, even if
    the executable is correctly linked to the relevant library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习链接中的另一个麻烦——**唯一定义规则**（**ODR**）。确保定义的数量是准确的至关重要。管理重复符号特别具有挑战性，尤其是对于共享库。此外，我们还将探讨为什么链接器有时无法找到外部符号，即使可执行文件已正确链接到相关库。
- en: Finally, we’ll discover how to use a linker efficiently, preparing our solution
    for testing within specific frameworks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将了解如何高效地使用链接器，为在特定框架中进行测试准备我们的解决方案。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Getting the basics of linking right
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确理解链接的基础
- en: Building different library types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建不同类型的库
- en: Solving problems with the ODR
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决ODR问题
- en: The order of linking and unresolved symbols
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接顺序和未解析符号
- en: Separating `main()` for testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`main()`分离用于测试
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch08](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch08).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中提到的代码文件，链接地址为：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch08](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch08)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path in which your source code is located.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`<build tree>`和`<source tree>`占位符替换为合适的路径。提醒一下：**build tree**是目标/输出目录的路径，**source
    tree**是源代码所在的路径。
- en: Getting the basics of linking right
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确理解链接的基础
- en: We discussed the life cycle of a C++ program in *Chapter 7*, *Compiling C++
    Sources with CMake*. It consists of five main stages – writing, compiling, linking,
    loading, and execution. After correctly compiling all the sources, we need to
    put them together into an executable. We said that object files produced in a
    compilation can’t be executed by a processor directly. But why?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第7章*《使用 CMake 编译 C++ 源代码》中讨论了 C++ 程序的生命周期。它由五个主要阶段组成——编写、编译、链接、加载和执行。在正确编译所有源代码之后，我们需要将它们组合成一个可执行文件。我们曾提到过，编译过程中生成的目标文件不能被处理器直接执行。那么，为什么呢？
- en: 'To answer this, let’s understand that object files are a variant of the widely-used
    **Executable and Linkable Format** (**ELF**), common in Unix-like systems and
    many others. Systems like Windows or macOS have their own formats, but we’ll focus
    on ELF to explain the principle. *Figure 8.1* shows how a compiler structures
    these files:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们需要理解目标文件是广泛使用的**可执行和可链接格式**（**ELF**）的一种变体，该格式在类似 Unix 的系统以及许多其他系统中都很常见。像
    Windows 或 macOS 这样的系统有自己的格式，但我们将重点讲解 ELF 格式，以便解释其原理。*图 8.1* 展示了编译器如何构建这些文件：
- en: '![](img/B19844_08_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_08_01.png)'
- en: 'Figure 8.1: The structure of an object file'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：目标文件的结构
- en: 'The compiler will prepare an object file for every unit of translation (for
    every `.cpp` file). These files will be used to build an in-memory image of our
    program. Object files consist of:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会为每个翻译单元（每个 `.cpp` 文件）准备一个目标文件。这些文件将用于构建我们程序的内存映像。目标文件由以下内容组成：
- en: 'An **ELF Header**, which identifies the target **operating system** (**OS**),
    file type, target instruction set architecture, and details on the position and
    size of two header tables found in ELF files: the **Program Headers** table (which
    isn’t present in object files) and the **Section Headers** table.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**ELF 头**，用于标识目标**操作系统**（**OS**）、文件类型、目标指令集架构，以及有关 ELF 文件中两个头表的位置和大小的详细信息：**程序头**表（在目标文件中不存在）和**区段头**表。
- en: Binary sections that group information by type.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按类型分组信息的二进制区段。
- en: A **Section Headers** table, containing information about the name, the type,
    flags, the destination address in memory, the offset in the file, and other miscellaneous
    information. It is used to understand what sections are in this file and where
    they are, just like a table of contents.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**区段头**表，包含有关名称、类型、标志、内存中的目标地址、文件中的偏移量以及其他杂项信息。它用于了解文件中有哪些区段以及它们的位置，类似于目录。
- en: 'When the compiler works through your source code, it categorizes the gathered
    information into distinct sections. These sections form the core of the ELF file,
    positioned between the **ELF Header** and the **Section Headers**. Here are some
    examples of such sections:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器处理你的源代码时，它将收集的信息按不同区段分类。这些区段构成了 ELF 文件的核心，位于**ELF 头**和**区段头**之间。以下是一些这样的区段示例：
- en: The `.text` section contains machine code with all the instructions designated
    for processor execution.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text` 区段包含机器代码，包含所有指定给处理器执行的指令。'
- en: The `.data` section holds values for initialized global and static variables.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data` 区段保存初始化的全局变量和静态变量的值。'
- en: The `.bss` section reserves space for uninitialized global and static variables,
    which get initialized to zero at the program’s start.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss` 区段为未初始化的全局变量和静态变量保留空间，这些变量在程序启动时会被初始化为零。'
- en: The `.rodata` section keeps values of constants, making it a read-only data
    segment.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata` 区段保存常量的值，使其成为只读数据段。'
- en: The `.strtab` section is a string table containing constant strings, like “Hello
    World” from a basic `hello.cpp` example.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.strtab` 区段是一个字符串表，包含常量字符串，例如从基础的 `hello.cpp` 示例中提取的“Hello World”。'
- en: The `.shstrtab` section is a string table holding the names of all other sections.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shstrtab` 区段是一个字符串表，保存所有其他区段的名称。'
- en: These sections closely mirror the final version of the executable that gets
    placed into RAM to run our application. Yet, we can’t simply concatenate object
    files together and load the resulting file into the memory. Merging without caution
    would lead to a host of complications. For one, we’d squander both space and time,
    consuming excessive RAM pages. Transferring instructions and data to the CPU cache
    would also become cumbersome. The entire system would have to deal with increased
    complexity, burning precious cycles, and jumping between countless `.text`, `.data`,
    and other sections during execution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分与最终的可执行文件版本非常相似，该文件将被加载到内存中运行我们的应用程序。然而，我们不能仅仅将目标文件连接起来并将结果文件加载到内存中。没有谨慎处理的合并会导致一系列复杂的问题。首先，我们会浪费空间和时间，消耗过多的
    RAM 页。将指令和数据传输到 CPU 缓存也会变得繁琐。整个系统不得不处理更高的复杂性，浪费宝贵的周期，并且在执行过程中在无数的 `.text`、`.data`
    和其他部分之间跳跃。
- en: 'We’ll take a more organized approach: each section of an object file will be
    grouped with sections of the same type as other object files. This procedure is
    called **relocation**, which is why the ELF file type for object files is labeled
    as “Relocatable.” But relocation is more than just assembling matching sections.
    It also involves updating internal references in the file, such as addresses of
    variables, functions, symbol table indices, and string table indices. Each of
    these values is local to its own object file and starts numbering from zero. So,
    when merging files, it’s imperative to adjust these values to ensure they reference
    the right addresses in the consolidated file.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用更有组织的方法：每个目标文件的各个部分将与其他目标文件中相同类型的部分分组。这个过程叫做**重定位**，这也是目标文件的 ELF 文件类型被标记为“可重定位”的原因。但是重定位不仅仅是将匹配的部分组合在一起。它还涉及更新文件中的内部引用，例如变量地址、函数地址、符号表索引和字符串表索引。这些值在各自的目标文件中是局部的，并且从零开始编号。因此，在合并文件时，必须调整这些值，以确保它们引用合并后的文件中的正确地址。
- en: '*Figure 8.2* shows relocation in action – the `.text` section is already relocated,
    the `.data` is being assembled from all linked files, and the `.rodata` and `.strtab`
    sections will follow the same process (for simplicity, the figure doesn’t contain
    headers):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.2* 展示了重定位的过程 —— `.text` 部分已经被重定位，`.data` 部分正在从所有链接的文件中组装，而 `.rodata` 和
    `.strtab` 部分将遵循相同的过程（为了简便，图中没有包含头部）：'
- en: '![](img/B19844_08_02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_08_02.png)'
- en: 'Figure 8.2: The relocation of the .data section'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：.data 部分的重定位
- en: 'Next, the linker needs to resolve references. When code from one translation
    unit refers to a symbol defined in another, whether by including its header or
    using the `extern` keyword, the compiler acknowledges the declaration, assuming
    the definition will be provided later. The linker’s role is mainly to gather these
    unresolved external symbol references, and then identify and populate the addresses
    where they belong in the consolidated executable. *Figure 8.3* shows a simple
    example of this reference resolution process:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，链接器需要解析引用。当一个翻译单元中的代码引用了另一个翻译单元中定义的符号时，无论是通过包含其头文件还是使用 `extern` 关键字，编译器都会确认声明，假设定义将在稍后提供。链接器的主要作用是收集这些未解决的外部符号引用，然后识别并填充它们在合并后的可执行文件中的正确地址。*图
    8.3* 显示了该引用解析过程的一个简单示例：
- en: '![](img/B19844_08_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_08_03.png)'
- en: 'Figure 8.3: A reference resolution'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：引用解析
- en: 'This part of the linking can be a source of problems if a programmer is unaware
    of how it works. We may end up with unresolved references that can’t locate their
    corresponding external symbols. Or, the opposite: we have provided too many definitions
    and the linker doesn’t know which one to choose.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员不了解其工作原理，链接过程中的这一部分可能会成为问题的根源。我们可能会遇到无法找到对应外部符号的未解决引用，或者相反，提供了过多的定义，链接器不知道该选择哪个。
- en: 'The final executable file looks very similar to the object file, as it contains
    relocated sections with resolved references, a **Section Headers** table, and
    of course, the **ELF Header** describing the whole file. The main difference is
    the presence of the **Program Header** depicted in the following figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的可执行文件与目标文件非常相似，因为它包含了已重定位的部分和已解析的引用、**段头表**以及当然描述整个文件的**ELF 头**。主要的区别是存在一个**程序头**，如下图所示：
- en: '![](img/B19844_08_04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_08_04.png)'
- en: 'Figure 8.4: The structure of the executable file in ELF'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：ELF 中可执行文件的结构
- en: The **Program Header** is located right after the **ELF Header**. The OS’s **loader**
    will read this **Program Header** to set up the program, configure the memory
    layout, and create a process image. Entries in the **Program Header** specify
    which sections will be copied, in what order, and to which addresses in the virtual
    memory. They also contain information about their access control flags (read,
    write, or execute), and a few other useful details. Each named section will be
    represented by one fragment of memory in the created process; such a fragment
    is called a **segment**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序头**位于**ELF头**之后。操作系统的**加载器**将读取这个**程序头**，以便设置程序、配置内存布局并创建进程映像。**程序头**中的条目指定哪些部分会被复制、复制的顺序，以及在虚拟内存中的地址。它们还包含有关访问控制标志（读、写或执行）以及其他一些有用信息。每个命名的部分将在创建的进程中由一块内存表示；这种内存块称为**段**。'
- en: Object files may also be bundled in a library, which is an intermediate product
    that can be used in a final executable or another library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件也可以被捆绑到库中，这是一种中间产品，可以在最终的可执行文件或其他库中使用。
- en: Now that we understand how linking works in principle, let’s move on to the
    next section, where we’ll discuss three different types of libraries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了链接的原理，接下来让我们进入下一部分，讨论三种不同类型的库。
- en: Building different library types
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建不同类型的库
- en: After compiling the source code, it’s often desirable to sidestep recompilation
    for the same platform or even share the compiled output with external projects.
    One could distribute the individual object files as initially produced, but this
    comes with challenges. Distributing multiple files and integrating them one by
    one into a buildsystem can be a hassle, particularly when dealing with a large
    number. A more efficient approach is to consolidate all object files into a singular
    unit for sharing. CMake significantly simplifies this task. We can generate these
    libraries with a simple `add_library()` command (paired with the `target_link_libraries()`
    command).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译源代码之后，通常希望避免在相同平台上重新编译，或者甚至将编译结果与外部项目共享。虽然可以分发最初生成的单个目标文件，但这会带来一些挑战。分发多个文件并逐个将它们集成到构建系统中可能会很麻烦，尤其是在处理大量文件时。一种更高效的方法是将所有目标文件合并为一个单独的单元进行共享。CMake
    可以大大简化这一任务。我们可以通过简单的 `add_library()` 命令（配合 `target_link_libraries()` 命令）来生成这些库。
- en: 'By convention, all the libraries have a common prefix, `lib`, and use system-specific
    extensions that denote what kind of library they are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，所有库都有一个共同的前缀 `lib`，并使用系统特定的扩展名来表示它们是哪种类型的库：
- en: A static library has a `.a` extension on Unix-like systems and `.lib` on Windows.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态库在类 Unix 系统上具有 `.a` 扩展名，在 Windows 上则是 `.lib`。
- en: Shared libraries (and modules) have a `.so` extension on some Unix-like systems
    (like Linux) and `.dylib` on others (macOS). On Windows, their extension is `.dll`
    .
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库（和模块）在某些类 Unix 系统（如 Linux）上具有 `.so` 扩展名，在其他系统（如 macOS）上则是 `.dylib`。在 Windows
    上，它们的扩展名是 `.dll`。
- en: Shared modules usually use the same extensions as shared libraries, but not
    always. On macOS, they can use `.so`, especially when the module is ported from
    another Unix platform.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享模块通常与共享库使用相同的扩展名，但并非总是如此。在 macOS 上，它们可以使用 `.so`，特别是当模块是从另一个 Unix 平台移植过来时。
- en: 'The process of building libraries (static, shared, or shared modules) is by
    convention called “linking,” as can be seen in the build output of the `ch08/01-libraries`
    project:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 构建库（静态库、共享库或共享模块）的过程通常被称为“链接”，如在 `ch08/01-libraries` 项目的构建输出中所见：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, not all of the preceding libraries necessarily use a linker for their
    creation. The process might skip certain steps like relocation and reference resolution
    for some libraries.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有前述的库在创建时都一定会使用链接器。某些库的创建过程可能会跳过像重定位和引用解析等步骤。
- en: Let’s delve into each library type to understand their respective workings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每种库类型，以理解它们各自的工作原理。
- en: Static libraries
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态库
- en: Static libraries are essentially a collection of raw object files stored in
    an archive. Sometimes, they’re extended with an index to speed up linking the
    process. On Unix-like systems, such archives can be created by the `ar` tool,
    and indexed with `ranlib`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库本质上是存储在归档文件中的原始目标文件集合。有时，它们会通过索引来加速链接过程。在类 Unix 系统上，可以使用 `ar` 工具创建这种归档文件，并通过
    `ranlib` 进行索引。
- en: During the build process, only necessary symbols from the static library are
    imported into the final executable, optimizing its size and memory usage. This
    selective integration ensures the executable is self-contained, eliminating the
    need for external files at runtime.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，仅将静态库中必要的符号导入到最终的可执行文件中，从而优化其大小和内存使用。这种选择性整合确保了可执行文件是自包含的，运行时不需要外部文件。
- en: 'To create a static library, we can simply use the command that we have already
    seen in the previous chapters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建静态库，我们可以简单地使用我们在前几章中已经看到的命令：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This short-hand code will produce a static library by default. This can be
    overridden by setting the `BUILD_SHARED_LIBS` variable to `ON`. If we want to
    build a static library regardless, we can provide an explicit keyword:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简写代码默认会生成一个静态库。通过将`BUILD_SHARED_LIBS`变量设置为`ON`，可以覆盖这一行为。如果我们无论如何都想构建一个静态库，可以提供一个明确的关键字：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Utilizing static libraries might not always be an ideal option, especially when
    we aim to share compiled code among multiple applications running on the same
    machine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态库可能并不总是理想的选择，特别是当我们希望在同一台机器上共享多个应用程序编译后的代码时。
- en: Shared libraries
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库
- en: Shared libraries differ significantly from static libraries. They are constructed
    using a linker, which completes both stages of linking. This results in a file
    complete with section headers, sections, and a section header table, as illustrated
    in *Figure 8.1*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库与静态库有显著不同。它们是使用链接器构建的，链接器完成了链接的两个阶段。这会生成一个完整的文件，包含节头、节以及节头表，如*图 8.1*所示。
- en: Shared libraries, often referred to as shared objects, can be utilized across
    multiple distinct applications simultaneously. When the first program uses a shared
    library, the OS loads one instance of it into the memory. Subsequent programs
    are then provided with the same address by the OS, courtesy of intricate virtual
    memory mechanisms. However, for every process that uses the library, the `.data`
    and `.bss` segments of the library are instantiated separately. This ensures that
    each process can adjust its variables without influencing other processes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库，通常被称为共享对象，可以在多个不同的应用程序之间同时使用。当第一个程序使用共享库时，操作系统将该库的一个实例加载到内存中。随后的程序将由操作系统提供相同的地址，得益于复杂的虚拟内存机制。然而，对于每个使用该库的进程，库的`.data`和`.bss`段会被单独实例化。这确保了每个进程可以调整其变量，而不影响其他进程。
- en: Thanks to this approach, the overall memory usage in the system is optimized.
    If we’re using a widely recognized library, it might not be necessary to include
    it with our program, as it’s likely already available on the target machine. However,
    if it’s not pre-installed, users are expected to manually install it before running
    the application. This can lead to potential issues if the installed version of
    a library differs from what’s expected. Such problems are referred to as “dependency
    hell.” More details can be found in the *Further reading* section of this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于这种方法，系统的整体内存使用得到了优化。如果我们使用的是一个广泛认可的库，可能无需将其与程序一起包含，因为它很可能已经在目标机器上可用。然而，如果该库没有预先安装，用户需要在运行应用程序之前手动安装它。如果安装的库版本与预期不符，可能会导致潜在问题。这种问题被称为“依赖地狱”。更多详情请参见本章的*进一步阅读*部分。
- en: 'We can build shared libraries by explicitly using the `SHARED` keyword:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过明确使用`SHARED`关键字来构建共享库：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since shared libraries are loaded during the program initialization, there’s
    no association between the executing program and the actual library file on disk.
    Instead, the linking is done indirectly. In Unix-like systems, this is achieved
    through a **shared object name** (**SONAME**), which can be understood as the
    “logical name” of the library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于共享库在程序初始化期间被加载，因此执行程序与磁盘上的实际库文件之间没有直接关联。相反，链接是间接完成的。在类Unix系统中，这是通过**共享对象名称**（**SONAME**）实现的，它可以理解为库的“逻辑名称”。
- en: This allows flexibility in library versioning and ensures that backward-compatible
    changes to libraries don’t immediately break dependent applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这为库版本控制提供了灵活性，并确保对库的向后兼容性更改不会立即破坏依赖的应用程序。
- en: 'We can query some path properties of the produced SONAME file with generator
    expressions (be sure to replace `target` with the name of your target):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器表达式查询生成的SONAME文件的一些路径属性（确保将`target`替换为目标的名称）：
- en: '`$<TARGET_SONAME_FILE:target>` returns the full path (`.so.3`).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE:target>`返回完整路径（`.so.3`）。'
- en: '`$<TARGET_SONAME_FILE_NAME:target>` returns only the filename.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE_NAME:target>` 仅返回文件名。'
- en: '`$<TARGET_SONAME_FILE_DIR:target>` returns the directory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE_DIR:target>` 返回目录。'
- en: 'These come in handy in more advanced scenarios that we’ll cover later in the
    book, including:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在更高级的场景中非常有用，我们将在本书稍后部分讨论，包括：
- en: Correct usage of the generated library during packaging and installation.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在打包和安装过程中正确使用生成的库。
- en: Writing custom CMake rules for dependency management.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为依赖管理编写自定义 CMake 规则。
- en: Utilizing SONAME during testing.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试过程中使用 SONAME。
- en: Copying or renaming produced libraries in post-build commands.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建后命令中复制或重命名生成的库。
- en: 'You may have similar needs for other OS-specific artifacts; for that purpose,
    CMake offers two families of generator expressions that offer the same suffixes
    as SONAME. For Windows, we have:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对其他特定于操作系统的构件有类似需求；为此，CMake 提供了两种生成器表达式，它们提供与 SONAME 相同的后缀。对于 Windows，我们有：
- en: '`$<TARGET_LINKER_FILE:target>` returns the full path to the `.lib` import library
    associated with the produced **dynamic-link library** (**DLL**). Note that the`.lib`
    extension is the same as for the static Windows library, but their application
    is not the same.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_LINKER_FILE:target>` 返回与生成的 **动态链接库** (**DLL**) 相关联的 `.lib` 导入库的完整路径。请注意，`.lib`
    扩展名与静态 Windows 库相同，但它们的应用不同。'
- en: '`$<TARGET_RUNTIME_DLLS:target>` returns a list of DLLs that the target depends
    on at runtime.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_RUNTIME_DLLS:target>` 返回目标在运行时所依赖的 DLL 列表。'
- en: '`$<TARGET_PDB_FILE:target>` returns the full path to the `.pdb` program database
    file (used for debugging purposes).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_PDB_FILE:target>` 返回 `.pdb` 程序数据库文件的完整路径（用于调试目的）。'
- en: Since shared libraries are loaded into the OS’s memory during the initialization
    of the program, they are applicable when knowing upfront which libraries the program
    will use. What about the scenarios where this needs to be determined during the
    runtime?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于共享库在程序初始化时加载到操作系统内存中，因此当知道程序将使用哪些库时它们是适用的。那么在运行时需要确定的场景怎么办呢？
- en: Shared modules
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享模块
- en: 'A shared module, or module library, is a variant of a shared library designed
    to be used as a plugin loaded during runtime. Unlike standard shared libraries,
    which load automatically when a program starts, a shared module only loads when
    the program explicitly requests it. This can be done through the system calls:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 共享模块或模块库是共享库的变种，旨在作为插件在运行时加载。与标准共享库不同，标准共享库在程序启动时自动加载，而共享模块仅在程序明确请求时才会加载。这可以通过系统调用完成：
- en: '`LoadLibrary` on Windows'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 上的 `LoadLibrary`
- en: '`dlopen()` followed by `dlsym()` on Linux and macOS'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 Linux 和 macOS 上使用 `dlopen()` 后跟 `dlsym()` '
- en: The primary reason for this approach is memory conservation. Many software applications
    have advanced features that aren’t utilized throughout the life cycle of every
    process. Loading such features into memory every time would be inefficient.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要原因是内存节省。许多软件应用程序具有生命周期内并不总是使用的高级功能。每次将此类功能加载到内存中将会非常低效。
- en: Alternatively, we might want to provide an avenue for extending the main program
    with specialized features that can be sold, delivered, and loaded separately.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可能希望为主程序提供一个扩展的途径，能够销售、交付并单独加载具有专门功能的部分。
- en: 'To build shared modules, we need to use the `MODULE` keyword:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建共享模块，我们需要使用 `MODULE` 关键字：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You shouldn’t attempt to link your executable with a module, as the module is
    designed to be deployed separately from the executable that will utilize it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该尝试将可执行文件与模块链接，因为该模块旨在与可执行文件分开部署，后者将使用该模块。
- en: Position-independent code (PIC)
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与位置无关的代码（PIC）
- en: Programs today are inherently somewhat position-independent because of the use
    of virtual memory. This technology abstracts physical addresses. When calling
    a function, the CPU uses the **memory management unit** (**MMU**) to translate
    a virtual address (starting from 0 for every process) to the corresponding physical
    address (determined at the time of allocation). Interestingly, these mappings
    don’t always follow a specific order.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟内存的使用，今天的程序本质上是某种程度的与位置无关的。这项技术抽象了物理地址。当调用一个函数时，CPU 使用 **内存管理单元** (**MMU**)
    将虚拟地址（每个进程从 0 开始）转换为相应的物理地址（在分配时确定）。有趣的是，这些映射不总是遵循特定的顺序。
- en: 'Compiling a library introduces uncertainty: it’s unclear which processes might
    use the library or where it will be located in virtual memory. We also can’t predict
    the addresses of the symbols or their locations relative to the library’s machine
    code. To handle this, we need another level of indirection.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编译一个库会带来不确定性：我们无法确定哪些进程可能会使用这个库，或者它将位于虚拟内存的哪个位置。我们也无法预测符号的地址或它们相对于库的机器代码的位置。为了解决这个问题，我们需要另一个间接层。
- en: '**PIC** was introduced to map symbols (like references to functions and global
    variables) to their runtime addresses. PIC introduces a new section to the binary
    file: the **Global Offset Table** (**GOT**). During the linking, the relative
    position of the GOT section to the `.text` section (the program code) is calculated.
    All symbol references will be pointed through an offset to a placeholder in the
    GOT.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**PIC**的引入是为了将符号（如函数和全局变量的引用）映射到它们的运行时地址。PIC为二进制文件引入了一个新的部分：**全局偏移表**（**GOT**）。在链接过程中，GOT部分相对于`.text`部分（程序代码）的相对位置会被计算出来。所有的符号引用将通过一个偏移量指向GOT中的占位符。'
- en: When the program is loaded, the GOT section transforms into a memory segment.
    Over time, this segment accumulates the runtime addresses of the symbols. This
    method, termed “lazy loading,” ensures that the loader populates specific GOT
    entries only when required.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序加载时，GOT（全局偏移表）部分会转变为一个内存段。随着时间的推移，这个段会积累符号的运行时地址。这种方法被称为“懒加载”，它确保加载器仅在需要时填充特定的GOT条目。
- en: All sources for shared libraries and modules must be compiled with a PIC flag
    activated. By setting the `POSITION_INDEPENDENT_CODE` target property to `ON`,
    we’ll tell CMake to appropriately add compiler-specific flags such as `-fPIC`
    for GCC or Clang.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有共享库和模块的源代码必须在编译时启用PIC标志。通过将`POSITION_INDEPENDENT_CODE`目标属性设置为`ON`，我们会告诉CMake适当添加编译器特定的标志，例如GCC或Clang的`-fPIC`。
- en: 'This property is automatically enabled for shared libraries. However, if a
    shared library depends on another target, such as a static or object library,
    you must also apply this property to the dependent target:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享库，这个属性是自动启用的。然而，如果一个共享库依赖于另一个目标，例如静态库或对象库，你还必须将这个属性应用于依赖的目标：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Overlooking this step will cause conflicts in CMake, since it checks this property
    for inconsistencies. You can find a more thorough exploration of this in the *Dealing
    with conflicting propagated properties* section of *Chapter 5*, *Working with
    Targets*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 忽视这一步骤会导致CMake中的冲突，因为它会检查这个属性是否存在不一致。你可以在*第5章，*处理目标*部分的*处理冲突的传播属性*小节中找到更深入的讨论。
- en: Our next discussion point pivots to symbols. Specifically, the subsequent section
    will explore the challenges of name collisions, which can lead to ambiguity and
    definition inconsistencies.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的讨论重点是符号。具体来说，接下来的部分将探讨命名冲突的挑战，这可能导致歧义和定义不一致。
- en: Solving problems with the ODR
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决ODR问题
- en: 'Phil Karlton, Netscape’s principal curmudgeon and tech visionary, was right
    when he said the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape的首席固执者兼技术远见者Phil Karlton曾说过一句话，他说的对：
- en: '”There are two hard things in computer science: cache invalidation and naming
    things.”'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “计算机科学中有两件困难的事情：缓存失效和命名事物。”
- en: 'Names are difficult for several reasons. They must be precise yet simple, brief
    yet expressive. This not only gives them meaning but also enables programmers
    to grasp the concepts underlying the raw implementation. C++ and many other languages
    add another stipulation: most names must be unique.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 名称之所以困难，原因有很多。它们必须既精确又简单，简短又富有表现力。这不仅赋予了它们意义，而且使程序员能够理解原始实现背后的概念。C++和许多其他语言增加了另一个要求：大多数名称必须是唯一的。
- en: 'This requirement manifests in the form of the ODR: within the scope of a single
    translation unit (a single `.cpp` file), you are required to define a symbol exactly
    once, even if the same name (whether for a variable, function, class type, enumeration,
    concept, or template) is declared multiple times. To clarify, “declaring” introduces
    the symbol, while “defining” provides all its details, such as a value for a variable
    or a body for a function.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求表现为ODR（单一定义规则）：在一个单独的翻译单元（一个`.cpp`文件）的范围内，你必须准确地定义一个符号一次，即使相同的名称（无论是变量、函数、类类型、枚举、概念还是模板）被多次声明。为了澄清，“声明”引入了符号，而“定义”提供了符号的所有细节，比如变量的值或函数的主体。
- en: 'During linking, this rule is extended to the entire program, covering all non-inlined
    functions and variables you effectively use in your code. Consider the following
    example comprising three source files:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接过程中，这条规则会扩展到整个程序，涵盖你在代码中有效使用的所有非内联函数和变量。考虑以下包含三个源文件的示例：
- en: '**ch08/02-odr-fail/shared.h**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/02-odr-fail/shared.h**'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**ch08/02-odr-fail/one.cpp**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/02-odr-fail/one.cpp**'
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**ch08/02-odr-fail/two.cpp**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/02-odr-fail/two.cpp**'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It also comprises a listfile:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含一个列表文件：
- en: '**ch08/02-odr-fail/CMakeLists.txt**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/02-odr-fail/CMakeLists.txt**'
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the example is very simple – we created a `shared.h` header
    file defining the `i` variable, which is used in two separate translation units:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，示例非常简单——我们创建了一个 `shared.h` 头文件，定义了 `i` 变量，该变量在两个不同的翻译单元中使用：
- en: '`one.cpp` simply printing `i` to the screen'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`one.cpp` 仅将 `i` 打印到屏幕'
- en: '`two.cpp` only including the header'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`two.cpp` 仅包含头文件'
- en: 'But when we try to build the example, the linker produces the following error:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们尝试构建示例时，链接器会产生以下错误：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Symbols cannot be defined more than once. Yet, there’s a significant exception.
    Types, templates, and `extern` inline functions can have repeated definitions
    across multiple translation units, but only if these definitions are identical
    (meaning they have the exact same sequence of tokens).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 符号不能定义多次。然而，有一个重要的例外。类型、模板和 `extern` 内联函数可以在多个翻译单元中重复定义，但前提是这些定义完全相同（即它们具有完全相同的令牌序列）。
- en: 'To demonstrate this, let’s replace the definition of a variable with a definition
    of a type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们将变量的定义替换为类型的定义：
- en: '**ch08/03-odr-success/shared.h**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/03-odr-success/shared.h**'
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we use it like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按以下方式使用它：
- en: '**ch08/03-odr-success/one.cpp**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/03-odr-success/one.cpp**'
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The other two files, `two.cpp` and `CMakeLists.txt`, remain the same as in
    the `02-odr-fail` example. Such a change will allow the linking to succeed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个文件，`two.cpp` 和 `CMakeLists.txt`，与 `02-odr-fail` 示例中的保持一致。这样的变化将允许链接成功：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, we can mark the variable as local to a translation unit (it
    won’t be exported outside of the object file). To do so, we’ll use the `static`
    keyword (this keyword is context specific, so don’t confuse it with `static` keyword
    in classes), like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以将变量标记为仅对某个翻译单元局部（它不会被导出到目标文件之外）。为此，我们将使用 `static` 关键字（该关键字是特定上下文的，因此不要将其与类中的
    `static` 关键字混淆），如下所示：
- en: '**ch08/04-odr-success/shared.h**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/04-odr-success/shared.h**'
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you try linking this example, you will see it works, which implies that the
    static variables are stored separately for each translation unit. Therefore, modifications
    to one will not impact the other.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试链接这个示例，你会发现它有效，这意味着静态变量为每个翻译单元单独存储。因此，对一个的修改不会影响另一个。
- en: The ODR rule works exactly the same for static libraries as it does for object
    files, but things aren’t so clear when we build our code with shared libraries
    – let’s take a look.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ODR 规则对于静态库和目标文件的作用完全相同，但当我们使用共享库构建代码时，情况就不那么清晰了——我们来看一下。
- en: Sorting out dynamically linked duplicated symbols
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序动态链接的重复符号
- en: 'The linker will allow duplicated symbols here. In the following example, we’ll
    create two shared libraries, `A` and `B`, with one `duplicated()` function and
    two unique `a()` and `b()` functions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器将允许此处的重复符号。在以下示例中，我们将创建两个共享库 `A` 和 `B`，其中包含一个 `duplicated()` 函数和两个唯一的 `a()`
    和 `b()` 函数：
- en: '**ch08/05-dynamic/a.cpp**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/05-dynamic/a.cpp**'
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second implementation file is almost an exact copy of the first:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个实现文件几乎与第一个完全相同：
- en: '**ch08/05-dynamic/b.cpp**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/05-dynamic/b.cpp**'
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s use each function to see what happens (we’ll declare them locally
    with `extern` for simplicity):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用每个函数来看看会发生什么（为了简化，我们将它们声明为 `extern`）：
- en: '**ch08/05-dynamic/main.cpp**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/05-dynamic/main.cpp**'
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code will run unique functions from each library and then call
    a function defined with the same signature in both dynamic libraries. What do
    you think will happen? Would the linking order matter in this case? Let’s test
    it for two cases:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将运行每个库中的唯一函数，然后调用在两个动态库中定义的具有相同签名的函数。你认为会发生什么？在这种情况下，链接顺序会有影响吗？让我们分别测试两种情况：
- en: '`main_1` target will be linked with the `a` library first'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_1` 目标将首先与 `a` 库链接'
- en: '`main_2` target will be linked with the `b` library first'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_2` 目标将首先与 `b` 库链接'
- en: 'The listfile looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表文件如下所示：
- en: '**ch08/05-dynamic/CMakeLists.txt**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/05-dynamic/CMakeLists.txt**'
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After building and running both executables, we’ll see the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行这两个可执行文件后，我们将看到以下输出：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Aha! Clearly, the order in which the libraries are linked matters to the linker.
    This can lead to confusion if we aren’t vigilant. Contrary to what one might think,
    naming collisions are not that uncommon in practice.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！显然，库的链接顺序对链接器非常重要。如果我们不小心，这可能会导致混淆。与人们的想法相反，命名冲突在实践中并不罕见。
- en: If we define locally visible symbols, they will take precedence over those available
    from DLLs. Defining the `duplicated()` function in `main.cpp` will override the
    behavior of both targets.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义了本地可见的符号，它们将优先于DLL中的符号。如果在`main.cpp`中定义了`duplicated()`函数，它将覆盖两个目标的行为。
- en: Always take great care when exporting names from libraries, as you’re bound
    to encounter name collisions sooner or later.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在从库中导出名称时一定要小心，因为你迟早会遇到命名冲突。
- en: Use namespaces – don’t count on the linker
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间——不要依赖链接器
- en: '**C++ namespaces** were invented to avoid such weird problems and deal with
    the ODR more effectively. The best practice is to wrap your library code in a
    namespace named after the library. This tactic helps to prevent the complications
    arising from duplicated symbols.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++命名空间**的发明是为了避免这种奇怪的问题，并更有效地处理ODR。最佳做法是将你的库代码封装在一个以库名命名的命名空间中。这种策略有助于防止因重复符号而引发的复杂问题。'
- en: In our projects we might come across cases where one shared library links to
    another, forming a long chain. Such situations are not as uncommon as they might
    seem, especially in intricate configurations. However, it’s crucial to understand
    that simply linking one library to another doesn’t introduce any sort of namespace
    inheritance. Symbols at each link of this chain stay in their original namespaces,
    as they were when compiled.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，可能会遇到一个共享库链接到另一个库，形成一个长链。这样的情况并不像看起来那样罕见，尤其是在复杂的配置中。然而，重要的是要理解，仅仅将一个库链接到另一个库并不会引入任何命名空间的继承。在这个链中的每个链接的符号仍然保持其编译时的原始命名空间。
- en: 'While the intricacies of linkers are intriguing and occasionally essential,
    another pressing issue often crops up: the mysterious disappearance of properly
    defined symbols. Let’s delve into that in the next section.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然链接器的复杂性非常有趣，有时也至关重要，但另一个紧迫的问题常常浮现出来：已正确定义的符号神秘地消失了。我们将在下一节中深入探讨这个问题。
- en: The order of linking and unresolved symbols
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接顺序和未解决的符号
- en: The behavior of the linker can sometimes seem capricious, throwing complaints
    seemingly without cause. This often becomes a particularly vexing challenge for
    novice programmers unfamiliar with the intricacies of this tool. Understandably,
    they often try to steer clear of build configurations for as long as possible.
    But there comes a time when they need to make a change – perhaps integrating a
    library they’ve developed – and all hell breaks loose.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的行为有时看起来很任性，似乎无缘无故就抛出抱怨。这对于那些不熟悉这个工具细节的新手程序员来说，常常是一个特别令人烦恼的挑战。可以理解的是，他们通常尽量避免接触构建配置，直到不得不进行更改——也许是集成他们开发的库——这时一切都乱套了。
- en: 'Consider this: a relatively straightforward dependency chain where the main
    executable relies on an “outer” library. In turn, this outer library depends on
    a “nested” library that contains the essential `int b` variable. Out of the blue,
    a cryptic error message confronts the programmer:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 试想这样一种情况：一个相对简单的依赖链，主可执行文件依赖于一个“外部”库。而这个外部库又依赖于一个包含必需的`int b`变量的“嵌套”库。突然，一个令人费解的错误信息出现在程序员面前：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Such errors are not particularly uncommon. Typically, they indicate a forgotten
    library in the linker. Yet, in this scenario, the library seems to have been correctly
    added to the `target_link_libraries()` command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的错误并不罕见。通常，它们表示链接器中忘记添加某个库。然而，在这种情况下，库似乎已经正确地添加到了`target_link_libraries()`命令中：
- en: '**ch08/06-unresolved/CMakeLists.txt**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/06-unresolved/CMakeLists.txt**'
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What then!? Very few errors can be as infuriating to debug and understand.
    What we’re seeing here is an incorrect order of linking. Let’s dive into the source
    code to figure out the reason:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那该怎么办！？很少有错误能像这个一样令人抓狂，难以调试和理解。我们看到的是链接顺序不正确。让我们深入源代码找出原因：
- en: '**ch08/06-unresolved/main.cpp**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/06-unresolved/main.cpp**'
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code seems easy enough – we’ll print an external variable `a`, which can
    be found in the `outer` library. We’re declaring it ahead of time with the `extern`
    keyword. Here is the source for that library:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来足够简单——我们将打印一个外部变量`a`，它可以在`outer`库中找到。我们事先用`extern`关键字声明它。以下是该库的源代码：
- en: '**ch08/06-unresolved/outer.cpp**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/06-unresolved/outer.cpp**'
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is quite simple too – `outer` depends on the `nested` library to provide
    the external variable, `b`, which gets assigned to the `a` variable. Let’s see
    the source of `nested` to confirm that we’re not missing the definition:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很简单 —— `outer` 依赖于 `nested` 库来提供外部变量 `b`，然后将其赋值给 `a` 变量。让我们查看 `nested` 的源代码，确认我们没有遗漏定义：
- en: '**ch08/06-unresolved/nested.cpp**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/06-unresolved/nested.cpp**'
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Indeed, we have provided the definition for `b`, and since it’s not marked
    as local with the `static` keyword, it’s correctly exported from the `nested`
    target. As we saw previously, this target is linked with the `main` executable
    in `CMakeLists.txt`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们已经为 `b` 提供了定义，并且由于它没有用 `static` 关键字标记为局部，因此它正确地从 `nested` 目标中导出。正如我们之前看到的，这个目标与
    `main` 可执行文件在 `CMakeLists.txt` 中进行了链接：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, where does the `undefined reference to 'b'` error come from?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`undefined reference to 'b'` 错误是从哪里来的呢？
- en: 'Resolving undefined symbols works like this – a linker processes the binaries
    from left to right. As the linker iterates through the binaries, it will do the
    following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 解析未定义符号是这样的 —— 链接器按从左到右的顺序处理二进制文件。在链接器遍历这些二进制文件时，它将执行以下操作：
- en: Collect all undefined symbols exported from this binary and store them for later.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有从该二进制文件导出的未定义符号，并将它们存储以供以后使用。
- en: Try to resolve undefined symbols (collected from all binaries processed so far)
    with symbols defined in this binary.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试用此二进制文件中定义的符号来解析之前所有已处理二进制文件中收集到的未定义符号。
- en: Repeat this process for the next binary.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对下一个二进制文件重复这个过程。
- en: 'If any symbols remain undefined after the whole operation is completed, the
    linking fails. This is the case in our example (CMake prepends the object files
    of the executable target in front of the libraries):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在整个操作完成后仍然有未定义的符号，链接会失败。这就是我们例子中的情况（CMake 将可执行目标的目标文件放在库文件之前）：
- en: The linker processed `main.o,` found an undefined reference to the `a` variable,
    and collected it for future resolution.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接器处理了 `main.o`，发现了对 `a` 变量的未定义引用，并将其收集起来以便将来解析。
- en: The linker processed `libnested.a`, no undefined references were found, and
    there was nothing to resolve.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接器处理了`libnested.a`，没有发现未定义的引用，也没有需要解决的问题。
- en: The linker processed `libouter.a`, found an undefined reference to the `b` variable,
    and resolved the reference to the `a` variable.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接器处理了 `libouter.a`，发现了对 `b` 变量的未定义引用，并解析了对 `a` 变量的引用。
- en: 'We did correctly resolve the reference to the `a` variable, but not to the
    `b` variable. To correct this, we need to reverse the order of linking so that
    nested comes after outer:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实正确解析了对 `a` 变量的引用，但没有解析 `b` 变量的引用。为了解决这个问题，我们需要反转链接顺序，使 `nested` 排在 `outer`
    后面：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sometimes, we’ll encounter cyclic references, where translation units define
    symbols for each other, and there’s no single valid order where all references
    can be satisfied. The only way to solve this is to process some targets twice:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会遇到循环引用的情况，其中翻译单元相互定义符号，且没有单一的有效顺序能满足所有引用。解决这个问题的唯一方法是处理某些目标两次：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is a common practice, however slightly inelegant in use. If you have the
    privilege of using CMake 3.24 or newer, you can utilize the `$<LINK_GROUP>` generator
    expression with the `RESCAN` feature that adds linker-specific flags, like `--start-group`
    or `--end-group`, to ensure all symbols are evaluated:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见做法，但使用时稍显不优雅。如果你有幸使用 CMake 3.24 或更新版本，你可以利用 `$<LINK_GROUP>` 生成器表达式和 `RESCAN`
    特性，添加链接器特定的标志，例如 `--start-group` 或 `--end-group`，以确保所有符号都被评估：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Bear in mind that this mechanism introduces additional processing steps and
    should be used only if necessary. There are very rare cases where cyclic references
    are needed (and justified). Encountering this issue usually indicates poor design.
    It’s supported on Linux, BSD, SunOS, and Windows with a GNU toolchain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种机制引入了额外的处理步骤，应该仅在必要时使用。需要（并且有正当理由）使用循环引用的情况非常罕见。遇到这个问题通常表示设计不当。它在 Linux、BSD、SunOS
    和 Windows 上的 GNU 工具链中得到支持。
- en: We’re now prepared to deal with ODR issues. What other problems we can encounter?
    Suspiciously missing symbols during linking. Let’s find out what that’s about.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备处理 ODR 问题了。我们可能会遇到什么其他问题？在链接时符号异常丢失。让我们找出问题所在。
- en: Dealing with unreferenced symbols
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理未引用的符号
- en: When libraries, especially static libraries, are created, they are essentially
    archives that consist of multiple object files bundled together. We mentioned
    that some archiving tools might also create symbol indexes to expedite the linking
    process. Those indexes provide a mapping between each symbol and the object files
    in which they are defined. When a symbol is resolved, the object file containing
    it is incorporated into the resulting binary (some linkers further optimize this
    by only including specific sections of the file). If no symbols from an object
    file within a static library are referenced, that object file might be entirely
    omitted. Hence, only portions of a static library that are actually used could
    appear in the final binary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当库，特别是静态库被创建时，它们本质上是由多个目标文件组成的档案。我们提到过，一些归档工具还可能创建符号索引以加速链接过程。这些索引提供了每个符号与其所在目标文件的映射。当符号被解析时，包含该符号的目标文件将被并入最终的二进制文件（一些链接器进一步优化，通过仅包含文件的特定部分）。如果静态库中的某个目标文件没有任何符号被引用，那么该目标文件可能会完全被省略。因此，静态库中只有实际使用的部分才会出现在最终的二进制文件中。
- en: 'However, there are several scenarios where you might need some of the unreferenced
    symbols:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些场景下，你可能需要一些未引用的符号：
- en: '**Static initialization**: If your library has global objects requiring initialization
    (i.e., their constructors are executed) before `main()`, and these objects aren’t
    directly referenced elsewhere; the linker might exclude them from the final binary.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态初始化**：如果你的库有全局对象需要初始化（即它们的构造函数在 `main()` 之前执行），并且这些对象没有在其他地方直接引用；链接器可能会将它们从最终的二进制文件中排除。'
- en: '**Plugin architectures**: If you’re developing a plugin system (with module
    libraries) where code needs to be identified and loaded at runtime without direct
    referencing.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件架构**：如果你正在开发一个插件系统（使用模块库），其中的代码需要在运行时被识别并加载，而不需要直接引用。'
- en: '**Unused code in static libraries**: If you’re developing a static library
    containing utility functions or code that isn’t always directly referenced but
    you still want it in the final binary.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态库中的未使用代码**：如果你正在开发一个静态库，其中包含一些实用功能或代码，这些代码不一定总是被直接引用，但你仍希望它出现在最终的二进制文件中。'
- en: '**Template instantiations**: For libraries relying heavily on templates; some
    template instantiations might be overlooked during linking if not explicitly mentioned.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板实例化**：对于依赖于模板的库；如果没有明确提到，某些模板实例化可能在链接过程中被忽略。'
- en: '**Linking Issues**: Particularly with intricate buildsystems or elaborate codebases,
    linking might yield unpredictable outcomes where some symbols or code sections
    appear to be absent.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接问题**：特别是在复杂的构建系统或庞大的代码库中，链接可能会产生不可预测的结果，其中某些符号或代码段似乎缺失。'
- en: In these instances, forcing the inclusion of all object files during the linking
    process might be beneficial. This is often achieved via a mode called `whole-archive`
    linking.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，强制在链接过程中包含所有目标文件可能是有益的。这通常通过一种称为 `whole-archive` 链接模式来实现。
- en: 'Specific compiler linking flags are:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的编译器链接标志有：
- en: '`--whole-archive` for GCC'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--whole-archive` 用于 GCC'
- en: '`--force-load` for Clang'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force-load` 用于 Clang'
- en: '`/WHOLEARCHIVE` for MSVC'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/WHOLEARCHIVE` 用于 MSVC'
- en: 'To do so, we can use the `target_link_options()` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用 `target_link_options()` 命令：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, this command is linker specific, so incorporating generator expressions
    to detect different compilers and provide respective flags is essential. Fortunately,
    CMake 3.24 introduced a new generator expression for this purpose:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个命令是特定于链接器的，因此需要使用生成器表达式来检测不同的编译器并提供相应的标志。幸运的是，CMake 3.24 引入了一个新的生成器表达式来实现这一目的：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Utilizing this method ensures that the `tgt` target incorporates all object
    files from the `lib1` library.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以确保 `tgt` 目标包含 `lib1` 库中的所有目标文件。
- en: 'Nevertheless, a few potential drawbacks need consideration:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍需考虑一些潜在的缺点：
- en: '**Increased binary size**: This flag can substantially enlarge your final binary
    since all objects from the specified library are incorporated, whether they’re
    utilized or not.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的二进制文件大小**：这个标志可能会显著增大你的最终二进制文件，因为指定库中的所有对象都会被包含在内，无论它们是否被使用。'
- en: '**Potential for symbol clashes**: Introducing all symbols might cause clashes
    with others, leading to linker errors.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号冲突的潜在风险**：引入所有符号可能会导致与其他符号冲突，进而产生链接错误。'
- en: '**Maintenance overhead**: Over-relying on such flags can obscure underlying
    issues in the design or structure of your code.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护开销**：过度依赖此类标志可能会掩盖代码设计或结构中的潜在问题。'
- en: With an understanding of how to address common linking challenges, we can now
    progress to preparing our project for tests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何解决常见的链接问题后，我们现在可以继续准备项目进行测试。
- en: Separating main() for testing
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了测试，分离 `main()` 函数
- en: As we’ve established, the linker enforces the ODR and ensures that all external
    symbols provide their definitions during the linking process. Another linker-related
    challenge we might face is the elegant and efficient testing of the project.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所建立的那样，链接器强制执行 ODR，并确保在链接过程中所有外部符号提供它们的定义。我们可能面临的另一个与链接器相关的挑战是项目的优雅和高效的测试。
- en: In an ideal scenario, we should be testing the exact same source code that runs
    in production. A comprehensive testing pipeline would build the source code, run
    tests on the resulting binary, and then package and distribute the executable
    (optionally excluding the tests themselves).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，我们应该测试与生产环境中运行的完全相同的源代码。一个全面的测试流水线会构建源代码，对生成的二进制文件进行测试，然后打包并分发可执行文件（可选择不包括测试本身）。
- en: But how can we implement this? Executables typically have a precise execution
    flow, often involving the reading of command-line arguments. The compiled nature
    of C++ doesn’t readily support pluggable units that can be temporarily injected
    into the binary just for testing. This suggests that we may need a nuanced approach
    to tackle this challenge.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何实现这一点呢？可执行文件通常有一个精确的执行流程，通常涉及读取命令行参数。C++ 的编译性质不容易支持可以临时注入到二进制文件中的可插拔单元，仅用于测试。这表明我们可能需要采取更为细致的方法来应对这一挑战。
- en: 'Luckily, we can use a linker to help us deal with this in an elegant manner.
    Consider extracting all logic from your program’s `main()` to an external function,
    `start_program()`, like so:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用链接器以一种优雅的方式帮助我们解决这个问题。考虑将程序的所有逻辑从 `main()` 提取到一个外部函数 `start_program()`
    中，如下所示：
- en: '**ch08/07-testing/main.cpp**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/07-testing/main.cpp**'
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It’s reasonable to skip testing this new `main()` function when it’s written
    in such form; it is only forwarding arguments to a function defined elsewhere
    (in another file). We can then create a library containing the original source
    from `main()` wrapped in a new function – `start_program()`. In this example,
    the code checks whether the command-line argument count is higher than `1`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当新写的 `main()` 函数只是将参数转发到另一个地方定义的函数（在另一个文件中）时，跳过测试是合理的。我们可以创建一个包含原始源代码的库，`main()`
    中的源代码被包装在一个新的函数 `start_program()` 中。在这个示例中，代码检查命令行参数的数量是否大于 `1`：
- en: '**ch08/07-testing/program.cpp**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/07-testing/program.cpp**'
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now prepare a project that builds this application and links together
    those two translation units:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以准备一个构建该应用程序并将这两个翻译单元链接在一起的项目：
- en: '**ch08/07-testing/CMakeLists.txt**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/07-testing/CMakeLists.txt**'
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `main` target is just providing the required `main()` function. The command-line
    argument verification logic is contained in the `program` target. We can now test
    it by creating another executable with its own `main()` function, which will host
    the test cases.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 目标仅提供所需的 `main()` 函数。命令行参数验证逻辑包含在 `program` 目标中。我们现在可以通过创建另一个具有自己 `main()`
    函数的可执行文件来进行测试，该文件将托管测试用例。'
- en: 'In a real-world scenario, frameworks such as **GoogleTest** or **Catch2** will
    provide their own `main()` method that can be used to replace your program’s entry
    point and run all the defined tests. We’ll dive deep into the subject of actual
    testing in *Chapter 11*, *Testing Frameworks*. For now, let’s focus on the general
    principle and write our own test cases directly in the `main()` function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，像 **GoogleTest** 或 **Catch2** 这样的框架将提供自己的 `main()` 方法，可以替换程序的入口点并运行所有定义的测试。我们将在
    *第 11 章*，*测试框架* 中深入探讨实际测试的主题。现在，让我们专注于一般原则，并直接在 `main()` 函数中编写自己的测试用例：
- en: '**ch08/07-testing/test.cpp**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch08/07-testing/test.cpp**'
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code will call `start_program` twice, with and without arguments,
    and check whether the returned exit codes are correct. Here’s the output you’ll
    see if tests execute correctly:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将调用 `start_program` 两次，分别带有和不带有参数，并检查返回的退出代码是否正确。如果测试正确执行，您将看到以下输出：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Not enough arguments` line is coming from `start_program()`, and is an
    expected error message (we’re checking whether the program is failing correctly).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Not enough arguments` 行来自 `start_program()`，这是一个预期的错误消息（我们在检查程序是否正确失败）。'
- en: This unit test leaves much to be desired in terms of clean code and elegant
    testing practices, but it’s a start.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试在清晰的代码和优雅的测试实践方面还有很多改进空间，但它是一个开始。
- en: 'We have now defined `main()` twice:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了两次 `main()`：
- en: In `main.cpp` for production use
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main.cpp`中用于生产环境
- en: In `test.cpp` for test purposes
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`test.cpp`中用于测试目的
- en: 'Let’s define the testing executable at the bottom of our `CMakeLists.txt` now:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`CMakeLists.txt`的底部定义测试可执行文件：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This addition creates a new target that links against the same binary code as
    our production code. Yet, it gives us the flexibility to call all exported functions
    as needed. Thanks to this, we can run all code paths automatically and check whether
    they work as expected. Great!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新增内容创建了一个新的目标，链接到与我们的生产代码相同的二进制代码。但它赋予了我们根据需要调用所有导出函数的灵活性。得益于此，我们可以自动运行所有代码路径并检查它们是否按预期工作。太棒了！
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Linking in CMake might initially appear straightforward, but as we dig deeper,
    we see there’s much more beneath the surface. After all, linking executables isn’t
    as simple as piecing puzzle parts together. When we delve deep into the structure
    of object files and libraries, it’s clear that sections, which store various types
    of data, instructions, symbol names, and the like, need some reordering. Before
    a program is runnable, these sections undergo what’s known as relocation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中的链接最初看起来可能很简单，但随着我们深入探讨，我们发现背后隐藏了更多内容。毕竟，链接可执行文件并不像拼图一样简单。当我们深入研究目标文件和库的结构时，我们清楚地看到，存储各种类型的数据、指令、符号名称等的段需要重新排序。在程序可以运行之前，这些段将进行所谓的重定位。
- en: 'It’s also crucial to resolve symbols. The linker must sort through references
    across all translation units, ensuring nothing’s left out. Once this is settled,
    the linker then creates the program header and places it into the final executable.
    This header offers instructions to the system loader, detailing how to transform
    consolidated sections into segments that will make up the runtime memory image
    of the process. We also discussed the three kinds of libraries: static, shared,
    and shared modules. We examined how they differ and which scenarios some might
    be better suited for than others. Additionally, we touched on PIC – a powerful
    concept that facilitates the lazy binding of symbols.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 解决符号的问题也至关重要。链接器必须遍历所有翻译单元中的引用，确保没有遗漏。一旦解决了这些问题，链接器接着会创建程序头并将其放入最终的可执行文件中。这个头文件为系统加载器提供了指令，详细说明了如何将整合后的段落转换为构成进程运行时内存映像的段。我们还讨论了三种类型的库：静态库、共享库和共享模块。我们研究了它们之间的差异，以及在某些场景下某些库可能比其他库更适合使用。此外，我们还提到了一些有关PIC的内容——这是一个强大的概念，它促进了符号的懒绑定。
- en: The ODR is a C++ concept, but as we’ve seen, it’s strongly enforced by linkers.
    We looked at how to tackle the most basic symbol duplication in both static and
    dynamic libraries. We also highlighted the value of using namespaces whenever
    possible and advised against depending too much on a linker to prevent symbol
    collisions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ODR是一个C++概念，但正如我们所看到的，它被链接器强力执行。我们探讨了如何解决静态库和动态库中最基本的符号重复问题。我们还强调了在可能的情况下使用命名空间的价值，并建议不要过度依赖链接器来避免符号冲突。
- en: For a step that might seem straightforward (given CMake’s limited commands dedicated
    to linking), it certainly has its complexities. One of the trickier aspects is
    the order of linking, especially when dealing with libraries that have nested
    and cyclical dependencies. We now understand how the linker selects symbols that
    end up in the final binary file, and how we can override this behavior if needed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个看起来可能很简单的步骤（鉴于CMake专门用于链接的命令较少），它确实有一些复杂性。一个较为棘手的方面是链接顺序，尤其是在处理具有嵌套和循环依赖的库时。我们现在理解了链接器是如何选择最终二进制文件中的符号的，以及在需要时如何覆盖这种行为。
- en: Lastly, we investigated how to take advantage of a linker to prepare our program
    for testing – by separating the `main()` function into another translation unit.
    This enabled us to introduce another executable, which ran tests against the exact
    same machine code that will be executed in production.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何利用链接器准备我们的程序进行测试——通过将`main()`函数分离到另一个翻译单元中。这使我们能够引入另一个可执行文件，该文件运行与生产中将要执行的机器代码完全相同的测试。
- en: With our newfound knowledge of linking, we’re ready to bring external libraries
    into our CMake projects. In the next chapter, we’ll look at how to manage dependencies
    in CMake.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对链接的全新理解，我们已经准备好将外部库引入到CMake项目中。在下一章中，我们将学习如何管理CMake中的依赖关系。
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章讨论主题的更多信息，请参考以下内容：
- en: 'The structure of ELF files: [https://en.wikipedia.org/wiki/Executable_and_Linkable_Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELF文件的结构：[https://en.wikipedia.org/wiki/Executable_and_Linkable_Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
- en: 'The CMake manual for `add_library()`: [https://cmake.org/cmake/help/latest/command/add_library.html](https://cmake.org/cmake/help/latest/command/add_library.html)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_library()`的CMake手册：[https://cmake.org/cmake/help/latest/command/add_library.html](https://cmake.org/cmake/help/latest/command/add_library.html)'
- en: 'Dependency hell: [https://en.wikipedia.org/wiki/Dependency_hell](https://en.wikipedia.org/wiki/Dependency_hell)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖地狱：[https://en.wikipedia.org/wiki/Dependency_hell](https://en.wikipedia.org/wiki/Dependency_hell)
- en: 'The differences between modules and shared libraries: [https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries](https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和共享库之间的区别：[https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries](https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries)
- en: Join our community on Discord
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者一起讨论：
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code94081075213645359.png)'
