- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: General-Purpose Peripherals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用外设
- en: 'Modern microcontrollers integrate several features that help in building stable
    and reliable embedded systems. Once the system is up and running, memory and peripherals
    can be accessed, and basic functionalities are in place. Only then can all the
    components of the system be initialized by activating the associated peripherals
    through the system registers, setting the correct frequencies for the clock lines,
    and configuring and activating interrupts. In this chapter, we will describe the
    interface exposed by the microcontroller to access built-in peripherals and some
    basic system functionalities. We will focus on the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代微控制器集成了多个功能，有助于构建稳定可靠的嵌入式系统。一旦系统启动并运行，就可以访问内存和外设，并具备基本功能。只有在此之后，才能通过激活相关外设的系统寄存器、设置时钟线的正确频率以及配置和激活中断来初始化系统的所有组件。在本章中，我们将描述微控制器暴露的接口，以访问内置外设和一些基本系统功能。我们将重点关注以下主题：
- en: The interrupt controller
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断控制器
- en: System time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统时间
- en: Generic timers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用定时器
- en: '**General-purpose** **input/output** (**GPIO**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用** **输入/输出** （**GPIO**）'
- en: The watchdog
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看门狗
- en: While these peripherals are often accessible through the hardware-support libraries
    implemented and distributed by chip manufacturers, our approach here involves
    fully understanding the hardware components and the meaning of all the registers
    involved. This will be achieved by configuring and using the functionalities in
    the microcontroller straight through the interface exported by the hardware logic.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些外设通常可以通过芯片制造商实现和分发的硬件支持库访问，但我们的方法涉及完全理解硬件组件和所有相关寄存器的含义。这将通过配置和使用微控制器中通过硬件逻辑导出的接口的功能来实现。
- en: When designing drivers for a specific platform, it is necessary to study the
    interface provided by the microcontroller to access peripherals and CPU features.
    In the examples provided, the STM32F4 microcontroller is used as a reference target
    for implementing platform-specific features. Nevertheless, inspecting a possible
    implementation on our reference platform allows us to get better insight into
    how to interact with generic targets exposing similar functionalities using the
    documentation provided by the silicon manufacturer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在为特定平台设计驱动程序时，有必要研究微控制器提供的用于访问外设和CPU功能的接口。在提供的示例中，STM32F4微控制器被用作实现平台特定功能的参考目标。尽管如此，检查我们参考平台上的可能实现使我们能够更好地了解如何使用硅制造商提供的文档与具有类似功能的通用目标进行交互。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter6)。
- en: Bitwise operations
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位操作
- en: The examples associated with this chapter make extensive use of bitwise operations
    for checking, setting, and clearing single bits within larger registers (in most
    cases, 32-bit long). You should already be familiar with bitwise logic operations
    in C.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例广泛使用了位操作来检查、设置和清除大寄存器（在大多数情况下，为32位长）内的单个位。你应该已经熟悉C语言中的位逻辑运算。
- en: 'The operations commonly used in the examples are the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中常用的操作如下：
- en: '`R |= (1 << N)`: The new value of the register R will contain the result of
    the bitwise `OR` operation between its original value and a bitmask containing
    all zeros, except the bit corresponding to the value we want to set, which is
    set to the value one'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R |= (1 << N)`: 寄存器R的新值将包含其原始值与一个掩码进行位或操作的位运算结果，该掩码除了我们想要设置的位对应的位置外，其余位均为零，该位被设置为1'
- en: '`R &= ~(1 << N)`: The new value of the register is the result of a bitwise
    `AND` operation between its original value and a bitmask containing all ones,
    except the bit in the position we want to clear, which is set to the value zero'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R &= ~(1 << N)`: 寄存器的新值是其原始值与一个掩码进行位与操作的位运算结果，该掩码除了我们想要清除的位对应的位置外，其余位均为1，该位被设置为0'
- en: '`(R & (1 << N) == (1 << N))`: Returns `true` only if the Nth bit of the register
    is set'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(R & (1 << N) == (1 << N))`: 只有当寄存器的第N位被设置时，才返回`true`'
- en: Let us quickly jump into the first topic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速跳到第一个主题。
- en: The interrupt controller
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断控制器
- en: Real-time systems have improved their accuracy thanks to the rapid evolution
    of modern embedded systems, in particular from the research on interrupt controllers.
    Assigning different priorities to interrupt lines guarantees a lower interrupt
    latency for higher-priority interrupt sources and makes the system react faster
    to prioritized events. Interrupts may, however, occur at any time while the system
    is running, including during the execution of another interrupt service routine.
    In this case, the interrupt controller provides a way to chain the interrupt handlers,
    and the order of execution depends on the priority levels assigned to the interrupt
    source.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代嵌入式系统的快速发展，特别是中断控制器的研究，实时系统的精度得到了提高。为中断线路分配不同的优先级确保了高优先级中断源具有更低的中断延迟，使系统能够更快地响应优先级事件。然而，中断可能在系统运行时任何时候发生，包括在执行另一个中断服务例程期间。在这种情况下，中断控制器提供了一种链式中断处理程序的方法，执行顺序取决于分配给中断源的优先级级别。
- en: One of the reasons for the popularity of the Cortex-M family of microprocessors
    among real-time and low-power embedded applications is perhaps the design of its
    programmable real-time controller—namely, the **Nested Vector Interrupt Controller**,
    or **NVIC** for short. The NVIC supports up to 240 interrupt sources, which can
    be grouped into up to 256 priority levels, depending on the bits reserved to store
    the priority in the microprocessor logic. These characteristics make it very flexible,
    as the priorities can also be changed while the system is running, maximizing
    the freedom of choice for the programmer. As we already know, the NVIC is connected
    to the vector table located at the beginning of the code region. Whenever an interrupt
    occurs, the current state of the executing application is pushed into the stack
    automatically by the processor, and the service routine associated with the interrupt
    line is executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M系列微处理器在实时和低功耗嵌入式应用中的流行，其中一个原因可能是其可编程实时控制器的设计——即嵌套向量中断控制器，简称**NVIC**。NVIC支持多达240个中断源，这些中断源可以根据存储在微处理器逻辑中的优先级位进行分组，最多可达256个优先级级别。这些特性使其非常灵活，因为优先级也可以在系统运行时更改，从而最大化程序员的选择自由度。正如我们所知，NVIC连接到代码区域开头的向量表。每当发生中断时，处理器会自动将执行应用的当前状态推入堆栈，并执行与中断线路相关联的服务例程。
- en: Systems that do not have an interrupt-priority mechanism implement back-to-back
    interrupt handling. In these cases, chaining interrupts implies that the context
    is restored at the end of the execution of the first service routine in line,
    and then saved again while entering the following one. The NVIC implements a tail-chaining
    mechanism to execute nested interrupts. If one or more interrupts occur while
    another service routine is executing, the pull operation normally occurring at
    the end of the interrupt to restore the context from the stack will be canceled,
    and the controller will instead fetch the location of the second handler in the
    interrupt vector and ensure it is executed immediately after the first. Because
    of the increased pace of the stack save and restore operations being implemented
    in hardware, the interrupt latency is significantly reduced in all those cases
    where interrupts are chained. Thanks to its implementation, NVIC allows us to
    change parameters while the system is running, and is able to reshuffle the order
    of execution of the interrupt service routines associated with the pending signals,
    according to the priority levels. Moreover, the same interrupt is not allowed
    to run twice in the same chain of handlers, which may be caused by altering the
    priorities in the other handlers. This is intrinsically enforced by the NVIC logic,
    which ensures that no loops are possible in the chain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 没有中断优先级机制的系统实现连续中断处理。在这些情况下，中断链意味着在执行第一个服务例程结束时恢复上下文，然后在进入下一个服务例程时再次保存。NVIC
    实现了一个尾链机制来执行嵌套中断。如果在另一个服务例程执行期间发生一个或多个中断，通常在中断结束时发生的从堆栈恢复上下文的拉取操作将被取消，控制器将取而代之从中断向量中获取第二个处理器的位置，并确保它在第一个之后立即执行。由于在硬件中实现了堆栈保存和恢复操作的加速，因此在所有这些中断链的情况下，中断延迟都显著降低。得益于其实现，NVIC
    允许我们在系统运行时更改参数，并且能够根据优先级重新排列待处理信号的关联中断服务例程的执行顺序。此外，不允许在同一个处理器链中两次运行相同的中断，这可能是由于在其他处理器中更改优先级所引起的。这由
    NVIC 逻辑内在强制执行，确保链中不可能出现循环。
- en: Peripherals’ interrupt configuration
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外设的中断配置
- en: Each interrupt line can be enabled and disabled through the NVIC Interrupt Set/Clear
    Enable registers, `NVIC_ISER` and `NVIC_ICER`, located at addresses `0xE000E100`
    and `0xE000E180`, respectively. If the target supports more than 32 external interrupts,
    arrays of 32-bit registers are mapped at the same locations. Each bit in the registers
    is used to activate a predefined interrupt line, associated with the bit position
    in that specific register. For example, on an STM32F4 microcontroller, in order
    to activate the interrupt line for the `NVIC_ISER` area.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中断线都可以通过位于地址 `0xE000E100` 和 `0xE000E180` 的 NVIC 中断设置/清除使能寄存器 `NVIC_ISER` 和
    `NVIC_ICER` 来启用和禁用。如果目标支持超过 32 个外部中断，则将在相同位置映射 32 位寄存器数组。寄存器中的每个位都用于激活一个预定义的中断线，与该特定寄存器中的位位置相关联。例如，在
    STM32F4 微控制器上，为了激活 `NVIC_ISER` 区域的中断线。
- en: 'The generic NVIC function, to enable the interrupt, activates the flag corresponding
    to the NVIC interrupt number for the source, in the associate `NVIC_ISER` register:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 NVIC 函数，用于启用中断，会在关联的 `NVIC_ISER` 寄存器中激活对应于 NVIC 中断号的标志：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, to disable the interrupt, the `nvic_irq_disable` function activates
    the corresponding bit in the interrupt clear register:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要禁用中断，`nvic_irq_disable` 函数会在中断清除寄存器中激活相应的位：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The interrupt priorities are mapped in an array of 8-bit registers, each containing
    the priority value for the corresponding interrupt line, starting at address `0xE000E400`
    so that they can be accessed independently to change the priority at runtime:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 中断优先级映射在一个 8 位寄存器数组中，每个寄存器包含对应中断线的优先级值，从地址 `0xE000E400` 开始，以便它们可以独立访问以在运行时更改优先级：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These functions will come in handy to route and prioritize interrupt lines whenever
    an interrupt is enabled for a peripheral.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在为外设启用中断时，将有助于路由和优先级排序中断线。
- en: System time
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统时间
- en: Timekeeping is a basic requirement for almost any embedded system. A microcontroller
    can be programmed to trigger an interrupt at regular intervals, which is commonly
    used to increment the monotonic system clock. To do so, a few configuration steps
    must be performed at startup in order to have a stable tick interrupt. Many processors
    can run at custom frequencies while using the same oscillator as the source. The
    input frequency of the oscillator, which can be internal or external to the CPU,
    is used to derive the processor’s main clock. The configurable logic integrated
    into the CPU is implemented by a **phase-locked loop** (**PLL**) that multiplies
    the input clock from an external stable source and produces the desired frequencies
    used by the CPU and integrated peripherals.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 时间管理几乎是任何嵌入式系统的基本要求。微控制器可以被编程为在固定时间间隔触发中断，这通常用于递增单调系统时钟。为此，必须在启动时执行几个配置步骤，以便有一个稳定的滴答中断。许多处理器可以使用与
    CPU 相同的振荡器作为源以自定义频率运行。振荡器的输入频率，可以是 CPU 内部或外部的，用于推导处理器的主时钟。集成到 CPU 中的可配置逻辑通过一个
    **锁相环**（**PLL**）实现，该环将外部稳定源的输入时钟乘以，产生 CPU 和集成外设使用的所需频率。
- en: Adjusting the flash wait states
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整闪存等待状态
- en: 'If the initialization code is running from flash, it might be necessary to
    set the wait state for the flash memory before altering the system clocks. If
    the microprocessor runs at high frequencies, it might require a few wait states
    in between two consecutive access operations to persistent memory with `0x40023800`.
    The **Access Control Register** (**ACR**), which is the one we need to access
    to set the wait states, is located at the beginning of the area:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始化代码是从闪存中运行的，在更改系统时钟之前可能需要设置闪存内存的等待状态。如果微处理器以高频率运行，它可能需要在两个连续访问操作之间对具有 `0x40023800`
    的持久性内存设置几个等待状态。**访问控制寄存器**（**ACR**），我们需要访问以设置等待状态的寄存器，位于该区域的开始处：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The lowest three bits in the `FLASH_ACR` register are used to set the number
    of wait states. According to the STM32F407 datasheet, the ideal number of wait
    states to access the flash while the system is running at 168 MHz is `5`. At the
    same time, we can enable the data and instruction cache by activating bits `10`
    and `9`, respectively:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLASH_ACR` 寄存器的最低三位用于设置等待状态的数量。根据 STM32F407 数据手册，当系统以 168 MHz 运行时，访问闪存的理想等待状态数量是
    `5`。同时，我们可以通过激活位 `10` 和 `9` 分别启用数据和指令缓存：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the wait states are set, it is safe to run the code from the flash after
    setting the CPU frequency at a higher speed, so we can proceed with the actual
    clock configuration and distribution to the peripherals.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设置等待状态后，在将 CPU 频率设置得更高后，从闪存中运行代码是安全的，因此我们可以继续进行实际的时钟配置和分配到外设。
- en: Clock configuration
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟配置
- en: The configuration of the clocks in Cortex-M microcontrollers happens through
    the **Reset and Clock Control** (**RCC**) registers, located at a specific address
    within the internal peripheral region. The RCC configuration is vendor-specific,
    as it depends on the logic of the PLL implemented in the microcontroller. The
    registers are described in the documentation of the microcontroller, and often,
    example source code is provided by the chip manufacturer demonstrating how to
    properly configure the clocks on the microcontroller. On our reference target,
    STM32F407, assuming that an external 8 MHz oscillator is used as a source, the
    following procedure configures a 168 MHz system clock and ensures that the clock
    is also distributed to each peripheral bus. The following code ensures that the
    PLL is initialized with the required value and that the CPU clock is ticking at
    the desired frequency. This procedure is common among many STM Cortex-M microcontrollers,
    and the values for the PLL configurations can be obtained from the chip documentation,
    or calculated using software tools provided by ST.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M 微控制器中的时钟配置是通过位于内部外设区域特定地址的 **重置和时钟控制**（**RCC**）寄存器来完成的。RCC 配置是供应商特定的，因为它取决于微控制器中实现的
    PLL 逻辑。寄存器在微控制器的文档中描述，通常，芯片制造商提供示例源代码，演示如何在微控制器上正确配置时钟。在我们的参考目标 STM32F407 上，假设使用外部
    8 MHz 振荡器作为源，以下过程配置了一个 168 MHz 系统时钟，并确保时钟也分配到每个外设总线。以下代码确保 PLL 以所需值初始化，并且 CPU
    时钟以期望的频率滴答。此过程在许多 STM Cortex-M 微控制器中很常见，PLL 配置的值可以从芯片文档中获得，或使用 ST 提供的软件工具计算。
- en: The software examples provided after this point will make use of a system-specific
    module, exporting the functions needed to configure the clock and set the flash
    memory latency. We now analyze two possible implementations for the PLL configuration,
    on two different Cortex-M microcontrollers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此处提供的软件示例将使用系统特定模块，导出配置时钟和设置闪存延迟所需的函数。我们现在分析两种可能的PLL配置实现，针对两种不同的Cortex-M微控制器。
- en: 'To access the configuration of the PLL in the STM32F407-Discovery, first, we
    define some shortcut macros to the addresses of the registers provided by the
    `RCC`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问STM32F407-Discovery中PLL的配置，首先，我们定义了一些快捷宏到由`RCC`提供的寄存器地址：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the sake of readability, and to ensure that the code is maintainable in
    the future, we also define the mnemonics associated with the single-bit values
    in the corresponding registers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，并确保代码在未来可维护，我们还定义了与相应寄存器中单比特值相关的助记符：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we define the platform-specific constant values used to configure
    the PLL:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了用于配置PLL的平台特定常量值：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One additional macro invoking the `DMB` assembly instruction is defined, for
    brevity, as it will be used in the code to ensure that any pending memory transfer
    toward the configuration registers is completed before the execution of the next
    statement:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个额外的宏来调用`DMB`汇编指令，为了简洁起见，因为它将在代码中使用，以确保在执行下一个语句之前完成任何挂起的配置寄存器内存传输：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next function will then ensure that the PLL initialization sequence is
    performed, in order to set the correct CPU frequency. First, it will enable the
    internal high-speed oscillator, and will wait until it is ready by polling the
    CR:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数将确保执行PLL初始化序列，以设置正确的CPU频率。首先，它将启用内部高速振荡器，并通过轮询CR来等待其就绪：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The internal oscillator is then selected as a temporary clock source:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择内部振荡器作为临时时钟源：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The external oscillator is then activated in the same way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以相同的方式激活外部振荡器：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On this device, the clock can be distributed to all the peripherals through
    three system buses. Using prescalers, the frequency of each bus can be scaled
    by a factor of two or four. In this case, we set the clock speed for HPRE, PPRE1,
    and PPRE2 to be 168, 84, and 46 MHz respectively on this target:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设备上，时钟可以通过三个系统总线分布到所有外围设备。使用预分频器，每个总线的频率可以按2或4的倍数缩放。在这种情况下，我们将HPRE、PPRE1和PPRE2的时钟速度分别设置为168、84和46
    MHz：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The PLL configuration register is set to contain the parameters to correctly
    scale the external oscillator frequency to the desired value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PLL配置寄存器被设置为包含将外部振荡器频率正确缩放到所需值的参数：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The PLL is then activated, and the execution is suspended until the output
    is stable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后激活PLL，执行将暂停，直到输出稳定：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The PLL is selected as the final source for the system clock:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将PLL选为系统时钟的最终源：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The internal oscillator is no longer in use and can be disabled. The control
    returns to the caller, and all the clocks are successfully set.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 内部振荡器不再使用，可以禁用。控制权返回调用者，所有时钟都成功设置。
- en: 'As mentioned earlier, the procedure for clock initialization is strictly dependent
    on the PLL configuration in the microcontroller. To properly initialize the system
    clocks required for the CPU and the peripherals to operate at the desired frequencies,
    it is always advised to refer to the datasheet of the microcontroller provided
    by the silicon manufacturer. As a second example, we can verify how `RCC` and
    `RCC2`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，时钟初始化的步骤严格依赖于微控制器中的PLL配置。为了正确初始化CPU和外围设备所需的系统时钟，以便在期望的频率下运行，始终建议参考硅制造商提供的微控制器数据手册。作为第二个例子，我们可以验证`RCC`和`RCC2`：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To reset the `RCC` registers to a known state, the reset value must be written
    to these registers at boot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`RCC`寄存器重置到已知状态，必须在启动时将这些寄存器写入重置值：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This microcontroller uses a raw interrupt to notify that the PLL is locked
    to the requested frequency. The interrupt status can be checked by reading bit
    `6` in the **Raw Interrupt Status** (**RIS**) register:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此微控制器使用原始中断来通知PLL已锁定到请求的频率。可以通过读取**原始中断状态**（**RIS**）寄存器中的位`6`来检查中断状态：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The clock configuration routine in this case starts by resetting the `RCC`
    registers and setting the appropriate values to configure the PLL. The PLL is
    configured to generate a 400 MHz clock from an 8 MHz oscillator source:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，时钟配置例程首先重置`RCC`寄存器，并设置适当的值以配置PLL。PLL被配置为从8 MHz振荡器源生成400 MHz时钟：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resultant 50 MHz CPU frequency is derived from this master 400 MHz clock
    using the system divider. The clock is pre-divided by two, and then a factor of
    `4` is applied:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个主400 MHz时钟通过系统分频器得到的50 MHz CPU频率。时钟先被预分频两次，然后应用一个`4`的倍数：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The external oscillators are powered on:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 外部振荡器也被启用：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the system clock divider is powered on as well. At the same time, setting
    the bypass bit ensures that the oscillator is used as a source for the system
    clock, and the PLL is bypassed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并且系统时钟分频器也被启用。同时，设置旁路位确保振荡器被用作系统时钟的源，PLL被旁路：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The execution is held until the PLL is stable and has locked on the desired
    frequency:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行将保持，直到PLL稳定并锁定在所需的频率：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Disabling the bypass bits in the `RCC` registers at this point is sufficient
    to connect the PLL output to the system clock:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此点禁用`RCC`寄存器中的旁路位足以将PLL输出连接到系统时钟：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Clock distribution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟分配
- en: Once the bus clocks are available, the `RCC` logic can be programmed to distribute
    the clock to single peripherals. To do so, the `RCC` exposes bit-mapped peripheral
    clock source registers. Setting the corresponding bit in one of the registers
    enables the clock for each mapped peripheral in the microcontroller. Each register
    can control clock gating for 32 peripherals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦总线时钟可用，`RCC`逻辑可以被编程以将时钟分配给单个外设。为此，`RCC`公开了位图外设时钟源寄存器。在其中一个寄存器中设置相应的位将启用微控制器中每个映射外设的时钟。每个寄存器可以控制32个外设的时钟门控。
- en: 'The order of the peripherals, and consequently the corresponding register and
    bit, is strictly dependent on the specific microcontrollers. The STM32F4 has three
    registers dedicated to this purpose. For example, to enable the clock source for
    the internal watchdog, it is sufficient to set the bit number `9` in the clock
    enable register at address `0x40021001c`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 外设的顺序以及相应的寄存器和位严格依赖于特定的微控制器。STM32F4有三个寄存器专门用于此目的。例如，为了启用内部看门狗的时钟源，只需在地址`0x40021001c`的时钟使能寄存器中将位号`9`设置为`1`：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keeping the clock source off for a peripheral that is not in use saves power;
    thus, if the target supports clock gating, it can implement optimization and fine-tuning
    of power consumption by disabling the single peripherals at runtime through their
    clock gates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭未使用外设的时钟源可以节省电源；因此，如果目标支持时钟门控，它可以通过在运行时通过它们的时钟门控禁用单个外设来实现功耗的优化和微调。
- en: Enabling the SysTick
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用SysTick
- en: 'Once a stable CPU frequency has been set up, we can configure the main timer
    on the system—the SysTick. Since the implementation of a specific system timer
    is not mandatory on all Cortex-M, sometimes it is necessary to use an ordinary
    auxiliary timer to keep track of the system time. In most cases, though, the SysTick
    interrupt can be enabled by accessing its configuration, which is located in the
    system control block within the system configuration region. In all Cortex-M microcontrollers
    that include a system tick, the configuration can be found starting at address
    `0xE000E010`, and exposes four registers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了稳定的CPU频率，我们就可以配置系统上的主定时器——SysTick。由于并非所有Cortex-M都需要特定的系统定时器实现，有时有必要使用普通辅助定时器来跟踪系统时间。然而，在大多数情况下，可以通过访问其配置来启用SysTick中断，该配置位于系统配置区域内的系统控制块中。在所有包含系统滴答的Cortex-M微控制器中，配置可以从地址`0xE000E010`开始找到，并公开了四个寄存器：
- en: The control/status register (`SYSTICK_CSR`) at offset `0`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制状态寄存器（`SYSTICK_CSR`）偏移量为`0`
- en: The reload value register (`SYSTICK_RVR`) at offset `4`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载值寄存器（`SYSTICK_RVR`）偏移量为`4`
- en: The current value register (`SYSTICK_CVR`) at offset `8`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前值寄存器（`SYSTICK_CVR`）偏移量为`8`
- en: The calibration register (`SYSTICK_CALIB`) at offset `12`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校准寄存器（`SYSTICK_CALIB`）偏移量为`12`
- en: The SysTick works as a countdown timer. It holds a 24-bit value, which is decreased
    at every CPU clock tick. The timer reloads the same value every time it reaches
    `0` and triggers the SysTick interrupt if it is configured to do so.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick作为一个倒计时计时器工作。它持有一个24位值，每次CPU时钟滴答时该值会减少。当计时器达到`0`时，它会重新加载相同的值，如果配置为这样做，则触发SysTick中断。
- en: 'As a shortcut to access the SysTick registers, we define their locations:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为访问SysTick寄存器的快捷方式，我们定义了它们的地址：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we know the frequency of the CPU in Hz, we can define the system tick
    interval by setting the value in the `0` so that the first interrupt is immediately
    triggered after we enable the countdown. The SysTick can finally be enabled by
    configuring the control/status register. The meaning of the least significant
    three bits of the CSR is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道CPU的频率（Hz），我们可以通过设置`0`中的值来定义系统滴答间隔，这样在启用倒计时后，第一个中断立即触发。通过配置控制/状态寄存器，SysTick最终可以启用。CSR最低三位的意义如下：
- en: '**Bit 0**: Enables countdown. After this bit is set, the counter in the SysTick
    timer is automatically decreased at every CPU clock interval.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位0**：启用倒计时。在此位设置后，SysTick计时器的计数器在每次CPU时钟间隔自动减少。'
- en: '`0`, a SysTick interrupt will be generated.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`，将生成SysTick中断。'
- en: '**Bit 2**: Source clock selection. If this bit is reset, an external reference
    clock is used as the source. The CPU clock is used as the source when this bit
    is set.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位2**：源时钟选择。如果此位被清除，则使用外部参考时钟作为源。当此位被设置时，使用CPU时钟作为源。'
- en: 'We are going to define a custom SysTick interrupt handler, so we want to set
    bit `1` as well. Because we configured the CPU clock correctly, and we are scaling
    the system tick interval reload value on that, we also want bit `2` to be set.
    The last line of our `systick_enable` routine will enable the three bits together
    in the CSR:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个自定义的SysTick中断处理程序，因此我们还想设置位`1`。因为我们正确地配置了CPU时钟，并且我们在其上缩放系统滴答间隔重载值，所以我们还想设置位`2`。我们`systick_enable`例程的最后一行将一起在CSR中启用这三个位：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The system timer that we have configured is the same as that used by **real-time
    operating systems** (**RTOSs**) to initiate process switches. In our case, it
    might be helpful to keep a monotonic system wall clock, measuring the time elapsed
    since the clock configuration. A minimalist implementation of the interrupt service
    routine for the system timer could be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置的系统计时器与**实时操作系统**（RTOSs）用于启动进程切换所使用的计时器相同。在我们的情况下，保持一个单调的系统墙钟，测量自时钟配置以来经过的时间，可能会有所帮助。系统计时器的中断服务例程的最小化实现可能如下所示：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simple function, and the associated global `volatile` variable associated,
    are sufficient to keep track of the time transparently while the application is
    running. In fact, the system tick interrupt happens independently, at regular
    intervals, when the `jiffies` variable is incremented in the interrupt handler,
    without altering the flow of the main application. What actually happens is that
    every time the system tick counter reaches `0`, the execution is suspended, and
    the interrupt routine quickly executes. When `isr_systick` returns, the flow of
    the main application is resumed by restoring exactly the same context of execution
    stored in memory a moment before the interrupt occurred.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数以及相关的全局`volatile`变量足以在应用程序运行时透明地跟踪时间。实际上，系统滴答中断是独立发生的，在`jiffies`变量在中断处理程序中增加时，以固定的时间间隔发生，而不改变主应用程序的流程。实际上发生的情况是，每当系统滴答计数器达到`0`时，执行被暂停，中断例程快速执行。当`isr_systick`返回时，通过恢复中断发生前存储在内存中的相同的执行上下文，主应用程序的流程得以恢复。
- en: The reason why the system timer variable must be defined and declared everywhere
    as `volatile` is that its value is supposed to change while executing the application
    in a way that is independent of the behavior possibly predicted by the compiler
    for the local context of execution. The `volatile` keyword in this case ensures
    that the compiler is forced to produce code that checks the value of the variable
    every time it is instantiated, by disallowing the use of optimizations based on
    the false assumption that the variable is not being modified by the local code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 系统计时器变量必须在所有地方定义为`volatile`的原因是，其值在执行应用程序时可能会以与编译器对局部执行上下文行为可能预测的方式独立地改变。在这种情况下，`volatile`关键字确保编译器被迫产生代码，每次实例化变量时都检查变量的值，通过禁止使用基于变量未由局部代码修改的虚假假设的优化。
- en: 'Here is an example main program that uses the previous functions to boot the
    system, configure the master clock, and enable the SysTick:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用前面函数来启动系统、配置主时钟和启用SysTick的示例主程序：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The shortcut for the **WFI** assembly instruction (short for **wait for interrupt**)
    is defined. It is used in the main application to keep the CPU inactive until
    the next interrupt occurs:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了**WFI**汇编指令的快捷方式（代表**等待中断**）。它在主应用程序中使用，以保持CPU在下一个中断发生之前不活动：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To verify that the SysTick is actually running, the program can be executed
    with the debugger attached and stopped after a while. If the system tick has been
    configured correctly, the `jiffies` variable should always be displaying the time
    in milliseconds elapsed since boot.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证SysTick实际上正在运行，可以在调试器附加的情况下执行程序，并在一段时间后停止。如果系统滴答已正确配置，`jiffies`变量应始终显示自引导以来经过的毫秒数。
- en: Generic timers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用定时器
- en: Providing a SysTick timer is not mandatory for low-end microcontrollers. Some
    targets may not have a system timer, but all of them expose some kind of interface
    to program several general-purpose timers for the program to be able to implement
    time-driven operations. Timers in general are very flexible and easy to configure
    and are generally capable of triggering interrupts at regular intervals. The STM32F4
    provides up to 17 timers, each with different characteristics. Timers are in general
    independent from each other, as each of them has its own interrupt line and a
    separate peripheral clock gate. On the STM32F4, for example, these are the steps
    needed to enable the clock source and the interrupt line for timer 2\. The timer
    interface is based on a counter that is incremented or decremented at every tick.
    The interface exposed on this platform is very flexible and supports several features,
    including the selection of a different clock source for input, the possibility
    to concatenate timers, and even the internals of the timer implementation that
    can be programmed. It is possible to configure the timer to count up or down,
    and trigger interrupt events on different values of the internal counter. Timers
    can be one-shot or continuous.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低端微控制器，提供SysTick定时器不是强制性的。某些目标可能没有系统定时器，但它们都暴露了某种类型的接口，以便程序能够实现时间驱动的操作。定时器通常非常灵活且易于配置，并且通常能够以固定间隔触发中断。STM32F4提供了多达17个定时器，每个定时器都有不同的特性。定时器通常相互独立，因为每个定时器都有自己的中断线和单独的外设时钟门。例如，在STM32F4上，启用定时器2的时钟源和中断线的步骤如下。定时器接口基于一个计数器，它在每个滴答时增加或减少。该平台暴露的接口非常灵活，支持多个功能，包括选择不同的时钟源作为输入，将定时器串联的可能性，甚至可以编程的定时器实现内部结构。可以配置定时器向上或向下计数，并在内部计数器的不同值上触发中断事件。定时器可以是单次或连续的。
- en: An abstraction of the `timer` interface can usually be found in support libraries
    provided by the silicon vendor, or in other open source libraries. However, in
    order to understand the interface exposed by the microcontroller, the example
    provided here is once again directly communicating with the peripherals using
    the configuration registers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以在硅供应商提供的支持库中找到对`定时器`接口的抽象，或者在其他开源库中。然而，为了理解微控制器暴露的接口，这里提供的示例再次直接通过配置寄存器与外围设备进行通信。
- en: 'This example mostly uses the default settings for a general-purpose timer on
    the STM32F407\. By default, the counter is increased at every tick, up to its
    automatic reload value, and continuously generates interrupt events on overflow.
    A prescaler value can be set to divide the clock source to increase the range
    of possible intervals. To generate interrupts spread at a constant given interval,
    only a few registers need to be accessed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例主要使用STM32F407上通用定时器的默认设置。默认情况下，计数器在每个滴答时增加，直到其自动重载值，并在溢出时连续生成中断事件。可以设置预分频值来分频时钟源，以增加可能间隔的范围。为了生成以恒定间隔分散的中断，只需要访问几个寄存器：
- en: The **control registers 1** and **2** (**CR1** and **CR2**)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制寄存器1**和**2**（**CR1**和**CR2**）'
- en: The **direct memory access (DMA)/Interrupt enable** **register** (**DIER**)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接内存访问（DMA）/中断使能寄存器**（**DIER**）'
- en: The **status** **register** (**SR**)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态寄存器**（**SR**）'
- en: The **prescaler** **counter** (**PSC**)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预分频计数器**（**PSC**）'
- en: The **auto-reload** **register** (**ARR**)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重载寄存器**（**ARR**）'
- en: 'In general, the offsets for these registers are the same for all the timers
    so that, given the base address, they can be calculated using a macro. In this
    case, only the register for the timer in use is defined:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些寄存器的偏移量对所有定时器都是相同的，因此，给定基本地址，它们可以通过宏来计算。在这种情况下，只定义了正在使用的定时器的寄存器：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, for readability, we define some relevant bit positions in the registers
    that we are going to configure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了提高可读性，我们在将要配置的寄存器中定义了一些相关的位位置：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First of all, we are going to define a service routine. The `timer` interface
    requires us to clear one flag in the status register, to acknowledge the interrupt.
    In this simple case, all we do is increment a local variable so that we can verify
    that the `timer` is being executed by inspecting it in the debugger. We mark the
    `timer2_ticks` variable as `volatile` so that it does not get optimized out by
    the compiler, since it is never used in the code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个服务例程。`timer`接口要求我们在状态寄存器中清除一个标志，以确认中断。在这个简单的例子中，我们只是增加一个局部变量，以便我们可以通过在调试器中检查它来验证`timer`是否正在执行。我们将`timer2_ticks`变量标记为`volatile`，这样编译器就不会将其优化掉，因为它在代码中从未使用过：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The service routine must be associated, by including a pointer to the function
    in the right position within the interrupt vector defined in `startup.c`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 服务例程必须通过在`startup.c`中定义的中断向量中正确位置包含函数指针来关联：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the timer is connected to a different branch in the clock tree, as in this
    case, we need to account for the additional scaling factor between the clock bus
    that feeds the timer and the actual CPU clock frequency, while calculating the
    values for the prescaler and the reload threshold. Timer 2 on STM32F407 is connected
    to the **Advanced Peripheral Bus** (**APB**) bus, which runs at half of the CPU
    frequency.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计时器连接到时钟树中的不同分支，就像这个例子一样，我们需要在计算预分频器和重载阈值时，考虑到时钟总线（为计时器供电）和实际CPU时钟频率之间的额外缩放因子。在STM32F407上，计时器2连接到**高级外设总线**（**APB**）总线，该总线运行在CPU频率的一半。
- en: This initialization is an example of a function that automatically calculates
    `TIM2_PSC` and `TIM2_ARR` values and initializes a timer based on the given interval,
    expressed in milliseconds. The clock variable must be set to the frequency of
    the clock source for the timer, which may differ from the CPU frequency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化是一个函数示例，该函数自动计算`TIM2_PSC`和`TIM2_ARR`值，并根据给定的毫秒数间隔初始化计时器。时钟变量必须设置为计时器时钟源的频率，这可能与CPU频率不同。
- en: 'The following definitions are specific to our platform, mapping the address
    for the clock gating configuration and the interrupt number of the device we want
    to use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义仅适用于我们的平台，将时钟门控配置的地址和我们要使用的设备的中断号映射：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here is the function to invoke from `main` to enable a continuous timer
    interrupt at the desired interval:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`main`函数中调用的函数，用于在期望的间隔内启用连续的计时器中断：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The example presented here is only one of the possible applications of system
    timers. On the reference platform, timers can be used for different purposes,
    such as measuring intervals between pulses, synchronizing with each other, or
    activating signals periodically, given a chosen frequency and duty cycle. This
    last usage will be explained in the *PWM* subsection later in this chapter. For
    all other uses of generic timers on the target, please refer to the reference
    manual of the microcontroller in use. Now that our system is configured and ready
    to run, and we have learned how to manage time and generate synchronous events,
    it is finally time to introduce our first peripherals to start communicating with
    the outside world. In the next section, we will introduce GPIO lines in their
    multiple configurations, which allow driving or sensing a voltage on single microcontroller
    pins.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的示例只是系统定时器可能应用的一种可能。在参考平台上，定时器可用于不同的目的，例如测量脉冲之间的间隔、相互同步或根据选择的频率和占空比定期激活信号。这种最后一种用法将在本章后面的*PWM*小节中解释。对于目标上通用定时器的所有其他用途，请参阅所使用微控制器的参考手册。现在，我们的系统已配置就绪，可以运行，并且我们已经学会了如何管理时间和生成同步事件，现在是时候介绍我们的第一个外设，开始与外部世界通信了。在下一节中，我们将介绍GPIO引脚的多种配置，这些配置允许驱动或感应单个微控制器引脚上的电压。
- en: GPIO
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO
- en: The majority of the pins of a microcontroller chip represent configurable I/O
    lines. Each pin can be configured to represent a logic level by driving the voltage
    of the pin as a digital output or to sense the logic state by comparing the voltage
    as a digital input. Some of the generic pins, though, can be associated with alternate
    functions, such as analog input, a serial interface, or the output pulse from
    a timer. Pins may have several possible configurations, but only one is activated
    at a time. The GPIO controller exposes the configuration of all the pins and manages
    the association of the pins with the subsystems when alternate functions are in
    use.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数微控制器芯片的引脚代表可配置的 I/O 线。每个引脚都可以配置为通过驱动引脚的电压作为数字输出来表示逻辑电平，或者通过比较电压作为数字输入来感知逻辑状态。尽管如此，一些通用引脚可以与替代功能相关联，例如模拟输入、串行接口或计时器的输出脉冲。引脚可能有几种可能的配置，但一次只能激活一个。GPIO
    控制器公开所有引脚的配置，并在使用替代功能时管理引脚与子系统的关联。
- en: Pin configuration
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引脚配置
- en: Depending on the logic of the GPIO controller, the pins can be activated all
    together, separately, or in groups. In order to implement a driver to set up the
    pins and use them as needed, it is possible to refer to the datasheet of the microcontroller
    or any example implementation provided by the silicon vendor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 GPIO 控制器的逻辑，引脚可以全部激活、单独激活或分组激活。为了实现设置引脚并按需使用它们的驱动程序，可以参考微控制器的数据手册或硅供应商提供的任何示例实现。
- en: 'In the case of the STM32F4, GPIO pins are divided into groups. Each group is
    connected to a separate clock gate, so, to use the pins associated with a group,
    the clock gate must be enabled. The following code will distribute the clock source
    to the GPIO controller for the group `D`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STM32F4 的情况下，GPIO 引脚被分为组。每个组连接到一个单独的时钟门，因此，要使用与组关联的引脚，必须启用时钟门。以下代码将时钟源分配给组
    `D` 的 GPIO 控制器：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The configuration registers associated with the GPIO controllers are mapped
    to a specific area in the peripherals region as well. In the case of the `GPIOD`
    controller, the base address is at `0x40020C00`. On the STM32F4 microcontrollers,
    there are 10 different registers for configuring and using each digital I/O group.
    As groups are composed of at most 16 pins, some registers may use a representation
    of 2 bits per pin:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GPIO 控制器关联的配置寄存器映射到外设区域中的特定区域。对于 `GPIOD` 控制器，基本地址为 `0x40020C00`。在 STM32F4
    微控制器上，有 10 个不同的寄存器用于配置和使用每个数字 I/O 组。由于组最多由 16 个引脚组成，一些寄存器可能使用每引脚 2 位的表示：
- en: Mode register (offset `0` in the address space) selects the mode (among digital
    input, digital output, alternate function, or analog input), using 2 bits per
    pin
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式寄存器（地址空间中的偏移量 `0`）选择模式（在数字输入、数字输出、替代功能或模拟输入之间），每引脚使用 2 位
- en: Output type register (offset `4`) selects the output signal driving logic (push-pull
    or open-drain)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出类型寄存器（偏移量 `4`）选择输出信号驱动逻辑（推挽或开漏）
- en: Output speed register (offset `8`) selects output drive speed
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出速度寄存器（偏移量 `8`）选择输出驱动速度
- en: Pull-up register (offset `12`) enables or disables the internal pull-up or pull-down
    resistor
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉起寄存器（偏移量 `12`）启用或禁用内部上拉或下拉电阻
- en: Port input data (offset `16`) is used to read the state of a digital input pin
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口输入数据（偏移量 `16`）用于读取数字输入引脚的状态
- en: Port output data (offset `20`) containing the current value of the digital output
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口输出数据（偏移量 `20`）包含数字输出的当前值
- en: Port bit set/reset (offset `24`) used to drive a digital output signal high
    or low
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口位设置/重置（偏移量 `24`）用于驱动数字输出信号高或低
- en: Port configuration lock (offset `28`)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口配置锁定（偏移量 `28`）
- en: Alternate function low bit register (offset `32`), 4 bits per pin, pins 0-7
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代功能低位寄存器（偏移量 `32`），每引脚 4 位，引脚 0-7
- en: Alternate function high bit register (offset `36`), 4 bits per pin, pins 8-15
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代功能高位寄存器（偏移量 `36`），每引脚 4 位，引脚 8-15
- en: The pin must be configured before use, and the clock gating configured to route
    the source clock to the controller for the group. The configurations available
    on this GPIO controller can be better explained by looking at specific examples.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前必须配置引脚，并配置时钟门以将源时钟路由到控制器的组。此 GPIO 控制器上的配置可以通过查看具体示例来更好地解释。
- en: Digital output
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字输出
- en: 'Enabling a digital output is possible by setting the mode to output in the
    mode register bits corresponding to the given pin. To be able to control the level
    of pin D13, which is also connected to an LED on our reference platform, we need
    to access the following registers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模式寄存器中对应于给定引脚的位中将模式设置为输出，可以启用数字输出。为了能够控制连接到我们参考平台上的LED的D13引脚的电平，我们需要访问以下寄存器：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In later examples, alternate functions are used to change the pin assignment.
    The two registers containing the alternate function settings are shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续示例中，使用备用功能来更改引脚分配。包含备用功能设置的寄存器如下所示：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following simple functions are meant to control the output of pin D15 connected
    to the blue LED on the STM32F4\. The main program must call `led_setup` before
    any other function call, in order to configure the pin as output and activate
    the pull-up/pull-down internal resistor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单函数旨在控制连接到STM32F4上的蓝色LED的D15引脚的输出。主程序必须在调用任何其他函数之前调用`led_setup`，以便将引脚配置为输出并激活上拉/下拉内部电阻：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'First, the clock gating is configured to enable the clock source for the `GPIOD`
    controller:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，配置时钟门控以启用`GPIOD`控制器的时钟源：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The mode register is altered to set the mode for GPIO D15 to digital output.
    The operation is done in two steps. Any previous value set in the 2 bits corresponding
    to the position of the pin mode within the register is erased:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模式寄存器被修改以设置GPIO D15的模式为数字输出。此操作分为两步。在寄存器中对应于引脚模式位置的2位中设置的任何先前值都会被清除：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the same position, the value `1` is set, meaning that the pin is now configured
    as digital output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的位置，设置值为`1`，这意味着引脚现在配置为数字输出：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To enable the pull-up and pull-down internal resistors, we do the same. The
    value to set in this case is `2`, corresponding to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用上拉和下拉内部电阻，我们执行相同的操作。在这种情况下要设置的值是`2`，对应以下内容：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the `setup` function is invoked, the application and the interrupt handlers
    can call the functions exported, to set the value of the pin high or low, by acting
    on the bit set/reset register:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`setup`函数之后，应用程序和中断处理程序可以调用导出的函数，通过操作设置/重置寄存器来设置引脚的高电平或低电平值：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The highest half of the `BSRR` is used to reset the pins. Writing `1` in the
    reset register bit drives the pin logic level to low:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`BSRR`的最高半部分用于重置引脚。在重置寄存器位中写入`1`将引脚逻辑电平驱动到低电平：'
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A convenience function is defined, to toggle the LED value from on to off and
    vice versa:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个便利函数，用于在开和关之间切换LED值：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Using the `timer` configured in the previous section, it is possible to run
    a small program that blinks the blue LED on the STM32F407-Discovery. The `led_toggle`
    function can be called from inside the service routine of the `timer` implemented
    in the previous section:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节中配置的`timer`，可以运行一个小程序，闪烁STM32F407-Discovery上的蓝色LED。`led_toggle`函数可以从上一节中实现的`timer`的服务例程内部调用：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the main program, the LED driver must be initialized before starting the
    timer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，在启动定时器之前必须初始化LED驱动器：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The main loop of the program is empty. The `led_toggle` action is invoked every
    second to blink the LED.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主循环为空。每秒调用一次`led_toggle`操作来闪烁LED。
- en: PWM
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PWM
- en: '**Pulse Width Modulation**, or **PWM** for brevity, is a commonly used technique
    to control different types of actuators, encode messages into signals with different
    pulse duration, and, in general, generate pulses with fixed frequency and variable
    duty cycles on digital output lines for different purposes.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉冲宽度调制**，或简称**PWM**，是一种常用的技术，用于控制不同类型的执行器，将消息编码到具有不同脉冲宽度的信号中，并且通常在数字输出线上以固定频率和可变占空比生成脉冲，用于不同的目的。'
- en: The `timer` interface may allow associating pins to output a PWM signal. On
    our reference microcontroller, four output compare channels can be associated
    with general-purpose timers, and the pins connected to the OC channels may be
    configured to output the encoded output automatically. On the STM32F407-Discovery
    board, the blue LED pin PD15, used in the previous example to demonstrate digital
    output functionality, is associated with the OC4 that can be driven by timer 4\.
    According to the chip documentation, selecting the alternate function 2 for the
    pin directly connects the output pin to OC4.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer`接口可能允许将引脚关联到输出PWM信号。在我们的参考微控制器上，四个输出比较通道可以与通用定时器关联，连接到OC通道的引脚可以配置为自动输出编码输出。在STM32F407-Discovery板上，用于演示数字输出功能的先前示例中的蓝色LED引脚PD15，与可以由定时器4驱动的OC4关联。根据芯片文档，选择引脚的备用功能2直接将输出引脚连接到OC4。'
- en: 'The following diagram shows the pin configuration to use alternate function
    2 to connect it to the output of the timer:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了使用备用功能2将引脚连接到定时器输出的引脚配置：
- en: '![Figure 6.1 – Configuring pin D15 to use alternate function 2 connects it
    to the output of the timer](img/B18730_06_01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 配置引脚D15使用备用功能2将其连接到定时器的输出](img/B18730_06_01.jpg)'
- en: Figure 6.1 – Configuring pin D15 to use alternate function 2 connects it to
    the output of the timer
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 配置引脚D15使用备用功能2将其连接到定时器的输出
- en: 'The pin is initialized, and set to use the alternate configuration instead
    of the plain digital output, by clearing the `MODE` register bits and setting
    the value to `2`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚被初始化，并设置为使用备用配置而不是普通数字输出，通过清除`MODE`寄存器位并将值设置为`2`：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Pins from 0 to 7 in this GPIO group use 4 bits each in the AFL register of
    the `GPIOD` controller. Higher pins, in the range 8-15, use 4 bits each in the
    AFH register. Once the alternate mode is selected, the right alternate function
    number is programmed into the 4 bits associated with pin 15, so we are using the
    AFH register in this case:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本GPIO组中的引脚0到7在`GPIOD`控制器的AFL寄存器中每个使用4位。更高位的引脚，在8-15范围内，在AFH寄存器中每个使用4位。一旦选择了备用模式，正确的备用功能号被编程到与引脚15关联的4位中，因此在这种情况下我们使用AFH寄存器：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `pwm_led_init()` function, which we can call from the main program to configure
    the LED pin PD15, will look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwm_led_init()`函数，我们可以从主程序中调用它来配置LED引脚PD15，将如下所示：'
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The function that sets up the timer for PWM generation is similar to the one
    used in the simple interrupt-generating timer in the digital output example, except
    that configuring the timer to output a PWM involves modifying the value of four
    additional registers:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 设置定时器以生成PWM的函数与数字输出示例中使用的简单中断生成定时器中的函数类似，除了配置定时器以输出PWM需要修改四个额外的寄存器值：
- en: The **capture/compare enable** **register** (**CCER**)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获/比较使能** **寄存器** (**CCER**)'
- en: The **capture/compare mode registers 1** and **2** (**CCMR1** and **CCMR2**)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获/比较模式寄存器1** 和 **2** (**CCMR1** 和 **CCMR2**)'
- en: The **capture channel 4** (**CC4**) configuration
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获通道4** (**CC4**) 配置'
- en: 'The signature of the function we will use in the example to configure a PWM
    with the given duty cycle has the following signature:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例中用于配置给定占空比的PWM函数的签名如下：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Enabling the clock gate to turn on timer 4 is still required:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 启用时钟门控以打开定时器4仍然是必需的：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Both the timer and its output compare channels are temporarily disabled to
    start the configuration from a clean slate:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器和其输出比较通道暂时禁用，以便从干净的状态开始配置：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For this example, we can use a fixed PWM frequency of 100 kHz, by setting the
    automatic reload value to `1`/`100000` of the input clock, and enforcing no use
    of the prescaler:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例，我们可以使用固定的PWM频率100 kHz，通过将自动重载值设置为输入时钟的`1`/`100000`，并强制不使用预分频器：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The duty cycle is calculated according to the value that is passed as a second
    parameter to `pwm_init()`, expressed as a percentage. To calculate the corresponding
    threshold level, this simple formula is used so that, for example, a value of
    80 means that the PWM will be active for 4/5 of the time. The resultant value
    is decremented by one, only if not zero to avoid underflow:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 负载周期是根据传递给`pwm_init()`函数的第二个参数的值计算的，该值以百分比表示。为了计算相应的阈值水平，使用以下简单公式，例如，值为80表示PWM将在4/5的时间内处于活动状态。结果值减去1，除非为零，以避免下溢：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Comparator value register `CCR4`, and auto-reload value register `ARR`, are
    set accordingly. Also, in this case, the value of ARR is decreased by 1, to account
    for the zero-based counter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 比较器值寄存器`CCR4`和自动重载值寄存器`ARR`相应设置。此外，在这种情况下，`ARR`的值减少1，以考虑基于零的计数器：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to correctly set up a PWM signal on this platform, we first ensure
    that the portions of the `CCMR1` register we are going to configure are correctly
    cleared. This includes the capture selection and the mode configuration:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设置此平台上的PWM信号，我们首先确保我们将要配置的`CCMR1`寄存器部分被正确清除。这包括捕获选择和模式配置：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `PWM1` mode selected is just one of the possible alternate configurations
    that are based on the capture/compare timer. To enable the mode, we set the `PWM1`
    value in `CCMR2`, after clearing the relevant bits of the registers:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的`PWM1`模式是基于捕获/比较定时器的可能交替配置之一。为了启用该模式，我们在清除寄存器相关位后，在`CCMR2`中设置`PWM1`值：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we enable the output comparator OC4\. The timer is then set up to
    automatically reload its stored value every time the counter overflows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启用输出比较器OC4。然后，定时器被设置为在计数器溢出时自动重载其存储的值：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Using a PWM to drive the voltage applied on the LED modifies its brightness,
    according to the configured duty cycle. An example program such as the following
    reduces the brightness of the LED to 50% if compared to that of an LED powered
    by a constant voltage output, such as the one in the digital output example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PWM驱动LED上的电压可以改变其亮度，根据配置的占空比。例如，以下示例程序将LED的亮度降低到50%，与由恒定电压输出供电的LED相比，例如数字输出示例中的LED：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The effect of the PWM on the LED brightness can be better visualized by dynamically
    altering the duty cycle. It is possible, for example, to set up a second timer
    to generate an interrupt every 50 ms. In the interrupt handler, the duty cycle
    factor is cycling in the range 0-80% and back, using 16 steps. In the first 8
    steps, the duty cycle is increased by 10% at every interrupt, from 0 to 80%, and
    in the last 8 steps, it is reduced at the same rate, bringing the duty cycle back
    to `0`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态改变占空比，可以更好地可视化PWM对LED亮度的效果。例如，可以设置一个定时器，每隔50毫秒产生一个中断。在中断处理程序中，占空比因子在0-80%的范围内循环，使用16个步骤。在前8个步骤中，每个中断占空比增加10%，从0增加到80%，在最后8个步骤中，以相同的速率减少，将占空比恢复到`0`：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we initialize timer 2 in the main program to trigger interrupts spread over
    constant intervals, as in the previous examples, we can see the LED pulsating,
    rhythmically fading in and out.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在主程序中将定时器2初始化为触发恒定间隔中断，就像前面的示例一样，我们可以看到LED以有节奏的节奏闪烁，明暗交替。
- en: 'In this case, timer 2 is initialized by the main program, and its associated
    interrupt handler updates the settings for timer 4, 20 times per second:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，定时器2由主程序初始化，其关联的中断处理程序每秒更新定时器4的设置20次：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Digital input
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字输入
- en: A GPIO pin configured in input mode detects the logic level of the voltage applied
    to it. The logic value of all the input pins on a GPIO controller can be read
    from the **input data register** (**IDR**). On the reference board, pin A0 is
    connected to the user button, so the status of the button can be read at any time
    while the application is running.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个配置为输入模式的GPIO引脚检测施加在其上的电压的逻辑电平。GPIO控制器上所有输入引脚的逻辑值都可以从**输入数据寄存器**（**IDR**）中读取。在参考板上，引脚A0连接到用户按钮，因此可以在应用程序运行时随时读取按钮的状态。
- en: 'The `GPIOA` controller can be turned on by clock gating:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过时钟门控来开启`GPIOA`控制器：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The controller itself is mapped at address `0x40020000`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器本身映射到地址`0x40020000`：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To set up the pin for input, we only ensure that the mode is set to `0`, by
    clearing the two mode bits relative to pin `0`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置引脚为输入，我们只需确保模式设置为`0`，通过清除与引脚`0`相关的两个模式位：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The application can now check the status of the button at any time by reading
    the lowest bit of the IDR. When the button is pressed, the reference voltage is
    connected to the pin, and the value of the bit corresponding to the pin changes
    from `0` to `1`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可以通过读取IDR的最低位来随时检查按钮的状态。当按钮被按下时，参考电压连接到引脚，对应引脚的位值从`0`变为`1`：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Interrupt-based input
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于中断的输入
- en: Having to proactively read the value of a pin by constantly polling the IDR
    is not convenient in many cases, where the application is supposed to react to
    state changes. Microcontrollers usually provide mechanisms to connect digital
    input pins to interrupt lines so that the application can react in real time to
    events related to the input because the execution is interrupted to execute the
    associated service routine.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，需要通过不断轮询IDR来主动读取引脚值并不方便，尤其是在应用需要响应状态变化时。微控制器通常提供机制将数字输入引脚连接到中断线上，以便应用能够实时响应与输入相关的事件，因为执行被中断以执行相关服务例程。
- en: 'On the reference **microcontroller unit** (**MCU**), pin A0 can be connected
    to the external interrupt and event controller, also known as **EXTI**. EXTI offers
    edge-detection triggers that can be attached to interrupt lines. The number of
    the pin within the GPIO group determines the number of the EXTI interrupt that
    is associated with it so that the EXTI 0 interrupt routine may be connected to
    pin 0 of any GPIO group if needed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考**微控制器单元**（**MCU**）上，引脚A0可以连接到外部中断和事件控制器，也称为**EXTI**。EXTI提供边缘检测触发器，可以附加到中断线上。引脚在GPIO组中的编号决定了与它关联的EXTI中断编号，因此如果需要，EXTI
    0中断例程可以连接到任何GPIO组的引脚0：
- en: '![Figure 6.2 – EXTI0 controller associating edge detection triggers to the
    user button connected to PA0](img/B18730_06_02.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – EXTI0控制器将边缘检测触发器关联到连接到PA0的用户按钮](img/B18730_06_02.jpg)'
- en: Figure 6.2 – EXTI0 controller associating edge detection triggers to the user
    button connected to PA0
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – EXTI0控制器将边缘检测触发器关联到连接到PA0的用户按钮
- en: 'To associate `EXTI_CR`) are located at address `0x40013808`. Each register
    is used to set the interrupt controller associated with an EXTI line. The lowest
    four bits of the first register are relative to EXTI line 0\. The number for the
    GPIO group A is 0, so we need to ensure that the corresponding bits are cleared
    in the first `EXTI_CR` register. The goal of the next example is to demonstrate
    how to enable the `EXTI_CR` register to set the GPIO group A:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTI_CR`寄存器位于地址`0x40013808`。每个寄存器用于设置与EXTI线关联的中断控制器。第一个寄存器的最低四位与EXTI线0相关。GPIO组A的编号为0，因此我们需要确保第一个`EXTI_CR`寄存器中的相应位被清除。下一个示例的目标是演示如何启用`EXTI_CR`寄存器以设置GPIO组A：'
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `EXTI0` interrupt is connected to NVIC line number `6`, so we add this
    definition to configure the NVIC:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTI0`中断连接到NVIC行号`6`，因此我们添加此定义以配置NVIC：'
- en: '[PRE70]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The EXTI controller in STM32F4 microcontrollers is located at address `0x40013C00`,
    and provides the following registers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4微控制器中的EXTI控制器位于地址`0x40013C00`，并提供以下寄存器：
- en: '`0`. Sets/clears the corresponding bit to enable/disable the interrupt for
    each of the EXTI lines.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`. 设置/清除相应的位以启用/禁用每个EXTI线的中断。'
- en: '`4`. Sets/clears the corresponding bit to enable/disable the event trigger
    for the corresponding EXTI line.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`. 设置/清除相应的位以启用/禁用对应EXTI线的触发事件。'
- en: '`8`. Sets the corresponding bit to generate events and interrupts when the
    associated digital input level switches from 0 to 1.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8`. 设置相应的位，当相关的数字输入电平从0切换到1时生成事件和中断。'
- en: '`12`. Sets the corresponding bit to generate events and interrupts when the
    associated signal falls from a logic value of `1` back to `0`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`12`. 设置相应的位，当相关的信号从逻辑值`1`下降回`0`时生成事件和中断。'
- en: '`16`. If a bit is set in this register, the associated interrupt event will
    be immediately generated, and the service routine executed. This mechanism can
    be used to implement custom software interrupts.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`16`. 如果此寄存器中设置了位，则相关的中断事件将立即生成，并执行服务例程。此机制可用于实现自定义软件中断。'
- en: '`20`. To clear a pending interrupt, the service routine should set the bit
    corresponding to the EXTI line, or the interrupt will remain pending. A new service
    routine will be spawned until the PR bit for the EXTI line is cleared.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`20`. 要清除挂起的中断，服务例程应设置对应EXTI线的位，否则中断将保持挂起状态。直到EXTI线的PR位被清除，才会产生新的服务例程。'
- en: 'For convenience, we may define the registers as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们可以定义寄存器如下：
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The procedure to enable the interrupt on the rising edge of PA0, associated
    with the button press, is the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在PA0上升沿触发中断，与按钮按下相关联的步骤如下：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The ISR, IMR, and RTSR corresponding bits have been set, and the interrupt
    has been enabled in the NVIC. Instead of polling for the value of the digital
    input to change, we can now define a service routine that will be invoked every
    time the button is pressed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 已设置ISR、IMR和RTSR对应位，并在NVIC中启用了中断。我们不再需要轮询数字输入值的变化，现在可以定义一个服务例程，每次按钮按下时都会调用它：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this simple example, the `button_presses` counter is expected to increase
    by one at every button press event. In a real-life scenario, buttons based on
    mechanical contact (such as the one on the STM32F407-Discovery) are tricky to
    control using this mechanism. A single physical button press may in fact trigger
    the rising front interrupt multiple times during the transitory phase. This phenomenon,
    known as a button bouncing effect, can be mitigated using specific *debounce*
    techniques, which are not discussed here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，`button_presses`计数器预计在每次按钮按下事件时增加一次。在实际场景中，基于机械接触的按钮（如STM32F407-Discovery上的按钮）使用此机制控制可能很棘手。实际上，单个物理按钮按下可能在过渡阶段触发上升沿中断多次。这种现象称为按钮抖动效应，可以使用特定的*去抖动*技术来减轻，这些技术在此未讨论。
- en: Analog input
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟输入
- en: Some pins have the possibility to measure the applied voltage dynamically and
    assign a discrete number to the measured value, using an **analog-to-digital signal
    converter**, or **ADC**. This is very useful to acquire data from a wide range
    of sensors, capable of conveying the information as output voltage or simply using
    a variable resistor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一些引脚可以动态测量施加的电压，并将一个离散的数字分配给测量的值，使用**模拟-数字信号转换器**，或**ADC**。这对于从广泛范围的传感器获取数据非常有用，这些传感器能够以输出电压或简单地使用可变电阻的形式传递信息。
- en: The configuration of the ADC subsystem may vary significantly across different
    platforms. ADCs on modern microcontrollers offer a wide range of configuration
    options. The reference microcontroller equips 3 separate ADC controllers, sharing
    16 input channels, each one with a resolution of 12 bits. Multiple features are
    available, such as DMA transfer of the acquired data, and monitoring the signals
    in between two watchdog thresholds.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ADC子系统的配置在不同平台上可能会有很大差异。现代微控制器上的ADC提供了广泛的配置选项。参考微控制器配备了3个独立的ADC控制器，共享16个输入通道，每个通道的分辨率为12位。提供了多种功能，例如获取数据的DMA传输和监控两个看门狗阈值之间的信号。
- en: ADC controllers are generally designed to automatically sample input values
    multiple times per second and provide stable results that are immediately available.
    The case we analyze here is simpler and consists of a one-shot read operation
    for a single conversion.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ADC控制器通常设计为每秒自动采样输入值多次，并提供稳定的结果，这些结果立即可用。我们分析的这个案例更简单，它由单次读取操作的单次转换组成。
- en: 'Associating a specific pin to a controller is possible by checking how channels
    are mapped on the controllers if the pin supports it and it is connected through
    a channel to one of the configured as analog input and reading out the value,
    which results from the conversion of the analog signal. In this example, pin B1
    is used as analog input and can be connected to the `ADB1` controller through
    channel `9`. The following constants and registers are defined for the configuration
    of the `ADB1` controller:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引脚支持并且通过通道连接到配置为模拟输入的其中一个，可以通过检查控制器上通道的映射来将特定引脚关联到控制器。在这个例子中，引脚B1用作模拟输入，可以通过通道`9`连接到`ADB1`控制器。以下常量和寄存器被定义为配置`ADB1`控制器：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'These are the definitions to configure GPIO as usual, this time mapped for
    `GPIOB`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是配置GPIO的常规定义，这次映射为`GPIOB`：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The three ADCs share a few registers for common settings, such as the clock
    prescale factor, so they will all operate at the same frequency. The prescale
    factor for the ADC must be set within the working range of the converter recommended
    by the datasheet—in the target platform, halving the frequency of the `APB2` clock
    through the common prescaler. The common ADC configuration registers start at
    port `0x40012300`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模数转换器（ADC）共享一些用于常见设置的寄存器，例如时钟预分频因子，因此它们将以相同的频率运行。ADC的预分频因子必须在数据手册推荐的转换器工作范围内设置——在目标平台上，通过公共预分频器将`APB2`时钟频率减半。公共ADC配置寄存器从端口`0x40012300`开始：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Based on these definitions, the initialization function can be written as follows.
    First, we enable the clock gating for both the ADC controller and the GPIO group:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义，初始化函数可以编写如下。首先，我们启用ADC控制器和GPIO组的时钟门控：
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'PB1 is set to analog input mode, corresponding to the value `3` in the mode
    register:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: PB1设置为模拟输入模式，对应模式寄存器中的值`3`：
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`ADC1` is temporarily switched off to set the desired configuration. The common
    clock prescaler is set to `0`, meaning a divisor of 2 from the input clock. This
    ensures that the frequency fed to the ADC controller is within its operational
    range. Scan mode is disabled, and so is continuous mode, as we are not using these
    features in this example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADC1`暂时关闭以设置所需的配置。公共时钟预分频器设置为`0`，意味着从输入时钟中除以2。这确保了馈送到ADC控制器的频率在其操作范围内。扫描模式被禁用，连续模式也被禁用，因为我们在这个示例中不使用这些功能：'
- en: '[PRE79]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The sampling frequency can be set using the two registers `SMPR1` and `SMPR2`,
    depending on the channel in use. Each register represents one channel sample rate
    using 3 bits per register, so the channels `0` to `9` are configurable using `SMPR1`,
    and all the others through `SMPR2`. The channel for PB1 is set to `9`, so in this
    case, the `SMPR1` register is used, but to remind about this, the generic mechanism
    to set the sample rate on any channel is provided:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两个寄存器`SMPR1`和`SMPR2`，可以根据使用的通道设置采样频率。每个寄存器使用3位表示一个通道的采样率，因此通道`0`到`9`可以使用`SMPR1`进行配置，而所有其他通道则通过`SMPR2`。PB1的通道设置为`9`，因此在这种情况下，使用`SMPR1`寄存器，但为了提醒这一点，提供了在任何通道上设置采样率的通用机制：
- en: '[PRE80]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, the channel is enabled in the conversion sequence of the ADC controller
    using the `SQR3` to `SQR1`. Each source channel is represented in five bits, so
    each register contains up to six sources, except `SQR1`, which stores five, and
    reserves the higher bits to indicate the length of the stack stored in the registers,
    minus one. In our case, there is no need to set the length-minus-one field, as
    it would be zero for a single source in `SQR1`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在ADC控制器的转换序列中启用通道，使用`SQR3`到`SQR1`。每个源通道用五位表示，因此每个寄存器最多包含六个源，除了`SQR1`，它存储五个，并保留高位来指示寄存器中存储的堆栈长度减一。在我们的情况下，不需要设置长度减一字段，因为它对于`SQR1`中的单个源将是零：
- en: '[PRE81]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, the `ADC1` analog converter is enabled again by setting the enable
    bit in the `CR2` control register and the initialization function successfully
    returns:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过设置`CR2`控制寄存器中的使能位，再次启用了`ADC1`模拟转换器，初始化函数成功返回：
- en: '[PRE82]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'After the ADC has been initialized and configured to convert the analog signal
    on PB1, the A/D conversion can be started at any time. A simple blocking read
    function would initiate the conversion, wait for the conversion to be successfully
    started, then wait until the conversion is completed by looking at the **end of
    conversion** (**EOC**) bit in the status register:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在ADC初始化并配置为转换PB1上的模拟信号后，可以随时开始A/D转换。一个简单的阻塞读取函数将启动转换，等待转换成功开始，然后等待转换完成，通过查看状态寄存器中的**转换结束**（**EOC**）位：
- en: '[PRE83]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When the conversion is completed, the corresponding discrete value is available
    on the lowest 12 bits of the data register, and can be returned to the caller:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换完成时，相应的离散值在数据寄存器的最低12位上可用，并且可以被返回给调用者：
- en: '[PRE84]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We have learned how to communicate with the outside world using GPIOs. The same
    GPIO setup and management interface will be useful again in the next chapter to
    configure more complex, local bus interfaces, using the alternate functions for
    the associated GPIO lines.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用GPIO与外界通信。相同的GPIO设置和管理接口将在下一章中再次有用，用于配置更复杂的本地总线接口，使用相关GPIO线的备用功能：
- en: The upcoming section introduces the watchdog, the last of the generic system
    features analyzed in this chapter. Commonly present in several microcontrollers,
    it provides a handy emergency recovery procedure whenever, for any reason, the
    system is frozen and will not resume its normal execution.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分介绍了看门狗，这是本章分析的最后一个通用系统特性。看门狗通常存在于多个微控制器中，它提供了一个方便的紧急恢复程序，无论出于何种原因，当系统冻结且无法恢复其正常执行时。
- en: The watchdog
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看门狗
- en: A common feature in many microcontrollers is the presence of a watchdog timer.
    A watchdog ensures that the system is not stuck within an endless loop or any
    other blocking situation within the code. This is particularly useful in bare-metal
    applications that rely on an event-driven loop, where calls are required not to
    block, and to return to the main event loop within the allowed amount of time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微控制器中常见的功能是存在看门狗定时器。看门狗确保系统不会陷入无限循环或其他代码中的任何阻塞情况。这在依赖于事件驱动的循环的裸机应用程序中特别有用，其中调用要求不阻塞，并在允许的时间内返回到主事件循环。
- en: The watchdog must be seen as the very last resort to recover an unresponsive
    system, by triggering a forced reboot regardless of the current state of execution
    in the CPU.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器必须被视为恢复无响应系统的最后手段，通过触发强制重启，无论CPU当前执行状态如何。
- en: The reference platform provides one independent watchdog timer, with a counter
    similar to those of the generic timers, with a 12-bit granularity and a prescaler
    factor. The prescaler of the watchdog, however, is expressed in multiples of 2
    and has a range between 4 (represented by the value 0) and 256 (value 6).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 参考平台提供了一个独立的看门狗定时器，其计数器与通用定时器类似，具有12位分辨率和预分频因子。然而，看门狗的预分频因子以2的倍数表示，范围在4（由值0表示）到256（值6）之间。
- en: The clock source is connected to a lower-speed oscillator, through an independent
    branch of the clock distribution. For this reason, clock gating is not involved
    in the activation of this peripheral.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟源连接到一个较低速度的振荡器，通过时钟分布的独立分支。因此，时钟门控不涉及此外围设备的激活。
- en: 'The watchdog configuration area is mapped within the peripherals address region,
    and consists of four registers:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗配置区域映射在外围设备地址区域中，由四个寄存器组成：
- en: The key register (offset `0`), used to trigger the three unlock, start, and
    reset operations by writing predefined values in the lowest 16 bits
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键寄存器（偏移量`0`），用于通过在最低16位写入预定义值来触发三个解锁、启动和重置操作
- en: The prescale register (offset `4`), to set the prescale factor of the counter
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预分频寄存器（偏移量`4`），用于设置计数器的预分频因子
- en: The reload register (offset `8`), containing the reload value for the counter
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载寄存器（偏移量`8`），包含计数器的重载值
- en: The status register (offset `12`), providing the status flags to synchronize
    the setup operations
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态寄存器（偏移量`12`），提供状态标志以同步设置操作
- en: 'The registers can be referenced using shortcut macros:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用快捷宏来引用寄存器：
- en: '[PRE85]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The three possible operations that can be triggered via the key register are
    as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键寄存器可以触发的三种可能操作如下：
- en: '[PRE86]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Two meaningful status bits are provided in the status, and they must be checked
    to ensure that the watchdog is not busy before unlocking and setting the value
    for prescale and reload:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 状态中提供了两个有意义的状态位，并且必须检查以确保在解锁和设置预分频和重载值之前看门狗不忙：
- en: '[PRE87]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The initialization function to configure and start the watchdog may look like
    the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化函数用于配置和启动看门狗，可能如下所示：
- en: '[PRE88]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the next line, the input value in milliseconds is scaled to the frequency
    of the watchdog clock, which is 32 kHz:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，以毫秒为单位的输入值缩放到看门狗时钟的频率，该频率为32 kHz：
- en: '[PRE89]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The minimum prescaler factor is 4, however, so the value should be divided
    again. We then look for the minimum prescaler value that results in a counter
    that fits the 12 bits available, by halving the counter value and increasing the
    prescaler factor until the counter is appropriately scaled:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最小预分频因子是4，因此值应该再次除以。然后我们寻找最小的预分频值，使得计数器适合12位，通过将计数器值减半并增加预分频因子，直到计数器适当地缩放：
- en: '[PRE90]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The following checks ensure that the interval provided does not result in a
    zero counter or a value that is too large for the available scaling factor:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下检查确保提供的间隔不会导致计数器为零或值太大，以至于无法适用于可用的缩放因子：
- en: '[PRE91]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The actual initialization of the registers is done, but the device requires
    us to initiate the write with an unlock operation, and only after checking that
    the registers are available for writing:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上已经完成了寄存器的初始化，但设备要求我们通过解锁操作来启动写入，并且只有在检查寄存器可用于写入之后：
- en: '[PRE92]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Starting the watchdog simply consists of setting the `START` command in the
    key register to initiate the start operation:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 启动看门狗简单地说就是将键寄存器中的`START`命令设置为启动操作：
- en: '[PRE93]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Once started, the watchdog cannot be stopped and will run forever, decreasing
    the counter until it reaches zero, and rebooting the system.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，看门狗就无法停止，将一直运行，直到计数器减到零，然后重启系统。
- en: 'The only way to prevent the system from being rebooted is resetting the timer
    manually, an operation often referred to as *kicking the watchdog*. A watchdog
    driver should export a function that allows the application to reset the counter—for
    example, at the end of each iteration in the main loop. Here is ours:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 防止系统重启的唯一方法是通过手动重置计时器，这一操作通常被称为*踢看门狗*。看门狗驱动程序应该导出一个函数，允许应用程序重置计数器——例如，在主循环的每次迭代结束时。以下是我们提供的示例：
- en: '[PRE94]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As a simple test for the watchdog driver, a watchdog counter of 2 seconds can
    be initialized in `main()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对看门狗驱动程序的简单测试，可以在`main()`函数中初始化一个2秒的看门狗计数器：
- en: '[PRE95]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The watchdog is reset upon button press, in the interrupt service routine of
    the GPIO button:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下按钮时，看门狗会在GPIO按钮的中断服务例程中被重置：
- en: '[PRE96]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this test, the system will reboot if the user button is not pressed for 2
    seconds in a row, so the only way to keep the system running is by repeatedly
    pressing the button.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，如果用户按钮连续2秒没有被按下，系统将会重启，因此保持系统运行的唯一方法是通过反复按下按钮。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The clock configuration, timers, and I/O lines are the general-purpose peripherals
    shown in this chapter, commonly supported by a wide range of microcontrollers.
    Although implementation details such as register names and placement may differ
    on other targets, the proposed approach is valid on most embedded platforms, and
    the general-purpose peripherals are the bricks for building the most basic system
    functionalities as well as providing a means of interaction with sensors and actuators.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟配置、计时器和I/O线是本章中展示的通用外设，通常由广泛的微控制器支持。尽管在其他目标上，实现细节如寄存器名称和位置可能有所不同，但提出的方法在大多数嵌入式平台上都是有效的，通用外设是构建最基本系统功能以及与传感器和执行器交互的基石。
- en: In the next chapter, we will focus on serial communication channels provided
    by most microprocessors as communication interfaces toward other devices, and
    peripherals in the proximity of the target system.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注大多数微处理器提供的串行通信通道，作为与其他设备以及目标系统附近的外设的通信接口。
