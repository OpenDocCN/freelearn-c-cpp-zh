- en: Chapter 4. Procedurally Populating Game Environments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。程序化填充游戏环境
- en: Now that we're comfortable using **Random Number Generator** (**RNG**) with
    core C++ data types, let's have a look at how to create a highly randomized environment.
    This will include the random generation and positioning of items, enemies, and
    more. We'll also touch upon random map generation in this chapter before tackling
    it head-on toward the end of the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了使用核心C++数据类型的**随机数生成器**（**RNG**），让我们看看如何创建一个高度随机化的环境。这将包括随机生成和定位物品、敌人等。在本章中，我们还将触及随机地图生成，然后在本书末尾直面挑战。
- en: The way in which objects are spawned will largely depend on the infrastructure
    of your level data. With most 2D games, you'll be able to take an approach that
    is similar, if not identical, to the one demonstrated in this chapter. However,
    a 3D game requires more work because there's an extra dimension to deal with,
    but the principles are still valid.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 物体生成的方式在很大程度上取决于你的级别数据的基础设施。对于大多数2D游戏，你可以采取与本章演示的类似的方法，如果不是完全相同的方法。然而，3D游戏需要更多的工作，因为有一个额外的维度需要处理，但原则仍然是有效的。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Obstacles with procedurally populating an environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序化填充环境时的障碍
- en: Defining the spawn area
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义生成区域
- en: Randomly selecting a game `tile`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择游戏“tile”
- en: Spawning items at a random location
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在随机位置生成物品
- en: Procedurally generating changes to an environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化生成环境的变化
- en: Potential obstacles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 潜在障碍
- en: Generating game environments randomly isn't as simple as it may first appear.
    It's not just a case of generating a random number within the bounds of a level.
    Though this might technically work, there is no control there, and the environment
    that is generated as a result will have many flaws. Objects may overlap, be located
    in unreachable places, or be laid out in a poor order. In order to generate meaningful
    and playable levels there needs to be more control.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成游戏环境并不像看起来那么简单。不仅仅是在级别范围内生成一个随机数。虽然这在技术上可能有效，但那里没有控制，因此生成的环境将有许多缺陷。物体可能重叠，位于无法到达的地方，或者按照不好的顺序布置。为了生成有意义且可玩的级别，需要更多的控制。
- en: Keeping within the bounds of a level
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持在一个级别的范围内
- en: I'm sure that at some point we've all played a game where an item spawned beyond
    our reach. It's infuriating to have that shiny new item just out of reach, but
    this can easily happen when spawning objects randomly around a map. Therefore,
    it's important to establish accurate bounds within which the objects can be spawned.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们都玩过一个物品生成在我们触及不到的地方的游戏。当在地图周围随机生成物体时，物体生成在触及不到的地方是非常令人恼火的。因此，建立准确的边界以内可以生成物体是很重要的。
- en: As you can imagine, the complexity of this task will match the complexity of
    your environment. Thankfully for us, our level is described as a simple 2D array.
    Hence, it's fairly easy to calculate the bounds.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，这项任务的复杂性将与你的环境的复杂性相匹配。对我们来说，我们的级别被描述为一个简单的2D数组。因此，计算边界是相当容易的。
- en: Avoiding overlapping objects
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免物体重叠
- en: Even if you define your level bounds perfectly, you are still not home and dry.
    Environments are generally not empty, and are mostly filled with scenery and other
    game objects. It's important to take these objects into account when choosing
    random spawn coordinates as to not spawn object within them, again pushing items
    out of the reach of the player.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你完美地定义了你的级别边界，你还没有成功。环境通常不是空的，大部分都充满了风景和其他游戏对象。在选择随机生成坐标时，重要的是要考虑这些对象，以免在其中生成对象，再次将物品推出玩家的触及范围之外。
- en: Again, we're not going to have to worry too much about this as we will have
    simple levels with no scenery.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们不必太担心这一点，因为我们将有简单的没有风景的级别。
- en: Creating meaningful levels
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建有意义的级别
- en: After all is said and done, the level has to make sense. Even if we avoid spawning
    items that are beyond the reach of the player, and which don't overlap one another,
    it's no good if they all spawn in one far corner.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 说来话长，级别必须是有意义的。即使我们避免生成玩家无法触及的物品，也不会互相重叠，但如果它们都生成在一个遥远的角落，那也不好。
- en: We need to create suitable parameters within which our RNG operates so we retain
    a suitable level of control over the results. It's one of the major pitfalls of
    procedurally generated games. Time and time again, you will see a level that just
    doesn't make much sense because the algorithm has produced an odd result.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的RNG操作的范围内创建合适的参数，以便我们对结果保持适当的控制。这是程序化生成游戏的一个主要陷阱。一次又一次，你会看到一个级别并不合理，因为算法产生了一个奇怪的结果。
- en: Level tiles
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别瓦片
- en: 'Before we start working with a `level` grid, we need to know how it is set
    up! Our `level` is described as a 2D array of a custom type `Tile`, a `struct`
    defined in `Level.h`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用“级别”网格之前，我们需要知道它是如何设置的！我们的“级别”被描述为一个自定义类型“Tile”的2D数组，这是在“Level.h”中定义的一个“struct”：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Don''t worry about the final four values at this point; we''ll use them later
    when we get to the section on path finding! For now, we just need to know that
    each `tile` struct stores its type, position in the 2D array, and its sprite.
    All the possible `tile` types are defined in an enumerator in `Util.h`, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心最后四个值；当我们到达寻路部分时，我们会在稍后使用它们！现在，我们只需要知道每个“tile”结构存储其类型，在2D数组中的位置和其精灵。所有可能的“tile”类型都在“Util.h”中的枚举器中定义，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This gives every `tile` type a string constant. So, instead of working with
    vague numbers, we can work with these values instead. With this sorted, let's
    get started.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这给每个“tile”类型一个字符串常量。因此，我们可以使用这些值而不是使用模糊的数字。有了这个，让我们开始吧。
- en: Defining the spawn area
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义生成区域
- en: Now we know what obstacles lie ahead, and how the level data is stored, let's
    take a look at how we can spawn items at random locations in our `roguelike` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了前方的障碍，以及级别数据是如何存储的，让我们看看如何在我们的“roguelike”对象中随机生成物品的位置。
- en: Calculating the level bounds
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算级别边界
- en: The first step is to calculate the level bounds. Since we're making a 2D `roguelike`
    object, described in a 2D array, we need to identify the tiles that are suitable
    to spawn items on. If this was done for a 3D game, you would also have to take
    into account the third axis. Though we could just find the top left point of the
    map and calculate the distance to the bottom right, this would almost certainly
    cause problems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是计算级别边界。由于我们正在制作一个2D`roguelike`对象，描述为一个2D数组，我们需要确定适合生成物品的tile。如果这是为了一个3D游戏，你还需要考虑第三个轴。虽然我们可以找到地图的左上角点并计算到右下角的距离，但这几乎肯定会引起问题。
- en: 'We mentioned earlier that it''s important that items are spawned within valid
    level areas. If we take this simple approach, we run the risk of spawning items
    in the walls. The following pseudocode shows how this can be achieved:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，重要的是物品生成在有效的级别区域内。如果我们采用这种简单的方法，就有可能在墙壁上生成物品。以下伪代码显示了如何实现这一点：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the spawn area if we use this simple approach
    in the game:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在游戏中使用这种简单的方法，下面的截图显示了生成区域：
- en: '![Calculating the level bounds](img/B04920_04_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![计算级别边界](img/B04920_04_01.jpg)'
- en: As we can see, the spawn area that was created exceeds the playable level area,
    even though it is technically within the level bounds.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，所创建的生成区域超出了可玩级别区域，尽管它在技术上是在级别边界内。
- en: Checking the underlying game grid
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查底层游戏网格
- en: 'The easiest way to do this in our case is by checking the underlying game grid.
    Since each floor tile in the level grid has a unique tile type that denotes what
    kind of tile it is, we can iterate over the level grid and only mark the tiles
    with a valid type as possible spawn locations. The previous pseudocode has been
    modified and updated in the following way to make this check:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，最简单的方法是检查底层游戏网格。由于级别网格中的每个地板tile都有一个唯一的tile类型，表示它是什么类型的tile，我们可以遍历级别网格，并只标记具有有效类型的tile作为可能的生成位置。前面的伪代码已经被修改和更新，以便进行这个检查：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we ran a check like this, we would end up with the following possible spawn
    area:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行这样的检查，我们最终会得到以下可能的生成区域：
- en: '![Checking the underlying game grid](img/B04920_04_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![检查底层游戏网格](img/B04920_04_02.jpg)'
- en: As you can see, this is a much better area to spawn items. The next step is
    to choose a point within this area as the spawn location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个更好的生成物品区域。下一步是在这个区域内选择一个点作为生成位置。
- en: Selecting a suitable game tile
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个合适的游戏tile
- en: Now, to find suitable tiles, we will generate random spawn coordinates. We know
    that all tiles with the `TILE::FLOOR` or `TILE::FLOOR_ALT` type are floor tiles.
    Therefore, we can select a tile at random and deduce if it's suitable for the
    spawning of an item.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了找到合适的tile，我们将生成随机的生成坐标。我们知道所有具有`TILE::FLOOR`或`TILE::FLOOR_ALT`类型的tile都是地板tile。因此，我们可以随机选择一个tile，并推断它是否适合生成物品。
- en: To avoid having to do these checks ourselves, the project provides the `Level::IsFloor`
    function. It is quite self-explanatory; you can pass it a tile, or the indices
    of one, and it will return true if it's a floor tile. We'll use that from now
    on to check whether the tiles are valid for spawning an item.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免自己进行这些检查，项目提供了`Level::IsFloor`函数。它相当不言自明；你可以传递一个tile或其索引，如果它是一个地板tile，它将返回true。从现在开始，我们将使用它来检查生成物品的tile是否有效。
- en: Randomly selecting a tile
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机选择一个tile
- en: The first function that we'll look at is choosing a value from an underlying
    grid. In our case, the level data is described in a 2D array. Therefore, we simply
    need to generate a random column and a row index.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看的功能是从底层网格中选择一个值。在我们的情况下，级别数据是用2D数组描述的。因此，我们只需要生成一个随机列和一个行索引。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that this range is the number of rows and columns - 1 as all indices
    start from 0\. If we have a grid with 10 rows and columns, then they are numbered
    0 to 9, and the total is 10.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个范围是行数和列数-1，因为所有索引都从0开始。如果我们有一个有10行和10列的网格，那么它们的编号是0到9，总共是10。
- en: 'Here is some pseudocode to generate a random index for a 2D array with 10 rows
    and 10 columns:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些伪代码，用于生成一个具有10行和10列的2D数组的随机索引：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To get the `Tile` object from the level, we just need to call the `Level::GetTile`
    function and pass the randomly generated indices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要从级别中获取`Tile`对象，我们只需要调用`Level::GetTile`函数并传递随机生成的索引。
- en: Checking whether a tile is suitable
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查一个tile是否合适
- en: 'To check whether a `tile` is valid, we can use the `Level::IsFloor` function
    that we had a look at earlier. The following pseudocode will achieve this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个`tile`是否有效，我们可以使用之前看过的`Level::IsFloor`函数。以下伪代码将实现这一点：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Converting to absolute position
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为绝对位置
- en: Now that we can choose a valid `tile` in the game grid, we need to convert that
    position to an absolute screen position. To convert indices into a position that
    is relative to the grid, we simply need to multiply them by the width of a tile
    in the game. In our case, the tiles have a size of 50 square pixels. For example,
    if we're at location `[1][6]` in the grid, the position relative to the grid will
    be 50*300.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在游戏网格中选择一个有效的`tile`，我们需要将该位置转换为绝对屏幕位置。要将索引转换为相对于网格的位置，我们只需要将它们乘以游戏中一个tile的宽度。在我们的情况下，tile的大小是50个方形像素。例如，如果我们在网格中的位置是`[1][6]`，相对于网格的位置将是50*300。
- en: Now we just need to add the location of the grid to these values, making them
    absolute coordinated relative to our window. The practice of converting a grid
    position to an absolute position will come in handy. So let's encapsulate the
    behavior in its own function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将网格的位置添加到这些值中，使它们成为相对于我们窗口的绝对坐标。将网格位置转换为绝对位置的做法将会派上用场。所以让我们将这种行为封装在自己的函数中。
- en: 'In `Level.h`, add the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Level.h`中，添加以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Level.cpp`, add the following definition of a function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Level.cpp`中，添加以下函数的定义：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Spawning items at a random location
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在随机位置生成物品
- en: 'Now, let''s tie all of this together to spawn items randomly in the map. Here
    is a quick overview of the steps that we''ll take:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有这些内容联系起来，在地图中随机生成物品。以下是我们将采取的步骤的快速概述：
- en: Select a random `tile` from the **level** data.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**level**数据中选择一个随机“瓷砖”。
- en: Check whether this tile is a `floor` tile. If not, go to step 1.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这个瓷砖是否是“地板”瓷砖。如果不是，返回到步骤1。
- en: Convert the tile location to the absolute position and give it to the item.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将瓷砖位置转换为绝对位置并将其提供给物品。
- en: 'The first step is to select a random tile in the **level** data. Earlier in
    this chapter, we covered how we''ll achieve this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在**level**数据中选择一个随机瓷砖。在本章的前面，我们已经介绍了如何实现这一点：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to check whether the randomly selected tile is suitable for the
    spawning of an item. We know that we can do this by checking the type of the tile,
    but we need to incorporate this into some kind of loop, so that if the randomly
    selected tile is unsuitable, it will try again. To accomplish this, we''ll wrap
    the random tile selection code inside a `while` statement, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要检查随机选择的瓷砖是否适合生成物品。我们知道可以通过检查瓷砖的类型来做到这一点，但我们需要将其纳入某种循环中，以便如果随机选择的瓷砖不合适，它将再次尝试。为了实现这一点，我们将随机选择瓷砖的代码包装在一个`while`语句中，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's worth noting that having a while loop here will not be suitable for all
    game types. In our game, there is more area where an item can be spawned as compared
    to the area where it can't be spawned. Therefore, a valid location can be easily
    found. If this is not the case and a suitable spawn location is scarce, then a
    while loop may hold the game up indefinitely, as it is looped to find the area.
    Use the `while` statements with extreme caution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在这里使用while循环并不适合所有类型的游戏。在我们的游戏中，可以生成物品的区域比不能生成的区域更多。因此，可以很容易地找到有效位置。如果情况不是这样，适合生成位置很少，那么while循环可能会无限期地阻塞游戏，因为它在循环中寻找区域。请极度谨慎地使用while语句。
- en: 'This code now loops until it finds a suitable, but still random, `tile` where
    we can spawn items. This is very useful and will most likely be reused multiple
    times. Therefore, we will create a dedicated function for the code named `Level::GetRandomSpawnLocation`,
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，此代码将循环，直到找到一个合适但仍然随机的“瓷砖”，我们可以在其中生成物品。这非常有用，很可能会被多次重复使用。因此，我们将为该代码创建一个名为`Level::GetRandomSpawnLocation`的专用函数，如下所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, add the following code to the body of the new function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到新函数的主体中：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that at the end of the function we've added a `return` statement. When
    a suitable `tile` is found, we fetch the absolute position using the function
    that we added earlier, and then return the value. We also add a random offset
    to the coordinates of our items so they aren't all fixed to the dead center of
    the `tile` that they lie on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在函数的结尾，我们添加了一个“return”语句。当找到合适的“瓷砖”时，我们使用之前添加的函数获取绝对位置，然后返回该值。我们还对物品的坐标添加了随机偏移量，以便它们不都固定在所在“瓷砖”的中心位置。
- en: We now have a function that will return absolute coordinates for a suitable
    spawn location in the level. Very handy indeed! The final step is to incorporate
    this function in the `Game::PopulateLevel` spawn function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数，它将返回在级别中适合生成位置的绝对坐标。非常方便！最后一步是将此函数合并到`Game::PopulateLevel`生成函数中。
- en: 'Currently, we''ve set the position of the items manually. To make use of the
    new function, simply replace the fixed values with the results of a call to the
    `Level::GetRandomSpawnLocation()` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经手动设置了物品的位置。要使用新函数，只需用`Level::GetRandomSpawnLocation()`函数的结果替换固定值：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, every time we create an item, its location will be generated randomly.
    If we run the game now, we will see that the items are spread through the level
    randomly, but only on the tiles that are valid and which the player can reach:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次创建物品时，其位置将随机生成。如果现在运行游戏，我们将看到物品随机分布在级别中，但只在有效的瓷砖上，玩家可以到达的瓷砖上：
- en: '![Spawning items at a random location](img/B04920_04_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![在随机位置生成物品](img/B04920_04_03.jpg)'
- en: Expanding the spawning system
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展生成系统
- en: In the last chapter, we covered the use of enumerators; we're going to put that
    to good use here. We're going to break the item `spawn` code into its own dedicated
    function. This will give us greater control over how we populate the level. We'll
    also expand this system to include all items and enemies!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了枚举器的使用；我们将在这里充分利用它。我们将把物品“生成”代码分解为自己专用的函数。这将使我们更好地控制如何填充级别。我们还将扩展此系统以包括所有物品和敌人！
- en: Using enumerators to denote an object type
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用枚举器表示对象类型
- en: 'The first step in constructing this system is to look at the items. In `Util.h`,
    all the item types are described in the following enumerator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此系统的第一步是查看物品。在`Util.h`中，所有物品类型都在以下枚举器中描述：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When deciding what items need to be spawned, we will select random values from
    these enumerator values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定生成哪些物品时，我们将从这些枚举值中选择随机值。
- en: Optional parameters
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数
- en: Another technique that we'll utilize in this system is the use of optional parameters.
    By default the function will spawn an item at a random location, but we may sometimes
    wish to override this behavior with a set location. This is achieved by using
    optional parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此系统中，我们将使用的另一种技术是使用可选参数。默认情况下，该函数将在随机位置生成物品，但有时我们可能希望使用固定位置覆盖此行为。这可以通过使用可选参数来实现。
- en: 'Consider the following function declaration:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数声明：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `TestFunction()` function created from this declaration requires spawn coordinates
    that need to be passed. We could just pass an `sf::Vector` value that is equal
    to `{0.f, 0.f}` and ignore these values, but that's a bit messy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从此声明创建的`TestFunction()`函数需要传递需要生成坐标。我们可以只传递等于`{0.f, 0.f}`的`sf::Vector`值并忽略这些值，但这有点混乱。
- en: 'Optional parameters are those that are given a default value in the function
    declaration. If these parameters aren''t provided in the function call, the default
    values are used. Let''s rewrite this same function declaration, this time utilizing
    optional parameters in the following way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数是在函数声明中给定默认值的参数。如果在函数调用中没有提供这些参数，将使用默认值。让我们以以下方式重写相同的函数声明，这次利用可选参数：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Another approach to this is to create two distinct functions. One function takes
    parameters and the other one doesn't; you can give them different names to highlight
    the difference.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建两个不同的函数。一个函数带有参数，另一个函数没有；您可以给它们不同的名称以突出差异。
- en: 'Now, the `position` variable has a default value of `{-1.f, -1.f}`. So, if
    no values are passed with the function call, these defaults will be used. This
    is the behavior that we''re going to need from the spawning functions. So, with
    this in mind, let''s declare a new function named `Game::SpawnItem`, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`position`变量的默认值是`{-1.f, -1.f}`。因此，如果在函数调用中没有传递值，将使用这些默认值。这是我们需要生成函数的行为。因此，考虑到这一点，让我们声明一个名为`Game::SpawnItem`的新函数，如下所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the default values set, we now need to determine whether they should be
    used or not. To check this, we can just evaluate the *x* and *y* values of the
    `position` variable. If *x* and *y* remain at `-1.f`, then we know that the user
    has not overridden them and wants to generate a value randomly. However, if *x*
    and *y* are not `-1.f`, then they have been overridden and we should use them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了默认值后，现在需要确定是否应该使用它们。为了检查这一点，我们只需评估`position`变量的*x*和*y*值。如果*x*和*y*保持为`-1.f`，那么我们知道用户没有覆盖它们，并且希望随机生成值。然而，如果*x*和*y*不是`-1.f`，那么它们已经被覆盖，我们应该使用它们。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I've used `-1.f` as my default parameter as it's an invalid spawn coordinate.
    The default parameter should allow you to easily determine whether they have been
    overwritten.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`-1.f`作为默认参数，因为它是一个无效的生成坐标。默认参数应该让您轻松确定它们是否已被覆盖。
- en: 'The following lines of code will choose a random spawn location:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将选择一个随机的生成位置：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As the `position` variable is optional, both the following function calls are
    now valid:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`position`变量是可选的，以下函数调用都是有效的：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete spawn functions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的生成函数
- en: 'Now, let''s put all of this together and create the `SpawnItem()` function,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把所有这些放在一起，创建`SpawnItem()`函数，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test the new function, we can update the `Game::PopulateLevel` function
    in the following way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试新函数，我们可以以以下方式更新`Game::PopulateLevel`函数：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This may seem like a lot of work for a seemingly small change that does not
    affect the gameplay, but it's an important one. Software should be built in such
    a way that it is easily maintainable and scalable. Now that this system is in
    place, we can spawn an item with a single function call. Spot on!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是为了一个看似不影响游戏玩法的小改变而做了很多工作，但这是重要的。软件应该以易于维护和可扩展的方式构建。现在这个系统已经建立，我们可以通过一个函数调用生成一个物品。太棒了！
- en: 'A quick run of the game confirms that the code is working as intended, and
    we''ve taken a big step towards an entirely procedurally populated environment,
    as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的快速运行确认了代码按预期工作，并且我们迈出了朝着完全程序化的环境迈出了一大步，如下截图所示：
- en: '![The complete spawn functions](img/B04920_04_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![完整的生成函数](img/B04920_04_04.jpg)'
- en: Updating the spawn code
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新生成代码
- en: 'Now that the `Game::SpawnItem` function is up and running, let''s refactor
    the `Game::PopulatelLevel` function a little. In `Game.h`, let''s declare the
    following static `const`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Game::SpawnItem`函数已经启动运行，让我们稍微重构一下`Game::PopulatelLevel`函数。在`Game.h`中，让我们声明以下静态`const`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Instead of hard-coding the limit of the `for` loop, we can instead use this
    constant. The purpose of this is to remove all hard-coded values from the code.
    If we hard-code a value here instead of using a `const`, every time we want to
    change the value we will have to do so manually. This is both time-consuming and
    prone to errors. With a `const`, we can simply change its value, and this will
    affect every instance in which it's used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个常量来代替`for`循环的硬编码限制。这样做的目的是从代码中删除所有硬编码的值。如果我们在这里硬编码一个值而不使用`const`，每次想要更改值时都必须手动更改。这既耗时又容易出错。使用`const`，我们只需更改它的值，这将影响到它被使用的每个实例。
- en: 'We can also tidy up some variables now that we''re comfortable with what the
    function is doing, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了函数的功能，可以整理一些变量，如下所示：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this tidied up, we can now extend this approach to spawning enemies into
    the level!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 整理好了这些，现在我们可以将这种方法扩展到生成敌人到关卡中！
- en: Randomly spawning enemies
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机生成敌人
- en: 'Now that we can spawn items into the game, let''s take this same system and
    use it to spawn in enemies! We''ll start by defining a `Game::SpawnEnemy` function,
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成游戏中的物品，让我们使用相同的系统来生成敌人！我们将首先定义一个`Game::SpawnEnemy`函数，如下所示：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, declare another static `const` to cap the maximum number of enemies that
    we can spawn:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，声明另一个静态`const`来限制我们可以生成的敌人的最大数量：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this declared, we can now add the function''s definition. It will be much
    like the `Game::SpawnItem` function, only instead of switching through the values
    in the item enumerator, we''ll create enemies that are defined in the following
    enumerator:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个声明，我们现在可以添加函数的定义。它将类似于`Game::SpawnItem`函数，只是不再通过物品枚举中的值进行切换，而是创建在以下枚举中定义的敌人：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s add this definition:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加这个定义：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, to call this function, we need to jump back to the `Game::Populate` level
    function and add another loop to create enemies in a way that is similar to how
    we created items:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要调用这个函数，我们需要回到`Game::Populate`函数，并添加另一个循环，以类似于创建物品的方式创建敌人：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this in place, items and enemies will be spawned randomly across the level.
    This system is very flexible and easy. To add another item or enemy, we just need
    to add it to the relevant enumerator and add a corresponding `switch` statement.
    This is the kind of flexible approach that is needed when generating procedural
    content and systems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，物品和敌人将在整个级别随机生成。这个系统非常灵活和简单。要添加另一个物品或敌人，我们只需要将其添加到相关的枚举器中，并添加相应的`switch`语句。这是在生成程序内容和系统时所需要的灵活方法。
- en: 'Let''s run the game and have a look at the populated level:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏，看看填充的级别：
- en: '![Randomly spawning enemies](img/B04920_04_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![随机生成敌人](img/B04920_04_05.jpg)'
- en: Spawning random tiles
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机瓷砖
- en: The spawning of environmental features will be covered briefly here as there's
    a whole chapter toward the end of the book that is dedicated to procedurally generating
    the game map. This is our end goal. So, to get started, we'll generate some superficial
    environmental features that will be ready for the random level generation later.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 环境特征的生成将在这里简要介绍，因为本书的最后一章专门讨论了程序生成游戏地图。这是我们的最终目标。因此，为了开始，我们将生成一些表面的环境特征，以备后来随机生成级别。
- en: Adding a new `tile` to the game will greatly increase the diversity of levels.
    One of the problems with procedural generation is that environments can feel too
    unnatural and generic. So this will help avoid that.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的`tile`到游戏中将大大增加级别的多样性。程序生成的一个问题是环境可能会感觉过于不自然和通用。因此，这将有助于避免这种情况。
- en: 'Let''s add the following declaration to `Game.h`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下声明添加到`Game.h`中：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have two parameters in this function. One allows us to specify a `tile` index
    that we would like to spawn, and the second allows us to specify how many. We
    could have skipped the creation of a function and just hard-coded the behavior
    in the `Game::PopulateLevel` function, which would have worked, but couldn't have
    been used for anything else.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个参数。一个允许我们指定我们想要生成的`tile`索引，另一个允许我们指定数量。我们本可以跳过创建一个函数，直接在`Game::PopulateLevel`函数中硬编码行为，这样也可以工作，但不能用于其他用途。
- en: However, with our approach, we can easily reuse the code, specifying the `tile`
    that needs to be used, and the number of tiles that we wish to spawn. If we use
    RNG to determine these values, we gain even more procedural generation and randomness
    in the system. When writing procedural systems, always bear this in mind, and
    avoid using hard-coded values as much as possible. Always create options, even
    if they end up not being used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过我们的方法，我们可以轻松地重用代码，指定需要使用的`tile`和我们希望生成的瓷砖数量。如果我们使用随机数来确定这些值，我们甚至可以在系统中获得更多的程序生成和随机性。在编写程序系统时，始终牢记这一点，并尽量避免使用硬编码的值。即使最终可能不会使用，也要创建选项。
- en: Adding a new game tile
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个新的游戏瓷砖
- en: 'The next step is to add the new `tile` assets in the level object, and the
    `Level::AddTile()`function does just that. In `Game::Initialize`, we''ll make
    a call to this function and add a new `tile`, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在级别对象中添加新的`tile`资源，`Level::AddTile()`函数就是这样做的。在`Game::Initialize`中，我们将调用这个函数并添加一个新的`tile`，如下所示：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function takes two parameters, namely a `path` to a `resource` and the
    `ID` parameter value that the `tile` should have. In this case, we're using the
    `TILE::FLOOR_ALT` value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个参数，即`resource`的`path`和`tile`应该具有的`ID`参数值。在这种情况下，我们使用`TILE::FLOOR_ALT`值。
- en: Choosing a random tile
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个随机瓷砖
- en: If we're going to spawn tiles randomly in the level, we need to first choose
    a random floor tile in the game grid. Luckily, we've already written the code
    to do this; it's in the `Level::GetRandomSpawnLocation()` function. Therefore,
    we can use the code and add it to the new function. We also created a parameter
    for the number of tiles that need to be created. So, we'll wrap up everything
    inside a `for` loop to repeat the process the correct number of times.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在级别中随机生成瓷砖，我们需要首先在游戏网格中选择一个随机的地板瓷砖。幸运的是，我们已经编写了代码来做到这一点；它在`Level::GetRandomSpawnLocation()`函数中。因此，我们可以使用这段代码并将其添加到新的函数中。我们还为需要创建的瓷砖数量创建了一个参数。因此，我们将把所有内容都放在一个`for`循环中，以便正确重复这个过程的次数。
- en: 'Let''s give the function a definition, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个函数一个定义，如下所示：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once we find a `tile` that is a valid `floor` tile, we can update its type to
    that passed in the parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到一个有效的地板瓷砖，我们就可以将其类型更新为传递的类型。
- en: Implementing the SpawnRandomTiles function
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现SpawnRandomTiles函数
- en: 'The very last step is to make a call to `Game::SpawnRandomTiles`. This function
    relies on the level grid that has already been in place. So, we''ll call it at
    the end of the `Game::Initialize` function, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用`Game::SpawnRandomTiles`。这个函数依赖于已经存在的级别网格。因此，我们将在`Game::Initialize`函数的末尾调用它，如下所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I've hard-coded the parameters here, but to make it even more random, you can
    generate random numbers that can be used in their place. I've left this as one
    of the exercises in this chapter!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里硬编码了参数，但为了使它更随机，你可以生成随机数来代替它们。我把这留作本章的一个练习！
- en: 'All that''s left is to now run the game and see our work in action in the following
    screenshot. We can see that where the floor used to be a single tile, there are
    now randomly distributed broken tiles, and we can control both the sprite and
    their amount thanks to the way we architected the function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需运行游戏，看看我们的工作在下面的截图中的效果。我们可以看到，原来地板是单一瓷砖的地方，现在是随机分布的破碎瓷砖，我们可以通过我们设计的函数来控制精灵和它们的数量：
- en: '![Implementing the SpawnRandomTiles function](img/B04920_04_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![实现SpawnRandomTiles函数](img/B04920_04_06.jpg)'
- en: Exercises
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you access your strengths and weaknesses in
    the material covered:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你测试本章内容的知识，这里有一些练习，你应该去做。它们对本书的其余部分并不是必须的，但是做这些练习将帮助你评估自己在所学内容上的优势和劣势：
- en: Add a new item to the game. Then, hook it up to the spawn system so that it
    can be randomly spawned with the existing items.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向游戏中添加一个新物品。然后，将其与生成系统连接起来，以便它可以与现有物品随机生成。
- en: Add your own `tile` to the game. Hook this up to the spawn code and change the
    underlying level grid so that the player cannot move through it.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向游戏中添加你自己的“tile”。将其与生成代码连接起来，并更改底层级别网格，使玩家无法穿过它。
- en: 'Check whether the number of tiles that we created when calling `Game::SpawnRandomTiles()`
    are hard-coded:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在调用`Game::SpawnRandomTiles()`时我们创建的瓦片数量是否是硬编码的：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Use RNG to generate a count during the runtime instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时使用RNG生成一个计数。
- en: Now we have our Game::SpawnItem function, update our enemy item drops to use
    it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了Game::SpawnItem函数，更新我们的敌人物品掉落以使用它。
- en: Since we now have a function to calculate actual tile location, update our torch
    spawn code so we don't do the position calculations ourselves.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在有一个函数来计算实际的瓦片位置，更新我们的火炬生成代码，这样我们就不需要自己进行位置计算了。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we implemented RNG to procedurally generate a suitable spawn
    location in the levels, and we encapsulated this behavior in its own function.
    We then used this to spawn items and enemies around the map at random locations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了RNG来在关卡中以程序方式生成合适的生成位置，并将这一行为封装在自己的函数中。然后我们使用这个函数在地图周围的随机位置生成物品和敌人。
- en: In the next chapter, we're going to look at creating unique, randomized game
    objects. Certain items will be procedurally generated during runtime, meaning
    there will be an almost infinite number of possible combinations. We covered the
    skills and techniques that are used to achieve this in the earlier chapters, so
    it's time to pull it together and build our own procedural system!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论创建独特的、随机生成的游戏对象。在运行时，某些物品将以程序方式生成，这意味着可能会有几乎无限数量的可能组合。在前几章中，我们介绍了用于实现这一点的技能和技术，现在是时候把它们整合起来，建立我们自己的程序系统！
