- en: Chapter 5. Advanced IR Block Transformations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 高级 IR 块转换
- en: In the previous chapter, we have gone through some of the optimizations, which
    were mainly at instruction level. In this chapter, we will look at optimizations
    on block level where we will be optimizing a block of code to a simpler form,
    which makes the code more effective. We will start by looking at how loops are
    represented in LLVM, use the concept of dominance and CFG to optimize loops. We
    will use **Loop Simplification** (`LoopSimplify`)and **Loop Invariant Code Motion**
    optimizations for loop processing. We will then see how a scalar value changes
    during program execution and how the result of this **Scalar Evolution Optimization**
    can be used in other optimizations. Then we will look into how LLVM represents
    its in build functions called as LLVM intrinsics. Finally, we will look into how
    LLVM deals with concepts of parallelism by understanding its approach towards
    vectorization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经介绍了一些优化，这些优化主要在指令级别。在本章中，我们将探讨块级别的优化，我们将优化一段代码到一个更简单的形式，这使得代码更加高效。我们将首先探讨在
    LLVM 中如何表示循环，使用支配关系和CFG来优化循环。我们将使用**循环简化**（`LoopSimplify`）和**循环不变式代码移动**优化来进行循环处理。然后我们将看到标量值在程序执行过程中的变化，以及如何将这种**标量演化优化**的结果用于其他优化。然后我们将探讨
    LLVM 如何表示其内建函数，称为 LLVM 内联函数。最后，我们将探讨 LLVM 通过理解其向量化方法来处理并行概念。
- en: 'In this chapter, we will look into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Loop processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环处理
- en: Scalar evolution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量演化
- en: LLVM intrinsics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 内联函数
- en: Vectorization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量化
- en: Loop processing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环处理
- en: Before getting started with loop processing and optimization, we must have a
    little heads up about the concepts of CFG and dominance information. A CFG is
    the control flow graph of the program that gives a look into how the program may
    be executed through the various basic blocks. By dominance information, we get
    to know about the relation between the various basic blocks in the CFG.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始循环处理和优化之前，我们必须对 CFG 和支配信息的概念有一个初步的了解。CFG 是程序的控制流图，它展示了程序如何通过各种基本块被执行。通过支配信息，我们了解到
    CFG 中各个基本块之间的关系。
- en: In a CFG, we say a node `d` dominates a node `n` if every path (from the input
    towards output) that passes through `n` must also pass through `d`. This is denoted
    by `d -> n`. The graph `G = (V, E)`, where `V` is the set of basic blocks and
    `E` is the dominance relation defined on `V`, is called dominator tree.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CFG 中，我们说节点 `d` 支配节点 `n`，如果通过 `n` 的每条路径（从输入到输出的路径）都必须通过 `d`。这表示为 `d -> n`。图
    `G = (V, E)`，其中 `V` 是基本块的集合，`E` 是定义在 `V` 上的支配关系，被称为支配树。
- en: Let's take an example to show the CFG of a program and the corresponding dominator
    tree.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示程序的控制流图（CFG）和相应的支配树。
- en: 'Put example code here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处放置示例代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CFG for the preceding code looks like the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的 CFG 看起来如下：
- en: '![Loop processing](img/00004.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![循环处理](img/00004.jpeg)'
- en: 'From what you have learned about dominance and dominator trees, the dominator
    tree for the preceding CFG looks something like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从你所学的支配关系和支配树，前一个 CFG 的支配树看起来如下：
- en: '![Loop processing](img/00005.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![循环处理](img/00005.jpeg)'
- en: The first figure shows the CFG of the preceding code and the next figure shows
    the dominator tree for the same CFG. We have numbered each of the CFG components
    and we can see that 2 dominates 3 in the CFG, and 2 also dominates 4, 5, and 6\.
    3 dominates 4, 5, and 6 and is the immediate dominator of these. There is no dominance
    relation between 4 and 5\. 6 is not dominated by 5 because there is another path
    available through 4 and for the same reasons, 4 does not dominate 6.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一幅图显示了前述代码的 CFG，下一幅图显示了相同 CFG 的支配树。我们已经对 CFG 的各个组件进行了编号，我们可以看到在 CFG 中，2支配着3，2也支配着4、5和6。3支配着4、5和6，并且是这些节点的直接支配者。4和5之间没有支配关系。6不是5的支配者，因为存在通过4的另一个路径，同样地，由于同样的原因，4也不支配6。
- en: All the loop optimizations and transformation in LLVM are derived from the `LoopPass`
    class implemented in the `LoopPass.cpp` file located in `lib/Analysis`. The `LPPassManager`
    class is responsible for the handling of all `LoopPasses`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 中的所有循环优化和转换都源自于位于 `lib/Analysis` 目录下的 `LoopPass.cpp` 文件中实现的 `LoopPass`
    类。`LPPassManager` 类负责处理所有的 `LoopPasses`。
- en: 'The most important class to get started with loop processing is the `LoopInfo`
    Class, which is used to identify the natural loops in the code and to know the
    depth of various nodes in the CFG. Natural loops are the cyclic structures in
    a CFG. To define a natural loop in a CFG, we must know what a backedge is: it
    is an edge in the CFG where the source dominates the target. A natural loop can
    be defined by a backedge `a->d` that defines a subgraph of the CFG, where `d`
    is the header node and it contains all other basic blocks that can reach a without
    having to reach `d`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开始处理循环最重要的类是`LoopInfo`类，它用于识别代码中的自然循环以及了解CFG中各种节点的深度。自然循环是CFG中的循环结构。为了在CFG中定义一个自然循环，我们必须知道什么是回边：它是在CFG中源节点支配目标节点的边。一个自然循环可以通过一个回边`a->d`来定义，它定义了CFG的一个子图，其中`d`是头节点，它包含所有可以到达`a`而不必到达`d`的其他基本块。
- en: We can see in the preceding diagram that the backedge `6->2` forms a natural
    loop consisting of the nodes `2`, `3`, `4`, `5`, and `6`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到回边`6->2`形成了一个由节点`2`、`3`、`4`、`5`和`6`组成的自然循环。
- en: The next important step is loop simplification that transforms the loop into
    a canonical form, which includes the insertion of a preheader to the loop, which
    in turn ensures that there is a single entry edge to the loop header from outside
    the loop. It also inserts loop exit blocks, which ensure that all exit blocks
    from the loop have predecessors only from within the loop. These insertion of
    pre-header and exit blocks help in later loop optimizations, such as Loop Independent
    Code Motion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要步骤是将循环简化为规范形式，这包括向循环中插入一个预头节点，这反过来又确保从循环外部只有一个入口边到循环头。它还插入循环退出块，确保所有从循环退出的块只有来自循环内部的先导。这些预头节点和退出块的插入有助于后续的循环优化，例如循环独立代码移动。
- en: Loop Simplification also ensures that the loop will have only one backedge,
    that is if the loop header is having more than two predecessors, (from the pre
    header block and multiple latches to the loop) we adjust only this loop latch.
    One way of doing this is by inserting a new block which is the target of all the
    backedges and make this new block jump to loop header. Let's take a look at how
    a loop looks after **Loop Simplify Pass**. We will be able to see that a preheader
    node is inserted, new exit blocks are created, and there is only one backedge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 循环简化还确保循环只有一个回边，即如果循环头有超过两个先导（从预头节点块和多个锁存器到循环），我们只调整这个循环锁存器。一种实现方式是插入一个新块，这个新块是所有回边的目标，并使这个新块跳转到循环头。让我们看看**循环简化遍历**后循环看起来如何。我们将能够看到插入了一个预头节点，创建了新的退出块，并且只有一个回边。
- en: '![Loop processing](img/00006.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![循环处理](img/00006.jpeg)'
- en: Now, after getting the required information from `LoopInfo` and simplifying
    the loop to a canonical form, we will look into some of the loop optimizations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在从`LoopInfo`获取所需信息并将循环简化为规范形式之后，我们将探讨一些循环优化。
- en: One of the main loop optimizations is **Loop Invariant Code Motion** (**LICM**)
    optimization. This pass tries to remove as much code from the body of the loop
    as possible. The condition for removal of the code is that this piece of code
    is invariant inside the loop, that is the output of this part of code not dependent
    on loop execution and it will remain same in every iteration of the loop. This
    is done by moving this piece of code either in the preheader block or moving the
    code to exit blocks. This pass is implemented in the `lib/TransformsScalar/LICM.cpp`
    file. If we look into the code of the loop, we see it requires `LoopInfo` and
    `LoopSimplify` passes to be run before it. Also, it needs the `AliasAnalysis`
    information. Alias analysis is needed to move loop invariant loads and calls out
    of the loop. If there is no load and call inside the loop that aliases anything
    stored, we can move these out of the loop. This also helps in scalar promotion
    of memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的循环优化之一是**循环不变代码移动**（**LICM**）优化。这个遍历尝试尽可能从循环体中移除代码。移除代码的条件是这段代码在循环内是不变的，即这部分代码的输出不依赖于循环执行，并且它将在循环的每次迭代中保持相同。这是通过将这段代码移动到预头节点块或将代码移动到退出块来实现的。这个遍历在`lib/TransformsScalar/LICM.cpp`文件中实现。如果我们查看循环的代码，我们会看到它需要在运行之前运行`LoopInfo`和`LoopSimplify`遍历。它还需要`AliasAnalysis`信息。别名分析是必要的，以便将循环不变加载和调用移出循环。如果没有加载和调用在循环内部与存储的任何内容别名，我们可以将这些移出循环。这也帮助了内存的标量提升。
- en: Let's look at an example to see how LICM is getting done.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看LICM是如何完成的。
- en: 'Let''s write the testcase in a file `licm.ll`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件 `licm.ll` 中编写这个测试用例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `testcase` has a loop denoted by Loop block in the test code with the loop
    condition being `br i1 %cond`, `label %Exit`, `label %Loop` (Latch part of the
    loop). We can see the `%j` value, which is being used as the induction variable
    is derived after using the phi instruction. Basically, it tells to choose the
    value `0` if the control is coming from the Entry block and `%Val` if the control
    is coming from Loop block. In this, the invariant code can be seen as `%loopinvar
    = mul i32 %i, 17`, as `%loopinvar` value is independent of the iteration of loop
    and depends on the function argument only. So when we run the LICM pass, we expect
    this value to be hoisted out of the loop, thus preventing its computation in every
    iteration of the loop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `testcase` 在测试代码中有一个由 Loop 块表示的循环，循环条件是 `br i1 %cond`，`label %Exit`，`label
    %Loop`（循环的 Latch 部分）。我们可以看到 `%j` 值，它是作为归纳变量被使用的，是在使用 phi 指令之后推导出来的。基本上，它告诉如果控制来自
    Entry 块，则选择值 `0`，如果控制来自 Loop 块，则选择 `%Val`。在这里，不变代码可以看作是 `%loopinvar = mul i32
    %i, 17`，因为 `%loopinvar` 的值不依赖于循环的迭代次数，只依赖于函数参数。所以当我们运行 LICM 过滤器时，我们期望这个值能够从循环中提升出来，从而防止在循环的每次迭代中计算它。
- en: 'Let''s run the `licm` pass and see the output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `licm` 过滤器并查看输出：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see in the output, the calculation `%loopinvar = mul i32 %i, 17` is
    hoisted out of the loop, which is the expected output.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在输出中看到的，计算 `%loopinvar = mul i32 %i, 17` 已经从循环中提升出来，这正是我们期望的输出。
- en: We have many other loop optimizations such as **Loop Rotation**, **Loop Interchange**,
    **Loop Unswitch**, and so on. The source codes for these can be looked under the
    LLVM folder `lib/Transforms/Scalar` to get more understanding about these optimizations.
    In the next section, we will see the concept of scalar evolution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多其他的循环优化，例如**循环旋转**、**循环交换**、**循环展开**等等。这些优化的源代码可以在 LLVM 文件夹 `lib/Transforms/Scalar`
    下找到，以获得对这些优化的更多理解。在下一节中，我们将看到标量演化的概念。
- en: Scalar evolution
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量演化
- en: By scalar evolution, we mean how the value of a scalar changes in a program
    with the execution of code. We look at a particular scalar value and see how it
    is getting derived, what all other elements it is dependent on, whether this is
    known at compile time or not, and what all operations are being performed. We
    need to look into a block of code rather than looking into individual instructions.
    A scalar value is build up from two elements, a variable and an operation of constant
    step. The variable element that builds up this scalar value is unknown at compile
    time and its value can be known at run time only. The other element is the constant
    part. These elements themselves may be recursively broken into other elements
    such as a constant, an unknown value or an arithmetic operation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标量演化，我们指的是一个标量值在程序中随着代码执行而变化的情况。我们查看一个特定的标量值，并观察它是如何被推导出来的，它依赖于哪些其他元素，这些元素是否在编译时已知，以及执行了哪些操作。我们需要查看代码块而不是单个指令。一个标量值由两个元素组成，一个变量和一个常数步长的操作。构建这个标量值的变量元素在编译时是未知的，其值只能在运行时知道。另一个元素是常数部分。这些元素本身可能可以递归地分解成其他元素，例如一个常数、一个未知值或一个算术操作。
- en: The main idea here is to look at complete scalar value containing the unknown
    part at compile time and see how this value will evolve during execution and try
    to use this for optimization. One example is removing a redundant value for which
    the scalar evolution is similar to some other value in the same program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是在编译时查看包含未知部分的完整标量值，并观察这个值在执行过程中的变化，并尝试利用这一点进行优化。一个例子是移除一个与程序中其他某个值具有相似标量演化的冗余值。
- en: In LLVM, we can use scalar evolution to analyze code that contains common integer
    arithmetic operations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，我们可以使用标量演化来分析包含常见整数算术运算的代码。
- en: In LLVM `ScalarEvolution` class is implemented in `include/llvm/Analysis`, which
    is a LLVM pass and can be used analyze scalar expressions in a loop. It is able
    to recognize general induction variables (a variable in loop whose value is a
    function of loop iteration number) and represent them using object of SCEV class,
    which is used to represent analyzed expression in a program. Using this analysis
    trip count and other important analysis can be obtained. This scalar evolution
    analysis is mainly used in induction variable substitution and strength reduction
    of loops.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，`ScalarEvolution` 类在 `include/llvm/Analysis` 中实现，这是一个 LLVM 通过，可以用来分析循环中的标量表达式。它能够识别通用归纳变量（循环中值是迭代次数函数的变量）并使用
    SCEV 类的对象来表示它们，SCEV 类用于表示程序中分析的表达式。使用这种分析可以获得迭代次数和其他重要分析。这种标量演化分析主要用于归纳变量替换和循环强度降低。
- en: Let's take an example now and run the scalar evolution pass on it and see what
    output it generates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们举一个例子，并运行标量演化通过它，看看它生成什么输出。
- en: Write a testcase `scalevl.ll` with a loop and some scalar values within the
    loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个包含循环和一些循环内标量值的测试用例`scalevl.ll`。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this test case, we have a loop consisting of header and body blocks with
    `%a` and `%b` being the scalars in loop body of interest. Let''s run the scalar
    evolution pass on this and see the output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，我们有一个由头和体块组成的循环，其中`%a`和`%b`是感兴趣的循环体内的标量。让我们运行标量演化通过这个，看看输出结果：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we can see, the output of scalar evolution pass shows the range of values
    for a particular variable (`U` stands for unsigned range and `S` for signed range,
    here both are same) and the exit value, the value in that variable when the loop
    runs its last iteration. For example, the value `%i` has the range as `[1,11)`,
    that is the starting iteration value is `1` and when the value of `%i` becomes
    `11` the condition `%cond = icmp eq i32 %i, 10` becomes false and the loop breaks.
    So, the the value of `%i` when it exited the loop was `10`, which is denoted by
    `Exits: 10` in the output.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们所见，标量演化通过输出的范围显示了特定变量（`U`代表无符号范围，`S`代表有符号范围，这里两者相同）的值域以及退出值，即循环运行其最后一次迭代时该变量的值。例如，`%i`的值域为`[1,11)`，这意味着起始迭代值为`1`，当`%i`的值变为`11`时，条件`%cond
    = icmp eq i32 %i, 10`变为假，循环中断。因此，当`%i`退出循环时的值为`10`，这在输出中用`Exits: 10`表示。'
- en: The value in the form of `{x,+,y}` representation, such as `{2,+,1}`, represents
    add recurrence, that is the expressions changing value during loop execution where
    x represents the base value at 0th iteration and y represents the value added
    to it on each subsequent iteration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`{x,+,y}`形式的值，例如`{2,+,1}`，表示加法递归，即在循环执行期间改变值的表达式，其中x代表第0次迭代的基值，y代表在每次后续迭代中添加到它上面的值。'
- en: The output also shows the number of times the loop has iterated after the first
    run. Here, it shows the value `9` for backedge-taken, that is the loop has run
    `10` times in total. The max backedge-taken value is the least value which can
    never be less than the backedge-taken value, which here is `9`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出还显示了循环在第一次运行后的迭代次数。这里，它显示了`9`的值，表示回边取用，即循环总共运行了`10`次。最大回边取用值是永远不会小于回边取用值的最小值，这里为`9`。
- en: This is the output for this example, you can try some other test cases and see
    what this pass outputs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个示例的输出，你可以尝试一些其他的测试用例，看看这个通过会输出什么。
- en: LLVM intrinsics
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM 内置函数
- en: An intrinsic function is a function built in to the compiler. The compiler knows
    how to best implement the functionality in the most optimized way for these functions
    and replaces with a set of machine instruction for a particular backend. Often,
    the code for the function is inserted inline thus avoiding the overhead of function
    call (In many cases, we do call the library function. For example, for the functions
    listed in [http://llvm.org/docs/LangRef.html#standard-c-library-intrinsics](http://llvm.org/docs/LangRef.html#standard-c-library-intrinsics)
    we make a call to `libc`). These are also called built-in functions for other
    compilers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数是编译器内部构建的函数。编译器知道如何以最优化方式实现这些函数的功能，并为特定后端替换成一组机器指令。通常，函数的代码会内联插入，从而避免函数调用的开销（在许多情况下，我们确实调用了库函数。例如，对于列在[http://llvm.org/docs/LangRef.html#standard-c-library-intrinsics](http://llvm.org/docs/LangRef.html#standard-c-library-intrinsics)中的函数，我们调用`libc`）。这些在其他编译器中也被称为内置函数。
- en: In LLVM these intrinsics are introduced during code optimization at IR level
    (Intrinsics written in program code can be emitted through frontend directly).
    These function names will start with a prefix "`llvm.`", which is a reserved word
    in LLVM. These functions are always external and a user cannot specify the body
    for these functions in his/her code. In our code, we can only call these intrinsic
    functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中，这些内建函数在IR级别的代码优化期间引入（程序代码中编写的内建函数可以通过前端直接发出）。这些函数名将以前缀"`llvm.`"开头，这是LLVM中的一个保留词。这些函数始终是外部的，用户不能在其代码中指定这些函数的主体。在我们的代码中，我们只能调用这些内建函数。
- en: In this section, we will not go much deep into details. We will take an example
    and see how LLVM optimizes certain part of code with its own intrinsic functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会深入探讨细节。我们将通过一个示例来了解LLVM如何使用其自身的内建函数优化代码的某些部分。
- en: 'Let''s write a simple code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一段简单的代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now use Clang to generate the IR file. Using the command given below, we will
    get the `intrinsic.ll` file that contains the unoptimized IR without any intrinsic
    function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Clang生成IR文件。使用以下命令，我们将得到包含未优化IR且没有任何内建函数的`intrinsic.ll`文件。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, use the opt tool to optimize the IR with O1 level of optimization.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用opt工具以O1优化级别优化IR。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The important optimization to be noted here is the call to LLVM intrinsic function
    `llvm.memset.p0i8.i64` to fill the array with value `0`. The intrinsic functions
    may be used to implement vectorization and parallelization in the code, leading
    to better code generation. It might call the most optimized version of the `memset`
    call from the `libc` library and may choose to completely omit this function if
    there is no usage of this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要优化是调用LLVM内建函数`llvm.memset.p0i8.i64`以填充数组值为`0`。内建函数可以用于在代码中实现向量化和并行化，从而生成更好的代码。它可能会调用`libc`库中最优化的`memset`调用版本，并且如果没有使用此函数，可能会选择完全省略此函数。
- en: The first argument in the call specifies the array "`a`", that is the destination
    array where the value needs to be filled. The second argument specifies the value
    to be filled. The third argument to the call is specification about number of
    bytes to be filled. The fourth argument specifies the alignment of destination
    value. The last argument is to determine whether this is a volatile operation
    or not.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中的第一个参数指定了数组"`a`"，即需要填充值的目标数组。第二个参数指定了要填充的值。调用中的第三个参数指定了要填充的字节数。第四个参数指定了目标值的对齐方式。最后一个参数用于确定这是一个易失性操作还是非易失性操作。
- en: There is a list of such intrinsic functions in LLVM, a list of which can be
    found at [http://llvm.org/docs/LangRef.html#intrinsic-functions](http://llvm.org/docs/LangRef.html#intrinsic-functions).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中有一系列这样的内建函数，其列表可以在[http://llvm.org/docs/LangRef.html#intrinsic-functions](http://llvm.org/docs/LangRef.html#intrinsic-functions)找到。
- en: Vectorization
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量化
- en: '**Vectorization** is an important optimization for compilers where we can vectorize
    code to execute an instruction on multiple datasets in one go. Advance target
    architecture typically have vector registers set and vector instructions—where
    broad range of data type (typically 128/246 bit) can be loaded into the vector
    registers and operations can be performed on those register set, performing two,
    four, and sometimes eight operations at the same time, with the cost of one scalar
    operation.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量化**是编译器的重要优化手段，我们可以将代码向量化以一次执行多个数据集上的指令。高级目标架构通常具有向量寄存器和向量指令——其中广泛的数据类型（通常是128/256位）可以加载到向量寄存器中，并且可以在这些寄存器集上执行操作，同时执行两个、四个，有时甚至八个操作，其成本与一个标量操作相当。'
- en: There are two types of vectorization in LLVM—**Superword-Level Parallelism**
    (**SLP**) and loop vectorization. Loop vectorization deals with vectorization
    opportunities in a loop, while SLP vectorization deals with vectorizing straight-line
    code in a basic block.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中有两种向量化类型——**超字级并行**（**SLP**）和循环向量化。循环向量化处理循环中的向量化机会，而SLP向量化处理基本块中的直接代码的向量化。
- en: A vector instruction performs **Single-instruction multiple-data** (**SIMD**)
    operations; the same operation on multiple data lanes (in parallel).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向量指令执行**单指令多数据**（**SIMD**）操作；在多个数据通道上并行执行相同的操作。
- en: '![Vectorization](img/00007.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![向量化](img/00007.jpeg)'
- en: Let's look at how SLP Vectorization is implemented in LLVM infrastructure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在LLVM基础设施中实现SLP向量化。
- en: As the code itself attributes, the implementation of SLP Vectorization in LLVM
    is inspired by the work described in the paper *Loop-Aware SLP in GCC* by Ira
    Rosen, Dorit Nuzman, and Ayal Zaks. LLVM SLP Vectorization Pass implements the
    Bottom Up SLP vectorizer. It detects consecutive stores that can be put together
    into vector-stores. Next, it attempts to stores that can be put together into
    vector-stores. Next, it attempts to construct vectorizable tree using the `use-def`
    chains. If a profitable tree was found, the SLP vectorizer performs vectorization
    on the tree.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码本身所描述，LLVM 中 SLP 矢量化实现的灵感来源于 Ira Rosen、Dorit Nuzman 和 Ayal Zaks 在论文 *GCC
    中的循环感知 SLP* 中描述的工作。LLVM SLP 矢量化传递实现自底向上的 SLP 矢量化器。它检测可以组合成向量存储的连续存储操作。接下来，它尝试将存储操作组合成向量存储。然后，它尝试使用
    `use-def` 链构造可矢量化树。如果找到了有利的树，SLP 矢量化器就会在树上执行矢量化。
- en: 'There are three stages to SLP Vectorization:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SLP 矢量化有三个阶段：
- en: Identify the pattern and determine if it is a valid Vectorization pattern
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别模式并确定它是否是有效的矢量化模式
- en: Determine if it is profitable to vectorize the code
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定矢量化代码是否有利可图
- en: If step 1 and 2 are true, then vectorize the code
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果步骤 1 和 2 都成立，那么就矢量化代码
- en: 'Let''s look at an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: Consider addition of `4` consecutive elements of two arrays into third array.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将两个数组的 `4` 个连续元素添加到第三个数组中。
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The IR for the preceding kind of expression will look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种表达式的 IR 将看起来像这样：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The expression tree for the preceding pattern can be visualized as a chain
    of stores and loads:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个模式的表达式树可以可视化为一系列的存储和加载操作：
- en: '![Vectorization](img/00008.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![矢量化](img/00008.jpeg)'
- en: 'For the preceding expression tree, the bottom-up SLP Vectorization first constructs
    a chain that starts with a store instruction:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的表达式树，自底向上的 SLP 矢量化首先构建一个以存储指令开始的链：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It then scans the tree already built in the preceding code for all the stores
    in the given basic block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它扫描前面代码中已经构建的树中的所有给定基本块中的存储操作：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `collectStores()` function collects all the store references.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectStores()` 函数收集所有存储引用。'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function `SLPVectorizer::vectorizeStoreChains()` has three steps and function
    calls to each three steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SLPVectorizer::vectorizeStoreChains()` 函数有三个步骤和对每个步骤的函数调用：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first step is to identify pattern. The function `buildTree()` subsequently
    builds up the tree recursively as the preceding visualization.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是识别模式。函数 `buildTree()` 随后递归地构建树，如前面的可视化所示。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For our given example, it will identify that all the store operations have
    binary addition operations as their operands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的给定例子，它将确定所有存储操作的操作数都是二进制加法操作：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the binary operation `ADD` is encountered, it again recursively builds
    tree (calling the same function) on LHS and RHS operands of the ADD operation,
    which in our case are both `Load`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到二进制运算符 `ADD` 时，它会在 ADD 操作的左右操作数（在我们的情况下都是 `Load`）上递归地构建树（调用相同的函数）：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While building the tree, there are several checks that validate if the tree
    can be vectorized. For example, in the preceding case, when loads are encountered
    across trees, it is checked whether they are consecutive loads or not. In our
    expression tree, the loads across trees in LHS—b[0], b[1], b[2], and b[3] are
    accessing consecutive memory location. Similarly, loads across tress in RHS—c[0],
    c[1], c[2] and c[3] are accessing consecutive memory location. If any of the checks
    fail for a given operation, the building of a tree is aborted and code is not
    vectorized.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建树的过程中，有几个检查来验证树是否可以矢量化。例如，在前面的例子中，当在树之间遇到加载操作时，会检查它们是否是连续加载。在我们的表达式树中，LHS
    中的树之间的加载操作（b[0]、b[1]、b[2] 和 b[3]）正在访问连续的内存位置。同样，RHS 中的树之间的加载操作（c[0]、c[1]、c[2]
    和 c[3]）也在访问连续的内存位置。如果给定的操作中的任何检查失败，则树的构建将被终止，代码不会被矢量化。
- en: 'After the pattern is identified and the vector tree is built, the next step
    is to get the cost of vectorizing the built tree. This effectively refers to the
    cost of the tree if it is vectorized compared to the cost of tree in current scalar
    form. If the vector cost is less than the scalar cost, it is beneficial to vectorize
    the tree:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了模式和构建了向量树之后，下一步是获取构建的树的矢量化成本。这实际上是指如果矢量化，与当前标量形式的树的成本相比的成本。如果矢量化成本低于标量成本，则矢量化树是有益的：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An important interface to focus on here is the **TargetTransformInfo** (**TTI**),
    which provides access to the codegen interfaces that are needed for IR-level transformations.
    In our SLP Vectorization, TTI is used to get the cost of the vector instruction
    of the built vector tree:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要关注的一个重要接口是**TargetTransformInfo**（**TTI**），它提供了访问用于IR级别转换的代码生成接口。在我们的SLP向量化中，TTI用于获取构建的向量树中向量指令的成本：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same function, the cost of vector add is also calculated:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，也计算了向量加法的成本：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In our example, the total cost of the whole expression tree comes out to be
    `-12`, which indicates that it is profitable to vectorize the tree.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，整个表达式树的总成本为`-12`，这表明向量化这棵树是有利可图的。
- en: 'Finally, the tree is vectorized by the function call `R.vectorizeTree()` on
    the tree:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在树上调用函数`R.vectorizeTree()`来对树进行向量化：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Lets see all the steps the Vectorization process follows for our example. Note
    that this will require a '`Debug`' build of the '`opt`' tool.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看向量化过程遵循的所有步骤。注意，这需要`'opt'`工具的`'Debug'`构建版本。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final vectorized output is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的向量化输出是：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we concluded the optimizer part of the compiler where we had
    seen block level optimizations. We took the examples of loop optimization, Scalar
    Evolution, Vectorization, and LLVM Intrinsic functions. We also saw how SLP Vectorization
    is handled in LLVM. However, there are many other such optimizations that you
    can look into and get a hold of.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们总结了编译器的优化部分，其中我们看到了块级优化。我们讨论了循环优化、标量演化、向量化和LLVM内建函数的例子。我们还了解了在LLVM中如何处理SLP向量化。然而，还有许多其他这样的优化你可以去了解并掌握。
- en: In the next chapter, we will see how this IR is converted to **Directed Acyclic
    Graph**. We have some optimizations at `selectionDAG` level as well, which we
    will take a look at.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将这个中间表示（IR）转换为**有向无环图**。在`selectionDAG`级别也有一些优化，我们将对其进行探讨。
