- en: Building the World and Optimizing for VR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建世界并针对VR进行优化
- en: Through the course of our work so far in this book, we've been focused for the
    most part on the player avatar. This makes sense—virtual reality dramatically
    changes the way the player engages with the world. We needed to learn new ways
    of enabling the player to get around, new ways of using their hands to interact
    with the world, and new ways of constructing user interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书迄今为止的工作过程中，我们大部分时间都专注于玩家角色。这是有道理的-虚拟现实极大地改变了玩家与世界互动的方式。我们需要学习新的方法来让玩家四处移动，使用手来与世界互动，以及构建用户界面的新方法。
- en: This is no small achievement, so congratulations for getting this far!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项不小的成就，所以恭喜你走到了这一步！
- en: Now, we're going to shift our focus a bit and begin to look at the environment
    around us. Up to this point, we've been using existing environments, but now it's
    time to begin to build our own. As we do this, we are going to learn that environments
    in VR present challenges that we're going to need to address. Lighting, object
    scale, and sightlines all come into play to a greater degree than they do on the
    flat screen, and performance is a major consideration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要稍微改变一下焦点，开始关注我们周围的环境。到目前为止，我们一直在使用现有的环境，但现在是时候开始建立我们自己的环境了。在这个过程中，我们将会发现VR环境带来了一些需要解决的挑战。光照、物体比例和视线都比平面屏幕更重要，并且性能是一个重要考虑因素。
- en: In this chapter, we're going to learn how to use the tools and techniques at
    our disposal to address these challenges as we build. We'll learn how to use the
    VR editor to lay out our environment from within the headset and see how it's
    actually going to appear in VR as we build it, and we'll learn how to profile
    and optimize these environments to make sure that we can meet our frame rate requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何利用我们手头的工具和技术来解决这些挑战。我们将学习如何使用VR编辑器在头戴式显示器中布置环境，并在构建过程中实际查看其在VR中的外观，还将学习如何对这些环境进行性能分析和优化，以确保我们能够满足帧率要求。
- en: 'In this chapter, we''re going to explore the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Building and lighting a scene using the VR editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VR编辑器构建和照明场景
- en: Profiling the scene to identify performance bottlenecks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对场景进行性能分析以识别瓶颈
- en: Optimizing the scene using static mesh instancing, LODs, mesh combination, and
    lighting changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态网格实例化、LOD、网格组合和光照更改来优化场景
- en: Project settings for optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化的项目设置
- en: Special considerations and technical requirements for mobile VR
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动VR的特殊考虑和技术要求
- en: Let's get to it and give ourselves a place to play.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，给自己一个玩耍的地方。
- en: Setting up the project and collecting assets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目并收集资产
- en: 'For this chapter''s work, let''s create a new project with the following template
    options:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的工作，让我们使用以下模板选项创建一个新项目：
- en: A Blank Blueprint template
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空白的蓝图模板
- en: Targeting Mobile/Tablet hardware
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对移动/平板硬件进行优化
- en: Scalable 2D or 3D
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的2D或3D
- en: No starter content
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有起始内容
- en: 'Once the project has been created, open its Project Settings and set the following menu
    options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，打开其项目设置并设置以下菜单选项：
- en: Project | Description | Settings | Start in VR: True
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 | 描述 | 设置 | 在VR中启动：True
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 正向渲染器 | 正向着色：True
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 环境遮蔽静态分数：False
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: Engine | Rendering | VR | Instanced Stereo: True
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 实例化立体声：True
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 循环轮询遮挡查询：True
- en: Allow the project to restart once all these settings have been set.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有这些设置后，允许项目重新启动。
- en: Once the project has restarted, open the File menu and use it to load the previous
    chapter's project. Just as we did last time, we're going to grab elements that
    we previously created and carry them forward using the Migrate tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目重新启动后，打开文件菜单并使用它加载上一章的项目。就像上次一样，我们将使用迁移工具获取之前创建的元素并将它们带入新项目中。
- en: Migrating blueprints into the new project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将蓝图迁移到新项目中
- en: From your previous project, select BP_VRGameMode from the content explorer,
    right-click it, and select Asset Actions | Migrate. Select your new project's
    `Content` directory as its destination content folder. Because the GameMode references
    BP_VRPawn, and BP_VRPawn references BP_CompanionCharacter, all of these objects
    and their required supporting assets should come across.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的项目中，选择内容资源管理器中的BP_VRGameMode，右键点击它，选择资源操作 | 迁移。将你的新项目的`Content`目录作为目标内容文件夹。因为GameMode引用了BP_VRPawn，而BP_VRPawn引用了BP_CompanionCharacter，所有这些对象及其所需的支持资产都应该被迁移过来。
- en: Once the migration is complete, there's one more thing we need to do. We have
    a few custom inputs set up for our previous project, and we'll need them for our
    new one as well. Navigate to last chapter's project directory and copy the `Config/DefaultInput.ini`
    file to your new project's config directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移完成后，还有一件事情需要做。我们在之前的项目中设置了一些自定义输入，我们在新项目中也需要它们。导航到上一章的项目目录，并将`Config/DefaultInput.ini`文件复制到新项目的配置目录中。
- en: Verifying the migrated content
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证迁移的内容
- en: 'Re-open the new project. The first thing we''re going to want to do here is
    verify that everything we''ve brought across is working correctly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开新项目。这里我们要做的第一件事是验证我们带入的所有内容是否正常工作：
- en: Let's select File | New Level | VR Basic to create a starting VR map.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 新建关卡 | VR基础，创建一个起始的VR地图。
- en: Drop a Nav Mesh Bounds Volume onto the map and make sure it surrounds the floor.
    Setting its Location to (X=0.0, Y=0.0, Z=0.0) and Scale to (X=10.0, Y=10.0, Z=2.0)
    will take care of this. Remember to hit the *P* key to visualize your navmesh
    and make sure it's generating properly.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个导航网格边界体放置在地图上，并确保它围绕着地板。将其位置设置为(X=0.0，Y=0.0，Z=0.0)，将其缩放设置为(X=10.0，Y=10.0，Z=2.0)即可。记得按下“P”键来可视化你的导航网格，并确保它正常生成。
- en: Save this level (we named ours VRModePractice and placed it in `Content/C07/Maps`).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这个关卡（我们将其命名为VRModePractice，并放置在`Content/C07/Maps`中）。
- en: Open Settings | Project Settings | Maps & Modes | Default Modes, and set your
    Default GameMode to the BP_VRGameMode we migrated from the other project. Set
    your Editor Startup Map and Game Default Map to this map, as well.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置|项目设置|地图和模式|默认模式，并将默认游戏模式设置为我们从其他项目迁移的BP_VRGameMode。将编辑器启动地图和游戏默认地图也设置为这个地图。
- en: Drop an instance of BP_CompanionCharacter anywhere onto the level.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡上放置一个BP_CompanionCharacter的实例。
- en: 'Test the map in a VR preview. You should be able to move and teleport, and
    your companion character should follow you:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR预览中测试地图。你应该能够移动和传送，你的伴侣角色应该跟随你：
- en: '![](img/fc9c3181-0e37-4c0e-941c-dce2a397c9fb.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc9c3181-0e37-4c0e-941c-dce2a397c9fb.png)'
- en: This map is a great map to use for learning the Unreal Editor's VR Mode—it's
    easy to get around, and gives us lots of pieces we can manipulate as we practice
    with the interface. Let's take advantage of this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图非常适合用于学习虚幻编辑器的VR模式-它易于操作，并且提供了许多我们可以在界面上练习时操作的部件。让我们充分利用它。
- en: Using the VR editor
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VR编辑器
- en: Unreal Engine comes equipped with a very capable virtual reality editor that
    allows you to build your scenes entirely from within the virtual environment.
    Nearly any editor operation you might need to perform can be done without leaving
    VR.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎配备了一个非常强大的虚拟现实编辑器，可以让你完全在虚拟环境中构建场景。几乎任何你可能需要执行的编辑操作都可以在不离开VR的情况下完成。
- en: 'It may be tempting, though, to look at the VR Mode editor as a gimmick when
    you first encounter it. After all, what''s wrong with the existing editor? Nothing,
    but here''s the thing: virtual reality isn''t a flat screen. Depth exists. Sightlines
    are different. Colors render differently. Developing for virtual reality by using
    a flat screen adds a layer of abstraction to your design process. You''ll understand
    more and get better results by working directly in your target medium when you
    can.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你第一次遇到VR模式编辑器时，可能会认为它只是一个花招。毕竟，现有的编辑器有什么问题呢？没有问题，但是这里有一点需要注意：虚拟现实不是一个平面屏幕。深度是存在的。视线是不同的。颜色的渲染也不同。通过使用平面屏幕进行虚拟现实开发会给你的设计过程增加一层抽象。当你能够直接在目标媒介中工作时，你会更加了解并获得更好的结果。
- en: In practice, you're likely to find both editing modes useful. Just as it's difficult
    to see what a scene is really going to look like in VR from the flat-screen editor
    view, it's difficult to achieve precision in placing objects in VR Mode. You'll
    discover your workflow as you get comfortable with the tools, and you'll discover
    which operations you prefer to do in which domains. The point here, though, is
    that it's worthwhile to think of VR Mode as an important part of your scene layout
    workflow for VR. Take the time to get comfortable with it so you can rely on it
    when it's warranted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能会发现两种编辑模式都很有用。就像在平面屏幕编辑器视图中很难看清楚一个场景在VR中的真实样子一样，在VR模式下放置物体时很难达到精确。当你熟悉工具时，你会发现自己的工作流程，并发现你更喜欢在哪个领域进行哪些操作。然而，这里的重点是，将VR模式视为VR场景布局工作流程的重要组成部分是值得的。花时间熟悉它，这样当需要时就可以依赖它。
- en: A good practice for VR editing is to do your initial block-out in VR. Place
    objects in ways that evoke the sense of space you want to convey, and then go
    to traditional flat-screen editing to refine your layout and populate it further.
    Finally, return to VR editing for your final refinements so you can see exactly
    what you're going to get.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: VR编辑的一个好的实践是在VR中进行初始的块状布局。以一种能够传达你想要表达的空间感的方式放置物体，然后转到传统的平面编辑来进一步完善你的布局并填充它。最后，返回到VR编辑中进行最后的调整，这样你就可以清楚地看到你将要得到的结果。
- en: Let's activate the VR editor and see what we can do with it. Since you won't
    be able to read this book while you're inside the headset, we'll go over a few
    basic principles, allow you to try them out, and then return here to explore a
    few more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们激活VR编辑器，看看我们可以用它做些什么。由于你在戴头盔时无法阅读这本书，我们将介绍一些基本原则，让你尝试一下，然后再回到这里探索更多内容。
- en: The first thing to know is how to enter and exit the VR editor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是如何进入和退出VR编辑器。
- en: Entering and exiting VR Mode
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入和退出VR模式
- en: 'You can activate the VR editor by using the VR Mode toolbar button. To exit
    VR Mode, activate the radial menu (more on this later) and select System | Exit.
    It''s easiest, though, to get used to using *Alt* + *V* to enter and exit VR Mode:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用VR模式工具栏按钮来激活VR编辑器。要退出VR模式，请激活径向菜单（稍后会详细介绍）并选择“系统|退出”。不过，最简单的方法是习惯使用*Alt*
    + *V*来进入和退出VR模式：
- en: '![](img/f2ae6c39-2220-4e8a-9a50-b632e84f25e1.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2ae6c39-2220-4e8a-9a50-b632e84f25e1.png)'
- en: It's also possible to configure VR Mode to enter automatically when the headset
    is put on while the editor is running. To do this, select Edit | Editor Preferences
    | General | VR Mode, and set Enable VR Mode Auto-Entry to True. Whether you'd
    like to do this is your choice, but, in practice, it tends to have a difficult
    time figuring out when to turn itself back off, so using *Alt* + *V* to enter
    and exit is usually a better idea.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将VR模式配置为在编辑器运行时自动进入头戴式显示器时自动进入。要做到这一点，选择“编辑|编辑器首选项|常规|VR模式”，并将“启用VR模式自动进入”设置为True。是否这样做取决于你的选择，但是在实践中，它往往很难确定何时关闭自身，因此使用*Alt*
    + *V*进入和退出通常是一个更好的主意。
- en: 'If you prefer to interact primarily using your left hand, you have the option
    here in the VR Mode preferences to switch your Interactor Hand:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用左手进行交互，你可以在VR模式首选项中选择此选项：
- en: '![](img/a392086e-d933-429b-a2c3-4f1bf5fc4f12.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a392086e-d933-429b-a2c3-4f1bf5fc4f12.png)'
- en: VR Mode settings are found under Edit | Editor Preferences | General | VR Mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: VR模式的设置可以在“编辑”|“编辑器首选项”|“常规”|“VR模式”下找到。
- en: Set either of these options if you'd like. We're going to leave the rest of
    these at their defaults for our work here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以设置其中任何一个选项。我们将保留这些选项的默认设置。
- en: The other thing we're going to need to address is how to move and look around.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要解决的另一件事是如何移动和观察周围。
- en: Navigating in VR Mode
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR模式下导航
- en: You activate movement mode in the VR editor by squeezing the grip buttons. When
    movement mode activates, the movement grid will appear and the interaction beam
    will turn green.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR编辑器中，通过挤压握持按钮来激活移动模式。当移动模式激活时，移动网格将出现，交互光束将变为绿色。
- en: The interaction beam in the VR editor changes colors to indicate what mode it's
    in. Red indicates standard interaction mode, green indicates movement mode, yellow
    indicates that you currently have an actor selected, and blue indicates that you're
    in UI interaction mode.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: VR编辑器中的交互光束会改变颜色以指示其所处的模式。红色表示标准交互模式，绿色表示移动模式，黄色表示你当前选择了一个角色，蓝色表示你处于UI交互模式。
- en: The metaphor for movement in the VR editor is **pushing** and **pulling** the
    world. It's fairly intuitive. In most instances, the world will move in the way
    your hand is moving while your movement mode is active.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR编辑器中，移动的隐喻是**推动**和**拉动**世界。这是相当直观的。在大多数情况下，当你的移动模式处于活动状态时，世界会按照你的手的移动方式移动。
- en: Moving through the world
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在世界中移动
- en: 'If you move the controller while holding the grip, the world moves as though
    you''re pulling it, or swimming through it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在握持按钮的同时移动控制器，世界会移动，就像你在拉动它，或者在其中游泳一样：
- en: '![](img/f2dc78f9-a553-4565-8de0-6e296858c517.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2dc78f9-a553-4565-8de0-6e296858c517.png)'
- en: If you release the grip while moving the controller, the movement continues
    for a bit, as though you'd pushed off of an object and were now floating away
    from it. This takes a bit of practice, but it becomes fairly intuitive once you
    get the hang of it. Squeezing the grip again stops your movement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在移动控制器时松开握持按钮，移动会继续一段时间，就像你从一个物体上推开并且现在漂离它一样。这需要一些练习，但一旦你掌握了它，它就会变得相当直观。再次挤压握持按钮会停止你的移动。
- en: The movement grid displays the location of the floor in your real-world tracking
    volume. Align it with the floor in your scene to see what objects will really
    look like from the perspective of someone standing on the floor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 移动网格显示了你真实世界跟踪体积中地板的位置。将其与场景中的地板对齐，以查看从站在地板上的人的视角看物体的真实样子。
- en: Teleporting through the world
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过世界传送
- en: 'To teleport through the world, squeeze the grip button on your dominant hand''s
    controller and squeeze the trigger. Aim the controller at an object or destination,
    and you''ll teleport there on release:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过世界传送，挤压你主手控制器上的握持按钮并按下扳机。将控制器对准一个物体或目的地，释放时你将传送到那里：
- en: '![](img/8b12e78c-502a-4277-b5a6-c0cf29469f4c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b12e78c-502a-4277-b5a6-c0cf29469f4c.png)'
- en: Using a combination of teleport and drag moves, you can get around the world
    pretty well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传送和拖动的组合，你可以很好地在世界中移动。
- en: Rotating the world
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转世界
- en: 'When you need to rotate your viewpoint, hold both controllers'' grips and rotate
    the controllers around each other as though you were trying to spin the world:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要旋转视角时，握住两个手柄的握持按钮，将手柄彼此旋转，就像你试图旋转世界一样：
- en: '![](img/6670d6e8-9842-40d5-8e06-93375f97a53f.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6670d6e8-9842-40d5-8e06-93375f97a53f.png)'
- en: The number you see over the rotation axis is the world's current scale. We can
    manipulate that too.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你在旋转轴上看到的数字是世界当前的比例。我们也可以操纵它。
- en: Scaling the world
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放世界
- en: 'To scale the world, squeeze the grips and move the controllers toward each
    other to shrink the world, or away from each other to expand it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放世界，挤压握持按钮并将控制器向彼此移动以缩小世界，或将其远离彼此以扩大世界：
- en: '![](img/f9f14b1e-e254-4ebe-8ede-68b9a207c0ba.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f14b1e-e254-4ebe-8ede-68b9a207c0ba.png)'
- en: It's weirdly satisfying to shrink your scene down until it looks like miniatures
    on a table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景缩小到看起来像桌子上的微型场景真是一种奇妙的满足感。
- en: Moving the controllers toward each other shrinks the world. Moving them away
    from each other grows the world. This can be useful for layout, as you can assemble
    the world in miniature, then teleport back to the ground and restore its normal
    scale to see what you've made.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制器彼此靠近会缩小世界。将它们远离彼此会扩大世界。这对于布局很有用，因为你可以将世界组装成微型，然后传送回地面并恢复其正常比例，以查看你所做的事情。
- en: One of the fastest ways to get around the world in VR Mode is to shrink the
    world, then use the teleport action (grip + trigger) to teleport to a new location
    on your map. The world will return to its default size when you teleport.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR模式下，最快的方法之一是缩小世界，然后使用传送动作（握住+扳机）在地图上传送到新的位置。当你传送时，世界会恢复到默认大小。
- en: Practicing movement
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习移动
- en: Take some time now to practice navigating through the world using your controllers.
    Use *Alt* + *V* to enter VR Mode, and hit *Alt* + *V* again when you want to exit.
    Use the grip buttons to move through the world, teleport, rotate, and change its
    scale. Play with it until it feels natural. There's a bit of subtlety to getting
    this, but it's a very useful tool once you've made yourself comfortable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在花点时间用你的控制器练习在世界中导航。使用*Alt* + *V*进入VR模式，当你想退出时再次按下*Alt* + *V*。使用握持按钮在世界中移动、传送、旋转和改变其比例。玩弄它直到感觉自然。这需要一些细微的技巧，但一旦你熟悉了，它就是一个非常有用的工具。
- en: Modifying the world in VR Mode
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改VR模式下的世界
- en: Now that you've practiced moving around the world a bit, let's start to learn
    some of the skills we'll need to do scene composition in VR.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经练习了一下在世界中移动，让我们开始学习一些在VR中进行场景构图所需的技巧。
- en: Moving, rotating, and scaling objects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动、旋转和缩放对象
- en: 'To select an object, just point at it and pull the trigger. Your interaction
    beam will turn yellow to indicate that you''ve entered selection mode. A gizmo
    will appear that allows you to move the object. By default, this will be a translate
    gizmo, which allows you to move the selected object around (we''ll see in a moment
    how to switch to other types of gizmo):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择一个对象，只需将光束对准它并拉动触发器。您的交互光束将变为黄色，表示您已进入选择模式。将出现一个Gizmo，允许您移动对象。默认情况下，这将是一个平移Gizmo，允许您在选定的对象周围移动（我们将在一会儿看到如何切换到其他类型的Gizmo）：
- en: '![](img/80c407e4-b9b3-4693-bf34-7108cdaaa4c5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80c407e4-b9b3-4693-bf34-7108cdaaa4c5.png)'
- en: If you'd like to move the selected object, release the trigger and then pull
    it again while pointing at the object or at the transform gizmo. You can use the
    transform gizmo's arrows and planes to constrain your movement, or interact directly
    with the object to move it freely. When moving an object directly with the interaction
    beam, you can use the trackpad to move it closer or further from you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想移动所选对象，请释放触发器，然后再次拉动触发器，同时指向对象或变换Gizmo。您可以使用变换Gizmo的箭头和平面来限制移动，或者直接与对象交互以自由移动它。当使用交互光束直接移动对象时，您可以使用触摸板将其靠近或远离您。
- en: Be aware that hidden objects with collision can sometimes interfere with selection
    in VR Mode. If your selection beam appears to pass through the object you want
    to select, move to a different vantage point to select it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，带有碰撞的隐藏对象有时会干扰VR模式下的选择。如果您的选择光束似乎穿过您想要选择的对象，请移动到不同的视角点来选择它。
- en: Usually it's a better idea to use the gizmo to move an object, as it's fairly
    difficult to move objects in depth with any precision.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好使用Gizmo来移动对象，因为使用任何精度将对象在深度上移动是相当困难的。
- en: 'The default transform gizmo can be switched to other modes using the radial
    menu interface. To activate the radial menu, touch the trackpad or thumbstick
    on your non-interactor hand and point at the menu option you''d like to select.
    Use the trigger to select it. Your controller''s menu button takes you back out
    of sub-menus, or closes the radial menu if you''re already at the top menu:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用径向菜单界面将默认的变换Gizmo切换到其他模式。要激活径向菜单，请触摸非交互手上的触摸板或拇指杆，并指向您想要选择的菜单选项。使用触发器进行选择。您的控制器菜单按钮将带您退出子菜单，或者如果您已经在顶级菜单，则关闭径向菜单：
- en: '![](img/dab60762-c626-49ee-97e7-5d65f28008b3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dab60762-c626-49ee-97e7-5d65f28008b3.png)'
- en: 'Selecting the Gizmo submenu allows you to switch between transform gizmo options:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Gizmo子菜单可以在变换Gizmo选项之间切换：
- en: '![](img/155452c0-31cd-40fa-a1d4-61ddd45c5fbf.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/155452c0-31cd-40fa-a1d4-61ddd45c5fbf.png)'
- en: The Universal gizmo provides translation, rotation, and scale handles on a single
    gizmo. The Translate, Rotate, and Scale gizmos provide individual tools for those
    operations. Switching the transform mode to Local Space rotates, scales, and moves
    the object along its own axes, while the World Space mode transforms the object
    along the world axes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通用Gizmo提供了一个单一的Gizmo上的平移、旋转和缩放控制。平移、旋转和缩放Gizmo为这些操作提供了单独的工具。将变换模式切换为局部空间时，对象沿着自己的轴旋转、缩放和移动，而世界空间模式则沿着世界轴变换对象。
- en: Using both controllers to rotate and scale objects
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用两个控制器旋转和缩放对象
- en: 'You also may have noticed that, whenever you have an object selected and you''re
    holding the trigger over the object itself (rather than a gizmo handle), a second
    interaction beam appears on your off-hand controller. If you aim that second interaction
    beam at the object and squeeze the trigger, you can use them both to tumble and
    stretch the object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到，每当您选择一个对象并将触发器放在对象本身上（而不是Gizmo手柄上）时，您的非主手控制器上会出现第二个交互光束。如果您将第二个交互光束对准对象并按下触发器，您可以同时使用它们来翻转和拉伸对象：
- en: '![](img/b2e8f473-afa4-4b7c-a554-b2fc53f4fd6a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2e8f473-afa4-4b7c-a554-b2fc53f4fd6a.png)'
- en: This is a great tool for exploring improvising rough layouts. It's intuitive
    and invites natural interaction with objects in your environment. This is a good
    tool to use for exploring and improvising layouts. You'll probably have a tough
    time getting things exactly where you want them, but if you use this tool for
    rough layouts and then clean them up in the flat-screen editor, you can achieve
    good results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个探索即兴布局的好工具。它直观并邀请您与环境中的对象进行自然互动。这是一个用于探索和即兴布局的好工具。您可能会发现将物体放在您想要的位置可能会很困难，但如果您使用此工具进行粗略布局，然后在平面编辑器中进行清理，您可以获得良好的结果。
- en: Practicing moving objects
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习移动对象
- en: Try it out now. Hit *Alt* + *V* to enter VR Mode, and, in addition to practicing
    moving around the world, practice using the transform gizmos and free movement
    to move objects around the world. Remember to use the radial menu to change movement
    modes, and use the Menu button to get back out to the Home menu. Take some time
    to practice this. The controls will probably feel unfamiliar at first, but once
    you get the hang of them, world-building in VR is a rewarding experience.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧。按下*Alt* + *V*进入VR模式，并且除了练习在世界中移动之外，还要练习使用变换Gizmo和自由移动来移动世界中的对象。记得使用径向菜单来改变移动模式，并使用菜单按钮返回到主菜单。花些时间练习一下。一开始控制可能会感到陌生，但一旦掌握了它们，用VR进行世界构建将是一种有益的体验。
- en: When you're done, hit *Alt* + *V* to exit VR Mode again, and, if you'd like,
    clean up your object alignments in flat-screen editing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，按下*Alt* + *V*再次退出VR模式，如果需要，在平面编辑中清理对象对齐。
- en: Now we're ready to begin composing a scene, and to do this, we'll be using the
    VR Mode menus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始组合一个场景，为此，我们将使用VR模式菜单。
- en: Composing a new scene in VR Mode
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR模式中组合新场景
- en: 'Now that we''ve learned the basics of operating the VR Mode editor, let''s
    go deeper and really see how we can use this as a scene composition tool. First,
    we''re going to need some assets to work with. The free Infinity Blade: Grass
    Lands package will give us something to play with.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了VR模式编辑器的基本操作，让我们深入了解一下如何将其用作场景组合工具。首先，我们需要一些要使用的资产。免费的无尽之剑：草地包将为我们提供一些可以玩耍的东西。
- en: 'Open your Epic Games Launcher (it''s fine to leave your existing project open
    as you do this), navigate to the Unreal Engine | Marketplace | Free tab, and search
    for Infinity Blade: Grass Lands. Hit Add to Project and select your new project
    as the target project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '打开您的Epic Games Launcher（在此过程中可以保留您现有的项目打开），导航到Unreal Engine | Marketplace |
    Free选项卡，并搜索Infinity Blade: Grass Lands。点击“添加到项目”并选择您的新项目作为目标项目：'
- en: '![](img/de76f21f-15b8-4547-aea8-0b70bc57d246.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de76f21f-15b8-4547-aea8-0b70bc57d246.png)'
- en: Once the assets have finished downloading and installing, let's force the new
    shaders to compile. Open up `Content/InfinityBladeGrassLands/Maps/Overview`, and
    let the shaders compile. While these shaders are compiling, feel free to enter
    VR Mode using *Alt* + *V* and navigate around the overview map to see what assets
    we have available to us.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦资产下载和安装完成，让我们强制编译新的着色器。打开`Content/InfinityBladeGrassLands/Maps/Overview`，并让着色器编译。在这些着色器编译时，可以使用*Alt*
    + *V*进入VR模式，并在概览地图中导航，看看我们可以使用的资产。
- en: After you've built your shaders, we can do some work composing a scene using
    these assets. For this exercise, we're going to start with an existing map and
    modify it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了您的着色器之后，我们可以使用这些资产来组合一个场景。对于这个练习，我们将从一个现有的地图开始并进行修改。
- en: First, we'll need to learn how to navigate the editor menus in VR.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要学习如何在VR中导航编辑器菜单。
- en: Navigating the radial menu
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航径向菜单
- en: 'Menu interaction in the VR editor, is for the most part, handled by a series
    of radial menus attached to the controller. In practice, these are fairly intuitive
    to use, as they map clearly to the touchpad or thumbstick inputs on the hand controllers.
    Let''s look at how they work:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: VR编辑器中的菜单交互主要是通过附加到控制器的一系列径向菜单来处理的。实际上，这些菜单使用起来相当直观，因为它们清晰地映射到手柄上的触摸板或拇指杆输入。让我们看看它们是如何工作的：
- en: Select `Content/InfinityBladeGrassLands/Maps/ElvenRuins` and open it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Content/InfinityBladeGrassLands/Maps/ElvenRuins`并打开它。
- en: If you'd like, you can also change your Project Settings | Maps & Modes | Default
    Maps to open this map automatically.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，您还可以更改您的项目设置|地图和模式|默认地图以自动打开此地图。
- en: Use *Alt* + *V* to enter VR Mode, and, while you're in this mode, touch the
    left trackpad or thumbstick to activate the radial menu.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Alt* + *V*进入VR模式，当您处于此模式时，触摸左侧的触摸板或拇指杆以激活径向菜单。
- en: To enter a menu, aim the interaction beam at it and squeeze the trigger or use
    the menu hand's trackpad to select options.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进入菜单，请将交互光束对准它并按下扳机或使用菜单手柄的触控板选择选项。
- en: 'To back out of the submenus, use the non-dominant hand''s menu button:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出子菜单，请使用非主导手的菜单按钮：
- en: '![](img/d0ebaa31-c31e-4b5a-af82-d439d01952b0.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0ebaa31-c31e-4b5a-af82-d439d01952b0.png)'
- en: You can use the interaction beam or the menu hand's trackpad to navigate menus
    in VR Mode
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用交互光束或菜单手柄的触控板在VR模式下导航菜单
- en: Let's get into VR Mode and explore the menus. You have eight major menu categories
    available from the Home menu.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入VR模式并探索菜单。您可以从主菜单中选择八个主要菜单类别。
- en: Gizmo
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gizmo
- en: We've already explored the Gizmo menu, so we won't dive back into detail here.
    Remember that it's used to switch between behaviors of your in-editor movement
    tools.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了Gizmo菜单，所以我们不会在这里详细介绍。请记住，它用于在编辑器中切换移动工具的行为。
- en: Snapping
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐
- en: 'The Snapping menu is a close partner to the Gizmo menu. Most of these behave
    as you''re used to in the flat-screen editor, but the Smart Snapping option is
    especially worth knowing about:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐菜单是Gizmo菜单的紧密伙伴。其中大多数的行为与平面编辑器中的行为相同，但智能对齐选项特别值得了解：
- en: '![](img/0d9a5d14-bdee-44c3-b3f7-0d9b4a6d0ab6.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d9a5d14-bdee-44c3-b3f7-0d9b4a6d0ab6.png)'
- en: With Smart Snapping active, objects you move in-scene will attempt to align
    themselves to other objects as you move them. Since precise placement can be challenging
    to achieve in VR Mode, this is a big help.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 启用智能对齐后，您在场景中移动的对象将尝试在移动时与其他对象对齐。由于在VR模式下很难实现精确的定位，这是一个很大的帮助。
- en: Use the Set Targets option to select a specific object you'd like other objects
    to snap to, and use the Reset Targets option to clear it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“设置目标”选项选择一个特定的对象，您希望其他对象对齐到该对象，并使用“重置目标”选项清除它。
- en: Windows
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口
- en: 'The Windows submenu provides access to the individual palettes and menus you''ll
    be using as you compose your scene:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Windows子菜单提供了访问您在组合场景时将使用的各个调色板和菜单：
- en: '![](img/08e0c5ff-bf84-4ffe-b5f7-6106e96a719d.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e0c5ff-bf84-4ffe-b5f7-6106e96a719d.png)'
- en: 'Each button opens its associated panel. These are the same panels you''re used
    to from the flat-screen editor:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都会打开其关联的面板。这些面板与平面编辑器中的面板相同：
- en: '![](img/1c3a8eb8-99ed-4ec7-b102-ad48fb8b989e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c3a8eb8-99ed-4ec7-b102-ad48fb8b989e.png)'
- en: The Content Browser as seen in the editor's VR Mode
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器的VR模式中看到的内容浏览器
- en: 'To move a window, aim the interaction beam at the large bar beneath it. You
    can place and angle it any way you want. The downward-facing arrow to the left
    of the move bar pins the window in place. When it''s activated, the window will
    stay where you place it, regardless of how you move through the world. When it''s
    un pinned, the window will move with you when you move. The X-shaped button to
    the right of the bar closes the window:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动一个窗口，将交互光束对准其下方的大条。您可以将其放置和角度调整为任何您想要的方式。移动条左侧的朝下箭头将窗口固定在原位。当它被激活时，窗口将保持在您放置的位置，无论您如何在世界中移动。当它未固定时，窗口将随您的移动而移动。条右侧的X形按钮关闭窗口：
- en: '![](img/356e00a5-a2bb-40f3-b05e-b134d6f70583.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/356e00a5-a2bb-40f3-b05e-b134d6f70583.png)'
- en: You can move your active windows around to create a virtual workspace from which
    to work
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以移动活动窗口以创建一个虚拟工作空间来进行工作
- en: These windows work just as they do in the flat-screen editor. An effective practice
    in using them is to open only the windows that you need, and arrange them around
    yourself in a virtual workspace for the task you're doing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些窗口的工作方式与平面编辑器中的窗口相同。在使用它们时，一个有效的做法是只打开您需要的窗口，并将它们排列在您周围的虚拟工作空间中以完成您正在进行的任务。
- en: In practice, much of the time, you'll find it useful to leave your content browser
    open to your side along with the details pane.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，很多时候，将内容浏览器和详细信息窗格保持打开状态会很有用。
- en: Edit
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑
- en: 'The Edit menu allows you to duplicate, delete, and snap objects in your scene:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑菜单允许您在场景中复制、删除和对齐对象：
- en: '![](img/4488086f-c2ca-40b5-b0c8-61c05d031518.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4488086f-c2ca-40b5-b0c8-61c05d031518.png)'
- en: Most of these options should be pretty self-explanatory and what you'd expect
    an edit menu to contain. Snap to Floor is a bit of an outlier, so it's worth remembering
    that it's in here. You'll use it often.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数选项应该都很容易理解，并且符合您对编辑菜单的期望。对齐到地板是一个例外，所以值得记住它在这里。您会经常使用它。
- en: Tools
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: 'The Tools menu is primarily geared toward managing simulations in the editor.
    Here, you can start, pause, and resume simulations, and save their results back
    to the editor:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 工具菜单主要用于管理编辑器中的模拟。在这里，您可以启动、暂停和恢复模拟，并将其结果保存回编辑器：
- en: '![](img/5892c6f2-95f1-45d8-8bee-99f8bff1de4e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5892c6f2-95f1-45d8-8bee-99f8bff1de4e.png)'
- en: Two options that aren't related to simulations are also contained here. The
    Screenshot tool snaps a standard-resolution screenshot, but be aware that the
    screenshot will include the menu, so move it out of sight if you want a clean
    shot. The Flashlight tool is useful for finding your way around dark scenes, especially
    if you're midway through composing your scene lighting.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还包含了两个与模拟无关的选项。截图工具可以捕捉标准分辨率的截图，但请注意，截图将包括菜单，所以如果您想要一个干净的截图，请将其移出视线。手电筒工具对于在黑暗场景中找到方向非常有用，特别是如果您正在进行场景照明的中途。
- en: Modes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'The Modes panel allows you to place actors such as lights, volumes, and primitives;
    manage foliage; enter landscape sculpting mode; and paint textures and vertex
    colors, just as it does in the flat-screen editor:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 模式面板允许您放置诸如灯光、体积和基元等演员；管理植被；进入地形雕刻模式；以及绘制纹理和顶点颜色，就像在平面编辑器中一样：
- en: '![](img/64bd219b-1806-4c61-bd7c-c849fa96e31f.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64bd219b-1806-4c61-bd7c-c849fa96e31f.png)'
- en: Selecting one of these options will bring up a Modes panel that can then be
    placed in the world and used in the same way as the other panels available from
    the Windows menu.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 选择其中一个选项将带出一个模式面板，然后可以将其放置在世界中，并以与Windows菜单中提供的其他面板相同的方式使用。
- en: Actions and System
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作和系统
- en: At present, the System menu just gives you a way to exit VR Mode. At the time
    of writing, it doesn't do anything else. The Actions menu's behavior varies depending
    on context.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，系统菜单只提供了退出VR模式的方法。在撰写本文时，它没有其他功能。操作菜单的行为取决于上下文。
- en: Making changes to our scene
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对场景进行更改
- en: Now that we've learned how to get around in VR Mode, let's put some of this
    learning into practice. We're going to modify the Elven Ruins map from within
    VR Mode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在VR模式下操作，让我们将这些学习应用到实践中。我们将在VR模式下修改Elven Ruins地图。
- en: The first thing we're going to do is change the time of day. Let's see how these
    ruins would look at dawn.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是改变白天的时间。让我们看看这些废墟在黎明时会是什么样子。
- en: Use *Alt* + *V* to enter VR Mode and touch your non-interaction hand's trackpad
    or thumbstick to bring up the radial menu. Use the menu button to navigate back
    up to home if you're currently in a submenu. Select the Windows menu and, from
    there, activate the World Outliner.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Alt* + *V*进入VR模式，用非交互手的触摸板或拇指杆触摸来呼出径向菜单。使用菜单按钮导航返回主页，如果当前处于子菜单中，请选择Windows菜单，然后激活World
    Outliner。
- en: Use the interaction beam to drag the movement box at the base of the menu. Put
    it to your side and a bit below you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互光束拖动菜单底部的移动框。将其放在您的侧面稍微下方。
- en: 'We''re going to look for the directional light that''s acting as our sun in
    this scene. To find it, click the Type column''s header to sort your actor list
    by type, and then use the trackpad to scroll through the list and find the Directional
    Light named Light Source:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找到在这个场景中充当太阳的定向光。要找到它，点击类型列的标题，按类型对演员列表进行排序，然后使用触摸板滚动列表，找到名为Light Source的定向光：
- en: '![](img/140918b5-9f61-407c-9946-f1c8c0a90074.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/140918b5-9f61-407c-9946-f1c8c0a90074.png)'
- en: Unfortunately, you don't have an easy way to enter text in VR Mode. The radial
    menu offers a number pad that you can use when setting values, but if you wanted
    to search for light, you'd have to type it using a conventional keyboard. Sorting,
    scrolling, and selecting works pretty well for this sort of work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在VR模式下没有简单的方法输入文本。径向菜单提供了一个数字键盘，您可以在设置值时使用，但如果您想搜索光源，您必须使用传统键盘进行输入。对于这种类型的工作，排序、滚动和选择功能非常好用。
- en: 'Once you''ve selected the directional light, use the radial menu to activate
    the Details panel. Use the bar beneath it to drag it to a location where you can
    read it and interact with it, but can still see the sky:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 选择定向光后，使用径向菜单激活详细信息面板。使用面板下方的条形图将其拖动到一个可以阅读和交互的位置，但仍然可以看到天空：
- en: '![](img/f3da5d9f-2324-46c8-b3c8-f9ef685ac4a7.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3da5d9f-2324-46c8-b3c8-f9ef685ac4a7.png)'
- en: In this shot taken from within the VR headset, you can see how we've been able
    to create a virtual workspace by manipulating the panels in 3D space.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张从VR头盔中拍摄的照片中，你可以看到我们通过在3D空间中操作面板来创建了一个虚拟工作空间。
- en: Point the interaction beam at the light's Rotation Y value and drag it back
    and forth over the box to change its value. You'll see the sun changing overhead.
    It starts out at around -48\. Drag it to around 210 (or wherever you like, really)
    to create some nice dramatic shadows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将交互光束对准光源的Rotation Y值，并在盒子上来回拖动以改变其值。你会看到太阳在头顶上变化。它的初始值大约为-48。将其拖动到大约210（或者你喜欢的任何位置），可以创建一些漂亮的戏剧性阴影。
- en: 'Now, select BP_SkySphere. From its Details panel, turn on Colors Determined
    by Sun Position, and check the Refresh Material checkbox to change the sky''s
    color:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择BP_SkySphere。在其详细信息面板中，打开Colors Determined by Sun Position，并勾选Refresh Material复选框以改变天空的颜色：
- en: '![](img/e22807ac-9bb1-4709-8745-a18250d6ae31.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e22807ac-9bb1-4709-8745-a18250d6ae31.png)'
- en: That's kind of nice, right? Lighting changes like this are often best made inside
    the VR Mode editor, as light and colors render very differently in the headset
    than they do on the flat screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样很好，对吧？像这样的光照变化通常最好在VR模式编辑器中进行，因为头戴式显示器中的光照和颜色与平面屏幕上的显示非常不同。
- en: 'Building new elements in your map is generally best done in the flat-screen
    editor. VR Mode is excellent for checking sightlines and adjusting object positions,
    but, in practice, it still suffers from some growing pains that can make object
    selection difficult:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好在平面屏幕编辑器中构建地图中的新元素。VR模式非常适合检查视线和调整物体位置，但在实践中，它仍然存在一些问题，这可能会使物体选择变得困难：
- en: '![](img/c765d94a-f495-4905-81c7-2f95b9da01af.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c765d94a-f495-4905-81c7-2f95b9da01af.png)'
- en: 'Here are a few effective ways to work within VR Mode, benefit from its strengths,
    and work around its weaknesses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在VR模式下工作的几种有效方法，以发挥其优势并解决其弱点：
- en: Get around by scaling the world down, then use teleport to land where you want
    to go
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缩小世界规模来移动，然后使用传送来到达目的地
- en: Do rough lighting adjustments inside VR Mode where you can see what their effects
    on the world will really be
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VR模式中进行粗略的光照调整，以便您可以看到它们对世界的真实影响
- en: Build geometry in the traditional editor, but use VR Mode to experiment with
    its placement
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统编辑器中构建几何体，但使用VR模式来尝试其位置
- en: Get into the habit of using *Alt* + *V* frequently to check your environment
    in VR as you build it. You'll get a sense of which adjustments make sense to do
    in VR Mode and which work best in the traditional editor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 养成经常使用*Alt* + *V*来在VR中检查环境的习惯，以便在构建时了解哪些调整在VR模式下是有意义的，哪些在传统编辑器中效果最好。
- en: Most importantly, what we wanted to communicate in this section is that VR Mode,
    far from being a luxury or a gimmick, should be considered an essential tool for
    your scene construction workflow in VR.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们在本节中想要传达的是，VR模式绝非奢侈品或花招，而应被视为VR场景构建工作流程中的必备工具。
- en: Optimizing scenes for VR
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为VR优化场景
- en: Now that we've spoken a fair bit about editing scenes using VR Mode, let's talk
    about an absolutely crucial topic in VR development – maintaining an acceptable
    frame rate.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经谈了很多关于使用VR模式编辑场景的内容，让我们谈谈VR开发中一个非常关键的主题-保持可接受的帧率。
- en: We've discussed the paramount importance of maintaining frame rate in virtual
    reality several times before. It's critical, and it's challenging to do. In the
    remainder of this chapter, we're going to talk about things that you can do to
    speed up your scenes and to find out what's preventing them from running faster.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经多次讨论了在虚拟现实中保持帧率的至关重要性。这是至关重要的，也是具有挑战性的。在本章的剩余部分，我们将讨论一些可以加快场景速度并找出导致速度变慢的原因的方法。
- en: Testing your current performance
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试当前性能
- en: The first thing you need to do when assessing your scene's performance is to
    find out how fast you're currently running. We're going to look at a few commands
    we can use for this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估场景性能时，您需要做的第一件事是找出当前运行速度有多快。我们将看一些可以用于此的命令。
- en: 'From within the editor, click on the **`** (backtick) key. It''s to the left
    of the *1* key on your keyboard, above the Tab key. A console entry box will appear:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从编辑器中，点击**`**（反引号）键。它位于键盘上1键的左边，Tab键的上方。将出现一个控制台输入框：
- en: '![](img/9b17c2c8-c708-4a46-b879-a20869b57de7.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b17c2c8-c708-4a46-b879-a20869b57de7.png)'
- en: A wide range of console commands can be entered here. We're going to talk about
    those you're most likely to use as you optimize your scenes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处输入各种控制台命令。我们将讨论您在优化场景时最有可能使用的命令。
- en: Stat FPS
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stat FPS
- en: 'Enter `stat fps` into the console command line. A frame rate counter will appear
    in your editor window, displaying two values:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台命令行中输入`stat fps`。编辑器窗口中将出现一个帧率计数器，显示两个值：
- en: '![](img/11449d96-431c-4d3b-8911-fce9fbf607fe.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11449d96-431c-4d3b-8911-fce9fbf607fe.png)'
- en: The first is your frames per second (FPS). The second value tells you how many
    milliseconds it took to draw the frame, and this is the value you should train
    yourself to focus on. Frame rate is what your player perceives, but, as you're
    developing and trying to solve problems that impact your frame rate, you're going
    to have a much easier time thinking about how the changes you make affect your
    performance if you train yourself to think in milliseconds. The frame rate describes
    your desired result, but the milliseconds you're spending on each part of getting
    the frame rendered are the cause. When fixing your scene, you need to look at
    the individual costs of each operation that's contributing to your frame time,
    and these are expressed in milliseconds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是每秒帧数（FPS）。第二个值告诉您绘制帧所花费的毫秒数，这是您应该训练自己关注的值。帧率是玩家所感知到的，但在开发和尝试解决影响帧率的问题时，如果您训练自己以毫秒为单位思考，那么您在思考所做更改如何影响性能时会更容易。帧率描述了您期望的结果，但您在渲染帧的每个部分上花费的毫秒数是原因。在修复场景时，您需要查看每个操作的单独成本，这些成本以毫秒为单位表示。
- en: Determining your frame time budget
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定您的帧时间预算
- en: If we're going to think in terms of milliseconds, the first thing we need to
    do is establish how many milliseconds we can spend drawing our frame and still
    hit our target frame rate. Figuring this out is simple.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要以毫秒为单位思考，首先要做的是确定我们可以花多少毫秒来绘制帧并仍然达到目标帧率。这很简单。
- en: To find your application's frame time budget, divide 1,000 by your target frame
    rate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到应用程序的帧时间预算，将1,000除以目标帧率。
- en: 'This gives you the number of milliseconds in which you have to draw your frame
    to achieve this frame rate. So, for example, if you''re targeting a headset that
    refreshes at 90 FPS (which describes most of them), we find our frame budget like
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了您必须绘制帧的毫秒数以实现此帧率。例如，如果您的目标是刷新率为90 FPS的头戴式显示器（大多数头戴式显示器都是如此），我们可以这样找到我们的帧预算：
- en: '*1000 / 90 = 11.11*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*1000 / 90 = 11.11*'
- en: This gives us a frame budget of around 11 milliseconds. Your VR application
    will refresh at 90 FPS if it takes you 11 milliseconds or less to deliver the
    frame. That's not a lot of time, so we're going to have to do some work with most
    scenes to achieve this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个大约11毫秒的帧预算。如果你在11毫秒或更短的时间内交付帧，你的VR应用程序将以90 FPS刷新。这不是很多时间，所以我们需要在大多数场景中做一些工作来实现这一点。
- en: Warnings about performance profiling
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于性能分析的警告
- en: Before we dive too deep down the performance optimization rabbit hole, let's
    keep a few important things in mind.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入性能优化的兔子洞之前，让我们记住几个重要的事情。
- en: First, the frame time reported on a flat screen isn't going to be accurate for
    VR. It's a good baseline value that you can use to see roughly how you're doing,
    but when you activate VR, your frame rate is going to drop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，平面屏幕上报告的帧时间对于VR来说不准确。它是一个可以用来大致了解你的情况的基准值，但当你激活VR时，你的帧率会下降。
- en: If you see a really substantial drop in frame rate between your flat-screen
    values and your VR values, check your Project Settings and make sure you have
    Instanced Stereo turned on. If it's off, which is its default setting, you'll
    be paying the full cost of rendering your entire scene twice, which you definitely
    don't want to do.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在平面屏幕值和VR值之间看到了明显的帧率下降，请检查你的项目设置，确保已经打开了实例化立体。如果关闭了（这是默认设置），你将支付渲染整个场景两次的全部成本，这绝对是你不想做的。
- en: Be sure you're not just checking your values on flat-screen. Test in VR often.
    A quick way of checking your VR performance is to read your stat fps values from
    within VR Mode.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你不仅仅在平面屏幕上检查数值。经常在VR中进行测试。一种快速检查VR性能的方法是从VR模式中读取stat fps的值。
- en: Activate VR Mode with stat fps visible. The text will probably be too small
    to read from within the headset, but you can read it from the flat-screen output.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可见的stat fps下激活VR模式。从头戴式显示器中可能无法读取文本，但你可以从平面屏幕输出中读取。
- en: Use this method to spot-check your environment. Move through the map and check
    for problem areas using VR Mode.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法来检查你的环境。在地图中移动并使用VR模式检查问题区域。
- en: Another important thing to consider is that, because we're testing in-editor,
    our numbers are affected by the editor itself. We're paying to render all those
    windows that your editor displays along with the in-game scene. For accurate values,
    we have to run the game in a stand alone session. Checking your numbers in-editor
    is a good practice to see whether changes you're making are making things better
    or worse, but you should remember that they don't accurately describe what your
    packaged application will do.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要考虑的是，因为我们是在编辑器中进行测试，所以我们的数字受到编辑器本身的影响。我们需要支付渲染编辑器显示的所有窗口以及游戏场景的成本。为了获得准确的值，我们必须在独立会话中运行游戏。在编辑器中检查你的数字是一个好的实践，可以看到你所做的更改是好还是坏，但你应该记住它们并不能准确描述你打包的应用程序会做什么。
- en: We also need to remember that, when we test frame time in-editor, we're really
    just looking at rendering performance, but we're not getting any information about
    what the rest of our application is costing us. This is fine much of the time,
    since the bulk of your problems are likely to be in rendering, but you should
    still make sure you're testing the running application to make sure you don't
    have a runaway Blueprint or too many animated characters bringing you down.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住，当我们在编辑器中测试帧时间时，我们实际上只是在看渲染性能，但我们没有得到关于应用程序的其他部分成本的任何信息。这在大多数情况下都没问题，因为你的问题很可能在渲染方面，但你仍然应该确保测试正在运行的应用程序，以确保你没有一个失控的蓝图或太多的动画角色拖累你。
- en: Finally, we should talk about system specifications. Different hardware configurations
    will perform in different ways. If you're planning to release an application to
    the public, you should be sure that you're testing it on your minimum spec hardware,
    as well as on your development machines. Just because your application is running
    fine on a beast with a brand-new high-end video card doesn't mean it's going to
    run so well on older hardware. If you can test on your min-spec target, do so.
    If you can't, be conscious of how far your development machine is from your min-spec
    and make sure you leave a decent amount of headroom in your frame time budget
    to accommodate this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该谈一下系统规格。不同的硬件配置会有不同的性能表现。如果你计划向公众发布一个应用程序，你应该确保你在最低规格的硬件上进行测试，以及在开发机器上进行测试。仅仅因为你的应用程序在一台配备全新高端显卡的怪物上运行良好，并不意味着它在旧硬件上也会运行得很好。如果你可以在最低规格的目标上进行测试，那就这样做。如果不能，要意识到你的开发机器与最低规格相差多远，并确保在帧时间预算中留出足够的余地来适应这一点。
- en: Now that we've talked a bit about the things that can affect our measurements,
    let's dive in deeper and learn how to get better information than we can get with
    stat fps alone.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经谈了一些可能影响我们测量结果的因素，让我们深入了解如何获得比仅仅使用stat fps更好的信息。
- en: Stat unit
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stat unit
- en: Checking our frame rate is useful and it's an important thing to do frequently,
    but on it's own it doesn't tell us much. It may tell us that we have a problem,
    but it won't give us much guidance in finding what's wrong or how to fix it. For
    this, we have a few more useful commands at our disposal.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的帧率是有用的，也是一个重要的频繁操作，但仅仅这样并不能告诉我们太多信息。它可能告诉我们有问题，但它不会给我们提供找出问题所在或如何修复问题的指导。为此，我们还有一些更有用的命令可以使用。
- en: The stat unit command breaks down the frame's cost in milliseconds and shows
    us which parts of that cost are coming from the scene we're rendering and which
    parts are coming from other things going on in our application, such as animations
    and AI.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: stat unit命令以毫秒为单位分解了帧的成本，并显示了我们渲染场景所花费的成本和应用程序中其他活动（如动画和AI）所花费的成本。
- en: 'Try it now. Click on the **` **(backtick) key to bring up your console command
    window, and type stat unit to add this additional information below your frame
    rate information:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试。点击**`**(反引号)键以打开控制台命令窗口，然后输入stat unit以在帧率信息下添加此额外信息：
- en: '![](img/5122dfe5-e217-4074-91b6-280a4a5dedf2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5122dfe5-e217-4074-91b6-280a4a5dedf2.png)'
- en: 'The stat unit command displays four primary pieces of information:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: stat unit命令显示四个主要信息：
- en: 'Frame: This is the total time it took to draw the frame. This is the same value
    we saw in the stat fps results.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧：这是绘制帧所花费的总时间。这与我们在stat fps结果中看到的值相同。
- en: 'Game: This tells you how long your game thread is taking on your CPU. This
    covers things such as animation updates, AI, and anything else your CPU has to
    figure out in order to update the frame. If you have Blueprints doing inefficient
    things on the Tick event, that will drive this value up.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Game：这告诉您游戏线程在CPU上花费了多长时间。这包括动画更新、AI和CPU必须解决的其他任何事情，以更新帧。如果蓝图在Tick事件上执行效率低下的操作，这将增加该值。
- en: 'Draw: This tells you how long your CPU spent preparing the scene for rendering.
    High values here may mean that you''re doing too much occlusion culling or spending
    too much on lights or shadows.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Draw：这告诉您CPU花费了多长时间来准备渲染场景。这里的高值可能意味着您进行了过多的遮挡剔除或在光照或阴影上花费了太多时间。
- en: 'GPU: This value tells you how long the GPU took to draw the frame. High values
    here may mean that you''re drawing too many polygons, using too many materials,
    or that your materials are too complex. Most of the time, your problems will be
    here.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU：这个值告诉您GPU绘制帧所花费的时间。这里的高值可能意味着您绘制了太多的多边形，使用了太多的材质，或者您的材质过于复杂。大多数情况下，您的问题将出现在这里。
- en: These values are not additive. Your game thread will wait for the rendering
    thread to complete, so, if the Game timing matches your GPU timing, what that's
    really telling you is that your CPU isn't holding you up, and that your frame
    time is being driven by rendering.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值不是累加的。您的游戏线程将等待渲染线程完成，因此，如果游戏时间与GPU时间匹配，那么实际上告诉您的是您的CPU没有拖慢您的速度，并且您的帧时间是由渲染驱动的。
- en: 'In addition to these four base values, we also have two advanced pieces of
    information that you don''t need to worry about right now:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这四个基本值之外，我们还有两个高级信息，您现在不需要担心：
- en: 'RHIT: This is your rendering hardware interface thread. Realistically, you
    won''t be seeing values here that differ much from your GPU values unless you''re
    working with advanced rendering hardware or a video game console, and you''re
    running your rendering hardware interface calls on a dedicated thread. Until you''re
    working on an advanced project with a dedicated team of engineers, this probably
    doesn''t apply to you.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHIT：这是您的渲染硬件接口线程。实际上，除非您使用高级渲染硬件或视频游戏主机，并且在专用线程上运行渲染硬件接口调用，否则您不会在这里看到与GPU值差异很大的值。除非您正在进行一个带有专门的工程团队的高级项目，否则这可能不适用于您。
- en: 'DynRes: This indicates whether dynamic resolution is supported or being used
    by your application. In practice, this is only supported on video game consoles,
    so you don''t need to worry about it here. If you''re curious, further information
    can be found at [https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution](https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynRes：这表示您的应用程序是否支持或正在使用动态分辨率。实际上，这仅在视频游戏主机上支持，所以您不需要在这里担心它。如果您感兴趣，可以在[https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution](https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution)找到更多信息。
- en: What we're interested in finding from our stat unit information is whether we're
    spending most of our time on our Game CPU, our Game rendering operations, or on
    our GPU. We're looking for the largest number, because this is going to tell us
    what we need to fix.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从stat unit信息中感兴趣的是我们是否在Game CPU、Game渲染操作或GPU上花费了大部分时间。我们寻找最大的数字，因为这将告诉我们需要修复的问题。
- en: You should make it a habit to leave stat fps and stat unit on nearly all the
    time as you develop. If you introduce something new to the scene that is going
    to hammer your frame rate, the best time to discover this is when you put it in.
    If you go a long time before you discover a problem, you're going to have to do
    a lot more work to find out what caused it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您应该养成几乎一直保持stat fps和stat unit的习惯。如果您引入了新的场景，会导致帧率下降，那么发现问题的最佳时间就是在放入场景时。如果您很长时间才发现问题，那么您将需要做更多的工作来找出问题的原因。
- en: 'It''s often worth it to see how your stat unit values are changing over time,
    either as things happen in your application (this is useful for finding hitches)
    or as you move through the scene. To get this information, use stat unitgraph
    to display a graph over time of your scene''s performance metrics:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 查看统计单位值随时间变化的情况通常是值得的，无论是在应用程序中发生的事情（这对于找到卡顿很有用）还是在场景中移动时。要获取这些信息，请使用stat unitgraph来显示场景性能指标随时间变化的图表：
- en: '![](img/971499d0-346e-437d-b48f-f10bb04678da.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/971499d0-346e-437d-b48f-f10bb04678da.png)'
- en: You'll see that your stat unit values have now been color-coded to correspond
    with lines on the graph.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到您的stat unit值现在已经被彩色编码以对应图表上的线条。
- en: As mentioned previously, most of the time, your problems will be with the GPU
    art that's just too heavy to fit within your scene.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数情况下，您的问题将与GPU艺术品有关，这些艺术品太重而无法适应您的场景。
- en: Of course, if you're doing ridiculous things on your Tick, you may be getting
    killed on your CPU, in which case you're going to want to look for Blueprints
    that could be refactored to act in response to events or changes in data instead
    of using the tick. But, most of the time, GPU is where you're going to run into
    trouble.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您在Tick上做了荒谬的事情，您的CPU可能会被杀死，这种情况下，您将希望寻找可以重构以响应事件或数据变化而不是使用Tick的蓝图。但是，大多数情况下，您可能会遇到GPU的问题。
- en: Profiling the GPU
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对GPU进行分析
- en: 'The first tool you should learn to use in optimizing your scene is the GPU
    profiler. You can activate this by typing profilegpu in the console, but since
    you''re going to use it so often, it''s a better idea to memorize the hotkey:
    *Ctrl* + *Shift* + *,* (comma). Hit it now and let''s look at the numbers:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 优化场景时，您应该学会使用的第一个工具是GPU分析器。您可以在控制台中输入profilegpu来激活它，但由于您将经常使用它，最好记住快捷键：Ctrl
    + Shift + ,（逗号）。现在按下它，让我们看看数字：
- en: '![](img/97c0ff5f-9d7a-462c-a3b4-3a2ee3630f01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97c0ff5f-9d7a-462c-a3b4-3a2ee3630f01.png)'
- en: The most important part of this profile report is the graph under the Scene
    heading. Roll over the graph, and you'll see that tooltips tell you what each
    block represents. The two biggest blocks will usually be your BasePass and your
    PostProcessing pass. The base pass represents the act of drawing everything in
    the scene. Post processing handles anything that's taken care of after the scene
    has been drawn, such as screen-space ambient occlusion, color correction, and
    other effects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件报告的最重要部分是场景标题下的图表。将鼠标悬停在图表上，您将看到工具提示告诉您每个块代表什么。最大的两个块通常是您的BasePass和PostProcessing
    pass。基本传递表示绘制场景中的所有内容的行为。后处理处理在场景绘制完成后处理的任何内容，例如屏幕空间环境遮挡、颜色校正和其他效果。
- en: 'Hit the expander to the left of the Scene heading to drill down for more detail
    into your scene rendering:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 点击场景标题左侧的展开器，以获取更多关于场景渲染的详细信息：
- en: '![](img/ae6955a0-d425-4afa-8eb5-9d33ee1045fa.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae6955a0-d425-4afa-8eb5-9d33ee1045fa.png)'
- en: Here, we can see a more detailed breakdown of what's costing us time in drawing
    our frame. Lighting looks good here, as does translucency. Our BasePass is fairly
    sizeable, but that's to be expected.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到更详细的细分，了解绘制帧所花费的时间。光照看起来很好，透明度也很好。我们的BasePass相当大，但这是可以预料的。
- en: 'You''re not going to get too much more information by drilling down into your
    BasePass, but you can learn some useful stuff by drilling into your PostProcessing
    operations. Use the triangle beside your PostProcessing header to drill into it,
    and then click on large chunks in your PostProcessing operations to see what they
    are:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深入研究BasePass，您不会获得太多更多的信息，但是通过深入研究PostProcessing操作，您可以学到一些有用的东西。使用PostProcessing标题旁边的三角形进行深入研究，然后单击PostProcessing操作中的大块以查看它们是什么：
- en: '![](img/d6640a19-f716-4575-8685-0433e7722b89.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6640a19-f716-4575-8685-0433e7722b89.png)'
- en: In this instance, these post numbers look pretty good. We don't have anything
    returning an unreasonably high duration.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这些后续数字看起来相当不错。我们没有任何一个持续时间过长的问题。
- en: Make sure you profile with the game running, or you'll see a lot of operations
    coming from the editor.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在游戏运行时进行分析，否则您将看到许多来自编辑器的操作。
- en: We're not going to have the space here to dig into everything involved in the
    rendering process and what it means, but in general, what you're looking for are
    large items that may be unnecessarily impacting your frame rate. When you find
    something that looks suspicious, search for it on the Unreal forums, and you'll
    likely find a discussion of what it means and what to do about it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有足够的空间来深入研究渲染过程和其含义的所有内容，但总的来说，您要寻找的是可能不必要地影响帧率的大型项目。当您发现看起来可疑的东西时，在虚幻论坛上搜索它，您可能会找到关于它的讨论以及如何处理它的方法。
- en: As you use this tool more and more, you'll develop a sense for what looks healthy
    and what problem areas look like. Use it often to get a clear handle on what your
    application is doing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您越来越多地使用这个工具，您会逐渐对健康的外观和问题区域的外观有所了解。经常使用它来清楚地了解您的应用程序正在做什么。
- en: Now, let's look at a few other useful commands we can use to debug our scene.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些其他有用的命令，我们可以用来调试我们的场景。
- en: Stat scenerendering
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stat scenerendering
- en: 'Behind the GPU profiler, your next most useful command is likely to be stat
    scenerendering. This command gives you a detailed list of the steps your system
    is taking to render the scene with their associated timings:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU分析器之后，您下一个最有用的命令可能是stat scenerendering。该命令会详细列出系统在渲染场景时所采取的步骤及其相关的时间：
- en: '![](img/6087c36f-4f15-4688-b71f-292166f05f8a.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6087c36f-4f15-4688-b71f-292166f05f8a.png)'
- en: It's especially worthwhile in here to look at your Dynamic shadow setup and
    your Translucency drawing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里特别值得一看的是您的动态阴影设置和透明度绘制。
- en: If you're seeing high values in your shadow setup, see whether one or more of
    your lights is doing too many shadow cascades or has a shadow distance that's
    too long. You can find more information on this topic at [https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow](https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在阴影设置中看到较高的值，请查看是否有一个或多个灯光正在执行过多的阴影级联或具有过长的阴影距离。您可以在此主题的[https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow](https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow)上找到更多信息。
- en: 'If your Translucency drawing is high, activate your editor''s Quad Overdraw
    optimization viewmode, and look for translucent objects stacking over one another.
    If you have a problem here, you might be able to solve it by using masked rather
    than translucent materials, or by being careful about how they overlap in views:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的透明度绘制很高，请激活编辑器的Quad Overdraw优化视图模式，并查找互相堆叠的透明对象。如果您在这里有问题，您可以尝试使用遮罩材质而不是透明材质，或者注意它们在视图中的重叠情况：
- en: '![](img/acd1e832-c2fe-4486-89d3-c317d9df8bd0.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acd1e832-c2fe-4486-89d3-c317d9df8bd0.png)'
- en: 'At the bottom of this list are some very important numbers: Mesh draw calls
    and Static List draw calls. We should talk about these.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表的底部有一些非常重要的数字：网格绘制调用和静态列表绘制调用。我们应该谈谈这些。
- en: Draw calls
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制调用
- en: 'One of the biggest factors that will impact your scene performance is the number
    of **draw calls** required to get its information onto the GPU. What are we talking
    about here? It breaks down like this: everything you want the video card to draw
    has to be copied onto that card''s memory. The act of sending a set of instructions
    to the card is called a draw call, or a **draw primitive call** (sometimes abbreviated
    to **DPC**). Let''s say you have a static mesh appearing in your scene that has
    three materials on it. That''s going to take four draw calls to set it up on the
    card: one for the mesh, and one for each material. You should endeavor to keep
    the number of draw calls in your scene as low as you can get it. Realistically,
    2,000 draw calls is probably your limit for a VR scene. On mobile VR, like the
    Oculus Go or Quest, that number is lower.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 影响场景性能的最大因素之一是将信息传输到GPU所需的绘制调用次数。我们在这里讨论什么？情况如下：你希望显卡绘制的所有内容都必须复制到该显卡的内存中。向显卡发送一组指令的行为称为绘制调用，或称为绘制原语调用（有时缩写为DPC）。假设你的场景中出现了一个静态网格，上面有三个材质。这将需要四个绘制调用来设置它在显卡上的绘制：一个用于网格，每个材质一个。你应该尽量减少场景中的绘制调用次数。实际上，对于VR场景，2000个绘制调用可能是你的限制。在移动VR中，如Oculus
    Go或Quest，这个数字更低。
- en: What does this mean for you? First, put as few materials on your objects as
    you can get away with; ideally, one material per object. By adding just one more
    material slot, you've literally added one-third more to the cost of loading that
    object onto the video hardware, and if that object appears frequently in your
    scene, that's going to add up in a hurry.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你意味着什么？首先，尽量少地在物体上使用材质；理想情况下，每个物体只使用一个材质。只需添加一个额外的材质槽，你就增加了加载该物体到视频硬件的成本的三分之一，如果该物体在场景中频繁出现，这个成本会迅速累积。
- en: We're going to talk shortly about what you can do about high draw call counts,
    but for now what you need to know about them is that, if these numbers are high,
    you're sending too many separate instructions to the video card, and that's going
    to slow you down. Maybe you have too many material slots on your objects, or too
    many individual objects being sent separately, but in all cases, it's a thing
    you'll need to fix.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会讨论如何处理高绘制调用次数的方法，但现在你需要知道的是，如果这些数字很高，说明你向显卡发送了太多的单独指令，这会减慢速度。也许你的物体上有太多的材质槽，或者有太多单独发送的物体，但在所有情况下，这都是你需要解决的问题。
- en: Stat RHI
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stat RHI
- en: 'Another closely related command you''ll use often is stat rhi. **RHI** stands
    for **rendering hardware interface**, and it tells you specifically what''s impacting
    your rendering performance:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与之密切相关的经常使用的命令是stat rhi。RHI代表渲染硬件接口，它告诉你具体影响渲染性能的是什么：
- en: '![](img/bc2c62aa-340e-407c-99c4-2d67ef13d687.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc2c62aa-340e-407c-99c4-2d67ef13d687.png)'
- en: The two values you'll care most about here are Triangles drawn and your DrawPrimitive
    calls. Make it a habit to look through your scene with these values displayed,
    and look for views with unreasonably high triangle counts or draw call counts.
    For a VR scene on a desktop VR headset, you want to keep the number of triangles
    drawn below 2 million, and you want to keep your draw calls under 2,000.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你最关心的两个值是绘制的三角形数量和绘制原语调用次数。养成查看这些值的习惯，并寻找三角形数量或绘制调用次数过高的视图。对于桌面VR头显上的VR场景，你希望将绘制的三角形数量保持在200万以下，并且将绘制调用次数保持在2000以下。
- en: The other value you should care about here is your memory consumption. Another
    way to get a scene running really slowly in real time is to use textures that
    are unreasonably large. Don't put a 4K texture on a pebble. We've seen it happen.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你还应该关注的另一个值是内存消耗。在实时场景中，使用过大的纹理也会导致场景运行非常缓慢。不要将4K纹理放在小石子上。我们见过这种情况发生。
- en: '`Stat rhi` is one of the most useful commands overall for getting a general
    sense of how well your scene is fitting within its budget.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stat rhi`是获取场景在预算内的整体感觉最有用的命令之一。'
- en: Stat memory
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计内存
- en: 'When you need more information about what''s blowing your memory budget, you
    can use stat memory:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要更多关于内存预算超支的信息时，可以使用stat memory：
- en: '![](img/d76c5890-822a-441f-9c67-8ade3e67b798.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d76c5890-822a-441f-9c67-8ade3e67b798.png)'
- en: Most of the time, if you're consuming too much memory, the culprit will be textures.
    Be on the lookout for textures that are too large for what they're being used
    for. A huge object or a hero character might warrant a 2048x2048 texture. Anything
    else should be 1024x1024 or smaller. A 4K texture is probably not reasonable under
    any circumstances in VR. As you consider where to cut your textures down, look
    at the object in scene. How big is it? How close can the player get to it? Is
    it something the player really cares about looking at? It's awfully easy to spend
    way too much on an object the player can barely see. Start to think in terms of
    spending your texture and polycount budgets where they matter, and economizing
    where you can get away with it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，如果你的内存消耗过高，罪魁祸首往往是纹理。要注意使用过大的纹理。一个巨大的物体或主角角色可能需要一个2048x2048的纹理。其他任何东西都应该是1024x1024或更小。在VR中，使用4K纹理可能在任何情况下都不合理。在考虑如何减少纹理时，看看场景中的物体。它有多大？玩家能走多近？玩家真的在意看它吗？很容易在玩家几乎看不到的物体上花费太多。开始考虑在重要的地方使用纹理和多边形预算，并在可以节省的地方节约。
- en: Optimization view modes
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化视图模式
- en: In addition to the stat commands, we also have a few optimization view modes
    that can be used to find problems in your scene. These are each accessed from
    the editor viewport's view mode menu. We're just going to talk about two of them
    here.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了统计命令之外，我们还有一些优化视图模式，可以用来找出场景中的问题。这些模式可以从编辑器视口的视图模式菜单中访问。我们这里只讨论其中的两个。
- en: 'The Shader Complexity view shows you where your materials may be slowing you
    down. When you find a suspect object, select it, and see what''s going on in its
    materials. Is your material too complicated or doing expensive math? Consider
    the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器复杂度视图显示了可能导致性能下降的材质位置。当您找到一个可疑的对象时，选择它，并查看其材质中发生了什么。您的材质是否过于复杂或进行了昂贵的计算？考虑以下截图：
- en: '![](img/2e5b4544-4e4d-4bb0-87b6-e97ca675ea5a.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e5b4544-4e4d-4bb0-87b6-e97ca675ea5a.png)'
- en: In the case of the preceding screenshot, the grass and tree are registering
    as expensive materials. When we select their objects and look at those materials,
    we can see that what's driving up their cost is that they use their World Position
    Offset input to simulate wind. That's expensive, but it's a nice effect and the
    player would notice if we turned it off, so we can leave it alone since the rest
    of our scene is running pretty efficiently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，草和树被识别为昂贵的材质。当我们选择它们的对象并查看这些材质时，我们可以看到推高成本的原因是它们使用了世界位置偏移输入来模拟风。这是昂贵的，但是这是一个很好的效果，如果我们关闭它，玩家会注意到，所以我们可以不管它，因为我们场景的其余部分运行得相当高效。
- en: Use this view to search for materials that may be costing you a lot without
    adding much value to the scene.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此视图搜索可能会消耗大量资源但对场景没有太多价值的材质。
- en: The Light Complexity view comes into play if you're using dynamic lights under
    the deferred shading model. Because we're using forward rendering and static lights
    here, it won't show us anything on this scene. When you are using dynamic lights
    and deferred shading, this view can show you where your lights are causing problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在延迟渲染模型下使用动态光源，那么光照复杂度视图就会起作用。因为我们在这里使用的是正向渲染和静态光源，所以在这个场景中不会显示任何内容。当您使用动态光源和延迟渲染时，这个视图可以显示您的光源引起的问题所在。
- en: CPU profiling
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU分析
- en: If you're having trouble with your CPU times, you can use CPU profiling to find
    out where the problems are, just as we did earlier with the GPU profiler.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的CPU时间有问题，您可以使用CPU分析来找出问题所在，就像我们之前使用GPU分析器一样。
- en: To activate CPU profiling, while the game is running, open a console command
    and type stat startfile to begin profiling. Profiling generates a lot of data,
    so you don't want to run your profiler over an entire session – just capture things
    you're interested in, such as, *why does the game slow down so much when that
    character alerts to an enemy?*
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活CPU分析，在游戏运行时，打开控制台命令并键入`stat startfile`开始分析。分析会生成大量数据，所以您不希望在整个会话中运行分析器-只捕获您感兴趣的内容，比如“为什么当角色警报敌人时游戏会变得如此缓慢？”
- en: After you've captured whatever you're looking for, type `stat stopfile` to turn
    profiling back off. The profiler will save the captured data to a `.ue4stats`
    file in your project's `\Saved\Profiling\UnrealStats\` directory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获到您要查找的内容后，键入`stat stopfile`以关闭分析。分析器将把捕获的数据保存到项目的`\Saved\Profiling\UnrealStats\`目录下的`.ue4stats`文件中。
- en: 'Now, open your Unreal Engine''s install directory, and, inside its `Binaries\Win64`
    folder, look for the `UnrealFrontend.exe` application. Launch it and use the tabs
    to select Session | Frontend | Profiler. Use the profiler''s Load button to open
    the `.ue4stats` file you just generated:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您的虚幻引擎安装目录，在其中的`Binaries\Win64`文件夹中找到`UnrealFrontend.exe`应用程序。启动它并使用选项卡选择Session
    | Frontend | Profiler。使用分析器的加载按钮打开刚刚生成的`.ue4stats`文件：
- en: '![](img/79471103-c543-4e39-80c6-7eaf659f054e.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79471103-c543-4e39-80c6-7eaf659f054e.png)'
- en: The CPU Profiler shows you how much time each operation called during a frame
    takes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: CPU分析器显示了每个帧调用的操作所花费的时间。
- en: Just as we did with the GPU profiler, you can use this tool to burrow through
    expensive-looking function calls and see what's going on. It would take us beyond
    the scope of this book to go deeply into using the CPU profiler here—it's an extremely
    useful and powerful tool, but it does take some time to learn how to get good
    information from it. We recommend that you explore the write-up on the topic to
    go further, which can be found at [https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance](https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在GPU分析器中所做的那样，您可以使用此工具来查看昂贵的函数调用并了解发生了什么。在这本书的范围之外，我们无法深入介绍如何在此处使用CPU分析器-它是一个非常有用和强大的工具，但需要一些时间来学习如何从中获取有用的信息。我们建议您探索有关此主题的详细信息，可以在[https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance](https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance)找到。
- en: Turning things on and off
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开和关闭功能
- en: As primitive as it may sound, one of the most effective ways to find out what's
    costing you frame rate is simply to turn features on and off with the relevant
    stat information displayed (usually, stat unit is what you want for this). Use
    the viewport's Show menu to turn individual elements on and off, especially if
    you've determined through your GPU profiling or your stat information that the
    thing in question might be causing a problem. It can also be helpful to start
    deleting objects from your level (as long as you have a backup or it's under source
    control), and see whether a particular object makes a big change.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来很原始，但是找出导致帧率下降的原因最有效的方法之一就是打开和关闭相关统计信息显示的功能（通常，`stat unit`是您想要的）。使用视口的显示菜单打开和关闭单个元素，特别是如果您通过GPU分析或统计信息确定该元素可能会引起问题。如果从您的关卡中删除对象（只要您有备份或它在源代码控制下），并查看是否有特定对象会产生很大的变化，这也可能会有所帮助。
- en: Addressing frame rate problems
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决帧率问题
- en: Now that we've learned a bit about how to find problems in your scene, let's
    talk a bit about what to do about them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何找到场景中的问题，让我们谈谈如何处理这些问题。
- en: Cleaning up Blueprint Tick events
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理蓝图的Tick事件
- en: If you're seeing high numbers on your CPU, one of the first culprits you want
    to look for is any Blueprint doing operations on the Tick event. This is an extremely
    common culprit. Remember that Tick events happen every single frame, so if you're
    doing a lot of work on your Tick, you're impacting every single frame you need
    to draw. Look for ways to spread this work out over multiple frames, or to avoid
    using the Tick altogether and use events to make objects change their state only
    when something changes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在CPU上看到很高的数字，你要寻找的第一个罪魁祸首之一就是在Tick事件上执行操作的蓝图。这是一个非常常见的问题。请记住，Tick事件在每一帧都会发生，所以如果你在Tick上做了很多工作，你就会影响到每一帧的绘制。寻找将这个工作分散到多个帧上的方法，或者避免使用Tick，只在发生变化时使用事件来改变对象的状态。
- en: Managing skeletal animations
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理骨骼动画
- en: If you have a lot of skeletal meshes animating, make sure they don't have a
    ridiculous number of bones in their skeletons, and make sure they're not using
    a ton of blend space animations. It's a much better practice to use skeletal mesh **Level
    of Detail** (**LOD**) to include fine details only when the player can see them,
    or to use separate skeletal meshes for cinematics, where highly-detailed facial
    animations matter, and for in-game meshes, use skeletons with lower bone counts.
    For more information on setting up skeletal mesh LODs, begin by looking at [https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs](https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多骨骼网格在进行动画，确保它们的骨架中没有荒谬的骨骼数量，并确保它们没有使用大量的混合空间动画。最好的做法是使用骨骼网格的细节层次（LOD），只在玩家能看到时包含细节，或者在电影中使用单独的骨骼网格，其中高度详细的面部动画很重要，并且在游戏中使用骨骼数量较低的骨骼网格。有关设置骨骼网格LOD的更多信息，请从以下链接开始查看：[https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs](https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs)。
- en: Merging actors
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并演员
- en: This is a big one. Remember a short while ago when we mentioned that draw call
    counts have a big impact on your frame rate? One of the cheapest and easiest ways
    to drop your draw call counts is to merge multiple meshes into a single mesh.
    This will not only create a single mesh out of the multiple individual meshes
    you've selected, but it will also create a combined material for that mesh out
    of each child mesh's materials. This is a big deal.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的问题。还记得不久前我们提到过绘制调用数量对帧率有很大影响吗？将多个网格合并成一个单一的网格是降低绘制调用数量的最便宜和最简单的方法之一。这不仅会将你选择的多个单独网格创建为一个单一网格，还会为该网格创建一个合并的材质，其中包含每个子网格的材质。这是一个重要的事情。
- en: Let's say you have a bunch of debris in a corner of a room; maybe 25 objects
    or so, and each of them uses one material slot. You're looking at 50 draw calls
    right there, out of a total of maybe 2,000 that you have available for your entire
    scene. That's a big hit. By merging these into a single object, you can drop 50
    draw calls down to two. This is one of the fastest and most effective ways you
    can bring down your draw call count.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在房间的一个角落里有一堆碎片；大约有25个物体，每个物体使用一个材质槽。这样一来，你就会有50个绘制调用，而你整个场景可用的绘制调用总数可能是2000个。这是一个很大的负担。通过将它们合并成一个单一的物体，你可以将50个绘制调用减少到两个。这是你可以减少绘制调用数量的最快和最有效的方法之一。
- en: 'One caveat about this though: remember earlier in this book when we talked
    about Kent Beck''s advice to *make it work, make it right, make it fast*? This
    is one of those areas where that wisdom applies. Once you bake all these objects
    into a single object, you no longer have the freedom to rearrange the individual
    components, so get the scene looking the way you want it, and then merge your
    actors to bring things under control.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这里有一个需要注意的地方：还记得在本书前面我们提到过Kent Beck的建议“让它工作，让它正确，让它快”吗？这是其中一个适用的领域。一旦你将所有这些物体合并成一个单一的物体，你就不再有重新排列各个组件的自由，所以先让场景看起来符合你的要求，然后合并你的演员以控制事物。
- en: 'Here''s how to do it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何操作：
- en: 'Select Window | Developer Tools | Merge Actors. The Merge Actors window will
    appear. Select the actors you want to merge. In general, it''s a good idea to
    merge actors that are close together and likely to be in the same view. Once they''re
    merged, all of them will be drawn even if only one of them is on camera, so merge
    items that are all going to be on camera simultaneously most of the time:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 选择窗口 | 开发者工具 | 合并演员。合并演员窗口将出现。选择要合并的演员。一般来说，合并那些靠近并且可能在同一视图中的演员是一个好主意。一旦它们被合并，即使只有其中一个在镜头中，所有它们都将被绘制，所以合并那些大部分时间都会同时出现在镜头中的物体：
- en: '![](img/050ceecf-612a-4b08-a493-794364c8321a.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/050ceecf-612a-4b08-a493-794364c8321a.png)'
- en: The Merge Actors dialog seen with multiple selected actors in the viewport behind
    it
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在视口后面看到多个选定演员的合并演员对话框
- en: If you select Replace Source Actors, the actors you've selected in-scene will
    be replaced by the merged model. For more information about merging actors, begin
    with [https://docs.unrealengine.com/en-us/Engine/Actors/Merging](https://docs.unrealengine.com/en-us/Engine/Actors/Merging).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择替换源演员，则在场景中选择的演员将被合并模型替换。有关合并演员的更多信息，请从以下链接开始：[https://docs.unrealengine.com/en-us/Engine/Actors/Merging](https://docs.unrealengine.com/en-us/Engine/Actors/Merging)。
- en: Using mesh LODs
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格LOD
- en: The number of triangles you're drawing in a scene (usually called the **polycount**)
    is another huge factor in determining your scene's rendering speed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中绘制的三角形数量（通常称为多边形数量）是决定场景渲染速度的另一个重要因素。
- en: Of course, your first line of defense against high polycounts is in modeling.
    Use an application such as Pixologic's ZBrush to bake normal maps from a high-detail
    model, and apply them to a lower-detail mesh that you import into the game engine.
    Much of the time, your players will never notice the difference. VR is less forgiving
    of using normal maps to simulate geometric detail than the flat screen is, because
    players can sometimes see that the depth isn't real, but you should still make
    use of this technique anywhere you can get away with it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对抗高面数的第一道防线是建模。使用像Pixologic的ZBrush这样的应用程序，从高细节模型中烘焙法线贴图，并将其应用于导入游戏引擎的低细节网格。大部分时间，你的玩家都不会注意到区别。虚拟现实对使用法线贴图模拟几何细节的宽屏显示器不太宽容，因为玩家有时会看到深度不是真实的，但你仍然应该在任何可以使用这种技术的地方使用它。
- en: 'Once you have a mesh in-game, however, you have a powerful LOD tool available
    to you to manage how many triangles you''re drawing. LODs work like this: they
    store several versions of the same model, with increasingly small polycounts.
    As the model gets smaller on screen, the system switches out the high-detail mesh
    for a lower-detail mesh, since the player won''t be able to see the detail anyway,
    now that it''s further away.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你在游戏中有了一个网格，你就有一个强大的LOD工具可用于管理你绘制的三角形数量。LOD的工作原理如下：它们存储了同一模型的几个版本，其面数逐渐减小。随着模型在屏幕上变小，系统会将高细节网格替换为低细节网格，因为玩家无法看到远离的细节。
- en: 'Here''s how to set up an LOD:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何设置LOD：
- en: Select a static mesh and open the Static Mesh editor from the content browser.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个静态网格，并从内容浏览器中打开静态网格编辑器。
- en: Under its Details, look for the LOD Settings section.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息下，找到LOD设置部分。
- en: Find the Number of LODs entry, and set it to a value greater than  1\. (For
    this test, just set it to 2 to create 2 LODs.)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到LOD数量条目，并将其设置为大于1的值。（对于此测试，只需将其设置为2以创建2个LOD。）
- en: Click on Apply Changes. One or more additional LOD models will now be created
    and added to the static mesh asset.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用更改”。现在将创建一个或多个额外的LOD模型，并将其添加到静态网格资源中。
- en: Under the LOD Picker section, find the LOD entry, and use it to select one of
    the new LODs.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在LOD选择器部分，找到LOD条目，并使用它选择一个新的LOD。
- en: LOD 0 is the original model. Most of the time you'll leave this unchanged. LOD
    1 is the first LOD after LOD 0.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: LOD 0是原始模型。大部分时间你会保持不变。LOD 1是LOD 0之后的第一个LOD。
- en: With the new LOD, such as LOD 1, selected, open the Reduction Settings entry
    from its LOD detail section and modify it.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个新的LOD，比如LOD 1，打开其LOD详细部分的减少设置条目并进行修改。
- en: 'You have a number of options available here, but most of the time, you''ll
    be managing the Percent Triangles value. If you make changes here, click on Apply
    Changes to see the result:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多选项，但大部分时间，你将管理三角形百分比值。如果在这里进行更改，请点击“应用更改”以查看结果：
- en: '![](img/6a7ebedb-cecd-4c70-af01-6fdb195e3d3e.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7ebedb-cecd-4c70-af01-6fdb195e3d3e.png)'
- en: You'll see the modified mesh in your viewport. To see what it will look like
    at the real view distance, switch your LOD Picker back to LOD Auto and move your
    view around to see how the object changes as it switches between LODs. The LOD
    generator is surprisingly good.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在视口中看到修改后的网格。为了看到它在真实视距下的样子，将LOD选择器切换回LOD自动，并移动视图以查看对象在LOD之间切换时的变化。LOD生成器非常出色。
- en: For more information about creating and using LODs, start by looking at [https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs](https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建和使用LOD的更多信息，请首先查看[https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs](https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs)。
- en: Static mesh instancing
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态网格实例化
- en: Remember those draw calls we were so concerned about a moment ago? There's another
    powerful way to reduce their count and dramatically speed up your rendering.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们刚才关注的绘制调用吗？还有另一种强大的方法可以减少它们的数量并大大加快渲染速度。
- en: Say you have a big collection of mostly the same assets, such as a forest that
    reuses the same tree mesh hundreds of times. If you simply place those meshes
    in the environment individually, every single one of them is going to generate
    a minimum of two draw calls, and even more if it uses more materials. That's a
    recipe for a slide show. What you want to do instead is **instance** this geometry.
    Instancing is a way of telling your GPU that, even though it's about to draw a
    few hundred meshes, they're really all just the same mesh with different transforms.
    So, instead of making a separate draw call for each tree, the system makes one
    set of draw calls and gives the video hardware a list of locations, orientations,
    and scales at which to draw them. This is wildly faster than passing each item
    as a separate item.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个大的集合，其中大部分是相同的资产，比如一个重复使用相同树木网格数百次的森林。如果你只是单独将这些网格放置在环境中，每一个都会生成至少两个绘制调用，如果使用更多材质则会更多。这是一个幻灯片的制作方法。相反，你想要做的是**实例化**这个几何体。实例化是一种告诉你的GPU的方法，即使它即将绘制几百个网格，它们实际上都是相同的网格，只是具有不同的变换。因此，系统不是为每棵树都进行单独的绘制调用，而是进行一组绘制调用，并向视频硬件提供一个位置、方向和缩放的列表来绘制它们。这比将每个项目作为单独的项目传递要快得多。
- en: By default in Unreal, the easiest way to instance objects is to use the foliage
    tool. While it's most commonly used for foliage, as the name suggests, you can
    also use it for repeated objects in lots of other contexts, like streetlamps on
    city streets. You can find more information on foliage instancing at [https://docs.unrealengine.com/en-us/Engine/Foliage](https://docs.unrealengine.com/en-us/Engine/Foliage).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻中，默认情况下实例化对象的最简单方法是使用植被工具。虽然它通常用于植被，但正如其名称所示，您也可以在许多其他情境中使用它来重复使用对象，比如城市街道上的路灯。您可以在[https://docs.unrealengine.com/en-us/Engine/Foliage](https://docs.unrealengine.com/en-us/Engine/Foliage)上找到有关植被实例化的更多信息。
- en: Instancing static meshes outside the foliage tool is a bit more of a complex
    topic, but it can be done and can be a good idea if you're procedurally generating
    an actor that contains a large array of individual static meshes. Most of the
    time, however, when you're instancing objects in scenes, use the foliage tool
    to do it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景之外实例化静态网格是一个稍微复杂的话题，但是可以做到，并且如果您正在以程序化方式生成包含大量单独静态网格的角色，这可能是一个好主意。然而，大多数情况下，当您在场景中实例化对象时，请使用植被工具来完成。
- en: Nativizing Blueprints
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化蓝图
- en: Blueprints are already interpreted amazingly fast, but they can be made even
    faster by translating them automatically into C++ and then allowing the system
    to compile them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图已经以惊人的速度进行解释，但通过自动将它们转换为C++，然后允许系统编译它们，可以使它们变得更快。
- en: To turn this on, open Project Settings | Project | Packaging | Blueprints, and
    use the Blueprint Nativization Method selector to select **inclusive** or **exclusive** nativization.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开此选项，请打开“项目设置 | 项目 | 打包 | 蓝图”，并使用“蓝图本地化方法”选择器选择**包含**或**独占**本地化。
- en: '**Inclusive** nativization will convert all your Blueprints to C++ when they
    compile.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**本地化将在编译时将所有蓝图转换为C++。'
- en: '**Exclusive** nativization will convert only those Blueprints for which you
    set the nativize flag.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独占**本地化只会转换那些您设置了本地化标志的蓝图。'
- en: 'If you''re using exclusive nativization, select the Blueprints you want to
    nativize by opening their Class Settings, and turn on the Nativize option in their Details
    | Packaging panel. Again, you don''t need to do this if you''re using inclusive
    nativization. In that case, every Blueprint is nativized:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用独占本地化，请通过打开它们的“类设置”来选择要本地化的蓝图，并在其“详细信息 | 打包”面板中打开“本地化”选项。如果您使用包含本地化，则不需要这样做。在这种情况下，每个蓝图都会被本地化：
- en: '![](img/ff134984-41b9-4db7-a36c-3ae3e9514914.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff134984-41b9-4db7-a36c-3ae3e9514914.png)'
- en: If you're planning to ship your application on desktop VR, inclusive nativization
    may be fine, but if you're planning to deploy to mobile VR, such as the Oculus
    Go or Quest, it's probably smarter to use exclusive nativization to choose which
    Blueprints you want to nativize, since including them all can increase your executable
    size.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在桌面VR上发布应用程序，包含本地化可能是可以的，但如果您计划部署到移动VR，比如Oculus Go或Quest，最好使用独占本地化来选择要本地化的蓝图，因为包含所有蓝图可能会增加可执行文件的大小。
- en: This is a bit of an advanced topic. In general, you'll see a benefit if you
    nativize Blueprints that do a lot of work on the Tick event, or that just do a
    lot of work in general. If your Blueprints are fairly simple, you won't really
    see a difference either way. Because speed is so critical to VR development, it's
    good to know that this option is available to you.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比较高级的话题。一般来说，如果您的蓝图在Tick事件上做了很多工作，或者总体上做了很多工作，您将会看到一些好处。如果您的蓝图相当简单，无论如何都不会看到差异。由于速度对于VR开发非常关键，所以了解这个选项是很好的。
- en: If you do plan to do this, turn nativization on early in your project's development,
    and test on cooked builds frequently. Nativization is extremely good, but it can
    sometimes still cause unexpected side effects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划这样做，请在项目开发的早期打开本地化，并经常在烹饪的构建上进行测试。本地化非常好，但有时仍可能导致意外的副作用。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned quite a lot about how to use Unreal's VR Mode editor
    to compose environments from within VR, and we learned how to analyze and optimize
    scenes to see where our performance bottlenecks are.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了如何使用虚幻的VR模式编辑器在VR中组合环境，并学习了如何分析和优化场景以查看性能瓶颈所在。
- en: In the next chapter, we're going to take a detour from building real-time 3D
    worlds in VR and look at another common application – movies and immersive photography.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时离开在VR中构建实时3D世界的内容，转而看另一个常见的应用程序——电影和沉浸式摄影。
