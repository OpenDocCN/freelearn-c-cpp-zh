- en: '*Chapter 7*: Managing Dependencies with CMake'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*7*章：使用CMake管理依赖
- en: It doesn't really matter whether your solution is big or small; as it matures,
    you'll eventually decide to bring in external dependencies. It's important to
    avoid the costs of creating and maintaining code using prevailing business logic.
    This way, you can devote your time to things that matter to you and your customers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解决方案是大型还是小型，并不重要；随着它的成熟，你最终会决定引入外部依赖。避免根据普遍的商业逻辑创建和维护代码的成本是很重要的。这样，你就可以将时间投入到对你和你的客户有意义的事情上。
- en: External dependencies are used not only to provide frameworks and features and
    solve quirky problems. They can also play an important part in the process of
    building and controlling the quality of your code – whether it is in the form
    of special compilers such as **Protobuf** or testing frameworks such as **GTest**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 外部依赖不仅用于提供框架和功能以及解决古怪的问题。它们在构建和控制代码质量的过程中也起着重要的作用——无论是特殊编译器如**Protobuf**，还是测试框架如**GTest**。
- en: Whether you're working with open source projects or using projects written by
    other developers in your company, you still need a good, clean process to manage
    external dependencies. Solving this on your own would take countless hours of
    setup and a lot of additional support work later. Fortunately, CMake does an excellent
    job in accommodating different styles and historical approaches to dependency
    management while keeping up with the constant evolution of industry-approved standards.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在处理开源项目，还是在使用你公司其他开发者编写的项目，你仍然需要一个良好、干净的流程来管理外部依赖。自己解决这个问题将花费无数的设置时间和大量的额外支持工作。幸运的是，CMake在适应不同风格和依赖管理的历史方法的同时，还能跟上行业批准标准的不断演变。
- en: To supply an external dependency, we should first check whether the host system
    already has the dependency available, since it's best to avoid unnecessary downloads
    and lengthy compilations. We'll explore how to find and turn such dependencies
    into CMake targets to use in our project. This can be done in many ways, specifically
    when packages support CMake out of the box or at least provide files for a slightly
    older PkgConfig tool. If that's not the case, we can still write our own file
    to detect and include such a dependency.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个外部依赖，我们首先应该检查宿主系统是否已经有了这个依赖，因为最好避免不必要的下载和漫长的编译。我们将探讨如何找到并把这样的依赖转换成CMake目标，在我们的项目中使用。这可以通过很多方式完成，特别是当包支持CMake开箱即用，或者至少提供给一个稍微老一点的PkgConfig工具的文件时。如果情况不是这样，我们仍然可以编写自己的文件来检测并包含这样的依赖。
- en: We'll discuss what to do when a dependency isn't present on a system. As you
    can imagine, we can take alternative steps to automatically provide the necessary
    files. We'll consider tackling this problem using different Git methods and bringing
    in entire CMake projects as part of our build.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论当一个依赖在系统上不存在时应该做什么。正如你可以想象，我们可以采取替代步骤来自动提供必要的文件。我们将考虑使用不同的Git方法来解决这个问题，并将整个CMake项目作为我们构建的一部分引入。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: How to find installed packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找到已安装的包
- en: Discovering legacy packages with `FindPkgConfig0`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FindPkgConfig0`发现遗留包
- en: Writing your own find-modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的find-modules
- en: Working with Git repositories
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Git仓库协作
- en: Using `ExternalProject` and `FetchContent` modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ExternalProject`和`FetchContent`模块
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter07](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter07).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节中找到的代码文件在GitHub上，地址为[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter07](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter07)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书中提供的示例，总是使用推荐的命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build` `tree>` and `<source` `tree>` with
    appropriate paths. As a reminder: **build tree** is the path to target/output
    directory, **source tree** is the path at which your source code is located.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build` `tree>`和`<source` `tree>`替换为适当的路径。作为提醒：**build tree** 是目标/输出目录的路径，**source
    tree** 是源代码所在的位置的路径。
- en: How to find installed packages
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何找到已安装的包
- en: Alright, let's say that you have decided to up your game with network communication
    or storing data at rest. Plaintext files, JSON, or even good old XML won't do.
    You want to serialize your data straight to binary format, preferably with a library
    known very well in the industry – say, protocol buffers (Protobuf) from Google.
    You find the documentation, install the dependencies in the system, and now what?
    How do we actually tell CMake to find and use this external dependency you're
    introducing? Luckily, there's a `find_package()` command. It works like a charm
    in most cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，假设你已经决定通过网络通信或静态存储数据来提高你的技能。纯文本文件、JSON，甚至是老旧的XML都不行。你希望将你的数据直接序列化为二进制格式，最好使用业界知名的库——比如谷歌的protocol
    buffers（Protobuf）。你找到了文档，在系统中安装了依赖项，现在怎么办？我们实际上如何告诉CMake找到并使用你引入的这项外部依赖？幸运的是，有一个`find_package()`命令。在大多数情况下，它都像魔法一样起作用。
- en: Let's rewind and start by setting the scene – we have to install the dependencies
    we want to use because `find_package()`, as the name suggests, is only about discovering
    packages in a system. We're assuming that dependencies are already installed or
    that users of our solution know how to install specific, necessary dependencies
    when prompted. To cover other scenarios, you'll need to provide a backup plan
    (more on which can be found in the *Working with Git repositories* section).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们倒带并从头开始设置场景——我们必须安装我们想要使用的依赖项，因为`find_package()`，正如其名，只是关于在系统中发现包。我们假设依赖项已经安装，或者我们解决方案的用户知道如何在提示时安装特定的、必要的依赖项。为了覆盖其他场景，你需要提供一个备份计划（关于这方面的更多信息可以在*与Git仓库一起工作*部分中找到）。
- en: 'In the case of Protobuf, the situation is fairly straightforward: you can either
    download, compile, and install the library yourself from the official repository
    ([https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf))
    or use the package manager in your operating system. If you''re following these
    examples using the Docker image mentioned in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014),
    *First Steps with CMake*, you''ll be using Debian Linux. The commands to install
    the Protobuf library and compiler are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Protobuf的情况下，情况相当直接：你可以从官方存储库（[https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf)）下载、编译并自行安装库，也可以使用你操作系统的包管理器。如果你正在使用第[*章
    1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)《*CMake初步*》中提到的Docker镜像，你将使用Debian
    Linux。安装Protobuf库和编译器的命令如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Every system has its own way of installing packages and managing them. Finding
    the path where a package is residing can be tricky and time-consuming, especially
    when you want to support most of the operating systems used today. Fortunately,
    `find_package()` can often do it for you if the package in question provides an
    appropriate **config-file** that allows CMake to determine variables necessary
    to support the package.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都有它自己的安装和管理包的方式。找到一个包所在的路径可能会很棘手且耗时，特别是当你想要支持今天大多数操作系统时。幸运的是，如果涉及的包提供了一个合适的**配置文件**，允许CMake确定支持该包所需的变量，`find_package()`通常可以为你完成这个任务。
- en: 'Today, many projects are compatible with this requirement and provide this
    file for CMake during installation. If you plan to use some popular library that
    doesn''t provide it, don''t worry just yet. Chances are that CMake authors have
    bundled the file with CMake itself (these are called **find-modules**, to differentiate
    from config-files). If that''s not the case, we still have some options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多项目都符合这一要求，在安装过程中提供了这个文件给CMake。如果你计划使用某个流行的库而它没有提供此文件，暂时不必担心。很可能CMake的作者已经将文件与CMake本身捆绑在一起（这些被称为**find-modules**，以便与配置文件区分开来）。如果情况不是这样，我们仍然还有一些选择：
- en: Provide our own find-modules for a specific package and bundle it with our project.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定包提供我们自己的find-modules，并将其与我们的项目捆绑在一起。
- en: Write a config-file and ask package maintainers to ship the package with it.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个配置文件，并请包维护者将该包与文件一起分发。
- en: 'You might say that you''re not quite ready to create such merge requests yourself,
    and that''s fine because it''s most likely you won''t have to. CMake ships with
    over 150 find-modules that can find libraries such as Boost, bzip2, curl, curses,
    GIF, GTK, iconv, ImageMagick, JPEG, Lua, OpenGL, OpenSSL, PNG, PostgreSQL, Qt,
    SDL, Threads, XML-RPC, X11, and zlib, and luckily, also the Protobuf file that
    we''re going to use in this example. A full list is available in the CMake documentation:
    [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find%20modules).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说你还没有完全准备好自己创建这样的合并请求，这没关系，因为很可能你不需要这么做。CMake附带了超过150个查找模块，可以找到如Boost、bzip2、curl、curses、GIF、GTK、iconv、ImageMagick、JPEG、Lua、OpenGL、OpenSSL、PNG、PostgreSQL、Qt、SDL、Threads、XML-RPC、X11和zlib等库，幸运的是，还包括我们在这个例子中将要使用的Protobuf文件。完整的列表在CMake文档中可以找到：[https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find
    modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find%20modules)。
- en: Both find-modules and config-files can be used in CMake projects with a single
    `find_package()` command. CMake looks for matching find-modules, and if it can't
    find any, it will turn to config-files. The search will start from the path stored
    in the `CMAKE_MODULE_PATH` variable (which is empty by default). This variable
    can be configured by a project when it wants to add and use external find-modules.
    Next, CMake will scan the list of built-in find-modules available in the installed
    version of CMake.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块和配置文件都可以在CMake项目中用一个`find_package()`命令。CMake寻找匹配的查找模块，如果找不到任何模块，它会转向配置文件。搜索将从存储在`CMAKE_MODULE_PATH`变量中的路径开始（默认情况下这个变量是空的）。当项目想要添加和使用外部查找模块时，这个变量可以被项目配置。接下来，CMake将扫描安装的CMake版本的内置查找模块列表。
- en: 'If no applicable module is found, it''s time to search for corresponding package
    config-files. CMake has a long list of paths appropriate for a host operating
    system, which can be scanned for filenames matching the following pattern:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到适用的模块，该寻找相应的包配置文件了。CMake有一长串适合宿主操作系统的路径，可以扫描与以下模式匹配的文件名：
- en: '`<CamelCasePackageName>Config.cmake`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<CamelCasePackageName>Config.cmake`'
- en: '`<kebab-case-package-name>-config.cmake`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<kebab-case-package-name>-config.cmake`'
- en: Let's talk a little about the project files; in this example, I don't really
    intend to design a full network-based solution with remote procedure calls and
    all the bells and whistles. Instead, I just want to prove that I can build and
    run a project that depends on Protobuf. To accomplish this, I'm going to create
    a `.proto` file with as small a contract as possible. If you're not that familiar
    with Protobuf, just know that this library provides a mechanism to serialize structured
    data in a binary form. To do so, we need to provide a schema of such a structure,
    which will be used to write and read from binary form into C++ objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈项目文件；在这个例子中，我其实并不打算设计一个带有远程过程调用和所有附件的网络解决方案。相反，我只是想证明我能构建并运行一个依赖于Protobuf的项目。为了实现这一点，我将创建一个尽可能小的合同的`.proto`文件。如果你对Protobuf不是特别熟悉，只需知道这个库提供了一种机制，可以将结构化数据序列化为二进制形式。为此，我们需要提供一个此类结构的模式，它将用于将二进制形式写入和读取C++对象。
- en: 'This is what I came up with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我想出的是这样的：
- en: chapter07/01-find-package-variables/message.proto
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/01-find-package-variables/message.proto
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Don''t worry if you''re not familiar with Protobuf syntax (this isn''t really
    what this example is about). This is just a simple `message` that contains just
    one 32-bit integer. Protobuf has a special compiler that will read these files
    and generate C++ sources and headers that can be then used by our application.
    This means we''ll need to somehow add this compilation step to our process. We''ll
    return to that. For now, let''s see what our `main.cpp` file looks like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉Protobuf语法（这其实不是这个例子真正关注的），不必担心。这是一个只包含一个32位整数的简单`message`。Protobuf有一个特殊的编译器，它会读取这些文件，并生成可以被我们的应用程序使用的C++源文件和头文件。这意味着我们需要将这个编译步骤以某种方式添加到我们的过程中。我们稍后再回到这个问题。现在，让我们看看我们的`main.cpp`文件长什么样：
- en: chapter07/01-find-package-variables/main.cpp
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/01-find-package-variables/main.cpp
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As I've mentioned, `Message` contains a single `id` field. In the `main.cpp`
    file, I'm creating an object representing this message, setting the field to `123`,
    and printing its debug information to the standard output. Next, I'm creating
    a file stream, writing a binary version of this object to it, and closing the
    stream – the simplest possible use for a serialization library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，`Message`包含一个唯一的`id`字段。在`main.cpp`文件中，我创建了一个代表这个消息的对象，将字段设置为`123`，并将其调试信息打印到标准输出。接下来，我创建了一个文件流，将这个对象的二进制版本写入其中，并关闭流——这是序列化库最简单的可能用途。
- en: 'Note that I''ve included a `message.pb.h` header. This file doesn''t yet exist;
    it needs to be created by `protoc`, the Protobuf compiler, during compilation
    of `message.proto`. This scenario sounds pretty complex, implying that the list
    file of such a project must be incredibly long. Not at all! This is where the
    CMake magic happens:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经包含了一个`message.pb.h`头文件。这个文件还不存在；它需要在`message.proto`编译期间由Protobuf编译器`protoc`创建。这种情况听起来相当复杂，暗示这样一个项目的列表文件必须非常长。根本不是！这就是CMake魔法发生的地方：
- en: chapter07/01-find-package-variables/CMakeLists.txt
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/01-find-package-variables/CMakeLists.txt
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s break this down:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: The first two lines we know already; they create the project and declare its
    language.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两行我们已经知道了；它们创建了一个项目和声明了它的语言。
- en: '`find_package(Protobuf REQUIRED)` asks CMake to run the bundled `FindProtobuf.cmake`
    find-module and set up the Protobuf library for us. That find-module will scan
    commonly used paths and (because we provided the `REQUIRED` keyword) terminate
    if a library is not found. It will also specify useful variables and functions
    (such as the one on the next line).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package(Protobuf REQUIRED)` 要求CMake运行捆绑的`FindProtobuf.cmake`查找模块，并为我们设置Protobuf库。那个查找模块将扫描常用路径（因为我们提供了`REQUIRED`关键字）并在找不到库时终止。它还将指定有用的变量和函数（如下面的行所示）。'
- en: '`protobuf_generate_cpp` is a custom function defined in the Protobuf find-module.
    Under the hood, it calls `add_custom_command()`, which invokes the `protoc` compiler
    with appropriate arguments. We use this function by providing two variables that
    will be filled with paths to the generated source (`GENERATED_SRC`) and header
    (`GENERATED_HEADER`) files, and a list of files to compile (`message.proto`).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protobuf_generate_cpp` 是Protobuf查找模块中定义的自定义函数。在其内部，它调用`add_custom_command()`，该命令使用适当的参数调用`protoc`编译器。我们通过提供两个变量来使用这个函数，这些变量将被填充生成的源文件（`GENERATED_SRC`）和头文件（`GENERATED_HEADER`）的路径，以及要编译的文件列表（`message.proto`）。'
- en: '`add_executable`, as we already know, will create our executable using `main.cpp`
    and Protobuf files configured in the previous command.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们所知，`add_executable` 将使用`main.cpp`和前面命令中配置的Protobuf文件创建我们的可执行文件。
- en: '`target_link_libraries` adds libraries (static or shared) found by `find_package()`
    to the linking command of our `main` target.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_link_libraries` 将由`find_package()`找到的（静态或共享）库添加到我们的`main`目标链接命令中。'
- en: '`target_include_directories()` adds to *include paths* the necessary `INCLUDE_DIRS`
    provided by the package and `CMAKE_CURRENT_BINARY_DIR`. The latter is needed so
    that the compiler can find the generated `message.pb.h` header.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_include_directories()` 将必要的`INCLUDE_DIRS`（由包提供）添加到*包含路径*中，以及`CMAKE_CURRENT_BINARY_DIR`。后者是必需的，以便编译器可以找到生成的`message.pb.h`头文件。'
- en: 'In other words, it achieves the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它实现了以下功能：
- en: Finds the location of the library and the compiler
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找库和编译器的所在位置
- en: Provides helper functions to teach CMake how to call a custom compiler for `.proto`
    files
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供辅助函数，教会CMake如何调用`.proto`文件的定制编译器
- en: Adds variables containing the necessary paths for inclusion and linking
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加包含包含和链接所需路径的变量
- en: 'In most cases, you can expect some variables to be set when you call `find_package()`,
    whether you''re using a built-in find-module or a config-file bundled with a package
    (assuming that the package was found):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当你调用`find_package()`时，你可以期待一些变量会被设置，不管你是使用内置的查找模块还是随包附带的配置文件（假设已经找到了包）：
- en: '`<PKG_NAME>_FOUND`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_FOUND`'
- en: '`<PKG_NAME>_INCLUDE_DIRS` or `<PKG_NAME>_INCLUDES`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_INCLUDE_DIRS`或`<PKG_NAME>_INCLUDES`'
- en: '`<PKG_NAME>_LIBRARIES` or `<PKG_NAME>_LIBRARIES` or `<PKG_NAME>_LIBS`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_LIBRARIES`或`<PKG_NAME>_LIBRARIES`或`<PKG_NAME>_LIBS`'
- en: '`<PKG_NAME>_DEFINITIONS`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_DEFINITIONS`'
- en: '`IMPORTED` targets specified by the find-module or config-file'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由查找模块或配置文件指定的`IMPORTED`目标
- en: The last point is really interesting – if a package supports so-called "modern
    CMake" (built around targets), it will provide those `IMPORTED` targets instead
    (or alongside) of these variables, which allows for cleaner, simpler code. It
    is recommended to prioritize targets over variables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个观点非常有趣——如果一个包支持所谓的“现代CMake”（以目标为中心），它将提供这些`IMPORTED`目标而不是这些变量，这使得代码更简洁、更简单。建议优先使用目标而不是变量。
- en: 'Protobuf is a great example, as it offers both variables and `IMPORTED` targets
    (since CMake 3.10): `protobuf::libprotobuf`, `protobuf::libprotobuf-lite`, `protobuf::libprotoc`,
    and `protobuf::protoc`. This allows us to write even more concise code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf是一个很好的例子，因为它提供了变量和`IMPORTED`目标（自从CMake 3.10以来）：`protobuf::libprotobuf`，`protobuf::libprotobuf-lite`，`protobuf::libprotoc`和`protobuf::protoc`。这允许我们编写更加简洁的代码：
- en: chapter07/02-find-package-targets/CMakeLists.txt
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/02-find-package-targets/CMakeLists.txt
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `protobuf::libprotobuf` imported target implicitly specifies *include directories*
    and, thanks to transitive dependencies (or propagated properties as I call them),
    they are shared with our `main` target. The same process happens with the linker
    and compiler flags.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`protobuf::libprotobuf`导入的目标隐式地指定了*包含目录*，并且多亏了传递依赖（或者我叫它们传播属性），它们与我们的`main`目标共享。链接器和编译器标志也是同样的过程。'
- en: 'If you need to know what exactly is provided from a specific find-module, it''s
    best to visit its online documentation. One for Protobuf can be found here: [https://cmake.org/cmake/help/latest/module/FindProtobuf.html](https://cmake.org/cmake/help/latest/module/FindProtobuf.html).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确切知道特定find-module提供了什么，最好是访问其在线文档。Protobuf的一个可以在以下位置找到：[https://cmake.org/cmake/help/latest/module/FindProtobuf.html](https://cmake.org/cmake/help/latest/module/FindProtobuf.html)。
- en: Important Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To keep things simple, examples in this section will simply fail if the protobuf
    library (or its compiler) was not found in the user's system. But a really robust
    solution should verify that by checking the `Protobuf_FOUND` variable and acting
    accordingly, either by printing a clear diagnostic message for the user (so they
    can install it) or performing the installation automatically.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，本节中的示例如果用户系统中没有找到protobuf库（或其编译器）将简单地失败。但一个真正健壮的解决方案应该通过检查`Protobuf_FOUND`变量并相应地行事，要么打印给用户的清晰诊断消息（这样他们可以安装它）要么自动执行安装。
- en: 'The last thing to mention about the `find_package()` command is its options.
    A full list is a bit extensive, so we''ll just focus on the basic signature. It
    looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`find_package()`命令的最后一点是它的选项。完整的列表有点长，所以我们只关注基本的签名。它看起来像这样：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The most important options are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的选项如下：
- en: '`[version]`, which allows us to optionally request a specific version. Use
    the `major.minor.patch.tweak` format (such as `1.22`) or provide a range – `1.22...1.40.1`
    (use three dots as a separator).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[version]`，它允许我们选择性地请求一个特定的版本。使用`major.minor.patch.tweak`格式（如`1.22`）或提供一个范围——`1.22...1.40.1`（使用三个点作为分隔符）。'
- en: The `EXACT` keyword means that we want an exact version (a range is not supported
    here).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXACT`关键字意味着我们想要一个确切的版本（这里不支持版本范围）。'
- en: The `QUIET` keyword silences all messages about a found/not found package.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUIET`关键字可以静默所有关于找到/未找到包的消息。'
- en: The `REQUIRED` keyword will stop execution if a package is not found and print
    a diagnostic message (even if `QUIET` is enabled).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REQUIRED`关键字如果找不到包将停止执行，并打印一个诊断消息（即使启用了`QUIET`也是如此）。'
- en: 'More information on the command can be found on the documentation page here:
    [https://cmake.org/cmake/help/latest/command/find_package.html](https://cmake.org/cmake/help/latest/command/find_package.html).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关命令的更多信息可以在文档页面找到：[https://cmake.org/cmake/help/latest/command/find_package.html](https://cmake.org/cmake/help/latest/command/find_package.html)。
- en: The concept of providing config-files for a package that could be automatically
    consumed by buildsystems isn't that new. And it certainly wasn't invented by CMake.
    There are other tools and formats for this very purpose. PkgConfig is one of them.
    CMake provides a useful wrapper module to support it as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为包提供配置文件的概念并不新鲜。而且它肯定不是CMake发明的。还有其他工具和格式为此目的而设计。PkgConfig就是其中之一。CMake还提供了一个有用的包装模块来支持它。
- en: Discovering legacy packages with FindPkgConfig
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FindPkgConfig发现遗留的包
- en: The problem of managing dependencies and discovering all the compile flags that
    they require is as old as C++ libraries themselves. There are many tools to deal
    with it, ranging from very small and minimal mechanisms to very versatile solutions
    offered as parts of buildsystems and IDEs. One of the (once very popular) tools
    is called PkgConfig ([freedesktop.org/wiki/Software/pkg-config/](http://freedesktop.org/wiki/Software/pkg-config/)).
    It is often available on Unix-like systems (although it works on macOS and Windows
    too).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖项和发现它们所需的所有编译标志的问题与C++库本身一样古老。有许多工具可以处理这个问题，从非常小和简单的机制到作为构建系统和IDE的一部分提供的非常灵活的解决方案。其中一个（曾经非常流行）的工具被称为PkgConfig([freedesktop.org/wiki/Software/pkg-config/](http://freedesktop.org/wiki/Software/pkg-config/)）。它通常在类Unix系统中可用（尽管它也适用于macOS和Windows）。
- en: '`pkg-config` is slowly being phased out by other more modern solutions. A question
    arises here – should you invest your time in supporting it? The answer is as usual
    – it depends:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg-config`正逐渐被其他更现代的解决方案所取代。这里出现了一个问题——你应该投入时间支持它吗？答案一如既往——视情况而定：'
- en: If a library is really popular, it might already have its find-module in CMake;
    in that case, you probably won't need it.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个库真的很受欢迎，它可能已经有了自己的CMake find-module；在这种情况下，你可能不需要它。
- en: If there's no find-module (or it doesn't work for your library) and a PkgConfig
    `.pc` file is all that library provides, just use what's readily available.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有find-module（或者它不适用于您的库）并且库只提供PkgConfig `.pc`文件，只需使用现成的即可。
- en: Many (if not most) libraries have embraced CMake and provide a package config-file
    in current versions. If you're not publishing your solution and you control the
    environment, use `find_package()` and don't worry about legacy versions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多（如果不是大多数）库已经采用了CMake，并在当前版本中提供了包配置文件。如果您不发布您的解决方案并且您控制环境，请使用`find_package()`，不要担心遗留版本。
- en: Sadly, not all environments can be quickly updated to the latest versions of
    a library. A lot of companies are still using legacy systems in production, which
    are no longer getting the latest packages. In that case, users might be stuck
    with an older (but hopefully compatible) version. And very often, it will provide
    a `.pc` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，并非所有环境都可以快速更新到库的最新版本。许多公司仍在使用生产中的遗留系统，这些系统不再获得最新包。在这种情况下，用户可能只能使用较旧的（但希望兼容）版本。而且经常情况下，它会提供一个`.pc`文件。
- en: Additionally, efforts to support the older PkgConfig format might be worthwhile
    if it means that your project will work out of the box for most users.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果这意味着您的项目可以为大多数用户无障碍地工作，那么支持旧的PkgConfig格式的努力可能是值得的。
- en: In any case, start by using `find_package()`, as described in the previous section,
    and if `<PKG_NAME>_FOUND` is false, fall back on PkgConfig. This way, we cover
    a scenario where an environment gets upgraded and we can just use the main method
    without changing the code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，首先使用`find_package()`，如前一部分所述，如果`<PKG_NAME>_FOUND`为假，则退回到PkgConfig。这样，我们覆盖了一种场景，即环境升级后我们只需使用主方法而无需更改代码。
- en: 'The concept of this *helper tool* is quite simple – the author of the library
    provides a small `.pc` file containing details necessary for compilation and linking,
    such as this one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*助手工具*的概念相当简单——库的作者提供一个小型的`.pc`文件，其中包含编译和链接所需的信息，例如这个：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The format is pretty straightforward, lightweight, and it even supports a basic
    variable expansion. This is why many developers prefer it over complex, robust
    solutions such as CMake. While PkgConfig is extremely easy to use, its features
    are quite limited:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格式相当直接，轻量级，甚至支持基本变量扩展。这就是为什么许多开发者更喜欢它而不是像CMake这样的复杂、健壮的解决方案。尽管PkgConfig极其易于使用，但其功能却相当有限：
- en: Checks to see whether a library exists in the system and if a `.pc` file is
    provided with it
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查系统中是否存在库，并且是否提供了与之一起的`.pc`文件
- en: Checks whether a sufficient version of a library is available
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否有一个库的足够新版本可用
- en: Gets linker flags for a library by running `pkg-config --libs libfoo`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过运行`pkg-config --libs libfoo`获取库的链接器标志
- en: Gets the *include directories* for a library (this field can technically contain
    other compiler flags) – `pkg-config --cflags libfoo`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取库的*包含目录*（此字段技术上可以包含其他编译器标志）——`pkg-config --cflags libfoo`
- en: To properly use PkgConfig in a build scenario, your buildsystem has to find
    the `pkg-config` executable in the OS, run it a few times and provide appropriate
    arguments, and store the responses in variables so they can be passed later to
    the compiler. We already know how to do that in CMake – scan paths known for storing
    helper tools to check whether PkgConfig is installed and then use a few `exec_program()`
    commands to discover how to link dependencies. Even though the steps are limited,
    it seems excessive to do it every time when we'd like to use PkgConfig.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在构建场景中正确使用PkgConfig，您的构建系统需要在操作系统中找到`pkg-config`可执行文件，运行它几次，并提供适当的参数，然后将响应存储在变量中，以便稍后传递给编译器。在CMake中我们已经知道如何做到这一点——扫描已知存储辅助工具的路径以检查是否安装了PkgConfig，然后使用几个`exec_program()`命令来发现如何链接依赖项。尽管步骤有限，但似乎每次使用PkgConfig时都这样做是过于繁琐的。
- en: Fortunately, CMake provides a handy built-in find-module just for that purpose
    – `FindPkgConfig`. It follows most of the rules for regular find modules, but
    instead of providing `PKG_CONFIG_INCLUDE_DIRS` or `PKG_CONFIG_LIBS` variables,
    it sets a variable with a direct path to the binary – `PKG_CONFIG_EXECUTABLE`.
    Unsurprisingly, the `PKG_CONFIG_FOUND` variable is set too – we'll use it to confirm
    that the tool is available in the system and then scan for a package with a `pkg_check_modules()`
    helper command defined in the module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，CMake提供了一个方便的内置查找模块，正是为了这个目的——`FindPkgConfig`。它遵循大多数常规查找模块的规则，但不是提供`PKG_CONFIG_INCLUDE_DIRS`或`PKG_CONFIG_LIBS`变量，而是设置一个变量，直接指向二进制文件的路径——`PKG_CONFIG_EXECUTABLE`。不出所料，`PKG_CONFIG_FOUND`变量也被设置了——我们将使用它来确认系统中是否有这个工具，然后使用模块中定义的`pkg_check_modules()`帮助命令扫描一个`pkg_check_modules()`包。
- en: Let's see that in practice. One example of a somewhat popular library that offers
    a `.pc` file is a client for the PostgreSQL database – `libpqxx`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来实际看看这个过程。一个提供`.pc`文件的相对受欢迎的库的一个例子是一个PostgreSQL数据库的客户端——`libpqxx`。
- en: 'To install it on Debian, you can use the `libpqxx-dev` package (your OS might
    need a different package):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Debian上安装它，您可以使用`libpqxx-dev`包（您的操作系统可能需要不同的包）：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll create the shortest possible `main.cpp` file, which utilizes a dummy
    connection class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个尽可能短的`main.cpp`文件，其中包含一个虚拟连接类：
- en: chapter07/02-find-pkg-config/main.cpp
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/02-find-pkg-config/main.cpp
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And we can now provide the necessary dependencies for the previous code by
    using the PkgConfig find-module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用PkgConfig查找模块为之前的代码提供必要的依赖项：
- en: chapter07/03-find-pkg-config/CMakeLists.txt
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/03-find-pkg-config/CMakeLists.txt
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down what happens:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下发生了什么：
- en: We ask CMake to find the PkgConfig executable with the `find_package()` command.
    It will fail if `pkg-config` is not present because of the `REQUIRED` keyword.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要求CMake使用`find_package()`命令查找PkgConfig可执行文件。如果因为`REQUIRED`关键字而没有`pkg-config`，它将会失败。
- en: A `pkg_check_modules()` custom macro defined in the `FindPkgConfig` find-module
    is called to create a new `IMPORTED` target with `PQXX` as the chosen name. The
    find-module will search for a dependency called `libpxx`, and again, it will fail
    if the library isn't available because of the `REQUIRED` keyword. Note the `IMPORTED_TARGET`
    keyword – without it, no target would be automatically created, and we would have
    to define it manually with variables created by the macro.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`FindPkgConfig`查找模块中定义的`pkg_check_modules()`自定义宏被调用，以创建一个名为`PQXX`的新`IMPORTED`目标。查找模块将搜索一个名为`libpxx`的依赖项，同样，因为`REQUIRED`关键字，如果库不可用，它将会失败。注意`IMPORTED_TARGET`关键字——没有它，就不会自动创建目标，我们必须手动定义由宏创建的变量。
- en: We confirm that everything is correct with a diagnostic message by printing
    `PQXX_FOUND`. If we didn't specify `REQUIRED` in the previous command, we can
    check here whether this variable was set (perhaps to allow other fallback mechanisms
    to kick in).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过打印`PQXX_FOUND`来确认一切是否正确，并显示诊断信息。如果我们之前没有指定`REQUIRED`，我们在这里可以检查这个变量是否被设置（也许是为了允许其他备选机制介入）。
- en: We create the `main` executable.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`main`可执行文件。
- en: We link the `PkgConfig::PQXX` `IMPORTED` target created by `pkg_check_modules()`.
    Note that `PkgConfig::` is a constant prefix, and `PQXX` comes from the first
    argument passed to that command.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们链接了由`pkg_check_modules()`创建的`PkgConfig::PQXX` `IMPORTED`目标。注意`PkgConfig::`是一个常量前缀，`PQXX`来自传递给该命令的第一个参数。
- en: 'This was a fairly convenient method to bring in dependencies that don''t support
    CMake yet. This find-module has a few other methods and options; if you''re interested
    in learning more, I recommend referring to the official documentation: [https://cmake.org/cmake/help/latest/module/FindPkgConfig.html](https://cmake.org/cmake/help/latest/module/FindPkgConfig.html).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当方便的方法，可以引入尚不支持CMake的依赖项。这个查找模块还有其他一些方法和选项；如果你对了解更多感兴趣，我建议你参考官方文档：[https://cmake.org/cmake/help/latest/module/FindPkgConfig.html](https://cmake.org/cmake/help/latest/module/FindPkgConfig.html)。
- en: Find-modules are meant as a very convenient way of providing CMake with information
    on installed dependencies. Most popular libraries are widely supported by CMake
    on all major platforms. What can we do though when we want to use a third-party
    library that doesn't have a dedicated find-module yet?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块旨在为CMake提供一个非常方便的方式来提供有关已安装依赖项的信息。大多数流行的库在所有主要平台上都广泛支持CMake。那么，当我们想要使用一个还没有专用的查找模块的第三方库时，我们能做些什么呢？
- en: Writing your own find-modules
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的查找模块
- en: On a rare occasion, the library that you really want to use in your project
    doesn't provide a config-file or a PkgConfig file, and there's no find-module
    readily available in CMake already. You can then write a custom find-module for
    that library and ship it with your project. This situation is not ideal, but in
    the interest of taking care of the users of your project, it has to be done.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，你真正想在项目中使用的库没有提供配置文件或PkgConfig文件，而且CMake中没有现成的查找模块可供使用。在这种情况下，你可以为该库编写一个自定义的查找模块，并将其与你的项目一起分发。这种情况并不理想，但为了照顾到你的项目的用户，这是必须的。
- en: 'Since we have already become familiar with `libpqxx` in the previous section,
    let''s write a nice find-module for it. We start by writing in a new `FindPQXX.cmake`
    file, which we''ll store in the `cmake/module` directory of our project source
    tree. We need to make sure that the find-module gets discovered by the CMake when
    `find_package()` is called, so we''ll add this path to the `CMAKE_MODULE_PATH`
    variable in our `CMakeLists.txt` with `list(APPEND)`. The whole list file should
    look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在上一节中熟悉了`libpqxx`，那么现在就让我们为它编写一个好的查找模块吧。我们首先在项目中源代码树的`cmake/module`目录下创建一个新文件`FindPQXX.cmake`，并开始编写。我们需要确保当调用`find_package()`时，CMake能够发现这个查找模块，因此我们将这个路径添加到`CMakeLists.txt`中的`CMAKE_MODULE_PATH`变量里，用`list(APPEND)`。整个列表文件应该看起来像这样：
- en: chapter07/04-find-package-custom/CMakeLists.txt
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/04-find-package-custom/CMakeLists.txt
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that''s done, we need to write the actual find-module. Technically speaking,
    nothing will happen if the `FindPQXX.cmake` file is empty: CMake won''t complain
    if some specific variables aren''t set (including `PQXX_FOUND`), even if a user
    calls `find_package()` with `REQUIRED`. It''s up to the author of the find-module
    to respect conventions outlined in CMake''s documentation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个步骤，接下来我们需要编写实际的查找模块。从技术上讲，如果`FindPQXX.cmake`文件为空，将不会有任何事情发生：即使用户调用`find_package()`时使用了`REQUIRED`，CMake也不会抱怨一些特定的变量没有被设置（包括`PQXX_FOUND`），这是查找模块的作者需要尊重CMake文档中概述的约定：
- en: CMake will provide a `<PKG_NAME>_FIND_REQUIRED` variable set to `1` when `find_package(<PKG_NAME>
    REQUIRED)` is called. A find-module should call `message(FATAL_ERROR)` when a
    library is not found.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`find_package(<PKG_NAME> REQUIRED)`时，CMake将提供一个`<PKG_NAME>_FIND_REQUIRED`变量，设置为`1`。如果找不到库，查找模块应该调用`message(FATAL_ERROR)`。
- en: CMake will provide a `<PKG_NAME>_FIND_QUIETLY` variable set to `1` when `find_package(<PKG_NAME>
    QUIET)` is called. A find-module should avoid printing diagnostic messages (other
    than the one mentioned previously).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`find_package(<PKG_NAME> QUIET)`时，CMake将提供一个`<PKG_NAME>_FIND_QUIETLY`变量，设置为`1`。查找模块应避免打印诊断信息（除了前面提到的一次）。
- en: CMake will provide a `<PKG_NAME>_FIND_VERSION` variable set to the version required
    by calling the list file. A find-module should find the appropriate version or
    issue `FATAL_ERROR`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用列表文件时，CMake将提供一个`<PKG_NAME>_FIND_VERSION`变量，设置为所需版本。查找模块应该找到适当的版本，或者发出`FATAL_ERROR`。
- en: 'Of course, it''s best to follow the preceding rules for consistency with other
    find-modules. Let''s discuss the steps needed to create an elegant find-module
    for `PQXX`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了与其他查找模块保持一致性，最好遵循前面的规则。让我们讨论创建一个优雅的`PQXX`查找模块所需的步骤：
- en: If paths to library and headers are known (either provided by a user or coming
    from the cache of a previous run), use these paths and create an `IMPORTED` target.
    End here.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已知库和头文件的路径（要么由用户提供，要么来自之前运行的缓存），使用这些路径并创建一个`IMPORTED`目标。在此结束。
- en: Otherwise, find the library and headers of the nested dependency – PostgreSQL.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，请找到嵌套依赖项——PostgreSQL的库和头文件。
- en: Search the known paths for the binary version of the PostgreSQL client library.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在已知的路径中搜索PostgreSQL客户端库的二进制版本。
- en: Search the known paths for the PostgreSQL client *include headers*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在已知的路径中搜索PostgreSQL客户端*包含头文件*。
- en: Check whether the library and *include headers* were found; if so, create an
    `IMPORTED` target.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否找到了库和*包含头文件*；如果是，创建一个`IMPORTED`目标。
- en: The creation of an `IMPORTED` target happens twice – if the user provides the
    library's paths from the command line or if they're found automatically. We'll
    start by writing a function to handle the result of our search process and keep
    our code DRY.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`IMPORTED`目标发生了两次——如果用户从命令行提供了库的路径，或者如果它们是自动找到的。我们将从编写一个函数来处理我们搜索过程的结果开始，并保持我们的代码DRY。
- en: To create an `IMPORTED` target, we'll simply need a library with an `IMPORTED`
    keyword (to use it in the `target_link_libraries()` command in `CMakeLists.txt`).
    The library has to provide a type – we mark it as `UNKNOWN` to say that we don't
    want to detect whether a found library was static or dynamic; we just want to
    provide an argument to a linker.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`IMPORTED`目标，我们只需要一个带有`IMPORTED`关键字的库（以便在`CMakeLists.txt`中的`target_link_libraries()`命令中使用它）。该库必须提供一个类型——我们将其标记为`UNKNOWN`，以表示我们不希望检测找到的库是静态的还是动态的；我们只想为链接器提供一个参数。
- en: Next, we set the required properties of the `IMPORTED_LOCATION` and `INTERFACE_INCLUDE_DIRECTORIES`
    `IMPORTED` targets to arguments the function was called with. We can specify other
    properties too (such as `COMPILE_DEFINITIONS`); they just aren't necessary for
    `PQXX`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`IMPORTED_LOCATION`和`INTERFACE_INCLUDE_DIRECTORIES``IMPORTED`目标的必需属性设置为函数被调用时传递的参数。我们还可以指定其他属性（如`COMPILE_DEFINITIONS`）；它们对于`PQXX`来说只是不必要的。
- en: After that, we'll store the paths in cache variables so that we don't need to
    perform the search again. It's worth mentioning that `PQXX_FOUND` is set explicitly
    in the cache, and therefore it's visible in the global variable scope (so it can
    be accessed by the user's `CMakeLists.txt`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，我们将路径存储在缓存变量中，这样我们就无需再次执行搜索。值得一提的是，`PQXX_FOUND`在缓存中被显式设置，因此它在全局变量作用域中可见（所以它可以被用户的`CMakeLists.txt`访问）。
- en: 'Finally, we mark cache variables as advanced, which means they won''t be visible
    in the CMake GUI unless the "advanced" option is enabled. This is a common practice
    for these variables and we should follow the convention too:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将缓存变量标记为高级，这意味着除非启用“高级”选项，否则它们不会在CMake GUI中显示。对于这些变量，这是一种常见的做法，我们也应该遵循约定：
- en: chapter07/04-find-package-custom/cmake/module/FindPQXX.cmake
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/04-find-package-custom/cmake/module/FindPQXX.cmake
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we cover the first case – a user who has their `PQXX` installed in a non-standard
    location can provide necessary paths through the command line, with `-D` arguments.
    If that's the case, we just call the function we just defined and abandon the
    search by escaping with `return()`. We trust that the user knows best and provides
    us with correct paths to the library and its dependencies (PostgreSQL).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们覆盖第一种情况——一个用户如果将他们的`PQXX`安装在非标准位置，可以通过命令行（使用`-D`参数）提供必要的路径。如果是这种情况，我们只需调用我们刚刚定义的函数并使用`return()`放弃搜索。我们相信用户最清楚，能提供库及其依赖项（PostgreSQL）的正确路径给我们。
- en: This condition will also be true if the configuration stage was performed in
    the past, as the `PQXX_LIBRARIES` and `PQXX_INCLUDES` variables are cached.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置阶段在过去已经执行过，这个条件也将为真，因为`PQXX_LIBRARIES`和`PQXX_INCLUDES`变量是被缓存的。
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's time to find some nested dependencies. To use `PQXX`, the host machine
    also needs PostgreSQL. It's completely legal to use another find-module in our
    find-module, but we should forward the `REQUIRED` and `QUIET` flags to it (so
    that the nested search behaves consistently with the outer one). It's not complex
    logic, but we should try to avoid unnecessary code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候找到一些嵌套依赖项了。为了使用`PQXX`，宿主机器还需要PostgreSQL。在我们的查找模块中使用另一个查找模块是完全合法的，但我们应该将`REQUIRED`和`QUIET`标志传递给它（以便嵌套搜索与外层搜索行为一致）。这不是复杂的逻辑，但我们应该尽量避免不必要的代码。
- en: 'CMake has a built-in helper macro that does just that – `find_dependency()`.
    Interestingly, the documentation states that it''s not a right fit for find-modules,
    as it calls the `return()` command if the dependency is not found. Because this
    is a macro (and not a function), `return()` will exit the scope of the caller,
    the `FindPQXX.cmake` file, stopping the execution of the outer find-module. There
    may be cases when that''s undesirable, but in this one, this is exactly what we
    want to do – prevent CMake from going down the rabbit hole and looking for the
    components of `PQXX` when we already know that PostgreSQL isn''t available:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CMake有一个内置的帮助宏，正是为此而设计——`find_dependency()`。有趣的是，文档中指出它不适合用于find-modules，因为它如果在找不到依赖项时调用`return()`命令。因为这是一个宏（而不是一个函数），`return()`将退出调用者的作用域，即`FindPQXX.cmake`文件，停止外层find-module的执行。可能有些情况下这是不希望的，但在这个情况下，这正是我们想要做的——阻止CMake深入寻找`PQXX`的组件，因为我们已经知道PostgreSQL不可用：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To find the `PQXX` library, we'll set up a `_PQXX_DIR` helper variable (transformed
    to a CMake-style path) and use the `find_library()` command to scan a list of
    paths we'll provide after the `PATHS` keyword. The command will check for the
    presence of library binaries that match names provided after another keyword,
    `NAMES`. If a matching file is found, its path will be stored in the `PQXX_LIBRARY_PATH`
    variable. Otherwise, the variable will be set to `<VAR>-NOTFOUND`, or `PQXX_HEADER_PATH-NOTFOUND`
    in this case.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到`PQXX`库，我们将设置一个`_PQXX_DIR`帮助变量（转换为CMake风格的路径）并使用`find_library()`命令扫描我们在`PATHS`关键字之后提供的路径列表。该命令将检查是否有与`NAMES`关键字之后提供的名称匹配的库二进制文件。如果找到了匹配的文件，其路径将被存储在`PQXX_LIBRARY_PATH`变量中。否则，该变量将被设置为`<VAR>-NOTFOUND`，在这种情况下是`PQXX_HEADER_PATH-NOTFOUND`。
- en: 'The `NO_DEFAULT_PATH` keyword disables the default behavior, which will scan
    a long list of default paths provided by CMake for this host environment:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`NO_DEFAULT_PATH`关键字禁用了默认行为，这将扫描CMake为该主机环境提供的默认路径列表：'
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we'll search for all known header files with the `find_path()` command,
    which works very similarly to `find_library()`. The main difference is that `find_library()`
    knows the system-specific extensions for the libraries and will implicitly append
    those as needed, and for `find_path()`, we'll need to provide exact names.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`find_path()`命令搜索所有已知的头文件，这个命令的工作方式与`find_library()`非常相似。主要区别在于`find_library()`知道库的系统特定扩展，并将这些扩展作为需要自动添加，而对于`find_path()`，我们需要提供确切的名称。
- en: 'Also, don''t get confused here with `pqxx/pqxx`. It''s an actual header file,
    but the extension was deliberately omitted by library authors to comply with `#include`directives
    in C++ style (rather than following the C-style `.h` extension):`#include <pqxx/pqxx>`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里也不要混淆`pqxx/pqxx`。这是一个实际的头文件，但库作者故意省略了扩展名，以符合C++风格`#include`指令（而不是遵循C风格`.h`扩展名）：`#include
    <pqxx/pqxx>`：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now it's time to check whether the `PQXX_LIBRARY_PATH` and `PQXX_HEADER_PATH`
    variables contain any `-NOTFOUND` value. Again, we can do this manually and then
    print diagnostic messages or terminate the build execution, according to the convention,
    or we could use the `find_package_handle_standard_args()` helper function available
    in the `FindPackageHandleStandardArgs` list file provided by CMake. It's a helper
    command that sets the `<PKG_NAME>_FOUND` variable to `1` if path variables are
    filled and provides the correct diagnostic message about success and failure (it
    will respect the `QUIET` keyword). It will also terminate execution with `FATAL_ERROR`
    if one of the provided path variables is empty when the `REQUIRED` keyword was
    passed to the find-module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查`PQXX_LIBRARY_PATH`和`PQXX_HEADER_PATH`变量是否包含任何`-NOTFOUND`值的时候。同样，我们可以手动进行这项工作，然后根据约定打印诊断信息或终止构建执行，或者我们可以使用CMake提供的`FindPackageHandleStandardArgs`列表文件中的`find_package_handle_standard_args()`帮助函数。这是一个帮助命令，如果路径变量被填充，则将`<PKG_NAME>_FOUND`变量设置为`1`，并提供关于成功和失败的正确诊断信息（它将尊重`QUIET`关键字）。如果传递了`REQUIRED`关键字给find-module，而其中一个提供的路径变量为空，它还将以`FATAL_ERROR`终止执行。
- en: 'If a library was found, we''ll call the function to define the `IMPORTED` targets
    and store the paths in the cache:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了库，我们将调用函数定义`IMPORTED`目标并将路径存储在缓存中：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s it. This find-module will find `PQXX` and create the appropriate `PQXX::PQXX`
    targets. You can find the whole file in the book examples repository: `chapter07/04-find-package-custom/cmake/module/FindPQXX.cmake`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。这个find-module将找到`PQXX`并创建相应的`PQXX::PQXX`目标。你可以在整个文件中找到这个模块，文件位于书籍示例仓库中：`chapter07/04-find-package-custom/cmake/module/FindPQXX.cmake`。
- en: This method works great if a library is popular and most likely already installed
    in the system. However, not all libraries will be available all the time. Can
    we make this easy for our users and fetch and build these dependencies with CMake?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个库很受欢迎，并且很可能会在系统中已经安装，这种方法非常有效。然而，并非所有的库随时都能获得。我们能否让这个步骤变得简单，让我们的用户使用CMake获取和构建这些依赖项？
- en: Working with Git repositories
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Git仓库工作
- en: Many projects rely on Git as a version control system. Assuming that our project
    and external library are both using it, is there some kind of Git magic that would
    allow us to link these repositories together? Can we build a specific (or latest)
    version of the library as a step toward building our project? If so, how?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目依赖于Git作为版本控制系统。假设我们的项目和外部库都在使用它，有没有某种Git魔法能让我们把这些仓库链接在一起？我们能否构建库的特定（或最新）版本，作为构建我们项目的一个步骤？如果是，怎么做？
- en: Providing external libraries through Git submodules
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Git子模块提供外部库
- en: 'One possible solution is to use a mechanism built into Git called **Git submodules**.
    Submodules allow a project repository to use other Git repositories without actually
    adding the referenced files to the project repository. They work similarly to
    soft links – they point to a specific branch or commit in an external repository
    (but you need to update them explicitly). To add a submodule to your repository
    (and clone its repository), execute the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是使用Git内置的机制，称为**Git子模块**。子模块允许项目仓库使用其他Git仓库，而实际上不将引用的文件添加到项目仓库中。它们的工作方式与软链接类似——它们指向外部仓库中的特定分支或提交（但你需要显式地更新它们）。要向你的仓库中添加一个子模块（并克隆其仓库），执行以下命令：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you pulled a repository that already has submodules, you''ll need to initialize
    them:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拉取了一个已经包含子模块的仓库，你需要初始化它们：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can tell, this is a versatile mechanism to leverage third-party code
    in our solution. The small drawback is that submodules don't get automatically
    pulled when a user clones the repository with the root project. An explicit `init`/`pull`
    command is required. Hold that thought – we'll solve it with CMake too. First,
    let's see how we can use a freshly created submodule in our code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个多功能的机制，可以利用第三方代码在我们的解决方案中。一个小缺点是，当用户克隆带有根项目的仓库时，子模块不会自动拉取。需要一个显式的`init`/`pull`命令。暂时保留这个想法——我们也会用CMake解决它。首先，让我们看看我们如何在代码中使用一个新创建的子模块。
- en: For this example, I've decided to write a tiny program that reads a name from
    a YAML file and prints it out in a welcome message. YAML is a great, simple format
    to store human-readable configuration, but it's quite complex to parse by machines.
    I've found a neat, small project that solves this problem by Jesse Beder (and
    92 other contributors at the time) called yaml-cpp ([https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子，我决定写一个小程序，从YAML文件中读取一个名字，并在欢迎消息中打印出来。YAML是一种很好的简单格式，用于存储可读的配置，但机器解析起来相当复杂。我找到了一个由Jesse
    Beder（及当时92名其他贡献者）解决这个问题的整洁小型项目，称为yaml-cpp([https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp))。
- en: 'The example is fairly straightforward. It''s a greeting program that prints
    a `Welcome <name>` message. The default value of `name` will be `Guest`, but we
    can specify a different name in a YAML configuration file. Here''s the code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当直接。它是一个问候程序，打印出`欢迎<名字>`的消息。`name`的默认值将是`Guest`，但我们可以在YAML配置文件中指定一个不同的名字。以下是代码：
- en: chapter07/05-git-submodule-manual/main.cpp
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章/05-git-submodule-manual/main.cpp
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The configuration file for this example is just a single line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的配置文件只有一行：
- en: chapter07/05-git-submodule-manual/config.yaml
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章/05-git-submodule-manual/config.yaml
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s get back to `main.cpp` for a second – it includes the `"yaml-cpp/yaml.h"`
    header. To make it available, we need to clone the `yaml-cpp` project and build
    it. Let''s make an `extern` directory to store all third-party dependencies (as
    suggested in the *Thinking about the project structure* section in [*Chapter 3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Setting Up Your First CMake Project*) and add a Git submodule, referencing the
    library''s repository:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`main.cpp`一会儿——它包含了`"yaml-cpp/yaml.h"`头文件。为了使其可用，我们需要克隆`yaml-cpp`项目并构建它。让我们创建一个`extern`目录来存储所有第三方依赖项（如[第3章](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)、*设置你的第一个CMake项目*部分中所述）并添加一个Git子模块，引用库的仓库：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Git has cloned the repository; we can now add it as a dependency to our project
    and have CMake take care of building:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Git已经克隆了仓库；现在我们可以将其作为项目的依赖项，并让CMake负责构建：
- en: chapter07/05-git-submodule-manual/CMakeLists.txt
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/05-git-submodule-manual/CMakeLists.txt
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s break down what instructions we are giving to CMake here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们在这里给予CMake的指令：
- en: Set up the project and add our `welcome` executable.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置项目并添加我们的`welcome`可执行文件。
- en: Next, call `configure_file` but don't actually configure anything. By providing
    the `COPYONLY` keyword, we just copy our `config.yaml` to the build tree so that
    the executable can find it in runtime.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用`configure_file`，但实际上不配置任何内容。通过提供`COPYONLY`关键字，我们只是将我们的`config.yaml`复制到构建树中，这样可执行文件在运行时能够找到它。
- en: Add the subdirectory of the yaml-cpp repository. CMake will treat it as part
    of the project and recursively execute any nested `CMakeLists.txt` files.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加yaml-cpp仓库的子目录。CMake会将其视为项目的一部分，并递归执行任何嵌套的`CMakeLists.txt`文件。
- en: Link the `yaml-cpp` target provided by the library with the `welcome` target.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库提供的`yaml-cpp`目标与`welcome`目标链接。
- en: Authors of yaml-cpp follow the practices outlined in [*Chapter 3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Setting Up Your First CMake Project* and store public headers in a separate directory
    – `<project-name>/include/<project-name>`. This allows clients of the library
    (such as `main.cpp`) to address the files with paths containing the `"yaml-cpp/yaml.h"`
    library name. Such naming practices are great for discovery – we know immediately
    which library is providing this header.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: yaml-cpp的作者遵循在[*第3章*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)《*设置你的第一个CMake项目*》中概述的实践，并将公共头文件存储在单独的目录中——`<项目名称>/include/<项目名称>`。这允许库的客户（如`main.cpp`）通过包含`"yaml-cpp/yaml.h"`库名称的路径来访问这些文件。这种命名实践非常适合发现——我们立即知道是哪个库提供了这个头文件。
- en: As you can see, this isn't a very complex process, but it isn't ideal – the
    user has to manually initialize the submodule we have added after cloning the
    repository. What's worse is that it doesn't take into account the fact that the
    user might already have this library installed in their system. That means a wasteful
    download and build of this dependency. There has to be a better way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这并不是一个非常复杂的过程，但它并不理想——用户在克隆仓库后必须手动初始化我们添加的子模块。更糟糕的是，它没有考虑到用户可能已经在他们的系统上安装了这个库。这意味着浪费了下载并构建这个依赖项的过程。一定有更好的方法。
- en: Automatic Git submodule initialization
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动初始化Git子模块
- en: Providing a neat experience to the users doesn't always have to be painful for
    developers. If a library provides a package config-file, we can just ask `find_package()`
    to search for it in the installed libraries. As promised, CMake will start by
    checking whether there's an appropriate find-module, and if there's not, it will
    look for config-files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户提供整洁的体验并不总是对开发者来说是痛苦的。如果一个库提供了一个包配置文件，我们只需让`find_package()`在安装的库中搜索它。正如承诺的那样，CMake首先检查是否有合适的find模块，如果没有，它将寻找配置文件。
- en: 'We already know that if the `<LIB_NAME>_FOUND` variable is set to `1`, the
    library was found and we can just use it. We can also act when library wasn''t
    found and provide convenient workaround to silently improve the user''s experience:
    fall back to fetching submodules and building the library from source. Suddenly,
    the fact that a freshly cloned repository doesn''t automatically download and
    initialize nested submodules doesn''t look so bad, does it?'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，如果`<LIB_NAME>_FOUND`变量被设置为`1`，则库被找到，我们可以直接使用它。我们也可以在库未找到时采取行动，并提供方便的解决方法来默默改善用户的体验：退回到获取子模块并从源代码构建库。突然之间，一个新克隆的仓库不自动下载和初始化嵌套子模块的事实看起来并没有那么糟糕，不是吗？
- en: 'Let''s take the code from the previous example and extend it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上一个示例中的代码进行扩展：
- en: chapter07/06-git-submodule-auto/CMakeLists.txt
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/06-git-submodule-auto/CMakeLists.txt
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We added the highlighted lines:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了高亮显示的行：
- en: We'll try to quietly find yaml-cpp and use it.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将尝试悄悄地查找yaml-cpp并使用它。
- en: If it's not present, we'll print a short diagnostic message and use the `execute_process()`
    command to initialize the submodule. This effectively clones the files from the
    referenced repository.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它不存在，我们将打印一个简短的诊断信息，并使用`execute_process()`命令来初始化子模块。这实际上是从引用仓库中克隆文件。
- en: Finally, we'll `add_subdirectory()` to build the dependency from the source.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将`add_subdirectory()`用于从源代码构建依赖项。
- en: This is short and sweet. This also works for libraries that aren't built with
    CMake – we can follow the example of `git submodule` and call `execute_process()`
    again to kick off any external build tools in the same fashion.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 简短而精炼。这也适用于未使用 CMake 构建的库——我们可以遵循 `git submodule` 的示例，再次调用 `execute_process()`
    以同样的方式启动任何外部构建工具。
- en: Sadly, this method falls apart if your company works with **Concurrent Versions
    System** (**CVS**), **Subversion** (**SVN**), Mercurial, or anything else to ship
    code to your users. If you cannot rely on Git submodules, what's the alternative?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可悲的是，如果您的公司使用 **Concurrent Versions System** (**CVS**)、**Subversion** (**SVN**)、Mercurial
    或任何其他方法向用户提供代码，这种方法就会崩溃。如果您不能依赖 Git submodules，替代方案是什么？
- en: Git-cloning dependencies for projects that don't use Git
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为不使用 Git 的项目克隆依赖项
- en: If you're using another VCS or offer your source in an archive, you might have
    a hard time relying on Git submodules bringing in external dependencies to your
    repository. Chances are that the environment that will build your code has Git
    installed and could execute the `git clone` command.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用另一个 VCS 或者提供源代码的存档，您可能会在依赖 Git submodules 将外部依赖项引入您的仓库时遇到困难。很有可能是构建您代码的环境安装了
    Git 并能执行 `git clone` 命令。
- en: 'Let''s see how we can go about this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们应该如何进行：
- en: chapter07/07-git-clone/CMakeLists.txt
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/07-git-clone/CMakeLists.txt
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Again, the highlighted lines are new parts in our YAML project. Here''s what
    happens:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，加粗的行是我们 YAML 项目中的新部分。发生了以下情况：
- en: We start by checking if Git is available through the `FindGit` find-module.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过 `FindGit` 查找模块检查 Git 是否可用。
- en: If it's not, we're stuck. We'll issue `FATAL_ERROR` and hope that the user knows
    what to do next.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不可以使用，我们就束手无策了。我们将发出 `FATAL_ERROR`，并希望用户知道接下来该做什么。
- en: Otherwise, we'll call `execute_process()` with the `GIT_EXECUTABLE` variable
    that was set by `find_package()` and clone the repository we're interested in.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将使用 `FindGit` 查找模块设置的 `GIT_EXECUTABLE` 变量调用 `execute_process()` 并克隆我们感兴趣的仓库。
- en: Git is especially attractive for developers who have some experience with it.
    It can be a good fit for a smaller project that doesn't contain nested references
    to the same repositories. However, if it does, you'll find that you might need
    to clone and build the same project multiple times. If the dependency project
    doesn't use Git at all, you'll need another solution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Git 对于有一定经验的开发者来说尤其有吸引力。它可能适合一个不包含对相同仓库的嵌套引用的小项目。然而，如果确实如此，您可能会发现您可能需要多次克隆和构建同一个项目。如果依赖项目根本不使用
    Git，您将需要另一个解决方案。
- en: Using ExternalProject and FetchContent modules
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ExternalProject 和 FetchContent 模块
- en: Online reference books on CMake will suggest `ExternalProject` and `FetchContent`
    modules to deal with the management of dependencies in more complex projects.
    That's actually good advice, but it's often given without appropriate context.
    Suddenly, we're facing a lot of questions. What are these modules for? When to
    choose one over the other? How exactly do they work, and how do they interact
    with each other? Some answers are harder to find than others, and surprisingly,
    CMake's documentation doesn't provide a smooth introduction to the subject. Not
    to worry – we'll take care of it here.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在线 CMake 参考书籍将建议使用 `ExternalProject` 和 `FetchContent` 模块来处理更复杂项目中依赖项的管理。这实际上是个好建议，但它通常在没有适当上下文的情况下给出。突然之间，我们面临了许多问题。这些模块是做什么的？何时选择一个而不是另一个？它们究竟是如何工作的，以及它们是如何相互作用的？一些答案比其他的更难找到，令人惊讶的是，CMake
    的文档没有为该主题提供一个平滑的介绍。不用担心——我们在这里会处理。
- en: ExternalProject
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部项目
- en: 'CMake 3.0.0 introduced a module called `ExternalProject`. As you can guess,
    its purpose was to add support for external projects available in online repositories.
    Over the years, the module was gradually extended for different needs, resulting
    in quite a complicated command – `ExternalProject_Add()`. And I mean complicated
    – it accepts over 85 different options. No wonder, as it provides an impressive
    set of features:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 3.0.0 引入了一个名为 `ExternalProject` 的模块。正如您所猜测的，它的目的是为了添加对在线仓库中可用的外部项目的支持。多年来，该模块逐渐扩展以满足不同的需求，最终变得相当复杂的命令——`ExternalProject_Add()`。我是说复杂——它接受超过
    85 个不同的选项。不足为奇，因为它提供了一组令人印象深刻的特性：
- en: Management of directory structure for an external project
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为外部项目管理目录结构
- en: Downloading of sources from a URL (and extracting from archives if needed)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 URL 下载源代码（如有需要，从归档中提取）
- en: Support for Git, Subversion, Mercurial, and CVS repositories
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Git、Subversion、Mercurial 和 CVS 仓库
- en: Fetching updates if needed
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有需要，获取更新
- en: Configuring and building the project with CMake, Make, or with a user-specified
    tool
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake、Make 配置和构建项目，或使用用户指定的工具
- en: Performing installations and running tests
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行安装和运行测试
- en: Logging to files
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到文件
- en: Asking for user input from terminals
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从终端请求用户输入
- en: Depending on other targets
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于其他目标
- en: Adding custom commands/steps to the build
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向构建过程中添加自定义命令/步骤
- en: 'The `ExternalProject` module populates the dependencies during the build stage.
    For every external project added with `ExternalProject_Add()`, CMake will execute
    the following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject` 模块在构建阶段填充依赖项。对于通过 `ExternalProject_Add()` 添加的每个外部项目，CMake
    将执行以下步骤：'
- en: '`mkdir` – create a subdirectory for the external project'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mkdir` – 为外部项目创建子目录'
- en: '`download` – get the project files from a repository or URL'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`download` – 从仓库或URL获取项目文件'
- en: '`update` – refresh the files on rerun for download methods that support delta
    updates'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update` – 在支持差量更新的下载方法中重新运行时更新文件'
- en: '`patch` – optionally execute a *patch command* that alters downloaded files
    for the needs of the project'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`patch` – 可选执行一个*补丁命令*，用于修改下载文件以满足项目需求'
- en: '`configure` – execute the configure stage for CMake projects or manually specified
    command for non-CMake dependencies'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`configure` – 为CMake项目执行配置阶段，或为非CMake依赖手动指定命令'
- en: '`build` – perform the build stage for CMake projects, and for other dependencies,
    execute the `make` command'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build` – 为CMake项目执行构建阶段，对于其他依赖项，执行 `make` 命令'
- en: '`install` – install CMake projects, and for other dependencies, execute the
    `make install` command'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`install` – 安装CMake项目，对于其他依赖项，执行 `make install` 命令'
- en: '`test` – execute the dependency''s tests if any of the `TEST_...` options are
    defined'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test` – 如果定义了任何 `TEST_...` 选项，则执行依赖项的测试'
- en: The steps follow the preceding exact order, with the exception of the `test`
    step, which can be optionally enabled before or after the `install` step with
    the `TEST_BEFORE_INSTALL <bool>` or `TEST_AFTER_INSTALL <bool>` option.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤按照前面的确切顺序进行，除了 `test` 步骤，该步骤可以通过 `TEST_BEFORE_INSTALL <bool>` 或 `TEST_AFTER_INSTALL
    <bool>` 选项在 `install` 步骤之前或之后可选地启用。
- en: Downloading the step options
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载步骤选项
- en: 'We''re mostly interested in options controlling the `download` step or how
    the dependency will get fetched by CMake. Firstly, we may choose to not use the
    CMake built-in method for that but rather provide a custom command (generator
    expressions are supported here):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注控制 `download` 步骤或CMake如何获取依赖项的选项。首先，我们可能选择不使用CMake内置的此方法，而是提供一个自定义命令（在此处支持生成器表达式）：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By doing so, we tell CMake to ignore all other options for this step and just
    execute a system-specific command. An empty string is accepted too, and it is
    used to disable this step.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，我们告诉CMake忽略此步骤的所有其他选项，只需执行一个特定于系统的命令。空字符串也被接受，用于禁用此步骤。
- en: Downloading dependencies from a URL
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从URL下载依赖项
- en: 'We can provide a list of URLs to be scanned in sequence until a download succeeds.
    CMake will recognize whether the downloaded file is an archive and will unpack
    it by default:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一系列URL，按顺序扫描直到下载成功。CMake 将识别下载文件是否为归档文件，并默认进行解压：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Additional options allow us to customize the behavior of this method further:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项允许我们进一步自定义此方法的行为：
- en: '`URL_HASH <algo>=<hashValue>` – checks whether a downloaded file''s checksum
    generated by `<algo>` matches the provided `<hashValue>`. It is recommended to
    guarantee the integrity of downloads. The `MD5`, `SHA1`, `SHA224`, `SHA256`, `SHA384`,
    `SHA512`, `SHA3_224`, `SHA3_256`, `SHA3_384`, and `SHA3_512` supported algorithms
    are defined by the `string(<HASH>)` command. For `MD5`, we can use a shorthand
    option, `URL_MD5 <md5>`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL_HASH <algo>=<hashValue>` – 检查通过 `<algo>` 生成的下载文件的校验和是否与提供的 `<hashValue>`
    匹配。建议确保下载的完整性。支持的算法包括 `MD5`、`SHA1`、`SHA224`、`SHA256`、`SHA384`、`SHA512`、`SHA3_224`、`SHA3_256`、`SHA3_384`
    和 `SHA3_512`，这些算法由 `string(<HASH>)` 命令定义。对于 `MD5`，我们可以使用简写选项 `URL_MD5 <md5>`。'
- en: '`DOWNLOAD_NO_EXTRACT <bool>` – explicitly disables extraction after downloading.
    We may consume the filename of downloaded files in the follow-up steps by accessing
    the `<DOWNLOADED_FILE>` variable.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOWNLOAD_NO_EXTRACT <bool>` – 显式禁用下载后的提取。我们可以通过访问 `<DOWNLOADED_FILE>` 变量，在后续步骤中使用下载文件的文件名。'
- en: '`DOWNLOAD_NO_PROGRESS <bool>` – don''t log download progress.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOWNLOAD_NO_PROGRESS <bool>` – 不记录下载进度。'
- en: '`TIMEOUT <seconds>` and `INACTIVITY_TIMEOUT <seconds>` – timeouts to terminate
    the download after a fixed total time or period of inactivity.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMEOUT <seconds>` 和 `INACTIVITY_TIMEOUT <seconds>` – 在固定总时间或无活动期后终止下载的超时时间。'
- en: '`HTTP_USERNAME <username>` and `HTTP_PASSWORD <password>` – options to provide
    values for HTTP authentication. Always be sure to avoid hardcoding any credentials
    in your projects.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_USERNAME <username>`和`HTTP_PASSWORD <password>` – 提供HTTP认证值的选项。确保在项目中避免硬编码任何凭据。'
- en: '`HTTP_HEADER <header1> [<header2>…]` – sends additional headers with your HTTP
    request. Use this to access content in AWS or pass some custom tokens.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_HEADER <header1> [<header2>…]` – 发送额外的HTTP头。用这个来访问AWS中的内容或传递一些自定义令牌。'
- en: '`TLS_VERIFY <bool>` – verifies the SSL certificate. If this is not set, CMake
    will read this setting from the `CMAKE_TLS_VERIFY` variable, which is set to `false`
    by default. Skipping TLS verification is an unsafe, bad practice and should be
    avoided, especially in production environments.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TLS_VERIFY <bool>` – 验证SSL证书。如果没有设置，CMake将从`CMAKE_TLS_VERIFY`变量中读取这个设置，默认为`false`。跳过TLS验证是一种不安全、糟糕的做法，应该避免，尤其是在生产环境中。'
- en: '`TLS_CAINFO <file>` – this is useful if your company is issuing self-signed
    SSL certificates. This option provides a path to the authority file; if it isn''t
    specified, CMake will read this setting from the `CMAKE_TLS_CAINFO` variable.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TLS_CAINFO <file>` – 如果你的公司发行自签名SSL证书，这个选项很有用。这个选项提供了一个权威文件的路径；如果没有指定，CMake将从`CMAKE_TLS_CAINFO`变量中读取这个设置。'
- en: Downloading dependencies from Git
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从Git下载依赖项
- en: 'To download dependencies from Git, you''ll need to make sure that the host
    has Git 1.6.5 or later installed. The following options are required to clone
    from Git:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Git下载依赖项，你需要确保主机安装了Git 1.6.5或更高版本。以下选项是克隆Git的必要条件：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Both `<url>` and `<tag>` should be in formats understood by the `git` command.
    Additionally, it is recommended to use a specific git hash to make sure that produced
    binaries can be traced to a specific commit and no unnecessary `git fetch` executions
    are made. If you insist on using a branch, use remote names such as `origin/main`.
    This guarantees the correct synchronization of the local clone.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`<url>`和`<tag>`都应该符合`git`命令能理解的格式。此外，建议使用特定的git哈希，以确保生成的二进制文件可以追溯到特定的提交，并且不会执行不必要的`git
    fetch`。如果你坚持使用分支，使用如`origin/main`的远程名称。这保证了本地克隆的正确同步。'
- en: 'Additional options are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项如下：
- en: '`GIT_REMOTE_NAME <name>` – the remote name, which defaults to `origin`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_REMOTE_NAME <name>` – 远程名称，默认为`origin`。'
- en: '`GIT_SUBMODULES <module>...` – specifies which submodules should be updated.
    Since 3.16, this value defaults to none (previously, all submodules were updated).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_SUBMODULES <module>...` – 指定应该更新的子模块。从3.16起，这个值默认为无（之前，所有子模块都被更新）。'
- en: '`GIT_SUBMODULES_RECURSE 1` – enables the recursive update of submodules.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_SUBMODULES_RECURSE 1` – 启用子模块的递归更新。'
- en: '`GIT_SHALLOW 1` – performs a shallow clone (don''t download historical commits).
    This option is recommended for performance.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_SHALLOW 1` – 执行浅克隆（不下载历史提交）。这个选项推荐用于性能。'
- en: '`TLS_VERIFY <bool>` – this option was explained in the *Downloading dependencies
    from a URL* section. It is also available for Git, and should be enabled for security.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TLS_VERIFY <bool>` – 这个选项在*从URL下载依赖项*部分解释过。它也适用于Git，并且为了安全起见应该启用。'
- en: Downloading dependencies from Subversion
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从Subversion下载依赖项
- en: 'To download from Subversion, we should specify the following options:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Subversion下载，我们应该指定以下选项：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Additionally, we may provide the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以提供以下内容：
- en: '`SVN_USERNAME <user>` and `SVN_PASSWORD <password>` – credentials for checkout
    and update. As always, avoid hardcoding them in your projects.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SVN_USERNAME <user>`和`SVN_PASSWORD <password>` – 用于检出和更新的凭据。像往常一样，避免在项目中硬编码它们。'
- en: '`SVN_TRUST_CERT <bool>` – skips the verification of the Subversion server site
    certificate. Only use this option if the network path to the server and its integrity
    are trustworthy. It is disabled by default.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SVN_TRUST_CERT <bool>` – 跳过对Subversion服务器证书的验证。只有在你信任网络路径到服务器及其完整性时才使用这个选项。默认是禁用的。'
- en: Downloading dependencies from Mercurial
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从Mercurial下载依赖项
- en: 'This mode is very straightforward. We need to provide two options and we''re
    done:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常直接。我们需要提供两个选项，就完成了：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Downloading dependencies from CVS
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从CVS下载依赖项
- en: 'To check out modules from CVS, we need to provide these three options:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要从CVS检出模块，我们需要提供这三个选项：
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Update step options
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新步骤选项
- en: 'By default, the `update` step will re-download the external project''s files
    if the download method supports updates. We can override this behavior in two
    ways:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`update`步骤如果支持更新，将会重新下载外部项目的文件。我们可以用两种方式覆盖这个行为：
- en: Provide a custom command to be executed during the update with `UPDATE_COMMAND
    <cmd>`.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个自定义命令，在更新期间执行`UPDATE_COMMAND <cmd>`。
- en: Completely disable the `update` step (to allow building with a disconnected
    network) – `UPDATE_DISCONNECTED <bool>`. Do note that the `download` step (during
    the first build) will still happen.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全禁用`update`步骤（允许在断开网络的情况下构建）– `UPDATE_DISCONNECTED <bool>`。请注意，第一次构建期间的`download`步骤仍然会发生。
- en: Patch step options
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修补步骤选项
- en: '`Patch` is an optional step that will execute after the source is fetched.
    To enable it, we need to specify the exact command we want to execute with:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Patch`是一个可选步骤，在源代码获取后执行。要启用它，我们需要指定我们要执行的确切命令：'
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: CMake documentation warns that some patches may be more "sticky" than others.
    For example, in Git, changed files don't get restored to the original state during
    the update, and we need to be careful to avoid incorrectly patching the file twice.
    Ideally, the `patch` command should be really robust and idempotent.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CMake文档警告说，一些修补程序可能比其他修补程序“更粘”。例如，在Git中，更改的文件在更新期间不会恢复到原始状态，我们需要小心避免错误地再次修补文件。理想情况下，`patch`命令应该是真正健壮且幂等的。
- en: Important Note
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The previously mentioned lists of options contain only the most useful entries.
    Be sure to reference the official documentation for more details and a description
    of options for other steps: [https://cmake.org/cmake/help/latest/module/ExternalProject.html](https://cmake.org/cmake/help/latest/module/ExternalProject.html).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的选项列表只包含最常用的条目。确保参考官方文档以获取更多详细信息和描述其他步骤的选项：[https://cmake.org/cmake/help/latest/module/ExternalProject.html](https://cmake.org/cmake/help/latest/module/ExternalProject.html)。
- en: Using ExternalProject in practice
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在实际中使用ExternalProject
- en: 'The fact that dependency is populated at the build stage is very important,
    and it has two effects – the namespaces of projects are completely separate, and
    targets defined by any external project are not visible in the main project. The
    latter is especially painful, as we can''t use `target_link_libraries()` in the
    same fashion as we would after using the `find_package()` command. This is because
    of a disjoint of two configuration stages. The main project has to finish the
    configuration stage and start the build stage before the dependency is downloaded
    and configured. This is an issue, but we''ll learn how to deal with that in a
    second. For now, let''s see how `ExternalProject_Add()` would work with the yaml-cpp
    library that we used in the previous examples:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项在构建阶段被填充非常重要，它有两个效果——项目的命名空间完全分离，任何外部项目定义的目标在主项目中不可见。后者尤其痛苦，因为我们在使用`find_package()`命令后不能以同样的方式使用`target_link_libraries()`。这是因为两个配置阶段的分离。主项目必须完成配置阶段并开始构建阶段，然后依赖项才能下载并配置。这是一个问题，但我们将学习如何处理第二个。现在，让我们看看`ExternalProject_Add()`如何与我们在
    previous examples中使用的yaml-cpp库工作：
- en: chapter07/08-external-project-git/CMakeLists.txt
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/08-external-project-git/CMakeLists.txt
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These are the steps taken to build this project:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 构建该项目采取以下步骤：
- en: We included the `ExternalProject` module to access its functions.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们包含了`ExternalProject`模块以访问其功能。
- en: We called the `FindExternalProject_Add()` command, which tasks the build stage
    with downloading the necessary files, and configuring, building, and installing
    the dependency in our system.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用了`FindExternalProject_Add()`命令，该命令将构建阶段任务为下载必要文件，并在我们的系统中配置、构建和安装依赖项。
- en: We need to be cautious here and understand that this example only works because
    the yaml-cpp library has an installation stage defined in its `CMakeLists.txt`.
    This stage copies the library files to the standard locations in the system. The
    `yaml-cpp` argument to the `target_link_libraries()` command is interpreted by
    CMake as a direct argument to the linker – `-lyaml-cpp`. This behavior differs
    from the previous examples, where we explicitly defined the `yaml-cpp` target.
    If the library wouldn't provide an installation stage (or the name of the binary
    version wouldn't match), the linker would throw an error.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心这里，并理解这个例子之所以能工作，是因为yaml-cpp库在其`CMakeLists.txt`中定义了一个安装阶段。这个阶段将库文件复制到系统中的标准位置。`target_link_libraries()`命令中的`yaml-cpp`参数被CMake解释为直接传递给链接器的参数——`-lyaml-cpp`。这个行为与之前的例子不同，在那里我们明确定义了`yaml-cpp`目标。如果库不提供安装阶段（或者二进制版本的名字不匹配），链接器将抛出错误。
- en: 'At this point, we should dive deeper into the configuration of each stage and
    explain how to use different download methods. We''ll get to that in the *FetchContent*
    section, but first, let''s get back to the problem of late dependency fetching
    by `ExternalProject`. We cannot use targets of external projects in the compilation
    stage because that stage has already finished by the time these projects are being
    fetched. CMake will explicitly protect the target created with `FindExternalProject_Add()`
    by marking it with a special `UTILITY` type. When you mistakenly try to use such
    a target in the main project (perhaps to link it), CMake will throw an error:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之际，我们应该更深入地探讨每个阶段的配置，并解释如何使用不同的下载方法。我们将在*FetchContent*部分讨论这些问题，但首先，让我们回到讨论`ExternalProject`导致的依赖项晚获取问题。我们不能在外部项目被获取的时候使用它们的目标，因为编译阶段已经结束了。CMake将通过将其标记为特殊的`UTILITY`类型来显式保护使用`FindExternalProject_Add()`创建的目标。当你错误地尝试在主项目中使用这样一个目标（也许是为了链接它）时，CMake将抛出一个错误：
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To get around this limitation, we can technically create another target, an
    `IMPORTED` library, and use that instead (just as we did earlier in this chapter
    with `FindPQXX.cmake`). But this is an awful lot of work. What's worse is that
    CMake actually understands the targets created by the external CMake projects
    (since it builds them). Repeating those declarations in the main project wouldn't
    be a very DRY practice.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，技术上我们可以创建另一个目标，一个`IMPORTED`库，然后使用它（就像我们在这个章节前面用`FindPQXX.cmake`做的那样）。但这实在太麻烦了。更糟糕的是，CMake实际上理解外部CMake项目创建的目标（因为它在构建它们）。在主项目中重复这些声明不会是一个非常DRY的做法。
- en: 'Another possible solution is to extract whole dependency fetching and building
    to a separate sub-project and build that during the configuration stage. To make
    it happen, we''d need to start another instance of CMake with `execute_process()`.
    With some trickery and the `add_subdirectory()` command, we can then consume this
    sub-project''s list files and binaries into the main project. This approach (sometimes
    called *the super-build*) is outdated and unnecessarily complex. I won''t go into
    the details here, as it wouldn''t be very useful for beginners. If you''re curious,
    read this great article by Craig Scott: [https://crascit.com/2015/07/25/cmake-gtest/](https://crascit.com/2015/07/25/cmake-gtest/).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案是将整个依赖项的获取和构建提取到一个独立的子项目中，并在配置阶段构建该子项目。要实现这一点，我们需要用`execute_process()`启动CMake的另一个实例。通过一些技巧和`add_subdirectory()`命令，我们随后可以将这个子项目的列表文件和二进制文件合并到主项目中。这种方法（有时被称为*超级构建*）过时且不必要的复杂。在这里我不详细说明，因为对初学者来说没有太大用处。如果你好奇，可以阅读Craig
    Scott这篇很好的文章：[https://crascit.com/2015/07/25/cmake-gtest/](https://crascit.com/2015/07/25/cmake-gtest/)。
- en: To sum it up, `ExternalProject` can get us out of a bind when there are namespacing
    collisions across projects, but in all other cases, `FetchContent` is far superior.
    Let's figure out why.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当项目间存在命名空间冲突时，`ExternalProject`可以帮我们摆脱困境，但在其他所有情况下，`FetchContent`都远远优于它。让我们来找出为什么。
- en: FetchContent
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FetchContent
- en: Nowadays, it is recommended to go with the `FetchContent` module to import external
    projects. This module has been available in CMake since version 3.11, but we recommend
    using at least 3.14 to work with it effectively.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，建议使用`FetchContent`模块来导入外部项目。这个模块自CMake 3.11版本以来一直可用，但我们建议至少使用3.14版本才能有效地与之工作。
- en: Essentially, it's a high-level wrapper around `ExternalProject`, offering similar
    functionality and more. The key difference is in the stage of execution – unlike
    `ExternalProject`, `FetchContent` populates dependencies during the configuration
    stage, bringing all the targets declared by an external project to the scope of
    the main project. This way, we can use them exactly like the ones we defined ourselves.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，它是一个高级别的`ExternalProject`包装器，提供类似的功能和更多功能。关键区别在于执行阶段——与`ExternalProject`不同，`FetchContent`在配置阶段填充依赖项，将外部项目声明的所有目标带到主项目的范围内。这样，我们可以像定义自己的目标一样精确地使用它们。
- en: 'The usage of `FetchContent` module requires three steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FetchContent`模块需要三个步骤：
- en: Include the module in your project with `include(FetchModule)`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块包含在你的项目中，使用`include(FetchModule)`。
- en: Configure dependencies with the `FetchContent_Declare()` command.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FetchContent_Declare()`命令配置依赖项。
- en: Populate dependencies with the `FetchContent_MakeAvailable()` command – download,
    build, install, and add its list files to the main project and parse.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FetchContent_MakeAvailable()`命令填充依赖项——下载、构建、安装，并将其列表文件添加到主项目中并解析。
- en: 'You may ask yourself why the `Declare` and `MakeAvailable` commands were separated.
    This was done to enable configuration overrides in hierarchical projects. Here''s
    a scenario – a parent project depends on the **A** and **B** external libraries.
    The **A** library also depends on **B**, but authors of the **A** library are
    still using an old version, different from the parent project (*Figure 7.1*):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己为什么`Declare`和`MakeAvailable`命令被分开。这是为了在层次化项目中启用配置覆盖。这是一个场景——一个父项目依赖于**A**和**B**外部库。**A**库也依赖于**B**，但**A**库的作者仍在使用与父项目不同的旧版本(*图7.1*)：
- en: '![Figure 7.1 – The hierarchical project'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 —— 层次化项目'
- en: '](img/Figure_7.1_B17205.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B17205.jpg)'
- en: Figure 7.1 – The hierarchical project
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 —— 层次化项目
- en: What's more, the dependency on the `MakeAvailable` can't both configure and
    populate the dependency because to override the version in the **A** library,
    the parent project would be forced to populate the dependency regardless of its
    final necessity in the **A** library.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，对`MakeAvailable`的依赖既不能配置也不能填充依赖，因为要覆盖**A**库中的版本，父项目将被迫无论在**A**库中最终是否需要，都要填充依赖。
- en: 'By virtue of having a separate configuration step, we''re able to specify a
    single version in the parent project and have it used in all sub-projects and
    dependencies:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了单独的配置步骤，我们能够为父项目指定一个版本，并在所有子项目和依赖项中使用它：
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Any subsequent calls to `FetchContent_Declare()` with `googletest` as the first
    argument will be ignored to allow the project highest in the hierarchy to decide
    how to handle this dependency.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续调用`FetchContent_Declare()`，以`googletest`作为第一个参数，都将被忽略，以允许层次结构最高的项目决定如何处理这个依赖。
- en: 'The signature of the `FetchContent_Declare()` command is exactly the same as
    `ExternalProject_Add()`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent_Declare()`命令的签名与`ExternalProject_Add()`完全相同：'
- en: '[PRE36]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is no coincidence – these arguments will be stored by CMake until the `FetchContent_MakeAvailable()`
    is called and population is necessary. Then, they will be forwarded internally
    to the `ExternalProject_Add()` command. However, not all of the options are allowed.
    We can specify any options of the `download`, `update`, or `patch` steps but not
    the `configure`, `build`, `install`, or `test` steps.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这并非巧合——这些参数会被CMake存储，直到调用`FetchContent_MakeAvailable()`并且需要填充时才会传递。然后，内部会将这些参数传递给`ExternalProject_Add()`命令。然而，并非所有的选项都是允许的。我们可以指定`download`、`update`或`patch`步骤的任何选项，但不能是`configure`、`build`、`install`或`test`步骤。
- en: 'When the configuration is ready, we''ll populate the dependencies like so:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置就绪后，我们会像这样填充依赖项：
- en: '[PRE37]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will download the files and read the targets into the project, but what
    actually happens during this call? `FetchContent_MakeAvailable()` was added to
    CMake 3.14 to wrap the most commonly used scenario in a single command. In *Figure
    7.2*, you can see the details of this process:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载文件并读取目标到项目中，但在这次调用中实际发生了什么？`FetchContent_MakeAvailable()`是在CMake 3.14中添加的，以将最常用的场景封装在一个命令中。在*图7.2*中，你可以看到这个过程的详细信息：
- en: Call `FetchContent_GetProperties()` to read the configuration set by `FetchContent_Declare()`
    from the global variables to local variables.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`FetchContent_GetProperties()`，从全局变量将`FetchContent_Declare()`设置的配置从全局变量传递到局部变量。
- en: Check (case-insensitively) whether the dependency with this name was already
    populated to avoid downloading it twice. If so, stop here.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查（不区分大小写）是否已经为具有此名称的依赖项进行了填充，以避免重复下载。如果是，就在这里停止。
- en: Call `FetchContent_Populate()`. It will configure the wrapped `ExternalProject`
    module by forwarding options we have set (but skipping the disabled ones) and
    downloading the dependency. It will also set some variables to prevent re-downloading
    on subsequent calls and forward the necessary paths to the next command.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`FetchContent_Populate()`。它会配置包装的`ExternalProject`模块，通过传递我们设置的（但跳过禁用的）选项并下载依赖项。它还会设置一些变量，以防止后续调用重新下载，并将必要的路径传递给下一个命令。
- en: Finally, `add_subdirectory()` is called with source and build trees as arguments
    to tell the parent project where the list files are and where to put the build
    artifacts.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`add_subdirectory()`带着源和构建树作为参数调用，告诉父项目列表文件在哪里以及构建工件应放在哪里。
- en: By calling `add_subdirectory()`, CMake effectively performs the configuration
    stage of the fetched project and retrieves any targets defined there in the current
    scope. How convenient!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`add_subdirectory()`，CMake实际上执行了获取项目的配置阶段，并在当前作用域中检索那里定义的任何目标。多么方便！
- en: '![Figure 7.2 – How FetchContent_MakeAvailable() wraps calls to ExternalProject'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – FetchContent_MakeAvailable()如何包装对ExternalProject的调用](img/Figure_7.2_B17205.jpg)'
- en: '](img/Figure_7.2_B17205.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B17205.jpg)'
- en: Figure 7.2 – How FetchContent_MakeAvailable() wraps calls to ExternalProject
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – FetchContent_MakeAvailable()如何包装对ExternalProject的调用
- en: Obviously, we may have a situation where two unrelated projects declare a target
    with the same name. This is a problem that can only be solved by falling back
    to `ExternalProject` or other methods. Luckily, it doesn't happen too often.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可能遇到两个无关项目声明具有相同名称的目标的情况。这是一个只能通过回退到`ExternalProject`或其他方法来解决的问题。幸运的是，这种情况并不经常发生。
- en: 'For this explanation to be complete, it has to be complemented with a practical
    example. Let''s see how the list file from the previous section changes when we
    switch to `FetchContent`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个解释完整，它必须与一个实际例子相补充。让我们看看当我们将`FetchContent`更改为`FetchContent`时，前一部分的列表文件是如何变化的：
- en: chapter07/09-fetch-content/CMakeLists.txt
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: chapter07/09-fetch-content/CMakeLists.txt
- en: '[PRE38]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`ExternalProject_Add` was directly replaced with `FetchContent_Declare`, and
    we added another command – `FetchContent_MakeAvailable`. The changes in code are
    minuscule, but the practical differences are huge! We can explicitly access the
    targets created by the yaml-cpp library. To prove it, we''ll use a `CMakePrintHelpers`
    helper module and add these lines to the previous file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add`直接被`FetchContent_Declare`替换，我们还添加了另一个命令——`FetchContent_MakeAvailable`。代码的变化微乎其微，但实际的区别却很大！我们可以明确地访问由yaml-cpp库创建的目标。为了证明这一点，我们将使用`CMakePrintHelpers`帮助模块，并向之前的文件添加这些行：'
- en: '[PRE39]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the configuration stage will print the following output:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，配置阶段将打印以下输出：
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The target exists; it''s a static library, and its source directory resides
    inside the build tree. Using the same helper to debug the target in the `ExternalProject`
    example simply returns:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 目标存在；它是一个静态库，其源代码目录位于构建树内部。使用相同的助手在`ExternalProject`示例中调试目标简单地返回：
- en: '[PRE41]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The target isn't recognized during the configuration stage. This is why `FetchContent`
    is much better and should be used wherever possible.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置阶段目标没有被识别。这就是为什么`FetchContent`要好得多，并且应该尽可能地在任何地方使用。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Managing dependencies isn't complicated when we use modern, well-supported projects.
    In most cases, we'd simply rely on the library being available in the system and
    fall back to `FetchContent` if it's not. This would be appropriate if dependencies
    are relatively small and quick to build.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用现代的、得到良好支持的项目时，管理依赖关系并不复杂。在大多数情况下，我们只需依赖系统中有可用的库，如果没有就回退到`FetchContent`。如果依赖项相对较小且易于构建，这种方法是合适的。
- en: For some really big libraries out there (such as Qt), it would take a significant
    amount of time to build from the source. To provide automatic dependency resolution
    in these cases, we'd have to resort to package managers offering compiled versions
    of libraries matching the user's environment. External tools such as Apt or Conan
    aren't within the scope of this book, as they are either too system-dependent
    or too complex.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些非常大的库（如Qt），从源代码构建会花费大量时间。为了在这些情况下提供自动依赖解析，我们不得不求助于提供与用户环境匹配的库编译版本的包管理器。像Apt或Conan这样的外部工具超出了本书的范围，因为它们要么太依赖于系统，要么太复杂。
- en: The good news is that most users know how to install dependencies that your
    project might require, as long as you provide them with clear instructions to
    do so. From this chapter, you already know how to detect packages installed in
    the system with CMake's find-modules and config files bundled with the library.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，大多数用户知道如何安装您的项目可能需要的依赖项，只要您为他们提供清晰的指示即可。从这一章，您已经知道如何使用CMake的find-modules检测系统中的包，以及库捆绑的配置文件。
- en: We also learned what to do if a library is a bit older and doesn't support CMake
    but is distributed with the `.pc` files instead – we'll rely on the PkgConfig
    tool and the `FindPkgConfig` find-module bundled with CMake. We can expect that
    CMake will automatically create build targets when a library is found with one
    of the aforementioned methods, which is convenient and elegant. We also discussed
    relying on Git, and its submodules and cloning entire repositories. This method
    comes in useful when others won't do or are impractical to implement.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，如果一个库有点旧，不支持CMake，但 distribution 中包含`.pc`文件，我们可以依靠PkgConfig工具和随CMake捆绑的`FindPkgConfig`查找模块。我们可以期待，当使用上述任一方法找到库时，CMake会自动创建构建目标，这是方便且优雅的。我们还讨论了依赖Git及其子模块和克隆整个仓库的方法。当其他方法不适用或实施起来不切实际时，这种方法非常有用。
- en: Finally, we explored the `ExternalProject` module and its functionalities and
    limitations. We studied how `FetchContent` extends the `ExternalProject` module,
    which things it has in common with the module, where it differs from the module,
    and why `FetchContent` is preferable.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了`ExternalProject`模块及其功能和限制。我们研究了`FetchContent`如何扩展`ExternalProject`模块，它与模块有哪些共同之处，与模块有何不同，以及为什么`FetchContent`更优越。
- en: You're now ready to use regular libraries in your projects; however, there's
    another kind of dependency that we should cover – testing frameworks. Every serious
    project needs to be tested for correctness, and CMake is a great tool to automate
    this process. We'll learn how to do it in the next chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已准备好在你的项目中使用常规库；然而，我们还应该覆盖另一种类型的依赖——测试框架。每个认真的项目都需要 Correctness testing，而CMake是一个很好的工具来自动化这一过程。我们将在下一章学习如何操作。
- en: Further reading
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，你可以参考以下内容：
- en: '*CMake documentation – Using Dependencies Guide:* [https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake文档 - 使用依赖关系指南：[https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html)
- en: '*Tutorial: Easy dependency management for C++ with CMake and Git:* [https://www.foonathan.net/2016/07/cmake-dependency-handling/](https://www.foonathan.net/2016/07/cmake-dependency-handling/)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程：使用CMake和Git进行C++的简易依赖管理：[https://www.foonathan.net/2016/07/cmake-dependency-handling/](https://www.foonathan.net/2016/07/cmake-dependency-handling/)
- en: '*CMake and using git-submodule for dependence projects:* [https://stackoverflow.com/questions/43761594/](https://stackoverflow.com/questions/43761594/)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake和用于依赖项目的git-submodule使用：[https://stackoverflow.com/questions/43761594/](https://stackoverflow.com/questions/43761594/)
- en: '*Piggybacking on PkgConfig:* [https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config](https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用PkgConfig进行依赖共享：[https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config](https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config)
- en: '*Discussion on the* `UNKNOWN` *type of imported libraries in findmodules:*
    [https://gitlab.kitware.com/cmake/cmake/-/issues/19564](https://gitlab.kitware.com/cmake/cmake/-/issues/19564)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于在findmodules中导入库的`UNKNOWN`类型的讨论：[https://gitlab.kitware.com/cmake/cmake/-/issues/19564](https://gitlab.kitware.com/cmake/cmake/-/issues/19564)
- en: '*What Git submodules are:* [https://git-scm.com/book/en/v2/Git-Tools-Submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Git子模块：[https://git-scm.com/book/en/v2/Git-Tools-Submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules)
- en: '*How to use ExternalProject:* [https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html](https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用ExternalProject：[https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html](https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html)
- en: '*CMake FetchContent vs. ExternalProject:* [https://www.scivision.dev/cmake-fetchcontent-vs-external-project/](https://www.scivision.dev/cmake-fetchcontent-vs-external-project/)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake FetchContent 与 ExternalProject 的比较：[https://www.scivision.dev/cmake-fetchcontent-vs-external-project/](https://www.scivision.dev/cmake-fetchcontent-vs-external-project/)
- en: '*Using CMake with External Projects:* [http://www.saoe.net/blog/using-cmake-with-external-projects/](http://www.saoe.net/blog/using-cmake-with-external-projects/)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake与外部项目：[http://www.saoe.net/blog/using-cmake-with-external-projects/](http://www.saoe.net/blog/using-cmake-with-external-projects/)
