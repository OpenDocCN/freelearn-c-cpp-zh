["```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter08\n```", "```cpp\n> cmake .\n> make recipe01_examples\n```", "```cpp\n> ./recipe01_example01\n1\n2\n3\n4\n5\n6\n7\n8\n\n> ./recipe01_example02\n1\n2\n3\n\n> ./recipe01_example03\n3\nelements: 4 42 \n3\nelements: 4 8 15 42 \n3\nelements: 4 8 15 16 23 42 \n```", "```cpp\n#include <vector>\n#include <algorithm>\n#include <iostream>\n```", "```cpp\ntemplate<\n    typename T,\n    typename Compare = std::less<T>,\n    typename Allocator = std::allocator<T>\n    >\nclass container\n{\n    using vector_type = std::vector<T, Allocator>;\n    vector_type m_v;\n\npublic:\n```", "```cpp\n    using value_type = typename vector_type::value_type;\n    using allocator_type = typename vector_type::allocator_type;\n    using size_type = typename vector_type::size_type;\n    using difference_type = typename vector_type::difference_type;\n    using const_reference = typename vector_type::const_reference;\n    using const_pointer = typename vector_type::const_pointer;\n    using compare_type = Compare;\n```", "```cpp\n    container() noexcept(noexcept(Allocator()))\n    {\n        std::cout << \"1\\n\";\n    }\n```", "```cpp\n    explicit container(\n        const Allocator &alloc\n    ) noexcept :\n        m_v(alloc)\n    {\n        std::cout << \"2\\n\";\n    }\n```", "```cpp\n    container(\n        size_type count,\n        const T &value,\n        const Allocator &alloc = Allocator()\n    ) :\n        m_v(count, value, alloc)\n    {\n        std::cout << \"3\\n\";\n    }\n\n    explicit container(\n        size_type count,\n        const Allocator &alloc = Allocator()\n    ) :\n        m_v(count, alloc)\n    {\n        std::cout << \"4\\n\";\n    }\n```", "```cpp\n    container(\n        const container &other,\n        const Allocator &alloc\n    ) :\n        m_v(other.m_v, alloc)\n    {\n        std::cout << \"5\\n\";\n    }\n\n    container(\n        container &&other\n    ) noexcept :\n        m_v(std::move(other.m_v))\n    {\n        std::cout << \"6\\n\";\n    }\n```", "```cpp\n    container(\n        container &&other,\n        const Allocator &alloc\n    ) :\n        m_v(std::move(other.m_v), alloc)\n    {\n        std::cout << \"7\\n\";\n    }\n```", "```cpp\n    container(\n        std::initializer_list<T> init,\n        const Allocator &alloc = Allocator()\n    ) :\n        m_v(init, alloc)\n    {\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n        std::cout << \"8\\n\";\n    }\n```", "```cpp\nint main(void)\n{\n    auto alloc = std::allocator<int>();\n\n    container<int> c1;\n    container<int> c2(alloc);\n    container<int> c3(42, 42);\n    container<int> c4(42);\n    container<int> c5(c1, alloc);\n    container<int> c6(std::move(c1));\n    container<int> c7(std::move(c2), alloc);\n    container<int> c8{4, 42, 15, 8, 23, 16};\n\n    return 0;\n}\n```", "```cpp\n    void push_back(const T &value)\n    {\n        m_v.push_back(value);\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n\n        std::cout << \"1\\n\";\n    }\n\n    void push_back(T &&value)\n    {\n        m_v.push_back(std::move(value));\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n\n        std::cout << \"2\\n\";\n    }\n```", "```cpp\n    template<typename... Args>\n    void emplace_back(Args&&... args)\n    {\n        m_v.emplace_back(std::forward<Args>(args)...);\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n\n        std::cout << \"3\\n\";\n    }\n```", "```cpp\nint main(void)\n{\n    int i = 42;\n    container<int> c;\n\n    c.push_back(i);\n    c.push_back(std::move(i));\n    c.emplace_back(42);\n\n    return 0;\n}\n```", "```cpp\nint main(void)\n{\n    int i = 42;\n    container<int> c;\n\n    c.emplace_back(4);\n    c.push_back(i);\n    c.emplace_back(15);\n    c.push_back(8);\n    c.emplace_back(23);\n    c.push_back(std::move(16));\n\n    return 0;\n}\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter08\n```", "```cpp\n> cmake .\n> make recipe02_examples\n```", "```cpp\n> ./recipe02_example01 \nelements: 4 \nelements: 4 42 \nelements: 4 15 42 \nelements: 4 8 15 42 \nelements: 4 8 15 23 42 \nelements: 4 8 15 16 23 42 \n```", "```cpp\n    void insert(const T &value)\n    {\n        push_back(value);\n    }\n\n    void insert(T &&value)\n    {\n        push_back(std::move(value));\n    }\n\n    template<typename... Args>\n    void emplace(Args&&... args)\n    {\n        emplace_back(std::forward<Args>(args)...);\n    }\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter08\n```", "```cpp\n> cmake .\n> make recipe03_examples\n```", "```cpp\n> ./recipe03_example01 \nelements: 4 8 15 16 23 42 \n\n> ./recipe03_example02 \nelements: 4 8 15 16 23 42 \nelements: 4 8 15 16 23 42 \nelements: 42 23 16 15 8 4 \nelements: 1 4 8 15 16 23 42 \nelements: 4 8 15 16 23 42 \nelements: \n```", "```cpp\n    template <typename Iter>\n    container(\n        Iter first,\n        Iter last,\n        const Allocator &alloc = Allocator()\n    ) :\n        m_v(first, last, alloc)\n    {\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n    }\n```", "```cpp\n    using const_iterator = typename vector_type::const_iterator;\n    using const_reverse_iterator = typename vector_type::const_reverse_iterator;\n```", "```cpp\n    const_iterator begin() const noexcept\n    {\n        return m_v.begin();\n    }\n\n    const_iterator cbegin() const noexcept\n    {\n        return m_v.cbegin();\n    }\n```", "```cpp\n    const_iterator end() const noexcept\n    {\n        return m_v.end();\n    }\n\n    const_iterator cend() const noexcept\n    {\n        return m_v.cend();\n    }\n```", "```cpp\n    template <typename... Args>\n    void emplace(const_iterator pos, Args&&... args)\n    {\n        m_v.emplace(pos, std::forward<Args>(args)...);\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n    }\n```", "```cpp\n    const_iterator erase(const_iterator pos)\n    {\n        return m_v.erase(pos);\n    }\n\n    const_iterator erase(const_iterator first, const_iterator last)\n    {\n        return m_v.erase(first, last);\n    }\n```", "```cpp\nint main(void)\n{\n    container<int> c{4, 42, 15, 8, 23, 16};\n```", "```cpp\n    std::cout << \"elements: \";\n\n    for (const auto &elem : c) {\n        std::cout << elem << ' ';\n    }\n\n    std::cout << '\\n';\n```", "```cpp\nelements: 4 8 15 16 23 42\n```", "```cpp\n    for (auto &elem : c) {\n        elem = 42;\n    }\n```", "```cpp\n/home/user/book/chapter08/recipe03.cpp: In function \u2018int main()\u2019:\n/home/user/book/chapter08/recipe03.cpp:396:14: error: assignment of read-only reference \u2018elem\u2019\n  396 | elem = 42;\n```", "```cpp\n    std::cout << \"elements: \";\n\n    for (auto iter = c.begin(); iter != c.end(); iter++) {\n        auto &elem = *iter;\n        std::cout << elem << ' ';\n    }\n\n    std::cout << '\\n';\n```", "```cpp\n    c.emplace(c.cend(), 1);\n\n    std::cout << \"elements: \";\n    for (const auto &elem : c) {\n        std::cout << elem << ' ';\n    }\n    std::cout << '\\n';\n```", "```cpp\nelements: 1 4 8 15 16 23 42\n```", "```cpp\n    c.erase(c.cbegin());\n\n    std::cout << \"elements: \";\n    for (const auto &elem : c) {\n        std::cout << elem << ' ';\n    }\n    std::cout << '\\n';\n```", "```cpp\nelements: 4 8 15 16 23 42\n```", "```cpp\n> sudo apt-get install build-essential git cmake\n```", "```cpp\n> cd ~/\n> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git\n> cd Advanced-CPP-CookBook/chapter08\n```", "```cpp\n> cmake .\n> make recipe04_examples\n```", "```cpp\n> ./recipe04_example01 \nelements: 4 8 15 16 23 42 \nelements: 4 8 15 16 23 42 \nelements: 4 8 15 16 23 42 \nelements: 42 \nelements: 4 8 15 16 23 42 \nelements: 4 8 15 16 23 42 \nc1.at(0): 4\nc1.front(): 4\nc1.back(): 42\nc1.data(): 0xc01eb0\nc1.empty(): 0\nc1.size(): 6\nc1.max_size(): 2305843009213693951\nc1.capacity(): 42\nc1.capacity(): 6\nc1.size(): 0\nc1.size(): 42\nc1.size(): 0\nc1.size(): 42\nelements: 4 8 15 16 23 \n==: 0\n!=: 1\n <: 1\n<=: 1\n >: 0\n>=: 0\n```", "```cpp\n    constexpr container &operator=(const container &other)\n    {\n        m_v = other.m_v;\n        return *this;\n    }\n\n    constexpr container &operator=(container &&other) noexcept\n    {\n        m_v = std::move(other.m_v);\n        return *this;\n    }    \n```", "```cpp\n    constexpr container &operator=(container &&other) noexcept\n    {\n        if (&other == this) {\n            return *this;\n        }\n\n        m_v = std::move(other.m_v);\n        m_something = other.m_something;\n\n        return *this;\n    }\n```", "```cpp\n    constexpr container &operator=(std::initializer_list<T> list)\n    {\n        m_v = list;\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n\n        return *this;\n    }\n```", "```cpp\n    constexpr void assign(size_type count, const T &value)\n    {\n        m_v.assign(count, value);\n    }\n\n    template <typename Iter>\n    constexpr void assign(Iter first, Iter last)\n    {\n        m_v.assign(first, last);\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n    }\n\n    constexpr void assign(std::initializer_list<T> list)\n    {\n        m_v.assign(list);\n        std::sort(m_v.begin(), m_v.end(), compare_type());\n    }\n```", "```cpp\n    constexpr const_reference at(size_type pos) const\n    {\n        return m_v.at(pos);\n    }\n```", "```cpp\n    constexpr const_reference front() const\n    {\n        return m_v.front();\n    }\n\n    constexpr const_reference back() const\n    {\n        return m_v.back();\n    }\n```", "```cpp\n    constexpr const T* data() const noexcept\n    {\n        return m_v.data();\n    }\n```", "```cpp\n    template <typename O, typename Alloc>\n    friend constexpr bool operator==(const container<O, Alloc> &lhs,\n                                     const container<O, Alloc> &rhs);\n\n    template <typename O, typename Alloc>\n    friend constexpr bool operator!=(const container<O, Alloc> &lhs,\n                                     const container<O, Alloc> &rhs);\n\n    template <typename O, typename Alloc>\n    friend constexpr bool operator<(const container<O, Alloc> &lhs,\n                                    const container<O, Alloc> &rhs);\n\n    template <typename O, typename Alloc>\n    friend constexpr bool operator<=(const container<O, Alloc> &lhs,\n                                     const container<O, Alloc> &rhs);\n\n    template <typename O, typename Alloc>\n    friend constexpr bool operator>(const container<O, Alloc> &lhs,\n                                    const container<O, Alloc> &rhs);\n\n    template <typename O, typename Alloc>\n    friend constexpr bool operator>=(const container<O, Alloc> &lhs,\n                                     const container<O, Alloc> &rhs);\n```", "```cpp\ntemplate <typename O, typename Alloc>\nbool constexpr operator==(const container<O, Alloc> &lhs,\n                          const container<O, Alloc> &rhs)\n{\n    return lhs.m_v == rhs.m_v;\n}\n\ntemplate <typename O, typename Alloc>\nbool constexpr operator!=(const container<O, Alloc> &lhs,\n                          const container<O, Alloc> &rhs)\n{\n    return lhs.m_v != rhs.m_v;\n}\n```", "```cpp\ntemplate <typename O, typename Alloc>\nbool constexpr operator<(const container<O, Alloc> &lhs,\n                         const container<O, Alloc> &rhs)\n{\n    return lhs.m_v < rhs.m_v;\n}\n\ntemplate <typename O, typename Alloc>\nbool constexpr operator<=(const container<O, Alloc> &lhs,\n                          const container<O, Alloc> &rhs)\n{\n    return lhs.m_v <= rhs.m_v;\n}\n\ntemplate <typename O, typename Alloc>\nbool constexpr operator>(const container<O, Alloc> &lhs,\n                         const container<O, Alloc> &rhs)\n{\n    return lhs.m_v > rhs.m_v;\n}\n\ntemplate <typename O, typename Alloc>\nbool constexpr operator>=(const container<O, Alloc> &lhs,\n                          const container<O, Alloc> &rhs)\n{\n    return lhs.m_v >= rhs.m_v;\n}\n```"]