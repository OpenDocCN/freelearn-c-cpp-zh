- en: Testing Resource-Restricted Platforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试资源受限的平台
- en: Developing for MCUs and similar resource-restricted platforms is pretty much
    exclusively done on regular PCs, except for testing and debugging. The question
    is when one should be testing on the physical device and when one should be looking
    at alternative means of testing and debugging code in order to speed up development
    and debugging efforts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为MCU和类似资源受限的平台开发几乎完全是在常规PC上进行的，除了测试和调试。问题是何时应该在物理设备上进行测试，何时应该寻找替代测试和调试代码的方法，以加快开发和调试工作。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the resource needs of specific code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解特定代码的资源需求
- en: Effectively using Linux-based tools to test cross-platform code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地使用基于Linux的工具来测试跨平台代码
- en: Using remote debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程调试
- en: Using cross-compilers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交叉编译器
- en: Creating a platform-independent build system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个平台无关的构建系统
- en: Reducing wear
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少磨损
- en: 'Often, during development, there comes that point where one is fixing an issue
    in a system and have to go through the same tweak-compile-deploy-test cycle, over
    and over. Here are the main problems that are introduced with this approach:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在开发过程中，总会出现这样的情况：在系统中修复问题时，不断地进行调整-编译-部署-测试的循环。以下是采用这种方法引入的主要问题：
- en: '**It''s not fun**: It''s frustrating to have to constantly wait for results
    without a clear idea of whether it will actually be fixed this time.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这不是一件有趣的事**：不断等待结果而又不清楚这一次是否真的会被修复，令人沮丧。'
- en: '**It''s not productive**: You spend a lot of time waiting for results you wouldn''t
    need if you could just analyze the problem better.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这不是高效的**：你会花很多时间等待结果，如果你能更好地分析问题，就不需要这样做。'
- en: '**It wears down the hardware**: After removing and reinserting the same connectors
    dozens of times, writing and overwriting the same sections of the ROM chip countless
    times, and power cycling the system hundreds of times, the hardware''s lifespan
    is reduced significantly, along with one''s own patience, and new errors are introduced.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它会磨损硬件**：多次拔插相同的连接器，多次写入和覆盖ROM芯片的相同部分，数百次对系统进行电源循环后，硬件的寿命会显著减少，自己的耐心也会减少，并且会引入新的错误。'
- en: '**Fiddling with test hardware isn''t fun**: The best-case scenario for any
    embedded setup is to be able to take the development board, plug in all the peripherals
    and wiring, flash the ROM with the application, and power it up to see it work.
    Any deviation from this scenario is frustrating and time-consuming.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆弄测试硬件并不有趣**：任何嵌入式设置的最佳情况是能够拿起开发板，插入所有外围设备和接线，刷写应用程序的ROM，并启动它以查看它的工作情况。任何偏离这种情况的情况都令人沮丧且耗时。'
- en: Avoiding such cycles during development is therefore essential. The question
    is how we can most effectively get to a point where we can produce code for something
    such as an 8-bit MCU or a larger 32-bit ARM MCU without ever touching the hardware
    until the final stages of testing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开发过程中避免这种循环是至关重要的。问题是我们如何能够最有效地达到这样一个目标，即在最终测试阶段之前，能够为8位MCU或更大的32位ARM MCU等东西编写代码，而不需要接触硬件。
- en: Planning out a design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划设计
- en: In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at how to pick an appropriate microcontroller for
    an embedded platform. While designing the firmware for the MCU, it's essential
    that we consider not only the resource requirements of specific codes, but also
    the ease of debugging.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml)中，*资源受限的嵌入式系统*，我们讨论了如何为嵌入式平台选择合适的微控制器。在为MCU设计固件时，我们不仅要考虑特定代码的资源需求，还要考虑调试的便利性。
- en: An important advantage of using C++ is the abstractions it offers, including
    the ability to subdivide the code into logical classes, namespaces, and other
    abstractions that allow us to easily reuse, test, and debug the code. This is
    a crucial aspect in any design, and an aspect that needs to be implemented fully
    before one can proceed with actually implementing the design.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++的一个重要优势是它提供的抽象，包括将代码分成逻辑类、命名空间和其他抽象的能力，这使我们能够轻松地重用、测试和调试代码。这是任何设计中的一个关键方面，也是在实际实现设计之前必须完全实现的一个方面。
- en: Depending on the design, it can be either very easy or frustratingly hard to
    debug any issue, or anything in between. If there's a clean separation between
    all the functionality, without leaky APIs or similar problems that could leak
    internal, private data, creating different versions of fundamental classes for
    things such as integration and unit testing will be easy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，调试任何问题可能会非常容易或非常困难，或者介于两者之间。如果所有功能之间有清晰的分离，没有泄漏的API或类似可能泄漏内部私有数据的问题，那么为诸如集成和单元测试之类的基本类创建不同版本将会很容易。
- en: Simply using classes and the like is no guarantee for a design that is modular.
    Even with such a design one can still end up passing internal class data between
    classes, thus breaking modularity. When this happens, i will complicate the overall
    design as the level of dependencies increases with changes to data structures
    and data formats potentially causing issues elsewhere in the application and will
    require creative hacks while writing tests and reimplementing APIs as part of
    larger integration tests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用类等并不能保证设计是模块化的。即使有这样的设计，仍然可能出现在类之间传递内部类数据的情况，从而破坏模块化。当这种情况发生时，会使整体设计变得复杂，因为依赖关系的级别随着数据结构和数据格式的更改而增加，可能会在应用程序的其他地方引起问题，并且在编写测试和重新实现API时需要创造性的解决方法。
- en: In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at how to pick the proper MCU. The points of RAM,
    ROM, and floating-point usage are obviously down to the design we picked to fit
    the project. As we covered in [Chapter 2](cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml),
    *C++ as an Embedded Language*, it's important to understand what the code we write
    is compiled into. This understanding allows one to get an intuitive feeling for
    what the resource cost of a line of code is going to be like without having to
    step through the generated machine code and create an exact clock cycle count
    from there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml)中，*资源受限的嵌入式系统*，我们看了如何选择合适的MCU。RAM、ROM和浮点使用的点显然取决于我们选择的设计来适应项目。正如我们在[第2章](cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml)中所介绍的，*C++作为嵌入式语言*，了解我们编写的代码被编译成什么是很重要的。这种理解使人能够直观地感受到一行代码的资源成本，而无需逐步执行生成的机器代码并从中创建精确的时钟周期计数。
- en: It should be obvious at this point that before one can pick an MCU, one must
    have a pretty good idea of the overall design and the resource requirements, so
    starting off with a solid design is essential.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，显然很明显，在选择MCU之前，必须对整体设计和资源需求有一个相当好的想法，因此从一个坚实的设计开始是至关重要的。
- en: Platform-independent build systems
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台无关的构建系统
- en: Ideally, the project and build system we choose could be used to build the target
    platform on any desktop platform. Usually, the main consideration here is the
    availability of the same toolchain and programmer for each development platform.
    Fortunately, for AVR- and ARM-based MCU platforms, the same GCC-based toolchain
    is available, so that we do not have to take different toolchains with different
    naming conventions, flags and settings into account.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们选择的项目和构建系统可以在任何桌面平台上用于构建目标平台。通常，这里的主要考虑因素是每个开发平台上相同工具链和程序员的可用性。幸运的是，对于基于AVR和ARM的MCU平台，都有相同的基于GCC的工具链可用，因此我们不必考虑不同命名约定、标志和设置的不同工具链。
- en: The remaining challenge is simply to invoke the toolchain, and subsequently
    the programmer utility, in a way that doesn't require any knowledge of the underlying
    OS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的挑战只是以不需要了解底层操作系统的方式调用工具链，以及随后的程序员实用工具。
- en: 'In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we looked at a multitarget build system, which could produce binaries
    for a wide variety of targets with minimal effort for each new target. For an
    MCU target, there would only be the following two targets:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)中，*测试基于操作系统的应用程序*，我们看了一个多目标构建系统，可以在最小的工作量下为各种目标生成二进制文件。对于MCU目标，只会有以下两个目标：
- en: The physical MCU target
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理MCU目标
- en: The local OS target
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地操作系统目标
- en: Here, the first target is obviously fixed, as we picked out the MCU that we
    wanted to target. Barring any unpleasant surprises, we will be using this one
    target for the entire development process. In addition, we will want to preform
    local testing on our development PC. This is the second target.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个目标显然是固定的，因为我们已经选择了我们想要针对的MCU。除非有令人不快的惊喜，我们将在整个开发过程中使用这一个目标。此外，我们还希望在开发PC上进行本地测试。这是第二个目标。
- en: Here it would be great if there is a version of the same or similar  C++ toolchain
    on each mainstream desktop OS. Fortunately, we find that GCC is available on just
    about any platform imaginable, with the Clang C++ frontend of the LLVM toolchain
    using regular GCC-style flags, providing us with broad compatibility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在每个主流桌面操作系统上都有相同或类似的C++工具链版本，那将是很好的。幸运的是，我们发现GCC几乎可以在任何想得到的平台上使用，LLVM工具链的Clang
    C++前端使用常规的GCC风格标志，为我们提供了广泛的兼容性。
- en: Instead of requiring the complexity of a multitarget build system, as we saw
    in [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we can simplify it so it that  just uses GCC, which would allow
    us to use that toolchain on Linux- and BSD-based OSes, along with Windows (MinGW
    via MSYS2 or equivalent) and macOS (after installing GCC).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)中看到的多目标构建系统的复杂性不同，我们可以简化它，只使用GCC，这将允许我们在Linux和BSD操作系统以及Windows（通过MSYS2或等效方式使用MinGW）和macOS（安装GCC后）上使用该工具链。
- en: For full compatibility on macOS, the use of GCC is recommended, due to small
    issues in the Clang implementation. One of these current issues is the `__forceinline`
    macro attribute being broken, for example, which would break a lot of code that
    assumes the GCC compiler.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在macOS上实现完全兼容，建议使用GCC，因为在Clang实现中存在一些小问题。其中一个当前的问题是`__forceinline`宏属性被破坏，例如，这将破坏许多假定GCC编译器的代码。
- en: Using cross-compilers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交叉编译器
- en: Every compiler toolchain consists of a side (frontend) that takes in the source
    code and a side that outputs the binary format for the target platform (backend).
    There's no reason why the backend couldn't work on any other platform than the
    one it's targeting. In the end, one merely transforms text files into sequences
    of bytes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器工具链都由一个接收源代码的一侧（前端）和一个输出目标平台的二进制格式的一侧（后端）组成。后端工作在除了它所针对的平台之外的任何其他平台上都是没有问题的。最终，只是将文本文件转换为字节序列。
- en: Cross-compiling in this fashion is an essential feature with MCU-oriented development,
    as compiling directly on those MCUs would be highly inefficient. There is, however,
    nothing magical about this process. In the case of GCC-based and GCC-compatible
    toolchains, one would still be interacting with the same interfaces on the toolchain,
    just with the tools usually prefixed with the target platform name to distinguish
    them from other toolchains for different targets. Essentially, instead of `g++` one
    would use `arm-none-eabi-g++`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行交叉编译是MCU导向开发的一个重要特性，因为直接在这些MCU上编译将非常低效。然而，这个过程并没有什么神奇之处。对于基于GCC和兼容GCC的工具链，人们仍然会与工具链上的相同接口进行交互，只是工具通常会以目标平台名称为前缀，以区别于其他不同目标的工具链。基本上，人们会使用`arm-none-eabi-g++`代替`g++`。
- en: The resulting binaries would be in the format appropriate for that target platform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的二进制文件将采用适合目标平台的格式。
- en: Local and on-chip debugging
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地和片上调试
- en: In [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml), *Testing OS-Based
    Applications*, we looked at debugging applications using Valgrind and similar
    tools, as well as GDB and kin. With the OS-based integration tests for MCU-based
    projects, such as those demonstrated in the *Example – ESP8266 integration test* section,
    we can use the exact same techniques, profiling and debugging the code without
    concerning ourselves just yet with the fact that the same code will be running
    on a much slower and more limited platform during final integration testing on
    real hardware.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)中，*测试基于OS的应用程序*，我们研究了使用Valgrind和类似工具进行调试应用程序，以及GDB等。通过基于OS的集成测试，例如在*示例
    - ESP8266集成测试*部分演示的MCU项目，我们可以使用完全相同的技术，对代码进行分析和调试，而暂时不用担心相同的代码将在最终集成测试中在一个运行速度更慢、更有限的平台上运行。
- en: The real challenge comes during that final integration stage, when the firmware—which
    we have been debugging on our fast desktop system using Valgrind and other highly
    capable tools—is now running on a paltry 16 MHz ATmega MCU without the ability
    to quickly launch the code with a Valgrind tool or within a GDB session.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的挑战出现在最终集成阶段，当我们在快速桌面系统上调试的固件现在在一个只有16 MHz的ATmega MCU上运行，无法使用Valgrind工具或在GDB会话中快速启动代码。
- en: As one will inevitably encounter bugs and issues during this stage, we need
    to be prepared to deal with this situation. Often, one has to resort to **on-chip
    debugging** (**OCD**), which can be performed over whichever debugging interface
    the MCU provides. This can be JTAG, DebugWire or SWD, PDI, or some other type.
    In [Chapter 4](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml), *Resource-Restricted
    Embedded Systems*, we looked at some of those interfaces in the context of programming
    these MCUs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将不可避免地遇到错误和问题，我们需要做好准备来处理这种情况。通常，人们不得不求助于**片上调试**（**OCD**），可以通过MCU提供的任何调试接口执行。这可以是JTAG、DebugWire或SWD、PDI或其他类型。在[第4章](bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml)中，*资源受限的嵌入式系统*，我们在编程这些MCU时研究了一些接口。
- en: Embedded IDEs will provide the ability to perform OCD right out of the box,
    connecting with the target hardware, allowing one to set breakpoints, much like
    one would be used to setting for a local process. Of course, it's also possible
    to use GDB from the command line to do the same thing, using a program such as
    OpenOCD ([http://openocd.org/](http://openocd.org/)), which provides a `gdbserver`
    interface for GDB while interfacing with a wide variety of debug interfaces.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式IDE将提供直接进行OCD的能力，连接到目标硬件，允许设置断点，就像设置本地进程一样。当然，也可以使用命令行中的GDB来做同样的事情，使用OpenOCD（[http://openocd.org/](http://openocd.org/)）这样的程序，它为GDB提供了`gdbserver`接口，同时与各种调试接口进行交互。
- en: Example – ESP8266 integration test
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - ESP8266集成测试
- en: In this example project, we will look at creating an implementation of the Arduino-like
    APIs of the Sming framework, which we first looked at it in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml),
    *Example - Soil Humidity Monitor with Wi-Fi*. The goal of this is to provide a
    native framework implementation for desktop **operating systems** (**OSes**),
    allowing the firmware to be compiled to an executable and run locally.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例项目中，我们将研究创建Sming框架类似Arduino的API的实现，我们在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中首次看到它，*示例
    - 带WiFi的土壤湿度监测器*。这样做的目的是为桌面**操作系统**（**OSes**）提供一个本地框架实现，允许将固件编译为可执行文件并在本地运行。
- en: In addition, we want to have simulated sensors and actuators that the firmware
    can connect to in order to read out environmental data and send data to actuators
    as part of the BMaC project, which we had a glimpse of in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example -
    Soil Humidity Monitor with WiFi*, and which we will look at in more detail in
    [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example - Building Monitoring
    and Control*. For this, we also need to have a central service that keeps track
    of such information. This way, we can also have multiple firmware processes running,
    to simulate entire rooms full of devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望有模拟传感器和执行器，固件可以连接到这些传感器和执行器，以读取环境数据并将数据发送到执行器，作为BMaC项目的一部分。我们在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中已经有所了解，*示例
    - 带WiFi的土壤湿度监测器*，并且我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中更详细地讨论，*示例
    - 建筑监控与控制*。为此，我们还需要一个中央服务来跟踪这些信息。这样，我们也可以运行多个固件进程，模拟装满设备的整个房间。
- en: The reason for this scope of the simulation is due to not having the physical
    hardware. Without a physical MCU system, we don't have physical sensors, and these
    sensors would not exist in a physical room. Ergo we have to generate plausible
    input for the sensors and simulate the effect of any actuators.  This does however
    come with a lot of advantages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的范围之所以如此之广，是因为没有实际的硬件。没有物理MCU系统，我们就没有物理传感器，这些传感器也不会存在于物理房间中。因此，我们必须为传感器生成合理的输入，并模拟任何执行器的效果。然而，这也带来了许多优势。
- en: Having this scaling ability is useful in that it allows us to validate the firmware
    not only as a standalone system, but also as part of the system it would be installed
    in. In the case of BMaC, this would mean a single node installed in a room of
    a building, with dozens to hundreds of further nodes installed in the same and
    other rooms across the building's floors, along with accompanying backend services
    running on the same network.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种扩展能力是有用的，因为它不仅允许我们验证固件作为独立系统的正确性，还允许我们验证其作为将要安装在其中的系统的一部分的正确性。对于BMaC来说，这意味着在建筑物的一个房间安装一个节点，建筑物的其他房间以及楼层上安装数十到数百个其他节点，同时在同一网络上运行相应的后端服务。
- en: With this kind of large-scale simulation ability, one can test not only the
    basic correctness of the firmware by itself, but also that of the system as a
    whole, with the different firmware types or even versions running in tandem with
    the various sensors and actuators (for air-conditioning units, fans, coffee machines,
    switches, and so on). In addition to this, the backend services would be directing
    the nodes according to the data being passed to them from the same nodes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种大规模模拟能力，我们不仅可以测试固件本身的基本正确性，还可以测试整个系统的正确性，不同类型或版本的固件与各种传感器和执行器（空调、风扇、咖啡机、开关等）同时运行。此外，后端服务将根据从相同节点传递给它们的数据来指导节点。
- en: Within the simulated building, one could then configure specific rooms to have
    particular environmental conditions, run through a working day with people entering,
    working, and leaving, to determine the effect of different levels of building
    occupation, outside conditions, and so on. You could also do this with the firmware
    and backend services that would be used for the final production system. While
    testing a system this way won't fully eliminate any potential problems, it should
    at least validate that the software side of the system is functionally correct.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的建筑物中，可以配置特定的房间具有特定的环境条件，通过一个工作日，人们进入、工作和离开，以确定建筑物占用水平、外部条件等的影响。您也可以使用将用于最终生产系统的固件和后端服务进行这样的测试。虽然以这种方式测试系统不会完全消除任何潜在问题，但至少可以验证系统的软件部分是否功能正确。
- en: As embedded systems are by definition part of a larger (hardware-based) system,
    a full integration test will involve the actual hardware or its equivalent. One
    could therefore consider this example the software integration test, prior to
    deploying the firmware to the target hardware in a physical building.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌入式系统从定义上来说是更大（基于硬件）系统的一部分，完整的集成测试将涉及实际的硬件或其等效物。因此，可以将这个示例视为部署固件到物理建筑物的目标硬件之前的软件集成测试。
- en: Both the simulation server and the individual firmware processes have their
    own main function and run independently from each other. This allows us to inspect
    the functioning of the firmware with as little interference as possible and promotes
    a clean design. To allow efficient communication between these processes, we use
    a **remote procedure call** (**RPC**) library, which essentially creates a connection
    between the firmware and the I2C, SPI, and UART-based devices in the simulated
    room. The RPC library used with this example is NymphRPC, an RPC library developed
    by the author. The source for the current version has been included with the source
    code for this chapter. The current version of the NymphRPC library can be found
    at its GitHub repository at [https://github.com/MayaPosch/NymphRPC](https://github.com/MayaPosch/NymphRPC).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟服务器和单独的固件进程都有自己的主函数，并且彼此独立运行。这使我们能够尽可能少地干扰下检查固件的功能，并促进清晰的设计。为了实现这些进程之间的高效通信，我们使用了一个**远程过程调用**（**RPC**）库，它基本上在模拟房间的固件和I2C、SPI和UART设备之间创建了连接。本示例中使用的RPC库是NymphRPC，这是作者开发的一个RPC库。当前版本的源代码已包含在本章的源代码中。NymphRPC库的当前版本可以在其GitHub存储库中找到：[https://github.com/MayaPosch/NymphRPC](https://github.com/MayaPosch/NymphRPC)。
- en: The server
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: We will first look at the server for this integration test. Its role is to run
    the RPC server and to maintain the state of each of the sensor and actuator devices,
    as well as the rooms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下这个集成测试的服务器。它的作用是运行RPC服务器并维护每个传感器和执行器设备以及房间的状态。
- en: 'The main file, `simulation.cpp`, sets up the RPC configuration as well as the
    main loop, as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 主文件`simulation.cpp`设置了RPC配置以及主循环，如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The includes at the top shows us the basic structure and dependencies. We have
    a custom configuration class, a class defining the building, a static class for
    the nodes, and finally the multithreading headers (available since C++11) and
    the NymphRPC RPC header to gain access to its functionality.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的包含部分向我们展示了基本的结构和依赖关系。我们有一个自定义配置类，一个定义建筑物的类，一个用于节点的静态类，最后是多线程头文件（自C++11起可用）和NymphRPC
    RPC头文件，以便访问其功能。
- en: A signal handler function is defined to be used with the waiting condition later
    on, allowing the server to be terminated with a simple control signal. Finally,
    a logging function is defined for use with the NymphRPC server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个信号处理函数，以便稍后与等待条件一起使用，允许服务器通过简单的控制信号终止。最后，定义了一个用于NymphRPC服务器的日志记录函数。
- en: 'Next, we define the callback functions for the RPC server, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义RPC服务器的回调函数，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the initial function that the clients will call on the server. It will
    check the global, static `Nodes` class for an available MAC address. This address
    uniquely identifies a new node instance, the way a device on the network would
    also be identified by its unique Ethernet MAC address. This is an internal function
    that will not require modification of the firmware, but shifts the ability to
    assign MACs to the server, instead of­ having them hardcoded somewhere. When a
    new MAC has been assigned, it gets associated with the NymphRPC session ID so
    that we can later use the MAC to find the appropriate session ID and, with it,
    the client to call for events generated by simulated devices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端将在服务器上调用的初始函数。它将检查全局静态的“Nodes”类，以获取可用的MAC地址。此地址唯一标识新节点实例，就像网络上的设备也将通过其唯一的以太网MAC地址进行标识一样。这是一个内部函数，不需要修改固件，但是将MAC分配的能力转移到服务器，而不是在某个地方硬编码它们。当分配了新的MAC时，它将与NymphRPC会话ID关联起来，以便我们稍后可以使用MAC找到适当的会话ID，并通过它调用由模拟设备生成的事件的客户端。
- en: 'Here, we also see the basic signature of a NymphRPC callback function as used
    on a server instance. It obviously returns the return message, and it receives
    as its parameters the session ID associated with the connected client, the message
    received from this client, and some user-defined data, as shown in the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还看到了NymphRPC回调函数的基本签名，它在服务器实例上使用。显然，它返回返回消息，并接收与连接的客户端相关的会话ID、从该客户端接收的消息以及一些用户定义的数据，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This callback implements a way to write to the UART interface of a simulated
    node within the simulation, addressing whichever simulated device is hooked up
    to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该回调实现了一种在模拟中写入UART接口的方法，该接口针对连接的任何模拟设备进行寻址。
- en: 'To find the node, we use the MAC address and send it, along with the bytes,
    to be written to the appropriate `Nodes` class function, as shown in the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到节点，我们使用MAC地址并将其与字节一起发送到适当的“Nodes”类函数中，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the SPI bus, a similar system is used for writing and reading. The MAC
    identifies the node and either a string is sent to the bus or is received from
    it. One limitation here is that we assume the presence of only a single SPI device,
    since there is no way to select a different SPI **chip-select** (**CS**) line.
    A separate CS parameter would have to be passed here to enable more than one SPI
    device. Let''s look at the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SPI总线，写入和读取使用类似的系统。MAC标识节点，然后将字符串发送到总线或从总线接收。这里的一个限制是，我们假设只有一个SPI设备存在，因为没有办法选择不同的SPI芯片选择（CS）线。必须在此处传递一个单独的CS参数，以启用多个SPI设备。让我们看看以下代码：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the I2C bus version, we pass the I2C slave device address to allow us to
    use more than a single I2C device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于I2C总线版本，我们传递I2C从设备地址，以允许我们使用多个I2C设备。
- en: 'Finally, the main function registers the RPC methods, starts the simulation,
    and then enters a waiting condition, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主函数注册RPC方法，启动模拟，然后进入等待条件，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first get the configuration data for this simulation using the following
    code. This is all defined in a separate file, that we will load using the special
    `Config` class, which we will take a more detailed look at in a moment when we
    look at the configuration parser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用以下代码获取此模拟的配置数据。这一切都在一个单独的文件中定义，我们将使用特殊的“Config”类加载它，我们稍后将在查看配置解析器时更详细地查看它。
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code, we register the further methods we wish to provide to the client
    node processes, allowing these to call the functions we looked at earlier in this
    source file. In order to register a server-side function with NymphRPC, we have
    to define the parameter types (in order) and use these to define a new `NymphMethod`
    instance, which we provide with this parameter type list, the function name, and
    the return type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们注册了希望提供给客户端节点进程的进一步方法，使其能够调用我们在此源文件中早期查看的函数。为了使用NymphRPC注册服务器端函数，我们必须定义参数类型（按顺序）并使用这些类型来定义一个新的“NymphMethod”实例，然后将此参数类型列表、函数名称和返回类型提供给它。
- en: 'These method instances are then registered with `NymphRemoteClient`, which
    is the top-level class for the server-side NymphRPC, as shown in the following
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些方法实例被注册到“NymphRemoteClient”中，这是服务器端NymphRPC的顶级类，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we install the signal handler for SIGINT (*Ctrl* + *c*) signals. The
    NymphRPC server is started on port 4004, all interfaces. Next, a `Building` instance
    is created, providing it with the instance of the configuration we loaded earlier
    with the configuration parser class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为SIGINT（*Ctrl* + *c*）信号安装信号处理程序。NymphRPC服务器在端口4004上启动，所有接口都可用。接下来，创建一个“Building”实例，并为其提供先前使用配置解析器类加载的配置实例。
- en: We then start a loop that checks whether the value of the `gPredicate` global
    variable has changed to `true`, which will be the case if the signal handler has
    been triggered, and this Boolean variable has been set to `true`. A condition
    variable is used to allow us to block the main thread execution as much as possible
    by having the signal handler notify this condition variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动一个循环，检查“gPredicate”全局变量的值是否已更改为“true”，如果信号处理程序已被触发，并且此布尔变量已设置为“true”，则会发生这种情况。条件变量用于允许我们通过信号处理程序通知此条件变量，尽可能地阻止主线程执行。
- en: By having the condition variable's wait condition inside a loop, we ensure that
    even if the condition variable's wait condition suffers a spurious wake up, it'll
    simply go back to waiting to be notified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在循环中使用条件变量的等待条件，我们确保即使条件变量的等待条件遭受虚假唤醒，它也会简单地回到等待被通知的状态。
- en: Lastly, if the server is requested to terminate, we shut down the NymphRPC server,
    before giving all active threads an additional two seconds to cleanly terminate.
    After this, the server shuts down.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果服务器被要求终止，我们关闭NymphRPC服务器，然后给所有活动线程额外两秒的时间来干净地终止。之后，服务器关闭。
- en: 'Next, let''s look at the `config.cfg` file that we loaded for this simulation,
    as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下我们为此模拟加载的`config.cfg`文件，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, this configuration file uses the standard INI configuration file
    format. It defines a building with two floors, each with two rooms. Each room
    has a single node and each node has a BME280 sensor attached to it on the I2C
    bus.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个配置文件使用标准的INI配置文件格式。它定义了一个有两层楼的建筑，每层有两个房间。每个房间有一个节点，每个节点都连接了一个I2C总线上的BME280传感器。
- en: More devices are defined, but are left unused here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还定义了更多的设备，但在这里没有使用。
- en: 'Let''s look at the configuration parser shown in the following code, which
    parses the preceding format, declared in config.h:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在config.h中声明的解析前述格式的配置解析器：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we see an interesting use of templates, as well as one of their limitations.
    The type passed to the template is used both for the default parameter and the
    return type, allowing the template to cast the raw string obtained from the configuration
    file to the desired type, while also avoiding the issue of incomplete templates
    by only using the type in the return type of the function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了模板的一个有趣用法，以及它们的一个限制。传递给模板的类型既用于默认参数，也用于返回类型，允许模板将从配置文件获取的原始字符串转换为所需的类型，同时避免了不完整模板的问题，因为函数的返回类型中只使用了类型。
- en: Due to the limitation of C++, where every function with the same name must have
    a different set of parameters even if their return value differs, we must use
    the default value parameter here to circumvent that issue. As most of the time
    we want to provide a default value for the keys we are trying to read, this isn't
    much of an issue here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++的限制，即使它们的返回值不同，每个具有相同名称的函数必须具有不同的参数集，因此我们必须在这里使用默认值参数来规避这个问题。由于大多数时候我们希望为我们尝试读取的键提供一个默认值，所以这在这里并不是什么问题。
- en: Finally, we do a bit of type comparison with `std::is_same` to ensure that if
    the target return type is a string, we copy the string straight out of `stringstream`
    instead of trying to convert it using formatted output. As we read the values
    from the INI file using the POCO INI file reader as raw strings, there's no need
    to do any kind of conversion on this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`std::is_same`进行了一些类型比较，以确保如果目标返回类型是字符串，我们直接从`stringstream`中复制字符串，而不是尝试使用格式化输出进行转换。由于我们使用POCO
    INI文件阅读器从INI文件中读取值作为原始字符串，因此无需对其进行任何类型的转换。
- en: 'Its implementation in `config.cpp` is pretty small, as a result of templates
    having to be defined in the header file. You can see this in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`config.cpp`中的实现非常简单，因为模板必须在头文件中定义。您可以在以下代码中看到这一点：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We just implement the method here, which actually loads the configuration file
    from the filename string. In this implementation, we create an instance of the
    POCO `IniFileConfiguration` class on the assumption that we are trying to parse
    an INI file. If loading the configuration file fails for whatever reason, we return
    an error.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在这里实现了这个方法，它实际上从文件名字符串加载配置文件。在这个实现中，我们创建了一个POCO `IniFileConfiguration`类的实例，假设我们正在尝试解析一个INI文件。如果由于任何原因加载配置文件失败，我们会返回一个错误。
- en: In a more fleshed-out version of this parser, we would maybe support different
    configuration types or even sources, with advanced error handling. For our purposes,
    the humble INI format more than suffices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解析器的更完整版本中，我们可能会支持不同的配置类型或甚至来源，并进行高级错误处理。对于我们的目的，简单的INI格式已经足够了。
- en: 'Moving on, the following code shows the `Building` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下代码显示了`Building`类：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because we haven''t added any advanced features to the simulation server, there
    isn''t much to see here yet, nor in its implementation, as shown in the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们还没有向模拟服务器添加任何高级功能，所以在这里还没有太多可看的，也没有在其实现中展示，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we read each floor definition from the file and create a `Floor` instance
    for it, which we add to an array. The instances also receive a reference to the
    configuration object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从文件中读取每个楼层的定义，并为其创建一个`Floor`实例，然后将其添加到数组中。这些实例还会接收一个对配置对象的引用。
- en: 'The `Floor` class is basic as well, for the same reason, as you can see in
    the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floor`类也很基本，原因同样，您可以在以下代码中看到：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s its implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实现：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of note is the way that the central configuration file is being parsed one part
    at a time by each individual class, with each class instance only caring about
    the small section that it has been instructed to care about by the ID.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，中央配置文件被每个单独的类一次性解析一部分，每个类实例只关心其根据ID被指示关心的小节。
- en: Here, we are only concerned with the rooms that are defined for this floor ID.
    We extract the IDs for those rooms, then create new class instances for those
    rooms, saving a copy of each room in a vector. In a more advanced implementation
    of the simulation server, we could implement floor-wide events here, for example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只关心为该楼层ID定义的房间。我们提取这些房间的ID，然后为这些房间创建新的类实例，并将每个房间的副本保存在向量中。在模拟服务器的更高级实现中，我们可以在这里实现整个楼层的事件，例如。
- en: 'The utility header here defines a simple method for splitting strings, as shown
    in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的实用头文件定义了一个简单的方法来分割字符串，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s its implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实现：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function is quite simple, using the provided separator to take a string
    and separate it into parts defined by said separator, which then get copied into
    a vector using emplacement.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单，使用提供的分隔符将一个字符串分隔成由该分隔符定义的部分，然后使用emplacement将其复制到向量中。
- en: 'Next, here''s the `Room` class, as declared in `room.h`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是在`room.h`中声明的`Room`类：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s its implementation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实现：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this class' constructor, we start off by setting the initial conditions of
    this room, specifically the temperature and humidity values. Next, we read out
    the nodes and devices for this room ID, creating instances of each. It starts
    by getting the list of nodes for this room, then for each node we get the list
    of devices, splitting this string into the individual device IDs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的构造函数中，我们首先设置了这个房间的初始条件，具体是温度和湿度值。接下来，我们读取了这个房间ID的节点和设备，创建了每个实例。它首先获取了这个房间的节点列表，然后对于每个节点，我们获取了设备列表，将这个字符串拆分成单独的设备ID。
- en: Each device ID has a device class instantiated for it, with this instance added
    to the node that uses it. This finishes the basic initialization of the simulation
    server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备ID都有一个为其实例化的设备类实例，并将此实例添加到使用它的节点中。这完成了仿真服务器的基本初始化。
- en: 'Next, here''s the `Device` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`Device`类：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s its definition:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的定义：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the constructor, we read out the information for this specific device using
    the provided device ID. Depending on the device type, we look for specific keys.
    These are all stored inside member variables, as shown in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用提供的设备ID读取了这个特定设备的信息。根据设备类型，我们寻找特定的键。这些都存储在成员变量中，如下面的代码所示。
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After a simple setter method for the MAC of the connected node, we get a method
    that allows generated UART events to trigger a callback to the node process via
    an RPC callback method (as we will see in more detail in a moment when we look
    at the `Nodes` class). This is shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接的节点的MAC的简单setter方法之后，我们得到了一个方法，允许生成的UART事件通过RPC回调方法触发对节点进程的回调（我们将在稍后查看`Nodes`类时更详细地看到）。这在下面的代码中显示。
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define a generic method to write to the device, regardless of the type.
    Here, we only handle the I2C interface to obtain the device register that''s being
    addressed, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个通用的方法来写入设备，无论类型如何。在这里，我们只处理I2C接口，以获取正在寻址的设备寄存器，如下面的代码所示。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `read` methods come with a version that defines a length parameter for the
    bytes to be read and a version without parameters, instead passing a zero to the
    first method. This parameter would be useful for a UART, where a fixed buffer
    size would be used for the data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法有一个定义了要读取的字节长度的版本，还有一个没有参数的版本，而是将零传递给第一个方法。这个参数对于UART可能很有用，因为数据的固定缓冲区大小将用于数据。'
- en: For simplicity's sake, we have hardcoded the response for a BME280 combined
    thermometer, hygrometer, and air pressure meter device. We check the value of
    the register that was sent over with an earlier `write` command, then return the
    value appropriate to it, reading the current room values as appropriate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们已经为BME280组合温度计、湿度计和气压计设备硬编码了响应。我们检查了之前发送的寄存器的值，然后根据它返回适当的值，读取当前的房间值。
- en: There are many more devices possible, we would want to implement them in their
    own configuration files or dedicated classes instead of hardcoding them all here
    like this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多可能的设备，我们希望将它们实现在它们自己的配置文件或专用类中，而不是像这样在这里全部硬编码。
- en: 'Custom types for the application are defined in the `types.h` header, as shown
    in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的自定义类型在`types.h`头文件中定义，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we see the enumeration for the different connection types, as well as
    the `RoomState` class, which defines a basic getter/setter-based construction,
    with a mutex providing thread-safe access to the individual values, as multiple
    nodes can try to access the same values while the room itself tries to update
    them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了不同连接类型的枚举，以及`RoomState`类，它定义了基于getter/setter的构造，使用互斥锁提供对单个值的线程安全访问，因为多个节点可以尝试访问相同的值，而房间本身尝试更新它们。
- en: 'Next, here''s the `Node` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`Node`类：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s its implementation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实现：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When a new class instance is created, it obtains its MAC address, adds it to
    its own local variable, and registers it with the `Nodes` class. A new instance
    of the node executable (in our case, called `esp8266`) is launched using the native
    system call, which will cause the OS to start this new process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的类实例时，它会获取它的MAC地址，将其添加到自己的局部变量中，并将其注册到`Nodes`类中。使用本机系统调用启动了节点可执行文件的新实例（在我们的案例中称为`esp8266`），这将导致操作系统启动这个新进程。
- en: 'As the new process starts, it will connect to the RPC server and obtain the
    MAC using the RPC functions that we looked at earlier in this section. After this,
    the class instance and the remote process act as mirror images of each other:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新进程的启动，它将连接到RPC服务器，并使用我们在本节前面看到的RPC函数获取MAC。之后，类实例和远程进程将成为彼此的镜像：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the `Room` class assigns a new device to the node, we assign our MAC to
    it to act as an identifier for which node it belongs to. After this, we query
    the device to see which type of interface it has, so that we can add it to the
    proper interface, taking into account the CS line (if used) for SPI and the bus
    address for I2C.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Room`类为节点分配一个新设备时，我们将我们的MAC分配给它，以充当它所属的节点的标识符。之后，我们查询设备，看它具有哪种类型的接口，以便我们可以将它添加到适当的接口中，考虑到SPI的CS线（如果使用）和I2C的总线地址。
- en: 'Using move semantics, we ensure that we aren''t merely mindlessly making copies
    of the same device class instance, but essentially shifting ownership of the original
    instance, thus improving efficiency. Let''s look at the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动语义，我们确保不仅仅是毫无意义地复制相同的设备类实例，而是实质上转移了原始实例的所有权，从而提高了效率。让我们看看下面的代码。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the writing and reading functionality, not a lot is involved. Using the
    CS (SPI), the bus address (I2C), or neither (UART), we know which type of device
    to access and call its respective methods.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于写入和读取功能，涉及的不多。使用CS（SPI）、总线地址（I2C）或无（UART），我们知道要访问哪种类型的设备，并调用其相应的方法。
- en: 'Finally, here''s the `Nodes` class that ties everything together:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是将所有内容联系在一起的`Nodes`类：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s its definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的定义：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the following methods, we can set and remove node class instances:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方法，我们可以设置和移除节点类实例：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'New MAC and RPC session IDs are registered with the following function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 新的MAC和RPC会话ID是通过以下函数注册的：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The methods for writing and reading from the different interfaces are basically
    pass-through methods, merely using the MAC address to find the appropriate `Node`
    instance to call the method on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同接口写入和读取的方法基本上是透传方法，仅使用MAC地址来找到适当的`Node`实例来调用方法。
- en: 'Of note here is the `sendUart()` method, which uses the NymphRPC server to
    call the callback method on the appropriate node process to trigger its UART receive
    callback, as shown in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是`sendUart()`方法，它使用NymphRPC服务器调用适当节点进程上的回调方法来触发其UART接收回调，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, we got the methods used to set and get the MAC address for new nodes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有用于设置和获取新节点的MAC地址的方法。
- en: With this, we have the basics of the full integration server. In the next section,
    we will take a look at the firmware and client side of the system before looking
    at how everything fits together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了完整集成服务器的基础。在下一节中，我们将看一下系统的固件和客户端端的实现，然后再看看一切是如何组合在一起的。
- en: Makefile
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile
- en: 'The Makefile for this part of the project looks as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分项目的Makefile如下所示：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a rather simple Makefile as we have no special demands. We gather the
    source files, determine the names of the resulting object files, and compile all
    of them before generating a binary out of these object files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的Makefile，因为我们没有特殊的要求。我们收集源文件，确定生成的目标文件的名称，并在生成这些目标文件的二进制文件之前编译它们。
- en: The node
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: This section covers the firmware for the integration test specifically the reimplementation
    of the (Arduino) APIs used in the Sming framework.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了集成测试的固件，具体是重新实现在Sming框架中使用的（Arduino）API。
- en: Most crucial here is that we don't in any way modify the firmware code itself.
    The only parts that we wish to change from the original firmware image for the
    ESP8266 MCU are the APIs that our own code interacts with.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最关键的是，我们绝对不会以任何方式修改固件代码本身。我们希望从ESP8266 MCU的原始固件映像中更改的唯一部分是我们自己的代码与之交互的API。
- en: This means that we have to first determine the APIs that our code interacts
    with and reimplement these in a way that is supported on the target (desktop)
    platform. For our ESP8266-based firmware, this means, for example, that the Wi-Fi
    network side is left unimplemented, as we are using the local network stack of
    the OS and therefore don't care about such details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们首先要确定我们的代码与之交互的API，并以在目标（桌面）平台上支持的方式重新实现这些API。对于基于ESP8266的固件，这意味着，例如，Wi-Fi网络端是未实现的，因为我们使用操作系统的本地网络堆栈，因此不关心这些细节。
- en: Similarly, the I2C, SPI, and UART interfaces are implemented as mere stubs that
    call their respective counterparts on the RPC interface, which we looked at in
    the previous section. For the MQTT protocol client, we could use the `emqtt` MQTT
    library that is part of the Sming framework, but as one will quickly find out,
    this library is meant to be used on embedded systems where the code using it is
    responsible for connecting it to the network stack.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，I2C、SPI和UART接口被实现为简单的存根，调用它们在RPC接口上的对应部分，我们在上一节中已经看过了。对于MQTT协议客户端，我们可以使用Sming框架中的`emqtt`
    MQTT库，但很快就会发现，这个库是用于嵌入式系统的，使用它的代码需要负责将其连接到网络堆栈。
- en: Our code interacts with the API offered by the `MqttClient` class in Sming.
    It uses `emqtt` for the MQTT protocol, and inherits from the `TcpClient` class.
    Following the code down the hierarchy, one will end up at the TCP connection class
    before diving into the underlying LWIP network library stack.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码与Sming中的`MqttClient`类提供的API进行交互。它使用`emqtt`来进行MQTT协议，并继承自`TcpClient`类。沿着代码的层次结构，我们最终会到达TCP连接类，然后深入到底层的LWIP网络库堆栈中。
- en: In order to save ourselves a lot of trouble, it's easiest to just use an alternative
    MQTT library, such as the Mosquitto client library, which is meant to be run on
    a desktop OS, and will therefore use the OS-provided sockets API. This will cleanly
    map to the methods provided by Sming's MQTT client class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免麻烦，最简单的方法就是使用另一个MQTT库，比如Mosquitto客户端库，它是用于在桌面操作系统上运行的，并且因此将使用操作系统提供的套接字API。这将清晰地映射到Sming的MQTT客户端类提供的方法。
- en: 'We can leave the header for this class almost entirely untouched, just adding
    our modifications to integrate the Mosquitto library, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以完全不改动这个类的头文件，只需添加我们的修改以集成Mosquitto库，如下所示：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We're including the header file for the C++-based wrapper for the Mosquitto
    client library here from the version of the Mosquitto library that is included
    in the project for this chapter. This is because the official version of the library
    doesn't support building with MinGW.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含了基于C++的Mosquitto客户端库的头文件，这个库是本章项目中包含的Mosquitto库的版本。这是因为官方版本的库不支持在MinGW下构建。
- en: With the header included, we have the class derive from the Mosquitto MQTT client
    class instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了头文件后，我们让这个类从Mosquitto MQTT客户端类派生而来。
- en: 'Naturally, the implementation of the Sming MQTT client class has been completely
    changed, as you can see in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Sming MQTT客户端类的实现已经完全改变了，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The constructor simply initializes the Mosquitto library, with no further input
    required:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是初始化Mosquitto库，不需要进一步的输入：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the destructor (shown in the following code) we stop the MQTT client-listening
    thread that we launched when we connect to an MQTT broker and clean up the resources
    that were used by the library:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构函数中（如下面的代码所示），我们停止了MQTT客户端监听线程，这个线程是在连接到MQTT代理时启动的，并清理了库使用的资源：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have a number of utility functions, not all of which are being utilized,
    but they are still implemented here for the sake of completeness. It''s also hard
    to predict which ones will be required, therefore it''s often better to implement
    more than strictly necessary, especially if they are small functions that take
    less time to implement than to find out whether that function or method is used
    at all. Let''s look at the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多实用函数，并非所有函数都被使用，但它们仍然在这里实现，以保持完整性。很难预测哪些函数将被需要，因此最好实现比严格必要更多的函数，特别是如果它们是小函数，实现时间比查找该函数或方法是否被使用更少。让我们看一下以下代码：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `connect` methods remain the same, as they all use the same `private` method
    of the class to perform the actual connection operation, as shown in the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`方法保持不变，因为它们都使用类的相同`private`方法来执行实际的连接操作，如下面的代码所示：'
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the first section where we directly use the Mosquitto library. We reinitialize
    the instance either without a password or TLS (anonymous broker access), or with
    a password, or with TLS (left unimplemented here, as we don't need it).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们直接使用Mosquitto库的第一部分。我们重新初始化实例，可以选择不使用密码或TLS（匿名代理访问），或使用密码或TLS（这里未实现，因为我们不需要）。
- en: 'In this method, we also start the listening thread for the MQTT client, which
    will handle all incoming messages so that we don''t have to further concern ourselves
    with this aspect of the process. Let''s look at the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们还启动了MQTT客户端的监听线程，它将处理所有传入的消息，这样我们就不必进一步关注这个过程的方面了。让我们看一下以下代码：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The MQTT message-publish functionality directly maps to the Mosquitto library''s
    methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT消息发布功能直接映射到Mosquitto库的方法：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Subscribing and unsubscribing both also map easily to the MQTT client instance,
    as shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅和取消订阅也很容易映射到MQTT客户端实例，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we implement the Mosquitto `callback` method for when we receive a
    new message from the broker. For each received message, we then call the registered
    `callback` method (from the firmware code) to provide it with the payload and
    topic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了Mosquitto的`callback`方法，当我们从代理接收到新消息时。对于每个接收到的消息，我们调用已注册的`callback`方法（来自固件代码）以提供有效载荷和主题。
- en: This takes care of the MQTT client aspect of the firmware. Next, we need to
    make the rest of the APIs compatible with a desktop OS.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了固件的MQTT客户端方面。接下来，我们需要使其余的API与桌面操作系统兼容。
- en: 'The headers of the Sming framework that the firmware uses are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 固件使用的Sming框架的头文件如下：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first header file defines some platform-related features that we don't need.
    The second header is the one that we will add everything that we need to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个头文件定义了一些与平台相关的特性，我们不需要。第二个头文件是我们将添加我们需要的一切的地方。
- en: 'To check the firmware''s code for API dependencies, we use standard text searching
    tools to find all function calls, filtering out any that do not call into our
    code but into the Sming framework. After doing this we can write the following
    SmingCore.h file with these dependencies:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查固件代码的API依赖关系，我们使用标准文本搜索工具来查找所有函数调用，过滤掉不调用我们的代码而调用Sming框架的函数。在这样做之后，我们可以编写以下带有这些依赖关系的SmingCore.h文件：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We start off with a combination of standard C library and STL includes, along
    with a number of headers that define the rest of the API that we are implementing.
    We also directly use a number of header files that define classes that are used
    throughout these APIs, but not by the firmware itself.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用标准C库和STL包含，以及一些定义我们正在实现的API的头文件。我们还直接使用了一些定义了在这些API中使用的类的头文件，但固件本身并不使用这些类。
- en: A class like the `Delegate` class is sufficiently abstract that it can be used
    as is. As we will see, the `Filesystem` and `Timer` classes required a fair bit
    of reworking to make them work for our purposes. We already looked at the modifications
    to the MQTT client earlier.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 像`Delegate`类这样的类足够抽象，可以直接使用。正如我们将看到的，`Filesystem`和`Timer`类需要进行大量的重写，以使它们适用于我们的目的。我们已经在之前看过对MQTT客户端的修改。
- en: 'Naturally, we also include the header file for the NymphRPC library, which
    will allow us to communicate with the server side of the integration test, as
    shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还包括NymphRPC库的头文件，这将允许我们与集成测试的服务器端进行通信，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For compatibility reasons, we need to define a range of types that are used
    throughout the firmware code. These are equivalent to the types in `cstdint` from
    the C library, so we can use simple `typedefs`, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 出于兼容性原因，我们需要定义一系列在整个固件代码中使用的类型。这些类型相当于C库中的`cstdint`中的类型，因此我们可以使用简单的`typedefs`，如下所示：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first API we fully reimplement is the hardware-based serial device. Since
    this communicates directly with the virtual interface in the server, we just need
    to provide the methods here, with the definition in the source file, as we will
    see in a moment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全重新实现的第一个API是基于硬件的串行设备。由于这与服务器中的虚拟接口直接通信，我们只需要在这里提供方法，并在源文件中进行定义，我们将在下一刻看到。
- en: 'We also declare a global instantiation of this serial object class, identical
    to how the original framework implementation handles it, as shown in the following
    code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了这个串行对象类的全局实例化，与原始框架实现处理方式相同，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The rboot boot manager and SPIFFS filesystem-related functionality has no equivalent
    on a desktop system, so we declare them here (but as we''ll see in a moment, they
    are left as empty stubs):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: rboot引导管理器和SPIFFS文件系统相关功能在桌面系统上没有等效功能，因此我们在这里声明它们（但正如我们将在下一刻看到的，它们被留空作为存根）。
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'On the network side, we have to provide all of the class instances and related
    information that are normally used to connect to a WiFi access point and ensure
    that we are connected. As we aren''t testing WiFi functionality here, these methods
    are of little use, but are needed to satisfy the firmware code and the compiler:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络端，我们必须提供所有通常用于连接到WiFi接入点并确保我们已连接的类实例和相关信息。由于我们在这里不测试WiFi功能，这些方法用处不大，但需要满足固件代码和编译器的要求：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then declare the debug-related output function as well as the watchdog class
    using the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码声明了与调试相关的输出函数以及看门狗类：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We declare the two types of communication buses here, as shown in the following
    code. Again, we declare that there is a global instantiation of each:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明了两种类型的通信总线，如下面的代码所示。同样，我们声明每个都有一个全局实例：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since the firmware contains code that uses the GPIO and ADC pins, the above functions
    are needed as well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于固件包含使用GPIO和ADC引脚的代码，上述函数也是必需的。
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, we declare a number of classes and functions that are mostly there
    to satisfy the compiler as they have no practical use for our purposes, though
    we could potentially implement advanced test scenarios this way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明了许多类和函数，这些类和函数大多是为了满足编译器的要求，因为它们对我们的目的没有实际用途，尽管我们可能可以通过这种方式实现高级测试场景。
- en: 'Next, we''ll look at the implementation of these functions using the following
    code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下代码来实现这些功能：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `handle` variable is the one variable we declare as being static in this
    compile unit. Its purpose is to store the remote server handle ID for future operations
    after we connect to the RPC server, as shown in the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`变量是我们在这个编译单元中声明为静态的唯一变量。它的目的是在连接到RPC服务器后存储远程服务器句柄ID，如下面的代码所示：'
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Just like in the server-side code, we define a simple logging function to use
    with NymphRPC, as shown in the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务器端代码一样，我们定义了一个简单的日志记录函数，用于NymphRPC，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We implement the simple debug output function using C-style string formatting
    features to fit the function''s signature, as shown in the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C风格的字符串格式化功能来实现简单的调试输出函数，以适应函数的签名，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We define the serial callback delegate along with the serial receive buffer
    as static, as we assume the presence of a single UART capable of **receiving data**
    (RX), which happens to be the case on the ESP8266 MCU. We also create a single
    instance of the `HardwareSerial` class, for UART 0, as shown in the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义串行回调委托以及串行接收缓冲区为静态，因为我们假设存在一个能够接收数据（RX）的单个UART，这恰好是ESP8266 MCU的情况。我们还创建了`HardwareSerial`类的单个实例，用于UART
    0，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This class is just there to act as a stub. As none of the code actually uses
    this object''s methods, we can leave them all unimplemented, as shown in the following
    code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是作为一个存根存在。由于代码实际上没有使用这个对象的方法，我们可以将它们全部未实现，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A lot of the methods in this class are simple enough that they can be implemented
    as a simple write to the standard (system) output or with an assignment to a variable.
    Occasionally a method is left unaltered from the original, though even for the
    setting of the callback delegate function in the last method in this group, the
    original code is called into the C-based low-level APIs of the ESP8266''s SDK.
    Let''s look at the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的许多方法都很简单，可以实现为对标准（系统）输出的简单写入或对变量的赋值。偶尔，某个方法与原始方法保持不变，尽管即使在这个组中的最后一个方法中设置回调委托函数时，也调用了原始代码到ESP8266的SDK的C语言低级API。让我们看看下面的代码：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: To receive UART messages, we define a NymphRPC callback function, which for
    that reason is defined as being static. Since the ESP8266 only has a single UART
    capable of receiving data this suffices.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收UART消息，我们定义了一个NymphRPC回调函数，因此它被定义为静态。由于ESP8266只有一个能够接收数据的UART，这就足够了。
- en: 'When called, this method reads out the payload being received on the UART and
    calls the `callback` function that the firmware registered previously, as shown
    in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，这个方法读取在UART上接收的有效负载，并调用固件之前注册的`callback`函数，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Writing to the remote UART is done using an RPC call. To do this, we create
    an STL vector and fill it with the parameters to pass in the proper order—in this
    case, the node's MAC address and the data that we wish to send on the remote UART.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 向远程UART写入是使用RPC调用完成的。为此，我们创建了一个STL向量，并按正确顺序填充参数——在本例中是节点的MAC地址和我们希望在远程UART上发送的数据。
- en: 'After this, we use the NymphRPC handle that we got when we connected to call
    the RPC server and wait for the response from the remote function, as shown in
    the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用连接时获得的NymphRPC句柄来调用RPC服务器，并等待远程函数的响应，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Reading from the UART is done after we''ve received data on the UART, after
    which we can read it out with the following method, just as we would with the
    original code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从UART接收数据后，我们可以使用以下方法读取它，就像原始代码一样：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Both the rboot boot manager and the SPIFFS filesystem are not used, so they
    can just return safe values, as shown in the following code. The **over-the-air**
    (**OTA**) functionality could potentially be implemented as well, depending on
    the kind of features of the system one would want to test:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: rboot引导管理器和SPIFFS文件系统都没有被使用，因此它们可以返回安全值，如下面的代码所示。**空中**（OTA）功能也可能被实现，这取决于系统的特性。
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since we don''t have a Wi-Fi adapter that we want to use directly and are just
    using the OS''s network capabilities, the `WiFiStation` object doesn''t do a lot
    for most of its methods, except for when we actually connect to the RPC server,
    which is done using the following method:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有要直接使用的WiFi适配器，而只是使用操作系统的网络功能，大多数情况下`WiFiStation`对象的方法并没有太多用处，除非我们实际连接到RPC服务器，这是使用以下方法完成的：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is one of the first methods that gets called in the firmware when it tries
    to connect to the Wi-Fi access point. Instead of connecting to a Wi-Fi access
    point, we use this method to connect to the RPC server instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是固件尝试连接到Wi-Fi接入点时调用的第一个方法之一。我们使用这个方法连接到RPC服务器，而不是连接到Wi-Fi接入点。
- en: We start by initializing the NymphRPC library, calling the initialization method
    on its `NymphRemoteServer` class, and then connecting to the RPC server using
    the hardcoded location and port number. Upon successfully connecting to the RPC
    server, this client will receive a list of the available methods on the RPC server—in
    this case, all of the methods we registered, as we saw in the previous section
    on the simulation server.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化NymphRPC库，调用其`NymphRemoteServer`类的初始化方法，然后使用硬编码的位置和端口号连接到RPC服务器。成功连接到RPC服务器后，此客户端将接收RPC服务器上可用方法的列表——在本例中，就是我们在模拟服务器上注册的所有方法，正如我们在前一节中看到的。
- en: 'Next, we request our MAC address from the server, verify that it''s a string
    that we received, and set it for later use. Finally, we locally register the callback
    for the UART with NymphRPC, as shown in the following code. As we saw in the simulation
    server''s section, the `Nodes` class on the server expects this callback to exist
    on the client:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从服务器请求我们的MAC地址，验证收到的是否是字符串，并将其设置为以后使用。最后，我们在NymphRPC中本地注册UART的回调，如下面的代码所示。正如我们在模拟服务器的部分中看到的，服务器上的`Nodes`类期望客户端存在这个回调：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We conclude this networking section with some more stub classes and, finally,
    the watchdog class, which might make for a nice point for advanced testing, including
    soft reset testing for long-running code. Of course, such advanced tests would
    also require that the code runs with the performance of the ESP8266's sub-100
    MHz processor.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一些更多的存根类和最后的看门狗类结束了这个网络部分，这可能是一个很好的高级测试点，包括长时间运行代码的软复位测试。当然，这样的高级测试也需要代码以ESP8266的低于100MHz的处理器性能运行。
- en: 'Of note here is the Wi-Fi events class, where we immediately call the `callback`
    function for a successful connection to the Wi-Fi access point, or at least pretend
    to. Without this step, the firmware would forever wait for something to happen.
    Let''s look at the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是Wi-Fi事件类，在成功连接到Wi-Fi接入点时，我们立即调用`callback`函数，或者至少假装这样做。如果没有这一步，固件将永远等待发生某些事情。让我们看看下面的代码：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To write on the SPI bus, we again just call the RPC method on the server, getting
    the response once that call has been completed, as shown in the following code.
    For simplicity''s sake, no SPI read functionality is implemented in this example
    project:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在SPI总线上写入，我们只需在服务器上调用RPC方法，在完成调用后获取响应，如下面的代码所示。为简单起见，此示例项目中未实现SPI读取功能：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After some stub methods in the I2C class, we find the `write` methods. These
    are essentially the same methods, calling the `remote` method to send the data
    to the simulated I2C bus on the server, as shown in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在I2C类中的一些存根方法之后，我们找到了`write`方法。这些本质上是相同的方法，调用`remote`方法将数据发送到服务器上模拟的I2C总线，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To read from the I2C bus, we use the preceding method, first writing the I2C
    address we wish to write to, then calling the RPC function to read from the simulated
    I2C device that should have data available to read, as shown in the following
    code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要从I2C总线读取，我们使用前面的方法，首先写入我们希望写入的I2C地址，然后调用RPC函数从模拟的I2C设备读取应该可用于读取的数据，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The I2C read functionality is essentially the same as it was in the original
    implementation, as both just interact with a local buffer, as shown in the following
    code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: I2C读取功能本质上与原始实现中的相同，因为两者都只是与本地缓冲区交互，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here are more stub implementations that could be of use for specific test scenarios:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有更多的存根实现，可能对特定的测试场景有用：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We left these functions unimplemented, but they could implement GPIO and ADC
    pins that are connected to virtual GPIO pins on the server side, to control devices
    and record data that does not use a UART, SPI, or I2C interface. The same would
    work for PWM functionality.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有实现这些函数，但它们可以实现连接到服务器端虚拟GPIO引脚的GPIO和ADC引脚，以控制设备并记录不使用UART、SPI或I2C接口的数据。PWM功能也是一样的。
- en: 'Moving on to the final part in this source file, we implement the main function
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是这个源文件的最后部分，我们实现了主函数如下：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Just like the Sming version of the entry point, we call the global `init()`
    function in the custom firmware code, which serves as the entrance point there.
    Conceivably, we could also perform various types of initialization in this main
    function if we needed to.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Sming版本的入口点一样，我们在自定义固件代码中调用全局的`init()`函数，这在那里充当入口点。可以想象，如果需要的话，我们也可以在这个主函数中执行各种类型的初始化。
- en: 'The filesystem class methods are implemented using a mixture of C-style file
    access and C++17-style filesystem operations, as shown in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统类方法使用C风格文件访问和C++17风格文件系统操作的混合实现，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To simplify this method, we ignore the provided flags and always open the file
    in full read and write mode (one would only implement the full set of flags if
    it contributed to the integration test in some way). Let''s look at the following
    code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个方法，我们忽略提供的标志，并始终以完全读写模式打开文件（只有在某种程度上有助于集成测试时，才会实现完整的标志集）。让我们看看下面的代码：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These are all standard file operations, so they don't require a lot of explanation.
    The main reason why both C-style and C++17-style file access are used is because
    the original API methods assume a C-style way of handling things, and also because
    of the underlying, C-based SDK functionality.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是标准文件操作，因此不需要太多解释。之所以同时使用C风格和C++17风格的文件访问，主要是因为原始API方法假定以C风格处理事务，并且还因为底层基于C的SDK功能。
- en: We would map all API methods to a pure C++17 filesystem functionality, but this
    would be an additional time investment without any obvious payoff.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来想将所有API方法映射到纯C++17文件系统功能，但这将是额外的时间投资，没有明显的回报。
- en: 'The timer functionality uses POCO''s `Timer` class in Sming''s `SimpleTimer`
    class to implement an equivalent functionality, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器功能使用POCO的`Timer`类在Sming的`SimpleTimer`类中实现了等效功能，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, for the reimplementation of the `Clock` class, we use STL''s chrono
    functionality, as shown in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Clock`类的重新实现，我们使用STL的chrono功能，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we leave the `delay` functions unimplemented since we don't need them
    at this point.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有实现`delay`函数，因为在这一点上我们不需要它们。
- en: Makefile
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile
- en: 'The Makefile for this part of the project looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的这一部分的Makefile如下所示：
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The main thing to note about this Makefile is that it gathers source files from
    two different source folders, both for the test API and for the firmware source.
    The former source files are first compiled to object files, which are assembled
    into an archive. The firmware source is used directly along with this test framework
    library, though we also have the firmware object files available if we need them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个Makefile的主要注意事项是它从两个不同的源文件夹中收集源文件，一个是测试API，一个是固件源代码。前者的源文件首先被编译为目标文件，然后被组装成一个存档文件。固件源代码直接与这个测试框架库一起使用，尽管如果需要，我们也可以使用固件对象文件。
- en: The reason for creating an archive of the test API before linking it has to
    do with the way that the linker finds symbols. By using the AR tool, it will create
    an index of all symbols in the object files inside the archive, ensuring that
    we will not get any linker errors. Especially for large projects this is often
    a requirement to have the object files successfully link into a binary.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接之前创建测试API的存档的原因与链接器查找符号的方式有关。通过使用AR工具，它将创建存档文件中对象文件的所有符号的索引，确保我们不会得到任何链接器错误。特别是对于大型项目，这通常是将对象文件成功链接到二进制文件中的要求。
- en: Compiling to object files first is also helpful with larger projects, as Make
    will ensure that only files that have actually changed will be recompiled, which
    can really speed up development time. Since the target firmware source for this
    project is fairly minimal, we can compile directly from the source files here.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将文件编译为目标文件对于较大的项目也是有帮助的，因为Make会确保只重新编译实际更改的文件，这可以真正加快开发时间。由于该项目的目标固件源代码相当简化，我们可以直接从这里的源文件进行编译。
- en: We also include two more Makefiles from this one. The first includes the version
    number of the firmware source we are compiling with, which is useful since it'll
    ensure that the produced node binary will report the exact same version as the
    version installed on an ESP8266 module would. This making validation of a specific
    firmware version much easier.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从这个Makefile中包含了另外两个Makefile。第一个包括我们正在编译的固件源代码的版本号，这很有用，因为它将确保生成的节点二进制文件将报告与安装在ESP8266模块上的固件版本完全相同的版本。这样可以更轻松地验证特定固件版本。
- en: 'The second is the Makefile with user-definable settings, copied *verbatim*
    from the firmware project Makefile, but with just the variables we need for the
    firmware source to compile and work, as shown in the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是Makefile，具有可由用户定义的设置，直接从固件项目的Makefile中复制，但只包括固件源代码编译和工作所需的变量，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Including this Makefile sets all of these defines to be passed to the compiler.
    These are all preprocessor statements that are used to set strings or to change
    which parts of the code will be compiled, such as the SSL code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此Makefile会将所有这些定义传递给编译器。这些都是预处理器语句，用于设置字符串或更改将被编译的代码的哪些部分，例如SSL代码。
- en: However, for simplicity's sake, we aren't implementing SSL functionality for
    this example project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，出于简单起见，我们不会为这个示例项目实现SSL功能。
- en: Building the project
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建项目
- en: 'For the server side, we have the following library dependencies:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端，我们有以下库依赖：
- en: NymphRPC
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NymphRPC
- en: POCO
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POCO
- en: 'For the node, we have the following dependencies:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于节点，我们有以下依赖：
- en: NymphRPC
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NymphRPC
- en: POCO
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POCO
- en: Mosquitto
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mosquitto
- en: The NymphRPC library (described at the beginning of this section) is compiled
    according to the project's instructions and installed in a place where the linker
    can find it. The POCO libraries are installed using the system's package manager
    (Linux, BSD, or MSYS2) or by hand.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: NymphRPC库（在本节开头描述）根据项目的说明进行编译，并安装在链接器可以找到的位置。POCO库使用系统的软件包管理器（Linux、BSD或MSYS2）或手动安装。
- en: For the Mosquitto library dependency, we can compile the `libmosquitto` and
    `libmosquittopp` library files using the project's library version by using the
    Makefile in the `test/SmingCore/network/libmosquitto` folder. Again you should
    install the resulting library files where the linker can find them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mosquitto库依赖，我们可以使用`test/SmingCore/network/libmosquitto`文件夹中的Makefile编译`libmosquitto`和`libmosquittopp`库文件。同样，您应该将生成的库文件安装在链接器可以找到的位置。
- en: When not using MinGW, one can also use the generally available version via the
    OS's package manager or similar.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当不使用MinGW时，也可以通过操作系统的软件包管理器或类似方式使用通常可用的版本。
- en: 'After these steps, we can compile the server and client using the following
    command-line command from the root of the project:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些步骤，我们可以使用以下命令行命令从项目的根目录编译服务器和客户端：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This should compile both the server and node projects using the top-level Makefile,
    resulting in an executable for each in their respective `bin/` folder. You should
    ensure that the executable name and path in the server's `Node` class match that
    of the node executable's location.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该使用顶层Makefile编译服务器和节点项目，分别在它们各自的`bin/`文件夹中生成可执行文件。您应该确保服务器的`Node`类中的可执行文件名称和路径与节点可执行文件的位置匹配。
- en: We should now be able to run the project and start to collect test results.
    The project includes a stripped version of the ESP8266-based BMAC firmware, which
    we'll be covering in detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Monitoring and Control*. Please refer to that chapter to understand
    how to communicate with the simulated nodes via MQTT, how to turn on modules inside
    the firmware and how to interpret the data sent over MQTT by the modules.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够运行项目并开始收集测试结果。该项目包括一个精简版本的基于ESP8266的BMAC固件，我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中详细介绍，*示例
    - 建筑监控和控制*。请参考该章节，了解如何通过MQTT与模拟节点通信，如何在固件中打开模块，以及如何解释模块通过MQTT发送的数据。
- en: After setting things up as described in that chapter - requiring at the least
    an MQTT broker and a suitable MQTT client - and turning on the BME280 module in
    the simulated node, we expect it to start sending over MQTT the temperature, humidity
    and air pressure values we set for the room the simulated node is in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照该章节中描述的设置之后 - 至少需要一个MQTT代理和一个合适的MQTT客户端 - 并在模拟节点中打开BME280模块后，我们期望它开始通过MQTT发送我们为模拟节点所在房间设置的温度、湿度和气压值。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to effectively develop for MCU-based targets
    in a way that allows us to test them without expensive and long-winded development
    cycles. We learned how to implement an integration environment that allows us
    to debug MCU-based applications from the comfort of a desktop OS and the tools
    it provides.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何有效地为基于MCU的目标开发，以便我们可以在不昂贵和冗长的开发周期中测试它们。我们学会了如何实现一个集成环境，使我们能够从桌面操作系统和提供的工具舒适地调试基于MCU的应用程序。
- en: The reader should now be able to develop integration tests for MCU-based projects
    and effectively use OS-based tools to profile and debug them before doing final
    integration work on real hardware. The reader should also be able to perform on-chip
    debugging, and have a feel for the relative cost of specific software implementations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该能够为基于MCU的项目开发集成测试，并有效地使用基于操作系统的工具对其进行分析和调试，然后在真实硬件上进行最终集成工作。读者还应该能够进行芯片内调试，并对特定软件实现的相对成本有所了解。
- en: In the next chapter, we'll develop a simple infotainment system, based on an
    SBC platform.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开发一个基于SBC平台的简单信息娱乐系统。
