- en: '*Chapter 4*: Implementing Quaternions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：实现四元数'
- en: In this chapter, you will learn about quaternions. Quaternions are used to encode
    rotations. A quaternion is a complex number in an *x*i *+ y*j *+ z*k *+ w* form.
    Think of *i,* *j*,
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习有关四元数的知识。四元数用于编码旋转。四元数是以*x*i *+ y*j *+ z*k *+ w*形式的复数。想象一下*i，*j，
- en: and *k* as placeholders that each represent a three-dimensional axis. *w* is
    a real number. While quaternions don't directly encode an angle axis pair, it's
    easy to think of them
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 和*k*作为每个代表三维轴的占位符。*w*是一个实数。虽然四元数不直接编码角轴对，但很容易将它们想象为
- en: as just that—a rotation about an arbitrary axis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那样——围绕任意轴旋转。
- en: 'By the end of this chapter, you should have a strong understanding of what
    quaternions are and how to use them and you will have implemented a robust quaternion
    class in code. This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该对四元数是什么以及如何使用它们有很强的理解，并且您将在代码中实现了一个强大的四元数类。本章将涵盖以下主题：
- en: Different methods for creating quaternions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建四元数的不同方法
- en: Retrieving the angle and axis of a quaternion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索四元数的角度和轴
- en: Basic component-wise operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的分量操作
- en: The length and dot product of two quaternions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个四元数的长度和点积
- en: Inverting quaternions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转四元数
- en: Combining quaternions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合四元数
- en: Transforming vectors by quaternions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过四元数变换向量
- en: Interpolating between quaternions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在四元数之间插值
- en: Converting quaternions and matrices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将四元数和矩阵转换
- en: Why are quaternions important? Most humanoid animations are created using only
    rotations—no translation or scale is needed. Think about an elbow joint, for example.
    The natural motion of an elbow only rotates. If you want to translate the elbow
    through space, you rotate the shoulder. Quaternions encode rotations and they
    interpolate well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么四元数很重要？大多数人形动画只使用旋转——不需要平移或缩放。例如，想象一下肘关节。肘部的自然运动只是旋转。如果您想要将肘部平移到空间中，您需要旋转肩膀。四元数编码旋转，并且它们插值得很好。
- en: 'Important information:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息：
- en: In this chapter, you will implement quaternions with an intuitive, code-first
    approach. If you are interested in the more formal math behind quaternions, check
    out [https://gabormakesgames.com/quaternions.html](https://gabormakesgames.com/quaternions.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将以直观的代码优先方法实现四元数。如果您对四元数背后更正式的数学感兴趣，请查看[https://gabormakesgames.com/quaternions.html](https://gabormakesgames.com/quaternions.html)。
- en: Creating quaternions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建四元数
- en: Quaternions are used to encode rotation data. In code, quaternions will have
    four components. They resemble `vec4` in that they have an `x`, `y`, `z`, and
    `w` component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数用于编码旋转数据。在代码中，四元数将有四个分量。它们类似于`vec4`，因为它们有`x`、`y`、`z`和`w`分量。
- en: As with `vec4`, the `w` component comes last.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与`vec4`一样，`w`分量最后出现。
- en: 'The `quat` structure should have two constructors. The default constructor
    creates an identity quaternion, `(0, 0, 0, 1)`. The `(0, 0, 0, 1)` identity quaternion
    is like `1`. Any number multiplied by `1` remains the same. Similarly, any quaternion
    multiplied by the identity quaternion remains the same:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`quat`结构应该有两个构造函数。默认构造函数创建一个单位四元数，`(0, 0, 0, 1)`。`(0, 0, 0, 1)`单位四元数就像`1`。任何数乘以`1`仍然保持不变。同样，任何四元数乘以单位四元数仍然保持不变：'
- en: 'Create a new file, `quat.h`, to declare the quaternion structure. The `quat`
    structure is going to be used throughout the rest of this book to represent rotations:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`quat.h`，声明四元数结构。`quat`结构将在本书的其余部分中用于表示旋转：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The anonymous union inside the `quat` structure will allow you to access the
    data inside a quaternion through `X`, `Y`, `Z`, and `W` subscript notation, as
    a vector and scalar pair, or as an array of floating-point values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`quat`结构内的匿名联合将允许您通过`X`、`Y`、`Z`和`W`下标符号访问四元数内的数据，作为矢量和标量对，或作为浮点值数组。'
- en: Next, you're going to learn how to start creating quaternions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何开始创建四元数。
- en: Angle axis
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角轴
- en: Quaternions are often created using an axis of rotation and an angle. A rotation
    about an axis by *θ* can be represented on a sphere as any directed arc whose
    length is ![](img/Formula_04_001.png) on the plane perpendicular to the rotation
    axis. Positive angles yield a counterclockwise rotation around the axis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数通常使用旋转轴和角度创建。关于轴的旋转*θ*可以在球面上表示为任何有向弧，其长度为![](img/Formula_04_001.png)，位于垂直于旋转轴的平面上。正角度产生绕轴的逆时针旋转。
- en: 'Create a new file, `quat.cpp`. Implement the `angleAxis` function in `quat.cpp`.
    Don''t forget to add the function declaration to `quat.h`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`quat.cpp`。在`quat.cpp`中实现`angleAxis`函数。不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why ![](img/Formula_04_002.png)? A quaternion can track two full rotations,
    which is *720* degrees. This makes the period of a quaternion *720* degrees. The
    period of sin/cos is *360* degrees. Dividing *θ* by *2* maps the range of a quaternion
    to the range of sin/cos.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么！[](img/Formula_04_002.png)？四元数可以跟踪两个完整的旋转，即*720*度。这使得四元数的周期为*720*度。sin/cos的周期是*360*度。将*θ*除以*2*将四元数的范围映射到sin/cos的范围。
- en: In this section, you learned how the angle and axis of a rotation are encoded
    in
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何编码旋转的角度和轴
- en: a quaternion. In the next section, you will learn how to build an angle and
    an axis
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数。在下一节中，您将学习如何构建一个角度和一个轴
- en: for the rotation between two vectors and encode that into a quaternion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用于两个向量之间的旋转，并将其编码为四元数。
- en: Creating rotations from one vector to another
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个向量到另一个向量创建旋转
- en: Any two-unit vectors can represent points on a sphere. The shortest arc between
    these points lies on a plane that contains both points and the center of the sphere.
    This plane
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何两个单位向量都可以表示球面上的点。这些点之间的最短弧位于包含这两个点和球心的平面上。这个平面
- en: is perpendicular to the axis of rotation between those two vectors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直于这两个向量之间的旋转轴。
- en: 'To find the axis of rotation, normalize the input vectors. Find the cross product
    of the input vectors. This is the axis of rotation. Find the angle between the
    input vectors. From [*Chapter 2*](B16191_02_Final_JC_ePub.xhtml#_idTextAnchor026),
    *Implementing Vectors*, the formula for the angle between two vectors is ![](img/Formula_04_003.png).
    Since both input vectors are normalized, this simplifies to ![](img/Formula_04_004.png),
    which means that the cosine of *θ* is the dot product of the input vectors:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到旋转轴，需要对输入向量进行归一化。找到输入向量的叉积。这就是旋转轴。找到输入向量之间的角度。从[*第2章*](B16191_02_Final_JC_ePub.xhtml#_idTextAnchor026)，*实现向量*中，两个向量之间角度的公式为![](img/Formula_04_003.png)。由于两个输入向量都被归一化了，这简化为![](img/Formula_04_004.png)，这意味着*θ*的余弦是输入向量的点积：
- en: '![](img/Formula_04_005.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_005.png)'
- en: 'You will recall from [*Chapter 2*](B16191_02_Final_JC_ePub.xhtml#_idTextAnchor026),
    *Implementing Vectors*, that the dot product has a relationship to the cosine
    of the angle between two vectors, and that the cross product has a relationship
    to the sine of the angle between two vectors. When creating quaternions, the dot
    and cross product have the following properties:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得从[*第2章*](B16191_02_Final_JC_ePub.xhtml#_idTextAnchor026)，*实现向量*中，点积与两个向量之间夹角的余弦有关，而叉积与两个向量之间夹角的正弦有关。在创建四元数时，点积和叉积具有以下属性：
- en: '![](img/Formula_04_006.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_006.png)'
- en: '![](img/Formula_04_007.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_007.png)'
- en: The cross product can be expanded into *x*, *y*, and *z* components and the
    previous equation starts to look like the code for creating a quaternion from
    an angle and an axis of rotation. Finding the angle between the two vectors would
    be expensive, but the half-angle can be counted without knowing what the angle
    is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积可以扩展为*x*、*y*和*z*分量，前面的方程开始看起来像是从角度和旋转轴创建四元数的代码。找到两个向量之间的角度会很昂贵，但可以计算出半角而不知道角度是多少。
- en: To find the half-angle, find the halfway vector between the *v1* and *v2* input
    vectors. Construct a quaternion using *v1* and this halfway vector. This will
    create a quaternion that results in the desired rotation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到半角，找到*v1*和*v2*输入向量之间的中间向量。使用*v1*和这个中间向量构造一个四元数。这将创建一个导致所需旋转的四元数。
- en: There is one edge case—what happens when *v1* and *v2* are parallel? Or if *v1==
    -v2* ? The cross product that's used to find the axis of rotation would yield
    a *0* vector. If this edge case happens, find the most perpendicular vector between
    the two vectors to create a pure quaternion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊情况——当*v1*和*v2*平行时会发生什么？或者如果*v1== -v2*？用于找到旋转轴的叉积会产生一个*0*向量。如果发生这种特殊情况，找到两个向量之间最垂直的向量来创建一个纯四元数。
- en: 'Perform the following steps to implement the `fromTo` function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现`fromTo`函数：
- en: 'Begin to implement the `fromTo` function in `quat.cpp` and add the function
    declaration to `quat.h`. Start by normalizing the `from` and `to` vectors, making
    sure they are not the same vector:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始在`quat.cpp`中实现`fromTo`函数，并在`quat.h`中添加函数声明。首先对`from`和`to`向量进行归一化，确保它们不是相同的向量：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, check whether the two vectors are opposites of each other. If they are,
    the most orthogonal axis of the `from` vector can be used to create a pure quaternion:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查两个向量是否互为相反。如果是的话，`from`向量的最正交轴可以用来创建一个纯四元数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create a half vector between the `from` and `to` vectors. Use the
    cross product of the half vector and the starting vector to calculate the axis
    of rotation and the dot product of the two to find the angle of rotation:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个`from`和`to`向量之间的半向量。使用半向量和起始向量的叉积来计算旋转轴，使用两者的点积来找到旋转角度：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `fromTo` function is one of the most intuitive ways of creating a quaternion.
    Next, you're going to learn how to retrieve the angle and the axis that define
    a quaternion.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromTo`函数是创建四元数的最直观方式之一。接下来，你将学习如何检索定义四元数的角度和轴。'
- en: Retrieving quaternion data
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索四元数数据
- en: Since a quaternion can be created from an angle and an axis, it's reasonable
    to expect to be able to retrieve the same angle and axis from the quaternion.
    To retrieve the axis of rotation, normalize the vector part of the quaternion.
    The angle of rotation is double the inverse cosine of the real component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以从角度和轴创建四元数，因此可以合理地期望能够从四元数中检索相同的角度和轴。要检索旋转轴，需要对四元数的向量部分进行归一化。旋转角度是实部的反余弦的两倍。
- en: 'Implement the `getAngle` and `getAxis` functions in `quat.cpp` and add function
    declarations for both in `quat.h`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`getAngle`和`getAxis`函数，并在`quat.h`中为两个函数添加函数声明：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Being able to retrieve the angle and the axis that defines a quaternion will
    be needed later for some quaternion operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 能够检索定义四元数的角度和轴将在以后一些四元数操作中需要。
- en: Next, you're going to learn about the component-wise operations that are commonly
    performed on quaternions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习常用的四元数分量操作。
- en: Common quaternion operations
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的四元数操作
- en: Like vectors, quaternions also have component-wise operations. Common
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量一样，四元数也有分量操作。常见的
- en: component-wise operations are adding, subtracting, multiplying, or negating
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分量操作包括加法、减法、乘法或否定
- en: quaternions. Component-wise quaternion multiplication multiplies a quaternion
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数。分量乘法将四元数相乘
- en: by a single scalar value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单个标量值。
- en: 'Since these functions are component-wise, they just perform the appropriate
    action on similar components of the input quaternions. Implement these functions
    in `quat.cpp` and add declarations for each function in `quat.h`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些函数是分量操作，它们只是对输入四元数的相似分量执行适当的操作。在`quat.cpp`中实现这些函数，并在`quat.h`中为每个函数添加声明：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These component-wise operations don't have much practical use by themselves.
    They are the building blocks for building the rest of the quaternion functionality
    on. Next, you're going to learn about the different ways to compare quaternions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分量级的操作本身并没有太多实际用途。它们是构建四元数功能的基本组件。接下来，您将学习有关比较四元数的不同方法。
- en: Comparison operations
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较操作
- en: 'Comparing two quaternions can be done component-wise. Two quaternions can represent
    the same rotation even if they are not identical on a component level. This happens
    because a quaternion and its inverse rotate to the same spot but they take different
    routes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个四元数可以逐分量进行。即使两个四元数在分量级别上不相同，它们仍然可以表示相同的旋转。这是因为一个四元数及其逆旋转到相同的位置，但它们采取不同的路径。
- en: 'Overload the `==` and `!=` operators in `quat.cpp`. Add the declaration for
    these functions to `quat.h`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中重载`==`和`!=`运算符。将这些函数的声明添加到`quat.h`中：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To test whether two quaternions represent the same rotation, the absolute difference
    between the two needs to be tested. Implement the `sameOrientation` function in
    `quat.cpp`. Add the function declaration to `quat.h`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试两个四元数是否代表相同的旋转，需要测试两者之间的绝对差异。在`quat.cpp`中实现`sameOrientation`函数。将函数声明添加到`quat.h`中：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of the time, you will want to use the equality operator to compare quaternions.
    The `sameOrientation` function is not as useful because the rotation that a quaternion
    takes can be changed if the quaternion is inverted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您将希望使用相等运算符来比较四元数。`sameOrientation`函数不太有用，因为四元数的旋转可以在四元数被反转时发生变化。
- en: In the next section, you will learn how to implement a quaternion dot product.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何实现四元数点积。
- en: Dot product
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点积
- en: Like with vectors, the dot product measures how similar two quaternions are.
    The implementation is the same as the vector implementation. Multiply like components
    and sum the result.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量一样，点积测量两个四元数的相似程度。实现与向量实现相同。相乘相同的分量并求和结果。
- en: 'Implement the quaternion dot product function in `quat.cpp` and add its declaration
    to `quat.h`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现四元数点积函数，并将其声明添加到`quat.h`中：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Like vectors, the length of a quaternion is the dot product of the quaternion
    with itself. In the next section, you will learn how to find the squared length
    and length of a quaternion.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量一样，四元数的长度是四元数与自身的点积。在下一节中，您将学习如何找到四元数的平方长度和长度。
- en: Length and squared length
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长度和平方长度
- en: 'Like vectors, the squared length of a quaternion is the same as the dot product
    of the quaternion with itself. The length of a quaternion is the square root of
    the square length:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量一样，四元数的平方长度与四元数与自身的点积相同。四元数的长度是平方长度的平方根：
- en: 'Implement the `lenSq` function in `quat.cpp` and declare the function in `quat.h`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`lenSq`函数，并在`quat.h`中声明该函数：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `len` function in `quat.cpp`. Don''t forget to add the function
    declaration to `quat.h`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`len`函数。不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Quaternions that represent a rotation should always have a length of *1*. In
    the next section, you will learn about unit quaternions, which always have a length
    of *1*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代表旋转的四元数应始终具有*1*的长度。在下一节中，您将了解始终具有*1*长度的单位四元数。
- en: Unit quaternions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四元数
- en: Quaternions can be normalized just like vectors. Normalized quaternions represent
    only a rotation and non-normalized quaternions introduce a skew. In the context
    of game animation, quaternions should be normalized to avoid adding a skew to
    the transform.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数可以像向量一样被归一化。归一化的四元数只代表旋转，而非归一化的四元数会引入扭曲。在游戏动画的背景下，应该对四元数进行归一化，以避免给变换添加扭曲。
- en: 'To normalize a quaternion, divide each component of the quaternion by its length.
    The resulting quaternion''s length will be *1*. This can be implemented as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要归一化一个四元数，将四元数的每个分量除以其长度。结果四元数的长度将为*1*。可以实现如下：
- en: 'Implement the `normalize` function in `quat.cpp` and declare it in `quat.h`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`normalize`函数，并在`quat.h`中声明它：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `normalized` function in `quat.cpp`, and declare it in `quat.h`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`normalized`函数，并在`quat.h`中声明它：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is a fast way of inverting any unit quaternion. In the next section, you
    will learn how to find the conjugate and inverse of a quaternion and their relationship
    when it comes to unit quaternions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种快速的方法可以求任意单位四元数的倒数。在下一节中，您将学习如何找到四元数的共轭和倒数，以及它们在单位四元数方面的关系。
- en: Conjugate and inverse
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共轭和逆
- en: Games mostly use normalized quaternions, which comes in handy when inverting
    quaternions. The inverse of a normalized quaternion is its conjugate. The conjugate
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏大多使用归一化的四元数，在反转四元数时非常方便。归一化四元数的逆是它的共轭。共轭
- en: 'of a quaternion flips its axis of rotation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数的翻转其旋转轴：
- en: 'Implement the `conjugate` function in `quat.cpp` and remember to declare the
    function in `quat.h`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`conjugate`函数，并记得在`quat.h`中声明该函数：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The proper inverse of a quaternion is the conjugate divided by the squared
    length of the quaternion. Implement the quaternion `inverse` function in `quat.cpp`.
    Add the function declaration to `quat.h`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四元数的逆是四元数的共轭除以四元数的平方长度。在`quat.cpp`中实现四元数`inverse`函数。将函数声明添加到`quat.h`中：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you need to find out whether a quaternion is normalized or not, check the
    squared length. The squared length of a normalized quaternion is always *1*. If
    a quaternion is normalized, its conjugate and inverse are the same. This means
    you can use the faster `conjugate` function, instead of the `inverse` function.
    In the next section, you will learn how to multiply two quaternions together.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要找出一个四元数是否已经归一化，可以检查平方长度。归一化四元数的平方长度始终为*1*。如果四元数已经归一化，其共轭和逆将是相同的。这意味着您可以使用更快的`conjugate`函数，而不是`inverse`函数。在下一节中，您将学习如何将两个四元数相乘。
- en: Multiplying quaternions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法四元数
- en: Two quaternions can be concatenated by multiplying them together. Like with
    matrices, the operation is carried out from right to left; the right quaternion's
    rotation is applied first and then the left quaternion's.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 两个四元数可以通过将它们相乘来连接。与矩阵类似，操作是从右到左进行的；首先应用右四元数的旋转，然后是左四元数的。
- en: 'Assume you have two quaternions, *q* and *p*. They are subscripted with `0`,
    `1`, `2`, and `3`, which correspond to the `X`, `Y`, `Z`, and `W` components,
    respectively. These quaternions can be expressed in *ijk* notation, as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个四元数*q*和*p*。它们带有`0`、`1`、`2`和`3`下标，分别对应`X`、`Y`、`Z`和`W`分量。这些四元数可以用*ijk*符号表示，如下所示：
- en: '![](img/Formula_04_008.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_008.png)'
- en: '![](img/Formula_04_009.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_009.png)'
- en: 'To multiply these two quaternions together, distribute the components of *p*
    to the components of *q*. Distributing the real component is simple. Distributing
    *p*3 to *q* would look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这两个四元数相乘，将*p*的各个分量分配给*q*的各个分量。分配实部很简单。将*p*3分配给*q*会是这样的：
- en: '![](img/Formula_04_010.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_010.png)'
- en: 'Distributing the imaginary components looks very similar. The real and imaginary
    parts are combined separately; the order of imaginary components matters. For
    example, distributing *p*o*i* to *q* would look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 分配虚部看起来非常相似。实部和虚部分别组合；虚部的顺序很重要。例如，将*p*o*i*分配给*q*会是这样的：
- en: '![](img/Formula_04_011.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_011.png)'
- en: 'Fully distributing *p* to *q* looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完全分配*p*给*q*看起来是这样的：
- en: '![](img/Formula_04_012.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_012.png)'
- en: '![](img/Formula_04_013.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_013.png)'
- en: '![](img/Formula_04_014.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_014.png)'
- en: '![](img/Formula_04_015.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_015.png)'
- en: 'Start simplifying for the case when imaginary numbers are squared. The square
    root of an imaginary number is *-1*. If you raise *-1* to the power of *-1*, the
    result is also *-1*. This means that any instance of *i*2, *j*2, or *k*2 can be
    replaced by *-1*, like so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 开始简化虚数平方的情况。虚数的平方根是*-1*。如果将*-1*提高到*-1*的幂，结果也是*-1*。这意味着任何* i*2*、*j*2*或*k*2*的实例都可以被替换为*-1*，如下所示：
- en: '![](img/Formula_04_016.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_016.png)'
- en: '![](img/Formula_04_017.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_017.png)'
- en: '![](img/Formula_04_018.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_018.png)'
- en: '![](img/Formula_04_019.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_019.png)'
- en: What about the rest of the imaginary numbers? When talking about quaternions,
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其他虚数呢？在谈论四元数时，
- en: '*ijk= -1*, the squared value of each of these components is also *-1*, which
    means that'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*ijk= -1*，每个分量的平方值也是*-1*，这意味着'
- en: '*i*2*= j*2*= k*2*=ijk*. This property of quaternions can be used to simplify
    the rest of the equation.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*i*2*= j*2*= k*2*=ijk*。四元数的这个性质可以用来简化方程的其余部分。'
- en: Take *jk*, for example. Start with *ijk= -1* and try to isolate *jk* to one
    side of the equation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以*jk*为例。从*ijk= -1*开始，尝试将*jk*隔离到方程的一边。
- en: To do this, multiply both sides by *i*, leaving you with *i(ijk)= -i*. Distribute
    *i*, which will leave you with *i*2 *jk= -i*. You already know that the value
    of *i*2 is *-1*. Substitute it to get
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，将两边都乘以*i*，得到*i(ijk)= -i*。分配*i*，得到*i*2 *jk= -i*。你已经知道*i*2的值是*-1*。将其代入得到
- en: '*-jk= -i*. Multiply both sides by *-1* and you have found the value of *jk—
    jk=i*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*-jk= -i*。两边都乘以*-1*，就找到了*jk*的值—*jk=i*。'
- en: 'The values for *ki* and *ij* can be found in a similar way; they are *ki=j*
    and *k=ij*. You can now substitute any instances of *ki* with *j*, *ij* with *k*,
    and *jk* with *i*. Substituting these values leaves you with the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以类似的方式找到*ki*和*ij*的值；它们分别是*ki=j*和*k=ij*。现在可以用*j*替换任何*ki*的实例，用*k*替换*ij*的实例，用*i*替换*jk*的实例。代入这些值后得到：
- en: '![](img/Formula_04_020.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_020.png)'
- en: '![](img/Formula_04_021.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_021.png)'
- en: '![](img/Formula_04_022.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_022.png)'
- en: '![](img/Formula_04_019.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_019.png)'
- en: 'The remaining imaginary numbers are *ik*, *ji*, and *kj*. Like the cross product,
    the order matters: *ik= -ki*. From this, you can assume that *ik= -j*, *ji= -k*,
    and *kj= -1*. Substituting these values leaves you with the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的虚数是*ik*、*ji*和*kj*。就像叉乘一样，顺序很重要：*ik= -ki*。由此可推断*ik= -j*，*ji= -k*，*kj= -1*。代入这些值后得到：
- en: '![](img/Formula_04_024.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_024.png)'
- en: '![](img/Formula_04_025.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_025.png)'
- en: '![](img/Formula_04_026.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_026.png)'
- en: '![](img/Formula_04_027.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_027.png)'
- en: 'Numbers with different imaginary components cannot be added together. Re-arrange
    the preceding formula so that like imaginary components are next to each other.
    This results in the final equation for quaternion multiplication:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同虚部的数字不能相加。重新排列前面的公式，使相似的虚部相邻。这导致四元数乘法的最终方程式：
- en: '![](img/Formula_04_028.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_028.png)'
- en: '![](img/Formula_04_029.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_029.png)'
- en: '![](img/Formula_04_030.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_030.png)'
- en: '![](img/Formula_04_031.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_031.png)'
- en: 'To implement this formula in code, change from this subscripted *ijk* notation
    back to vector notation with `X`, `Y`, `Z`, and `W` subscripts. Implement the
    quaternion multiplication function in `quat.cpp` and don''t forget to add the
    function declaration to `quat.h`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中实现这个公式，需要从下标化的*ijk*符号改回带有`X`、`Y`、`Z`和`W`下标的向量表示。在`quat.cpp`中实现四元数乘法函数，并不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When looking at the preceding code, notice that the real part of the quaternion
    has one positive component, but the vector part has one negative component. Re-arrange
    the quaternion so that the negative numbers are always last. Write it down using
    vector notation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的代码时，请注意四元数的实部有一个正分量，但向量部分有一个负分量。重新排列四元数，使负数始终在最后。使用向量表示写下来：
- en: '*qp*x*= p*x *q*w*+ p*w *q*x*+ p*y *q*z*- p*z *q*y'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*qp*x*= p*x *q*w*+ p*w *q*x*+ p*y *q*z*- p*z *q*y'
- en: '*qp*y= *p*y *q*w+ *p*w *q*y+ *p*z *q*x- *p*x *q*z'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*qp*y= *p*y *q*w+ *p*w *q*y+ *p*z *q*x- *p*x *q*z'
- en: '*qp*z= *p*z *q*w+ *p*w *q*z+ *p*x *q*y- *p*y *q*x'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*qp*z= *p*z *q*w+ *p*w *q*z+ *p*x *q*y- *p*y *q*x'
- en: '*qp*w= *p*w *q*w- *p*x *q*x- *p*y *q*y- *p*z *q*z'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*qp*w= *p*w *q*w- *p*x *q*x- *p*y *q*y- *p*z *q*z'
- en: There are two interesting parts in the preceding equation. If you look closely
    at the last two columns of the first three rows, the columns with the subtraction
    are the cross product. The first two columns are just scaling the vector parts
    of each quaternion by the scalar parts of the others.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述等式中有两个有趣的部分。如果你仔细观察前三行的最后两列，减法的列是叉乘。前两列只是通过其他四元数的标量部分来缩放每个四元数的向量部分。
- en: 'If you look at the last row, the dot product is in there with the negative
    of the dot product. The last row is basically multiplying the real parts of both
    quaternions, then subtracting the dot product of their vector parts. This means
    that an alternate multiplication implementation could look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看最后一行，点积和点积的负数都在其中。最后一行基本上是将两个四元数的实部相乘，然后减去它们的向量部分的点积。这意味着另一种乘法实现可能是这样的：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The original implementation is a bit more performant since it doesn't need to
    invoke other functions. The sample code for this book will use the first implementation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 原始实现稍微更高效，因为它不需要调用其他函数。本书的示例代码将使用第一种实现。
- en: Next, you will learn how to transform vectors by quaternions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何通过四元数来转换向量。
- en: Transforming vectors
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换向量
- en: 'To multiply a vector and a quaternion, you first have to turn the vector into
    a pure quaternion. What is a pure quaternion? It''s a quaternion whose `W` component
    is `0` and the vector part is normalized. Assume you have a quaternion, *q*, and
    a vector, *v*. First, turn *v* into a pure quaternion, represented as *v*'':'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要将向量和四元数相乘，首先必须将向量转换为纯四元数。什么是纯四元数？它是一个其`W`分量为`0`且向量部分被归一化的四元数。假设你有一个四元数*q*和一个向量*v*。首先，将*v*转换为纯四元数，表示为*v*'：
- en: '![](img/Formula_04_035.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_035.png)'
- en: '![](img/Formula_04_036.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_036.png)'
- en: 'Next, multiply *q* by *v*'' then multiply the result by the inverse of *q*.
    The result of this multiplication is a pure quaternion whose vector part contains
    the rotated vector. The quaternion becomes the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将*q*乘以*v*'，然后将结果乘以*q*的逆。这个乘法的结果是一个纯四元数，其向量部分包含了旋转后的向量。四元数变成了以下形式：
- en: '![](img/Formula_04_038.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_038.png)'
- en: Why is *v*' multiplied by *q* and then *q*-1? Multiplying by *q* will rotate
    the vector twice as much as the rotation of *q*. Multiplying by *q*-1 brings the
    vector back into the expected range. This formula can be simplified further.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么*v*'要先乘以*q*，然后再乘以*q*^-1？乘以*q*会使向量旋转的角度是*q*的两倍。乘以*q*^-1会将向量带回到预期的范围内。这个公式可以进一步简化。
- en: Deriving this formula is outside the scope of this book. Given a quaternion,
    *q*, and
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 推导这个公式超出了本书的范围。给定一个四元数*q*和
- en: a vector, *v*, the simplified vector quaternion multiplication formula is listed
    as follows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量*v*，简化的向量四元数乘法公式如下所示。
- en: '*q*v refers to the vector part of the quaternion and *q*s refers to the real
    (or scalar) part:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*q*v指的是四元数的向量部分，*q*s指的是实数（或标量）部分：'
- en: '![](img/Formula_04_042.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_042.png)'
- en: 'Implement the preceding formula for quaternion vector multiplication in `quat.cpp`.
    Don''t forget to add the function declaration to `quat.h`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现前述四元数向量乘法公式。不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Multiplying a vector by a quaternion will always yield a vector that is rotated
    by the quaternion. In the next section, you're going to learn about interpolating
    between quaternions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量乘以四元数总是会得到一个被四元数旋转的向量。在下一节中，你将学习如何在四元数之间进行插值。
- en: Interpolating quaternions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值四元数
- en: Quaternions can be interpolated in a similar fashion to vectors. Quaternion
    interpolation is used to animate rotation between two keyframes. Since most skeletal
    animation is achieved by rotating joints over time, interpolating between quaternions
    is going to be
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数可以以类似的方式进行插值，用于在两个关键帧之间旋转。由于大多数骨骼动画是通过随时间旋转关节来实现的，因此在四元数之间进行插值将是一个非常常见的操作。
- en: a very common operation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的操作。
- en: Neighborhood
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻域
- en: A quaternion represents a rotation, not an orientation. Rotating from one part
    of a sphere to another can be achieved by one of two rotations. The rotation can
    take the shortest or the longest arc. Generally, having quaternions travel along
    the shortest arc is desirable. When interpolating between two quaternions, which
    path will be taken—the shortest arc or the longest?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数代表的是旋转，而不是方向。从球的一部分旋转到另一部分可以通过两种旋转中的一种来实现。旋转可以采取最短或最长的弧。通常，使四元数沿着最短的弧旋转是可取的。在两个四元数之间进行插值时，将采取哪种路径——最短的弧还是最长的弧？
- en: This problem is called neighborhooding. To solve it, check the dot product of
    the quaternions being interpolated. If the dot product is positive, the shorter
    arc will be taken. If the dot product is negative, the longer arc will be taken.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题被称为邻域问题。要解决它，检查被插值的四元数的点积。如果点积是正的，将采取较短的弧。如果点积是负的，将采取较长的弧。
- en: 'If the dot product is negative, how can you correct the interpolation to take
    the shortest arc? The answer is to negate one of the quaternions. An example of
    quaternion neighborhooding is provided in the following code sample:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点积是负的，如何纠正插值以采取最短的弧？答案是对其中一个四元数取反。以下是四元数邻域化的一个示例代码：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You only need to neighborhood quaternions when interpolating between them. Next,
    you will learn how to mix linear interpolation (`lerp`), normalized linear interpolation
    (`nlerp`), and spherical linear interpolation (`slerp`) quaternions. Remember
    that these functions expect the quaternion to already be in its desired neighborhood.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在插值两个四元数时才需要邻域。接下来，你将学习如何混合线性插值（lerp）、归一化线性插值（nlerp）和球形线性插值（slerp）四元数。请记住，这些函数期望四元数已经处于所需的邻域内。
- en: Understanding the mix function
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解mix函数
- en: When mixing two or more quaternions together, each quaternion is scaled by some
    weight value, then the resulting scaled quaternions are added together. All the
    weights of all input quaternions must add up to *1*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合两个或多个四元数时，每个四元数都会被某个权重值缩放，然后将结果缩放的四元数相加。所有输入四元数的权重值必须加起来等于*1*。
- en: If all input quaternions are of unit length, the resulting quaternion will be
    of unit length as well. This function achieves the same result as `lerp` does,
    but it's not really a `lerp` function as the quaternion still travels on an arc.
    To avoid any confusion, this function will be called `mix`, not `lerp`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有输入四元数的长度都为单位长度，那么结果四元数也将是单位长度。这个函数实现了与`lerp`相同的结果，但它并不是真正的`lerp`函数，因为四元数仍然沿着弧线移动。为避免混淆，这个函数将被称为`mix`，而不是`lerp`。
- en: 'The `mix` function assumes that the input quaternions are in the desired neighborhood.
    Implement the `mix` function in `quat.cpp` and don''t forget to add the function
    declaration to `quat.h`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`mix`函数假设输入四元数在所需的邻域内。在`quat.cpp`中实现`mix`函数，并不要忘记将函数声明添加到`quat.h`中：'
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Understanding the nlerp function
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解nlerp函数
- en: '`nlerp` between quaternions is a fast and good approximation for spherical
    interpolation. Its implementation is almost the same as the `nlerp` implementation
    of the `vec3` class.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数之间的`nlerp`是球面插值的一种快速且良好的近似。它的实现几乎与`vec3`类的`nlerp`实现相同。
- en: 'Like `mix`, `nlerp` also assumes the input vectors are in the desired neighborhood.
    Implement the `nlerp` function in `quat.cpp` and don''t forget to add the function
    declaration to `quat.h`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 像`mix`一样，`nlerp`也假设输入向量在所需的邻域内。在`quat.cpp`中实现`nlerp`函数，并不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Introduction to slerp
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slerp简介
- en: '`slerp` should only be used if consistent velocity is required. In most cases,
    `nlerp` will be a better interpolation method. Depending on the interpolation
    step size, `slerp` may end up falling back to `nlerp` anyway.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要一致速度时才应该使用`slerp`。在大多数情况下，`nlerp`将是更好的插值方法。根据插值步长的不同，`slerp`最终可能会回退到`nlerp`。
- en: In order to spherically interpolate between two quaternions, create a delta
    quaternion between the two. Adjust the angle of the delta quaternion, then concatenate
    it with the starting quaternion using quaternion multiplication.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在两个四元数之间进行球面插值，创建两者之间的增量四元数。调整增量四元数的角度，然后使用四元数乘法将其与起始四元数连接起来。
- en: How can the angle of a quaternion be adjusted? To adjust the angle of a quaternion,
    raise it to the desired power. For example, to adjust the quaternion to only rotate
    halfway, you would raise it to the power of *0.5*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如何调整四元数的角度？要调整四元数的角度，将其提升到所需的幂。例如，要将四元数调整为只旋转一半，可以将其提升到*0.5*的幂。
- en: Power
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂
- en: 'To raise a quaternion to some power, it needs to be decomposed into an angle
    and an axis. Then, the angle can be adjusted by the power and a new quaternion
    can be built from the adjusted angle and axis. If a quaternion rotates around
    the *v* axis by an *θ* angle, raising it to some power, *t*, would be done as
    follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要将四元数提升到某个幂，需要将其分解为一个角度和一个轴。然后，可以通过幂和调整的角度构建一个新的四元数。如果一个四元数围绕*v*轴旋转*θ*角度，将其提升到某个幂*t*，可以按照以下方式进行：
- en: '![](img/Formula_04_044.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_044.png)'
- en: 'Implement the `power operator` in `quat.cpp`. Don''t forget to add the function
    declaration to `quat.h`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`power operator`。不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Implementing slerp
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现slerp
- en: Now that you know how to raise a quaternion to a power, implementing `slerp`
    becomes straightforward. If the start and end quaternions are very close together,
    `slerp` tends to produce unexpected results. If the start and end quaternions
    are close together, fall back on `nlerp`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何将四元数提升到幂，实现`slerp`就变得简单了。如果起始和结束四元数非常接近，`slerp`往往会产生意外的结果。如果起始和结束四元数接近，就回退到`nlerp`。
- en: To interpolate between two quaternions, find the delta quaternion from the start
    rotation to the end rotation. This delta quaternion is the interpolation path.
    Raise the angle to the power of how much the two quaternions are being interpolated
    between (usually represented as *t*) and multiply the start quaternion back.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个四元数之间进行插值，找到从起始旋转到结束旋转的增量四元数。这个增量四元数就是插值路径。将角度提升到两个四元数之间插值的幂（通常表示为*t*），然后将起始四元数相乘。
- en: 'Implement the `slerp` function in `quat.cpp`. Don''t forget to add the function
    declaration to `quat.h`. Like the other interpolation functions, `slerp` assumes
    that the quaternions being interpolated are in the desired neighborhoods:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`slerp`函数。不要忘记将函数声明添加到`quat.h`中。与其他插值函数一样，`slerp`假设被插值的四元数在所需的邻域内：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The input vectors to `slerp` should be normalized, which means you could use
    `conjugate` instead of `inverse` in the `slerp` function. Most of the time, `nlerp`
    will be used over `slerp`. In the next section, you will learn how to create a
    quaternion that points in a specific direction.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`slerp`的输入向量应该是归一化的，这意味着在`slerp`函数中可以使用`conjugate`而不是`inverse`。大多数情况下，`nlerp`将会被用于`slerp`。在下一节中，您将学习如何创建一个指向特定方向的四元数。'
- en: Look rotation
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察旋转
- en: Given a direction and a reference for which way is up, it's possible to create
    a quaternion that looks in that direction with the correct orientation. This function
    will be called `lookRotation`—not `lookAt`, to avoid any confusion with the matrix
    `lookAt` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个方向和一个指示向上方向的参考，可以创建一个朝向该方向并具有正确方向的四元数。这个函数将被称为`lookRotation`，而不是`lookAt`，以避免与矩阵`lookAt`函数混淆。
- en: To implement the `lookRotation` function, find a quaternion that rotates to
    the desired direction. To do this, create a quaternion between the world `forward`
    vector *(0, 0, 1)* and the `desired direction`. This quaternion will rotate to
    the `right` target, but with no regard for what direction `up` might be.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`lookRotation`函数，找到一个将旋转到所需方向的四元数。为此，创建一个世界`forward`向量*(0, 0, 1)*和`desired
    direction`之间的四元数。这个四元数将旋转到`right`目标，但不考虑`up`可能的方向。
- en: To correct the `up` direction of this quaternion, you first have to find a vector
    that is perpendicular to the current forward direction and the desired `up` direction.
    This can be done by taking the cross product of the two vectors.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要纠正这个四元数的`up`方向，首先必须找到一个垂直于当前前向方向和期望的`up`方向的向量。这可以通过这两个向量的叉积来实现。
- en: The result of this cross product will be used to construct three orthogonal
    vectors—the forward vector, this new vector, and a vector that points up. The
    one you just found would point to the right.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个叉积的结果将用于构造三个正交向量——前向向量、这个新向量和一个指向上的向量。你刚刚找到的将指向右边。
- en: Next, you need to find a vector that is perpendicular to both the `forward`
    and `right` directions; this will be the orthonormal `up` vector. To find this
    vector, take the cross product of the direction and this `right` vector and the
    result is the object space `up` vector.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要找到一个既垂直于`forward`又垂直于`right`方向的向量；这将是正交的`up`向量。要找到这个向量，可以取方向和这个`right`向量的叉积，结果就是物体空间的`up`向量。
- en: Find a quaternion that rotates from the desired `up` vector to the object `up`
    vector. Multiply the quaternion that rotates to the target direction and the quaternion
    that rotates from `desired up` to `object up`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个从期望的`up`向量旋转到物体`up`向量的四元数。将旋转到目标方向的四元数和从`desired up`到`object up`的四元数相乘。
- en: 'Implement the `lookRotation` function in `quat.cpp`. Don''t forget to add the
    function declaration to `quat.h`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`lookRotation`函数。不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The matrix `lookAt` function creates a view matrix, which is the inverse of
    the camera transform. This means the rotation of `lookAt` and the result of `lookRotation`
    are going to be the inverse of each other. In the next section, you will learn
    how to convert matrices to quaternions and quaternions to matrices.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵`lookAt`函数创建一个视图矩阵，这是相机变换的逆。这意味着`lookAt`的旋转和`lookRotation`的结果将互为逆运算。在下一节中，您将学习如何将矩阵转换为四元数，以及四元数转换为矩阵。
- en: Converting between quaternions and matrices
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在矩阵和四元数之间进行转换
- en: Since both matrices and quaternions can be used to encode rotation data, it
    will be useful to be able to convert between them. To make converting between
    the two easier, you have to start thinking about rotation in terms of basis vectors,
    which are the vectors that represent the *x*, *y*, and *z* axes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于矩阵和四元数都可以用于编码旋转数据，因此能够在它们之间进行转换将非常有用。为了使在两者之间进行转换更容易，您必须开始考虑基向量的旋转，这些向量代表了*x*、*y*和*z*轴。
- en: The upper 3 x 3 sub-matrix of a 4 x 4 matrix contains three basis vectors. The
    first column is the `right` vector, the second is the `up` vector, and the third
    is the `forward` vector. Using only the `forward` and `up` vectors, the `lookRotation`
    function can be used to convert a matrix into a quaternion.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 4x4矩阵的上3x3子矩阵包含三个基向量。第一列是`right`向量，第二列是`up`向量，第三列是`forward`向量。只使用`forward`和`up`向量，`lookRotation`函数可以将矩阵转换为四元数。
- en: 'To convert a quaternion into a matrix, simply multiply the world basis vectors,
    which are the *x*, *y*, and *z* axes of the world, by the quaternion. Store the
    resulting vectors in the appropriate components of the matrix:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要将四元数转换为矩阵，只需将世界基向量（世界的*x*、*y*和*z*轴）乘以四元数。将结果向量存储在矩阵的相应分量中：
- en: 'Implement the `quatToMat4` function in `quat.cpp`. Don''t forget to add the
    function declaration to `quat.h`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`quat.cpp`中实现`quatToMat4`函数。不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A matrix stores both rotation and scale data using some of the same components.
    To address this, the basis vectors need to be normalized and the cross product
    needs to be used to make sure that the resulting vectors are orthogonal. Implement
    the `mat4ToQuat` function in `quat.cpp` and don''t forget to add the function
    declaration to `quat.h`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵使用相同的组件存储旋转和缩放数据。为了解决这个问题，基向量需要被归一化，并且需要使用叉积来确保结果向量是正交的。在`quat.cpp`中实现`mat4ToQuat`函数，不要忘记将函数声明添加到`quat.h`中：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Being able to convert quaternions to matrices will be useful later when you
    need to pass rotation data to a shader. Shaders don't know what a quaternion is,
    but they have built-in functionality to deal with matrices. Converting matrices
    to quaternions is going to be useful for debugging and in the case where an external
    data source only provides rotations as matrices.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将四元数转换为矩阵将在以后需要将旋转数据传递给着色器时非常有用。着色器不知道四元数是什么，但它们内置了处理矩阵的功能。将矩阵转换为四元数对于调试和在外部数据源只提供矩阵旋转的情况下也将非常有用。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you implemented a robust quaternion library. Quaternions are
    important to the rest of this book as all animated rotation data is recorded as
    quaternions. You learned how to create quaternions and common quaternion operations,
    combine quaternions with multiplication, transform vectors by quaternions, interpolate
    quaternions and utility functions to create quaternions given a forward and up
    direction, and convert between matrices and quaternions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您实现了一个强大的四元数库。四元数对本书的其余部分非常重要，因为所有动画旋转数据都记录为四元数。您学会了如何创建四元数和常见的四元数操作，通过乘法组合四元数，通过四元数转换向量，插值四元数和实用函数来创建四元数，给定前向和上方向，并在矩阵和四元数之间进行转换。
- en: In the next chapter, you will use your combined knowledge of vectors, matrices,
    and quaternions to define a transformation object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将使用向量、矩阵和四元数的综合知识来定义一个变换对象。
