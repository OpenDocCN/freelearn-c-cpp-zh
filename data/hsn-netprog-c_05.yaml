- en: Establishing UDP Connections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立UDP连接
- en: In this chapter, we will look at how to send and receive **User Datagram Protocol** (**UDP**)
    packets. UDP socket programming is very similar to **Transmission Control Protocol** (**TCP**)
    socket programming, so it is recommended that you read and understand [Chapter
    3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An In-Depth Overview of TCP Connections*,
    before beginning this one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何发送和接收**用户数据报协议**（**UDP**）数据包。UDP套接字编程与**传输控制协议**（**TCP**）套接字编程非常相似，因此建议你在开始本章之前阅读并理解[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，“TCP连接的深入概述”。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The differences between TCP socket programming and UDP socket programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP套接字编程与UDP套接字编程之间的区别
- en: The `sendto()` and `recvfrom()` functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendto()`和`recvfrom()`函数'
- en: How `connect()` works on a UDP socket
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`在UDP套接字上的工作方式'
- en: Implementing a UDP server using only one socket
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用一个套接字实现UDP服务器
- en: Using `select()` to tell when a UDP socket has data ready
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`select()`来告知何时UDP套接字有数据准备好
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs in this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler On Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler On Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler On macOS*, for compiler setup.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以用任何现代C编译器编译。我们推荐在Windows上使用MinGW，在Linux和macOS上使用GCC。有关编译器的设置，请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，“在Windows上设置您的C编译器”，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，“在Linux上设置您的C编译器”，和[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，“在macOS上设置您的C编译器”。
- en: The code for this book can be found in this book's GitHub repository: [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在本书的GitHub仓库中找到：[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令从命令行下载本章的代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. While
    compiling on Windows, each example program requires being linked with the Winsock
    library. This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要与Winsock库链接。这可以通过将`-lws2_32`选项传递给`gcc`来实现。
- en: We provide the exact commands that are needed to compile each example as they
    are introduced.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在介绍每个示例时都提供了编译每个示例所需的精确命令。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap04.h`, which we can include in each program. For an
    explanation of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有示例程序都需要与我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握Socket
    API”中开发的相同头文件和C宏。为了简洁，我们将这些语句放在一个单独的头文件`chap04.h`中，我们可以在每个程序中包含它。有关这些语句的解释，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握Socket
    API”。
- en: 'The content of `chap04.h` is shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap04.h`的内容如下所示：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How UDP sockets differ
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP套接字的区别
- en: 'The socket API for UDP sockets is only very slightly different than what we''ve
    already learned for TCP. In fact, they are similar enough that we can take the
    TCP client from the last chapter and turn it into a fully functional UDP client
    by changing only one line of code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: UDP套接字的socket API与我们之前学习的TCP套接字API只有非常细微的差别。实际上，它们足够相似，以至于我们可以将上一章的TCP客户端代码仅通过更改一行代码就转换成一个完全功能的UDP客户端：
- en: 'Take `tcp_client.c` from [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An
    In-Depth Overview of TCP Connections*, and find the following line of code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，“TCP连接的深入概述”中获取`tcp_client.c`，并找到以下代码行：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Change the preceding code to the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的代码更改为以下内容：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This modification is included in this chapter's code as `udp_client.c`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改包含在本章的代码中，作为`udp_client.c`。
- en: You can recompile the program using the same commands as before, and you'll
    get a fully functional UDP client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用之前相同的命令重新编译程序，你将得到一个完全功能的UDP客户端。
- en: Unfortunately, changing the TCP servers of the previous chapters to UDP won't
    be as easy. TCP and UDP server code are different enough that a slightly different
    approach is needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将上一章的TCP服务器更改为UDP不会那么容易。TCP和UDP服务器代码的差异足够大，需要稍微不同的方法。
- en: Also, don't assume that because we had to change only one line of the code that
    the client behaves exactly the same way – this won't happen. The two programs
    are using a different protocol, after all.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要假设我们只更改了一行代码，客户端的行为就完全相同——这种情况不会发生。毕竟，这两个程序使用的是不同的协议。
- en: Remember from [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting
    to Grips with Socket APIs* that UDP does not try to be a reliable protocol. Lost
    packets are not automatically re-transmitted, and packets may be received in a
    different order than they were sent. It is even possible for one packet to erroneously
    arrive twice! TCP attempts to solve all these problems, but UDP leaves you to
    your own devices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*，UDP并不试图成为一个可靠的协议。丢失的数据包不会自动重传，数据包可能以与发送时不同的顺序接收。甚至可能有一个数据包错误地到达两次！TCP试图解决所有这些问题，但UDP让你自己解决问题。
- en: Do you know what the best thing about a UDP joke is? I don't care if you get
    it or not.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道UDP笑话最好的地方是什么吗？我不在乎你是否能理解它。
- en: Despite UDP's (lack of) reliability, it is still appropriate for many applications.
    Let's look at the methods that are used by UDP clients and servers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UDP（缺乏）可靠性，但它仍然适用于许多应用。让我们看看UDP客户端和服务器使用的方法。
- en: UDP client methods
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP客户端方法
- en: 'Sending data with TCP requires calling `connect()` to set the remote address
    and establish the TCP connection. Thus, we use `send()` with TCP sockets, as shown
    in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TCP发送数据需要调用`connect()`来设置远程地址并建立TCP连接。因此，我们使用TCP套接字上的`send()`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'UDP is a connectionless protocol. Therefore, no connection is established before
    sending data. A UDP connection is never established. With UDP, data is simply
    sent and received. We can call `connect()` and then `send()`, as we mentioned
    previously, but the socket API provides an easier way for UDP sockets in the form
    of the `sendto()` function. It works like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: UDP是一个无连接协议。因此，在发送数据之前不会建立任何连接。UDP连接永远不会建立。在UDP中，数据只是发送和接收。我们可以调用`connect()`然后`send()`，就像我们之前提到的，但套接字API为UDP套接字提供了一个更简单的方式，即`sendto()`函数。它的工作方式如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`connect()` on a UDP socket works a bit differently. All `connect()` does with
    a UDP socket is associate a remote address. Thus, while `connect()` on a TCP socket
    involves a handshake for sending packets over the network, `connect()` on a UDP
    socket only stores an address locally.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在UDP套接字上，`connect()`的工作方式略有不同。对于UDP套接字，`connect()`所做的只是关联一个远程地址。因此，虽然TCP套接字上的`connect()`涉及在网络发送数据包时的握手，但UDP套接字上的`connect()`只会在本地存储一个地址。
- en: So, a UDP client can be structured in two different ways, depending on whether
    you use `connect()`, `send()`, and `recv()`, or instead use `sendto()` and `recvfrom()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，UDP客户端可以根据是否使用`connect()`、`send()`和`recv()`，或者使用`sendto()`和`recvfrom()`来以两种不同的方式构建。
- en: 'The following diagram compares the program flow of a **TCP Client** to a **UDP
    Client** using either method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表比较了使用两种方法时**TCP客户端**和**UDP客户端**的程序流程：
- en: '![](img/b64a2d6f-8113-4081-aeb6-3cb9d97f00fb.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b64a2d6f-8113-4081-aeb6-3cb9d97f00fb.png)'
- en: Note that, while using `connect()`, the **UDP Client** only receives data from
    the peer having the IP address and the port that is given to `connect()`. However,
    when not using `connect()`, the `recvfrom()` function returns data from any peer
    that addresses us! Of course, that peer would need to know our address and port.
    Unless we call `bind()`, our local address and port is assigned automatically
    by the operating system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`connect()`时，**UDP客户端**只接收来自具有给定IP地址和端口的对等方的数据。然而，当不使用`connect()`时，`recvfrom()`函数会从任何向我们发送地址的数据对等方返回数据！当然，那个对等方需要知道我们的地址和端口。除非我们调用`bind()`，否则操作系统会自动分配我们的本地地址和端口。
- en: UDP server methods
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP服务器方法
- en: Programming a UDP server is a bit different than TCP. TCP requires managing
    a socket for each peer connection. With UDP, our program only needs one socket.
    That one socket can communicate with any number of peers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编程UDP服务器与TCP略有不同。TCP需要为每个对等连接管理一个套接字。对于UDP，我们的程序只需要一个套接字。这个套接字可以与任何数量的对等方通信。
- en: While the TCP program flow required us to use `listen()` and `accept()` to wait
    for and establish new connections, these functions are not used with UDP. Our
    UDP server simply binds to the local address, and then it can immediately start
    sending and receiving data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TCP程序流程需要我们使用`listen()`和`accept()`来等待和建立新的连接，但这些函数在UDP中并不使用。我们的UDP服务器只需绑定到本地地址，然后就可以立即开始发送和接收数据。
- en: 'The program flow of a **TCP Server** compared to a **UDP Server** is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与**UDP服务器**相比，**TCP服务器**的程序流程如下：
- en: '![](img/f6d79306-4799-4b68-9904-dcedf358b4c3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6d79306-4799-4b68-9904-dcedf358b4c3.png)'
- en: With either a TCP or UDP server, we use `select()` when we need to check/wait
    for incoming data. The difference is that a **TCP Server** using `select()` is
    likely monitoring many separate sockets, while a **UDP Server** often only needs
    to monitor one socket. If your program uses both TCP and UDP sockets, you can
    monitor them all with only one call to `select()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用TCP还是UDP服务器，当需要检查/等待传入数据时，我们都会使用`select()`。区别在于使用`select()`的**TCP服务器**可能正在监控多个独立的套接字，而**UDP服务器**通常只需要监控一个套接字。如果你的程序同时使用TCP和UDP套接字，你只需调用一次`select()`就可以监控它们所有。
- en: A first UDP client/server
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个UDP客户端/服务器
- en: To drive these points home, it will be useful to work through a full UDP client
    and UDP server program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些要点更加清晰，通过一个完整的UDP客户端和UDP服务器程序来实践将是有用的。
- en: To keep things simple, we will create a UDP client program that simply sends
    the `Hello World` string to `127.0.0.1` on port `8080`. Our UDP server listens
    on `8080`. It prints any data it receives, along with the sender's address and
    port number.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将创建一个UDP客户端程序，该程序简单地发送`Hello World`字符串到`127.0.0.1`的`8080`端口。我们的UDP服务器监听在`8080`。它打印接收到的任何数据，以及发送者的地址和端口号。
- en: We will begin by implementing the simple UDP server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现这个简单的UDP服务器。
- en: A simple UDP server
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的UDP服务器
- en: We will start with the server, since we already have a usable UDP client, that
    is, `udp_client.c`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从服务器开始，因为我们已经有一个可用的UDP客户端，即`udp_client.c`。
- en: 'Like all of our networked programs, we will begin by including the necessary
    headers, starting with the `main()` function, and initializing Winsock as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所有的网络程序一样，我们将从包含必要的头文件开始，从`main()`函数开始，并初始化Winsock，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you've been working through this book in order, this code should be very
    routine for you by now. If you haven't, then please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照顺序阅读这本书，现在这段代码应该对你来说非常熟悉。如果没有，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*。
- en: 'Then, we must configure the local address that our server listens on. We use
    `getaddrinfo()` for this, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须配置服务器监听的本地地址。我们使用`getaddrinfo()`来完成此操作，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This differs only slightly from how we've done it before. Notably, we set `hints.ai_socktype
    = SOCK_DGRAM`. Recall that `SOCK_STREAM` was used there for TCP connections. We
    are still setting `hints.ai_family = AF_INET` here. This makes our server listen
    for IPv4 connections. We could change that to `AF_INET6` to make our server listen
    for IPv6 connections instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的方法略有不同。值得注意的是，我们设置了`hints.ai_socktype = SOCK_DGRAM`。回想一下，那里使用`SOCK_STREAM`进行TCP连接。我们在这里仍然设置`hints.ai_family
    = AF_INET`。这使得我们的服务器监听IPv4连接。我们可以将其更改为`AF_INET6`，使服务器监听IPv6连接。
- en: 'After we have our local address information, we can create the socket, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了本地地址信息之后，我们可以创建套接字，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is exactly the same as in the TCP case. The call to `socket()` uses
    our address information from `getaddrinfo()` to create the proper type of socket.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与TCP的情况完全相同。`socket()`调用使用从`getaddrinfo()`获取的地址信息来创建适当的套接字类型。
- en: 'We must then bind the new socket to the local address that we got from `getaddrinfo()`.
    This is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将新套接字绑定到从`getaddrinfo()`获取的本地地址。如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, that code is exactly the same as in the TCP case.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这段代码与TCP的情况完全相同。
- en: 'Here is where the UDP server diverges from the TCP server. Once the local address
    is bound, we can simply start to receive data. There is no need to call `listen()`
    or `accept()`. We listen for incoming data using `recvfrom()`, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是UDP服务器与TCP服务器不同的地方。一旦本地地址绑定，我们就可以简单地开始接收数据。不需要调用`listen()`或`accept()`。我们使用`recvfrom()`来监听传入的数据，如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code, we created a `struct sockaddr_storage` to store the client's
    address. We also defined `socklen_t client_len` to hold the address size. This
    keeps our code robust in the case that we change it from IPv4 to IPv6\. Finally,
    we created a buffer, `char read[1024]`, to store incoming data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 `struct sockaddr_storage` 来存储客户端的地址。我们还定义了 `socklen_t client_len`
    来保存地址的大小。这使我们的代码在从 IPv4 更改为 IPv6 时更加健壮。最后，我们创建了一个缓冲区 `char read[1024]` 来存储传入的数据。
- en: '`recvfrom()` is used in a similar manner to `recv()`, except that it returns
    the sender''s address, as well as the received data. You can think of `recvfrom()` as
    a combination of the TCP server `accept()` and `recv()`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`recvfrom()` 的使用方式与 `recv()` 类似，但它除了返回接收到的数据外，还会返回发送者的地址。你可以将 `recvfrom()`
    视为 TCP 服务器 `accept()` 和 `recv()` 的组合。'
- en: 'Once we''ve received data, we can print it out. Keep in mind that the data
    may not be null terminated. It can be safely printed with the `%.*s` `printf()`
    format specifier, as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们接收到了数据，我们就可以将其打印出来。请注意，数据可能不是以空字符终止的。可以使用 `%.*s` 的 `printf()` 格式说明符安全地打印数据，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It may also be useful to print the sender''s address and port number. We can
    use the `getnameinfo()` function to convert this data into a printable string,
    as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打印发送者的地址和端口号可能也有用。我们可以使用 `getnameinfo()` 函数将此数据转换为可打印的字符串，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last argument to `getnameinfo()` (`NI_NUMERICHOST | NI_NUMERICSERV`) tells
    `getnameinfo()` that we want both the client address and port number to be in
    numeric form. Without this, it would attempt to return a hostname or protocol
    name if the port number matches a known protocol. If you do want a protocol name,
    pass in the `NI_DGRAM` flag to tell `getnameinfo()` that you're working on a UDP
    port. This is important for the few protocols that have different ports for TCP
    and UDP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`getnameinfo()` 的最后一个参数 (`NI_NUMERICHOST | NI_NUMERICSERV`) 告诉 `getnameinfo()`
    我们希望客户端地址和端口号都采用数字形式。如果没有这个参数，它会尝试返回一个主机名或协议名，如果端口号与已知协议匹配。如果你确实需要一个协议名，可以通过传递
    `NI_DGRAM` 标志来告诉 `getnameinfo()` 你正在处理一个 UDP 端口。这对于那些 TCP 和 UDP 使用不同端口的少数协议来说非常重要。'
- en: It's also worth noting that the client will rarely set its local port number
    explicitly. So, the port number returned here by `getnameinfo()` is likely to
    be a high number that's chosen randomly by the client's operating system. Even
    if the client did set its local port number, the port number we can see here might
    have been changed by **network address translation** (**NAT**).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，客户端很少会显式设置其本地端口号。因此，`getnameinfo()` 返回的端口号很可能是客户端操作系统随机选择的一个高数字。即使客户端设置了本地端口号，我们在这里看到的端口号也可能已经被网络地址转换（NAT）所更改。
- en: In any case, if our server were to send data back, it would need to send it
    to the address and port stored in `client_address`. This would be done by passing
    `client_address` to `sendto()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果我们的服务器需要发送数据回客户端，它需要将数据发送到存储在 `client_address` 中的地址和端口。这可以通过将 `client_address`
    传递给 `sendto()` 来完成。
- en: 'Once the data has been received, we''ll end our simple UDP server by closing
    the connection, cleaning up Winsock, and ending the program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被接收，我们将通过关闭连接、清理 Winsock 和结束程序来结束我们的简单 UDP 服务器：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can compile and run `udp_recvfrom.c` on Linux and macOS by using the following
    commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在 Linux 和 macOS 上编译和运行 `udp_recvfrom.c`：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compiling and running on Windows with MinGW is done as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MinGW 在 Windows 上编译和运行的操作如下：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While running, it simply waits for an incoming connection:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，它只是等待传入的连接：
- en: '![](img/92c1a4aa-591b-49a4-8a8c-44ed3b83445e.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92c1a4aa-591b-49a4-8a8c-44ed3b83445e.png)'
- en: You could use `udp_client` to connect to `udp_recvfrom` for testing, or you
    can implement `udp_sendto`, which we will do next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `udp_client` 连接到 `udp_recvfrom` 进行测试，或者你可以实现 `udp_sendto`，这是我们接下来要做的。
- en: A simple UDP client
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 UDP 客户端
- en: Although we've already shown a fairly full-featured UDP client, `udp_client.c`,
    it is worthwhile building a very simple UDP client. This client shows only the
    minimal required steps to get a working UDP client, and it uses `sendto()` instead
    of `send()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经展示了一个功能较为齐全的 UDP 客户端 `udp_client.c`，但构建一个非常简单的 UDP 客户端也是值得的。这个客户端仅展示了获取一个可工作的
    UDP 客户端所需的最小步骤，并且它使用 `sendto()` 而不是 `send()`。
- en: 'Let''s begin the same way we begin each program, by including the necessary
    headers, starting `main()`, and initializing Winsock, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以开始每个程序相同的方式开始，通过包含必要的头文件，开始 `main()`，并初始化 Winsock，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We then configure the remote address using `getaddrinfo()`. In this minimal
    example, we use `127.0.0.1` as the remote address and `8080` as the remote port.
    This means that it connects to the UDP server only if it's running on the same
    computer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 `getaddrinfo()` 配置远程地址。在这个最小示例中，我们使用 `127.0.0.1` 作为远程地址，`8080` 作为远程端口。这意味着它仅在服务器运行在同一台计算机上时才会连接到
    UDP 服务器。
- en: 'Here is how the remote address is configured:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何配置远程地址的：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we hardcoded `127.0.0.1` and `8080` into the call to `getaddrinfo()`.
    Also, notice that we've set `hints.ai_socktype = SOCK_DGRAM`. This tells `getaddrinfo()`
    that we are connecting over UDP. Notice that we did not set `AF_INET` or `AF_INET6`.
    This allows `getaddrinfo()` to return the appropriate address for IPv4 or IPv6\.
    In this case, it is IPv4 because the address, `127.0.0.1`, is an IPv4 address.
    We will cover `getaddrinfo()` in more detail in [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml),
    *Hostname Resolution and DNS*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `getaddrinfo()` 的调用中硬编码了 `127.0.0.1` 和 `8080`。另外，注意我们已将 `hints.ai_socktype
    = SOCK_DGRAM` 设置。这告诉 `getaddrinfo()` 我们正在通过 UDP 连接。注意我们没有设置 `AF_INET` 或 `AF_INET6`。这允许
    `getaddrinfo()` 返回 IPv4 或 IPv6 的适当地址。在这种情况下，它是 IPv4，因为地址 `127.0.0.1` 是一个 IPv4
    地址。我们将在第 5 章[3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml]中更详细地介绍 `getaddrinfo()`，*主机名解析和
    DNS*。
- en: 'We can print the configured address using `getnameinfo()`. The call to `getnameinfo()`
    is the same as in the previous UDP server, `udp_recvfrom.c`. It works as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `getnameinfo()` 打印配置的地址。`getnameinfo()` 的调用与之前的 UDP 服务器 `udp_recvfrom.c`
    中的调用相同。它的工作方式如下：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we''ve stored the remote address, we are ready to create our socket
    with a call to `socket()`. We pass in fields from `peer_address` to create the
    appropriate socket type. The code for this is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经存储了远程地址，我们就可以通过调用 `socket()` 创建我们的套接字了。我们通过 `peer_address` 中的字段来创建适当的套接字类型。相应的代码如下：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the socket has been created, we can go straight to sending data with `sendto()`.
    There is no need to call `connect()`. Here is the code to send `Hello World` to
    our UDP server:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建套接字，我们就可以直接使用 `sendto()` 发送数据。不需要调用 `connect()`。以下是向我们的 UDP 服务器发送 `Hello
    World` 的代码：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that `sendto()` is much like `send()`, except that we need to pass in
    an address as the last parameter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sendto()` 与 `send()` 非常相似，除了我们需要将地址作为最后一个参数传递。
- en: It is also worth noting that we do not get an error back if sending fails. `send()` simply
    tries to send a message, but if it gets lost or is misdelivered along the way,
    there is nothing we can do about it. If the message is important, it is up to
    the application protocol to implement the corrective action.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果发送失败，我们不会收到错误。`send()` 只是尝试发送消息，但如果它在途中丢失或误递送，我们无能为力。如果消息很重要，那么实现纠正措施的责任就落在应用协议上。
- en: After we've sent our data, we could reuse the same socket to send data to another
    address (as long as it's the same type of address, which is IPv4 in this case).
    We could also try to receive a reply from the UDP server by calling `recvfrom()`.
    Note that if we did call `recvfrom()` here, we could get data from anybody that
    sends to us – not necessarily the server we just transmitted to.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发送数据后，我们可以重用相同的套接字向另一个地址发送数据（只要它是同一类型的地址，在这个例子中是 IPv4）。我们也可以尝试通过调用 `recvfrom()`
    从 UDP 服务器接收回复。注意，如果我们在这里调用 `recvfrom()`，我们可能会从任何向我们发送数据的人那里获取数据——并不一定是我们刚刚传输到的服务器。
- en: When we sent our data, our socket was assigned with a temporary local port number
    by the operating system. This local port number is called the **ephemeral port
    number**. From then on, our socket is essentially listening for a reply on this
    local port. If the local port is important, you can use `bind()` to associate
    a specific port before calling `send()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送数据时，操作系统会分配一个临时的本地端口号给我们的套接字。这个本地端口号被称为 **临时端口号**。从那时起，我们的套接字基本上是在这个本地端口上监听回复。如果本地端口很重要，你可以在调用
    `send()` 之前使用 `bind()` 将特定端口关联起来。
- en: If multiple applications on the same system are connecting to a remote server
    at the same port, the operating system uses the local ephemeral port number to
    keep replies separate. Without this, it wouldn't be possible to know which application
    should receive which reply.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一系统上的多个应用程序正在同一端口连接到远程服务器，操作系统将使用本地临时端口号来保持回复的分离。没有这个，我们就无法知道哪个应用程序应该接收哪个回复。
- en: 'We''ll end our example program by freeing the memory for `peer_address`, closing
    the socket, cleaning up Winsock, and finishing `main()`, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过释放 `peer_address` 的内存、关闭套接字、清理 Winsock 和完成 `main()` 来结束我们的示例程序，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can compile `udp_sendto.c` on Linux and macOS using the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在 Linux 和 macOS 上编译 `udp_sendto.c`：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compiling on Windows with MinGW is done in the following way:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MinGW 在 Windows 上编译的方式如下：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To test it out, first, start `udp_recvfrom` in a separate terminal. With `udp_recvfrom`
    already running, you can start `udp_sendto`. It should look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，首先，在一个单独的终端中启动 `udp_recvfrom`。在 `udp_recvfrom` 已经运行的情况下，您可以启动 `udp_sendto`。它应该看起来如下：
- en: '![](img/27489ad6-d9bb-40ce-9b90-c0c3019a6af7.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27489ad6-d9bb-40ce-9b90-c0c3019a6af7.png)'
- en: If no server is running on port `8080`, `udp_sendto` still produces the same
    output. `udp_sendto` doesn't know that the packet was not delivered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口 `8080` 上没有运行服务器，`udp_sendto` 仍然会产生相同的输出。`udp_sendto` 并不知道数据包没有被送达。
- en: A UDP server
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 UDP 服务器
- en: It will be useful to look at a UDP server that's been designed to service many
    connections. Fortunately for us, the UDP socket API makes this very easy.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 研究一个设计用来服务多个连接的 UDP 服务器将是有用的。幸运的是，UDP 套接字 API 使这变得非常简单。
- en: We will take the motivating example from our last chapter, which was to provide
    a service that converts all text into uppercase. This is useful because you can
    directly compare the UDP code from here to the TCP server code from [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前一章的激励示例开始，即提供一个将所有文本转换为上档的服务。这很有用，因为您可以直接比较这里的 UDP 代码和第 3 章中的 TCP 服务器代码。
- en: Our server begins by setting up the socket and binding to our local address.
    It then waits to receive data. Once it has received a data string, it converts
    the string into all uppercase and sends it back.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器首先设置套接字并将其绑定到本地地址。然后它等待接收数据。一旦它接收到了一个数据字符串，它将字符串转换成全部大写并发送回去。
- en: 'The program flow looks as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 程序流程如下：
- en: '![](img/93ab4ec5-3ed5-4a9a-9cbc-75df89e33326.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93ab4ec5-3ed5-4a9a-9cbc-75df89e33326.png)'
- en: If you compare the flow of this program to the TCP server from the last chapter
    ([Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An In-Depth Overview
    of TCP Connections*), you will find that it's much simpler. With TCP, we had to
    use `listen()` and `accept()`. With UDP, we skip those calls and go straight into
    receiving data with `recvfrom()`. With our TCP server, we had to monitor a listening
    socket for new connections while simultaneously monitoring an additional socket
    for each connected client. Our UDP server only uses one socket, so there is much
    less to keep track of.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将这个程序的流程与上一章的 TCP 服务器进行比较（[第 3 章](https://cdp.packtpub.com/hands_on_network_programming_with_c/wp-admin/post.php?post=27&action=edit#post_26)，*TCP
    连接的深入概述*），您会发现它要简单得多。在 TCP 中，我们必须使用 `listen()` 和 `accept()`。在 UDP 中，我们跳过这些调用，直接使用
    `recvfrom()` 接收数据。在我们的 TCP 服务器中，我们必须同时监控一个监听套接字以寻找新的连接，并监控每个已连接客户端的额外套接字。我们的 UDP
    服务器只使用一个套接字，因此需要跟踪的内容要少得多。
- en: 'Our UDP server program begins by including the necessary headers, starting
    the `main()` function, and initializing Winsock, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 UDP 服务器程序首先包括必要的头文件，启动 `main()` 函数，并初始化 Winsock，如下所示：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We then find our local address that we should listen on, create the socket,
    and bind to it. This is all exactly the same as in our earlier server, `udp_recvfrom.c`.
    The only difference between this code and the TCP servers in [Chapter 3](https://cdp.packtpub.com/hands_on_network_programming_with_c/wp-admin/post.php?post=27&action=edit#post_26), *An
    In-Depth Overview of TCP Connections*, is that we use `SOCK_DGRAM` instead of
    `SOCK_STREAM`. Recall that `SOCK_DGRAM` specifies that we want a UDP socket.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们找到我们应该监听的本地地址，创建套接字，并将其绑定。这和我们在之前的服务器 `udp_recvfrom.c` 中的操作完全一样。这段代码和第 3
    章中的 TCP 服务器代码的唯一区别是，我们使用 `SOCK_DGRAM` 而不是 `SOCK_STREAM`。回想一下，`SOCK_DGRAM` 指定了我们想要一个
    UDP 套接字。
- en: 'Here is the code for setting the address and creating a new socket:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置地址和创建新套接字的代码：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Binding the new socket to the local address is done as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的套接字绑定到本地地址的方式如下：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because our server uses `select()`, we need to create a new `fd_set` to store
    our listening socket. We zero the set using `FD_ZERO()`, and then add our socket
    to this set using `FD_SET()`. We also maintain the maximum socket in the set using
    `max_socket`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务器使用 `select()`，我们需要创建一个新的 `fd_set` 来存储我们的监听套接字。我们使用 `FD_ZERO()` 将集合清零，然后使用
    `FD_SET()` 将我们的套接字添加到这个集合中。我们还使用 `max_socket` 维护集合中的最大套接字：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we don't really have to use `select()` for this program, and omitting
    it would make the program simpler (see `udp_server_toupper_simple.c`). However,
    we are going to use `select()` because it makes our code more flexible. We could
    easily add in an additional socket (if we needed to listen on multiple ports,
    for example), and we could add in a `select()` timeout if our program needs to
    perform other functions. Of course, our program doesn't do those things, so we
    don't need `select()`, but I think that most programs do, so we will show it that
    way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上并不需要在这个程序中使用`select()`，省略它会使程序更简单（参见`udp_server_toupper_simple.c`）。然而，我们将使用`select()`因为它使我们的代码更灵活。如果我们需要监听多个端口，例如，我们可以轻松地添加一个额外的套接字，并且如果我们程序需要执行其他功能，我们可以添加一个`select()`超时。当然，我们的程序不做这些事情，所以我们不需要`select()`，但我认为大多数程序都需要，所以我们将以这种方式展示。
- en: Now, we are ready for the main loop. It copies the socket set into a new variable,
    `reads`, and then uses `select()` to wait until our socket is ready to read from.
    Recall that we could pass in a timeout value as the last parameter to `select()`
    if we want to set a maximum waiting time for the next read. Refer to [Chapter
    3](https://cdp.packtpub.com/hands_on_network_programming_with_c/wp-admin/post.php?post=27&action=edit#post_26), *An
    In-Depth Overview of TCP Connections*, the *Synchronous multiplexing with select()*
    section, for more information on `select()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好进入主循环。它将套接字集复制到一个新的变量`reads`中，然后使用`select()`等待我们的套接字准备好读取。回想一下，如果我们想为下一次读取设置最大等待时间，可以将超时值作为`select()`的最后一个参数传递。有关`select()`的更多信息，请参阅[第3章](https://cdp.packtpub.com/hands_on_network_programming_with_c/wp-admin/post.php?post=27&action=edit#post_26)，*TCP连接的深入概述*，*使用select()的同步多路复用*部分。
- en: Once `select()` returns, we use `FD_ISSET()` to tell if our particular socket,
    `socket_listen`, is ready to be read from. If we had additional sockets, we would
    need to use `FD_ISSET()` for each socket.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`select()`返回，我们使用`FD_ISSET()`来判断我们的特定套接字`socket_listen`是否准备好读取。如果我们有额外的套接字，我们需要为每个套接字使用`FD_ISSET()`。
- en: If `FD_ISSET()` returns true, we read from the socket using `recvfrom()`. `recvfrom()`
    gives us the sender's address, so we must first allocate a variable to hold the
    address, that is, `client_address`. Once we've read a string from the socket using
    `recvfrom()`, we convert the string into uppercase using the C `toupper()` function.
    We then send the modified text back to the sender using `sendto()`. Note that
    the last two parameters to `sendto()` are the client's addresses that we got from
    `recvfrom()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`FD_ISSET()`返回true，我们使用`recvfrom()`从套接字读取。`recvfrom()`提供了发送者的地址，因此我们必须首先分配一个变量来保存地址，即`client_address`。一旦我们使用`recvfrom()`从套接字读取了一个字符串，我们使用C的`toupper()`函数将字符串转换为大写。然后我们使用`sendto()`将修改后的文本发送回发送者。请注意，`sendto()`的最后两个参数是我们从`recvfrom()`得到的客户端地址。
- en: 'The main program loop can be seen in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序循环可以在以下代码中看到：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can then close the socket, clean up Winsock, and terminate the program. Note
    that this code never runs, because the main loop never terminates. We include
    this code anyway as good practice; in case the program is adapted in the future
    to have an exit function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以关闭套接字，清理Winsock，并终止程序。请注意，此代码永远不会运行，因为主循环永远不会终止。我们仍然包含此代码作为良好实践；以防程序将来被修改以包含退出函数。
- en: 'The cleanup code is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清理代码如下：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That''s our complete UDP server program. You can compile and run it on Linux
    and macOS as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的完整UDP服务器程序。你可以在Linux和macOS上编译和运行它，如下所示：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compiling and running on Windows with MinGW is done in the following manner:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MinGW在Windows上编译和运行的方法如下：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can abort the program's execution with *Ctrl* + *C*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*Ctrl* + *C*来终止程序的执行。
- en: 'Once the program is running, you should open another terminal window and run
    the `udp_client` program from earlier to connect to it, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序开始运行，你应该打开另一个终端窗口，并运行之前提到的`udp_client`程序来连接到它，如下所示：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Anything you type in `udp_client` should be sent back to it in uppercase. Here''s
    what that might look like:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`udp_client`中输入的任何内容都应该以大写形式发送回它。这可能看起来是这样的：
- en: '![](img/6ac794ac-42a7-47aa-b223-129577602a51.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac794ac-42a7-47aa-b223-129577602a51.png)'
- en: You may also want to try opening additional terminal windows and connecting
    with `udp_client`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试打开额外的终端窗口，并使用`udp_client`进行连接。
- en: See `udp_serve_toupper_simple.c` for an implementation that doesn't use `select()`,
    but manages to work just as well anyway.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`udp_serve_toupper_simple.c`以获取一个不使用`select()`但仍然可以正常工作的实现。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that programming with UDP sockets is somewhat easier
    than with TCP sockets. We learned that UDP sockets don't need the `listen()`,
    `accept()`, or `connect()` function calls. This is mostly because `sendto()` and
    `recvfrom()` deal with the addresses directly. For more complicated programs,
    we can still use the `select()` function to see which sockets are ready for I/O.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到使用 UDP 套接字编程比使用 TCP 套接字要简单一些。我们了解到 UDP 套接字不需要 `listen()`、`accept()`
    或 `connect()` 函数调用。这主要是因为 `sendto()` 和 `recvfrom()` 直接处理地址。对于更复杂的程序，我们仍然可以使用 `select()`
    函数来查看哪些套接字已准备好进行 I/O。
- en: We also saw that UDP sockets are connectionless. This is in contrast to connection-oriented
    TCP sockets. With TCP, we had to establish a connection before sending data, but
    with UDP, we simply send individual packets directly to a destination address.
    This keeps UDP socket programming simple, but it can complicate application protocol
    design, and UDP does not automatically retry communication failures or ensure
    that packets arrive in order.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到 UDP 套接字是无连接的。这与面向连接的 TCP 套接字形成对比。在使用 TCP 时，我们必须在发送数据之前建立连接，但使用 UDP，我们只需将单个数据包直接发送到目标地址。这使
    UDP 套接字编程变得简单，但它可能会使应用程序协议设计复杂化，UDP 不会自动重试通信失败，也不能确保数据包按顺序到达。
- en: The next chapter, [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml), *Hostname
    Resolution and DNS*, is all about hostnames. Hostnames are resolved using the
    DNS protocol, which works over UDP. Move on to [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml), *Hostname
    Resolution and DNS*, to learn about implementing a real-world UDP protocol.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[第五章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)，*主机名解析和 DNS*，全部关于主机名。主机名是通过
    DNS 协议解析的，该协议在 UDP 上工作。继续阅读 [第五章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)，*主机名解析和
    DNS*，了解实现现实世界 UDP 协议的方法。
- en: Questions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try answering these questions to test your knowledge of this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答这些问题以测试你对本章知识的掌握：
- en: How do `sendto()` and `recvfrom()` differ from `send()` and `recv()`?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sendto()` 和 `recvfrom()` 与 `send()` 和 `recv()` 有何不同？'
- en: Can `send()` and `recv()` be used on UDP sockets?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()` 和 `recv()` 是否可以在 UDP 套接字上使用？'
- en: What does `connect()` do in the case of a UDP socket?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UDP 套接字的情况下，`connect()` 函数做什么？
- en: What makes multiplexing with UDP easier than with TCP?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 TCP 相比，什么使得使用 UDP 的多路复用更简单？
- en: What are the downsides to UDP when compared to TCP?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 TCP 相比，UDP 的缺点是什么？
- en: Can the same program use UDP and TCP?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一个程序可以使用 UDP 和 TCP 吗？
- en: The answers can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可以在 [附录 A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml) 中找到，*问题解答*。
