- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Executing Custom Tasks with CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake 执行自定义任务
- en: Building and shipping software can be a complex task, and no tool can ever do
    all the different tasks that are needed to build and ship a project. At some point,
    you may want to execute a task that is not covered by a compiler or CMake’s functionality.
    Common tasks include archiving build artifacts, creating hashes to verify downloads,
    or generating or customizing input files for a build. There are also lots of other
    specialized tasks that depend on the environment that certain software is built
    in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和发布软件可能是一个复杂的任务，任何工具都无法完成构建和发布项目所需的所有不同任务。在某些时候，您可能需要执行一个编译器或 CMake 功能没有涵盖的任务。常见任务包括归档构建成果、创建哈希以验证下载，或生成或自定义构建的输入文件。还有许多其他依赖于特定软件构建环境的专门任务。
- en: In this chapter, we will learn how to include such custom tasks in a CMake project
    and how to create custom build targets and custom commands. We will go over how
    to create and manage dependencies between targets and how to include or exclude
    them from standard builds.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将自定义任务包含到 CMake 项目中，以及如何创建自定义构建目标和自定义命令。我们将讨论如何创建和管理目标之间的依赖关系，以及如何将它们包含或排除在标准构建之外。
- en: Including such external programs in the build steps of a project can help ensure
    that code is kept consistent, even when many people contribute to it. As a CMake
    build is very easy to automate, using CMake to invoke the necessary commands makes
    it easy to apply these tools to various machines or a CI environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的构建步骤中包含这样的外部程序可以帮助确保代码的一致性，即使有很多人参与其中。由于 CMake 构建非常容易自动化，使用 CMake 调用必要的命令使得将这些工具应用到不同的机器或
    CI 环境变得简单。
- en: In this chapter, we will learn how custom tasks can be defined and how to control
    when they are executed. In particular, we will focus on managing the dependency
    between custom tasks and regular targets. As CMake is often used to provide build
    information across multiple platforms, you will also learn how to define common
    tasks so that they run everywhere where CMake runs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何定义自定义任务，以及如何控制它们的执行时机。特别地，我们将专注于管理自定义任务和常规目标之间的依赖关系。由于 CMake 通常用于在多个平台上提供构建信息，您还将学习如何定义通用任务，以便它们能在任何运行
    CMake 的地方执行。
- en: 'This chapter will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Using external programs with CMake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CMake 中使用外部程序
- en: Executing custom tasks at build time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时执行自定义任务
- en: Executing custom tasks at configuration time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置时执行自定义任务
- en: Copying and modifying files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制和修改文件
- en: Using CMake for platform-independent commands
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 执行平台独立的命令
- en: So, let’s begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, the examples in this chapter have been tested
    with CMake 3.21 and can run on any of the following compilers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，本章中的示例已在 CMake 3.21 上进行过测试，并且可以在以下编译器上运行：
- en: GCC 9 or newer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 9 或更高版本
- en: Clang 12 or newer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12 或更高版本
- en: MSVC 19 or newer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSVC 19 或更高版本
- en: All the examples and source code for this chapter are available in this book’s
    GitHub repository at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
    If any of the software is missing, the corresponding examples will be excluded
    from the build.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有示例和源代码可以在本书的 GitHub 仓库中找到，地址是 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)。如果缺少任何软件，相应的示例将从构建中排除。
- en: Using external programs with CMake
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CMake 中使用外部程序
- en: 'CMake has pretty broad functionality, so it can cover many tasks when building
    software. However, there are situations when developers will need to do something
    that is not covered. Common examples include running special tools that do some
    pre-or post-processing of files for a target, using source code generators that
    produce input for the compiler, and compressing and archiving artifacts that are
    not handled with CPack. The list of such special tasks that must be accomplished
    during a build step is probably near-endless. CMake supports three ways of executing
    custom tasks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 功能非常广泛，因此它可以覆盖许多构建软件时的任务。然而，也有一些情况，开发者需要执行一些 CMake 功能没有涵盖的任务。常见的例子包括运行特殊工具，对目标的文件进行预处理或后处理，使用源代码生成器为编译器生成输入，以及压缩和归档不由
    CPack 处理的构建成果。必须在构建步骤中完成的此类特殊任务的列表可能是几乎无尽的。CMake 支持三种执行自定义任务的方式：
- en: By defining a target that executes a command with `add_custom_target`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义一个使用 `add_custom_target` 执行命令的目标
- en: By attaching a custom command to an existing target by using `add_custom_command`,
    or by making a target depend on a file that’s been generated by a custom command
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`add_custom_command`将自定义命令附加到现有目标，或者通过使目标依赖于由自定义命令生成的文件
- en: By using the `execute_process` function, which executes a command during the
    configuration step
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`execute_process`函数，在配置步骤中执行命令
- en: Whenever possible, external programs should be called during the build step,
    as the configuration step is far less controllable by the user and should generally
    run as fast as possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，应在构建步骤中调用外部程序，因为配置步骤用户控制性较低，应尽可能快速地运行。
- en: Let’s learn how to define tasks that run at build time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何定义在构建时运行的任务。
- en: Executing custom tasks at build time
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建时执行自定义任务
- en: 'The most generic way to add a custom task is by creating a custom target that
    executes an external task as a sequence of commands. Custom targets are handled
    like any other library or executable target, with the difference that they do
    not invoke the compiler and linker; instead, they do something defined by the
    user. Custom targets are defined using the `add_custom_target` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义任务的最通用方法是通过创建一个自定义目标，该目标以命令序列执行外部任务。自定义目标像任何其他库或可执行目标一样处理，不同之处在于它们不调用编译器和链接器，而是执行用户定义的操作。自定义目标使用`add_custom_target`命令定义：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The core of the `add_custom_target` command is the list of commands that are
    passed with the `COMMAND` option. Although the first command can be passed without
    this option, it is good practice to always add the `COMMAND` option to any `add_custom_target`
    call. By default, custom targets are only executed if they’re explicitly requested
    unless the `ALL` option is specified. Custom targets are always considered out
    of date, so the commands specified internally are always run, regardless of whether
    they produce the same result repeatedly. With the `DEPENDS` keyword, custom targets
    can be made to depend on the files and outputs of custom commands that have been
    defined with the `add_custom_command` function or by other targets. To make the
    custom target depend on another target, use the `add_dependencies` function. The
    same works the other way around – any target may depend on a custom target. If
    the custom target creates files, these can be listed under the `BYPRODUCTS` option.
    Any file that’s listed there will be marked with the `GENERATED` property, which
    is used by CMake to determine whether a build is out of date and to find out which
    files to clean. However, tasks that create files using `add_custom_command` might
    be better suited, as described later in this section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_custom_target`命令的核心是通过`COMMAND`选项传递的命令列表。虽然第一个命令可以在没有此选项的情况下传递，但最好在任何`add_custom_target`调用中始终添加`COMMAND`选项。默认情况下，只有在明确请求时，自定义目标才会执行，除非指定了`ALL`选项。自定义目标始终被认为是过时的，因此指定的命令会始终运行，无论它们是否重复产生相同的结果。通过`DEPENDS`关键字，可以使自定义目标依赖于通过`add_custom_command`函数定义的自定义命令的文件和输出，或依赖于其他目标。若要使自定义目标依赖于另一个目标，请使用`add_dependencies`函数。反过来也适用——任何目标都可以依赖于自定义目标。如果自定义目标创建了文件，可以在`BYPRODUCTS`选项下列出这些文件。列在其中的任何文件都会标记为`GENERATED`属性，CMake会用这个属性来判断构建是否过时，并找出需要清理的文件。然而，使用`add_custom_command`创建文件的任务可能更适合，如本节后续所述。'
- en: By default, these commands are executed in the current binary directory, which
    is stored in the `CMAKE_CURRENT_BINARY_DIRECTORY` cache variable. If necessary,
    this can be changed with the `WORKING_DIRECTORY` option. This option can either
    be an absolute path or a relative path, if it is a relative path to the current
    binary directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些命令在当前二进制目录中执行，该目录存储在`CMAKE_CURRENT_BINARY_DIRECTORY`缓存变量中。如有必要，可以通过`WORKING_DIRECTORY`选项更改此目录。此选项可以是绝对路径，也可以是相对路径，若为相对路径，则相对于当前二进制目录。
- en: The `COMMENT` option is used to specify a message that is printed right before
    the command runs, which can come in handy if a command runs silently. Unfortunately,
    not all generators show these messages, so using this to display critical information
    is somewhat unreliable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMMENT`选项用于指定在命令运行之前打印的消息，这在命令默默运行时非常有用。不幸的是，并非所有生成器都显示这些消息，因此将其用于显示关键信息可能不太可靠。'
- en: The `VERBATIM` flag causes all the commands to be passed directly to the platform
    without further escaping or variable substitution by the underlying shell. CMake
    itself will still replace variables that are passed to the commands or the arguments.
    Whenever escaping might be an issue, passing the `VERBATIM` flag is recommended.
    It is also good practice to write custom tasks so that they are independent of
    the underlying platform. You can find more tips on how to create platform-independent
    commands later in this chapter, in the *Using CMake for platform-independent*
    *commands* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`VERBATIM` 标志会将所有命令直接传递给平台，而不经过底层 shell 的转义或变量替换。CMake 本身仍会替换传递给命令或参数的变量。当转义可能成为问题时，建议传递
    `VERBATIM` 标志。编写自定义任务时，使其与底层平台独立也是一种良好的实践。在本章稍后，在 *使用 CMake 创建平台独立的* *命令* 部分，你可以找到更多有关如何创建平台独立命令的技巧。'
- en: The `USES_TERMINAL` option instructs CMake to give the command access to the
    terminal if possible. If the Ninja generator is used, this means that it runs
    in the `terminal` job pool. All the commands in this pool are executed serially.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`USES_TERMINAL` 选项指示 CMake 如果可能的话让命令访问终端。如果使用的是 Ninja 生成器，这意味着它将在 `terminal`
    作业池中运行。该池中的所有命令是串行执行的。'
- en: The `JOB_POOL` option can be used when you’re generating with Ninja to control
    the concurrency of a job. It is rarely used and cannot be used together with the
    `USES_TERMINAL` flag. You will rarely need to interfere with Ninja’s job pool,
    and handling it is not trivial. If you wish to learn more, further information
    can be found in the official documentation for CMake’s `JOB_POOLS` property.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`JOB_POOL` 选项可在使用 Ninja 生成时控制作业的并发性。它很少使用，并且不能与 `USES_TERMINAL` 标志一起使用。你很少需要干预
    Ninja 的作业池，且处理起来并不简单。如果你想了解更多信息，可以参考 CMake 官方文档中的 `JOB_POOLS` 属性部分。'
- en: The `SOURCES` properties take a list of source files that are associated with
    the custom target. The property does not affect the source files but can help
    make the files visible in some IDEs. If a command relies on files such as scripts
    that are delivered together with a project, these should be added here.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`SOURCES` 属性接受与自定义目标关联的源文件列表。该属性不会影响源文件，但可以帮助在某些 IDE 中显示文件。如果一个命令依赖于例如与项目一起交付的脚本等文件，这些文件应该在这里添加。'
- en: The `COMMAND_EXPAND_LISTS` option tells CMake to expand lists before passing
    them to the command. This is sometimes necessary because, in CMake, lists are
    just strings separated by semicolons, which may lead to syntax errors. When you
    pass the `COMMAND_EXPAND_LISTS` option, the semicolons are replaced with a suitable
    whitespace character, depending on the platform. The expansion includes lists
    that have been generated using the `$<JOIN:` generator expression.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMMAND_EXPAND_LISTS` 选项告诉 CMake 在将列表传递给命令之前展开它们。这在某些情况下是必要的，因为在 CMake 中，列表只是由分号分隔的字符串，这可能导致语法错误。当传递
    `COMMAND_EXPAND_LISTS` 选项时，分号会根据平台被替换为合适的空白字符。展开操作包括使用 `$<JOIN:` 生成器表达式生成的列表。'
- en: 'The following is an example of a custom target that uses an external program
    called *CreateHash* to create a hash for the output of another target:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了一个使用名为 *CreateHash* 的外部程序来为另一个目标的输出创建哈希值的自定义目标：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example creates a custom target called *CreateHash* that invokes the external
    *SomeHasher* program, with the binary file of the *SomeExe* target as an argument.
    Note that the binary file is retrieved using the `$<TARGET_FILE:SomeExe>` generator
    expression. This serves two purposes – it removes the need for the user to track
    the filename of the binary of the target, and it adds an implicit dependency between
    the two targets. CMake will recognize these implicit dependencies and execute
    the targets in the correct order. If the target that produces the required file
    hasn’t been built yet, CMake will automatically build it. You can also use the
    `$<TARGET_FILE:` generator to directly execute an executable that’s been created
    by another target. The following generator expressions cause implicit dependencies
    between targets:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本例创建了一个名为 *CreateHash* 的自定义目标，它调用外部的 *SomeHasher* 程序，并将 *SomeExe* 目标的二进制文件作为参数。请注意，二进制文件是通过
    `$<TARGET_FILE:SomeExe>` 生成器表达式获取的。这有两个目的——它消除了用户需要跟踪目标二进制文件名的需求，并且在两个目标之间建立了一个隐式依赖关系。CMake
    会识别这些隐式依赖并按正确的顺序执行目标。如果生成所需文件的目标尚未构建，CMake 将自动构建它。你还可以使用 `$<TARGET_FILE:` 生成器来直接执行由另一个目标创建的可执行文件。以下生成器表达式会在目标之间引发隐式依赖：
- en: '`$<TARGET_FILE:target>`: This contains the full path to the main binary file
    of the target, such as `.exe`, `.so`, or `.dll`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_FILE:target>`：这包含了目标的主二进制文件的完整路径，如`.exe`、`.so`或`.dll`。'
- en: '`$<TARGET_LINKER_FILE: target >`: This contains the full path to the file that’s
    used to link against the target. This is usually the library file itself, except
    on Windows, where the `.lib` file will be associated with the DLL.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_LINKER_FILE: target>`：这包含了用于与目标进行链接的文件的完整路径。通常是库文件本身，但在Windows上，`.lib`文件会与DLL相关联。'
- en: '`$<TARGET_SONAME_FILE: target >`: This contains the library file and its full
    name, including any number that’s been set by the `SOVERSION` property, such as
    `.so.3`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_SONAME_FILE: target>`：这包含了库文件及其完整名称，包括由`SOVERSION`属性设置的任何数字，如`.so.3`。'
- en: '`$<TARGET_PDB_FILE: target >`: This contains the full path to the generated
    program database file that’s used for debugging.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<TARGET_PDB_FILE: target>`：这包含了用于调试的生成的程序数据库文件的完整路径。'
- en: Creating custom targets is one way to execute external tasks during build time.
    Another way is to define custom commands. Custom commands can be used to add custom
    tasks to existing targets, including custom targets.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义目标是一种在构建时执行外部任务的方法。另一种方法是定义自定义命令。自定义命令可以用来将自定义任务添加到现有目标中，包括自定义目标。
- en: Adding custom tasks to existing targets
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自定义任务添加到现有目标
- en: 'Sometimes, you may need to perform an additional, external task when building
    a target. In CMake, you can achieve this with `add_custom_command`, which has
    two signatures. One is used to hook commands into existing targets, while the
    other is used to generate files. We will cover this later in this section. The
    signature to add commands to an existing target looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在构建目标时，你可能需要执行一个额外的外部任务。在CMake中，你可以使用`add_custom_command`来实现这一点，它有两种签名。一种用于将命令钩入现有的目标，另一种用于生成文件。我们将在本节后续部分讲解这一点。将命令添加到现有目标的签名如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of the options work similarly to those in `add_custom_target`, as described
    earlier. The `TARGET` property can be any target that is defined in the current
    directory, which is a limitation of the command, although it is rarely an issue.
    Commands can be hooked into the build at the following times:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数选项的工作方式与之前提到的`add_custom_target`类似。`TARGET`属性可以是当前目录中定义的任何目标，这是该命令的一个限制，尽管这很少成为问题。命令可以在以下时间钩入构建过程：
- en: '`PRE_BUILD`: In Visual Studio, this command is executed before any other build
    steps are executed. When you use other generators, it will run just before the
    `PRE_LINK` commands.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_BUILD`：在Visual Studio中，此命令会在任何其他构建步骤之前执行。当你使用其他生成器时，它将在`PRE_LINK`命令之前执行。'
- en: '`PRE_LINK`: This command will run after the sources have been compiled but
    before the executable or archiver tool has been linked to static libraries.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_LINK`：此命令将在源代码编译完成后执行，但在可执行文件或归档工具链接到静态库之前执行。'
- en: '`POST_BUILD`: This runs the command after all the other build rules have been
    executed.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST_BUILD`：在所有其他构建规则执行完毕后运行此命令。'
- en: The most common way to execute custom steps is by using `POST_BUILD`; the other
    two options are rarely used, either because of limited support or because they
    can neither influence the link nor the build.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行自定义步骤的最常见方法是使用`POST_BUILD`；另外两种选项很少使用，可能是因为支持有限，或者因为它们既不能影响链接，也不能影响构建。
- en: 'Adding a custom command to an existing target is relatively straightforward.
    The following code adds a command that generates and stores the hash of a built
    file after each compilation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将自定义命令添加到现有目标相对简单。以下代码在每次编译后添加一个命令，用于生成并存储已构建文件的哈希值：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, a custom executable called `hasher` is used to generate the
    hash of the output file of the `MyExectuable` target.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用一个名为`hasher`的自定义可执行文件来生成`MyExecutable`目标的输出文件的哈希值。
- en: Often, the reason you may need to execute something before a build is to change
    files or to generate additional information. For this, a second signature is often
    the better choice. Let’s take a closer look.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建之前你可能需要执行某些操作，以更改文件或生成额外的信息。对于这种情况，第二种签名通常是更好的选择。让我们仔细看看。
- en: Generating files with custom tasks
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成文件与自定义任务
- en: 'Typically, we want custom tasks to produce a specific output file. This can
    be done by defining custom targets and setting the necessary dependencies between
    the targets, or by hooking into the build steps, as described earlier. Unfortunately,
    the `PRE_BUILD` hook is unreliable because only the Visual Studio generator supports
    it properly. Therefore, a better way to do this is to create a custom command
    that creates the file, by using the second signature of the `add_custom_command`
    function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望自定义任务能生成特定的输出文件。这可以通过定义自定义目标并设置目标之间的必要依赖关系来完成，或者通过挂钩构建步骤来实现，正如前面所述。不幸的是，`PRE_BUILD`
    钩子并不可靠，因为只有 Visual Studio 生成器能正确支持它。因此，一个更好的方法是创建一个自定义命令来生成文件，通过使用 `add_custom_command`
    函数的第二种签名：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This signature of `add_custom_command` defines a command that generates a file
    specified in `OUTPUT`. Most of the options of the command are very similar to
    `add_custom_target` and the signature to hook custom tasks into build steps. The
    `DEPENDS` option can be used to manually specify a dependency to either files
    or targets. Note that, in comparison, the `DEPENDS` option of custom targets can
    only point to files. If any of the dependencies are updated by a build or CMake,
    the custom command is run again. The `MAIN_DEPENDENCY` option is closely related,
    which specifies the primary input file for the command. It works like the `DEPENDS`
    option does, except that it only takes one file. `MAIN_DEPENDENCY` is mainly used
    to tell Visual Studio where to add the custom command.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种签名的 `add_custom_command` 定义了一个生成 `OUTPUT` 中指定文件的命令。该命令的大多数选项与 `add_custom_target`
    和挂钩自定义任务到构建步骤的签名非常相似。`DEPENDS` 选项可以用来手动指定文件或目标的依赖关系。需要注意的是，与此相比，自定义目标的 `DEPENDS`
    选项只能指向文件。如果任何依赖关系在构建或 CMake 更新时发生变化，自定义命令将再次运行。`MAIN_DEPENDENCY` 选项密切相关，指定命令的主要输入文件。它的作用类似于
    `DEPENDS` 选项，只是它只接受一个文件。`MAIN_DEPENDENCY` 主要用于告诉 Visual Studio 添加自定义命令的位置。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a source file is listed as `MAIN_DEPENDENCY`, then the custom command replaces
    the normal compilation of the file listed, which can lead to linker errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源文件列为 `MAIN_DEPENDENCY`，则自定义命令会替代正常的文件编译，这可能导致链接错误。
- en: 'The other two dependency-related options, `IMPLICIT_DEPENDS` and `DEPFILE`,
    are rarely used because their support is limited to the Makefile generator. `IMPLICT_DEPENDS`
    tells CMake to use a C or C++ scanner to detect any compile-time dependencies
    of the files listed and create dependencies from that. The other option, `DEPFILE`,
    can be used to point to a `.d` dependency file, which is generated by the Makefile
    project. The `.d` files originally stem from the GNU Make project and can be powerful
    to use, but they are also complex and should not be manually managed for most
    projects. The following example illustrates how a custom command can be used to
    generate a source file before a regular target is run, based on another file that
    is used for input:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个与依赖相关的选项，`IMPLICIT_DEPENDS` 和 `DEPFILE`，很少使用，因为它们的支持仅限于 Makefile 生成器。`IMPLICIT_DEPENDS`
    告诉 CMake 使用 C 或 C++ 扫描器来检测列出文件的任何编译时依赖关系，并基于此创建依赖关系。另一个选项 `DEPFILE` 可以用来指向 `.d`
    依赖文件，该文件由 Makefile 项目生成。`.d` 文件最初来自 GNU Make 项目，虽然它们非常强大，但也比较复杂，大多数项目不应手动管理这些文件。以下示例展示了如何使用自定义命令，在常规目标运行之前，根据用于输入的另一个文件生成源文件：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Several things are happening in this example. First, the custom command defines
    the `main.cpp` file in the current binary directive as an `OUTPUT` file. Then,
    the command that generates this file is defined – here, an imaginary program called
    `sourceFileGenerator` is used – which converts a message file into a `.cpp` file.
    The `DEPENDS` part states that this command should be rerun every time the `message.txt`
    file changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中发生了几件事。首先，自定义命令将当前二进制目录中的 `main.cpp` 文件定义为 `OUTPUT` 文件。然后，定义了生成该文件的命令——这里使用了一个名为
    `sourceFileGenerator` 的假设程序——它将消息文件转换为 `.cpp` 文件。`DEPENDS` 部分指出，每次 `message.txt`
    文件发生变化时，都应重新运行该命令。
- en: Later, the target for the executable is created. Since the executable references
    the `main.cpp` file specified in the `OUTPUT` section of the custom command, CMake
    will implicitly add the necessary dependency between the command and the target.
    Using custom commands in this way is much more reliable and portable than using
    the `PRE_BUILD` directive, as it works with all generators.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 后续创建了可执行文件的目标。由于可执行文件引用了在自定义命令的`OUTPUT`部分指定的`main.cpp`文件，CMake会隐式添加命令和目标之间的必要依赖关系。以这种方式使用自定义命令比使用`PRE_BUILD`指令更可靠且具有更好的移植性，因为它适用于所有生成器。
- en: 'Sometimes, to create the desired output, more than one command is needed. If
    a previous command that produces the same output exists, commands can be chained
    by using the `APPEND` option. Custom commands that use `APPEND` may only define
    additional `COMMAND` and `DEPENDS` options; the other options are ignored. If
    two commands produce the same output file, CMake will print an error unless `APPEND`
    is specified. This is mainly useful if a command is only optionally executed.
    Consider the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了创建所需的输出，可能需要多个命令。如果存在一个生成相同输出的先前命令，可以通过使用`APPEND`选项将命令链接起来。使用`APPEND`的自定义命令只能定义额外的`COMMAND`和`DEPENDS`选项；其他选项会被忽略。如果两个命令生成相同的输出文件，除非指定`APPEND`，CMake会打印出错误。这个功能主要用于当一个命令是可选执行时。考虑以下示例：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, the output file of a target, `MyTarget`, has been added to
    a `tar.gz` archive; later, another file is added to the same archive. Note that
    the first command automatically depends on `MyTarget` because it uses the binary
    file that was created in the command. However, it will not automatically be executed
    by a build. The second custom command lists the same output file as the first
    command but adds the compressed file as a second output. By specifying `APPEND`,
    the second command is automatically executed whenever the first command is executed.
    If the `APPEND` keyword is missing, CMake will print out an error, similar to
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，目标`MyTarget`的输出文件已经被添加到一个`tar.gz`归档中；之后，另一个文件被添加到相同的归档中。注意，第一个命令自动依赖于`MyTarget`，因为它使用了在命令中创建的二进制文件。然而，它不会通过构建自动执行。第二个自定义命令列出了与第一个命令相同的输出文件，但将压缩文件作为第二个输出添加。通过指定`APPEND`，第二个命令会在每次执行第一个命令时自动执行。如果缺少`APPEND`关键字，CMake会打印出类似如下的错误：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we mentioned previously, the custom commands in this example implicitly
    depend on `MyTarget`, but they will not be executed automatically. To execute
    them, the recommended practice is to create a custom target that depends on the
    output file, which can be generated like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本示例中的自定义命令隐式依赖于`MyTarget`，但它们不会自动执行。为了执行这些命令，推荐的做法是创建一个依赖于输出文件的自定义目标，可以像这样生成：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a custom target called `create_archive` has been created that is executed
    as part of the `All` build. Since it depends on the output of the custom commands,
    building the target will invoke the custom commands. The custom commands, in turn,
    depend on `MyTarget`, so building `create_archive` will also trigger a build of
    `MyTarget` if it is not already up to date.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个名为`create_archive`的自定义目标，该目标作为`All`构建的一部分执行。由于它依赖于自定义命令的输出，因此构建该目标会调用自定义命令。自定义命令反过来依赖于`MyTarget`，因此如果`MyTarget`尚未是最新的，构建`create_archive`也会触发`MyTarget`的构建。
- en: Both the `add_custom_command` and `add_custom_target` custom tasks are executed
    during the build step of CMake. It is possible to add tasks at configuration time
    if necessary. We’ll look at this in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_custom_command`和`add_custom_target`自定义任务都会在CMake的构建步骤中执行。如果需要，也可以在配置时添加任务。我们将在下一节中讨论这个问题。'
- en: Executing custom tasks at configuration time
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置时执行自定义任务
- en: To execute custom tasks at configuration time, you can use the `execute_process`
    function. Common needs for this are if the build requires additional information
    before a build, or if files need to be updated for any rerun of CMake. Another
    common case is when either the `CMakeLists.txt` file or other input files are
    generated during the configuration step, although this can also be achieved with
    the specialized `configure_file` command, as shown later in this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要在配置时执行自定义任务，可以使用`execute_process`函数。常见的需求是，如果构建在开始之前需要额外的信息，或者需要更新文件以便重新运行CMake。另一个常见的情况是，当`CMakeLists.txt`文件或其他输入文件在配置步骤中生成时，尽管这也可以通过专用的`configure_file`命令实现，正如本章稍后所展示的那样。
- en: 'The `execute_process` function works very similarly to the `add_custom_target`
    and `add_custom_command` functions we saw earlier. However, one distinction is
    that `execute_process` can capture output to `stdout` and `stderr` in a variable
    or files. The signature of `execute_process` is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_process` 函数的工作方式与我们之前看到的 `add_custom_target` 和 `add_custom_command`
    函数非常相似。然而，有一个区别是，`execute_process` 可以将输出捕获到变量或文件中的 `stdout` 和 `stderr`。`execute_process`
    的函数签名如下：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `execute_process` function takes a list of `COMMAND` properties to be executed
    in `WORKING_DIRECTORY`. The return codes of the last command to be executed can
    be stored in the variable defined with `RESULT_VARIABLE`. Alternatively, a semicolon-separated
    list of variables can be passed to `RESULTS_VARIABLE`. If you use the `list` version,
    the commands will store the return code of the commands in the same order as the
    variables that have been defined. If fewer variables have been defined than commands,
    any surplus return code will be ignored. If `TIMEOUT` was defined and any of the
    child processes failed to return, the result variables will contain `timeout`.
    Since CMake version 3.19, the convenient `COMMAND_ERROR_IS_FATAL` option is available,
    which tells CMake to abort execution if any (or just the last) of the processes
    fails. This is much more convenient than retrieving all the return codes and then
    checking them individually after their execution. In the following example, if
    any of the commands return a non-zero value, the configuration step of CMake will
    fail with an error:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_process` 函数接受一系列要在 `WORKING_DIRECTORY` 中执行的 `COMMAND` 属性。最后执行命令的返回代码可以存储在使用
    `RESULT_VARIABLE` 定义的变量中。或者，可以将以分号分隔的变量列表传递给 `RESULTS_VARIABLE`。如果使用 `list` 版本，命令会按照定义的变量顺序存储命令的返回码。如果定义的变量少于命令，任何多余的返回码将被忽略。如果定义了
    `TIMEOUT` 且任何子进程未能返回，结果变量将包含 `timeout`。从 CMake 3.19 版本开始，提供了方便的 `COMMAND_ERROR_IS_FATAL`
    选项，它告诉 CMake 如果任何（或仅最后一个）进程失败，则中止执行。这比在执行后获取所有返回码并逐个检查要方便得多。在以下示例中，如果任何命令返回非零值，CMake
    的配置步骤将失败并报错：'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any output to `stdout` or `stderr` can be captured using the `OUTPUT_VARIABLE`
    or `ERROR_VARIABLE` variable, respectively. As an alternative, they can be redirected
    to files by using `OUTPUT_FILE` or `ERROR_FILE`, or can be completely ignored
    by passing `OUTPUT_QUIET` or `ERROR_QUIET`. Capturing the output in both a variable
    and a file is not possible and will result in either of the two being empty. Which
    one is kept and which is discarded depends on the platform. If not, the `OUTPUT_*`
    option specifies that the output is sent to the CMake process itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何输出到 `stdout` 或 `stderr` 的内容可以分别通过 `OUTPUT_VARIABLE` 或 `ERROR_VARIABLE` 变量进行捕获。作为替代方法，它们可以通过使用
    `OUTPUT_FILE` 或 `ERROR_FILE` 重定向到文件，或者通过传递 `OUTPUT_QUIET` 或 `ERROR_QUIET` 完全忽略。不能同时将输出捕获到变量和文件中，这会导致其中一个为空。保留哪个输出，丢弃哪个，取决于平台。如果没有其他设置，`OUTPUT_*`
    选项表示输出将发送到 CMake 进程本身。
- en: If the output is captured in a variable but can still be displayed, `ECHO_<STREAM>_VARIABLE`
    can be added. CMake can also be told to output the command itself by passing `STDOUT`,
    `STDERR`, or `NONE` to the `COMMAND_ECHO` option. However, if the output is captured
    in files, this will have no effect. If the same variable or file is specified
    for both `stdout` and `stderr`, then the results will be merged. If necessary,
    the input stream of the first command can be controlled by passing a file to the
    `INPUT_FILE` option.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出被捕获到变量中但仍然可以显示，可以添加 `ECHO_<STREAM>_VARIABLE`。也可以通过传递 `STDOUT`、`STDERR` 或
    `NONE` 给 `COMMAND_ECHO` 选项来让 CMake 输出命令本身。然而，如果输出被捕获到文件中，这将没有任何效果。如果为 `stdout`
    和 `stderr` 指定相同的变量或文件，结果将被合并。如果需要，可以通过传递文件给 `INPUT_FILE` 选项来控制第一个命令的输入流。
- en: 'The output to variables can be controlled in a limited way by using the `<STREAM>_STRIP_TRAILING_WHITESPACE`
    option, which will trim any whitespace at the end of the output. When you’re redirecting
    output to files, this has no effect. On Windows, the `ENCODING` option can be
    used to control the output. It takes the following values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到变量的行为可以通过使用 `<STREAM>_STRIP_TRAILING_WHITESPACE` 选项进行有限控制，该选项会去除输出末尾的空白字符。当输出被重定向到文件时，此选项无效。在
    Windows 上，可以使用 `ENCODING` 选项来控制输出编码。它支持以下几种值：
- en: '`NONE`: Performs no re-encoding. This will keep CMake’s internal encoding,
    which is UTF-8.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NONE`：不进行重新编码。这将保持 CMake 内部的编码格式，即 UTF-8。'
- en: '`AUTO`: Uses the current console’s encoding. If this is not available, it uses
    ANSI.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTO`：使用当前控制台的编码。如果不可用，则使用 ANSI 编码。'
- en: '`ANSI`: Uses the ANSI code page for encoding.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANSI`：使用 ANSI 代码页进行编码。'
- en: '`OEM`: Uses the code page defined by the platform.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM`：使用平台定义的代码页。'
- en: '`UTF8` or `UTF-8`: Forced to use the UTF-8 encoding.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UTF8` 或 `UTF-8`：强制使用 UTF-8 编码。'
- en: 'A common reason for using `execute_process` is gathering information that is
    needed for a build and then passing it to a project. Consider an example where
    we want to compile the git revision into an executable by passing it as a preprocessor
    definition. The downside of this approach is that for the custom tasks to be executed,
    CMake has to be invoked, not just the build system. So, using `add_custom_command`
    with an `OUTPUT` parameter would probably be the more realistic solution here,
    but for illustrative purposes, this example should serve well enough. The following
    is an example where the git hash is read out at configuration time and passed
    as a compile definition to a target:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `execute_process` 的常见原因之一是收集构建所需的信息，然后将其传递给项目。考虑一个示例，我们想要将 git 修订版编译到可执行文件中，通过将其作为预处理器定义传递。这样做的缺点是，为了执行自定义任务，必须调用
    CMake，而不仅仅是构建系统。因此，使用带有 `OUTPUT` 参数的 `add_custom_command` 可能是更实际的解决方案，但为了说明目的，这个示例应该已经足够。以下是一个示例，其中在配置时读取
    git 哈希并作为编译定义传递给目标：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `git` command that’s passed to `execute_process` is executed
    in the directory containing the `CMakeLists.txt` file, which is currently being
    executed. The resulting hash is stored in the `GIT_REVISION` variable, and if
    the command fails for any reason, the configuration process is halted with an
    error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，传递给 `execute_process` 的 `git` 命令是在包含当前正在执行的 `CMakeLists.txt` 文件的目录中执行的。生成的哈希值存储在
    `GIT_REVISION` 变量中，如果命令由于任何原因失败，配置过程将会停止并报错。
- en: Passing the information from `execute_process` into the compiler by using a
    preprocessor definition is far from optimal. A much nicer solution would be if
    we could generate a header file to be included that contains this information.
    CMake has another feature called `configure_file` that can be used for this purpose,
    as we will see in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用预处理器定义将 `execute_process` 的信息传递给编译器的做法远非最佳。更好的解决方案是，如果我们能够生成一个包含这些信息的头文件，并将其包含进来。CMake
    还有一个名为 `configure_file` 的功能可以用来实现这一目的，正如我们将在下一节中看到的那样。
- en: Copying and modifying files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制和修改文件
- en: 'A relatively common task when building software is that some files must be
    copied to a specific location before the build. Most file operations can be done
    using the `file()` command at configuration time. For instance, copying files
    is done by invoking the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建软件时，一个相对常见的任务是必须在构建前将某些文件复制到特定位置。大多数文件操作可以在配置时通过 `file()` 命令来完成。例如，复制文件可以通过以下方式调用：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are several file operations available, such as `file(REMOVE)` and `file(REMOVE_RECURSE)`
    to delete files or directory trees, `file(RENAME)` to move files, and `file(CHMOD)`
    to change permissions on systems that support it. The full documentation of the
    `file` command is available here: [https://cmake.org/cmake/help/latest/command/file.html](https://cmake.org/cmake/help/latest/command/file.html).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种文件操作可用，例如 `file(REMOVE)` 和 `file(REMOVE_RECURSE)` 用于删除文件或目录树，`file(RENAME)`
    用于移动文件，`file(CHMOD)` 用于更改支持该操作的系统上的权限。`file` 命令的完整文档请参见：[https://cmake.org/cmake/help/latest/command/file.html](https://cmake.org/cmake/help/latest/command/file.html)。
- en: 'But what if we want to copy and modify a file at the same time? In the *Executing
    custom tasks at configuration time* section, we saw an example where the git revision
    was retrieved and passed to the compiler as a preprocessor definition. A much
    nicer way to do this would be to generate a header file containing the necessary
    information. While just echoing the code snippet and writing it into a file would
    be possible, it is dangerous, as it may lead to platform-specific code. CMake’s
    solution to this is the `configure_file` command, which can copy files from one
    location to another and modify their content while doing so. The signature of
    `configure_file` is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想要同时复制和修改一个文件该怎么办呢？在*配置时执行自定义任务*一节中，我们看到了一个示例，其中获取了 git 修订版本并作为预处理器定义传递给编译器。更好的做法是生成一个包含必要信息的头文件。虽然直接回显代码片段并将其写入文件是可行的，但这样做是危险的，因为它可能会导致平台特定的代码。CMake
    的解决方案是 `configure_file` 命令，它可以将文件从一个位置复制到另一个位置并在此过程中修改其内容。`configure_file` 的函数签名如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `configure_file` function will copy the `<input>` file to the `<output>`
    file. If necessary, the path to the output file will be created, and the paths
    can be relative or absolute. If you’re using relative paths, the input file will
    be searched from the current source directory, but the path of the output file
    will be relative to the current build directory. If the output file cannot be
    written, the command will fail, and the configuration will be halted. By default,
    the output file has the same permissions as the target file, although ownership
    may change if the current user is a different one than the one that the input
    file belongs to. If `NO_SOURCE_PERMISSION` is added, the permissions are not transferred,
    and the output file gets the default `rw-r--r--` value. Alternatively, the permissions
    can be manually specified with the `FILE_PERMISSIONS` option, which takes a three-digit
    number as an argument. The `USE_SOURCE_PERMISSION` is already the default, and
    the option is only there to state the intent more explicitly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure_file`函数会将`<input>`文件复制到`<output>`文件。如果需要，输出文件的路径将被创建，路径可以是相对路径或绝对路径。如果使用相对路径，输入文件将从当前源目录中查找，但输出文件的路径将相对于当前构建目录。如果无法写入输出文件，命令将失败，配置将被停止。默认情况下，输出文件与目标文件具有相同的权限，尽管如果当前用户与输入文件所属的用户不同，所有权可能会发生变化。如果添加`NO_SOURCE_PERMISSION`，则不会传递权限，输出文件将获得默认的`rw-r--r--`权限。或者，可以通过`FILE_PERMISSIONS`选项手动指定权限，该选项需要一个三位数字作为参数。`USE_SOURCE_PERMISSION`已经是默认值，该选项仅用于更明确地表达意图。'
- en: 'As we mentioned earlier, `configure_file` will also replace parts of the input
    file when you’re copying to the output path unless `COPYONLY` is passed. By default,
    `configure_file` will replace all the variables referenced as `${SOME_VARIABLE}`
    or `@SOME_VARIABLE@` with the value of any variable of the same name. If a variable
    is defined in `CMakeLists.txt`, when `configure_file` is called, the respective
    value is written into the output file. If a variable is not specified, the output
    file will contain an empty string in the respective place. Consider a `hello.txt.in`
    file that contains the following information:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`configure_file`在复制到输出路径时也会替换输入文件的部分内容，除非传递了`COPYONLY`。默认情况下，`configure_file`会将所有引用的变量`${SOME_VARIABLE}`或`@SOME_VARIABLE@`替换为相同名称的变量的值。如果在`CMakeLists.txt`中定义了变量，当调用`configure_file`时，相应的值会写入输出文件。如果未指定变量，输出文件中的相应位置将包含空字符串。考虑一个包含以下信息的`hello.txt.in`文件：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In a `CMakeLists.txt` file, the `configure_file` function is used to configure
    the `hello.txt.in` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CMakeLists.txt`文件中，`configure_file`函数用于配置`hello.txt.in`文件：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the resulting `hello.txt` file will contain `Hello World from
    The Universe`. If the `@ONLY` option is passed to `configure_file`, only `@GREETER@`
    is replaced, and the resulting content is `Hello ${GUEST} from The Universe`.
    Using `@ONLY` is useful when you’re transforming CMake files that may contain
    brace-enclosed variables that should not be replaced. `ESCAPE_QUOTES` will escape
    any quotes in the target file with a backslash. By default, `configure_file` will
    transform the newline character so that the target file matches the current platform.
    The default behavior can be changed by setting `NEWLINE_STYLE`. `UNIX` or `LF`
    will use `\n` for newlines, while `DOS`, `WIN32`, and `CRLF` will use `\r\n`.
    Setting the `NEWLINE_STYLE` and `COPYONLY` options together will cause an error.
    Note that setting `COPYONLY` will not affect the newline style.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，生成的`hello.txt`文件将包含`Hello World from The Universe`。如果将`@ONLY`选项传递给`configure_file`，只有`@GREETER@`会被替换，生成的内容将是`Hello
    ${GUEST} from The Universe`。使用`@ONLY`在你转换可能包含大括号括起来的变量的CMake文件时非常有用，这些变量不应该被替换。`ESCAPE_QUOTES`会在目标文件中用反斜杠转义任何引号。默认情况下，`configure_file`会转换换行符，以便目标文件与当前平台匹配。默认行为可以通过设置`NEWLINE_STYLE`来改变。`UNIX`或`LF`将使用`\n`作为换行符，而`DOS`、`WIN32`和`CRLF`将使用`\r\n`。同时设置`NEWLINE_STYLE`和`COPYONLY`选项将导致错误。请注意，设置`COPYONLY`不会影响换行符样式。
- en: 'Let’s go back to the example where we want to compile the git revision into
    an executable. Here, we would write a header file as input. It may contain a line
    that looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们希望将git修订版编译到可执行文件中的示例。在这里，我们将编写一个头文件作为输入。它可能包含如下内容：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As shown in the example in the previous section, where the version information
    was passed as a compile definition, the git revision is first retrieved with `execute_process`.
    Later, the file is copied using `configure_file`, and `@GIT_REVISION@` is replaced
    with the short hash of the current commit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节中的示例所示，版本信息是作为编译定义传递的，git修订版首先通过`execute_process`获取。随后，文件通过`configure_file`进行复制，`@GIT_REVISION@`被替换为当前提交的短哈希值。
- en: When you work with preprocessor definitions, `configure_file` will replace any
    lines in the form of `#cmakedefine VAR ...` with either `#define VAR` or `/* undef
    VAR */`, depending on whether `VAR` contains a value that CMake interprets as
    `true` or `false`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用预处理器定义时，`configure_file`会将所有形如`#cmakedefine VAR ...`的行替换为`#define VAR`或`/*
    undef VAR */`，具体取决于`VAR`是否包含CMake解释为`true`或`false`的值。
- en: 'Consider a file called `version.in.h` that contains the following two lines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为`version.in.h`的文件，其中包含以下两行：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The accompanying `CMakeLists.txt` file might look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 附带的`CMakeLists.txt`文件可能如下所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the configuration has been run, if `GIT_REVISION_ENABLE` is on, the resulting
    file will contain the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置已运行，如果`GIT_REVISION_ENABLE`被启用，生成的文件将包含以下输出：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If `GIT_REVISION_ENABLE` is off, the resulting file will contain the following
    output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`GIT_REVISION_ENABLE`被禁用，生成的文件将包含以下输出：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All in all, the `configure_file` command is quite useful to prepare input for
    a build. Apart from generating source files, it is often used to generate CMake
    files that are then included in a `CMakeLists.txt` file. One of the strengths
    of this is that it allows you to copy and modify files independent of the platform,
    which is a major advantage when you’re working cross-platform. Since `configure_file`
    and `execute_process` often go hand in hand, ensure that the commands that are
    executed are also platform-independent.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，`configure_file`命令非常有用，可以为构建准备输入。除了生成源文件外，它常用于生成CMake文件，这些文件随后会被包含在`CMakeLists.txt`文件中。其优点之一是它允许你独立于平台复制和修改文件，这在跨平台工作时是一个重要的优势。由于`configure_file`和`execute_process`常常一起使用，因此确保执行的命令也是平台无关的。
- en: In the next section, you will learn how CMake can be used to define platform-agnostic
    commands and scripts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用CMake来定义平台无关的命令和脚本。
- en: Using CMake for platform-independent commands
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CMake进行平台无关命令
- en: One of the keystones for the success of CMake is that it allows you to build
    the same software on a multitude of platforms. Conversely, this means that `CMakeLists.txt`
    must be written in a way that does not assume a certain platform or compiler must
    be used. This can be challenging, especially when you’re working with custom tasks.
    A big help here is that the `cmake` command-line utility supports the `-E` flag,
    which can be used to perform common tasks such as file operations and creating
    hashes. Most of the `cmake -E` commands are for file-related operations such as
    creating, copying, renaming, and deleting files, as well as creating directories.
    On systems that support filesystem links, CMake can also create symbolic links
    or hard links between files. Since CMake version 3.21, most of them are also available
    by using the `file()` command, but not all of them. Notably, creating hashes from
    files can be done in a platform-independent way with `cmake –``E <alogrithm>`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CMake成功的一个关键因素是它允许你在多种平台上构建相同的软件。相反，这意味着`CMakeLists.txt`必须以不假设某个平台或编译器必须使用的方式编写。这可能会很具挑战性，特别是当你在处理自定义任务时。在这种情况下，`cmake`命令行工具提供的`-E`标志非常有帮助，它可以用于执行常见任务，例如文件操作和创建哈希。大多数`cmake
    -E`命令用于与文件相关的操作，如创建、复制、重命名和删除文件，以及创建目录。在支持文件系统链接的系统上，CMake还可以在文件之间创建符号链接或硬链接。自CMake版本3.21以来，大多数操作也可以通过使用`file()`命令来实现，但并非所有操作都可以。值得注意的是，创建哈希值时，可以使用`cmake
    –``E <algorithm>`以平台无关的方式进行。
- en: Additionally, CMake can create file archives using the `tar` command and concatenate
    text files with the `cat` command. It can also be used to create various hashes
    for files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CMake可以使用`tar`命令创建文件归档，并使用`cat`命令连接文本文件。它还可以用于为文件创建各种哈希值。
- en: There are also a few operations that provide information about the current system.
    The `capabilities` operation will print out CMake’s capabilities, such as knowing
    which generators are supported and the version that CMake is currently running.
    The `environment` command will print a list of environment variables that have
    been set.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些操作可以提供关于当前系统信息的信息。`capabilities`操作将打印出CMake的能力，例如了解支持的生成器和当前正在运行的CMake版本。`environment`命令将打印出已设置的环境变量列表。
- en: You can get a full reference to the command-line options by running `cmake -E`
    without any other arguments. The online documentation for CMake can be found at
    [https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool](https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行`cmake -E`而不带任何其他参数来获取命令行选项的完整参考。CMake的在线文档可以在[https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool](https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool)找到。
- en: Platform-agnostic file operations
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 平台无关的文件操作
- en: Whenever file operations must be performed by a custom task, use `cmake –``E`
    .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要通过自定义任务执行文件操作时，请使用`cmake –``E`。
- en: With `cmake -E`, you can get pretty far in most cases. Sometimes, however, more
    complex operations need to be done. For this, CMake can run in script mode, which
    executes CMake files.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cmake -E`，在大多数情况下可以做得相当远。但是，有时需要执行更复杂的操作。为此，CMake可以在脚本模式下运行，执行CMake文件。
- en: Executing CMake files as scripts
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行CMake文件作为脚本
- en: 'CMake’s script mode is a very powerful feature when it comes to creating cross-platform
    scripts. It’s powerful because it allows you to create scripts that are completely
    platform-agnostic. By invoking `cmake -P <script>.cmake`, a specified CMake file
    is executed. The script files may not contain any commands that define a build
    target. Arguments may be passed as variables with the `-D` flag, but this must
    be done before the `-P` option. Alternatively, the arguments may only be appended
    after the script name so that they can be retrieved with the `CMAKE_ARGV[n]` variables.
    The number of arguments is stored in the `CMAKE_ARGC` variable. The following
    script, which generates the hash of a file and stores it in another, demonstrates
    how to use positional arguments:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的脚本模式在创建跨平台脚本时非常强大。这是因为它允许您创建完全与平台无关的脚本。通过调用`cmake -P <script>.cmake`，执行指定的CMake文件。脚本文件可能不包含定义构建目标的任何命令。可以使用`-D`标志将参数作为变量传递，但必须在`-P`选项之前执行此操作。或者，参数仅可以在脚本名称之后追加，以便可以使用`CMAKE_ARGV[n]`变量检索它们。参数的数量存储在`CMAKE_ARGC`变量中。以下脚本演示了如何使用位置参数生成文件的哈希并将其存储在另一个文件中：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This script can be invoked with `cmake -P CreateSha256.cmake <input file> <output_file>`.
    Note that the first three arguments are occupied with `cmake`, `-P`, and the name
    of the script (`CreateSha256.cmake`). Although not strictly required, script files
    should always contain a `cmake_minimum_required` statement at the beginning. An
    alternative way to define the script without positional arguments would be as
    follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`cmake -P CreateSha256.cmake <input file> <output_file>`来调用此脚本。请注意，前三个参数被`cmake`，`-P`和脚本名称（`CreateSha256.cmake`）占用。虽然不是严格要求，但脚本文件应始终在开头包含`cmake_minimum_required`语句。定义脚本的另一种方式，而不使用位置参数，如下所示：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, the script would have to be invoked with the variables passed
    explicitly, like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，脚本必须通过显式传递变量来调用，如下所示：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These two approaches can also be combined. A common pattern is to expect all
    simple mandatory arguments as positional arguments and any optional or more complex
    arguments as defined variables. Combining script mode with `add_custom_command`,
    `add_custom_target`, or `execute_process` is a good way to create platform-independent
    build instructions. An example of generating hashes from the earlier sections
    could look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法也可以结合使用。一个常见的模式是将所有简单的强制参数作为位置参数来期望，并将任何可选或更复杂的参数作为定义的变量。将脚本模式与`add_custom_command`、`add_custom_target`或`execute_process`结合使用是创建跨平台无关的构建指令的好方法。从前面章节生成哈希的示例可能如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Combining the script mode of CMake with the various ways to execute custom commands
    during the configuration or build phase of a project provides a lot of freedom
    when you’re defining build processes, even for different platforms. However, beware
    that adding too much logic to a build process may make it harder to maintain it
    than it should be. Whenever you need to write a script or add a custom command
    to a `CMakeLists.txt` file, it pays to take a quick break and consider whether
    this step belongs to the build process, or whether it is something better left
    to the user when they’re setting up the development environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将CMake的脚本模式与在项目的配置或构建阶段执行自定义命令的各种方式结合使用，为您在定义构建过程时提供了很大的自由，甚至适用于不同的平台。然而，需注意的是，向构建过程中添加过多的逻辑可能会使其维护变得比预期更加困难。每当您需要编写脚本或向`CMakeLists.txt`文件中添加自定义命令时，最好先休息一下，考虑一下这一步是否属于构建过程，还是应该留给用户在设置开发环境时处理。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to customize a build by executing external
    tasks and programs. We covered how to add custom build actions as targets, how
    to add them to existing targets, and how to execute them during the configuration
    step. We explored how commands can generate files and how CMake can copy and modify
    files with the `configure_file` command. Finally, we learned how the CMake command-line
    utility can be used to perform tasks in a platform-independent manner.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何通过执行外部任务和程序来定制构建。我们介绍了如何将自定义构建操作作为目标添加，如何将它们添加到现有目标中，以及如何在配置步骤期间执行它们。我们探讨了如何通过命令生成文件，以及如何使用`configure_file`命令复制和修改文件。最后，我们学习了如何使用CMake命令行工具以平台无关的方式执行任务。
- en: The ability to customize a CMake build is a very powerful asset, but it also
    tends to make builds more brittle, as their complexity often increases when any
    customized tasks are performed. Although sometimes not avoidable, relying on external
    programs other than a compiler and linker being installed may mean that a piece
    of software can be built on a platform where those programs haven’t been installed
    or available. This means special care must be taken to ensure that custom tasks
    do not assume anything about the system using CMake if possible. Lastly, executing
    custom tasks may carry a performance penalty for a build system, especially if
    they do heavy work on each build.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 定制CMake构建的能力是一个非常强大的资产，但它也往往会使构建变得更加脆弱，因为当执行任何自定义任务时，构建的复杂性通常会增加。虽然有时不可避免，但依赖于除编译器和链接器之外的外部程序的安装可能意味着某些软件无法在未安装或不可用这些程序的平台上构建。这意味着，必须特别小心，确保自定义任务在可能的情况下不会假设使用CMake的系统有什么特定的配置。最后，执行自定义任务可能会对构建系统带来性能负担，尤其是当它们在每次构建时进行大量工作时。
- en: However, if you are careful with custom build steps, they are a great way of
    increasing the cohesion of a build, as many of the build-related tasks can be
    defined where the build definition is. This can make automating tasks such as
    creating hashes of the build artifacts or assembling all the documents in a common
    archive much easier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您小心处理自定义构建步骤，它们是增加构建凝聚力的一个很好的方式，因为许多与构建相关的任务可以在构建定义的位置进行定义。这可以使自动化任务（如创建构建产物的哈希值或将所有文档打包成一个公共档案）变得更加容易。
- en: In the next chapter, you will learn how to make the build environment portable
    between different systems. You will learn how to use presets to define common
    ways to configure a CMake project, how to wrap your build environment into a container,
    and how to use `sysroots` to define toolchains and libraries as being portable
    between systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使构建环境在不同系统之间具有可移植性。您将学习如何使用预设来定义配置CMake项目的常见方式，如何将您的构建环境打包到容器中，以及如何使用`sysroots`来定义工具链和库，以便它们在不同系统之间具有可移植性。
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试您对本章内容的掌握情况：
- en: What is the main difference between `add_custom_command` and `execute_process`?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add_custom_command`和`execute_process`之间的主要区别是什么？'
- en: What are the two signatures of `add_custom_command` used for?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add_custom_command`的两种签名分别用于什么？'
- en: What is the problem with the `PRE_BUILD`, `PRE_LINK`, and `POST_BUILD` options
    of `add_custom_command`?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add_custom_command`的`PRE_BUILD`、`PRE_LINK`和`POST_BUILD`选项有什么问题？'
- en: What are the two ways of defining variables so that they can be substituted
    with `configure_file`?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种方式可以定义变量，以便它们可以通过`configure_file`进行替换？
- en: How can the substitution behavior of `configure_file` be controlled?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何控制`configure_file`的替换行为？
- en: What are the two flags for the CMake command-line tool to execute tasks?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake命令行工具执行任务的两个标志是什么？
- en: Answers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The following are the answers to this chapter’s questions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章节问题的答案：
- en: Commands that are added with `add_custom_command` are executed at build time,
    while commands that are added with `execute_process` are executed at configuration
    time.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`add_custom_command`添加的命令在构建时执行，而使用`execute_process`添加的命令在配置时执行。
- en: One signature is used to create custom build steps, while the other is used
    to generate files.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个签名用于创建自定义构建步骤，而另一个用于生成文件。
- en: Only `POST_BUILD` is reliably supported across all generators.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有`POST_BUILD`在所有生成器中都可靠地得到支持。
- en: Variables can be defined either as `${VAR}` or `@VAR@`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以定义为`${VAR}`或`@VAR@`。
- en: Variable substitution can be controlled by either passing `@ONLY`, which only
    replaces variables defined as `@VAR@`, or by specifying the `COPYONLY` option,
    which does not perform any substitution at all.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量替换可以通过传递`@ONLY`来控制，这样只替换定义为`@VAR@`的变量，或者通过指定`COPYONLY`选项来控制，这样完全不执行任何替换。
- en: With `cmake -E`, common tasks can be executed directly. With `cmake -P`, `.cmake`
    files can be executed as scripts.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cmake -E`可以直接执行常见任务。使用`cmake -P`，`.cmake`文件可以作为脚本执行。
