- en: Chapter 5. Intelligent Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 智能音频
- en: Up to this point, we have played sounds in a very linear fashion; we load an
    audio file from a disk and play it when needed, optionally controlling some of
    its parameters during playback. Even when we used advanced features such as 3D
    audio, there was still a one-to-one relationship between the sound and the audio
    file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们以非常线性的方式播放声音；我们从磁盘加载音频文件，并在需要时播放它，可以在播放过程中控制一些参数。即使我们使用了高级功能，比如3D音频，声音和音频文件之间仍然是一对一的关系。
- en: However, a sound does not necessarily correspond to a single audio file. In
    many scenarios we can benefit from using multiple audio files for a single sound.
    For example, we can often reduce repetition by providing several variations of
    the same sound as separate audio files, or we can build complex soundscapes by
    combining several smaller sound fragments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个声音不一定对应一个单独的音频文件。在许多情况下，我们可以受益于为单个声音使用多个音频文件。例如，我们通常可以通过提供几种不同的声音变体作为单独的音频文件来减少重复，或者我们可以通过组合几个较小的声音片段来构建复杂的音景。
- en: For other sounds, the modifications we apply at runtime to their parameters
    are just as important as the audio files that compose them. For example, we cannot
    realistically simulate the sound of a car engine without constantly updating its
    pitch and volume based on the engine's rpm and load values. Another common example
    is to have a soundtrack dynamically react to the events in the game in order to
    convey more or less tension to the player.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他声音，我们在运行时应用到它们的参数的修改和构成它们的音频文件一样重要。例如，我们无法真实地模拟汽车引擎的声音，而不是根据发动机的转速和负载值不断更新其音调和音量。另一个常见的例子是，让配乐动态地对游戏中的事件做出反应，以向玩家传达更多或更少的紧张感。
- en: As programmers, we could certainly implement any of these features by writing
    specialized code for each situation, orchestrating each audio file and sound parameter
    as necessary. However, this approach takes a significant amount of effort, and
    is hard to manage and tweak, since most of the behavior gets hardcoded into the
    game. An even bigger problem is that it is usually a sound designer, not a programmer,
    which creates the sounds for a game, and using this approach would require a significant
    amount of communication and synchronization between both parties.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们当然可以通过为每种情况编写专门的代码来实现这些功能，根据需要编排每个音频文件和声音参数。然而，这种方法需要大量的工作量，而且很难管理和调整，因为大部分行为都是硬编码到游戏中的。更大的问题是，通常是声音设计师而不是程序员为游戏创建声音，使用这种方法需要双方之间大量的沟通和同步。
- en: Thankfully, we can solve this problem by using a high-level audio engine. These
    engines usually provide an external tool that the sound designer can use to create
    complex sounds, independently from a programmer, and store them as sound events.
    Then, regardless of the complexity of the sound, the programmer can easily trigger
    it from the game, usually by writing the name of the event.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过使用高级音频引擎来解决这个问题。这些引擎通常提供一个外部工具，声音设计师可以使用它来创建复杂的声音，独立于程序员，并将它们存储为声音事件。然后，无论声音的复杂性如何，程序员都可以轻松地从游戏中触发它，通常是通过编写事件的名称。
- en: The main difficulty in covering this topic is that there are several high-level
    audio engines available, and each of them has its own set of features and philosophy.
    Using these tools, we can perform things such as generative audio (generating
    audio at runtime from a set of sound samples and rules) or adaptive music (music
    that changes depending on game events). To simplify the terminology, we will be
    using the term intelligent audio to encompass all situations where a sound can
    have complex behavior attached to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖这个主题的主要困难在于有几个高级音频引擎可用，每个引擎都有自己的一套功能和理念。使用这些工具，我们可以执行诸如生成音频（根据一组声音样本和规则在运行时生成音频）或自适应音乐（根据游戏事件变化的音乐）等操作。为了简化术语，我们将使用智能音频这个术语来涵盖所有声音可以附加复杂行为的情况。
- en: In this chapter, we will work with the FMOD Designer tool and see some of the
    interesting stuff that we can do with it. A detailed coverage of the tool would
    be impossible given the limited scope of the book, but it should be enough to
    give you some ideas and to get you started. For more information, the FMOD Designer
    tool ships with a user manual that is over 400 pages long, and a sample project
    with many examples.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用FMOD Designer工具，并了解一些有趣的东西。由于本书的范围有限，详细介绍这个工具是不可能的，但这应该足够给你一些想法，并让你开始。有关更多信息，FMOD
    Designer工具附带了一个超过400页的用户手册和一个包含许多示例的示例项目。
- en: Audio files versus sound events
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频文件与声音事件
- en: 'Before installing the FMOD Designer tool, let us start by really understanding
    the difference between treating each audio file as a sound, and working at a higher
    level of abstraction with sound events (or sound cues in some engines). The following
    figure demonstrates how we have been approaching audio in our games so far:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装FMOD Designer工具之前，让我们真正理解将每个音频文件视为声音与以更高的抽象级别处理声音事件（或一些引擎中的声音提示）之间的区别。以下图表展示了迄今为止我们在游戏中处理音频的方式：
- en: '![Audio files versus sound events](img/9099OT_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![音频文件与声音事件](img/9099OT_05_01.jpg)'
- en: 'In this model, we can see that the game interacts directly with the audio files,
    and that the code is responsible for using these audio files in a way that is
    appropriate for the game, which usually requires the creation of specialized codes.
    When we move over to using a high-level audio engine such as the FMOD Designer,
    the process is significantly different, as we can see in the following figure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，我们可以看到游戏直接与音频文件交互，代码负责以适合游戏的方式使用这些音频文件，通常需要创建专门的代码。当我们转向使用FMOD Designer等高级音频引擎时，这个过程是完全不同的，如下图所示：
- en: '![Audio files versus sound events](img/9099OT_05_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![音频文件与声音事件](img/9099OT_05_02.jpg)'
- en: The first difference in this model is that the game does not interact directly
    with audio files. Instead, it interacts with entities known as sound events, which
    may contain multiple audio files, and encapsulate all of the custom behavior and
    parameters of the sound that were previously inside the game. This separation
    makes the game code a lot simpler, and provides a better environment for a sound
    designer to work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的第一个区别是游戏不直接与音频文件交互。相反，它与称为声音事件的实体交互，这些实体可能包含多个音频文件，并封装了以前在游戏中的所有自定义行为和参数的声音。这种分离使游戏代码变得简单得多，并为声音设计师提供了更好的工作环境。
- en: Notice also, that there is an audio project file that groups all sound events
    together. This means that the game only needs to load this single file to get
    access to all sound events, which is significantly easier than having to load
    every individual audio file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，有一个将所有声音事件组合在一起的音频项目文件。这意味着游戏只需要加载这一个文件就可以访问所有声音事件，这比加载每个单独的音频文件要容易得多。
- en: Introducing the FMOD Designer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍FMOD Designer
- en: 'The FMOD Designer is the high-level, data-driven API that complements the FMOD
    Ex low-level engine that we have been using so far. It contains two parts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD Designer是高级的、数据驱动的API，它补充了我们迄今为止使用的FMOD Ex低级引擎。它包含两个部分：
- en: '**FMOD Designer**: This is a sound designer tool that allows us to create complex
    sound events and interactive music for our games (from [http://www.fmod.org](http://www.fmod.org))'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMOD Designer**：这是一个声音设计师工具，允许我们为我们的游戏创建复杂的声音事件和交互式音乐（来自[http://www.fmod.org](http://www.fmod.org)）'
- en: '**FMOD Event System**: This is an application layer that lets us use the content
    created with the designer within our games (comes bundled with FMOD Ex, inside
    the `fmoddesignerapi` folder)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMOD事件系统**：这是一个应用层，让我们可以在游戏中使用设计师创建的内容（与FMOD Ex捆绑在一起，位于`fmoddesignerapi`文件夹内）'
- en: 'The FMOD Designer projects have the `.fdp` extension, but to use them inside
    of a game you must first build them from the **Project** menu. The build process
    generates a `.fev` file, containing all the information for every sound event
    in the project, and one `.fsb` file for each wave bank in the project, which is
    where the audio files are stored. The following is a screenshot of the FMOD Designer
    user interface:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD Designer项目的文件扩展名为`.fdp`，但要在游戏中使用它们，必须首先从**项目**菜单中构建它们。构建过程会生成一个`.fev`文件，其中包含项目中每个声音事件的所有信息，以及项目中每个波形库的一个`.fsb`文件，其中存储着音频文件。以下是FMOD
    Designer用户界面的截图：
- en: '![Introducing the FMOD Designer](img/9099OT_05_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![介绍FMOD Designer](img/9099OT_05_03.jpg)'
- en: 'The most important task of the FMOD Designer is to create sound events. There
    are two types of sound events in FMOD, and an interactive music system:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FMOD Designer最重要的任务是创建声音事件。在FMOD中有两种类型的声音事件，以及一个交互式音乐系统：
- en: '**Simple events**: With simple events, we can create sounds composed by multiple
    audio files, and play them randomly or sequentially, one or several at a time,
    at different rates, and with random volume or pitch variation'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单事件**：通过简单事件，我们可以创建由多个音频文件组成的声音，并以随机或顺序方式播放它们，一次或多次，以不同的速率，并具有随机的音量或音调变化'
- en: '**Multi-track events**: With multi-track events, we can combine as many simple
    events as we need (in this case called **sound defs**), organize them into layers,
    apply effects to them, control which sound defs should be playing at any given
    time, create custom parameters, and link those parameters to any of the properties
    of the sound or effects'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多轨事件**：通过多轨事件，我们可以组合我们需要的简单事件（在这种情况下称为**声音定义**），将它们组织成层，对它们应用效果，控制任何给定时间应该播放哪些声音定义，创建自定义参数，并将这些参数链接到声音或效果的任何属性'
- en: '**Interactive music**: With the interactive music system, we can create songs
    (called **cues**) composed by multiple segments, and have the game transition
    between them in response to certain events. Besides transitions, we can also add
    flourishes to the music, which play concurrently and synchronized with the main
    song'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式音乐**：通过交互式音乐系统，我们可以创建由多个片段组成的歌曲（称为**提示**），并使游戏在响应特定事件时在它们之间过渡。除了过渡，我们还可以向音乐中添加装饰，这些装饰与主歌同时播放并与之同步。'
- en: Over the next few sections, we will briefly cover the main features and user
    interface of the first two of these systems, as well as some ideas and examples
    of how to use them in the context of a game. Coverage of the topic of interactive
    music will have to be more superficial, because its breadth exceeds the scope
    of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将简要介绍这两个系统的主要特点和用户界面，以及一些如何在游戏环境中使用它们的想法和示例。由于交互式音乐的范围超出了本书的范围，因此对交互式音乐的讨论将更加肤浅。
- en: Simple events
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单事件
- en: 'Simple events are the easiest to use, as well as the least resource intensive.
    We should therefore try to use simple events whenever they are enough for our
    requirements. With a simple event, we can:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简单事件是最容易使用，也是最不占资源的。因此，我们应该尽量在满足我们要求的情况下使用简单事件。通过简单事件，我们可以：
- en: Create a sound composed by multiple audio files
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建由多个音频文件组成的声音
- en: Play audio files sequentially or in a random order
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序或随机顺序播放音频文件
- en: Randomize sound properties, such as volume or pitch
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机化声音属性，如音量或音调
- en: Control the looping behavior of the sound
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制声音的循环行为
- en: Play multiple audio files at once, or at certain intervals
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时播放多个音频文件，或在特定间隔播放
- en: 'To create a simple event, go to the **Events** section, right-click on top
    of any **Event Group**, and then select the **Add Simple Event** option. If there
    is no **Event Group** created, we can create one from the same context menu. Event
    groups behave like folders and serve to organize all of our events:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单事件，转到**事件**部分，在任何**事件组**上右键单击，然后选择**添加简单事件**选项。如果没有创建**事件组**，我们可以从同一上下文菜单中创建一个。事件组的行为类似于文件夹，用于组织我们所有的事件：
- en: '![Simple events](img/9099OT_05_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![简单事件](img/9099OT_05_04.jpg)'
- en: 'With the event selected, the next step is to add the audio files that compose
    it to the **Playlist** pane, either through the right-click context menu, or by
    dragging some audio files into it. If we intend to play the audio files in a random
    order, we can specify the probability of each file playing through the right-click
    context menu, or using the dial control at the bottom-left corner of the pane:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 选择事件后，下一步是将组成它的音频文件添加到**播放列表**窗格中，可以通过右键单击上下文菜单，或将一些音频文件拖放到其中。如果我们打算以随机顺序播放音频文件，可以通过右键单击上下文菜单或使用窗格左下角的旋钮控制指定每个文件播放的概率：
- en: '![Simple events](img/9099OT_05_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: （简单事件）（img/9099OT_05_05.jpg）
- en: 'On the **Playlist Options** pane, we can control how the audio engine should
    pick files from the playlist. There are three different **Playlist Behaviors**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在**播放列表选项**窗格中，我们可以控制音频引擎应该如何从播放列表中选择文件。有三种不同的**播放列表行为**：
- en: '**Random**: This option picks an audio file at random every time, following
    the weights attributed in the playlist to each of them. We can also select whether
    to allow the same audio file to play twice in a row.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机**：此选项每次随机选择一个音频文件，遵循播放列表中为每个文件分配的权重。我们还可以选择是否允许同一个音频文件连续播放两次。'
- en: '**Shuffle**: This option randomizes the playlist once, and then plays the audio
    files in that order.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机**：此选项随机播放播放列表一次，然后按照该顺序播放音频文件。'
- en: '**Sequential**: This option follows the same order in which the audio files
    appear in the playlist.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**：此选项按照音频文件在播放列表中出现的顺序进行播放。'
- en: 'Inside the **Playlist Options** pane, we can also find a **Sound Randomization**
    section, which lets us apply some variation to the starting volume and pitch of
    each file (similar to what we implemented ourselves back in [Chapter 3](ch03.html
    "Chapter 3. Audio Control"), *Audio Control*):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在**播放列表选项**窗格中，我们还可以找到**声音随机化**部分，它让我们可以对每个文件的起始音量和音调应用一些变化（类似于我们在[第3章](ch03.html
    "第3章。音频控制")中实现的内容，*音频控制*）：
- en: '![Simple events](img/9099OT_05_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: （简单事件）（img/9099OT_05_06.jpg）
- en: 'In the **Playback Options** pane, which controls how many audio files, should
    be played and how often, there are four different **Playback Modes**:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制应该播放多少音频文件以及多频率的**播放选项**窗格中，有四种不同的**播放模式**：
- en: '**Oneshot**: This mode picks a single audio file, and plays it only once'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**：此模式选择一个单一的音频文件，并仅播放一次'
- en: '**Repeating Loop**: This mode picks a single audio file, and plays it multiple
    times (with the number of times being controlled by the **Play Count** parameter)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复循环**：此模式选择一个单一的音频文件，并多次播放（由**播放计数**参数控制次数）'
- en: '**Successive Loop**: This mode plays multiple audio files in succession, picking
    a new one each time (with the number of files to play being controlled by the
    **Loop Count** parameter)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续循环**：此模式连续播放多个音频文件，每次选择一个新的（由**循环计数**参数控制要播放的文件数量）'
- en: '**Granular**: This mode is similar to the previous mode, but allows us to control
    the time to wait between each file that is played (**Grain Interval** parameter),
    how many files can be playing simultaneously (**Polyphony** parameter), and the
    total amount of files to play before the sound ends (**Total Grains** parameter)![Simple
    events](img/9099OT_05_07.jpg)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颗粒状：这种模式类似于上一个模式，但允许我们控制每个播放的文件之间等待的时间（Grain Interval参数），可以同时播放多少个文件（Polyphony参数），以及在声音结束之前要播放的文件总数（Total
    Grains参数）！（简单事件）（img/9099OT_05_07.jpg）
- en: Finally, there is the **Properties** pane on the right side of the interface,
    which allows us to control several other properties of the sound event, such as
    most of the 3D audio properties discussed on the previous chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，界面右侧有一个**属性**窗格，它允许我们控制声音事件的其他几个属性，例如前一章讨论的大多数3D音频属性。
- en: Examples of simple events
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单事件示例
- en: Here are some ideas of how we can use simple events to enrich the audio in our
    games. Most of these ideas can be found on the examples project that comes with
    the FMOD Designer, so be sure to look there too.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我们可以使用简单事件丰富游戏中音频的想法。这些想法大多可以在FMOD Designer附带的示例项目中找到，所以一定要在那里查找。
- en: Avoiding repetitive sound effects
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免重复的音效
- en: Most games have a few sound effects that are played all the time, such as the
    sound of a character's footsteps, or the sound of a gun. If we use the exact same
    audio file every time, the player will usually notice the repetition after some
    time, which is undesirable in most cases. Using simple events, we can easily make
    these sound effects more interesting and dynamic, just by providing a few variations
    of the sound and letting the audio engine pick one randomly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都有一些声音效果会一直播放，比如角色的脚步声或枪声。如果每次都使用完全相同的音频文件，玩家通常会在一段时间后注意到重复，这在大多数情况下是不希望的。使用简单事件，我们可以通过提供一些声音的变化并让音频引擎随机选择一个来轻松地使这些声音效果更有趣和动态。
- en: Adding a very small volume and pitch variation to the sound can also do wonders,
    as long as the variation is not large enough to change the overall nature of the
    sound. Values along the lines of `-3` dB for the volume and `+/- 2` semitones
    for the pitch are usually good starting points.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对声音进行微小的音量和音调变化也可以奇迹般地产生效果，只要变化不足以改变声音的整体特性。音量方面的值通常在-3 dB左右，音调方面的值通常在+/- 2个半音左右。
- en: Creating a footsteps sound loop
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建脚步声循环
- en: There are several ways we can use a footsteps sound effect in a game. For example,
    we could have an audio file containing the sound of a single footstep, and trigger
    it once for every step the character takes inside the game world, or we could
    have a looping audio file with a walking sound, and play it constantly whenever
    the character is walking.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种方式在游戏中使用脚步声效。例如，我们可以有一个包含单个脚步声音的音频文件，并在游戏世界中角色每走一步时触发它一次，或者我们可以有一个循环播放的行走声音的音频文件，并在角色行走时不断播放。
- en: The first approach requires more work inside the game, while the second approach
    takes more memory, as the audio file needs to be longer. Using a simple event,
    we can combine both approaches, by taking an audio file of a single footstep,
    and setting up the event so that it performs the looping, using time intervals
    that are appropriate for a certain walking speed. Later, when working with multi-track
    events, we will also see a way to vary the walking speed dynamically.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法需要在游戏内进行更多的工作，而第二种方法需要更多的内存，因为音频文件需要更长。使用简单事件，我们可以结合两种方法，通过使用单个脚步的音频文件，并设置事件以执行循环，使用适合特定行走速度的时间间隔。稍后，在处理多轨事件时，我们还将看到一种动态变化行走速度的方法。
- en: We start by creating a simple event with the footstep audio files (following
    the advices given earlier in order to avoid repetition) and set the playback mode
    to granular. Then we adjust the grain interval so that the time between each footstep
    corresponds to the speed of the character walking, and increase the polyphony
    so that each footstep can sound without having to wait for the previous to end.
    We can also set slightly different maximum and minimum grain interval values,
    to reinforce the variations of the sound even further.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个简单的事件，使用脚步声音文件（遵循之前给出的建议以避免重复），并将播放模式设置为颗粒化。然后我们调整颗粒间隔，使每个脚步之间的时间与角色行走的速度相对应，并增加多音，以便每个脚步都可以发出声音，而不必等待前一个结束。我们还可以设置略有不同的最大和最小颗粒间隔值，以进一步增强声音的变化。
- en: Creating a breaking glass sound effect
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建玻璃破碎声音效果
- en: Another approach we can use to reduce repetition in our sound effects is to
    generate them at runtime as a combination of a few smaller sound fragments. For
    example, to simulate the sound of a glass object falling to the ground and shattering,
    we could have a pool of different glass breaking sounds, and always play two or
    three of them in quick succession. Combined with the usual volume and pitch variations,
    the result is a sound effect that will sound different most of the time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一种方法来减少声音效果中的重复，即在运行时将它们生成为几个较小的声音片段的组合。例如，为了模拟玻璃物体掉落并破碎的声音，我们可以有一个不同的玻璃破碎声音池，并且总是快速连续地播放其中的两三个声音。结合通常的音量和音调变化，结果是一个大部分时间听起来不同的声音效果。
- en: To implement this type of sound effect, we need to use the granular playback
    mode, and set both the polyphony and the grain count parameters to the number
    of sound fragments that we want to use at once. For the breaking glass sound effect,
    we could set the polyphony and grain count to 2 or 3, and set a very small grain
    interval (for example, 200 ms), so that the sounds play almost at the same time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种类型的声音效果，我们需要使用颗粒化播放模式，并将多音和颗粒计数参数设置为我们想要同时使用的声音片段数量。对于玻璃破碎声音效果，我们可以将多音和颗粒计数设置为2或3，并设置一个非常小的颗粒间隔（例如200毫秒），以便声音几乎同时播放。
- en: Creating an ambient track of singing birds
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建鸟鸣环境音轨
- en: The same technique used to generate the sound of a glass breaking can also generate
    long, looping, and ever changing, ambient tracks. A common example is to take
    a few small audio files of birds singing, and by triggering them randomly at different
    times, and with different volume and pitch, we can easily give the impression
    of being in a forest, where there are several different birds singing. The process
    is very similar to the previous effect, except that this time we should set a
    large polyphony (such as 15), a grain interval value of around 1s, and an infinite
    grain count so that the sound does not stop playing. Modifying the 3D position
    randomization properties can also be useful to create a volumetric sound, and
    give the impression that every bird is located in a different point in space,
    instead of every sound coming from the same spot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成玻璃破碎声音的相同技术也可以生成长时间、循环且不断变化的环境音轨。一个常见的例子是取几个小的鸟鸣音频文件，通过在不同时间随机触发它们，并以不同的音量和音调，我们可以轻松地给人一种在森林中的印象，那里有几只不同的鸟在歌唱。该过程与之前的效果非常相似，只是这次我们应该设置一个大的多音（例如15），大约1秒的颗粒间隔值，以及一个无限的颗粒计数，以便声音不会停止播放。修改3D位置随机化属性也可以用来创建体积感的声音，并给人一种每只鸟都位于空间中的不同点的印象，而不是每个声音都来自同一个位置。
- en: Multi-track events
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多轨事件
- en: 'Multi-track events are significantly more powerful than simple events. In fact,
    before adding any sound to a multi-track event, we must turn it into a sound def,
    which has almost the same functionality as a simple event. With a multi-track
    event, we can:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 多轨事件比简单事件更强大。事实上，在向多轨事件添加任何声音之前，我们必须将其转换为声音定义，它几乎具有与简单事件相同的功能。使用多轨事件，我们可以：
- en: Perform everything that we could with a simple event
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行我们可以用简单事件完成的一切
- en: Create multiple layers of sounds that play at the same time
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多层声音，同时播放
- en: Apply one or more DSP effects to each layer
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个层应用一个或多个DSP效果
- en: Create custom parameters to modify the sound in real-time
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义参数以实时修改声音
- en: Play different sounds depending on the value of a parameter
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据参数值播放不同的声音
- en: Modify any of the sound or effect properties from a parameter
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过参数修改任何声音或效果属性
- en: 'Before creating a multi-track event, we must prepare a sound def for each of
    the sounds that we intend to use. The process is similar to creating a simple
    event, although the interface is a bit different. Head over to the **Sound Defs**
    section, right-click on top of any folder, and select one of the **Add sound def**
    options:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建多轨事件之前，我们必须为我们打算使用的每个声音准备一个声音定义。该过程类似于创建简单事件，尽管界面有些不同。转到**声音定义**部分，在任何文件夹上右键单击，并选择**添加声音定义**选项之一：
- en: '![Multi-track events](img/9099OT_05_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_08.jpg)'
- en: 'The interface used to create a sound def is a bit like a condensed version
    of the simple event interface, with the playlist on the left, and every other
    property on the right. Since most of the properties control something that we
    have already seen in simple events, there is no need to repeat that information
    here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建声音定义的界面有点像简单事件界面的简化版本，左侧是播放列表，右侧是其他所有属性。由于大多数属性控制的是我们已经在简单事件中看到的内容，因此在这里不需要重复这些信息：
- en: '![Multi-track events](img/9099OT_05_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_09.jpg)'
- en: 'To create a multi-track event, follow the same steps used to create a simple
    event, but select the **Add Multi-Track Event** option instead:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多轨事件，请按照创建简单事件的相同步骤，但选择**添加多轨事件**选项。
- en: '![Multi-track events](img/9099OT_05_10.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_10.jpg)'
- en: 'A multi-track event is divided into layers, or tracks, with each layer being
    able to contain multiple sound defs. Adding a new layer, or adding sound to a
    layer, are both handled by right-clicking on the following interface and selecting
    the **Add layer** or **Add sound** option from the context menu:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 多轨事件分为层或轨道，每个层可以包含多个声音定义。通过右键单击以下界面并从上下文菜单中选择**添加层**或**添加声音**选项来添加新层或向层添加声音：
- en: '![Multi-track events](img/9099OT_05_11.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_11.jpg)'
- en: 'By default, the preceding example will play all three sound defs at the same
    time. This behavior changes as soon as we add a parameter to the sound, which
    can be done by right-clicking on the dark area on top of the sounds region, and
    selecting the **Add parameter** option from the list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，前面的示例将同时播放所有三个声音定义。只要我们在声音上添加参数，这种行为就会改变，可以通过右键单击声音区域顶部的黑暗区域，并从列表中选择**添加参数**选项来完成：
- en: '![Multi-track events](img/9099OT_05_12.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_12.jpg)'
- en: A parameter is essentially a variable with a certain range of permitted values
    that the game code can modify. The way the FMOD Designer represents parameters
    might look like a timeline, but it is important to understand that a parameter
    is a generic value, and does not necessarily represent time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 参数本质上是一个具有一定范围允许值的变量，游戏代码可以修改。FMOD Designer表示参数的方式可能看起来像时间轴，但重要的是要理解参数是一个通用值，并不一定代表时间。
- en: 'The first parameter we create is marked as the **primary** parameter, and it
    determines which sounds to play. In the following example, only the two sounds
    that are in contact with the red line (representing the current value of the **primary**
    parameter) will be playing. Changing the value of the parameter to any value above
    0.5 would replace the **Frogs** sound with the **Crickets** sound. We can create
    multiple parameters in the same event, although only one of them will be marked
    as primary:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个参数标记为**主要**参数，并确定要播放哪些声音。在下面的示例中，只有与红线（代表**主要**参数的当前值）接触的两个声音将会播放。将参数的值更改为大于0.5的任何值将用**蛙鸣**声替换**蟋蟀**声。我们可以在同一个事件中创建多个参数，尽管其中只有一个会被标记为主要：
- en: '![Multi-track events](img/9099OT_05_13.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_13.jpg)'
- en: 'Another use of parameters is to control the sound properties of each layer.
    In order to do that, we must first add an effect to the layer we want to control,
    by right-clicking on the layer, and selecting the **Add effect** option. Effects
    can vary from a simple volume or pitch control, to more complex DSP effects, such
    as a distortion or a delay:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的另一个用途是控制每个层的声音属性。为了做到这一点，我们必须首先通过右键单击层并选择**添加效果**选项来向要控制的层添加效果。效果可以从简单的音量或音高控制到更复杂的DSP效果，如失真或延迟：
- en: '![Multi-track events](img/9099OT_05_14.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_14.jpg)'
- en: 'Having an effect added to a layer, and a parameter selected, we can draw curves
    on the layer, which represent how the properties of the effect should vary with
    the values of the parameter. In the following example, we have added a second
    parameter to the event, which modifies the pitch of the first layer, and the volume
    of the second layer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在层上添加效果并选择参数后，我们可以在层上绘制曲线，表示效果的属性应该随参数值的变化而变化。在下面的示例中，我们向事件添加了第二个参数，它修改了第一层的音高和第二层的音量：
- en: '![Multi-track events](img/9099OT_05_15.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_15.jpg)'
- en: 'Finally, by right-clicking on any sound inside a multi-track event, we can
    access some sound instance properties that are not available elsewhere. Among
    those properties, there is an auto pitch feature, which behaves like adding a
    pitch effect to that sound, and controlling it based on a parameter, but is simpler
    to use. This feature is useful when trying to simulate the sound of a car engine:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过右键单击多轨事件中的任何声音，我们可以访问一些其他地方无法使用的声音实例属性。在这些属性中，有一个自动音高特性，它的行为类似于向该声音添加音高效果，并根据参数进行控制，但使用起来更简单。当尝试模拟汽车引擎的声音时，这个特性非常有用：
- en: '![Multi-track events](img/9099OT_05_16.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![多轨事件](img/9099OT_05_16.jpg)'
- en: Examples of multi-track events
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多轨事件的示例
- en: Here are some ideas of how we can use multi-track events to provide a more interactive
    and dynamic game audio experience in our games. Many of these ideas build upon
    the ones discussed earlier for simple events.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何在游戏中提供更具交互性和动态性的游戏音频体验的多轨事件的想法。其中许多想法是基于之前讨论的简单事件的想法。
- en: Creating an interactive footsteps sound loop
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建交互式的脚步声音循环
- en: One of the simple event examples from the previous section described how to
    generate a looping footsteps sound. However, that sound was only useful for a
    specific walking speed, and for a specific surface. Using multi-track events,
    we can create a single sound event that contains footstep sounds for all different
    types of surfaces, such as grass, concrete, or sand, and allow the game to control
    the walking speed through a parameter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的简单事件示例中，描述了如何生成循环的脚步声音。然而，该声音仅适用于特定的行走速度和特定的地面。使用多轨事件，我们可以创建一个单一的声音事件，其中包含所有不同类型地面的脚步声音，比如草地、混凝土或沙地，并允许游戏通过参数来控制行走速度。
- en: In order to do this, we must first create a sound def for each type of surface
    the character can walk on. Each sound def should play a footsteps sound loop at
    the average walking speed, which we can control with the spawn rate parameter
    (this speed should be consistent between each sound def).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先必须为角色可以行走的每种地面类型创建一个声音定义。每个声音定义应该以平均行走速度播放脚步声音循环，我们可以通过生成速率参数来控制这个速度（这个速度应该在每个声音定义之间保持一致）。
- en: Then, we must create a multi-track event with a single layer, and two parameters
    to control the surface type (primary) and the walking speed. By adding all the
    sounds to this layer, distributing them evenly (by right-clicking and selecting
    the **Layout sounds evenly** option), and setting the maximum range of the `surface
    type` parameter to be the total number of sounds in the layer, we can use that
    parameter as a simple index to select which surface the character is walking on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建一个多轨事件，其中包含一个图层和两个参数来控制地面类型（主要）和行走速度。通过将所有声音添加到这个图层中，均匀分布它们（通过右键单击并选择**均匀布局声音**选项），并将`surface
    type`参数的最大范围设置为图层中声音的总数，我们可以使用该参数作为简单的索引来选择角色所行走的地面类型。
- en: For the `walking speed` parameter, we need to add an effect of type `Spawn Intensity`
    to the layer, and draw a curve to control how the spawn intensity relates to the
    `walking speed` parameter. For example, a value of 0.5 means that the footsteps
    will occur at half the average speed, while a value of 2.0 means that footsteps
    will occur at twice the average speed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`walking speed`参数，我们需要向图层添加一个`Spawn Intensity`类型的效果，并绘制一条曲线来控制生成强度与`walking
    speed`参数的关系。例如，数值为0.5意味着脚步声将以平均速度的一半发生，而数值为2.0意味着脚步声将以平均速度的两倍发生。
- en: Simulating the sound of a car engine
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟汽车引擎的声音
- en: We can also use multi-track events to generate complex interactive sounds, such
    as the sound of a car engine. The FMOD Designer examples project has a great car
    engine simulation that we can study. That sound event has two layers, and two
    parameters, one for the engine's rpm, and one for the engine's load.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用多轨事件来生成复杂的交互声音，比如汽车引擎的声音。FMOD Designer示例项目中有一个很棒的汽车引擎模拟，我们可以学习。该声音事件有两个图层和两个参数，一个用于引擎的转速，另一个用于引擎的负载。
- en: Each of the layers contains four different sounds, recorded from a car engine
    at different rpm ranges. The sounds on the top layer correspond to the car accelerating
    (on-load), while the sounds on the bottom layer correspond to the car decelerating
    (off-load).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图层包含四种不同的声音，这些声音是从汽车引擎在不同转速范围内录制的。顶层的声音对应汽车加速（负载），而底层的声音对应汽车减速（卸载）。
- en: The `load` parameter serves to blend between both layers at runtime with a volume
    effect. When the `load` parameter is in the middle, we hear a mix of both layers,
    but as the `load` parameter changes, the volumes quickly change so that we only
    hear one of the layers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`参数用于在运行时混合两个图层，并产生音量效果。当`load`参数处于中间时，我们听到两个图层的混合声音，但随着`load`参数的变化，音量迅速变化，以至于我们只听到其中一个图层的声音。'
- en: 'The `rpm` parameter serves two purposes. As the primary parameter, it determines
    which of the four sounds should be playing for the current value. The sounds actually
    overlap at the edges, so at certain rpm values, we can hear a mix of two sounds
    at once. The other purpose of the `rpm` parameter is to modify the pitch of the
    sound, so that higher the rpm value, the higher is the pitch of the sound. This
    is handled automatically by enabling the **auto-pitch** feature on each of the
    sounds:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpm`参数有两个作用。作为主要参数，它确定当前数值应该播放哪四种声音中的哪一种。实际上，这些声音在边缘处重叠，因此在某些转速数值下，我们可以同时听到两种声音的混合。`rpm`参数的另一个作用是修改声音的音调，因此转速数值越高，声音的音调就越高。这是通过在每个声音上启用**自动音调**功能来自动处理的：'
- en: '![Simulating the sound of a car engine](img/9099OT_05_17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![模拟汽车引擎的声音](img/9099OT_05_17.jpg)'
- en: Creating a complex ambient track of a forest
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个复杂的森林环境音轨
- en: Using a simple event, we were able to create a looping ambient track with a
    large number of singing birds. Using a multi-track event, we can easily extend
    the ambient track to contain other layer of sounds. For example, we could add
    a layer with the sound of the wind looping in the background, and layers for other
    types of animal cries, probably occurring at different rates than the bird sounds.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个简单的事件，我们能够创建一个循环的环境音轨，其中有大量的鸟鸣声。使用多轨事件，我们可以轻松地扩展环境音轨，以包含其他声音图层。例如，我们可以添加一个包含背景中风声循环的声音图层，以及其他类型动物的叫声图层，这些叫声可能以不同的速率发生，与鸟鸣声不同。
- en: If we wanted to simulate a cave within the forest, we could create a parameter
    to control the location of the character, and add an occlusion effect to every
    layer that is only active for a certain range of values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在森林中模拟一个洞穴，我们可以创建一个参数来控制角色的位置，并为每个图层添加一个遮蔽效果，该效果仅在一定数值范围内有效。
- en: Additionally, we could create a parameter to specify the time of the day, and
    play different sounds depending on its value, such as removing the sounds of the
    birds at night, and bringing some cricket sounds in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以创建一个参数来指定一天中的时间，并根据其数值播放不同的声音，比如在夜晚消除鸟鸣声，并加入一些蟋蟀的声音。
- en: Interactive music
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互音乐
- en: In the same way that we can create complex sound effects that change depending
    on the events of the game, it is also possible to do the same for the game's background
    music. This allows the music to adapt to the circumstances, for example, to convey
    the correct emotion for the moment, or provide a sense of tension when danger
    draws near.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以创建根据游戏事件而改变的复杂音效一样，也可以对游戏的背景音乐做同样的事情。这使得音乐可以适应环境，例如，在危险临近时传达正确的情感，或者提供紧张感。
- en: Music that is played in a non-linear fashion like this is known as interactive
    music (if the player directly controls the changes) or adaptive music (if the
    music reacts to the game environment, but not necessarily to the player). There
    are two main approaches to creating interactive music.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种非线性方式播放的音乐被称为交互式音乐（如果玩家直接控制变化）或自适应音乐（如果音乐对游戏环境做出反应，但不一定对玩家做出反应）。创建交互式音乐有两种主要方法。
- en: The vertical approach (re-orchestration)
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直方法（重新编排）
- en: In this approach, the audio system modifies the mix of the song in real-time
    depending on events occurring in the game. This can consist, for example, of adding
    new instruments to the song, or making the music play faster or slower to match
    the gameplay.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，音频系统根据游戏中发生的事件实时修改歌曲的混音。例如，可以向歌曲添加新乐器，或者使音乐播放速度更快或更慢以匹配游戏玩法。
- en: The easiest way to implement this type of interactive music in the FMOD Designer
    is by using multi-track events in combination with specially prepared multi-channel
    audio files (which we can create using audio editing software, such as Audacity).
    This usually requires splitting up the music into layers, and adding each of the
    layers to a different audio channel in the file. Then, using the Channel Mix effect
    on a multi-track event, we can easily control the individual volumes of each audio
    channel based on the value of a parameter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在FMOD Designer中实现这种类型的交互式音乐最简单的方法是使用多轨事件结合特别准备的多声道音频文件（可以使用Audacity等音频编辑软件创建）。这通常需要将音乐分成层，并将每个层添加到文件中的不同音频通道中。然后，使用多轨事件上的通道混音效果，我们可以根据参数的值轻松控制每个音频通道的音量。
- en: 'The most common application of this technique is to create a `tension` or `excitement`
    parameter, so that the song gets more intense (by adding more layers) as the value
    increases. The famous Japanese composer, Koji Kondo, is very fond of creating
    interactive music using this approach. Some recent examples include:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术最常见的应用是创建“紧张”或“兴奋”参数，使得随着数值的增加，歌曲变得更加紧张（通过添加更多层）。著名的日本作曲家近藤浩治非常喜欢使用这种方法创建交互式音乐。一些最近的例子包括：
- en: On the Super Mario Galaxy levels where Mario rides on top of a star ball, the
    speed at which Mario moves completely determines the pitch, playback rate, and
    even the amount of instruments playing in the song.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《超级马里奥银河》的关卡中，马里奥站在星球上移动的速度完全决定了歌曲的音调、播放速度，甚至演奏的乐器数量。
- en: 'On the market area of The Legend of Zelda: Skyward Sword, each merchant has
    its own variation of the market theme. As the link approaches one of the merchants,
    the music changes very smoothly into the corresponding variation (while retaining
    the correct relative positioning within the theme).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《塞尔达传说：天空之剑》的市场区域，每个商人都有自己的市场主题变化。当林克接近其中一个商人时，音乐会非常平稳地转换为相应的变化（同时保持正确的主题内相对定位）。
- en: The horizontal approach (re-sequencing)
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水平方法（重新排列）
- en: In this approach, the music moves or jumps between different sections depending
    on the events of the game. This usually requires splitting the music into segments,
    so that the game can transition between them. When the system is not transitioning
    between segments, it keeps looping the current segment, and the music continues
    playing indefinitely.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，音乐根据游戏事件移动或跳转到不同的部分。这通常需要将音乐分成段，以便游戏可以在它们之间进行过渡。当系统不在段之间过渡时，它会保持当前段的循环，音乐会持续播放。
- en: Information about the tempo and time signature of the music is frequently required,
    so that the audio system can synchronize transitions to beats or measures of the
    song to provide a more musical experience. The interactive music system in the
    FMOD Designer is capable of creating interactive music sequences in this fashion.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要音乐的速度和拍子信息，以便音频系统可以将过渡与歌曲的节拍或小节同步，以提供更加音乐化的体验。FMOD Designer中的交互式音乐系统能够以这种方式创建交互式音乐序列。
- en: A classic example of interactive music using the horizontal approach is the
    song, *A pirate I was meant to be*, in *Monkey Island 3*, where the player can
    actually select, in real-time, what verse of the song the characters will sing
    next. The song waits in a loop while the player makes his choice, and transitions
    gracefully afterwards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用水平方法创建交互式音乐的经典例子是《猴岛传奇3》中的歌曲《我是个海盗》，玩家实际上可以实时选择角色接下来要唱的歌词。歌曲在玩家做出选择时等待循环，并在之后平稳过渡。
- en: Calling sound events from the game code
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从游戏代码中调用声音事件
- en: In order to test our FMOD Designer project in a game, we must first build the
    project, by selecting the **Build from the Project** menu, or pressing *Ctrl*
    + *B*. This process will generate the `fev` and `fsb` files that we have to copy
    to our game assets folder.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏中测试我们的FMOD Designer项目，我们必须首先构建项目，通过选择“从项目构建”菜单或按下Ctrl + B。这个过程将生成我们必须复制到游戏资产文件夹中的fev和fsb文件。
- en: 'Next, we have to add some extra dependencies to our C++ project, so that we
    can interact with the FMOD Designer API. These dependencies ship together with
    the FMOD Ex Programmer''s API, but we must add the references ourselves, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须向我们的C++项目添加一些额外的依赖项，以便与FMOD Designer API进行交互。这些依赖项与FMOD Ex程序员API一起提供，但我们必须自己添加引用，如下所示：
- en: Navigate to **C/C++** | **General**, and add `C:\FMOD\ fmoddesignerapi\api\inc`
    to the list of **Additional Include Directories** (entries are separated by semicolons).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**C/C++** | **常规**，并将`C:\FMOD\ fmoddesignerapi\api\inc`添加到**附加包含目录**列表中（条目用分号分隔）。
- en: Navigate to **Linker** | **General**, and add `C:\FMOD\ fmoddesignerapi\api\lib`
    to the list of **Additional Library Directories**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**链接器** | **常规**，并将`C:\FMOD\ fmoddesignerapi\api\lib`添加到**附加库目录**列表中。
- en: Navigate to **Linker** | **Input**, and add `fmod_event.lib` to the list of
    **Additional Dependencies**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**链接器** | **输入**，并将`fmod_event.lib`添加到**附加依赖项**列表中。
- en: Navigate to **Build Events** | **Post-Build Event**, and add `xcopy /y "C:\FMOD\fmoddesignerapi\api\fmod_event.dll”
    "$(OutDir)”` to the **Command Line** list.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**构建事件** | **后期构建事件**，并将`xcopy /y "C:\FMOD\fmoddesignerapi\api\fmod_event.dll”
    "$(OutDir)”`添加到**命令行**列表中。
- en: Include the `<fmod_event.hpp>` header file from your code.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的代码中包含`<fmod_event.hpp>`头文件。
- en: Finally, the process of loading an FMOD Designer project, playing a sound event,
    and modifying some of its parameters, is in many ways similar to what we saw in
    [Chapter 2](ch02.html "Chapter 2. Audio Playback"), *Audio Playback*. Let us take
    a look at the most basic way to do it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加载FMOD Designer项目，播放声音事件，并修改一些参数的过程，在很多方面与我们在[第2章](ch02.html "第2章。音频播放")中看到的*音频播放*类似。让我们看看最基本的做法。
- en: 'First, we must create and initialize an `FMOD::EventSystem` object, and load
    the project file. We should also call the `update()` method in every frame, and
    the `release()` method at the end of the game:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建和初始化一个`FMOD::EventSystem`对象，并加载项目文件。我们还应该在每一帧调用`update()`方法，并在游戏结束时调用`release()`方法：
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to play an event, we must get a reference to it, by using the fully
    qualified name of the event, which contains the project name, the name of the
    event group that contains the event, and the name of the event itself. Then, we
    can simply use the `start()` method to play the event:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了播放一个事件，我们必须通过事件的完全限定名称来获取对它的引用，其中包含项目名称、包含事件的事件组的名称和事件本身的名称。然后，我们可以简单地使用`start()`方法来播放事件：
- en: '[PRE1]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, if there is a parameter that we want to modify, we can get a reference
    to it using the `getParameter()` method of the event object, and change the value
    using the `setValue()` method of the parameter object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果有一个我们想要修改的参数，我们可以使用事件对象的`getParameter()`方法获取对它的引用，并使用参数对象的`setValue()`方法更改值：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how a sound can be a lot more than just an audio
    file, how FMOD has a high-level tool called the FMOD Designer, how we can create
    simple and multi-track sound events in the FMOD Designer, how we can also apply
    some of these concepts to music and play sound events created in the FMOD Designer
    from our applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了声音可以不仅仅是一个音频文件，FMOD有一个名为FMOD Designer的高级工具，我们可以在FMOD Designer中创建简单和多轨声音事件，我们还可以将一些概念应用到音乐中，并从我们的应用程序中播放在FMOD
    Designer中创建的声音事件。
