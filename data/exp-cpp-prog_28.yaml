- en: Utility Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用类
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Converting between different time units using `std::ratio`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::ratio`在不同时间单位之间转换
- en: Converting between absolute and relative times with `std::chrono`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::chrono`在绝对时间和相对时间之间进行转换
- en: Safely signalizing failure with `std::optional`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::optional`安全地标记失败
- en: Applying functions on tuples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在元组上应用函数
- en: Quickly composing data structures with `std::tuple`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::tuple`快速组合数据结构
- en: Replacing `void*` with `std::any` for more type safety
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::any`替换`void*`以获得更多类型安全性
- en: Storing different types with `std::variant`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::variant`存储不同类型
- en: Automatically handling resources with `std::unique_ptr`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unique_ptr`自动处理资源
- en: Automatically handling shared heap memory with `std::shared_ptr`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::shared_ptr`自动处理共享堆内存
- en: Dealing with weak pointers to shared objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理指向共享对象的弱指针
- en: Simplifying resource handling of legacy APIs with smart pointers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化智能指针处理遗留API的资源处理
- en: Sharing different member values of the same object
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享同一对象的不同成员值
- en: Generating random numbers and choosing the right random number engine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数并选择正确的随机数引擎
- en: Generating random numbers and letting the STL shape specific distributions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数并让STL形成特定分布
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter is dedicated to utility classes that are very useful for solving
    very specific tasks. Some of them are indeed so useful that we will most probably
    see them extremely often in any C++ program snippet in the future or have at least
    already seen them sprinkled over all other chapters in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍了对解决特定任务非常有用的实用类。其中一些确实非常有用，以至于我们很可能在将来的任何C++程序片段中经常看到它们，或者至少已经在本书的所有其他章节中看到它们。
- en: The first two recipes are about measuring and taking the *time*. We will also
    see how to convert between different time units and how to jump between points
    in time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个配方是关于测量和获取*时间*的。我们还将看到如何在不同时间单位之间转换以及如何在时间点之间跳转。
- en: Then, we will have a look at the `optional`, `variant`, and `any` types (which
    all came with C++14 and C++17) as well as some `tuple` tricks in another five
    recipes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将研究`optional`、`variant`和`any`类型（这些类型都是C++14和C++17中引入的），以及另外五个配方中的一些`tuple`技巧。
- en: Since C++11, we also got sophisticated smart pointer types, namely `unique_ptr`,
    `shared_ptr`, and `weak_ptr`, which are an enormously effective help regarding
    *memory management*, which is why we will have a dedicated look at them in five
    recipes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，我们还获得了复杂的智能指针类型，即`unique_ptr`、`shared_ptr`和`weak_ptr`，它们在*内存管理*方面提供了极大的帮助，这就是为什么我们将专门介绍它们的五个配方。
- en: Finally, we will have a panoramic view of the library parts of the STL that
    are about generating *random numbers*. Apart from learning about the most important
    characteristics of the STL's random engines, we will also learn how to apply shaping
    to random numbers in order to get distributions that fit our actual needs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将全面了解STL库中与生成*随机数*有关的部分。除了学习STL随机引擎的最重要特性外，我们还将学习如何对随机数应用形状，以获得符合我们实际需求的分布。
- en: Converting between different time units using std::ratio
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::ratio在不同时间单位之间转换
- en: Since C++11, the STL contains some new types and functions for taking, measuring,
    and displaying time. This part of the library exists in the `std::chrono` namespace
    and has some sophisticated details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，STL包含了一些新类型和函数，用于获取、测量和显示时间。这部分库存在于`std::chrono`命名空间中，并具有一些复杂的细节。
- en: In this recipe, we will concentrate on measuring time spans and how to convert
    the result of the measurement between units, such as seconds, milliseconds, and
    microseconds. The STL provides facilities, which enable us to define our own time
    units and convert between them seamlessly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将集中在测量时间跨度以及如何在单位之间转换测量结果，比如秒、毫秒和微秒。STL提供了设施，使我们能够定义自己的时间单位并在它们之间无缝转换。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we will write a little *game* that prompts the user to enter
    a specific word. The time that the user needs to type this word into the keyboard
    is measured and displayed in multiple time units:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个小*游戏*，提示用户输入特定的单词。用户需要在键盘上输入这个单词所需的时间将被测量并以多种时间单位显示出来：
- en: 'At first, we need to include all the necessary headers. For reasons of comfort,
    we declare that we use the `std` namespace by default:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含所有必要的头文件。出于舒适的原因，我们声明默认使用`std`命名空间：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `chrono::duration` as a type for time durations usually refers to multiples
    or fractions of seconds. All the STL time duration units refer to integer typed
    duration specializations. In this recipe, we are going to specialize on `double`.
    In the recipe after this one, we will concentrate more on the existing time unit
    definitions that are already built into the STL:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chrono::duration`作为时间持续的类型通常指的是秒的倍数或分数。所有STL时间持续单位都是整数类型的持续特化。在这个配方中，我们将专门研究`double`。在这个配方之后，我们将更多地集中在STL中已经内置的时间单位定义上：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One millisecond is a fraction of a second, so we define this unit by referring
    to seconds. The `ratio_multiply` template parameter applies the STL-predefined
    `milli` factor to `seconds::period`, which gives us the fraction we want. The
    `ratio_multiply` template is basically a meta programming function for multiplying
    ratios:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一毫秒是秒的一部分，因此我们通过参考秒来定义这个单位。`ratio_multiply`模板参数将STL预定义的`milli`因子应用于`seconds::period`，从而给我们提供了所需的分数。`ratio_multiply`模板基本上是一个用于乘法比例的元编程函数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s the same thing with microseconds. While a millisecond is a `milli`-fraction
    of a second, a microsecond is a `micro`-fraction of a second:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微秒也是一样的。虽然毫秒是秒的“毫”分之一，但微秒是秒的“微”分之一：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we are going to implement a function, which reads a string from user input
    and measures how long it took the user to type the input. It takes no arguments
    and returns us the user input string as well as the elapsed time, bundled in a
    pair:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现一个函数，该函数从用户输入中读取一个字符串，并测量用户输入该字符串所需的时间。它不带参数，并返回用户输入字符串以及经过的时间，捆绑在一对中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to take the time from the beginning of the period during which user
    input occurs and after it. Taking a time snapshot looks like this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在用户输入发生的期间开始和结束之后获取时间。获取时间快照看起来像这样：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The actual capturing of user input takes place now. If we are not successful,
    we just return a default-initialized tuple. The caller will see that he got an
    empty input string:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进行实际的用户输入捕获。如果我们不成功，我们只返回一个默认初始化的元组。调用者将看到他得到了一个空的输入字符串：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the case of success, we continue by taking another time snapshot. Then we
    return the input string and the difference between both time points. Note that
    both are absolute time points, but by calculating the difference, we get a duration:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功的情况下，我们继续获取另一个时间快照。然后我们返回输入字符串和两个时间点之间的差异。请注意，这两个时间点都是绝对时间点，但通过计算差异，我们得到一个持续时间：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s implement the actual program now. We loop until the user enters the
    input string correctly. In every loop step, we ask the user to please enter the
    string `"C++17"` and, then, call our `get_input` function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现实际的程序。我们循环直到用户正确输入输入字符串。在每个循环步骤中，我们要求用户输入字符串`"C++17"`，然后调用我们的`get_input`函数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we check the input. If the input is empty, we interpret this as a request
    to exit the whole program:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查输入。如果输入为空，我们将其解释为请求退出整个程序：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the user correctly types `"C++17"`, we express our congratulations and then
    print the time the user needed to type the word correctly. The `diff.count()`
    method returns the number of seconds as a floating point number. If we had used
    the original STL `seconds` duration type, then we would have got a *rounded* integer
    value, not a fraction. By feeding the milliseconds or microseconds `constructor`
    with our `diff` variable before calling `count()`, we get the same value transformed
    to a different unit:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户正确输入了`"C++17"`，我们表示祝贺，然后打印用户正确输入该单词所需的时间。`diff.count()`方法返回浮点数秒数。如果我们使用原始的STL`seconds`持续时间类型，那么我们将得到一个*四舍五入*的整数值，而不是一个分数。通过在调用`count()`之前使用我们的`diff`变量来喂入毫秒或微秒`constructor`，我们可以得到相同的值转换为不同的单位：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the user has a typo in the input, we let him try again:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在输入中出现拼写错误，我们让他再试一次：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compiling and running the program leads to the following output. At first,
    with a typo, the program repeatedly asks for the correct input word. After typing
    the word correctly, it displays how long it took us to type it in three different
    time units:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出。首先，有拼写错误，程序会反复要求正确输入单词。在正确输入单词后，它会显示我们输入该单词所用的三种不同时间单位的时间：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'While this section is all about converting between different time units, we
    first had to choose one of the three available clock objects. There is generally
    the choice between `system_clock`, `steady_clock`, and `high_resolution_clock`
    in the `std::chrono` namespace. What are the differences between them? Let''s
    have a closer look:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节主要是关于不同时间单位之间的转换，但我们首先必须选择三个可用时钟对象中的一个。通常在`std::chrono`命名空间中可以选择`system_clock`、`steady_clock`和`high_resolution_clock`之间。它们之间有什么区别？让我们仔细看一下：
- en: '| **Clock** | **Characteristics** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '**时钟** **特征**'
- en: '| `system_clock` | This represents the system-wide real-time "*wall*" clock.
    It is the right choice if we want to obtain the local time. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '`system_clock`代表系统范围内的实时“墙”时钟。如果我们想要获取本地时间，这是正确的选择。'
- en: '| `steady_clock` | This clock is promised to be *monotonic*. This means that
    it will never be set back by any amount of time. This can happen to other clocks
    when their time is corrected by minimal amounts, or even when the time is switched
    between winter and summer time. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '`steady_clock`这个时钟被承诺是*单调*的。这意味着它永远不会被任何时间量倒退。当其他时钟的时间被最小量校正时，或者当时间在冬夏时间之间切换时，其他时钟可能会发生这种情况。'
- en: '| `high_resolution_clock` | This is the clock with the most fine-grained clock
    tick period the STL implementation can provide. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '`high_resolution_clock`这是STL实现可以提供的最精细粒度时钟滴答周期的时钟。'
- en: Since we measured the time distance, or duration from one absolute point in
    time and the other absolute point in time (which we captured in the variables
    `tic` and `toc`), we are not interested if those points in time were globally
    skewed. Even if the clock was 112 years, 5 hours, 10 minutes, and 1 second (or
    whatever) late or ahead of time, then this does not make a difference on the *difference
    between* them. The only important thing is that after we save the time point `tic`
    and before we save the time point `toc`, the clock must not be micro-adjusted
    (which happens on many systems from time to time) because that would distort our
    measurement. For these requirements, `steady_clock` is the optimal choice. Its
    implementation can be based on the processor's timestamp counter, which always
    counts up monotonously since the system was started.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们测量了从一个绝对时间点到另一个绝对时间点的时间距离或持续时间（我们在变量`tic`和`toc`中捕获了这些时间点），我们不关心这些时间点是否在全球范围内偏移。即使时钟晚了112年、5小时、10分钟和1秒（或其他任何时间），这对它们之间的*差异*没有影响。唯一重要的是，在我们保存时间点`tic`之后并在保存时间点`toc`之前，时钟不能进行微调（这在许多系统中不时发生），因为这会扭曲我们的测量。对于这些要求，`steady_clock`是最佳选择。它的实现可以基于处理器的时间戳计数器，该计数器自系统启动以来一直单调递增。
- en: 'Okay, now with the right time object choice, we are able to save points in
    time via `chrono::steady_clock::now()`. The `now` function returns us a `chrono::time_point<chrono::steady_clock>`
    typed value. The difference between two such values (as in `toc - tic`) is a *time
    span*, or *duration* of type `chrono::duration`. As this is the central type of
    this section, this gets a little complicated now. Let''s have a closer look at
    the template type interface of `duration`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在通过正确的时间对象选择，我们能够通过`chrono::steady_clock::now()`保存时间点。`now`函数会返回一个`chrono::time_point<chrono::steady_clock>`类型的值。两个这样的值之间的差异（如`toc
    - tic`）是一个*时间跨度*，或者是`chrono::duration`类型的*持续时间*。由于这是本节的核心类型，现在变得有点复杂。让我们更仔细地看看`duration`的模板类型接口：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The parameters we can change are called `Rep` and `Period`. `Rep` is easy to
    explain: this is just the numeric variable type that is used to save the time
    value. For the existing STL time units, this is usually `long long int`. In this
    recipe, we chose `double`. Because of our choice, we can save time values in seconds
    by default and then convert them to milli- or microseconds. If we save the time
    duration of `1.2345` seconds in the `chrono::seconds` type, then it would be rounded
    to one full second. This way, we would have to save the time difference between
    `tic` and `toc` in `chrono::microseconds` and could then convert to less-fine-grained
    units. With our `double` choice for `Rep`, we can convert up and down and lose
    only a minimal amount of precision, which does not hurt in this example.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改的参数称为`Rep`和`Period`。`Rep`很容易解释：这只是用于保存时间值的数值变量类型。对于现有的STL时间单位，这通常是`long
    long int`。在这个示例中，我们选择了`double`。由于我们的选择，我们可以默认保存秒为单位的时间值，然后将其转换为毫秒或微秒。如果我们将`1.2345`秒的时间持续保存在`chrono::seconds`类型中，那么它将四舍五入为一秒。这样，我们将必须将`tik`和`toc`之间的时间差保存在`chrono::microseconds`中，然后可以转换为较不精细的单位。由于我们选择了`double`作为`Rep`，我们可以向上和向下转换，只会丢失一点点精度，这在这个例子中并不会有影响。
- en: 'We used `Rep = double` for all our time units, so they differed only in our
    choice of the `Period` parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对所有时间单位使用了`Rep = double`，因此它们只在我们选择的`Period`参数上有所不同：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While `seconds` is the simplest unit to describe, as it works with `Period =
    ratio<1>`, the others have to be adjusted. As one millisecond is a thousandth
    of a second, we multiply the `seconds::period` (which is just a getter function
    to the `Period` parameter) with `milli`, which is a type alias for `std::ratio<1,
    1000>` (`std::ratio<a, b>` represents the fractional value `a/b`). The `ratio_multiply`
    type is basically a *compile time function*, which represents the type that results
    from multiplying one ratio type with another.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`seconds`是最简单的单位，因为它使用`Period = ratio<1>`，但其他单位必须进行调整。由于一毫秒是一秒的千分之一，我们将`seconds::period`（这只是一个获取函数，用于`Period`参数）与`milli`相乘，`milli`是`std::ratio<1,
    1000>`的类型别名（`std::ratio<a, b>`表示分数值`a/b`）。`ratio_multiply`类型基本上是一个*编译时函数*，它表示从一个比率类型乘以另一个比率类型得到的类型。
- en: 'Maybe this sounds too complicated, so let''s have a look at an example: `ratio_multiply<ratio<2,
    3>, ratio<4, 5>>` results in `ratio<8, 15>` because `(2/3) * (4/5) = 8/15`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这听起来太复杂了，所以让我们看一个例子：`ratio_multiply<ratio<2, 3>, ratio<4, 5>>`的结果是`ratio<8,
    15>`，因为`(2/3) * (4/5) = 8/15`。
- en: 'Our resulting type definitions are equivalent to the following definitions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果类型定义等同于以下定义：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Having these types lined up, it is easy to convert between them. If we have
    a time duration `d` of type `seconds`, we can transform it to `milliseconds` just
    by feeding it through the constructor of the other type, that is, `milliseconds(d)`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些类型的对齐，它们之间的转换就变得很容易。如果我们有一个类型为`seconds`的时间持续时间`d`，我们可以通过将其传递到另一种类型的构造函数中，即`milliseconds(d)`，将其转换为`milliseconds`。
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In other tutorials or books, you might run across `duration_cast` whenever time
    durations are transformed. If we have a duration value of type `chrono::milliseconds`
    and want to transform it to `chrono::hours`, for example, we do indeed need to
    write `duration_cast<chrono::hours>(milliseconds_value)` because these units depend
    on *integer* types. Transforming from fine-grained units to less-fine-grained
    units leads to *precision loss* in that case, which is why we need a `duration_cast`.
    For `double`- or `float`-based duration units, this is not needed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他教程或书籍中，当时间持续时间被转换时，你可能会遇到`duration_cast`。例如，如果我们有一个类型为`chrono::milliseconds`的持续时间值，并且想要将其转换为`chrono::hours`，我们确实需要写`duration_cast<chrono::hours>(milliseconds_value)`，因为这些单位依赖于*整数*类型。从细粒度单位转换为较不精细的单位会导致*精度损失*，这就是为什么我们需要一个`duration_cast`。对于基于`double`或`float`的持续时间单位，这是不需要的。
- en: Converting between absolute and relative times with std::chrono
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::chrono在绝对时间和相对时间之间进行转换
- en: Until C++11, it was quite a hassle to take the wall clock time and *just print*
    it, because C++ did not have its own time library. It was always necessary to
    call functions of the C library, which looks very archaic, considering that such
    calls could be encapsulated nicely into their own classes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C++11，获取墙上的时钟时间并*仅仅打印*它是相当麻烦的，因为C++没有自己的时间库。总是需要调用C库的函数，这看起来非常古老，考虑到这些调用可以很好地封装到它们自己的类中。
- en: Since C++11, the STL provides the `chrono` library, which makes time-related
    tasks much easier to implement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，STL提供了`chrono`库，使得与时间相关的任务更容易实现。
- en: In this recipe, we are going to take the local time, print it, and play around
    by adding different time offsets, which is a really comfortable thing to do with
    `std::chrono`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将获取本地时间，打印它，并通过添加不同的时间偏移量来玩耍，这是使用`std::chrono`非常方便的事情。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to save the current time and print it. Additionally, our program
    will add different offsets to the saved time point and print the resulting time
    points too:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存当前时间并打印它。此外，我们的程序将向保存的时间点添加不同的偏移量，并打印出结果时间点：
- en: 'The typical include lines come first; then, we declare that we use the `std`
    namespace by default:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 典型的包含行首先出现；然后，我们声明默认使用`std`命名空间：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are going to print absolute time points. These will come along in the form
    of the `chrono::time_point` type template, so we will just overload the output
    stream operator for it. There are different ways to print the date and/or time
    part of a time point. We will just use the `%c` standard formatting. We could,
    of course, also print only the time, only the date, only the year, or whatever
    comes to our mind. All the conversions between the different types before we can
    finally apply `put_time` look a bit clunky, but we are only doing this once:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将打印绝对时间点。这些将以`chrono::time_point`类型模板的形式出现，所以我们只需为其重载输出流运算符。有不同的方法可以打印时间点的日期和/或时间部分。我们将只使用`%c`标准格式。当然，我们也可以只打印时间、只打印日期、只打印年份，或者任何我们想到的东西。在我们最终应用`put_time`之前，所有不同类型之间的转换看起来有点笨拙，但我们只需要做一次：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are already STL type definitions for `seconds`, `minutes`, `hours`, and
    so on. We will add the `days` type now. This is easy; we just have to specialize
    the `chrono::duration` template by referring to `hours` and multiply with `24`,
    because a full day has 24 hours:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: STL已经为`seconds`、`minutes`、`hours`等定义了类型。现在我们将添加`days`类型。这很容易；我们只需通过引用`hours`来专门化`chrono::duration`模板，并乘以`24`，因为一整天有24小时：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to be able to express a duration in multiples of days in the most
    elegant way, we can define our own `days` literal operator. Now, we can write
    `3_days` to construct a value that represents three days:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够以最优雅的方式表示多天的持续时间，我们可以定义自己的`days`字面量运算符。现在，我们可以写`3_days`来构造一个代表三天的值：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the actual program, we will take a time snapshot, which we simply print
    afterward. This is very easy and comfortable because we already implemented the
    right operator overload for this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际程序中，我们将拍摄一个时间快照，然后简单地打印出来。这非常容易和舒适，因为我们已经为此实现了正确的运算符重载：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Having saved the current time in the `now` variable, we can add arbitrary durations
    to it and print those too. Let''s add 12 hours to the current time and print what
    time we will have in 12 hours:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前时间保存在“now”变量中后，我们可以向其中添加任意持续时间并打印出来。让我们在当前时间上加12小时，并打印出12小时后的时间：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By declaring that we use the `chrono_literals` namespace by default, we unlock
    all the existing duration literals for hours, seconds, and so on. This way, we
    can elegantly print what time it was 12 hours and 15 minutes ago, or 7 days ago:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过默认声明我们使用`chrono_literals`命名空间，我们解锁了所有现有的持续时间字面量，如小时、秒等。这样，我们可以优雅地打印12小时15分钟前的时间，或者7天前的时间：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compiling and running the program yields the following output. Because we used
    `%c` as the format string for time formatting, we get a pretty complete description
    in a specific format. By playing around with different format strings, we can
    get it in any format we like. Note that the time format is not 12 hours AM/PM
    but 24 hours because the app is run on a European system:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序后，会得到以下输出。因为我们在时间格式化的格式字符串中使用了`%c`，所以我们得到了一个相当完整的描述，以特定格式呈现。通过尝试不同的格式字符串，我们可以得到任何我们喜欢的格式。请注意，时间格式不是12小时制的AM/PM，而是24小时制，因为该应用在欧洲系统上运行：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We obtained the current time point from `std::chrono::system_clock`. This STL
    clock class is the only one that can transform its time point values to a time
    structure that can be displayed as a human-readable time description string.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`std::chrono::system_clock`获得了当前时间点。这个STL时钟类是唯一一个可以将其时间点值转换为可以显示为人类可读时间描述字符串的时间结构的类。
- en: 'In order to print such time points, we implemented `operator<<` for output
    streams:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印这样的时间点，我们实现了输出流的`operator<<`：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What happens here first, is that we transform from `chrono::time_point<chrono::system_clock>`
    to `std::time_t`. Values of this type can be transformed to a local wall clock
    relevant time value, which we do with `std::localtime`. This function returns
    us a pointer to a converted value (don't worry about the maintenance of the memory
    behind this pointer; it is a static object not allocated on the heap), which we
    can now finally print.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先发生的是，我们从`chrono::time_point<chrono::system_clock>`转换为`std::time_t`。这种类型的值可以转换为本地墙钟相关的时间值，我们使用`std::localtime`进行转换。这个函数返回一个指向转换值的指针（不用担心指针后面的内存维护；它是一个静态对象，不是在堆上分配的），现在我们可以最终打印出来了。
- en: The `std::put_time` function accepts such an object together with a time format
    string. `"%c"` displays a standard date-time string, such as `Sun Mar 12 11:33:40
    2017`. We could also have written `"%m/%d/%y"`; then the program would have printed
    the time in the format, `03/12/17`. The whole list of existing format string modifiers
    for time is very long, but it is nicely documented to its full extent in the online
    C++ reference.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::put_time`函数接受这样一个对象和一个时间格式字符串。`"%c"`显示标准的日期时间字符串，如`Sun Mar 12 11:33:40
    2017`。我们也可以写`"%m/%d/%y"`；那么程序将以`03/12/17`的格式打印时间。现有的时间格式字符串修饰符列表非常长，但在在线C++参考文档中有完整的文档。'
- en: Aside from printing, we also added time offsets to our time point. This is very
    easy because we can express time durations, such as *12 hours and 15 minutes*
    as `12h + 15min`. The `chrono_literals` namespace already provides handy type
    literals for hours (`h`), minutes (`min`), seconds (`s`), milliseconds (`ms`),
    microseconds (`us`), and nanoseconds (`ns`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打印外，我们还向时间点添加了时间偏移。这很容易，因为我们可以将时间持续时间表示为“12小时15分钟”这样的表达式，如`12h + 15min`。`chrono_literals`命名空间已经为小时（`h`）、分钟（`min`）、秒（`s`）、毫秒（`ms`）、微秒（`us`）和纳秒（`ns`）提供了方便的类型字面量。
- en: Adding such a duration value to a time point value creates a new time point
    value because these types have the right `operator+` and `operator-` overloads,
    which is why it is so simple to add and display offsets in time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将这样的持续时间值添加到时间点值会创建一个新的时间点值，因为这些类型具有正确的`operator+`和`operator-`重载，这就是为什么在时间中添加和显示偏移如此简单的原因。
- en: Safely signalizing failure with std::optional
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::optional安全地标记失败
- en: When a program communicates with the outside world and relies on values it gets
    from there, then all kinds of failures can happen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序与外部世界通信并依赖于从那里得到的值时，各种故障都可能发生。
- en: 'This means that whenever we write a function that ought to return a value,
    but that can also possibly fail, then this must be reflected in some change of
    the function interface. We have several possibilities. Let''s see how we can design
    the interface of a function that will return a string, but that could also fail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当我们编写一个应该返回一个值的函数，但也可能失败时，这必须在函数接口的某些改变中得到体现。我们有几种可能性。让我们看看如何设计一个将返回一个字符串但也可能失败的函数的接口：
- en: 'Use a success-indicating return value and output parameters: `bool get_string(string&);`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表示成功的返回值和输出参数：`bool get_string(string&);`
- en: 'Return a pointer (or a smart pointer) that can be set to `nullptr` if there
    is a failure: `string* get_string();`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个指针（或智能指针），如果失败则可以设置为`nullptr`：`string* get_string();`
- en: 'Throw an exception in the case of failure and leave the function signature
    very simple: `string get_string();`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败的情况下抛出异常，并保持函数签名非常简单：`string get_string();`
- en: 'All these approaches have different advantages and disadvantages. Since C++17,
    there is a new type that can be used to solve such a problem in a different way:
    `std::optional`. The notion of an optional value comes from purely functional
    programming languages (where they are sometimes called `Maybe` types) and can
    lead to very elegant code.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都有不同的优点和缺点。自C++17以来，有一种新类型可以用来以不同的方式解决这样的问题：`std::optional`。可选值的概念来自纯函数式编程语言（有时被称为`Maybe`类型），可以导致非常优雅的代码。
- en: We can wrap `optional` around our own types in order to signal *empty* or *erroneous*
    values. In this recipe, we will learn how to do that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们自己的类型周围包装`optional`，以便表示*空*或*错误*的值。在这个示例中，我们将学习如何做到这一点。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we will implement a program that reads integers from the user
    and sums them up. Because the user can always input random things instead of numbers,
    we will see how `optional` can improve our error handling:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个程序，从用户那里读取整数并将它们求和。因为用户总是可以输入随机的东西而不是数字，我们将看到`optional`如何改进我们的错误处理：
- en: 'First, we include all the needed headers and declare that we use the `std`
    namespace:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有需要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s define an integer type, which, *maybe,* contains a value. The `std::optional`
    type does exactly that. By wrapping any type into `optional`, we give it an additional
    possible state, which reflects that it currently has *no* value:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个整数类型，*可能*包含一个值。`std::optional`类型正是这样做的。通过将任何类型包装成`optional`，我们为其赋予了一个额外的可能状态，这反映了它当前*没有*值：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By having defined an optional integer type, we can express that a function
    that usually returns an integer can also possibly fail. If we take an integer
    from user input, this can possibly fail because the user might not always enter
    an integer even though we asked him to do so. Returning an optional integer is
    perfect in this case. If reading an integer succeeds, we feed it into the `optional<int>`
    constructor. Otherwise, we return a default constructed optional, which signals
    failure or emptiness:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义了一个可选整数类型，我们可以表达通常返回整数的函数也可能失败。如果我们从用户输入中获取一个整数，这可能会失败，因为用户可能并不总是输入一个整数，即使我们要求他这样做。在这种情况下，返回一个可选整数是完美的。如果读取整数成功，我们将其传递给`optional<int>`构造函数。否则，我们返回一个默认构造的可选值，这表示失败或空：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can do more than returning integers from functions that can possibly fail.
    What if we calculate the sum of two optional integers? This can only lead to a
    real numeric sum if both the operands contain an actual value. In any other case,
    we return an empty optional variable. This function needs a little more explanation:
    by implicitly transforming the `optional<int>` variables, `a` and `b`, to boolean
    expressions (by writing `!a` and `!b`), we get to know whether they contain actual
    values. If they do, we can access them like pointers or iterators by simply dereferencing
    them with `*a` and `*b`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以做的不仅仅是从可能失败的函数中返回整数。如果我们计算两个可选整数的和会怎样？只有当操作数都包含实际值时，这才可能导致真正的数值和。在任何其他情况下，我们返回一个空的可选变量。这个函数需要更多的解释：通过隐式转换`optional<int>`变量`a`和`b`为布尔表达式（通过写`!a`和`!b`），我们可以知道它们是否包含实际值。如果它们包含实际值，我们可以通过简单地用`*a`和`*b`对它们进行解引用来访问它们，就像指针或迭代器一样：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Adding a normal integer to an optional integer follows the same logic:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个普通整数添加到一个可选整数遵循相同的逻辑：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s now write a program that does something with optional integers. We let
    the user enter two numbers:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编写一个程序，对可选整数进行操作。我们让用户输入两个数字：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we add those input numbers and additionally add the value 10 to their
    sum. Since `a` and `b` are optional integers, `sum` will also be an optional integer
    type variable:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加这些输入数字，并额外添加值10到它们的和。由于`a`和`b`是可选整数，`sum`也将是一个可选整数类型的变量：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If `a` and/or `b` do not contain a value, then `sum` cannot possibly contain
    a value either. The nice thing about our optional integers now is that we do not
    need to explicitly check `a` and `b`. What happens when we sum up empty optionals
    is perfectly sane and defined behavior because we defined `operator+` in a safe
    way for those types. This way, we can arbitrarily add many possibly empty optional
    integers, and we''ll only need to check the resulting optional value. If it contains
    a value, then we can safely access and print it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`a`和/或`b`不包含值，那么`sum`也不可能包含值。现在我们的可选整数的好处是，我们不需要显式检查`a`和`b`。当我们对空的可选值求和时会发生什么是完全合理和定义良好的行为，因为我们已经为这些类型安全地定义了`operator+`。这样，我们可以任意地添加许多可能为空的可选整数，我们只需要检查结果的可选值。如果它包含一个值，那么我们可以安全地访问并打印它：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the user enters something non-numeric, we error out:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入非数字内容，我们会报错：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s it. When we compile and run the program, we get the following output:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。当我们编译并运行程序时，我们会得到以下输出：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the program again and entering something non-numeric yields the error
    message we prepared for this case:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行程序并输入非数字内容会产生我们为这种情况准备的错误消息：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Working with `optional` is generally very simple and convenient. If we want
    to attach the notion of possible failure or optionality to any type `T`, we can
    just wrap it into `std::optional<T>` and that's it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`optional`通常非常简单和方便。如果我们想要将可能失败或可选性的概念附加到任何类型`T`，我们只需将其包装到`std::optional<T>`中，就可以了。
- en: Whenever we get such a value from somewhere, we have to check whether it is
    in the empty state or whether it contains a real value. The `bool optional::has_value()`
    function does that for us. If it returns `true`, we may access the value. Accessing
    the value of an optional can be done with `T& optional::value()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从某个地方得到这样一个值时，我们必须检查它是否处于空状态或者是否包含了一个真实的值。`bool optional::has_value()`函数为我们做到了这一点。如果它返回`true`，我们可以访问该值。访问可选值的值可以使用`T&
    optional::value()`来完成。
- en: Instead of always writing `if (x.has_value()) {...}` and `x.value()`, we can
    also write `if (x) {...}` and `*x`. The `std::optional` type defines explicit
    conversion to `bool` and `operator*` in such a way that dealing with an optional
    type is similar to dealing with a pointer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`if (x) {...}`和`*x`来代替总是写`if (x.has_value()) {...}`和`x.value()`。`std::optional`类型以这样一种方式定义了对`bool`和`operator*`的显式转换，以便处理可选类型类似于处理指针。
- en: Another handy operator helper that is good to know is the `operator->` overload
    of `optional`. If we have a `struct Foo { int a; string b; }` type and want to
    access one of its members through an `optional<Foo>` variable, `x`, then we can
    write `x->a` or `x->b`. Of course, we should first check whether `x` actually
    has a value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便的操作符助手是`optional`的`operator->`重载。如果我们有一个`struct Foo { int a; string b;
    }`类型，并且想通过一个`optional<Foo>`变量`x`访问它的成员之一，那么我们可以写`x->a`或`x->b`。当然，我们应该首先检查`x`是否真的有一个值。
- en: 'If we try to access an optional value even though it does not have a value,
    then it will throw `std::logic_error`. This way, it is possible to mess around
    with a lot of optional values without always checking them. Using a `try-``catch`
    clause, we could write code in the following form:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试访问一个可选值，即使它没有值，那么它将抛出`std::logic_error`。这样，我们可以在不总是检查它们的情况下处理大量可选值。使用`try-catch`子句，我们可以编写以下形式的代码：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another gimmick of `std::optional` is `optional::value_or`. If we want to take
    an optional's value and fall back to a default value if it is in the empty state,
    then this is of help. `x = optional_var.value_or(123)` does this job in one concise
    line, where `123` is the fallback default value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional`的另一个妙招是`optional::value_or`。如果我们想取一个可选的值，并在它处于空状态时返回一个默认值，那么这就有帮助了。`x
    = optional_var.value_or(123)`在一行简洁的代码中完成了这项工作，其中`123`是备用默认值。'
- en: Applying functions on tuples
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用函数到元组
- en: Since C++11, the STL provides `std::tuple`. This type allows us to sporadically
    *bundle* multiple values into a single variable and reach them around. The notion
    of tuples has been there for a long time in a lot of programming languages, and
    some recipes in this book are already devoted to this type because it is extremely
    versatile to use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，STL提供了`std::tuple`。这种类型允许我们将多个值偶尔*捆绑*到单个变量中并在周围到达它们。元组的概念在许多编程语言中已经存在很长时间了，本书中的一些示例已经致力于这种类型，因为它非常适用。
- en: 'However, we sometimes end up with values bundled up in a tuple and then need
    to call functions with their individual members. Unpacking the members individually
    for every function argument is very tedious (and error-prone if we introduce a
    typo somewhere). The tedious form looks like this: `func(get<0>(tup), get<1>(tup),
    get<2>(tup), ...);`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们最终会得到一个捆绑在元组中的值，然后需要使用它们的各个成员调用函数。为每个函数参数单独解包成员非常乏味（如果我们在某个地方引入了拼写错误，那么容易出错）。繁琐的形式看起来像这样：`func(get<0>(tup),
    get<1>(tup), get<2>(tup), ...);`。
- en: In this recipe, you will learn how to pack and unpack values to and from tuples
    in an elegant way, in order to call some functions that don't know about tuples.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何以一种优雅的方式将值打包到元组中并从元组中解包，以便调用一些不知道元组的函数。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to implement a program that packs and unpacks values to and from
    tuples. Then, we will see how to call functions that know nothing about tuples
    with values from tuples:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个程序，将值打包到元组中并从元组中解包。然后，我们将看到如何使用元组中的值调用不知道元组的函数：
- en: 'First, we include a lot of headers and declare that we use the `std` namespace:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括了许多头文件，并声明我们使用`std`命名空间：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s first define a function that takes multiple parameters describing a
    student and prints them. A lot of legacy- or C-function interfaces look similar.:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先定义一个函数，它接受描述学生的多个参数并打印它们。许多传统或C函数接口看起来很相似。
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the actual program, we define a tuple type on the fly and fill it with meaningful
    student data:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际程序中，我们动态定义了一个元组类型，并用有意义的学生数据填充它：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In order to print such an object, we can decompose it to its individual members
    and call `print_student` with those individual variables:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了打印这样的对象，我们可以将其分解为其各个成员，并使用这些单独的变量调用`print_student`：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s create a whole set of students in the form of an initializer list of
    student tuples:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个以学生元组的初始化列表形式的整套学生：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can still relatively comfortably print them all, but in order to decompose
    the tuple, we need to care how many elements such tuples have. If we have to write
    such code, then we will also have to restructure it in case the function call
    interface changes:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然可以相对舒适地打印它们所有，但是为了分解元组，我们需要关心这样的元组有多少个元素。如果我们不得不编写这样的代码，那么我们也将不得不在函数调用接口发生变化的情况下对其进行重构：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can do better. Without even knowing the argument types of `print_student`
    or the number of members in a student tuple, we can directly forward the tuple''s
    content to the function using `std::apply`. This function accepts a function pointer
    or a function object and a tuple and then *unpacks* the tuple in order to call
    the function with the tuple members as parameters:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以做得更好。即使不知道`print_student`的参数类型或学生元组中的成员数量，我们也可以直接使用`std::apply`将元组的内容传递给函数。这个函数接受一个函数指针或函数对象和一个元组，然后*解包*元组以便使用元组成员作为参数调用函数：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This also works nicely in a loop, of course:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这在循环中也可以很好地工作：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Compiling and running the program shows that both ways work, as we assumed:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序显示，两种方式都可以正常工作，正如我们所假设的那样：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `std::apply` is a compile-time helper that helps us work more agnostic about
    the types we handle in our code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::apply`是一个在编译时帮助我们更不受我们代码中处理的类型的影响的辅助程序。'
- en: Imagine we have a tuple `t` with the values `(123, "abc"s, 456.0)`. This tuple
    has the type, `tuple<int, string, double>`. Additionally, assume that we have
    a function `f` with the signature `int f(int, string, double)` (the types can
    also be references).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含值`(123, "abc"s, 456.0)`的元组`t`。这个元组的类型是`tuple<int, string, double>`。另外，假设我们有一个签名为`int
    f(int, string, double)`的函数`f`（类型也可以是引用）。
- en: Then, we can write `x = apply(f, t)`, which will result in a function call,
    `x = f(123, "abc"s, 456.0)`. The `apply` method does even return to us what `f`
    returns.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以写`x = apply(f, t)`，这将导致一个函数调用，`x = f(123, "abc"s, 456.0)`。`apply`方法甚至会返回`f`的返回值。
- en: Quickly composing data structures with std::tuple
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::tuple快速组合数据结构
- en: 'Let''s have a look at a basic use case for tuples that we most probably already
    know. We can define a structure as follows, in order to just bundle some variables:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个我们很可能已经知道的元组的基本用例。我们可以定义一个结构如下，以便只是捆绑一些变量：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of defining a structure as in the preceding example, we can also define
    a tuple:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个元组，而不是像前面的例子中那样定义一个结构：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can access its items using the index number of the type from the type list.
    In order to access the first member of a tuple, `t`, we can use `std::get<0>(t)`
    to access the second member we write `std::get<1>`, and so on. If the index number
    is too large, then the compiler will even safely error out.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类型列表中的类型的索引号来访问元组的项。为了访问元组的第一个成员，我们可以使用`std::get<0>(t)`，要访问第二个成员，我们写`std::get<1>`，依此类推。如果索引号太大，编译器甚至会安全地报错。
- en: Throughout the book, we have already used the decomposition capabilities of
    C++17 for tuples. They allow us to decompose a tuple quickly by just writing `auto
    [a, b, c] = some_tuple` in order to access its individual items.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已经使用了C++17的元组分解功能。它们允许我们通过只需编写`auto [a, b, c] = some_tuple`来快速分解元组，以便访问其各个项。
- en: Composing and decomposing single data structures are not the only things we
    can do with tuples. We can also concatenate or split tuples, or do all kinds of
    magic. In this recipe, we will play around with such capabilities in order to
    learn how to do it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 组合和分解单个数据结构并不是我们可以使用元组做的唯一事情。我们还可以连接或拆分元组，或者进行各种魔术。在这个示例中，我们将玩弄这些功能，以便学习如何做到这一点。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will write a program that can print any tuple on the fly.
    In addition to that, we will write a function that can *zip* tuples together:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个可以即时打印任何元组的程序。除此之外，我们还将编写一个可以*zip*元组的函数：
- en: 'We need to include a number of headers first and then we declare that we use
    the `std` namespace by default:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含一些头文件，然后我们声明默认使用`std`命名空间：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we will be dealing with tuples, it will be interesting to display their
    content. Therefore, we will now implement a very generic function that can print
    any tuple that consists of printable types. The function accepts an output stream
    reference `os`, which will be used to do the actual printing, and a variadic argument
    list, which carries all the tuple members. We decompose all the arguments into
    the first element and put it into the argument, `v`, and the rest, which is stored
    in the argument pack `vs...`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将处理元组，因此展示它们的内容将是有趣的。因此，我们现在将实现一个非常通用的函数，可以打印任何由可打印类型组成的元组。该函数接受一个输出流引用`os`，用于实际打印，以及一个可变参数列表，其中包含所有元组成员。我们将所有参数分解为第一个元素并将其放入参数`v`中，其余部分存储在参数包`vs...`中：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If there are arguments left in the parameter pack, `vs`, these are printed
    interleaved with `", "` using the `initializer_list` expansion trick. You learned
    about this trick in the [Chapter 21](5eec7af8-298a-4292-b0a8-e0cbcf3d5c81.xhtml),
    *Lambda Expressions*:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果参数包`vs`中还有参数，这些参数将使用`initializer_list`扩展技巧交错打印`", "`。您在[第21章](5eec7af8-298a-4292-b0a8-e0cbcf3d5c81.xhtml)中学习了这个技巧，*Lambda表达式*：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can now print arbitrary sets of arguments by writing `print_args(cout, 1,
    2, "foo", 3, "bar")`, for example. But this has nothing to do with tuples yet.
    In order to print tuples, we overload the stream output operator `<<` for any
    case of tuples by implementing a template function that matches on any tuple specialization:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过编写`print_args(cout, 1, 2, "foo", 3, "bar")`来打印任意一组参数，例如。但这与元组无关。为了打印元组，我们通过实现一个模板函数重载流输出运算符`<<`来匹配任何元组特化的情况：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now it gets a little complicated. We first use a lambda expression that arbitrarily
    accepts many parameters. Whenever it is called, it prepends the `os` argument
    to those arguments and then calls `print_args` with the resulting new list of
    arguments. This means that a call to `capt_tup(...some parameters...)` leads to
    a `print_args(os, ...some parameters...)` call:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在变得有点复杂了。我们首先使用一个lambda表达式，任意接受许多参数。每当它被调用时，它将`os`参数放在这些参数之前，然后调用`print_args`，并使用结果新的参数列表。这意味着对`capt_tup(...一些参数...)`的调用会导致对`print_args(os,
    ...一些参数...)`的调用：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can do the actual tuple unpacking magic. We use `std::apply` to unpack
    the tuple. All values will be taken out of the tuple then and lined up as function
    arguments for the function that we provide as the first argument. This just means
    that if we have a tuple, `t = (1, 2, 3)`, and call `apply(capt_tup, t)`, then
    this will lead to a function call, `capt_tup(1, 2, 3)`, which in turn leads to
    the function call, `print_args(os, 1, 2, 3)`. This is just what we need. As a
    nice extra, we surround the printing with parentheses:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以进行实际的元组解包魔术。我们使用`std::apply`来解包元组。所有的值都将从元组中取出，然后作为函数参数排列给我们提供的函数。这意味着如果我们有一个元组`t
    = (1, 2, 3)`，并调用`apply(capt_tup, t)`，那么这将导致一个函数调用`capt_tup(1, 2, 3)`，这又将导致函数调用`print_args(os,
    1, 2, 3)`。这正是我们需要的。作为一个很好的额外，我们用括号括起来打印：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Okay, now we wrote some complicated code that will make our life much easier
    when we want to print a tuple. But we can do a lot more with tuples. Let''s, for
    example, write a function that accepts an iterable range, such as a vector or
    a list of numbers, as an argument. This function will then iterate over that range
    and then return us the *sum* of all the numbers in the range and bundle that with
    the *minimum* of all values, the *maximum* of all values, and the numeric *average*
    of them. By packing these four values into a tuple, we can return them as a single
    object without defining an additional structure type:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们写了一些复杂的代码，当我们想要打印一个元组时，这将使我们的生活变得更容易。但是我们可以用元组做更多的事情。例如，让我们编写一个函数，接受一个可迭代的范围，比如一个向量或一组数字的列表，作为参数。这个函数将遍历该范围，然后返回范围中所有数字的*总和*，并将其与所有值的*最小值*、*最大值*和*平均数*捆绑在一起。通过将这四个值打包成一个元组，我们可以将它们作为单个对象返回，而无需定义额外的结构类型：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `std::minmax_element` function returns us a pair of iterators that respectively
    point to the minimum and maximum values of the input range. The `std::accumulate`
    method sums up all the values in its input range. This is all we need to return
    the four values that fit in our tuple!
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::minmax_element`函数返回一对迭代器，分别指向输入范围的最小值和最大值。`std::accumulate`方法对其输入范围中的所有值进行求和。这就是我们需要返回适合我们元组的四个值的全部内容！'
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Before implementing the main program, we will implement one last magic helper
    function. I call it magic because it really looks complicated at first, but after
    understanding how it works, it will turn out as a really slick and nice helper.
    It will zip two tuples. This means that if we feed it a tuple, `(1, 2, 3)`, and
    another tuple, `(''a'', ''b'', ''c'')`, it will return a tuple `(1, ''a'', 2,
    ''b'', 3, ''c'')`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现主程序之前，我们将实现一个最后的魔术辅助函数。我称它为魔术，因为一开始看起来确实很复杂，但在理解它的工作原理之后，它将变得非常流畅和有用。它将两个元组进行压缩。这意味着如果我们给它一个元组`(1,
    2, 3)`，和另一个元组`('a', 'b', 'c')`，它将返回一个元组`(1, 'a', 2, 'b', 3, 'c')`：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we arrived at the most complex lines of code of this recipe. We create
    a function object, `z`, which accepts an arbitrary number of arguments. It then
    returns another function object that captures all these arguments in a parameter
    pack, `xs`, but also accepts another arbitrary number of arguments. Let''s sink
    this in for a moment. Within this inner function object, we can access both lists
    of arguments in the form of the parameter packs, `xs` and `ys`. And now let''s
    have a look what we actually do with these parameter packs. The expression, `make_tuple(xs,
    ys)...`, groups the parameter packs item wise. This means that if we have `xs
    = 1, 2, 3` and `ys = ''a'', ''b'', ''c''`, this will result in a new parameter
    pack, `(1, ''a''), (2, ''b''), (3, ''c'')`. This is a comma-separated list of
    three tuples. In order to get them all grouped in *one* tuple, we use `std::tuple_cat`,
    which accepts an arbitrary number of tuples and repacks them into one tuple. This
    way we get a nice `(1, ''a'', 2, ''b'', 3, ''c'')` tuple:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来到了这个食谱中最复杂的代码行。我们创建了一个函数对象`z`，它接受任意数量的参数。然后它返回另一个函数对象，它捕获所有这些参数在一个参数包`xs`中，但也接受另一个任意数量的参数。让我们沉浸在其中片刻。在这个内部函数对象中，我们可以以参数包`xs`和`ys`的形式访问两个参数列表。现在让我们看看我们实际上如何处理这些参数包。表达式`make_tuple(xs,
    ys)...`将参数包逐项分组。这意味着如果我们有`xs = 1, 2, 3`和`ys = 'a', 'b', 'c'`，这将导致一个新的参数包`(1, 'a'),
    (2, 'b'), (3, 'c')`。这是一个逗号分隔的三个元组的列表。为了将它们全部分组在*一个*元组中，我们使用`std::tuple_cat`，它接受任意数量的元组并将它们重新打包成一个元组。这样我们就得到了一个漂亮的`(1,
    'a', 2, 'b', 3, 'c')`元组：
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The last step is unwrapping all the values from the input tuples, `a` and `b`,
    and pushing them into `z`. The expression, `apply(z, a)`, puts all the values
    from `a` into the parameter pack `xs`, and `apply(..., b)` puts all the values
    of `b` into the parameter pack `ys`. The resulting tuple is the large zipped one,
    which we return to the caller:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是从输入元组`a`和`b`中解包所有值，并将它们推入`z`。表达式`apply(z, a)`将`a`中的所有值放入参数包`xs`中，`apply(...,
    b)`将`b`中的所有值放入参数包`ys`中。结果的元组是大的压缩元组，我们将其返回给调用者：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We invested a considerable amount of lines into helper/library code. Let''s
    now finally put it to use. First, we construct some arbitrary tuples. The `student`
    contains ID, name, and GPA score of a student. The `student_desc` contains strings
    that describe what those fields mean in human-readable form. The `std::make_tuple`
    is a really nice helper because it automatically deduces the type of all the arguments
    and creates a suitable tuple type:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在辅助/库代码中投入了相当多的行。现在让我们最终将它们投入使用。首先，我们构造一些任意的元组。`student`包含学生的ID、姓名和GPA分数。`student_desc`包含描述这些字段在人类可读形式中意味着什么的字符串。`std::make_tuple`是一个非常好的辅助函数，因为它自动推断所有参数的类型并创建一个合适的元组类型：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s just print what we have. This is really simple because we just implemented
    the right `operator<<` overload for that:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印一下我们所拥有的。这很简单，因为我们刚刚为它实现了正确的`operator<<`重载：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can also group both the tuples on the fly with `std::tuple_cat` and print
    them like this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`std::tuple_cat`在飞行中对元组进行分组并像这样打印它们：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can also create a new *zipped* tuple with our `zip` function and also print
    it:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用我们的`zip`函数创建一个新的*zipped*元组，并打印它：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s not forget our `sum_min_max_avg` function. We create an initializer
    list that contains some numbers and feed it into this function. To make it a little
    bit more complicated, we create another tuple of the same size, which contains
    some describing strings. By zipping these tuples, we get a nice, interleaved output,
    as we will see when we run the program:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记我们的`sum_min_max_avg`函数。我们创建了一个包含一些数字的初始化列表，并将其传递给这个函数。为了使它变得更加复杂，我们创建了另一个相同大小的元组，其中包含一些描述字符串。通过压缩这些元组，我们得到了一个漂亮的、交错的输出，当我们运行程序时会看到：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Compiling and running the program yields the following output. The first two
    lines are just the individual `student` and `student_desc` tuples. Line 3 is the
    tuple composition we got by using `tuple_cat`. Line 4 contains the zipped student
    tuple. In the last line, we see the sum, minimum, maximum, and average value of
    the numeric list we last created. Because of the zipping, it is really easy to
    see what each value means:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。前两行只是单独的`student`和`student_desc`元组。第3行是我们通过使用`tuple_cat`得到的元组组合。第4行包含了压缩的学生元组。在最后一行，我们看到了我们上次创建的数字列表的总和、最小值、最大值和平均值。由于压缩，很容易看出每个值的含义：
- en: '[PRE64]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Some of the code in this section is admittedly complicated. We wrote an `operator<<`
    implementation for tuples, which looks very complex but supports all kinds of
    tuples that themselves consist of printable types. Then we implemented the `sum_min_max_avg`
    function, which just returns a tuple. Another very complicated thing to get our
    head around was the function `zip`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的一些代码确实很复杂。我们为元组编写了一个`operator<<`实现，看起来非常复杂，但支持所有由可打印类型组成的元组。然后我们实现了`sum_min_max_avg`函数，它只返回一个元组。我们头脑中非常复杂的另一件事是`zip`函数。
- en: The easiest part was `sum_min_max_avg`. The point about it is that when we define
    a function that returns an instance `tuple<Foo`, `Bar`, `Baz> f()`, we can just
    write `return {foo_instance, bar_instance, baz_instance};` in that function to
    construct such a tuple. If you have trouble understanding the STL algorithms we
    used in the `sum_min_max_avg` function, then you might want to have a look at
    the [Chapter 22](ab657908-ae5c-43bc-bcfb-701cfd3777d5.xhtml), *STL Algorithm Basics*
    of this book, where we already had a closer look at them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易的部分是`sum_min_max_avg`。关于它的要点是，当我们定义一个返回实例`tuple<Foo`，`Bar`，`Baz> f()`的函数时，我们可以在该函数中写`return
    {foo_instance, bar_instance, baz_instance};`来构造这样一个元组。如果您对我们在`sum_min_max_avg`函数中使用的STL算法有困难，那么您可能想看看本书的[第22章](ab657908-ae5c-43bc-bcfb-701cfd3777d5.xhtml)
    *STL算法基础*，在那里我们已经仔细研究了它们。
- en: 'The other code was so complicated that we dedicate the specific helpers their
    own subsections:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码太复杂了，我们将专门的辅助程序分配给它们自己的子部分：
- en: operator<< for tuples
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组的operator<<
- en: 'Before we even touched `operator<<` for output streams, we implemented the
    `print_args` function. Due to its variadic argument nature, it accepts any number
    and type of arguments, as long as the first one is an `ostream` instance:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们甚至触及输出流的`operator<<`之前，我们实现了`print_args`函数。由于它的可变参数性质，它接受任意数量和类型的参数，只要第一个参数是`ostream`实例：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This function prints the first item, `v`, and then prints all the other items
    from the parameter pack, `vs`. We print the first item individually because we
    want to have all items interleaved with `", "` but we do not want this string
    leading or trailing the whole list (as in `"1, 2, 3, "` or `", 1, 2, 3"`). We
    learned about the `initializer_list` expansion trick in [Chapter 21](5eec7af8-298a-4292-b0a8-e0cbcf3d5c81.xhtml),
    *Lambda Expressions*, in the recipe *Calling multiple functions with the same
    input*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数打印第一个项目`v`，然后打印参数包`vs`中的所有其他项目。我们单独打印第一个项目，因为我们希望所有项目都与`", "`交错，但我们不希望这个字符串领先或尾随整个列表（就像`"1,
    2, 3, "`或`", 1, 2, 3"`）。我们在[第21章](5eec7af8-298a-4292-b0a8-e0cbcf3d5c81.xhtml)
    *Lambda表达式*的*使用相同输入调用多个函数*中学习了`initializer_list`扩展技巧。
- en: 'Having that function lined up, we have everything we need in order to print
    tuples. Our `operator<<` implementation looks as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，我们就可以打印元组所需的一切。我们的`operator<<`实现如下：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first thing we do is defining the function object, `capt_tup`. When we call
    `capt_tup(foo, bar, whatever)`, this results in the call, `print_args(**os,**
    foo, bar, whatever)`. The only thing this function object does is prepend the
    output stream object `os` to its variadic list of arguments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是定义函数对象`capt_tup`。当我们调用`capt_tup(foo, bar, whatever)`时，这会导致调用`print_args(**os,**
    foo, bar, whatever)`。这个函数对象唯一要做的就是将输出流对象`os`放在它的可变参数列表之前。
- en: Afterward, we use `std::apply` in order to unpack all the items from tuple `t`.
    If this step looks too complicated, please have a look at the recipe before this
    one, which is dedicated to demonstrating how `std::apply` works.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`std::apply`来解包元组`t`中的所有项目。如果这一步看起来太复杂，请看看这之前的一篇文章，专门介绍了`std::apply`的工作原理。
- en: The zip function for tuples
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组的zip函数
- en: 'The `zip` function accepts two tuples, but looks horribly complicated, although
    it has a very crisp implementation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`函数接受两个元组，但看起来非常复杂，尽管它有一个非常清晰的实现：'
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In order to understand this code better, imagine for a moment that the tuple
    `a` carries the values, `1, 2, 3`, and tuple `b` carries the values, `'a', 'b',
    'c'`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这段代码，想象一下元组`a`携带值`1, 2, 3`，元组`b`携带值`'a', 'b', 'c'`。
- en: In such a case, calling `apply(z, a)` leads to a function call `z(1, 2, 3)`,
    which returns another function object that captures those values, `1, 2, 3`, in
    the parameter pack `xs`. When this function object is then called with `apply(z(1,
    2, 3), b)`, it gets the values, `'a', 'b', 'c'`, stuffed into the parameter pack,
    `ys`. This is basically the same as if we called `z(1, 2, 3)('a', 'b', 'c')` directly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用`apply(z, a)`会导致调用`z(1, 2, 3)`的函数调用，它返回另一个捕获这些值`1, 2, 3`的函数对象，放入参数包`xs`中。然后，当这个函数对象被`apply(z(1,
    2, 3), b)`调用时，它会将值`'a', 'b', 'c'`填入参数包`ys`中。这基本上与直接调用`z(1, 2, 3)('a', 'b', 'c')`是一样的。
- en: 'Okay, now that we have `xs = (1, 2, 3)` and `ys = (''a'', ''b'', ''c'')`, what
    happens then? The expression `tuple_cat(make_tuple(xs, ys) ...)` does the following
    magic; have a look at the diagram:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们有了`xs = (1, 2, 3)`和`ys = ('a', 'b', 'c')`，然后会发生什么？表达式`tuple_cat(make_tuple(xs,
    ys) ...)`进行了以下魔术；看一下图表：
- en: '![](img/54ce6577-8405-4849-a5bb-40c6235b6d5b.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54ce6577-8405-4849-a5bb-40c6235b6d5b.png)'
- en: At first, the items from `xs` and `ys` are zipped together by interleaving them
    pairwise. This "pairwise interleaving" happens in the `make_tuple(xs, ys) ...`
    expression. This initially only leads to a variadic list of tuples with two items
    each. In order to get *one large* tuple, we apply `tuple_cat` on them and then
    we finally get a large concatenated tuple that contains all the members of the
    initial tuples in an interleaved manner.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`xs`和`ys`中的项目通过成对交错地进行了配对。这种“成对交错”发生在`make_tuple(xs, ys) ...`表达式中。这最初只导致一个包含两个项目的元组的可变列表。为了获得*一个大*元组，我们对它们应用`tuple_cat`，然后最终得到一个包含初始元组的所有成员的大的串联元组。
- en: Replacing void* with std::any for more type safety
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用std::any替换void*以获得更多的类型安全
- en: It can happen that we want to store items of *any* type in a variable. For such
    a variable, we then need to be able to check whether it contains *anything*, and
    if it does, we need to be able to distinguish *what* it contains. All this needs
    to happen in a type-safe manner.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望在变量中存储*任何*类型的项目。对于这样的变量，我们需要能够检查它是否包含*任何东西*，如果包含，我们需要能够区分*它包含什么*。所有这些都需要以类型安全的方式发生。
- en: In the past, we were basically able to store pointers to various objects in
    a `void*` pointer. A `void` typed pointer alone cannot tell us what kind of object
    it points to, so we would need to handcraft some kind of additional mechanism
    that tells us what to expect. Such code quickly leads to quirky looking and unsafe
    code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们基本上能够在`void*`指针中存储指向各种对象的指针。`void`类型的指针本身无法告诉我们它指向什么类型的对象，因此我们需要手工制作一种额外的机制来告诉我们应该期望什么。这样的代码很快就会导致看起来古怪和不安全的代码。
- en: Another addition of C++17 to the STL is the `std::any` type. It is designed
    to hold variables of any kind and provides facilities that enable for type-safe
    inspection and access to it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: C++17对STL的另一个补充是`std::any`类型。它旨在保存任何类型的变量，并提供了使其能够进行类型安全检查和访问的功能。
- en: In this recipe, we will play around with this utility type in order to get a
    feeling of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用这种实用类型来感受一下它。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will implement a function that tries to be able to print everything. It
    uses `std::any` as its argument type:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个函数，试图能够打印一切。它使用`std::any`作为参数类型：
- en: 'First, we include some necessary headers and declare that we use the `std`
    namespace:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含一些必要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In order to reduce the number of angle bracket syntax in the following program,
    we define an alias for `list<int>`, which we will use later:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了减少以下程序中尖括号语法的数量，我们为`list<int>`定义了一个别名，稍后我们将使用它：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s implement a function that claims to be able to print anything. The promise
    is that it prints anything provided as an argument in the form of an `std::any`
    variable:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个声称能够打印任何东西的函数。承诺是以`std::any`变量的形式打印任何提供的参数：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first thing we need to check is if the argument contains *anything* or
    if it is just an empty `any` instance. If it is empty, then there is no sense
    in trying to figure out how to print it:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要检查的第一件事是参数是否包含*任何东西*，或者它只是一个空的`any`实例。如果是空的，那么试图弄清楚如何打印它就没有意义：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If it is not empty, we can try to compare it with different types until we
    see a match. The first type to try is `string`. If it is a `string`, we can cast
    `a` to a `string` typed reference using `std::any_cast` and just print it. We
    put the string in quotes for cosmetic reasons:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不为空，我们可以尝试将其与不同的类型进行比较，直到找到匹配项。首先要尝试的类型是`string`。如果是`string`，我们可以使用`std::any_cast`将`a`转换为`string`类型的引用，并直接打印它。我们将字符串放在引号中是为了美观的原因：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If it is not a `string`, it might be an `int`. In case this type matches, we
    can use `any_cast<int>` to obtain the actual `int` value:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是`string`，可能是`int`。如果这种类型匹配，我们可以使用`any_cast<int>`来获取实际的`int`值：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`std::any` does not only work with such simple types as `string` and `int`.
    We can also put a whole map or list or whatever composed complex data structure
    into an `any` variable. Let''s see if the input is a list of integers, and if
    it is, we can just print it like we would print a list:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::any`不仅适用于`string`和`int`等简单类型。我们还可以将整个映射或列表或任何组成的复杂数据结构放入`any`变量中。让我们看看输入是否是整数列表，如果是，我们可以像打印列表一样打印它：'
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If none of these types match, we run out of type guesses. Let''s give up in
    that case and tell the user that we have no idea how to print this:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些类型都不匹配，我们就无法猜测类型了。在这种情况下，让我们放弃，并告诉用户我们不知道如何打印这个：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the main function, we can now call this function with arbitrary types. We
    can call it with an empty `any` variable using `{}` or feed it with a string `"abc"`
    or an integer. Because `std::any` can be constructed from such types implicitly,
    there is no syntax overhead. We can even construct a whole list and throw it into
    this function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们现在可以使用任意类型调用这个函数。我们可以使用空的`any`变量`{}`调用它，或者用字符串`"abc"`或整数来调用它。因为`std::any`可以从这些类型隐式构造，所以没有语法开销。我们甚至可以构造一个完整的列表并将其传递给这个函数：
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If we are going to put objects that are really expensive to copy into an `any`
    variable, we can also perform an *in-place* construction. Let''s try this with
    our list type. The `in_place_type_t<int_list>{}` expression is an empty object
    that gives the constructor of `any` enough information to know what we are going
    to construct. The second parameter, `{1, 2, 3}`, is just an initializer list that
    will be fed to the `int_list` embedded in the `any` variable for construction.
    This way, we avoid unnecessary copies or moves:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们要将真正昂贵的对象放入`any`变量中，我们也可以执行*就地*构造。让我们尝试一下我们的列表类型。`in_place_type_t<int_list>{}`表达式是一个空对象，它给`any`的构造函数提供了足够的信息，以知道我们将要构造什么。第二个参数`{1,
    2, 3}`只是一个初始化列表，将被馈送到嵌入在`any`变量中用于构造的`int_list`中。这样，我们避免了不必要的复制或移动：
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Compiling and running the program yields the following output, which is just
    what we expected:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了以下输出，这正是我们所期望的：
- en: '[PRE78]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::any` type is similar in one regard to `std::optional`--it has a `has_value()`
    method that tells if an instance carries a value or not. But apart from that,
    it can contain literally *anything*, so it is more complex to handle compared
    with `optional`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any`类型在一个方面类似于`std::optional`--它有一个`has_value()`方法，告诉实例是否携带值。但除此之外，它可以包含任何东西，因此与`optional`相比，处理起来更加复杂。'
- en: Before accessing the content of an `any` variable, we need to find out *what*
    type it carries and, then, *cast* it to that type.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问`any`变量的内容之前，我们需要找出它携带的*是什么*类型，然后将其*转换*为该类型。
- en: 'Finding out if an `any` instance holds a type `T` value can be done with a
    comparison: `x.type() == typeid(T)`. If this comparison results in `true`, then
    we can use `any_cast` to get at the content.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 找出`any`实例是否持有类型`T`值可以通过比较来完成：`x.type() == typeid(T)`。如果这个比较结果为`true`，那么我们可以使用`any_cast`来获取内容。
- en: Note that `any_cast<T>(x)` returns a *copy* of the internal `T` value in `x`.
    If we want a *reference* in order to avoid copying of complex objects, we need
    to use `any_cast<T&>(x)`. This is what we did when we accessed the internal `string`
    or `list<int>` objects in this section's code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`any_cast<T>(x)`返回`x`中内部`T`值的*副本*。如果我们想要一个*引用*，以避免复制复杂对象，我们需要使用`any_cast<T&>(x)`。这就是我们在本节代码中访问内部`string`或`list<int>`对象时所做的。
- en: If we cast an instance of `any` to the wrong type, it will throw an `std::bad_any_cast`
    exception.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`any`的实例转换为错误的类型，它将抛出一个`std::bad_any_cast`异常。
- en: Storing different types with std::variant
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::variant存储不同类型
- en: There are not only `struct` and `class` primitives in C++ that enable us to
    compose types. If we want to express that some variable can hold either some type
    `A` or a type `B` (or `C`, or whatever), we can use `union`. The problem with
    unions is that they cannot tell us they were actually initialized to which of
    the types that they can hold.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中不仅有`struct`和`class`原语可以让我们组合类型。如果我们想表达某个变量可以容纳类型`A`或类型`B`（或`C`，或其他任何类型），我们可以使用`union`。联合的问题在于它们无法告诉我们它们实际上是初始化为可以容纳的类型中的哪一个。
- en: 'Consider the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE79]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If we call the `func` function with a union that was initialized to hold an
    integer via member `a`, there is nothing that prevents us from accessing it, as
    if it was initialized to store a pointer to a string via member `b`. All kinds
    of bugs can be spread from such code. Before we start to pack our union with an
    auxiliary variable that tells us to what it was initialized in order to gain some
    safety, we can directly use `std::variant`, which came with C++17.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个初始化为通过成员`a`持有整数的联合来调用`func`函数，没有任何阻止我们访问它的东西，就好像它是通过成员`b`持有指向字符串的指针初始化的一样。这样的代码可能传播各种错误。在我们开始用一个辅助变量来打包我们的联合，告诉我们它是为了获得一些安全性而初始化的之前，我们可以直接使用C++17中提供的`std::variant`。
- en: The `variant` is kind of the *new-school*, type-safe, and efficient union type.
    It does not use the heap, so it is as space-efficient and time-efficient as a
    union-based handcrafted solution could be, so we do not have to implement it ourselves.
    It can store anything apart from references, arrays, or the `void` type.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`有点像*新式*、类型安全和高效的联合类型。它不使用堆，因此它与基于联合的手工制作的解决方案一样空间和时间高效，因此我们不必自己实现它。它可以存储除了引用、数组或`void`类型之外的任何东西。'
- en: In this recipe, we will construct an example that profits from `variant` in
    order to get a feeling of how to use this cool new addition to the STL.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个利用`variant`来获得如何使用STL这个新功能的示例。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s implement a program that knows the types, `cat` and `dog`, and that
    stores a mixed list of cats and dogs without using any runtime polymorphy:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个程序，它知道类型`cat`和`dog`，并且存储了一个混合的猫和狗列表，而不使用任何运行时多态：
- en: 'First, we include all the needed headers and define that we use the `std` namespace:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有需要的头文件，并定义我们使用`std`命名空间：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, we implement two classes that have similar functionality but are not
    related to each other in any other way, in contrast to classes that, for example,
    inherit from the same interface or a similar interface. The first class is `cat`.
    A `cat` object has a name and can say *meow*:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现两个具有类似功能的类，但彼此之间没有任何其他关联，与那些例如继承自相同接口或类似接口的类相反。第一个类是`cat`。一个`cat`对象有一个名字，可以说*meow*：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The other class is `dog`. A `dog` object does not say *meow* but *woof*, of
    course:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个类是`dog`。一个`dog`对象不会说*meow*，而是*woof*，当然：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we can define an `animal` type, which is just a type alias to `std::variant<dog,
    cat>`. This is basically the same as an old-school union but has all the extra
    features that `variant` provides:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个`animal`类型，它只是一个到`std::variant<dog, cat>`的类型别名。这基本上与老式联合相同，但具有`variant`提供的所有额外功能：
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Before we write the main program, we implement two helpers first. One helper
    is an animal predicate. By calling `is_type<cat>(...)` or `is_type<dog>(...)`,
    we can find out if an animal variant instance holds a `cat` or a `dog`. The implementation
    just calls `holds_alternative`, which is a generic predicate function for variant
    types:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写主程序之前，我们首先实现了两个帮助器。一个帮助器是一个动物谓词。通过调用`is_type<cat>(...)`或`is_type<dog>(...)`，我们可以找出动物变体实例是否持有`cat`或`dog`。实现只是调用`holds_alternative`，这是一个用于变体类型的通用谓词函数：
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The second helper is a structure that acts as a function object. It is a twofold
    function object because it implements `operator()` twice. One implementation is
    an overload that accepts dogs and the other accepts cats. For these types, it
    just calls the `woof` or the `meow` function:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个帮助器是一个充当函数对象的结构。它是一个双重的函数对象，因为它实现了两次`operator()`。一个实现是一个重载，接受狗，另一个接受猫。对于这些类型，它只是调用`woof`或`meow`函数：
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s put these types and helpers to use. First, we define a list of `animal`
    variant instances and fill it with cats and dogs:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把这些类型和帮助器用起来。首先，我们定义了一个`animal`变体实例列表，并用猫和狗填充它：
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we print the contents of the list three times, and each time in a different
    way. One way is using `variant::index()`. Because `animal` is an alias of `variant<dog,
    cat>`, a return value of `0` means that the variant holds a `dog` instance. Index
    `1` means it is a `cat`. The order of the types in the variant specialization
    is the key here. In the switch case block, we access the variant with `get<T>`
    in order to get the actual `cat` or `dog` instance inside:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将三次打印列表的内容，每次以不同的方式。一种方法是使用`variant::index()`。因为`animal`是`variant<dog,
    cat>`的别名，返回值为`0`意味着变体持有`dog`实例。索引`1`表示它是`cat`。这里关键是变体专门化中类型的顺序。在switch case块中，我们使用`get<T>`访问变体，以获取内部的实际`cat`或`dog`实例：
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Instead of using the numeric index of the type, we can also explicitly ask
    for every type. The `get_if<dog>` returns a `dog`-typed pointer to the internal
    `dog` instance. If there is no `dog` instance inside, then the pointer is `null`.
    This way, we can try to get at different types until we finally succeed:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以明确要求每种类型，而不是使用类型的数字索引。`get_if<dog>`返回一个指向内部`dog`实例的`dog`类型指针。如果内部没有`dog`实例，则指针为`null`。这样，我们可以尝试获取不同类型，直到最终成功：
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The last and most elegant way is `variant::visit`. This function accepts a
    function object and a variant instance. The function object must implement different
    overloads for all the possible types the variant can hold. We implemented a structure
    with the right `operator()` overloads before, so we can use it here:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最优雅的方法是`variant::visit`。此函数接受一个函数对象和一个变体实例。函数对象必须为变体可以容纳的所有可能类型实现不同的重载。我们之前实现了一个具有正确`operator()`重载的结构，因此可以在这里使用它：
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'At last, we will count the number of cats and dogs in the variant list. The
    `is_type<T>` predicate can be specialized on `cat` and `dog` and can then be used
    in combination with `std::count_if` to return us the number of instances of this
    type:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将计算变体列表中猫和狗的数量。`is_type<T>`谓词可以专门用于`cat`和`dog`，然后可以与`std::count_if`结合使用，以返回此类型的实例数：
- en: '[PRE90]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Compiling and running the program first yields the same list printed three
    times. After that, we see that the `is_type` predicates combined with `count_if`
    work just fine:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先编译和运行程序会打印相同的列表三次。之后，我们看到`is_type`谓词与`count_if`结合使用效果很好：
- en: '[PRE91]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::variant` type is kind of similar to `std::any` because both can hold
    objects of different types, and we need to distinguish at runtime what exactly
    they hold before we try to access their content.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant`类型有点类似于`std::any`，因为两者都可以持有不同类型的对象，并且我们需要在运行时区分它们确切地持有什么，然后再尝试访问它们的内容。'
- en: On the other hand, `std::variant` is different from `std::any` in the regard
    that we must declare what it shall be able to store in the form of a template
    type list. An instance of `std::variant<A, B, C>` *must* hold one instance of
    type `A`, `B`, or `C`. There is no possibility to hold *none* of them, which means
    that `std::variant` has no notion of *optionality*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`std::variant`与`std::any`不同之处在于，我们必须声明它应该能够以模板类型列表的形式存储什么。`std::variant<A,
    B, C>`的实例*必须*持有`A`、`B`或`C`类型的一个实例。没有可能持有*它们中的任何一个*，这意味着`std::variant`没有*可选性*的概念。
- en: 'A variant of type, `variant<A, B, C>`, mimics a union type that could look
    like the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`variant<A, B, C>`的变体模拟了一个联合类型，可能如下所示：
- en: '[PRE92]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The problem with unions is that we need to build our own mechanisms to distinguish
    if it was initialized with an `A`, `B`, or `C` variable. The `std::variant` type
    can do this for us without much hassle.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 联合的问题在于我们需要构建自己的机制来区分它是用`A`、`B`还是`C`变量初始化的。`std::variant`类型可以在不费吹灰之力的情况下为我们做到这一点。
- en: In the code in this section, we used three different ways to handle the content
    of a variant variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的代码中，我们使用了三种不同的方法来处理变体变量的内容。
- en: The first way was the `index()` function of `variant`. For a variant type `variant<A,
    B, C>` it can return index `0` if it was initialized to hold an `A` type, or `1`
    for `B`, or `2` for `C`, and so on for more complex variants.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是`variant`的`index()`函数。对于变体类型`variant<A, B, C>`，如果它被初始化为持有`A`类型，则可以返回索引`0`，对于`B`，则为`1`，对于`C`，则为`2`，对于更复杂的变体，依此类推。
- en: The next way is the `get_if<T>` function. It accepts the address of a variant
    object and returns a `T`-typed pointer to its content. If the `T` type is wrong,
    then this pointer will be a `null` pointer. It is also possible to call `get<T>(x)`
    on a variant variable in order to get a reference to its content, but if that
    does not succeed, this function throws an exception (before doing such `get`-casts,
    checking for the right type can be done with the Boolean predicate `holds_alternative<T>(x)`).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的方法是`get_if<T>`函数。它接受一个变体对象的地址，并返回一个`T`类型的指针指向其内容。如果`T`类型错误，那么这个指针将是一个`null`指针。还可以在变体变量上调用`get<T>(x)`，以便获得对其内容的引用，但如果失败，此函数会抛出异常（在进行这种`get`-casts之前，可以使用布尔谓词`holds_alternative<T>(x)`来检查正确的类型）。
- en: The last way to access the variant is the `std::visit` function. It accepts
    a function object and a `variant` instance. The `visit` function then checks of
    which type the content of the variant is and then calls the right `operator()`
    overload of the function object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 variant 的最后一种方式是 `std::visit` 函数。它接受一个函数对象和一个 `variant` 实例。`visit` 函数然后检查
    variant 的内容是哪种类型，然后调用函数对象的正确的 `operator()` 重载。
- en: 'For exactly this purpose, we implemented the `animal_voice` type because it
    can be used in combination with `visit` and `variant<dog, cat>`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正是为了这个目的，我们实现了 `animal_voice` 类型，因为它可以与 `visit` 和 `variant<dog, cat>` 结合使用：
- en: '[PRE93]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `visit`-way of accessing variants can be considered the most elegant one
    because the code sections that actually access the variant do not need to be hardcoded
    to the types the variant can hold. This makes our code easier to extend.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 variant 的 `visit` 方式可以被认为是最优雅的，因为实际访问 variant 的代码部分不需要硬编码到 variant 可以保存的类型。这使得我们的代码更容易扩展。
- en: The claim that a `variant` type cannot hold *no* value was not completely true.
    By adding the `std::monostate` type to its type list, it can indeed be initialized
    to hold *no* value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant` 类型不能保存 *没有* 值的说法并不完全正确。通过将 `std::monostate` 类型添加到其类型列表中，它确实可以被初始化为
    *没有* 值。'
- en: Automatically handling resources with std::unique_ptr
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::unique_ptr 自动处理资源
- en: Since C++11, the STL provides smart pointers that really help keep track of
    dynamic memory and its disposal. Even before C++11, there was a class called `auto_ptr`
    that was already able to do automatic memory disposal, but it was easy to use
    the wrong way.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，STL 提供了智能指针，可以真正帮助跟踪动态内存及其处理。即使在 C++11 之前，也有一个称为 `auto_ptr` 的类，它已经能够进行自动内存处理，但很容易以错误的方式使用。
- en: However, with the C++11-generation smart pointers, we seldom need to write `new`
    and `delete` ourselves, which is a really good thing. Smart pointers are a shiny
    example of automatic memory management. If we maintain dynamically allocated objects
    with `unique_ptr`, we are basically safe from memory leaks, because upon its destruction
    this class automatically calls `delete` on the object it maintains.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 C++11 生成的智能指针，我们很少需要自己编写 `new` 和 `delete`，这是一件非常好的事情。智能指针是自动内存管理的一个光辉例子。如果我们使用
    `unique_ptr` 维护动态分配的对象，我们基本上不会有内存泄漏，因为在其销毁时，该类会自动调用 `delete` 来释放它维护的对象。
- en: A unique pointer expresses ownership of the object it points to and follows
    its responsibility of freeing its memory again if it is no longer used. This class
    has the potential of relieving us forever from memory leaks (at least together
    with its companions `shared_ptr` and `weak_ptr`, but in this recipe, we solely
    concentrate on `unique_ptr`). And the best thing is that it imposes *no overhead*
    on space and runtime performance, compared with code with raw pointers and manual
    memory management. (Okay, it still sets its internal raw pointer to `nullptr`
    internally after destruction of the object it points to, which cannot always be
    optimized away. Most manually written code that manages dynamic memory does the
    same, though.)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一指针表示对其指向的对象的所有权，并在不再使用时遵循释放其内存的责任。这个类有潜力永远解决我们的内存泄漏问题（至少与其伴侣 `shared_ptr`
    和 `weak_ptr` 一起，但在这个示例中，我们只集中在 `unique_ptr` 上）。最好的是，与使用原始指针和手动内存管理的代码相比，它对空间和运行时性能没有额外的开销。（好吧，它在销毁指向的对象后在内部将其内部原始指针设置为
    `nullptr`，这不能总是被优化掉。大多数手动编写管理动态内存的代码也是这样。）
- en: In this recipe, we will a look at `unique_ptr` and how to use it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看 `unique_ptr` 以及如何使用它。
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will write a program that shows us how `unique_ptr` handles memory by creating
    a custom type that adds some debug messages upon its construction and destruction.
    Then, we will play around with unique pointers, maintaining dynamically allocated
    instances of it:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个程序，通过创建一个自定义类型，该类型在其构造和销毁时添加一些调试消息，以显示我们如何使用 `unique_ptr` 处理内存。然后，我们将使用唯一指针来维护动态分配的实例：
- en: 'First, we include the necessary headers and declare that we use the `std` namespace:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含必要的头文件，并声明我们使用 `std` 命名空间：
- en: '[PRE94]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We are going to implement a little class for the object we are going to manage
    using `unique_ptr`. Its constructor and destructor print to the terminal, so we
    can see later when it is actually automatically deleted:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们将使用 `unique_ptr` 管理的对象实现一个小类。它的构造函数和析构函数会打印到终端，这样我们以后就可以看到它何时被自动删除。
- en: '[PRE95]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In order to see what limitations a function has that accepts unique pointers
    as arguments, we just implement one. It *processes* a Foo item by printing its
    name. Note that while unique pointers are smart, overhead-free, and comfortably
    safe, they can still be `null`. This means that we still have to check them before
    we dereference them:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看接受唯一指针作为参数的函数有什么限制，我们只需实现一个函数。它通过打印其名称来 *处理* 一个 Foo 项。请注意，虽然唯一指针很聪明，没有额外开销，并且非常安全，但它们仍然可能是
    `null`。这意味着我们在解引用它们之前仍然需要检查它们：
- en: '[PRE96]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the main function, we will open another scope, create two `Foo` objects
    on the heap, and manage both with unique pointers. We create the first one explicitly
    on the heap using the `new` operator and then put it into the constructor of the
    `unique_ptr<Foo>` variable, `p1`. We create the unique pointer, `p2`, by calling
    `make_unique<Foo>` with the arguments we would otherwise directly give the constructor
    of `Foo`. This is the more elegant way because we can use auto type deduction
    and the first time we can access the object, it is already managed by `unique_ptr`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们将打开另一个作用域，在堆上创建两个 `Foo` 对象，并使用唯一指针管理两个对象。我们使用 `new` 运算符显式在堆上创建第一个对象，然后将其放入
    `unique_ptr<Foo>` 变量 `p1` 的构造函数中。我们通过调用 `make_unique<Foo>` 创建唯一指针 `p2`，并使用我们否则直接提供给
    `Foo` 构造函数的参数。这是更加优雅的方式，因为我们可以使用自动类型推断，而且第一次访问对象时，它已经由 `unique_ptr` 管理：
- en: '[PRE97]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'After we left the scope, both objects are destructed immediately and their
    memory is released to the heap. Let''s have a look at the `process_item` function
    and how to use it with `unique_ptr` now. If we construct a new `Foo` instance,
    managed by a `unique_ptr` in the function call, then its lifetime is reduced to
    the scope of the function. When `process_item` returns, the object is destroyed:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们离开作用域后，两个对象立即被销毁，它们的内存被释放到堆中。现在让我们来看一下`process_item`函数以及如何在`unique_ptr`中使用它。如果我们在函数调用中构造一个由`unique_ptr`管理的新的`Foo`实例，那么它的生命周期将缩短到函数的作用域。当`process_item`返回时，对象被销毁：
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If we want to call `process_item` with an object that already existed before
    the call, then we need to *transfer ownership* because that function takes a `unique_ptr`
    by value, which means that calling it would lead to a copy. But `unique_ptr` cannot
    be copied, it can only be *moved*. Let''s create two new `Foo` objects and move
    one into `process_item`. By looking at the terminal output later, we will see
    that `foo2` is destroyed when `process_item` returns because we transferred ownership
    to it. `foo3` will continue living until the main function returns:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要使用已经存在的对象调用`process_item`，那么我们需要*转移所有权*，因为该函数通过值传递了一个`unique_ptr`，这意味着调用它会导致复制。但`unique_ptr`不能被复制，它只能被*移动*。让我们创建两个新的`Foo`对象，并将其中一个移动到`process_item`中。通过稍后查看终端输出，我们将看到`foo2`在`process_item`返回时被销毁，因为我们将所有权转移到了它。`foo3`将继续存在，直到主函数返回：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s compile and run the program. At first, we see the constructor and destructor
    calls of `foo` and `bar`. They are indeed destroyed just after the program leaves
    the additional scope. Note that the objects are destroyed in the opposite order
    of their creation. The next constructor line comes from `foo1`, which is the item
    we created during the `process_item` call. It is indeed destroyed immediately
    after the function call. Then we created `foo2` and `foo3`. `foo2` is destroyed
    immediately after the `process_item` call where we transferred the ownership.
    The other item, `foo3`, in comparison, is destroyed after the last code line in
    the main function:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序。首先，我们看到了`foo`和`bar`的构造函数和析构函数调用。它们确实在程序离开额外的作用域后立即被销毁。请注意，对象的销毁顺序与它们的创建顺序相反。下一个构造函数行来自`foo1`，这是我们在`process_item`调用期间创建的项目。它确实在函数调用后立即被销毁。然后我们创建了`foo2`和`foo3`。`foo2`在我们转移所有权的`process_item`调用后立即被销毁。而另一个项目`foo3`则是在主函数的最后一行代码后被销毁：
- en: '[PRE100]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: Handling heap objects with `std::unique_ptr` is really simple. After we initialized
    a unique pointer to hold a pointer to some object, there is *no way* we can accidentally
    *forget* about deleting it on some code path.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::unique_ptr`处理堆对象非常简单。在初始化唯一指针以持有指向某个对象的指针后，我们*无法*在某些代码路径上意外*忘记*删除它。
- en: If we assign some new pointer to a unique pointer, then it will always first
    delete the old object it pointed to and then store the new pointer. On a unique
    pointer variable, `x`, we can also call `x.reset()` to just delete the object
    it points to immediately without assigning a new pointer. Another equivalent alternative
    to reassigning via `x = new_pointer` is `x.reset(new_pointer)`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将某个新指针分配给唯一指针，那么它将始终首先删除它指向的旧对象，然后存储新指针。在唯一指针变量`x`上，我们还可以调用`x.reset()`来立即删除它指向的对象，而不分配新指针。通过`x
    = new_pointer`重新分配的另一个等效替代方法是`x.reset(new_pointer)`。
- en: There is indeed one single way to release an object from the management of `unique_ptr`
    without deleting it. The `release` function does that, but using this function
    is not advisable in most situations.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有一种方法可以释放`unique_ptr`管理的对象，而不删除它。`release`函数可以做到这一点，但在大多数情况下不建议使用这个函数。
- en: Since pointers need to be checked before they are actually dereferenced, they
    overload the right operators in a way that enables them to mimic raw pointers.
    Conditionals like `if (p) {...}` and `if (p != nullptr) {...}` perform the same
    way as we would check a raw pointer.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针在实际解引用之前需要进行检查，它们以一种使它们能够模拟原始指针的方式重载了正确的运算符。条件语句如`if (p) {...}`和`if (p !=
    nullptr) {...}`的执行方式与我们检查原始指针的方式相同。
- en: Dereferencing a unique pointer can be done via the `get()` function, which returns
    a raw pointer to the object that can be dereferenced, or directly via `operator*`,
    which again mimics raw pointers.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`get()`函数可以对唯一指针进行解引用，该函数返回一个可以进行解引用的对象的原始指针，或者直接通过`operator*`进行解引用，这再次模拟了原始指针。
- en: One important characteristic of `unique_ptr` is that its instances cannot be
    *copied* but can be *moved* from one `unique_ptr` variable to the other. This
    is why we had to move an existing unique pointer into the `process_item` function.
    If we were able to copy a unique pointer, then this would mean that the object
    being pointed to is owned by *two* unique pointers, although this contradicts
    the design of a *unique* pointer that is the *only* *owner* (and later the "*deleter"*)
    of the underlying object.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`的一个重要特性是，它的实例不能被*复制*，但可以从一个`unique_ptr`变量*移动*到另一个。这就是为什么我们必须将现有的唯一指针移动到`process_item`函数中的原因。如果我们能够复制一个唯一指针，那么这意味着被指向的对象由*两个*唯一指针拥有，尽管这与*唯一*指针的设计相矛盾，它是底层对象的*唯一*
    *所有者*（后来是“*删除器”*）。'
- en: Since there are data structures, such as `unique_ptr` and `shared_ptr`, there
    is rarely any reason to create heap objects directly with `new` and `delete` them
    manually. Use such classes wherever you can! Especially `unique_ptr` imposes *no*
    overhead at runtime.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在`unique_ptr`和`shared_ptr`等数据结构，因此很少有理由直接使用`new`创建堆对象并手动`delete`它们。无论何时都要使用这些类！特别是`unique_ptr`在运行时*没有*开销。
- en: Automatically handling shared heap memory with std::shared_ptr
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::shared_ptr自动处理共享堆内存
- en: In the last recipe, we learned how to use `unique_ptr`. This is an enormously
    useful and important class because it helps us manage dynamically allocated objects.
    However, it can only handle *single* ownership. It is not possible to let *multiple*
    objects own the same dynamically allocated object because, then, it would be unclear
    who has to delete it later.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何使用`unique_ptr`。这是一个非常有用和重要的类，因为它帮助我们管理动态分配的对象。但它只能处理*单一*所有权。不可能让*多个*对象拥有相同的动态分配对象，因为这样，谁后来删除它将是不清楚的。
- en: The pointer type, `shared_ptr`, was designed for specifically this case. Shared
    pointers can be *copied* arbitrarily often. An internal reference counting mechanism
    tracks how many objects are still maintaining a pointer to the payload object.
    Only the last shared pointer that goes out of scope will call `delete` on the
    payload object. This way, we can be sure that we do not get memory leaks because
    objects are deleted automatically after use. At the same time, we can be sure
    that they are not deleted too early, or too often (every created object must only
    be deleted *once*).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型`shared_ptr`专门为这种情况而设计。共享指针可以任意*复制*。内部引用计数机制跟踪有多少对象仍然维护对载荷对象的指针。只有最后一个共享指针离开范围时，才会调用载荷对象的`delete`。这样，我们可以确保我们不会因为对象在使用后自动删除而导致内存泄漏。同时，我们可以确保它们不会过早或过频繁地被删除（每个创建的对象只能被删除*一次*）。
- en: 'In this recipe, you will learn how to use `shared_ptr` to automatically manage
    dynamic objects that are shared between multiple owners and see what''s different
    when comparing it with `unique_ptr`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`shared_ptr`来自动管理在多个所有者之间共享的动态对象，并了解与`unique_ptr`相比有何不同的地方：
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to write a program that is similar to the program we wrote in
    the `unique_ptr` recipe in order to get insights into the usage and principles
    of `shared_ptr`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个类似于我们在`unique_ptr`示例中编写的程序，以便深入了解`shared_ptr`的用法和原则：
- en: 'At first, we just include the necessary headers and declare that we use the
    `std` namespace by default:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们只包括必要的头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE101]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then we define a little helper class, which helps us see when instances of
    it are actually created and destroyed. We will manage instances of it with `shared_ptr`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个小的辅助类，它可以帮助我们看到它的实例何时被创建和销毁。我们将使用`shared_ptr`来管理它的实例：
- en: '[PRE102]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, we implement a function that takes a shared pointer to a `Foo` instance
    *by value*. Accepting shared pointers as arguments by value is more interesting
    than accepting them by reference because in this case, they need to be copied,
    which changes their internal reference counter, as we will see:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现一个函数，该函数通过值接受一个指向`Foo`实例的共享指针。通过值接受共享指针作为参数比通过引用接受更有趣，因为在这种情况下，它们需要被复制，这会改变它们的内部引用计数，我们将会看到：
- en: '[PRE103]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the main function, we declare an empty shared pointer. By default constructing
    it, it is effectively a `null` pointer:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们声明一个空的共享指针。通过默认构造它，它实际上是一个`null`指针：
- en: '[PRE104]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we open another scope and instantiate two `Foo` objects. We create the
    first one using the `new` operator and then feed it into the constructor of a
    new `shared_ptr`. Then we create the second instance using `make_shared<Foo>`,
    which creates a `Foo` instance from the parameters we provide. This is the more
    elegant method because we can use auto type deduction and the object is already
    managed when we have the chance to access it for the first time. This is very
    similar to the `unique_ptr` recipe at this point:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打开另一个范围并实例化两个`Foo`对象。我们使用`new`运算符创建第一个对象，然后将其传递给一个新的`shared_ptr`的构造函数。然后我们使用`make_shared<Foo>`创建第二个实例，它从我们提供的参数创建一个`Foo`实例。这是更优雅的方法，因为我们可以使用自动类型推断，并且在我们有机会第一次访问它时，对象已经被管理。在这一点上，这与`unique_ptr`示例非常相似：
- en: '[PRE105]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Since shared pointers can be shared, they need to track how many parties share
    them. This is done with an internal reference counter or *use* counter. We can
    print its value using `use_count`. The value is exactly `1` at this point because
    we did not copy it yet. We can copy `f1` to `fa`, which increases the use counter
    to `2`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于共享指针可以被共享，它们需要跟踪有多少方共享它们。这是通过内部引用计数或*use*计数来完成的。我们可以使用`use_count`打印它的值。此时的值正好是`1`，因为我们还没有复制它。我们可以将`f1`复制到`fa`，这会将使用计数增加到`2`。
- en: '[PRE106]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'While we''re leaving the scope, the shared pointers `f1` and `f2` are destroyed.
    The `f1` variable''s reference counter is decremented to `1` again, making `fa`
    the only owner of the `Foo` instance. While `f2` is destroyed, its reference counter
    is decremented to `0`. In this case, the `shared_ptr` pointer''s destructor will
    call `delete` on this object, which disposes of it:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们离开范围时，共享指针`f1`和`f2`被销毁。`f1`变量的引用计数再次减少到`1`，使`fa`成为`Foo`实例的唯一所有者。当`f2`被销毁时，它的引用计数减少到`0`。在这种情况下，`shared_ptr`指针的析构函数将调用`delete`来处理它：
- en: '[PRE107]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, let''s call the `f` function with our shared pointer in two different
    ways. At first, we call it naively by copying `fa`. The `f` function will then
    print that the reference counter has the value `2`. In the second call to `f`,
    we move the pointer into the function. This makes `f` the only owner of the object:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们以两种不同的方式使用我们的共享指针调用`f`函数。首先，我们通过复制`fa`来天真地调用它。`f`函数将打印出引用计数为`2`的值。在对`f`的第二次调用中，我们将指针移动到函数中。这使得`f`成为对象的唯一所有者：
- en: '[PRE108]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'After `f` is returned, the `Foo` instance is destroyed immediately because
    we do not have ownership of it any longer. Therefore, all the objects are already
    destroyed when the main function returns:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`f`被返回后，`Foo`实例立即被销毁，因为我们不再拥有它。因此，当主函数返回时，所有对象都已经被销毁：
- en: '[PRE109]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Compiling and running the program yields the following output. In the beginning,
    we see `"foo"` and `"bar"` created. After we copied `f1` (which points to `"foo"`),
    its reference counter was incremented to `2`. While leaving the scope, `"bar"`
    is destroyed because the shared pointer to it being the subject of destruction
    is the only owner. The single `1` in the output is the reference count of `fa`,
    which is now the only owner of `"foo"`. Afterward, we called function `f` twice.
    On the first call, we copied `fa` into it, which gave it a reference counter of
    `2` again. On the second call, we moved it into `f`, which did not alter its reference
    counter. Moreover, because `f` is the only owner of `"foo"` at this point, the
    object is destroyed immediately after `f` leaves the scope. This way, no other
    heap objects are destroyed after the last print line in `main`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。一开始，我们看到`"foo"`和`"bar"`被创建。在我们复制`f1`（指向`"foo"`）时，它的引用计数增加到`2`。在离开作用域时，"bar"被销毁，因为指向它的共享指针是唯一的所有者。输出中的单个`1`是`fa`的引用计数，它现在是`"foo"`的唯一所有者。之后，我们调用函数`f`两次。在第一次调用时，我们将`fa`复制到其中，这再次给它一个引用计数为`2`。在第二次调用时，我们将其移动到`f`中，这不会改变它的引用计数。此外，因为此时`f`是`"foo"`的唯一所有者，对象在`f`离开作用域后立即被销毁。这样，在`main`中的最后一行打印后，没有其他堆对象被销毁：
- en: '[PRE110]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When constructing and deleting objects, `shared_ptr` works basically like `unique_ptr`.
    Constructing shared pointers works similarly as creating unique pointers (although
    there is a function `make_shared` that creates shared objects as a pendant to
    `unique_ptr` pointer's `make_unique` function).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造和删除对象时，`shared_ptr`的工作原理基本上与`unique_ptr`相似。构造共享指针的方式与创建唯一指针类似（尽管有一个函数`make_shared`，它创建共享对象作为`unique_ptr`指针的`make_unique`函数的对应物）。
- en: The major difference from `unique_ptr` is that we can copy the `shared_ptr`
    instances because shared pointers maintain a so-called *control block* together
    with the object they manage. The control block contains a pointer to the payload
    object and a reference counter or *use* counter. If there are `N` number of `shared_ptr`
    instances pointing to the object, then the use counter also has the value `N`.
    Whenever a `shared_ptr` instance is destructed, then its destructor decrements
    this internal use counter. The last shared pointer to such an object will hit
    the condition that it decrements the use counter to `0` during its destruction.
    This is, then, the shared pointer instance, which calls the `delete` operator
    on the payload object! This way, we can't possibly suffer from memory leaks because
    the object's use count is automatically tracked.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 与`unique_ptr`的主要区别在于我们可以复制`shared_ptr`实例，因为共享指针与它们管理的对象一起维护一个所谓的*控制块*。控制块包含指向有效负载对象的指针和引用计数或*使用*计数器。如果有`N`个`shared_ptr`实例指向对象，则使用计数器的值也为`N`。每当`shared_ptr`实例被销毁时，它的析构函数会递减这个内部使用计数器。对于这样一个对象的最后一个共享指针将满足条件，在其销毁期间将使用计数器递减到`0`。这是，然后，共享指针实例，它在有效负载对象上调用`delete`运算符！这样，我们不可能遭受内存泄漏，因为对象的使用计数会自动跟踪。
- en: 'To illustrate this a bit more, let''s have a look at the following diagram:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这一点，让我们来看一下下面的图表：
- en: '![](img/4d305c80-4368-4efd-945c-8a4debac7d23.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d305c80-4368-4efd-945c-8a4debac7d23.png)'
- en: In step 1, we have two `shared_ptr` instances managing an object of type `Foo`.
    The use counter is at value `2`. Then, `shared_ptr2` is destroyed, which decrements
    the use counter to `1`. The `Foo` instance is not destroyed yet because there
    is still the other shared pointer. In step 3, the last shared pointer is destroyed
    too. This leads to the use counter being decremented to `0`. Step 4 happens immediately
    after step 3\. Both the control block and the instance of `Foo` are destroyed
    and their memory is released to the heap.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们有两个管理类型为`Foo`的对象的`shared_ptr`实例。使用计数器的值为`2`。然后，`shared_ptr2`被销毁，这将使用计数器减少到`1`。`Foo`实例尚未被销毁，因为还有另一个共享指针。在第3步中，最后一个共享指针也被销毁。这导致使用计数器减少到`0`。第4步发生在第3步之后立即。控制块和`Foo`实例都被销毁，它们的内存被释放到堆上。
- en: Equipped with `shared_ptr` and `unique_ptr`, we can automatically deal with
    most dynamically allocated objects without having to worry about memory leaks
    any longer. There is, however, one important caveat to consider--imagine we have
    two objects on the heap that contain shared pointers to each other, and some other
    shared pointer points to one of them from somewhere else. If that external shared
    pointer goes out of scope, then both objects still have the use counters with
    *nonzero* values because they reference *each other*. This leads to a *memory
    leak*. Shared pointers should not be used in this case because such cyclic reference
    chains prevent the use counter of such objects to ever reach `0`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`shared_ptr`和`unique_ptr`，我们可以自动处理大多数动态分配的对象，而不必再担心内存泄漏。然而，有一个重要的警告需要考虑——想象一下，我们在堆上有两个包含彼此的共享指针的对象，还有其他共享指针从其他地方指向其中一个。如果外部共享指针超出范围，那么两个对象仍然具有*非零*值的使用计数，因为它们相互引用。这会导致*内存泄漏*。在这种情况下不应该使用共享指针，因为这样的循环引用链会阻止这些对象的使用计数永远达到`0`。
- en: There's more...
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Look at the following code. What if you are told that it contains a potential
    *memory leak*?
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码。如果告诉你它包含潜在的*内存泄漏*，会怎么样？
- en: '[PRE111]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '"Where is the memory leak?", one might ask, since the newly allocated objects
    `A` and `B` are immediately fed into `shared_ptr` types, and *then* we are safe
    from memory leaks.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '"内存泄漏在哪里？"，有人可能会问，因为新分配的对象`A`和`B`立即被输入到`shared_ptr`类型中，*然后*我们就不再担心内存泄漏了。'
- en: Yes, it is true that we are safe from memory leaks as soon as the pointers are
    captured in the `shared_ptr` instances. The problem is a bit fiddly to grasp.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，事实上，一旦指针被捕获在`shared_ptr`实例中，我们就不再担心内存泄漏了。问题有点棘手，需要理解。
- en: When we call a function, `f(x(), y(), z())`, the compiler needs to assemble
    code that calls `x()`, `y()`, and `z()` first so that it can forward their return
    values to `f`. What gets us very bad in combination with the example from before
    is that the compiler can execute these function calls to `x`, `y`, and `z` in
    *any* order.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个函数，`f(x(), y(), z())`，编译器需要组装代码，先调用`x()`，`y()`和`z()`，这样它才能将它们的返回值转发给`f`。与之前的例子结合起来，这样做会让我们非常糟糕，因为编译器可以以*任何*顺序执行这些函数调用到`x`，`y`和`z`。
- en: Looking back at the example, what happens if the compiler decides to structure
    the code in a way where at first `new A{}` is called, then `other_function()`,
    and then `new B{}` is called, before the results of these functions are finally
    fed into `function`? If `other_function()` throws an exception, we get a memory
    leak because we still have an unmanaged object, `A`, on the heap because we just
    allocated it but did not have a chance to hand it to the management of `shared_ptr`.
    No matter how we catch the exception, the handle to the object is *gone* and we
    *cannot delete* it!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下这个例子，如果编译器决定以一种方式构造代码，首先调用`new A{}`，然后调用`other_function()`，最后调用`new B{}`，然后再将这些函数的结果最终传递给`function`，如果`other_function()`抛出异常，我们会得到一个内存泄漏，因为我们仍然在堆上有一个未管理的对象`A`，因为我们刚刚分配了它，但没有机会将其交给`shared_ptr`的管理。无论我们如何捕获异常，对象的句柄都已经*消失*，我们*无法删除*它！
- en: 'There are two easy ways to circumvent this problem:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法可以避免这个问题：
- en: '[PRE112]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This way, the objects are already managed by `shared_ptr`, no matter who throws
    what exception afterward.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对象已经由`shared_ptr`管理，无论之后谁抛出了什么异常。
- en: Dealing with weak pointers to shared objects
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理指向共享对象的弱指针
- en: In the recipe about `shared_ptr`, we learned how useful and easy to use shared
    pointers are. Together with `unique_ptr`, they pose an invaluable improvement
    for code that needs to manage dynamically allocated objects.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于`shared_ptr`的配方中，我们学会了共享指针是多么有用和易于使用。与`unique_ptr`一起，它们为需要管理动态分配的对象的代码提供了无价的改进。
- en: Whenever we copy `shared_ptr`, we increment its internal reference counter.
    As long as we hold our shared pointer copy, the object being pointed to will not
    be deleted. But what if we want some kind of *weak* pointer, which enables us
    to get at the object as long as it exists but does not prevent its destruction?
    And how do we determine if the object still exists, then?
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们复制`shared_ptr`时，我们都会增加它的内部引用计数。只要我们持有共享指针的副本，被指向的对象就不会被删除。但是如果我们想要一种*弱*指针，它使我们能够在对象存在的情况下访问它，但不会阻止它的销毁呢？我们如何确定对象是否仍然存在呢？
- en: In such situations, `weak_ptr` is our companion. It is a little bit more complicated
    to use than `unique_ptr` and `shared_ptr`, but after following this recipe, we
    will be ready to use it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`weak_ptr`是我们的伙伴。它比`unique_ptr`和`shared_ptr`更复杂一些，但在遵循这个配方之后，我们将准备好使用它。
- en: How to do it...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will implement a program that maintains objects with `shared_ptr` instances,
    and then, we mix in `weak_ptr` to see how this changes the behavior of smart pointer
    memory handling:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个程序，用`shared_ptr`实例维护对象，然后，我们混入`weak_ptr`，看看这如何改变智能指针内存处理的行为：
- en: 'At first, we include the necessary headers and declare that we use the `std`
    namespace by default:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括必要的头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE113]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we implement a class that prints a message in its destructor implementation.
    This way, we can simply check when an item is actually destroyed later in the
    program output:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现一个类，在其析构函数实现中打印一条消息。这样，我们可以简单地检查稍后在程序输出中何时实际销毁一个项目：
- en: '[PRE114]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let''s also implement a function that prints information about a weak pointer,
    so we can print a weak pointer''s state at different points of our program. The
    `expired` function of `weak_ptr` tells us if the object it points to still really
    exists, because holding a weak pointer to an object does not prolong its lifetime!
    The `use_count` counter tells us how many `shared_ptr` instances are currently
    pointing to the object in question:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还实现一个函数，打印关于弱指针的信息，这样我们就可以在程序的不同点打印弱指针的状态。`weak_ptr`的`expired`函数告诉我们它指向的对象是否仍然存在，因为持有一个对象的弱指针不会延长它的生命周期！`use_count`计数器告诉我们当前有多少`shared_ptr`实例指向所讨论的对象：
- en: '[PRE115]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If we want to access the actual object, we need to call the `lock` function.
    It returns us a shared pointer to the object. In case the object does *not exist*
    any longer, the shared pointer we got from it is effectively a `null` pointer.
    We need to check that, and then we can access it:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要访问实际对象，我们需要调用`lock`函数。它会返回一个指向对象的共享指针。如果对象*不再存在*，我们从中得到的共享指针实际上是一个`null`指针。我们需要检查一下，然后我们就可以访问它了：
- en: '[PRE116]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Let''s instantiate an empty weak pointer in the main function and print its
    content which is, of course, empty at first:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在主函数中实例化一个空的弱指针，并打印它的内容，当然，一开始是空的：
- en: '[PRE117]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'In a new scope, we instantiate a new shared pointer with a fresh instance of
    the `Foo` class. Then we copy it to the weak pointer. Note that this will not
    increment the reference count of the shared pointer. The reference counter is
    `1` because only one *shared* pointer owns it:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的作用域中，我们用`Foo`类的一个新实例实例化一个新的共享指针，然后将其复制到弱指针中。请注意，这不会增加共享指针的引用计数。引用计数器为`1`，因为只有一个*共享*指针拥有它：
- en: '[PRE118]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Let''s call the weak pointer function before we *leave* the scope and, again,
    *after* we leave the scope. The `Foo` instance should be destroyed immediately,
    *although* a weak pointer points to it:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们*离开*作用域之前，让我们调用弱指针函数，然后在离开作用域*后*再次调用。`Foo`实例应该立即被销毁，*尽管*有一个弱指针指向它：
- en: '[PRE119]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Compiling and running the program yields us three times the output of the `weak_ptr_info`
    function. In the first call, the weak pointer is empty. In the second call, it
    already points to the `Foo` instance we created and is able to dereference it
    after *locking* it. Before the third call, we leave the inner scope, which triggers
    the destructor of the `Foo` instance, as we expected. Afterward, it is not possible
    to get at the content of the deleted `Foo` item via the weak pointer any longer,
    and the weak pointer correctly recognizes that it has expired:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会使我们得到`weak_ptr_info`函数的输出三次。在第一次调用中，弱指针为空。在第二次调用中，它已经指向我们创建的`Foo`实例，并且在*锁定*之后能够解引用它。在第三次调用之前，我们离开了内部范围，这触发了`Foo`实例的析构函数，正如我们所预期的那样。之后，不再可能通过弱指针访问已删除的`Foo`项目的内容，弱指针正确地识别出它已经过期：
- en: '[PRE120]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: How it works...
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Weak pointers provide us a way to point at an object maintained by shared pointers
    without incrementing its use counter. Okay, a raw pointer could do the same, but
    a raw pointer cannot tell us if it is dangling or not. A weak pointer can!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 弱指针为我们提供了一种指向由共享指针维护的对象的方式，而不增加其使用计数器。好吧，原始指针也可以做同样的事情，但原始指针无法告诉我们它是否悬空。而弱指针可以！
- en: 'In order to understand how weak pointers as an addition to shared pointers
    work, let''s directly jump to an illustrating diagram:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解弱指针作为共享指针的补充是如何工作的，让我们直接跳到一个说明性的图表：
- en: '![](img/583fb0b1-7b58-4bab-ac2a-41fa81b5a685.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/583fb0b1-7b58-4bab-ac2a-41fa81b5a685.png)'
- en: The flow is similar to the diagram in the recipe about shared pointers. In step
    1, we have two shared pointers and a weak pointer pointing to the object of type
    `Foo`. Although there are three objects pointing to it, only the shared pointers
    manipulate its use counter, which is why it has the value `2`. The weak pointer
    only manipulates a *weak counter* of the control block. In steps 2 and 3, the
    shared pointer instances are destroyed, which leads stepwise to a use counter
    of `0`. In step 4, this results in the `Foo` object being deleted, but the control
    block *stays* there. The weak pointer still needs the control block in order to
    distinguish if it dangles or not. Only when the *last* *weak* pointer that still
    points to a control block *also* goes out of scope, the control block is deleted.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 流程与关于共享指针的配方中的图表类似。在步骤1中，我们有两个共享指针和一个指向类型为`Foo`的对象的弱指针。尽管有三个对象指向它，但只有共享指针操作其使用计数器，这就是为什么它的值为`2`。弱指针只操作控制块的*弱计数器*。在步骤2和3中，共享指针实例被销毁，逐步导致使用计数器为`0`。在步骤4中，这导致`Foo`对象被删除，但控制块*仍然存在*。弱指针仍然需要控制块来区分它是否悬空。只有当*最后一个*仍然指向控制块的*弱*指针也超出范围时，控制块才会被删除。
- en: We can also say that a dangling weak pointer has *expired*. In order to check
    for this attribute, we can ask `weak_ptr` pointer's `expired` method, which returns
    a boolean value. If it is `true`, then we cannot dereference the weak pointer
    because there is no object to dereference any longer.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以说悬空的弱指针已经*过期*。为了检查这个属性，我们可以询问`weak_ptr`指针的`expired`方法，它返回一个布尔值。如果为`true`，那么我们不能解引用弱指针，因为没有对象可以再解引用了。
- en: In order to dereference a weak pointer, we need to call `lock()`. This is safe
    and convenient because this function returns us a shared pointer. As long as we
    hold this shared pointer, the object behind it cannot vanish because we incremented
    the use counter by locking it. If the object is deleted, shortly before the `lock()`
    call, then the shared pointer it returns is effectively a `null` pointer.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解引用弱指针，我们需要调用`lock()`。这是安全和方便的，因为这个函数返回给我们一个共享指针。只要我们持有这个共享指针，它后面的对象就不会消失，因为我们通过锁定它来增加了使用计数器。如果对象在`lock()`调用之前被删除，那么它返回的共享指针实际上是一个`null`指针。
- en: Simplifying resource handling of legacy APIs with smart pointers
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针简化遗留API的资源处理
- en: Smart pointers (`unique_ptr`, `shared_ptr`, and `weak_ptr`) are extremely useful,
    and it is, in general, safe to say that a programmer should *always* use these
    instead of allocating and freeing memory manually.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针（`unique_ptr`、`shared_ptr`和`weak_ptr`）非常有用，通常可以安全地说，程序员应该*始终*使用这些指针，而不是手动分配和释放内存。
- en: But what if objects cannot be allocated using the `new` operator and/or cannot
    be freed again using `delete`? Many legacy libraries come with their own allocation/destruction
    functions. It seems that this would be a problem because we learned that smart
    pointers rely on `new` and `delete`. If the creation and/or destruction of specific
    types of objects relies on specific factory functions' deleter interfaces, does
    this prevent us from getting the humongous benefits of smart pointers?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果对象不能使用`new`运算符进行分配和/或不能使用`delete`再次释放呢？许多遗留库都带有自己的分配/销毁函数。看起来这可能是一个问题，因为我们学到智能指针依赖于`new`和`delete`。如果特定类型的对象的创建和/或销毁依赖于特定工厂函数的删除器接口，这是否会阻止我们获得智能指针的巨大好处呢？
- en: Not at all. In this recipe, we will see that we only need to perform very minimal
    customizations on smart pointers in order to let them follow specific procedures
    for allocation and destruction of specific objects.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 一点也不。在这个配方中，我们将看到我们只需要对智能指针进行非常少量的定制，以便让它们遵循特定对象的分配和销毁的特定程序。
- en: How to do it...
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will define a type that cannot be allocated with `new`
    directly and, also, cannot be released again using `delete`. As this prevents
    it from being used with smart pointers directly, we perform the necessary little
    adaptions to instances of `unique_ptr` and `smart_ptr`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一种类型，不能直接使用`new`进行分配，也不能使用`delete`进行释放。由于这阻止了它直接与智能指针一起使用，我们对`unique_ptr`和`smart_ptr`的实例进行了必要的小调整：
- en: 'As always, we first include the necessary headers and declare that we use the
    `std` namespace by default:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先包含必要的头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE121]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Next, we declare a class that has its constructor and destructor declared `private`.
    This way, we simulate the problem that we have to access specific functions that
    create and destroy instances of it:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个类，其构造函数和析构函数声明为`private`。这样，我们模拟了我们需要访问特定函数来创建和销毁它的实例的问题：
- en: '[PRE122]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The static methods, `create_foo` and `destroy_foo`, then create and destroy
    the `Foo` instances. They work with raw pointers. This simulates the situation
    of a legacy C API, which prevents us from using them with normal `shared_ptr`
    pointers directly:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法`create_foo`和`destroy_foo`然后创建和销毁`Foo`实例。它们使用原始指针。这模拟了一个遗留的C API的情况，它阻止我们直接使用普通的`shared_ptr`指针：
- en: '[PRE123]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, let''s make such objects manageable by `shared_ptr`. We can, of course,
    put the pointer we get from `create_foo` into the constructor of a shared pointer.
    Only the destruction is tricky because the default deleter of `shared_ptr` would
    do it wrong. The trick is that we can give `shared_ptr` a *custom deleter*. The
    function signature that a deleter function or callable object needs to have is
    already the same as that of the `destroy_foo` function. If the function we need
    to call for destroying the object is more complicated, we can simply wrap it into
    a lambda expression:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过`shared_ptr`来管理这样的对象。当然，我们可以将从`create_foo`得到的指针放入shared指针的构造函数中。只有销毁是棘手的，因为`shared_ptr`的默认删除器会做错。诀窍在于我们可以给`shared_ptr`一个*自定义删除器*。删除器函数或可调用对象需要具有的函数签名已经与`destroy_foo`函数的相同。如果我们需要调用更复杂的函数来销毁对象，我们可以简单地将其包装成lambda表达式：
- en: '[PRE124]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Note that `make_shared_foo` returns a usual `shared_ptr<Foo>` instance because
    giving it a custom deleter did not change its type. This is because `shared_ptr`
    uses virtual function calls to hide such details. Unique pointers do not impose
    any overhead, which makes the same trick unfeasible for them. Here, we need to
    change the type of the `unique_ptr`. As a second template parameter, we give it
    `void (*)(Foo*)`, which is exactly the type of pointer to the function, `destroy_foo`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`make_shared_foo`返回一个通常的`shared_ptr<Foo>`实例，因为给它一个自定义的删除器并没有改变它的类型。这是因为`shared_ptr`使用虚函数调用来隐藏这些细节。唯一指针不会施加任何开销，这使得对它们来说同样的技巧不可行。在这里，我们需要改变`unique_ptr`的类型。作为第二个模板参数，我们给它`void
    (*)(Foo*)`，这正是指向函数`destroy_foo`的指针的类型：
- en: '[PRE125]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In the main function, we just instantiate both a shared pointer and a unique
    pointer instance. In the program output, we will see if they are really, correctly,
    and automatically destroyed:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们只是实例化了一个shared指针和一个unique指针实例。在程序输出中，我们将看到它们是否真的、正确地自动销毁了：
- en: '[PRE126]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Compiling and running the program yields the following output, which is luckily
    just what we expected:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了以下输出，幸运的是正是我们所期望的：
- en: '[PRE127]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: How it works...
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Usually, `unique_ptr` and `shared_ptr` just call `delete` on their internal
    pointers, whenever they ought to destroy the object they maintain. In this section,
    we constructed a class which can neither be allocated the C++ way using `x = new
    Foo{123}` nor can it be destructed with `delete x` directly.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`unique_ptr`和`shared_ptr`只是在它们应该销毁维护的对象时在内部指针上调用`delete`。在本节中，我们构造了一个类，它既不能使用`x
    = new Foo{123}`的C++方式分配，也不能直接使用`delete x`来销毁。
- en: The `Foo::create_foo` function just returns a plain raw pointer to a newly constructed
    `Foo` instance, so this causes no further problems because smart pointers work
    with raw pointers anyway.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foo::create_foo`函数只是返回一个新构造的`Foo`实例的普通原始指针，因此这不会引起进一步的问题，因为智能指针无论如何都可以使用原始指针。'
- en: The problem we had to deal with is that we need to teach `unique_ptr` and `shared_ptr`
    how to *destruct* an object if the default way is *not* the right one.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的问题是，如果默认方式不正确，我们需要教`unique_ptr`和`shared_ptr`如何*销毁*一个对象。
- en: In that regard, both the smart pointer types differ a little bit. In order to
    define a custom deleter for `unique_ptr`, we have to alter its type. Because the
    type signature of the `Foo` deleter is `void Foo::destroy_foo(Foo*);`, the type
    of the `unique_ptr` maintaining a `Foo` instance must be `unique_ptr<Foo, void
    (*)(Foo*)>`. Now, it can hold a function pointer to `destroy_foo`, which we provide
    it as a second constructor parameter in our `make_unique_foo` function.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，智能指针类型有一点不同。为了为`unique_ptr`定义自定义删除器，我们必须改变它的类型。因为`Foo`删除器的类型签名是`void Foo::destroy_foo(Foo*);`，维护`Foo`实例的`unique_ptr`的类型必须是`unique_ptr<Foo,
    void (*)(Foo*)>`。现在，它可以持有一个指向`destroy_foo`的函数指针，我们在`make_unique_foo`函数中将其作为第二个构造参数提供给它。
- en: If giving `unique_ptr` a custom deleter function forces us to change its type,
    why were we able to do the same with `shared_ptr` *without* changing its type?
    The only thing we had to do there was giving `shared_ptr` a second constructor
    parameter, and that's it. Why can't it be as easy for `unique_ptr` as it is for
    `shared_ptr`?
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给`unique_ptr`一个自定义的删除器函数强迫我们改变它的类型，那么为什么我们能够在`shared_ptr`上做同样的事情而*不*改变它的类型呢？我们在那里唯一需要做的事情就是给`shared_ptr`一个第二个构造参数，就是这样。为什么对于`unique_ptr`来说不能像对`shared_ptr`那样容易呢？
- en: The reason why it is so simple to just provide `shared_ptr` some kind of callable
    deleter object without altering the shared pointer's type lies in the nature of
    shared pointers, which maintain a control block. The control block of shared pointers
    is an object with virtual functions. This means that the control block of a standard
    shared pointer compared with the type of a control block of a shared pointer with
    a custom deleter is *different*! When we want a unique pointer to use a custom
    deleter, then this changes the type of the unique pointer. When we want a shared
    pointer to use a custom deleter, then this changes the type of the internal *control
    block*, which is invisible to us because this difference is hidden behind a virtual
    function interface.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以可以很简单地为`shared_ptr`提供某种可调用的删除对象，而不改变共享指针的类型，是因为共享指针的本质在于维护一个控制块。共享指针的控制块是一个具有虚函数的对象。这意味着标准共享指针的控制块与具有自定义删除器的共享指针的控制块的类型是*不同*的！当我们想让唯一指针使用自定义删除器时，这会改变唯一指针的类型。当我们想让共享指针使用自定义删除器时，这会改变内部*控制块*的类型，这对我们来说是不可见的，因为这种差异被隐藏在虚函数接口的背后。
- en: It would be *possible* to do the same trick with unique pointers, but then,
    this would imply a certain runtime overhead on them. This is not what we want
    because unique pointers promise to be completely *overhead free* at runtime.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*可能*使用唯一指针做同样的技巧，但这将意味着在它们上面有一定的运行时开销。这不是我们想要的，因为唯一指针承诺在运行时完全没有开销。'
- en: Sharing different member values of the same object
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享同一对象的不同成员值
- en: Let's imagine we are maintaining a shared pointer to some complex, composed,
    and dynamically allocated object. Then, we want to start a new thread that does
    some time-consuming work on a member of this complex object. If we want to release
    this shared pointer now, the object will be deleted while the other thread is
    still accessing it. If we don't want to give the thread object the pointer to
    the whole complex object because that would mess with our nice interface, or for
    other reasons, does this mean that we have to do manual memory management now?
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在维护一个指向某个复杂、组合和动态分配的对象的共享指针。然后，我们想要启动一个新的线程，对这个复杂对象的成员进行一些耗时的工作。如果我们现在想释放这个共享指针，那么在其他线程仍在访问它时，对象将被删除。如果我们不想给线程对象整个复杂对象的指针，因为那会破坏我们的良好接口，或者出于其他原因，这是否意味着我们现在必须进行手动内存管理？
- en: No. It is possible to use shared pointers that on one hand, point to a member
    of a large shared object, while on the other hand, perform automatic memory management
    for the entire initial object.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 不。可以使用共享指针，一方面指向一个大型共享对象的成员，另一方面对整个初始对象执行自动内存管理。
- en: In this example, we will create such a scenario (without threads to keep it
    simple) in order to get a feeling for this handy feature of `shared_ptr`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建这样的一个场景（为了简单起见，不使用线程），以便对`shared_ptr`的这一便利功能有所感受。
- en: How to do it...
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to define a structure that is composed of multiple members. Then,
    we allocate an instance of this structure on the heap that is maintained by a
    shared pointer. From this shared pointer, we obtain more shared pointers that
    do not point to the actual object but to its members:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个由多个成员组成的结构。然后，我们在堆上分配这个结构的一个实例，并由共享指针维护。从这个共享指针，我们获得更多的共享指针，它们不指向实际对象，而是指向它的成员：
- en: 'We include the necessary headers first and then declare that we use the `std`
    namespace by default:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先包括必要的头文件，然后声明我们默认使用`std`命名空间：
- en: '[PRE128]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Then we define a class that has different members. We will let shared pointers
    point to the individual members. In order to be able to see when the class is
    created and destroyed, we let its constructor and destructor print messages:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个具有不同成员的类。我们将让共享指针指向各个成员。为了能够看到类何时被创建和销毁，我们让它的构造函数和析构函数打印消息：
- en: '[PRE129]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Let''s define shared pointers that have the right types to point to the `name`
    and `age` member variables of a `person` class instance:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义共享指针，使其具有正确的类型，可以指向`person`类实例的`name`和`age`成员变量：
- en: '[PRE130]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Next, we enter a new scope, create such a person object, and let a shared pointer
    manage it:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进入一个新的作用域，创建这样一个人物对象，并让一个共享指针管理它：
- en: '[PRE131]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Then, we let the first two shared pointers point to its name and age members.
    The trick is that we use a specific constructor of `shared_ptr`, which accepts
    a shared pointer and a pointer to a member of the shared object. This way, we
    can manage the object while not pointing at the object itself!
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们让前两个共享指针指向它的名称和年龄成员。诀窍在于我们使用了`shared_ptr`的特定构造函数，该构造函数接受一个共享指针和一个指向共享对象成员的指针。这样，我们可以管理对象，而不是直接指向对象本身！
- en: '[PRE132]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'After leaving the scope, we print the person''s name and age values. This is
    only legal if the object is still allocated:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开作用域后，我们打印人的姓名和年龄值。只有在对象仍然分配时才合法：
- en: '[PRE133]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Compiling and running the program yields the following output. From the destructor
    message, we see that the object is indeed still alive and allocated when we access
    the person's name and age values via the member pointers!
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。从析构函数的消息中，我们看到当我们通过成员指针访问人的姓名和年龄值时，对象确实仍然存活和分配！
- en: '[PRE134]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: How it works...
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this section, we first created a shared pointer that manages a dynamically
    allocated `person` object. Then we made two other smart pointers point to the
    person object, but they both did not *directly* point to the person object itself
    but instead to its members, `name` and `age`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们首先创建了一个管理动态分配的`person`对象的共享指针。然后，我们让另外两个智能指针指向该人物对象，但它们都没有*直接*指向该人物对象本身，而是指向它的成员，`name`和`age`。
- en: 'To summarize what kind of scenario we just created, let''s have a look at the
    following diagram:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下我们刚刚创建的场景，让我们看一下下面的图表：
- en: '![](img/835d6935-4712-4ccb-9e5c-8ff335816245.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](img/835d6935-4712-4ccb-9e5c-8ff335816245.png)'
- en: Note that `shared_ptr1` points to the `person` object directly, while `shared_name`
    and `shared_age` point to the `name` and the `age` members of the same object.
    Apparently, they still manage the object's entire lifetime. This is possible because
    the internal control block pointers still point to the same control block, no
    matter what sub-object the individual shared pointers point to.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`shared_ptr1`直接指向`person`对象，而`shared_name`和`shared_age`指向同一对象的`name`和`age`成员。显然，它们仍然管理对象的整个生命周期。这是可能的，因为内部控制块指针仍然指向相同的控制块，无论个别共享指针指向哪个子对象。
- en: In this scenario, the use count of the control block is `3`. This way, the `person`
    object is not destroyed when `shared_ptr1` is destroyed because the other shared
    pointers still own the object.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，控制块的使用计数为`3`。这样，当`shared_ptr1`被销毁时，`person`对象不会被销毁，因为其他共享指针仍然拥有该对象。
- en: 'When creating such shared pointer instances that point to members of the shared
    object, the syntax looks a bit strange. In order to obtain a `shared_ptr<string>`
    that points to the name member of a shared person, we need to write the following:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建指向共享对象成员的这种共享指针实例时，语法看起来有点奇怪。为了获得指向共享人员的名称成员的`shared_ptr<string>`，我们需要写如下内容：
- en: '[PRE135]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In order to get a specific pointer to a member of a shared object, we instantiate
    a shared pointer with a type specialization of the member we want to access. This
    is why we write `shared_ptr<**string**>`. Then, in the constructor, we first provide
    the original shared pointer that maintains the `person` object and, as a second
    argument, the address of the object the new shared pointer will use when we dereference
    it.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得共享对象成员的特定指针，我们使用共享指针实例化一个类型特化的成员。这就是为什么我们写`shared_ptr<**string**>`。然后，在构造函数中，我们首先提供维护`person`对象的原始共享指针，作为第二个参数，我们提供新共享指针在解引用时将使用的对象的地址。
- en: Generating random numbers and choosing the right random number engine
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数和选择正确的随机数引擎
- en: In order to get random numbers for whatever purpose, C++ programmers usually
    basically used the `rand()` function of the C library before C++11\. Since C++11,
    there has been a whole *suite* of random number generators that serve different
    purposes and have different characteristics.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得任何目的的随机数，C++程序员通常在C++11之前基本上使用C库的`rand()`函数。自C++11以来，已经有了一整套不同目的和不同特性的随机数生成器。
- en: These generators are not completely self-explanatory, so we will have a look
    at all of them in this recipe. In the end, we will see in what ways they differ,
    how to choose the right one, and that we will most probably never use all of them.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器并不完全自解释，所以我们将在本教程中查看它们。最后，我们将看到它们之间的区别，如何选择正确的生成器，以及我们很可能永远不会使用它们全部。
- en: How to do it...
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will implement a procedure that prints a nice illustrating histogram of the
    numbers a random generator produces. Then, we will run all STL random number generator
    engines through this procedure and learn from the results. This program contains
    many repetitive lines, so it might be advantageous to just copy the source code
    from the code repository accompanying this book on the Internet instead of typing
    all the repetitive code manually.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个过程，打印一个漂亮的直方图，显示随机生成器生成的数字。然后，我们将运行所有STL随机数生成器引擎通过这个过程，并从结果中学习。这个程序包含许多重复的行，所以最好直接从附带本书互联网代码库中复制源代码，而不是手动输入所有重复的代码。
- en: 'At first, we include all the necessary headers and then declare that we use
    the `std` namespace by default:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含所有必要的头文件，然后声明我们默认使用`std`命名空间：
- en: '[PRE136]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Then we implement a helper function, which helps us maintain and print some
    statistics for each type of random number engine. It accepts two parameters: the
    number of *partitions* and the number of *samples*. We will see immediately what
    these are for. The type of random generator is defined via the template parameter
    `RD`. The first thing we do in this function is define an alias type for the resulting
    numeric type of the numbers the generator returns. We also make sure that we have
    at least 10 partitions:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现一个辅助函数，它帮助我们维护和打印每种随机数引擎的一些统计信息。它接受两个参数：*分区*的数量和*样本*的数量。我们将立即看到这些是什么。随机生成器的类型是通过模板参数`RD`定义的。在这个函数中，我们做的第一件事是为生成器返回的数字的结果数值类型定义一个别名类型。我们还确保至少有10个分区：
- en: '[PRE137]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, we instantiate an actual generator instance of type `RD`. Then, we define
    a divisor variable called `div`. All random number engines emit random numbers
    within the range from `0` to `RD::max()`. The function argument, `partitions`,
    allows the caller to choose by how many partitions we divide every random number
    range. By dividing the largest possible value by the number of partitions, we
    know how large every partition is:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实例化一个类型为`RD`的实际生成器实例。然后，我们定义一个称为`div`的除数变量。所有随机数引擎发出的随机数范围为`0`到`RD::max()`。函数参数`partitions`允许调用者选择我们将每个随机数范围划分为多少个分区。通过将最大可能值除以分区数，我们知道每个分区有多大：
- en: '[PRE138]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Next, we instantiate a vector of counter variables. It is exactly as large
    as the number of partitions we have. Then, we get as many random values out of
    the random engine as the variable `samples` says. The expression, `rd()`, gets
    a random number from the generator and shifts its internal state to prepare it
    for returning the next random number. By dividing every random number by `div`,
    we get the partition number it falls into and can increment the right counter
    in the vector of counters:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实例化一个计数器变量的向量。它的大小正好等于我们拥有的分区数。然后，我们从随机引擎中获取与变量`samples`相同数量的随机值。表达式`rd()`从生成器中获取一个随机数，并将其内部状态移位，以准备返回下一个随机数。通过将每个随机数除以`div`，我们得到它所在的分区号，并可以增加计数器向量中的正确计数器：
- en: '[PRE139]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now we have a nice coarse-grained histogram of sample values. In order to print
    it, we need to know a little bit more about its actual counter values. Let''s
    extract its largest value using the `max_element` algorithm. We then divide this
    largest counter value by `100`. This way, we can divide all the counter values
    by `max_div` and print a lot of stars on the terminal without exceeding the width
    of `100`. If the largest counter contains a number less than `100`, because we
    did not use so many samples, we use `max` in order to get a minimal divisor of
    `1`:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个样本值的粗略直方图。为了打印它，我们需要了解更多关于其实际计数器值的信息。让我们使用`max_element`算法提取其最大值。然后我们将这个最大计数器值除以`100`。这样，我们可以将所有计数器值除以`max_div`并在终端上打印大量星号，而不会超过`100`的宽度。如果最大计数器包含的数字小于`100`，因为我们没有使用太多样本，我们使用`max`来获得`1`的最小除数：
- en: '[PRE140]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Let''s now print the histogram to the terminal. Every partition gets its own
    line on the terminal. By dividing its counter value by `max_div` and print so
    many asterisk symbols `''*''`, we get histogram lines that fit into the terminal:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将直方图打印到终端上。每个分区在终端上都有自己的一行。通过将其计数器值除以`max_div`并打印相应数量的星号`'*'`，我们可以得到适合终端的直方图行：
- en: '[PRE141]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Okay, that''s it. Now to the main program. We let the user define how many
    partitions and samples should be used:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，就是这样。现在到主程序。我们让用户定义应该使用多少个分区和样本：
- en: '[PRE142]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'We then read those variables from the command line. Of course, the command
    line consists of strings, which we can convert to numbers using `std::stoull`
    (`stoull` is an abbreviation for **s**tring **to** **u**nsigned **l**ong **l**ong):'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们从命令行读取这些变量。当然，命令行由字符串组成，我们可以使用`std::stoull`（`stoull`是**s**tring **to** **u**nsigned
    **l**ong **l**ong的缩写）将其转换为数字：
- en: '[PRE143]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now we call our histogram helper function on *every* random number engine the
    STL provides. This makes this recipe very long and repetitive. Better copy the
    example from the Internet. The output of this program is really interesting to
    look at. We start with `random_device`. This device tries to distribute the randomness
    equally over all the possible values:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们对STL提供的*每个*随机数引擎调用我们的直方图辅助函数。这使得这个示例非常冗长和重复。最好从互联网上复制示例。这个程序的输出真的很有趣。我们从`random_device`开始。这个设备试图将随机性均匀分布在所有可能的值上：
- en: '[PRE144]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The next random engine we try is `default_random_engine`. What kind of engine
    this type refers to is implementation-specific. It can be *any* of the following
    random engines:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试的下一个随机引擎是`default_random_engine`。这种类型引用的引擎是特定于实现的。它可以是以下任何一种随机引擎：
- en: '[PRE145]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Then we try it on all the other engines:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在所有其他引擎上尝试一下：
- en: '[PRE146]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Compiling and running the program yields interesting results. We will see a
    long list of output, and we''ll see that all the random engines have different
    characteristics. Let''s first run the program with `10` partitions and only `1000`
    samples:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生有趣的结果。我们将看到一个很长的输出列表，并且我们会看到所有随机引擎具有不同的特征。让我们首先使用`10`个分区和只有`1000`个样本运行程序：
- en: '![](img/ff7076af-b140-497a-9d23-c4453a43415f.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff7076af-b140-497a-9d23-c4453a43415f.png)'
- en: 'Then, we run the same program again. This time it is still `10` partitions
    but `1,000,000` samples. It becomes very obvious that the histograms look much
    *cleaner*, when we take more samples from them. This is an important observation:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们再次运行相同的程序。这次仍然是`10`个分区，但是`1,000,000`个样本。很明显，当我们从中取更多的样本时，直方图看起来会更*清晰*。这是一个重要的观察：
- en: '![](img/8178317e-d792-4766-be8a-d4e0e6a06d3c.png)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8178317e-d792-4766-be8a-d4e0e6a06d3c.png)'
- en: How it works...
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In general, any random number generator needs to be instantiated as an object
    before use. The resulting object can be called like a function without parameters
    because it overloads `operator()`. Every call will then lead to a new random number.
    It is that simple.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何随机数生成器在使用之前都需要实例化为对象。生成的对象可以像没有参数的函数一样调用，因为它重载了`operator()`。每次调用都会产生一个新的随机数。就是这么简单。
- en: 'In this section, we wrote a program that is much more complex than that in
    order to get a bit more information about random number generators. Please play
    around with the resulting program by launching it with different command-line
    arguments and realize the following facts:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们编写了一个比以往更复杂的程序，以便更多地了解随机数生成器。请通过使用不同的命令行参数启动生成的程序来玩耍，并意识到以下事实：
- en: The more samples we take, the more equal our partition counters appear.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们取样的样本越多，我们的分区计数器看起来就越均匀。
- en: The inequality of the partition counters wildly differs between individual engines.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区计数器的不平等在各个单独的引擎之间差异很大。
- en: For a large number of samples, it becomes apparent that the *performance* of
    the individual random engines differs.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大量样本，个别随机引擎的*性能*差异变得明显。
- en: Run the program with a low amount of samples multiple times. The distribution
    patterns look *the same* all the time--the random engines produce the *same* random
    number sequences repeatedly, which means they are *not random at all*. Such engines
    are called *deterministic* because their random numbers can be predicted. The
    only exception is `std::random_device`.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次以低数量的样本运行程序。分布模式始终看起来*相同*--随机引擎重复产生*相同*的随机数序列，这意味着它们*根本不是随机*。这样的引擎被称为*确定性*，因为它们的随机数可以被预测。唯一的例外是`std::random_device`。
- en: As we can see, there are a few characteristics to consider. For most standard
    applications, `std::default_random_engine` will be completely sufficient. Experts
    of cryptography or similarly security-sensitive topics will choose wisely between
    the engines they use, but for us average programmers, this is not too important
    when we write apps with some randomness.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有一些特征需要考虑。对于大多数标准应用程序，`std::default_random_engine`将完全足够。密码学专家或类似安全敏感主题的专家将明智地在使用的引擎之间进行选择，但对于我们这些普通程序员来说，在编写带有一些随机性的应用程序时，这并不太重要。
- en: 'We should carry home the following three facts from this recipe:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从这个示例中得出以下三个事实：
- en: Usually, `std::default_random_engine` is a good default choice for the average
    application.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，`std::default_random_engine` 对于一般的应用来说是一个很好的默认选择。
- en: If we really need non-deterministic random numbers, `std::random_device` provides
    us such.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们真的需要非确定性的随机数，`std::random_device`可以提供给我们这样的随机数。
- en: We can feed the constructor of any random engine with a *real* random number
    from `std::random_device` (or maybe a timestamp from the system clock), in order
    to make it produce different random numbers each time. This is called *seeding*.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用`std::random_device`的一个*真正*的随机数（或者可能是系统时钟的时间戳）来给任何随机引擎的构造函数提供种子，以便使其每次产生不同的随机数。这就是所谓的*种子*。
- en: Note that `std::random_device` *can* possibly fall back to one of the deterministic
    engines if the library has no support for nondeterministic random engines.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`std::random_device`*可能*会退回到其中一个确定性引擎，如果库不支持非确定性随机引擎。
- en: Generating random numbers and letting the STL shape specific distributions
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数并让STL塑造特定分布
- en: In the last recipe, we learned some bits about the STL random number engines.
    Generating random numbers this or the other way is often only half of the work.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了一些关于STL随机数引擎的知识。生成随机数这样或那样往往只是工作的一半。
- en: Another question is, what do we need those numbers for? Are we programmatically
    "flipping a coin"? People used to do this using `rand() % 2`, which results in
    values of `0` and `1` that can then be mapped to *head* or *tail*. Fair enough;
    we do not need a library for that (although randomness experts know that just
    using the lowest few bits of a random number does not always lead to high-quality
    random numbers).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，我们需要这些数字做什么？我们是在程序上“抛硬币”吗？人们过去常常使用`rand() % 2`来做这个，这会得到`0`和`1`的值，然后可以映射到*正面*或*反面*。好吧，我们不需要为此使用库（尽管随机性专家知道，仅使用随机数的最低几位并不总是会得到高质量的随机数）。
- en: What if we want to model a die? Then, we could surely write `(rand() % 6) +
    1`, in order to represent the result after rolling the die. There is still no
    pressing library needed for such simple tasks.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要建模一个骰子呢？那么，我们肯定可以写`(rand() % 6) + 1`，以表示掷骰子后的结果。对于这样简单的任务，还不需要使用库。
- en: What if we want to model something that happens with an exact probability of
    66%? Okay, then we can come up with a formula like `bool yesno = (rand() % 100
    > 66)`. (Oh wait, should it be `>=`, or is `>` correct?)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要建模一个发生的概率恰好为66%的事件怎么办？好吧，那么我们可以想出一个公式，比如`bool yesno = (rand() % 100 >
    66)`。（哦等等，应该是`>=`，还是`>`正确？）
- en: Apart from that, how do we model an *unfair* die whose sides do not all have
    the same probability? Or how do we model more complex distributions? Such problems
    can quickly evolve to scientific tasks. In order to concentrate on our primary
    problems, let's have a look at what the STL already provides in order to help
    us.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们如何建模一个*不公平*的骰子，其各面的概率并不相同？或者如何建模更复杂的分布？这些问题很快就会演变成科学任务。为了集中精力解决我们的主要问题，让我们先看看STL已经提供了什么来帮助我们。
- en: The STL contains more than a dozen distribution algorithms that can shape random
    numbers for specific needs. In this recipe, we are going to have a very brief
    look at all of them, and a closer look at the most generally useful ones.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: STL 包含了十几种分布算法，可以为特定的需求塑造随机数。在这个示例中，我们将简要地查看所有这些算法，并更仔细地研究其中最常用的几种。
- en: How to do it...
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We are going to generate random numbers, shape them, and print their distribution
    patterns to the terminal. This way, we can get to know all of them and understand
    the most important ones, which is useful if we ever need to model something specific
    with randomness in mind:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成随机数，塑造它们，并将它们的分布模式打印到终端。这样，我们可以了解它们，并理解最重要的那些，这对于我们如果需要以随机性为基础来建模某些特定的事物是很有用的。
- en: 'At first, we include all the needed headers and declare that we use the `std`
    namespace:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含所有需要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE147]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'For every distribution the STL provides, we will print a histogram in order
    to see its characteristics because every distribution looks very special. It accepts
    a distribution as an argument and the number of samples that shall be taken from
    it. Then, we instantiate the default random engine and a map. The map maps from
    the values we obtained from the distribution to counters that count how often
    which value occurred. The reason for why we always instantiate a random engine
    is that all distributions are just used as a *shaping function* for random numbers
    that still need to be generated by a random engine:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于STL提供的每个分布，我们将打印一个直方图，以便看到它的特征，因为每个分布看起来都很特别。它接受一个分布作为参数，以及应该从中取样的样本数。然后，我们实例化默认的随机引擎和一个地图。地图将从我们从分布中获得的值映射到计数器，计算每个值出现的次数。之所以总是实例化一个随机引擎，是因为所有分布只是用作随机数的*塑造函数*，而随机数仍然需要由随机引擎生成：
- en: '[PRE148]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We take as many samples as the `samples` variable says and feed the map counters
    with them. This way, we get a nice histogram. While calling `e()` alone would
    get us a raw random number from the random engine, `distro(e)` shapes the random
    numbers through the distribution object.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们取样本数与`samples`变量相同，并用它们来填充地图计数器。这样，我们就得到了一个漂亮的直方图。调用`e()`会得到一个原始的随机数，而`distro(e)`则通过分布对象塑造了随机数。
- en: '[PRE149]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'In order to get a terminal output that fits into the terminal window, we need
    to know the *largest* counter value. The `max_element` function helps us in finding
    the largest value by comparing all the associated counters in the map and returning
    us an iterator to the largest counter node. Knowing this value, we can determine
    by what value we need to divide all the counter values in order to fit the output
    into the terminal window:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了得到一个适合终端窗口的终端输出，我们需要知道*最大*计数器值。`max_element`函数帮助我们找到最大值，通过比较地图中所有相关的计数器，并返回一个指向最大计数器节点的迭代器。知道了这个值，我们就可以确定需要将所有计数器值除以多少，以便将输出适应终端窗口：
- en: '[PRE150]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now, we loop through the map and print a bar of asterisk symbols `''*''` for
    all counters which have a significant size. We drop the others because some distribution
    engines spread the numbers over such large domains that it would completely flood
    our terminal windows:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们遍历映射并为所有具有显着大小的计数器打印一个星号符号`'*'`的条形。我们放弃其他计数器，因为一些分布引擎将数字分布在如此大的域上，以至于它会完全淹没我们的终端窗口：
- en: '[PRE151]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: In the main function, we check if the user provided us exactly one parameter,
    which tells us how many samples to take from each distribution. If the user provided
    none or multiple parameters, we error out.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们检查用户是否向我们提供了一个参数，该参数告诉我们从每个分布中取多少个样本。如果用户没有提供或提供了多个参数，我们会报错。
- en: '[PRE152]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We convert the command-line argument string to a number using `std::stoull`:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`std::stoull`将命令行参数字符串转换为数字：
- en: '[PRE153]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'At first, we try the `uniform_int_distribution` and `normal_distribution`.
    These are the most typical distributions used where random numbers are needed.
    Everyone who ever had stochastic as a topic in maths at school will most probably
    have heard about these already. The uniform distribution accepts two values, denoting
    the lower and the upper bound of the range they shall distribute random values
    over. By choosing `0` and `9`, we will get equally often occurring values between
    (including) `0` and `9`. The normal distribution accepts a *mean value* and a
    *standard derivation* as arguments:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们尝试`uniform_int_distribution`和`normal_distribution`。这些是在需要随机数时使用的最典型的分布。在学校学习随机过程的人很可能已经听说过这些了。均匀分布接受两个值，表示它们将在其上分布随机值的范围的下限和上限。通过选择`0`和`9`，我们将得到在（包括）`0`和`9`之间出现的值。正态分布接受*均值*和*标准偏差*作为参数：
- en: '[PRE154]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Another really interesting distribution is `piecewise_constant_distribution`.
    It accepts two input ranges as arguments. The first range contains numbers that
    denote the limits of intervals. By defining it as `0, 5, 10, 30`, we get one interval
    that spans from `0` to `4`, then, an interval that spans from `5` to `9`, and
    the last interval spanning from `10` to `29`. The other input range defines the
    weights of the input ranges. By setting those weights to `0.2, 0.3, 0.5`, the
    intervals are hit by random numbers with the chances of 20%, 30%, and 50%. Within
    every interval, all the values are hit with equal probability:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个非常有趣的分布是`piecewise_constant_distribution`。它接受两个输入范围作为参数。第一个范围包含数字，表示区间的限制。通过将其定义为`0,
    5, 10, 30`，我们得到一个从`0`到`4`的区间，然后是一个从`5`到`9`的区间，最后一个从`10`到`29`的区间。另一个输入范围定义了输入范围的权重。通过将这些权重设置为`0.2,
    0.3, 0.5`，区间被随机数命中的概率分别为20％，30％和50％。在每个区间内，所有值都具有相等的概率被命中：
- en: '[PRE155]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The `piecewise_linear_distribution` is constructed similarly, but its weight
    characteristics work completely differently. For every interval boundary point,
    there is one weight value. In the transition from one boundary to the other, the
    probability is linearly interpolated. We use the same interval list but a different
    list of weight values.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`piecewise_linear_distribution`的构造方式类似，但其权重特性完全不同。对于每个区间边界点，都有一个权重值。在从一个边界过渡到另一个边界时，概率是线性插值的。我们使用相同的区间列表，但是不同的权重值列表。'
- en: '[PRE156]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The Bernoulli distribution is another important distribution because it distributes
    only *yes/no*, *hit/miss*, or *head/tail* values with a specific probability.
    Its output values are only `0` or `1`. Another interesting distribution, which
    is useful in many cases, is `discrete_distribution`. In our case, we initialize
    it to the discrete values `1, 2, 4, 8`. These values are interpreted as weights
    for the possible output values `0` to `3`:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 伯努利分布是另一个重要的分布，因为它只分布具有特定概率的*是/否*、*命中/未命中*或*正面/反面*值。其输出值只有`0`或`1`。另一个有趣的分布，在许多情况下都很有用，是`discrete_distribution`。在我们的情况下，我们将其初始化为离散值`1,
    2, 4, 8`。这些值被解释为可能的输出值`0`到`3`的权重：
- en: '[PRE157]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'There are a lot of different other distribution engines. They are very special
    and useful in very specific situations. If you have never heard about them, they
    *may* not be for you. However, since our program will produce nice distribution
    histograms, we will print them all, for curiosity reasons:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有很多其他不同的分布引擎。它们非常特殊，在非常特定的情况下非常有用。如果你从未听说过它们，它们*可能*不适合你。然而，由于我们的程序将产生漂亮的分布直方图，出于好奇的原因，我们将打印它们全部：
- en: '[PRE158]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Compiling and running the program yields the following output. Let''s first
    run the program with `1000` samples per distribution:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。让我们首先以每个分布`1000`个样本运行程序：
- en: '![](img/5ba7d1ee-ef21-4b2d-ae4f-6d68d5bc6ab5.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ba7d1ee-ef21-4b2d-ae4f-6d68d5bc6ab5.png)'
- en: 'Another run with `1,000,000` samples per distribution shows that the histograms
    appear much cleaner and more typical for each distribution. But we also see which
    ones are slow, and which ones are fast, while they are being generated:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个以每个分布`1,000,000`个样本运行的结果显示，直方图看起来更加干净，更加典型。但我们也可以看到哪些是慢的，哪些是快的，当它们被生成时：
- en: '![](img/0297daeb-5434-4bf4-8aa6-7f23b5036413.png)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0297daeb-5434-4bf4-8aa6-7f23b5036413.png)'
- en: How it works...
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: While we usually do not care too much about the random number engine, as long
    it is fast and produces numbers that are as random as possible, the distribution
    is something we *should* choose wisely, depending on the problem we like to solve
    (or create).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们不太关心随机数引擎，只要它快速并且产生尽可能随机的数字，分布是我们*应该*根据我们想要解决（或创建）的问题明智选择的东西。
- en: In order to use any distribution, we first need to instantiate a distribution
    object from it. We have seen that different distributions take different constructor
    arguments. In the recipe description, we went a bit too briefly over some distribution
    engines because most of them are too special and/or too complex to cover here.
    But don't worry, they are all documented in detail in the C++ STL documentation.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用任何分布，我们首先需要从中实例化一个分布对象。我们已经看到不同的分布需要不同的构造参数。在食谱描述中，我们对一些分布引擎描述得有点太简要了，因为它们中的大多数都太特殊和/或太复杂，无法在这里涵盖。但不要担心，它们在C++
    STL文档中都有详细的文档。
- en: However, as soon as we have a distribution instantiated, we can call it like
    a function that accepts a random engine object as its only parameter. What happens
    then is that the distribution engine takes a random value from the random engine,
    applies some magic shaping (which completely depends on the choice of the distribution
    engine, of course), and then returns us a *shaped* random value. This leads to
    completely different histograms, as we saw after executing the program.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们实例化了一个分布，我们就可以像调用函数一样调用它，它只接受一个随机引擎对象作为其唯一参数。然后发生的是，分布引擎从随机引擎中取一个随机值，应用一些魔术形状（当然完全取决于分布引擎的选择），然后返回给我们一个*形状*的随机值。这导致了完全不同的直方图，就像我们在执行程序后看到的那样。
- en: 'The most comprehensive way to get to know the different distributions is *playing*
    around with the program we just wrote. In addition to that, let''s summarize the
    most important distributions. For all the distributions that occur in our program
    but not in the following table, please consult the C++ STL documentation if you
    are interested:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 了解不同分布的最全面的方法是*玩弄*我们刚刚编写的程序。除此之外，让我们总结一下最重要的分布。对于我们程序中出现但下表中没有的所有分布，请参阅C++ STL文档（如果您感兴趣）：
- en: '| **Distribution** | **Description** |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| **分布** | **描述** |'
- en: '| `uniform_int_distribution` | This distribution accepts a lower and an upper
    bound value as constructor arguments. It does, then, give us random numbers that
    always fall into the interval between (including) those bounds. The probability
    for each of the values in this interval is the same, which gives us a histogram
    with a *flat* shape. This distribution is representative of rolling a *die*, for
    example, because each side of the die has the same probability to occur. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `uniform_int_distribution` | 这个分布接受下限和上限值作为构造参数。然后，它给我们的随机数总是落在（包括）这些边界之间的区间内。这个区间内每个值的概率是相同的，这给我们一个*平坦*形状的直方图。这个分布代表了掷骰子，因为骰子的每一面出现的概率都是相同的。'
- en: '| `normal_distribution` | The normal distribution, or Gauss distribution, occurs
    practically everywhere in nature. Its STL version accepts a mean value and a standard
    derivation value as constructor parameters and forms a *roof*-like shape in the
    histogram. If we compare the body size or IQ of humans or other animals, or the
    grades of students, we will realize that these numbers are also normal-distributed.
    |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `normal_distribution` | 正态分布或高斯分布在自然界几乎无处不在。它的STL版本接受平均值和标准偏差值作为构造函数参数，并在直方图中形成一个*屋顶*形状。如果我们比较人类或其他动物的身体大小或智商，或者学生的成绩，我们会意识到这些数字也是正态分布的。'
- en: '| `bernoulli_distribution` | The Bernoulli distribution is perfect if we want
    to flip a coin or get a yes/no answer. It emits only the values `0` or `1` and
    its only constructor parameter is the probability for the value of `1`. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| `bernoulli_distribution` | 伯努利分布非常适合我们想要抛硬币或得到是/否答案的情况。它只发出值`0`或`1`，其唯一的构造函数参数是值`1`的概率。'
- en: '| `discrete_distribution` | The discrete distribution is interesting if we
    only want a very limited, discrete set of values for which we want to define the
    probability for every individual value. Its constructor takes a list of weights
    and will emit random numbers with probabilities depending on their weight. If
    we want to model randomly distributed blood groups, of which there are only four
    different ones that have specific probabilities, then this engine is a perfect
    match. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| `discrete_distribution` | 离散分布在我们只想要一个非常有限的、离散的值集合，并且想要为每个单独的值定义概率时是很有趣的。它的构造函数接受一个权重列表，并将根据它们的权重发出具有不同概率的随机数。如果我们想要模拟随机分布的血型，其中只有四种不同的血型具有特定的概率，那么这个引擎就是一个完美的选择。'
