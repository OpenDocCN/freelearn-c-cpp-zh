- en: An In-Depth Overview of TCP Connections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接的深入概述
- en: In [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips
    with Socket APIs*, we implemented a simple TCP server that served a web page with
    HTTP. In this chapter, we will begin by implementing a TCP client. This client
    is able to establish an IPv4 or IPv6 TCP connection with any listening TCP server.
    It will be a useful debugging tool that we can reuse in the rest of this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*中，我们实现了一个简单的TCP服务器，该服务器使用HTTP提供网页服务。在本章中，我们将首先实现一个TCP客户端。这个客户端能够与任何监听的TCP服务器建立IPv4或IPv6
    TCP连接。它将是一个有用的调试工具，我们可以在本书的其余部分中重用它。
- en: Our TCP server from the last chapter was limited to accepting only one connection.
    In this chapter, we will look at multiplexing techniques to allow our programs
    to handle many separate connections simultaneously.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上一章的TCP服务器仅限于接受一个连接。在本章中，我们将探讨多路复用技术，以便我们的程序能够同时处理多个单独的连接。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Configuring a remote address with `getaddrinfo()`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getaddrinfo()`配置远程地址
- en: Initiating a TCP connection with `connect()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`connect()`初始化TCP连接
- en: Detecting terminal input in a non-blocking manner
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以非阻塞方式检测终端输入
- en: Multiplexing with `fork()`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fork()`进行多路复用
- en: Multiplexing with `select()`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`select()`进行多路复用
- en: Detecting peer disconnects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测对等端断开连接
- en: Implementing a very basic microservice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个非常基本的微服务
- en: The stream-like nature of TCP
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP的流式特性
- en: The blocking behavior of `send()`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()`的阻塞行为'
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs for this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler On Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler On Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler On macOS*, for compiler setup.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以使用任何现代C编译器编译。我们推荐在Windows上使用MinGW，在Linux和macOS上使用GCC。有关编译器设置的详细信息，请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在Windows上设置您的C编译器*，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在Linux上设置您的C编译器*，以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在macOS上设置您的C编译器*。
- en: The code for this book can be found in this book's GitHub repository: [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在本书的GitHub仓库中找到：[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，你可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. While
    compiling on Windows, each example program requires that you link with the Winsock
    library. This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要链接Winsock库。这可以通过将`-lws2_32`选项传递给`gcc`来实现。
- en: We provide the exact commands that are needed to compile each example as it
    is introduced.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了编译每个示例所需的精确命令，正如它被介绍的那样。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap03.h`, which we can include in each program. For an
    explanation of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例程序都需要我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*中开发的相同头文件和C宏。为了简洁起见，我们将这些语句放在一个单独的头文件`chap03.h`中，我们可以在每个程序中包含它。有关这些语句的解释，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*。
- en: 'The contents of `chap03.h` is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap03.h`的内容如下：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Multiplexing TCP connections
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用TCP连接
- en: The socket APIs are blocking by default. When you use `accept()` to wait for
    an incoming connection, your program's execution is blocked until a new incoming
    connection is actually available. When you use `recv()` to read incoming data,
    your program's execution blocks until new data is actually available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，套接字API是阻塞的。当你使用`accept()`等待传入连接时，你的程序执行将被阻塞，直到实际有新的传入连接可用。当你使用`recv()`读取传入数据时，你的程序执行将被阻塞，直到实际有新数据可用。
- en: In the last chapter, we built a simple TCP server. This server only accepted
    one connection, and it only read data from that connection once. Blocking wasn't
    a problem then, because our server had no other purpose than to serve its one
    and only client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个简单的TCP服务器。这个服务器只接受一个连接，并且只从这个连接中读取一次数据。当时阻塞不是问题，因为我们的服务器除了为其唯一的客户端提供服务外，没有其他目的。
- en: In the general case, though, blocking I/O can be a significant problem. Imagine
    that our server from [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*, needed to serve multiple clients. Then, imagine
    that one slow client connected to it. Maybe this slow client takes a minute before
    sending its first data. During this minute, our server would simply be waiting
    on the `recv()` call to return. If other clients were trying to connect, they
    would have to wait it out.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一般情况下，阻塞I/O可能是一个重大问题。想象一下，我们的服务器来自第2章，*掌握套接字API*，需要为多个客户端提供服务。然后，想象一个慢速客户端连接到它。也许这个慢速客户端需要一分钟才能发送它的第一条数据。在这分钟内，我们的服务器会简单地等待`recv()`调用返回。如果其他客户端正在尝试连接，它们将不得不等待。
- en: Blocking on `recv()` like this isn't really acceptable. A real application usually
    needs to be able to manage several connections simultaneously. This is obviously
    true on the server side, as most servers are built to manage many connected clients.
    Imagine running a website where hundreds of clients are connected at once. Serving
    these clients one at a time would be a non-starter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在`recv()`上阻塞实际上是不可接受的。真实的应用程序通常需要能够同时管理多个连接。这在服务器端显然是正确的，因为大多数服务器都是构建来管理许多已连接客户端的。想象一下运行一个网站，其中数百个客户端同时连接。一次只服务一个客户端将是不可行的。
- en: Blocking also isn't usually acceptable on the client side either. If you imagine
    building a fast web browser, it needs to be able to download many images, scripts,
    and other resources in parallel. Modern web browsers also have a **tab** feature
    where many whole web pages can be loaded in parallel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，阻塞通常也是不可接受的。如果你想象构建一个快速的网页浏览器，它需要能够并行下载许多图片、脚本和其他资源。现代网页浏览器还拥有一个**标签页**功能，其中许多整个网页可以并行加载。
- en: What we need is a technique for handling many separate connections simultaneously.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种同时处理多个单独连接的技术。
- en: Polling non-blocking sockets
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询非阻塞套接字
- en: It is possible to configure sockets to use a non-blocking operation. One way
    to do this is by calling `fcntl()` with the `O_NONBLOCK` flag (`ioctlsocket()`
    with the `FIONBIO` flag on Windows), although other ways also exist. Once in non-blocking
    mode, a call to `recv()` with no data will return immediately. See [Chapter 13](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml), *Socket
    Programming Tips and Pitfalls*, for more information.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置套接字使用非阻塞操作。一种方法是调用`fcntl()`并带有`O_NONBLOCK`标志（在Windows上使用`ioctlsocket()`并带有`FIONBIO`标志），尽管也存在其他方法。一旦进入非阻塞模式，对`recv()`的调用在没有数据的情况下会立即返回。有关更多信息，请参阅第13章，*套接字编程技巧和陷阱*。
- en: A program structured with this in mind could simply check each of its active
    sockets in turn, continuously. It would handle any socket that returned data and
    ignore any socket that didn't. This is called **polling**. Polling can be a waste
    of computer resources since most of the time, there will be no data to read. It
    also complicates the program somewhat, as the programmer is required to manually
    track which sockets are active and which state, they are in. Return values from
    `recv()` must also be handled differently than with blocking sockets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种思路构建的程序可以简单地依次检查其每个活跃套接字，持续不断地进行。它会处理任何返回数据的套接字，并忽略任何没有数据的套接字。这被称为**轮询**。轮询可能会浪费计算机资源，因为大多数时候，没有数据可读。这也使得程序变得有些复杂，因为程序员需要手动跟踪哪些套接字是活跃的以及它们的状态。从`recv()`返回的值也必须与阻塞套接字的处理方式不同。
- en: For these reasons, we won't use polling in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们在这本书中不会使用轮询。
- en: Forking and multithreading
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支和线程
- en: Another possible solution to multiplexing socket connections is to start a new
    thread or process for each connection. In this case, blocking sockets are fine,
    as they block only their servicing thread/process, and they do not block other
    threads/processes. This can be a useful technique, but it also has some downsides.
    First of all, threading is tricky to get right. This is especially true if the
    connections must share any state between them. It is also less portable as each
    operating system provides a different API for these features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的解决方案是针对每个连接启动一个新的线程或进程。在这种情况下，阻塞套接字是可以接受的，因为它们只阻塞其服务线程/进程，不会阻塞其他线程/进程。这可能是一种有用的技术，但它也有一些缺点。首先，线程编程比较复杂。如果连接之间必须共享任何状态，这一点尤其正确。它也相对不太便携，因为每个操作系统都为这些功能提供了不同的
    API。
- en: 'On Unix-based systems, such as Linux and macOS, starting a new process is very
    easy. We simply use the `fork()` function. The `fork()` function splits the executing
    program into two separate processes. A multi-process TCP server may accept connections
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Unix 的系统上，例如 Linux 和 macOS，启动一个新的进程非常简单。我们只需使用 `fork()` 函数。`fork()` 函数将正在执行的程序分割成两个独立的进程。一个多进程
    TCP 服务器可以像这样接受连接：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the program blocks on `accept()`. When a new connection is
    established, the program calls `fork()` to split into two processes. The child
    process, where `pid == 0`, only services this one connection. Therefore, the child
    process can use `recv()` freely without worrying about blocking. The parent process
    simply calls `close()` on the new connection and returns to listening for more
    connections with `accept()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序在 `accept()` 上阻塞。当建立新的连接时，程序调用 `fork()` 来分割成两个进程。子进程（`pid == 0`），只服务这个连接。因此，子进程可以自由使用
    `recv()` 而不用担心阻塞。父进程只是在新连接上调用 `close()` 并返回，继续使用 `accept()` 监听更多连接。
- en: Using multiple processes/threads is much more complicated on Windows. Windows
    provides `CreateProcess()`, `CreateThread()`, and many other functions for these
    features. However—and I can say this objectively—they are all much harder to use
    than Unix's `fork()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上使用多个进程/线程要复杂得多。Windows 提供了 `CreateProcess()`、`CreateThread()` 以及许多其他用于这些功能的函数。然而——我可以客观地说——它们的使用难度都比
    Unix 的 `fork()` 函数要高。
- en: Debugging these multi-process/thread programs can be much more difficult compared
    to the single process case. Communicating between sockets and managing shared
    state is also much more burdensome. For these reasons, we will avoid `fork()`
    and other multi-process/thread techniques for the rest of this book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与单进程情况相比，调试这些多进程/线程程序可能要困难得多。在套接字之间进行通信和管理共享状态也更加繁重。因此，我们将避免在本书的其余部分使用 `fork()`
    和其他多进程/线程技术。
- en: That being said, an example TCP server using fork is included in this chapter's
    code. It's named `tcp_serve_toupper_fork.c`. It does not run on Windows, but it
    should compile and run cleanly on Linux and macOS. I would suggest finishing the
    rest of this chapter before looking at it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，本章代码中包含了一个使用 `fork()` 的示例 TCP 服务器。它命名为 `tcp_serve_toupper_fork.c`。它不能在
    Windows 上运行，但它应该在 Linux 和 macOS 上编译和干净地运行。我建议在查看它之前完成本章的其余部分。
- en: The select() function
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`select()` 函数'
- en: Our preferred technique for multiplexing is to use the `select()` function.
    We can give `select()` a set of sockets, and it tells us which ones are ready
    to be read. It can also tell us which sockets are ready to write to and which
    sockets have exceptions. Furthermore, it is supported by both Berkeley sockets
    and Winsock. Using `select()` keeps our programs portable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首选的多路复用技术是使用 `select()` 函数。我们可以给 `select()` 提供一组套接字，它会告诉我们哪些套接字准备好读取。它还可以告诉我们哪些套接字准备好写入，以及哪些套接字有异常。此外，它由
    Berkeley 套接字和 Winsock 都支持。使用 `select()` 可以保持我们的程序便携性。
- en: Synchronous multiplexing with select()
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `select()` 进行同步多路复用
- en: The `select()` function has several useful features. Given a set of sockets,
    it can be used to block until any of the sockets in that set is ready to be read
    from. It can also be configured to return if a socket is ready to be written to
    or if a socket has an error. Additionally, we can configure `select()` to return
    after a specified time if none of these events take place.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 函数有几个有用的特性。给定一组套接字，它可以用来阻塞，直到该组中的某个套接字准备好读取。它还可以配置为在套接字准备好写入或套接字出现错误时返回。此外，我们还可以配置
    `select()` 在没有这些事件发生的情况下，在指定时间后返回。'
- en: 'The C function prototype for `select()` is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 函数的 C 函数原型如下：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before calling `select()`, we must first add our sockets into an `fd_set`.
    If we have three sockets, `socket_listen`, `socket_a`, and `socket_b`, we add
    them to an `fd_set`, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `select()` 之前，我们必须首先将我们的套接字添加到一个 `fd_set` 中。如果我们有三个套接字，`socket_listen`、`socket_a`
    和 `socket_b`，我们将它们添加到一个 `fd_set` 中，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is important to zero-out the `fd_set` using `FD_ZERO()` before use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，非常重要的一点是使用 `FD_ZERO()` 将 `fd_set` 清零。
- en: Socket descriptors are then added to the `fd_set` one at a time using `FD_SET()`.
    A socket can be removed from an `fd_set` using `FD_CLR()`, and we can check for
    the presence of a socket in the set using `FD_ISSET()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `FD_SET()` 逐个将套接字描述符添加到 `fd_set` 中。可以使用 `FD_CLR()` 从 `fd_set` 中移除一个套接字，并且我们可以使用
    `FD_ISSET()` 检查套接字是否存在于集合中。
- en: You may see some programs manipulating an `fd_set` directly. I recommend that
    you use only `FD_ZERO()`, `FD_SET()`, `FD_CLR()`, and `FD_ISSET()` to maintain
    portability between Berkeley sockets and Winsock.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些程序直接操作 `fd_set`。我建议你只使用 `FD_ZERO()`、`FD_SET()`、`FD_CLR()` 和 `FD_ISSET()`
    来保持伯克利套接字和 Winsock 之间的可移植性。
- en: '`select()` also requires that we pass a number that''s larger than the largest
    socket descriptor we are going to monitor. (This parameter is ignored on Windows,
    but we will always do it anyway for portability.) We store the largest socket
    descriptor in a variable, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 还要求我们传递一个比我们要监控的最大套接字描述符更大的数字。（在 Windows 上，此参数被忽略，但我们仍然会这样做以提高可移植性。）我们将最大的套接字描述符存储在一个变量中，如下所示：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we call `select()`, it modifies our `fd_set` of sockets to indicate which
    sockets are ready. For that reason, we want to copy our socket set before calling
    it. We can copy an `fd_set` with a simple assignment like this, and then call
    `select()` like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `select()` 时，它会修改我们的套接字 `fd_set` 来指示哪些套接字已准备好。因此，我们在调用它之前想要复制我们的套接字集。我们可以通过简单的赋值来复制一个
    `fd_set`，然后像这样调用 `select()`：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This call blocks until at least one of the sockets is ready to be read from.
    When `select()` returns, `copy` is modified so that it only contains the sockets
    that are ready to be read from. We can check which sockets are still in `copy`
    using `FD_ISSET()`, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用会阻塞，直到至少有一个套接字准备好读取。当 `select()` 返回时，`copy` 被修改，使其只包含准备好读取的套接字。我们可以使用 `FD_ISSET()`
    检查哪些套接字仍然在 `copy` 中，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous example, we passed our `fd_set` as the second argument to `select()`.
    If we wanted to monitor an `fd_set` for writability instead of readability, we
    would pass our `fd_set` as the third argument to `select()`. Likewise, we can
    monitor a set of sockets for exceptions by passing it as the fourth argument to
    `select()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将我们的 `fd_set` 作为 `select()` 的第二个参数传递。如果我们想监控 `fd_set` 的可写性而不是可读性，我们将
    `fd_set` 作为 `select()` 的第三个参数传递。同样，我们可以通过将 `fd_set` 作为 `select()` 的第四个参数传递来监控套接字集合的异常。
- en: select() timeout
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`select()` 超时'
- en: 'The last argument taken by `select()` allows us to specify a timeout. It expects
    a pointer to `struct timeval`. The `timeval` structure is declared as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 的最后一个参数允许我们指定一个超时时间。它期望一个指向 `struct timeval` 的指针。`timeval` 结构体声明如下：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`tv_sec` holds the number of seconds, and `tv_usec` holds the number of microseconds
    (1,000,000th second). If we want `select()` to wait a maximum of 1.5 seconds,
    we can call it like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`tv_sec` 包含秒数，`tv_usec` 包含微秒数（1/1,000,000 秒）。如果我们想让 `select()` 等待最多 1.5 秒，我们可以这样调用它：'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `select()` returns after a socket in `fd_set copy` is ready to
    read or after 1.5 seconds has elapsed, whichever is sooner.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`select()` 在 `fd_set copy` 中的套接字准备好读取或经过 1.5 秒后返回，以先到者为准。
- en: If `timeout.tv_sec = 0` and `timeout.tv_usec = 0`, then `select()` returns immediately
    (after changing the `fd_set` as appropriate). As we saw previously, if we pass
    in a null pointer for the timeout parameter, then `select()` does not return until
    at least one socket is ready to be read.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `timeout.tv_sec = 0` 且 `timeout.tv_usec = 0`，则 `select()` 立即返回（在适当更改 `fd_set`
    之后）。正如我们之前看到的，如果我们为超时参数传递一个空指针，那么 `select()` 不会返回，直到至少有一个套接字准备好读取。
- en: '`select()` can also be used to monitor for writeable sockets (sockets where
    we could call `send()` without blocking), and sockets with exceptions. We can
    check for all three conditions with one call:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 还可以用来监控可写套接字（我们可以调用 `send()` 而不会阻塞的套接字），以及带有异常的套接字。我们可以通过一个调用检查所有三个条件：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On success, `select()` itself returns the number of socket descriptors contained
    in the (up to) three descriptor sets it monitored. The return value is zero if
    it timed out before any sockets were readable/writeable/excepted. `select()` returns
    `-1` to indicate an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，`select()`自身返回它所监控的（最多）三个描述符集中的套接字描述符数量。如果在任何套接字可读/可写/异常之前超时，则返回值为零。`select()`返回`-1`以指示错误。
- en: Iterating through an fd_set
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历fd_set
- en: 'We can iterate through an `fd_set` using a simple `for` loop. Essentially,
    we start at `1`, since all socket descriptors are positive numbers, and we continue
    through to the largest known socket descriptor in the set. For each possible socket
    descriptor, we simply use `FD_ISSET()` to check if it is in the set. If we wanted
    to call `CLOSESOCKET()` for every socket in the `fd_set master`, we could do it
    like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的`for`循环遍历`fd_set`。本质上，我们从`1`开始，因为所有套接字描述符都是正数，然后继续到集合中已知的最大套接字描述符。对于每个可能的套接字描述符，我们只需使用`FD_ISSET()`来检查它是否在集合中。如果我们想为`fd_set
    master`中的每个套接字调用`CLOSESOCKET()`，我们可以这样做：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This may seem like a brute-force approach, and it actually kind of is. However,
    these are the tools that we have to work with. `FD_ISSET()` runs very fast, and
    it's likely that processor time spent on other socket operations will dwarf what
    time was spent iterating through them in this manner. Nevertheless, you may be
    able to optimize this operation by additionally storing your sockets in an array
    or linked list. I don't recommend that you make this optimization unless you profile
    your code and find the simple `for` loop iteration to be a significant bottleneck.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一种暴力方法，实际上确实如此。然而，这些是我们必须使用的工具。`FD_ISSET()`运行非常快，并且处理器在其它套接字操作上花费的时间可能会远远超过以这种方式遍历它们所花费的时间。尽管如此，你可能可以通过将你的套接字存储在数组或链表中来优化这个操作。除非你分析了你的代码并发现简单的`for`循环迭代是一个显著的瓶颈，否则我不建议你进行这种优化。
- en: select() on non-sockets
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非套接字的select()
- en: On Unix-based systems, `select()` can also be used on file and terminal I/O,
    which can be extremely useful. This doesn't work on Windows, though. Windows only
    supports `select()` for sockets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的系统上，`select()`也可以用于文件和终端I/O，这可以非常实用。不过，在Windows上则不行。Windows只支持`select()`用于套接字。
- en: A TCP client
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP客户端
- en: It will be useful for us to have a TCP client that can connect to any TCP server.
    This TCP client will take in a hostname (or IP address) and port number from the
    command line. It will attempt a connection to the TCP server at that address.
    If successful, it will relay data that's received from that server to the terminal
    and data inputted into the terminal to the server. It will continue until either
    it is terminated (with *Ctrl* + *C*) or the server closes the connection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可以连接到任何TCP服务器的TCP客户端对我们来说将非常有用。这个TCP客户端将从命令行接收主机名（或IP地址）和端口号。它将尝试连接到该地址的TCP服务器。如果成功，它将把从该服务器接收到的数据中继到终端，并将终端输入的数据发送到服务器。它将继续，直到它被终止（使用*Ctrl*
    + *C*）或服务器关闭连接。
- en: This is useful as a learning opportunity to see how to program a TCP client,
    but it is also useful for testing the TCP server programs we develop throughout
    this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于学习如何编写TCP客户端程序非常有用，同时也有助于测试本书中开发的TCP服务器程序。
- en: 'Our basic program flow looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本程序流程看起来是这样的：
- en: '![](img/d04d1605-edf2-4448-9b03-e74e04d07a08.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d04d1605-edf2-4448-9b03-e74e04d07a08.png)'
- en: Our program first uses `getaddrinfo()` to resolve the server address from the
    command-line arguments. Then, the socket is created with a call to `socket()`.
    The fresh socket has `connect()` called on it to connect to the server. We use
    `select()` to monitor for socket input. `select()` also monitors for terminal/keyboard
    input on non-Windows systems. On Windows, we use the `_kbhit()` function to detect
    terminal input. If terminal input is available, we send it over the socket using
    `send()`. If `select()` indicated that socket data is available, we read it with
    `recv()` and display it to the terminal. This `select()` loop is repeated until
    the socket is closed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序首先使用`getaddrinfo()`从命令行参数解析服务器地址。然后，通过调用`socket()`创建套接字。新套接字上调用`connect()`以连接到服务器。我们使用`select()`来监控套接字输入。`select()`在非Windows系统上还会监控终端/键盘输入。在Windows上，我们使用`_kbhit()`函数来检测终端输入。如果终端输入可用，我们使用`send()`通过套接字发送它。如果`select()`指示套接字数据可用，我们使用`recv()`读取它并将它显示到终端。这个`select()`循环会一直重复，直到套接字关闭。
- en: TCP client code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP客户端代码
- en: 'We begin our TCP client by including the header file, `chap03.h`, which was
    printed at the beginning of this chapter. This header file includes the various
    other headers and macros we need for cross-platform networking:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过包含本章开头打印的标题文件`chap03.h`来开始我们的TCP客户端。这个标题文件包含了我们进行跨平台网络所需的各个其他标题和宏：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Windows, we also need the `conio.h` header. This is required for the `_kbhit()`
    function, which helps us by indicating whether terminal input is waiting. We conditionally
    include this header, like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们还需要`conio.h`标题。这是必需的，因为`_kbhit()`函数，它通过指示终端输入是否等待来帮助我们。我们条件性地包含这个标题，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then begin the `main()` function and initialize Winsock:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始`main()`函数并初始化Winsock：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We would like our program to take the hostname and port number of the server
    it should connect to as command-line arguments. This makes our program flexible.
    We have our program check that these command-line arguments are given. If they
    aren''t, it displays usage information:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的程序接受它应该连接的服务器的域名和端口号作为命令行参数。这使得我们的程序更加灵活。我们的程序会检查是否提供了这些命令行参数。如果没有，它将显示用法信息：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`argc` contains the number of argument values available to us. Because the
    first argument is always our program''s name, we check that there is a total of
    at least three arguments. The actual values themselves are stored in `argv[]`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`argc`包含我们可用的参数值数量。因为第一个参数总是我们的程序名，所以我们检查总共有至少三个参数。实际的值存储在`argv[]`中。'
- en: 'We then use these values to configure a remote address for connection:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这些值来配置远程地址以建立连接：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is similar to how we called `getaddrinfo()` in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. However, in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*, we wanted it to configure a local address,
    whereas this time, we want it to configure a remote address.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握套接字API”中调用`getaddrinfo()`的方式相似。然而，在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握套接字API”中，我们希望它配置本地地址，而这次，我们希望它配置远程地址。
- en: We set `hints.ai_socktype = SOCK_STREAM` to tell `getaddrinfo()` that we want
    a TCP connection. Remember that we could set `SOCK_DGRAM` to indicate a UDP connection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`hints.ai_socktype = SOCK_STREAM`设置为告诉`getaddrinfo()`我们想要一个TCP连接。记住，我们可以将`SOCK_DGRAM`设置为指示UDP连接。
- en: In [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips
    with Socket APIs*, we also set the family. We don't need to set the family here,
    as we can let `getaddrinfo()` decide if IPv4 or IPv6 is the proper protocol to
    use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握套接字API”，我们也设置了族。在这里我们不需要设置族，因为我们可以让`getaddrinfo()`决定使用IPv4还是IPv6作为合适的协议。
- en: For the call to `getaddrinfo()` itself, we pass in the hostname and port as
    the first two arguments. These are passed directly in from the command line. If
    they aren't suitable, then `getaddrinfo()` returns non-zero and we print an error
    message. If everything goes well, then our remote address is in the `peer_address`
    variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`getaddrinfo()`本身的调用，我们传入主机名和端口号作为前两个参数。这些参数直接从命令行传入。如果它们不合适，则`getaddrinfo()`返回非零值，并打印错误信息。如果一切顺利，则远程地址存储在`peer_address`变量中。
- en: '`getaddrinfo()` is very flexible about how it takes inputs. The hostname could
    be a domain name like `example.com` or an IP address such as `192.168.17.23` or
    `::1`. The port can be a number, such as `80`, or a protocol, such as `http`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()`在接收输入方面非常灵活。主机名可以是域名，如`example.com`，或IP地址，如`192.168.17.23`或`::1`。端口号可以是数字，如`80`，或协议，如`http`。'
- en: 'After `getaddrinfo()` configures the remote address, we print it out. This
    isn''t really necessary, but it is a good debugging measure. We use `getnameinfo()`
    to convert the address back into a string, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getaddrinfo()`配置远程地址后，我们将其打印出来。这实际上并不是必需的，但这是一个很好的调试措施。我们使用`getnameinfo()`将地址转换回字符串，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then create our socket:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建我们的套接字：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This call to `socket()` is done in exactly the same way as it was in [Chapter
    2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips with Socket
    APIs*. We use `peer_address` to set the proper socket family and protocols. This
    keeps our program very flexible, as the `socket()` call creates an IPv4 or IPv6
    socket as needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对`socket()`的调用与[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握套接字API”中的调用方式完全相同。我们使用`peer_address`来设置正确的套接字族和协议。这使得我们的程序非常灵活，因为`socket()`调用会根据需要创建IPv4或IPv6套接字。
- en: 'After the socket has been created, we call `connect()` to establish a connection
    to the remote server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字创建之后，我们调用`connect()`来与远程服务器建立连接：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`connect()` takes three arguments—the socket, the remote address, and the remote
    address length. It returns `0` on success, so we print an error message if it
    returns non-zero. This call to `connect()` is extremely similar to how we called
    `bind()` in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting
    to Grips with Socket APIs*. Where `bind()` associates a socket with a local address,
    `connect()` associates a socket with a remote address and initiates the TCP connection.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`函数接受三个参数——套接字、远程地址和远程地址长度。成功时返回`0`，因此如果它返回非零值，我们打印一条错误消息。这个`connect()`调用与我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，《掌握Socket
    API》中调用`bind()`的方式极为相似。其中`bind()`将套接字与本地地址关联，而`connect()`将套接字与远程地址关联并初始化TCP连接。'
- en: After we've called `connect()` with `peer_address`, we use the `freeaddrinfo()`
    function to free the memory for `peer_address`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`peer_address`调用`connect()`之后，我们使用`freeaddrinfo()`函数释放`peer_address`的内存。
- en: 'If we''ve made it this far, then a TCP connection has been established to the
    remote server. We let the user know by printing a message and instructions on
    how to send data:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经到达这里，那么已经与远程服务器建立了TCP连接。我们通过打印一条消息和发送数据的说明来通知用户：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our program should now loop while checking both the terminal and socket for
    new data. If new data comes from the terminal, we send it over the socket. If
    new data is read from the socket, we print it out to the terminal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序现在应该循环检查终端和套接字是否有新数据。如果终端有新数据，我们通过套接字发送它。如果从套接字读取到新数据，我们将其打印到终端。
- en: 'It is clear we cannot call `recv()` directly here. If we did, it would block
    until data comes from the socket. In the meantime, if our user enters data on
    the terminal, that input is ignored. Instead, we use `select()`. We begin our
    loop and set up the call to `select()`, like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们在这里不能直接调用`recv()`。如果我们这样做，它将阻塞，直到从套接字接收数据。在此期间，如果我们的用户在终端输入数据，该输入将被忽略。相反，我们使用`select()`。我们开始循环并设置对`select()`的调用，如下所示：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we declare a variable, `fd_set reads`, to store our socket set. We then
    zero it with `FD_ZERO()` and add our only socket, `socket_peer`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个变量，`fd_set reads`，用于存储我们的套接字集合。然后我们使用`FD_ZERO()`将其清零，并添加我们的唯一套接字，`socket_peer`。
- en: On non-Windows systems, we also use `select()` to monitor for terminal input.
    We add `stdin` to the `reads` set with `FD_SET(0, &reads)`. This works because
    `0` is the file descriptor for `stdin`. Alternatively, we could have used `FD_SET(fileno(stdin),
    &reads)` to the same effect.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在非Windows系统上，我们同样使用`select()`来监控终端输入。我们通过`FD_SET(0, &reads)`将`stdin`添加到`reads`集合中。这是因为`0`是`stdin`的文件描述符。或者，我们也可以使用`FD_SET(fileno(stdin),
    &reads)`达到相同的效果。
- en: The Windows `select()` function only works on sockets. Therefore, we cannot
    use `select()` to monitor for console input. For this reason, we set up a timeout
    to the `select()` call for 100 milliseconds (100,000 microseconds). If there is
    no socket activity after 100 milliseconds, `select()` returns, and we can check
    for terminal input manually.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的`select()`函数仅在套接字上工作。因此，我们无法使用`select()`来监控控制台输入。因此，我们将`select()`调用的超时设置为100毫秒（100,000微秒）。如果在100毫秒后没有套接字活动，`select()`返回，我们可以手动检查终端输入。
- en: 'After `select()` returns, we check to see whether our socket is set in `reads`.
    If it is, then we know to call `recv()` to read the new data. The new data is
    printed to the console with `printf()`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select()`函数返回后，我们检查我们的套接字是否被设置为`reads`。如果是，那么我们知道需要调用`recv()`来读取新数据。新数据通过`printf()`打印到控制台：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember, the data from `recv()` is not null terminated. For this reason, we
    use the `%.*s` `printf()` format specifier, which prints a string of a specified
    length.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`recv()`返回的数据不是以空字符终止的。因此，我们使用`%.*s` `printf()`格式说明符，它打印指定长度的字符串。
- en: '`recv()` normally returns the number of bytes read. If it returns less than
    `1`, then the connection has ended, and we break out of the loop to shut it down.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`recv()`通常返回读取的字节数。如果它返回小于`1`，则表示连接已结束，我们跳出循环以关闭它。'
- en: 'After checking for new TCP data, we also need to check for terminal input:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查新的TCP数据之后，我们还需要检查终端输入：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On Windows, we use the `_kbhit()` function to indicate whether any console input
    is waiting. `_kbhit()` returns non-zero if an unhandled key press event is queued
    up. For Unix-based systems, we simply check if `select()` sets the `stdin` file
    descriptor, `0`. If input is ready, we call `fgets()` to read the next line of
    input. This input is then sent over our connected socket with `send()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们使用 `_kbhit()` 函数来指示是否有任何控制台输入等待。如果有一个未处理的关键事件被排队，则 `_kbhit()`
    返回非零值。对于基于 Unix 的系统，我们只需检查 `select()` 是否设置了 `stdin` 文件描述符，即 `0`。如果输入准备就绪，我们调用
    `fgets()` 来读取下一行输入。然后，通过 `send()` 将此输入发送到我们的连接套接字。
- en: Note that `fgets()` includes the newline character from the input. Therefore,
    our sent input always ends with a newline.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`fgets()` 包含输入中的换行符。因此，我们发送的输入总是以换行符结束。
- en: If the socket has closed, `send()` returns `-1`. We ignore this case here. This
    is because a closed socket causes `select()` to return immediately, and we notice
    the closed socket on the next call to `recv()`. This is a common paradigm in TCP
    socket programming to ignore errors on `send()` while detecting and handling them
    on `recv()`. It allows us to simplify our program by keeping our connection closing
    logic all in one place. Later in this chapter, we will discuss other concerns
    regarding `send()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字已关闭，`send()` 返回 `-1`。在这里我们忽略这种情况。这是因为关闭的套接字会导致 `select()` 立即返回，我们在下一次调用
    `recv()` 时注意到关闭的套接字。这在 TCP 套接字编程中是一个常见的范式，即在 `send()` 上忽略错误，而在 `recv()` 上检测和处理它们。这允许我们将连接关闭逻辑全部放在一个地方，从而简化我们的程序。在本章的后面部分，我们将讨论关于
    `send()` 的其他一些问题。
- en: This `select()` based terminal monitoring works very well on Unix-based systems.
    It also works equally well if input is piped in. For example, you could use our
    TCP client program to send a text file with a command such as `cat my_file.txt
    | tcp_client 192.168.54.122 8080`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `select()` 的终端监控在基于 Unix 的系统上工作得非常好。如果输入是通过管道传入的，它也工作得同样好。例如，您可以使用我们的 TCP
    客户端程序通过以下命令发送一个文本文件：`cat my_file.txt | tcp_client 192.168.54.122 8080`。
- en: The Windows terminal handling leaves a bit to be desired. Windows does not provide
    an easy way to tell whether `stdin` has input available without blocking, so we
    use `_kbhit()` as a poor proxy. However, if the user presses a non-printable key,
    such as an arrow key, it still triggers `_kbhit()`, even though there is no character
    to read. Also, after the first key press, our program will block on `fgets()`
    until the user presses the *Enter* key. (This doesn't happen on shells that buffer
    entire lines, which is common outside of Windows.) This blocking behavior is acceptable,
    but you should know that any received TCP data will not display until after that
    point. `_kbhit()` does not work for piped input. Doing proper piped and console
    input on Windows is possible, of course, but it's very complicated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 终端处理还有待提高。Windows 不提供一种在不阻塞的情况下轻松判断 `stdin` 是否有输入可用的方法，所以我们使用 `_kbhit()`
    作为一种较差的代理。然而，如果用户按下不可打印的键，例如箭头键，它仍然会触发 `_kbhit()`，即使没有可读的字符。此外，在第一次按键后，我们的程序将在
    `fgets()` 上阻塞，直到用户按下 *Enter* 键。（在 Windows 外部，通常在 shell 中缓冲整行，这种情况不会发生。）这种阻塞行为是可以接受的，但您应该知道，任何接收到的
    TCP 数据都将在此点之后才显示出来。`_kbhit()` 不适用于管道输入。当然，在 Windows 上进行适当的管道和控制台输入是可能的，但这非常复杂。
- en: We would need to use separate functions for each (`PeekNamedPipe()` and `PeekConsoleInput()`),
    and the logic for handling it would be as long as this entire program! Since handling
    terminal input isn't the purpose of this book, we're going to accept `_kbhit()`
    function's limitations and move on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个（`PeekNamedPipe()` 和 `PeekConsoleInput()`）使用单独的函数，并且处理它们的逻辑将和整个程序一样长！由于处理终端输入不是本书的目的，我们将接受
    `_kbhit()` 函数的限制并继续前进。
- en: 'At this point, our program is essentially done. We can end the `while` loop,
    close our socket, and clean up Winsock:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的程序基本上已经完成。我们可以结束 `while` 循环，关闭我们的套接字，并清理 Winsock：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s the complete program. You can compile it on Linux and macOS like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完整的程序。您可以在 Linux 和 macOS 上像这样编译它：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compiling on Windows with MinGW is done like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上使用 MinGW 编译是这样做的：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run the program, remember to pass in the remote hostname/address and port
    number, for example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，请记住传递远程主机名/地址和端口号，例如：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can use the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A fun way to test out the TCP client would be to connect to a live web server
    and send an HTTP request. For example, you could connect to `example.com` on port
    `80` and send the following HTTP request:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 TCP 客户端的一个有趣方法是连接到一个实时 Web 服务器并发送一个 HTTP 请求。例如，您可以在端口 `80` 上连接到 `example.com`
    并发送以下 HTTP 请求：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You must then send a blank line to indicate the end of the request. You''ll
    receive an HTTP response back. It might look something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你必须发送一个空白行来表示请求的结束。你将收到一个HTTP响应。它可能看起来像这样：
- en: '![](img/50a2358c-a619-4c07-b9d2-2bf0fcab6df6.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50a2358c-a619-4c07-b9d2-2bf0fcab6df6.png)'
- en: A TCP server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个TCP服务器
- en: Microservices have become increasingly popular in recent years. The idea of
    microservices is that large programming problems can be split up into many small
    subsystems that communicate over a network. For example, if your program needs
    to format a string, you could add code to your program to do that, but writing
    code is hard. Alternatively, you could keep your program simple and instead connect
    to a service that provides string formatting for you. This has the added advantage
    that many programs can use this same service without reinventing the wheel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微服务变得越来越流行。微服务的想法是将大型编程问题分解成许多小的子系统，这些子系统通过网络进行通信。例如，如果你的程序需要格式化字符串，你可以在程序中添加代码来做这件事，但编写代码是困难的。或者，你可以保持程序简单，并连接到一个为你提供字符串格式化的服务。这还有一个额外的优点，即许多程序可以使用这个相同的服务，而无需重新发明轮子。
- en: Unfortunately, the microservice paradigm has largely avoided the C ecosystem; until
    now!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，微服务范式在很大程度上避开了C生态系统；直到现在！
- en: As a motivating example, we are going to build a TCP server that converts strings
    into uppercase. If a client connects and sends `Hello`, then our program will
    send `HELLO` back. This will serve as a very basic microservice. Of course, a
    real-world microservice might do something a bit more advanced (such as left-pad
    a string), but this to-uppercase service works well for our pedagogical purposes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为激励性的例子，我们将构建一个将字符串转换为大写的TCP服务器。如果客户端连接并发送 `Hello`，那么我们的程序将发送 `HELLO` 回去。这将作为一个非常基础的微服务。当然，现实世界的微服务可能会做些更高级的事情（比如左填充字符串），但这个将字符串转换为大写的服务非常适合我们的教学目的。
- en: For our microservice to be useful, it does need to handle many simultaneous
    incoming connections. We again use `select()` to see which connections need to
    be serviced.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的微服务变得有用，它确实需要处理许多同时传入的连接。我们再次使用 `select()` 来查看哪些连接需要服务。
- en: 'Our basic program flow looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本程序流程如下：
- en: '![](img/59ec80b4-72b4-426a-848a-b3b13d71490c.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59ec80b4-72b4-426a-848a-b3b13d71490c.png)'
- en: Like in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to
    Grips with Socket APIs*, our TCP server uses `getaddrinfo()` to obtain the local
    address to listen on. It creates a socket with `socket()`, uses `bind()` to associate
    the local address to the socket, and uses `listen()` to begin listening for new
    connections. Up until that point, it is essentially identical to our TCP server
    from [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips
    with Socket APIs*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握Socket API*中一样，我们的TCP服务器使用
    `getaddrinfo()` 获取要监听的本地地址。它使用 `socket()` 创建一个套接字，使用 `bind()` 将本地地址关联到套接字，并使用
    `listen()` 开始监听新的连接。直到那时，它与[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握Socket
    API*中的我们的TCP服务器基本相同。
- en: However, our next step is not to call `accept()` to wait for new connections.
    Instead, we call `select()`, which alerts us if a new connection is available
    or if any of our established connections have new data ready. Only when we know
    that a new connection is waiting do we call `accept()`. All established connections
    are put into an `fd_set`, which is passed to every subsequent `select()` call.
    In this same way, we know which connections would block on `recv()`, and we only
    service those connections that we know will not block.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的下一步不是调用 `accept()` 来等待新的连接。相反，我们调用 `select()`，它会通知我们是否有新的连接可用，或者我们的任何已建立连接是否有新数据准备好。只有当我们知道有新的连接等待时，我们才调用
    `accept()`。所有已建立的连接都放入一个 `fd_set` 中，该集合被传递给每个后续的 `select()` 调用。以同样的方式，我们知道哪些连接会在
    `recv()` 上阻塞，我们只为那些我们知道不会阻塞的连接提供服务。
- en: When data is received by `recv()`, we run it through `toupper()` and return
    it to the client using `send()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过 `recv()` 接收时，我们通过 `toupper()` 处理它，并使用 `send()` 将其返回给客户端。
- en: This is a complicated program with several new concepts. Don't worry about understanding
    all the details right now. The flow is only intended to give you an overview of
    what to expect before we dive into the actual code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含许多新概念的复杂程序。现在不必担心理解所有细节。这个流程只是为了在我们深入研究实际代码之前，给你一个预期的概览。
- en: TCP server code
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP服务器代码
- en: 'Our TCP server code begins by including the needed headers, starting `main()`,
    and initializing Winsock. Refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting
    to Grips with Socket APIs*, if this doesn''t seem familiar:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 TCP 服务器代码首先包含所需的头文件，开始 `main()`，并初始化 Winsock。如果这看起来不熟悉，请参阅 [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，《掌握套接字
    API》：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then get our local address, create our socket, and `bind()`. This is all
    done exactly as explained in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取本地地址，创建套接字，并执行 `bind()`。这一切都按照 [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，《掌握套接字
    API》中所述的方式进行：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that we are going to listen on port `8080`. You can, of course, change
    that. We're also doing an IPv4 server here. If you want to listen for connections
    on IPv6, then just change `AF_INET` to `AF_INET6`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将监听端口 `8080`。当然，您可以更改它。我们这里也在做 IPv4 服务器。如果您想监听 IPv6 连接，只需将 `AF_INET` 更改为
    `AF_INET6`。
- en: 'We then `bind()` our socket to the local address and have it enter a listening
    state. Again, this is done exactly as in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将套接字绑定到本地地址，并使其进入监听状态。同样，这完全按照 [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，《掌握套接字
    API》中所述的方式进行：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is the point where we diverge from our earlier methods. We now define
    an `fd_set` structure that stores all of the active sockets. We also maintain
    a `max_socket` variable, which holds the largest socket descriptor. For now, we
    add only our listening socket to the set. Because it''s the only socket, it must
    also be the largest, so we set `max_socket = socket_listen` too:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们与之前方法的分歧点。我们现在定义一个 `fd_set` 结构，用于存储所有活动套接字。我们还维护一个 `max_socket` 变量，它保存最大的套接字描述符。目前，我们只将监听套接字添加到集合中。因为它是最唯一的套接字，所以它也必须是最大的，因此我们将
    `max_socket = socket_listen` 也设置好：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Later in the program, we will add new connections to `master` as they are established.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序稍后部分，我们将随着新连接的建立将它们添加到 `master`。
- en: 'We then print a status message, enter the main loop, and set up our call to
    `select()`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印状态消息，进入主循环，并设置我们的 `select()` 调用：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This works by first copying our `fd_set master` into `reads`. Recall that `select()`
    modifies the set given to it. If we didn't copy `master`, we would lose its data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过首先将我们的 `fd_set master` 复制到 `reads` 中来实现的。记住，`select()` 会修改它所提供的集合。如果我们没有复制
    `master`，我们就会丢失其数据。
- en: We pass a timeout value of `0` (NULL) to `select()` so that it doesn't return
    until a socket in the `master` set is ready to be read from. At the beginning
    of our program, `master` only contains `socket_listen`, but as our program runs,
    we add each new connection to `master`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `0`（NULL）作为超时值传递给 `select()`，这样它就不会在 `master` 集合中的套接字准备好读取之前返回。在程序开始时，`master`
    只包含 `socket_listen`，但随着程序的运行，我们会将每个新的连接添加到 `master`。
- en: 'We now loop through each possible socket and see whether it was flagged by
    `select()` as being ready. If a socket, `X`, was flagged by `select()`, then `FD_ISSET(X,
    &reads)` is true. Socket descriptors are positive integers, so we can try every
    possible socket descriptor up to `max_socket`. The basic structure of our loop
    is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遍历每个可能的套接字，查看它是否被 `select()` 标记为已准备好。如果一个套接字 `X` 被标记为 `select()`，则 `FD_ISSET(X,
    &reads)` 为真。套接字描述符是正整数，因此我们可以尝试从 `max_socket` 到 `socket_descriptor` 的每个可能的套接字描述符。我们的循环的基本结构如下：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Remember, `FD_ISSET()` is only true for sockets that are ready to be read.
    In the case of `socket_listen`, this means that a new connection is ready to be
    established with `accept()`. For all other sockets, it means that data is ready
    to be read with `recv()`. We should first determine whether the current socket
    is the listening one or not. If it is, we call `accept()`. This code snippet and
    the one that follows replace the `//Handle socket` comment in the preceding code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`FD_ISSET()` 只对准备好读取的套接字为真。在 `socket_listen` 的情况下，这意味着一个新连接准备好通过 `accept()`
    建立连接。对于所有其他套接字，这意味着数据准备好通过 `recv()` 读取。我们首先确定当前套接字是否是监听套接字。如果是，我们调用 `accept()`。此代码片段和随后的代码替换了前面代码中的
    `//Handle socket` 注释：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the socket is `socket_listen`, then we `accept()` the connection much as
    we did in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to
    Grips with Socket APIs*. We use `FD_SET()` to add the new connection's socket
    to the `master` socket set. This allows us to monitor it with subsequent calls
    to `select()`. We also maintain `max_socket`. As a final step, this code prints
    out the client's address using `getnameinfo()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字是 `socket_listen`，那么我们就像在 [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)
    中所做的那样 `accept()` 连接。我们使用 `FD_SET()` 将新连接的套接字添加到 `master` 套接字集合中。这允许我们通过后续的 `select()`
    调用来监控它。我们还维护 `max_socket`。作为最后一步，此代码使用 `getnameinfo()` 打印出客户端的地址。
- en: 'If the socket `i` is not `socket_listen`, then it is instead a request for
    an established connection. In this case, we need to read it with `recv()`, convert
    it into uppercase using the built-in `toupper()` function, and send the data back:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字 `i` 不是 `socket_listen`，那么它就变成了对一个已建立连接的请求。在这种情况下，我们需要使用 `recv()` 来读取它，使用内置的
    `toupper()` 函数将其转换为大写，并将数据发送回去：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the client has disconnected, then `recv()` returns a non-positive number.
    In this case, we remove that socket from the `master` socket set, and we also
    call `CLOSESOCKET()` on it to clean up.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端断开连接，那么 `recv()` 返回一个非正数。在这种情况下，我们从 `master` 套接字集合中删除该套接字，并且我们还调用 `CLOSESOCKET()`
    来清理它。
- en: 'Our program is now almost finished. We can end the `if FD_ISSET()` statement,
    end the `for` loop, end the `while` loop, close the listening socket, and clean
    up Winsock:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序现在几乎完成了。我们可以结束 `if FD_ISSET()` 语句，结束 `for` 循环，结束 `while` 循环，关闭监听套接字，并清理
    Winsock：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our program is set up to continuously listen for connections, so the code after
    the end of the `while` loop will never run. Nevertheless, I believe it is still
    good practice to include it in case we program in functionality later to abort
    the `while` loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序被设置为持续监听连接，所以 `while` 循环结束后的代码永远不会运行。尽管如此，我相信将其包含在内仍然是良好的实践，以防我们以后需要添加终止
    `while` 循环的功能。
- en: 'That''s the complete to-uppercase microservice TCP server program. You can
    compile and run it on Linux and macOS like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完整的将小写转换为大写的微服务 TCP 服务器程序。您可以在 Linux 和 macOS 上编译并运行它，如下所示：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Compiling and running on Windows with MinGW is done like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MinGW 在 Windows 上编译和运行的方法如下：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can abort the program's execution with *Ctrl* + *C*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 *Ctrl* + *C* 来终止程序的执行。
- en: 'Once the program is running, I would suggest opening another terminal and running
    the `tcp_client` program from earlier to connect to it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序开始运行，我建议打开另一个终端，并运行之前提到的 `tcp_client` 程序来连接到它：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Anything you type in `tcp_client` should be sent back as uppercase. Here''s
    what this might look like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tcp_client` 中输入的任何内容都应该以大写形式发送回去。这可能看起来是这样的：
- en: '![](img/482b7508-43d9-41c7-93d0-d5cc53657617.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/482b7508-43d9-41c7-93d0-d5cc53657617.png)'
- en: As a test of the server program's functionality, try opening several additional
    terminals and connecting with `tcp_client`. Our server should be able to handle
    many simultaneous connections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试服务器程序的功能，请尝试打开几个额外的终端，并使用 `tcp_client` 进行连接。我们的服务器应该能够处理多个并发连接。
- en: Also included with this chapter's code is `tcp_serve_toupper_fork.c`. This program
    only runs on Unix-based operating systems, but it performs the same functions
    as `tcp_serve_toupper.c` by using `fork()` instead of `select()`. The `fork()` function
    is commonly used by TCP servers, so I think it's helpful to be familiar with it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码中还包含了 `tcp_serve_toupper_fork.c`。这个程序仅在基于 Unix 的操作系统上运行，但它通过使用 `fork()`
    而不是 `select()` 来执行与 `tcp_serve_toupper.c` 相同的功能。`fork()` 函数通常由 TCP 服务器使用，因此我认为熟悉它是很有帮助的。
- en: Building a chat room
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天室
- en: It is also possible, and common, to need to send data between connected clients.
    We can modify our `tcp_serve_toupper.c` program and make it a chat room pretty
    easily.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能，并且很常见，需要在连接的客户端之间发送数据。我们可以修改我们的 `tcp_serve_toupper.c` 程序，并很容易地将其变成一个聊天室。
- en: 'First, locate the following code in `tcp_serve_toupper.c`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `tcp_serve_toupper.c` 中找到以下代码：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Replace the preceding code with the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下代码：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This works by looping through all the sockets in the `master` set. For each
    socket, `j`, we check that it's not the listening socket and we check that it's
    not the same socket that sent the data in the first place. If it's not, we call
    `send()` to echo the received data to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过遍历 `master` 集合中的所有套接字来实现的。对于每个套接字 `j`，我们检查它不是监听套接字，并且它不是最初发送数据的同一个套接字。如果不是，我们调用
    `send()` 将接收到的数据回显到它。
- en: You can compile and run this program in the same way as the previous one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像上一个程序一样编译和运行此程序。
- en: 'On Linux and macOS, this is done as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上，操作如下：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On Windows, this is done as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，操作如下：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should open two or more additional windows and connect to it with the following
    code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该打开两个或更多额外的窗口，并使用以下代码连接到它：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Whatever you type in one of the `tcp_client` terminals get sent to all of the
    other connected terminals.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你在任何一个 `tcp_client` 终端中输入的内容都会发送到所有其他已连接的终端。
- en: 'Here is an example of what this may look like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明这可能看起来像什么：
- en: '![](img/43483e9f-e3bb-4cfe-ae88-7aaa4902c31b.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43483e9f-e3bb-4cfe-ae88-7aaa4902c31b.png)'
- en: In the preceding screenshot, I am running `tcp_serve_chat` in the upper-left
    terminal windows. The other three terminal windows are running `tcp_client`. As
    you can see, any text entered in one of the `tcp_client` windows is sent to the
    server, which relays it to the other two connected clients.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我在左上角的终端窗口中运行 `tcp_serve_chat`。其他三个终端窗口正在运行 `tcp_client`。正如你所看到的，在任何一个
    `tcp_client` 窗口中输入的任何文本都会发送到服务器，服务器将其转发给其他两个已连接的客户端。
- en: Blocking on send()
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在发送时阻塞
- en: When we call `send()` with an amount of data, `send()` first copies this data
    into an outgoing buffer provided by the operating system. If we call `send()`
    when its outgoing buffer is already full, it blocks until its buffer has emptied
    enough to accept more of our data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用一定量的数据调用 `send()` 时，`send()` 首先将这些数据复制到操作系统提供的输出缓冲区中。如果我们在其输出缓冲区已满时调用 `send()`，它将阻塞，直到其缓冲区空出足够的空间以接受更多数据。
- en: In some cases where `send()` would block, it instead returns without copying
    all of the data as requested. In this case, the return value of `send()` indicates
    how many bytes were actually copied. One example of this is if your program is
    blocking on `send()` and then receives a signal from the operating system. In
    these cases, it is up to the caller to try again with any remaining data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果 `send()` 会阻塞，它将返回而不复制所有请求的数据。在这种情况下，`send()` 的返回值指示实际复制的字节数。一个例子是，如果你的程序在
    `send()` 上阻塞，然后从操作系统接收信号。在这些情况下，调用者需要尝试再次使用剩余的数据。
- en: In this chapter's *TCP server code* section, we ignored the possibility that
    `send()` could block or be interrupted. In a fully robust application, what we
    need to do is compare the return value from `send()` with the number of bytes
    that we tried to send. If the number of bytes actually sent is less than requested,
    we should use `select()` to determine when the socket is ready to accept new data,
    and then call `send()` with the remaining data. As you can imagine, this can become
    a bit complicated when keeping track of multiple sockets.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 *TCP 服务器代码* 部分，我们忽略了 `send()` 可能会阻塞或被中断的可能性。在一个完全健壮的应用程序中，我们需要做的是比较 `send()`
    的返回值与我们尝试发送的字节数。如果实际发送的字节数少于请求的，我们应该使用 `select()` 确定套接字何时准备好接受新数据，然后使用剩余的数据调用
    `send()`。正如你可以想象的那样，当跟踪多个套接字时，这可能会变得相当复杂。
- en: As the operating system usually provides a large enough outgoing buffer, we
    were able to avoid this possibility with our earlier server code. If we know that
    our server may try to send large amounts of data, we should certainly check for
    the return value from `send()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统通常提供足够大的输出缓冲区，我们能够通过我们早期的服务器代码避免这种情况。如果我们知道我们的服务器可能会尝试发送大量数据，我们绝对应该检查
    `send()` 的返回值。
- en: 'The following code example assumes that `buffer` contains `buffer_len` bytes
    of data to send over a socket called `peer_socket`. This code blocks until we''ve
    sent all of `buffer` or an error (such as the peer disconnecting) occurs:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例假设 `buffer` 包含要发送到名为 `peer_socket` 的套接字的数据，`buffer_len` 字节。此代码将阻塞，直到我们发送了所有
    `buffer` 或发生错误（例如对等方断开连接）：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we are managing multiple sockets and don't want to block, then we should
    put all sockets with pending `send()` into an `fd_set` and pass it as the third
    parameter to `select()`. When `select()` signals on these sockets, then we know
    that they are ready to send more data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在管理多个套接字并且不想阻塞，那么我们应该将所有具有挂起 `send()` 的套接字放入一个 `fd_set` 中，并将其作为 `select()`
    的第三个参数传递。当 `select()` 在这些套接字上发出信号时，我们知道它们已准备好发送更多数据。
- en: '[Chapter 13](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml), *Socket Programming
    Tips and Pitfalls*, addresses concerns regarding the `send()` function''s blocking
    behavior in more detail.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 13 章](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml)，*套接字编程技巧与陷阱*，更详细地讨论了 `send()`
    函数的阻塞行为。'
- en: TCP is a stream protocol
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 是一种流协议
- en: A common mistake beginners make is assuming that any data passed into `send()` can
    be read by `recv()` on the other end in the same amount. In reality, sending data
    is similar to writing and reading from a file. If we write 10 bytes to a file,
    followed by another 10 bytes, then the file has 20 bytes of data. If the file
    is to be read later, we could read 5 bytes and 15 bytes, or we could read all
    20 bytes at once, and so on. In any case, we have no way of knowing that the file
    was written in two 10 byte chunks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者常犯的一个错误是认为传递给 `send()` 的任何数据都可以以相同的数量在另一端的 `recv()` 中读取。实际上，发送数据类似于从文件中写入和读取。如果我们向文件写入10个字节，然后又写入另外10个字节，那么文件就有20个字节的数据。如果稍后要读取文件，我们可以读取5个字节和15个字节，或者一次性读取所有20个字节，等等。在任何情况下，我们都没有办法知道文件是分两次写入的，每次10个字节。
- en: Using `send()` and `recv()` works the same way. If you `send()` 20 bytes, it's
    not possible to tell how many `recv()` calls these bytes are partitioned into.
    It is possible that one call to `recv()` could return all 20 bytes, but it is
    also possible that a first call to `recv()` returns 16 bytes and that a second
    call to `recv()` is needed to get the last 4 bytes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `send()` 和 `recv()` 的方式是一样的。如果你发送了20个字节，无法知道这些字节被分成了多少个 `recv()` 调用。有可能一次
    `recv()` 调用就返回了所有20个字节，但也有可能第一次 `recv()` 调用返回了16个字节，而需要第二次 `recv()` 调用来获取最后的4个字节。
- en: This can make communication difficult. In many protocols, as we will see later
    in this book, it is important that received data be buffered up until enough of
    it has accumulated to warrant processing. We avoided this issue in this chapter
    with our to-uppercase sever by defining a protocol that operates just as well
    on 1 byte as it does on 100\. This isn't true for most application protocols.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使通信变得困难。在许多协议中，正如我们将在本书后面的章节中看到的，接收到的数据需要缓冲起来，直到积累到足够的数据以进行处理。在我们的将小写转换为大写的服务器中，我们避免了这个问题，我们定义了一个协议，它在处理1个字节和100个字节时效果一样好。这并不是大多数应用协议的情况。
- en: For a concrete example, imagine we wanted to make our `tcp_serve_toupper` server
    terminate if it received the `quit` command through a TCP socket. You could call
    `send(socket, "quit", 4, 0)` on the client and you may think that a call to `recv()`
    on the server would return `quit`. Indeed, in your testing, it is very likely
    to work that way. However, this behavior is not guaranteed. A call to `recv()`
    could just as likely return `qui`, and a second call to `recv()` may be required
    to receive the last `t`. If that is the case, consider how you would interpret
    whether a `quit` command has been received. The straightforward way to do it would
    be to buffer up data that's received from multiple `recv()` calls.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个具体的例子来说明，假设我们想让我们的 `tcp_serve_toupper` 服务器在通过 TCP 套接字接收到 `quit` 命令时终止。你可以在客户端调用
    `send(socket, "quit", 4, 0)`，你可能认为服务器上的 `recv()` 调用会返回 `quit`。确实，在你的测试中，这种方式很可能奏效。然而，这种行为并不保证。`recv()`
    调用同样可能只返回 `qui`，可能需要第二次 `recv()` 调用来接收最后的 `t` 字符。如果是这样，考虑一下你将如何解释是否接收到 `quit`
    命令。直接的方法是将从多个 `recv()` 调用接收到的数据缓冲起来。
- en: We will cover techniques for dealing with `recv()` buffering in [Section 2](fad8772d-ed91-4308-9f3a-834f2233ee6d.xhtml),
    *An Overview of Application Layer Protocols*, of this book.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的 [第2节](fad8772d-ed91-4308-9f3a-834f2233ee6d.xhtml)，*应用层协议概述*中介绍处理 `recv()`
    缓冲的技术。
- en: In contrast to TCP, UDP is not a stream protocol. With UDP, a packet is received
    with exactly the same contents as it was sent with. This can sometimes make handling
    UDP somewhat easier, as we will see in [Chapter 4](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml),
    *Establishing UDP Connections*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TCP 相比，UDP 不是一个流协议。使用 UDP，接收到的数据包与发送时具有完全相同的内容。这有时会使处理 UDP 变得更容易，正如我们将在第4章中看到，*建立
    UDP 连接*。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: TCP really serves as the backbone of the modern internet experience. TCP is
    used by HTTP, the protocol that powers websites, and by **Simple Mail Transfer
    Protocol** (**SMTP**), the protocol that powers email.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 实际上是现代互联网体验的骨干。TCP 被用于 HTTP 协议，这是驱动网站运行的协议，以及用于电子邮件的 **简单邮件传输协议**（**SMTP**）。
- en: In this chapter, we saw that building a TCP client was fairly straightforward.
    The only really tricky part was having the client monitor for local terminal input
    while simultaneously monitoring for socket data. We were able to accomplish this
    with `select()` on Unix-based systems, but it was slightly trickier on Windows.
    Many real-world applications don't need to monitor terminal input, and so this
    step isn't always needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到构建TCP客户端相当直接。唯一真正棘手的部分是客户端在同时监控套接字数据时还要监控本地终端输入。我们能够在基于Unix的系统上通过`select()`实现这一点，但在Windows上则稍微复杂一些。许多实际应用不需要监控终端输入，因此这一步并不总是必要的。
- en: Building a TCP server that's suitable for many parallel connections wasn't much
    harder. Here, `select()` was extremely useful, as it allowed a straightforward
    way of monitoring the listening socket for new connections while also monitoring
    existing connections for new data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 构建适合许多并行连接的TCP服务器并没有难多少。在这里，`select()`非常有用，因为它允许以直接的方式监控监听套接字以寻找新连接，同时监控现有连接以寻找新数据。
- en: We also touched briefly on some common pain points. TCP doesn't provide a native
    way to partition data. For more complicated protocols where this is needed, we
    have to buffer data from `recv()` until a suitable amount is available to interpret.
    For TCP peers that are handling large amounts of data, buffering to `send()` is
    also necessary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要地提到了一些常见的问题点。TCP不提供一种原生的数据分区方式。对于需要这种功能的更复杂的协议，我们必须从`recv()`缓冲数据，直到有足够的数据量可以解释。对于处理大量数据的TCP对等方，向`send()`缓冲也是必要的。
- en: The next chapter, [Chapter 4](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml), *Establishing
    UDP Connections,* is all about UDP, the counterpart to TCP. In some ways, UDP
    programming is simpler than TCP programming, but it is also very different.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[第四章](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml)，*建立UDP连接*，全部关于UDP，它是TCP的对立面。在某些方面，UDP编程比TCP编程简单，但它也非常不同。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try answering these questions to test your knowledge on this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答这些问题以测试你对本章知识的掌握：
- en: How can we tell whether the next call to `recv()` will block?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何判断下一次调用`recv()`是否会阻塞？
- en: How can you ensure that `select()` doesn't block for longer than a specified
    time?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确保`select()`不会阻塞超过指定的时间？
- en: When we used our `tcp_client` program to connect to a web server, why did we
    need to send a blank line before the web server responded?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用我们的`tcp_client`程序连接到Web服务器时，为什么需要在Web服务器响应之前发送一个空白行？
- en: Does `send()` ever block?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()`是否会阻塞？'
- en: How can we tell whether the socket has been disconnected by our peer?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何判断套接字是否被我们的对等方断开连接？
- en: Is data received by `recv()` always the same size as data sent with `send()`?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`recv()`接收到的数据是否总是与通过`send()`发送的数据大小相同？
- en: 'Consider the following code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: What is wrong with it?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它有什么问题？
- en: 'Also see what is wrong with this code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还请查看以下代码中存在的问题：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The answers can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可以在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)中找到，*问题答案*。
