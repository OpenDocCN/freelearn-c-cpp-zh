- en: Multithreading and Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程和同步
- en: Embedded platforms span a vast landscape of computing power. There are microcontrollers
    with just a few kilobytes of memory; there are powerful **systems-on-chip** (**SoCs**)
    with gigabytes of memory; there are multi-core CPUs capable of running many applications
    at the same time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式平台涵盖了广阔的计算能力领域。有些微控制器只有几千字节的内存；有些功能强大的**系统级芯片**（**SoCs**）有几千兆字节的内存；还有一些多核CPU能够同时运行许多应用程序。
- en: With more computational resources available for embedded developers, and more
    complex applications they can build on top of them, multithreading support has
    become very important. Developers need to know how to parallelize their applications
    to efficiently utilize all CPU cores. We will learn how to write applications
    that can utilize all available CPU cores in an efficient and safe way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着嵌入式开发人员可用的计算资源增加，以及他们可以构建的更复杂的应用程序，多线程支持变得非常重要。开发人员需要知道如何并行化他们的应用程序，以有效地利用所有CPU核心。我们将学习如何编写能够以高效和安全的方式利用所有可用CPU核心的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring thread support in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索C++中的线程支持
- en: Exploring data synchronization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据同步
- en: Using condition variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件变量
- en: Using atomic variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子变量
- en: Using the C++ memory model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++内存模型
- en: Exploring lock-free synchronization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索无锁同步
- en: Using atomic variables in shared memory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在共享内存中使用原子变量
- en: Exploring async functions and futures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异步函数和期货
- en: These recipes can be used as examples of building your own efficient multithreading
    and multiprocessing synchronization code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以用作构建自己的高效多线程和多进程同步代码的示例。
- en: Exploring thread support in C++
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索C++中的线程支持
- en: Prior to C++11, threads were completely out of the scope of C++ as a language.
    Developers could use platform-specific libraries, such as pthreads or the Win32
    **application programming interface** (**API**). Since each library has its own
    behavior, porting applications to another platform required significant development
    and testing efforts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，线程完全超出了C++作为一种语言的范围。开发人员可以使用特定于平台的库，如pthread或Win32 **应用程序编程接口**（**API**）。由于每个库都有自己的行为，将应用程序移植到另一个平台需要大量的开发和测试工作。
- en: C++11 introduced threads as part of the C++ standard and defined a set of classes
    to create multithreaded applications in its standard library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了线程作为C++标准的一部分，并在其标准库中定义了一组类来创建多线程应用程序。
- en: In this recipe, we will learn how to use C++ to spawn multiple concurrent threads
    in a single application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用C++在单个应用程序中生成多个并发线程。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will learn how to create two worker threads that run concurrently.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建两个并发运行的工作线程。
- en: In your `~/test` working directory, create a subdirectory called `threads`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`〜/test`工作目录中，创建一个名为`threads`的子目录。
- en: 'Use your favorite text editor to create a `threads.cpp` file in the `threads` subdirectory.
    Copy the code snippet into the `threads.cpp` file:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`threads`子目录中创建一个名为`threads.cpp`的文件。将代码片段复制到`threads.cpp`文件中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can build and run the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建并运行应用程序。
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this application, we defined a function called `worker`. To keep the code
    simple, it does not do much useful work, only printing `Worker X` starts and `Worker
    X` ends 10 times, with 50 milliseconds' delay between the messages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们定义了一个名为`worker`的函数。为了保持代码简单，它并没有做太多有用的工作，只是打印`Worker X`开始和`Worker
    X`结束10次，消息之间有50毫秒的延迟。
- en: 'In the `main` function, we create two worker threads, `worker1` and `worker2`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们创建了两个工作线程，`worker1`和`worker2`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We pass two parameters into the thread constructors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向线程构造函数传递了两个参数：
- en: A function that runs in the thread.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程中运行的函数。
- en: A parameter for the function. Since we pass the previously defined `worker`
    function as a thread function, the parameter should match its type—in our case,
    it is `int`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的参数。由于我们将先前定义的`worker`函数作为线程函数传递，参数应该与其类型匹配——在我们的例子中，它是`int`。
- en: This way, we defined two worker thread that do the same job but have different
    indices—`1` and `2`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们定义了两个工作线程，它们执行相同的工作，但具有不同的索引——`1`和`2`。
- en: 'The threads start running immediately as soon as they are created; there is
    no need to call any additional methods to start them. They are executed completely
    concurrently, as we can see from the program output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 线程一旦创建就立即开始运行；不需要调用任何额外的方法来启动它们。它们完全并行执行，正如我们从程序输出中看到的那样：
- en: '![](img/5772496b-0c8a-4c02-96c1-b9494da7fe2c.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5772496b-0c8a-4c02-96c1-b9494da7fe2c.png)'
- en: The output from our worker thread is mixed, and sometimes garbled, such as `Worker
    Worker 1 ends2 ends`. This happens because output to the Terminal is also working
    concurrently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作线程的输出是混合的，有时会混乱，比如`Worker Worker 1 ends2 ends`。这是因为终端的输出也是并行工作的。
- en: Since worker threads are executed independently, the main thread has nothing
    to do after creating the worker thread. However, if the execution of the main
    thread reaches the end of the `main` function, the program terminates. To avoid
    this, we added calls to the `join` method for each of our worker threads. This
    method blocks until the thread terminates. This way, we exit the main program
    only after both of the worker threads complete their work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作线程是独立执行的，主线程在创建工作线程后没有任何事情可做。但是，如果主线程的执行达到`main`函数的末尾，程序将终止。为了避免这种情况，我们为每个工作线程添加了`join`方法的调用。这种方法会阻塞，直到线程终止。这样，我们只有在两个工作线程完成工作后才退出主程序。
- en: Exploring data synchronization
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据同步
- en: Data synchronization is an important aspect of any application that deals with
    multiple execution threads. Different threads often need to access the same variables
    or memory regions. Writing to the same memory at the same time by two or more
    independent threads can result in data corruption. Even reading the variable at
    the same time when it is being updated by another thread is dangerous, since it
    can be only partially updated at the moment of the read.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数据同步是处理多个执行线程的任何应用程序的重要方面。不同的线程经常需要访问相同的变量或内存区域。两个或更多独立线程同时写入同一内存可能导致数据损坏。即使在另一个线程更新变量时同时读取该变量也是危险的，因为在读取时它可能只被部分更新。
- en: To avoid these issues, concurrent threads can use so-called synchronization
    primitives, the API that makes access to the shared memory deterministic and predictable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，并发线程可以使用所谓的同步原语，这是使对共享内存的访问变得确定和可预测的API。
- en: Similar to the case with thread support, the C++ language did not provide any
    synchronization primitives prior to the C++11 standard. Starting with C++11, a
    number of synchronization primitives were added into the C++ standard library
    as part of the standard.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程支持的情况类似，C++语言在C++11标准之前没有提供任何同步原语。从C++11开始，一些同步原语被添加到C++标准库中作为标准的一部分。
- en: In this recipe, we will learn how to synchronize access to a variable, using
    a mutex and a lock guard.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用互斥锁和锁保护来同步对变量的访问。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the preceding recipe, we learned how to run two worker threads completely
    concurrently and noticed that it can lead to garbled output to the Terminal. We
    are going to modify the code from the preceding recipe to add synchronization,
    using a mutex and a lock guard, and see the difference.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们学习了如何完全并发地运行两个工作线程，并注意到这可能导致终端输出混乱。我们将修改前面配方中的代码，添加同步，使用互斥锁和锁保护，并查看区别。
- en: In your `~/test` working directory, create a subdirectory called `mutex`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`mutex`的子目录。
- en: 'Use your favorite text editor to create a `mutex.cpp` file in the `mutex` subdirectory.
    Copy the code snippet into the `mutex.cpp` file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`mutex`子目录中创建一个`mutex.cpp`文件。将代码片段复制到`mutex.cpp`文件中：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can build and run the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建并运行应用程序。
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'After we build and run our application, we can see that its output is similar
    to the output of the thread application. However, there are also noticeable differences:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序后，我们可以看到其输出与线程应用程序的输出类似。但也有明显的区别：
- en: '![](img/36c850c0-19b0-49b4-a851-d1878279476c.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36c850c0-19b0-49b4-a851-d1878279476c.png)'
- en: 'Firstly, the output is not garbled. Secondly, we can see a clear order—no worker
    is interrupted by another worker, and each begin is followed by the corresponding
    end. The difference lies in the highlighted fragments of the source code. We create
    a global `mutex m`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输出不会混乱。其次，我们可以看到一个清晰的顺序——没有一个工作线程被另一个工作线程中断，每个开始都后跟相应的结束。区别在于源代码的突出部分。我们创建一个全局的`mutex
    m`：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we use `lock_guard` to protect our critical section of code, which starts
    from the line that prints `Worker X begins` and ends at the line that prints `Worker
    X ends`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`lock_guard`来保护我们的关键代码部分，从打印`Worker X begins`的行开始，到打印`Worker X ends`的行结束。
- en: '`lock_guard` is a wrapper on top of a mutex that uses an **RAII **(short for **Resource
    Acquisition Is Initialization**) technique to automatically lock the corresponding
    mutex in the constructor when the lock object is defined, and unlock it in the
    destructor after reaching the end of its scope. That is why we add extra curly
    braces to define the scope of our critical section:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock_guard`是互斥锁的包装器，它使用**RAII**（**资源获取即初始化**的缩写）技术，在构造函数中自动锁定相应的互斥锁，当定义锁对象时，它在析构函数中解锁，在其作用域结束时。这就是为什么我们添加额外的花括号来定义我们关键部分的作用域：'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Though it is possible to lock and unlock the mutex explicitly, by calling its
    lock and unlock methods, it is not recommended. Forgetting to unlock a locked
    mutex leads to multithreading synchronization issues that are hard to detect and
    hard to debug. The RAII approach unlocks mutexes automatically, making code safer,
    easier to read, and easier to understand.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过调用其lock和unlock方法显式锁定和解锁互斥锁，但不建议这样做。忘记解锁已锁定的互斥锁会导致难以检测和难以调试的多线程同步问题。RAII方法会自动解锁互斥锁，使代码更安全、更易读和更易理解。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Proper implementation of thread synchronization requires a lot of attention
    to detail and thorough analysis. A very common problem in multithreaded applications
    is a deadlock. This is a situation whereby a thread is blocked because it is waiting
    for another thread that, in turn, is blocked because it is waiting for the first
    thread. As a result, two threads are blocked infinitely.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现线程同步需要非常注意细节和彻底分析。多线程应用程序中一个非常常见的问题是死锁。这是一种情况，其中一个线程被阻塞，因为它正在等待另一个线程，而另一个线程又被阻塞，因为它正在等待第一个线程。因此，两个线程被无限期地阻塞。
- en: A deadlock occurs if two or more mutexes are required for synchronization. C++17 
    introduced   *std::scoped_lock*, available at [https://en.cppreference.com/w/cpp/thread/scoped_lock](https://en.cppreference.com/w/cpp/thread/scoped_lock)
    an RAII wrapper for multiple mutexes that helps to avoid deadlocks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要两个或更多个互斥锁进行同步，则会发生死锁。C++17引入了*std::scoped_lock*，可在[https://en.cppreference.com/w/cpp/thread/scoped_lock](https://en.cppreference.com/w/cpp/thread/scoped_lock)上找到，这是一个多个互斥锁的RAII包装器，有助于避免死锁。
- en: Using condition variables
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件变量
- en: We learned how to synchronize simultaneous access to the same variable from
    two or more threads. The particular order in which threads accessed the variable
    was not important; we only prevented simultaneous reads and writes to the variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何同步两个或多个线程对同一变量的同时访问。线程访问变量的特定顺序并不重要；我们只是防止了对变量的同时读写。
- en: A thread waiting for another thread to start processing data is a common scenario.
    In this case, the second thread should be notified by the first thread when the
    data is available. It can be done using condition variables, supported by C++,
    starting from the C++11 standard.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程等待另一个线程开始处理数据是一个常见的情况。在这种情况下，当数据可用时，第二个线程应该由第一个线程通知。这可以使用条件变量来完成，C++从C++11标准开始支持。
- en: In this recipe, we will learn how to use condition variables to activate data
    processing in a separate thread as soon as the data is available.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用条件变量在数据可用时立即激活数据处理的单独线程。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are going to implement an application with two worker threads, similar to
    the application we created in the *Exploring data synchronization* recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个具有两个工作线程的应用程序，类似于我们在*探索数据同步*配方中创建的应用程序。
- en: In your `~/test` working directory, create a subdirectory called `condvar`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`condvar`的子目录。
- en: Use your favorite text editor to create a `condv.cpp` file in the `condvar` subdirectory.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`condvar`子目录中创建一个名为`condv.cpp`的文件。
- en: 'Now, we put the required headers and define global variables in `condvar.cpp`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`condvar.cpp`中放置所需的头文件并定义全局变量：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the global variables are defined, we add our `worker` function, which
    is similar to the `worker` function from the preceding recipes:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义全局变量之后，我们添加了我们的`worker`函数，它与前面的配方中的`worker`函数类似：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we define our entry point—the `main` function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的入口点——`main`函数：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can build and run the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建并运行应用程序。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Similarly to the application that we created in the *Exploring data synchronization*
    recipe, we create two worker threads, `worker1` and `worker2`, that use the same
    `worker` function thread and differ only by the `index` parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在*探索数据同步*配方中创建的应用程序类似，我们创建了两个工作线程`worker1`和`worker2`，它们使用相同的`worker`函数线程，只是`index`参数不同。
- en: 'Besides printing messages to the console, the worker thread update a global
    vector result. Each worker just adds its index into the `result` variable in its
    loop, as shown in the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向控制台打印消息外，工作线程还更新了一个全局向量result。每个工作线程只是在其循环中将其索引添加到`result`变量中，如下命令所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We want each worker to add its index to the result only on its turn— `worker
    1`, then `worker 2`, then `worker 1` again, and so on. It is not possible to do
    this without synchronization; however, simple synchronization using mutexes is
    not sufficient. It can guarantee that two concurrent threads will not access the
    same critical section of the code at the same time, but cannot guarantee the order.
    It is possible that `worker 1` will lock the mutex again before `worker 2` locks
    it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个工作线程只在轮到它时将其索引添加到结果中——`worker 1`，然后`worker 2`，然后再次`worker 1`，依此类推。没有同步是不可能做到这一点的；然而，简单的互斥同步是不够的。它可以保证两个并发线程不会同时访问代码的同一关键部分，但不能保证顺序。可能是`worker
    1`在`worker 2`锁定之前再次锁定互斥锁。
- en: 'To solve the ordering problem, we define a `cv` condition variable and a `next` integer
    variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决排序问题，我们定义了一个`cv`条件变量和一个`next`整数变量：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `next` variable contains an index of the worker. It is initialized with
    `0` and set to a specific worker index in the `main` function. Since this variable
    is accessed from multiple threads, we do it under the protection of the lock guard:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`变量包含一个工作线程的索引。它初始化为`0`，并在`main`函数中设置为特定的工作线程索引。由于这个变量被多个线程访问，我们在锁保护下进行操作：'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Though the worker threads start executing after their creation, both of them
    are immediately blocked on the condition variables, waiting until the value of
    the `next` variable matches their index. Condition variables need `std::unique_lock`
    for waiting. We create it right before calling the `wait` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管工作线程在创建后开始执行，但它们两者立即被条件变量阻塞，等待`next`变量的值与它们的索引匹配。条件变量需要`std::unique_lock`进行等待。我们在调用`wait`方法之前创建它：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Though the condition variable `cv` was set to  `1` in the `main` function,
    it is not enough. We need to explicitly notify threads waiting on the condition
    variable. We do this using the `notify_all` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然条件变量`cv`在`main`函数中设置为`1`，但这还不够。我们需要显式通知等待条件变量的线程。我们使用`notify_all`方法来做到这一点：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This wakes up all waiting threads, and they compare their index against the
    `next` variable. The matching thread unblocks, and all other threads go to sleep
    again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将唤醒所有等待的线程，它们将自己的索引与`next`变量进行比较。匹配的线程解除阻塞，而所有其他线程再次进入睡眠状态。
- en: 'The active thread writes a message to the console and updates the `result`
    variable. Then, it updates the `next` variable to choose a thread that will be
    activated next. We increment the index until it reaches the maximum value, then
    reset it to `1`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 活动线程向控制台写入消息并更新`result`变量。然后，它更新`next`变量以选择下一个要激活的线程。我们递增索引直到达到最大值，然后将其重置为`1`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similar to the case with the code in the `main` function, after the index of
    the `next` thread is decided, we need to invoke `notify_all` to wake all threads
    up and let them decide whose turn it is to work:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与`main`函数中的代码情况类似，在决定`next`线程的索引后，我们需要调用`notify_all`来唤醒所有线程，并让它们决定轮到谁工作：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While the worker threads work, the `main` function waits for their completion:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作线程工作时，`main`函数等待它们的完成：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When all worker threads complete, the value of the `result` variable  is printed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有工作线程完成时，将打印`result`变量的值：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After we build and run our program, we get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行程序后，我们得到以下输出：
- en: '![](img/e9547f19-9f61-4307-bed0-e7fa66406e5a.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9547f19-9f61-4307-bed0-e7fa66406e5a.png)'
- en: As we can see, all threads were activated in the expected order.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，所有线程都按预期顺序激活了。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we only used a few methods provided by the condition variable
    object. Besides the simple `wait` function, there are functions for waiting for
    a specific time or waiting until a specified time point is reached. Learn more
    about the *C++ condition variable class* at its [https://en.cppreference.com/w/cpp/thread/condition_variable](https://en.cppreference.com/w/cpp/thread/condition_variable)
    reference page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只使用了条件变量对象提供的一些方法。除了简单的`wait`函数外，还有一些等待特定时间或等待直到达到指定时间点的函数。在[https://en.cppreference.com/w/cpp/thread/condition_variable](https://en.cppreference.com/w/cpp/thread/condition_variable)上了解更多关于*C++条件变量类*的信息。
- en: Using atomic variables
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子变量
- en: 'Atomic variables are named as such because they cannot be read or written partially.
    Compare, for example, the `Point` and `int` data types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 原子变量之所以被命名为原子变量，是因为它们不能被部分读取或写入。例如，比较`Point`和`int`数据类型：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, modification of the `p` variable is equivalent to two assignments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，修改`p`变量相当于两次赋值：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that any concurrent thread reading the `p` variable can get partially
    modified data, such as `x=10`, `y=0`, which can lead to incorrect calculations
    that are hard to detect and hard to reproduce. That is why access to such data
    types should be synchronized.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何并发线程读取`p`变量时可能会得到部分修改的数据，比如`x=10`，`y=0`，这可能导致难以检测和难以重现的错误计算。这就是为什么对这种数据类型的访问应该是同步的。
- en: 'How about the `b` variable? Can it be modified partially? The answer is: yes,
    depending on the platform. However, C++ provides a set of data types and templates
    to ensure that a variable changes all at once, as a whole, atomically.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`b`变量呢？它能被部分修改吗？答案是：取决于平台。然而，C++提供了一组数据类型和模板，以确保变量作为一个整体原子地一次性改变。
- en: In this recipe, we will learn how to use atomic variables for the synchronization
    of multiple threads. Since  atomic variables cannot be modified partially, there
    is no need to use mutexes or other expensive synchronization primitives.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用原子变量来同步多个线程。由于原子变量不能被部分修改，因此不需要使用互斥锁或其他昂贵的同步原语。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will create an application that spawns two worker threads to concurrently
    update an array of data. Instead of mutexes, we will use atomic variables to make
    sure the concurrent updates are safe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，生成两个工作线程来并发更新一个数据数组。我们将使用原子变量而不是互斥锁，以确保并发更新是安全的。
- en: In your `~/test` working directory, create a subdirectory called `atomic`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`~/test`工作目录中，创建一个名为`atomic`的子目录。
- en: Use your favorite text editor to create an `atomic.cpp` file in the `atomic` subdirectory.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器在`atomic`子目录中创建一个名为`atomic.cpp`的文件。
- en: 'Now, we put the required headers, and define global variables in `atomic.cpp`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们放置所需的头文件，并在`atomic.cpp`中定义全局变量：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After global variables are defined, we add our `worker` function. It resembles
    the `worker` function from the preceding recipes, but besides an `index`, it has
    an additional parameter—`timeout`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义全局变量之后，我们添加我们的`worker`函数。它类似于之前示例中的`worker`函数，但除了一个`index`之外，它还有一个额外的参数`timeout`：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we define our entry point— the `main` function:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的入口点——`main`函数：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，并包含以下内容：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can build and run the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以构建并运行应用程序。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We are creating an application that updates all elements of an array using multiple
    worker threads. For expensive update operations, this approach can result in substantial
    performance gains on a multi-core platform.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个应用程序，使用多个工作线程更新数组的所有元素。对于昂贵的更新操作，这种方法可以在多核平台上实现显著的性能提升。
- en: The difficulty is sharing the work between multiple worker threads, given that
    each of them may require a different amount of time to process a data element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 困难在于在多个工作线程之间共享工作，因为它们每个可能需要不同的时间来处理数据元素。
- en: 'We use a `shared_index` atomic variable to store an index of the next element
    that has not yet been claimed by any of the worker threads. This variable, along
    with the array to be processed, is declared as a global variable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个`shared_index`原子变量来存储尚未被任何工作线程声明的下一个元素的索引。这个变量，以及要处理的数组，被声明为全局变量：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our `worker` function resembles the `worker` function from earlier recipes but
    has important differences. Firstly, it has an additional parameter, `timeout`.
    This is used to simulate differences in the time required to process each element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`worker`函数类似于之前的示例中的`worker`函数，但有重要的区别。首先，它有一个额外的参数`timeout`。这用于模拟处理每个元素所需的时间差异。
- en: Secondly, instead of a fixed number of iterations, our worker threads run in
    a loop until the  `shared_index` variable reaches the maximum value. This indicates
    that all elements were processed, and the worker can terminate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们的工作线程不是在固定次数的迭代中运行，而是在一个循环中运行，直到`shared_index`变量达到最大值。这表示所有元素都已被处理，工作线程可以终止。
- en: On each iteration, a worker reads the value of `shared_index`. If there are
    elements to process, it stores the value of the `shared_index` variable in a local `worker_index` variable and
    increments the `shared_index` variable at the same time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，一个工作线程读取`shared_index`的值。如果有要处理的元素，它将`shared_index`变量的值存储在一个本地的`worker_index`变量中，并同时增加`shared_index`变量。
- en: 'Though it is possible to use an atomic variable in the same way as a regular
    variable—first, get its current value, and then increment the variable—it can
    lead to a race condition. Both worker threads can read the variable at almost
    the same time. In this case, both of them get the same value, then start processing
    the same element, interfering with each other. That is why we use a special method, `fetch_add`,
    which increments the variable and returns the value it had before the increment
    as a single, non-interruptible action:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以像使用常规变量一样使用原子变量——首先获取其当前值，然后增加变量——但这可能导致竞争条件。两个工作线程几乎同时读取变量。在这种情况下，它们都获得相同的值，然后开始处理相同的元素，相互干扰。这就是为什么我们使用特殊的`fetch_add`方法，它增加变量并返回增加之前的值作为单个、不可中断的操作：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the `worker_index` variable reaches the size of the array, it means that
    all elements were processed, and the worker can terminate:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`worker_index`变量达到数组的大小，这意味着所有元素都已经处理完毕，工作线程可以终止：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the `worker_index` variable is valid, it is used by the worker to update
    the value of the array element by this index. In our case, we just multiply it
    by `2`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`worker_index`变量有效，则工作线程将使用它来更新数组元素的值。在我们的情况下，我们只是将它乘以`2`：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To simulate expensive data operation, we use a custom delay. The duration of
    the delay is determined by the `timeout` parameter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟昂贵的数据操作，我们使用自定义延迟。延迟的持续时间由`timeout`参数确定：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `main` function, we add elements to process into the data vector. We
    use a loop to populate the vector with numbers from zero to nine:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们向数据向量中添加要处理的元素。我们使用循环将向量填充为从零到九的数字：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the initial dataset is ready, we create two worker threads, providing
    the `index` and the `timeout` parameters. Different timeouts of the worker thread
    are used to simulate different performances:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数据集准备好后，我们创建两个工作线程，提供`index`和`timeout`参数。使用工作线程的不同超时来模拟不同的性能：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we wait till both worker threads complete their jobs, and print the result
    to the console. When we build and run our application, we get the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们等待两个工作线程完成它们的工作，并将结果打印到控制台。当我们构建和运行我们的应用程序时，我们会得到以下输出：
- en: '![](img/c34579d8-b62e-4c9e-bcbe-a4441c2d5e89.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c34579d8-b62e-4c9e-bcbe-a4441c2d5e89.png)'
- en: As we can see, `Worker 2` has processed more elements than `Worker 1` because
    its timeout was 20 milliseconds, compared to the 50 milliseconds of `Worker 1`.
    Also, all elements were processed without omissions and repetitions, as intended.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Worker 2`处理的元素比`Worker 1`多，因为它的超时是20毫秒，而`Worker 1`是50毫秒。此外，所有元素都按预期进行处理，没有遗漏和重复。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We learned how to work with integer atomic variables. Though this type of atomic
    variable is the most commonly used, C++ allows atomic variables of other types
    to be defined as well, including non-integral types, given that they are trivially
    copyable, copy constructible, and copy assignable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何处理整数原子变量。虽然这种类型的原子变量是最常用的，但C++也允许定义其他类型的原子变量，包括非整数类型，只要它们是平凡可复制的、可复制构造的和可复制赋值的。
- en: Besides the `fetch_add` method we used in our example, atomic variables have
    other similar methods that help developers to query the value and modify the variable
    in a single operation. Consider using these methods to avoid race conditions or
    expensive synchronization using mutexes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在示例中使用的`fetch_add`方法，原子变量还有其他类似的方法，可以帮助开发人员在单个操作中查询值和修改变量。考虑使用这些方法来避免竞争条件或使用互斥锁进行昂贵的同步。
- en: In C++20, atomic variables receive `wait`, `notify_all`, and `notify_one` methods,
    similar to the methods of condition variables. They allow implementation of the
    logic that previously required condition variables by using much more efficient
    and lightweight atomic variables.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，原子变量获得了`wait`、`notify_all`和`notify_one`方法，类似于条件变量的方法。它们允许使用更高效、轻量级的原子变量来实现以前需要条件变量的逻辑。
- en: More information about atomic variables can be found at [https://en.cppreference.com/w/cpp/atomic/atomic](https://en.cppreference.com/w/cpp/atomic/atomic).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有关原子变量的更多信息，请访问[https://en.cppreference.com/w/cpp/atomic/atomic](https://en.cppreference.com/w/cpp/atomic/atomic)。
- en: Using the C++ memory model
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++内存模型
- en: Beginning with the C++11 standard, C++ defined an API and primitives for threads
    and synchronization as part of the language. Memory synchronization in a system
    that has multiple processor cores is complicated because modern processors can
    optimize code execution by reordering instructions. Even when using atomic variables,
    there is no guarantee that the data is modified or accessed in the desired order,
    since the order can be changed by a compiler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++11标准开始，C++定义了线程和同步的API和原语作为语言的一部分。在具有多个处理器核心的系统中进行内存同步是复杂的，因为现代处理器可以通过重新排序指令来优化代码执行。即使使用原子变量，也不能保证数据按预期顺序修改或访问，因为编译器可以改变顺序。
- en: To avoid ambiguity, C++11 introduced the memory model, defining the behavior
    of the concurrent access to the memory region. As part of the memory model, C++
    defined the `std::memory_order` enum, which gives hints to a compiler regarding
    the intended model of access. This helps the compiler to optimize the code in
    a way that does not interfere with the intended code behavior.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免歧义，C++11引入了内存模型，定义了对内存区域的并发访问行为。作为内存模型的一部分，C++定义了`std::memory_order`枚举，它向编译器提供有关预期访问模型的提示。这有助于编译器以不干扰预期代码行为的方式优化代码。
- en: In this recipe, we will learn how to use the simplest form of the `std::memory_order` enum to
    implement a shared counter variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用最简单的`std::memory_order`枚举来实现一个共享计数器变量。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are implementing an application that has a shared counter that is incremented
    by two concurrent worker threads.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实现一个应用程序，其中有一个共享计数器，由两个并发的工作线程递增。
- en: In your `~/test` working directory, create a subdirectory called `memorder`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`memorder`的子目录。
- en: Use your favorite text editor to create a `memorder.cpp` file in the `atomic` subdirectory.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`atomic`子目录中创建一个`memorder.cpp`文件。
- en: 'Now, we put the required headers and define global variables in `memorder.cpp`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在`memorder.cpp`中放置所需的头文件并定义全局变量：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After global variables are defined, we add our `worker` function. The function
    only increments a counter, and then sleeps for a specific time interval:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局变量定义后，我们添加我们的`worker`函数。该函数只是递增一个计数器，然后休眠一段特定的时间间隔：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we define our `main` function:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的`main`函数：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can build and run the application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建和运行应用程序。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our application, we are going to create two worker threads that will increment
    a shared counter, and let them run for a specific amount of time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将创建两个工作线程，它们将递增一个共享计数器，并让它们运行一段特定的时间。
- en: 'As a first step, we define two global atomic variables, `running` and `counter`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义两个全局原子变量`running`和`counter`：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `running` variable is a binary flag. When it is set to `true`, the worker
    threads should keep running. After it changes to `false`, the worker threads should
    terminate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`running`变量是一个二进制标志。当它设置为`true`时，工作线程应该继续运行。在它变为`false`后，工作线程应该终止。'
- en: 'The `counter` variable is our shared counter. The worker threads will concurrently
    increment it. We use the `fetch_add` method that we already used in the *Using
    atomic variables* recipe. It is used to increment a variable atomically. In this
    recipe, we pass an additional argument, `std::memory_order_relaxed`, to this method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter`变量是我们的共享计数器。工作线程将同时递增它。我们使用了在*使用原子变量*示例中已经使用过的`fetch_add`方法。它用于原子地递增一个变量。在这个示例中，我们将额外的参数`std::memory_order_relaxed`传递给这个方法：'
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This argument is a hint. While consistency in atomicity and modification is
    important and should be guaranteed for an implementation of a counter, the order
    among concurrent memory accesses is not that important. `std::memory_order_relaxed` defines
    this kind of memory access for atomic variables. Passing it into the `fetch_add` method
    allows us to fine-tune it for a particular target platform, to avoid unneeded
    synchronization delays that can affect performance.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数是一个提示。虽然原子性和修改的一致性对于计数器的实现很重要并且应该得到保证，但并发内存访问之间的顺序并不那么重要。`std::memory_order_relaxed`为原子变量定义了这种内存访问。将其传递给`fetch_add`方法允许我们为特定目标平台进行微调，以避免不必要的同步延迟，从而影响性能。
- en: 'In the `main` function, we create two worker threads:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们创建两个工作线程：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, the main thread is paused for 1 second. After the pause, the main thread
    sets the value of the `running` variable to `false`, indicating that the worker
    threads should terminate:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主线程暂停1秒。暂停后，主线程将`running`变量的值设置为`false`，表示工作线程应该终止。
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the worker threads terminate, we print the value of the counter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程终止后，我们打印计数器的值：
- en: '![](img/a33e028f-a5f8-4fe4-b857-23fd84788a3a.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a33e028f-a5f8-4fe4-b857-23fd84788a3a.png)'
- en: The resulting counter value is determined by the timeout intervals passed to
    the `worker` functions. Changing the type of memory order in the `fetch_add` method
    does not result in a noticeable change in the resulting value in our example.
    However, it can result in the better performance of highly concurrent applications
    that use atomic variables, because a compiler can reorder operations in concurrent
    threads without breaking the application logic. This kind of optimization is highly
    dependent on a developer's intents, and cannot be inferred automatically without
    hints from the developer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的计数器值由传递给`worker`函数的超时间隔确定。在我们的示例中，更改`fetch_add`方法中的内存顺序类型不会导致结果值的明显变化。但是，它可以提高使用原子变量的高并发应用程序的性能，因为编译器可以重新排序并发线程中的操作而不会破坏应用程序逻辑。这种优化高度依赖于开发人员的意图，并且不能在没有开发人员提示的情况下自动推断。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++ memory model and memory ordering types are complex topics that require
    a deep understanding of how modern CPUs access memory and optimize their code
    execution. *C++ Memory Model reference* , [https://en.cppreference.com/w/cpp/language/memory_model](https://en.cppreference.com/w/cpp/language/memory_model) provides
    lots of information and is a good starting point to learn advanced techniques
    for the optimization of multithreaded applications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: C++内存模型和内存排序类型是复杂的主题，需要深入了解现代CPU如何访问内存并优化其代码执行。*C++内存模型参考*，[https://en.cppreference.com/w/cpp/language/memory_model](https://en.cppreference.com/w/cpp/language/memory_model)提供了大量信息，是学习多线程应用程序优化的高级技术的良好起点。
- en: Exploring lock-free synchronization
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索无锁同步
- en: In the preceding recipes, we learned how to synchronize access of multiple threads
    to shared data, using mutexes and locks. If several threads try to run critical
    sections of the code protected by a lock, only one thread at a time can do it.
    All other threads have to wait until that thread leaves the critical section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何使用互斥锁和锁同步多个线程对共享数据的访问。如果多个线程尝试运行由锁保护的代码的关键部分，只有一个线程可以一次执行。所有其他线程都必须等待，直到该线程离开关键部分。
- en: In some cases, however, it is possible to synchronize access to shared data
    without mutexes and explicit locks. The idea is to use a local copy of data for
    modification, and then update the shared copy in a single, uninterruptible, and
    undividable operation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，可以在没有互斥锁和显式锁的情况下同步对共享数据的访问。其思想是使用数据的本地副本进行修改，然后在单个、不可中断和不可分割的操作中更新共享副本。
- en: This type of synchronization depends on the hardware. Target processors should
    provide some form of **Compare And Swap** (**CAS**) instruction. This checks whether
    the value in a memory location matches a given value, and replaces it with a new
    given value only if they match. Since it is a single-processor instruction, it
    cannot be interrupted by a context switch. This makes it a basic building block
    for more complex atomic operations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的同步取决于硬件。目标处理器应该提供某种形式的**比较和交换**（**CAS**）指令。这检查内存位置中的值是否与给定值匹配，并且仅当它们匹配时才用新给定值替换它。由于它是单处理器指令，它不会被上下文切换中断。这使它成为更复杂的原子操作的基本构建块。
- en: In this recipe, we will learn how to check whether an atomic variable is lock-free
    or implemented using mutexes or other locking operations. We will also implement
    a lock-free push operation for a custom stack, based on the example for the atomic
    compare-exchange family of functions for C++11, available at [https://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange](https://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何检查原子变量是否是无锁的，或者是使用互斥体或其他锁定操作实现的。我们还将根据C++11中的原子比较交换函数的示例实现一个无锁推送操作，该示例可在[https://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange](https://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange)上找到。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are implementing a simple `Stack` class that provides a constructor and a
    function named `Push`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实现一个简单的`Stack`类，它提供了一个构造函数和一个名为`Push`的函数。
- en: In your `~/test` working directory, create a subdirectory called `lockfree`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`lockfree`的子目录。
- en: Use your favorite text editor to create a `lockfree.cpp` file in the `lockfree` subdirectory.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`lockfree`子目录中创建一个名为`lockfree.cpp`的文件。
- en: 'Now, we put in the required headers, and define a `Node` helper data type in
    the  `lockfree.cpp` file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们放入所需的头文件，并在`lockfree.cpp`文件中定义一个`Node`辅助数据类型：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we define a simple `Stack` class. This uses the `Node` data type to organize
    data storage:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个简单的`Stack`类。这使用`Node`数据类型来组织数据存储：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we define a simple `main` function that creates an instance of `Stack`
    and pushes an element into it:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个简单的`main`函数，创建一个`Stack`实例并将一个元素推入其中：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can build and run the application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建并运行应用程序。
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We created a simple application that implements a simple stack of integer values.
    We store elements of the stack in dynamic memory, and for each element, we should
    be able to determine the elements that follow it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的应用程序，实现了一个整数值的简单堆栈。我们将堆栈的元素存储在动态内存中，对于每个元素，我们应该能够确定其后面的元素。
- en: 'For this purpose, we define a `Node` helper structure that has two data fields.
    The `data` field stores the actual value of an element, while the `next` field
    is a pointer to the next element in the stack:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们定义了一个`Node`辅助结构，它有两个数据字段。`data`字段存储元素的实际值，而`next`字段是堆栈中下一个元素的指针：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we define the `Stack` class. Normally, a stack implies two operations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`Stack`类。通常，堆栈意味着两个操作：
- en: '`Push`: to place an element on top of the stack'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Push`：将一个元素放在堆栈顶部'
- en: '`Pull`: to fetch an element from the top of the stack'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pull`：从堆栈顶部获取一个元素'
- en: 'To track the top of the stack, we create a `top` variable that holds a pointer
    to the `Node` object. It will be the top of our stack:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪堆栈的顶部，我们创建一个`top`变量，它保存指向`Node`对象的指针。它将是我们堆栈的顶部：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also define a simple constructor that initializes the value of our `top`
    variable and checks whether it is lock-free or not. In C++, atomic variables can
    be implemented using atomic **Consistency, Availability, and Partition tolerance**
    (**CAP**) operations or using regular mutexes. It depends on the target CPU:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个简单的构造函数，它初始化了我们的`top`变量的值，并检查它是否是无锁的。在C++中，原子变量可以使用原子**一致性、可用性和分区容错性**（**CAP**）操作或使用常规互斥体来实现。这取决于目标CPU：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In our application, we implement only the `Push` method, to demonstrate how
    it can be done in a lock-free way.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们只实现了`Push`方法，以演示如何以无锁的方式实现它。
- en: 'The `Push` method accepts a value to put on top of the stack. To do this, we
    create a new instance of the `Node` object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Push`方法接受要放在堆栈顶部的值。为此，我们创建一个新的`Node`对象的实例：'
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we put the element on the top of the stack, the pointer to the newly created
    instance should be assigned to the `top` variable, and the old value of the `top` variable
    should be assigned to the `next` pointer of our new `Node` object.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将元素放在堆栈的顶部，新创建的实例的指针应该分配给`top`变量，并且应该将`top`变量的旧值分配给我们的新`Node`对象的`next`指针。
- en: However, doing it directly is not thread-safe. Two or more threads can modify
    the `top` variable simultaneously, causing data corruption. We need some kind
    of data synchronization. We can do this using locks and mutexes, but it is also
    possible to do it in a lock-free way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直接这样做是不安全的。两个或更多线程可以同时修改`top`变量，导致数据损坏。我们需要某种数据同步。我们可以使用锁和互斥体来做到这一点，但也可以以无锁的方式来实现。
- en: 'That is why we initially update only the next pointer. Since our new `Node`
    object is not yet part of the stack, we can do it without synchronization, since
    other threads do not have access to it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们最初只更新下一个指针。由于我们的新`Node`对象还不是堆栈的一部分，所以我们可以在没有同步的情况下执行，因为其他线程无法访问它：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we need to add it as a new `top` variable of the stack. We do this using
    a loop over the `std::atomic_compare_exchange_weak` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将其添加为堆栈的新`top`变量。我们使用`std::atomic_compare_exchange_weak`函数进行循环：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function compares the value of the `top` variable to the value stored in
    the `next` pointer of the new element. If they match, it replaces the value of
    the `top` variable with the pointer to the new node and returns `true`. Otherwise,
    it writes the value of the `top` variable into the `next` pointer of the new element
    and returns `false`. Since we updated the `next` pointer to match the `top` variable
    on the next step, this can only happen if another thread modified it before the
    `std::atomic_compare_exchange_weak` function was invoked. Eventually, the function
    will return `true`, indicating that the `top` header is updated with the pointer
    to our element.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将`top`变量的值与新元素的`next`指针中存储的值进行比较。如果它们匹配，则将`top`变量的值替换为新节点的指针并返回`true`。否则，它将`top`变量的值写入新元素的`next`指针并返回`false`。由于我们在下一步中更新了`next`指针以匹配`top`变量，这只能发生在另一个线程在调用`std::atomic_compare_exchange_weak`函数之前修改了它。最终，该函数将返回`true`，表示`top`头部已更新为指向我们的元素的指针。
- en: 'The `main` function creates an instance of stack and pushes one element to
    it. In the output, we can see if the underlying implementation is lock-free or
    not:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数创建一个堆栈的实例，并将一个元素推入其中。在输出中，我们可以看到底层实现是否是无锁的：'
- en: '![](img/1c7151c3-b9d3-44d2-afb2-8a5caa5119f2.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c7151c3-b9d3-44d2-afb2-8a5caa5119f2.png)'
- en: For our target, the implementation is lock-free.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目标，实现是无锁的。
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Lock-free synchronization is an extremely complex topic. The development of
    lock-free data structures and algorithms requires lots of effort. Even the implementation
    of simple `Push` logic using lock-free operations is not easy to understand. An
    even larger effort is needed for proper analysis and debugging of your code. Often,
    it can lead to subtle issues that are hard to notice and hard to implement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 无锁同步是一个非常复杂的话题。开发无锁数据结构和算法需要大量的工作。即使是使用无锁操作实现简单的“Push”逻辑也不容易理解。对于代码的适当分析和调试需要更大的努力。通常，这可能导致难以注意和难以实现的微妙问题。
- en: Though the implementation of a lock-free algorithm can improve the performance
    of your application, consider using one of the existing libraries of lock-free
    data structures instead of writing of your own. For example, [Boost.Lockfree](https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html)
    provides a collection of lock-free data types for you to use.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无锁算法的实现可以提高应用程序的性能，但考虑使用现有的无锁数据结构库之一，而不是编写自己的库。例如，[Boost.Lockfree](https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html)提供了一系列无锁数据类型供您使用。
- en: Using atomic variables in shared memory
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在共享内存中使用原子变量
- en: We learned how to use atomic variables for the synchronization of two or more
    threads in a multithreaded application. However, atomic variables can also be
    used to synchronize independent applications that run as separate processes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用原子变量来同步多线程应用程序中的两个或多个线程。但是，原子变量也可以用于同步作为独立进程运行的独立应用程序。
- en: We already know how to use shared memory for exchanging data between two applications.
    Now, we can combine these two techniques—shared memory and atomic variables—to
    implement both the data exchange and synchronization of two independent applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何在两个应用程序之间交换数据使用共享内存。现在，我们可以结合这两种技术——共享内存和原子变量——来实现两个独立应用程序的数据交换和同步。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will modify an application we created in [Chapter 6](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml), *Memory
    Management*, for exchanging data between two processors using a shared memory
    region.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将修改我们在[第6章](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml)中创建的应用程序，*内存管理*，用于在两个处理器之间使用共享内存区域交换数据。
- en: In your `~/test` working directory, create a subdirectory called `shmatomic`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`shmatomic`的子目录。
- en: Use your favorite text editor to create a `shmatomic.cpp` file in the `shmatomic` subdirectory.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`shmatomic`子目录中创建一个名为`shmatomic.cpp`的文件。
- en: 'We reuse the shared memory data structure we created in the `shmem` application.
    Put the common headers and constants into the `shmatomic.cpp` file:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重用了我们在`shmem`应用程序中创建的共享内存数据结构。将公共头文件和常量放入`shmatomic.cpp`文件中：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, start defining the templated `SharedMem` class:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，开始定义模板化的`SharedMem`类：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The class will have a constructor, a destructor, and a getter method. Let''s
    add the constructor:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类将有一个构造函数，一个析构函数和一个getter方法。让我们添加构造函数：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The simple destructor and the getter follow:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是简单的析构函数和getter：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we define the data type we will use for data exchange and synchronization:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义要用于数据交换和同步的数据类型：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we define a function that will generate data:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个将生成数据的函数：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It is followed by the function that consumes the data:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是消耗数据的函数：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we add our `main` function, which ties everything together:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加我们的`main`函数，将所有内容联系在一起：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，并包含以下内容：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can build and run the application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建并运行应用程序。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our application, we reuse the templated `SharedMem` class we introduced in
    [Chapter 6](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml), *Memory Management*.
    This class is used to store an element of a specific type in a shared memory region.
    Let's quickly recap how it works.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们重用了我们在[第6章](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml)中介绍的模板化的`SharedMem`类，*内存管理*。该类用于在共享内存区域中存储特定类型的元素。让我们快速回顾一下它的工作原理。
- en: 'The `SharedMem` class is a wrapper on top of the **Portable Operating System
    Interface** (**POSIX**) shared memory API. It defines three private data fields
    to hold system-specific handlers and pointers, and exposes a public interface
    consisting of two functions:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedMem`类是**可移植操作系统接口**（**POSIX**）共享内存API的包装器。它定义了三个私有数据字段来保存特定于系统的处理程序和指针，并公开由两个函数组成的公共接口：'
- en: A constructor function that accepts the name of a shared region and the ownership
    flag
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受共享区域名称和所有权标志的构造函数
- en: A `get` method that returns a reference to the object stored in shared memory
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`get`方法，返回存储在共享内存中的对象的引用
- en: The class also defines a destructor that performs all operations needed to properly
    close the shared object. As a result, the `SharedMem` class can be used for safe
    resource management using the C++ RAII idiom.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还定义了一个析构函数，执行所有必要的操作以正确关闭共享对象。因此，`SharedMem`类可以用于使用C++ RAII习语进行安全资源管理。
- en: 'The `SharedMem` class is a templated class. It is parameterized by the data
    type we want to store in the shared memory. For this purpose, we define a structure
    called `Payload`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedMem`类是一个模板类。它由我们想要存储在共享内存中的数据类型参数化。为此，我们定义了一个名为`Payload`的结构：'
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It has an `index` integer variable that we are going to use as a data exchange
    field, and two atomic Boolean flags, `data_ready` and `data_processed`, that are
    used for data synchronization.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`index`整数变量，我们将使用它作为数据交换字段，并且有两个原子布尔标志，`data_ready`和`data_processed`，用于数据同步。
- en: We also define two functions, `producer` and `consumer`, that will work in separate
    processes and exchange data between each other using a shared memory region.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了两个函数，`producer`和`consumer`，它们将在单独的进程中工作，并使用共享内存区域相互交换数据。
- en: 'The `producer` function is producing data chunks. Firstly, it creates an instance
    of the `SharedMem` class, parametrized by the `Payload` data type. It passes a
    path to the shared memory region to the `SharedMem` constructor:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`函数正在生成数据块。首先，它创建了`SharedMem`类的一个实例，由`Payload`数据类型参数化。它将共享内存区域的路径传递给`SharedMem`构造函数：'
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After the shared memory instance is created, it gets the reference to the payload
    data stored there and checks whether any of the atomic flags we defined in the
    `Payload` data type are lock-free:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 创建共享内存实例后，它获取对存储在其中的有效负载数据的引用，并检查我们在`Payload`数据类型中定义的任何原子标志是否是无锁定的：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The function produces 10 chunks of data in a loop. An index of the chunk is
    put into the `index` field of the payload:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在循环中生成10个数据块。数据块的索引被放入有效负载的`index`字段中：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: However, besides putting the data into shared memory, we need to synchronize
    access to this data. This is when we use our atomic flags.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了将数据放入共享内存中，我们还需要同步对这些数据的访问。这就是我们使用原子标志的时候。
- en: 'For each iteration, before updating the `index` field, we reset the `data_processed`
    flag. After the index is updated, we set the `data ready` flag, which is an indicator
    to the consumer that a new chunk of data is ready, and wait till the data is processed
    by the consumer. We loop until the `data_processed` flag becomes `true`, and then
    go to the next iteration:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次迭代，在更新`index`字段之前，我们重置`data_processed`标志。更新索引后，我们设置`data ready`标志，这是向消费者指示新的数据块已准备就绪的指示器，并等待数据被消费者处理。我们循环直到`data_processed`标志变为`true`，然后进入下一个迭代：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `consumer` function works in a similar way. Since it works in a separate
    process, it opens the same shared memory region by creating an instance of the
    `SharedMem` class using the same path. We also make the `consumer` function the
    owner of the shared memory instance. It means it is responsible for removing the
    shared memory region after its instance of `SharedMem` is destroyed:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`consumer`函数的工作方式类似。由于它在一个单独的进程中工作，它通过使用相同的路径创建`SharedMem`类的实例来打开相同的共享内存区域。我们还使`consumer`函数成为共享内存实例的所有者。这意味着它负责在`SharedMem`实例被销毁后删除共享内存区域：'
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Similarly to the `producer` function, the `consumer` function checks whether
    an atomic flag is lock-free, and enters the loop of data consumption.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与`producer`函数类似，`consumer`函数检查原子标志是否是无锁定的，并进入数据消耗的循环。
- en: 'For each iteration, it waits in a tight loop until the data is ready:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次迭代，它在一个紧密的循环中等待直到数据准备就绪：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After the `producer` function sets the `data_ready` flag to `true`, the `consumer`
    function can safely read and process data. In our implementation, it only prints
    the `index` field to the console. After the data is processed, the `consumer`
    function indicates this by setting the `data_processed` flag to `true`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在`producer`函数将`data_ready`标志设置为`true`后，`consumer`函数可以安全地读取和处理数据。在我们的实现中，它只将`index`字段打印到控制台。处理完数据后，`consumer`函数通过将`data_processed`标志设置为`true`来指示这一点：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This triggers the next iteration of data production on the `producer` function
    side:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这触发了`producer`函数端的数据生产的下一个迭代：
- en: '![](img/96155edc-9e5c-42dc-b8d6-46969182a299.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96155edc-9e5c-42dc-b8d6-46969182a299.png)'
- en: As a result, we can see a deterministic output of processed data chunks, with
    no omissions or duplications; this is common in cases where data access is not
    synchronized.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们可以看到处理的数据块的确定性输出，没有遗漏或重复；这在数据访问不同步的情况下很常见。
- en: Exploring async functions and futures
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索异步函数和期货
- en: Dealing with data synchronization in multithreaded applications is hard, error-prone,
    and requires developers to write a lot of code to properly align data exchange
    and data notifications. In order to simplify development,  C++11 introduced a
    standard API for writing asynchronous code in a way that resembles regular synchronous
    function calls and hides lots of the synchronization complexities under the hood.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中处理数据同步是困难的，容易出错，并且需要开发人员编写大量代码来正确对齐数据交换和数据通知。为了简化开发，C++11引入了一种标准API，以一种类似于常规同步函数调用的方式编写异步代码，并在底层隐藏了许多同步复杂性。
- en: In this recipe, we will learn how to use asynchronous function invocations and
    futures to run our code in multiple threads with virtually no extra effort, for
    data synchronization.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用异步函数调用和期货在多个线程中运行我们的代码，几乎不需要额外的工作来进行数据同步。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will implement a simple application that invokes a long-running function
    in a separate thread and waits for its result. While the function is running,
    the application can keep working on other calculations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个简单的应用程序，调用一个长时间运行的函数，并等待其结果。在函数运行时，应用程序可以继续进行其他计算。
- en: In your `~/test` working directory, create a subdirectory called `async`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`async`的子目录。
- en: Use your favorite text editor to create an `async.cpp` file in the `async` subdirectory.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`async`子目录中创建一个名为`async.cpp`的文件。
- en: 'Put the code of our application into the `async.cpp` file, starting from the
    common headers and our long-running function:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的应用程序代码放入`async.cpp`文件中，从公共头文件和我们的长时间运行的函数开始：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, add the `test` function, which invokes the long-running function:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`test`函数，调用长时间运行的函数：
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, add a `main` minimalistic function:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个最简单的`main`函数：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory, with the
    following content:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can build and run the application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建并运行应用程序。
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In our application, we defined a `calculate` function that should take a long
    time to run. Technically, our function calculates the square of an integer argument,
    but we added an artificial delay to make it run for 1 second. We use a `sleep_for` standard
    library function to add a delay to the application:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们定义了一个`calculate`函数，应该需要很长时间才能运行。从技术上讲，我们的函数计算整数参数的平方，但我们添加了人为的延迟，使其运行1秒钟。我们使用`sleep_for`标准库函数来为应用程序添加延迟：
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Besides calculations, the function logs to the console when it started working,
    when it completed, and how much time it took.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算，该函数还在控制台记录了开始工作时的时间，完成时的时间以及花费的时间。
- en: Next, we defined a `test` function that invokes the `calculate` function, to
    demonstrate how asynchronous invocation works.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`test`函数，调用`calculate`函数，以演示异步调用的工作原理。
- en: The function has two parameters. The first parameter is a value that is passed
    to the `calculate` function. The second parameter is the amount of time the `test`
    function is going to spend after running the `calculate` function and before requesting
    the result. This way, we model the useful work the function can perform in parallel
    to the calculations it requested.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有两个参数。第一个参数是传递给`calculate`函数的值。第二个参数是在运行`calculate`函数后并在请求结果之前，`test`函数将花费的时间。这样，我们模拟了函数可以在并行计算中执行的有用工作。
- en: 'The `test` function starts working by running the `calculate` function in asynchronous
    mode and passing it the first parameter, `value`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数通过异步模式运行`calculate`函数，并传递第一个参数`value`：'
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `async` function implicitly spawns a thread and starts the execution of
    the `calculate` function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数隐式地生成一个线程，并开始执行`calculate`函数。'
- en: Since we run the function asynchronously, the result is not yet ready. Instead,
    the `async` function returns an instance of `std::future`, an object that will
    hold the result when it is available.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们异步运行函数，结果还没有准备好。相反，`async`函数返回一个`std::future`的实例，一个在结果可用时将保存结果的对象。
- en: 'Next, we simulate the useful work. In our case, it is the pause for the specified
    interval of time. After the work that can be done in parallel is completed, we
    need to get the result of the `calculate` function to proceed. To request the
    result, we use the `get` method of our `std::future` object, as shown:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们模拟有用的工作。在我们的情况下，这是指定时间间隔的暂停。在可以并行完成的工作完成后，我们需要获取`calculate`函数的结果才能继续。为了请求结果，我们使用`std::future`对象的`get`方法，如下所示：
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `get` method blocks until the result is available. Then, we can calculate
    the amount of time we have spent waiting for the result, and output the result—along
    with the wait time—to the console.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法会阻塞，直到结果可用。然后，我们可以计算等待结果的时间，并将结果以及等待时间输出到控制台。'
- en: 'In the `main` function, we run the `test` function to evaluate two scenarios:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们运行`test`函数来评估两种情况：
- en: The useful work takes less time than the calculation of the result.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的工作所花费的时间比计算结果的时间更短。
- en: The useful work takes more time than the calculation of the result.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的工作所花费的时间比计算结果的时间更长。
- en: Running the application produces the following output.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序会产生以下输出。
- en: 'In the first scenario, we can see that we are starting the calculations, and
    then started waiting for the result before the calculation has been completed.
    As a result, the `get` method blocked for 600 milliseconds until the result was
    ready:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们可以看到我们开始计算，然后在计算完成之前开始等待结果。结果，`get`方法阻塞了600毫秒，直到结果准备就绪：
- en: '![](img/46a609c8-dcd7-4286-b46c-dc2341addc93.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46a609c8-dcd7-4286-b46c-dc2341addc93.png)'
- en: In the second scenario, the useful work took `1200` milliseconds. As we can
    see, the calculation has been done before the result was requested, and because
    of that, the `get` method did not block, and immediately returned the result.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，有用的工作花费了`1200`毫秒。正如我们所看到的，计算在结果被请求之前就已经完成了，因此`get`方法没有阻塞，立即返回了结果。
- en: There's more...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Futures and async functions provide a powerful mechanism for writing parallel
    and understandable code. Async functions are flexible and support different execution
    policies. Promises are another mechanism that enables developers to overcome the
    complexities of asynchronous programming. More information can be found in the
    reference pages for `std::future` at [[https://en.cppreference.com/w/cpp/thread/future](https://en.cppreference.com/w/cpp/thread/future)], 
    `std::promise` at [[https://en.cppreference.com/w/cpp/thread/promise](https://en.cppreference.com/w/cpp/thread/promise)],
    and `std::async` at [[https://en.cppreference.com/w/cpp/thread/async](https://en.cppreference.com/w/cpp/thread/async)].
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 期货和异步函数提供了一个强大的机制来编写并行和易懂的代码。异步函数是灵活的，支持不同的执行策略。Promise是另一种机制，使开发人员能够克服异步编程的复杂性。更多信息可以在`std::future`的参考页面找到[[https://en.cppreference.com/w/cpp/thread/future](https://en.cppreference.com/w/cpp/thread/future)],
    `std::promise`的参考页面[[https://en.cppreference.com/w/cpp/thread/promise](https://en.cppreference.com/w/cpp/thread/promise)],
    以及`std::async`的参考页面[[https://en.cppreference.com/w/cpp/thread/async](https://en.cppreference.com/w/cpp/thread/async)]。
