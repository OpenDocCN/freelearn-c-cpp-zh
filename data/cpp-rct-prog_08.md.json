["```cpp\n//---------- ColdObservable.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \nint main(int argc, char *argv[])  \n{\n //----------- Get a Coordination \n auto eventloop = rxcpp::observe_on_event_loop(); \n //----- Create a Cold Observable \n auto values = rxcpp::observable<>::interval( \n               std::chrono::seconds(2)).take(2);\n```", "```cpp\n //----- Subscribe Twice\n\nvalues.subscribe_on(eventloop). \n    subscribe([](int v){printf(\"[1] onNext: %dn\", v);}, \n        [](){printf(\"[1] onCompleted\\n\");}); \n values.subscribe_on(eventloop). \n    subscribe([](int v){printf(\"[2] onNext: %dn\", v);}, \n        [](){printf(\"[2] onCompleted\\n\");}); \n  //---- make a blocking subscription to see the results \n values.as_blocking().subscribe(); \n //----------- Wait for Two Seconds \n rxcpp::observable<>::timer(std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n} \n```", "```cpp\n[1] onNext: 1 \n[2] onNext: 1 \n[2] onNext: 2 \n[1] onNext: 2 \n[2] onCompleted \n[1] onCompleted \n```", "```cpp\n//---------- HotObservable.cpp\n\n#include <rxcpp/rx.hpp> \n#include <memory> \nint main(int argc, char *argv[]) { \n auto eventloop = rxcpp::observe_on_event_loop(); \n //----- Create a Cold Observable \n //----- Convert Cold Observable to Hot Observable  \n //----- using .Publish(); \n auto values = rxcpp::observable<>::interval( \n               std::chrono::seconds(2)).take(2).publish();   \n //----- Subscribe Twice \n values. \n    subscribe_on(eventloop). \n    subscribe( \n        [](int v){printf(\"[1] onNext: %dn\", v);}, \n        [](){printf(\"[1] onCompletedn\");}); \n  values. \n    subscribe_on(eventloop). \n    subscribe( \n        [](int v){printf(\"[2] onNext: %dn\", v);}, \n        [](){printf(\"[2] onCompletedn\");}); \n //------ Connect to Start Emitting Values \n values.connect(); \n //---- make a blocking subscription to see the results \n values.as_blocking().subscribe(); \n //----------- Wait for Two Seconds \n rxcpp::observable<>::timer( \n       std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n} \n```", "```cpp\n//---------- HotObservable2.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \n\nint main(int argc, char *argv[]) { \n\n auto eventloop = rxcpp::observe_on_event_loop(); \n //----- Create a Cold Observable \n //----- Convert Cold Observable to Hot Observable  \n //----- using .publish_synchronized(); \n auto values = rxcpp::observable<>::interval( \n               std::chrono::seconds(2)). \n               take(5).publish_synchronized(eventloop);   \n //----- Subscribe Twice \n values. \n    subscribe( \n        [](int v){printf(\"[1] onNext: %dn\", v);}, \n        [](){printf(\"[1] onCompletedn\");}); \n\n values. \n    subscribe( \n        [](int v){printf(\"[2] onNext: %dn\", v);}, \n        [](){printf(\"[2] onCompletedn\");}); \n\n //------ Start Emitting Values \n values.connect(); \n //---- make a blocking subscription to see the results \n values.as_blocking().subscribe(); \n\n //----------- Wait for Two Seconds \n rxcpp::observable<>::timer( \n       std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n} \n```", "```cpp\n[1] onNext: 1 \n[2] onNext: 1 \n[1] onNext: 2 \n[2] onNext: 2 \n[1] onNext: 3 \n[2] onNext: 3 \n[1] onNext: 4 \n[2] onNext: 4 \n[1] onNext: 5 \n[2] onNext: 5 \n[1] onCompleted \n[2] onCompleted\n```", "```cpp\n//---------- ReplayAll.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \nint main(int argc, char *argv[]) { \n\n  auto values = rxcpp::observable<>::interval( \n                std::chrono::milliseconds(50),  \n                rxcpp::observe_on_new_thread()). \n                take(5).replay(); \n    // Subscribe from the beginning \n    values.subscribe( \n        [](long v){printf(\"[1] OnNext: %ldn\", v);}, \n        [](){printf(\"[1] OnCompletedn\");}); \n    // Start emitting \n    values.connect(); \n    // Wait before subscribing \n    rxcpp::observable<>::timer( \n         std::chrono::milliseconds(125)).subscribe([&](long){ \n        values.as_blocking().subscribe( \n            [](long v){printf(\"[2] OnNext: %ldn\", v);}, \n            [](){printf(\"[2] OnCompletedn\");}); \n    }); \n //----------- Wait for Two Seconds \n rxcpp::observable<>::timer( \n       std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n\n} \n```", "```cpp\n//---- Subscriber.cpp \n#include \"rxcpp/rx.hpp\" \nint main() { \n     //----- create a subscription object \n     auto subscription = rxcpp::composite_subscription(); \n     //----- Create a Subscription  \n     auto subscriber = rxcpp::make_subscriber<int>( \n        subscription, \n        [&](int v){ \n            printf(\"OnNext: --%dn\", v); \n            if (v == 3) \n                subscription.unsubscribe(); // Demonstrates Un Subscribes \n        }, \n        [](){ printf(\"OnCompletedn\");}); \n\n    rxcpp::observable<>::create<int>( \n        [](rxcpp::subscriber<int> s){ \n            for (int i = 0; i < 5; ++i) { \n                if (!s.is_subscribed())  \n                    break; \n                s.on_next(i); \n           } \n            s.on_completed();   \n    }).subscribe(subscriber); \n    return 0; \n} \n```", "```cpp\n//------- SimpleSubject.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \nint main(int argc, char *argv[]) { \n    //----- Create an instance of Subject \n    rxcpp::subjects::subject<int> subject; \n    //----- Retreive the Observable  \n    //----- attached to the Subject \n    auto observable = subject.get_observable(); \n    //------ Subscribe Twice \n    observable.subscribe( [] ( int v ) { printf(\"1------%dn\",v ); }); \n    observable.subscribe( [] ( int v ) { printf(\"2------%dn\",v );}); \n    //--------- Get the Subscriber Interface \n    //--------- Attached to the Subject \n    auto subscriber = subject.get_subscriber(); \n    //----------------- Emit Series of Values \n    subscriber.on_next(1); \n    subscriber.on_next(4); \n    subscriber.on_next(9); \n    subscriber.on_next(16); \n    //----------- Wait for Two Seconds \n    rxcpp::observable<>::timer(std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n}\n```", "```cpp\n//-------- BehaviorSubject.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \n\nint main(int argc, char *argv[]) { \n\n    rxcpp::subjects::behavior<int> behsubject(0); \n\n    auto observable = behsubject.get_observable(); \n    observable.subscribe( [] ( int v ) { \n        printf(\"1------%dn\",v ); \n     }); \n\n     observable.subscribe( [] ( int v ) { \n        printf(\"2------%dn\",v ); \n     }); \n\n    auto subscriber = behsubject.get_subscriber(); \n    subscriber.on_next(1); \n    subscriber.on_next(2); \n\n    int n = behsubject.get_value(); \n\n    printf (\"Last Value ....%dn\",n); \n\n} \n```", "```cpp\nreplay (Coordination cn,[optional] composite_subscription cs) \nreplay (std::size_t count, Coordination cn, [optional]composite_subscription cs) \nreplay (duration period, Coordination cn, [optional] composite_subscription cs) \nreplay (std::size_t count, duration period, Coordination cn,[optional] composite_subscription cs).\n```", "```cpp\n//------------- ReplaySubject.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \nint main(int argc, char *argv[]) { \n    //----------- instantiate a ReplaySubject \n    rxcpp::subjects::replay<int,rxcpp::observe_on_one_worker>       \n           replay_subject(10,rxcpp::observe_on_new_thread()); \n    //---------- get the observable interface \n    auto observable = replay_subject.get_observable(); \n    //---------- Subscribe! \n    observable.subscribe( [] ( int v ) {printf(\"1------%dn\",v );}); \n    //--------- get the subscriber interface \n    auto subscriber = replay_subject.get_subscriber(); \n    //---------- Emit data  \n    subscriber.on_next(1); \n    subscriber.on_next(2); \n    //-------- Add a new subscriber \n    //-------- A normal subject will drop data \n    //-------- Replay subject will not \n    observable.subscribe( [] ( int v ) {  printf(\"2------%dn\",v );}); \n     //----------- Wait for Two Seconds \n    rxcpp::observable<>::timer( \n       std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n} \n```", "```cpp\n//------------- SchedulerOne.cpp \n#include \"rxcpp/rx.hpp\" \nint main(){ \n    //---------- Get a Coordination  \n    auto Coordination function= rxcpp::serialize_new_thread(); \n    //------- Create a Worker instance  through a factory method  \n    auto worker = coordination.create_coordinator().get_worker(); \n    //--------- Create a action object \n    auto sub_action = rxcpp::schedulers::make_action( \n         [] (const rxcpp::schedulers::schedulable&) {   \n          printf(\"Action Executed in Thread # : %dn\",  \n          std::this_thread::get_id());   \n          } );  \n    //------------- Create a schedulable and schedule the action \n    auto scheduled = rxcpp::schedulers::make_schedulable(worker,sub_action); \n    scheduled.schedule(); \n    return 0; \n} \n```", "```cpp\n//----------- SchedulerTwo.cpp \n#include \"rxcpp/rx.hpp\" \nint main(){ \n    //-------- Create a Coordination function \n    auto Coordination function= rxcpp::identity_current_thread(); \n    //-------- Instantiate a coordinator and create a worker     \n    auto worker = coordination.create_coordinator().get_worker(); \n    //--------- start and the period \n    auto start = coordination.now() + std::chrono::milliseconds(1); \n    auto period = std::chrono::milliseconds(1);      \n    //----------- Create an Observable (Replay ) \n    auto values = rxcpp::observable<>::interval(start,period). \n    take(5).replay(2, coordination); \n    //--------------- Subscribe first time using a Worker \n    worker.schedule([&](const rxcpp::schedulers::schedulable&){ \n       values.subscribe( [](long v){ printf(\"#1 -- %d : %ldn\",  \n                   std::this_thread::get_id(),v);  }, \n                        [](){ printf(\"#1 --- OnCompletedn\");}); \n    }); \n    worker.schedule([&](const rxcpp::schedulers::schedulable&){ \n      values.subscribe( [](long v){printf(\"#2 -- %d : %ldn\",  \n                   std::this_thread::get_id(),v); }, \n                     [](){printf(\"#2 --- OnCompletedn\");});  \n    }); \n    //----- Start the emission of values  \n   worker.schedule([&](const rxcpp::schedulers::schedulable&) \n   { values.connect();}); \n   //------- Add blocking subscription to see results \n   values.as_blocking().subscribe(); return 0; \n}\n```", "```cpp\n//-------- ObservableOnScheduler.cpp \n#include \"rxcpp/rx.hpp\" \nint main(){ \n    //------- Print the main thread id \n    printf(\"Main Thread Id is %dn\",  \n             std::this_thread::get_id()); \n    //-------- We are using observe_on here \n    //-------- The Map will use the main thread \n    //-------- Subscribed Lambda will use a new thread \n    rxcpp::observable<>::range(0,15). \n        map([](int i){ \n            printf(\"Map %d : %dn\", std::this_thread::get_id(),i);  \n            return i; }). \n        take(5).observe_on(rxcpp::synchronize_new_thread()). \n        subscribe([&](int i){ \n           printf(\"Subs %d : %dn\", std::this_thread::get_id(),i);  \n        }); \n    //----------- Wait for Two Seconds \n    rxcpp::observable<>::timer( \n       std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n\n    return 0; \n}\n```", "```cpp\nMain Thread Id is 1 \nMap 1 : 0 \nMap 1 : 1 \nSubs 2 : 0 \nMap 1 : 2 \nSubs 2 : 1 \nMap 1 : 3 \nSubs 2 : 2 \nMap 1 : 4 \nSubs 2 : 3 \nSubs 2 : 4 \n```", "```cpp\n//-------- SubscribeOnScheduler.cpp \n#include \"rxcpp/rx.hpp\" \nint main(){ \n    //------- Print the main thread id \n    printf(\"Main Thread Id is %dn\",  \n             std::this_thread::get_id()); \n    //-------- We are using subscribe_on here \n    //-------- The Map and subscribed Lambda will  \n    //--------- use the secondary thread \n    rxcpp::observable<>::range(0,15). \n        map([](int i){ \n            printf(\"Map %d : %dn\", std::this_thread::get_id(),i);  \n            return i; \n        }). \n        take(5).subscribe_on(rxcpp::synchronize_new_thread()). \n        subscribe([&](int i){ \n           printf(\"Subs %d : %dn\", std::this_thread::get_id(),i);  \n        }); \n    //----------- Wait for Two Seconds \n    rxcpp::observable<>::timer( \n       std::chrono::milliseconds(2000)). \n       subscribe([&](long){ }); \n\n    return 0; \n}\n```", "```cpp\nMain Thread Id is 1 \nMap 2 : 0 \nSubs 2 : 0 \nMap 2 : 1 \nSubs 2 : 1 \nMap 2 : 2 \nSubs 2 : 2 \nMap 2 : 3 \nSubs 2 : 3 \nMap 2 : 4 \nSubs 2 : 4 \n```", "```cpp\n//------------- RunLoop.cpp \n#include \"rxcpp/rx.hpp\" \nint main(){ \n    //------------ Print the Main Thread Id \n    printf(\"Main Thread Id is %dn\",  \n                std::this_thread::get_id()); \n    //------- Instantiate a run_loop object \n    //------- which will loop in the main thread \n    rxcpp::schedulers::run_loop rlp; \n    //------ Create a Coordination functionfor run loop \n    auto main_thread = rxcpp::observe_on_run_loop(rlp); \n    auto worker_thread = rxcpp::synchronize_new_thread(); \n    rxcpp::composite_subscription scr; \n    rxcpp::observable<>::range(0,15). \n        map([](int i){ \n            //----- This will get executed in worker \n            printf(\"Map %d : %dn\", std::this_thread::get_id(),i);  \n            return i; \n        }).take(5).subscribe_on(worker_thread). \n        observe_on(main_thread). \n        subscribe(scr, [&](int i){ \n            //--- This will get executed in main thread \n            printf(\"Sub %d : %dn\", std::this_thread::get_id(),i); }); \n    //------------ Execute the Run Loop \n    while (scr.is_subscribed() || !rlp.empty()) { \n        while (!rlp.empty() && rlp.peek().when < rlp.now()) \n        { rlp.dispatch();} \n    }  \n    return 0; \n} \n```", "```cpp\nMain Thread Id is 1 \nMap 2 : 0 \nMap 2 : 1 \nSub 1 : 0 \nSub 1 : 1 \nMap 2 : 2 \nMap 2 : 3 \nSub 1 : 2 \nMap 2 : 4 \nSub 1 : 3 \nSub 1 : 4 \n```"]