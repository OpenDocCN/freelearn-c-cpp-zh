["```cpp\n#include <cstring> \n#include <boost/array.hpp> \n\n// C++17 has std::byte out of the box!\n// Unfortunately this is as C++03 example. \ntypedef unsigned char byte_t;\n\ntemplate <class T, std::size_t BufSizeV> \nvoid serialize_bad(const T& value, boost::array<byte_t, BufSizeV>& buffer) { \n    // TODO: check buffer size.\n    std::memcpy(&buffer[0], &value, sizeof(value)); \n}\n```", "```cpp\ntemplate <class T, std::size_t BufSizeV> \nvoid serialize_bad(const T& value, boost::array<byte_t, BufSizeV>& buffer) {  \n    // TODO: think of something better.\n    assert(BufSizeV >= sizeof(value));\n    std::memcpy(&buffer[0], &value, sizeof(value)); \n}\n```", "```cpp\n#include <boost/static_assert.hpp> \n#include <boost/type_traits/has_trivial_copy.hpp> \n\ntemplate <class T, std::size_t BufSizeV> \nvoid serialize(const T& value, boost::array<byte_t, BufSizeV>& buffer) { \n    BOOST_STATIC_ASSERT(BufSizeV >= sizeof(value)); \n    BOOST_STATIC_ASSERT(boost::has_trivial_copy<T>::value); \n\n    std::memcpy(&buffer[0], &value, sizeof(value)); \n}\n```", "```cpp\nBOOST_STATIC_ASSERT(3 >= 1); \n\nstruct some_struct { enum enum_t { value = 1}; }; \nBOOST_STATIC_ASSERT(some_struct::value); \n\ntemplate <class T1, class T2> \nstruct some_templated_struct \n{ \n    enum enum_t { value = (sizeof(T1) == sizeof(T2))}; \n}; \nBOOST_STATIC_ASSERT((some_templated_struct<int, unsigned int>::value));\n\ntemplate <class T1, class T2>\nstruct some_template { \n    BOOST_STATIC_ASSERT(sizeof(T1) == sizeof(T2));\n};\n```", "```cpp\n#include <iostream> \n#include <boost/type_traits/is_unsigned.hpp> \n#include <boost/type_traits/is_same.hpp> \n#include <boost/type_traits/remove_const.hpp> \n\ntemplate <class T1, class T2> \nvoid type_traits_examples(T1& /*v1*/, T2& /*v2*/)  { \n    // Returns true if T1 is an unsigned number \n    std::cout << boost::is_unsigned<T1>::value; \n\n    // Returns true if T1 has exactly the same type, as T2 \n    std::cout << boost::is_same<T1, T2>::value; \n\n    // This line removes const modifier from type of T1\\. \n    // Here is what will happen with T1 type if T1 is: \n    // const int => int \n    // int => int \n    // int const volatile => int volatile \n    // const int& => const int& \n    typedef typename boost::remove_const<T1>::type t1_nonconst_t; \n}\n```", "```cpp\ntemplate <class T, std::size_t BufSizeV> \nvoid serialize2(const T& value, boost::array<byte_t, BufSizeV>& buf) { \n    BOOST_STATIC_ASSERT_MSG(boost::has_trivial_copy<T>::value, \n        \"This serialize2 function may be used only \" \n        \"with trivially copyable types.\" \n    ); \n\n    BOOST_STATIC_ASSERT_MSG(BufSizeV >= sizeof(value), \n        \"Can not fit value to buffer. \" \n        \"Make the buffer bigger.\" \n    ); \n\n    std::memcpy(&buf[0], &value, sizeof(value)); \n} \n\nint main() { \n    // Somewhere in code: \n    boost::array<unsigned char, 1> buf; \n    serialize2(std::string(\"Hello word\"), buf);\n}\n```", "```cpp\nboost/static_assert.hpp:31:45: error: static assertion failed: This serialize2 function may be used only with trivially copyable types.\n #     define BOOST_STATIC_ASSERT_MSG( ... ) static_assert(__VA_ARGS__)\n ^\nChapter04/01_static_assert/main.cpp:76:5: note: in expansion of macro \u2018BOOST_STATIC_ASSERT_MSG;\n BOOST_STATIC_ASSERT_MSG(boost::has_trivial_copy<T>::value,\n ^~~~~~~~~~~~~~~~~~~~~~~\n\nboost/static_assert.hpp:31:45: error: static assertion failed: Can not fit value to buffer. Make the buffer bigger.\n #     define BOOST_STATIC_ASSERT_MSG( ... ) static_assert(__VA_ARGS__)\n ^\nChapter04/01_static_assert/main.cpp:81:5: note: in expansion of macro \u2018BOOST_STATIC_ASSERT_MSG;\n BOOST_STATIC_ASSERT_MSG(BufSizeV >= sizeof(value),\n ^~~~~~~~~~~~~~~~~~~~~~~\n```", "```cpp\ntemplate <class T>\nusing remove_const_t = typename remove_const<T>::type;\n```", "```cpp\ntemplate <class T>\ninline constexpr bool is_unsigned_v = is_unsigned<T>::value;\n```", "```cpp\n// Generic implementation.\ntemplate <class T> \nclass data_processor { \n    double process(const T& v1, const T& v2, const T& v3); \n};\n```", "```cpp\n// Integral types optimized version. \ntemplate <class T>\nclass data_processor_integral {\n    typedef int fast_int_t;\n    double process(fast_int_t v1, fast_int_t v2, fast_int_t v3);\n}; \n\n// SSE optimized version for float types.\ntemplate <class T>\nclass data_processor_sse {\n    double process(double v1, double v2, double v3);\n};\n```", "```cpp\n#include <boost/core/enable_if.hpp>\n#include <boost/type_traits/is_integral.hpp>\n#include <boost/type_traits/is_float.hpp>\n```", "```cpp\n// Generic implementation.\ntemplate <class T, class Enable = void>\nclass data_processor {\n    // ...\n};\n```", "```cpp\n// Integral types optimized version.\ntemplate <class T>\nclass data_processor<\n    T,\n    typename boost::enable_if_c<boost::is_integral<T>::value >::type\n>\n{\n    // ...\n};\n\n// SSE optimized version for float types.\ntemplate <class T>\nclass data_processor<\n    T,\n    typename boost::enable_if_c<boost::is_float<T>::value >::type\n>\n{\n    // ...\n};\n```", "```cpp\ntemplate <class T>\ndouble example_func(T v1, T v2, T v3) {\n    data_processor<T> proc;\n    return proc.process(v1, v2, v3);\n}\n\nint main () {\n    // Integral types optimized version\n    // will be called.\n    example_func(1, 2, 3);\n    short s = 0;\n    example_func(s, s, s);\n\n    // Real types version will be called.\n    example_func(1.0, 2.0, 3.0);\n    example_func(1.0f, 2.0f, 3.0f);\n\n    // Generic version will be called.\n    example_func(\"Hello\", \"word\", \"processing\");\n}\n```", "```cpp\ntemplate <class T> \nclass data_processor<\n    T, std::enable_if_t<boost::is_float<T>::value >\n>;\n```", "```cpp\ntemplate <class T> \nT process_data(const T& v1, const T& v2, const T& v3);\n```", "```cpp\ntemplate <class T> \nT process_data_plus_assign(const T& v1, const T& v2, const T& v3);\n```", "```cpp\n#include <boost/core/enable_if.hpp>\n#include <boost/type_traits/has_plus_assign.hpp>\n```", "```cpp\n// Modified generic version of process_data\ntemplate <class T>\ntypename boost::disable_if_c<boost::has_plus_assign<T>::value,T>::type\n    process_data(const T& v1, const T& v2, const T& v3);\n```", "```cpp\n// This process_data will call a process_data_plus_assign.\ntemplate <class T>\ntypename boost::enable_if_c<boost::has_plus_assign<T>::value, T>::type\n    process_data(const T& v1, const T& v2, const T& v3)\n{\n    return process_data_plus_assign(v1, v2, v3);\n}\n```", "```cpp\nint main() {\n    int i = 1;\n    // Optimized version.\n    process_data(i, i, i);\n\n    // Default version.\n    // Explicitly specifing template parameter.\n    process_data<const char*>(\"Testing\", \"example\", \"function\");\n}\n```", "```cpp\n// First version \ntemplate <class T> \ntypename boost::disable_if<boost::has_plus_assign<T>, T>::type \n    process_data2(const T& v1, const T& v2, const T& v3); \n\n// process_data_plus_assign \ntemplate <class T> \ntypename boost::enable_if<boost::has_plus_assign<T>, T>::type \n    process_data2(const T& v1, const T& v2, const T& v3);\n```", "```cpp\n#include <boost/static_assert.hpp> \n#include <boost/type_traits/is_pod.hpp> \n\n// Generic implementation. \ntemplate <class T> \nT process(const T& val) { \n    BOOST_STATIC_ASSERT((boost::is_pod<T>::value)); \n    // ... \n}\n```", "```cpp\n#include <boost/mpl/int.hpp> \n\nnamespace detail {\n    // Generic implementation.\n    template <class T, class Tag>\n    T process_impl(const T& val, Tag /*ignore*/) {\n        // ...\n    }\n\n    // 1 byte optimized implementation.\n    template <class T>\n    T process_impl(const T& val, boost::mpl::int_<1> /*ignore*/) {\n        // ...\n    }\n\n    // 4 bytes optimized implementation.\n    template <class T>\n    T process_impl(const T& val, boost::mpl::int_<4> /*ignore*/) {\n        // ...\n    }\n\n    // 8 bytes optimized implementation.\n    template <class T>\n    T process_impl(const T& val, boost::mpl::int_<8> /*ignore*/) {\n        // ...\n    }\n} // namespace detail\n```", "```cpp\n// Dispatching calls:\ntemplate <class T>\nT process(const T& val) {\n    BOOST_STATIC_ASSERT((boost::is_pod<T>::value));\n    return detail::process_impl(val, boost::mpl::int_<sizeof(T)>());\n}\n```", "```cpp\ntemplate <int Value> \nstruct int_ { \n    static const int value = Value; \n    typedef int_<Value> type; \n    typedef int value_type; \n};\n```", "```cpp\ntemplate <int Value>\nusing int_ = std::integral_constant<int, Value>;\n```", "```cpp\n#include <vector> \n#include <boost/type_traits/integral_constant.hpp> \n\ntemplate <class T> \nstruct is_stdvector: boost::false_type {}; \n\ntemplate <class T, class Allocator> \nstruct is_stdvector<std::vector<T, Allocator> >: boost::true_type  {};\n```", "```cpp\ntemplate <class T> \nvoid inc(T& value) { \n    // TODO:\n    // call ++value \n    // or call value ++ \n    // or value += T(1); \n    // or value = value + T(1); \n}\n```", "```cpp\nnamespace detail {\n    struct pre_inc_functor {\n    template <class T>\n        void operator()(T& value) const {\n           ++ value;\n        }\n    };\n\n    struct post_inc_functor {\n    template <class T>\n        void operator()(T& value) const {\n            value++;\n        }\n    };\n\n    struct plus_assignable_functor {\n    template <class T>\n        void operator()(T& value) const {\n            value += T(1);\n        }\n    };\n\n    struct plus_functor {\n    template <class T>\n        void operator()(T& value) const {\n            value = value + T(1);\n        }\n    };\n}\n```", "```cpp\n#include <boost/type_traits/conditional.hpp>\n#include <boost/type_traits/has_plus_assign.hpp>\n#include <boost/type_traits/has_plus.hpp>\n#include <boost/type_traits/has_post_increment.hpp>\n#include <boost/type_traits/has_pre_increment.hpp>\n```", "```cpp\ntemplate <class T>\nvoid inc(T& value) {\n    // call ++value\n    // or call value ++\n    // or value += T(1);\n    // or value = value + T(1);\n\n    typedef detail::plus_functor step_0_t;\n\n    typedef typename boost::conditional<\n      boost::has_plus_assign<T>::value,\n      detail::plus_assignable_functor,\n      step_0_t\n    >::type step_1_t; \n\n    typedef typename boost::conditional<\n      boost::has_post_increment<T>::value,\n      detail::post_inc_functor,\n      step_1_t\n    >::type step_2_t;\n\n    typedef typename boost::conditional<\n      boost::has_pre_increment<T>::value,\n      detail::pre_inc_functor,\n      step_2_t\n    >::type step_3_t;\n\n    step_3_t() // Default construction of the functor.\n        (value); // Calling operator() of the functor.\n}\n```", "```cpp\n#include <boost/mpl/if.hpp> \n\ntemplate <class T> \nvoid inc_mpl(T& value) { \n    typedef detail::plus_functor step_0_t;\n\n    typedef typename boost::mpl::if_<\n      boost::has_plus_assign<T>,\n      detail::plus_assignable_functor,\n      step_0_t\n    >::type step_1_t;\n\n    typedef typename boost::mpl::if_<\n      boost::has_post_increment<T>,\n      detail::post_inc_functor,\n      step_1_t\n    >::type step_2_t;\n\n    typedef typename boost::mpl::if_<\n      boost::has_pre_increment<T>,\n      detail::pre_inc_functor,\n      step_2_t\n    >::type step_3_t;\n\n    step_3_t()   // Default construction of the functor.\n        (value); // Calling operator() of the functor.\n}\n```", "```cpp\ntemplate <class T> \nvoid inc_cpp17(T& value) { \n    if constexpr (boost::has_pre_increment<T>()) {\n        ++value;\n    } else if constexpr (boost::has_post_increment<T>()) {\n        value++;\n    } else if constexpr(boost::has_plus_assign<T>()) {\n        value += T(1);\n    } else {\n        value = value + T(1);\n    }\n}\n```", "```cpp\n#include <functional> \n#include <boost/bind.hpp> \n\nconst ??? var = boost::bind(std::plus<int>(), _1, _1);\n```", "```cpp\n#include <boost/typeof/typeof.hpp>\n\nBOOST_AUTO(var, boost::bind(std::plus<int>(), _1, _1));\n```", "```cpp\ntypedef decltype(0.5 + 0.5f) type;\n```", "```cpp\ntypedef BOOST_TYPEOF(0.5 + 0.5f) type;\n```", "```cpp\ntemplate<class T1, class T2> \nauto add(const T1& t1, const T2& t2) ->decltype(t1 + t2) { \n    return t1 + t2; \n};\n```", "```cpp\n// Long and portable way:\ntemplate<class T1, class T2>\nstruct result_of {\n    typedef BOOST_TYPEOF_TPL(T1() + T2()) type;\n};\n\ntemplate<class T1, class T2>\ntypename result_of<T1, T2>::type add(const T1& t1, const T2& t2) {\n    return t1 + t2;\n};\n\n// ... or ...\n\n// Shorter version that may crush some compilers.\ntemplate<class T1, class T2>\nBOOST_TYPEOF_TPL(T1() + T2()) add(const T1& t1, const T2& t2) {\n    return t1 + t2;\n};\n```", "```cpp\n#include <boost/static_assert.hpp> \n#include <boost/type_traits/is_same.hpp> \nBOOST_STATIC_ASSERT((\n    boost::is_same<BOOST_TYPEOF(add(1, 1)), int>::value\n));\n```", "```cpp\nnamespace readers_project { \n    template <class T1, class T2, class T3> \n    struct readers_template_class{}; \n} \n\n#include <boost/tuple/tuple.hpp> \n\ntypedef \n    readers_project::readers_template_class<int, int, float> \nreaders_template_class_1; \n\ntypedef BOOST_TYPEOF(boost::get<0>( \n    boost::make_tuple(readers_template_class_1(), 1) \n)) readers_template_class_deduced; \n\nBOOST_STATIC_ASSERT(( \n    boost::is_same< \n        readers_template_class_1, \n        readers_template_class_deduced \n    >::value \n));\n```", "```cpp\nBOOST_TYPEOF_REGISTER_TEMPLATE( \n        readers_project::readers_template_class /*class name*/, \n        3 /*number of template classes*/ \n)\n```"]