- en: Native C++ Threads and Primitives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地C++线程和原语
- en: Starting with the 2011 revision of the C++ standard, a multithreading API is
    officially part of the C++ **Standard Template Library** (**STL**). This means
    that threads, thread primitives, and synchronization mechanisms are available
    to any new C++ application without the need to install a third-party library,
    or to rely on the operating system's APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从2011年的C++标准修订版开始，多线程API正式成为C++**标准模板库**（**STL**）的一部分。这意味着线程、线程原语和同步机制对于任何新的C++应用程序都是可用的，无需安装第三方库或依赖操作系统的API。
- en: This chapter looks at the multithreading features available in this native API
    up to the features added by the 2014 standard. A number of examples will be shown
    to use these features in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍本地API中可用的多线程功能，直到2014年标准添加的功能。将展示一些示例以详细使用这些功能。
- en: 'Topics in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括以下内容：
- en: The features covered by the multithreading API in C++'s STL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ STL中的多线程API提供的功能
- en: Detailed examples of the usage of each feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个功能的详细使用示例
- en: The STL threading API
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL线程API
- en: In [Chapter 10](981efdf3-efa2-4e62-aba0-2d52ab80f3c8.xhtml), *C++ Multithreading
    APIs*, we looked at the various APIs that are available to us when developing
    a multithreaded C++ application. In [Chapter 11](3569125d-7316-4147-ba03-9c65cfd755d7.xhtml),
    *Thread Synchronization and Communication*, we implemented a multithreaded scheduler
    application using the native C++ threading API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](981efdf3-efa2-4e62-aba0-2d52ab80f3c8.xhtml)中，*C++多线程API*，我们看了一下在开发多线程C++应用程序时可用的各种API。在[第11章](3569125d-7316-4147-ba03-9c65cfd755d7.xhtml)中，*线程同步和通信*，我们使用本地C++线程API实现了一个多线程调度程序应用程序。
- en: Boost.Thread API
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost.Thread API
- en: By including the `<thread>` header from the STL, we gain access to the `std::thread`
    class with facilities for mutual exclusion (mutex, and so on) provided by further
    headers. This API is, essentially, the same as the multithreading API from `Boost.Thread`**,**
    the main differences being more control over threads (join with timeout, thread
    groups, and thread interruption), and a number of additional lock types implemented
    on top of primitives such as mutexes and condition variables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含STL中的`<thread>`头文件，我们可以访问`std::thread`类，该类具有由其他头文件提供的互斥（互斥锁等）设施。这个API本质上与`Boost.Thread`的多线程API相同，主要区别在于对线程的更多控制（带超时的加入，线程组和线程中断），以及在原语（如互斥锁和条件变量）之上实现的一些额外的锁类型。
- en: In general, `Boost.Thread` should be used as a fall back for when C++11 support
    isn't present, or when these additional `Boost.Thread` features are a requirement
    of one's application, and not easily added otherwise. Since `Boost.Thread` builds
    upon the available (native) threading support, it's also likely to add overhead
    as compared to the C++11 STL implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当C++11支持不可用时，或者这些额外的`Boost.Thread`功能是应用程序的要求，并且不容易以其他方式添加时，应该使用`Boost.Thread`作为备用。由于`Boost.Thread`建立在可用的（本地）线程支持之上，因此与C++11
    STL实现相比，它还可能增加开销。
- en: The 2011 standard
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2011年标准
- en: The 2011 revision to the C++ standard (commonly referred to as C++11) adds a
    wide range of new features, the most crucial one being the addition of native
    multithreading support, which adds the ability to create, manage, and use threads
    within C++ without the use of third-party libraries.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准的2011年修订版（通常称为C++11）增加了许多新功能，其中最关键的是添加了本地多线程支持，这增加了在C++中创建、管理和使用线程的能力，而无需使用第三方库。
- en: This standard standardizes the memory model for the core language to allow multiple
    threads to coexist as well as enables features such as thread-local storage. Initial
    support was added in the C++03 standard, but the C++11 standard is the first to
    make full use of this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标准为核心语言规范了内存模型，允许多个线程共存，并启用了诸如线程本地存储之类的功能。C++03标准中已经添加了初始支持，但C++11标准是第一个充分利用这一特性的标准。
- en: As noted earlier, the actual threading API itself is implemented in the STL.
    One of the goals for the C++11 (C++0x) standard was to have as many of the new
    features as possible in the STL, and not as part of the core language. As a result,
    in order to use threads, mutexes, and kin, one has to first include the relevant
    STL header.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实际的线程API本身是在STL中实现的。C++11（C++0x）标准的一个目标是尽可能多地将新功能放入STL中，而不是作为核心语言的一部分。因此，为了使用线程、互斥锁等，必须首先包含相关的STL头文件。
- en: The standards committee which worked on the new multithreading API each had
    their own sets of goals, and as a result, a few features which were desired by
    some did not make it into the final standard. This includes features such as terminating
    another thread, or thread cancellation, which was strongly opposed by the POSIX
    representatives on account of canceling threads likely to cause issues with resource
    clean-up in the thread being destroyed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 负责新多线程API的标准委员会各自设定了自己的目标，因此一些希望加入的功能最终未能成为标准的一部分。这包括终止另一个线程或线程取消等功能，这些功能受到POSIX代表的强烈反对，因为取消线程可能会导致正在销毁的线程资源清理出现问题。
- en: 'Following are the features provided by this API implementation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此API实现提供的功能：
- en: '`std::thread`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::thread`'
- en: '`std::mutex`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mutex`'
- en: '`std::recursive_mutex`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::recursive_mutex`'
- en: '`std::condition_variable`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::condition_variable`'
- en: '`std::condition_variable_any`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::condition_variable_any`'
- en: '`std::lock_guard`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::lock_guard`'
- en: '`std::unique_lock`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_lock`'
- en: '`std::packaged_task`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::packaged_task`'
- en: '`std::async`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::async`'
- en: '`std::future`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::future`'
- en: In a moment, we will look at detailed examples of each of these features. First
    we will see what the next revisions of the C++ standard have added to this initial
    set.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细介绍每个功能的示例。首先，我们将看看C++标准的下一个修订版本添加了哪些初始功能。
- en: C++14
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++14
- en: 'The 2014 standard adds the following features to the standard library:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年的标准向标准库添加了以下功能：
- en: '`std::shared_lock`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_lock`'
- en: '`std::shared_timed_mutex`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_timed_mutex`'
- en: Both of these are defined in the `<shared_mutex>` STL header. Since locks are
    based on mutexes, a shared lock is, therefore, reliant on a shared mutex.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都在`<shared_mutex>`STL头文件中定义。由于锁是基于互斥锁的，因此共享锁依赖于共享互斥锁。
- en: Thread class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程类
- en: The `thread` class is the core of the entire threading API; it wraps the underlying
    operating system's threads, and provides the functionality we need to start and
    stop threads.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`类是整个线程API的核心；它包装了底层操作系统的线程，并提供了我们启动和停止线程所需的功能。'
- en: This functionality is made accessible by including the `<thread>` header.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含`<thread>`头文件，可以访问此功能。
- en: Basic use
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Upon creating a thread it is started immediately:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程后立即启动：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This preceding code would start the thread to then immediately terminate the
    application, because we are not waiting for the new thread to finish executing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将启动线程，然后立即终止应用程序，因为我们没有等待新线程执行完毕。
- en: 'To do this properly, we need to wait for the thread to finish, or rejoin as
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确执行这个操作，我们需要等待线程完成，或者重新加入如下：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This last code would execute, wait for the new thread to finish, and then return.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将执行，等待新线程完成，然后返回。
- en: Passing parameters
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'It''s also possible to pass parameters to a new thread. These parameter values
    have to be move constructible, which means that it''s a type which has a move
    or copy constructor (called for rvalue references). In practice, this is the case
    for all basic types and most (user-defined) classes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以向新线程传递参数。这些参数值必须是可移动构造的，这意味着它是一个具有移动或复制构造函数（用于右值引用）的类型。实际上，对于所有基本类型和大多数（用户定义的）类来说，这是成立的：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this preceding code, we pass an integer and string to the `thread` function.
    This function will receive copies of both variables. When passing references or
    pointers, things get more complicated with life cycle issues, data races, and
    such becoming a potential problem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将一个整数和一个字符串传递给`thread`函数。该函数将接收这两个变量的副本。当传递引用或指针时，生命周期问题、数据竞争等会变得更加复杂，可能会成为一个问题。
- en: Return value
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: Any value returned by the function passed to the `thread` class constructor
    is ignored. To return information to the thread which created the new thread,
    one has to use inter-thread synchronization mechanisms (like mutexes) and some
    kind of a shared variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`thread`类构造函数的函数返回的任何值都将被忽略。要将信息返回给创建新线程的线程，必须使用线程间同步机制（如互斥锁）和某种共享变量。
- en: Moving threads
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动线程
- en: 'The 2011 standard adds `std::move` to the `<utility>` header. Using this template
    method, one can move resources between objects. This means that it can also move
    thread instances:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年的标准在`<utility>`头文件中添加了`std::move`。使用这个模板方法，可以在对象之间移动资源。这意味着它也可以移动线程实例：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this version of the code, we create a thread before moving it to another
    thread. Thread 0 thus ceases to exist (since it instantly finishes), and the execution
    of the `thread` function resumes in the new thread that we create.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的代码中，我们在将线程移动到另一个线程之前创建了一个线程。因此线程0停止存在（因为它立即完成），并且`thread`函数的执行在我们创建的新线程中恢复。
- en: As a result of this, we do not have to wait for the first thread to re join,
    but only for the second one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必等待第一个线程重新加入，只需要等待第二个线程。
- en: Thread ID
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程ID
- en: 'Each thread has an identifier associated with it. This ID, or handle, is a
    unique identifier provided by the STL implementation. It can be obtained by calling
    the `get_id()` function of the `thread` class instance, or by calling `std::this_thread::get_id()`
    to get the ID of the thread calling the function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个与之关联的标识符。这个ID或句柄是STL实现提供的唯一标识符。可以通过调用`thread`类实例的`get_id()`函数或调用`std::this_thread::get_id()`来获取调用该函数的线程的ID：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code would produce output similar to this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将产生类似于以下的输出：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, one sees that the internal thread ID is an integer (`std::thread::id`
    type), relative to the initial thread (ID 1). This is comparable to most native
    thread IDs such as those for POSIX. These can also be obtained using `native_handle()`.
    That function will return whatever is the underlying native thread handle. It
    is particularly useful when one wishes to use a very specific PThread or Win32
    thread functionality that's not available in the STL implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可以看到内部线程ID是一个整数（`std::thread::id`类型），相对于初始线程（ID为1）。这类似于大多数本机线程ID，比如POSIX的线程ID。这些也可以使用`native_handle()`获得。该函数将返回底层的本机线程句柄。当希望使用STL实现中不可用的特定PThread或Win32线程功能时，这是特别有用的。
- en: Sleeping
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休眠
- en: 'It''s possible to delay the execution of a thread (sleep) using either of two
    methods. One is `sleep_for()`, which delays execution by at least the specified
    duration, but possibly longer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种方法延迟执行线程（休眠）。一种是`sleep_for()`，它至少延迟指定的持续时间，但可能更长：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This preceding code shows how to sleep for roughly 2 seconds, measuring the
    exact duration using a counter with the highest precision possible on the current
    OS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何休眠大约2秒，使用具有当前操作系统上可能的最高精度的计数器来测量确切的持续时间。
- en: Note that we are able to specify the number of seconds directly, with the seconds
    post-fix. This is a C++14 feature that got added to the `<chrono>` header. For
    the C++11 version, one has to create an instance of std::chrono::seconds and pass
    it to the `sleep_for()` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以直接指定秒数，使用秒后缀。这是C++14添加到`<chrono>`头文件的功能。对于C++11版本，需要创建一个std::chrono::seconds的实例并将其传递给`sleep_for()`函数。
- en: The other method is `sleep_until()`, which takes a single parameter of type
    `std::chrono::time_point<Clock, Duration>`. Using this function, one can set a
    thread to sleep until the specified time point has been reached. Due to the operating
    system's scheduling priorities, this wake-up time might not be the exact time
    as specified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是`sleep_until()`，它接受一个类型为`std::chrono::time_point<Clock, Duration>`的单个参数。使用这个函数，可以设置线程休眠，直到达到指定的时间点。由于操作系统的调度优先级，这个唤醒时间可能不是指定的确切时间。
- en: Yield
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屈服
- en: One can indicate to the OS that the current thread can be rescheduled so that
    other threads can run instead. For this, one uses the `std::this_thread::yield()`
    function. The exact result of this function depends on the underlying OS implementation
    and its scheduler. In the case of a FIFO scheduler, it's likely that the calling
    thread will be put at the back of the queue.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以告诉操作系统当前线程可以重新调度，以便其他线程可以运行。为此，可以使用`std::this_thread::yield()`函数。此函数的确切结果取决于底层操作系统实现及其调度程序。在FIFO调度程序的情况下，调用线程可能会被放在队列的末尾。
- en: This is a highly specialized function, with special use cases. It should not
    be used without first validating its effect on the application's performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高度专业化的函数，具有特殊的用例。在未验证其对应用程序性能的影响之前，不应使用它。
- en: Detach
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离
- en: After starting a thread, one can call `detach()` on the thread object. This
    effectively detaches the new thread from the calling thread, meaning that the
    former will continue executing even after the calling thread has exited.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 启动线程后，可以在线程对象上调用`detach()`。这实际上将新线程与调用线程分离，这意味着前者将在调用线程退出后继续执行。
- en: Swap
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换
- en: 'Using `swap()`, either as a standalone method or as function of a thread instance,
    one can exchange the underlying thread handles of thread objects:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`swap()`，可以作为独立方法或作为线程实例的函数，可以交换线程对象的基础线程句柄：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The possible output from this code might look like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的可能输出如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The effect of this is that the state of each thread is swapped with that of
    the other thread, essentially exchanging their identities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其效果是每个线程的状态与另一个线程的状态交换，实质上交换了它们的身份。
- en: Mutex
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: The `<mutex>` header contains multiple types of mutexes and locks. The mutex
    type is the most commonly used type, and provides the basic lock/unlock functionality
    without any further complications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mutex>`头文件包含多种类型的互斥锁和锁。互斥锁类型是最常用的类型，提供基本的锁定/解锁功能，没有更多的复杂性。'
- en: Basic use
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本用法
- en: At its core, the goal of a mutex is to exclude the possibility of simultaneous
    access so as to prevent data corruption, and to prevent crashes due to the use
    of non-thread-safe routines.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，互斥锁的目标是排除同时访问的可能性，以防止数据损坏，并防止由于使用非线程安全例程而导致崩溃。
- en: 'An example of where one would need to use a mutex is the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要使用互斥锁的示例代码如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If one were to try and run this preceding code as-is, one would notice that
    the text output from both threads would be mashed together instead of being output
    one after the other. The reason for this is that the standard output (whether
    C or C++-style) is not thread-safe. Though the application will not crash, the
    output will be a jumble.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个人尝试直接运行上述代码，就会注意到两个线程的文本输出会被混在一起，而不是依次输出。原因是标准输出（无论是C还是C++风格）不是线程安全的。虽然应用程序不会崩溃，但输出会是一团糟。
- en: 'The fix for this is simple, and is given as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的修复很简单，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this situation, each thread would first need to obtain access to the `mutex`
    object. Since only one thread can have access to the `mutex` object, the other
    thread will end up waiting for the first thread to finish writing to the standard
    output, and the two strings will appear one after the other, as intended.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个线程首先需要获取`mutex`对象的访问权。由于只有一个线程可以访问`mutex`对象，另一个线程将等待第一个线程完成对标准输出的写入，两个字符串将按预期依次出现。
- en: Non-blocking locking
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞锁定
- en: 'It''s possible to not want the thread to block and wait for the `mutex` object
    to become available: for example, when one just wants to know whether a request
    is already being handled by another thread, and there''s no use in waiting for
    it to finish.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不希望线程阻塞并等待`mutex`对象可用：例如，当一个人只想知道是否另一个线程已经处理了请求，并且没有必要等待其完成时。
- en: For this, a mutex comes with the `try_lock()` function which does exactly that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，互斥锁带有`try_lock()`函数，可以做到这一点。
- en: 'In the following example, we can see two threads trying to increment the same
    counter, but with one incrementing its own counter whenever it fails to immediately
    obtain access to the shared counter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以看到两个线程尝试递增相同的计数器，但是当一个线程无法立即访问共享计数器时，它会递增自己的计数器：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both threads in this preceding example run a different `worker` function, yet
    both have in common the fact that they sleep for a period of time, and try to
    acquire the mutex for the shared counter when they wake up. If they do, they'll
    increase the counter, but only the first worker will output this fact.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，两个线程运行不同的`worker`函数，但它们都有一个共同点，即它们都会在一段时间内休眠，并在醒来时尝试获取共享计数器的互斥锁。如果成功，它们将增加计数器，但只有第一个工作线程会输出这个事实。
- en: 'The first worker also logs when it did not get the shared counter, but only
    increased its exclusive counter. The resulting output might look something like
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个工作线程还会记录当它没有获得共享计数器时，但只增加了它自己的独立计数器。结果输出可能看起来像这样：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Timed mutex
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时互斥锁
- en: A timed mutex is a regular mutex type, but with a number of added functions
    which give one control over the time period during which it should be attempted
    to obtain the lock, that is, `try_lock_for` and `try_lock_until`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 定时互斥锁是常规互斥锁类型，但具有一些额外的函数，可以控制在尝试获取锁期间的时间段，即`try_lock_for`和`try_lock_until`。
- en: The former tries to obtain the lock during the specified time period (`std::chrono`
    object) before returning the result (true or false). The latter will wait until
    a specific point in the future before returning the result.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前者在指定的时间段（`std::chrono`对象）内尝试获取锁，然后返回结果（true或false）。后者将等待直到将来的特定时间点，然后返回结果。
- en: The use of these functions mostly lies in offering a middle path between the
    blocking (`lock`) and non-blocking (`try_lock`) methods of the regular mutex.
    One may want to wait for a number of tasks using only a single thread without
    knowing when a task will become available, or a task may expire at a certain point
    in time at which waiting for it makes no sense any more.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能的使用主要在于提供常规互斥锁的阻塞（`lock`）和非阻塞（`try_lock`）方法之间的中间路径。一个人可能希望使用单个线程等待一些任务，而不知道何时任务将变为可用，或者任务可能在某个特定时间点过期，此时等待它就不再有意义了。
- en: Lock guard
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁卫
- en: A lock guard is a simple mutex wrapper, which handles the obtaining of a lock
    on the `mutex` object as well as its release when the lock guard goes out of scope.
    This is a helpful mechanism to ensure that one does not forget to release a mutex
    lock, and to help reduce clutter in one's code when one has to release the same
    mutex in multiple locations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 锁卫是一个简单的互斥锁包装器，它处理对`mutex`对象的锁定以及在锁卫超出范围时的释放。这是一个有用的机制，可以确保不会忘记释放互斥锁，并且在必须在多个位置释放相同的互斥锁时，可以帮助减少代码的混乱。
- en: 'While refactoring of, for example, big if/else blocks can reduce the instances
    in which the release of a mutex lock is required, it''s much easier to just use
    this lock guard wrapper and not worry about such details:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管重构，例如大的if/else块可以减少需要释放互斥锁的情况，但最好还是使用这个锁卫包装器，不用担心这些细节：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, we see that we have a small if/else block with one
    condition leading to the `worker` function immediately returning. Without a lock
    guard, we would have to make sure that we also unlocked the mutex in this condition
    before returning from the function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到一个小的if/else块，其中一个条件导致`worker`函数立即返回。如果没有锁卫，我们必须确保在从函数返回之前在此条件下也解锁互斥锁。
- en: With the lock guard, however, we do not have to worry about such details, which
    allows us to focus on the business logic instead of worrying about mutex management.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有了锁卫，我们就不必担心这些细节，这使我们可以专注于业务逻辑，而不是担心互斥锁管理。
- en: Unique lock
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一锁
- en: The unique lock is a general-purpose mutex wrapper. It's similar to the timed
    mutex, but with additional features, primary of which is the concept of ownership.
    Unlike other lock types, a unique lock does not necessarily own the mutex it wraps
    if it contains any at all. Mutexes can be transferred between unique lock instances
    along with ownership of the said mutexes using the `swap()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一锁是一个通用的互斥锁包装器。它类似于定时互斥锁，但具有附加功能，主要是所有权的概念。与其他锁类型不同，唯一锁不一定拥有它包装的互斥锁，如果有的话。互斥锁可以在唯一锁实例之间以及使用`swap()`函数转移这些互斥锁的所有权。
- en: 'Whether a unique lock instance has ownership of its mutex, and whether it''s
    locked or not, is first determined when creating the lock, as can be seen with
    its constructors. For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一锁实例是否拥有其互斥锁的所有权，以及它是否被锁定或未锁定，是在创建锁时首先确定的，可以从其构造函数中看到。例如：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first constructor in the last code does not lock the assigned mutex (defers).
    The second attempts to lock the mutex using `try_lock()`. Finally, the third constructor
    assumes that it already owns the provided mutex.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个代码中的第一个构造函数不锁定分配的互斥锁（延迟）。第二个尝试使用`try_lock()`锁定互斥锁。最后，第三个构造函数假定它已经拥有提供的互斥锁。
- en: In addition to these, other constructors allow the functionality of a timed
    mutex. That is, it will wait for a time period until a time point has been reached,
    or until the lock has been acquired.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，其他构造函数允许定时互斥锁的功能。也就是说，它将等待一段时间，直到达到某个时间点，或者直到获得锁。
- en: Finally, the association between the lock and the mutex is broken by using the
    `release()` function, and a pointer is returned to the `mutex` object. The caller
    is then responsible for the releasing of any remaining locks on the mutex and
    for the further handling of it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`release()`函数可以断开锁与互斥锁之间的关联，并返回`mutex`对象的指针。然后调用者负责释放互斥锁上的任何剩余锁，并进一步处理它。
- en: This type of lock isn't one which one will tend to use very often on its own,
    as it's extremely generic. Most of the other types of mutexes and locks are significantly
    less complex, and likely to fulfil all the needs in 99% of all cases. The complexity
    of a unique lock is, thus, both a benefit and a risk.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的锁通常不会单独使用，因为它非常通用。大多数其他类型的互斥锁和锁都要简单得多，并且可能在99%的情况下满足所有需求。唯一锁的复杂性因此既是优点也是风险。
- en: It is, however, commonly used by other parts of the C++11 threading API, such
    as condition variables, as we will see in a moment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它通常被C++11线程API的其他部分使用，例如我们马上就会看到的条件变量。
- en: 'One area where a unique lock may be useful is as a scoped lock, allowing one
    to use scoped locks without having to rely on the native scoped locks in the C++17
    standard. See this example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一锁可能有用的一个领域是作为作用域锁，允许使用作用域锁而不必依赖C++17标准中的原生作用域锁。看这个例子：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we enter the function, we create a new unique_lock with the global mutex
    instance. The mutex is locked at this point, after which we can perform any critical
    operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入函数时，我们使用全局互斥锁实例创建一个新的unique_lock。在这一点上，互斥锁被锁定，之后我们可以执行任何关键操作。
- en: When the function scope ends, the destructor of the unique_lock is called, which
    results in the mutex getting unlocked again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数作用域结束时，唯一锁的析构函数被调用，这导致互斥锁再次被解锁。
- en: Scoped lock
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域锁
- en: First introduced in the 2017 standard, the scoped lock is a mutex wrapper which
    obtains access to (locks) the provided mutex, and ensures it is unlocked when
    the scoped lock goes out of scope. It differs from a lock guard in that it is
    a wrapper for not one, but multiple mutexes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域锁是在2017年标准中首次引入的，它是一个互斥锁包装器，用于获取（锁定）提供的互斥锁，并确保在作用域锁超出范围时解锁。它与锁卫的不同之处在于它是多个互斥锁的包装器，而不是一个。
- en: This can be useful when one deals with multiple mutexes in a single scope. One
    reason to use a scoped lock is to avoid accidentally introducing deadlocks and
    other unpleasant complications with, for example, one mutex being locked by the
    scoped lock, another lock still being waited upon, and another thread instance
    having the exactly opposite situation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当在单个作用域中处理多个互斥时，这可能是有用的。使用作用域锁的一个原因是为了避免意外引入死锁和其他不愉快的复杂情况，例如一个互斥被作用域锁锁定，另一个锁仍在等待，另一个线程实例具有完全相反的情况。
- en: One property of a scoped lock is that it tries to avoid such a situation, theoretically
    making this type of lock deadlock-safe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域锁的一个特性是，它试图避免这种情况，从理论上讲，使得这种类型的锁具有死锁安全性。
- en: Recursive mutex
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归互斥
- en: The recursive mutex is another subtype of mutex. Even though it has exactly
    the same functions as a regular mutex, it allows the calling thread, which initially
    locked the mutex, to lock the same mutex repeatedly. By doing this, the mutex
    doesn't become available for other threads until the owning thread has unlocked
    the mutex as many times as it has locked it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 递归互斥是互斥的另一种子类型。尽管它具有与常规互斥完全相同的功能，但它允许最初锁定互斥的调用线程重复锁定同一互斥。通过这样做，互斥在拥有线程解锁它的次数与锁定它的次数相同之前，不会对其他线程可用。
- en: One good reason to use a recursive mutex is for example when using recursive
    functions. With a regular mutex one would need to invent some kind of entry point
    which would lock the mutex before entering the recursive function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归互斥的一个很好的理由是，例如在使用递归函数时。使用常规互斥时，需要发明某种进入点，在进入递归函数之前锁定互斥。
- en: With a recursive mutex, each iteration of the recursive function would lock
    the recursive mutex again, and upon finishing one iteration, it would unlock the
    mutex. As a result the mutex would be unlocked and unlocked the same number of
    times.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归互斥时，递归函数的每次迭代都会再次锁定递归互斥，并在完成一次迭代后解锁互斥。结果是互斥锁定和解锁的次数相同。
- en: A potential complication hereby is that the maximum number of times that a recursive
    mutex can be locked is not defined in the standard. When the implementation's
    limit has been reached, a `std::system_error` will be thrown if one tries to lock
    it, or false is returned when using the non-blocking `try_lock` function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里可能存在的一个复杂情况是，递归互斥可以被锁定的最大次数在标准中没有定义。当达到实现的限制时，如果尝试锁定它，将抛出`std::system_error`，或者在使用非阻塞的`try_lock`函数时返回false。
- en: Recursive timed mutex
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归定时互斥
- en: The recursive timed mutex is, as the name suggests, an amalgamation of the functionality
    of the timed mutex and recursive mutex. As a result, it allows one to recursively
    lock the mutex using a timed conditional function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 递归定时互斥是，正如其名称所示，定时互斥和递归互斥功能的融合。因此，它允许使用定时条件函数递归锁定互斥。
- en: Although this adds challenges to ensuring that the mutex is unlocked as many
    times as the thread locks it, it nevertheless offers possibilities for more complex
    algorithms such as the aforementioned task-handlers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这增加了确保互斥锁定的次数与线程锁定次数相同的挑战，但它仍然为更复杂的算法提供了可能性，比如前面提到的任务处理程序。
- en: Shared mutex
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享互斥
- en: The `<shared_mutex>` header was first added with the 2014 standard, by adding
    the `shared_timed_mutex` class. With the 2017 standard, the `shared_mutex` class
    was also added.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`<shared_mutex>`头文件是在2014年标准中首次添加的，通过添加`shared_timed_mutex`类。在2017年标准中，还添加了`shared_mutex`类。'
- en: The shared mutex header has been present since C++17\. In addition to the usual
    mutual exclusive access, this `mutex` class adds the ability to provide shared
    access to the mutex. This allows one to, for example, provide read access to a
    resource by multiple threads, while a writing thread would still be able to gain
    exclusive access. This is similar to the read-write locks of Pthreads.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++17以来，共享互斥头文件一直存在。除了通常的互斥访问之外，这个`mutex`类还增加了提供互斥访问的能力。这允许多个线程对资源进行读访问，而写线程仍然可以获得独占访问。这类似于Pthreads的读写锁。
- en: 'The functions added to this mutex type are the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到这种互斥类型的函数如下：
- en: '`lock_shared()`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock_shared()`'
- en: '`try_lock_shared()`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try_lock_shared()`'
- en: '`unlock_shared()`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlock_shared()`'
- en: The use of this mutex's share functionality should be fairly self-explanatory.
    A theoretically infinite number of readers can gain read access to the mutex,
    while ensuring that only a single thread can write to the resource at any time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种互斥的共享功能的使用应该是相当不言自明的。理论上，无限数量的读者可以获得对互斥的读访问，同时确保只有一个线程可以随时写入资源。
- en: Shared timed mutex
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享定时互斥
- en: 'This header has been present since C++14\. It adds shared locking functionality
    to the timed mutex with these functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件自C++14以来一直存在。它通过这些函数向定时互斥添加了共享锁定功能：
- en: '`lock_shared()`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock_shared()`'
- en: '`try_lock_shared()`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try_lock_shared()`'
- en: '`try_lock_shared_for()`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try_lock_shared_for()`'
- en: '`try_lock_shared_until()`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try_lock_shared_until()`'
- en: '`unlock_shared()`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlock_shared()`'
- en: This class is essentially an amalgamation of the shared mutex and timed mutex,
    as the name suggests. The interesting thing here is that it was added to the standard
    before the more basic shared mutex.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类本质上是共享互斥和定时互斥的融合，正如其名称所示。这里有趣的是，它在更基本的共享互斥之前被添加到了标准中。
- en: Condition variable
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: In essence, a condition variable provides a mechanism through which a thread's
    execution can be controlled by another thread. This is done by having a shared
    variable which a thread will wait for until signaled by another thread. It is
    an essential part of the scheduler implementation we looked at in [Chapter 11](3569125d-7316-4147-ba03-9c65cfd755d7.xhtml),
    *Thread Synchronization and Communication*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，条件变量提供了一种机制，通过这种机制，一个线程的执行可以被另一个线程控制。这是通过一个共享变量来实现的，一个线程会等待这个变量，直到被另一个线程发出信号。这是我们在[第11章](3569125d-7316-4147-ba03-9c65cfd755d7.xhtml)中看到的调度器实现的一个基本部分，*线程同步和通信*。
- en: For the C++11 API, condition variables and their associated functionality are
    defined in the `<condition_variable>` header.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++11 API，条件变量及其相关功能在`<condition_variable>`头文件中定义。
- en: The basic usage of a condition variable can be summarized from that scheduler's
    code in [Chapter 11](3569125d-7316-4147-ba03-9c65cfd755d7.xhtml), *Thread Synchronization
    and Communication*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量的基本用法可以从[第11章](3569125d-7316-4147-ba03-9c65cfd755d7.xhtml)的调度器代码中总结出来，*线程同步和通信*。
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the constructor, as defined in the preceding `Worker` class declaration,
    we see the way a condition variable in the C++11 API is initialized. The steps
    are listed as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Worker`类声明中定义的构造函数中，我们看到了C++11 API中条件变量的初始化方式。步骤如下：
- en: Create a `condition_variable` and `mutex` instance.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`condition_variable`和`mutex`实例。
- en: Assign the mutex to a new `unique_lock` instance. With the constructor we use
    here for the lock, the assigned mutex is also locked upon assignment.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将互斥锁分配给一个新的`unique_lock`实例。使用我们在这里用于锁的构造函数，分配的互斥锁也在分配时被锁定。
- en: 'The condition variable is now ready for use:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件变量现在可以使用了：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we use the `wait_for()` function of the condition variable, and pass both
    the unique lock instance we created earlier and the amount of time which we want
    to wait for. Here we wait for 1 second. If we time out on this wait, we are free
    to re-enter the wait (as is done here) in a continuous loop, or continue execution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用条件变量的`wait_for()`函数，并传递我们之前创建的唯一锁实例和我们想要等待的时间。这里我们等待1秒。如果我们在这个等待中超时，我们可以自由地重新进入等待（就像这里做的那样）在一个连续的循环中，或者继续执行。
- en: It's also possible to perform a blocking wait using the simple `wait()` function,
    or wait until a certain point in time with `wait_for()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用简单的`wait()`函数执行阻塞等待，或者使用`wait_for()`等待到某个特定的时间点。
- en: As noted, when we first looked at this code, the reason why this worker's code
    uses the `ready` Boolean variable is to check that it was really another thread
    which signaled the condition variable, and not just a spurious wake-up. It's an
    unfortunate complication of most condition variable implementations--including
    the C++11 one--that they are susceptible to this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，这个工作线程的代码使用`ready`布尔变量的原因是为了检查是否真的是另一个线程发出了条件变量的信号，而不仅仅是一个虚假的唤醒。这是大多数条件变量实现（包括C++11）都容易受到的不幸的复杂性。
- en: As a result of these random wake-up events, it is necessary to have some way
    to ensure that we really did wake up intentionally. In the scheduler code, this
    is done by having the thread which wakes up the worker thread also set a `Boolean`
    value which the worker thread can wake up.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些随机唤醒事件，有必要确保我们确实是有意醒来的。在调度器代码中，这是通过唤醒工作线程的线程也设置一个`Boolean`值来完成的，工作线程可以唤醒。
- en: 'Whether we timed out, or were notified, or suffered a spurious wake-up can
    be checked with the `cv_status` enumeration. This enumeration knows these two
    possible conditions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否超时，或者被通知，或者遭受虚假唤醒，都可以通过`cv_status`枚举来检查。这个枚举知道这两种可能的情况：
- en: '`timeout`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`'
- en: '`no_timeout`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_timeout`'
- en: 'The signaling, or notifying, itself is quite straightforward:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 信号或通知本身非常简单：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this preceding function from the `Dispatcher` class, we attempt to obtain
    an available worker thread instance. If found, we obtain a reference to the worker
    thread''s condition variable as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dispatcher`类的前面的函数中，我们尝试获取一个可用的工作线程实例。如果找到，我们按如下方式获取对工作线程条件变量的引用：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Setting the new request on the worker thread also changes the value of the `ready`
    variable to true, allowing the worker to check that it is indeed allowed to continue.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设置工作线程上的新请求也会将`ready`变量的值更改为true，从而允许工作线程检查它确实被允许继续。
- en: Finally, the condition variable is notified that any threads which are waiting
    on it can now continue using `notify_one()`. This particular function will signal
    the first thread in the FIFO queue for this condition variable to continue. Here,
    only one thread will ever be notified, but if there are multiple threads waiting
    for the same condition variable, the calling of `notify_all()` will allow all
    threads in the FIFO queue to continue.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，条件变量被通知，任何等待它的线程现在可以继续使用`notify_one()`。这个特定的函数将信号传递给条件变量中FIFO队列中的第一个线程。在这里，只有一个线程会被通知，但如果有多个线程在等待相同的条件变量，调用`notify_all()`将允许FIFO队列中的所有线程继续。
- en: Condition_variable_any
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Condition_variable_any
- en: The `condition_variable_any` class is a generalization of the `condition_variable`
    class. It differs from the latter in that it allows for other mutual exclusion
    mechanisms to be used beyond `unique_lock<mutex>`. The only requirement is that
    the lock used meets the `BasicLockable` requirements, meaning that it provides
    a `lock()` and `unlock()` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition_variable_any`类是`condition_variable`类的泛化。它与后者的不同之处在于它允许使用除`unique_lock<mutex>`之外的其他互斥机制。唯一的要求是所使用的锁符合`BasicLockable`的要求，这意味着它提供了`lock()`和`unlock()`函数。'
- en: Notify all at thread exit
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程退出时通知所有
- en: The `std::notify_all_at_thread_exit()` function allows a (detached) thread to
    notify other threads that it has completely finished, and is in the process of
    having all objects within its scope (thread-local) destroyed. It functions by
    moving the provided lock to internal storage before signaling the provided condition
    variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::notify_all_at_thread_exit()`函数允许（分离的）线程通知其他线程它已经完全完成，并且正在销毁其范围内的所有对象（线程本地）。它的功能是在发出提供的条件变量信号之前将提供的锁移动到内部存储中。'
- en: The result is exactly as if the lock was unlocked and `notify_all()` was called
    on the condition variable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果就像锁被解锁并且在条件变量上调用了`notify_all()`一样。
- en: 'A basic (non-functional) example can be given as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以给出一个基本（非功能性）示例如下：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the worker thread executes a method which creates thread-local objects.
    It's therefore essential that the main thread waits for the detached worker thread
    to finish first. If the latter isn't done yet when the main thread finishes its
    tasks, it will enter a wait using the global condition variable. In the worker
    thread, `std::notify_all_at_thread_exit()` is called after setting the `ready`
    Boolean.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，工作线程执行一个创建线程本地对象的方法。因此，主线程必须首先等待分离的工作线程完成。如果主线程完成任务时后者尚未完成，它将使用全局条件变量进入等待。在工作线程中，设置`ready`布尔值后，调用`std::notify_all_at_thread_exit()`。
- en: What this accomplishes is twofold. After calling the function, no more threads
    are allowed to wait on the condition variable. It also allows the main thread
    to wait for the result of the detached worker thread to become available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有两个目的。在调用函数后，不允许更多的线程等待条件变量。它还允许主线程等待分离的工作线程的结果变得可用。
- en: Future
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Future
- en: The last part of the C++11 thread support API is defined in `<future>`. It offers
    a range of classes, which implement more high-level multithreading concepts aimed
    more at easy asynchronous processing rather than the implementation of a multithreaded
    architecture.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: C++11线程支持API的最后一部分在`<future>`中定义。它提供了一系列类，实现了更高级的多线程概念，旨在更容易地进行异步处理，而不是实现多线程架构。
- en: 'Here we have to distinguish two concepts: that of a future and that of a promise.
    The former is the end result (the future product) that''ll be used by a reader/consumer.
    The latter is what the writer/producer uses.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须区分两个概念：`future`和`promise`。前者是最终结果（未来的产品），将被读取者/消费者使用。后者是写入者/生产者使用的。
- en: 'A basic example of a future would be:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`future`的一个基本示例是：'
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code asynchronously calls a function, passing it a parameter (potential
    prime number). It then enters an active loop while it waits for the future it
    received from the asynchronous function call to finish. It sets a 100 ms timeout
    on its wait function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码异步调用一个函数，传递一个参数（可能是质数）。然后它进入一个活动循环，同时等待异步函数调用返回的`future`完成。它在等待函数上设置了100毫秒的超时。
- en: Once the future finishes (not returning a timeout on the wait function), we
    obtain the resulting value, in this case telling us that the value we provided
    the function with is in fact a prime number.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`future`完成（在等待函数上没有超时），我们就可以获得结果值，本例中告诉我们提供给函数的值实际上是一个质数。
- en: In the *async* section of this chapter, we will look a bit more at asynchronous
    function calls.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*async*部分，我们将更详细地看一下异步函数调用。
- en: Promise
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise
- en: 'A `promise` allows one to transfer states between threads. For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise`允许在线程之间传输状态。例如：'
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This preceding code uses a `promise` instance passed to a worker thread to transfer
    a value to the other thread, in this case an integer. The new thread waits for
    the future we created from the promise, and which it received from the main thread
    to complete.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用了传递给工作线程的`promise`实例，以将一个值传输到另一个线程，本例中是一个整数。新线程等待我们从`promise`创建的`future`完成，这个`future`是从主线程接收到的。
- en: The promise is completed when we set the value on the promise. This completes
    the future and finishes the worker thread.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`promise`上设置值时，`promise`就完成了。这完成了`future`并结束了工作线程。
- en: In this particular example, we use a blocking wait on the `future` object, but
    one can also use `wait_for()` and `wait_until()`, to wait for a time period or
    a point in time respectively, as we saw in the previous example for a future.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们对`future`对象进行了阻塞等待，但也可以使用`wait_for()`和`wait_until()`，分别等待一段时间或一个时间点，就像我们在上一个例子中对`future`进行的操作一样。
- en: Shared future
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享future
- en: A `shared_future` is just like a regular `future` object, but can be copied,
    which allows multiple threads to read its results.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_future`就像一个普通的`future`对象一样，但可以被复制，这允许多个线程读取其结果。'
- en: Creating a `shared_future` is similar to a regular `future.`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`shared_future`与创建一个普通的`future`类似。
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The biggest difference is that the regular `future` is passed to its constructor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别是普通的`future`被传递给它的构造函数。
- en: After this, all threads which have access to the `future` object can wait for
    it, and obtain its value. This can also be used to signal threads in a way similar
    to condition variables.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，所有可以访问`future`对象的线程都可以等待它，并获取其值。这也可以用于类似条件变量的方式来通知线程。
- en: Packaged_task
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装任务
- en: A `packaged_task` is a wrapper for any callable target (function, bind, lambda,
    or other function object). It allows for asynchronous execution with the result
    available in a `future` object. It is similar to `std::function`, but automatically
    transfers its results to a `future` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`packaged_task`是任何可调用目标（函数、绑定、lambda或其他函数对象）的包装器。它允许异步执行，并将结果可用于`future`对象。它类似于`std::function`，但自动将其结果传输到`future`对象。'
- en: 'For example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This preceding code implements a simple countdown feature, counting down from
    10 to 0\. After creating the task and obtaining a reference to its `future` object,
    we push it onto a thread along with the parameters of the `worker` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码实现了一个简单的倒计时功能，从10倒数到0。创建任务并获取其`future`对象的引用后，我们将其推送到一个线程，同时传递`worker`函数的参数。
- en: The result from the countdown worker thread becomes available as soon as it
    finishes. We can use the `future` object's waiting functions here the same way
    as for a `promise`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '倒计时工作线程的结果在完成后立即可用。我们可以使用`future`对象的等待函数，方式与`promise`一样。 '
- en: Async
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async
- en: A more straightforward version of `promise` and `packaged_task` can be found
    in `std::async()`. This is a simple function, which takes a callable object (function,
    bind, lambda, and similar) along with any parameters for it, and returns a `future`
    object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise`和`packaged_task`的更简单的版本可以在`std::async()`中找到。这是一个简单的函数，它接受一个可调用对象（函数、绑定、lambda等）以及它的任何参数，并返回一个`future`对象。'
- en: 'The following is a basic example of the `async()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`async()`函数的一个基本示例：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `worker` function in the preceding code determines whether a provided integer
    is a prime number or not. As we can see, the resulting code is a lot more simple
    than with a `packaged_task` or `promise`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`worker`函数确定提供的整数是否为质数。正如我们所看到的，结果代码比使用`packaged_task`或`promise`要简单得多。
- en: Launch policy
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动策略
- en: 'In addition to the basic version of `std::async(),` there is a second version
    which allows one to specify the launch policy as its first argument. This is a
    bitmask value of type `std::launch` with the following possible values:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::async()`的基本版本之外，还有第二个版本，允许将启动策略作为其第一个参数进行指定。这是一个`std::launch`类型的位掩码值，可能的取值如下：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `async` flag means that a new thread and execution context for the `worker`
    function is created immediately. The `deferred` flag means that this is postponed
    until `wait()` or `get()` is called on the `future` object. Specifying both flags
    causes the function to choose the method automatically depending on the current
    system situation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`标志意味着立即为`worker`函数创建一个新线程和执行上下文。`deferred`标志意味着这将被推迟，直到在`future`对象上调用`wait()`或`get()`。指定两个标志会导致函数根据当前系统情况自动选择方法。'
- en: The `std::async()` version, without explicitly specified bitmask values, defaults
    to the latter, automatic method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 未明确指定位掩码值的`std::async()`版本默认为后者，即自动方法。
- en: Atomics
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作
- en: With multithreading, the use of atomics is also very important. The C++11 STL
    offers an `<atomic>` header for this reason. This topic is covered extensively
    in [Chapter 15](fa81398a-9b4d-43c6-8ee5-cec7d6a6b6c1.xhtml), *Atomic Operations
    - Working with the Hardware*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程中，原子操作的使用也非常重要。C++11 STL出于这个原因提供了一个`<atomic>`头文件。这个主题在[第15章](fa81398a-9b4d-43c6-8ee5-cec7d6a6b6c1.xhtml)中得到了广泛覆盖，即*原子操作-与硬件交互*。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the entirety of the multithreading support in the
    C++11 API, along with the features added in C++14 and C++17.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C++11 API中的整个多线程支持，以及C++14和C++17中添加的特性。
- en: We saw how to use each feature using descriptions and example code. We can now
    use the native C++ multithreading API to implement multithreaded, thread-safe
    code as well as use the asynchronous execution features in order to speed up and
    execute functions in parallel.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用描述和示例代码来使用每个特性。现在我们可以使用本机C++多线程API来实现多线程、线程安全的代码，以及使用异步执行特性来加速并并行执行函数。
- en: 'In the next chapter, we will take a look at the inevitable next step in the
    implementation of multithreaded code: debugging and validating of the resulting
    application.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下多线程代码实现中不可避免的下一步：调试和验证所得应用程序。
