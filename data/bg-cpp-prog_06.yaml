- en: Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: C++ allows you to create your own types. These custom types can have operators
    and can be converted to other types; indeed, they can be used like built-in types
    with the behavior that you define. This facility uses a language feature called
    classes. The advantage of being able to define your own types is that you can
    encapsulate data in objects of your chosen type, and use the type to manage the
    lifetime of that data. You can also define the actions that can be performed on
    that data. In other words, you are able to define custom types that have state
    and behavior, which is the basis of object-orientated programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许您创建自己的类型。这些自定义类型可以有运算符，并且可以转换为其他类型；实际上，它们可以像内置类型一样使用，具有您定义的行为。这种功能使用一种称为类的语言特性。能够定义自己的类型的优势在于，您可以将数据封装在您选择的类型的对象中，并使用该类型来管理该数据的生命周期。您还可以定义可以对该数据执行的操作。换句话说，您可以定义具有状态和行为的自定义类型，这是面向对象编程的基础。
- en: Writing classes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写类
- en: When you use built-in types, the data is directly available to whatever code
    has access to that data. C++ provides a mechanism (`const`) to prevent write access,
    but any code can use `const_cast` to cast away `const`-ness. Your data could be
    complex, such as a pointer to a file mapped into memory with the intention that
    your code will change a few bytes and then write the file back to disk. Such raw
    pointers are dangerous because other code with access to the pointer could change
    part of the buffer that should not be changed. What is needed is a mechanism to
    encapsulate the data into a type that knows what bytes to change, and only allow
    that type to access the data. This is the basic idea behind classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用内置类型时，数据直接可供访问该数据的任何代码。C++提供了一种机制（`const`）来防止写访问，但任何代码都可以使用`const_cast`来取消`const`。您的数据可能很复杂，例如指向映射到内存中的文件的指针，意图是您的代码将更改一些字节，然后将文件写回磁盘。这样的原始指针是危险的，因为具有访问指针的其他代码可能更改不应更改的缓冲区的一部分。所需的是一种将数据封装到了解要更改哪些字节的类型中，并且只允许该类型访问数据的机制。这是类的基本思想。
- en: Reviewing structures
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查结构
- en: 'We have already seen one mechanism in C++ to encapsulate data: `struct`. A
    structure allows you to declare data members that are built-in types, pointers,
    or references. When you create a variable from that `struct`, you are creating
    an **instance** of the structure, also known as an **object**. You can create
    variables that are references to this object or pointers that point to the object.
    You can even pass the object by value to a function where the compiler will make
    a copy of the object (it will call the *copy constructor* for the `struct`). We
    have seen that with a `struct` any code that has access to an instance (even through
    a pointer or reference) can access the members of the object (although this can
    be changed). Used like this, a `struct` can be thought of as **aggregate** types
    containing the state.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在C++中看到了一种封装数据的机制：`struct`。结构允许您声明内置类型、指针或引用的数据成员。当您从该`struct`创建变量时，您正在创建该结构的**实例**，也称为**对象**。您可以创建引用此对象的变量或指向该对象的指针。甚至可以将对象按值传递给函数，编译器将对对象进行复制（它将调用`struct`的*复制构造函数*）。我们已经看到，对于`struct`，任何可以访问实例的代码（甚至通过指针或引用）都可以访问对象的成员（尽管这可能会更改）。在这种情况下，`struct`可以被视为包含状态的**聚合**类型。
- en: The members of an instance of a `struct` can be initialized by accessing them
    directly with the dot operator or using the `->` operator through a pointer to
    the object. We have also seen that you can initialize an instance of a `struct`
    with an initializer list (in braces). This is quite restrictive because the initializer
    list has to match the data members in the `struct`. In [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working with Memory, Arrays, and Pointers*, you saw that you can have a pointer
    as a member of a `struct`, but you have to explicitly take appropriate action
    to release the memory pointed to by the pointer; if you don't, then this could
    result in a memory leak.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`的实例的成员可以通过直接使用点运算符或通过指向对象的指针使用`->`运算符进行初始化。我们还看到您可以使用初始化器列表（用大括号括起来）初始化`struct`的实例。这是相当受限制的，因为初始化器列表必须与`struct`中的数据成员匹配。在[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)中，*使用内存、数组和指针*，您看到可以将指针作为`struct`的成员，但必须明确采取适当的操作来释放指针指向的内存；如果不这样做，可能会导致内存泄漏。'
- en: A `struct` is one of the class types that you can use in C++; the other two
    are `union` and `class`. Custom types defined as `struct` or `class` can have
    behaviors as well as state, and C++ allows you to define some special functions
    to control how instances are created and destroyed, copied, and converted. Furthermore,
    you can define operators on a `struct` or `class` type so that you can use the
    operators on instances in a similar way to using the operators on built-in types.
    There is a difference between `struct` and `class` which we will address later,
    but in general the rest of the chapter will be about classes and when a `class`
    is mentioned you can usually assume the same applies to a `struct` as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`是您可以在C++中使用的类类型之一；另外两个是`union`和`class`。定义为`struct`或`class`的自定义类型可以具有行为和状态，C++允许您定义一些特殊函数来控制如何创建和销毁实例，复制和转换。此外，您可以在`struct`或`class`类型上定义运算符，以便您可以类似于在内置类型上使用运算符一样在实例上使用运算符。`struct`和`class`之间存在差异，我们将在后面讨论，但一般来说，本章的其余部分将涉及类，当提到`class`时，通常可以假定相同的内容也适用于`struct`。'
- en: Defining classes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: A class is defined in a statement, and it will define its members in a block
    with multiple statements enclosed by braces `{}`. As it's a statement, you have
    to place a semicolon after the last brace. A class can be defined in a header
    file (as are many of the **C++ Standard Library** classes), but you have to take
    steps to ensure that such files are included only once in a source file. [Chapter
    1](318b7b93-7e5a-437b-95b3-9b6178ece82c.xhtml), *Starting with C++*, describes
    how to do this with `#pragma once`, conditional compilation, and precompiled header
    files. There are, however, some rules about specific items in a class that must
    be defined in a source file, which will be covered later.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类在一个语句中定义，并且它将在由大括号`{}`括起来的多个语句的块中定义其成员。因为它是一个语句，所以你必须在最后的大括号后面放一个分号。一个类可以在头文件中定义（就像许多**C++标准库**类一样），但你必须采取措施确保这样的文件只在源文件中包含一次。[第1章](318b7b93-7e5a-437b-95b3-9b6178ece82c.xhtml)，*从C++开始*，描述了如何使用`#pragma
    once`、条件编译和预编译头文件来实现这一点。然而，关于类中特定项目的一些规则必须在源文件中定义，这将在后面介绍。
- en: If you peruse the C++ Standard Library, you will see that classes contain member
    functions and, in an attempt to put all the code for a class into a single header
    file, this makes the code difficult to read and difficult to understand. This
    may be justifiable for a library file maintained by a legion of expert C++ programmers,
    but for your own projects readability should be a key design goal. For this reason,
    a C++ class can be declared in a C++ header file, including its member functions,
    and the actual implementation of the functions can be placed in a source file.
    This makes the header files easier to maintain and more reusable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览C++标准库，你会发现类包含成员函数，并且为了将类的所有代码放入单个头文件中，这使得代码难以阅读和理解。这可能是有道理的，对于一个由专家C++程序员组成的军团维护的库文件，但对于你自己的项目来说，可读性应该是一个关键的设计目标。因此，C++类可以在C++头文件中声明，包括其成员函数，并且函数的实际实现可以放在源文件中。这使得头文件更容易维护和更可重用。
- en: Defining class behavior
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类行为
- en: 'A class can define functions that can only be called through an instance of
    the class; such a function is often called a **method**. An object will have state;
    this is provided by the data members defined by the class and initialized when
    the object is created. The methods on an object define the behavior of the object,
    usually acting upon the state of the object. When you design a class, you should
    think of the methods in this way: they describe the object doing something.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以定义只能通过类的实例调用的函数；这样的函数通常被称为**方法**。对象将具有状态；这是由类定义的数据成员提供的，并在创建对象时初始化。对象上的方法定义了对象的行为，通常作用于对象的状态。当你设计一个类时，你应该这样考虑方法：它们描述了对象正在做某事。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class has two data members, `x` and `y`, which represent the direction
    of a two-dimensional vector resolved in the Cartesian x and y directions. The
    `public` keyword means that any members defined after this specifier are accessible
    by code defined outside of the class. By default, all the members of a class are
    `private` unless you indicate otherwise. Such access specifiers will be covered
    in more depth in the next chapter, but `private` means that the member can only
    be accessed by other members of the class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个数据成员，`x`和`y`，它们表示笛卡尔x和y方向上的二维向量的方向。`public`关键字意味着在此指定符号之后定义的任何成员都可以被类外定义的代码访问。默认情况下，类的所有成员都是`private`，除非你另有说明。这样的访问说明符将在下一章中更深入地介绍，但`private`意味着该成员只能被类的其他成员访问。
- en: 'This is the difference between a `struct` and a `class`: by default, members
    of a `struct` are `public` and by default, members of a `class` are `private`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`struct`和`class`之间的区别：默认情况下，`struct`的成员是`public`，默认情况下，`class`的成员是`private`。
- en: 'This class has a method called `get_magnituide` that will return the length
    of the Cartesian vector. This function acts upon the two data members of the class
    and returns a value. This is a type of **accessor** method; it gives access to
    the state of the object. Such a method is typical on a `class`, but there is no
    requirement that methods return values. Like functions, a method can also take
    parameters. The `get_magnituide` method can be called like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个名为`get_magnituide`的方法，它将返回笛卡尔向量的长度。这个函数作用于类的两个数据成员并返回一个值。这是一种**访问器**方法；它允许访问对象的状态。这样的方法在`class`上很典型，但并不要求方法返回值。像函数一样，方法也可以接受参数。`get_magnituide`方法可以这样调用：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here a `cartesian_vector` object is created on the stack and list initializer
    syntax is used to initialize it to a value representing a vector of `(3,4)`. The
    length of this vector is 5, which is the value returned by calling `get_magnitude`
    on the object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里创建了一个`cartesian_vector`对象，并使用列表初始化语法将其初始化为表示向量`(3,4)`的值。这个向量的长度是5，这是通过在对象上调用`get_magnitude`返回的值。
- en: Using the this pointer
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用this指针
- en: 'The methods in a class have a special calling convention, which in Visual C++
    is called `__thiscall`. The reason is that every method in a class has a hidden
    parameter called `this`, which is a pointer of the class type to the current instance:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法有一个特殊的调用约定，在Visual C++中称为`__thiscall`。原因是类中的每个方法都有一个名为`this`的隐藏参数，它是指向当前实例的类类型的指针：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `get_magnitude` method returns the length of the `cartesian_vector`
    object. The members of the object are accessed through the `->` operator. As shown
    previously, the members of the class can be accessed without the `this` pointer,
    but it does make it explicit that the items are members of the `class`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`get_magnitude`方法返回`cartesian_vector`对象的长度。对象的成员通过`->`运算符访问。如前所示，可以在没有`this`指针的情况下访问类的成员，但这确实明确了这些项目是`class`的成员。
- en: 'You could define a method on the `cartesian_vector` type that allows you to
    change its state:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cartesian_vector`类型上定义一个方法，允许你改变它的状态：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The parameters of the `reset` method have the same names as the data members
    of the class; however, since we use the `this` pointer the compiler knows that
    this is not ambiguous.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset`方法的参数与类的数据成员具有相同的名称；然而，由于我们使用了`this`指针，编译器知道这不会产生歧义。'
- en: You can dereference the `this` pointer with the `*` operator to get access to
    the object. This is useful when a member function must return a reference to the
    current object (as some operators will, as we will see later) and you can do this
    by returning `*this`. A method in a class can also pass the `this` pointer to
    an external function, which means that it is passing the current object by reference
    through a typed pointer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`*`运算符对`this`指针进行解引用，以访问对象。当一个成员函数必须返回对当前对象的引用时（正如我们将在后面看到的一些操作符），你可以通过返回`*this`来实现。类中的一个方法也可以将`this`指针传递给外部函数，这意味着它通过一个类型化的指针以引用的方式传递当前对象。
- en: Using the scope resolution operator
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用作用域解析运算符
- en: 'You can define a method inline in the `class` statement, but you can also separate
    the declaration and implementation, so the method is declared in the `class` statement
    but it is defined elsewhere. When defining a method out of the `class` statement,
    you need to provide the method with the name of the type using the scope resolution
    operator. For example, using the previous `cartesian_vector` example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`class`语句中内联定义一个方法，但你也可以分开声明和实现，所以方法在`class`语句中声明，但在其他地方定义。当在`class`语句之外定义一个方法时，你需要使用作用域解析运算符为方法提供类型的名称。例如，使用之前的`cartesian_vector`示例：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method is defined outside the class definition; it is, however, still the
    class method, so it has a `this` pointer that can be used to access the object's
    members. Typically, the class will be declared in a header file with prototypes
    for the methods and the actual methods will be implemented in a separate source
    file. In this case, using the `this` pointer to access the class members (methods
    and data members) make it obvious, when you take a cursory look at a source file,
    that the functions are methods of a class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在类定义之外定义；然而，它仍然是类方法，因此它有一个`this`指针，可以用来访问对象的成员。通常，类将在头文件中声明方法的原型，并且实际方法将在单独的源文件中实现。在这种情况下，使用`this`指针来访问类成员（方法和数据成员）在浏览源文件时是显而易见的，这些函数是类的方法。
- en: Defining class state
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类的状态
- en: Your class can have built-in types as data members, or custom types. These data
    members can be declared in the class (and created when an instance of the class
    is constructed), or they can be pointers to objects created in the free store
    or references to objects created elsewhere. Bear in mind that if you have a pointer
    to an item created in the free store, you need to know whose responsibility it
    is to deallocate the memory that the pointer points to. If you have a reference
    (or pointer) to an object created on a stack frame somewhere, you need to make
    sure that the objects of your class do not live longer than that stack frame.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你的类可以有内置类型作为数据成员，也可以有自定义类型。这些数据成员可以在类中声明（并在类的实例构造时创建），也可以是指向在自由存储中创建的对象的指针，或者是引用在其他地方创建的对象。请记住，如果你有一个指向在自由存储中创建的项目的指针，你需要知道谁负责释放指针指向的内存。如果你有一个引用（或指针）指向在某个栈帧上创建的对象，你需要确保你的类的对象不会比该栈帧存在的时间更长。
- en: 'When you declare data members as `public` it means that external code can read
    and write to the data members. You can decide that you would prefer to only give
    read-only access, in which case you can make the members `private` and provide
    read access through accessors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将数据成员声明为`public`时，这意味着外部代码可以读取和写入数据成员。你可以决定只提供只读访问，这种情况下你可以将成员设为`private`，并通过访问器提供读取访问：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you make the data members `private` it means that you cannot use the initializer
    list syntax to initialize an object, but we will address this later. You may decide
    to use an accessor to give write access to a data member and use this to check
    the value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将数据成员设为`private`时，意味着你不能使用初始化列表语法来初始化对象，但我们稍后会解决这个问题。你可以决定使用访问器来给数据成员提供写入访问，并使用这个来检查值。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is for a type where the range of values must be between (but not including)
    -`100` and `100`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个范围值必须在（但不包括）-100和100之间的类型。
- en: Creating objects
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'You can create objects on the stack or in the free store. Using the previous
    example, this is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在堆栈上或自由存储中创建对象。使用前面的示例，这是如下所示的：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is **direct initialization** of the object and assumes that the data members
    of `cartesian_vector` are `public`. The `vec` object is created on the stack and
    initialized with an initializer list. In the second line, an object is created
    in the free store and initialized with an initializer list. The object on the
    free store must be freed at some point and this is carried out by deleting the
    pointer. The `new` operator will allocate enough memory in the free store for
    the data members of the class and for any of the infrastructure the class needs
    (as described in the next chapter).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对象的**直接初始化**，假设`cartesian_vector`的数据成员是`public`。`vec`对象在堆栈上创建，并用初始化列表初始化。在第二行，一个对象在自由存储中创建，并用初始化列表初始化。自由存储中的对象必须在某个时刻被释放，这是通过删除指针来实现的。`new`运算符将在自由存储中为类的数据成员和类需要的任何基础设施分配足够的内存（如下一章所述）。
- en: 'A new feature of C++11 is to allow direct initialization to provide default
    values in the class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的一个新特性是允许直接初始化以在类中提供默认值：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This means that if you create an instance of `point` without any other initialization
    values, it will be initialized so that `x` and `y` are both zero. If the data
    member is a built-in array, then you can provide direct initialization with an
    initialization list in the class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你创建一个`point`的实例而没有任何其他初始化值，它将被初始化，使得`x`和`y`都为零。如果数据成员是内置数组，那么你可以在类中使用初始化列表进行直接初始化：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The C++ Standard Library containers can be initialized with an initialize list,
    so, in this class for `tire_pressures`, instead of declaring the type to be `double[4]`
    we could use `vector<double>` or `array<double,4>`, and initialize it in the same
    way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库容器可以使用初始化列表进行初始化，因此，在这个`tire_pressures`类中，我们可以使用`vector<double>`或`array<double,4>`来代替声明类型为`double[4]`，并以相同的方式进行初始化。
- en: Construction of objects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的构造
- en: 'C++ allows you to define special methods to perform the initialization of the
    object. These are called **constructors**. In C++11, you will get three such functions
    generated for you by default, but you can provide your own versions if you wish.
    These three constructors, along with three other related functions, are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许您定义特殊的方法来执行对象的初始化。这些被称为**构造函数**。在C++11中，默认情况下会为您生成三个这样的函数，但如果您愿意，也可以提供自己的版本。这三个构造函数以及另外三个相关函数如下：
- en: '**Default constructor:** This is called to create an object with the *default*
    value.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认构造函数：**用于创建具有*默认*值的对象。'
- en: '**Copy constructor:** This is used to create a new object based on the value
    of an existing object.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拷贝构造函数：**用于基于现有对象的值创建新对象。'
- en: '**Move constructor:** This is used to create a new object using the data moved
    from an existing object.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动构造函数：**用于使用从现有对象移动的数据创建新对象。'
- en: '**Destructor:** This is called to clean up the resources used by an object.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**析构函数：**用于清理对象使用的资源。'
- en: '**Copy assignment:** This copies the data from one existing object into another
    existing object.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拷贝赋值：**将数据从一个现有对象复制到另一个现有对象。'
- en: '**Move assignment:** This moves the data from one existing object into another
    existing object.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动赋值：**将数据从一个现有对象移动到另一个现有对象。'
- en: The compiler-created versions of these functions will be implicitly `public`;
    however, you may decide to prevent copying or assigning by defining your own versions,
    and making them `private`, or you can delete them using the `=delete` syntax.
    You can also provide your own constructors that will take any parameters you decide
    you need to initialize a new object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的编译器创建的版本将被隐式设为`public`；但是，您可以决定通过定义自己的版本并将它们设为`private`，或者使用`=delete`语法删除它们来阻止复制或赋值。您还可以提供自己的构造函数，以便使用您决定需要初始化新对象的任何参数。
- en: A constructor is a member function that has the same name as the type, but does
    not return a value, so you cannot return a value if the construction fails, which
    potentially means that the caller will receive a partially constructed object.
    The only way to handle this situation is to throw an exception (explained in [Chapter
    10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics and Debugging*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个与类型相同的成员函数，但不返回值，因此如果构造失败，您无法返回值，这可能意味着调用者将收到一个部分构造的对象。处理这种情况的唯一方法是抛出异常（在[第10章](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml)中有解释，*诊断和调试*）。
- en: Defining constructors
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义构造函数
- en: 'The default constructor is used when an object is created without a value and
    hence the object will have to be initialized with a default value. The `point`
    declared previously could be implemented like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个没有值的对象时，将使用默认构造函数，因此对象将必须用默认值进行初始化。之前声明的`point`可以这样实现：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This explicitly initializes the items to a value of zero. If you want to create
    an instance with the default values, you do not include parentheses.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将明确将项目初始化为零。如果要使用默认值创建实例，则不包括括号。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is important to be aware of this syntax because it is easy to write the
    following by mistake:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意这种语法，因为很容易出错写成以下形式：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will compile because the compiler will think you are providing a function
    prototype as a forward declaration. However, you''ll get an error when you attempt
    to use the symbol `p` as a variable. You can also call the default constructor
    using initialize list syntax with empty braces:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译通过，因为编译器会认为您正在提供一个函数原型作为前向声明。但是，当您尝试将符号`p`用作变量时，将会出现错误。您还可以使用空括号的初始化列表语法调用默认构造函数：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although it does not matter in this case, where the data members are built-in
    types, initializing data members in the body of the constructor like this involves
    a call to the assignment operator of the member type. A more efficient way is
    to use direct initialization with a **member list**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这种情况下并不重要，因为数据成员是内置类型，但是在构造函数的主体中像这样初始化数据成员涉及对成员类型的赋值运算符的调用。更有效的方法是使用**成员列表**进行直接初始化。
- en: 'The following is a constructor that takes two parameters, which illustrates
    a member list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个构造函数，它接受两个参数，用于说明成员列表：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The identifiers outside the parentheses are the names of class members, and
    the items inside the parentheses are expressions used to initialize that member
    (in this case, a constructor parameter). This example uses `x` and `y` for the
    parameter names. You don''t have to do this; this is only given here as an illustration
    that the compiler will distinguish between the parameters and data members. You
    can also use braced initializer syntax in the member list of a constructor:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 括号外的标识符是类成员的名称，括号内的项目是用于初始化该成员的表达式（在本例中是构造函数参数）。此示例使用`x`和`y`作为参数名称。您不必这样做；这里只是作为一个例子，说明编译器将区分参数和数据成员。您还可以在构造函数的成员列表中使用大括号初始化语法：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You call this constructor when you create an object like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象时调用此构造函数：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also create an array of objects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建对象数组：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates four `point` objects, which can be accessed by indexing the `arr`
    array. Note that when you create an array of objects the *default* constructor
    is called on the items; there is no way to call any other constructor, and so
    you have to initialize each one separately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建四个`point`对象，可以通过对`arr`数组进行索引来访问。请注意，当创建对象数组时，将调用*默认*构造函数；没有办法调用任何其他构造函数，因此必须分别初始化每个对象。
- en: 'You can also provide default values for constructor parameters. In the following
    code, the `car` class has values for the four tires (the first two are the front
    tires) and for the spare tire. There is one constructor that has mandatory values
    that will be used for the front and back tires, and an optional value for the
    spare. If a value is not provided for the spare tire pressure, then a default
    value will be used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为构造函数参数提供默认值。在下面的代码中，`car`类为四个轮胎（前两个是前轮）和备用轮胎提供了值。有一个构造函数具有用于前后轮的强制值，并为备用轮胎提供了一个可选值。如果未提供备用轮胎压力的值，则将使用默认值：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This constructor can be called with either two values or three values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数可以使用两个值或三个值调用：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Delegating constructors
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托构造函数
- en: 'A constructor may call another constructor using the same member list syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以使用相同的成员列表语法调用另一个构造函数：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the constructor that takes one value delegates to the constructor that
    takes three parameters (in this case using the default value for the spare).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，接受一个值的构造函数委托给接受三个参数的构造函数（在这种情况下使用备用值）。
- en: Copy constructor
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: 'A copy constructor is used when you pass an object by value (or return by value)
    or if you explicitly construct an object based on another object. The last two
    lines of the following both create a `point` object from another `point` object,
    and in both cases the copy constructor is called:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按值传递对象（或按值返回）或者明确基于另一个对象构造对象时，将使用复制构造函数。以下代码的最后两行都从另一个`point`对象创建一个`point`对象，并且在两种情况下都调用了复制构造函数：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last line looks like it involves the assignment operator, but it actually
    calls the copy constructor. The copy constructor could be implemented like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行看起来涉及赋值运算符，但实际上调用了复制构造函数。复制构造函数可以这样实现：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The initialization accesses the `private` data members on another object (`rhs`).
    This is acceptable because the constructor parameter is the same type as the object
    being created. The copy operation may not be as simple as this. For example, if
    the class contains a data member that is a pointer, you will most likely want
    to copy the data that the pointer points to, and this will involve creating a
    new memory buffer in the new object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化访问另一个对象（`rhs`）的`private`数据成员。这是可以接受的，因为构造函数参数与正在创建的对象的类型相同。复制操作可能不像这样简单。例如，如果类包含一个指针数据成员，您很可能希望复制指针指向的数据，并且这将涉及在新对象中创建一个新的内存缓冲区。
- en: Converting between types
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'You can also perform conversions. In math, you can define a vector that represents
    direction, so that the line drawn between two points is a vector. In our code
    we have already defined a `point` class and a `cartesian_vector` class. You could
    decide to have a constructor that creates a vector between the origin and a point,
    in which case you are converting a `point` object to a `cartesian_vector` object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以执行转换。在数学中，您可以定义表示方向的向量，以便在两点之间绘制的线是一个向量。在我们的代码中，我们已经定义了`point`类和`cartesian_vector`类。您可以决定创建一个构造函数，该构造函数创建原点和一个点之间的向量，在这种情况下，您正在将`point`对象转换为`cartesian_vector`对象：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is a problem here, which we will address in a moment. The conversions
    can be called like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题，我们稍后会解决。转换可以这样调用：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Making friends
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立友谊
- en: 'The problem with the code above is that the `cartesian_vector` class accesses
    `private` members of the `point` class. Since we have written both classes, we
    are happy to bend the rules, and so we make the `cartesian_vector` class a `friend`
    of the `point` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码问题在于`cartesian_vector`类访问`point`类的`private`成员。由于我们编写了两个类，我们很乐意打破规则，因此我们将`cartesian_vector`类设置为`point`类的`friend`：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the `cartesian_vector` class is declared after the `point` class, we have
    to provide a forward declaration that essentially tells the compiler that the
    name `cartesian_vector` is about to be used and it will be declared elsewhere.
    The important line starts with `friend`. This indicates that the code for the
    entire class, `cartesian_vector`, can have access to the private members (data
    and methods) of the `point` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cartesian_vector`类是在`point`类之后声明的，我们必须提供一个前向声明，告诉编译器名称`cartesian_vector`即将被使用，并且将在其他地方声明。重要的一行以`friend`开头。这表明整个`cartesian_vector`类的代码可以访问`point`类的私有成员（数据和方法）。
- en: 'You can also declare `friend` functions. For example, you could declare an
    operator such that a `point` object can be inserted into the `cout` object, so
    it can be printed to the console. You cannot change the `ostream` class, but you
    can define a global method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以声明`friend`函数。例如，您可以声明一个运算符，以便`point`对象可以插入`cout`对象，因此可以将其打印到控制台。您不能更改`ostream`类，但可以定义全局方法：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function accesses the `private` members of `point` so you have to make
    the function a `friend` of the `point` class with:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数访问`point`的`private`成员，因此您必须将函数设置为`point`类的`friend`：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Such `friend` declarations have to be declared in the `point` class, but it
    is irrelevant whether it is put in the `public` or `private` section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`friend`声明必须在`point`类中声明，但放在`public`或`private`部分都无关紧要。
- en: Marking constructors as explicit
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将构造函数标记为显式
- en: 'In some cases, you do not want to allow the implicit conversion between one
    type that is passed as a parameter of the constructor of another type. To do this,
    you need to mark the constructor with the `explicit` specifier. This now means
    that the only way to call the constructor is using the parentheses syntax: *explicitly*
    calling the constructor. In the following code, you cannot implicitly convert
    a `double` to an object of `mytype`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您不希望允许将一个类型隐式转换为另一个类型的构造函数的参数。为此，您需要使用`explicit`限定符标记构造函数。这现在意味着调用构造函数的唯一方法是使用括号语法：*显式*调用构造函数。在下面的代码中，您不能将`double`隐式转换为`mytype`的对象：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now you have to *explicitly* call the constructor if you want to create an
    object with a `double` parameter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果要使用`double`参数创建对象，则必须*显式*调用构造函数：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Destructing objects
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁对象
- en: When an object is destroyed, a special method called the destructor is called.
    This method has the name of the class prefixed with a `~` symbol and it does not
    return a value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被销毁时，将调用一个名为析构函数的特殊方法。该方法的名称以`~`符号为前缀，不返回值。
- en: If the object is an automatic variable, on the stack, then it will be destroyed
    when the variable goes out of scope. When an object is passed by value, a copy
    is made on the called function's stack and the object will be destroyed when the
    called function completes. Furthermore, it does not matter how the function completes,
    whether an explicit call to `return` or reaching the final brace, or if an exception
    is thrown; in all of these cases, the destructor is called. If there are multiple
    objects in a function, the destructors are called in the reverse order to the
    construction of the objects in the same scope. If you create an array of objects,
    then the default constructor is called for each object in the array on the statement
    that declares the array, and all the objects will be destroyed--and the destructor
    on each one is called, when the array goes out of scope.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是自动变量，位于堆栈上，那么当变量超出范围时，它将被销毁。当按值传递对象时，在被调用的函数堆栈上创建一个副本，并且当被调用的函数完成时，对象将被销毁。此外，函数的完成方式并不重要，无论是显式调用`return`还是达到最终的大括号，或者抛出异常；在所有这些情况下，都会调用析构函数。如果在函数中有多个对象，则在相同作用域中对象的构造顺序相反时调用析构函数。如果创建一个对象数组，则在声明数组的语句中为数组中的每个对象调用默认构造函数，并且当数组超出范围时，将销毁所有对象--并且调用每个对象的析构函数。
- en: 'Here are some examples, for a class `mytype`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，对于类`mytype`：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An interesting action occurs when you return an object. The following annotation
    is what you would expect:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您返回一个对象时，会发生有趣的操作。以下注释是您所期望的：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In fact, the process is more streamlined. In a debug build, the compiler will
    see that the temporary object created on the return of the `get_object` function
    is the object that will be used as the variable `tt`, and so there is no extra
    copy on the return value of the `get_object` function. The function actually looks
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个过程更加简洁。在调试版本中，编译器将看到在`get_object`函数返回时创建的临时对象是将用作变量`tt`的对象，因此在`get_object`函数的返回值上不会有额外的复制。函数实际上看起来是这样的：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, the compiler is able to optimize the code further. In a release build
    (with optimizations enabled), the temporary will not be created and the object
    `tt` in the calling function will be the actual object `t` created in `get_object`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器能够进一步优化代码。在发布版本中（启用了优化），临时对象将不会被创建，调用函数中的对象`tt`将是在`get_object`中创建的实际对象`t`。
- en: 'An object will be destroyed when you explicitly delete a pointer to an object
    allocated on the free store. In this case, the call to the destructor is deterministic:
    it is called when your code calls `delete`. Again, with the same class `mytype`,
    this is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当您显式删除在自由存储器上分配的对象的指针时，对象将被销毁。在这种情况下，对析构函数的调用是确定性的：当您的代码调用`delete`时，它会被调用。同样，对于相同的类`mytype`，情况如下：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There will be times when you want to use the deterministic aspect of deleting
    an object (with the possible danger of forgetting to call `delete`) and there
    will be times when you prefer to have the reassurance that an object is to be
    destroyed at an appropriate time (with the potential that it may be much later
    in time).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您希望使用删除对象的确定性方面（可能会忘记调用`delete`而存在潜在危险），有时您更希望确保对象在适当的时间被销毁（尽管可能会在以后的时间更晚）。
- en: If a data member in a class is a custom type with a destructor, then when the
    containing object is destroyed the destructors on the contained objects are called
    too. Nonetheless, note that this is only if the *object* is a class member. If
    a class member is a pointer to an object in the free store, then you have to explicitly
    delete the pointer in the containing object's destructor. However, you need to
    know where the object the pointer points to is because if it is not in the free
    store, or if the object is used by other objects, calling `delete` will cause
    problems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类中的数据成员是具有析构函数的自定义类型，那么当包含对象被销毁时，也会调用包含对象上的析构函数。尽管如此，请注意，这仅适用于*对象*是类成员的情况。如果类成员是指向自由存储器中对象的指针，则必须在包含对象的析构函数中显式删除指针。但是，您需要知道指针指向的对象在哪里，因为如果它不在自由存储器中，或者对象被其他对象使用，调用`delete`将会导致问题。
- en: Assigning objects
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配对象
- en: The assignment operator is called when an *already created* object is assigned
    to the value of another one. By default, you will get a copy assignment operator
    that will copy all the data members. This is not necessarily what you want, particularly
    if the object has a data member that is a pointer, in which case your intention
    is more likely to do a deep copy and copy the data pointed to rather than the
    value of the pointer (in the latter case, *two* objects will point to the same
    data).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当将*已创建*的对象分配给另一个对象的值时，将调用赋值运算符。默认情况下，您将获得一个复制赋值运算符，它将复制所有数据成员。这不一定是您想要的，特别是如果对象具有指针数据成员，那么您更有可能希望进行深层复制并复制指向的数据而不是指针的值（在后一种情况下，*两个*对象将指向相同的数据）。
- en: If you define a copy constructor, you will still get the default copy assignment
    operator; however, it makes sense that if you regard it important to write your
    own copy constructor, you should also provide a custom copy assignment operator.
    (Similarly, if you define a copy assignment operator, you will get the default
    copy constructor unless you define it.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了复制构造函数，您仍将获得默认的复制赋值运算符；然而，如果您认为编写自己的复制构造函数很重要，那么您应该提供自定义的复制赋值运算符。 （同样，如果定义了复制赋值运算符，除非定义它，否则将获得默认的复制构造函数。）
- en: 'The copy assignment operator is typically a `public` member of the class and
    it takes a `const` reference to the object that will be used to provide the values
    for the assignment. The semantics of the assignment operator are that you can
    chain them, so, for example, this code calls the assignment operator on two of
    the objects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值运算符通常是类的`public`成员，并且它接受一个用于提供赋值值的`const`引用对象。赋值运算符的语义是可以链接它们，因此，例如，这段代码调用了两个对象的赋值运算符：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last two lines do the same thing, but clearly the first is more readable.
    To enable these semantics, the assignment operator must return a reference to
    the object that has been assigned. So, the class `buffer` will have the following
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行做了同样的事情，但显然第一个更易读。为了启用这些语义，赋值运算符必须返回一个已经被赋值的对象的引用。因此，类`buffer`将具有以下方法：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although the copy constructor and copy assignment methods appear to do similar
    things, there is a key difference. A copy constructor creates a new object that
    did not exist before the call. The calling code is aware that if the construction
    fails, then an exception will be raised. With assignment, both objects already
    exist, so you are copying the value from one object to another. This should be
    treated as an atomic action and all the copy should be performed; it is not acceptable
    for the assignment to fail halfway through, resulting in an object that is a bit
    of both objects. Furthermore, in construction, an object only exists after the
    construction is successful, so a copy construction cannot happen on an object
    itself, but it is perfectly legal (if pointless) for code to assign an object
    to itself. The copy assignment needs to check for this situation and take appropriate
    action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管复制构造函数和复制赋值方法看起来做了类似的事情，但有一个关键的区别。复制构造函数创建了一个在调用之前不存在的新对象。调用代码知道，如果构造失败，那么将会引发异常。而赋值时，两个对象已经存在，所以你是将一个对象的值复制到另一个对象。这应该被视为一个原子操作，并且应该执行所有的复制；赋值在中途失败，导致一个对象是两个对象的一部分是不可接受的。此外，在构造中，只有在构造成功后对象才存在，因此复制构造不能在对象本身上发生，但是代码将对象分配给自身是完全合法的（尽管毫无意义）。复制赋值需要检查这种情况并采取适当的行动。
- en: There are various strategies to do this, and a common one is called the copy-and-swap
    idiom because it uses the Standard Library `swap` function that is marked as `noexcept`,
    and will not throw an exception. The idiom involves creating a temporary copy
    of the object on the right-hand side of the assignment and then swapping its data
    members with the data members of the object on the left-hand side.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种策略可以做到这一点，一个常见的策略称为复制和交换惯用法，因为它使用标记为`noexcept`的标准库`swap`函数，并且不会引发异常。这种惯用法涉及创建赋值右侧对象的临时副本，然后交换其数据成员与左侧对象的数据成员。
- en: Move semantics
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动语义
- en: C++11 provides move semantics through a move constructor and a move assignment
    operator, which are called when a temporary object is used either to create another
    object or to be assigned to an existing object. In both cases, because the temporary
    object will not live beyond the statement, the contents of the temporary can be
    moved to the other object, leaving the temporary object in an invalid state. The
    compiler will create these functions for you through the default action of moving
    the data from the temporary to the newly created (or the assigned to) object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过移动构造函数和移动赋值运算符提供了移动语义，当临时对象被用于创建另一个对象或被赋值给现有对象时，这些函数将被调用。在这两种情况下，由于临时对象不会在语句之后存在，临时对象的内容可以移动到另一个对象，使临时对象处于无效状态。编译器将通过默认操作从临时对象移动数据到新创建的（或分配给）对象来为您创建这些函数。
- en: You can write your own versions, and to indicate move semantics these have a
    parameter that is an rvalue reference (`&&`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写自己的版本，并且为了指示移动语义，这些版本有一个右值引用的参数（`&&`）。
- en: If you want the compiler to provide you with a default version of any of these
    methods, you can provide the prototype in the class declaration suffixed with
    `=default`. In most cases, this is self-documenting rather than being a requirement,
    but if you are writing a POD class you must use the default versions of these
    functions, otherwise `is_pod` will not return `true`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望编译器为您提供这些方法的默认版本，可以在类声明中提供带有`=default`后缀的原型。在大多数情况下，这是自说明的，而不是一个要求，但如果您正在编写POD类，您必须使用这些函数的默认版本，否则`is_pod`将不返回`true`。
- en: 'If you want to use only move and never to use copy (for example, a file handle
    class), then you can *delete* the copy functions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想使用移动而不使用复制（例如文件句柄类），那么可以*删除*复制函数：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This class has a pointer data member and allows move semantics, in which case
    the move constructor will be called with a reference to a temporary object. Since
    the object is temporary, it will not survive after the move constructor call.
    This means that the new object can *move* the state of the temporary object into
    itself:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个指针数据成员，并允许移动语义，在这种情况下，将调用移动构造函数并传递一个临时对象的引用。由于对象是临时的，它在移动构造函数调用后将不会存在。这意味着新对象可以*移动*临时对象的状态到自身：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The move constructor assigns the temporary object's pointer to `nullptr`, so
    that any destructor defined for the class does not attempt to delete the pointer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数将临时对象的指针赋值为`nullptr`，以便任何为类定义的析构函数不会尝试删除指针。
- en: Declaring static members
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明静态成员
- en: You can declare a member of a class--a data member or a method--`static`. This
    is similar in some ways to how you use the `static` keyword on automatic variables
    and functions declared at file scope, but there are some important, and different,
    properties to this keyword when used on a class member.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以声明类的成员——数据成员或方法——为`static`。在某些方面，这类似于在文件范围声明静态关键字的自动变量和函数的使用方式，但是当在类成员上使用此关键字时，有一些重要且不同的属性。
- en: Defining static members
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义静态成员
- en: When you use `static` on a class member it means that the item is associated
    with the class and not with a specific instance. In the case, of data members,
    this means that there is one data item shared by all instances of the class. Likewise,
    a `static` method is not attached to an object, it is not `__thiscall` and has
    no `this` pointer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在类成员上使用`static`时，这意味着该项与类相关，而不是与特定实例相关。对于数据成员来说，这意味着所有实例共享一个数据项。同样，`static`方法不附加到对象，它不是`__thiscall`，也没有`this`指针。
- en: A `static` method is part of the namespace of a class, so it can create objects
    for the class and have access to their `private` members. A `static` method has
    the `__cdecl` calling convention by default, but you can declare it as `__stdcall`
    if you wish. This means that, you can write a method within the class that can
    be used to initialize C-like pointers, which are used by many libraries. Note
    that the `static` function cannot call nonstatic methods on the class because
    a nonstatic method will need a `this` pointer, but a nonstatic method can call
    a `static` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`方法是类的命名空间的一部分，因此它可以为类创建对象并访问它们的`private`成员。`static`方法默认具有`__cdecl`调用约定，但如果愿意，可以将其声明为`__stdcall`。这意味着您可以编写一个在类中使用的方法来初始化许多库使用的C样式指针。请注意，`static`函数不能调用类上的非静态方法，因为非静态方法需要`this`指针，但非静态方法可以调用`static`方法。'
- en: 'A nonstatic method is called through an object, either using the dot operator
    (for a class instance) or the `->` operator for an object pointer. A `static`
    method does not need an associated object, but it can be called through one. This
    gives two ways to call a `static` method, through an object or through the `class`
    name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态方法通过对象调用，可以使用点运算符（对于类实例）或`->`运算符（对于对象指针）。`static`方法不需要关联对象，但可以通过对象调用。这给了调用`static`方法的两种方式，通过对象或通过`class`名称：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, the class defines a `static` method called `f` and a nonstatic method
    called `g`. The nonstatic method `g` can call the `static` method, but the `static`
    method `f` cannot call the nonstatic method. Since the `static` method `f` is
    `public`, code outside the `class` can call it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类定义了一个名为`f`的`static`方法和一个名为`g`的非静态方法。非静态方法`g`可以调用`static`方法，但`static`方法`f`不能调用非静态方法。由于`static`方法`f`是`public`，类外的代码可以调用它：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although the `static` function can be called through an object, you do not have
    to create any objects at all to call it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以通过对象调用`static`函数，但您根本不需要创建任何对象来调用它。
- en: 'Static data members need a bit more work because when you use `static` it indicates
    that the data member is not part of an object, and usually data members are allocated
    when an object is created. You have to define `static` data members outside of
    the class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据成员需要更多的工作，因为当您使用`static`时，它表示数据成员不是对象的一部分，通常在创建对象时分配数据成员。您必须在类外定义`static`数据成员：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The data member is defined outside of the class at file scope. It is named using
    the `class` name, but note that it also has to be defined using the type. In this
    case the data member is initialized with a value; if you do not do this, then
    on the first use of the variable it will have the default value of the type (in
    this case, zero). If you choose to declare the class in a header file (which is
    common), the definition of the `static` data members must be in a source file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据成员在类外部定义在文件范围内。它使用`class`名称命名，但请注意，它也必须使用类型进行定义。在这种情况下，数据成员使用一个值进行初始化；如果不这样做，那么在第一次使用变量时，它将具有类型的默认值（在这种情况下为零）。如果选择在头文件中声明类（这是常见的做法），则`static`数据成员的定义必须在源文件中。
- en: You can also declare a variable in a method that is `static`. In this case,
    the value is maintained across method calls, in all objects, so it has the same
    effect as a `static class` member, but you do not have the issue of defining the
    variable outside of the class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在方法中声明一个`static`变量。在这种情况下，该值在所有对象的方法调用中保持不变，因此具有与`static class`成员相同的效果，但您不必在类外定义变量的问题。
- en: Using static and global objects
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态和全局对象
- en: A `static` variable in a global function will be created at some point before
    the function is first called. Similarly, a `static` object that is a member of
    a class will be initialized at some point before it is first accessed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数中的`static`变量将在首次调用函数之前创建。同样，作为类成员的`static`对象将在首次访问之前初始化。
- en: Static and global objects are constructed before the `main` function is called,
    and destroyed after the `main` function finishes. The order of this initialization
    has some issues. The C++ standard says that the initialization of `static` and
    global objects defined in a source file will occur before any function or object
    defined in that source file is used, and if there are several global objects in
    a source file, they will be initialized in the order that they are *defined*.
    The issue is if you have several source files with `static` objects in each. There
    is no guarantee on the order in which these objects will be initialized. It becomes
    a problem if one `static` object depends on another `static` object because you
    cannot guarantee that the dependent object will be created after the object it
    depends upon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和全局对象在调用`main`函数之前构造，并在`main`函数完成后销毁。这种初始化顺序存在一些问题。C++标准规定，在源文件中定义的`static`和全局对象的初始化将在使用该源文件中定义的任何函数或对象之前发生，如果源文件中有几个全局对象，则它们将按照定义的顺序进行初始化。问题在于如果有几个源文件中都有`static`对象。无法保证这些对象的初始化顺序。如果一个`static`对象依赖于另一个`static`对象，那么就会出现问题，因为无法保证依赖对象将在其依赖对象之后创建。
- en: Named constructors
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名构造函数
- en: 'This is one application for `public static` methods. The idea is that since
    the `static` method is a member of the `class` it means that it has access to
    the `private` members of an instance of the `class`, so such a method can create
    an object, perform some additional initialization, and then return the object
    to the caller. This is a **factory method**. The `point` class used so far has
    been constructed using Cartesian points, but we could also create a point based
    on polar co-ordinates, where the `(x, y)` Cartesian co-ordinates can be calculated
    as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`public static`方法的一个应用。这个想法是，由于`static`方法是`class`的一个成员，这意味着它可以访问`class`实例的`private`成员，所以这样一个方法可以创建一个对象，执行一些额外的初始化，然后将对象返回给调用者。这是一个**工厂方法**。到目前为止使用的`point`类是使用笛卡尔坐标构建的，但我们也可以基于极坐标创建一个点，其中`(x,
    y)`笛卡尔坐标可以计算为：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here `r` is the length of the vector to the point and `theta` is the angle
    of this vector counter-clockwise to the x axis. The `point` class already has
    a constructor that takes two `double` values, so we cannot use this to pass polar
    co-ordinates; instead, we can use a `static` method as a *named constructor*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`r`是到点的向量的长度，`theta`是这个向量逆时针到x轴的角度。`point`类已经有一个接受两个`double`值的构造函数，所以我们不能用它来传递极坐标；相反，我们可以使用一个`static`方法作为*命名构造函数*：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The method can be called like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以这样调用：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The object `p11` is the `point` with the Cartesian co-ordinates of (1,1). In
    this example the `polar` method calls a `public` constructor, but it has access
    to private members, so the same method could be written (less efficiently) as:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`p11`是具有笛卡尔坐标(1,1)的`point`。在这个例子中，`polar`方法调用了一个`public`构造函数，但它可以访问私有成员，所以同样的方法也可以写成（效率较低）：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Nested classes
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类
- en: 'You can define a class within a class. If the nested class is declared as `public`,
    then you can create objects in the container class and return them to external
    code. Typically, however, you will want to declare a class that is used by the
    class and should be `private`. The following declares a `public` nested class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个类中定义一个类。如果嵌套类声明为`public`，那么你可以在容器类中创建对象并将它们返回给外部代码。然而，通常情况下，你会想要声明一个被类使用并且应该是`private`的类。以下声明了一个`public`的嵌套类：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how the name of the nested class is prefixed with the name of the containing
    class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类的名称前缀是包含类的名称。
- en: Accessing const objects
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问const对象
- en: 'You have seen many examples so far of using `const`, and perhaps the most frequent
    is when it is applied to a reference as a function parameter to indicate to the
    compiler that the function only has read-only access to the object. Such a `const`
    reference is used so that objects are passed by reference to avoid the overhead
    of the copying that would occur if the object were passed by value. Methods on
    a `class` can access the object data members and, potentially, can change them,
    so if you pass an object through a `const` reference the compiler will only allow
    the reference to call methods that do not change the object. The `point` class
    defined earlier had two accessors to access the data in the class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了许多使用`const`的例子，也许最常见的是当它作为函数参数应用于引用时，以指示编译器函数只对对象具有只读访问权限。这样的`const`引用用于通过引用传递对象，以避免通过值传递对象时会发生的复制开销。`class`上的方法可以访问对象数据成员，并且可能会改变它们，所以如果你通过`const`引用传递一个对象，编译器只允许引用调用不改变对象的方法。之前定义的`point`类有两个访问器来访问类中的数据：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you define a function that takes a `const` reference to this and you attempt
    to call these accessors, you will get an error from the compiler:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义一个函数，它接受一个对`const`的引用，并尝试调用这些访问器，你将会从编译器得到一个错误：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The error from the compiler is a bit obscure:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的错误有点模糊：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This message is the compiler complaining that the object is `const`, it is
    immutable, and it does not know whether these methods will preserve the state
    of the object. The solution is simple--add the `const` keyword to methods that
    do not change the object state, like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息是编译器抱怨对象是`const`，它是不可变的，并且它不知道这些方法是否会保持对象的状态。解决方法很简单--在不改变对象状态的方法中添加`const`关键字，就像这样：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This effectively means that the `this` pointer is `const`. The `const` keyword
    is part of the function prototype, so the method can be overloaded on this. You
    can have one method that is called when it is called on a `const` object and another
    called on a non-const object. This enables you to implement a copy-on-write pattern
    where, for example, a `const` method would return read-only access to the data
    and the non-const method would return a *copy* of the data that is writeable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着`this`指针是`const`。`const`关键字是函数原型的一部分，所以该方法可以在此上进行重载。你可以有一个方法，当它在一个`const`对象上调用时被调用，另一个方法在一个非`const`对象上被调用。这使你能够实现写时复制模式，例如，一个`const`方法会返回对数据的只读访问，而非`const`方法会返回可写的数据的*副本*。
- en: Of course, a method marked with `const` must not alter the data members, not
    even temporarily. So, such a method can only call `const` methods. There may be
    rare cases when a data member is designed to be changed through a `const` object;
    in this case the declaration of the member is marked with the `mutable` keyword.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，标记为`const`的方法不能改变数据成员，甚至是暂时的。因此，这样的方法只能调用`const`方法。也许有一些罕见的情况，一个数据成员被设计为通过`const`对象进行更改；在这种情况下，成员的声明会标记为`mutable`关键字。
- en: Using objects with pointers
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针的对象
- en: Objects can be created on the free store and accessed through a typed pointer.
    This gives more flexibility because it is efficient to pass pointers to functions,
    and you can explicitly determine the lifetime of the object because an object
    is created with the call to `new` and destroyed by the call to `delete`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以在自由存储器上创建，并通过类型指针访问。这样做更加灵活，因为将指针传递给函数是高效的，并且你可以明确确定对象的生命周期，因为对象是通过调用`new`创建的，并通过调用`delete`销毁的。
- en: Getting pointers to object members
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取对象成员的指针
- en: 'If you need to get access to the address of a class data member through an
    instance (assuming the data member is `public`), you simply use the `&` operator:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要通过实例访问类数据成员的地址（假设数据成员是`public`），您只需使用`&`运算符：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case `struct` is used to declare `point` so that the members are `public`
    by default. The second line uses an initialization list to construct a `point`
    object with two values, and then the final line gets a pointer to one of the data
    members. Of course, the pointer cannot be used after the object has been destroyed.
    Data members are allocated in memory (in this case on the stack), so the address
    operator merely gets a pointer to that memory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`struct`用于声明`point`，以便成员默认为`public`。第二行使用初始化列表构造了一个具有两个值的`point`对象，然后最后一行获取了一个数据成员的指针。当然，在对象被销毁后，指针不能再使用。数据成员被分配在内存中（在这种情况下是在堆栈上），因此地址运算符只是获取指向该内存的指针。
- en: 'Function pointers are a different case. There will only be one copy of the
    method in memory, regardless of how many instances of the `class` are created,
    but because methods are called using the `__thiscall` calling convention (with
    a hidden `this` parameter) you have to have a function pointer that can be initialized
    with a pointer to an object to provide the `this` pointer. Consider this `class`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针是一个不同的情况。无论创建了多少个`class`的实例，内存中只会有一个方法的副本，但是因为方法是使用`__thiscall`调用约定（带有隐藏的`this`参数）调用的，所以您必须有一个函数指针，可以用一个指向对象的指针来初始化，以提供`this`指针。考虑这个`class`：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can define a function pointer to the `get_magnitude` method like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样定义一个指向`get_magnitude`方法的函数指针：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first line declares a function pointer. This is similar to the C function
    pointer declarations except that there is an inclusion of the `class` name in
    the pointer type. This is needed so that the compiler knows that it has to provide
    a `this` pointer in any call through this pointer. The second line obtains a pointer
    to the method. Notice that no object is involved. You are not getting a function
    pointer to a method on an object; you are getting a pointer to a method on a `class`
    that must be called through an object. To call the method through this pointer,
    you need to use the pointer to the member operator `.*` on an object:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明一个函数指针。这类似于C函数指针声明，只是指针类型中包含了`class`名称。这是必需的，以便编译器知道它必须在通过此指针调用时提供`this`指针。第二行获取方法的指针。请注意，没有涉及任何对象。您不是获取一个对象上的方法的函数指针；您是获取一个必须通过对象调用的`class`上的方法的指针。要通过此指针调用方法，您需要在对象上使用成员运算符`.*`：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first line creates an object and the second line calls the method. The
    pointer to the member operator says that the function pointer on the *right* is
    called with the object on the *left*. The address of the object on the left is
    used for the `this` pointer when the method is called. As this is a method, we
    need to provide a parameter list, which in this case is empty (if you have parameters,
    they would be in the pair of parentheses on the right of this statement). If you
    have an object pointer, then the syntax is similar, but you use the `->*` pointer
    to the member operator:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建一个对象，第二行调用方法。成员运算符的指针表示在*左侧*的对象上调用*右侧*的函数指针。在调用方法时，左侧对象的地址用于`this`指针。由于这是一个方法，我们需要提供参数列表，在这种情况下为空（如果您有参数，它们将在此语句右侧的括号中）。如果您有一个对象指针，那么语法是类似的，但是您使用`->*`指向成员运算符：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Operator overloading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'One of behaviors of a type is the operations you can apply to it. C++ allows
    you to overload the C++ operators as part of a class so that it''s clear that
    the operator is acting upon the type. This means that for a unary operator the
    member method should have no parameters and for a binary operator you need only
    one parameter, since the current object will be on the left of the operator, and
    hence the method parameter is the item on the right. The following table summarizes
    how to implement unary and binary operators, and four exceptions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的一个行为是您可以应用于它的操作。C++允许您重载C++运算符作为类的一部分，以便清楚地表明运算符是作用于该类型的。这意味着对于一元运算符，成员方法不应该有参数，对于二元运算符，您只需要一个参数，因为当前对象将位于运算符的左侧，因此方法参数是右侧的项目。以下表总结了如何实现一元和二元运算符，以及四个异常：
- en: '| **Expression** | **Name** | **Member method** | **Non-member function** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **名称** | **成员方法** | **非成员函数** |'
- en: '| +a/-a | Prefix unary | operator() | operator(a) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| +a/-a | 前缀一元 | 运算符() | 运算符(a) |'
- en: '| a, b | Binary | operator(b) | operator(a,b) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| a, b | 二元 | 运算符(b) | 运算符(a,b) |'
- en: '| a+/a- | Postfix unary | operator(0) | operator(a,0) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| a+/a- | 后缀一元 | 运算符(0) | 运算符(a,0) |'
- en: '| a=b | Assignment | operator=(b) |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| a=b | 赋值 | 运算符=(b) |  |'
- en: '| a(b) | Function call | operator()(b) |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| a(b) | 函数调用 | 运算符()(b) |  |'
- en: '| a[b] | Indexing | operator[](b) |  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| a[b] | 索引 | 运算符[](b) |  |'
- en: '| a-> | Pointer access | operator->() |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| a-> | 指针访问 | 运算符->() |  |'
- en: Here the ■ symbol is used to indicate any of the acceptable unary or binary
    operators except for the four operators mentioned in the table.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的■符号用于表示表中提到的四个运算符之外的任何可接受的一元或二元运算符。
- en: There are no strict rules over what an operator should return, but it helps
    if an operator on a custom type behaves like operators on a built-in type. There
    also has to be some consistency. If you implement the `+` operator to add two
    objects together, then the same plus action should be used for the `+=` operator.
    Also, you could argue that the plus action will also determine what the minus
    action should be like, and hence the `-` and `-=` operators. Similarly, if you
    want to define the `<` operator, then you should define `<=. >`, `>=`, `==`, and
    `!=` too.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 没有严格的规则规定运算符应该返回什么，但是如果自定义类型的运算符的行为类似于内置类型的运算符，那将会有所帮助。还必须有一些一致性。如果您实现`+`运算符来将两个对象相加，那么`+=`运算符应该使用相同的加法操作。同样，您可以认为加法操作也将决定减法操作应该是什么样子，因此`-`和`-=`运算符。同样，如果您想定义`<`运算符，那么您应该定义`<=`、`>`、`>=`、`==`和`!=`。
- en: The Standard Library's algorithms (for example, `sort`) will only expect the
    `<` operator to be defined on a custom type.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的算法（例如`sort`）只会期望在自定义类型上定义`<`运算符。
- en: 'The table shows that you can implement almost all the operators as either a
    member of the custom type class or as a global function (with the exception of
    the four listed that have to be member methods). In general, it is best to implement
    the operator as part of the class because it maintains encapsulation: the member
    function has access to the non-public members of the class.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表格显示，你可以将几乎所有的运算符实现为自定义类型类的成员或全局函数（除了那四个必须是成员方法的例外）。一般来说，最好将运算符作为类的一部分实现，因为它保持了封装性：成员函数可以访问类的非公共成员。
- en: 'An example of a unary operator is the unary negative operator. This usually
    does not alter an object but returns a new object that is the *negative* of the
    object. For our `point class`, this means making both co-ordinates negative, which
    is equivalent to a mirror of the Cartesian point in a line *y = -x*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符的一个例子是一元负运算符。这通常不会改变一个对象，而是返回一个对象的*负值*。对于我们的`point class`，这意味着使两个坐标都变为负数，这相当于在一条线*y
    = -x*上对笛卡尔点进行镜像：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The operator is declared as `const` because it''s clear the operator does not
    change the object and hence it''s safe to be called on a `const` object. The operator
    can be called like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符声明为`const`，因为很明显运算符不会改变对象，因此可以安全地在`const`对象上调用。运算符可以这样调用：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To understand why we have implemented the operator like this, review what the
    unary operator would do when applied to a built-in type. The second statement
    here, `int i, j=0; i = -j;`, will only alter `i` and will not alter `j`, so the
    member `operator-` should not affect the value of the object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么我们要这样实现运算符，请回顾一下当应用于内置类型时一元运算符会做什么。这里的第二个语句，`int i, j=0; i = -j;`，只会改变`i`，不会改变`j`，所以成员`operator-`不应该影响对象的值。
- en: 'The binary negative operator has a different meaning. First, it has two operands,
    and, second, in this example, the result is a different type to the operands because
    the result is a vector that indicates a direction by taking one point away from
    another. Assuming that the `cartesian_vector` is already defined with a constructor
    that has two parameters, then we can write:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 二元负运算符有不同的含义。首先，它有两个操作数，其次，在这个例子中，结果与操作数的类型不同，因为结果是一个向量，通过从一个点中减去另一个点来指示一个方向。假设`cartesian_vector`已经定义了一个具有两个参数的构造函数，那么我们可以写成：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The increment and decrement operators have a special syntax because they are
    unary operators that can be prefixed or postfixed, and they alter the object they
    are applied to. The major difference between the two operators is that the postfixed
    operator returns the value of the object *before* the increment/decrement action,
    so a temporary has to be created. For this reason, the prefix operator almost
    always has better performance than the postfix operator. In a class definition,
    to distinguish between the two, the prefix operator has no parameters and the
    postfix operator has a dummy parameter (in the preceding table, 0 is given). For
    a class `mytype`, this is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量运算符有特殊的语法，因为它们是可以前置或后置的一元运算符，并且会改变它们所应用的对象。两个运算符之间的主要区别在于后置运算符返回增量/减量操作*之前*对象的值，因此需要创建一个临时对象。因此，前置运算符几乎总是比后置运算符具有更好的性能。在类定义中，为了区分这两者，前置运算符没有参数，后置运算符有一个虚拟参数（在前面的表中给出了0）。对于一个类`mytype`，如下所示：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The actual increment code is implemented by the prefix operator, and this logic
    is used by the postfix operator through an explicit call to the method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的增量代码是由前置运算符实现的，并且后置运算符通过显式调用该方法使用这个逻辑。
- en: Defining function classes
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数类
- en: 'A functor is a class that implements the `()` operator. This means that you
    can call an object using the same syntax as a function. Consider this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数对象是一个实现了`()`运算符的类。这意味着你可以使用与函数相同的语法调用一个对象。考虑这个：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This code can be called like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以这样调用：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code shows that the functor object not only provides some behavior (in
    this case, performing an action on the parameter) but it also can have a state.
    The preceding two lines are called through the `operator()` method on an object:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表明，函数对象不仅提供了一些行为（在这种情况下，在参数上执行一个动作），而且还可以有一个状态。前两行是通过对象上的`operator()`方法调用的：
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Look at the syntax. The functor object is called as if it is a function declared
    like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 看语法。函数对象被调用，就好像它是这样声明的函数：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Imagine that you want to pass a pointer to a function--perhaps you are want
    the function''s behavior to be altered by external code. To be able to use either
    a functor or a method pointer, you need to overload your function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想传递一个指向函数的指针--也许你希望函数的行为被外部代码改变。为了能够使用函数对象或方法指针，你需要重载你的函数：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first takes a reference to a functor object. The second has a C-type function
    pointer (to which you can pass a pointer to `multiply_by_3`) and is quite unreadable.
    In both cases the `fn` parameter is called in the same way in the implementation
    code, but you need to declare two functions because they are different types.
    Now, consider the magic of function templates:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个接受一个函数对象的引用。第二个有一个C类型的函数指针（你可以传递一个指向`multiply_by_3`的指针），并且相当难以阅读。在两种情况下，`fn`参数在实现代码中以相同的方式被调用，但你需要声明两个函数，因为它们是不同的类型。现在，考虑函数模板的魔力：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is generic code; the `Fn` type can be a C function pointer or a functor
    `class`, and the compiler will generate the appropriate code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用代码；`Fn`类型可以是一个C函数指针或一个函数对象`class`，编译器将生成适当的代码。
- en: This code can be called by either passing a function pointer to a global function,
    which will have the `__cdecl` calling convention, or a functor object where the
    `operator()` operator will be called, which has a `__thiscall` calling convention.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过传递一个指向全局函数的函数指针来调用，该函数将具有`__cdecl`调用约定，或者传递一个函数对象，其中将调用`operator()`运算符，该运算符具有`__thiscall`调用约定。
- en: This is a mere implementation detail, but it does mean that you can write a
    generic function that can take either a C-like function pointer or a functor object
    as a parameter. The C++ Standard Library uses this magic, which means that the
    algorithms it provides can be called either with a *global function* or a *functor*,
    or a *lambda expression*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个实现细节，但这意味着你可以编写一个通用函数，可以接受C风格的函数指针或函数对象作为参数。C++标准库使用了这个魔法，这意味着它提供的算法可以用*全局函数*、*函数对象*或*lambda表达式*来调用。
- en: The Standard Library algorithms use three type of functional classes, generators,
    and unary and binary functions; that is, functions with zero, one or two parameters.
    In addition, the Standard Library calls a function object (unary or binary) that
    returns a `bool` **predicate**. The documentation will tell you if a predicate,
    unary, or binary function is needed. Older versions of the Standard Library needed
    to know the types of the return value and parameters (if any) of the function
    object to work, and, for this reason, functor classes had to be based upon the
    standard classes, `unary_function` and `binary_function` (through inheritance,
    explained in the next chapter). In C++11, this requirement has been removed, so
    there is no requirement to use these classes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库算法使用三种类型的函数类、生成器和一元和二元函数；也就是说，没有参数、一个参数或两个参数的函数。此外，标准库调用返回`bool`的函数对象（一元或二元）**谓词**。文档会告诉你是否需要谓词、一元或二元函数。旧版本的标准库需要知道函数对象的返回值和参数（如果有的话）的类型，因此，函数对象类必须基于标准类`unary_function`和`binary_function`（通过继承，在下一章中解释）。在C++11中，这个要求已经被移除，因此没有必要使用这些类。
- en: 'In some cases, you will want to use a binary functor when a unary functor is
    required. For example, the Standard Library defines the `greater` class that,
    when used as a function object, takes two parameters and a `bool` to determine
    whether the first parameter is greater than the second one, using the `operator>`
    defined by the type of both parameters. This will be used for functions that need
    a binary functor, and hence the function will compare two values; for example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当需要一元函数时，你可能希望使用二元函数。例如，标准库定义了`greater`类，当作为函数对象使用时，它接受两个参数和一个`bool`来确定第一个参数是否大于第二个参数，使用两个参数的类型定义的`operator>`。这将用于需要二元函数的函数，因此函数将比较两个值；例如：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This takes two collections and compares corresponding items using the functor
    passed as the last parameter. It can be called like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要两个集合，并使用作为最后一个参数传递的函数对象比较相应的项目。可以这样调用它：
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `greater` functor class is defined in the `<functional>` header and compares
    two numbers using the `operator>` defined for the type. What if you wanted to
    compare the items in a container with a fixed value; that is, when the `operator()(double,
    double)` method on the functor is called, one parameter always has a fixed value?
    One option is to define a stateful functor class (as shown previously) so that
    the fixed value is a member of the functor object. Another way to do this is to
    fill another `vector` with the fixed value and continue to compare two `vector`s
    (this can get quite expensive for large `vector`s).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`greater`函数对象类在`<functional>`头文件中定义，使用为类型定义的`operator>`比较两个数字。如果你想要比较容器中的项目和一个固定值；也就是说，当函数对象的`operator()(double,
    double)`方法被调用时，一个参数总是有一个固定的值？一种选择是定义一个有状态的函数对象类（如前面所示），以便固定值是函数对象的成员。另一种方法是用固定值填充另一个`vector`，并继续比较两个`vector`（对于大的`vector`来说，这可能会变得非常昂贵）。'
- en: 'Another way is to reuse the functor class, but to *bind* a value to one of
    its parameters. A version of the `compare_vals` function can be written like this,
    to take just one `vector`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是重用函数对象类，但是*绑定*一个值到它的一个参数上。`compare_vals`函数的一个版本可以这样写，只接收一个`vector`：
- en: '[PRE67]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The code is written to call the functor parameter on just one value because
    it is assumed that the functor object contains the other value to compare. This
    is carried out by binding the functor class to the parameter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被编写为只调用函数对象参数的一个值，因为假设函数对象包含另一个要比较的值。这是通过将函数对象类绑定到参数来实现的：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `bind` function is variadic. The first parameter is the functor object and
    it is followed by the parameters that will be passed to the `operator()` method
    of the functor. The `compare_vals` function is passed a **binder** object that
    binds the functor to values. In the `compare_vals` function, the call to the functor
    in `compare(d[i])` is actually a call to the `operator()` method of the binder
    object, and this method forwards the parameter `d[i]` and the bound value to the
    `operator()` method of the functor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数是可变参数的。第一个参数是函数对象，后面是将传递给函数对象的`operator()`方法的参数。`compare_vals`函数接收一个**binder**对象，将函数对象绑定到值上。在`compare_vals`函数中，对`compare(d[i])`中的函数对象的调用实际上是对绑定对象的`operator()`方法的调用，这个方法将参数`d[i]`和绑定的值转发给函数对象的`operator()`方法。'
- en: In the call to `bind`, if an actual value is provided (here, `2.0`), then that
    value is passed to the functor at that position in the call to the functor (here,
    `2,0` is passed to the second parameter). If a symbol preceded by an underscore
    is used, then it is a **placeholder**. There are 20 such symbols (`_1` to `_20`)
    defined in the `std::placeholders` namespace. The placeholder means "use the value
    passed in this position to the binder object `operator()` method call to the functor
    call `operator()` method indicated by the placeholder." Thus, the placeholder
    in this call means "pass the first parameter from invoking the binder and pass
    it to the first parameter of the `greater` functor `operator()`."
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`bind`时，如果提供了实际值（这里是`2.0`），那么该值将传递给函数对象在调用函数对象时的位置（这里，`2.0`传递给第二个参数）。如果使用下划线前缀的符号，则是**占位符**。`std::placeholders`命名空间中定义了20个这样的符号（`_1`到`_20`）。占位符的意思是“使用在这个位置传递的值来调用绑定器对象的`operator()`方法，并将其传递给函数对象调用`operator()`方法中由占位符指示的位置”。因此，这个调用中的占位符意味着“将从调用绑定器中传递的第一个参数传递给`greater`函数对象的`operator()`的第一个参数”。
- en: 'The previous code compares each item in the `vector` with `2.0` and will keep
    a count of those that are greater than `2.0`. You could invoke it this way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将`vector`中的每个项目与`2.0`进行比较，并将大于`2.0`的项目计数。您可以这样调用它：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The parameter list is swapped, and this means that `2.0` is compared with each
    item in the `vector` and the function will keep a count of how many times `2.0`
    is greater than the item.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表被交换，这意味着`2.0`与`vector`中的每个项目进行比较，并且函数将计算`2.0`大于项目的次数。
- en: The `bind` function, and placeholders, are new to C++11\. In prior versions
    you could use the `bind1st` and `bind2nd` functions to bind a value to either
    the first or second parameter of the functor.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数和占位符是C++11中的新功能。在之前的版本中，您可以使用`bind1st`和`bind2nd`函数将值绑定到函数对象的第一个或第二个参数。'
- en: Defining conversion operators
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义转换运算符
- en: 'We have already seen that a constructor can be used to convert from another
    type to your custom type if your custom type has a constructor that takes the
    type you are converting. You can also perform the conversion in the other direction:
    converting the object into another type. To do this, you provide an operator without
    a return type with the name of the type to convert to. In this case, you need
    a space between the `operator` keyword and the name:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，如果自定义类型具有接受要转换的类型的构造函数，则可以使用构造函数将另一种类型转换为自定义类型。您还可以执行另一种方向的转换：将对象转换为另一种类型。为此，您提供一个没有返回类型的带有要转换为的类型名称的运算符。在这种情况下，`operator`关键字和名称之间需要有一个空格：
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This code can convert an `int` or a `string` to `mytype`; in the latter case,
    only through an explicit mention of the constructor. The last line allows you
    to convert an object back to an `int`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以将`int`或`string`转换为`mytype`；在后一种情况下，只能通过显式提及构造函数来实现。最后一行允许将对象转换回`int`：
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can make such conversion operators `explicit` so that they will be called
    only when an explicit cast is used. In many cases, you will want to leave off
    this keyword because implicit conversions are useful when you want to wrap a resource
    in a class and use the destructor to do automatic resource management for you.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这样的转换运算符设置为`explicit`，这样它们只会在使用显式转换时被调用。在许多情况下，您可能希望省略此关键字，因为当您想要将资源封装在类中并使用析构函数来自动管理资源时，隐式转换是有用的。
- en: Another example of using a conversion operator is returning values from a stateful
    functor. The idea here is that the `operator()` will perform some action and the
    result is maintained by the functor. The issue is how do you obtain this state
    of the functor, especially when they are often created as temporary objects? A
    conversion operator can provide this functionality.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转换运算符的另一个示例是从有状态的函数对象返回值。这里的想法是`operator()`将执行某些操作，并且结果由函数对象维护。问题是，当它们经常作为临时对象创建时，如何获取函数对象的状态？转换运算符可以提供此功能。
- en: 'For example, when you calculate an average, you do it in two stages: the first
    stage is to accumulate the values and then the second stage is to calculate the
    average by dividing it by the number of items. The following functor class does
    this with the division performed as part of the conversion to a `double`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当计算平均值时，需要分两个阶段：第一阶段是累积值，第二阶段是通过将其除以项目数来计算平均值。以下函数对象类通过将除法作为转换为`double`的一部分来执行此操作：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This can be called like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样调用：
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `for_each` function calls the functor for every item in the `vector`, and
    the `operator()` simply sums the items passed to it and maintains a count. The
    interesting part is that after the `for_each` function has iterated over all of
    the items in the `vector` it returns the functor, and so there is an implicit
    conversion to a `double`, which calls the conversion operator that calculates
    the average.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`函数对`vector`中的每个项目调用函数对象，`operator()`简单地对传递给它的项目求和并保持计数。有趣的部分是，在`for_each`函数遍历完`vector`中的所有项目后，它会返回函数对象，因此会有一个隐式转换为`double`，这会调用计算平均值的转换运算符。'
- en: Managing resources
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理资源
- en: 'We have already seen one sort of resource that requires careful management:
    memory. You allocate memory with `new`, and when you have finished with the memory
    you must deallocate the memory with `delete`. A failure to deallocate the memory
    will cause a memory leak. Memory is, perhaps, the most fundamental of system resources,
    but most operating systems have many others: file handles, handles to graphic
    objects, synchronization objects, threads, and processes. Sometimes possession
    of such a resource is exclusive and will prevent other code from accessing the
    resource accessed through the resource. Thus, it is important that such resources
    are freed at some point, and, usually, that they are freed in a timely manner.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到一种需要仔细管理的资源：内存。您使用`new`分配内存，当您使用完内存后，必须使用`delete`释放内存。未能释放内存将导致内存泄漏。内存可能是最基本的系统资源，但大多数操作系统还有许多其他资源：文件句柄、图形对象句柄、同步对象、线程和进程。有时拥有这样的资源是独占的，并且会阻止其他代码访问通过该资源访问的资源。因此，重要的是这些资源在某个时刻被释放，通常情况下，它们应该及时释放。
- en: Classes help here with a mechanism called **Resource Acquisition Is Initialization**
    (RAII) invented by Bjarne Stroustrup, the author of C++. Put simply, the resource
    is allocated in the constructor of an object and freed in the destructor, so it
    means that the lifetime of the resource is the lifetime of the object. Typically,
    such wrapper objects are allocated on the stack, and this means that you are guaranteed
    that the resource will be freed when the object goes out of scope *regardless
    of how this happens*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类在这里有所帮助，使用了由C++的作者Bjarne Stroustrup发明的一种称为**资源获取即初始化**（RAII）的机制。简单地说，资源在对象的构造函数中分配，并在析构函数中释放，这意味着资源的生命周期是对象的生命周期。通常，这样的包装对象是在堆栈上分配的，这意味着无论发生什么，当对象超出范围时，资源都将被释放。
- en: So, if objects are declared in the code block for a looping statement (`while`,
    `for`), then at the end of each loop the destructor for each will be called (in
    reverse order of creation) and the object will be created again when the loop
    is repeated. This occurs whether the loop is repeated because the end of the code
    block has been reached or if the loop is repeated through a call to `continue`.
    Another way to leave a code block is through a call to `break`, a `goto`, or if
    the code calls `return` to leave the function. If the code raises an exception
    (see [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics and Debugging*),
    the destructor will be called as the object goes out of scope, so if the code
    is guarded by a `try` block, the destructor of objects declared in the block will
    be called before the `catch` clause is called. If there is no guard block, then
    the destructor will be called before the function stack is destroyed and the exception
    propagated.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果对象在循环语句（`while`、`for`）的代码块中声明，则在每次循环结束时，将调用每个对象的析构函数（按创建顺序的相反顺序），并且当循环重复时，对象将被再次创建。无论循环是因为代码块的末尾已经到达，还是因为循环通过调用`continue`重复。离开代码块的另一种方法是通过调用`break`、`goto`，或者如果代码调用`return`离开函数。如果代码引发异常（参见[第10章](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml)，*诊断和调试*），则在对象超出范围时将调用析构函数，因此如果代码受`try`块保护，则在调用`catch`子句之前将调用块中声明的对象的析构函数。如果没有保护块，则在函数堆栈被销毁并传播异常之前将调用析构函数。
- en: Writing wrapper classes
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写包装类
- en: There are several issues that you must address when writing a class to wrap
    a resource. The constructor will be used, either to obtain the resource using
    some library function (usually accessed through some kind of opaque handle) or
    will take the resource as a parameter. This resource is stored as a data member
    so other methods on the class can use it. The resource will be released in the
    destructor using whatever function your library provides to do this. This is the
    bare minimum. In addition, you have to think how the object will be used. Often
    such wrapper classes are most convenient if you can use instances as if they are
    the resource handle. This means that you maintain the same style of programming
    to access the resource, but you just don't have to worry too much about releasing
    the resource.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写包装资源的类时，您必须解决几个问题。构造函数将被用来获取资源，要么使用某个库函数（通常通过某种不透明句柄访问），要么将资源作为参数。这个资源将作为数据成员存储，以便类上的其他方法可以使用它。析构函数将使用库提供的函数释放资源。这是最基本的。此外，您还需要考虑对象将如何被使用。通常，如果可以将实例用作资源句柄，这样的包装类最方便。这意味着您保持相同的编程风格来访问资源，但您不必太担心释放资源。
- en: You should think about whether you want to be able convert between your wrapper
    class and the resource handle. If you do allow this, it means that you may have
    to think about cloning the resource, so that you do not have two copies of the
    handle--one that is managed by the class and the other copy that could be released
    by external code. You also need to think about whether you want to allow the object
    to be copied or assigned, and if so, then you will need to appropriately implement
    the copy constructor, a move constructor, and the copy and move assignment operators.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑是否希望能够在包装类和资源句柄之间进行转换。如果允许这样做，这意味着您可能需要考虑克隆资源，以便您不会有两个句柄的副本--一个由类管理，另一个副本可能会被外部代码释放。您还需要考虑是否允许对象被复制或分配，如果是的话，那么您将需要适当地实现复制构造函数、移动构造函数以及复制和移动赋值运算符。
- en: Using smart pointers
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针
- en: The C++ Standard Library provides several classes to wrap resources accessed
    through pointers. To prevent memory leaks, you have to ensure that memory allocated
    on the free store is freed at some point. The idea of a smart pointer is that
    you treat an instance as if it is the pointer, so you use the `*` operator to
    dereference to get access to the object it points to or use the `->` operator
    to access a member of the wrapped object. The smart pointer class will manage
    the lifetime of the pointer it wraps and will release the resource appropriately.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了几个类来包装通过指针访问的资源。为了防止内存泄漏，您必须确保在某个时刻释放在自由存储器上分配的内存。智能指针的概念是您将一个实例视为指针，因此您使用`*`运算符进行解引用以访问它指向的对象，或者使用`->`运算符访问包装对象的成员。智能指针类将管理其包装的指针的生命周期，并将适当地释放资源。
- en: 'The Standard Library has three smart pointer classes: `unique_ptr`, `shared_ptr`,
    and `weak_ptr`. Each handles how the resource is released in a different way,
    and how or whether you can copy a pointer.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有三个智能指针类：`unique_ptr`、`shared_ptr`和`weak_ptr`。每个类以不同的方式处理资源的释放，以及是否以及如何复制指针。
- en: Managing exclusive ownership
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理独占所有权
- en: The `unique_ptr` class is constructed with a pointer to the object it will maintain.
    This class provides the operator `*` to give access to the object, dereferencing
    the wrapped pointer. It also provides the `->` operator, so that if the pointer
    is for a class, you can access the members through the wrapped pointer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`类是使用指向它将维护的对象的指针构造的。该类提供了`*`运算符来访问对象，对包装的指针进行解引用。它还提供了`->`运算符，因此如果指针是类的指针，您可以通过包装的指针访问成员。'
- en: 'The following allocates an object on the free store and manually maintains
    its lifetime:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在自由存储器上分配一个对象并手动维护其生命周期：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this case, you get a pointer to the memory on the free store allocated for
    an `int`. To access the memory--either to write to it or read from it--you dereference
    the pointer with the `*` operator. When you are finished with the pointer, you
    must call `delete` to deallocate the memory and return it to the free store. Now
    consider the same code, but with a smart pointer:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您获得了一个指向为`int`分配的自由存储器上的内存的指针。要访问内存--无论是写入还是读取--您都必须使用`*`运算符对指针进行解引用。当您完成指针时，必须调用`delete`来释放内存并将其返回给自由存储器。现在考虑相同的代码，但使用智能指针：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The two main differences are that the smart pointer object is constructed explicitly
    by calling the constructor that takes a pointer of the type that is used as the
    template parameter. This pattern reinforces the idea that the resource should
    only be managed by the smart pointer.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要区别是智能指针对象是通过调用接受用作模板参数的指针的构造函数来显式构造的。这种模式强调了资源应该只由智能指针管理的观念。
- en: The second change is that the memory is deallocated by calling the `release`
    method on the smart pointer object to take ownership of the wrapped pointer, so
    that we can delete the pointer explicitly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化是通过在智能指针对象上调用`release`方法来释放包装的指针的所有权，以便我们可以显式删除指针。
- en: Think of the `release` method releasing the pointer from the ownership of the
    smart pointer. After this call, the smart pointer no longer wraps the resource.
    The `unique_ptr` class also has a method `get` that will give access to the wrapped
    pointer, but the smart pointer object will still retain ownership; *do not delete
    the pointer obtained this way*!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`release`方法释放智能指针对指针的所有权。调用此方法后，智能指针不再包装资源。`unique_ptr`类还有一个`get`方法，可以访问包装的指针，但智能指针对象仍将保留所有权；*不要通过这种方式删除获取的指针*！
- en: 'Note that a `unique_ptr` object wraps a pointer, and just the pointer. This
    means that the object is the same size in memory as the pointer it wraps. So far,
    the smart pointer has added very little, so let''s look at another way to deallocate
    the resource:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`unique_ptr`对象包装一个指针，只是指针。这意味着对象在内存中的大小与它包装的指针相同。到目前为止，智能指针增加了很少的东西，所以让我们看另一种释放资源的方法：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is *deterministic* releasing of the resource, and means that the resource
    is released just when you want it to happen, which is similar to the situation
    with the pointer. The code here is not releasing the resource itself; it is allowing
    the smart pointer to do it, using a **deleter**. The default deleter for `unique_ptr`
    is a functor class called `default_delete`, which calls the `delete` operator
    on the wrapped pointer. If you intend to use deterministic destruction, `reset`
    is the preferred method. You can provide your own deleter by passing the type
    of a custom functor class as the second parameter to the `unique_ptr` template:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是资源的*确定性*释放，意味着资源在您希望发生时释放，这类似于指针的情况。这里的代码并不是释放资源本身；它允许智能指针使用**删除器**来执行释放。`unique_ptr`的默认删除器是一个名为`default_delete`的函数类，它在包装的指针上调用`delete`运算符。如果您打算使用确定性销毁，`reset`是首选方法。您可以通过将自定义函数类的类型作为`unique_ptr`模板的第二个参数传递来提供自己的删除器：
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In your code, you will specify that you want the custom deleter, like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，您将指定要使用自定义删除器，如下所示：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You may need to carry out an additional clean up before deleting the pointer,
    or the pointer could be a obtained by a mechanism other than `new`, so you can
    use a custom deleter to ensure that the appropriate releasing function is called.
    Note that the deleter is part of the smart pointer class, so if you have two different
    smart pointers using two different deleter this way, the smart pointer types are
    different even if they wrap the same type of resource.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除指针之前，您可能需要执行额外的清理，或者指针可能是通过`new`之外的机制获得的，因此您可以使用自定义删除器来确保调用适当的释放函数。请注意，删除器是智能指针类的一部分，因此如果您有两个不同的智能指针以这种方式使用两个不同的删除器，那么智能指针类型是不同的，即使它们包装相同类型的资源。
- en: When you use a custom deleter, the size of a `unique_ptr` object may be larger
    than the pointer wrapped. If the deleter is a functor object, each smart pointer
    object will need memory for this, but if you use a lambda expression, no more
    extra space will be required.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用自定义删除器时，`unique_ptr`对象的大小可能比包装的指针更大。如果删除器是一个函数对象，每个智能指针对象都将需要为此分配内存，但如果使用lambda表达式，则不需要额外的空间。
- en: 'Of course, you are most likely to allow the smart pointer to manage the resource
    lifetime for you, and to do this you simply allow the smart pointer object to
    go out of scope:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你很可能允许智能指针为你管理资源的生命周期，为此你只需允许智能指针对象超出范围即可：
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since the pointer created is a single object, it means that you can call the
    `new` operator on an appropriate constructor to pass in initialization parameters.
    The constructor of `unique_ptr` is passed a pointer to an already constructed
    object, and the class manages the lifetime of the object after that. Although
    a `unique_ptr` object can be created directly by calling its constructor, you
    cannot call the copy constructor, so you cannot use initialization syntax during
    construction. Instead, the Standard Library provides a function called `make_unique`.
    This has several overloads, and for this reason it is the preferred way to create
    smart pointers based on this class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建的指针是一个单一对象，这意味着你可以在适当的构造函数上调用`new`运算符来传递初始化参数。`unique_ptr`的构造函数接收一个指向已构造对象的指针，之后该类管理对象的生命周期。虽然可以直接通过调用其构造函数创建`unique_ptr`对象，但无法调用复制构造函数，因此无法在构造过程中使用初始化语法。相反，标准库提供了一个名为`make_unique`的函数。它有几种重载形式，因此这是创建基于该类的智能指针的首选方式：
- en: '[PRE80]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This code will call the default constructor on the wrapped type (`int`), but
    you can provide parameters that will be passed to the appropriate constructor
    of the type. For example, for a `struct` that has a constructor with two parameters,
    the following may be used:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将调用包装类型（`int`）的默认构造函数，但你可以提供参数，这些参数将传递给类型的适当构造函数。例如，对于具有两个参数的构造函数的`struct`，可以使用以下内容：
- en: '[PRE81]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `make_unique` function calls the constructor that assigns the members with
    non-default values. The `->` operator returns a pointer and the compiler will
    access the object members through this pointer.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`函数调用分配非默认值的成员的构造函数。`->`运算符返回一个指针，编译器将通过这个指针访问对象成员。'
- en: There is also a specialization of `unique_ptr` and `make_unique` for arrays.
    The default deleter for this version of `unique_ptr` will call `delete[]` on the
    pointer, and thus it will delete every object in the array (and call each object's
    destructor). The class implements an indexer operator (`[]`) so you can access
    each item in the array. However, note that there are no range checks, so, like
    a built-in array variable, you can access beyond the end of the array. There are
    no dereferencing operators (`*` or `->`), so a `unique_ptr` object based on an
    array can only be accessed with array syntax.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个用于数组的`unique_ptr`和`make_unique`的特化版本。这个版本的`unique_ptr`的默认删除器将在指针上调用`delete[]`，因此它将删除数组中的每个对象（并调用每个对象的析构函数）。该类实现了一个索引器运算符(`[]`)，因此可以访问数组中的每个项目。但是，请注意，没有范围检查，因此，就像内置数组变量一样，可以访问数组末尾之外的位置。没有解引用运算符(`*`或`->`)，因此基于数组的`unique_ptr`对象只能使用数组语法访问。
- en: 'The `make_unique` function has an overload that allows you to pass the size
    of the array to create, but you have to initialize each object individually:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`函数有一个重载，允许你传递要创建的数组的大小，但你必须单独初始化每个对象：'
- en: '[PRE82]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This creates an array with four `point` objects initially set to the default
    value, and the following lines initialize the second point to a value of `(10.0,
    -10.0)`. It is almost always better to use `vector` or `array` than `unique_ptr`
    to manage arrays of objects.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含四个初始设置为默认值的`point`对象的数组，并且以下行将第二个点初始化为`(10.0, -10.0)`的值。几乎总是比使用`vector`或`array`更好来管理对象数组。
- en: Earlier versions of the C++ Standard Library had a smart pointer class called
    `auto_ptr`. This was a first attempt, and worked in most cases, but also had some
    limitations; for example, `auto_ptr` objects could not be stored in Standard Library
    containers. C++11 introduces rvalue references and other language features such
    as move semantics, and, through these, `unique_ptr` objects can be stored in containers.
    The `auto_ptr` class is still available through the `<new>` header, but only so
    that older code can still compile.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的C++标准库有一个名为`auto_ptr`的智能指针类。这是一个首次尝试，在大多数情况下都有效，但也有一些限制；例如，`auto_ptr`对象无法存储在标准库容器中。C++11引入了右值引用和其他语言特性，如移动语义，通过这些特性，`unique_ptr`对象可以存储在容器中。`auto_ptr`类仍然可以通过`<new>`头文件使用，但只是为了让旧代码仍然可以编译。
- en: The important point about the `unique_ptr` class is that it ensures that there
    is a single copy of the pointer. This is important because the class destructor
    will release the resource, so if you *could* copy a `unique_ptr` object it would
    mean more than one destructor will attempt to release the resource. Objects of
    `unique_ptr` have *exclusive ownership*; an instance always owns what it points
    to.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`类的重要一点是它确保指针只有一个副本。这很重要，因为类析构函数将释放资源，因此如果*可以*复制`unique_ptr`对象，这将意味着将有多个析构函数尝试释放资源。`unique_ptr`对象具有*独占所有权*；实例始终拥有其指向的内容。'
- en: You cannot copy assign `unique_ptr` smart pointers (the copy assignment operator
    and copy constructor are deleted), but you can *move* them by transferring ownership
    of the resource from the source pointer to the destination pointer. So, a function
    can return a `unique_ptr` because the ownership is transferred through move semantics
    to the variable being assigned to the value of the function. If the smart pointer
    is put into a container, there is another move.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能复制分配`unique_ptr`智能指针（复制分配运算符和复制构造函数已被删除），但可以通过转移所有权从源指针到目标指针来*移动*它们。因此，函数可以返回`unique_ptr`，因为所有权通过移动语义传递给被分配给函数值的变量。如果智能指针放入容器中，还有另一个移动。
- en: Sharing ownership
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享所有权
- en: 'There are occasions when you will need to share a pointer: you may create several
    objects and pass a pointer to a single object to each of them so they can call
    this object. Ordinarily, when an object has a pointer to another object, that
    pointer represents a resource that should be destroyed during the destruction
    of the containing object. If a pointer is shared, it means that when one of the
    objects deletes the pointer, the pointers in all of the other objects will be
    invalid (this is called a **dangling pointer** because it no longer points to
    an object). You need a mechanism where several objects can hold a pointer that
    will remain valid until *all* the objects using that pointer have indicated they
    will no longer need to use it.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要共享指针：您可能创建了几个对象，并将指针传递给每个对象的单个对象，以便它们可以调用此对象。通常，当一个对象有指向另一个对象的指针时，该指针代表应在包含对象销毁期间销毁的资源。如果指针被共享，这意味着当其中一个对象删除指针时，所有其他对象中的指针将无效（这称为**悬空指针**，因为它不再指向对象）。您需要一种机制，使得几个对象可以持有一个指针，直到*所有*使用该指针的对象都表示它们将不再需要使用它为止，该指针将保持有效。
- en: C++11 provides this facility with the `shared_ptr` class. This class maintains
    a **reference count** on the resource, and each copy of the `shared_ptr` for that
    resource will increment the reference count. When one instance of `shared_ptr`
    for that resource is destroyed, it will decrement the reference count. The reference
    count is shared, so it means that a non-zero value signifies that at least one
    `shared_ptr` exists accessing the resource. When the last `shared_ptr` object
    decrements the reference count to zero, it is safe to release the resource. This
    means that the reference count must be managed in an atomic way to handle multithreaded
    code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: C++11提供了`shared_ptr`类的这个功能。该类在资源上维护**引用计数**，每个`shared_ptr`的副本都会增加引用计数。当销毁该资源的一个`shared_ptr`实例时，它将减少引用计数。引用计数是共享的，因此它意味着非零值表示至少存在一个`shared_ptr`访问该资源。当最后一个`shared_ptr`对象将引用计数减少到零时，可以安全释放资源。这意味着引用计数必须以原子方式进行管理，以处理多线程代码。
- en: Since the reference count is shared, it means that each `shared_ptr` object
    holds a pointer to a shared buffer called the **control block**, and this means
    it holds the raw pointer and a pointer to the control block, and so each `shared_ptr`
    object will hold more data than a `unique_ptr`. The control block is used for
    more than just the reference count.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用计数是共享的，这意味着每个`shared_ptr`对象都持有指向称为**控制块**的共享缓冲区的指针，这意味着它持有原始指针和指向控制块的指针，因此每个`shared_ptr`对象将持有比`unique_ptr`更多的数据。控制块用于不仅仅是引用计数。
- en: A `shared_ptr` object can be created to use a custom deleter (passed as a constructor
    parameter), and the deleter is stored in the control block. This is important
    because it means that the custom deleter is not part of the type of the smart
    pointer, so several `shared_ptr` objects wrapping the same resource type but using
    different deleters are still the same type and can be put in a container for that
    type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个`shared_ptr`对象来使用自定义删除器（作为构造函数参数传递），并且删除器存储在控制块中。这很重要，因为这意味着自定义删除器不是智能指针类型的一部分，因此封装相同资源类型但使用不同删除器的几个`shared_ptr`对象仍然是相同类型，并且可以放入该类型的容器中。
- en: You can create a `shared_ptr` object from another `shared_ptr` object, and this
    will initialize the new object with the raw pointer and the pointer to the control
    block, *and* increment the reference count.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从另一个`shared_ptr`对象创建一个`shared_ptr`对象，这将使用原始指针和指向控制块的指针初始化新对象，并增加引用计数。
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, the first shared pointer is created using a raw pointer. This is not the
    recommended way to use `shared_ptr`. The second shared pointer is created using
    the first smart pointer, so now there are two shared pointers to the same resource
    (`p` is assigned to `nullptr` to prevent its further use). After this, either
    `sp1` or `sp2` can be used to access the *same* resource. At the end of this code,
    one shared pointer is reset to `nullptr`; this means that `sp1` no longer has
    a reference count on the resource, and you cannot use it to access the resource.
    However, you can still use `sp2` to access the resource until it goes out of scope,
    or you call `reset`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个共享指针是使用原始指针创建的。这不是使用`shared_ptr`的推荐方式。第二个共享指针是使用第一个智能指针创建的，所以现在有两个共享指针指向相同的资源（`p`被赋值为`nullptr`以防止进一步使用）。在此之后，要么`sp1`要么`sp2`可以用来访问*相同*的资源。在此代码结束时，一个共享指针被重置为`nullptr`；这意味着`sp1`不再对资源有引用计数，并且不能使用它来访问资源。然而，您仍然可以使用`sp2`来访问资源，直到它超出范围，或者您调用`reset`。
- en: 'In this code, the smart pointers were created from a separate raw pointer.
    Since the shared pointers now have taken over the lifetime management of the resource
    it is important to no longer use the raw pointer, and in this case it is assigned
    to `nullptr`. It is better to avoid the use of raw pointers, and the Standard
    Library enables this with a function called `make_shared`, which can be used like
    this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，智能指针是从单独的原始指针创建的。由于共享指针现在已经接管了资源的生命周期管理，因此重要的是不再使用原始指针，在这种情况下将其分配为`nullptr`。最好避免使用原始指针，标准库通过一个名为`make_shared`的函数实现了这一点，可以像这样使用：
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The function will create the specified object using a call to `new`, and since
    it takes a variable number of parameters, you can use it to call any constructor
    on the wrapped class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将使用`new`调用创建指定的对象，并且由于它接受可变数量的参数，你可以使用它来调用包装类上的任何构造函数。
- en: You can create a `shared_ptr` object from a `unique_ptr` object, which means
    that the pointer is *moved* to the new object and the reference counting control
    block created. Since the resource will now be shared, it means that there is no
    longer exclusive ownership on the resource, so the pointer in the `unique_ptr`
    object will be made a `nullptr`. This means that you can have a factory function
    that returns a pointer to an object wrapped in a `unique_ptr` object, and the
    calling code can determine if it will use a `unique_ptr` object to get exclusive
    access to the resource or a `shared_ptr` object to share it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`unique_ptr`对象创建一个`shared_ptr`对象，这意味着指针被*移动*到新对象，并创建了引用计数控制块。由于资源现在是共享的，这意味着不再具有资源的独占所有权，因此`unique_ptr`对象中的指针将被设置为`nullptr`。这意味着你可以有一个工厂函数，返回一个包装在`unique_ptr`对象中的对象的指针，调用代码可以确定是否使用`unique_ptr`对象来独占访问资源，还是使用`shared_ptr`对象来共享资源。
- en: There is little point in using `shared_ptr` for arrays of objects; there are
    much better ways to store collections of objects (`vector` or `array`). In any
    case, there is an indexing operator (`[]`) and the default deleter calls `delete`,
    not `delete[]`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象数组，使用`shared_ptr`没有太大意义；有更好的方法来存储对象的集合（`vector`或`array`）。无论如何，有一个索引运算符（`[]`），默认删除器调用`delete`，而不是`delete[]`。
- en: Handling dangling pointers
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理悬空指针
- en: 'Earlier in this book we made the point that, when you delete a resource, you
    should set the pointer to `nullptr` and you should check a pointer before using
    it to see if it is `nullptr`. This is so that you do not call a pointer to memory
    for an object that has been deleted: a dangling pointer.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前面我们指出，当删除资源时，应将指针设置为`nullptr`，并在使用指针之前检查指针是否为`nullptr`。这样可以避免调用已删除对象的内存指针：悬空指针。
- en: There are situations when a dangling pointer can occur by design. For example,
    a *parent* object may create *child* objects that have a **back pointer** to the
    parent so that the child has access to the parent. (An example of this is a window
    that creates child controls; it is often useful for the child controls to have
    access to the parent window.) The problem with using a shared pointer in this
    situation is that the parent will have a reference count on each child control
    and each child control has a reference count on the parent, and this creates a
    circular dependency.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会出现悬空指针的情况。例如，*父*对象可能会创建具有指向父对象的**后指针**的*子*对象，以便子对象可以访问父对象。（一个例子是窗口创建子控件；子控件通常可以访问父窗口。）在这种情况下使用共享指针的问题在于，父对象将对每个子控件有一个引用计数，每个子控件对父对象也有一个引用计数，这会创建一个循环依赖。
- en: Another example is if you have a container of observer objects with the intention
    of being able to inform each of these observer objects when an event occurs by
    calling a method on each one. Maintaining this list can be complicated, particularly
    if an observer object can be deleted, and hence you have to provide a means to
    remove the object from the container (where there will be a `shared_ptr` reference
    count) before you can completely delete the object. It becomes easier if your
    code can simply add a pointer to the object to the container in a way that does
    not maintain a reference count, but allows you to check when the pointer is used
    if the pointer is dangling or points to an existing object.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果你有一个观察者对象的容器，希望在事件发生时通过调用每个观察者对象的方法来通知每个观察者对象。维护这个列表可能会很复杂，特别是如果观察者对象可以被删除，因此你必须提供一种方法来从容器中删除对象（其中将有一个`shared_ptr`引用计数），然后才能完全删除对象。如果你的代码可以简单地向容器中添加一个指向对象的指针，而不维护引用计数，但允许你在使用指针时检查指针是否悬空或指向现有对象，那就更容易了。
- en: Such a pointer is called a **weak pointer** and the C++11 Standard Library provides
    a class called `weak_ptr`. You cannot use a `weak_ptr` object directly and there
    is no dereference operator. Instead, you create a `weak_ptr` object from a `shared_ptr`
    object and, when you want to access the resource, you create a `shared_ptr` object
    from the `weak_ptr` object. This means that a `weak_ptr` object has the same raw
    pointer, and access to the same control block as the `shared_ptr` object, but
    it does not take part in reference counting.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的指针称为**弱指针**，C++11标准库提供了一个名为`weak_ptr`的类。你不能直接使用`weak_ptr`对象，也没有解引用运算符。相反，你可以从`shared_ptr`对象创建一个`weak_ptr`对象，当你想要访问资源时，你可以从`weak_ptr`对象创建一个`shared_ptr`对象。这意味着`weak_ptr`对象具有相同的原始指针，并且访问相同的控制块，但它不参与引用计数。
- en: 'Once created, the `weak_ptr` object will enable you to test whether the wrapper
    pointer is to an existing resource or to a resource that has been destroyed. There
    are two ways to do this: either call the member function `expired` or attempt
    to create a `shared_ptr` from the `weak_ptr`. If you are maintaining a collection
    of `weak_ptr` objects, you may decide to periodically iterate through the collection,
    call `expired` on each one, and if the method returns `true`, remove that object
    from the collection. Since the `weak_ptr` object has access to the control block
    created by the original `shared_ptr` object, it can test to see if the reference
    count is zero.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，`weak_ptr`对象将使你能够测试包装指针是指向现有资源还是已被销毁的资源。有两种方法可以做到这一点：要么调用成员函数`expired`，要么尝试从`weak_ptr`创建一个`shared_ptr`。如果你正在维护一组`weak_ptr`对象，你可能决定定期遍历集合，对每个对象调用`expired`，如果该方法返回`true`，则从集合中删除该对象。由于`weak_ptr`对象可以访问原始`shared_ptr`对象创建的控制块，它可以测试引用计数是否为零。
- en: 'The second way to test to see if a `weak_ptr` object is dangling is to create
    a `shared_ptr` object from it. There are two options. You can create the `shared_ptr`
    object by passing the weak pointer to its constructor and if the pointer has expired,
    the constructor will throw a `bad_weak_ptr` exception. The other way is to call
    the `lock` method on the weak pointer and if the weak pointer has expired, then
    the `shared_ptr` object will be assigned to `nullptr` and you can test for this.
    These three ways are shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`weak_ptr`对象是否悬空的第二种方法是从中创建一个`shared_ptr`对象。有两种选择。你可以通过将弱指针传递给其构造函数来创建`shared_ptr`对象，如果指针已经过期，构造函数将抛出一个`bad_weak_ptr`异常。另一种方法是在弱指针上调用`lock`方法，如果弱指针已经过期，那么`shared_ptr`对象将被分配为`nullptr`，你可以测试这一点。这三种方法在这里显示：
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Since a weak pointer does not alter the reference count on a resource it means
    that you can use it for a back pointer to break the cyclic dependency (although,
    often it makes sense to use a raw pointer instead because a child object cannot
    exist without its parent object).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于弱指针不会改变资源的引用计数，这意味着你可以用它作为回指针来打破循环依赖（尽管通常更合理的是使用原始指针，因为子对象不能没有父对象而存在）。
- en: Templates
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Classes can be templated, which means that you can write generic code and the
    compiler will generate a class with the types that your code uses. The parameters
    can be types, constant integer values, or variadic versions (zero or more parameters,
    as provided by the code using the class). For example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以被模板化，这意味着你可以编写通用代码，编译器将生成一个使用你的代码类型的类。参数可以是类型、常量整数值，或者可变版本（零个或多个参数，由使用类的代码提供）。例如：
- en: '[PRE86]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here is a very simple array class that defines the basic iterator functions
    and the indexing operator, so that you can call it like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的数组类，它定义了基本的迭代器函数和索引运算符，这样你就可以像这样调用它：
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you choose to define a function out of the `class` declaration, then you
    need to give the template and its parameters as part of the `class` name:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择在`class`声明之外定义一个函数，那么你需要将模板及其参数作为`class`名称的一部分提供：
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can also have default values for template parameters:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为模板参数设置默认值：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If you think you should have a specific implementation for a template parameter,
    then you can provide the code for that version as a specialization of the template:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为应该为模板参数提供特定的实现，那么你可以将该版本的代码作为模板的特化提供：
- en: '[PRE90]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Note that, with a specialization, you do not get any code from the fully templated
    class; you have to implement all the methods you want to provide, and, as illustrated
    here, methods that are relevant to the specialization but not available on the
    fully templated class. This example is a **partial specialization**, meaning that
    it is specialized on just one parameter (`T`, the type of the data). This class
    will be used for declared variables of the type `simple_array<n, char>`, where
    `n` is an integer. You are free to have a fully specialized template, which, in
    this case, will be a specialization for a fixed size and a specified type:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用特化时，你不会从完全模板化的类中获得任何代码；你必须实现你想要提供的所有方法，并且，如本例所示，特化相关但在完全模板化类上不可用的方法。这个例子是一个**部分特化**，意味着它只是针对一个参数（`T`，数据类型）进行了特化。这个类将用于声明为类型`simple_array<n,
    char>`的变量，其中`n`是一个整数。你可以自由地拥有一个完全特化的模板，在这种情况下，它将是一个特定大小和指定类型的特化：
- en: '[PRE91]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: It is probably not useful in this case, but the idea is that there will be special
    code for variables that need 256 chars.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下可能没有用，但是想法是对需要256个字符的变量有特殊的代码。
- en: Using classes
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类
- en: The **Resource Acquisition Is Initialization** technique is useful for managing
    resources provided by other libraries, such as the C Runtime Library or the Windows
    SDK. It simplifies your code because you do not have to think about where a resource
    handle will go out of scope and provide clean-up code at every point. If the clean-up
    code is complicated, it is typical in C code to see it put at the end of a function
    and every exit point in the function will have a `goto` jump to that code. This
    results in messy code. In this example, we will wrap the C files functions with
    a class, so that the lifetime of the file handle is maintained automatically.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源获取即初始化**技术对于管理由其他库提供的资源非常有用，比如C运行时库或Windows SDK。它简化了你的代码，因为你不必考虑资源句柄何时超出范围，并在每个点提供清理代码。如果清理代码很复杂，在C代码中通常会看到它放在函数的末尾，函数中的每个退出点都会有一个`goto`跳转到该代码。这会导致混乱的代码。在这个例子中，我们将用一个类来包装C文件函数，这样文件句柄的生命周期将自动维护。'
- en: The C runtime `_findfirst` and `_findnext` functions allow you to search for
    a file or directory that matches a pattern (including wildcard symbols). The `_findfirst`
    function returns an `intptr_t`, which is relevant to just that search and this
    is passed to the `_findnext` function to get subsequent values. This `intptr_t`
    is an opaque pointer to resources that the C Runtime maintains for the search,
    and so when you are finished with the search you must call `_findclose` to clean
    up any resources associated with it. To prevent memory leaks, it is important
    to call `_findclose`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时的`_findfirst`和`_findnext`函数允许你搜索与模式匹配的文件或目录（包括通配符）。`_findfirst`函数返回一个`intptr_t`，这与搜索相关，然后将其传递给`_findnext`函数以获取后续值。这个`intptr_t`是一个不透明指针，指向C运行时为搜索维护的资源，所以当你完成搜索时，你必须调用`_findclose`来清理与之相关的任何资源。为了防止内存泄漏，调用`_findclose`非常重要。
- en: 'Under the `Beginning_C++` folder, create a folder called `Chapter_06`. In Visual
    C++, create a new C++ source file, save it to the `Chapter_06` folder, and call
    it `search.cpp`. The application will use the Standard Library console and strings,
    and it will use the C Runtime file functions, so add these lines to the top of
    the file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Beginning_C++`文件夹下，创建一个名为`Chapter_06`的文件夹。在Visual C++中，创建一个新的C++源文件，将其保存到`Chapter_06`文件夹中，并将其命名为`search.cpp`。该应用程序将使用标准库控制台和字符串，并且将使用C运行时文件函数，因此在文件顶部添加这些行：
- en: '[PRE92]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The application will be called with a file search pattern and it will use the
    C functions to search for files, so you will need a `main` function that has parameters.
    Add the following to the bottom of the file:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用文件搜索模式调用，并使用C函数搜索文件，因此您需要一个具有参数的`main`函数。在文件底部添加以下内容：
- en: '[PRE93]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first thing is to create a wrapper class for the search handle that will
    manage this resource. Above the usage function, add a class called `search_handle`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要创建一个包装类来管理搜索句柄的资源。在使用函数上方，添加一个名为`search_handle`的类：
- en: '[PRE94]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This class has a separate function to release the handle. This is so that a
    user of this class can release the wrapper resource as soon as possible. If the
    object is used in code that could throw an exception, the `close` method won't
    be called directly, but the destructor will be called instead. The wrapper object
    can be created with a `intptr_t` value. If this value is -1, then the handle is
    invalid, so the close method will only call `_findclose` if the handle does not
    have this value.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此类有一个单独的函数来释放句柄。这样，该类的用户可以尽快释放包装资源。如果对象用于可能引发异常的代码中，则`close`方法不会直接调用，而是将调用析构函数。包装对象可以使用`intptr_t`值创建。如果此值为-1，则句柄无效，因此仅当句柄不具有此值时，`close`方法才会调用`_findclose`。
- en: 'We want objects of this class to have exclusive ownership of the handle, so
    delete the copy constructor and copy assignment by putting the following in the
    public part of the class:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望该类的对象具有句柄的独占所有权，因此通过将以下内容放入类的`public`部分来删除复制构造函数和复制赋值：
- en: '[PRE95]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If an object is moved, then any handle in the existing object must be released,
    so add the following after the lines you just added:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象被移动，那么现有对象中的任何句柄都必须被释放，因此在刚刚添加的行之后添加以下内容：
- en: '[PRE96]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The wrapper class will be allocated by a call to `_findfirst` and will be passed
    to a call to `_findnext`, so the wrapper class needs two operators: one to convert
    to an `intptr_t`, so objects of this class can be used wherever an `intptr_t`
    is needed, and the other so that object can be used when a `bool` is needed. Add
    these to the `public` part of the class:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类将通过调用`_findfirst`分配，并将传递给调用`_findnext`，因此包装类需要两个运算符：一个用于转换为`intptr_t`，以便可以在需要`intptr_t`的任何地方使用此类的对象，另一个用于在需要`bool`时使用对象。将这些添加到类的`public`部分：
- en: '[PRE97]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The conversion to `bool` allows you to write code like this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将转换为`bool`允许您编写如下代码：
- en: '[PRE98]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If you have a conversion operator that returns a pointer, then the compiler
    will call this in preference to the conversion to `bool`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个返回指针的转换运算符，那么编译器将优先调用它，而不是转换为`bool`。
- en: You should be able to compile this code (remember to use the `/EHsc` switch)
    to confirm that there are no typos.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够编译此代码（记得使用`/EHsc`开关）以确认没有拼写错误。
- en: 'Next, write a wrapper class to perform the search. Below the `search_handle`
    class, add a `file_search` class:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个包装类来执行搜索。在`search_handle`类下方，添加一个`file_search`类：
- en: '[PRE99]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This class is created with the search criteria, and we have the option of passing
    a C or C++ string. The class has a `search_handle` data member, and, since the
    default destructor will call the destructor of member objects, we do not need
    to provide a destructor ourselves. However, we will add a `close` method so that
    a user can explicitly release resources. Furthermore, so that users of the class
    can determine the search path, we need an accessor. At the bottom of the class,
    add the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 该类是使用搜索条件创建的，我们可以选择传递C或C++字符串。该类有一个`search_handle`数据成员，并且，由于默认析构函数将调用成员对象的析构函数，因此我们不需要自己提供析构函数。但是，我们将添加一个`close`方法，以便用户可以显式释放资源。此外，为了使该类的用户能够确定搜索路径，我们需要一个访问器。在类的底部添加以下内容：
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We do not want instances of the `file_search` object to be copied because that
    would mean two copies of the search handle. You could delete the copy constructor
    and assignment operator, but there is no need. Try this: in the `main` function,
    add this test code (it does not matter where):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望复制`file_search`对象的实例，因为这意味着搜索句柄的两个副本。您可以删除复制构造函数和赋值运算符，但没有必要。尝试这样做：在`main`函数中，添加此测试代码（位置无关紧要）：
- en: '[PRE101]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Compile the code. You''ll get an error and an explanation:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码。您将收到一个错误和一个解释：
- en: '[PRE102]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Without a copy constructor, the compiler will generate one (this is the second
    line). The first line is a bit odd because it is saying that you are trying to
    call a deleted method that the compiler has generated! In fact, the error is saying
    that the generated copy constructor is attempting to copy the `handle` data member
    and the `search_handle` copy constructor that has been deleted. Thus you are protected
    against copying `file_search` objects without adding any other code. Delete the
    test lines you just added.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 没有复制构造函数，编译器将生成一个（这是第二行）。第一行有点奇怪，因为它说您正在尝试调用编译器生成的已删除方法！实际上，错误是说生成的复制构造函数正在尝试复制`handle`数据成员和已删除的`search_handle`复制构造函数。因此，您受到保护，防止复制`file_search`对象而无需添加任何其他代码。删除刚添加的测试行。
- en: Next add the following lines to the bottom of the `main` function. This will
    create a `file_search` object and print out information to the console.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在`main`函数的底部添加以下行。这将创建一个`file_search`对象并将信息打印到控制台。
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then you need to add code to perform the search. The pattern used here will
    be a method that has an out parameter and returns a `bool`. If a call to the method
    succeeds, then the file found will be returned in the out parameter and the method
    will return `true`. If the call fails, then the out parameter is left untouched
    and the method returns `false`. In the `public` section of the `file_search` class,
    add this function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要添加代码来执行搜索。这里使用的模式将是一个具有输出参数并返回`bool`的方法。如果方法调用成功，则找到的文件将在输出参数中返回，并且该方法将返回`true`。如果调用失败，则输出参数将保持不变，并且该方法将返回`false`。在`file_search`类的`public`部分中，添加此函数：
- en: '[PRE104]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If this is the first call to this method, then `handle` will be invalid and
    so `_findfirst` is called. This will fill a `_finddata_t` structure with the results
    of the search and return an `intptr_t` value. The `search_handle` object data
    member is assigned to this value returned from this function, and if `_findfirst`
    returns `-1`, the method returns `false`. If the call is successful, then the
    out parameter (a reference to a `string`) is initialized using a C string pointer
    in the `_finddata_t` structure.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是对该方法的第一次调用，则`handle`将无效，因此将调用`_findfirst`。这将使用搜索结果填充`_finddata_t`结构并返回一个`intptr_t`值。`search_handle`对象的数据成员被赋予此函数返回的值，如果`_findfirst`返回`-1`，则该方法返回`false`。如果调用成功，则使用`_finddata_t`结构中的C字符串指针初始化输出参数（指向`string`的引用）。
- en: If there are more files that match the pattern, then you can call the `next`
    function repeatedly, and on these subsequent calls the `_findnext` function is
    called to get the next file. In this case the `search_handle` object is passed
    to the function and there is an implicit conversion to `intptr_t` through the
    class's conversion operator. If the `_findnext` function returns `-1`, it means
    there are no more files in the search.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多与模式匹配的文件，那么可以重复调用`next`函数，在这些后续调用中，将调用`_findnext`函数以获取下一个文件。在这种情况下，`search_handle`对象被传递给函数，并通过类的转换运算符隐式转换为`intptr_t`。如果`_findnext`函数返回`-1`，这意味着搜索中没有更多文件。
- en: 'At the bottom of the `main` function, add the following lines to perform the
    search:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的底部，添加以下行以执行搜索：
- en: '[PRE105]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now you can compile the code and run it with a search criterion. Bear in mind
    that this is constrained by the facilities of the `_findfirst`/`_findnext` functions,
    so the searches you can do will be quite simple. Try running this at the command
    line with a parameter to search for the subfolders in the `Beginning_C++` folder:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编译代码并使用搜索条件运行它。请记住，这受到`_findfirst`/`_findnext`函数的限制，因此您可以进行的搜索将非常简单。尝试在命令行中运行此代码，并使用参数搜索`Beginning_C++`文件夹中的子文件夹：
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This will give a list of the subfolders starting with `Ch`. Since there is no
    reason for `search_handle` to be a separate class, move the entire class to the
    `private` section of the `search_handle`, above the declaration of the `handle`
    data member. Compile and run the code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以`Ch`开头的子文件夹列表。由于没有理由让`search_handle`成为一个单独的类，将整个类移到`search_handle`的`private`部分，在`handle`数据成员的声明之上。编译并运行代码。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With classes, C++ provides a powerful and flexible mechanism to encapsulate
    data and methods to provide behavior that acts on the data. You can template this
    code so that you can write generic code and get the compiler to generate code
    for the types that you require. In the example, you have seen how classes are
    the basis of object orientation. A class encapsulates data, so that the caller
    only needs to know about the expected behavior (in this example, getting the next
    result in a search), without needing to know the details of how the class does
    this. In the next chapter, we will investigate further features of classes; in
    particular, code reuse through inheritance.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类，C++提供了一个强大而灵活的机制，用于封装数据和方法，以提供作用于数据的行为。您可以将此代码模板化，以便编写通用代码，并让编译器为您需要的类型生成代码。在本例中，您已经看到了类是面向对象的基础。类封装数据，使得调用者只需要了解预期的行为（在本例中是获取搜索中的下一个结果），而无需了解类如何实现这一点的细节。在下一章中，我们将进一步研究类的其他特性；特别是通过继承实现代码重用。
