["```cpp\n    #include <iostream>\n    template <typename T>\n    struct cir_list_node\n    {\n    \u00a0\u00a0\u00a0\u00a0T* data;\n    \u00a0\u00a0\u00a0\u00a0cir_list_node *next, *prev;\n\n    ~cir_list_node()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete data;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    template <typename T>\n    struct cir_list\n    {\n    \u00a0\u00a0\u00a0\u00a0public:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0using node = cir_list_node<T>;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0using node_ptr = node*;\n    \u00a0\u00a0\u00a0\u00a0private:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node_ptr head;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t n;\n    ```", "```cpp\n    public:\n    cir_list(): n(0)\n    {\n    \u00a0\u00a0\u00a0\u00a0head = new node{NULL, NULL, NULL};\u00a0\u00a0// Dummy node \u2013 having NULL data\n    \u00a0\u00a0\u00a0\u00a0head->next = head;\n    \u00a0\u00a0\u00a0\u00a0head->prev = head;\n    }\n    size_t size() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return n;\n    }\n    ```", "```cpp\n    void insert(const T& value)\n    {\n    \u00a0\u00a0\u00a0\u00a0node_ptr newNode = new node{new T(value), NULL, NULL};\n    \u00a0\u00a0\u00a0\u00a0n++;\n    auto dummy = head->prev;\n    dummy->next = newNode;\n    newNode->prev = dummy;\n    \u00a0\u00a0\u00a0\u00a0if(head == dummy)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dummy->prev = newNode;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode->next = dummy;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0head = newNode;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0newNode->next = head;\n    \u00a0\u00a0\u00a0\u00a0head->prev = newNode;\n    \u00a0\u00a0\u00a0\u00a0head = newNode;\n    }\n    void erase(const T& value)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto cur = head, dummy = head->prev;\n    \u00a0\u00a0\u00a0\u00a0while(cur != dummy)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(*(cur->data) == value)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur->prev->next = cur->next;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur->next->prev = cur->prev;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(cur == head)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0head = head->next;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete cur;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n--;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = cur->next;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    struct cir_list_it\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0node_ptr ptr;\n    public:\n    \u00a0\u00a0\u00a0\u00a0cir_list_it(node_ptr p) : ptr(p)\n    \u00a0\u00a0\u00a0\u00a0{}\n\n    \u00a0\u00a0\u00a0\u00a0T& operator*()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *(ptr->data);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0node_ptr get()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ptr;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    cir_list_it& operator++()\n    {\n    \u00a0\u00a0\u00a0\u00a0ptr = ptr->next;\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    cir_list_it operator++(int)\n    {\n    \u00a0\u00a0\u00a0\u00a0cir_list_it it = *this;\n    \u00a0\u00a0\u00a0\u00a0++(*this);\n    \u00a0\u00a0\u00a0\u00a0return it;\u00a0\u00a0\u00a0\u00a0\n    }\n    ```", "```cpp\n    cir_list_it& operator--()\n    {\n    \u00a0\u00a0\u00a0\u00a0ptr = ptr->prev;\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    cir_list_it operator--(int)\n    {\n    \u00a0\u00a0\u00a0\u00a0cir_list_it it = *this;\n    \u00a0\u00a0\u00a0\u00a0--(*this);\n    \u00a0\u00a0\u00a0\u00a0return it;\n    }\n    ```", "```cpp\n    friend bool operator==(const cir_list_it& it1, const cir_list_it& it2)\n    {\n    \u00a0\u00a0\u00a0\u00a0return it1.ptr == it2.ptr;\n    }\n    friend bool operator!=(const cir_list_it& it1, const cir_list_it& it2)\n    {\n    \u00a0\u00a0\u00a0\u00a0return it1.ptr != it2.ptr;\n    }\n    };\n    ```", "```cpp\n    cir_list_it begin()\n    {\n    \u00a0\u00a0\u00a0\u00a0return cir_list_it{head};\n    }\n    cir_list_it begin() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return cir_list_it{head};\n    }\n    cir_list_it end()\n    {\n    \u00a0\u00a0\u00a0\u00a0return cir_list_it{head->prev};\n    }\n    cir_list_it end() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return cir_list_it{head->prev};\n    }\n    ```", "```cpp\n    cir_list(const cir_list<T>& other): cir_list()\n    {\n    // Although, the following will insert the elements in a reverse order, it won't matter in a logical sense since this is a circular list.\n    \u00a0\u00a0\u00a0\u00a0for(const auto& i: other)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0insert(i);\n    }\n    cir_list(const std::initializer_list<T>& il): head(NULL), n(0)\n    {\n\n    // Although, the following will insert the elements in a reverse order, it won't matter in a logical sense since this is a circular list.\n    \u00a0\u00a0\u00a0\u00a0for(const auto& i: il)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0insert(i);\n    }\n    ~cir_list()\n    {\n    \u00a0\u00a0\u00a0\u00a0while(size())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0erase(head->data);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    };\n    ```", "```cpp\n    struct playlist\n    {\n    \u00a0\u00a0\u00a0\u00a0cir_list<int> list;\n    ```", "```cpp\n    void insert(int song)\n    {\n    \u00a0\u00a0\u00a0\u00a0list.insert(song);\n    }\n    void erase(int song)\n    {\n    \u00a0\u00a0\u00a0\u00a0list.erase(song);\n    }\n    ```", "```cpp\n    void loopOnce()\n    {\n    \u00a0\u00a0\u00a0\u00a0for(auto& song: list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << song << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0playlist pl;\n    \u00a0\u00a0\u00a0\u00a0pl.insert(1);\n    \u00a0\u00a0\u00a0\u00a0pl.insert(2);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Playlist: \";\n    \u00a0\u00a0\u00a0\u00a0pl.loopOnce();\n    \u00a0\u00a0\u00a0\u00a0playlist pl2 = pl;\n    \u00a0\u00a0\u00a0\u00a0pl2.erase(2);\n    \u00a0\u00a0\u00a0\u00a0pl2.insert(3);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Second playlist: \";\n    \u00a0\u00a0\u00a0\u00a0pl2.loopOnce();\n    }\n    ```", "```cpp\n    Playlist: 2 1 \n    Second playlist: 3 1\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <array>\n    #include <sstream>\n    #include <algorithm>\n    #include <random>\n    #include <chrono>\n    ```", "```cpp\n    struct card\n    {\n    \u00a0\u00a0\u00a0\u00a0int number;\n    \u00a0\u00a0\u00a0\u00a0enum suit\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HEART,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SPADE,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CLUB,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DIAMOND\n    \u00a0\u00a0\u00a0\u00a0} suit;\n    \u00a0\u00a0\u00a0\u00a0std::string to_string() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::ostringstream os;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(number > 0 && number <= 10)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << number;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    {\n    switch(number)\n    {\n    case 1:\n    \u00a0\u00a0\u00a0\u00a0os << \"Ace\";\n    \u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0case 11:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"Jack\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0case 12:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"Queen\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0case 13:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"King\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0default:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return \"Invalid card\";\n    }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \" of \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(suit)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case HEART:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"hearts\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case SPADE:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"spades\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case CLUB:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"clubs\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case DIAMOND:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"diamonds\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return os.str();\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    struct game\n    {\n    \u00a0\u00a0\u00a0\u00a0std::array<card, 52> deck;\n    \u00a0\u00a0\u00a0\u00a0std::vector<card> player1, player2, player3, player4;\n    \u00a0\u00a0\u00a0\u00a0void buildDeck()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < 13; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0deck[i] = card{i + 1, card::HEART};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < 13; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0deck[i + 13] = card{i + 1, card::SPADE};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < 13; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0deck[i + 26] = card{i + 1, card::CLUB};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < 13; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0deck[i + 39] = card{i + 1, card::DIAMOND};\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void dealCards()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::shuffle(deck.begin(), deck.end(), std::default_random_engine(seed));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0player1 = {deck.begin(), deck.begin() + 13};\n    player2 = {deck.begin() + 13, deck.begin() + 26};\n    player3 = {deck.begin() + 26, deck.begin() + 39};\n    player4 = {deck.begin() + 39, deck.end()};\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    bool compareAndRemove(std::vector<card>& p1, std::vector<card>& p2)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(p1.back().number == p2.back().number)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p1.pop_back();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p2.pop_back();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    void playOneRound()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(compareAndRemove(player1, player2))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compareAndRemove(player3, player4);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if(compareAndRemove(player1, player3))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compareAndRemove(player2, player4);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if(compareAndRemove(player1, player4))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compareAndRemove(player2, player3);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if(compareAndRemove(player2, player3))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if(compareAndRemove(player2, player4))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if(compareAndRemove(player3, player4))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::shuffle(player1.begin(), player1.end(), std::default_random_engine(seed));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::shuffle(player2.begin(), player2.end(), std::default_random_engine(seed));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::shuffle(player3.begin(), player3.end(), std::default_random_engine(seed));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::shuffle(player4.begin(), player4.end(), std::default_random_engine(seed));\n    }\n    ```", "```cpp\n    bool isGameComplete() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return player1.empty() || player2.empty() || player3.empty() || player4.empty();\n    }\n    void playGame()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(not isGameComplete())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0playOneRound();\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int getWinner() const\n    {\n    \u00a0\u00a0\u00a0\u00a0if(player1.empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n    \u00a0\u00a0\u00a0\u00a0if(player2.empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 2;\n    \u00a0\u00a0\u00a0\u00a0if(player3.empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 3;\n    \u00a0\u00a0\u00a0\u00a0if(player4.empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 4;\n    }\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0game newGame;\n    \u00a0\u00a0\u00a0\u00a0newGame.buildDeck();\n    \u00a0\u00a0\u00a0\u00a0newGame.dealCards();\n    \u00a0\u00a0\u00a0\u00a0newGame.playGame();\n    \u00a0\u00a0\u00a0\u00a0auto winner = newGame.getWinner();\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Player \" << winner << \" won the game.\" << std::endl;\n    }\n    ```", "```cpp\n    Player 4 won the game.\n    ```", "```cpp\n    #include <iostream>\n    #include <queue>\n    ```", "```cpp\n    class Job\n    {\n    \u00a0\u00a0\u00a0\u00a0int id;\n    \u00a0\u00a0\u00a0\u00a0std::string user;\n    \u00a0\u00a0\u00a0\u00a0int time;\n    \u00a0\u00a0\u00a0\u00a0static int count;\n    public:\n    \u00a0\u00a0\u00a0\u00a0Job(const std::string& u, int t) : user(u), time(t), id(++count)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<<(std::ostream& os, const Job& j)\n    \u00a0\u00a0\u00a0\u00a0 {\n    \u00a0\u00a0\u00a0\u00a0os << \"id: \" << id << \", user: \" << user << \", time: \" << time << \" seconds\" << std::endl;\u00a0\u00a0\u00a0\u00a0return os;\n    \u00a0\u00a0\u00a0\u00a0 }\n    };\n    int Job::count = 0;\n    ```", "```cpp\n    template <size_t N>\n    class Printer\n    {\n    \u00a0\u00a0\u00a0\u00a0std::queue<Job> jobs;\n    public:\n    \u00a0\u00a0\u00a0\u00a0bool addNewJob(const Job& job)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(jobs.size() == N)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Added job in the queue: \" << job;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jobs.push(job);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void startPrinting()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(not jobs.empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Processing job: \" << jobs.front();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jobs.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0Printer<5> printer;\n    \u00a0\u00a0\u00a0\u00a0Job j1(\"John\", 10);\n    \u00a0\u00a0\u00a0\u00a0Job j2(\"Jerry\", 4);\n    \u00a0\u00a0\u00a0\u00a0Job j3(\"Jimmy\", 5);\n    \u00a0\u00a0\u00a0\u00a0Job j4(\"George\", 7);\n    \u00a0\u00a0\u00a0\u00a0Job j5(\"Bill\", 8);\n    \u00a0\u00a0\u00a0\u00a0Job j6(\"Kenny\", 10);\n    \u00a0\u00a0\u00a0\u00a0printer.addNewJob(j1);\n    \u00a0\u00a0\u00a0\u00a0printer.addNewJob(j2);\n    \u00a0\u00a0\u00a0\u00a0printer.addNewJob(j3);\n    \u00a0\u00a0\u00a0\u00a0printer.addNewJob(j4);\n    \u00a0\u00a0\u00a0\u00a0printer.addNewJob(j5);\n    \u00a0\u00a0\u00a0\u00a0if(not printer.addNewJob(j6))\u00a0\u00a0// Can't add as queue is full.\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't add 6th job\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0printer.startPrinting();\n\n    \u00a0\u00a0\u00a0\u00a0printer.addNewJob(j6);\u00a0\u00a0// Can add now, as queue got emptied\n    \u00a0\u00a0\u00a0\u00a0printer.startPrinting();\n    }\n    ```", "```cpp\n    Added job in the queue: id: 1, user: John, time: 10 seconds\n    Added job in the queue: id: 2, user: Jerry, time: 4 seconds\n    Added job in the queue: id: 3, user: Jimmy, time: 5 seconds\n    Added job in the queue: id: 4, user: George, time: 7 seconds\n    Added job in the queue: id: 5, user: Bill, time: 8 seconds\n    Couldn't add 6th job\n    Processing job: id: 1, user: John, time: 10 seconds\n    Processing job: id: 2, user: Jerry, time: 4 seconds\n    Processing job: id: 3, user: Jimmy, time: 5 seconds\n    Processing job: id: 4, user: George, time: 7 seconds\n    Processing job: id: 5, user: Bill, time: 8 seconds\n    Added job in the queue: id: 6, user: Kenny, time: 10 seconds\n    Processing job: id: 6, user: Kenny, time: 10 seconds\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    ```", "```cpp\n    struct n_ary_node\n    {\n    \u00a0\u00a0\u00a0\u00a0std::string name;\n    \u00a0\u00a0\u00a0\u00a0bool is_dir;\n    \u00a0\u00a0\u00a0\u00a0std::vector<n_ary_node*> children;\n    };\n    ```", "```cpp\n    struct file_system\n    {\n    \u00a0\u00a0\u00a0\u00a0using node = n_ary_node;\n    \u00a0\u00a0\u00a0\u00a0using node_ptr = node*;\n    private:\n    \u00a0\u00a0\u00a0\u00a0node_ptr root;\n    \u00a0\u00a0\u00a0\u00a0node_ptr cwd;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0file_system()\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = new node{\"/\", true, {}};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cwd = root;\u00a0\u00a0// We'll keep the current directory as root in the beginning\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    node_ptr find(const std::string& path)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(path[0] == '/')\u00a0\u00a0// Absolute path\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return find_impl(root, path.substr(1));\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return find_impl(cwd, path);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    private:\n    node_ptr find_impl(node_ptr directory, const std::string& path)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(path.empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return directory;\n    \u00a0\u00a0\u00a0\u00a0auto sep = path.find('/');\n    \u00a0\u00a0\u00a0\u00a0std::string current_path = sep == std::string::npos ? path : path.substr(0, sep);\n    \u00a0\u00a0\u00a0\u00a0std::string rest_path = sep == std::string::npos ? \"\" : path.substr(sep + 1);\n    \u00a0\u00a0\u00a0\u00a0auto found = std::find_if(directory->children.begin(), directory->children.end(), [&](const node_ptr child)\n    {\n    \u00a0\u00a0\u00a0\u00a0return child->name == current_path;\n    });\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(found != directory->children.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return find_impl(*found, rest_path);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return NULL;\n    }\n    ```", "```cpp\n    public:\n    bool add(const std::string& path, bool is_dir)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(path[0] == '/')\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return add_impl(root, path.substr(1), is_dir);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return add_impl(cwd, path, is_dir);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    private:\n    bool add_impl(node_ptr directory, const std::string& path, bool is_dir)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(not directory->is_dir)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << directory->name << \" is a file.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    auto sep = path.find('/');\n    // This is the last part of the path for adding directory. It's a base condition of the recursion\n    \u00a0\u00a0\u00a0\u00a0if(sep == std::string::npos)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto found = std::find_if(directory->children.begin(), directory->children.end(), [&](const node_ptr child)\n    {\n    \u00a0\u00a0\u00a0\u00a0return child->name == path;\n    });\n    if(found != directory->children.end())\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"There's already a file/directory named \" << path << \" inside \" << directory->name << \".\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    directory->children.push_back(new node{path, is_dir, {}});\n    return true;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0// If the next segment of the path is still a directory\n    \u00a0\u00a0\u00a0\u00a0std::string next_dir = path.substr(0, sep);\n    \u00a0\u00a0\u00a0\u00a0auto found = std::find_if(directory->children.begin(), directory->children.end(), [&](const node_ptr child)\n    {\n    \u00a0\u00a0\u00a0\u00a0return child->name == next_dir && child->is_dir;\n    });\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(found != directory->children.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return add_impl(*found, path.substr(sep + 1), is_dir);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\n    std::cout << \"There's no directory named \" << next_dir << \" inside \" << directory->name << \".\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    public:\n    bool change_dir(const std::string& path)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto found = find(path);\n    \u00a0\u00a0\u00a0\u00a0if(found && found->is_dir)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cwd = found;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Current working directory changed to \" << cwd->name << \".\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Path not found.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    public:\n    void show_path(const std::string& path)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto found = find(path);\n    \u00a0\u00a0\u00a0\u00a0if(not found)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"No such path: \" << path << \".\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(found->is_dir)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto child: found->children)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    std::cout << (child->is_dir ? \"d \" : \"- \") << child->name << std::endl;}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"- \" << found->name << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0file_system fs;\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"usr\", true);\u00a0\u00a0// Add directory usr in \"/\"\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"etc\", true);\u00a0\u00a0// Add directory etc in \"/\"\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"var\", true);\u00a0\u00a0// Add directory var in \"/\"\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"tmp_file\", false);\u00a0\u00a0// Add file tmp_file in \"/\"\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Files/Directories under \\\"/\\\"\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0fs.show_path(\"/\");\u00a0\u00a0// List files/directories in \"/\"\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    \u00a0\u00a0\u00a0\u00a0fs.change_dir(\"usr\");\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"Packt\", true);\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"Packt/Downloads\", true);\n    \u00a0\u00a0\u00a0\u00a0fs.add(\"Packt/Downloads/newFile.cpp\", false);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Let's see the contents of dir usr: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0fs.show_path(\"usr\");\u00a0\u00a0// This will not print the path successfully, since we're already inside the dir usr. And there's no directory named usr inside it.\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Let's see the contents of \\\"/usr\\\"\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0fs.show_path(\"/usr\");\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Let's see the contents of \\\"/usr/Packt/Downloads\\\"\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0fs.show_path(\"/usr/Packt/Downloads\");\n\n    }\n    ```", "```cpp\n    Files/Directories under \"/\"\n    d usr\n    d etc\n    d var\n    - tmp_file\n    Current working directory changed to usr.\n    Let's try to print the contents of usr: \n    No such path: usr.\n    Let's see the contents of \"/usr\"\n    d Packt\n    Contents of \"/usr/Packt/Downloads\"\n    - newFile.cpp\n    ```", "```cpp\n    #include <iostream>\n    #include <algorithm>\n    #include <vector>\n    ```", "```cpp\n    struct node\n    {\n    \u00a0\u00a0\u00a0\u00a0int data;\n    \u00a0\u00a0\u00a0\u00a0int listPosition;\n    \u00a0\u00a0\u00a0\u00a0int dataPosition;\n    };\n    std::vector<int> merge(const std::vector<std::vector<int>>& input)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto comparator = [] (const node& left, const node& right)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(left.data == right.data)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return left.listPosition > right.listPosition;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return left.data > right.data;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\n    ```", "```cpp\n    std::vector<node> heap;\n    for(int i = 0; i < input.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0heap.push_back({input[i][0], i, 0});\n    \u00a0\u00a0\u00a0\u00a0std::push_heap(heap.begin(), heap.end(), comparator);\n    }\n    ```", "```cpp\n    std::vector<int> result;\n    while(!heap.empty())\n    {\n    \u00a0\u00a0\u00a0\u00a0std::pop_heap(heap.begin(), heap.end(), comparator);\n    \u00a0\u00a0\u00a0\u00a0auto min = heap.back();\n    \u00a0\u00a0\u00a0\u00a0heap.pop_back();\n    \u00a0\u00a0\u00a0\u00a0result.push_back(min.data);\n    \u00a0\u00a0\u00a0\u00a0int nextIndex = min.dataPosition + 1;\n    \u00a0\u00a0\u00a0\u00a0if(nextIndex < input[min.listPosition].size())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap.push_back({input[min.listPosition][nextIndex], min.listPosition, nextIndex});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::push_heap(heap.begin(), heap.end(), comparator);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return result;\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> v1 = {1, 3, 8, 15, 105};\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> v2 = {2, 3, 10, 11, 16, 20, 25};\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> v3 = {-2, 100, 1000};\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> v4 = {-1, 0, 14, 18};\n    \u00a0\u00a0\u00a0\u00a0auto result = merge({v1, v2, v3, v4});\n    \u00a0\u00a0\u00a0\u00a0for(auto i: result)\n    \u00a0\u00a0\u00a0\u00a0std::cout << i << ' ';\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    -2 -1 0 1 2 3 3 8 10 11 14 15 16 18 20 25 100 105 1000 \n    ```", "```cpp\n    #include <iostream>\n    #include <unordered_map>\n    ```", "```cpp\n    struct URLService\n    {\n    \u00a0\u00a0\u00a0\u00a0using ActualURL = std::string;\n    \u00a0\u00a0\u00a0\u00a0using TinyURL = std::string;\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::unordered_map<TinyURL, ActualURL> data;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0std::pair<bool, ActualURL> lookup(const TinyURL& url) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto it = data.find(url);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(it == data.end())\u00a0\u00a0// If small URL is not registered.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::make_pair(false, std::string());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::make_pair(true, it->second);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    bool registerURL(const ActualURL& actualURL, const TinyURL& tinyURL)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto found = lookup(tinyURL).first;\n    \u00a0\u00a0\u00a0\u00a0if(found)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0data[tinyURL] = actualURL;\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    bool deregisterURL(const TinyURL& tinyURL)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto found = lookup(tinyURL).first;\n    \u00a0\u00a0\u00a0\u00a0if(found)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data.erase(tinyURL);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    void printURLs() const\n    {\n    \u00a0\u00a0\u00a0\u00a0for(const auto& entry: data)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << entry.first << \" -> \" << entry.second << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0URLService service;\n    \u00a0\u00a0\u00a0\u00a0if(service.registerURL(\"https://www.packtpub.com/eu/big-data-and-business-intelligence/machine-learning-r-third-edition\", \"https://ml-r-v3\"))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Registered https://ml-r-v3\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't register https://ml-r-v3\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(service.registerURL(\"https://www.packtpub.com/eu/virtualization-and-cloud/hands-aws-penetration-testing-kali-linux\", \"https://aws-test-kali\"))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Registered https://aws-test-kali\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't register https://aws-test-kali\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(service.registerURL(\"https://www.packtpub.com/eu/application-development/hands-qt-python-developers\", \"https://qt-python\"))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Registered https://qt-python\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't register https://qt-python\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0auto findMLBook = service.lookup(\"https://ml-r-v3\");\n    \u00a0\u00a0\u00a0\u00a0if(findMLBook.first)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Actual URL: \" << findMLBook.second << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't find URL for book for ML.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0auto findReactBook = service.lookup(\"https://react-cookbook\");\n    \u00a0\u00a0\u00a0\u00a0if(findReactBook.first)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Actual URL: \" << findReactBook.second << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't find URL for book for React.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(service.deregisterURL(\"https://qt-python\"))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Deregistered qt python link\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't deregister qt python link\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0auto findQtBook = service.lookup(\"https://qt-python\");\n    \u00a0\u00a0\u00a0\u00a0if(findQtBook.first)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Actual URL: \" << findQtBook.second << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Couldn't find Qt Python book\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"List of registered URLs: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0service.printURLs();\n    }\n    ```", "```cpp\n    Registered https://ml-r-v3\n    Registered https://aws-test-kali\n    Registered https://qt-python\n    Actual URL: https://www.packtpub.com/eu/big-data-and-business-intelligence/machine-learning-r-third-edition\n    Couldn't find URL for book for React.\n    Deregistered qt python link\n    Couldn't find Qt Python book\n    List of registered URLs: \n    https://ml-r-v3 -> https://www.packtpub.com/eu/big-data-and-business-intelligence/machine-learning-r-third-edition\n    https://aws-test-kali -> https://www.packtpub.com/eu/virtualization-and-cloud/hands-aws-penetration-testing-kali-linux\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <openssl/md5.h>\n    ```", "```cpp\n    class BloomFilter\n    {\n    \u00a0\u00a0\u00a0\u00a0int nHashes;\n    \u00a0\u00a0\u00a0\u00a0std::vector<bool> bits;\n    \u00a0\u00a0\u00a0\u00a0static constexpr int hashSize = 128/8;\n    \u00a0\u00a0\u00a0\u00a0unsigned char hashValue[hashSize];\n    ```", "```cpp\n    BloomFilter(int size, int hashes) : bits(size), nHashes(hashes)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(nHashes > hashSize)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw (\"Number of hash functions too high\");\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(size > 255)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw (\"Size of bloom filter can't be >255\");\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void hash(const std::string& key)\n    {\n    \u00a0\u00a0\u00a0\u00a0MD5(reinterpret_cast<const unsigned char*>(key.data()), key.length(), hashValue);\n    }\n    ```", "```cpp\n    void add(const std::string& key)\n    {\n    \u00a0\u00a0\u00a0\u00a0hash(key);\n    \u00a0\u00a0\u00a0\u00a0for(auto\u00a0it\u00a0=\u00a0&hashValue[0];\u00a0it\u00a0<\u00a0&hashValue[nHashes];\u00a0it++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bits[*it]\u00a0=\u00a0true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0std::cout\u00a0<<\u00a0key\u00a0<<\u00a0\"\u00a0added\u00a0in\u00a0bloom\u00a0filter.\"\u00a0<<\u00a0std::endl;\n    }\n    ```", "```cpp\n    bool mayContain(const std::string &key)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hash(key);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto it = &hashValue[0]; it < &hashValue[nHashes]; it++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!bits[*it])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << key << \" email can by used.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << key << \" email is used by someone else.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0BloomFilter bloom(10, 15);\n    \u00a0\u00a0\u00a0\u00a0bloom.add(\"abc@packt.com\");\n    \u00a0\u00a0\u00a0\u00a0bloom.add(\"xyz@packt.com\");\n    \u00a0\u00a0\u00a0\u00a0bloom.mayContain(\"abc\");\n    \u00a0\u00a0\u00a0\u00a0bloom.mayContain(\"xyz@packt.com\");\n    \u00a0\u00a0\u00a0\u00a0bloom.mayContain(\"xyz\");\n    \u00a0\u00a0\u00a0\u00a0bloom.add(\"abcd@packt.com\");\n    \u00a0\u00a0\u00a0\u00a0bloom.add(\"ab@packt.com\");\n    \u00a0\u00a0\u00a0\u00a0bloom.mayContain(\"abc\");\n    \u00a0\u00a0\u00a0\u00a0bloom.mayContain(\"ab@packt.com\");\n    }\n    ```", "```cpp\n    abc@packt.com added in bloom filter.\n    xyz@packt.com added in bloom filter.\n    abc email can by used.\n    xyz@packt.com email is used by someone else.\n    xyz email can by used.\n    abcd@packt.com added in bloom filter.\n    ab@packt.com added in bloom filter.\n    abcd email can by used.\n    ab@packt.com email is used by someone else.\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    #include <numeric>\n    ```", "```cpp\n    class Student\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::pair<int, int> name;\n    \u00a0\u00a0\u00a0\u00a0bool vaccinated;\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Constructor\n    \u00a0\u00a0\u00a0\u00a0Student(std::pair<int, int> n, bool v) :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0name(n), vaccinated(v)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Getters\n    \u00a0\u00a0\u00a0\u00a0auto get_name() { return name; }\n    \u00a0\u00a0\u00a0\u00a0auto is_vaccinated() { return vaccinated; }\n    \u00a0\u00a0\u00a0\u00a0// Two people are same if they have the same name\n    \u00a0\u00a0\u00a0\u00a0bool operator ==(const Student& p) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->name == p.name;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// The ordering of a set of people is defined by their name\n    \u00a0\u00a0\u00a0\u00a0bool operator< (const Student& p) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->name < p.name;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0bool operator> (const Student& p) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->name > p.name;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    auto generate_random_Student(int max)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0// the IDs of Student should be in range [1, max]\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> uniform_dist(1, max);\n    \u00a0\u00a0\u00a0\u00a0// Generate random credentials\n    \u00a0\u00a0\u00a0\u00a0auto random_name = std::make_pair(uniform_dist(rand), uniform_dist(rand));\n    \u00a0\u00a0\u00a0\u00a0bool is_vaccinated = uniform_dist(rand) % 2 ? true : false;\n    \u00a0\u00a0\u00a0\u00a0return Student(random_name, is_vaccinated);\n    }\n    ```", "```cpp\n     void search_test(int size, Student p)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<Student> people;\n    \u00a0\u00a0\u00a0\u00a0// Create a list of random people\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 0; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people.push_back(generate_random_Student(size));\n    \u00a0\u00a0\u00a0\u00a0std::sort(people.begin(), people.end());\n    \u00a0\u00a0\u00a0\u00a0// To measure the time taken, start the clock\n    \u00a0\u00a0\u00a0\u00a0std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();\n    \u00a0\u00a0\u00a0\u00a0bool search_result = needs_vaccination(p, people);\n    \u00a0\u00a0\u00a0\u00a0// Stop the clock\n    \u00a0\u00a0\u00a0\u00a0std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Time taken to search = \" <<\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::chrono::duration_cast<std::chrono::microseconds>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(end - begin).count() << \" microseconds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0if (search_result)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Student (\" << p.get_name().first \n    << \" \" << p.get_name().second << \") \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"needs vaccination.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Student (\" << p.get_name().first \n    << \" \" << p.get_name().second << \") \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"does not need vaccination.\" << std::endl;\n    }\n    ```", "```cpp\n    bool needs_vaccination(Student P, std::vector<Student>& people)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto first = people.begin();\n    \u00a0\u00a0\u00a0\u00a0auto last = people.end();\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto range_length = std::distance(first, last);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto mid_element_index = std::floor(range_length / 2);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto mid_element = *(first + mid_element_index);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Return true if the Student is found in the sequence and \n    // he/she's not vaccinated \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mid_element == P && mid_element.is_vaccinated() == false)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (mid_element == P && mid_element.is_vaccinated() == true)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (mid_element > P)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::advance(last, -mid_element_index);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mid_element < P)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::advance(first, mid_element_index);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Student not found in the sequence and therefore should be vaccinated\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (range_length == 1)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0// Generate a Student to search\n    \u00a0\u00a0\u00a0\u00a0auto p = generate_random_Student(1000);\n    \u00a0\u00a0\u00a0\u00a0search_test(1000, p);\n    \u00a0\u00a0\u00a0\u00a0search_test(10000, p);\n    \u00a0\u00a0\u00a0\u00a0search_test(100000, p);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <chrono>\n    #include <random>\n    #include <algorithm>\n    ```", "```cpp\n     template <typename T>\n    auto partition(typename std::vector<T>::iterator begin,\n    \u00a0\u00a0\u00a0\u00a0typename std::vector<T>::iterator end)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto pivot_val = *begin;\n    \u00a0\u00a0\u00a0\u00a0auto left_iter = begin + 1;\n    \u00a0\u00a0\u00a0\u00a0auto right_iter = end;\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Starting from the first element of vector, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// find an element that is greater than pivot.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (*left_iter <= pivot_val && std::distance(left_iter, right_iter) > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left_iter++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Starting from the end of vector moving to the beginning, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// find an element that is lesser than the pivot.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (*right_iter > pivot_val && std::distance(left_iter, right_iter) > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right_iter--;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If left and right iterators meet, there are no elements left to swap. \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Else, swap the elements pointed to by the left and right iterators\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (left_iter == right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::iter_swap(left_iter, right_iter);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (pivot_val > *right_iter)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::iter_swap(begin, right_iter);\n    \u00a0\u00a0\u00a0\u00a0return right_iter;\n    }\n    ```", "```cpp\n     template <typename T>\n    void quick_sort(typename std::vector<T>::iterator begin,\n    \u00a0\u00a0\u00a0\u00a0typename std::vector<T>::iterator last)\n    {\n    \u00a0\u00a0\u00a0\u00a0// If there are more than 1 elements in the vector\n    \u00a0\u00a0\u00a0\u00a0if (std::distance(begin, last) >= 1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Apply the partition operation\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto partition_iter = partition<T>(begin, last);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Recursively sort the vectors created by the partition operation\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quick_sort<T>(begin, partition_iter-1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quick_sort<T>(partition_iter, last);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n     template <typename T>\n    void partial_quick_sort(typename std::vector<T>::iterator begin,\n    \u00a0\u00a0\u00a0\u00a0typename std::vector<T>::iterator last,\n    \u00a0\u00a0\u00a0\u00a0size_t k)\n    {\n    \u00a0\u00a0\u00a0\u00a0// If there are more than 1 elements in the vector\n    \u00a0\u00a0\u00a0\u00a0if (std::distance(begin, last) >= 1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Apply the partition operation\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto partition_iter = partition<T>(begin, last);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Recursively sort the vectors created by the partition operation\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0partial_quick_sort<T>(begin, partition_iter-1, k);\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Sort the right subvector only if the final position of pivot < k \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(std::distance(begin, partition_iter) < k)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0partial_quick_sort<T>(partition_iter, last, k);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n     template <typename T>\n    void print_vector(std::vector<T> arr)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i : arr)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    // Generates random vector of a given size with integers [1, size]\n    template <typename T>\n    auto generate_random_vector(T size)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> V;\n    \u00a0\u00a0\u00a0\u00a0V.reserve(size);\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0// the IDs of Student should be in range [1, max]\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> uniform_dist(1, size);\n    \u00a0\u00a0\u00a0\u00a0for (T i = 0; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V.push_back(uniform_dist(rand));\n    \u00a0\u00a0\u00a0\u00a0return std::move(V);\n    }\n    ```", "```cpp\n    // Sort the first K elements of a random vector of a given 'size'\n    template <typename T>\n    void test_partial_quicksort(size_t size, size_t k)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Create two copies of a random vector to use for the two algorithms\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto random_vec = generate_random_vector<T>(size);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto random_vec_copy(random_vec);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Original vector: \"<<std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print_vector<T>(random_vec); \n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Measure the time taken by partial quick sort\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::chrono::steady_clock::time_point \n    begin_qsort = std::chrono::steady_clock::now();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0partial_quick_sort<T>(random_vec.begin(), random_vec.end()-1, k);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::chrono::steady_clock::time_point \n    end_qsort = std::chrono::steady_clock::now();\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << std::endl << \"Time taken by partial quick sort = \" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< 'std::chrono::duration_cast<std::chrono::microseconds>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(end_qsort - begin_qsort).count() \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \" microseconds\" << std::endl;\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Partially sorted vector (only first \"<< k <<\" elements):\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print_vector<T>(random_vec);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Measure the time taken by partial quick sort\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0begin_qsort = std::chrono::steady_clock::now();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quick_sort<T>(random_vec_copy.begin(), random_vec_copy.end()-1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end_qsort = std::chrono::steady_clock::now();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << std::endl <<\"Time taken by full quick sort = \" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< std::chrono::duration_cast<std::chrono::microseconds>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(end_qsort - begin_qsort).count() \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \" microseconds\" << std::endl;\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Fully sorted vector: \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print_vector<T>(random_vec_copy);\n    }\n    ```", "```cpp\n     int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0test_partial_quicksort<unsigned>(100, 10);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    struct map_task : public mapreduce::map_task<\n    \u00a0\u00a0\u00a0\u00a0std::string,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// MapKey (filename)\n    \u00a0\u00a0\u00a0\u00a0std::pair<char const*, std::uintmax_t>>\u00a0\u00a0// MapValue (memory mapped file contents)\n    {\n    \u00a0\u00a0\u00a0\u00a0template<typename Runtime>\n    \u00a0\u00a0\u00a0\u00a0void operator()(Runtime& runtime, key_type const& key, value_type& value) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool in_word = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char const* ptr = value.first;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char const* end = ptr + value.second;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char const* word = ptr;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Iterate over the contents of the file, extract words and emit a <word,1> pair.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (; ptr != end; ++ptr)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Convert the character to upper case.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char const ch = std::toupper(*ptr, std::locale::classic());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (in_word)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((ch < 'A' || ch > 'Z') && ch != '\\'')\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    runtime.emit_intermediate(std::pair<char const*,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::uintmax_t> (word, ptr - word), 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in_word = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (ch >= 'A' && ch <= 'Z')\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0word = ptr;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in_word = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Handle the last word.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (in_word)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assert(ptr > word);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0runtime.emit_intermediate(std::pair<char const*,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::uintmax_t>(word, ptr - word), 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template<typename KeyType>\n    struct reduce_task : public mapreduce::reduce_task<KeyType, unsigned>\n    {\n    \u00a0\u00a0\u00a0\u00a0using typename mapreduce::reduce_task<KeyType, unsigned>::key_type;\n    \u00a0\u00a0\u00a0\u00a0template<typename Runtime, typename It>\n    \u00a0\u00a0\u00a0\u00a0void operator()(Runtime& runtime, key_type const& key, It it, It const ite) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0runtime.emit(key, std::accumulate(it, ite, 0));\u00a0\u00a0\u00a0\u00a0\n    }\n    }; \n    ```", "```cpp\n    #include <list>\n    #include <algorithm>\n    #include <iostream>\n    #include <random>\n    // Every task is represented as a pair <start_time, end_time>\n    struct Task\n    {\n    \u00a0\u00a0\u00a0\u00a0unsigned ID;\n    \u00a0\u00a0\u00a0\u00a0unsigned start_time;\n    \u00a0\u00a0\u00a0\u00a0unsigned end_time;\n    };\n    ```", "```cpp\n    auto initialize_tasks(size_t num_tasks)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::random_device rd;\n    \u00a0\u00a0\u00a0\u00a0std::mt19937 rand(rd());\n    \u00a0\u00a0\u00a0\u00a0std::uniform_int_distribution<std::mt19937::result_type> \n    uniform_dist(1, num_tasks);\n    \u00a0\u00a0\u00a0\u00a0// Create and initialize a set of tasks\n    \u00a0\u00a0\u00a0\u00a0std::list<Task> tasks;\n    \u00a0\u00a0\u00a0\u00a0for (unsigned i = 1; i <= num_tasks; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto start_time = uniform_dist(rand);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto duration = uniform_dist(rand);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tasks.push_back({i, start_time, start_time + duration });\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return tasks;\n    }\n    ```", "```cpp\n    auto schedule(std::list<Task> tasks)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Sort the list of tasks by their end times\n    \u00a0\u00a0\u00a0\u00a0tasks.sort([](const auto& lhs, const auto& rhs)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return lhs.end_time < rhs.end_time; });\n    \u00a0\u00a0\u00a0\u00a0// Remove the tasks that interfere with one another\n    \u00a0\u00a0\u00a0\u00a0for (auto curr_task = tasks.begin(); curr_task != tasks.end(); curr_task++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Point to the next task\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto next_task = std::next(curr_task, 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// While subsequent tasks interfere with the current task in iter\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (next_task != tasks.end() &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next_task->start_time < curr_task->end_time)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next_task = tasks.erase(next_task);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return tasks;\n    }\n    ```", "```cpp\n    void print(std::list<Task>& tasks)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Task ID \\t Starting Time \\t End time\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto t : tasks)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << t.ID << \"\\t\\t\" << t.start_time << \"\\t\\t\" << t.end_time << std::endl;\n    }\n    void test_interval_scheduling(unsigned num_tasks)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto tasks = initialize_tasks(num_tasks);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Original list of tasks: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print(tasks);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Scheduled tasks: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto scheduled_tasks = schedule(tasks);\n    \u00a0\u00a0\u00a0\u00a0print(scheduled_tasks);\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0test_interval_scheduling(20);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <unordered_map>\n    #include <set>\n    #include <map>\n    #include <string>\n    #include <vector>\n    #include <algorithm>\n    #include <iostream>\n    template <typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    // Initialize the colors that will be used to color the vertices\n    std::unordered_map<size_t, std::string> color_map = {\n    \u00a0\u00a0\u00a0\u00a0{1, \"Red\"},\n    \u00a0\u00a0\u00a0\u00a0{2, \"Blue\"},\n    \u00a0\u00a0\u00a0\u00a0{3, \"Green\"},\n    \u00a0\u00a0\u00a0\u00a0{4, \"Yellow\"},\n    \u00a0\u00a0\u00a0\u00a0{5, \"Black\"},\n    \u00a0\u00a0\u00a0\u00a0{6, \"White\"}\n    };\n    ```", "```cpp\n    template<typename T>\n    auto welsh_powell_coloring(const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto size = G.vertices();\n    \u00a0\u00a0\u00a0\u00a0std::vector<std::pair<size_t, size_t>> degrees;\n    \u00a0\u00a0\u00a0\u00a0// Collect the degrees of vertices as <vertex_ID, degree> pairs\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < size; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0degrees.push_back(std::make_pair(i, G.outgoing_edges(i).size()));\n    \u00a0\u00a0\u00a0\u00a0// Sort the vertices in decreasing order of degree\n    \u00a0\u00a0\u00a0\u00a0std::sort(degrees.begin(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0degrees.end(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[](const auto& a, const auto& b)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return a.second > b.second; });\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"The vertices will be colored in the following order: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Vertex ID \\t Degree\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto const i : degrees)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i.first << \"\\t\\t\" << i.second << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> assigned_colors(size);\n    \u00a0\u00a0\u00a0\u00a0auto color_to_be_assigned = 1;\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto const i : degrees)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (assigned_colors[i.first] != 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto outgoing_edges = G.outgoing_edges(i.first);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::set<size_t> neighbour_colors;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// We assume that the graph is bidirectional\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : outgoing_edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto dest_color = assigned_colors[e.dest];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0neighbour_colors.insert(dest_color);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    if (neighbour_colors.find(color_to_be_assigned) == neighbour_colors.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assigned_colors[i.first] = color_to_be_assigned;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0color_to_be_assigned++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If there are no uncolored vertices left, exit\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (std::find(assigned_colors.begin() + 1, assigned_colors.end(), 0) ==\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assigned_colors.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return assigned_colors;\n    }\n    ```", "```cpp\n    void print_colors(std::vector<size_t>& colors)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < colors.size(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << i << \": \" << color_map[colors[i]] << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 2}, {5, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 2}, {5, 5}, {4, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 2}, {7, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 1}, {3, 2}, {5, 2}, {6, 4}, {8, 5} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 3}, {2, 5}, {4, 2}, {8, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 4}, {7, 4}, {8, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 3}, {6, 4} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 5}, {5, 3}, {6, 1} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Original Graph\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << G;\n    \u00a0\u00a0\u00a0\u00a0auto colors = welsh_powell_coloring<T>(G);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Vertex Colors: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0print_colors(colors);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    #include <set>\n    #include <map>\n    #include <stack>\n    template<typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    template <typename T>\n    auto create_bipartite_reference_graph()\n    {\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(10);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 0}, {3, 0} , {8, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {2, 0}, {4, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {3, 0}, {6, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {7, 0}, {9, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {1, 0}, {4, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {5, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {2,0}, {9, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[9] = { {5, 0} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0return G;\n    }\n    ```", "```cpp\n    template <typename T>\n    auto bipartite_check(const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::stack<size_t> stack;\n    \u00a0\u00a0\u00a0\u00a0std::set<size_t> visited;\n    \u00a0\u00a0\u00a0\u00a0stack.push(1); // Assume that BFS always starts from vertex ID 1\n    \u00a0\u00a0\u00a0\u00a0enum class colors {NONE, RED, BLUE};\n    \u00a0\u00a0\u00a0\u00a0colors current_color{colors::BLUE}; // This variable tracks the color to be assigned to the next vertex that is visited.\n    \u00a0\u00a0\u00a0\u00a0std::vector<colors> vertex_colors(G.vertices(), colors::NONE);\n    \u00a0\u00a0\u00a0\u00a0while (!stack.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto current_vertex = stack.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the current vertex hasn't been visited in the past\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(current_vertex) == visited.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.insert(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vertex_colors[current_vertex] = current_color;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (current_color == colors::RED)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    std::cout << \"Coloring vertex \" << current_vertex << \" RED\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_color = colors::BLUE;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Coloring vertex \" \n    << current_vertex << \" BLUE\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_color = colors::RED;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Add unvisited adjacent vertices to the stack.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : G.outgoing_edges(current_vertex))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(e.dest) == visited.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.push(e.dest);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the found vertex is already colored and \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// has a color same as its parent's color, the graph is not bipartite\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (visited.find(current_vertex) != visited.end() && \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((vertex_colors[current_vertex] == colors::BLUE && \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_color == colors::RED) ||\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(vertex_colors[current_vertex] == colors::RED && \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_color == colors::BLUE)))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// If all vertices have been colored, the graph is bipartite\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    template <typename T>\n    void test_bipartite()\n    {\n    \u00a0\u00a0\u00a0\u00a0// Create an instance of and print the graph\n    \u00a0\u00a0\u00a0\u00a0auto BG = create_bipartite_reference_graph<T>();\n    \u00a0\u00a0\u00a0\u00a0std::cout << BG << std::endl;\n    \u00a0\u00a0\u00a0\u00a0if (bipartite_check<T>(BG))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"The graph is bipartite\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"The graph is not bipartite\" << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0test_bipartite<T>();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    #include <set>\n    #include <map>\n    #include <limits>\n    #include <queue>\n    #include <fstream>\n    #include <sstream>\n    template<typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    template <typename T>\n    auto read_graph_from_file()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::ifstream infile(\"USA-road-d.NY.gr\");\n    \u00a0\u00a0\u00a0\u00a0size_t num_vertices, num_edges;\n    \u00a0\u00a0\u00a0\u00a0std::string line;\n\n    \u00a0\u00a0\u00a0\u00a0// Read the problem description line that starts with 'p' and looks like:\n    \u00a0\u00a0\u00a0\u00a0// p <num_vertices> <num_edges>\n    \u00a0\u00a0\u00a0\u00a0while (std::getline(infile, line))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (line[0] == 'p')\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::istringstream iss(line);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char p;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::string sp;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iss >> p >>sp >> num_vertices >> num_edges; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Num vertices: \" << num_vertices \n    << \" Num edges: \" << num_edges <<std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(num_vertices + 1);\n    \u00a0\u00a0\u00a0\u00a0// Read the edges and edge weights, which look like:\n    \u00a0\u00a0\u00a0\u00a0// a <source_vertex> <destination_vertex> <weight>\n    \u00a0\u00a0\u00a0\u00a0while (std::getline(infile, line))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (line[0] == 'a')\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::istringstream iss(line);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char p;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t source_vertex, dest_vertex;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iss >> p >> source_vertex >> dest_vertex >> weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{source_vertex, dest_vertex, weight});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0infile.close();\n    \u00a0\u00a0\u00a0\u00a0return G;\n    }\n    ```", "```cpp\n    template<typename T>\n    struct Label\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t vertex_ID;\n    \u00a0\u00a0\u00a0\u00a0T distance_from_source;\n    \u00a0\u00a0\u00a0\u00a0Label(size_t _id, T _distance) :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vertex_ID(_id),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance_from_source(_distance)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// To compare labels, only compare their distances from source\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Label<T>& l) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->distance_from_source < l.distance_from_source;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Label<T>& l) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->distance_from_source > l.distance_from_source;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator() (const Label<T>& l) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this > l;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    auto dijkstra_shortest_path(const Graph<T>& G, size_t src, size_t dest)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::priority_queue<Label<T>, std::vector<Label<T>>, std::greater<Label<T>>> heap;\n    \u00a0\u00a0\u00a0\u00a0std::set<int> visited;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> parent(G.vertices());\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> distance(G.vertices(), std::numeric_limits<T>::max());\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> shortest_path;\n    \u00a0\u00a0\u00a0\u00a0heap.emplace(src, 0);\n    \u00a0\u00a0\u00a0\u00a0parent[src] = src;\n    \u00a0\u00a0\u00a0\u00a0// Search for the destination vertex in the graph\n    \u00a0\u00a0\u00a0\u00a0while (!heap.empty()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto current_vertex = heap.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the search has reached the destination vertex\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (current_vertex.vertex_ID == dest) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Destination \" << \n    current_vertex.vertex_ID << \" reached.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(current_vertex.vertex_ID) == visited.end()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Settling vertex \" << \n    current_vertex.vertex_ID << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// For each outgoing edge from the current vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// create a label for the destination vertex and add it to the heap\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : G.outgoing_edges(current_vertex.vertex_ID)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto neighbor_vertex_ID = e.dest;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto new_distance_to_dest=current_vertex.distance_from_source \n    + e.weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the new path to the destination vertex \n    // has a lower cost than any previous paths found to it, if // yes, then this path should be preferred \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (new_distance_to_dest < distance[neighbor_vertex_ID]) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap.emplace(neighbor_vertex_ID, new_distance_to_dest);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent[e.dest] = current_vertex.vertex_ID;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[e.dest] = new_distance_to_dest;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.insert(current_vertex.vertex_ID);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Construct the path from source to the destination by backtracking \n    \u00a0\u00a0\u00a0\u00a0// using the parent indexes\n    \u00a0\u00a0\u00a0\u00a0auto current_vertex = dest;\n    \u00a0\u00a0\u00a0\u00a0while (current_vertex != src) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0shortest_path.push_back(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_vertex = parent[current_vertex];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0shortest_path.push_back(src);\n    \u00a0\u00a0\u00a0\u00a0std::reverse(shortest_path.begin(), shortest_path.end());\n    \u00a0\u00a0\u00a0\u00a0return shortest_path;\n    }\n    ```", "```cpp\n    template<typename T>\n    void test_dijkstra()\n    {\n    \u00a0\u00a0\u00a0\u00a0auto G = read_graph_from_file<T>();\n    \u00a0\u00a0\u00a0\u00a0//std::cout << G << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto shortest_path = dijkstra_shortest_path<T>(G, 913, 542);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"The shortest path between 913 and 542 is:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto v : shortest_path)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << v << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0test_dijkstra<T>();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <climits>\n    using namespace std;\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int end;\u00a0\u00a0 \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Edge(int s, int e, int w) : start(s), end(e), weight(w) {}\n    };\n    const int UNKNOWN = INT_MAX;\n    vector<Edge*> edges;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int N;\n    \u00a0\u00a0\u00a0\u00a0cin >> N;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < N * N - 1; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0string directions;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int power;\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> directions >> power;\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    CURRENT CELL: (x, y) \u2014> i\n    NORTH: (x, y - 1) \u2014> i - N\n    SOUTH: (x, y + 1) \u2014> i + N\n    EAST: (x + 1, y) \u2014> i + 1\n    WEST: (x - 1, y) \u2014> i - 1 \n    ```", "```cpp\n    for(int i = 0; i < N * N - 1; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0string directions;\n    \u00a0\u00a0\u00a0\u00a0int power;\n    \u00a0\u00a0\u00a0\u00a0cin >> directions >> power;\n    \u00a0\u00a0\u00a0\u00a0int next;\n    \u00a0\u00a0\u00a0\u00a0for(auto d : directions)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(d)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 'N': next = i - N; break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 'S': next = i + N; break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 'E': next = i + 1; break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 'W': next = i - 1; break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    for(auto d : directions)\n    {\n    \u00a0\u00a0\u00a0\u00a0switch(d)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Add edge with power variable's sign reversed \n    \u00a0\u00a0\u00a0\u00a0edges.push_back(new Edge(i, next, -power));\n    }\n    ```", "```cpp\n    int BellmanFord(int N, vector<Edge*> edges)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance(N, UNKNOWN);\n\n    \u00a0\u00a0\u00a0\u00a0// Starting node is always index 0\n    \u00a0\u00a0\u00a0\u00a0distance[0] = 0;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < N - 1; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge->start] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge->start] + edge->weight < distance[edge->end])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[edge->end] = distance[edge->start] + edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    // Check for negative cycles\n    for(auto edge : edges)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(distance[edge->start] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(distance[edge->start] + edge->weight < distance[edge->end])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return UNKNOWN;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return distance[N];\n    ```", "```cpp\n    int result = BellmanFord(N * N, edges);\n    (result == UNKNOWN) ? cout << \"ABORT TRAVERSAL\" << endl \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: cout << -1 * result << endl;\n    return 0;\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <iomanip>\n    #include <algorithm>\n    #include <queue>\n    #include <utility>\n    using namespace std;\n    const int UNKNOWN = 1e9;\n    struct Edge \n    {\n    \u00a0\u00a0\u00a0\u00a0int u;\n    \u00a0\u00a0\u00a0\u00a0int v;\n    \u00a0\u00a0\u00a0\u00a0int w;\n    \u00a0\u00a0\u00a0\u00a0Edge(int u, int v, int w) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: u(u), v(v), w(w) {}\n    };\n    ```", "```cpp\n    struct Graph\n    {\n    \u00a0\u00a0\u00a0\u00a0int V, E;\n    \u00a0\u00a0\u00a0\u00a0int maxWeight = -1e9;\n    \u00a0\u00a0\u00a0\u00a0vector<Edge> edges;\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> adj;\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> weight;\n    \u00a0\u00a0\u00a0\u00a0Graph(int v, int e) : V(v), E(e) \n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    Graph(int v, int e) : V(v), E(e)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<vector<bool>> used(V, vector<bool>(V, false));\n    \u00a0\u00a0\u00a0\u00a0adj.resize(V);\n    \u00a0\u00a0\u00a0\u00a0weight.resize(V, vector<int>(V, UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0while(e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Generate edge values\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u = rand() % V;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int v = rand() % V;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int w = rand() % 100;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(rand() % 3 == 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w = -w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the edge is valid\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(u == v || used[u][v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Add to edges and mark as used\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges.push_back(Edge(u, v, w));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0adj[u].push_back(v);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0weight[u][v] = w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxWeight = max(maxWeight, w);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0used[u][u] = used[v][v] = used[u][v] = used[v][u] = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e--;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Set V to -1 to indicate the graph is invalid\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(!used[i][i])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = -1;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    enum RESULT\n    {\n    \u00a0\u00a0\u00a0\u00a0VALID,\n    \u00a0\u00a0\u00a0\u00a0INVALID,\n    \u00a0\u00a0\u00a0\u00a0INTERESTING\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0unsigned int seed;\n    \u00a0\u00a0\u00a0\u00a0int iterations, V, E;\n\n    \u00a0\u00a0\u00a0\u00a0cin >> seed;\n    \u00a0\u00a0\u00a0\u00a0cin >> iterations;\n    \u00a0\u00a0\u00a0\u00a0cin >> V >> E;\n    \u00a0\u00a0\u00a0\u00a0int invalid = 0;\n    \u00a0\u00a0\u00a0\u00a0int valid = 0;\n    \u00a0\u00a0\u00a0\u00a0int interesting = 0;\n    \u00a0\u00a0\u00a0\u00a0srand(seed);\n    \u00a0\u00a0\u00a0\u00a0while(iterations--)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Graph G(V, E);\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(TestGraph(G))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case INVALID: invalid++; break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case VALID: valid++; break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case INTERESTING: \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0valid++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interesting++;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    RESULT TestGraph(Graph G)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(G.V == -1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return INVALID;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance = BellmanFord(G);\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    vector<int> BellmanFord(Graph G)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance(G.V + 1, UNKNOWN);\n    \u00a0\u00a0\u00a0\u00a0int s = G.V;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < G.V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.edges.push_back(Edge(s, i, 0));\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0distance[s] = 0;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < G.V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto edge : G.edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge.u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge.u] + edge.w < distance[edge.v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[edge.v] = distance[edge.u] + edge.w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : G.edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge.u] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge.u] + edge.w < distance[edge.v])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return {};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    return distance;\n    }\n    ```", "```cpp\n    RESULT TestGraph(Graph G)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(G.V == -1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return INVALID;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance = BellmanFord(G);\n    \u00a0\u00a0\u00a0\u00a0if(distance.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return VALID;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for(auto edge : G.edges)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.weight[edge.u][edge.v] += (distance[edge.u] \u2013 distance[edge.v]);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0double result = 0;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < G.V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<int> shortest = Dijkstra(i, G);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    vector<int> Dijkstra(int source, Graph G)\n    {\n    \u00a0\u00a0\u00a0\u00a0typedef pair<int, int> State;\n    \u00a0\u00a0\u00a0\u00a0priority_queue<State, vector<State>, greater<State>> Q;\n    \u00a0\u00a0\u00a0\u00a0vector<bool> visited(G.V, false);\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance(G.V, UNKNOWN);\n    \u00a0\u00a0\u00a0\u00a0Q.push({0, source});\n    \u00a0\u00a0\u00a0\u00a0distance[source] = 0;\n    \u00a0\u00a0\u00a0\u00a0while(!Q.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State top = Q.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int node = top.second;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int dist = top.first;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[node] = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto next : G.adj[node])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(visited[next])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(dist != UNKNOWN && distance[next] > dist + G.weight[node][next])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[next] = distance[node] + G.weight[node][next];\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.push({distance[next], next});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return distance;\n    }\n    ```", "```cpp\n    double result = 0;\n    for(int i = 0; i < G.V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> shortest = Dijkstra(i, G);\n    \u00a0\u00a0\u00a0\u00a0double average = 0;\n    \u00a0\u00a0\u00a0\u00a0int count = 0;\n    \u00a0\u00a0\u00a0\u00a0for(int j = 0; j < G.V; j++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(i == j || shortest[j] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0shortest[j] += (distance[j] \u2013 distance[i]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0average += shortest[j];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count++;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0average = average / count;\n    \u00a0\u00a0\u00a0\u00a0result += average;\n    }\n    result = result / G.V;\n    ```", "```cpp\n    double ratio = result / G.maxWeight;\n    return (ratio < 0.5) ? INTERESTING : VALID;\n    ```", "```cpp\n    double percentInteresting = (double)interesting / valid * 100;\n    cout << \"INVALID GRAPHS: \" << invalid << endl;\n    cout << \"PERCENT INTERESTING: \" << fixed << setprecision(2) << percentInteresting << endl;\n    return 0;\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <stack>\n    #include <climits>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0int start;\n    \u00a0\u00a0\u00a0\u00a0int end;\n    \u00a0\u00a0\u00a0\u00a0int weight;\n    \u00a0\u00a0\u00a0\u00a0Edge(int s, int e, int w) : start(s), end(e), weight(w) {}\n    }\n    const int UNKNOWN = INT_MAX;\n    vector<Edge*> edges; // Collection of edge pointers\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int V, E;\n    \u00a0\u00a0\u00a0\u00a0cin >> V >> E;\n    \u00a0\u00a0\u00a0\u00a0vector<Edge*> edges;\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> adj(V + 1);\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < E; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int u, v, w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> u >> v >> w;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges.push_back(new Edge(u, v, w));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0adj[u].push_back(v);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0vector<int> results;\n    ```", "```cpp\n    int BellmanFord(int V, int start, vector<Edge*> edges)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Standard Bellman-Ford implementation\n    \u00a0\u00a0\u00a0\u00a0vector<int> distance(V, UNKNOWN);\n\n    \u00a0\u00a0\u00a0\u00a0distance[start] = 0;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < V - 1; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto edge : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge->start] == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(distance[edge->start] + edge->weight < distance[edge->end])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[edge->end] = distance[edge->start] + edge->weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return UNKNOWN if a negative cycle is found\n    \u00a0\u00a0\u00a0\u00a0if(HasNegativeCycle(distance, edges))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return UNKNOWN;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0int result = UNKNOWN;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < V; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(i == start) continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = min(result, distance[i]);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    vector<int> results;\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(adj[i].empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0results.push_back(UNKNOWN);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0int shortest = BellmanFord(V, i, edges);\n    \u00a0\u00a0\u00a0\u00a0if(shortest == UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"INVALID MAZE\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0results.push_back(shortest);\n    }\n    for(int i = 0; i < V; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0cout << i << \": \";\n    \u00a0\u00a0\u00a0\u00a0(results[i] == INVALID) ? cout << \"DEAD END\" << endl : cout << results[i] << endl;\n    }\n    ```", "```cpp\n    vector<bool> isStuck;\n    vector<int> inComponent;\n    int componentIndex;\n    ```", "```cpp\n    isStuck.resize(V, true);\n    inComponent.resize(V, UNKNOWN);\n    componentIndex = 0;\n    ```", "```cpp\n    while(!stack.empty())\n    {\n    \u00a0\u00a0\u00a0\u00a0int node = stack.top();\n    \u00a0\u00a0\u00a0\u00a0stack.pop();\n    \u00a0\u00a0\u00a0\u00a0if(!visited[node])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<int> component;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetComponent(node, transpose, visited, component);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0components.push_back(component);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0componentIndex++;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    component.push_back(node);\n    visited[node] = true;\n    inComponent[node] = componentIndex;\n    for(auto next : adj[node])\n    {\n    \u00a0\u00a0\u00a0\u00a0if(!visited[next])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetComponent(next, visited, adj, component);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if(inComponent[node] != inComponent[next])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isStuck[inComponent[next]] = false;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    auto components = Kosaraju(V, adj);\n    for(int i = 0; i < components.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(isStuck[i])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto node : components[i])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << node << \" \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return 0;\n    ```", "```cpp\n[1]: distance = 5\n[2]: distance = 3\n[3]: distance = 1\n[4]: distance = 2\n```", "```cpp\nCities reachable from index [1] -> { 2 3 4 5 6 }\nCities reachable from index [2] -> { 3 4 5 }\nCities reachable from index [3] -> { 4 }\nCities reachable from index [4] -> { 5 6 }\n```", "```cpp\nCities that connect to index [1] -> START\nCities that connect to index [2] -> { 1 }\nCities that connect to index [3] -> { 1 2 }\nCities that connect to index [4] -> { 1 2 3 }\nCities that connect to index [5] -> { 1 2 }\n```", "```cpp\nWays to reach City 1 = 1 (START)\nWays to reach City 2 = 1 \n\u00a0\u00a0\u00a0\u00a01 \" 2\nWays to reach City 3 = 2\n\u00a0\u00a0\u00a0\u00a01 \" 2 \" 3\n\u00a0\u00a0\u00a0\u00a01 \" 3\nWays to reach City 4 = 4\n\u00a0\u00a0\u00a0\u00a01 \" 2 \" 3 \" 4\n\u00a0\u00a0\u00a0\u00a01 \" 2 \" 4\n\u00a0\u00a0\u00a0\u00a01 \" 3 \" 4\n\u00a0\u00a0\u00a0\u00a01 \" 4\nWays to reach City 5 = 6\n\u00a0\u00a0\u00a0\u00a01 \" 2 \" 3 \" 4 \" 5\n\u00a0\u00a0\u00a0\u00a01 \" 2 \" 4 \" 5\n\u00a0\u00a0\u00a0\u00a01 \" 2 \" 5\n\u00a0\u00a0\u00a0\u00a01 \" 3 \" 4 \" 5\n\u00a0\u00a0\u00a0\u00a01 \" 4 \" 5\n\u00a0\u00a0\u00a0\u00a01 \" 5\n```", "```cpp\nF(n) -> number of ways to reach n'th location\nF(i) = \n\u00a0\u00a0\u00a0\u00a0if i = N: \n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1 \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Otherwise:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j = 1 to distance[i]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result + F(i + j)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return result\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    ```", "```cpp\n    typedef long long LL;\n    ```", "```cpp\n    const LL MOD = 1000000007;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int n;\n    \u00a0\u00a0\u00a0\u00a0cin >> n;\n\n    vector<int> distance(n);\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < n; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> distance[i];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0LL result = TravelItinerary(n, distance);\n    \u00a0\u00a0\u00a0\u00a0cout << result << endl;\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    LL TravelItinerary(int n, vector<int> distance)\n    {\n    \u00a0\u00a0\u00a0\u00a0...\n    }\n    ```", "```cpp\n    DP -> Array of size N + 1\n    DP[0] = 1 (There is one way to reach the starting location)\n    for i = 0 to N-1:\n    \u00a0\u00a0\u00a0\u00a0for j = 1 to distance[i]: \n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i + j] += DP[i]\n    return DP[N]\n    ```", "```cpp\n    vector<LL> DP(n + 1, 0);\n    DP[0] = 1;\n    ```", "```cpp\n    reverse(distance.begin(), distance.end());\n    DP[0] = 1;\n    for(int i = 1; i <= n; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0int dist = distance[i-1];\n    \u00a0\u00a0\u00a0\u00a0for(int j = 1; j <= dist; j++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i] = (DP[i] + DP[i \u2013 j]) % MOD;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return DP[n];\n    ```", "```cpp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 1  2  3  4\nA\u00a0\u00a0\u00a0\u00a0=\u00a0\u00a0\u00a0{ 3 1 10  2  5 } \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  0 1 2  3  4  5\nsums\u00a0\u00a0=\u00a0\u00a0{ 0 3 4 14 16 21 }\nrange(1, 3) = A[1] + A[2] + A[3]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 = 1 + 10 + 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= 13\nsums[4]\u00a0\u00a0\u2013\u00a0sums[1] = 13\nrange(3, 4) = A[3] + A[4]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= 2 + 5\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= 7\nsums[5] \u2013 sums[3] = 7\n```", "```cpp\n    LL TravelItinerary(int n, vector<int> distance)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<LL> DP(n + 1, 0);\n    \u00a0\u00a0\u00a0\u00a0vector<LL> sums(n + 2, 0);\n    \u00a0\u00a0\u00a0\u00a0DP[0] = sums[1] = 1;\n    \u00a0\u00a0\u00a0\u00a0reverse(distance.begin(), distance.end());\n    \u00a0\u00a0\u00a0\u00a0for(int i = 1; i <= n; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int dist = distance[i-1];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LL sum = sums[i] \u2013 sums[i \u2013 dist];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i] = (DP[i] + sum) % MOD;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sums[i + 1] = (sums[i] + DP[i]) % MOD;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return DP[n];\n    }\n    ```", "```cpp\n    return (DP[n] < 0) ? DP[n] + MOD : DP[n];\n    ```", "```cpp\n    vector<string> types =\n    {\n    \u00a0\u00a0\u00a0\u00a0\"BRUTE FORCE\",\n    \u00a0\u00a0\u00a0\u00a0\"MEMOIZATION\",\n    \u00a0\u00a0\u00a0\u00a0\"TABULATION\"\n    };\n    const int UNKNOWN = INT_MAX;\n    void GetTime(clock_t &timer, string type)\n    {\n    \u00a0\u00a0\u00a0\u00a0timer = clock() - timer;\n    \u00a0\u00a0\u00a0\u00a0cout << \"TIME TAKEN USING \" << type << \": \" << fixed << setprecision(5) << (float)timer / CLOCKS_PER_SEC << \" SECONDS\" << endl;\n    \u00a0\u00a0\u00a0\u00a0timer = clock();\n    }\n    ```", "```cpp\n    int LCS_Memoization(string A, string B, int i, int j, vector<vector<int>> &memo)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    // Base case \u2014 LCS is always zero for empty strings\n    if(i == 0 || j == 0)\n    {\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    // Have we found a result for the prefixes of the two strings?\n    if(memo[i - 1][j - 1] != UNKNOWN)\n    {\n    \u00a0\u00a0\u00a0\u00a0// If so, return it\n    \u00a0\u00a0\u00a0\u00a0return memo[i - 1][j - 1];\n    }\n    // Are the last characters of A's prefix and B's prefix equal?\n    if(A[i-1] == B[j-1])\n    {\n    \u00a0\u00a0\u00a0\u00a0// LCS for this state is equal to 1 plus the LCS of the prefixes of A and B, both reduced by one character\n    \u00a0\u00a0\u00a0\u00a0memo[i-1][j-1] = 1 + LCS_Memoization(A, B, i-1, j-1, memo);\n    \u00a0\u00a0\u00a0\u00a0// Return the cached result\n    \u00a0\u00a0\u00a0\u00a0return memo[i-1][j-1];\n    }\n    // If the last characters are not equal, LCS for this state is equal to the maximum LCS of A's prefix reduced by one character and B's prefix, and B's prefix reduced by one character and A's prefix\n    memo[i-1][j-1] = max(LCS_Memoization(A, B, i-1, j, memo), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 LCS_Memoization(A, B, i, j-1, memo));\n    return memo[i-1][j-1];\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0string A, B;\n    \u00a0\u00a0\u00a0\u00a0cin >> A >> B;\n    \u00a0\u00a0\u00a0\u00a0int tests = 2;\n    \u00a0\u00a0\u00a0\u00a0clock_t timer = clock();\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < tests; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int LCS;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(i)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 0:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LCS = LCS_BruteForce(A, B, 0, 0, {});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#if DEBUG\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PrintSubsequences(A, B);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#endif\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 1:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<vector<int>> memo(A.size(), vector<int>(B.size(), UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LCS = LCS_Memoization(A, B, A.size(), B.size(), memo);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Length of the longest common subsequence of \" << A << \" and \" << B << \" is: \" << LCS << ends;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetTime(timer, types[i]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    SIZE = 3\n    \u00a0\u00a0\u00a0\u00a0ABC________ ABC_______\n    SIZE = 4\n    \u00a0\u00a0\u00a0\u00a0ABC_B______ ABCB______\n    \u00a0\u00a0\u00a0\u00a0ABC_B______ ABC___B___\n    \u00a0\u00a0\u00a0\u00a0ABC_B______ ABC______B\n    \u00a0\u00a0\u00a0\u00a0ABC___B____ ABC______B\n    \u00a0\u00a0\u00a0\u00a0ABC____E___ ABC____E__\n    \u00a0\u00a0\u00a0\u00a0ABC______B_ ABC___B___\n    \u00a0\u00a0\u00a0\u00a0ABC______B_ ABC______B\n    \u00a0\u00a0\u00a0\u00a0ABC_______A ABC_____A_\n    SIZE = 5\n    \u00a0\u00a0\u00a0\u00a0ABCAB______ ABC_____AB\n    \u00a0\u00a0\u00a0\u00a0ABC_B_B____ ABCB_____B\n    \u00a0\u00a0\u00a0\u00a0ABC_B__E___ ABCB___E__\n    \u00a0\u00a0\u00a0\u00a0ABC_B____B_ ABCB__B___\n    \u00a0\u00a0\u00a0\u00a0ABC_B____B_ ABCB_____B\n    \u00a0\u00a0\u00a0\u00a0ABC_B_____A ABCB____A_\n    \u00a0\u00a0\u00a0\u00a0ABC_B_B____ ABC___B__B\n    \u00a0\u00a0\u00a0\u00a0ABC_B__E___ ABC___BE__\n    \u00a0\u00a0\u00a0\u00a0ABC_B____B_ ABC___B__B\n    \u00a0\u00a0\u00a0\u00a0ABC_B_____A ABC___B_A_\n    \u00a0\u00a0\u00a0\u00a0ABC___BE___ ABC___BE__\n    \u00a0\u00a0\u00a0\u00a0ABC____E_B_ ABC____E_B\n    \u00a0\u00a0\u00a0\u00a0ABC____E__A ABC____EA_\n    \u00a0\u00a0\u00a0\u00a0ABC_____FB_ ABC__FB___\n    \u00a0\u00a0\u00a0\u00a0ABC______BA ABC___B_A_\n    SIZE = 6\n    \u00a0\u00a0\u00a0\u00a0ABC_B_BE___ ABCB__BE__\n    \u00a0\u00a0\u00a0\u00a0ABC_B__E_B_ ABCB___E_B\n    \u00a0\u00a0\u00a0\u00a0ABC_B__E__A ABCB___EA_\n    \u00a0\u00a0\u00a0\u00a0ABC_B___FB_ ABCB_FB___\n    \u00a0\u00a0\u00a0\u00a0ABC_B____BA ABCB__B_A_\n    \u00a0\u00a0\u00a0\u00a0ABC_B__E_B_ ABC___BE_B\n    \u00a0\u00a0\u00a0\u00a0ABC_B__E__A ABC___BEA_\n    \u00a0\u00a0\u00a0\u00a0ABC___BE_B_ ABC___BE_B\n    \u00a0\u00a0\u00a0\u00a0ABC___BE__A ABC___BEA_\n    \u00a0\u00a0\u00a0\u00a0ABC____EFB_ ABC_EFB___\n    \u00a0\u00a0\u00a0\u00a0ABC_____FBA ABC__FB_A_\n    SIZE = 7\n    \u00a0\u00a0\u00a0\u00a0ABC_B_BE_B_ ABCB__BE_B\n    \u00a0\u00a0\u00a0\u00a0ABC_B_BE__A ABCB__BEA_\n    \u00a0\u00a0\u00a0\u00a0ABC_B__EFB_ ABCBEFB___\n    \u00a0\u00a0\u00a0\u00a0ABC_B___FBA ABCB_FB_A_\n    \u00a0\u00a0\u00a0\u00a0ABC____EFBA ABC_EFB_A_\n    SIZE = 8\n    \u00a0\u00a0\u00a0\u00a0ABC_B__EFBA ABCBEFB_A_\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING BRUTE FORCE: 0.00242 SECONDS\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING MEMOIZATION: 0.00003 SECONDS\n    ```", "```cpp\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING BRUTE FORCE: 0.00055 SECONDS\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING MEMOIZATION: 0.00002 SECONDS\n    ```", "```cpp\n    Length of the longest common subsequence of ABZCYDABAZADAEA and YABAZADBBEAAECYACAZ is: 10\n    TIME TAKEN USING BRUTE FORCE: 8.47842 SECONDS\n    Length of the longest common subsequence of ABZCYDABAZADAEA and YABAZADBBEAAECYACAZ is: 10\n    TIME TAKEN USING MEMOIZATION: 0.00008 SECONDS\n    ```", "```cpp\n    string LCS_Tabulation(string A, string B)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    } \n    ```", "```cpp\n    vector<vector<int>> DP(A.size() + 1, vector<int>(B.size() + 1));\n    ```", "```cpp\n    for(int i = 0; i <= A.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int j = 0; j <= B.size(); j++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    if(i == 0 || j == 0)\n    {\n    \u00a0\u00a0\u00a0\u00a0DP[i][j] = 0;\n    }\n    ```", "```cpp\n    else if(A[i-1] == B[j-1])\n    {\n    \u00a0\u00a0\u00a0\u00a0DP[i][j] = DP[i-1][j-1] + 1;\n    }\n    ```", "```cpp\n    else\n    {\n    \u00a0\u00a0\u00a0\u00a0DP[i][j] = max(DP[i-1][j], DP[i][j-1]);\n    }\n    ```", "```cpp\n    string LCS_Tabulation(string A, string B)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> DP(A.size() + 1, vector<int>(B.size() + 1));\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i <= A.size(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j = 0; j <= B.size(); j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(i == 0 || j == 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][j] = 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if(A[i-1] == B[j-1])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][j] = DP[i-1][j-1] + 1;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][j] = max(DP[i-1][j], DP[i][j-1]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0int length = DP[A.size()][B.size()];\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    if i = 0 or j = 0:\n    \u00a0\u00a0\u00a0\u00a0Return an empty string\n    If the characters at the end of A's prefix and B's prefix are equal:\n    \u00a0\u00a0\u00a0\u00a0Return the LCS of the next smaller prefix of both A and B, plus the equal character\n    Otherwise:\n    \u00a0\u00a0\u00a0\u00a0If the value of DP(i - 1, j) is greater than the value of DP(i, j - 1):\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2013 Return the LCS of A's next smaller prefix with B's current prefix\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2013 Otherwise:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Return the LCS of B's next smaller prefix with A's current prefix\n    ```", "```cpp\n    string ReconstructLCS(vector<vector<int>> &DP, string &A, string &B, int i, int j)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(i == 0 || j == 0)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return \"\";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(A[i-1] == B[j-1])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ReconstructLCS(DP, A, B, i-1, j-1) + A[i-1];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if(DP[i-1][j] > DP[i][j-1])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ReconstructLCS(DP, A, B, i-1, j);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ReconstructLCS(DP, A, B, i, j-1);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    string LCS_Tabulation(string A, string B)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0string lcs = ReconstructLCS(DP, A, B, A.size(), B.size());\n    \u00a0\u00a0\u00a0\u00a0return lcs; \n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0string A, B;\n    \u00a0\u00a0\u00a0\u00a0cin >> A >> B;\n    \u00a0\u00a0\u00a0\u00a0int tests = 3;\n    \u00a0\u00a0\u00a0\u00a0clock_t timer = clock();\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < tests; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int LCS;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(i)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 2:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0string lcs = LCS_Tabulation(A, B);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LCS = lcs.size();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"The longest common subsequence of \" << A << \" and \" << B << \" is: \" << lcs << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break; \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Length of the longest common subsequence of \" << A << \" and \" << B << \" is: \" << LCS << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetTime(timer, types[i]);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING BRUTE FORCE: 0.00060 SECONDS\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING MEMOIZATION: 0.00005 SECONDS\n    The longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: ABCBEFBA\n    Length of the longest common subsequence of ABCABDBEFBA and ABCBEFBEAB is: 8\n    TIME TAKEN USING TABULATION: 0.00009 SECONDS\n    ```", "```cpp\nfor i = 1 to length of melody (inclusive):\n\u00a0\u00a0\u00a0\u00a0for each subset previously found:\n\u00a0\u00a0\u00a0\u00a0DP(i, subset) = DP(i, subset) + DP(i - 1, subset)\n\u00a0\u00a0\u00a0\u00a0DP(i, subset \u222a melody[i - 1]) = DP(i, subset \u222a melody[i - 1]) + DP(i - 1, subset)\n```", "```cpp\nS\u00a0=\u00a0{\u00a0A,\u00a0B,\u00a0C,\u00a0D\u00a0}\n{\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0_\u00a0_\u00a0}\n{\u00a0A\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0_\u00a0_\u00a0}\n{\u00a0B\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0_\u00a0_\u00a0}\n{\u00a0C\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0#_\u00a0\u00a0}\n{\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0_\u00a0#\u00a0}\n{\u00a0A,\u00a0B\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0_\u00a0_\u00a0}\n{\u00a0A,\u00a0C\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0#_\u00a0\u00a0}\n{\u00a0A,\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0_\u00a0#\u00a0}\n{\u00a0B,\u00a0C\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0#_\u00a0\u00a0}\n{\u00a0B,\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0_\u00a0#\u00a0}\n{\u00a0C,\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0#\u00a0#\u00a0}\n{\u00a0A,\u00a0B,\u00a0C\u00a0}\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0#\u00a0_\u00a0}\n{\u00a0A,\u00a0B,\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0_\u00a0#\u00a0}\n{\u00a0A,\u00a0C,\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0#\u00a0#\u00a0}\n{\u00a0B,\u00a0C,\u00a0D\u00a0}\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0#\u00a0#\u00a0}\n{\u00a0A,\u00a0B,\u00a0C,\u00a0D\u00a0}\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0#\u00a0#\u00a0}\n```", "```cpp\n0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00000\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0_\u00a0_\u00a0}\n1\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00001\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0_\u00a0_\u00a0}\n2\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00010\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0_\u00a0_\u00a0}\n3\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00011\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0_\u00a0_\u00a0}\n4\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00100\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0#\u00a0_\u00a0}\n5\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00101\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0#\u00a0_\u00a0}\n6\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00110\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0#\u00a0_\u00a0}\n7\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a00111\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0#\u00a0_\u00a0}\n8\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01000\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0_\u00a0#\u00a0}\n9\u00a0\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01001\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0_\u00a0#\u00a0}\n10\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01010\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0_\u00a0#\u00a0}\n11\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01011\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0_\u00a0#\u00a0}\n12\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01100\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0_\u00a0#\u00a0#\u00a0}\n13\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01101\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0_\u00a0#\u00a0#\u00a0}\n14\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01110\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0_\u00a0#\u00a0#\u00a0#\u00a0}\n15\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a01111\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{\u00a0#\u00a0#\u00a0#\u00a0#\u00a0}\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <string>\n    #include <map>\n    using namespace std;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int melodyLength;\n    \u00a0\u00a0\u00a0\u00a0int setLength;\n    \u00a0\u00a0\u00a0\u00a0cin >> melodyLength;\n    \u00a0\u00a0\u00a0\u00a0vector<string> melody(melodyLength);\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < melodyLength; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> melody[i];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0cin >> setLength;\n    \u00a0\u00a0\u00a0\u00a0vector<string> set(setLength);\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < setLength; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> set[i];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    vector<int> ConvertNotes(vector<string> notes)\n    {\n    \u00a0\u00a0\u00a0\u00a0map<string, int> M = \n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"A\",\u00a0\u00a00 }, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"A#\", 1 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Bb\", 1 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"B\",\u00a0\u00a02 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Cb\", 2 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"B#\", 3 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"C\",\u00a0\u00a03 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"C#\", 4 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Db\", 4 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"D\",\u00a0\u00a05 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"D#\", 6 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Eb\", 6 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"E\",\u00a0\u00a07 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Fb\", 7 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"E#\", 8 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"F\",\u00a0\u00a08 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"F#\", 9 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Gb\", 9 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"G\",\u00a0\u00a010 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"G#\", 11 },\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ \"Ab\", 11 }\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0vector<int> converted;\n    \u00a0\u00a0\u00a0\u00a0for(auto note : notes)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Map to powers of 2\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0converted.push_back(1 << M[note]); \n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return converted;\n    }\n    ```", "```cpp\n    int CountMelodicPermutations(vector<int> melody, vector<int> set)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    unsigned int target = 0;\n    for(auto note : set)\n    {\n    \u00a0\u00a0\u00a0\u00a0target |= note;\n    }\n    ```", "```cpp\n    C\u00a0\u00a0= 3\n    F# = 9\n    A\u00a0\u00a0= 0\n    converted = { 23, 29, 20 } = { 8, 512, 1 }\n    target = (8 | 512 | 1) = 521\n    \u00a0\u00a0\u00a0\u00a00000001000\n    \u00a0\u00a0+\u00a00000000001\n    \u00a0\u00a0+\u00a01000000000\n    \u00a0\u00a0=\u00a01000001001\n    ```", "```cpp\n    vector<vector<int>> DP(melody.size() + 1, vector<int>(4096, 0));\n    ```", "```cpp\n    Base case:\n    \u00a0\u00a0\u00a0\u00a0DP(0, 0) \u2014> 1 \n    Recurrence:\n    \u00a0\u00a0\u00a0\u00a0DP(i, subset) \u2014> DP(i, subset) + DP(i - 1, subset)\n    \u00a0\u00a0\u00a0\u00a0DP(i, subset \u222a note[i-1]) \u2014> DP(i, subset \u222a note[i]) + DP(i - 1, subset)\n    ```", "```cpp\n    // Base case \u2014> empty set\n    DP[0][0] = 1;\n    for(int i = 1; i <= melody.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(unsigned int subset = 0; subset < 4096; subset++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Keep results for previous values of i\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][subset] += DP[i-1][subset];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Add results for union of subset with melody[i-1]\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][subset | melody[i-1]] += DP[i-1][subset];\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    // Solution\n    return DP[melody.size()][target];\n    ```", "```cpp\n    int count = CountMelodicPermutations(ConvertNotes(melody), ConvertNotes(set));\n    cout << count << endl;\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n    ```", "```cpp\n    struct Product \n    {\n    \u00a0\u00a0\u00a0\u00a0int quantity;\n    \u00a0\u00a0\u00a0\u00a0int price;\n    \u00a0\u00a0\u00a0\u00a0int value;\n    \u00a0\u00a0\u00a0\u00a0Product(int q, int p, int v) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: quantity(q), price(p), value(v) {}\n    };\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0int N, budget, capacity;\n    \u00a0\u00a0\u00a0\u00a0cin >> N >> budget >> capacity;\n    \u00a0\u00a0\u00a0\u00a0vector<Product> products;\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < N; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int quantity, cost, value;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> quantity >> cost >> value;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0products.push_back(Product(quantity, cost, value));\n    \u00a0\u00a0\u00a0\u00a0}\n    ...\n    return 0;\n    }\n    ```", "```cpp\n    F(i, count, cost, total): \n    I\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2013> The index of the current item \n    Cost\u00a0\u00a0\u00a0\u00a0\u00a0\u2013> The total money spent \n    count\u00a0\u00a0\u00a0\u00a0\u2013> The number of units purchased\n    total\u00a0\u00a0\u00a0\u00a0\u2013> The total profit value of the chosen items\n    Base cases: \n    \u00a0\u00a0\u00a0\u00a0if i = N: return total\n    \u00a0\u00a0\u00a0\u00a0if cost > budget: return 0\n    \u00a0\u00a0\u00a0\u00a0if count > capacity: return 0\n    Recurrence:\n    F(i, count, cost, total) = maximum of:\n    F(i + 1, count + quantity[i], cost + price[i], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0total + value[i]) \u2013 Include the item\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AND\n    \u00a0\u00a0\u00a0\u00a0F(i + 1, count, cost, total) \u2013 Leave as-is\n    ```", "```cpp\n    Base case:\n    \u00a0\u00a0\u00a0\u00a0DP(0, 0, 0) = 0 [Nothing has been chosen yet]\n    For i = 1 to N:\n    \u00a0\u00a0\u00a0\u00a0Product -> quantity, price, value\n    \u00a0\u00a0\u00a0\u00a0For cost = 0 to budget:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0For count = 0 to capacity:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0If price is greater than cost OR \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 quantity is greater than count:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP(i, cost, count) = DP(i-1, cost, count)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Otherwise:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP(i, cost, count) = maximum of:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP(i-1, cost, count)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AND\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP(i-1, cost \u2013 price, count \u2013 quantity) + value\n    ```", "```cpp\n    vector<vector<vector<int>>> DP(N + 1, vector<vector<int>>(budget + 1, vector<int>(capacity + 1, 0)));\n    for(int i = 1; i <= N; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0Product product = products[i-1];\n\n    for(int cost = 0; cost <= budget; cost++)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int count = 0; count <= capacity; count++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(cost < product.price || count < product.quantity)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][cost][count] = DP[i-1][cost][count];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][cost][count] = max\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i-1][cost][count],\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i-1][cost \u2013 product.price][count \u2013 product.quantity] + product.value\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    cout << DP[N][budget][capacity] << endl;\n    }\u00a0\u00a0\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n    const int UNKNOWN = 1e9;\n    const char EMPTY_SPACE = '.';\n    const string roads = \"-|/\\\\\";\n    struct Point\n    {\n    \u00a0\u00a0\u00a0\u00a0int x;\n    \u00a0\u00a0\u00a0\u00a0int y;\n    \u00a0\u00a0\u00a0\u00a0Point(){}\n    \u00a0\u00a0\u00a0\u00a0Point(int x, int y) : x(x), y(y) {}\n    };\n    int N;\n    int H, W;\n    vector<string> grid;\n    vector<vector<int>> terrain;\n    vector<vector<int>> cost;\n    vector<Point> houses;\n    ```", "```cpp\n    void Input()\n    {\n    \u00a0\u00a0\u00a0\u00a0cin >> H >> W;\n    \u00a0\u00a0\u00a0\u00a0cin >> N;\n    \u00a0\u00a0\u00a0\u00a0grid.resize(H);\n    \u00a0\u00a0\u00a0\u00a0houses.resize(N);\n    \u00a0\u00a0\u00a0\u00a0terrain.resize(H, vector<int>(W, UNKNOWN));\u00a0\u00a0\u00a0\u00a0cost.resize(H, vector<int>(W, UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0// Map of property\n    \u00a0\u00a0\u00a0\u00a0for(auto &row : grid) cin >> row;\n    \u00a0\u00a0\u00a0\u00a0// Terrain ruggedness\n    \u00a0\u00a0\u00a0\u00a0for(int I = 0; i < H; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j = 0; j < W; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> terrain[i][j];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// House coordinates\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < N; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cin >> houses[i].x >> house[i].y;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Set house labels in grid\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0grid[houses[i].y][houses[i].x] = char(i + 'A');\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    bool DirectLine(Point a, Point b)\n    {\n    \u00a0\u00a0\u00a0\u00a0return a.x == b.x || a.y == b.y || abs(a.x \u2013 b.x) == abs(a.y \u2013 b.y);\n    }\n    ```", "```cpp\n    int GetCost(int start, int end)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point a = houses[start];\n    \u00a0\u00a0\u00a0\u00a0Point b = houses[end];\n    \u00a0\u00a0\u00a0\u00a0// The values by which the coordinates change on each iteration\n    \u00a0\u00a0\u00a0\u00a0int x_dir = 0;\n    \u00a0\u00a0\u00a0\u00a0int y_dir = 0;\n    \u00a0\u00a0\u00a0\u00a0if(a.x != b.x)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x_dir = (a.x < b.x) ? 1 : -1;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(a.y != b.y)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y_dir = (a.y < b.y) ? 1 : -1;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0int cost = 0;\n\n    \u00a0\u00a0\u00a0\u00a0do\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a.x += x_dir;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a.y += y_dir;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cost += terrain[a.y][a.x];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0while(grid[a.y][a.x] == '.');\n    \u00a0\u00a0\u00a0\u00a0return (a != b) ? UNKNOWN : res;\n    }\n    ```", "```cpp\n    struct Point\n    {\n    \u00a0\u00a0\u00a0\u00a0......\n    \u00a0\u00a0\u00a0\u00a0bool operator !=(const Point &other) const { return x != other.x || y != other.y; }\n    }\n    ```", "```cpp\n    void GetAdjacencies()\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < N; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j = 0; j < N; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(DirectLine(houses[i], houses[j])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cost[i][j] = cost[j][i] = GetCost(i, j);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void GetShortestPaths()\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> dist(N, vector<int>(N, UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0vector<vector<int>> next(N, vector<int>(N, UNKNOWN));\n    for(int i = 0; i < N; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int j = 0; j < N; j++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i][j] = cost[i][j]\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(dist[i][j] != UNKNOWN)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next[i][j] = j;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0dist[i][j] = 0;\n    \u00a0\u00a0\u00a0\u00a0next[i][i] = i;\n    }\n    ...\n    }\n    ```", "```cpp\n    for(int mid = 0; mid < N; mid++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int start = 0; start < N; start++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int end = 0; end < N; end++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(dist[start][end] > dist[start][mid] + dist[mid][end])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[start][end] = dist[start][mid] + dist[mid][end];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next[start][end] = next[start][mid];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    vector<int> GetPath(int start, int end, vector<vector<int>> &next)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> path = { start };\n    \u00a0\u00a0\u00a0\u00a0do\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0start = next[start][end];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.push_back(start);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0while(next[start][end] != end);\n    \u00a0\u00a0\u00a0\u00a0return path;\n    }\n    ```", "```cpp\n    for(int i = 0; i < N; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0auto path = GetPath(i, N \u2013 1, next);\n\n    \u00a0\u00a0\u00a0\u00a0int curr = i;\n    \u00a0\u00a0\u00a0\u00a0for(auto neighbor : path)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DrawPath(curr, neighbor);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = neighbor;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void DrawPath(int start, int end)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point a = houses[start];\n    \u00a0\u00a0\u00a0\u00a0Point b = houses[end];\n    \u00a0\u00a0\u00a0\u00a0int x_dir = 0;\n    \u00a0\u00a0\u00a0\u00a0int y_dir = 0;\n    \u00a0\u00a0\u00a0\u00a0if(a.x != b.x)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x_dir = (a.x < b.x) 1 : -1;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if(a.y != b.y)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y_dir = (a.y < b.y) 1 : -1;\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    int GetDirection(int x_dir, int y_dir)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(y_dir == 0) return 0;\n    \u00a0\u00a0\u00a0\u00a0if(x_dir == 0) return 1;\n    \u00a0\u00a0\u00a0\u00a0if(x_dir == -1)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (y_dir == 1) ? 2 : 3;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return (y_dir == 1) ? 3 : 2;\n    }\n    void DrawPath(int start, int end)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0int direction = GetDirection(x_dir, y_dir);\n    \u00a0\u00a0\u00a0\u00a0char mark = roads[direction];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    do\n    {\n    \u00a0\u00a0\u00a0\u00a0a.x += x_dir;\n    \u00a0\u00a0\u00a0\u00a0a.y += y_dir;\n\n    \u00a0\u00a0\u00a0\u00a0if(grid[a.y][a.x] == EMPTY_SPACE)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0grid[a.y][a.x] = mark;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if(!isalpha(grid[a.y][a.x]))\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If two roads of differing orientations intersect, replace symbol with '+'\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0grid[a.y][a.x] = (mark != grid[a.y][a.x]) ? '+' : mark;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    while(a != b);\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Input();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BuildGraph();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetShortestPaths();\n\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto it : grid)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << it << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```"]