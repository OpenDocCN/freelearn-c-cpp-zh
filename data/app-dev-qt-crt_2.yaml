- en: Chapter 2. Building Applications with Qt Creator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Qt Creator构建应用程序
- en: The first thing you're going to want to do with Qt Creator is figure out how
    to add source files and build (or debug) your project. This chapter is all about
    that—we'll go over how to add files to your project, how to create libraries to
    your project, and use the debugger and console logger. At the end of this chapter,
    you'll be driving Qt Creator to develop your console applications like a pro.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你要做的第一件事是弄清楚如何向Qt Creator添加源文件并构建（或调试）你的项目。本章就是关于这个的-我们将讨论如何向项目添加文件，如何创建库以及如何使用调试器和控制台记录器。在本章结束时，你将能够驾驭Qt
    Creator来开发你的控制台应用程序。
- en: Getting started – our sample library
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门-我们的示例库
- en: 'This chapter''s example code has two pieces: a library that defines a public
    function and a console application that calls that function. Libraries are a great
    way to break up your applications, and while this example is trivial, it also
    lets me show you how to create a library and include it in your application.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码有两个部分：定义公共函数的库和调用该函数的控制台应用程序。库是拆分应用程序的好方法，虽然这个例子很简单，但也让我向你展示如何创建一个库并将其包含在你的应用程序中。
- en: 'I''m going to stretch your imagination a bit: let''s pretend that you''re responsible
    for setting up a library of math functions. In this example, we''ll only write
    one function, `factorial`. You should remember the `factorial` function from introductory
    programming; it''s represented by *a!*, and is defined as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我要稍微拉伸一下你的想象力：假设你负责设置一个数学函数库。在这个例子中，我们只会编写一个函数，`factorial`。你应该记得从入门编程中的`factorial`函数；它用*a!*表示，并定义为：
- en: 0! is 0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0！是0
- en: 1! is 1
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1！是1
- en: '*n!* is *n × (n-1)!*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n!*是*n × (n-1)!*'
- en: 'This is a recursive definition, and we can code it this way:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归定义，我们可以这样编码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'An alternate definition that avoids the cost of function calls is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个避免函数调用成本的替代定义是：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Why did I pick the recursive definition? Three reasons: I think that it''s
    clearer, function-call performance overhead isn''t a big deal in this example,
    and many readers of this book may be using this book as part of introductory computer
    science courses where recursion is taught and should be reinforced.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我选择了递归定义？有三个原因：我认为这更清晰，函数调用的性能开销在这个例子中并不重要，并且本书的许多读者可能会将这本书作为入门计算机科学课程的一部分，递归是教授和应该加强的。
- en: 'Let''s begin by creating the library that implements our `factorial` function.
    To do this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建实现我们的`factorial`函数的库。要做到这一点：
- en: In Qt Creator, from the **File** menu, choose **New File or Project…**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Creator中，从**文件**菜单中选择**新建文件或项目…**。
- en: Choose **Libraries** in the left-hand pane of the dialog and **C++ Library**
    from the center pane.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框的左侧窗格中选择**库**，并从中央窗格中选择**C++库**。
- en: Qt Creator can create dynamic libraries (DLLs, in Windows parlance), static
    libraries, or plugins that can be shared between applications. We're going to
    create a static library, so in the next screen choose **Statically Linked Library**,
    and name it `MathFunctions`. Choose a reasonable path for the project.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Qt Creator可以创建动态库（在Windows中称为DLL）、静态库或可以在应用程序之间共享的插件。我们将创建一个静态库，所以在下一个屏幕上选择**静态链接库**，并将其命名为`MathFunctions`。选择一个合理的项目路径。
- en: In the next step of the wizard, leave the Qt version, **Debug**, and **Release**
    items checked.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导的下一步中，保持Qt版本、**调试**和**发布**项目选中。
- en: Libraries built by Qt Creator can rely on the Qt libraries themselves. Let's
    allow this library to rely on QtCore, the core data structures for Qt; in the
    **Select Required Modules** window, leave **QtCore** checked and click on **Next**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Qt Creator构建的库可以依赖于Qt库本身。让我们允许这个库依赖于QtCore，Qt的核心数据结构；在**选择所需模块**窗口中，保持**QtCore**选中，然后点击**下一步**。
- en: In the next window, you'll name the skeleton files that Qt Creator will add
    to your project. Click on **Next**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，你将命名Qt Creator将添加到你的项目中的骨架文件。点击**下一步**。
- en: In the **Project Management** window, choose **<None>** for the version control
    choice (we won't use version control for this project) and click on **Finish**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目管理**窗口中，选择版本控制选择**<无>**（我们不会为这个项目使用版本控制），然后点击**完成**。
- en: 'Edit `mathfunctions.h` to include a static method declaration for our `factorial`
    function:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`mathfunctions.h`以包括我们的`factorial`函数的静态方法声明：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open `mathfunctions.cpp`. You can do this one of two ways, by either double-clicking
    on it in the **Projects** pane, or by right-clicking on the `factorial` function
    and choosing **Switch Header/Source**. Write your `factorial` function; `mathfunctions.cpp`
    should read:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mathfunctions.cpp`。有两种方法可以做到这一点，一种是在**项目**窗格中双击它，另一种是右键单击`factorial`函数，然后选择**切换头/源**。编写你的`factorial`函数；`mathfunctions.cpp`应该是这样的：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Click on the **Projects** button on the left, and change the output path for
    the **Release** and **Debug** builds to point to the same directory, by editing
    the **Build directory** line under **General**, first for the **Release** and
    then for **Debug** build configurations. To do this, remove the `release` and
    `debug` portions of the directory path from the **Build directory** path. This
    way, when you build your library, Qt Creator will place release and debug builds
    of your library in a single folder instead of folders named `release` and `debug`,
    respectively.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**项目**按钮，并更改**发布**和**调试**构建的输出路径，通过编辑**常规**下的**构建目录**行，首先是**发布**，然后是**调试**构建配置。为了做到这一点，从**构建目录**路径中删除`release`和`debug`部分。这样，当你构建你的库时，Qt
    Creator会将你的库的发布和调试版本放在一个单独的文件夹中，而不是分别命名为`release`和`debug`的文件夹。
- en: As you write the code, note that Qt Creator prompts you at various stages about
    things it can deduce from your header with automatic suggestions (called **autosuggest**).
    For example, once you type `MathFunc`, it offers to autocomplete the class name
    or the C pre-processor guard; you can select either using the mouse, or just hit
    *Enter* to get the class name. Similarly, typing the double colons tells Qt Creator
    you're trying to enter something in the `MathFunctions` class, and prompts you
    with the `MathFunctions` class members; you can use the arrows to select `factorial`
    and hit *Enter*, and it types that. Finally, typing an opening parenthesis cues
    Qt Creator that you're defining a function, and prompts you with the arguments
    to that function you defined in the header file. You'll see this autocompletion
    a lot when you type code; it's a great way to learn Qt, too, because you can type
    a class name or part of a function name and Qt Creator prompts you with helpful
    hints along the way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，请注意Qt Creator在各个阶段会提示您从头文件中推断出的内容，并提供自动建议（称为**自动建议**）。例如，一旦您键入`MathFunc`，它会提供自动完成类名或C预处理器保护；您可以使用鼠标选择其中一个，或者只需按*Enter*获取类名。同样，键入双冒号告诉Qt
    Creator您正在尝试输入`MathFunctions`类，并提示您`MathFunctions`类成员；您可以使用箭头选择`factorial`并按*Enter*，它会自动输入。最后，键入开括号提示Qt
    Creator您正在定义一个函数，并提示您在头文件中定义的该函数的参数。当您输入代码时，您会经常看到这种自动完成；这也是学习Qt的好方法，因为您可以键入类名或部分函数名，Qt
    Creator会在途中提示您有用的提示。
- en: Before you continue, be sure you've built your library in both the release and
    debug configurations. The easiest way to do this is to click on the build selector
    on the bottom left and choose either **Release** or **Debug**, and then click
    on the hammer icon to perform a build.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已经在发布和调试配置中构建了您的库。这样做的最简单方法是单击左下角的构建选择器，然后选择**发布**或**调试**，然后单击锤子图标进行构建。
- en: Learning the landscape – the Build menu and .pro files
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习景观——构建菜单和.pro文件
- en: In the previous chapter, you learned how to build applications by hitting the
    hammer button in the corner of Qt Creator's main window, or by starting the debugger.
    To just build your library—or any application—you can either use the hammer icon
    or various choices in the **Build** menu. The obvious choice is either **Build
    All** or **Rebuild All**; choosing **Build All** recompiles only those files that
    Qt Creator recognizes as those that need to be rebuilt; **Rebuild All** cleans
    the project of all object files and rebuilds the entire project from scratch.
    In most cases, it's sufficient to choose **Build All**, and that's what you want
    to do, because it's faster. Sometimes you really do want to rebuild the whole
    project, when Qt's `make` system can't reconcile all the dependencies (or, you've
    made changes to the dependencies). Choose **Build All** now, and wait for it to
    build while we discuss the other options.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学会了如何通过点击Qt Creator主窗口角落的锤子按钮或启动调试器来构建应用程序。要构建您的库或任何应用程序，您可以使用锤子图标或**构建**菜单中的各种选项。明显的选择是**构建所有**或**重新构建所有**；选择**构建所有**只重新编译Qt
    Creator识别为需要重新构建的文件；**重新构建所有**清理项目的所有对象文件，并从头开始重新构建整个项目。在大多数情况下，选择**构建所有**就足够了，这也是您想要做的，因为它更快。有时，当Qt的`make`系统无法协调所有依赖关系时（或者您已经对依赖关系进行了更改），您确实需要重新构建整个项目。现在选择**构建所有**，并等待它构建，同时我们讨论其他选项。
- en: The **Build** menu lets you build a single file—handy, if all you want to do
    is check the syntax of the code you're writing and make sure you're free of errors—or
    the entire project. It also lets you run the project outside of the debugger,
    which you might want to do in some circumstances, like giving a demonstration.
    You can also clean your project (remove all object files and other autogenerated
    products) by choosing **Clean All**. The **Publish** option is available for some
    add-on kits that let you publish compiled applications and libraries to application
    stores and repositories; you can find more details about that in the documentation
    of any Qt Creator add-in, such as the SDKs for Maemo development (an older Linux
    variant from Nokia for handheld devices).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建**菜单允许您构建单个文件——如果您只想检查正在编写的代码的语法并确保没有错误，或者整个项目。它还允许您在调试器之外运行项目，在某些情况下可能需要这样做，比如进行演示。您还可以通过选择**清除所有**来清理项目（删除所有对象文件和其他自动生成的产品）。**发布**选项适用于一些附加工具包，这些工具包允许您将编译的应用程序和库发布到应用商店和存储库；您可以在任何Qt
    Creator插件的文档中找到有关此内容的更多详细信息，例如用于Maemo开发的SDK（诺基亚旧版Linux变体，用于手持设备）。'
- en: 'Behind every Qt Creator project is a `.pro` file; this serves the same function
    as a `make` file, and, in fact, is processed by a Qt toolkit command called `qmake`.
    (Make files are files processed by the `make` command, which indicate what files
    should be compiled in what order to generate an executable.) These files are declarative,
    in that you declare the relationship between the files that make up your application,
    and `qmake` figures out how to build your application from there. In most cases
    you''ll need to make few or no changes to a `.pro` file, but it doesn''t hurt
    to understand how they work. Double-click on `MathFunctions.pro`, and you''ll
    find:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Qt Creator项目背后都有一个`.pro`文件；这个文件的作用与`make`文件相同，并且实际上是由一个名为`qmake`的Qt工具命令处理的。（Make文件是由`make`命令处理的文件，指示应以何种顺序编译文件以生成可执行文件。）这些文件是声明性的，您在其中声明了构成应用程序的文件之间的关系，`qmake`会从中找出如何构建您的应用程序。在大多数情况下，您可能需要对`.pro`文件进行很少或没有更改，但了解它们的工作原理也无妨。双击`MathFunctions.pro`，您会发现：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The basic syntax of a `.pro` file is variable assignments; this file, generated
    by Qt Creator for us, assigns the following variables:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pro`文件的基本语法是变量赋值；Qt Creator为我们生成的这个文件分配了以下变量：'
- en: The `QT` variable indicates the Qt modules your project will link against. By
    default, all projects include QtCore and QtGui; there's a plethora of other modules
    available, which include key features such as the WebKit web browsing engine (`QtWebkit`)
    and multimedia libraries (`Phonon`). Our assignment here, indicates that we use
    the default Qt modules, but don't link against `QtGui`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT`变量指示您的项目将链接的Qt模块。默认情况下，所有项目都包括QtCore和QtGui；还有大量其他可用的模块，其中包括关键功能，如WebKit网络浏览引擎（`QtWebkit`）和多媒体库（`Phonon`）。我们在这里的任务是指出我们使用默认的Qt模块，但不链接`QtGui`。'
- en: The `TARGET` variable is the name of the compiled library or executable.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET`变量是编译库或可执行文件的名称。'
- en: The `TEMPLATE` variable indicates the kind of `qmake` template `qmake` should
    use to generate the binary; in our case, we're saying it should use the template
    to create a `lib` file—a library.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEMPLATE`变量指示`qmake`应该使用哪种模板来生成二进制文件；在我们的情况下，我们说它应该使用模板来创建一个`lib`文件-一个库。'
- en: The `CONFIG` variable passes an additional configuration to the template of
    `qmake`; here, we say that we want a statically linked library.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG`变量将额外的配置传递给`qmake`的模板；在这里，我们说我们想要一个静态链接的库。'
- en: The `SOURCES` and `HEADERS` variables contain lists of the source and header
    files that make up your project.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCES`和`HEADERS`变量包含构成项目的源文件和头文件的列表。'
- en: The `INSTALLS` variable indicates where the resulting build product should be
    installed. Here, it's set in a scope. Scopes let you specify conditional options
    in `qmake`; the condition for the scope is a variable or expression, which may
    be `true` or `false`, and the code that follows is executed if the variable is
    `true`. The scope at the end of this file says, "If we're building for a `unix`
    variant and the variant isn't `symbian`, set the `target.path` variable to `/opt/usr/lib`
    if the `unix` variant is `maemo`, otherwise set it to `/usr/lib` for other `unix`
    variants, and in either case, set the `INSTALLS` variable to `target`".
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALLS`变量指示应该安装生成的构建产品的位置。在这里，它设置在一个范围内。范围允许您在`qmake`中指定条件选项；范围的条件是一个变量或表达式，可以是`true`或`false`，如果变量为`true`，则执行后面的代码。文件末尾的范围表示：“如果我们正在构建`unix`变体，并且变体不是`symbian`，则将`target.path`变量设置为`/opt/usr/lib`，如果`unix`变体是`maemo`，否则将其设置为`/usr/lib`，对于其他`unix`变体，并且在任何情况下，将`INSTALLS`变量设置为`target`”。'
- en: These are the basic variables you'll find in almost any `.pro` file; for a good
    discussion of `qmake` scopes you can use to control conditional compilation, see
    [http://bit.ly/163tAIh](http://bit.ly/163tAIh). Two additional variables you're
    likely to want to know about are `DEFINES` and `LIBS`; `DEFINES` lets you specify
    preprocessor defines that should be set throughout the build process, and `LIBS`
    indicates additional libraries against which Qt Creator should link your project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您几乎可以在任何`.pro`文件中找到的基本变量；有关您可以使用的`qmake`范围的详细讨论，可以参见[http://bit.ly/163tAIh](http://bit.ly/163tAIh)。您可能还想了解的两个附加变量是`DEFINES`和`LIBS`；`DEFINES`允许您指定在整个构建过程中应设置的预处理器定义，而`LIBS`指示Qt
    Creator链接项目的附加库。
- en: 'Note how variables are managed: you use `=` for assignment, `+=` to add an
    item to a list, and `-=` to remove an item from a list.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意变量的管理方式：使用`=`进行赋值，使用`+=`向列表中添加项目，使用`-=`从列表中删除项目。
- en: Linking against our sample library
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接到我们的示例库
- en: 'Now, let''s make an application that depends on our library. Our application
    will call the `factorial` function in the library, statically linking to the library
    to access the `factorial` function. To accomplish this, you need to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们制作一个依赖于我们的库的应用程序。我们的应用程序将调用库中的`factorial`函数，静态链接到库以访问`factorial`函数。为了实现这一点，您需要：
- en: Choose **Close All Projects and Editors** from the **File** menu.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文件**菜单中选择**关闭所有项目和编辑器**。
- en: Choose **New File or Project…** from the **File** menu, and create a new Qt
    console application called `MathFunctionsTest` using the wizard.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文件**菜单中选择**新文件或项目…**，并使用向导创建一个名为`MathFunctionsTest`的新Qt控制台应用程序。
- en: Right-click on **MathFunctionsTest**, and choose **Add Library**. You can then
    choose a library in your build tree, one outside your build tree, or an external
    library on your system like the Unix math library, `ffmpeg`, or another library
    you've created. Choose **External Library** and click on **Next**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**MathFunctionsTest**，然后选择**添加库**。然后可以选择构建树中的库，构建树之外的库，或者系统上的外部库，如Unix数学库、`ffmpeg`或其他您创建的库。选择**外部库**，然后单击**下一步**。
- en: Browse to the library file that was built in the previous section by clicking
    on **Browse** next to the line labeled **Library file**. It'll be in a folder
    named something like `build-MathFunctions-Desktop_Qt_5_0_2_MSVC2012_64bit` in
    your project's folder. Choose the `MathFunctions` library in either the `release`
    or `debug` folders—it doesn't matter which.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**浏览**旁边标有**库文件**的行来浏览上一节中构建的库文件。它将在项目文件夹中的名为`build-MathFunctions-Desktop_Qt_5_0_2_MSVC2012_64bit`的文件夹中。在`release`或`debug`文件夹中选择`MathFunctions`库，无论选择哪个都可以。
- en: Browse to include files for your library by clicking on **Browse** next to **Include
    path**; this is the directory where you put the headers for your library.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**浏览**旁边的**包含路径**来浏览库的包含文件；这是您放置库头文件的目录。
- en: Choose static linking; if you were linking a dynamically linked library, of
    course you'd choose **Dynamic**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择静态链接；如果您链接的是动态链接库，当然您会选择**动态**。
- en: Leave the other values set to their defaults, click on **Next** and then on
    **Finish**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他值保持为默认值，然后单击**下一步**，然后单击**完成**。
- en: Qt Creator will work its magic with your .pro file, adding a `LIBS` variable
    that includes the output of your library build and an include path to your library's
    header files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator将使用您的.pro文件进行魔术操作，添加一个包含您的库构建输出的`LIBS`变量，并包含您的库头文件的包含路径。
- en: 'We can now call our `factorial` function. Edit `main.cpp` to read:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用我们的`factorial`函数。编辑`main.cpp`以读取：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code first includes our library header file. Note that if you compile the
    application after adding just the `#include` declaration, you'll get autosuggest
    help for every element of the `MathFunctions` library. This code uses `qDebug`
    instead of the C standard library to perform its console output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先包含了我们的库头文件。请注意，如果你在添加了`#include`声明后编译应用程序，你将为`MathFunctions`库的每个元素获得自动建议帮助。这段代码使用`qDebug`而不是C标准库来执行控制台输出。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `qDebug()` function actually has a stream-savvy implementation too. I could
    have written the `qDebug` line as
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`qDebug()`函数实际上也有一个流智能的实现。我本可以将`qDebug`行写成'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and the code would have generated the same output.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将生成相同的输出。
- en: Now, build and run the application in debug mode; you should see a console window
    with the text `6! is 720`. Try building and running the library in release mode;
    wait, why is the debugging output from `qDebug` still there?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在调试模式下构建和运行应用程序；你应该看到一个带有文本`6! is 720`的控制台窗口。尝试在发布模式下构建和运行库；等等，为什么`qDebug`的调试输出还在那里？
- en: '`qDebug` isn''t really a debugging log, it''s an output stream for debugging
    information regardless of build levels. If you want to turn off its output in
    release builds, you''ll need to edit the `.pro` file. Double-click on your `.pro`
    file, and add the line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`qDebug`实际上不是一个调试日志，它是一个用于调试信息的输出流，不受构建级别限制。如果你想在发布构建中关闭它的输出，你需要编辑`.pro`文件。双击你的`.pro`文件，并添加以下行：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is another scope: it says that if your build configuration is release,
    add the preprocessor definition `QT_NO_DEBUG_OUTPUT` to the list of preprocessor
    definitions for the project.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个范围：它表示如果你的构建配置是发布，将`QT_NO_DEBUG_OUTPUT`预处理器定义添加到项目的预处理器定义列表中。
- en: Now, if you rebuild (don't just choose build, but actually choose rebuild, because
    you want a clean build through the entire system) and run in release mode, you
    won't see any output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新构建（不只是选择构建，而是选择重新构建，因为你希望整个系统进行一次干净的构建）并在发布模式下运行，你将看不到任何输出。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Qt actually defines four output streams, one for debugging messages and one
    for bona fide warnings. Use `qDebug` for regular logging and `qWarning` to output
    messages of a higher priority. There''s also `qCritical` and `qFatal` for higher-priority
    log messages that should indicate critical failures, or failures that cause the
    application to terminate. You can also turn off warnings in release builds the
    same way; simply add the following to your `.pro` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Qt实际上定义了四个输出流，一个用于调试消息，一个用于真正的警告。使用`qDebug`进行常规日志记录，使用`qWarning`输出优先级更高的消息。还有`qCritical`和`qFatal`用于指示关键失败或导致应用程序终止的更高优先级日志消息。你也可以以相同的方式在发布构建中关闭警告；只需将以下内容添加到你的`.pro`文件中：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What if you want to add files to your project? You can either do it by manually
    editing the `.pro` file, which can be faster if you''re a good typist, but also
    error prone and result in weird build problems if you mess up, or right-click
    on your project and choose either **Add New…** or **Add Existing Files…**. The
    **Add New…** option opens up a short wizard with choices like these:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向项目添加文件怎么办？你可以通过手动编辑`.pro`文件来做，如果你是一个熟练的打字员，这可能更快，但也容易出错，如果搞砸了会导致奇怪的构建问题，或者右键单击你的项目，然后选择**添加新建…**或**添加现有文件…**。**添加新建…**选项打开一个简短的向导，提供了这样的选择：
- en: C++ header and source files
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++头文件和源文件
- en: Qt Designer forms that we'll talk about in the next chapter
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论的Qt Designer表单
- en: Qt Resource files that we'll talk about in the next chapter
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论的Qt资源文件
- en: Qt Quick Markup (QML) files
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick标记（QML）文件
- en: JavaScript files (which can contain the code implementing the logic of a Qt
    Quick application)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript文件（可以包含实现Qt Quick应用程序逻辑的代码）
- en: OpenGL shaders for fragments or vertices in either full OpenGL or OpenGL/ES
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于完整OpenGL或OpenGL/ES中片段或顶点的OpenGL着色器
- en: Text files (like a `Readme` file for your project) or a scratch file to use
    as a place to stash temporary clipboard items until you're done with an editing
    session
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本文件（比如项目的`Readme`文件）或一个用作临时剪贴板项目存放处的草稿文件，直到你完成编辑会话
- en: 'Before we move on to the important topic of debugging, let''s look at one more
    `.pro` file, the `.pro` file for our application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论调试的重要主题之前，让我们再看一个应用程序的`.pro`文件：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Phew! That's pretty dense. Let's see if we can unravel it. It begins by telling
    the build system that we use QtCore, but not QtGui. Next up, is the instruction
    to disable the `qDebug` messages in release builds, which won't happen by default.
    The `TARGET`, `CONFIG`, and `TEMPLATE` options together say that we're building
    a console application with the name `MathFunctionsTest`. The next line indicates
    that we have one source file, `main.cpp`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！这相当密集。让我们看看我们能不能解开它。它首先告诉构建系统我们使用QtCore，但不使用QtGui。接下来的指令是在发布构建中禁用`qDebug`消息，这不会默认发生。`TARGET`、`CONFIG`和`TEMPLATE`选项一起表示我们正在构建一个名为`MathFunctionsTest`的控制台应用程序。下一行指示我们有一个源文件`main.cpp`。
- en: The next set of scopes indicates the path to our library, and handles the fact
    that our libraries are in different directories on Windows for `release` and `debug`—this
    is different from on Unix systems, where there is only one `build` variant of
    the library. After that, comes the `INCLUDEPATH` and `DEPENDPATH` variables, which
    indicate that there are library headers in the `MathFunctions` directory, and
    that the application depends on those headers. So, if the timestamps on the headers
    change, the binary should rebuild. The final scope specifies the same dependency
    on the output library itself; if the library changes, the application executable
    has to be rebuilt. This is especially important, because that way we can run multiple
    copies of Qt Creator, edit our library and application files separately, building
    the bits we need of either after they change. When we do so that way, all the
    dependencies get figured out and the right bits of the library and application
    get built automatically.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组范围指示了我们库的路径，并处理了我们的库在Windows上的`release`和`debug`目录不同的情况——这与Unix系统不同，在Unix系统中库只有一个`build`变体。之后是`INCLUDEPATH`和`DEPENDPATH`变量，指示`MathFunctions`目录中有库头文件，并且应用程序依赖于这些头文件。因此，如果头文件的时间戳发生变化，二进制文件应该重新构建。最后一个范围指定了对输出库本身的相同依赖；如果库发生变化，应用程序可执行文件必须重新构建。这一点尤为重要，因为这样我们可以运行多个Qt
    Creator的副本，分别编辑我们的库和应用程序文件，在它们发生变化后构建我们需要的部分。当我们这样做时，所有的依赖关系都会被解决，库和应用程序的正确部分会自动构建。
- en: Getting lost and found again – debugging
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迷失和重新找到——调试
- en: Qt Creator has a state-of-the-art GUI that hooks into either the GNU debugger
    GDB, or Microsoft's command-line debugger CDB, if you use Microsoft tools.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator拥有一流的GUI，可以连接到GNU调试器GDB，或者如果你使用Microsoft工具，还可以连接到Microsoft的命令行调试器CDB。
- en: 'If you''ve installed Qt Creator on Mac OS or Linux, or the MinGW version of
    Qt Creator for Windows, you have everything you need to begin debugging your application.
    If you already had Microsoft Visual Studio installed and installed a version of
    Qt Creator that uses Microsoft''s compiler, you need to also install the Microsoft
    command-line debugger to use Qt Creator''s debugging features. Here''s how to
    install the command-line debugger:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Mac OS或Linux上安装了Qt Creator，或者在Windows上安装了MinGW版本的Qt Creator，你已经拥有了开始调试应用程序所需的一切。如果你已经安装了Microsoft
    Visual Studio并安装了使用Microsoft编译器的Qt Creator版本，你还需要安装Microsoft命令行调试器以使用Qt Creator的调试功能。以下是安装命令行调试器的方法：
- en: Download the debugging tools for Windows, at either [http://bit.ly/1dWoqi0](http://bit.ly/1dWoqi0)
    if you are using the 32-bit version of the compiler and Qt Creator, or [http://bit.ly/12kEtGt](http://bit.ly/12kEtGt)
    for the 64-bit version of the compiler and Qt Creator.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Windows的调试工具，如果你使用32位版本的编译器和Qt Creator，请访问[http://bit.ly/1dWoqi0](http://bit.ly/1dWoqi0)，如果你使用64位版本的编译器和Qt
    Creator，请访问[http://bit.ly/12kEtGt](http://bit.ly/12kEtGt)。
- en: Configure the debugging symbol server by going to **Options** under the **Tools**
    menu, choosing the **Debugger** item on the left, choosing the **CDB** pane, and
    clicking on **Edit** next to the **Symbol Paths** line.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**工具**菜单下的**选项**，选择左侧的**调试器**项目，选择**CDB**选项卡，然后点击**符号路径**行旁边的**编辑**来配置调试符号服务器。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Usually, the debugger works out of the box with Qt Creator, unless you're using
    the Microsoft toolchain. However, if you encounter problems, consult the Qt documentation
    on setting up the debugger at [http://bit.ly/19jgycQ](http://bit.ly/19jgycQ).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Qt Creator可以直接使用调试器，除非你使用的是Microsoft的工具链。但是，如果你遇到问题，请参考Qt文档中有关设置调试器的部分，网址是[http://bit.ly/19jgycQ](http://bit.ly/19jgycQ)。
- en: 'The following screenshot shows the debugger in action with our test project,
    stopped at a breakpoint:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了调试器在我们的测试项目中的运行情况，停在一个断点上：
- en: '![Getting lost and found again – debugging](img/2319OS_02_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![迷失和重新找到——调试](img/2319OS_02_01.jpg)'
- en: Qt Creator's Debug view in action
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator的调试视图运行中
- en: 'Let''s look at the screenshot in detail to get oriented:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下截图以便定位：
- en: On the left is the usual row of buttons to pick a view in Qt Creator
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧是Qt Creator中选择视图的通常按钮行
- en: Next to the buttons is the view of the project files and the list of open documents
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮旁边是项目文件的视图和打开文档的列表
- en: In the main editor pane, every source line has a clickable indicator to let
    you set and clear breakpoints
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主编辑窗格中，每个源代码行都有一个可点击的指示器，让你设置和清除断点。
- en: The call stack, indicating how the program got to the line execution is stopped
    at, is shown in the pane below the editor pane
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑器窗格下面的窗格中显示了调用堆栈，指示程序如何到达执行停止的行
- en: On the upper right is the variable inspector, where you can see the values of
    the variables in the current stack frame, along with any global variables
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右上角是变量检查器，你可以在当前堆栈帧中看到变量的值，以及任何全局变量。
- en: Below the variable inspector is a list of pending breakpoints, so you can turn
    on and off breakpoints without needing to hunt through the code
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量检查器下面是一个待处理断点的列表，这样你就可以在不需要在代码中搜索的情况下打开和关闭断点。
- en: To generate the previous screenshot, I clicked on the left of line **7**, placing
    a breakpoint, and then clicked on the **Debug** button on the left after ensuring
    I'd specified a debug build in the build selector. Qt Creator built the application
    in debug mode, started the application, and let it run to the breakpoint on line
    **7**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成上面的截图，我点击了第7行的左侧，设置了一个断点，然后在构建选择器中确保我指定了一个调试构建，然后点击了左侧的**调试**按钮。Qt Creator以调试模式构建了应用程序，启动了应用程序，并让它运行到第7行的断点处。
- en: Setting breakpoints and stepping through your program
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置断点和逐行调试程序
- en: A breakpoint, if you haven't encountered the idea before, is just that—a point
    at which execution breaks and you can examine the program's state. Once stopped
    at a breakpoint, you can step into a function, or step over a line, executing
    your program one line at a time to see how it's behaving. In the **Debug** view,
    clicking on the left of the number line lets you set or clear breakpoints. While
    stopped at a breakpoint, a yellow arrow in the margin of the editor pane indicates
    the line of code that the processor is about to execute.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 断点，如果您以前没有遇到过这个概念，就是这样——执行中断的点，您可以检查程序的状态。一旦在断点处停止，您可以进入函数，或者跳过一行，逐行执行程序，以查看其行为。在**调试**视图中，单击行号左侧可以设置或清除断点。在断点处停止时，编辑窗格边缘的黄色箭头指示处理器即将执行的代码行。
- en: 'While at a breakpoint, several buttons appear above the call stack pane that
    let you control program flow. They are:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点处停止时，调用堆栈窗格上方会出现几个按钮，让您控制程序流程。它们是：
- en: The green continue button, which continues execution at the line indicated by
    the arrow. You can also continue by pressing the *F5* function key.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色继续按钮，继续执行由箭头指示的行。您也可以通过按下*F5*功能键来继续。
- en: The red stop button, which stops debugging altogether.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色停止按钮，完全停止调试。
- en: The step over button, which executes the current line and advances to the next
    line before stopping again. You can step over one line by pressing *F10*.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过按钮，执行当前行并在再次停止之前前进到下一行。您可以通过按下*F10*来跳过一行。
- en: The step into button, which enters the next function to be called and stops
    again. You can step into a function by pressing *F11*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入按钮，输入下一个要调用的函数并再次停止。您可以通过按下*F11*来进入函数。
- en: The step out button, which runs the remainder of the function in the current
    calling context before stopping again. You can step out of the current function
    by pressing *F11*.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳出按钮，在当前调用上下文中运行函数的其余部分，然后再次停止。您可以通过按下*F11*来跳出当前函数。
- en: The instruction-wise button (which looks like a little screen), which toggles
    the debugger between working a source line at a time and an assembly line at a
    time.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐条指令按钮（看起来像一个小屏幕），可以在源代码行和汇编代码行之间切换调试器。
- en: There's also a menu of threads, so you can see which thread is running or stopped.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个线程菜单，因此您可以看到哪个线程正在运行或停止。
- en: If (in the previous screenshot) from line **7** we step over line **8** (pressing
    *F10*) and then press *F11*, we'll end up inside our `factorial` function, as
    you see in the next screenshot. I've clipped the screenshot so you only see the
    relevant panes of the debugger that have changed, and resized the window a bit,
    so you can see the whole call stack.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（在上一张屏幕截图中）从第**7**行跳过第**8**行（按下*F10*），然后按下*F11*，我们将进入我们的`factorial`函数，就像您在下一张屏幕截图中看到的那样。我已经裁剪了屏幕截图，所以您只能看到调试器中已更改的相关窗格，并且稍微调整了窗口大小，以便您可以看到整个调用堆栈。
- en: '![Setting breakpoints and stepping through your program](img/2319OS_02_02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![设置断点并逐步执行程序](img/2319OS_02_02.jpg)'
- en: The debugger about to enter a function
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器即将进入函数
- en: 'At this point, if we step one more line (*F10*) again, we''ll see the value
    for **n** change in the right-hand column, and the arrow advance to point at line
    **9** (again, as numbered in the screenshot). From here, we can debug my function
    in several ways:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果我们再次步进一行（*F10*），我们将看到右侧列中**n**的值发生变化，并且箭头将前进指向第**9**行（再次，如屏幕截图中编号的那样）。从这里，我们可以以几种方式调试我的函数：
- en: We can examine the contents of a variable by looking at it in the right-hand
    pane. If it's in a stack frame above the current calling frame, we can change
    call frames and see variables in a different call frame too.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查看右侧窗格中的变量来检查变量的内容。如果它在当前调用帧的上方的堆栈帧中，我们可以更改调用帧并查看不同调用帧中的变量。
- en: We can modify a variable by clicking on its value and entering a new value.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过单击其值并输入新值来修改变量。
- en: With some debuggers, we can move the arrow to different lines in the calling
    function to skip one or more lines of code, or rewind the execution to re-run
    a segment of code over again.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些调试器，我们可以将箭头移动到调用函数中的不同行，以跳过一个或多个代码行，或者倒带执行以重新运行代码段。
- en: This last feature—which unfortunately doesn't work with CDB—is especially powerful,
    because we can step through a program, observe an error, modify variables to work
    around the course of the error, and continue testing our code without needing
    to recompile our code and re-run our executable. Or, we can skip a bit of code
    that we know takes a while to run by substituting the new state in the variables
    in question and continuing from a new location in the current call frame.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的功能——不幸的是，它与CDB不兼容——特别强大，因为我们可以逐步执行程序，观察错误，修改变量以解决错误的过程，并继续测试我们的代码，而无需重新编译代码和重新运行可执行文件。或者，我们可以通过替换相关变量的新状态并从当前调用帧的新位置继续，跳过我们知道需要花费很长时间运行的一部分代码。
- en: 'There are also a number of other things we can do, from how we debug the application
    to various ways we can view the state of our application when it''s running. On
    the main **Debug** menu, we can:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他事情可以做，从调试应用程序的方式到在应用程序运行时查看应用程序状态的各种方式。在主**调试**菜单上，我们可以：
- en: Detach the debugger from a running process by choosing **Detach** from the **Debug**
    menu (handy if the debugger is slowing things down and we know that part of our
    code doesn't need to be debugged).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从**调试**菜单中选择**分离**来从运行中的进程中分离调试器（如果调试器减慢了速度，而我们知道我们的代码的一部分不需要调试，这很方便）。
- en: Interrupt program execution, stop execution, and examine the current state by
    choosing **Interrupt** from the **Debug** menu (useful if our application seems
    caught in a long loop we weren't expecting and appears hung).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从**调试**菜单中选择**中断**来中断程序执行，停止执行并检查当前状态（如果我们的应用程序似乎陷入了一个我们没有预料到的长循环并且似乎挂起，这很有用）。
- en: While stopped, we can run to the line the cursor is on by choosing **Run to
    Line** or press *Ctrl* + *F10*.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在停止时，我们可以通过选择**运行到行**或按下*Ctrl* + *F10*来运行光标所在的行。
- en: While stopped, we can skip to the line the cursor is on by choosing **Jump to
    Line**.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止时，我们可以通过选择**跳转到行**来跳转到光标所在的行。
- en: Fine-grained control of breakpoints
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点的精细控制
- en: 'If you right-click in the breakpoint pane, you can add, edit, or delete breakpoints.
    Hitting **Add Breakpoint…** or **Edit Breakpoint…** brings up the Breakpoint Editor,
    a daunting dialog given the humble breakpoint itself. The following screenshot
    shows the Breakpoint Editor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在断点窗格中右键单击，可以添加、编辑或删除断点。点击**添加断点…**或**编辑断点…**会弹出断点编辑器，这是一个令人生畏的对话框，鉴于它只是一个简单的断点。以下截图显示了断点编辑器：
- en: '![Fine-grained control of breakpoints](img/2319OS_02_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![断点的精细控制](img/2319OS_02_03.jpg)'
- en: The Breakpoint Editor window
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 断点编辑器窗口
- en: 'From the editor, you can fine-tune a breakpoint, setting:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从编辑器中，您可以微调断点设置：
- en: 'The kind of breakpoint. Most breakpoints are by filename and line number—a
    specific line of the code—but you have several other choices, including:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点的类型。大多数断点是按文件名和行号进行的——代码的特定行——但您还有其他几种选择，包括：
- en: The entry point of a function by name
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名称的函数入口点
- en: When a memory address is reached for execution
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当内存地址被执行到
- en: When a C++ exception is thrown or caught
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当抛出或捕获C++异常时
- en: When a JavaScript exception occurs
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生JavaScript异常时
- en: When your main function starts
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的主函数开始时
- en: When a new process is forked
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个新进程被分叉时
- en: When a system call occurs
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统调用发生时
- en: When data is accessed at a fixed location, or an address indicated by an expression
    involving a pointer variable at runtime
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在固定位置访问数据，或者在运行时涉及指针变量的表达式指示的地址时
- en: The location of the breakpoint (such as the source line number and filename,
    or the function), depending on your choice from the previous list.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点的位置（例如源行号和文件名，或函数），取决于您在上一个列表中的选择。
- en: Whether the breakpoint is enabled or not.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论断点是否启用。
- en: Whether the breakpoint is one-shot, that is, will be disabled after it fires
    once.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点是否是一次性的，也就是说，触发一次后将被禁用。
- en: Conditions for the breakpoint, such as an expression in involving program variable
    values, how many times to ignore the breakpoint, and which threads the breakpoint
    applies to.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点的条件，例如涉及程序变量值的表达式，忽略断点的次数以及断点适用于哪些线程。
- en: Examining variables and memory
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查变量和内存
- en: The variables pane shows you the values of all the variables in the current
    stack frame. Structures show the values of their members, so you can walk through
    complex data structures as well. From the variables pane, you can also copy a
    variable name and value to the clipboard, or just a variable value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 变量窗格显示当前堆栈帧中所有变量的值。结构显示其成员的值，因此您也可以遍历复杂的数据结构。从变量窗格中，您还可以将变量名称和值复制到剪贴板，或者只复制变量值。
- en: From the variables pane, there's a really useful feature called the **Expression
    Evaluator**, which lets you construct algebraic expressions about variables in
    your code and see the results. For example, if I'm stopped at the beginning of
    the `factorial` function, as you see in the *The debugger about to enter a function*
    screenshot, with **n** set to `6`, I can right-click on the variables pane, choose
    **Insert New Expression Evaluator**, and type in a formula `n*(n-1)` in the dialog
    that appears, and a new line appears in the pane showing the expression and the
    value **30**. While this is a pretty contrived example, I can view pointer values
    and pointer dereferences as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从变量窗格中，有一个非常有用的功能称为**表达式求值器**，它允许您构建关于代码中变量的代数表达式并查看结果。例如，如果我停在`factorial`函数的开头，就像您在*调试器即将进入函数*截图中看到的那样，**n**设置为`6`，我可以右键单击变量窗格，选择**插入新表达式求值器**，然后在出现的对话框中输入一个公式`n*(n-1)`，然后窗格中会出现一个新行，显示表达式和值**30**。虽然这是一个相当牵强的例子，但我也可以查看指针值和指针解引用。
- en: 'I can also conditionally break execution when a variable changes; this is called
    a conditional breakpoint or a data breakpoint. For example, let''s put a loop
    in our main function, and break as we execute the loop. To do this, first change
    `main` to read:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量发生变化时，我还可以有条件地中断执行；这称为条件断点或数据断点。例如，让我们在主函数中放一个循环，并在执行循环时中断。要做到这一点，首先更改`main`如下：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will walk the values stored in the integer array values, and print the
    computed factorial of each value. Start debugging again, and let''s add a data
    breakpoint on `i`. To do this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历整数数组值中存储的值，并打印每个值的计算阶乘。重新开始调试，然后让我们在`i`上添加一个数据断点。要做到这一点：
- en: Put a breakpoint on the first line of `main`, the line initializing `QCoreApplication.`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`的第一行上设置一个断点，该行初始化`QCoreApplication`。
- en: Right-click on `i` in the left pane and choose **Add Data Breakpoint at Object's
    Address** from the **Add Data Breakpoint** submenu.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左窗格中右键单击`i`，然后从**添加数据断点**子菜单中选择**在对象地址处添加数据断点**。
- en: Continue by pressing *F5* or the **Continue** button.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*F5*或**继续**按钮继续。
- en: Execution will stop at line **11**, the beginning of the `for` loop, when `i`
    is set to `0`. Each time I hit *F5* to continue, the application runs until the
    value of `i` changes as a result of the `i++` statement at the end of the `for`
    loop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当`i`设置为`0`时，执行将在第**11**行停止，即`for`循环的开始。每次我按下*F5*继续，应用程序都会运行，直到`i`的值因`for`循环末尾的`i++`语句而发生变化。
- en: You can also inspect and change individual values of arrays in the variable
    inspector, by clicking on the expansion arrow next to the array name in the variable
    inspector pane.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过单击变量检查器窗格中数组名称旁边的展开箭头来检查和更改数组的单个值。
- en: 'In addition to viewing and changing variable values, you can also view and
    change individual memory locations. You might want to do that if you''re debugging
    a decoder or encoder for a binary format, for example, where you need to see a
    specific location in memory. From the variables pane, you have several choices:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看和更改变量值，您还可以查看和更改单个内存位置。例如，如果您需要查看内存中的特定位置，例如调试二进制格式的解码器或编码器，您可能需要这样做。从变量窗格中，您有几个选择：
- en: You can right-click on a given variable and open a memory window at that variable's
    address
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以右键单击给定变量并在该变量地址处打开内存窗口
- en: You can right-click on a given variable and open a memory window at the value
    that the variable points to (in other words, dereference a pointer to a memory
    location)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以右键单击给定变量并在变量指向的值处打开内存窗口（换句话说，解引用指向内存位置的指针）
- en: You can right-click on the variable pane and open up a memory browser at the
    beginning of the current stack frame
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以右键单击变量窗格，并在当前堆栈帧的开头打开内存浏览器
- en: You can right-click on the variable pane and open up a memory browser at an
    arbitrary location in memory
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以右键单击变量窗格，并在内存中的任意位置打开内存浏览器
- en: 'The following screenshot shows the memory viewer showing the memory that contains
    the values of the array values:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了内存查看器显示包含数组值的内存：
- en: '![Examining variables and memory](img/2319OS_02_04.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![检查变量和内存](img/2319OS_02_04.jpg)'
- en: The Memory Viewer window
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 内存查看器窗口
- en: 'The window shows the memory addresses down the left, the values of memory at
    sixteen bytes to a line (first in hexadecimal and then in ASCII), and colors the
    actual variable you''ve selected to open the window. You can select a range of
    values and then right-click to perform the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口显示左侧的内存地址，每行十六个字节的内存值（先是十六进制，然后是ASCII），并且突出显示你选择打开窗口的实际变量。您可以选择一系列值，然后右键单击执行以下操作：
- en: Copy the values in ASCII or hexadecimal
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以ASCII或十六进制形式复制值
- en: Set a data breakpoint on the memory location you've selected
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您选择的内存位置上设置数据断点
- en: Transfer execution to the address you've clicked (probably not what you want
    to do if you're viewing the data)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行转移到您单击的地址（如果您正在查看数据，这可能不是您想要做的）
- en: Examining the call stack
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查调用堆栈
- en: The **call stack** is the hierarchy of function calls in your application execution
    at a point in time. Although the actual flow varies, typically in your code it
    begins in `main`, although what calls `main` differs from platform to platform.
    An obvious use for the call stack is to provide context when you press the **Interrupt**
    button; if your program is just off contemplating its navel in a loop somewhere,
    clicking on **Interrupt** and looking at the call stack can give you a clue as
    to what's going on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用堆栈**是应用程序执行在某一时间点的函数调用层次结构。虽然实际流程各不相同，但通常在您的代码中，它始于`main`，尽管调用`main`的内容因平台而异。调用堆栈的一个明显用途是在按下**中断**按钮时提供上下文；如果您的程序在某个地方的循环中只是在思考问题，点击**中断**并查看调用堆栈可以给您一些线索。'
- en: 'Remember how I defined the `factorial` function in terms of itself? You can
    see this very clearly if you put a breakpoint in `factorial`, call it, and continue
    through the breakpoint a few times before looking at the call stack; you''ll see
    something akin to the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我如何定义`factorial`函数吗？如果您在`factorial`中设置断点，调用它，并在查看调用堆栈之前继续通过断点几次，您将看到类似以下屏幕截图的内容：
- en: '![Examining the call stack](img/2319OS_02_05.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![检查调用堆栈](img/2319OS_02_05.jpg)'
- en: The call stack of a recursive function in mid-computation
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的调用堆栈在中间计算时
- en: Working from left to right, the fields of the call stack window are the stack
    level (numbering from the top of the stack down), the function being invoked,
    the file the function is defined in, and the line number of the function currently
    being executed. So, this stack frame says that we're on line **9** of `MathFunctions::factorial`
    in `mathfunctions.cpp`, called by line **13** of **MathFunctions::factorial**,
    which is called by line **13** of `MathFunctions::factorial` and so on, until
    it bottoms out in our `main` function, and the system startup code that the operating
    system uses to set up the application process before that.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，调用堆栈窗口的字段是堆栈级别（从堆栈顶部向下编号），正在调用的函数，定义函数的文件，以及当前正在执行的函数的行号。因此，这个堆栈帧表示我们在`mathfunctions.cpp`的`MathFunctions::factorial`的第**9**行，由`MathFunctions::factorial`的第**13**行调用，依此类推，直到在我们的`main`函数中结束，并在此之前是操作系统用来设置应用程序进程的系统启动代码。
- en: 'If you right-click on a line of the call stack pane, you can:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您右键单击调用堆栈窗格的一行，您可以：
- en: Reload the stack, in case the display appears corrupted.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新加载堆栈，以防显示出现损坏。
- en: Copy the contents of the call stack to the clipboard; it is great for bug reports.
    If your application throws an exception or crashes in the debugger, you can copy
    the call stack and send it off to the developer responsible for that part of the
    code (or keep it for yourself as a souvenir).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用堆栈的内容复制到剪贴板；这对于错误报告非常有用。如果您的应用程序在调试器中抛出异常或崩溃，您可以复制调用堆栈并将其发送给负责该部分代码的开发人员（或者留作纪念品）。
- en: Open the memory editor at the address of the instruction at the line of code
    indicated by the function call in the call stack.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用堆栈中函数调用所指示的代码行的指令地址处打开内存编辑器。
- en: Open the disassembler at the address of the instruction at the line of code
    indicated by the function call in the call stack.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用堆栈中函数调用所指示的代码行的指令地址处打开反汇编器。
- en: Disassemble a region of memory or the current function.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反汇编内存区域或当前函数。
- en: Show the program counter address in the call stack window while debugging.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试时在调用堆栈窗口中显示程序计数器地址。
- en: The Projects pane and building your project
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目窗格和构建项目
- en: You've seen how the `.pro` file affects your project's compilation, but there's
    even more to it than that. If you click the **Projects** button on the left of
    Qt Creator, you'll see the project's options, which consist of the **Build & Run**
    options, the **Editor** options, the **Code Style** options, and **Dependencies**,
    each in their own panel.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了`.pro`文件如何影响项目的编译，但它的作用远不止于此。如果您在Qt Creator左侧点击**项目**按钮，您将看到项目选项，包括**构建和运行**选项，**编辑器**选项，**代码样式**选项和**依赖项**，每个选项都有自己的面板。
- en: In most cases, you won't need to monkey around with any of these settings. But
    you may need to tinker with the **Build & Run** settings, especially if you're
    targeting multiple platforms, such as Windows and Linux with cross-compilers,
    or Android and iOS once Digia finishes support for those platforms. (I write more
    about this exciting development in Qt later in this book.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您不需要调整这些设置。但是，您可能需要调整**构建和运行**设置，特别是如果您要针对多个平台进行目标设置，例如使用交叉编译器在Windows和Linux上，或者在Digia完成对这些平台的支持后，在Android和iOS上。
    （我稍后会在本书的后面更多地介绍这一激动人心的Qt发展。）
- en: 'The final thing you should know about is the build and run kit selector. Qt
    is one of the best cross-platform toolkits available today, and you can easily
    find yourself working on a system supporting multiple platforms, such as Linux
    and Android, or multiple versions of Qt. To support this, Qt has the notion of
    a build kit, which is just the headers, libraries, and associated stuff to support
    a specific platform. You can install multiple build kits, and choose which build
    kit you''re compiling against by choosing **Open Build** and **Run Kit Selector….**.
    By default, if you followed the steps in the previous chapter to install Qt Creator,
    you''ll have one build kit installed; from the Digia site, you can choose others.
    In a later chapter, we''ll build a sample application for Qt on Android. To do
    this, you''d need to download and install the Qt on Android build kit, and then
    tell Qt Creator about the new kit. Adding kits is easy, you just need to install
    the kit using your operating system, and then do the following in Qt Creator:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道的最后一件事是构建和运行工具包选择器。Qt是当今最好的跨平台工具包之一，您很容易发现自己在支持多个平台的系统上工作，例如Linux和Android，或者Qt的多个版本。为了支持这一点，Qt有一个构建工具包的概念，它只是支持特定平台的头文件、库和相关内容。您可以安装多个构建工具包，并通过选择**打开构建**和**运行工具包选择器…**来选择您要编译的构建工具包。默认情况下，如果您按照上一章中的步骤安装了Qt
    Creator，您将安装一个构建工具包；从Digia网站上，您可以选择其他工具包。在后面的章节中，我们将为Android上的Qt构建一个示例应用程序。为此，您需要下载并安装Qt
    on Android构建工具包，然后告诉Qt Creator有关新工具包。添加工具包很容易，您只需要在Qt Creator中安装工具包，然后按照以下步骤操作：
- en: Click on **Projects** on the left.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**项目**。
- en: Click on **Manage Kits…** on the upper left-hand side of the pane that appears.
    The **Build & Run** options window appears.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击出现的面板左上角的**管理工具包…**。**构建和运行**选项窗口将出现。
- en: Qt may autodetect your new kit, or you may need to add it by clicking on **Add**.
    Once you click on **Add**, you'll need to specify the target platform (such as
    an Android device), the compiler to use, and so forth.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Qt可能会自动检测到您的新工具包，或者您可能需要通过单击**添加**来添加它。单击**添加**后，您需要指定目标平台（例如Android设备）、要使用的编译器等。
- en: For the build settings, there are configuration options for your release and
    debug builds. In the **Build Settings** editor, you can control whether the build
    products are placed in their own directory (the default, a so-called shadow build
    where your build outputs are mixed with the source code), the `qmake` configuration
    for the build (and actually see how Qt Creator will invoke `qmake`), how Qt Creator
    cleans your project, and any environment variables you need to set for the build.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建设置，有发布和调试构建的配置选项。在**构建设置**编辑器中，您可以控制构建产品是否放置在它们自己的目录中（默认情况下，所谓的影子构建，其中您的构建输出与源代码混合），构建的`qmake`配置（实际上看到Qt
    Creator将如何调用`qmake`），Qt Creator如何清理您的项目，以及您需要为构建设置的任何环境变量。
- en: The run settings let you control whether your application runs locally or is
    deployed on a remote host (not always supported, but usually the case for platforms
    such as Android), any command-line arguments you want to pass to your applications,
    and the settings for the performance analyzer tool, which I will talk more about
    in [Chapter 4](ch04.html "Chapter 4. Localizing Your Application with Qt Linguist"),
    *Localizing Your Application with Qt Linguist*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行设置让您控制应用程序是在本地运行还是部署到远程主机（不一定始终支持，但通常适用于诸如Android之类的平台），您想要传递给应用程序的任何命令行参数，以及性能分析工具的设置，我将在[第4章](ch04.html
    "第4章。使用Qt Linguist本地化您的应用程序")中更多地谈到*使用Qt Linguist本地化您的应用程序*。
- en: In the **Editor** panel, you can set specific editor options for this project.
    These override the global Qt Creator defaults, which you can set by choosing **Options**
    from the **Tools** menu and selecting the **Text Editor** option. These options
    include details like whether to use tabs or spaces when formatting your code (I
    strongly suggest you use spaces; it's compatible with editors everywhere), the
    number of spaces per tab stop, whether or not automatic indentation occurs, how
    source files should be encoded, and so forth.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在**编辑器**面板中，您可以为此项目设置特定的编辑器选项。这些选项会覆盖全局Qt Creator默认设置，您可以通过选择**工具**菜单中的**选项**并选择**文本编辑器**选项来设置这些选项。这些选项包括诸如在格式化代码时是否使用制表符或空格（我强烈建议您使用空格；它与任何编辑器兼容）、每个制表位的空格数、是否自动缩进、源文件应该如何编码等细节。
- en: The **Code Style** panel is another override to the global settings for Qt Creator
    (this time, it's the C++ and Qt Quick panels of the **Options** dialog available
    from the **Options** menu). Here, you can pick default styles, or edit the styles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码风格**面板是Qt Creator全局设置的另一个覆盖（这次是C++和Qt Quick面板，可以从**选项**菜单中的**选项**对话框中找到）。在这里，您可以选择默认样式，或编辑样式。'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I'd strongly recommend that you pick a style that matches the existing source
    code you're editing; if you're starting from a blank page, the Qt default style
    is quite readable, and is my favorite.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您选择与您正在编辑的现有源代码相匹配的样式；如果您是从空白页面开始的，Qt默认样式非常易读，也是我最喜欢的。
- en: The **Dependencies** panel lets you set the build order if your project file
    contains multiple subprojects, so that things build in the right order. For example,
    we could choose to open both our library project and our test project; if we do,
    we'll see the `MathFunctions` library listed in the dependencies, and we can select
    that project to build before the test application is built.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖项**面板允许您设置构建顺序，如果您的项目文件包含多个子项目，以便以正确的顺序构建事物。例如，我们可以选择同时打开我们的库项目和测试项目；如果我们这样做，我们将在依赖项中看到`MathFunctions`库，并且我们可以选择在构建测试应用程序之前构建该项目。'
- en: A review – running and debugging your application
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾-运行和调试您的应用程序
- en: 'You''ll spend a lot of time editing, compiling, and debugging your code in
    Qt Creator, so, it''s wise to remember the following basics:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Creator中，您将花费大量时间编辑、编译和调试代码，因此，记住以下基础知识是明智的：
- en: The arrow key runs your application without the debugger; to debug your application,
    choose the arrow key with the bug icon on it.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头键在不使用调试器的情况下运行您的应用程序；要调试您的应用程序，请选择带有错误图标的箭头键。
- en: You can switch between the editor view and the debug view of your application
    by clicking on the **Edit** or **Debug** view choice on the left; if you debug
    your application, Qt Creator will enter the debug view automatically.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过单击左侧的**编辑**或**调试**视图选择在编辑器视图和调试视图之间切换您的应用程序；如果调试您的应用程序，Qt Creator将自动进入调试视图。
- en: There's more to breakpoints than just stopping at a line of code! Use data breakpoints
    to help pin down weird bugs that happen only sometimes, or to quickly skip over
    the first bazillion items of a large loop.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点比仅仅在代码行停止更有用！使用数据断点来帮助确定只有在某些时候发生的奇怪错误，或者快速跳过大循环的前几个项目。
- en: The variable pane lets you see more than just the contents of variables; you
    can also add expressions composed of several variables and arithmetic, or view
    arbitrary memory locations.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量窗格让您不仅可以查看变量的内容；您还可以添加由多个变量和算术组成的表达式，或查看任意内存位置。
- en: Want to hack around a bug during a debugging session? You can change the values
    of variables in the variable pane and continue running, changing the program state
    as you go.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要在调试会话期间解决错误？您可以在变量窗格中更改变量的值并继续运行，随着程序的进行改变程序状态。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Qt Creator's integrated development environment contains an editor and tools
    to start the compiler, linker, and debugger to build and debug your applications.
    Using it, you can start and stop your application, place breakpoints while your
    application is stopped, or examine variables or the logical flow of your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator集成开发环境包含编辑器和工具，用于启动编译器、链接器和调试器以构建和调试您的应用程序。使用它，您可以启动和停止应用程序，在应用程序停止时设置断点，或检查应用程序的变量或逻辑流程。
- en: While Qt Creator manages most of a project for you, sometimes you just have
    to get down and dirty with a `.pro` file. You can use scopes to handle conditional
    compilation (things like when building for a specific platform, or whether a file
    should be included in release or debug mode). The `.pro` file consists of scopes,
    variables, and their values; by setting the variables that the `.pro` file feeds
    `qmake`, `qmake` understands the dependencies in your project and magically creates
    a Make file to build your application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Qt Creator为您管理大部分项目，但有时您必须亲自动手处理`.pro`文件。您可以使用作用域来处理条件编译（例如在为特定平台构建时，或者文件是否应包含在发布或调试模式中）。`.pro`文件由作用域、变量及其值组成；通过设置`.pro`文件提供给`qmake`的变量，`qmake`了解项目中的依赖关系，并神奇地创建一个Make文件来构建您的应用程序。
- en: In the next chapter, we'll turn from the mechanics of making a project build
    and look at Qt Creator's UI designer, and give you a brief introduction into the
    worlds of both Qt Widgets and Qt Quick.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从制作项目构建的机制转向Qt Creator的UI设计师，并为您简要介绍Qt Widgets和Qt Quick的世界。
