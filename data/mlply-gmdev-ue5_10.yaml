- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Enhancing the Player Experience
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升玩家体验
- en: One of the best ways to improve a video game is to add a good look and feel
    to it. A great-looking game will create an immersive experience that will engage
    players and make them want to keep coming back for more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 提高视频游戏的最佳方式之一是为它添加良好的外观和感觉。一款外观出色的游戏将创造一个沉浸式的体验，吸引玩家并使他们想要不断回来玩。
- en: For this reason, it’s important for developers to focus on tweaking visual and
    audio feedback until everything looks just right! It might take some time, but
    getting these last touches right will make sure your video game has an awesome
    look and feel – something that players won’t forget anytime soon!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于开发者来说，专注于调整视觉和音频反馈，直到一切看起来都恰到好处非常重要！这可能需要一些时间，但确保这些最后的细节正确无误将确保您的视频游戏拥有令人惊叹的外观和感觉——这是玩家们短时间内不会忘记的！
- en: Keeping this in mind, the following chapter will concentrate on improving certain
    aspects, such as using different animations together and synchronizing them over
    the network, or adding **non-player characters** (**NPCs**) to interact with –
    features that your protagonist has longed for a considerable amount of time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，下一章将专注于改进某些方面，例如使用不同的动画组合并在网络上同步它们，或者添加**非玩家角色**（NPCs）进行交互——这些是主角渴望已久的特性。
- en: 'Additionally, you’ll be providing a purpose for your players to fight for:
    the daring rescue of some imprisoned comrades!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将为玩家提供一个战斗的理由：勇敢地营救一些被囚禁的同志！
- en: Finally, I’ll share some additional ideas to help guide you in completing your
    multiplayer game. This book may not have enough pages to cover every detail, but
    that shouldn’t stop your creativity and imagination from taking flight!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将分享一些额外的想法，以帮助您完成您的多人游戏。这本书可能没有足够的页面来涵盖每一个细节，但这不应该阻止您的创造力和想象力翱翔！
- en: By the end of this chapter, you will possess a sleek and robust prototype for
    your multiplayer game and be well equipped and prepared to embark on the next
    phase – learning how to optimize it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个光滑且健壮的多人游戏原型，并且将准备好开始下一阶段——学习如何优化它。
- en: 'In this chapter, I will guide you through the following sections:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将引导您通过以下部分：
- en: Animating the character
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为角色动画
- en: Adding NPC Actors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加NPC演员
- en: Making further improvements to the game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步改进游戏
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，您应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您希望从本书的配套仓库开始编写代码，您可以下载提供的`.zip`项目文件：
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 09``End` link.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击`Unreal Shadows – 第09章 结束`链接下载与上一章结尾一致的最新文件。
- en: Animating the character
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为角色动画
- en: So far, your hero has been exploring the dungeon and searching for hidden treasures
    while avoiding enemies, but there’s something missing that will really bring it
    to life – a proper animation system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的英雄一直在探索地牢，寻找隐藏的宝藏，同时避开敌人，但还有一些东西缺失，才能真正让它栩栩如生——一个合适的动画系统。
- en: In this section, I’ll guide you through the creation of simple animations that
    will work on the networked environment of your project. This will involve creating
    Blueprints specifically designed for the animation system and establishing their
    connection to your character class – you will be creating the needed animation
    assets and then adding the needed code to make everything work properly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将引导您创建简单的动画，这些动画将在您项目的网络环境中工作。这涉及到创建专门为动画系统设计的蓝图，并建立它们与您的角色类的连接——您将创建所需的动画资源，然后添加所需的代码以确保一切正常工作。
- en: Creating the animation assets
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动画资源
- en: Animating characters in Unreal Engine involves creating **Animation Blueprints**
    that handle the motion and logic of character movement and actions. This book
    doesn’t prioritize this topic – in fact, it’s not usually the main focus for game
    programmers! However, having some basic knowledge of how things work under the
    hood will be a good addition to your game development arsenal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中动画角色涉及创建**动画蓝图**来处理角色动作和移动的逻辑。本书并不优先考虑这个主题 – 实际上，这通常不是游戏程序员的主要关注点！然而，对内部工作原理有一些基本了解将有助于丰富你的游戏开发工具箱。
- en: 'To create a simple but fully functional animation system for the player character,
    we will need three assets:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要为玩家角色创建一个简单但功能齐全的动画系统，我们需要三个资源：
- en: An asset to control the movement transitions from idle to walk to run, and vice
    versa
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于控制从空闲到行走再到跑步，以及相反方向移动过渡的资源
- en: An asset used to play the throw animation
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于播放投掷动画的资源
- en: A Blueprint to control the two aforementioned assets
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个蓝图来控制上述两个资源
- en: To get started, we first need a folder to put all the assets in. So, open the
    Unreal Editor and, in `Animations`. Once it is created, you will be ready to add
    the first asset.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们首先需要一个文件夹来存放所有资源。因此，打开虚幻编辑器，在`Animations`中。一旦创建，你就可以添加第一个资源。
- en: Creating the movement Blend Space
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建运动混合空间
- en: In Unreal Engine, a **Blend Space** is a special asset that allows for the blending
    of animations based on the values of two inputs. It allows multiple animations
    to be blended by plotting them onto a one- or two-dimensional graph. Animators
    and game developers often use blend spaces to create smooth and realistic transitions
    between different animations for characters in games.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**混合空间**是一个特殊资源，允许根据两个输入值来混合动画。它允许通过将多个动画绘制到一维或二维图表上来混合多个动画。动画师和游戏开发者经常使用混合空间来创建游戏中角色不同动画之间的平滑和逼真的过渡。
- en: In our case, we will need to blend three animations – the idle, walk, and sprint
    ones – that will be managed depending on the character’s speed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们需要混合三个动画 – 空闲、行走和冲刺动画 – 这些动画将根据角色的速度进行管理。
- en: 'To create this Blend Space, complete the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个混合空间，完成以下步骤：
- en: 'Inside the `Animations` folder, right-click and select **Animation | Blend
    Space**. Then, from the **Pick Skeleton** window that will pop up, select **rogue_Skeleton**,
    as depicted in *Figure 10**.1*:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Animations`文件夹内，右键点击并选择**动画 | 混合空间**。然后，从弹出的**选择骨架**窗口中，选择**rogue_Skeleton**，如*图10.1*所示：
- en: '![Figure 10.1 – Blend Space creation](img/Figure_10_01_B18203.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 创建混合空间](img/Figure_10_01_B18203.jpg)'
- en: Figure 10.1 – Blend Space creation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 创建混合空间
- en: Name the newly-created asset `BS_WalkRun` and double-click it to open the **Blend
    Space** **Editor** window.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资源命名为`BS_WalkRun`，双击它以打开**混合空间** **编辑器**窗口。
- en: In `Speed`
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Speed`
- en: Set the `500`
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`500`
- en: Leave the **Vertical Axis** section as it is (i.e., set to **None**), as we
    won’t use it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持**垂直轴**部分不变（即，设置为**无**），因为我们不会使用它。
- en: What we have done here is initialize the main setting values for the animation
    blend, exposing the **Speed** property that will be used by the controlling Blueprint
    we will be adding later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的初始化动画混合的主要设置值，暴露了将被我们稍后添加的控制蓝图使用的**Speed**属性。
- en: Now, you will be adding the animation assets that will be blended together.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将添加将被混合在一起的动画资源。
- en: Locate the **rogue_Idle** animation in the **Asset Browser** and drag it into
    the graph at the center of the editor. This will create a point in the coordinate
    system of the diagram.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源浏览器**中找到**rogue_Idle**动画，并将其拖拽到编辑器中心的图中。这将创建一个在图坐标系统中的点。
- en: Select the point and set its `0` and its `0`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择点并设置其`0`和其`0`。
- en: 'You should get a graph that looks like the one depicted in *Figure 10**.2*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个看起来像*图10.2*中描述的图表：
- en: '![Figure 10.2 – Idle animation settings](img/Figure_10_02_B18203.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 空闲动画设置](img/Figure_10_02_B18203.jpg)'
- en: Figure 10.2 – Idle animation settings
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 空闲动画设置
- en: Now, we will add two more assets to the graph – one for the walk animation and
    one for the run animation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向图表中添加两个更多资源 – 一个用于行走动画，另一个用于跑步动画。
- en: Drag the `45` and its `0`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`45`及其`0`。
- en: Again, drag the `100` and its `0`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，拖动`100`及其`0`。
- en: Drag the `500` and its `0`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`500`及其`0`。
- en: 'The complete Blend Space asset can be seen in *Figure 10**.3*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的混合空间资源可以在*图10.3*中看到：
- en: '![Figure 10.3 – Complete blend space](img/Figure_10_03_B18203.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 完整混合空间](img/Figure_10_03_B18203.jpg)'
- en: Figure 10.3 – Complete blend space
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 完整混合空间
- en: To test the animation blends on the character, you can simply press the *Ctrl*
    key and hover the mouse on the zone of the graph you want to check – you will
    see the character start a walk-and-move cycle, the animation assets blending seamlessly.
    The Blend Space is complete, so we can now start creating the asset that will
    handle the throw animation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试角色上的动画混合，您可以简单地按住*Ctrl*键并将鼠标悬停在您想要检查的图表区域上 – 您将看到角色开始行走和移动循环，动画资产无缝混合。混合空间已完成，因此我们现在可以开始创建处理投掷动画的资产。
- en: Creating the throw Animation Montage
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建投掷动画蒙太奇
- en: An **Animation Montage** is a type of asset that enables the combination of
    multiple animations and their selective play from a Blueprint. Animation Montages
    are commonly used for creating complex animation sequences such as attack combos,
    cutscenes, and other interactive gameplay elements. In our project, we will use
    one to play the single-throw animation from the controlling Blueprint.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画蒙太奇**是一种资产类型，它允许从蓝图组合多个动画并选择性地播放。动画蒙太奇通常用于创建复杂的动画序列，如攻击组合、场景和其它交互式游戏元素。在我们的项目中，我们将使用它来播放由控制蓝图播放的单次投掷动画。'
- en: 'To create the Animation Montage, complete the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建动画蒙太奇，请完成以下步骤：
- en: Inside the `Animations` folder, right-click and select **Animation | Animation
    Montage**. Then, from the **Pick Skeleton** window that will pop up, select **rogue_Skeleton**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Animations`文件夹中，右键单击并选择**Animation | Animation Montage**。然后，从弹出的**选择骨架**窗口中，选择**rogue_Skeleton**。
- en: Name the newly created asset `AM_Throw` and double-click it to open the **Animation
    Montage** **Editor** window.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为`AM_Throw`并双击它以打开**动画蒙太奇****编辑器**窗口。
- en: From the **Asset Browser**, drag the **rogue_Throw** asset – in the **DefaultGroup.DefaultSlot**
    line – onto the timeline at the center of the editor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**资产浏览器**中，将**rogue_Throw**资产 – 在**DefaultGroup.DefaultSlot**行 – 拖动到编辑器中心的时序线上。
- en: 'The final result for the Animation Montage is shown in *Figure 10**.4*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蒙太奇的最终结果如图*图10**.4*所示：
- en: '![Figure 10.4 – Throw Animation Montage](img/Figure_10_04_B18203.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 投掷动画蒙太奇](img/Figure_10_04_B18203.jpg)'
- en: Figure 10.4 – Throw Animation Montage
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 投掷动画蒙太奇
- en: This Montage and the previous **Blend Space** asset will be controlled by a
    dedicated Blueprint that we are going to add to the project in the next steps.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此蒙太奇和之前的**混合空间**资产将由一个专门的蓝图控制，我们将在下一步骤中将它添加到项目中。
- en: Creating the character Animation Blueprint
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建角色动画蓝图
- en: An **Animation Blueprint** is a specialized type of Blueprint that is used to
    create and control complex animation behaviors for Actors in the game. It defines
    how animations should be processed and blended together, as well as how animation
    inputs should be mapped.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画蓝图**是一种专门类型的蓝图，用于创建和控制游戏中Actors的复杂动画行为。它定义了动画应该如何处理和混合，以及动画输入应该如何映射。'
- en: In our case, we need to control the Blend Space **Speed** parameter in order
    to let the character walk and run when needed, and start the throw Animation Montage
    when the character is attacking.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们需要控制混合空间**速度**参数，以便在需要时让角色行走和奔跑，并在角色攻击时启动投掷动画蒙太奇。
- en: 'To create the Animation Blueprint, complete the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建动画蓝图，请完成以下步骤：
- en: 'Inside the `Animations` folder, right-click and select **Animation | Animation
    Blueprint**. Then, from the **Create Animation Blueprint** window that will pop
    up, select **rogue_Skeleton**, as depicted in *Figure 10**.5*:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Animations`文件夹中，右键单击并选择**Animation | Animation Blueprint**。然后，从弹出的**创建动画蓝图**窗口中，选择**rogue_Skeleton**，如图*图10**.5*所示：
- en: '![Figure 10.5 – Animation Blueprint creation](img/Figure_10_05_B18203.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 动画蓝图创建](img/Figure_10_05_B18203.jpg)'
- en: Figure 10.5 – Animation Blueprint creation
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 动画蓝图创建
- en: Name the newly-created asset `AB_Character` and double-click it to open the
    editor window.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为`AB_Character`并双击它以打开编辑器窗口。
- en: If you are not already familiar with Animation Blueprints, you will notice some
    similarities to a regular Blueprint class, such as the **My Blueprints** and **Event
    Graph** tabs. If it is not already selected, open **Event Graph** to start some
    Visual Scripting code and then continue with the following steps.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉动画蓝图，您会注意到它与常规蓝图类有一些相似之处，例如**我的蓝图**和**事件图**选项卡。如果尚未选择，请打开**事件图**以开始一些可视化脚本代码，然后继续以下步骤。
- en: Add an **Event Blueprint Initialize** **Animation** node.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**事件蓝图初始化** **动画**节点。
- en: Click and drag from the **Return Value** outgoing pin of **Try Get Pawn Owner**
    (which will already be present in the graph) and add a **Cast To** **US_Character**
    node.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动**Try Get Pawn Owner**（它将已经存在于图表中）的**返回值**输出引脚，并添加一个**Cast To** **US_Character**节点。
- en: Connect the event execution pin to the cast node incoming execution pin.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件执行引脚连接到cast节点输入执行引脚。
- en: From the `Character`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Character**。
- en: From the outgoing pin of the **Set Character** node, click and drag to add a
    **Character Movement** getter node.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Set Character**节点的输出引脚点击并拖动，添加一个**Character Movement**获取节点。
- en: From this getter node outgoing pin, click and drag and select `Movement Component`
    and connect the **Set Movement Component** node that will be automatically added
    to the graph to the execution pin of the **Set** **Character** node.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个获取节点的输出引脚点击并拖动，选择`Movement Component`，并将自动添加到图表中的**Set Movement Component**节点连接到**Set**
    **Character**节点的执行引脚。
- en: 'The final graph is shown in *Figure 10**.6*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最终图表如图*图10.6*所示：
- en: '![Figure 10.6 – Event Blueprint Initialize Animation graph](img/Figure_10_06_B18203.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 事件蓝图初始化动画图表](img/Figure_10_06_B18203.jpg)'
- en: Figure 10.6 – Event Blueprint Initialize Animation graph
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 事件蓝图初始化动画图表
- en: This visual script is executed when the Blueprint is initialized and basically
    sets the variables you will need later on, during gameplay.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段视觉脚本在蓝图初始化时执行，并基本上设置你在游戏过程中需要的变量。
- en: Now, locate the **Event Blueprint Update** animation node that should be already
    present in the graph.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定位图表中已经存在的**事件蓝图更新**动画节点。
- en: From the **Variables** section, drag a getter node for the **Character** property.
    Right-click it and select the **Convert to Validated Get** option; this will change
    the node into an executable one that will check whether the **Character** variable
    is valid.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分拖动一个获取节点用于**Character**属性。右键单击它并选择**转换为验证获取**选项；这将把节点转换成一个可执行的节点，该节点将检查**Character**变量是否有效。
- en: Connect the **Event Blueprint Update Animation** execution pin to the incoming
    execution pin of the **Get Validated** **Character** node.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**事件蓝图更新动画**执行引脚连接到**Get Validated** **Character**节点的输入执行引脚。
- en: In the `CharacterSpeed`. Drag a **Set** node for this variable into the graph.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CharacterSpeed**中。将一个**Set**节点用于此变量拖入图表。
- en: From the **Variables** section, drag a **Get** node for the **Movement** **Component**
    variable.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分拖动一个**Get**节点用于**Movement Component**变量。
- en: Click and drag from the outgoing pin of the **Movement Component** node and
    create a **Get Velocity** property node.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Movement Component**节点的输出引脚点击并拖动，创建一个**Get Velocity**属性节点。
- en: Click and drag from the outgoing pin of the **Get Velocity** node and create
    a **Vector Length** **XY** node.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Get Velocity**节点的输出引脚点击并拖动，创建一个**Vector Length** **XY**节点。
- en: Connect the outgoing pin of the **Vector Length XY** node to the incoming pin
    of the **Set Character** **Speed** node.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Vector Length XY**节点的输出引脚连接到**Set Character** **Speed**节点的输入引脚。
- en: 'The final result of the graph is shown in *Figure 10**.7*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的最终结果如图*图10.7*所示：
- en: '![Figure 10.7 – Event Blueprint Update graph](img/Figure_10_07_B18203.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 事件蓝图更新图表](img/Figure_10_07_B18203.jpg)'
- en: Figure 10.7 – Event Blueprint Update graph
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 事件蓝图更新图表
- en: This Visual Scripting code basically tracks the velocity magnitude of the character
    and stores it in the **Character Speed** variable, which will be used in the following
    steps to blend the movement animation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段视觉脚本代码基本上跟踪角色的速度大小并将其存储在**Character Speed**变量中，该变量将在以下步骤中用于混合移动动画。
- en: Next, select the **AnimGraph** tab of the editor, which will display a single
    **Output Pose** – this node represents the final animation pose of the character.
    We now need to tell the graph how to animate the character.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择编辑器的**AnimGraph**选项卡，它将显示一个单独的**输出姿态**节点——这个节点代表角色的最终动画姿态。我们现在需要告诉图表如何动画化角色。
- en: Drag the **Character Speed** property from the **Variables** section to create
    a getter node.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分将**Character Speed**属性拖动以创建一个获取节点。
- en: Click and drag from the **Character Speed** outgoing pin and create a **Blendspace
    Player ‘****BS_WalkRun’** node.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Character Speed**输出引脚点击并拖动，创建一个**Blendspace Player ‘****BS_WalkRun’**节点。
- en: Click and drag the outgoing pin of the **Blendspace Player ‘BS_WalkRun’** node
    and create a **Slot ‘Default Slot’** node – we will use this node from the C++
    code to execute the throw Animation Montage.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动 **Blendspace Player ‘BS_WalkRun’** 节点的输出引脚，创建一个 **Slot ‘Default Slot’**
    节点——我们将从 C++ 代码中使用此节点来执行投掷动画蒙太奇。
- en: Connect the outgoing pin of **Slot ‘Default Slot’** to the incoming pin of the
    **Output** **Pose** node.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Slot ‘Default Slot’** 的输出引脚连接到 **Output** **Pose** 节点的输入引脚。
- en: 'The final result of the AnimGraph is depicted in *Figure 10**.8*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 动画图最终结果如图 *图 10.8* 所示：
- en: '![Figure 10.8 – AnimGraph](img/Figure_10_08_B18203.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 动画图](img/Figure_10_08_B18203.jpg)'
- en: Figure 10.8 – AnimGraph
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 动画图
- en: With this final step, the Animation Blueprint is complete; now, you just need
    to connect it to the character Blueprint to make it work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一最终步骤，动画蓝图就完成了；现在，你只需要将其连接到角色蓝图，使其工作。
- en: Adding the Animation System to the character
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将动画系统添加到角色中
- en: 'To add the animation system to the character, you just have to declare the
    Animation Blueprint inside the Blueprint class. To do so, open the **BP_Character**
    Blueprint and select the **Mesh** property. Then, in the **Details** panel, locate
    the **Anim Class** property. From the drop-down menu next to it, select **AB_Character**
    as shown in *Figure 10**.9*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将动画系统添加到角色中，你只需在蓝图类中声明动画蓝图。要这样做，打开 **BP_Character** 蓝图并选择 **Mesh** 属性。然后，在
    **Details** 面板中，找到 **Anim Class** 属性。从其旁边的下拉菜单中选择 **AB_Character**，如图 *图 10.9*
    所示：
- en: '![Figure 10.9 – Animation Blueprint assigned to the Blueprint class](img/Figure_10_09_B18203.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 分配给蓝图类的动画蓝图](img/Figure_10_09_B18203.jpg)'
- en: Figure 10.9 – Animation Blueprint assigned to the Blueprint class
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 分配给蓝图类的动画蓝图
- en: If you test the game right now, you should see the character starting the animation
    loop and reacting to the player input when walking and running. However, the run
    animation will be weirdly jumpy and buggy – this is happening because these animations
    are not replicated and are just checking the character speed to update.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试游戏，你应该看到角色开始动画循环，并在行走和跑步时对玩家输入做出反应。然而，跑步动画会奇怪地跳跃和出现错误——这是因为这些动画没有被复制，只是检查角色速度来更新。
- en: From a technical point of view, the speed value (i.e., `MaxWalkSpeed`) is just
    stored in the server instance of the character, but the client will have its own
    `MaxWalkSpeed` value. While this may be acceptable if you are just moving an Actor
    around, as the server will be constantly updating the Actor position, animating
    a Skeletal Mesh component based on its speed is a totally different beast. In
    fact, the Animation System is using the local value (i.e., the client one) and
    the system will continuously conflict between server and client data, resulting
    in a broken animation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，速度值（即 `MaxWalkSpeed`）只是存储在角色的服务器实例中，但客户端将有自己的 `MaxWalkSpeed` 值。如果你只是移动一个
    Actor，这可能是可以接受的，因为服务器会不断更新 Actor 位置，但基于速度的骨骼网格组件动画则完全是另一回事。事实上，动画系统正在使用本地值（即客户端的值），系统将不断在服务器和客户端数据之间发生冲突，导致动画损坏。
- en: That’s why we need to move the start-and-stop sprint logic we implemented in
    [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote Procedure Calls
    (RPCs),* from the server to the client and call the corresponding methods as multicast
    ones so that all the clients will be aware of this change.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们需要将我们在 [*第 7 章*](B18203_07.xhtml#_idTextAnchor147)*，使用远程过程调用 (RPCs)*
    中实现的开始和停止冲刺逻辑从服务器移动到客户端，并将相应的调用作为多播调用，这样所有客户端都会意识到这个变化。
- en: 'To do so, open the `US_Character.h` header file and add the following client
    declarations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，打开 `US_Character.h` 头文件，并添加以下客户端声明：
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we used the `NetMulticast` specifier in order to let all the
    clients know that the character has started sprinting. Additionally, this call
    needs to be a `Reliable` one so you are guaranteed to send all the data to the
    recipients without any packet loss.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了 `NetMulticast` 指定符，以便让所有客户端都知道角色已经开始冲刺。此外，这个调用需要是一个 `Reliable` 的调用，这样你就可以保证将所有数据发送给接收者，而不会有任何数据包丢失。
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a refresher on RPCs and the `NetMulticast` specifier, please refer to [*Chapter
    7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote Procedure* *Calls (RPCs)*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解 RPCs 和 `NetMulticast` 指定符的复习，请参阅 [*第 7 章*](B18203_07.xhtml#_idTextAnchor147)*，使用远程过程调用
    (RPCs)*。
- en: 'Now, open the `US_Character.cpp` file and locate `SprintStart_Server_Implementation()`
    and `SprintEnd_Server_Implementation()`. You are going to move all the content
    of both methods to the corresponding client-side calls. To do so, remove all the
    content (i.e., the code in between the brackets) and, in `SprintStart_Server_Implementation()`,
    add the client-side call:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`US_Character.cpp`文件并定位到`SprintStart_Server_Implementation()`和`SprintEnd_Server_Implementation()`。你需要将这两个方法的所有内容移动到相应的客户端调用中。为此，删除所有内容（即括号内的代码），并在`SprintStart_Server_Implementation()`中添加客户端调用：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the `SprintEnd_Server_Implementation()` method, add the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SprintEnd_Server_Implementation()`方法，添加以下内容：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, move the previously removed code to the client-side implementations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将之前移除的代码移动到客户端实现中：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The overall behavior will then be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总体行为将如下：
- en: The client controlled by the player receives the movement inputs and sends this
    data to the server
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由玩家控制的客户端接收移动输入并将此数据发送到服务器
- en: The server handles this input and sends the update request to all clients
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器处理这个输入并向所有客户端发送更新请求
- en: All the clients update the `MaxWalkSpeed` value accordingly
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有客户端相应地更新`MaxWalkSpeed`值
- en: Once you have compiled the project, try testing the game – our character can
    now move and sprint like a pro, and you’ll get to see their animations shine in
    all their glory!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译了项目，尝试测试游戏——我们的角色现在可以像专业人士一样移动和冲刺，你将看到他们的动画在所有荣耀中闪耀！
- en: For some extra practice, try working on the minion character and implementing
    the same animation logic. This is the true meaning of summoning a bunch of bones
    to a fully-fledged, reanimated minion, and who knows? The Lichlord might just
    reward you with a surprise or two for a job well done!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了额外练习，尝试对随从角色进行工作并实现相同的动画逻辑。这就是召唤一帮骨头成为一个完整的、重新激活的随从的真实含义，谁知道呢？巫妖王可能会因为你的出色工作而给你带来一些惊喜！
- en: Adding the throw animation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加投掷动画
- en: What’s missing at the moment is the throw animation and, in this case, network
    synchronization is something we really want – every connected player in the game
    will need to see the character animation whenever it is throwing the dagger in
    the dungeon, and this animation should be played at the same time for all clients.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 目前缺少的是投掷动画，在这种情况下，网络同步是我们真正想要的——游戏中所有连接的玩家都需要在角色在地下城投掷匕首时看到角色动画，并且这个动画应该对所有客户端同时播放。
- en: 'The first thing to do is to ensure that the WeaponProjectile component will
    be properly replicated. To do so, open the `US_Character.cpp` file. Then, in the
    constructor, locate the `Weapon` component initialization, and add the following
    line of code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要确保武器投射物组件能够正确复制。为此，打开`US_Character.cpp`文件。然后，在构造函数中找到`Weapon`组件初始化，并添加以下代码行：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, open `US_WeaponProjectileComponent.h` and, in the `private` section,
    add the following Animation Montage reference:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`US_WeaponProjectileComponent.h`文件，并在`private`部分添加以下动画蒙太奇引用：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After that, in the `protected` section, add the following declaration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`protected`部分添加以下声明：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the throw method that will be executed from the client side. Notice
    that we are RPC multicasting to all clients with the `Unreliable` property specifier
    – even though we want this animation synchronized over the network, it is just
    an aesthetic add-on, so we can afford to lose the data over the network. The other
    clients won’t see the animation, but the dagger will be spawned anyway.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将在客户端执行的投掷方法。注意，我们使用具有`Unreliable`属性指定符的RPC多播到所有客户端——尽管我们希望这个动画在网络中同步，但这只是一个美学上的附加功能，因此我们可以承受在网络中丢失数据。其他客户端不会看到动画，但匕首仍然会被生成。
- en: 'With the header declarations complete, open the `US_WeaponProjectileComponent.cpp`
    file and add the client-side throw method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完成头文件声明后，打开`US_WeaponProjectileComponent.cpp`文件并添加客户端投掷方法：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the code will get the owner of this component and, if it is
    of the `US_Character` type, will play the Animation Montage.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码将获取此组件的所有者，如果它是`US_Character`类型，将播放动画蒙太奇。
- en: 'This method will be called from its server-side counterpart, so locate the
    `Throw_Server_Implementation()` method. We could just execute the method call,
    but we need to give a slight delay to the spawn logic because the throw animation
    will take some time to complete, and spawning the dagger ahead of time would return
    ugly visual feedback to the player. To do so, remove all the content of the function
    and replace it with the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将从其服务器端对应方法 `Throw_Server_Implementation()` 中调用，因此找到该方法。我们本可以直接执行方法调用，但我们需要给生成逻辑添加一点延迟，因为投掷动画需要一些时间才能完成，提前生成匕首会给玩家带来不美观的视觉反馈。为此，删除函数中的所有内容，并用以下代码替换：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have just moved the spawn logic inside a timer handle to delay the
    spawn process while calling the client-side throw logic, in order to start the
    animation immediately.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将生成逻辑移动到计时器句柄中，以在调用客户端投掷逻辑的同时延迟生成过程，以便立即开始动画。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unreal Engine provides more advanced methods for synchronizing animations beyond
    simply delaying method calls, such as **Animation Notifies** ([https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/)).
    However, for the purpose of this book, the delay method is a quick and dirty solution
    that will suffice for our needs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 提供了比简单延迟方法调用更高级的动画同步方法，例如 **Animation Notifies** ([https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/))。然而，为了本书的目的，延迟方法是满足我们需求的一个快速且实用的解决方案。
- en: As the last step, open the **BP_Character** Blueprint, select the **Weapon**
    component and, in the **Details** panel, look for the **Throw Animation** property
    and assign the **AM_Throw** montage you have already created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，打开 **BP_Character** Blueprint，选择 **Weapon** 组件，在 **Details** 面板中查找 **Throw
    Animation** 属性，并分配你已创建的 **AM_Throw** 蒙太奇。
- en: You can now test the game and the character should throw the dagger and synchronize
    correctly with the throw animation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以测试游戏，角色应该能够投掷匕首，并且与投掷动画正确同步。
- en: In this section, you have dipped your toes into the mystical realm of animation
    (although you’re not quite ready to battle the Lichlord just yet) and conjured
    up a basic animation system that networked players will appreciate. In the next
    section, you’re about to bring some friendly characters to life and add even more
    fun to your game by giving players someone to rescue.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你刚刚涉足神秘的动画领域（尽管你还没有准备好与巫妖领主战斗），并创造了一个基本的动画系统，网络玩家会欣赏。在下一节中，你将使一些友好角色复活，并通过为玩家提供可以解救的人来为你的游戏增添更多乐趣。
- en: Adding NPC Actors
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 NPC 角色演员
- en: While taking a leisurely stroll in the underground and dodging or stabbing zombies
    can be amusing, let’s not forget the big bucks the king’s shelling out for us.
    We’ve got a rescue mission on our hands – liberate his knights from the Lichlord’s
    dungeons before they’re turned into undead abominations. Time to get down to business,
    my fearless developer!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在地下漫步，躲避或刺杀僵尸可能会很有趣，但我们不要忘记国王为我们支付的丰厚报酬。我们手头有一个救援任务——在骑士们被变成不死生物之前，从巫妖领主的地下城中解放他们。是时候开始认真工作了，我的无畏的开发者！
- en: In this section, you’ll create an Actor Blueprint that will serve as a prisoner
    your beloved thief needs to rescue (in order to get more experience points). To
    implement such a system, you will make good use of the `Interactable` interface
    you implemented in [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote
    Procedure* *Calls (RPCs)*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个 Actor Blueprint，它将作为你心爱的盗贼需要解救的囚犯（为了获得更多的经验值）。为了实现这样的系统，你将充分利用在
    [*第 7 章*](B18203_07.xhtml#_idTextAnchor147)* 使用远程过程调用 (RPCs)* 中实现的 `Interactable`
    接口。
- en: Creating the NPC character
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 NPC 角色
- en: 'The NPCyou will be creating is a simple, replicated Actor that will cheer when
    the player has interacted with it and will grant some experience points. The first
    things we need are the Animation Montages that will play the idle and cheer animations.
    To do so, complete the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要创建的 NPC 是一个简单的、可复制的演员，当玩家与之交互时，它会欢呼，并授予一些经验值。我们需要做的第一件事是播放空闲和欢呼动画的动画蒙太奇。为此，完成以下步骤：
- en: In the `Animations` folder, add a new `AM_KnightIdle`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Animations` 文件夹中添加一个新的 `AM_KnightIdle`。
- en: Add the **knight_Idle** animation to the **DefaultGroup.DefaultSlot** section
    of the montage.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **knight_Idle** 动画添加到 montage 的 **DefaultGroup.DefaultSlot** 部分。
- en: Add another `AM_KnightCheer`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个 `AM_KnightCheer`。
- en: Add the **knight_cheer** animation to the montage.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**knight_cheer**动画添加到蒙太奇中。
- en: With these two animation assets ready, you can start creating the prisoner Blueprint.
    Open the `Blueprints` folder and complete the following steps.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个动画资产准备就绪后，您可以开始创建囚犯蓝图。打开`Blueprints`文件夹并完成以下步骤。
- en: Create a new Blueprint based on the `BP_KnightPrisoner`. Double-click it to
    open it.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于的`BP_KnightPrisoner`创建一个新的蓝图。双击它以打开它。
- en: In the **Components** panel, add a **Skeletal** **Mesh** component.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，添加一个**骨骼** **网格**组件。
- en: In the **Details** panel, tick the **Replicates** property in order to replicate
    the Actor over the network.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，选中**复制**属性以在网络中复制演员。
- en: Create an `EarnedXp`. Set its `20`. Tick the **Instance Editable** property
    to make the variable public.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`EarnedXp`。将其设置为`20`。选中**实例可编辑**属性以使变量公开。
- en: Create an `MontageIdle`. Set its **Default Value** to **AM_KnightIdle**. Tick
    the **Instance** **Editable** property.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MontageIdle`。将其**默认值**设置为**AM_KnightIdle**。选中**实例** **可编辑**属性。
- en: Create another `MontageCheer`. Set its default value to **AM_KnightCheer**.
    Tick the **Instance** **Editable** property.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`MontageCheer`。将其默认值设置为**AM_KnightCheer**。选中**实例** **可编辑**属性。
- en: 'With these base settings available, you can start adding some Visual Scripting
    to the Event Graph in order to make the Actor fully functional. You will start
    from the **Begin Play** event to start the idle animation. To do so, complete
    the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基本设置可用的情况下，您可以从**开始播放**事件开始添加一些视觉脚本到事件图，以使演员完全功能化。您将从**开始播放**事件开始，以启动空闲动画。为此，完成以下步骤：
- en: Add an **Event BeginPlay** node to the graph.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**事件开始播放**节点。
- en: From the **Components** panel, drag into the graph a reference of the **Skeletal**
    **Mesh** component.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**组件**面板，将**骨骼** **网格**组件的引用拖入图中。
- en: From the **Variables** panel, drag a getter node for the **MontageIdle** variable.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**面板，拖动一个用于**MontageIdle**变量的获取节点。
- en: From the **Event BeginPlay** execution pin, create a **Play** **Animation**
    node.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**事件开始播放**执行引脚，创建一个**播放** **动画**节点。
- en: Connect the **Skeletal Mesh** pin to the **Target** pin of the **Play** **Animation**
    node.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**骨骼网格**引脚连接到**播放** **动画**节点的**目标**引脚。
- en: Connect the **Montage Idle** pin to the **New Anim to Play** pin of the **Play**
    **Animation** node.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Montage Idle**引脚连接到**播放** **动画**节点的**新动画播放**引脚。
- en: Tick the **Looping** property of the **Play** **Animation** node.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**播放** **动画**节点的**循环**属性。
- en: 'The final result for this part of the graph is shown in *Figure 10**.10*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该图部分的最终结果如图*图10**.10*所示：
- en: '![Figure 10.10 – Event BeginPlay graph](img/Figure_10_10_B18203.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 事件开始播放图](img/Figure_10_10_B18203.jpg)'
- en: Figure 10.10 – Event BeginPlay graph
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 事件开始播放图
- en: 'Then, create a custom event that will start the cheer animation when the prisoner
    is rescued by the player character. This event needs to be executed as a **Multicast**
    event in order to start the animation on all clients. To do so, complete the following
    steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个自定义事件，当玩家角色救出囚犯时，将启动欢呼动画。为了在所有客户端上启动动画，此事件需要作为**多播**事件执行。为此，完成以下步骤：
- en: 'Right-click on the graph and create a `CharacterCheer`. With the event selected,
    locate the **Replicates** property in the **Details** panel and, from its drop-down
    menu, select **Multicast**, leaving the **Reliable** checkmark unticked, as shown
    in *Figure 10**.11*:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击图，创建一个`CharacterCheer`。选择事件后，在**详细信息**面板中找到**复制**属性，并从下拉菜单中选择**多播**，保留**可靠**复选框未勾选，如图*图10**.11*所示：
- en: '![Figure 10.11 – Custom Event replication](img/Figure_10_11_B18203.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 自定义事件复制](img/Figure_10_11_B18203.jpg)'
- en: Figure 10.11 – Custom Event replication
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 自定义事件复制
- en: From the **Components** panel, drag into the graph a reference to the **Skeletal**
    **Mesh** component.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**组件**面板，将**骨骼** **网格**组件的引用拖入图中。
- en: From the **Variables** panel, drag a getter node for the **MontageCheer** variable.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**面板中，拖动一个用于**MontageCheer**变量的获取节点。
- en: From the **Event BeginPlay** execution pin, create a **Play** **Animation**
    node.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**事件开始播放**执行引脚，创建一个**播放** **动画**节点。
- en: Connect the **Skeletal Mesh** pin to the **Target** pin of the **Play** **Animation**
    node.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**骨骼网格**引脚连接到**播放** **动画**节点的**目标**引脚。
- en: Connect the **Montage Idle** pin to the **New Anim to Play** pin of the **Play**
    **Animation** node.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Montage Idle**引脚连接到**播放** **动画**节点的**新动画播放**引脚。
- en: Tick the **Looping** property of the **Play** **Animation** node.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**播放** **动画**节点的**循环**属性。
- en: 'The final result for this part of the graph is shown in *Figure 10**.12*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图表这一部分的最终结果如图 *图 10.12* 所示：
- en: '![Figure 10.12 – CharacterCheer Custom Event](img/Figure_10_12_B18203.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – CharacterCheer 自定义事件](img/Figure_10_12_B18203.jpg)'
- en: Figure 10.12 – CharacterCheer Custom Event
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – CharacterCheer 自定义事件
- en: 'The last step needed to make the Actor work properly is to make it interactable
    with the player character by implementing the `US_Interactable` interface. To
    do so, complete the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使演员正常工作的最后一步是通过实现 `US_Interactable` 接口使其与玩家角色可交互。为此，完成以下步骤：
- en: Open the **Class Settings** panel and locate the **Interfaces** category.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **类设置** 面板并定位到 **接口** 类别。
- en: In **Implemented Interfaces**, add the **US_Interactable** interface.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **实现接口** 中添加 **US_Interactable** 接口。
- en: In the **My Blueprint** panel, locate the **Interfaces** category and right-click
    the **Interact** method, selecting **Implement event**. An **Event Interact**
    node will be added to the Event Graph.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **我的蓝图** 面板中，定位到 **接口** 类别，右键单击 **Interact** 方法，选择 **实现事件**。将在事件图中添加一个 **Event
    Interact** 节点。
- en: Click and drag from the event **Character Instigator** pin to add a **PlayerState**
    node and connect its **Target** pin to the **Character Instigator** pin of the
    **Event** **Interact** node.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件 **Character Instigator** 引脚点击并拖动以添加一个 **PlayerState** 节点，并将其 **Target**
    引脚连接到 **Event Interact** 节点的 **Character Instigator** 引脚。
- en: Click and drag from the outgoing pin of the **PlayerState** node and create
    a **Cast To US_PlayerState** node. Connect its incoming execution pin to the outgoing
    execution pin of the **Event** **Interact** node.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **PlayerState** 节点的输出引脚点击并拖动，创建一个 **Cast To US_PlayerState** 节点。将其执行输入引脚连接到
    **Event Interact** 节点的输出执行引脚。
- en: Click and drag from the **As US PlayerState** of the cast node and create an
    **Add Xp** node. Connect its incoming execution pin to the **Success** execution
    pin of the cast node.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 cast 节点的 **As US PlayerState** 点击并拖动，创建一个 **Add Xp** 节点。将其执行输入引脚连接到 cast 节点的
    **Success** 执行引脚。
- en: From the **Variables** panel, drag a getter node for the **EarnedXp** variable.
    Connect its outgoing pin to the **Value** pin of the **Add** **Xp** node.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **变量** 面板拖动一个 **EarnedXp** 变量的获取节点。将其输出引脚连接到 **Add Xp** 节点的 **Value** 引脚。
- en: 'Click and drag from the outgoing pin of the **Add Xp** node and create a **Character
    Cheer** node to complete the graph, as shown in *Figure 10**.13*:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Add Xp** 节点的输出引脚点击并拖动，创建一个 **Character Cheer** 节点以完成图表，如图 *图 10.13* 所示：
- en: '![Figure 10.13 – Interaction graph](img/Figure_10_13_B18203.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 交互图](img/Figure_10_13_B18203.jpg)'
- en: Figure 10.13 – Interaction graph
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 交互图
- en: You may have noticed that we didn’t use any authority checks in the previous
    graph; this is because we know that this event will only be called on the server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们之前没有使用任何权限检查；这是因为我们知道这个事件只会在服务器上调用。
- en: The Blueprint is now complete, so it’s time to do some testing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图现在已完成，因此是时候进行一些测试了。
- en: Testing the NPC Actor
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 NPC 演员行为
- en: To test the Blueprint, you can drag an instance of it into the level and start
    a gameplay session. The thief character should be able to reach the NPC and, if
    we use the interaction button, the animation should show them cheering. The hero
    who liberates the NPC characters will receive a well-deserved pool of experience
    points as a reward. Time to level up and become an even greater hero!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试蓝图，可以将其实例拖入关卡并开始游戏会话。盗贼角色应该能够到达 NPC，如果我们使用交互按钮，动画应该显示他们在欢呼。解放 NPC 角色的英雄将获得应得的丰富经验点作为奖励。是时候升级并成为更伟大的英雄了！
- en: '*Figure 10**.14* shows the final result of the NPC Actor, once it has been
    liberated by the thief hero:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.14* 显示了 NPC 演员被盗贼英雄解放后的最终结果：'
- en: "![Figure 10.14 – A \uFEFFliberated Actor during gameplay](img/Figure_10_14_B18203.jpg)"
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 游戏过程中被解放的演员](img/Figure_10_14_B18203.jpg)'
- en: Figure 10.14 – A liberated Actor during gameplay
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 游戏过程中被解放的演员
- en: Well, it seems we now have a new prisoner to play with! But why settle for one
    when we can have variations? Feel free to get creative and give our captive some
    fresh looks to keep things interesting. By creating child Blueprints and changing
    the Actor’s Skeletal Mesh component and Animation Montages, you will be able to
    make good use of the barbarian and mage models available in the project. You may
    even create a rogue prisoner variation – who says we can’t go off-script a little?
    The king may have paid us to rescue his knights and warriors, but hey, a skilled
    hero or two in the Thief Guild never hurt anyone!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看来我们现在又有一个新囚犯可以玩弄了！但为什么只满足于一个呢？当我们能够有多种变化时，为什么不发挥创意，给我们的囚犯一些新鲜的外观，以保持事情的新鲜感呢？通过创建子蓝图并更改演员的骨骼网格组件和动画蒙太奇，你将能够充分利用项目中可用的野蛮人和法师模型。你甚至可以创建一个游侠囚犯的变化版本——谁说我们不能稍微偏离剧本呢？国王可能付钱给我们来营救他的骑士和战士，但嘿，盗贼公会里一个或两个熟练的英雄从未伤害过任何人！
- en: Congratulations – you’ve completed this part of the adventure. Now it’s time
    to let your imagination run wild and add your own game logic! In the next section,
    I won’t be teaching you any new techniques, but I’ll provide you with some fresh
    ideas to enhance the gameplay and make it more exciting.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你已经完成了这个冒险的一部分。现在，是时候让你的想象力自由驰骋，添加你自己的游戏逻辑了！在下一节中，我不会教你任何新的技术，但我会提供一些新想法来增强游戏玩法，使其更加刺激。
- en: Making further improvements to the game
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进游戏
- en: Now that you have solid knowledge of how the Unreal multiplayer system works,
    it’s time to unleash your creativity and bring your own ideas to life, making
    your game truly unique and personalized. In this section, I will give you some
    hints on how to spice up your project, but don’t hesitate to add your own twist
    to make it uniquely yours.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对虚幻引擎的多玩家系统有了扎实的了解，是时候释放你的创造力，让你的想法变为现实，让你的游戏真正独特和个性化了。在本节中，我将给你一些提示，告诉你如何让你的项目更加生动，但不要犹豫，加入你自己的创意，让它独一无二。
- en: Let’s make some noise!
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们制造一些噪音！
- en: Currently, the minions’ hearing senses are only utilized to detect when a character
    is running. Why not tweak the system and let other elements in the game alert
    the Lichlord’s minions?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，小兵的听觉感知仅用于检测角色是否在奔跑。为什么不调整系统，让游戏中的其他元素也能警告巫妖领主的小兵呢？
- en: Unfortunately, `PawnNoiseEmitterComponent` can only be used on, well... pawns,
    so you cannot attach it to other Actors (it simply won’t work); however, in [*Chapter
    9*](B18203_09.xhtml#_idTextAnchor174)*, Extending AI Behaviors*, you built a strong
    system to alert enemy minions that makes use of the Game Mode. As the Game Mode
    can be reached by any Actor in the level, you can exploit the `AlertMinions()`
    function and send messages that will call for help when activated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`PawnNoiseEmitterComponent` 只能在，嗯... 基础单位上使用，所以你不能将它附加到其他演员上（它根本不会起作用）；然而，在[*第9章*](B18203_09.xhtml#_idTextAnchor174)*，扩展AI行为*中，你构建了一个强大的系统，用于通过游戏模式来警告敌人小兵。由于游戏模式可以被关卡中的任何演员访问，你可以利用`AlertMinions()`函数并发送在激活时请求帮助的消息。
- en: 'One of the best ways to use this method is through traps – whenever the player
    character steps into one such device, all the minions around will be alerted.
    Some examples of this kind of game feature include the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法最好的方式之一是通过陷阱——每当玩家角色踏入这样的装置时，周围的所有小兵都会被警告。这类游戏功能的例子包括以下内容：
- en: '*Creaking doors*: Whenever the character opens a door, it will make a creaking
    or squeaking sound that will alert the Lichlord’s servants to the intruders.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*吱吱作响的门*：每当角色打开一扇门时，它都会发出吱吱或吱吱声，这会警告巫妖领主的仆人有关入侵者。'
- en: '*Traps*: Some dungeon areas will be more protected than others – set some mechanical
    devices that will rally all nearby enemies. After all, this is just a matter of
    creating a collision area and calling a method in the Game Mode!'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*陷阱*：一些地牢区域比其他区域更受保护——设置一些能够召集所有附近敌人的机械装置。毕竟，这只是一个创建碰撞区域并在游戏模式中调用方法的问题！'
- en: '*Magical items*: Create some magical artifact that can be interacted with by
    the player. The Lichlord is a sneaky one: he cast an alert spell, which condemned
    the hapless thief hero to their inevitable fate. Whenever the character tries
    to use that juicy item, an alarm will be sent to nearby minions, alerting them.
    Think of the possibilities! You can even use the floating book we created at the
    beginning of the project.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*魔法物品*：创建一些玩家可以与之交互的魔法神器。巫妖领主是个狡猾的家伙：他施了一个警报咒语，将不幸的盗贼英雄注定走向不可避免的命运。每当角色试图使用那个诱人的物品时，就会向附近的小兵发送警报。想想看！你甚至可以使用我们在项目开始时创建的漂浮书籍。'
- en: I need a key!
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要一把钥匙！
- en: Opening doors in a dungeon can be a fun game, but things can get even more interesting
    when you come across a locked door. Why not give it a try and see what other surprises
    lie in wait?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在地牢中开门可能是一种有趣的游戏，但当你遇到一扇锁着的门时，事情会变得更加有趣。为什么不试试看，看看还有哪些惊喜在等待着你？
- en: In [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote Procedure
    Calls (RPCs)*, you created the `US_Interactable` interface and made use of the
    `Interact()` method. However, the interface also exposes the `CanInteract()` method,
    which can be used to check whether the Actor can be interacted with.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第七章*](B18203_07.xhtml#_idTextAnchor147)《使用远程过程调用（RPCs）》中，你创建了`US_Interactable`接口，并使用了`Interact()`方法。然而，该接口还公开了`CanInteract()`方法，可以用来检查Actor是否可以交互。
- en: A door may implement a system that will only return `true` to the `CanInteract()`
    method if the player character has a key – this means creating a key pickup item
    and adding the `US_Character` system to track whether they have one or more keys
    to use. These locked doors can be used to keep the NPCs locked in some cellars
    and only able to be freed if the corresponding key is found somewhere in the level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一扇门可能实现了一个系统，只有当玩家角色有钥匙时，`CanInteract()`方法才会返回`true`——这意味着创建一个钥匙拾取物品，并添加`US_Character`系统来跟踪他们是否有一把或多把钥匙可以使用。这些锁着的门可以用来将NPC锁在一些地牢的牢房中，并且只有找到相应的钥匙才能被释放。
- en: Watch out for the Lichlord! His prisoners are double-locked up tighter than
    a merchant’s coin purse in the deepest and most heavily guarded cells of his dungeon!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当心巫妖领主！他的囚犯被锁得比最深最严密的牢房里的商人钱袋还要紧！
- en: Improve your arsenal, my hero!
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升你的武器库，我的英雄！
- en: While it’s nice to have a pointy dagger to throw at your hated opponents, it’s
    even nicer to have a magical one that will inflict more damage, or even defeat
    enemies with a single hit. You can implement a pickup Blueprint that will make
    good use of the `SetProjectileClass()` function you implemented in the `US_WeaponProjectileComponent`
    class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一把尖锐的匕首可以投掷给你的敌人很酷，但有一把魔法匕首会造成更多伤害，或者甚至一击击败敌人，那就更好了。你可以实现一个拾取蓝图，充分利用你在`US_WeaponProjectileComponent`类中实现的`SetProjectileClass()`函数。
- en: Upon picking up the item, the character will be granted a variant of the `US_BaseWeaponProjectile`
    class with augmented damage. You can even think about letting defeated enemies
    drop weapon pickups instead of coins!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 拾取物品后，角色将获得一个增强伤害的`US_BaseWeaponProjectile`类变体。你甚至可以考虑让击败的敌人掉落武器拾取物而不是金币！
- en: As an additional feature, you may even think to create throwing rocks that will
    send alert messages upon hitting the ground – just remember to enable gravity
    for the projectile. Having items that can be thrown and that will make noise to
    alert minions and direct them far away from the player characters will add some
    fresh gameplay logic that will improve the overall game experience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项附加功能，你甚至可以考虑创建一些投掷的石头，当它们击中地面时会发送警报信息——只需记住为投射物启用重力。拥有可以投掷并发出噪音以警告小兵并将他们从玩家角色附近引开的物品，将为游戏增加一些新的游戏逻辑，从而提高整体游戏体验。
- en: Get ready for a wickedly clever twist, and use your quick wit to dazzle the
    Lichlord’s mindless servants! With brains like yours, who needs brawn?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 准备迎接一个狡猾的转折，并运用你的机智来迷惑巫妖领主的盲目仆人！以你的头脑，谁还需要力量？
- en: You are not a machine gun
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你不是机枪
- en: Currently, players have the ability to throw an unlimited number of daggers
    during gameplay. While this may be enjoyable initially, it will ultimately disrupt
    the balance of the game and result in a monotonous experience over time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，玩家在游戏过程中可以投掷无限数量的匕首。虽然这最初可能很有趣，但最终会破坏游戏的平衡，并导致随着时间的推移游戏体验变得单调。
- en: To make things more interesting (and in favor of the Lichlord’s shadowy plans),
    limit the players to just one throwing dagger projectile at a time. Once the character
    has thrown the weapon, it won’t be able to throw it again until the dagger has
    been recovered.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣（并且有利于巫妖领主的阴暗计划），限制玩家一次只能使用一把投掷匕首。一旦角色投掷了武器，除非匕首被找回，否则角色将无法再次投掷。
- en: Implementing this feature is quite straightforward – once the character throws
    the projectile, set the `ProjectileClass` weapon component to a `null` value so
    that the character won’t be able to spawn any more objects. Upon hitting something,
    the thrown weapon will spawn a dagger pickup (see the previous subsection) before
    destroying itself. This will force the character to get to the dropped weapon
    and pick it up in order to attack again.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个功能相当简单——一旦角色投掷了投射物，将`ProjectileClass`武器组件设置为`null`值，这样角色就无法再生成任何对象。在击中某个物体后，投掷的武器会在自我销毁之前生成一个匕首拾取（见前一小节）。这将迫使角色走到掉落的武器那里并捡起它，以便再次攻击。
- en: As an alternative feature, you may give your character a limited number of knives
    and use a count variable to check whether the character has any knives available
    every time the player tries to throw one.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项替代功能，你可以给你的角色有限数量的刀子，并在玩家尝试投掷刀子时使用计数变量来检查角色是否有可用的刀子。
- en: Whoever said life in the dungeon would be a walk in the park obviously never
    encountered a horde of undead monsters while armed with a simple (and single!)
    weapon.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说地牢生活就像在公园散步一样轻松，显然他们从未在装备简单（而且是单一！）武器的情况下遭遇过一群不死怪物。
- en: No time to waste
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有时间可以浪费
- en: At the moment, your characters can walk around calmly and take their time in
    rescuing the prisoners. Why not spice things up by adding a time counter? The
    Lichlord is hosting a grand celebration with the intention of transforming the
    king’s knight into a loyal member of his undead army! Your hero must hurry up
    before it is too late!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的角色可以平静地四处走动，并从容不迫地营救囚犯。为什么不添加一个时间计数器来增加一些趣味呢？巫妖领主正在举办一场盛大的庆祝活动，意图将国王的骑士变成他不死之军的忠实成员！你的英雄必须赶紧行动，以免为时已晚！
- en: You can make good use of the `US_GameMode` class and create a time manager that
    will start as soon as the first player enters the dungeon – if the players can’t
    free every captive from the dungeon, they’ll be royally out of luck and the game
    will be a total flop. It looks like it’s all or nothing for this quest!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用`US_GameMode`类创建一个时间管理器，一旦第一个玩家进入地牢就会启动——如果玩家不能从地牢中释放所有被俘者，他们将非常不幸，游戏将彻底失败。看来这个任务似乎是一切或一无所有！
- en: Tables, tables everywhere!
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍地都是表格！
- en: As your project progresses, it will become increasingly difficult to keep track
    of all the variations in enemies and weapons. To ease the pain, you can use the
    struct and data table system introduced in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125)*,
    Replicating Properties* *Over* *the Network,* to create dedicated structures for
    the throwing weapons and AI opponents.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目进展，跟踪所有敌人和武器的变化将变得越来越困难。为了减轻痛苦，你可以使用在[*第6章*](B18203_06.xhtml#_idTextAnchor125)*，跨网络复制属性*中引入的结构和数据表系统，为投掷武器和AI对手创建专用结构。
- en: Let your creative side run wild and come up with a ton of amazing Blueprint
    options based on the stats you like best – get ready for your hero adventurers
    to embark on thrilling journeys full of surprises in your game!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的创意自由发挥，根据你最喜欢的统计数据提出大量令人惊叹的蓝图选项——准备好让你的英雄冒险家在你的游戏中踏上充满惊喜的惊险旅程吧！
- en: Need some help?
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要一些帮助？
- en: As you may have noticed from the previous subsections, once you become familiar
    with your game, the potential outcomes become limitless. You can add any new gameplay
    logic and test it until you are happy.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，一旦你熟悉了你的游戏，潜在的结果将是无限的。你可以添加任何新的游戏逻辑并测试，直到你满意为止。
- en: On my end, I’ll be working on creating exciting new features for the game and
    storing them in my own GitHub repository. Feel free to check in from time to time
    to see what wild and crazy ideas I’ve come up with! The link to the repository
    is [https://github.com/marcosecchi/unrealshadows-ltol](https://github.com/marcosecchi/unrealshadows-ltol).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的这一边，我将致力于为游戏开发令人兴奋的新功能，并将它们存储在我的GitHub仓库中。随时查看，看看我提出了哪些疯狂的想法！仓库链接是[https://github.com/marcosecchi/unrealshadows-ltol](https://github.com/marcosecchi/unrealshadows-ltol)。
- en: And if you come up with a clever idea, feel free to contact me and tell me about
    it – if time permits, I will try to implement it and upload it to the repository
    in order to make this project grow!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个巧妙的想法，请随时联系我并告诉我——如果时间允许，我会尝试实现它并将其上传到仓库，以便让这个项目不断成长！
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, you fine-tuned the gameplay logic and added the finishing
    touches. You began by incorporating some nice animations for character movements
    and attacks, elevating the game’s overall appeal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你微调了游戏玩法逻辑并添加了最后的修饰。你从为角色移动和攻击添加一些漂亮的动画开始，提升了游戏的整体吸引力。
- en: 'Additionally, you created someone for the players to rescue: a prisoner Actor
    that can be interacted with and that will grant the thief hero some well-deserved
    experience points.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你为玩家创造了一个可以营救的角色：一个可以被互动的囚犯Actor，这将授予盗贼英雄一些应得的经验值。
- en: Last but not least, I shared a few fresh ideas to take your gameplay to the
    next level. By incorporating these ideas, you can make the game truly your own
    and one of a kind. So, get creative and have fun!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我分享了一些新鲜的想法，让你的游戏体验提升到新的层次。通过融入这些想法，你可以使游戏真正成为你自己的独特之作。所以，发挥创意，享受乐趣！
- en: Get ready for the next chapter, where you’ll dive into debugging and testing
    a networked game. This will take your development skills to the next level, something
    that’s necessary if you want to become a top-notch multiplayer programmer!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 准备进入下一章节，你将深入调试和测试一个网络游戏。这将提升你的开发技能到新的水平，这对于你想要成为一名顶尖的多玩家程序员来说是必要的！
