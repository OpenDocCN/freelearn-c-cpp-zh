["```cpp\nclass Vehicle\n{\npublic:\n\u00a0\u00a0Vehicle() = default;\n\u00a0\u00a0Vehicle(int numberWheels, int engineSize) : \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_numberOfWheels{numberWheels}, m_engineSizeCC{engineSize}\n\u00a0\u00a0{\n\u00a0\u00a0}\n\u00a0\u00a0bool StartEngine()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Vehicle::StartEngine \" << m_engineSizeCC << \" CC\\n\";\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0};\n\u00a0\u00a0void Drive()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Vehicle::Drive\\n\";\n\u00a0\u00a0};\n\u00a0\u00a0void ApplyBrakes()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Vehicle::ApplyBrakes to \" << m_numberOfWheels << \" wheels\\n\";\n\u00a0\u00a0};\n\u00a0\u00a0bool StopEngine()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Vehicle::StopEngine\\n\";\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0};\nprivate:\n\u00a0\u00a0int m_numberOfWheels {4};\n\u00a0\u00a0int m_engineSizeCC{1000};\n};\n```", "```cpp\nclass DerivedClassName : access_modifier BaseClassName\n{\n\u00a0\u00a0// Body of DerivedClass\n};\n```", "```cpp\nclass Motorcycle : public Vehicle\n{\npublic:\n\u00a0\u00a0Motorcycle(int engineSize) : Vehicle(2, engineSize) {};\n};\n```", "```cpp\nclass Motorcycle : public Vehicle\n{\npublic:\n\u00a0\u00a0Motorcycle(int engineSize) : Vehicle(2, engineSize) {};\n\u00a0\u00a0void Drive()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Motorcycle::Drive\\n\";\n\u00a0\u00a0};\n};\n```", "```cpp\n#include <iostream>\nint main()\n{\n\u00a0\u00a0Vehicle vehicle;\n\u00a0\u00a0Motorcycle cycle{1500};\n\u00a0\u00a0Vehicle* myVehicle{&vehicle};\n\u00a0\u00a0myVehicle->StartEngine();\n\u00a0\u00a0myVehicle->Drive();\n\u00a0\u00a0myVehicle->ApplyBrakes();\n\u00a0\u00a0myVehicle->StopEngine();\n\u00a0\u00a0myVehicle = &cycle;\n\u00a0\u00a0myVehicle->StartEngine();\n\u00a0\u00a0myVehicle->Drive();\n\u00a0\u00a0myVehicle->ApplyBrakes();\n\u00a0\u00a0myVehicle->StopEngine();\n\u00a0\u00a0return 0;\n}\n```", "```cpp\nvirtual void Drive()\n{\n\u00a0\u00a0std::cout << \"Vehicle::Drive\\n\";\n};\n```", "```cpp\nvoid Drive() override\n{\n\u00a0\u00a0std::cout << \"Motorcycle::Drive\\n\";\n};\n```", "```cpp\nclass Vehicle\n{\npublic:\n\u00a0\u00a0// Constructors - hidden \n\u00a0\u00a0virtual ~Vehicle() = default;\u00a0\u00a0// Virtual Destructor\n\u00a0\u00a0// Other methods and data -- hidden\n};\n```", "```cpp\nclass DerivedClassName : access_modifier BaseClassName\n```", "```cpp\nclass Motorcycle : public Vehicle\n```", "```cpp\nvirtual void Drive() = 0;\n```", "```cpp\n    class ICharacter\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0~ICharacter() {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Destroying Character\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0virtual void speak() = 0;\n    \u00a0\u00a0\u00a0\u00a0virtual void act() = 0;\n    };\n    ```", "```cpp\n    class Wizard : public Icharacter { ...\n    ```", "```cpp\n    void createCharacters(std::vector<ICharacter*>& cast)\n    {\n    \u00a0\u00a0\u00a0\u00a0cast.push_back(new Wizard(\"Gandalf\"));\n    \u00a0\u00a0\u00a0\u00a0cast.push_back(new Healer(\"Glenda\"));\n    \u00a0\u00a0\u00a0\u00a0cast.push_back(new Warrior(\"Ben Grimm\"));\n    }\n    void freeCharacters(std::vector<ICharacter*>& cast)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(auto* character : cast)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete character;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0cast.clear();\n    }\n    ```", "```cpp\n    int main(int argc, char**argv)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"\\n------ Exercise 1 ------\\n\";\n    \u00a0\u00a0\u00a0\u00a0std::vector<ICharacter*> cast;\n    \u00a0\u00a0\u00a0\u00a0createCharacters(cast);\n    \u00a0\u00a0\u00a0\u00a0for(auto* character : cast)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0character->speak();\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for(auto* character : cast)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0character->act();\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0freeCharacters(cast);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    virtual ~ICharacter() {\n    ```", "```cpp\nclass DerivedC : Base\u00a0\u00a0// inherits as if \"class DerivedC : private Base\" was used\n{\n};\nstruct DerivedS : Base // inherits as if \"struct DerivedS : public Base\" was used\n{\n};\n```", "```cpp\nstruct Point\u00a0\u00a0\u00a0\u00a0\u00a0// A point in 3D space\n{\n\u00a0\u00a0double m_x;\n\u00a0\u00a0double m_y;\n\u00a0\u00a0double m_z;\n};\n```", "```cpp\nclass Matrix\n{\npublic:\n\u00a0\u00a0Matrix& operator*(const Matrix& rhs)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0// nitty gritty of the multiplication\n\u00a0\u00a0}\nprivate:\n\u00a0\u00a0// Declaration of the 2D array to store matrix.\n};\n```", "```cpp\nnamespace name_of_namespace {\u00a0\u00a0// put declarations in here }\n```", "```cpp\n    template< class RandomIt > void sort( RandomIt first, RandomIt last );\n    ```", "```cpp\ntemplate <class T>\nT clamp(T val, T lo, T hi)\n{\n\u00a0\u00a0return (val < lo) ? lo : (hi < val) ? hi : val;\n}\n```", "```cpp\n#include <iostream>\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << clamp(5, 3, 10) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << clamp(3, 5, 10) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << clamp(13, 3, 10) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << clamp(13.0, 3.0, 10.1) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << clamp<double>(13.0, 3, 10.2) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n#include <cassert>\ntemplate<class T, class Compare>\nconst T& clamp( const T& v, const T& lo, const T& hi, Compare comp )\n{\n\u00a0\u00a0\u00a0\u00a0return assert( !comp(hi, lo) ),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0comp(v, lo) ? lo : comp(hi, v) ? hi : v;\n}\ntemplate<class T>\nconst T& clamp( const T& v, const T& lo, const T& hi )\n{\n\u00a0\u00a0\u00a0\u00a0return clamp( v, lo, hi, std::less<>() );\n}\n```", "```cpp\nnamespace std {\n\u00a0\u00a0typedef basic_string<char> string;\n}\n```", "```cpp\n    typedef std::unique_ptr<std::map<std::string,myClass>> UptrMapStrToClass;\n    ```", "```cpp\nnamespace std {\n\u00a0\u00a0using string = basic_string<char>;\n}\n```", "```cpp\ntypedef int (*FunctionPointer)(const std::string&, const Point&); \n```", "```cpp\nusing FunctionPointer = int (*)(const std::string&, const Point&);\n```", "```cpp\n    typedef std::vector<int> IntVector;\n    ```", "```cpp\n    using IntVector = std::vector<int>;\n    ```", "```cpp\n    using IntVectorIter = std::vector<int>::iterator;\n    ```", "```cpp\n#include <iostream>\n#include <type_traits>\ntemplate <typename T, std::enable_if_t<sizeof(T) == 1, int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%c\\n\", val);\n}\ntemplate <typename T, std::enable_if_t<sizeof(T) == sizeof(int), int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\\n\", val);\n}\ntemplate <typename T, std::enable_if_t<sizeof(T) == sizeof(double), int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%f\\n\", val);\n}\nint main(int argc, char** argv)\n{\n\u00a0\u00a0\u00a0\u00a0print('c');\n\u00a0\u00a0\u00a0\u00a0print(55);\n\u00a0\u00a0\u00a0\u00a0print(32.1F);\n\u00a0\u00a0\u00a0\u00a0print(77.3);\n}\n```", "```cpp\ntemplate<typename int, int=0>\nvoid print<int,0>(int val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\\n\",val);\n}\ntemplate<typename float, int=0>\nvoid print<float,0>(float val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\\n\", val);\n}\n```", "```cpp\n#include <type_traits>\ntemplate <typename T, std::enable_if_t<std::is_floating_point_v<T>, int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%f\\n\", val);\n}\n```", "```cpp\ntemplate<bool B, class T = void>\nstruct enable_if {};\ntemplate<class T>\nstruct enable_if<true, T> { typedef T type; };\ntemplate< bool B, class T = void >\nusing enable_if_t = typename enable_if<B,T>::type;\n```", "```cpp\ntemplate <typename T, std::enable_if_t<condition, int> = 0>\nvoid print(T val) { \u2026 }\n```", "```cpp\ntemplate <typename T, int = 0>\nvoid print(T val) { \u2026 }\n```", "```cpp\ntemplate <typename T, = 0>\nvoid print(T val) { \u2026 }\n```", "```cpp\ntemplate <typename T, std::enable_if_t<sizeof(T) == sizeof(int), int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\\n\", val);\n}\ntemplate <typename T, std::enable_if_t<std::is_floating_point_v<T>, int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%f\\n\", val);\n}\n```", "```cpp\ntemplate <typename T, std::enable_if_t<std::is_integral_v<T>, int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\\n\", val);\n}\n```", "```cpp\ntemplate <typename T, std::enable_if_t<std::is_integral_v<T> && sizeof(T) != 1, int> = 0>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\\n\", val);\n}\n```", "```cpp\n#include <iostream>\n#include <type_traits>\ntemplate <typename T>\nvoid print(T val)\n{\n\u00a0\u00a0\u00a0if constexpr(sizeof(T)==1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"%c\",val);\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0else if constexpr(std::is_integral_v<T>) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"%d\",val);\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0else if constexpr(std::is_floating_point_v<T>) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"%f\",val);\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0printf(\"\\n\");\n}\nint main(int argc, char** argv)\n{\n\u00a0\u00a0\u00a0\u00a0print('c');\n\u00a0\u00a0\u00a0\u00a0print(55);\n\u00a0\u00a0\u00a0\u00a0print(32.1F);\n\u00a0\u00a0\u00a0\u00a0print(77.3);\n}\n```", "```cpp\ntemplate<>\nvoid print<int>(int val)\n{\n\u00a0\u00a0\u00a0\u00a0printf(\"%d\",val);\n\u00a0\u00a0\u00a0\u00a0printf(\"\\n\");\n}\n```", "```cpp\ntemplate <class T>\nT sum(T data[], int number)\n{\n\u00a0\u00a0T total = 0;\n\u00a0\u00a0for(auto i=0U ; i<number ; i++)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0total += data[i];\n\u00a0\u00a0}\n\u00a0\u00a0return total;\n}\n```", "```cpp\nfloat data[5] = {1.1, 2.2, 3.3, 4.4, 5.5};\nauto total = sum(data, 5);\n```", "```cpp\nauto total = sum(data);\n```", "```cpp\ntemplate <class T, std::size_t size>\nT sum(T (&data)[size])\n{\n\u00a0\u00a0T total = 0;\n\u00a0\u00a0for(auto i=0U ; i< size; i++)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0total += data[i];\n\u00a0\u00a0}\n\u00a0\u00a0return total;\n}\n```", "```cpp\n    template<typename T> std::string stringify(const T& x)\n    {\n    \u00a0\u00a0std::ostringstream out;\n    \u00a0\u00a0if constexpr (std::is_same_v<T, bool>)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out << std::boolalpha;\n    \u00a0\u00a0}\n    \u00a0\u00a0out << x;\n    \u00a0\u00a0return out.str();\n    }\n    ```", "```cpp\n    template<typename T> std::string stringify(const T& x)\n    {\n    \u00a0\u00a0std::ostringstream out;\n    \u00a0\u00a0if constexpr (std::is_same_v<T, bool>)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out << std::boolalpha;\n    \u00a0\u00a0}\n    \u00a0\u00a0else if constexpr (std::is_floating_point_v<T>)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const int sigdigits = std::numeric_limits<T>::digits10;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out << std::setprecision(sigdigits);\n    \u00a0\u00a0}\n    \u00a0\u00a0out << x;\n    \u00a0\u00a0return out.str();\n    }\n    ```", "```cpp\ntemplate<typename T>\nvoid function(ParamType parameter);\n```", "```cpp\nfunction(expression);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// deduce T and ParamType from expression\n```", "```cpp\ntemplate<typename T>\nstruct TypeDisplay;\n```", "```cpp\ntemplate<typename T>\nclass TypeDisplay;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0signed int x = 1;\n\u00a0\u00a0\u00a0\u00a0unsigned int y = 2;\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<decltype(x)> x_type;\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<decltype(y)> y_type;\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<decltype(x+y)> x_y_type;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\ntemplate<typename T>\nvoid function(ParamType parameter);\n```", "```cpp\nfunction(expression);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// deduce T and ParamType from expression\n```", "```cpp\ntemplate<typename T>\nvoid function(T parameter);\n```", "```cpp\ntemplate<typename T>\nclass TypeDisplay;\ntemplate<typename T>\nvoid function(T parameter)\n{\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<T> type;\n}\nvoid types()\n{\n\u00a0\u00a0\u00a0\u00a0int x = 42;\n\u00a0\u00a0\u00a0\u00a0function(x);\n}\n```", "```cpp\nconst int x = 42;\nfunction(x);\n```", "```cpp\nint x = 42;\nconst int& rx = x;\nfunction(rx);\n```", "```cpp\ntemplate<typename T>\nclass TypeDisplay;\ntemplate<typename T>\nvoid function(T& parameter)\n{\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<T> type;\n}\nvoid types()\n{\n\u00a0\u00a0\u00a0\u00a0int x = 42;\n\u00a0\u00a0\u00a0\u00a0function(x);\n}\n```", "```cpp\nvoid types()\n{\n\u00a0\u00a0\u00a0\u00a0const int x = 42;\n\u00a0\u00a0\u00a0\u00a0const int& rx = x;\n\u00a0\u00a0\u00a0\u00a0function(rx);\n}\n```", "```cpp\ntemplate<typename T>\nvoid function(const T& parameter)\n{\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<T> type;\n}\n```", "```cpp\nint ary[15];\nfunction(ary);\n```", "```cpp\ntemplate<typename T>\nvoid function(T parameter)\n{\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<T> type;\n}\n```", "```cpp\ntemplate<typename T>\nvoid function(T&& parameter)\n{\n\u00a0\u00a0\u00a0\u00a0TypeDisplay<T> type;\n}\n```", "```cpp\ntemplate<class T>\nauto mul(T a, T b) -> decltype(a * b) \n{\n\u00a0\u00a0\u00a0\u00a0return a * b;\n}\n```", "```cpp\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <set>\ntemplate<class C, class T>\nauto contains(const C& c, const T& x) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> decltype((void)(std::declval<C>().find(std::declval<T>())), true)\n{\n\u00a0\u00a0\u00a0\u00a0return end(c) != c.find(x);\n}\nint main(int argc, char**argv)\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ SFINAE Exercise ------\\n\";\n\u00a0\u00a0\u00a0\u00a0std::set<int> mySet {1,2,3,4,5};\n\u00a0\u00a0\u00a0\u00a0std::cout << std::boolalpha;\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Set contains 5: \" << contains(mySet,5) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Set contains 15: \" << contains(mySet,15) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\ndecltype( (void)(std::declval<C>().find(std::declval<T>())), true)\n```", "```cpp\ntemplate <class T, class A0>\nauto test_find(long) -> std::false_type;\ntemplate <class T, class A0>\nauto test_find(int) \n-> decltype(void(std::declval<T>().find(std::declval<A0>())), std::true_type{});\ntemplate <class T, class A0>\nstruct has_find : decltype(test_find<T,A0>(0)) {};\n```", "```cpp\ntemplate<class T>\nclass MyClass {\n\u00a0\u00a0\u00a0// variables and methods that use T.\n};\n```", "```cpp\n    bool empty() const\n    {\n    \u00a0\u00a0return m_stack.empty();\n    }\n    ```", "```cpp\n    using value_type = T;\n    using reference = value_type&;\n    using const_reference = const value_type&;\n    using size_type = std::size_t;\n    ```", "```cpp\n    void push(const value_type& value)\n    {\n    \u00a0\u00a0\u00a0\u00a0m_stack.push_back(value);\n    }\n    ```", "```cpp\n    size_type size() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_stack.size();\n    }\n    ```", "```cpp\n    void pop()\n    {\n    \u00a0\u00a0\u00a0\u00a0m_stack.pop_back();\n    }\n    ```", "```cpp\n    reference top()\n    {\n    \u00a0\u00a0\u00a0\u00a0m_stack.back();\n    }\n    const_reference top() const\n    {\n    \u00a0\u00a0\u00a0\u00a0m_stack.back();\n    }\n    ```"]