- en: '*Chapter 4*: Indirect Addressing: References'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：间接寻址：引用'
- en: This chapter will examine how to utilize references in C++. References can often,
    but not always, be used as an alternative to pointers for indirect addressing.
    Though you have prior experience with indirect addressing from our last chapter
    using pointers, we will start at the beginning to understand C++ references.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何在C++中利用引用。引用通常可以用作间接寻址的替代方案，但并非总是如此。尽管您在上一章中使用指针有间接寻址的经验，我们将从头开始理解C++引用。
- en: References, like pointers, are a language feature you must be able to utilize
    with ease. Many other languages use references for indirect addressing without
    requiring a thorough understanding that C++ imposes to correctly utilize both
    pointers and references. Just as with pointers, you will see references frequently
    used throughout code from other programmers. You may be pleased that using references
    will provide notational ease when writing applications compared to pointers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 引用和指针一样，是您必须能够轻松使用的语言特性。许多其他语言使用引用进行间接寻址，而不需要像C++那样深入理解才能正确使用指针和引用。与指针一样，您会经常在其他程序员的代码中看到引用的使用。与指针相比，使用引用在编写应用程序时提供了更简洁的表示方式，这可能会让您感到满意。
- en: Unfortunately, references cannot be used as a substitute for pointers in all
    situations requiring indirect addressing. Therefore, a thorough understanding
    of indirect addressing using both pointers and references is a necessity in C++
    to create successful and maintainable code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，在所有需要间接寻址的情况下，引用不能替代指针。因此，在C++中，深入理解使用指针和引用进行间接寻址是成功创建可维护代码的必要条件。
- en: The goal of this chapter will be to complement your understanding of indirect
    addressing using pointers with knowing how to use C++ references as an alternative.
    Understanding both techniques of indirect addressing will enable you to be a better
    programmer, easily able to understand and modify other's code and write original,
    mature, and competent C++ code yourself.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是通过了解如何使用C++引用作为替代方案来补充您对使用指针进行间接寻址的理解。了解两种间接寻址技术将使您成为一名更优秀的程序员，轻松理解和修改他人的代码，并自己编写原始、成熟和有竞争力的C++代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Reference basics – declaring, initializing, accessing, and referencing existing
    objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用基础 - 声明、初始化、访问和引用现有对象
- en: Using references with functions as arguments and as return values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将引用用作函数的参数和返回值
- en: Using the const qualifier with references
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引用中使用const限定符
- en: Understanding underlying implementation, and when references cannot be used
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解底层实现，以及引用不能使用的情况
- en: By the end of this chapter, you will understand how to declare, initialize,
    and access references; you will understand how to reference existing objects in
    memory. You will be able to use references as arguments to functions, and understand
    how they may be used as return values from functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何声明、初始化和访问引用；您将了解如何引用内存中现有的对象。您将能够将引用用作函数的参数，并了解它们如何作为函数的返回值使用。
- en: You will also fathom how the const qualifier may apply to references as variables,
    and be utilized with both a function's parameters and return type. You will be
    able to distinguish when references can be used in lieu of pointers, and which
    situations they cannot provide a substitute for pointers. These skills will be
    necessary in order to move forward with the next chapters in the book successfully.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解const限定符如何适用于引用作为变量，并且如何与函数的参数和返回类型一起使用。您将能够区分引用何时可以替代指针，以及它们不能替代指针的情况。这些技能将是成功阅读本书后续章节的必要条件。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter04` in a file named `Chp4-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与所在章节编号相对应，后跟破折号，再跟随所在章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp4-Ex1.cpp`的文件中的`Chapter04`子目录中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OM7GJP](https://bit.ly/2OM7GJP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/2OM7GJP](https://bit.ly/2OM7GJP)
- en: Understanding reference basics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解引用基础
- en: In this section, we will revisit reference basics as well as introduce operators
    applicable to references, such as the reference operator `&`. We will employ the
    reference operator `&` to establish a reference to the existing variable. Like
    pointer variables, reference variables refer to memory that is defined elsewhere.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新讨论引用基础，并介绍适用于引用的运算符，如引用运算符`&`。我们将使用引用运算符`&`来建立对现有变量的引用。与指针变量一样，引用变量指向在其他地方定义的内存。
- en: Using reference variables allows us to use a more straightforward notation than
    pointers use when using indirectly accessed memory. Many programmers appreciate
    the clarity in the notation of a reference versus a pointer variable. But, behind
    the scenes, memory must always be properly allocated and released; some portion
    of memory that is referenced may come from the heap. The programmer will undoubtedly
    need to deal with pointers for some portion of their overall code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引用变量允许我们使用比指针间接访问内存时更简单的符号。许多程序员欣赏引用与指针变量的符号的清晰度。但是，在幕后，内存必须始终被正确分配和释放；被引用的一部分内存可能来自堆。程序员无疑需要处理指针来处理其整体代码的一部分。
- en: We will discern when references and pointers are interchangeable, and when they
    are not. Let's get started with the basic notation for declaring and using reference
    variables.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分辨引用和指针何时可以互换使用，何时不可以。让我们从声明和使用引用变量的基本符号开始。
- en: Declaring, initializing, and accessing references
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明、初始化和访问引用
- en: Let's begin with the meaning of a reference variable. A C++ `&`. A reference
    must be initialized (at declaration) and may never be assigned to reference another
    object. The reference and the initializer must be of the same type. Since the
    reference and the object being referenced share the same memory, either variable
    may be used to modify the contents of the shared memory location.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从引用变量的含义开始。C++中的`&`。引用必须在声明时初始化，并且永远不能被分配给引用另一个对象。引用和初始化器必须是相同类型。由于引用和被引用的对象共享相同的内存，任一变量都可以用来修改共享内存位置的内容。
- en: A reference variable, behind the scenes, can be compared to a pointer variable—in
    that it holds the address of the variable that it is referencing. Unlike a pointer
    variable, any usage of the reference variable automatically dereferences the variable
    to go to the address that it contains; the dereference operator `*` is simply
    not needed with references. Dereferencing is automatic and implied with each use
    of a reference variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量，在幕后，可以与指针变量相比较——因为它保存了它引用的变量的地址。与指针变量不同，引用变量的任何使用都会自动取消引用变量以转到它包含的地址；取消引用运算符`*`在引用中是不需要的。取消引用是自动的，并且隐含在每次使用引用变量时。
- en: 'Let''s take a look at an example illustrating reference basics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个说明引用基础的例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex1.cpp)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we first declare and initialize `int x = 10;` and
    then declare and allocate `int *p = new int;`. We then assign the integer value
    20 to `*p`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先声明并初始化`int x = 10;`，然后声明并分配`int *p = new int;`。然后我们将整数值20分配给`*p`。
- en: Next, we declare and initialize two reference variables, `refInt1` and `refInt2`.
    In the first reference declaration and initialization, `int &refInt1 = x;`, we
    establish `refInt1` to refer to variable `x`. It helps to read the reference declaration
    from right to left. Here, we are saying to use `x` to initialize `refInt1`, which
    is a reference (`&`) to an integer. Notice that both the initializer, `x`, is
    an integer, and that `refInt1` is declared to be a reference to an integer; their
    types match. This is important. The code will not compile if the types differ.
    Likewise, the declaration and initialization `int &refInt2 = *p;` also establishes
    `refInt2` as a reference to an integer. Which one? The one pointed to by `p`.
    This is why `p` is dereferenced using `*` to go to the integer itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明并初始化两个引用变量，`refInt1`和`refInt2`。在第一个引用声明和初始化中，`int &refInt1 = x;`，我们建立`refInt1`引用变量指向变量`x`。从右向左阅读引用声明有助于理解。在这里，我们说要使用`x`来初始化`refInt1`，它是一个整数的引用（`&`）。注意初始化器`x`是一个整数，并且`refInt1`声明为整数的引用；它们的类型匹配。这很重要。如果类型不同，代码将无法编译。同样，声明和初始化`int
    &refInt2 = *p;`也将`refInt2`建立为整数的引用。哪一个？由`p`指向的那个。这就是为什么使用`*`对`p`进行取消引用以获得整数本身。
- en: Now, we print out `x`, `*p`, `refInt1`, and `refInt2`; we can verify that `x`
    and `refInt1` have the same value of `10`, and `*p` and `refInt2` also have the
    same value of `20`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打印出`x`、`*p`、`refInt1`和`refInt2`；我们可以验证`x`和`refInt1`的值相同为`10`，而`*p`和`refInt2`的值也相同为`20`。
- en: Next, using the original variables, we increment both `x` and `*p` by one. Not
    only does this increment the values of `x` and `*p`, but the values of `refInt1`
    and `refInt2`. Repeating the printing of these four values, we again notice that
    `x` and `refInt1` have the value of `11`, while `*p` and `refInt2` have the value
    of `21`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用原始变量，我们将`x`和`*p`都增加一。这不仅增加了`x`和`*p`的值，还增加了`refInt1`和`refInt2`的值。重复打印这四个值，我们再次注意到`x`和`refInt1`的值为`11`，而`*p`和`refInt2`的值为`21`。
- en: Finally, we use the reference variables to increment the shared memory. We increment
    both `refInt1` and `*refint2` by one and this also increments the values of the
    original variables `x` and `*p`. This is because the memory is one and the same
    between the original variable and the reference to that variable. That is, the
    reference can be thought of as an alias to the original variable. We conclude
    the program by again printing out the four variables.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用引用变量来增加共享内存。我们将`refInt1`和`*refint2`都增加一，这也增加了原始变量`x`和`*p`的值。这是因为内存是原始变量和引用到该变量的相同。也就是说，引用可以被视为原始变量的别名。我们通过再次打印这四个变量来结束程序。
- en: 'Here is the output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember, a reference variable must be initialized to the variable it will refer
    to. The reference may never be assigned to another variable. The reference and
    its initializer must be the same type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，引用变量必须初始化为它将引用的变量。引用永远不能被分配给另一个变量。引用和它的初始化器必须是相同类型。
- en: Now that we have a handle on how to declare simple references, let's take a
    more complete look at referencing existing objects, such as those to user defined
    types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了如何声明简单引用，让我们更全面地看一下引用现有对象，比如用户定义类型的对象。
- en: Referencing existing objects of user defined types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用现有的用户定义类型的对象
- en: Should a reference to an object of a `struct` or `class` type be defined, the
    object being referenced is simply accessed using the `.` (member selection operator).
    Again, it is not necessary (as it is with pointers) to first use the dereference
    operator to go to the object being referenced before choosing the desired member.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义一个`struct`或`class`类型的对象的引用，那么被引用的对象可以简单地使用`.`（成员选择运算符）访问。同样，不需要（就像指针一样）首先使用取消引用运算符来访问被引用的对象，然后选择所需的成员。
- en: 'Let''s take a look at an example in which we reference a user defined type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个引用用户定义类型的例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex2.cpp)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first part of this program, we define a user defined type, `Student`,
    using a `class`. Next, we declare a variable `s1` of type `Student` using `Student
    s1;`. Now, we declare and initialize a reference to a `Student` using `Student
    &sRef = s1;`. Here, we declare `sRef` to reference a specific `Student`, namely,
    `s1`. Notice that both `s1` is of type `Student` and the reference type of `sRef`
    is also that of type `Student`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第一部分中，我们使用`class`定义了一个用户定义类型`Student`。接下来，我们使用`Student s1;`声明了一个类型为`Student`的变量`s1`。现在，我们使用`Student
    &sRef = s1;`声明并初始化了一个`Student`的引用。在这里，我们声明`sRef`引用特定的`Student`，即`s1`。注意，`s1`是`Student`类型，而`sRef`的引用类型也是`Student`类型。
- en: Now, we load some initial data into `s1` using `strcpy()`, followed by a simple
    assignment. Consequently, this alters the value of `sRef` since `s1` and `sRef`
    refer to the same memory. That is, `sRef` is an alias for `s1`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`strcpy()`加载一些初始数据到`s1`中，然后进行简单赋值。因此，这改变了`sRef`的值，因为`s1`和`sRef`引用相同的内存。也就是说，`sRef`是`S1`的别名。
- en: We print out various data members for `s1` and `sRef` and notice that they contain
    the same values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出`s1`和`sRef`的各种数据成员，并注意到它们包含相同的值。
- en: Now, we load new values into `sRef`, also using `strcpy()`, and a simple assignment.
    Similarly, we print out various data members for `s1` and `sRef` and notice that
    again, the values for both have changed. Again, we can see that they reference
    the same memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们加载新的值到`sRef`中，也使用`strcpy()`和简单赋值。同样，我们打印出`s1`和`sRef`的各种数据成员，并注意到它们的值再次发生了改变。我们可以看到它们引用相同的内存。
- en: 'The output to accompany this program is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出如下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's now move forward with our understanding of references by considering their
    usage in functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过考虑在函数中使用引用来进一步了解引用的用法。
- en: Using references with functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引用与函数
- en: So far, we have minimally demonstrated references by using them to establish
    an alias for an existing variable. Instead, let's put forth a meaningful use of
    references, such as when they are used in function calls. We know most functions
    in C++ will take arguments, and we have seen many examples in the previous chapters
    illustrating function prototypes and function definitions. Now, let's augment
    our understanding of functions by passing references as arguments to functions,
    and using references as return values from functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过使用引用来为现有变量建立别名来最小程度地演示了引用。相反，让我们提出引用的有意义用法，比如在函数调用中使用它们。我们知道C++中的大多数函数将接受参数，并且在前几章中我们已经看到了许多示例，说明了函数原型和函数定义。现在，让我们通过将引用作为函数的参数传递，并使用引用作为函数的返回值来增进我们对函数的理解。
- en: Passing references as arguments to functions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将引用作为函数的参数传递
- en: References may be used as arguments to functions to achieve call-by-reference,
    rather than call-by-value parameter passing. References can alleviate the need
    for pointer notation in the scope of the function in question as well as in the
    call to that function. Object or `.` (member selection) notation is used to access
    `struct` or `class` members for formal parameters that are references.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以作为函数的参数来实现按引用传递，而不是按值传递参数。引用可以减轻在所涉及的函数范围内以及调用该函数时使用指针表示的需要。对于引用的形式参数，使用对象或`.`（成员选择）表示法来访问`struct`或`class`成员。
- en: In order to modify the contents of a variable passed as an argument to a function,
    a reference (or pointer) to that argument must be used as a function parameter.
    Just as with a pointer, when a reference is passed to a function, a copy of the
    address representing the reference is passed to the function. However, within
    the function, any usage of a formal parameter that is a reference will automatically
    and implicitly be dereferenced, allowing the user to use object rather than pointer
    notation. As with passing a pointer variable, passing a reference variable to
    a function will allow the memory referenced by that parameter to be modified.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改作为参数传递给函数的变量的内容，必须使用对该参数的引用（或指针）作为函数参数。就像指针一样，当引用传递给函数时，传递给函数的是表示引用的地址的副本。然而，在函数内部，任何使用引用作为形式参数的用法都会自动隐式地取消引用，允许用户使用对象而不是指针表示。与传递指针变量一样，将引用变量传递给函数将允许修改由该参数引用的内存。
- en: When examining a function call (apart from its prototype), it will not be obvious
    if an object passed to that function is passed by value or by reference. That
    is, whether the entire object will be copied on the stack or if a reference to
    that object will instead be passed on the stack. This is because object notation
    is used when manipulating references and the function calls for these two scenarios
    will use the same syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查函数调用时（除了其原型），如果传递给该函数的对象是按值传递还是按引用传递，这将不明显。也就是说，整个对象是否将在堆栈上复制，还是堆栈上将传递对该对象的引用。这是因为在操作引用时使用对象表示法，并且这两种情况的函数调用将使用相同的语法。
- en: Diligent use of function prototypes will solve the mystery of what a function
    definition looks like and whether its arguments are objects or references to objects.
    Remember, a function definition may be defined in a separate file from any calls
    to that function, and not be easily available to view. Note that this ambiguity
    does not come up with pointers specified in a function call; it is immediately
    obvious that an address is being sent to a function based on how the variable
    is declared.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 勤奋使用函数原型将解决函数定义的外观以及其参数是对象还是对象引用的神秘。请记住，函数定义可以在与该函数的任何调用分开的文件中定义，并且不容易查看。请注意，指定在函数调用中的指针不会出现这种模棱两可的情况；根据变量的声明方式，立即就能明显地知道地址被发送到函数。
- en: 'Let''s take a few minutes to understand an example illustrating passing references
    as arguments to functions. Here, we will begin by examining three functions that
    contribute to the following full program example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟来理解一个示例，说明将引用作为参数传递给函数。在这里，我们将从检查有助于以下完整程序示例的三个函数开始：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex3.cpp)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Examining the functions above, notice that `AddOne(int &arg)` takes a reference
    to an `int` as a formal parameter, while `AddOne(int *arg)` takes a pointer to
    an `int` as a formal parameter. These functions are overloaded. The types of their
    actual parameters will determine which version is called.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的函数中，注意`AddOne（int＆arg）`将引用作为形式参数，而`AddOne（int *arg）`将指针作为形式参数。这些函数是重载的。它们的实际参数的类型将决定调用哪个版本。
- en: Now let's consider `Display(int &arg)`. This function takes a reference to an
    integer. Notice that object (not pointer) notation is used to print `arg` within
    this function's definition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑`Display（int＆arg）`。此函数接受对整数的引用。请注意，在此函数的定义中，使用对象（而不是指针）表示法来打印`arg`。
- en: 'Now, let''s examine the remainder of this program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查此程序的其余部分：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the function prototypes at the top of this program segment. They will
    match the function definitions in the previous segment of code. Now, in the `main()`
    function, we declare and initialize `int x = 10;` and declare a pointer `int *y;`.
    We allocate the memory for `y` using `new()` and then assign a value by dereferencing
    the pointer with `*y = 15;`. We print out the respective values of `x` and `*y`
    as a baseline using successive calls to `Display()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此程序段顶部的函数原型。它们将与先前代码段中的函数定义匹配。现在，在`main（）`函数中，我们声明并初始化`int x = 10;`并声明一个指针`int
    *y;`。我们使用`new（）`为`y`分配内存，然后通过解引用指针赋值`*y = 15;`。我们使用连续调用`Display（）`打印出`x`和`*y`的相应值作为基线。
- en: Next, we call `AddOne(x)` followed by `AddOne(*y)`. Variable `x` is declared
    to be an integer and `*y` refers to the integer pointed to by `y`. In both cases,
    we are passing integers as actual parameters to the version of the overloaded
    function with the signature `void AddOne(int &);`. In both cases, the formal parameters
    will be changed in the function, as we are passing by reference. We can verify
    this when their respective values are next printed using successive calls to `Display()`.
    Note that in the function call `AddOne(x);`, the reference to the actual parameter
    `x` is established by the formal parameter `arg` (in the function's parameter
    list) at the time of the function call.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`AddOne（x）`，然后是`AddOne（*y）`。变量`x`被声明为整数，`*y`指的是`y`指向的整数。在这两种情况下，我们都将整数作为实际参数传递给带有签名`void
    AddOne（int＆）`的重载函数版本。在这两种情况下，形式参数将在函数中更改，因为我们是通过引用传递的。当它们的相应值在接下来的连续调用`Display（）`中打印时，我们可以验证这一点。请注意，在函数调用`AddOne（x）`中，实际参数`x`的引用是在函数调用时由形式参数`arg`（在函数的参数列表中）建立的。
- en: In comparison, we then call `AddOne(&x);` followed by `AddOne(y);`. In both
    cases, we are calling the overloaded version of this function with the signature
    `void AddOne(int *);`. In each case, we are passing a copy of an address as the
    actual parameter to the function. Naturally, `&x` is the address of variable `x`,
    so this works. Likewise, `y` itself is an address – it is declared as a pointer
    variable. We again verify that their respective values are again changed with
    two calls to `Display()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们接下来调用`AddOne（＆x）`，然后是`AddOne（y）`。在这两种情况下，我们都调用了带有签名`void AddOne（int *）`的此函数的重载版本。在每种情况下，我们都将地址的副本作为实际参数传递给函数。自然地，`＆x`是变量`x`的地址，所以这有效。同样，`y`本身就是一个地址-它被声明为指针变量。我们再次验证它们的相应值是否再次更改，使用两次`Display（）`调用。
- en: Notice, in each call to `Display()`, we pass an object of type `int`. Looking
    at the function call alone, we cannot determine whether this function will take
    an `int` as an actual parameter (which would imply the value could not be changed),
    or an `int &` as an actual parameter (which would imply that the value could be
    modified). Either of these are possibilities. However, by looking at the function
    prototype, we can clearly see that this function takes an `int &` as a parameter,
    and from this, we understand that the parameter may likely be modified. This is
    one of the many reasons function prototypes are helpful.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每次调用`Display()`时，我们都传递了一个`int`类型的对象。仅仅看函数调用本身，我们无法确定这个函数是否将以实际参数`int`（这意味着值不能被更改）或者以实际参数`int
    &`（这意味着值可以被修改）的形式接受。这两种情况都是可能的。然而，通过查看函数原型，我们可以清楚地看到这个函数以`int &`作为参数，从中我们可以理解参数很可能会被修改。这是函数原型有帮助的众多原因之一。
- en: 'Here is the output for the full program example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整程序示例的输出：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's add to our discussion of using references with functions by using
    references as return values from functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用引用作为函数的返回值来扩展我们对使用引用的讨论。
- en: Using references as return values from functions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用引用作为函数返回值
- en: Functions may return references to data via their return statements. We will
    see a requirement to return data by reference when we overload operators for user
    defined types in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Friends and Operator Overloading*. With operator overloading, returning a value
    from a function using a pointer will not be an option to preserve the operator's
    original syntax; we must return a reference (or a reference qualified with const).
    Additionally, understanding how to return objects by reference will be useful
    as we explore the C++ Standard Template Library in [*Chapter 14*](B15702_14_Final_NM_ePub.xhtml#_idTextAnchor518),
    *Understanding STL Basics*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过它们的返回语句返回对数据的引用。我们将在[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)中看到需要通过引用返回数据的情况，*友元和运算符重载*。使用运算符重载，使用指针从函数返回值将不是一个选项，以保留运算符的原始语法；我们必须返回一个引用（或者一个带有const限定符的引用）。此外，了解如何通过引用返回对象将是有用的，因为我们在[*第14章*](B15702_14_Final_NM_ePub.xhtml#_idTextAnchor518)中探讨C++标准模板库时会用到，*理解STL基础*。
- en: When returning a reference via the return statement of a function, be sure that
    the memory that is referred to will persist after the function call is completed.
    Do **not** return a reference to a local variable defined on the stack within
    the function; this memory will be popped off the stack the moment the function
    completes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过函数的返回语句返回引用时，请确保被引用的内存在函数调用完成后仍然存在。**不要**返回对函数内部栈上定义的局部变量的引用；这些内存将在函数完成时从栈上弹出。
- en: Since we cannot return a reference to a local variable within the function,
    and since returning a reference to an external variable is pointless, you may
    ask where will the data that we return a reference to reside? This data will inevitably
    be on the heap. Heap memory will exist past the extent of the function call. In
    most circumstances, the heap memory will have been allocated elsewhere; however,
    on rare occasions, the memory may have been allocated within this function. In
    this situation, you must remember to relinquish the allocated heap memory when
    it is no longer required.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法从函数内部返回对局部变量的引用，并且因为返回对外部变量的引用是没有意义的，您可能会问我们返回的引用所指向的数据将存放在哪里？这些数据将不可避免地位于堆上。堆内存将存在于函数调用的范围之外。在大多数情况下，堆内存将在其他地方分配；然而，在很少的情况下，内存可能已经在此函数内分配。在这种情况下，当不再需要时，您必须记得放弃已分配的堆内存。
- en: Deleting heap memory through a reference (versus pointer) variable will require
    you to use the address-of operator `&` to pass the required address to operator
    `delete()`. Even though reference variables contain the address of the object
    they are referencing, the use of a reference identifier is always in its dereferenced
    state. It is rare that the need may arise to delete memory using a reference variable;
    we will discuss a meaningful (yet rare) example in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用（而不是指针）变量删除堆内存将需要您使用取地址运算符`&`将所需的地址传递给`delete()`运算符。即使引用变量包含它们引用的对象的地址，但引用标识符的使用始终处于其取消引用状态。很少会出现使用引用变量删除内存的情况；我们将在[*第10章*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386)中讨论一个有意义（但很少）的例子，*实现关联、聚合和组合*。
- en: 'Let''s see an example to illustrate the mechanics of using a reference as a
    return value from a function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来说明使用引用作为函数返回值的机制：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex4.cpp)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex4.cpp)'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we see `int &CreateId();` prototyped towards the top of the
    program. This tells us that `CreateId()` will return a reference to an integer.
    The return value must be used to initialize a variable of type `int &`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到程序顶部有`int &CreateId();`的原型。这告诉我们`CreateId()`将返回一个整数的引用。返回值必须用来初始化一个`int
    &`类型的变量。
- en: Towards the bottom of the program, we see the function definition for `CreateId()`.
    Notice that this function first declares a `static` counter, which is initialized
    exactly once to `100`. Because this local variable is `static`, it will preserve
    its value from function call to function call. We then increment this counter
    by one a few lines later. The static variable, `count`, will be used as a basis
    to generate a unique ID.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序底部，我们看到了`CreateId()`的函数定义。请注意，此函数首先声明了一个`static`计数器，它被初始化为`100`。因为这个局部变量是`static`的，它将保留从函数调用到函数调用的值。然后我们在几行后递增这个计数器。静态变量`count`将被用作生成唯一ID的基础。
- en: Next in `CreateId()`, we allocate space for an integer on the heap and point
    to it using the local variable `memory`. We then load `*memory` with the value
    of `count` and then increase `count` for the next time we enter this function.
    We then use `*memory` as the return value of this function. Notice that `*memory`
    is an integer (the one pointed to on the heap by the variable `memory`). When
    we return it from the function, it is returned as a reference to that integer.
    When returning a reference from a function, always ensure that the memory that
    is referenced exists beyond the extent of the function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在`CreateId()`中，我们在堆上为一个整数分配空间，并使用局部变量`memory`指向它。然后我们将`*memory`加载为`count`的值，然后为下一次进入这个函数增加`count`。然后我们使用`*memory`作为这个函数的返回值。请注意，`*memory`是一个整数（由变量`memory`在堆上指向的整数）。当我们从函数中返回它时，它作为对该整数的引用返回。当从函数中返回引用时，始终确保被引用的内存存在于函数的范围之外。
- en: 'Now, let''s look at our `main()` function. Here, we initialize a reference
    variable `id1` with the return value of our first call to `CreateId()` in the
    following function call and initialization: `int &id1 = CreateId();`. Note that
    the reference `id1` must be initialized when it is declared, and we have met that
    requirement with the aforementioned line of code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`main()`函数。在这里，我们使用第一次调用`CreateId()`的返回值初始化了一个引用变量`id1`，如下所示的函数调用和初始化：`int
    &id1 = CreateId();`。请注意，引用`id1`在声明时必须被初始化，我们已经通过上述代码行满足了这个要求。
- en: We repeat this process with `id2`, initializing this reference with the return
    value of `CreateId()`. We then print both `id1` and `id2`. By printing both `id1`
    and `id2`, you can see that each id variable has its own memory and maintains
    its own data values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复这个过程，用`CreateId()`的返回值初始化这个引用`id2`。然后我们打印`id1`和`id2`。通过打印`id1`和`id2`，您可以看到每个id变量都有自己的内存并保持自己的数据值。
- en: Next, we must remember to deallocate the memory that `CreateId()` allocated
    on our behalf. We must use operator `delete()`. Wait, operator `delete()` expects
    a pointer to the memory that will be deleted. Variables `id1` and `id2` are both
    references, not pointers. True, they each contain an address because each is inherently
    implemented as a pointer, but any use of their respective identifiers is always
    in a dereferenced state. To circumvent this dilemma, we simply take the address
    of reference variables `id1` and `id2` prior to calling `delete()`, such as `delete
    &id1;`. It is *rare* that you would need to delete memory via a reference variable,
    but now you know how to do so should the need arise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须记得释放`CreateId()`分配的内存。我们必须使用`delete()`运算符。等等，`delete()`运算符需要一个指向将被删除的内存的指针。变量`id1`和`id2`都是引用，而不是指针。是的，它们各自包含一个地址，因为每个都是作为指针实现的，但是它们各自的标识符的任何使用总是处于解引用状态。为了规避这个困境，我们只需在调用`delete()`之前取引用变量`id1`和`id2`的地址，比如`delete
    &id1;`。*很少*情况下，您可能需要通过引用变量删除内存，但现在您知道在需要时如何做。
- en: 'The output for this example is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的输出是：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we understand how references can be used within parameters to functions
    and as return values from functions, let's move forward by examining further reference
    nuances.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了引用如何在函数参数中使用以及作为函数的返回值，让我们继续通过进一步研究引用的微妙之处。
- en: Using the const qualifier with references
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用const限定符与引用
- en: The `const` qualifier can be used to qualify the data in which references are
    initialized or *refer to*. We can also use `const` qualified references as arguments
    to functions and as return values from functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`限定符可以用来限定引用初始化或*引用的*数据。我们还可以将`const`限定的引用用作函数的参数和函数的返回值。'
- en: It is important to understand that a reference is implemented as a constant
    pointer in C++. That is, the address contained within the reference variable is
    a fixed address. This explains why a reference variable must be initialized to
    the object that it will refer to, and may not later be updated using an assignment.
    This also explains why constant qualifying the reference itself (and not just
    the data that it refers to) does not make sense. This variety of `const` qualification
    is already implied with its underlying implementation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在C++中，引用被实现为一个常量指针。也就是说，引用变量中包含的地址是一个固定的地址。这解释了为什么引用变量必须初始化为它将引用的对象，并且不能以后使用赋值来更新。这也解释了为什么仅对引用本身（而不仅仅是它引用的数据）进行常量限定是没有意义的。这种`const`限定的变体已经隐含在其底层实现中。
- en: Let's take a look at these various scenarios using `const` with references.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在引用中使用`const`的各种情况。
- en: Using references to constant objects
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对常量对象的引用
- en: The `const` qualifier can be used to indicate that the data in which references
    are initialized to are unmodifiable. In this fashion, the alias always refers
    to a fixed piece of memory, and the value of that variable may not be changed
    using the alias itself. The reference, once specified as constant, implies neither
    the reference nor its value may be changed. Again, the reference itself may not
    be changed due to its underlying implementation as a constant qualified pointer.
    A `const` qualified reference may not be used as an *l-value* in any assignment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`限定符可以用来指示引用初始化的数据是不可修改的。这样，别名总是引用一个固定的内存块，该变量的值不能使用别名本身来改变。一旦指定为常量，引用意味着既不会改变引用本身，也不会改变其值。同样，由于其底层实现为常量限定指针，`const`限定的引用不能在任何赋值中用作*l值*。'
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Recall, an l-value means a value that can be modified, and that occurs on the
    left-hand side of an assignment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，左值意味着可以修改的值，并且出现在赋值的左侧。
- en: 'Let''s introduce a simple example to understand the situation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子来理解这种情况：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex5.cpp)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex5.cpp
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous example, notice that we declare `int x = 5;` and then we establish
    a constant reference to that integer with the declaration `const int &refInt =
    x;`. Next, we print out both values for a baseline and notice that they are identical.
    This makes sense, they reference the same integer memory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，注意我们声明`int x = 5;`，然后我们用声明`const int &refInt = x;`建立对该整数的常量引用。接下来，我们打印出基线的两个值，并注意它们是相同的。这是有道理的，它们引用相同的整数内存。
- en: Next, in the commented-out piece of code, `//refInt = 6;`, we try to modify
    the data that the reference refers to. Because `refInt` is qualified as `const`,
    this is illegal; hence this is the reason why we commented out this line of code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在被注释掉的代码片段中，`//refInt = 6;`，我们试图修改引用所指向的数据。因为`refInt`被限定为`const`，这是非法的；因此这就是我们注释掉这行代码的原因。
- en: However, in the following line of code, we assign `x` a value of `7`. Since
    `refInt` refers to this same memory, its value will also be modified. Wait, isn't
    `refInt` constant? Yes, by qualifying `refInt` as `const`, we are indicating that
    its value will not be modified using the identifier `refInt`. This memory can
    still be modified using `x`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下一行代码中，我们给`x`赋值为`7`。由于`refInt`引用了相同的内存，它的值也将被修改。等等，`refInt`不是常量吗？是的，通过将`refInt`限定为`const`，我们指示使用标识符`refInt`时其值不会被修改。这个内存仍然可以使用`x`来修改。
- en: But wait, isn't this a problem? No, if `refInt` truly wants to refer to something
    unmodifiable, it can instead initialize itself with a `const int`, not an `int`.
    This subtle point is something to remember in C++ so you can write code for exactly
    the scenario you intend to have, understanding the significance and consequences
    of each choice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，这不是一个问题吗？不，如果`refInt`真的想要引用不可修改的东西，它可以用`const int`而不是`int`来初始化自己。这是C++中一个微妙的点，因此你可以编写完全符合你意图的代码，理解每种选择的重要性和后果。
- en: 'The output for this example is:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的输出是：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, let's see a variation on the `const` qualification theme.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`const`限定符主题的变化。
- en: Using pointers to constant objects as function arguments and as return types
    from functions
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指向常量对象的指针作为函数参数和作为函数的返回类型
- en: Using `const` qualification with function parameters can allow the speed of
    passing an argument by reference, but the safety of passing an argument by value.
    It is a useful feature in C++.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`限定符与函数参数可以允许通过引用传递参数的速度，但通过值传递参数的安全性。这是C++中一个有用的特性。
- en: A function that takes a reference to an object as a parameter often has less
    overhead than a comparable version of the function that takes a copy of an object
    as a parameter. This most notably occurs when the object type that would be otherwise
    copied on the stack is large. Passing a reference as a formal parameter is speedier,
    yet permits the actual parameter to be potentially modified in the scope of the
    function. Passing a reference to a constant object as a function argument provides
    both speed and safety for the argument in question. The reference qualified as
    `const` in the parameter list simply may not be an l-value in the scope of the
    function in question.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数将一个对象的引用作为参数通常比将对象的副本作为参数的函数版本具有更少的开销。当在堆栈上复制的对象类型很大时，这种情况最为明显。将引用作为形式参数传递更快，但允许在函数范围内可能修改实际参数。将常量对象的引用作为函数参数提供了参数的速度和安全性。在参数列表中限定为`const`的引用在所讨论的函数范围内可能不是一个左值。
- en: The same benefit of `const` qualified references exists for the return value
    from a function. Constant qualifying the data referenced insists that the caller
    of the function must also store the return value in a reference to a constant
    object, ensuring the object may not be modified.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`限定符引用的同样好处也存在于函数的返回值中。常量限定所引用的数据坚持要求函数的调用者也必须将返回值存储在对常量对象的引用中，确保对象不会被修改。'
- en: 'Let''s take a look at an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex6.cpp)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex6.cpp
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we first define a simple `class Collection` with data members
    `x` and `y`. Next, we prototype `Update(Collection &);` and `Print(const Collection
    &);`. Notice that `Print()` constant qualifies the data being referenced as the
    input parameter. This means that this function will enjoy the speed of passing
    this parameter by reference, but the safety of passing the parameter by value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个简单的`class Collection`，其中包含数据成员`x`和`y`。接下来，我们原型化了`Update(Collection
    &);`和`Print(const Collection &);`。请注意，`Print()`对被引用的数据进行了常量限定作为输入参数。这意味着该函数将通过引用传递此参数，享受传递参数的速度，但通过值传递参数的安全性。
- en: 'Notice, towards the end of the program, we see the definitions for both `Update()`
    and `Print()`. Both take references as arguments, however, the parameter to `Print()`
    is constant qualified: `void Print(const Collection &);`. Notice that both functions
    use `.` (member selection) notation within each function body to access the relevant
    data members.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在程序的末尾，我们看到了`Update()`和`Print()`的定义。两者都采用引用作为参数，但是`Print()`的参数是常量限定的：`void
    Print(const Collection &);`。请注意，两个函数在每个函数体内使用`.`（成员选择）符号来访问相关的数据成员。
- en: In `main()`, we declare two variables, `collect1` of type `Collection`, and
    `collect2`, which is a pointer to a `Collection` (and whose memory is subsequently
    allocated). We call `Update()` for both `collect1` and `*collect2`, and in each
    case, a reference to the applicable object is passed to the `Update()` function.
    In the case of `collect2`, which is a pointer variable, the actual parameter must
    first dereference `*collect2` to go to the object being referenced, before calling
    this function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们声明了两个变量，`collect1`类型为`Collection`，`collect2`是指向`Collection`的指针（并且其内存随后被分配）。我们为`collect1`和`*collect2`都调用了`Update()`，在每种情况下，都将适用对象的引用传递给`Update()`函数。对于`collect2`，它是一个指针变量，实际参数必须首先解引用`*collect2`，然后调用此函数。
- en: Finally, in `main()`, we call `Print()` successively for both `collect1` and
    `*collect2`. Here, `Print()` will reference each object serving as a formal parameter
    as constant qualified referenced data, ensuring that no modifications of either
    input parameter are possible within the scope of the `Print()` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`中，我们连续为`collect1`和`*collect2`调用`Print()`。在这里，`Print()`将引用每个对象作为常量限定的引用数据，确保在`Print()`函数范围内不可能修改任何输入参数。
- en: 'Here is the output to accompany our example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例的输出：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have an understanding of when `const` qualified references are useful,
    let's take a look at when we can use references in lieu of pointers, and when
    we may not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`const`限定引用何时有用，让我们看看何时可以使用引用代替指针，以及何时不可以。
- en: Realizing underlying implementation and restrictions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现底层实现和限制
- en: References can ease the notation required for indirect referencing. However,
    there are situations in which references simply cannot take the place of pointers.
    To understand these situations, it is useful to review the underlying implementation
    of a reference in C++.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以简化间接引用所需的符号。但是，在某些情况下，引用根本无法取代指针。要了解这些情况，有必要回顾一下C++中引用的底层实现。
- en: References are implemented as constant pointers, hence they must be initialized.
    Once initialized, references may not refer to a different object (though the value
    of the object being referenced can be changed).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 引用被实现为常量指针，因此必须初始化。一旦初始化，引用就不能引用不同的对象（尽管被引用的对象的值可以更改）。
- en: 'To understand the implementation, let''s consider a sample reference declaration:
    `int &intVar = x;`. From an implementation aspect, it is as though the former
    variable declaration is instead declared as `int *const intVar = &x;`. Note that
    the `&` symbol shown on the left-hand side of an initialization takes on the meaning
    of reference, whereas the `&` symbol shown on the right-hand side of an initialization
    or assignment implies address-of. These two declarations illustrate how a reference
    is defined versus its underlying implementation.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解实现，让我们考虑一个样本引用声明：`int &intVar = x;`。从实现的角度来看，前一个变量声明实际上被声明为`int *const intVar
    = &x;`。请注意，初始化左侧显示的`&`符号具有引用的含义，而初始化或赋值右侧显示的`&`符号意味着取地址。这两个声明说明了引用的定义与其底层实现。
- en: Next, let's understand in which situations we cannot use references.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解在哪些情况下不能使用引用。
- en: Understanding when we must use pointers instead of references
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解何时必须使用指针而不是引用
- en: Based on the underlying implementation of references (as `const` pointers),
    most of the restrictions for reference usage make sense. For example, references
    to references are not allowed; each level of indirection would need to be initialized
    upfront and that often takes multiple steps, such as when using pointers. Arrays
    of references are also not permitted (each element would need to be initialized
    immediately); nonetheless, arrays of pointers are always an option. Also, pointers
    to references are not permitted; however, references to pointers are permitted
    (as are pointers to pointers).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据引用的底层实现（作为`const`指针），大多数引用使用的限制都是有道理的。例如，不允许引用引用；每个间接级别都需要提前初始化，这通常需要多个步骤，例如使用指针。也不允许引用数组（每个元素都需要立即初始化）；尽管如此，指针数组始终是一个选择。还不允许指向引用的指针；但是，允许引用指针（以及指向指针的指针）。
- en: 'Let''s take a look at the mechanics of an interesting allowable reference case
    that we have not yet explored:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个有趣的允许引用的机制，这是我们尚未探讨的。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex7.cpp)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex7.cpp)'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we declare `int *ptr;` and then allocate the memory for `ptr`
    (consolidated on one line). We then assign a value of `20` to `*p`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明`int *ptr;`，然后为`ptr`分配内存（在一行上合并）。然后我们给`*p`赋值为`20`。
- en: 'Next, we declare `int *&refPtr = ptr;`, which is a reference to a pointer of
    type `int`. It helps to read the declaration right to left. As such, we use `ptr`
    to initialize `refPtr`, which is a reference to a pointer to an `int`. In this
    case, the two types match: `ptr` is a pointer to an `int`, so that `refPtr` must
    also then reference a pointer to an `int`. We then print out both the value of
    `*ptr` and `*refPtr` and can see that they are the same.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`int *&refPtr = ptr;`，这是一个指向`int`类型指针的引用。最好从右向左阅读声明。因此，我们使用`ptr`来初始化`refPtr`，它是指向`int`的指针的引用。在这种情况下，两种类型匹配：`ptr`是指向`int`的指针，因此`refPtr`必须引用指向`int`的指针。然后我们打印出`*ptr`和`*refPtr`的值，可以看到它们是相同的。
- en: 'Here is the output to accompany our program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们程序的输出：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this example, we have seen yet another interesting use of references. We
    also understand the restrictions placed upon using references, all of which are
    driven by their underlying implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们看到了另一个有趣的引用用法。我们也了解了使用引用所施加的限制，所有这些限制都是由它们的基础实现驱动的。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned numerous aspects of C++ references. We have
    taken the time to understand reference basics, such as declaring and initializing
    reference variables to existing objects, as well as how to access reference components
    for basic and user defined types.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C++引用的许多方面。我们花时间了解了引用的基础知识，比如声明和初始化引用变量到现有对象，以及如何访问基本类型和用户定义类型的引用组件。
- en: We have seen how to utilize references in a meaningful fashion with functions,
    both as input parameters and as a return value. We have also seen when it is reasonable
    to apply the `const` qualifier to references, as well as see how this concept
    can be combined with parameters and return values from functions. Lastly, we have
    seen the underlying implementation of references. This has helped explain some
    of the restrictions references encompass, as well as helping us to understand
    which cases of indirect addressing will require the use of pointers instead of
    references.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在函数中有意义地利用引用，既作为输入参数，又作为返回值。我们还看到了何时合理地对引用应用`const`限定符，以及如何将这个概念与函数的参数和返回值相结合。最后，我们看到了引用的基础实现。这有助于解释引用所包含的一些限制，以及帮助我们理解间接寻址的哪些情况将需要使用指针而不是引用。
- en: As with pointers, all of the skills using references from this chapter will
    be used freely in the upcoming chapters. C++ allows programmers to have a more
    convenient notation for indirect addressing using references; however, programmers
    are expected to utilize either for indirect addressing with relative ease.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针一样，本章中使用引用的所有技能将在接下来的章节中自由使用。C++允许程序员使用引用来更方便地进行间接寻址的表示；然而，程序员预计可以相对轻松地利用指针进行间接寻址。
- en: Finally, you are now ready to move forward to [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*, in which we begin the object-oriented features
    of C++. This is what we have been waiting for; let's get started!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您现在可以继续前往[*第5章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199)，*详细探讨类*，在这一章中，我们将开始C++的面向对象特性。这就是我们一直在等待的；让我们开始吧！
- en: Questions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Modify and augment your C++ program from [*Chapter 3*](B15702_03_Final_NM_ePub.xhtml#_idTextAnchor112),
    *Indirect Addressing – Pointers*, *Exercise 1*, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改并增强您的C++程序，从[*第3章*](B15702_03_Final_NM_ePub.xhtml#_idTextAnchor112)，*间接寻址-指针*，*练习1*，如下所示：
- en: a. Overload your `ReadData()` function with a version that accepts a `Student
    &` parameter to allow `firstName`, `lastName`, `currentCourseEnrolled`, and `gpa`
    to be entered from the keyboard within the function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: a. 重载您的`ReadData()`函数，使用接受`Student &`参数的版本，以允许从键盘在函数内输入`firstName`、`lastName`、`currentCourseEnrolled`和`gpa`。
- en: b. Replace the `Print()` function, which takes a `Student` from your previous
    solution, to instead take a `const` `Student &` as a parameter for `Print()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b. 替换您先前解决方案中的`Print()`函数，该函数取一个`Student`，而是取一个`const``Student &`作为`Print()`的参数。
- en: c. Create variables of type `Student` and of type `Student *` in `main()`. Now,
    call the various versions of `ReadData()` and `Print()`. Do the pointer variables
    necessarily need to call the versions of these functions that accept pointers,
    and do the non-pointer variables necessarily need to call the versions of these
    functions that accept references? Why or why not?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在`main()`中创建`Student`类型和`Student *`类型的变量。现在，调用各种版本的`ReadData()`和`Print()`。指针变量是否必须调用接受指针的这些函数的版本，非指针变量是否必须调用接受引用的这些函数的版本？为什么？
