- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Refactoring Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构工具
- en: Clang is renowned for its ability to provide suggestions for code fixes. For
    instance, if you miss a semicolon, Clang will suggest that you insert it. The
    ability to modify source code goes beyond the compilation process and is widely
    used in various tools for code modifications, particularly in refactoring tools.
    The ability to offer fixes is a powerful feature that extends the capabilities
    of a linter framework, such as Clang-Tidy, which not only detects issues but also
    provides suggestions for fixing them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Clang因其提供代码修复建议的能力而闻名。例如，如果你遗漏了分号，Clang会建议你插入它。修改源代码的能力不仅限于编译过程，而且在各种代码修改工具中得到了广泛应用，尤其是在重构工具中。提供修复的能力是扩展lint框架功能的一个强大特性，例如Clang-Tidy，它不仅能够检测问题，还能提供修复建议。
- en: In this chapter, we will explore refactoring tools. We will begin by discussing
    the fundamental classes used for code modification, notably `clang``::``Rewriter`.
    We will use Rewriter to build a custom refactoring tool that changes method names
    within a class. Later in the chapter, we will reimplement the tool using Clang-Tidy
    and delve into `clang``::``FixItHint`, a component of the Clang Diagnostics subsystem
    that is employed by both Clang-Tidy and the Clang compiler to modify source code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨重构工具。我们将从讨论用于代码修改的基本类开始，特别是 `clang``::``Rewriter`。我们将使用Rewriter构建一个自定义的重构工具，该工具可以更改类中的方法名。在章节的后面部分，我们将使用Clang-Tidy重新实现该工具，并深入研究
    `clang``::``FixItHint`，这是Clang诊断子系统的一个组件，Clang-Tidy和Clang编译器都使用它来修改源代码。
- en: To conclude the chapter, we will introduce a crucial Clang tool called Clang-Format.
    This tool is widely employed for code formatting. We will explore the functionality
    offered by the tool, delve into its design, and understand the rationale behind
    specific design decisions made during its development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们将介绍一个关键的Clang工具，称为Clang-Format。这个工具被广泛用于代码格式化。我们将探讨该工具提供的功能，深入研究其设计，并理解其开发过程中做出的具体设计决策背后的原因。
- en: 'The chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: How to create a custom Clang tool for code refactoring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建自定义的Clang代码重构工具
- en: How to integrate code modifications into a Clang-Tidy check
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将代码修改集成到Clang-Tidy检查中
- en: An overview of Clang-Format and how it can be integrated with Clang-Tidy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang-Format概述及其如何与Clang-Tidy集成
- en: 7.1 Technical requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 技术要求
- en: 'The source code for this chapter is located in the `chapter7` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于本书GitHub仓库的 `chapter7` 文件夹中：[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7)。
- en: 7.2 Custom code modification tool
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 自定义代码修改工具
- en: We will create a Clang tool that will help us to rename methods for a class
    that is used for unit testing. We will start with a description for the `clang``::``Rewriter`
    class – the basic class that is used for code modifications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Clang工具，帮助我们为用于单元测试的类重命名方法。我们将从对 `clang``::``Rewriter` 类的描述开始——这是用于代码修改的基本类。
- en: 7.2.1 Code modification support at Clang
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 Clang中的代码修改支持
- en: '`clang``::``Rewriter` is a Clang library class that facilitates source code
    rewriting operations within a translation unit. It provides methods for inserting,
    removing, and replacing code within the**Abstract Syntax Tree** **(AST)** of the
    source code. Developers can use `clang``::``Rewriter` for complex code modifications,
    such as restructuring or generating new code constructs. It can be applied for
    both code generation and code refactoring tasks, making it versatile for various
    code transformation purposes.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang``::``Rewriter` 是一个Clang库类，它简化了在翻译单元内进行源代码重写操作。它提供了在源代码的**抽象语法树**（AST）中插入、删除和替换代码的方法。开发者可以使用
    `clang``::``Rewriter` 进行复杂的代码修改，例如重构或生成新的代码结构。它可以应用于代码生成和代码重构任务，使其在多种代码转换目的上具有多功能性。'
- en: The class has several methods for text insertion; for instance, `clang``::``Rewriter`
    `::``InsertText` inserts the text at the specified source location, and `clang`
    `::``SourceLocation` is used to specify the exact location at the buffer, see
    [*Section** 4.4.1*](B19722_04.xhtml#x1-790001)*,* *SourceManager and SourceLocation*.
    In addition to the text insertion, you can also remove text with `clang``::``Rewriter``::``RemoveText`
    or replace text with a new one using `clang``::``Rewriter``::``ReplaceText`. The
    last two use source range (`clang``::``SourceRange`) to specify the positions
    at the text to be removed or replaced.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有几个用于文本插入的方法；例如，`clang``::``Rewriter` `::``InsertText`在指定的源位置插入文本，而`clang`
    `::``SourceLocation`用于指定缓冲区中的确切位置，见[*第4.4.1节*](B19722_04.xhtml#x1-790001)*，*源管理器和源位置*。除了文本插入外，您还可以使用`clang``::``Rewriter``::``RemoveText`删除文本，或使用`clang``::``Rewriter``::``ReplaceText`用新文本替换文本。后两种使用源范围（`clang``::``SourceRange`）来指定要删除或替换的文本位置。
- en: '`clang``::``Rewriter` uses `clang``::``SourceManager`, as explained in [*Section** 4.4.1*](B19722_04.xhtml#x1-790001)*,
    SourceManager and SourceLocation*, to access the source code that needs to be
    modified. Let’s look at how Rewriter can be used in a real project.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang``::``Rewriter`使用`clang``::``SourceManager`，如[*第4.4.1节*](B19722_04.xhtml#x1-790001)*，源管理器和源位置*中所述，来访问需要修改的源代码。让我们看看Rewriter如何在实际项目中使用。'
- en: 7.2.2 Test class
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 测试类
- en: Suppose we have a class that is used for tests. The class name starts with the
    ”Test” prefix (for instance, `TestClass`), but there aren’t any ’test_’ prefixes
    for public methods of the class. For instance, the class has a public method with
    the name ’pos’ (`TestClass``::``pos`) instead of ’test_pos’ (`TestClass``::``test_pos``()`).
    We want to create a tool that will add such a prefix for the class methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个用于测试的类。类的名称以“Test”前缀开头（例如，`TestClass`），但类的公共方法没有“test_”前缀。例如，该类有一个名为’pos’的公共方法（`TestClass``::``pos`），而不是’test_pos’（`TestClass``::``test_pos``()）。我们想要创建一个工具，为类方法添加这样的前缀。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Original code**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始代码**'
- en: '**[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE1]'
- en: '**Modified code**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改后的代码**'
- en: '****Figure 7.1**: Code transformations for TestClass'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '****图7.1**: TestClass的代码转换'
- en: Thus, we want the method `TestClass``::``pos` (see [Figure 7.1](#x1-136020r1))
    to be replaced with `TestClass``::``test_pos` at the class declaration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望将方法`TestClass``::``pos`（见[图7.1](#x1-136020r1)）在类声明中替换为`TestClass``::``test_pos`。
- en: 'If we have a code where we make a call to the method, the following replacement
    should be made:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有调用方法的代码，应进行以下替换：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Original code**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始代码**'
- en: '**[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE3]'
- en: '**Modified code**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改后的代码**'
- en: '****Figure 7.2**: Code transformations for TestClass’s method calls'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '****图7.2**: TestClass的方法调用代码转换'
- en: The tool should also ignore all public methods with the required modifications
    already applied, either manually or automatically. In other words, if a method
    already has the required ’test_’ prefix, the tool should not modify it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工具还应忽略所有已手动或自动应用了所需修改的公共方法。换句话说，如果一个方法已经有了所需的’test_’前缀，则工具不应修改它。
- en: We are going to create a Clang tool called ’methodrename’, which will perform
    all the required code modifications. This tool will utilize the recursive AST
    visitor discussed in [*Section** 3.4*](B19722_03.xhtml#x1-620004)*, Recursive
    AST visitor*. The most crucial aspect is the implementation of the `Visitor` class.
    Let’s examine it in detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为“methodrename”的Clang工具，该工具将执行所有必要的代码修改。这个工具将利用在第[*第3.4节*](B19722_03.xhtml#x1-620004)*，递归AST访问者*中讨论的递归AST访问者。最关键的部分是实现`Visitor`类。让我们详细地检查它。
- en: 7.2.3 Visitor class implementation
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 访问者类实现
- en: 'Our `Visitor` class should handle specific processing for the following AST
    nodes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Visitor`类应该处理以下AST节点中的特定处理：
- en: '`clang``::``CXXRecordDecl`: This involves processing C++ class definitions
    with names starting with the ”Test” prefix. For such classes, all user-defined
    public methods should be prefixed with ”test_”.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang``::``CXXRecordDecl`：这涉及到处理以“Test”前缀开头的C++类定义。对于此类，所有用户定义的公共方法都应该以“test_”为前缀。'
- en: '`clang``::``CXXMemberCallExpr`: Additionally, we need to identify all instances
    where the modified method is used and make the corresponding changes following
    the method’s renaming in the class definition.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang``::``CXXMemberCallExpr`：此外，我们还需要识别所有修改后方法的使用实例，并在类定义中方法重命名后进行相应的更改。'
- en: 'The processing for `clang``::``CXXRecordDecl` nodes will be as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`clang``::``CXXRecordDecl`节点的处理如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Figure 7.3**: CXXRecordDecl visitor implementation'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.3**：CXXRecordDecl 访问者实现'
- en: '*Lines 11-16* in [Figure 7.3](#x1-137017r3) represent the conditions that we
    require from the examined node. For example, the corresponding class name should
    start with the ”Test” prefix (see *Lines 15-16* in [Figure 7.3](#x1-137017r3)),
    where we utilize the `starts_with``()` method of the `llvm``::``StringRef` class.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.3](#x1-137017r3) 中的 *第 11-16 行* 表示我们从检查的节点中需要的条件。例如，相应的类名应以 "Test" 前缀开头（参见
    [图 7.3](#x1-137017r3) 中的 *第 15-16 行*），在那里我们使用了 `llvm::StringRef` 类的 `starts_with()`
    方法。'
- en: After verifying these conditions, we proceed to examine the methods within the
    found class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证这些条件之后，我们继续检查找到的类中的方法。
- en: 'The verification process is implemented in the `Visitor``::``processMethod`
    method, and its implementation is presented in the following code fragment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 验证过程在 `Visitor::processMethod` 方法中实现，其实现如下代码片段：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 7.4**: Implementation of `processMethod`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.4**：`processMethod` 的实现'
- en: '*Lines 46-51* in [Figure 7.4](#x1-137040r4) contain the checks for the required
    conditions. For instance, in *Lines 46-47*, we verify that the method is public.
    *Lines 48-49* are used to exclude constructors from processing, and *Lines 50-51*
    serve to exclude methods that already have the required prefix.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.4](#x1-137040r4) 中的 *第 46-51 行* 包含了对所需条件的检查。例如，在第 *46-47 行*，我们验证方法是否为公共的。*第
    48-49 行* 用于排除构造函数的处理，而 *第 50-51 行* 用于排除已经具有所需前缀的方法。'
- en: 'The main replacement logic is implemented in *Lines 53-58*. Particularly, in
    *Lines* *56-57*, we create a special `clang``::``tooling``::``Replacement` object,
    which serves as a wrapper for required code modifications. The object’s parameters
    are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的替换逻辑实现在 *第 53-58 行*。特别是，在第 *56-57 行*，我们创建了一个特殊的 `clang::tooling::Replacement`
    对象，它作为所需代码修改的包装器。该对象的参数如下：
- en: '`clang``::``SourceManager`: We obtain the source manager from `clang``::``ASTContext`
    at *Line 55*.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clang::SourceManager`：我们在 *第 55 行* 从 `clang::ASTContext` 获取源管理器。'
- en: '`clang``::``SourceLocation`: The source location specifies the starting position
    for replacement. The position is passed as the second parameter of our `processMethod`
    method, as seen in *Line 45*.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clang::SourceLocation`：指定替换的起始位置。位置作为我们 `processMethod` 方法的第二个参数传递，如 *第 45
    行* 所见。'
- en: '`unsigned`: The length of the replaced text.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unsigned`：替换文本的长度。'
- en: '`clang``::``StringRef`: The replacement text, which we create at *Line* *54*.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clang::StringRef`：替换文本，我们在 *第 54 行* 创建。'
- en: 'We store the replacement in the `Replaces` object, a private member of our
    Visitor class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换存储在 `Replaces` 对象中，它是我们访问者类的私有成员：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is a special getter to access the object outside the Visitor class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的获取器可以用于在访问者类外部访问对象：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We log the action at *Lines 59-60*, using `LogMessage` as the prefix for the
    log message. Different log messages are used for different AST nodes; for instance,
    we use ”Renamed method” (see [Figure 7.3](#x1-137017r3), *Line 19*) for `clang``::``CXXRecordDecl`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 *59-60 行使用 `LogMessage` 作为日志消息的前缀记录操作。对于不同的 AST 节点，使用不同的日志消息；例如，对于 `clang::CXXRecordDecl`，我们使用
    "Renamed method"（参见 [图 7.3](#x1-137017r3)，*第 19 行*）。
- en: The log message will be different for the method call. The corresponding processing
    is shown in the following figure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用将会有不同的日志消息。相应的处理在下面的图中展示。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Figure 7.5**: CXXMemberCallExpr visitor implementation'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.5**：CXXMemberCallExpr 访问者实现'
- en: We verify that the class name, which holds the test method, starts with the
    ’Test’ prefix at *Lines 27-29*. The replacement source location is obtained at
    *Line 30*. At *Line 31*, we call our `processMethod` function to process the found
    method, passing the ”Renamed method call” as the log message to the call.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 *27-29 行验证包含测试方法类的类名以 "Test" 前缀开头。替换源位置在第 *30 行获得。在第 *31 行，我们调用我们的 `processMethod`
    函数来处理找到的方法，将 "Renamed method call" 作为日志消息传递给调用。
- en: The `Visitor` is initialized in the `Consumer` class, which will be our next
    goal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visitor` 在 `Consumer` 类中初始化，这将是我们的下一个目标。'
- en: 7.2.4 Consumer class implementation
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 Consumer 类实现
- en: 'The `Consumer` class initializes the Visitor and starts AST traversal in the
    `HandleTranslationUnit` method. The class can be written as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer` 类在 `HandleTranslationUnit` 方法中初始化访问者并开始 AST 遍历。该类可以编写如下：'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Figure 7.6**: Consumer class implementation'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.6**：Consumer 类实现'
- en: We initialize the Visitor and begin traversal at *Lines 9-10* (see [Figure 7.6](#x1-138025r6)).
    The Rewriter is created at *Line 13*, and replacements are applied at *Lines 14-19*.
    Finally, the result is stored in the original file at *Lines 22-24*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化访问者，并从*第9-10行*开始遍历（见[图7.6](#x1-138025r6)）。重写器在第13行创建，替换在第14-19行应用。最后，结果在第22-24行存储在原始文件中。
- en: The Visitor and Consumer classes are wrapped within the `clangbook``::``methodrename`
    namespace. The Consumer instance is created in the FrontendAction class. This
    class’s implementation mirrors that of the `RecursiveVisitor` and `DeclVisitor`,
    as detailed in [Figure 3.8](B19722_03.xhtml#x1-60077r8). The only difference is
    the use of the `clangbook``::``methodrename` namespace for the new tool.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者和消费者类被封装在`clangbook::methodrename`命名空间中。消费者实例在FrontendAction类中创建。这个类的实现与[图3.8](B19722_03.xhtml#x1-60077r8)中详细描述的`RecursiveVisitor`和`DeclVisitor`的实现类似。唯一的区别是，新工具使用了`clangbook::methodrename`命名空间。
- en: 7.2.5 Build configuration and main function
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.5 构建配置和主函数
- en: 'The `main` function for our tool is similar to the recursive visitor one defined
    in [Figure 3.21](B19722_03.xhtml#x1-62057r21):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工具的`main`函数与[图3.21](B19722_03.xhtml#x1-62057r21)中定义的递归访问者类似：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 7.7**: The main function for the ’methodrename’ test tool'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.7**：''methodrename''测试工具的主函数'
- en: As you can see, we changed only the namespace name for our custom frontend action
    at *Line 23*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只在第23行更改了自定义前端动作的命名空间名称。
- en: 'The build configuration is specified as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构建配置如下：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Figure 7.8**: Build configuration for ’methodrename’ test tool'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.8**：''methodrename''测试工具的构建配置'
- en: 'The most notable changes, compared to the code from [Figure 3.20](B19722_03.xhtml#x1-62028r20),
    are at *Lines* *23 and 24*, where we added two new libraries to support code modifications:
    `clangToolingCore` and `clangRewrite` . Other changes include the new name for
    the tool (*Line 2*) and the source file that contains the main function (*Line*
    *14*).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与[图3.20](B19722_03.xhtml#x1-62028r20)中的代码相比，最显著的变化在第23和24行，我们添加了两个新的库来支持代码修改：`clangToolingCore`和`clangRewrite`。其他更改还包括工具的新名称（第2行）和包含主函数的源文件（第14行）。
- en: As soon as we finish with the code, it’s time to build and run our tool.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成代码，就是时候构建和运行我们的工具了。
- en: 7.2.6 Running the code modification tool
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.6 运行代码修改工具
- en: 'The program can be compiled using the same sequence of commands as we used
    previously in [*Section** 3.3*](B19722_03.xhtml#x1-590003)*, AST traversal*, see
    [Figure 3.11](B19722_03.xhtml#x1-60132r11):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以使用与我们在[*第3.3节*](B19722_03.xhtml#x1-590003)*，AST遍历*中之前使用的相同命令序列进行编译，见[图3.11](B19722_03.xhtml#x1-60132r11)：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Figure 7.9**: Configure and build commands for ’methodrename’ tool'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.9**：''methodrename''工具的配置和构建命令'
- en: 'We can run the create tool on the following test file (`TestClass.cpp` ):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下测试文件（`TestClass.cpp`）上运行创建工具：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Figure 7.10**: Original TestClass.cpp'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.10**：原始TestClass.cpp'
- en: 'We can run the tool as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式运行工具：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Figure 7.11**: Running methodrename Clang Tool on TestClass.cpp'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.11**：在TestClass.cpp上运行methodrename Clang Tool'
- en: 'As we can see, the method `TestClass``::``pos` was renamed to `TestClass``::``test_pos`.
    The method call was also updated, as shown in the following figure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，方法`TestClass::pos`被重命名为`TestClass::test_pos`。方法调用也如以下图所示进行了更新：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Figure 7.12**: Modified TestClass.cpp'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.12**：修改后的TestClass.cpp'
- en: The provided example demonstrates how Clang can assist in creating refactoring
    tools. The created Clang Tool uses a recursive visitor to set up the required
    code transformation. Another possible option is to use Clang-Tidy, which we investigated
    earlier in [*Chapter** 5*](B19722_05.xhtml#x1-990005)*, Clang-Tidy Linter Framework*.
    Let’s examine this option in more detail.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例演示了Clang如何协助创建重构工具。创建的Clang Tool使用递归访问者来设置所需的代码转换。另一个可能的选项是使用Clang-Tidy，我们之前在[*第5章*](B19722_05.xhtml#x1-990005)*，Clang-Tidy
    Linter Framework*中进行了调查。让我们更详细地考察这个选项。
- en: 7.3 Clang-Tidy as a code modification tool
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 Clang-Tidy作为代码修改工具
- en: We plan to investigate `FixItHint`, which is a part of the Clang Diagnostics
    subsystem (see [*Section** 4.4.2*](B19722_04.xhtml#x1-800002)*, Diagnostics support*).
    `FixItHint` can be integrated with `clang``::``Rewriter` and `clang``::``tooling``::``Replacement`
    explored previously, providing advanced diagnostics that are used in powerful
    tools such as Clang-Tidy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划研究`FixItHint`，它是Clang诊断子系统的一部分（参见[*第4.4.2节*](B19722_04.xhtml#x1-800002)*，诊断支持*）。`FixItHint`可以与之前探索过的`clang::Rewriter`和`clang::tooling::Replacement`集成，提供用于Clang-Tidy等强大工具的高级诊断。
- en: 7.3.1 FixItHint
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 FixItHint
- en: '`clang``::``FixItHint` is a class in the Clang compiler that significantly
    enhances its diagnostic capabilities. Its primary role is to provide automated
    suggestions for correcting code errors or issues that the compiler detects. These
    suggestions, known as ”fix-its,” are a part of Clang’s diagnostic messages and
    are intended to guide developers in resolving identified issues in their code.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang::FixItHint`是Clang编译器中的一个类，它显著增强了其诊断能力。其主要作用是提供编译器检测到的代码错误或问题的自动修正建议。这些建议被称为“修复”，是Clang诊断消息的一部分，旨在指导开发者在他们的代码中解决已识别的问题。'
- en: When Clang encounters a coding error, warning, or stylistic issue, it generates
    a `FixItHint`. This hint contains specific recommendations for changes in the
    source code. For instance, it may suggest replacing a snippet of text with a corrected
    version or inserting or removing code at a particular location.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当Clang遇到编码错误、警告或风格问题时，它会生成一个`FixItHint`。这个提示包含对源代码更改的具体建议。例如，它可能建议用修正后的版本替换文本片段或在特定位置插入或删除代码。
- en: 'For example, consider the following source code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下源代码：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Figure 7.13**: Test file foo.cpp'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.13**: 测试文件foo.cpp'
- en: 'If we run a compilation for the file, we will get the following error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对文件进行编译，我们将得到以下错误：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Figure 7.14**: Compilation error generated in foo.cpp'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.14**: 在foo.cpp中生成的编译错误'
- en: As you can see, the compiler suggests adding the `static` keyword at *Line 2*
    for the program shown in [Figure 7.13](#x1-142007r13).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器建议为[图7.13](#x1-142007r13)中显示的程序在*第2行*添加`static`关键字。
- en: The error is processed by Clang using the FixItHint object, as shown in [Figure 7.15](#x1-142022r15).
    As seen in [Figure 7.15](#x1-142022r15), when Clang detects an issue in the source
    code and generates a diagnostic, it can also produce a `clang``::``FixItHint`
    that suggests how to fix the issue. The hint is later processed by the Clang diagnostics
    subsystem and displayed to the user.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 错误由Clang使用FixItHint对象处理，如图7.15所示。如图7.15所示，当Clang在源代码中检测到问题并生成诊断时，它还可以生成一个`clang::FixItHint`，建议如何修复问题。提示随后由Clang诊断子系统处理并显示给用户。
- en: It’s important to highlight that the hint can also be converted into a `Replacement`
    object, which represents the exact text change needed. For example, Clang-Tidy
    uses the `Replacement` object as temporary storage for information from `FixItHint`
    in its `DiagnosticConsumer` class implementation, allowing the FixItHint to be
    converted into a `Replacement` object that represents the exact text change needed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，提示也可以转换为`Replacement`对象，它表示所需的精确文本更改。例如，Clang-Tidy使用`Replacement`对象作为其`DiagnosticConsumer`类实现中从`FixItHint`获取信息的临时存储，允许将FixItHint转换为表示所需精确文本更改的`Replacement`对象。
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Figure 7.15**: Code fragment from clang/lib/AST/ExprConstant.cpp'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.15**: 来自clang/lib/AST/ExprConstant.cpp的代码片段'
- en: Overall, `clang::FixItHint` enhances the user-friendliness and utility of Clang,
    providing developers with practical tools for improving code quality and resolving
    issues efficiently. Its integration into Clang’s diagnostic system exemplifies
    the compiler’s emphasis on not only pinpointing code issues but also aiding in
    their resolution. We are going to utilize this feature in a Clang-Tidy check that
    will rename methods in a test class and convert the code shown in [Figure 7.10](#x1-140016r10)
    to that in [Figure 7.12](#x1-140033r12).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`clang::FixItHint`增强了Clang的用户友好性和实用性，为开发者提供了提高代码质量和有效解决问题的实用工具。它集成到Clang的诊断系统中，体现了编译器不仅关注定位代码问题，还帮助解决这些问题的重点。我们计划在Clang-Tidy检查中使用此功能，该检查将重命名测试类中的方法，并将[图7.10](#x1-140016r10)中的代码转换为[图7.12](#x1-140033r12)中的代码。
- en: 7.3.2 Creating project skeleton
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 创建项目骨架
- en: Let’s create the project skeleton for our Clang-Tidy check. We will name our
    check ”methodrename” and it will be a part of ”misc” set of Clang-Tidy checks.
    We will use the command from [Section 5.4.1](B19722_05.xhtml#x1-1100001)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的Clang-Tidy检查创建项目骨架。我们将我们的检查命名为”methodrename”，它将是”misc”集合的一部分Clang-Tidy检查。我们将使用[第5.4.1节](B19722_05.xhtml#x1-1100001)中的命令。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Figure 7.16**: Creating a skeleton for the misc-methodrename check'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.16**：为misc-methodrename检查创建骨架'
- en: 'The command from [Figure 7.16](#x1-143002r16) should be run from the root of
    the cloned LLVM project. We specified two parameters for the `add``_new``_check.py`
    script: `misc` – the set of checks that will contain our new check, and `methodrename`
    – the name of our check.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图7.16](#x1-143002r16)中的命令应该在克隆的LLVM项目的根目录下运行。我们为`add_new_check.py`脚本指定了两个参数：`misc`
    – 将包含我们的新检查的检查集，和`methodrename` – 我们检查的名称。
- en: 'The command will produce the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将产生以下输出：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Figure 7.17**: Artefacts created for misc-methodrename check'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.17**：为misc-methodrename检查创建的工件'
- en: 'We have to modify at least two generated files in the `./clang-tools-extra/clang-tidy`
    `/misc` folder:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改`./clang-tools-extra/clang-tidy` `/misc`文件夹中的至少两个生成的文件：
- en: '`MethodrenameCheck.h` : This is the header file for our check. Here, we want
    to add an additional private method `processMethod` for checking the method’s
    properties and displaying diagnostics.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MethodrenameCheck.h`：这是我们的检查的头文件。在这里，我们想要添加一个额外的私有方法`processMethod`，用于检查方法属性并显示诊断信息。'
- en: '`MethodrenameCheck.cpp` : This file contains the processing logic, and we need
    to implement three methods: `registerMatchers`, `check`, and the newly added private
    method `processMethod`.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MethodrenameCheck.cpp`：此文件包含处理逻辑，我们需要实现三个方法：`registerMatchers`、`check`和新增的私有方法`processMethod`。'
- en: 7.3.3 Check implementation
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 检查实现
- en: 'We will start with modifications to the header file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从修改头文件开始：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 7.18**: MethodrenameCheck.h modifications'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.18**：MethodrenameCheck.h修改'
- en: The added private method `MethodrenameCheck``::``processMethod` has the same
    parameters as the method introduced earlier in our Clang Tool ’methodrename’,
    as seen in [Figure 7.4](#x1-137040r4).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的私有方法`MethodrenameCheck::processMethod`具有与我们在Clang Tool ’methodrename’中较早引入的方法相同的参数，如[图7.4](#x1-137040r4)所示。
- en: 'We start the implementation with the `MethodrenameCheck``::``registerMatchers`
    method of our check as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的检查的`MethodrenameCheck::registerMatchers`方法开始实现，如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Figure 7.19**: Implementation of registerMatchers'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.19**：registerMatchers实现'
- en: '*Lines 30 and 31* register two matchers. The first one is for method declarations
    (bound to the ”method” identifier), and the second one is for method calls (bound
    to the ”call” identifier).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*第30行和第31行*注册了两个匹配器。第一个是用于方法声明（绑定到”method”标识符），第二个是用于方法调用（绑定到”call”标识符）。'
- en: Here, we use a **Domain Specific Language (DSL)** defined in [*Section** 3.5*](B19722_03.xhtml#x1-630005)*,*
    *AST matchers*. The `ClassMatcher` specifies that our method declaration has to
    be declared within a class with a name starting with the ”Test” prefix.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用在[*第3.5节*](B19722_03.xhtml#x1-630005)*中定义的**领域特定语言（DSL）*，即*AST匹配器*。`ClassMatcher`指定我们的方法声明必须在以“Test”前缀开头的类内部声明。
- en: The method declaration matcher (`MethodMatcher`) is defined at *Line 28*. It
    must be declared within the class specified by `ClassMatcher` and should be a
    test method (details about the `isNotTestMethod` matcher will be described below).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 方法声明匹配器（`MethodMatcher`）定义在*第28行*。它必须在由`ClassMatcher`指定的类内部声明，并且应该是一个测试方法（关于`isNotTestMethod`匹配器的详细信息将在下面描述）。
- en: The last matcher, `CallMatcher`, is defined at *Line 29* and specifies that
    it must be a call to a method that satisfies the conditions of `MethodMatcher`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个匹配器，`CallMatcher`，定义在*第29行*，并指定它必须是对满足`MethodMatcher`条件的方法的调用。
- en: 'The `isNotTestMethod` matcher is an ad-hoc matcher that is used to check our
    specific conditions. We can define our own matchers using `AST_MATCHER` and related
    macros. The implementation for it can be found here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNotTestMethod`匹配器是一个专门用于检查我们特定条件的匹配器。我们可以使用`AST_MATCHER`和相关宏来定义自己的匹配器。它的实现可以在这里找到：'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Figure 7.20**: isNotTestMethod matcher implementation'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.20**：`isNotTestMethod`匹配器实现'
- en: The macro has two parameters. The first one specifies the AST node we want to
    check, which is `clang``::``CXXMethodDecl` in our case. The second parameter is
    the matcher name that we want to use for the user-defined matcher, which is `isNotTestMethod`
    in our case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 宏有两个参数。第一个参数指定我们想要检查的AST节点，在我们的情况下是`clang`::`CXXMethodDecl`。第二个参数是我们想要用于用户定义匹配器的匹配器名称，在我们的情况下是`isNotTestMethod`。
- en: The AST node can be accessed as a `Node` variable at the macro body. The macro
    should return `true` if the Node matches the required conditions. We use the same
    conditions we used for our ’methodrename’ Clang Tool in [Figure 7.4](#x1-137040r4)
    (*Lines* *46-51*).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AST节点可以在宏体中以`Node`变量访问。宏应该返回`true`如果节点符合所需条件。我们使用与我们在[图7.4](#x1-137040r4)中使用的相同条件，用于我们的`methodrename`
    Clang工具（*行* *46-51*）。
- en: 'The `MethodrenameCheck``::``check` is the main method for our check and can
    be implemented as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MethodrenameCheck`::`check`是我们检查的主要方法，可以如下实现：'
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Figure 7.21**: check implementation'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.21**：检查实现'
- en: The code has two blocks. The first one (*Lines 35-37*) processes method declarations,
    and the last one (*Lines 39-42*) processes method calls. Both call `MethodrenameCheck`
    `::``processMethod` to display diagnostics and create the required code modifications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有两个块。第一个块（*行35-37*）处理方法声明，最后一个块（*行39-42*）处理方法调用。两者都调用`MethodrenameCheck` `::`
    `processMethod`来显示诊断并创建所需的代码修改。
- en: Let’s examine how it’s implemented and how `clang``::``FixItHint` is used.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它的实现以及如何使用`clang`::`FixItHint`。
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Figure 7.22**: processMethod implementation'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.22**：processMethod实现'
- en: We print diagnostics about the detected issue at *Line 49*. *Lines 50-51* print
    an informational message about the suggested code modifications and create the
    corresponding code replacement at *Line 51*. To insert text, we use `clang``::``FixItHint``::``CreateInsertion`.
    We also display the insertion as a note for our primary warning.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*行49*打印关于检测到的问题的诊断信息。*行50-51*打印有关建议的代码修改的信息性消息，并在*行51*创建相应的代码替换。要插入文本，我们使用`clang`::`FixItHint`::`CreateInsertion`。我们还以注释的形式显示插入到主要警告中。
- en: As soon as all the required changes are applied to the generated skeleton, it’s
    time to build and run our check on a test file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有必要的更改都应用到生成的骨架中，就是时候在测试文件上构建和运行我们的检查了。
- en: 7.3.4 Build and run the check
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 构建和运行检查
- en: 'We assume that build configuration from [Figure 1.12](B19722_01.xhtml#x1-30003r12)
    was used. Thus, we have to run the following command to build our check:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设使用了[图1.12](B19722_01.xhtml#x1-30003r12)中的构建配置。因此，我们必须运行以下命令来构建我们的检查：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can install it to the `install` folder with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将其安装到`install`文件夹中：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can run our check as follows on the `TestClass` from [Figure 7.10](#x1-140016r10):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`TestClass`上如下运行我们的检查，如[图7.10](#x1-140016r10)所示：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Figure 7.23**: Clang-Tidy misc-methodrename check run on the test file TestClass.cpp'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.23**：在测试文件TestClass.cpp上运行的Clang-Tidy misc-methodrename检查'
- en: 'The command will produce the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将产生以下输出：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Figure 7.24**: Warning generated for TestClass.cpp by misc-methodrename check'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.24**：由misc-methodrename检查为TestClass.cpp生成的警告'
- en: 'As we can see, the check correctly detected two places where the method name
    has to be changed and created replacements. The command from [Figure 7.23](#x1-145003r23)
    does not modify the original source file. We have to specify an additional argument
    `-fix-notes` to apply the insertions specified as notes to the original warnings.
    The required command will look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，检查正确地检测到两个需要更改方法名的地方并创建了替换。来自[图7.23](#x1-145003r23)的命令不会修改原始源文件。我们必须指定一个额外的参数`-fix-notes`来将指定的插入作为注释应用到原始警告中。所需的命令将如下所示：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Figure 7.25**: Clang-Tidy with -fix-notes option'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.25**：带有-fix-notes选项的Clang-Tidy'
- en: 'The command output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出如下：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Figure 7.26**: Clang-Tidy fixes applied to the TestClass.cpp'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.26**：Clang-Tidy对TestClass.cpp应用的修复'
- en: As we can see, the required insertions were applied here. Clang-Tidy has powerful
    tools to control the applied fixes and can be considered a significant resource
    for code modification. Another popular tool used for code modification is Clang-Format.
    As the name suggests, this tool specializes in code formatting. Let’s explore
    it in detail.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所需的插入已在此处应用。Clang-Tidy具有强大的工具来控制应用的修复，并且可以被认为是代码修改的重要资源。另一个用于代码修改的流行工具是Clang-Format。正如其名所示，该工具专门用于代码格式化。让我们详细探讨它。
- en: 7.4 Code modification and Clang-Format
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 代码修改和Clang-Format
- en: Clang-Format is an essential tool in the Clang/LLVM project, designed for formatting
    C, C++, Java, JavaScript, Objective-C, or Protobuf code. It plays a crucial role
    in the Clang tooling ecosystem, offering capabilities for parsing, analyzing,
    and manipulating source code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 是 Clang/LLVM 项目中的一个重要工具，旨在格式化 C、C++、Java、JavaScript、Objective-C
    或 Protobuf 代码。它在 Clang 工具生态系统扮演着关键角色，提供了解析、分析和操作源代码的能力。
- en: Clang-Format is a part of Clang and has to be installed if we have built and
    installed the Clang compiler. Let’s look at how it can be used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 是 Clang 的一部分，如果已经构建并安装了 Clang 编译器，则必须安装它。让我们看看它是如何使用的。
- en: 7.4.1 Clang-Format configuration and usage examples
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 Clang-Format 配置和使用示例
- en: 'Clang-Format uses `.clang-format` configuration files. The utility will use
    the closest configuration file; i.e., if the file is located at the folder with
    the source files we want to format, then the configuration from the folder will
    be used. The format for configuration files is YAML, which is the same format
    used for Clang-Tidy configuration files, as shown in [*Figure** 5.12*](B19722_05.xhtml#x1-1080002)*,*
    *Clang-Tidy configuration*. Let’s create the following simple configuration file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 使用 `.clang-format` 配置文件。实用程序将使用最近的配置文件；即，如果该文件位于我们想要格式化的源文件所在的文件夹中，则将使用该文件夹的配置。配置文件的格式是
    YAML，与 Clang-Tidy 配置文件使用的格式相同，如 [*图** 5.12*](B19722_05.xhtml#x1-1080002)*，*Clang-Tidy
    配置*。让我们创建以下简单的配置文件：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Figure 7.27**: Simple .clang-format configuration file'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**图** 7.27**: 简单的 .clang-format 配置文件'
- en: The configuration file says that we will use the code style defined by LLVM,
    see [https://llvm.org/docs/CodingStandards.html](https://llvm.org/docs/CodingStandards.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件指出我们将使用由 LLVM 定义的代码风格，请参阅 [https://llvm.org/docs/CodingStandards.html](https://llvm.org/docs/CodingStandards.html)。
- en: 'Suppose we have a non-formatted file `main.cpp` , then the following command
    will format it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个未格式化的文件 `main.cpp`，那么以下命令将格式化它：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result of the formatting is shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化的结果如下所示：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Original code**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始代码**'
- en: '**[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE36**]'
- en: '**Formatted code**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式化后的代码**'
- en: '****Figure 7.28**: Formatting for main.cpp'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '****图** 7.28**: main.cpp 的格式化'
- en: In the example provided in [Figure 7.28](#x1-147032r28), we can see that the
    indentation defined by the LLVM code style was applied. We can also observe that
    Clang-Format broke *Line 6* in the original source code and made the main function
    definition start on a separate line. Additionally, we can see that Clang-Format
    added a comment to the namespace closing bracket in the formatted code at *Line*
    *6*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图** 7.28](#x1-147032r28) 提供的示例中，我们可以看到应用了由 LLVM 代码风格定义的缩进。我们还可以观察到 Clang-Format
    将原始源代码中的 *第 6 行* 分割，并使主函数定义从新的一行开始。此外，我们还可以看到 Clang-Format 在格式化代码的第 *6* 行添加了一个注释到命名空间关闭括号。
- en: After considering the usage example, it’s time to look at the internal design
    of Clang-Format.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了使用示例之后，现在是时候看看 Clang-Format 的内部设计了。
- en: 7.4.2 Design considerations
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 设计考虑
- en: At the core of Clang-Format is the Clang Lexer (see [*Figure** 2.5*](B19722_02.xhtml#x1-380002)*,
    Lexer*), which tokenizes the input source code, breaking it down into individual
    tokens like keywords, identifiers, and literals. These tokens serve as the basis
    for formatting decisions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 的核心是 Clang Lexer（见 [*图** 2.5*](B19722_02.xhtml#x1-380002)*，Lexer*），它将输入源代码分解成单个标记，如关键字、标识符和字面量。这些标记是格式化决策的基础。
- en: 'The initial Clang-Format design document considered the Parser and AST as basic
    components for formatting. Despite the advantages provided by advanced data structures
    such as the AST, this approach has some disadvantages:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 的初始设计文档考虑了解析器和 AST 作为格式化的基本组件。尽管 AST 等高级数据结构提供了优势，但这种方法也有一些缺点：
- en: The Parser requires a full build process and, therefore, build configuration.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器需要完整的构建过程和相应的构建配置。
- en: The Parser has limited capabilities to process a part of the source text, which
    is a typical task for formatting, such as formatting a single function or a source
    range of the source file.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器在处理源文本的一部分时能力有限，这是格式化中的一个典型任务，例如格式化单个函数或源文件的源范围。
- en: Formatting macros is a challenging task when using the AST as the basic structure
    for formatting. For instance, the processed macro may not be called in the compiled
    code and, as a result, may be missed in the AST.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 AST 作为格式化的基本结构时，格式化宏是一个具有挑战性的任务。例如，处理过的宏可能没有在编译后的代码中调用，因此可能在 AST 中被遗漏。
- en: The Parser is much slower than the Lexer.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器比 Lexer 慢得多。
- en: Clang-Format leverages `clang``::``tooling``::``Replacement` to represent code
    formatting changes and utilizes `clang``::``Rewriter` to apply these changes to
    the source code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 利用 `clang``::``tooling``::``Replacement` 来表示代码格式化更改，并利用 `clang``::``Rewriter`
    将这些更改应用到源代码中。
- en: Configuration plays a pivotal role in Clang-Format’s operation. Users define
    their preferred formatting style by configuring rules in a `.clang-format` file.
    This configuration specifies details such as indentation width, brace placement,
    line breaks, and more.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 配置在 Clang-Format 的操作中起着关键作用。用户通过在 `.clang-format` 文件中配置规则来定义他们首选的格式化风格。此配置指定了缩进宽度、括号放置、换行符等详细信息。
- en: Clang-Format supports various predefined and customizable formatting styles,
    such as ”LLVM,” ”Google,” and ”Chromium.” Users can select a style that aligns
    with their project’s coding standards.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 支持各种预定义和可自定义的格式化风格，如“LLVM”、“Google”和“Chromium”。用户可以选择与项目编码标准一致的风格。
- en: Once tokenized, Clang-Format processes the token stream, taking into account
    the current context, indentation level, and configured style rules. It then adjusts
    whitespace and line breaks accordingly to adhere to the chosen style.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进行标记，Clang-Format 会处理标记流，考虑到当前上下文、缩进级别和配置的样式规则。然后相应地调整空白和换行符，以符合所选风格。
- en: One notable feature of Clang-Format is its ability to handle macros effectively,
    preserving the original formatting within macros and complex macros.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 的一个显著特点是它能够有效地处理宏，保留宏和复杂宏中的原始格式。
- en: Customization is a key aspect of Clang-Format. Users can extend or customize
    its behavior by defining custom rules and formatting options in the configuration
    file. This flexibility allows teams to enforce specific coding standards or adapt
    Clang-Format to project-specific needs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义是 Clang-Format 的一个关键方面。用户可以通过在配置文件中定义自定义规则和格式化选项来扩展或自定义其行为。这种灵活性允许团队强制执行特定的编码标准或根据项目特定需求调整
    Clang-Format。
- en: It offers a user-friendly command-line interface, enabling manual code formatting
    or integration into scripts and automation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个用户友好的命令行界面，允许手动格式化代码或集成到脚本和自动化中。
- en: 'Clang-Format utilizes Clang’s Format library to generate formatted code accurately.
    This library ensures that the code consistently follows the desired formatting
    style. The design follows the main paradigm of LLVM: ”everything is a library,”
    as discussed in [*Section** 1.2.1*](B19722_01.xhtml#x1-200001)*, Short LLVM history*.
    Thus, we can effectively use the formatting functionality in other Clang Tools.
    For instance, formatting can be used with Clang-Tidy to format code with fixes
    applied by Clang-Tidy. Let’s consider an example of how this functionality can
    be used.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Format 利用 Clang 的格式化库来准确生成格式化代码。这个库确保代码始终遵循所需的格式化风格。设计遵循 LLVM 的主要范式：“一切皆库”，如[*第1.2.1节*](B19722_01.xhtml#x1-200001)“简短的
    LLVM 历史”中所述。因此，我们可以有效地在其他 Clang 工具中使用格式化功能。例如，可以使用 Clang-Tidy 的修复来格式化代码。让我们考虑一个如何使用此功能的例子。
- en: 7.4.3 Clang-Tidy and Clang-Format
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 Clang-Tidy 和 Clang-Format
- en: The applied Clang-Tidy fixes can break formatting. Clang-Tidy suggests using
    the `-format-style` option to address the problem. This option will apply formatting
    using the functionality provided by the clangFormat library. The formatting is
    applied to the modified lines of code. Consider an example when our TestClass
    has broken formatting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 Clang-Tidy 修复可能会破坏格式。Clang-Tidy 建议使用 `-format-style` 选项来解决这个问题。此选项将使用 clangFormat
    库提供的功能进行格式化。格式化应用于修改后的代码行。考虑我们的 TestClass 格式化损坏的例子。
- en: 'If we run Clang-Tidy as we did before (see [Figure 7.25](#x1-145011r25)), then
    the formatting will remain unchanged and broken:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像之前一样运行 Clang-Tidy（见[图7.25](#x1-145011r25)），则格式将保持不变和损坏：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Original code**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始代码**'
- en: '**[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE38]'
- en: '**Applied fixes**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用修复**'
- en: '****Figure 7.29**: Applying Clang-Tidy fixes without formatting on TestClassNotFormated.cpp'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '****图7.29**: 在 TestClassNotFormated.cpp 上应用 Clang-Tidy 修复而不进行格式化'
- en: We used the following command for [Figure 7.29](#x1-149026r29)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令生成了[图7.29](#x1-149026r29)
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result will be different if we run Clang-Tidy with `-format-style` option,
    for example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `-format-style` 选项运行 Clang-Tidy，结果将不同，例如：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we can see the ’llvm’ formatting style was chosen for the example. The result
    is shown in the following figure:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，示例中选择了“llvm”格式化风格。结果将在以下图中展示：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Original code**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始代码**'
- en: '**[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE42]'
- en: '**Applied fixes with formatting**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用格式化修复**'
- en: '****Figure 7.30**: Applying Clang-Tidy fixes with formatting on TestClassNotFormated.cpp'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '****图7.30**: 在TestClassNotFormated.cpp上应用Clang-Tidy格式化修复'
- en: 'The relationship between Clang-Tidy and Clang-Format, as we just demonstrated,
    can be visualized as presented in the following figure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才所展示的，Clang-Tidy和Clang-Format之间的关系可以如图所示：
- en: '![Figure 7.31: Clang-Tidy and Clang-Format integration ](img/Figure7.31_B19722.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图7.31: Clang-Tidy和Clang-Format集成](img/Figure7.31_B19722.png)'
- en: '**Figure 7.31**: Clang-Tidy and Clang-Format integration'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.31**: Clang-Tidy和Clang-Format集成'
- en: In the figure, both Clang-Tidy and Clang-Format use the `clangFormat` library
    to format the code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，Clang-Tidy和Clang-Format都使用`clangFormat`库来格式化代码。
- en: The provided example demonstrates the integration of various Clang Tools. Modularity,
    an essential design decision in LLVM/Clang, is a key component for such integration.
    This example is not unique, and we will explore the further integration of different
    Clang Tools to enhance the development experience in **Integrated Development
    Environments** (**IDEs**) like **Visual Studio Code** (**VS Code**). This will
    be the topic of our next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例演示了各种Clang工具的集成。模块化，LLVM/Clang中一个基本的设计决策，是此类集成的一个关键组件。这个例子并不独特，我们将探讨不同Clang工具的进一步集成，以增强**集成开发环境**（**IDEs**）如**Visual
    Studio Code**（**VS Code**）的开发体验。这将是下一章的主题。
- en: 7.5 Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 摘要
- en: In this chapter, we investigated the different options provided by Clang for
    code modifications. We created a specialized Clang Tool that renames a method
    in a test class. We also rewrote the tool using Clang-Tidy and explored how custom
    AST matchers can be created. Furthermore, we delved into a variety of different
    classes provided by Clang for code modifications. One of these classes, `clang``::``FixItHint`,
    is integrated with the Clang diagnostics subsystem and provides a powerful tool
    for code modification within Clang, as well as in different tools created with
    Clang. We concluded with Clang-Format, the only tool in the book that does not
    use the AST but instead utilizes the Clang Lexer to perform code formatting. The
    next chapter will focus on the integration of different Clang Tools within IDEs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了Clang提供的不同代码修改选项。我们创建了一个专门用于重命名测试类中方法的Clang工具。我们还使用Clang-Tidy重写了工具，并探讨了如何创建自定义AST匹配器。此外，我们还深入研究了Clang提供的各种不同类，用于代码修改。其中之一，`clang``::``FixItHint`，与Clang诊断子系统集成，为Clang以及使用Clang创建的不同工具中的代码修改提供了一个强大的工具。我们以Clang-Format结束，这是本书中唯一不使用AST而是利用Clang词法分析器进行代码格式化的工具。下一章将专注于IDE中不同Clang工具的集成。
- en: 7.6 Further reading
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 进一步阅读
- en: 'Clang-Format Style Options: [https://clang.llvm.org/docs/ClangFormatStyleOptions.html](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang-Format样式选项：[https://clang.llvm.org/docs/ClangFormatStyleOptions.html](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)
- en: Peter Goldsborough, Emitting Diagnostics in Clang [[23](B19722_Bib.xhtml#Xmisc_peter_goldsborough)]
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彼得·戈尔茨伯勒，Clang中的诊断输出 [[23](B19722_Bib.xhtml#Xmisc_peter_goldsborough)]
- en: 'AST Matcher Reference: [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)********************'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AST 匹配器参考：[https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)********************
