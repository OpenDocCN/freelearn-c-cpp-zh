- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Essential C++ Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的C++技术
- en: In this chapter, we will take an in-depth look at some fundamental C++ techniques,
    such as move semantics, error handling, and lambda expressions, that will be used
    throughout this book. Some of these concepts still confuse even experienced C++
    programmers and therefore we will look into both their use cases and how they
    work under the hood.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究一些基本的C++技术，如移动语义、错误处理和lambda表达式，这些技术将贯穿本书使用。即使是经验丰富的C++程序员，有些概念仍然会让人困惑，因此我们将探讨它们的用例和工作原理。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Automatic type deduction and how to use the `auto` keyword when declaring functions
    and variables.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动类型推导以及在声明函数和变量时如何使用`auto`关键字。
- en: Move semantics and the *rule of five* and *rule of zero*.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动语义和*五法则*和*零法则*。
- en: Error handling and contracts. Although these topics don't present anything that
    can be considered modern C++, both exceptions and contracts are highly debated
    areas within C++ today.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理和契约。虽然这些主题并没有提供可以被视为现代C++的任何内容，但异常和契约在当今的C++中都是高度争议的领域。
- en: Creating function objects using lambda expressions, one of the most important
    features from C++11.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式创建函数对象，这是C++11中最重要的功能之一。
- en: Let's begin by taking a look at automatic type deduction.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下自动类型推导。
- en: Automatic type deduction with the auto keyword
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用auto关键字进行自动类型推导
- en: Since the introduction of the `auto` keyword in C++11, there has been a lot
    of confusion in the C++ community about how to use the different flavors of `auto`,
    such as `const` `auto&`, `auto&`, `auto&&`, and `decltype(auto)`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C++11引入了`auto`关键字以来，C++社区对如何使用不同类型的`auto`（如`const` `auto&`、`auto&`、`auto&&`和`decltype(auto)`）产生了很多困惑。
- en: Using auto in function signatures
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数签名中使用auto
- en: Although discouraged by some C++ programmers, in my experience the use of `auto`
    in function signatures can increase readability when browsing and viewing header
    files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些C++程序员不赞成，但在我的经验中，在函数签名中使用`auto`可以增加可读性，方便浏览和查看头文件。
- en: 'Here is how the `auto` syntax looks compared to the traditional syntax with
    explicit types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`auto`语法与显式类型的传统语法相比的样子：
- en: '| Traditional syntax with explicit type: | New syntax with auto: |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 显式类型的传统语法：| 使用auto的新语法：|'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The `auto` syntax can be used both with and without a trailing return type.
    The trailing return is necessary in some contexts. For example, if we are writing
    a virtual function, or the function declaration is put in a header file and the
    function definition is in a `.cpp` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`语法可以在有或没有尾随返回类型的情况下使用。在某些情境下，尾随返回类型是必要的。例如，如果我们正在编写虚函数，或者函数声明放在头文件中，函数定义在`.cpp`文件中。'
- en: 'Note that the `auto` syntax can also be used with free functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`auto`语法也可以用于自由函数：
- en: '| Return type | Syntactic variants (a, b, and c correspond to the same result):
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | 语法变体（a、b和c对应相同的结果）：|'
- en: '| Value |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 值 |'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Const reference |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 常量引用 |'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Mutable reference |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 可变引用 |'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Forwarding the return type using decltype(auto)
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用decltype(auto)进行返回类型转发
- en: 'There is a somewhat rare version of automatic type deduction called `decltype(auto)`.
    Its most common use is for forwarding the exact type from a function. Imagine
    that we are writing wrapper functions for `val()` and `mref()` declared in the
    previous table, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种相对罕见的自动类型推导版本称为`decltype(auto)`。它最常见的用途是从函数中转发确切的类型。想象一下，我们正在为前面表格中声明的`val()`和`mref()`编写包装函数，就像这样：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if we wanted to use return type deduction for the wrapper functions, the
    `auto` keyword would deduce the return type to an `int` in both cases:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望对包装函数使用返回类型推导，`auto`关键字将在两种情况下推导返回类型为`int`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we wanted our `mref_wrapper()` to return an `int&`, we would need to write
    `auto&`. In this example, this would be fine, since we know the return type of
    `mref()`. However, that''s not always the case. So if we want the compiler to
    instead choose the exact same type without explicitly saying `int&` or `auto&`
    for `mref_wrapper()`, we can use `decltype(auto)`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望`mref_wrapper()`返回`int&`，我们需要写`auto&`。在这个例子中，这是可以的，因为我们知道`mref()`的返回类型。然而，并非总是如此。因此，如果我们希望编译器选择与`int&`或`auto&`相同的类型而不明确指定`mref_wrapper()`的返回类型，我们可以使用`decltype(auto)`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this way, we can avoid explicitly choosing between writing `auto` or `auto&`
    when we don't know what the function `val()` or `mref()` return. This is a scenario
    that usually happens in generic code where the type of the function that is being
    wrapped is a template parameter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以避免在不知道函数`val()`或`mref()`返回的类型时明确选择写`auto`或`auto&`。这通常发生在泛型代码中，其中被包装的函数的类型是模板参数。
- en: Using auto for variables
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用auto声明变量
- en: The introduction of the `auto` keyword in C++11 has initiated quite a debate
    among C++ programmers. Many people think it reduces readability, or even that
    it makes C++ similar to a dynamically typed language. I tend to not participate
    in those debates, but my personal opinion is that you should (almost) always use
    `auto` as, in my experience, it makes the code safer and less littered with clutter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入`auto`关键字引发了C++程序员之间的激烈辩论。许多人认为它降低了可读性，甚至使C++变得类似于动态类型语言。我倾向于不参与这些辩论，但我个人认为你应该（几乎）总是使用`auto`，因为在我的经验中，它使代码更安全，减少了混乱。
- en: Overusing `auto` can make the code harder to understand. When reading code,
    we usually want to know which operations are supported by some object. A good
    IDE can provide us with this information, but it's not explicitly there in the
    source code. C++20 concepts address this issue by focusing on the behavior of
    an object. See *Chapter 8*, *Compile-Time Programming*, for more information about
    C++ concepts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 过度使用`auto`可能会使代码难以理解。在阅读代码时，我们通常想知道某个对象支持哪些操作。一个好的IDE可以为我们提供这些信息，但在源代码中并没有明确显示。C++20概念通过关注对象的行为来解决这个问题。有关C++概念的更多信息，请参阅*第8章*，*编译时编程*。
- en: 'I prefer to use `auto` for local variables using the left-to-right initialization
    style. This means keeping the variable on the left, followed by an equals sign,
    and then the type on the right side, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用`auto`来定义使用从左到右的初始化样式的局部变量。这意味着将变量保留在左侧，后跟一个等号，然后在右侧是类型，就像这样：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With *guaranteed copy elision* introduced in C++17, the statement `auto x =
    Foo{}` is identical to `Foo x{}`; that is, the language guarantees that there
    is no temporary object that needs to be moved or copied in this case. This means
    that we can now use the left-to-right initialization style without worrying about
    performance and we can also use it for non-movable/non-copyable types, such as
    `std::atomic` or `std::mutex`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中引入了*保证的拷贝省略*，语句`auto x = Foo{}`与`Foo x{}`是相同的；也就是说，语言保证在这种情况下没有需要移动或复制的临时对象。这意味着我们现在可以使用从左到右的初始化样式，而不用担心性能，我们还可以用于不可移动/不可复制的类型，如`std::atomic`或`std::mutex`。
- en: One big advantage of using `auto` for variables is that you will never leave
    a variable uninitialized since `auto x;` doesn't compile. Uninitialized variables
    are a particularly common source of undefined behavior that you can completely
    eliminate by following the style suggested here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto`定义变量的一个很大的优势是，您永远不会留下未初始化的变量，因为`auto x;`不会编译。未初始化的变量是未定义行为的一个常见来源，您可以通过遵循这里建议的样式完全消除。
- en: Using `auto` will help you with using the correct type for your variables. What
    you still need to do, though, is to express how you intend to use a variable by
    specifying whether you need a reference or a copy, and whether you want to modify
    the variable or just read from it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto`将帮助您使用正确的类型来定义变量。但您仍然需要通过指定需要引用还是副本，以及是否要修改变量或仅从中读取来表达您打算如何使用变量。
- en: A const reference
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个const引用
- en: A `const` reference, denoted by `const auto&`, has the ability to bind to anything.
    The original object can never be mutated through such a reference. I believe that
    the `const` reference should be the default choice for objects that are potentially
    expensive to copy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`引用，用`const auto&`表示，具有绑定到任何东西的能力。原始对象永远不会通过这样的引用发生变异。我认为`const`引用应该是潜在昂贵的对象的默认选择。'
- en: 'If the `const` reference is bound to a temporary object, the lifetime of the
    temporary will be extended to the lifetime of the reference. This is demonstrated
    in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`const`引用绑定到临时对象，则临时对象的生命周期将延长到引用的生命周期。这在以下示例中得到了证明：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s also possible to end up with a `const` reference by using `auto&`. This
    can be seen in the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用`auto&`得到一个`const`引用。可以在以下示例中看到：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even though this is perfectly valid, it is preferable to always explicitly express
    that we are dealing with `const` references by using `const auto&`, and, more
    importantly, we should use `auto&` to *only* denote mutable references.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是完全有效的，但最好始终明确表示我们正在处理`const`引用，使用`const auto&`，更重要的是，我们应该使用`auto&`仅表示可变引用。
- en: A mutable reference
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个可变引用
- en: In contrast to a `const` reference, a mutable reference cannot bind to a temporary.
    As mentioned, we use `auto&` to denote mutable references. Use a mutable reference
    only when you intend to change the object it references.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与`const`引用相反，可变引用不能绑定到临时对象。如前所述，我们使用`auto&`来表示可变引用。只有在打算更改引用的对象时才使用可变引用。
- en: A forwarding reference
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转发引用
- en: '`auto&&` is called a forwarding reference (also referred to as a *universal
    reference*). It can bind to anything, which makes it useful for certain cases.
    Forwarding references will, just like `const` references, extend the lifetime
    of a temporary. But in contrast to the `const` reference, `auto&&` allows us to
    mutate objects it references, temporaries included.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto&&`被称为转发引用（也称为*通用引用*）。它可以绑定到任何东西，这对某些情况很有用。转发引用将像`const`引用一样，延长临时对象的生命周期。但与`const`引用相反，`auto&&`允许我们改变它引用的对象，包括临时对象。'
- en: Use `auto&&` for variables that you only forward to some other code. In those
    forwarding cases, you rarely care about whether the variable is a `const` or a
    mutable; you just want to pass it to some code that is actually going to use the
    variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只转发到其他代码的变量，请使用`auto&&`。在这些转发情况下，您很少关心变量是`const`还是可变的；您只是想将其传递给实际要使用变量的一些代码。
- en: It's important to note that `auto&&` and `T&&` are only forwarding references
    if used in a function template where `T` is a template parameter of that function
    template. Using the `&&` syntax with an explicit type, for example `std::string&&`,
    denotes an **rvalue** reference and does not have the properties of a forwarding
    reference (rvalues and move semantics will be discussed later in this chapter).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，只有在函数模板中使用`T`作为该函数模板的模板参数时，`auto&&`和`T&&`才是转发引用。使用显式类型，例如`std::string&&`，带有`&&`语法表示**右值**引用，并且不具有转发引用的属性（右值和移动语义将在本章后面讨论）。
- en: Practices for ease of use
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 便于使用的实践
- en: Although this is my personal opinion, I recommend using `const auto` for fundamental
    types (`int`, `float`, and so on) and small non-fundamental types like `std::pair`
    and `std::complex`. For bigger types that are potentially expensive to copy, use
    `const auto&`. This should cover the majority of the variable declarations in
    a C++ code base.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是我的个人意见，我建议对基本类型（`int`，`float`等）和小的非基本类型（如`std::pair`和`std::complex`）使用`const
    auto`。对于潜在昂贵的大型类型，使用`const auto&`。这应该涵盖C++代码库中大多数变量声明。
- en: '`auto&` and `auto` should only be used when you require the behavior of a mutable
    reference or an explicit copy; this communicates to the reader of the code that
    those variables are important as they either copy an object or mutate a referenced
    object. Finally, use `auto&&` for forwarding code only.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要可变引用或显式复制的行为时，才应使用`auto&`和`auto`；这向代码的读者传达了这些变量的重要性，因为它们要么复制一个对象，要么改变一个引用的对象。最后，只在转发代码时使用`auto&&`。
- en: Following these rules makes your code base easier to read, debug, and reason
    about.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些规则可以使您的代码库更易于阅读、调试和理解。
- en: It might seem odd that while I recommend using `const auto` and `const auto&`
    for most variable declarations, I tend to use a simple `auto` in some places in
    this book. The reason for using plain `auto` is the limited space that the format
    of a book provides.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也许会觉得奇怪，虽然我建议在大多数变量声明中使用`const auto`和`const auto&`，但在本书的某些地方我倾向于使用简单的`auto`。使用普通的`auto`的原因是书籍格式提供的有限空间。
- en: Before moving on, we will spend a little time talking about `const` and how
    to propagate `const` when using pointers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将花一点时间讨论`const`以及在使用指针时如何传播`const`。
- en: Const propagation for pointers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针的const传播
- en: 'By using the keyword `const`, we can inform the compiler about which objects
    are immutable. The compiler can then check that we don''t try to mutate objects
    that aren''t intended to be changed. In other words, the compiler checks our code
    for `const`-correctness. A common mistake when writing `const`-correct code in
    C++ is that a `const`-initialized object can still manipulate the values that
    member pointers point at. The following example illustrates the problem:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用关键字`const`，我们可以告诉编译器哪些对象是不可变的。然后编译器可以检查我们是否尝试改变不打算改变的对象。换句话说，编译器检查我们的代码是否符合`const`-correctness。在C++中编写`const`-correct代码时的一个常见错误是，`const`初始化的对象仍然可以操作成员指针指向的值。以下示例说明了这个问题：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although the function `set_ptr_val()` is mutating the `int` value, it's valid
    to declare it `const` since the pointer `ptr_` itself is not mutated, only the
    `int` object that the pointer is pointing at.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数`set_ptr_val()`正在改变`int`值，但声明它为`const`是有效的，因为指针`ptr_`本身没有被改变，只有指针指向的`int`对象被改变。
- en: In order to prevent this in a readable way, a wrapper called `std::experimental::propagate_const`
    has been added to the standard library extensions (included in, at the time of
    writing, the latest versions of Clang and GCC). Using `propagate_const`, the function
    `set_ptr_val()` will not compile. Note that `propagate_const` only applies to
    pointers, and pointer-like classes such as `std::shared_ptr` and `std::unique_ptr`,
    but not `std::function`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以一种可读的方式防止这种情况，标准库扩展中添加了一个名为`std::experimental::propagate_const`的包装器（在撰写本文时，已包含在最新版本的Clang和GCC中）。使用`propagate_const`，函数`set_ptr_val()`将无法编译。请注意，`propagate_const`仅适用于指针和类似指针的类，如`std::shared_ptr`和`std::unique_ptr`，而不适用于`std::function`。
- en: 'The following example demonstrates how `propagate_const` can be used to generate
    compilation errors when trying to mutate an object inside a `const` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用`propagate_const`在尝试在`const`函数内部改变对象时生成编译错误：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The importance of proper use of `const` in large code bases cannot be overstated,
    and the introduction of `propagate_const` makes `const`-correctness even more
    effective.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型代码库中正确使用`const`的重要性不言而喻，而引入`propagate_const`使`const`-correctness变得更加有效。
- en: Next, we will have a look at move semantics and some important rules for handling
    resources inside a class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下移动语义以及处理类内部资源的一些重要规则。
- en: Move semantics explained
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释移动语义
- en: Move semantics is a concept introduced in C++11 that, in my experience, is quite
    hard to grasp, even by experienced programmers. Therefore, I will try to give
    you an in-depth explanation of how it works, when the compiler utilizes it, and,
    most importantly, why it is needed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义是C++11中引入的一个概念，在我看来，即使是经验丰富的程序员也很难理解。因此，我将尝试为您深入解释它的工作原理，编译器如何利用它，以及为什么它是必要的。
- en: 'Essentially, the reason C++ even has the concept of move semantics, whereas
    most other languages don''t, is a result of it being a value-based language, as
    discussed in *Chapter 1*, *A Brief Introduction to C++*. If C++ did not have move
    semantics built in, the advantages of value-based semantics would get lost in
    many cases and programmers would have to perform one of the following trade-offs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，C++之所以有移动语义的概念，而大多数其他语言没有，是因为它是一种基于值的语言，正如在《第1章C++简介》中讨论的那样。如果C++没有内置移动语义，那么基于值的语义的优势在许多情况下将会丢失，程序员将不得不进行以下折衷之一：
- en: Performing redundant deep-cloning operations with high performance costs
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行性能成本高的冗余深克隆操作
- en: Using pointers for objects like Java does, losing the robustness of value semantics
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Java一样使用对象指针，失去值语义的健壮性
- en: Performing error-prone swapping operations at the cost of readability
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以牺牲可读性为代价进行容易出错的交换操作
- en: We do not want any of these, so let's have a look at how move semantics help
    us.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望出现这些情况，所以让我们看看移动语义如何帮助我们。
- en: Copy-construction, swap, and move
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制构造、交换和移动
- en: Before we go into the details of move, I will first explain and illustrate the
    differences between copy-constructing an object, swapping two objects, and move-constructing
    an object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解移动的细节之前，我将首先解释并说明复制构造对象、交换两个对象和移动构造对象之间的区别。
- en: Copy-constructing an object
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制构造对象
- en: 'When copying an object handling a resource, a new resource needs to be allocated,
    and the resource from the source object needs to be copied so that the two objects
    are completely separated. Imagine that we have a class, `Widget`, that references
    some sort of resource that needs to be allocated on construction. The following
    code default-constructs a `Widget` object and then copy-constructs a new instance:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制处理资源的对象时，需要分配新资源，并且需要复制源对象的资源，以便使这两个对象完全分离。想象一下，我们有一个类`Widget`，它引用需要在构造时分配的某种资源。以下代码默认构造了一个`Widget`对象，然后复制构造了一个新实例：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resource allocations that are carried out are illustrated in the following
    figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所进行的资源分配如下图所示：
- en: '![](img/B15619_02_01.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_02_01.png)'
- en: 'Figure 2.1: Copying an object with resources'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：复制具有资源的对象
- en: The allocation and copying are slow processes, and, in many cases, the source
    object isn't needed anymore. With move semantics, the compiler detects cases like
    these where the old object is not tied to a variable, and instead performs a move
    operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分配和复制是缓慢的过程，在许多情况下，源对象不再需要。使用移动语义，编译器会检测到这样的情况，其中旧对象不与变量绑定，而是执行移动操作。
- en: Swapping two objects
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交换两个对象
- en: 'Before move semantics were added in C++11, swapping the content of two objects
    was a common way to transfer data without allocating and copying. As shown next,
    objects simply swap their content with each other:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中添加移动语义之前，交换两个对象的内容是一种常见的在不分配和复制的情况下传输数据的方式。如下所示，对象只是互相交换它们的内容：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following figure illustrates the process:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了这个过程：
- en: '![](img/B15619_02_02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_02_02.png)'
- en: 'Figure 2.2: Swapping resources between two objects'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在两个对象之间交换资源
- en: The `std::swap()` function is a simple but useful utility used in the copy-and-swap
    idiom covered later in this chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::swap()`函数是一个简单但有用的实用程序，在本章后面将介绍的复制和交换习语中使用。'
- en: Move-constructing an object
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移动构造对象
- en: When moving an object, the destination object steals the resource straight from
    the source object, and the source object is reset.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 移动对象时，目标对象直接从源对象中夺取资源，而源对象被重置。
- en: 'As you can see, it is very similar to swapping, except that the *moved-from*
    object does not have to receive the resources from the *moved-to* object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这与交换非常相似，只是*移出*的对象不必从*移入*对象那里接收资源：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following figure illustrates the process:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了这个过程：
- en: '![](img/B15619_02_03.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_02_03.png)'
- en: 'Figure 2.3: Moving resources from one object to another'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：将资源从一个对象移动到另一个对象
- en: Although the source object is reset, it's still in a valid state. This resetting
    of the source object is not something that the compiler does automatically for
    us. Instead, we need to implement the resetting in the move constructor to ensure
    that the object is in a valid state that can be destroyed or assigned to. We will
    talk more about valid states later on in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管源对象被重置，但它仍处于有效状态。源对象的重置不是编译器自动为我们执行的。相反，我们需要在移动构造函数中实现重置，以确保对象处于可以被销毁或赋值的有效状态。我们将在本章后面更多地讨论有效状态。
- en: Moving objects only makes sense if the object type owns a resource of some sort
    (the most common case being heap-allocated memory). If all data is contained within
    the object, the most efficient way to move an object is to just copy it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在对象类型拥有某种资源（最常见的情况是堆分配的内存）时，移动对象才有意义。如果所有数据都包含在对象内部，移动对象的最有效方式就是简单地复制它。
- en: Now that you have a basic grasp of move semantics, let's go into the details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经基本掌握了移动语义，让我们深入了解一下细节。
- en: Resource acquisition and the rule of five
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源获取和五法则
- en: To fully understand move semantics, we need to go back to the basics of classes
    and resource acquisition in C++. One of the basic concepts in C++ is that a class
    should completely handle its resources. This means that when a class is copied,
    moved, copy-assigned, move-assigned, or destructed, the class should make sure
    its resources are handled accordingly. The necessity of implementing these five
    functions is commonly referred to as **the rule of five**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解移动语义，我们需要回到C++中类和资源获取的基础概念。C++中的一个基本概念是，一个类应该完全处理其资源。这意味着当一个类被复制、移动、复制赋值、移动赋值或销毁时，类应该确保其资源得到适当处理。实现这五个函数的必要性通常被称为**五法则**。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, the handled resource is a block of memory allocated in the constructor
    of the `Buffer` class. Memory is probably the most common resource for classes
    to handle, but a resource can be so much more: a mutex, a handle for a texture
    on the graphics card, a thread handle, and so on.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，处理的资源是在`Buffer`类的构造函数中分配的一块内存。内存可能是类处理的最常见资源，但资源可以是更多：互斥锁、图形卡上纹理的句柄、线程句柄等等。
- en: 'The five functions that are referred to in the rule of five have been left
    out and will follow next. We will begin with the copy-constructor, copy-assignment,
    and destructor, which all need to be involved in the resource handling:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在“五法则”中提到的五个函数已被省略，将在下文中介绍。我们将从复制构造函数、复制赋值运算符和析构函数开始，这些函数都需要参与资源处理：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before the introduction of move semantics in C++11, these three functions were
    usually referred to as the **rule of three**. The copy-constructor, copy-assignment,
    and destructor are invoked in the following cases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中引入移动语义之前，这三个函数通常被称为**三法则**。复制构造函数、复制赋值运算符和析构函数在以下情况下被调用：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Although a correct implementation of these three functions is all that is required
    for a class to handle its internal resources, two problems arise:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正确实现这三个函数是类处理内部资源所需的全部内容，但会出现两个问题：
- en: '**Resources that cannot be copied**: In the `Buffer` class example, our resource
    can be copied, but there are other types of resources where a copy wouldn''t make
    sense. For example, the resource contained in a class might be a `std::thread`,
    a network connection, or something else that it''s not possible to copy. In these
    cases, we cannot pass around the object.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法复制的资源**：在`Buffer`类示例中，我们的资源可以被复制，但还有其他类型的资源，复制是没有意义的。例如，类中包含的资源可能是`std::thread`、网络连接或其他无法复制的资源。在这些情况下，我们无法传递对象。'
- en: '**Unnecessary copies**: If we return our `Buffer` class from a function, the
    entire array needs to be copied. (The compiler optimizes away the copy in some
    cases, though, but let''s ignore that for now.)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不必要的复制**：如果我们从函数中返回我们的`Buffer`类，整个数组都需要被复制。（编译器在某些情况下会优化掉复制，但现在让我们忽略这一点。）'
- en: The solution to these problems is move semantics. In addition to the copy-constructor
    and copy-assignment, we can add a move-constructor and a move-assignment operator
    to our class. Instead of taking a `const` reference (`const Buffer&`) as a parameter,
    the move versions accept a `Buffer&&` object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法是移动语义。除了复制构造函数和复制赋值，我们还可以在我们的类中添加移动构造函数和移动赋值运算符。移动版本不是以`const`引用（`const
    Buffer&`）作为参数，而是接受`Buffer&&`对象。
- en: The `&&` modifier indicates that the parameter is an object that we intend to
    move from instead of copying it. Speaking in C++ terms, this is called an rvalue,
    and we will talk a little bit more about those later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`修饰符表示参数是我们打算从中移动而不是复制的对象。用C++术语来说，这被称为rvalue，我们稍后会更详细地讨论这些。'
- en: Whereas the `copy()` functions copy an object, the move equivalents are intended
    to move resources from one object to another, freeing the moved-from object from
    the resource.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 而`copy()`函数复制对象，移动等效函数旨在将资源从一个对象移动到另一个对象，释放被移动对象的资源。
- en: 'This is how we would extend our `Buffer` class with the move-constructor and
    move-assignment. As you can see, these functions will not throw any exceptions
    and can therefore be marked as `noexcept`. This is because, as opposed to the
    copy-constructor/copy-assignment, they do not allocate memory or do something
    that might throw exceptions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何通过移动构造函数和移动赋值来扩展我们的`Buffer`类。如您所见，这些函数不会抛出任何异常，因此可以标记为`noexcept`。这是因为，与复制构造函数/复制赋值相反，它们不会分配内存或执行可能引发异常的操作：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, when the compiler detects that we perform what seems to be a copy, such
    as returning a `Buffer` from a function, but the copied-from value isn't used
    anymore, it will utilize the no-throw move-constructor/move-assignment instead
    of copying.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当编译器检测到我们执行了似乎是复制的操作，例如从函数返回一个`Buffer`，但复制的值不再被使用时，它将使用不抛出异常的移动构造函数/移动赋值代替复制。
- en: This is pretty sweet; the interface remains as clear as when copying but, under
    the hood, the compiler has performed a simple move. Thus, the programmer does
    not need to use any esoteric pointers or out-parameters in order to avoid a copy;
    as the class has move semantics implemented, the compiler handles this automatically.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常棒；接口保持与复制时一样清晰，但在底层，编译器执行了一个简单的移动。因此，程序员不需要使用任何奇怪的指针或输出参数来避免复制；因为类已经实现了移动语义，编译器会自动处理这个问题。
- en: Do not forget to mark your move-constructors and move-assignment operators as
    `noexcept` (unless they might throw an exception, of course). Not marking them
    `noexcept` prevents standard library containers and algorithms from utilizing
    them, instead resorting to using a regular copy/assignment under certain conditions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将您的移动构造函数和移动赋值运算符标记为`noexcept`（除非它们可能抛出异常）。不标记它们为`noexcept`会阻止标准库容器和算法在某些条件下使用它们，而是转而使用常规的复制/赋值。
- en: To be able to know when the compiler is allowed to move an object instead of
    copying, an understanding of rvalues is necessary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够知道编译器何时允许移动对象而不是复制，需要了解rvalue。
- en: Named variables and rvalues
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名变量和rvalue
- en: 'So, when is the compiler allowed to move objects instead of copying? As a short
    answer, the compiler moves an object when the object can be categorized as an
    rvalue. The term **rvalue** might sound complicated, but in essence it is just
    an object that is not tied to a named variable, for either of the following reasons:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，编译器何时允许移动对象而不是复制呢？简短的答案是，当对象可以被归类为rvalue时，编译器会移动对象。术语**rvalue**听起来可能很复杂，但本质上它只是一个不与命名变量绑定的对象，原因如下：
- en: It's coming straight out of a function
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接来自函数
- en: We make a variable an rvalue by using `std::move()`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`std::move()`，我们可以将变量变成rvalue
- en: 'The following example demonstrates both of these scenarios:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这两种情况：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I will also use the terms **lvalue** and **named variable** interchangeably
    in this book. An lvalue corresponds to objects that we can refer to by name in
    our code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我还将交替使用术语**lvalue**和**命名变量**。lvalue对应于我们在代码中可以通过名称引用的对象。
- en: 'Now we will make this a little more advanced by using a member variable of
    type `std::string` in a class. The following `Button` class will serve as an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过在类中使用`std::string`类型的成员变量来使其更加高级。以下的`Button`类将作为一个例子：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also need a free function returning a title and a `Button` variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个返回标题和`Button`变量的自由函数：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Given these prerequisites, let''s look at a few cases of copying and moving
    in detail:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在满足这些先决条件的情况下，让我们详细看一些复制和移动的案例：
- en: '**Case 1**: `Button::title_` is copy-assigned because the `string` object is
    tied to the variable `str`:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Case 1**：`Button::title_`被移动赋值，因为`string`对象通过`std::move()`传递：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Case 2**: `Button::title_` is move-assigned because `str` is passed through
    `std::move()`:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Case 2**：`Button::title_`被移动赋值，因为`str`通过`std::move()`传递：'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Case 3**: `Button::title_` is move-assigned because the new `std::string`
    object is coming straight out of a function:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Case 3**：`Button::title_`被移动赋值，因为新的`std::string`对象直接来自函数：'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Case 4**: `Button::title_` is copy-assigned because the `string` object is
    tied to `s` (this is the same as *Case 1*):'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Case 4**：`Button::title_`被复制赋值，因为`string`对象与`s`绑定（这与*Case 1*相同）：'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Case 5**: `Button::title_` is copy-assigned because `str` is declared `const`
    and therefore is not allowed to mutate:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Case 5**：`Button::title_`被复制赋值，因为`str`被声明为`const`，因此不允许改变：'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, determining whether an object is moved or copied is quite simple.
    If it has a variable name, it is copied; otherwise, it is moved. If you are using
    `std::move()` to move a named object, the object cannot be declared `const`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，确定对象是移动还是复制非常简单。如果它有一个变量名，它就会被复制；否则，它就会被移动。如果您正在使用`std::move()`来移动一个命名对象，那么该对象就不能被声明为`const`。
- en: Default move semantics and the rule of zero
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认移动语义和零规则
- en: This section discusses automatically generated copy-assignment operators. It's
    important to know that the generated function does not have strong exception guarantees.
    Therefore, if an exception is thrown during the copy-assignment, the object might
    end up in a state where it is only partially copied.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论自动生成的复制赋值运算符。重要的是要知道生成的函数没有强异常保证。因此，如果在复制赋值期间抛出异常，对象可能最终处于部分复制的状态。
- en: As with the copy-constructor and copy-assignment, the move-constructor and move-assignment
    can be generated by the compiler. Although some compilers allow themselves to
    automatically generate these functions under certain conditions (more about this
    later), we can simply force the compiler to generate them by using the `default`
    keyword.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与复制构造函数和复制赋值一样，移动构造函数和移动赋值可以由编译器生成。尽管一些编译器允许在某些条件下自动生成这些函数（稍后会详细介绍），但我们可以通过使用`default`关键字简单地强制编译器生成它们。
- en: 'In the case of the `Button` class, which doesn''t manually handle any resources,
    we can simply extend it like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不手动处理任何资源的`Button`类，我们可以简单地扩展它如下：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make it even simpler, if we do not declare *any* custom copy-constructor/copy-assignment
    or destructor, the move-constructors/move-assignments are implicitly declared,
    meaning that the first `Button` class actually handles everything:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的是，如果我们不声明*任何*自定义复制构造函数/复制赋值或析构函数，移动构造函数/移动赋值将被隐式声明，这意味着第一个`Button`类实际上处理了一切：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It''s easy to forget that adding just one of the five functions prevents the
    compiler from generating the other ones. The following version of the `Button`
    class has a custom destructor. As a result, the move operators are not generated,
    and the class will always be copied:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记只添加五个函数中的一个会阻止编译器生成其他函数。以下版本的`Button`类具有自定义析构函数。因此，移动运算符不会生成，并且该类将始终被复制：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's see how we can use this insight into generated functions when implementing
    application classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在实现应用程序类时如何使用这些生成函数的见解。
- en: Rule of zero in a real code base
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际代码库中的零规则
- en: In practice, the cases where you have to write your own copy/move-constructors,
    copy/move-assignments, and constructors should be very few. Writing your classes
    so that they don't require any of these special member functions to be explicitly
    written (or `default` - declared) is often referred to as **the rule of zero**.
    This means that if a class in the application code base is required to have any
    of these functions written explicitly, that piece of code would probably be better
    off in the library part of your code base.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，必须编写自己的复制/移动构造函数、复制/移动赋值和构造函数的情况应该非常少。编写类，使其不需要显式编写任何这些特殊成员函数（或声明为`default`）通常被称为**零规则**。这意味着如果应用程序代码库中的类需要显式编写任何这些函数，那么该代码片段可能更适合于代码库的一部分。
- en: Later on in this book, we will discuss `std::optional`, which is a handy utility
    class for dealing with optional members when applying the rule of zero.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将讨论`std::optional`，这是一个方便的实用类，用于处理可选成员，同时应用零规则。
- en: A note on empty destructors
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于空析构函数的说明
- en: 'Writing an empty destructor can prevent the compiler from implementing certain
    optimizations. As you can see in the following snippets, copying an array of a
    trivial class with an empty destructor yields the same (non-optimized) assembler
    code as copying with a handcrafted `for`-loop. The first version uses an empty
    destructor with `std::copy()`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编写空析构函数可以防止编译器实现某些优化。如下片段所示，使用具有空析构函数的平凡类的数组复制产生与使用手工制作的`for`循环复制相同（非优化）的汇编代码。第一个版本使用具有`std::copy()`的空析构函数：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second version uses a `Point` class with no destructor but with a handcrafted
    `for`-loop:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本使用了一个没有析构函数但有手工制作的`for`循环的`Point`类：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Both versions generate the following x86 assembler, which corresponds to a
    simple loop:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本生成以下x86汇编代码，对应一个简单的循环：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, if we remove the destructor or declare the destructor `default`, the
    compiler optimizes `std::copy()` to utilize `memmove()` instead of a loop:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们删除析构函数或声明析构函数为`default`，编译器将优化`std::copy()`以利用`memmove()`而不是循环：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code generates the following x86 assembler, with the `memmove()`
    optimization:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成以下x86汇编代码，带有`memmove()`优化：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The assembler was generated using GCC 7.1 in *Compiler Explorer*, which is available
    at [https://godbolt.org/](https://godbolt.org/).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编是使用*Compiler Explorer*中的GCC 7.1生成的，可在[https://godbolt.org/](https://godbolt.org/)上找到。
- en: To summarize, use `default` destructors or no destructors at all in favor of
    empty destructors to squeeze a little bit more performance out of your application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用`default`析构函数或根本不使用析构函数，以便在应用程序中挤出更多性能。
- en: A common pitfall – moving non-resources
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个常见的陷阱-移动非资源
- en: 'There is one common pitfall when using default-created move-assignments: classes
    that mix fundamental types with more advanced compound types. As opposed to compound
    types, fundamental types (such as `int`, `float`, and `bool`) are simply copied
    when moved, as they don''t handle any resources.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用默认创建的移动赋值时存在一个常见的陷阱：将基本类型与更高级的复合类型混合使用。与复合类型相反，基本类型（如`int`、`float`和`bool`）在移动时只是被复制，因为它们不处理任何资源。
- en: When a simple type is mixed with a resource-owning type, the move-assignment
    becomes a mixture of move and copy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当简单类型与拥有资源的类型混合在一起时，移动赋值成为移动和复制的混合。
- en: 'Here is an example of a class that will fail:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将失败的类的示例：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Menu` class will have undefined behavior if it''s used like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像这样使用`Menu`类，它将具有未定义的行为：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The undefined behavior happens as the `items_` vector is moved and is therefore
    empty. The `index_`, on the other hand, is copied, and therefore still has the
    value `2` in the moved-from object `a`. When `selected_item()` is called, the
    function will try to access `items_` at index `2` and the program will crash.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义的行为发生在`items_`向量被移动并且因此为空。另一方面，`index_`被复制，因此在移动的对象`a`中仍然具有值`2`。当调用`selected_item()`时，函数将尝试访问索引`2`处的`items_`，程序将崩溃。
- en: 'In these cases, the move-constructor/assignment is better implemented by simply
    swapping the members, like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，移动构造函数/赋值最好通过简单交换成员来实现，就像这样：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This way, the `Menu` class can be safely moved while still preserving the no-throw
    guarantee. In *Chapter 8*, *Compile-Time Programming*, you will learn how to take
    advantage of reflection techniques in C++ in order to automate the process of
    creating move-constructor/assignment functions that swap the elements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式，`Menu`类可以安全地移动，同时保留无抛出保证。在*第8章*，*编译时编程*中，您将学习如何利用C++中的反射技术来自动创建交换元素的移动构造函数/赋值函数。
- en: Applying the && modifier to class member functions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`&&`修饰符应用于类成员函数
- en: 'In addition to being applied to objects, you can also add the `&&` modifier
    to a member function of a class, just as you can apply a `const` modifier to a
    member function. As with the `const` modifier, a member function that has the
    `&&` modifier will only be considered by overload resolution if the object is
    an rvalue:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用于对象之外，您还可以向类的成员函数添加`&&`修饰符，就像您可以向成员函数应用`const`修饰符一样。与`const`修饰符一样，具有`&&`修饰符的成员函数只有在对象是右值时才会被重载解析考虑：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It might seem odd that anyone would ever want this behavior, but there are use
    cases. We will investigate one of them in *Chapter 10,* *Proxy Objects and Lazy
    Evaluation*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有些奇怪，有人会想要这种行为，但确实有用例。我们将在*第10章*，*代理对象和延迟评估*中调查其中之一。
- en: Don't move when copies are elided anyway
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当复制被省略时不要移动
- en: 'It might be tempting to use `std::move()` when returning a value from a function,
    like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数返回值时，可能会诱人使用`std::move()`，就像这样：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, unless `x` is a move-only type, you shouldn''t be doing this. This
    usage of `std::move()` prevents the compiler from using **return value optimization**
    (**RVO**) and thereby completely elides the copying of `x`, which is more efficient
    than moving it. So, when returning a newly created object by value, don''t use
    `std::move()`; instead, just return the object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非`x`是一个仅移动类型，否则不应该这样做。使用`std::move()`会阻止编译器使用**返回值优化**（**RVO**），从而完全省略了`x`的复制，这比移动更有效。因此，当通过值返回新创建的对象时，不要使用`std::move()`；而是直接返回对象：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This particular example where a *named* object is elided is usually called **NRVO**,
    or **Named-RVO**. RVO and NRVO are implemented by all major C++ compilers today.
    If you want to read more about RVO and copy elision, you can find a detailed summary
    at [https://en.cppreference.com/w/cpp/language/copy_elision](https://en.cppreference.com/w/cpp/language/copy_elision).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的例子，其中*命名*对象被省略，通常称为**NRVO**或**Named-RVO**。 RVO和NRVO由今天所有主要的C++编译器实现。如果您想了解更多关于RVO和复制省略的信息，您可以在[https://en.cppreference.com/w/cpp/language/copy_elision](https://en.cppreference.com/w/cpp/language/copy_elision)找到详细的摘要。
- en: Pass by value when applicable
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在适用时传递值
- en: 'Consider a function that converts a `std::string` to lowercase. In order to
    use the move-constructor where applicable, and the copy-constructor otherwise,
    it may seem like two functions are required:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个将`std::string`转换为小写的函数。为了在适用时使用移动构造函数，在不适用时使用复制构造函数，似乎需要两个函数：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, by taking the `std::string` by value instead, we can write one function
    that covers both cases:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过按值传递`std::string`，我们可以编写一个函数来涵盖这两种情况：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s see why this implementation of `str_to_lower()` avoids unnecessary copying
    where possible. When passed a regular variable, shown as follows, the content
    of `str` is copy-constructed into `s` prior to the function call, and then move-assigned
    back to `str` when the functions returns:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`str_to_lower()`的这种实现如何避免可能的不必要的复制。当传递一个常规变量时，如下所示，函数调用之前`str`的内容被复制构造到`s`中，然后在函数返回时移动分配回`str`：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When passed an rvalue, as shown below, the content of `str` is move-constructed
    into `s` prior to the function call, and then move-assigned back to `str` when
    the function returns. Therefore, no copy is made through the function call:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递一个右值时，如下所示，函数调用之前`str`的内容被移动构造到`s`中，然后在函数返回时移动分配回`str`。因此，没有通过函数调用进行复制：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At first sight, it seems like this technique could be applicable to all parameters.
    However, this pattern is not always optimal, as you will see next.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这种技术似乎适用于所有参数。然而，这种模式并不总是最佳的，接下来您将看到。
- en: Cases where pass-by-value is not applicable
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不适用传值的情况
- en: 'Sometimes this pattern of accept-by-value-then-move is actually a pessimization.
    For example, consider the following class where the function `set_data()` will
    keep a copy of the argument passed to it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，接受按值然后移动的模式实际上是一种悲观化。例如，考虑以下类，其中函数`set_data()`将保留传递给它的参数的副本：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Assume we call `set_data()` and pass it an lvalue, like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们调用`set_data()`并将一个左值传递给它，就像这样：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we are passing a named object, `v`, the code will copy-construct a new
    `std::vector` object, `x`, and then move-assign that object into the `data_` member.
    Unless we pass an empty vector object to `set_data()`, the `std::vector` copy-constructor
    will perform a heap allocation for its internal buffer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们传递了一个命名对象`v`，代码将复制构造一个新的`std::vector`对象`x`，然后将该对象移动分配到`data_`成员中。除非我们将一个空的向量对象传递给`set_data()`，否则`std::vector`复制构造函数将为其内部缓冲区执行堆分配。
- en: 'Now compare this with the following version of `set_data()` optimized for lvalues:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其与`set_data()`的以下版本进行比较，该版本针对左值进行了优化：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, there will only be a heap allocation inside the assignment operator if
    the capacity of the current vector, `data_`, is smaller than the size of the source
    object, `x`. In other words, the internal pre-allocated buffer of `data_` can
    be reused in the assignment operator in many cases and save us from an extra heap
    allocation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果当前向量`data_`的容量小于源对象`x`的大小，那么赋值运算符内部将只有一个堆分配。换句话说，在许多情况下，`data_`的内部预分配缓冲区可以在赋值运算符中被重用，从而避免额外的堆分配。
- en: 'If we find it necessary to optimize `set_data()` for lvalues and rvalues, it''s
    better, in this case, to provide two overloads:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现有必要优化`set_data()`以适应lvalues和rvalues，最好在这种情况下提供两个重载：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first version is optimal for lvalues and the second version for rvalues.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本对于lvalues是最佳的，第二个版本对于rvalues是最佳的。
- en: Finally, we will now look at a scenario where we can safely pass by value without
    worrying about the pessimization just demonstrated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在将看一个场景，在这个场景中我们可以安全地传值，而不用担心刚刚演示的悲观情况。
- en: Moving constructor parameters
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动构造函数参数
- en: 'When initializing class members in a constructor, we can safely use the pass-by-value-then-move
    pattern. During the construction of a new object, there is no chance that there
    are pre-allocated buffers that could have been utilized to avoid heap allocations.
    What follows is an example of a class with one `std::vector` member and a constructor
    to demonstrate this pattern:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中初始化类成员时，我们可以安全地使用传值然后移动的模式。在构造新对象时，没有机会利用预分配的缓冲区来避免堆分配。接下来是一个具有一个`std::vector`成员和一个构造函数的类的示例，用于演示这种模式：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will now shift our focus to a topic that cannot be considered *modern C++*
    but is frequently discussed even today.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把焦点转移到一个不能被视为*现代C++*但即使在今天也经常被讨论的话题。
- en: Designing interfaces with error handling
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计带有错误处理的接口
- en: Error handling is an important and often overlooked part of the interface of
    functions and classes. Error handling is a heavily debated topic in C++, but often
    the discussions tend to focus on exceptions versus some other error mechanism.
    Although this is an interesting area, there are other aspects of error handling
    that are even more important to understand before focusing on the actual implementation
    of error handling. Obviously, both exceptions and error codes have been used in
    numerous successful software projects, and it is not uncommon to stumble upon
    projects that combine the two.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是函数和类接口中重要但经常被忽视的部分。错误处理是C++中一个备受争议的话题，但讨论往往倾向于异常与其他错误机制之间的对比。虽然这是一个有趣的领域，但在关注错误处理的实际实现之前，还有其他更重要的错误处理方面需要理解。显然，异常和错误码在许多成功的软件项目中都被使用过，而且经常会遇到将两者结合在一起的项目。
- en: A fundamental aspect of error handling, regardless of programming language,
    is to distinguish between **programming errors** (also known as bugs) and **runtime
    errors**. Runtime errors can be further divided into **recoverable runtime errors**
    and **unrecoverable runtime errors**. An example of an unrecoverable runtime error
    is *stack overflow* (see *Chapter 7*, *Memory Management*). When an unrecoverable
    error occurs, the program typically terminates immediately, so there is no point
    in signaling these types of errors. However, some errors might be considered recoverable
    in one type of application but unrecoverable in others.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 无论编程语言如何，错误处理的一个基本方面是区分**编程错误**（也称为错误）和**运行时错误**。运行时错误可以进一步分为**可恢复的运行时错误**和**不可恢复的运行时错误**。不可恢复的运行时错误的一个例子是*堆栈溢出*（见*第7章*，*内存管理*）。当发生不可恢复的错误时，程序通常会立即终止，因此没有必要发出这些类型的错误。然而，一些错误在某种类型的应用程序中可能被认为是可恢复的，但在其他应用程序中是不可恢复的。
- en: 'An edge case that often comes up when discussing recoverable and unrecoverable
    errors is the somewhat unfortunate behavior of the C++ standard library when running
    out of memory. When your program runs out of memory, this is typically unrecoverable,
    yet the standard library (tries) to throw a `std::bad_alloc` exception when this
    happens. We will not spend time on unrecoverable errors here, but the talk *De-fragmenting
    C++: Making Exceptions and RTTI More Affordable and Usable* by Herb Sutter ([https://sched.co/SiVW](https://sched.co/SiVW))
    is highly recommended if you want to dig deeper into this topic.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '讨论可恢复和不可恢复错误时经常出现的一个边缘情况是C++标准库在内存耗尽时的不太幸运的行为。当程序耗尽内存时，这通常是不可恢复的，但标准库在这种情况下会尝试抛出`std::bad_alloc`异常。我们不会在这里花时间讨论不可恢复的错误，但是Herb
    Sutter的演讲《De-fragmenting C++: Making Exceptions and RTTI More Affordable and Usable》（[https://sched.co/SiVW](https://sched.co/SiVW)）非常推荐，如果你想深入了解这个话题。'
- en: When designing and implementing an API, you should always reflect on what type
    of error you are dealing with, because errors from different categories should
    be handled in completely different ways. Deciding whether errors are programming
    errors or runtime errors can be done by using a methodology called **Design by
    Contract**; this is a topic that deserves a book on its own. However, I will here
    introduce the fundamentals, which are enough for our purposes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和实现API时，您应该始终反思您正在处理的错误类型，因为不同类别的错误应该以完全不同的方式处理。决定错误是编程错误还是运行时错误可以通过使用一种称为**设计契约**的方法来完成；这是一个值得一本书的话题。然而，我在这里将介绍足够我们目的的基本原则。
- en: There are proposals for adding language support for contracts in C++, but currently
    contracts haven't made it to the standard yet. However, many C++ APIs and guidelines
    assume that you know the basics about contracts because the terminology contracts
    use makes it easier to discuss and document interfaces of classes and functions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在C++中添加契约语言支持的提案，但目前契约尚未成为标准的一部分。然而，许多C++ API和指南都假定您了解契约的基础知识，因为契约使用的术语使得更容易讨论和记录类和函数的接口。
- en: Contracts
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 契约
- en: 'A **contract** is a set of rules between the caller of some function and the
    function itself (the callee). C++ allows us to explicitly specify some rules using
    the C++ type system. For example, consider the following function signature:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同**是调用某个函数的调用者和函数本身（被调用者）之间的一组规则。C++允许我们使用C++类型系统明确指定一些规则。例如，考虑以下函数签名：'
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It specifies that `func()` is returning an integer (unless it throws an exception),
    and that the caller has to pass two floating-point values. However, it doesn't
    say anything about what floating-point values that are allowed. For instance,
    can we pass the value 0.0 or a negative value? In addition, there might be some
    required relationship between `x` and `y` that cannot easily be expressed using
    the C++ type system. When we talk about contracts in C++, we usually refer to
    the rules that exist between a caller and a callee that cannot easily be expressed
    using the type system.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它指定`func()`返回一个整数（除非它抛出异常），并且调用者必须传递两个浮点值。但它并没有说明允许使用什么浮点值。例如，我们可以传递值0.0或负值吗？此外，`x`和`y`之间可能存在一些必需的关系，这些关系不能很容易地使用C++类型系统来表达。当我们谈论C++中的合同时，通常指的是调用者和被调用者之间存在的一些规则，这些规则不能很容易地使用类型系统来表达。
- en: 'Without being too formal, a few concepts related to Design by Contract will
    be introduced here in order to give you some terms that you can use to reason
    about interfaces and error handling:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在不太正式的情况下，这里将介绍与设计合同相关的一些概念，以便为您提供一些可以用来推理接口和错误处理的术语：
- en: '**A precondition** specifies the *responsibilities of the caller* of a function.
    There may be constraints on the parameters passed to the function. Or, if it''s
    a member function, the object might have to be in a specific state before calling
    the function. For example, the precondition when calling `pop_back()` on a `std::vector`
    is that the vector is not empty. It''s the responsibility of the *caller* of `pop_back()`
    to ensure that the vector is not empty.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前置条件指定了函数的*调用者*的*责任*。对函数传递的参数可能有约束。或者，如果它是一个成员函数，在调用函数之前对象可能必须处于特定状态。例如，在`std::vector`上调用`pop_back()`时的前置条件是向量不为空。确保向量不为空是`pop_back()`的*调用者*的责任。
- en: '**A postcondition** specifies the *responsibilities of the function* upon returning.
    If it''s a member function, in what state does the function leave the object?
    For example, the postcondition of `std::list::sort()` is that the elements in
    the list are sorted in ascending order.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后置条件指定了函数返回时的*职责*。如果它是一个成员函数，函数在什么状态下离开对象？例如，`std::list::sort()`的后置条件是列表中的元素按升序排序。
- en: '**An invariant** is a condition that should always hold true. Invariants can
    be used in many contexts. A *loop invariant* is a condition that must be true
    at the beginning of every loop iteration. Further, a *class invariant* defines
    the valid states of an object. For example, an invariant of `std::vector` is that
    `size() <= capacity()`. Explicitly stating the invariants around some code gives
    us a better understanding of the code. Invariants are also a tool that can be
    used when proving that some algorithm does what it''s supposed to do.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变量是一个应该始终成立的条件。不变量可以在许多情境中使用。循环不变量是每次循环迭代开始时必须为真的条件。此外，类不变量定义了对象的有效状态。例如，`std::vector`的不变量是`size()
    <= capacity()`。明确陈述某些代码周围的不变量使我们更好地理解代码。不变量也是一种工具，可以用来证明某些算法是否按预期运行。
- en: Class invariants are very important; we will therefore spend some more time
    discussing what they are and how they affect the design of classes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类不变量非常重要；因此，我们将花费更多时间讨论它们是什么以及它们如何影响类的设计。
- en: Class invariants
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类不变量
- en: 'As mentioned, a **class invariant** defines the valid states of an object.
    It specifies the relationship between the data members inside a class. An object
    can temporarily be in an invalid state during the time a member function is being
    executed. The important thing is that the invariant is upheld whenever the function
    passes the control to some other code that can observe the state of the object.
    This can happen when the function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**类不变量**定义了对象的有效状态。它指定了类内部数据成员之间的关系。在执行成员函数时，对象可能暂时处于无效状态。重要的是，当函数将控制权传递给可以观察对象状态的其他代码时，不变量得到维持。这可能发生在函数：
- en: Returns
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回
- en: Throws an exception
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Invokes a callback function
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用回调函数
- en: Calls some other function that might observe the state of the currently calling
    object; a common scenario is when passing a reference to `this` to some other
    function
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用可能观察当前调用对象状态的其他函数；一个常见的情况是将`this`的引用传递给其他函数
- en: 'It''s important to realize that the class invariant is an implicit part of
    the precondition and postcondition for every member function of a class. If a
    member function leaves an object in an invalid state, the postcondition has not
    been fulfilled. Similarly, a member function can always assume that the object
    is in a valid state when the function is called. The exception to this rule is
    the constructors and the destructor of a class. If we wanted to insert code to
    check that the class invariant holds true, we could do that at the following points:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到类不变量是类的每个成员函数的前置条件和后置条件的隐含部分。如果成员函数使对象处于无效状态，则未满足后置条件。类似地，成员函数在调用函数时始终可以假定对象处于有效状态。这条规则的例外是类的构造函数和析构函数。如果我们想要插入代码来检查类不变量是否成立，我们可以在以下点进行：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The copy/move constructors and copy/move assignment operators were left out
    here, but they follow the same pattern as the constructor and `some_func()`, respectively.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 复制/移动构造函数和复制/移动赋值运算符在这里没有提到，但它们遵循与构造函数和`some_func()`相同的模式。
- en: When an object has been moved from, the object might be in some empty or reset
    state. This is also a valid state of the object and is therefore part of the class
    invariant. However, usually there are only a few member functions that can be
    called when the object is in this state. For example, you cannot call `push_back()`,
    `empty()`, or `size()` on a `std::vector` that has been moved from, but you can
    call `clear()`, which will put the vector in a state where it is ready to be used
    again.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象已被移动后，对象可能处于某种空或重置状态。这也是对象的有效状态之一，因此是类不变式的一部分。然而，通常只有少数成员函数可以在对象处于此状态时调用。例如，您不能在已移动的`std::vector`上调用`push_back()`、`empty()`或`size()`，但可以调用`clear()`，这将使向量处于准备再次使用的状态。
- en: You should be aware, though, that this extra reset state makes the class invariant
    weaker and less useful. To avoid this state completely, you should implement your
    classes in such a way so that moved-from objects are reset to the state the object
    would have after default construction. My recommendation is to always do this,
    except in the very rare cases where resetting the moved-from state to the default
    state carries an unacceptable performance penalty. In that way, you can reason
    much better about moved-from states, and the class is safer to use because calling
    member functions on that object is fine.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，这种额外的重置状态使类不变式变得更弱，也更不实用。为了完全避免这种状态，您应该以这样的方式实现您的类，使得已移动的对象被重置为对象在默认构造后的状态。我的建议是总是这样做，除非在很少的情况下，将已移动的状态重置为默认状态会带来无法接受的性能损失。这样，您可以更好地推理有关已移动状态的情况，而且类的使用更安全，因为在该对象上调用成员函数是可以的。
- en: If you can ensure that an object is always in a valid state (the class invariant
    holds true), you are likely to have a class that is hard to misuse, and if you
    have bugs in the implementation, they will usually be easy to spot. The last thing
    you want is to find a class in your code base and wonder whether some behavior
    of that class is a bug or a feature. Violation of a contract is always a serious
    bug.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以确保对象始终处于有效状态（类不变式成立），那么您可能会拥有一个难以被误用的类，如果实现中存在错误，通常很容易发现。您最不希望的是在代码库中找到一个类，并想知道该类的某些行为是一个错误还是一个特性。违反合同始终是一个严重的错误。
- en: In order to be able to write meaningful class invariants, we are required to
    write classes with high cohesion and with few possible states. If you have ever
    written a unit test for a class that you have authored yourself, you have probably
    noticed that while writing the unit test, it became clear that the API could be
    improved from the initial version. A unit test forces you to use and reflect on
    the interface of the class rather than the implementation details. In the same
    way, a class invariant makes you think about all the valid states an object could
    be in. If you find it hard to define a class invariant, it's usually because your
    class has too many responsibilities and handles too many states. Therefore, defining
    class invariants usually means that you end up with well-designed classes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够编写有意义的类不变式，我们需要编写具有高内聚性和少可能状态的类。如果您曾经为自己编写的类编写单元测试，您可能会注意到，在编写单元测试时，很明显可以从初始版本改进API。单元测试迫使您使用和反思类的接口而不是实现细节。同样，类不变式使您考虑对象可能处于的所有有效状态。如果您发现很难定义类不变式，通常是因为您的类承担了太多的责任并处理了太多的状态。因此，定义类不变式通常意味着您最终会得到设计良好的类。
- en: Maintaining contracts
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护合同
- en: 'Contracts are parts of the API that you design and implement. But how do you
    maintain and communicate a contract to the clients using your API? C++ has no
    built-in support for contracts yet, but there is ongoing work to add it to future
    versions of C++. There are some options, though:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 合同是您设计和实现的API的一部分。但是，您如何维护和向使用您的API的客户端传达合同呢？C++尚没有内置支持合同的功能，但正在进行工作以将其添加到未来的C++版本中。不过，也有一些选择：
- en: Use a library such as Boost.Contract.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如Boost.Contract之类的库。
- en: Document the contracts. This has the disadvantage that the contracts are not
    checked when running the program. Also, documentation tends to be outdated when
    the code changes.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录合同。这样做的缺点是在运行程序时不会检查合同。此外，文档往往在代码更改时过时。
- en: Use `static_assert()` and the `assert()` macro defined in `<cassert>`. Asserts
    are portable, standard C++.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`static_assert()`和`<cassert>`中定义的`assert()`宏。断言是可移植的，标准的C++。
- en: Build a custom library with custom macros similar to asserts but with better
    control of the behavior of failed contracts.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个自定义库，其中包含类似断言的自定义宏，但对失败合同的行为具有更好的控制。
- en: In this book, we will use asserts, one of the most primitive ways of checking
    for contract violations. Still, asserts can be very effective and have an enormous
    impact on code quality.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用断言，这是检查合同违规的最原始的方式之一。然而，断言可以非常有效，并对代码质量产生巨大影响。
- en: Enabling and disabling asserts
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用和禁用断言
- en: 'Technically, we have two standard ways to assert things in C++: using `static_assert()`
    or the `assert()` macro from the `<cassert>` header. `static_assert()` is validated
    during the compilation of the code, and therefore requires an expression that
    can be checked during compile time rather than runtime. A failed `static_assert()`
    results in a compilation error.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在C++中有两种标准的断言方式：使用`<cassert>`头文件中的`static_assert()`或`assert()`宏。`static_assert()`在代码编译期间进行验证，因此需要一个可以在编译时而不是运行时进行检查的表达式。失败的`static_assert()`会导致编译错误。
- en: 'For asserts that can only be evaluated during runtime, you need to use the
    `assert()` macro instead. The `assert()` macro is a runtime check that is typically
    active during debugging and testing, and completely disabled when the program
    is built in release mode. The `assert()` macro is typically defined something
    like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只能在运行时评估的断言，您需要使用`assert()`宏。`assert()`宏是一种运行时检查，通常在调试和测试期间处于活动状态，并在以发布模式构建程序时完全禁用。`assert()`宏通常定义如下：
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This means that you can completely remove all the asserts and the code for checking
    the conditions by defining `NDEBUG`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以通过定义`NDEBUG`完全删除所有断言和用于检查条件的代码。
- en: Now, with some terminology from Design by Contract under your belt, let's focus
    on contract violations (errors) and how to handle them in your code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了一些设计合同的术语，让我们专注于合同违反（错误）以及如何在您的代码中处理它们。
- en: Error handling
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: The first thing to do when designing APIs with proper error handling is to distinguish
    between programming errors and runtime errors. So, before we dive into error handling
    strategies, we will use Design by Contract to define what type of error we are
    dealing with.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计具有适当错误处理的API时，首先要做的是区分编程错误和运行时错误。因此，在我们深入讨论错误处理策略之前，我们将使用设计合同来定义我们正在处理的错误类型。
- en: Programming error or runtime error?
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程错误还是运行时错误？
- en: If we find a violation of a contract, we have also found an error in our program.
    For example, if we can detect that someone is calling `pop_back()` on an empty
    vector, we know that there is at least one bug in our source code that needs to
    be fixed. Whenever a precondition is not met, we know we are dealing with a *programming
    error*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现合同违反，我们也发现了我们程序中的错误。例如，如果我们可以检测到有人在空向量上调用`pop_back()`，我们知道我们的源代码中至少有一个错误需要修复。每当前提条件不满足时，我们知道我们正在处理一个*编程错误*。
- en: 'On the other hand, if we have a function that loads some record from disk and
    cannot return the record because of a read error on the disk, then we have detected
    a *runtime error*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个从磁盘加载某个记录的函数，并且由于磁盘上的读取错误而无法返回记录，那么我们已经检测到了一个*运行时错误*：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The precondition is fulfilled, but the postcondition cannot be met because of
    something outside of our program. There is no bug in the source code, but the
    function cannot return the record found on disk because of some disk-related error.
    Since the postcondition cannot be fulfilled, a runtime error has to be reported
    back to the caller, unless the caller can recover from it itself by retrying and
    so on.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件得到满足，但由于程序外部的某些原因，后置条件无法满足。源代码中没有错误，但由于某些与磁盘相关的错误，函数无法返回在磁盘上找到的记录。由于无法满足后置条件，必须将运行时错误报告给调用者，除非调用者可以自行通过重试等方式恢复。
- en: Programming errors (bugs)
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程错误（错误）
- en: In general, there is no point in writing code that signals and handles bugs
    in your code. Instead, use asserts (or some of the other alternatives mentioned
    previously) to make the developer aware of issues in the code. You should only
    use exceptions or error codes for recoverable runtime errors.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，编写代码来发出并处理代码中的错误没有意义。相反，使用断言（或先前提到的其他一些替代方案）来使开发人员意识到代码中的问题。您应该只对可恢复的运行时错误使用异常或错误代码。
- en: Narrowing the problem space by assumptions
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过假设缩小问题空间
- en: An assert specifies what assumptions you, as the author of some code, have made.
    You can only guarantee that the code works as intended if all the asserts in your
    code hold true. This makes coding much easier because you can effectively limit
    the amount of cases that you need to handle. Asserts are also a tremendous help
    for your team when using, reading, and modifying code written by you. All the
    assumptions are clearly documented in the form of assert statements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 断言指定了您作为某些代码的作者所做的假设。只有在您的代码中的所有断言都为真时，您才能保证代码按预期工作。这使编码变得更容易，因为您可以有效地限制需要处理的情况数量。断言在您的团队使用、阅读和修改您编写的代码时也是巨大的帮助。所有假设都以断言语句的形式清楚地记录下来。
- en: Finding bugs with asserts
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用断言查找错误
- en: 'A failed assert is always a serious bug. There are basically three options
    when you find an assert that fails during testing:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的断言总是严重的错误。当您在测试过程中发现一个失败的断言时，基本上有三种选择：
- en: The assert is correct, but the code is wrong (either because of a bug in the
    implementation of the function, or a bug on the call-site). In my experience,
    this is the most common case. Getting the asserts correct is usually easier than
    getting the code around them correct. Fix the code and test again.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言是正确的，但代码是错误的（要么是因为函数实现中的错误，要么是因为调用站点上的错误）。根据我的经验，这是最常见的情况。通常情况下，使断言正确比使其周围的代码正确要容易得多。修复代码并重新测试。
- en: The code is correct, but the assert is wrong. Sometimes this happens and it
    is usually pretty uncomfortable if you are looking at old code. Changing or removing
    an assert that fails can be time consuming because you need to be 100% sure that
    the code actually works and understand why an old assert has suddenly started
    to fail. Usually, this is because of a new use case that the original authors
    did not think about.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是正确的，但断言是错误的。有时会发生这种情况，如果您看的是旧代码，通常会感到非常不舒服。更改或删除失败的断言可能会耗费时间，因为您需要确保代码实际上是有效的，并理解为什么旧断言突然开始失败。通常，这是因为原始作者没有考虑到一个新的用例。
- en: Both the assert and the code are wrong. This usually requires a redesign of
    the class or function. Maybe the requirements have changed, and the assumptions
    made by the programmer are no longer true. But don't despair; instead, you should
    be glad that those assumptions were explicitly written using asserts; now you
    know why the code is not working anymore.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言和代码都是错误的。这通常需要重新设计类或函数。也许要求已经改变，程序员所做的假设不再成立。但不要绝望；相反，您应该高兴那些假设是明确地使用断言写出来的；现在您知道为什么代码不再起作用了。
- en: Runtime asserts require testing, otherwise the asserts will not be exercised.
    Newly written code with many asserts usually breaks when testing. This doesn't
    mean that you are a bad programmer; it means that you have added meaningful asserts
    that catch some of the errors that otherwise could have made it to production.
    Also, bugs that make a test version of your program terminate are also likely
    to be fixed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时断言需要测试，否则断言将不会被执行。新编写的带有许多断言的代码通常在测试时会出现故障。这并不意味着您是一个糟糕的程序员；这意味着您添加了有意义的断言，可以捕获一些本来可能会进入生产的错误。此外，使测试版本的程序终止的错误也很可能会被修复。
- en: Performance impact
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能影响
- en: Having many runtime asserts in your code will most likely degrade the performance
    of your test builds. However, asserts are never meant to be used in the final
    version of your optimized program. If your asserts make your test build too slow
    to be usable, finding the set of asserts that slows down your code is usually
    easy to track in a profiler (see *Chapter 3*, *Analyzing and Measuring Performance*,
    for more info about profiling).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中有许多运行时断言很可能会降低测试构建的性能。然而，断言从不应该在优化程序的最终版本中使用。如果您的断言使您的测试构建速度太慢而无法使用，通常很容易在分析器中跟踪到减慢代码速度的断言集（有关分析器的更多信息，请参见*第3章*，*分析和测量性能*）。
- en: By having the release build of your program completely ignore all sorts of programming
    errors, your program will not spend time checking error states caused by bugs.
    Instead, your code will run faster and only spend time solving the actual problem
    it was meant to solve. It will only check for runtime errors that need to be recovered.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使程序的发布构建完全忽略由错误引起的错误状态，程序将不会花时间检查由错误引起的错误状态。相反，您的代码将运行得更快，只花时间解决它本来要解决的实际问题。它只会检查需要恢复的运行时错误。
- en: To summarize, programming errors should be detected when testing the program.
    There is no need to use exceptions or some other error handling mechanism for
    dealing with programming errors. Instead, a programming error should preferably
    log something meaningful and terminate the program to inform the programmer that
    the bug needs to be fixed. Following this guideline dramatically reduces the number
    of places we need to handle exceptions in our code. We will have better performance
    in our optimized build and hopefully fewer bugs since they have been detected
    by failed asserts. However, there are situations where errors can occur at runtime,
    and those errors need to be handled and recovered by the code we implement.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，编程错误应该在测试程序时被检测出来。没有必要使用异常或其他错误处理机制来处理编程错误。相反，编程错误应该记录一些有意义的东西，并终止程序，以通知程序员需要修复错误。遵循这一准则显著减少了我们需要在代码中处理异常的地方。我们在优化构建中会有更好的性能，希望由于断言失败而检测到的错误会更少。然而，有些情况下可能会发生运行时错误，这些错误需要被我们实现的代码处理和恢复。
- en: Recoverable runtime errors
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可恢复的运行时错误
- en: 'If a function cannot uphold its part of the contract (the postcondition, that
    is), a runtime error has occurred and needs to be signaled to some place in the
    code that can handle it and recover the valid state. The purpose of handling recoverable
    errors is to pass an error from the place where the error occurred to the place
    where the valid state can be recovered. There are many ways to achieve this. There
    are two sides of this coin:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数无法履行其合同的一部分（即后置条件），则发生了运行时错误，需要将其通知到可以处理并恢复有效状态的代码中。处理可恢复错误的目的是将错误从发生错误的地方传递到可以恢复有效状态的地方。有许多方法可以实现这一点。这是一个硬币的两面：
- en: For the signaling part we can choose between C++ exceptions, error codes, returning
    a `std::optional` or `std::pair`, or using `boost::outcome` or `std::experimental::expected`.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于信号部分，我们可以选择C++异常、错误代码、返回`std::optional`或`std::pair`，或使用`boost::outcome`或`std::experimental::expected`。
- en: Preserving the valid state of the program without leaking any resources. Deterministic
    destructors and automatic storage duration are the tools that make this possible
    in C++.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持程序的有效状态而不泄漏任何资源。确定性析构函数和自动存储期是C++中使这成为可能的工具。
- en: The utility classes `std::optional` and `std::pair` will be covered in *Chapter
    9*, *Essential Utilities*. We will now focus on C++ exceptions and how to avoid
    leaking resources when recovering from an error.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 实用类`std::optional`和`std::pair`将在*第9章*，*基本实用程序*中介绍。现在我们将专注于C++异常以及如何在从错误中恢复时避免泄漏资源。
- en: Exceptions
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions are the standard error handling mechanism provided by C++. The language
    was designed to be used with exceptions. One example of this is constructors that
    fail; the only way to signal errors from constructors is by using exceptions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是C++提供的标准错误处理机制。该语言设计用于与异常一起使用。一个例子是构造函数失败；从构造函数中发出错误的唯一方法是使用异常。
- en: In my experience, exceptions are used in many different ways. One reason for
    this is that distinct applications can have vastly different requirements when
    dealing with runtime errors. With some applications, such as a pacemaker or a
    power plant control system, which may have a severe impact if they crash, we may
    have to deal with every possible exceptional circumstance, such as running out
    of memory, and keep the application in a running state. Some applications even
    completely stay away from using the heap memory, either because the platform doesn't
    have any heap available at all, or because the heap introduces an uncontrollable
    level of uncertainty as the mechanics of allocating new memory are out of the
    application's control.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，异常以许多不同的方式使用。造成这种情况的一个原因是不同的应用在处理运行时错误时可能有非常不同的要求。对于一些应用，比如起搏器或发电厂控制系统，如果它们崩溃可能会产生严重影响，我们可能必须处理每种可能的异常情况，比如内存耗尽，并保持应用程序处于运行状态。有些应用甚至完全不使用堆内存，要么是因为平台根本没有可用的堆，要么是因为堆引入了无法控制的不确定性，因为分配新内存的机制超出了应用程序的控制。
- en: I assume that you already know the syntax of throwing and catching exceptions
    and will not cover it here. A function that is guaranteed to not throw an exception
    can be marked as `noexcept`. It's important to understand that the compiler does
    *not* verify this; instead, it is up to the author of the code to figure out whether
    their function could throw an exception.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您已经知道抛出和捕获异常的语法，并且不会在这里涵盖它。可以标记为`noexcept`的函数保证不会抛出异常。重要的是要理解编译器*不*验证这一点；相反，这取决于代码的作者来弄清楚他们的函数是否可能抛出异常。
- en: 'A function marked with `noexcept` makes it possible for the compiler to generate
    faster code in some cases. If an exception would be thrown from a function marked
    with `noexcept`, the program will call `std::terminate()` instead of unwinding
    the stack. The following code demonstrates how to mark a function as not throwing:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`noexcept`的函数在某些情况下可以使编译器生成更快的代码。如果从标记为`noexcept`的函数中抛出异常，程序将调用`std::terminate()`而不是展开堆栈。以下代码演示了如何将函数标记为不抛出异常：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You may notice that many code examples in this book don't use `noexcept` (or
    `const`) even if it would have been appropriate in production code. This is only
    because of the format of a book; it would make the code hard to read to add `noexcept`
    and `const` at all the places that I normally would.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，本书中的许多代码示例即使在生产代码中也适用`noexcept`（或`const`），也没有使用。这仅仅是因为书的格式；如果在我通常会添加`noexcept`和`const`的所有地方添加它们，会使代码难以阅读。
- en: Preserving the valid state
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保持有效状态
- en: Exception handling requires us programmers to think about exception safety guarantees;
    that is, what is the program state before and after an exception has occurred?
    Strong exception safety can be seen as a transaction. A function either commits
    all state changes, or performs a complete rollback in the case of an exception.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理要求我们程序员考虑异常安全性保证；也就是说，在异常发生之前和之后程序的状态是什么？强异常安全性可以被视为一个事务。一个函数要么提交所有状态更改，要么在发生异常时执行完全回滚。
- en: 'To make this a bit more concrete, let''s take a look at the following simple
    function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更具体化，让我们来看一个简单的函数：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The function appends the result of `f1()` and `f2()` to the string, `str`.
    Now consider what would happen if an exception was thrown when calling the function
    `f2()`; only the result from `f1()` would be appended to `str`. What we want instead
    is to have `str` untouched if an exception occurs. This can be fixed by using
    an idiom called **copy-and-swap**. It means that we perform the operations that
    might throw exceptions on temporary copies before we let the application''s state
    be modified by non-throwing `swap()` functions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将`f1()`和`f2()`的结果附加到字符串`str`。现在考虑一下，如果调用函数`f2()`时抛出异常会发生什么；只有`f1()`的结果会附加到`str`。相反，我们希望在发生异常时`str`保持不变。这可以通过使用一种称为**复制和交换**的惯用法来解决。这意味着我们在让应用程序状态被非抛出`swap()`函数修改之前，在临时副本上执行可能引发异常的操作：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The same pattern can be used in member functions to preserve the valid state
    of an object. Let''s say we have a class with two data members and a class invariant
    that says that the data members cannot compare equal, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的模式可以在成员函数中使用，以保持对象的有效状态。假设我们有一个类，其中包含两个数据成员和一个类不变式，该不变式规定数据成员不能相等，如下所示：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, assume we are adding a member function that updates both data members,
    like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们正在添加一个成员函数，该函数更新两个数据成员，如下所示：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The precondition states that `x` and `y` must not compare equal. If the assignment
    of `x_` and `y_` can throw, `x_` might be updated but not `y_`. This may result
    in a broken class invariant; that is, an object in an invalid state. We want the
    function to preserve the valid state of the object it had before the assignment
    operations if an error occurs. Again, one possible solution is to use the copy-and-swap
    idiom:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件规定`x`和`y`不能相等。如果`x_`和`y_`的赋值可能会抛出异常，`x_`可能会被更新，但`y_`不会。这可能导致破坏类不变式；也就是说，对象处于无效状态。如果发生错误，我们希望函数保持对象在赋值操作之前的有效状态。再次，一个可能的解决方案是使用复制和交换惯用法：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: First, local copies are created without modifying the state of the object. Then,
    if no exception has been thrown, the state of the object can be changed using
    a non-throwing `swap()`. The copy-and-swap idiom can also be used when implementing
    assignment operators to achieve strong exception safety guarantees.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建本地副本，而不修改对象的状态。然后，如果没有抛出异常，可以使用非抛出`swap()`来更改对象的状态。复制和交换惯用法也可以在实现赋值运算符时使用，以实现强异常安全性保证。
- en: Another important aspect of error handling is to avoid leaking resources when
    an error occurs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的另一个重要方面是避免在发生错误时泄漏资源。
- en: Resource acquisition
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源获取
- en: 'The destruction of C++ objects is predictable, meaning that we have full control
    over when, and in what order, resources that we have acquired are released. This
    is further illustrated in the following example, where the mutex variable `m`
    is always unlocked when exiting the function, as the scoped lock releases it when
    we exit the scope, regardless of how and where we exit:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: C++对象的销毁是可预测的，这意味着我们完全控制我们何时以及以何种顺序释放我们获取的资源。在下面的示例中进一步说明了这一点，当退出函数时，互斥变量`m`总是被解锁，因为作用域锁在我们退出作用域时释放它，无论我们如何以及在何处退出：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Ownership, lifetime of objects, and resource acquisition are fundamental concepts
    in C++, and we will cover them in *Chapter 7*, *Memory Management*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权、对象的生命周期和资源获取是C++中的基本概念，我们将在*第7章* *内存管理*中进行讨论。
- en: Performance
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能
- en: 'Unfortunately, exceptions have a bad reputation when it comes to performance.
    Some concerns are legitimate, whereas some are based on historical observations
    when exceptions were not implemented efficiently by the compilers. However, today
    there are two main reasons why people abandon exceptions:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，异常在性能方面声誉不佳。一些担忧是合理的，而一些是基于历史观察的，当时编译器没有有效地实现异常。然而，今天人们放弃异常的两个主要原因是：
- en: The size of the binary program is increased even if exceptions are not being
    thrown. Even though this is usually not an issue, it doesn't follow the zero-overhead
    principle since we are paying for something that we don't use.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使不抛出异常，二进制程序的大小也会增加。尽管这通常不是问题，但它并不遵循零开销原则，因为我们为我们不使用的东西付费。
- en: Throwing and catching exceptions is relatively expensive. The runtime cost of
    throwing and catching exceptions is not deterministic. This makes exceptions unsuitable
    in contexts with hard real-time requirements. In this case, other alternatives
    such as returning a `std::pair` with a return value and an error code might better.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出和捕获异常相对昂贵。抛出和捕获异常的运行时成本是不确定的。这使得异常在具有硬实时要求的情况下不适用。在这种情况下，其他替代方案，如返回带有返回值和错误代码的`std::pair`可能更好。
- en: On the other hand, exceptions perform outstandingly when no exceptions are being
    thrown; that is, when the program follows the success path. Other error reporting
    mechanisms such as error codes require checking return codes in `if-else` statements
    even when the program runs without any errors.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当没有抛出异常时，异常的性能表现非常出色；也就是说，当程序遵循成功路径时。其他错误报告机制，如错误代码，即使在程序没有任何错误时也需要在`if-else`语句中检查返回代码。
- en: Exceptions should happen rarely, and typically when an exception occurs, the
    extra performance penalty that exception handling adds is usually not an issue
    in those situations. It's usually possible to perform computations that could
    potentially throw before or after some performance-critical code runs. In that
    way, we can avoid having exceptions thrown and caught at the places in our program
    where we cannot afford to have exceptions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 异常情况应该很少发生，通常当异常发生时，异常处理所增加的额外性能损耗通常不是这些情况的问题。通常可以在一些性能关键代码运行之前或之后执行可能引发异常的计算。这样，我们可以避免在程序中不能容忍异常的地方抛出和捕获异常。
- en: To make a fair comparison between exceptions and some other error reporting
    mechanism, it's important to specify what to compare. Sometimes exceptions are
    compared with no error handling at all, which is unfair; exceptions need to be
    compared with a mechanism that offers the same functionality, of course. Don't
    abandon exceptions for performance reasons before you have measured the impact
    they might have. You can read more about analyzing and measuring performance in
    the next chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公平比较异常和其他错误报告机制，重要的是要指定要比较的内容。有时异常与根本没有错误处理的情况进行比较是不公平的；异常需要与提供相同功能的机制进行比较。在你测量它们可能产生的影响之前，不要因为性能原因而放弃异常。你可以在下一章中了解更多关于分析和测量性能的内容。
- en: Now we will move away from error handling and explore how we can use lambda
    expressions to create function objects.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将远离错误处理，探讨如何使用lambda表达式创建函数对象。
- en: Function objects and lambda expressions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象和lambda表达式
- en: Lambda expressions, introduced in C++11, and further enhanced with every C++
    version since, are one of the most useful features in modern C++. Their versatility
    comes not only from easily passing functions to algorithms, but also their use
    in a lot of circumstances where you need to pass the code around, especially as
    you can store a lambda in a `std::function`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式，引入于C++11，并在每个C++版本中进一步增强，是现代C++中最有用的功能之一。它们的多功能性不仅来自于轻松地将函数传递给算法，还来自于在许多需要传递代码的情况下的使用，特别是可以将lambda存储在`std::function`中。
- en: Although lambdas made these programming techniques vastly simpler to work with,
    everything mentioned in this section is possible to perform without them. A lambda—or,
    more formally, a lambda expression—is a convenient way of constructing a function
    object. But instead of using lambda expressions, we could instead implement classes
    with `operator()` overloaded, and then instantiate these to create function objects.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管lambda使得这些编程技术变得更加简单易用，但本节提到的所有内容都可以在没有lambda的情况下执行。lambda，或者更正式地说，lambda表达式是构造函数对象的一种便捷方式。但是，我们可以不使用lambda表达式，而是实现重载了`operator()`的类，然后实例化这些类来创建函数对象。
- en: We will explore the lambda's similarities to these kinds of classes later, but
    first I will introduce lambda expressions in a simple use case.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后探讨lambda与这些类的相似之处，但首先我将在一个简单的用例中介绍lambda表达式。
- en: The basic syntax of a C++ lambda
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ lambda的基本语法
- en: In a nutshell, lambdas enable programmers to pass functions to other functions,
    just as easily as a variable is passed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，lambda使程序员能够像传递变量一样轻松地将函数传递给其他函数。
- en: 'Let''s compare passing a lambda to an algorithm with passing a variable:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较将lambda传递给算法和将变量传递给算法：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the first case, we pass a variable to `std::count()`, and in the latter case
    we pass a function object to `std::count_if()`. This is a typical use case for
    lambdas; we pass a function to be evaluated many times by another function (in
    this case, `std::count_if()`).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们将一个变量传递给`std::count()`，而在后一种情况下，我们将一个函数对象传递给`std::count_if()`。这是lambda的典型用例；我们传递一个函数，由另一个函数（在本例中是`std::count_if()`）多次评估。
- en: 'Also, the lambda does not need to be tied to a variable; just as we can put
    a variable right into an expression, we can do the same with a lambda:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，lambda不需要与变量绑定；就像我们可以将变量直接放入表达式中一样，我们也可以将lambda放入表达式中：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The lambdas you have seen so far are called **stateless lambdas**; they don't
    copy or reference any variables from outside the lambda and therefore don't need
    any internal state. Let's make this a little more advanced by introducing **stateful
    lambdas** by using capture blocks.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你看到的lambda被称为**无状态lambda**；它们不复制或引用lambda外部的任何变量，因此不需要任何内部状态。让我们通过使用捕获块引入**有状态lambda**来使其更加高级。
- en: The capture clause
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获子句
- en: 'In the previous example, we hard-coded the value `3` inside the lambda so that
    we always counted the numbers greater than three. What if we want to use external
    variables inside the lambda? What we do is capture the external variables by putting them in
    the **capture clause**; that is, the `[]` part of the lambda:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在lambda中硬编码了值`3`，以便我们始终计算大于三的数字。如果我们想在lambda中使用外部变量怎么办？我们通过将外部变量放入**捕获子句**（即lambda的`[]`部分）来捕获外部变量：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this example, we captured the variable `x` by copying it into the lambda.
    If we want to declare `x` as a reference, we put an `&` at the beginning, like
    this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将变量`x`复制到lambda中来捕获它。如果我们想要将`x`声明为引用，我们在开头加上`&`，像这样：
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The variable is now merely a reference to the outer `x` variable, just like
    a regular reference variable in C++. Of course, we need to be very cautious about
    the lifetime of objects we pass by reference into a lambda since the lambda might
    execute in a context where the referenced objects have ceased to exist. It's therefore
    safer to capture by value.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量现在只是外部`x`变量的引用，就像C++中的常规引用变量一样。当然，我们需要非常小心引用到lambda中的对象的生命周期，因为lambda可能在引用的对象已经不存在的情况下执行。因此，通过值捕获更安全。
- en: Capture by reference versus capture by value
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过引用捕获与通过值捕获
- en: 'Using the capture clause for referencing and copying variables works just like
    regular variables. Take a look at these two examples and see if you can spot the
    difference:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用捕获子句引用和复制变量的工作方式与常规变量一样。看看这两个例子，看看你能否发现区别：
- en: '| Capture by value | Capture by reference |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 通过值捕获 | 通过引用捕获 |'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In the first example, `x` was *copied* into the lambda and was therefore not
    affected when `x` was mutated; consequently `std::count_if()` counts the number
    of values above 3.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`x`被*复制*到lambda中，因此当`x`被改变时不受影响；因此`std::count_if()`计算的是大于3的值的数量。
- en: In the second example, `x` was *captured by reference*, and therefore `std::count_if()`
    instead counts the number of values above 4.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，`x`被*引用捕获*，因此`std::count_if()`实际上计算的是大于4的值的数量。
- en: Similarities between a lambda and a class
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lambda和类之间的相似之处
- en: I mentioned earlier that lambda expressions generate function objects. A function
    object is an instance of a class that has the call operator, `operator()()`, defined.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，lambda表达式生成函数对象。函数对象是一个具有调用运算符`operator()()`定义的类的实例。
- en: 'To understand what a lambda expression consists of, you can view it as a regular
    class with restrictions:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解lambda表达式的组成，你可以将其视为具有限制的常规类：
- en: The class only consists of one member function
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类只包含一个成员函数
- en: The capture clause is a combination of the class' member variables and its constructor
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获子句是类的成员变量和其构造函数的组合
- en: 'The following table shows lambda expressions and the corresponding classes.
    The left column uses *capture by value* and the right column *c**apture by reference*:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了lambda表达式和相应的类。左列使用*通过值捕获*，右列使用*通过引用捕获*：
- en: '| A lambda with capture by value… | A lambda with capture by reference... |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 通过值捕获的lambda... | 通过引用捕获的lambda... |'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE69]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ...corresponds to this class: | ...corresponds to this class: |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| ...对应于这个类：| ...对应于这个类：|'
- en: '|'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Thanks to lambda expressions, we don't have to manually implement these function
    object types as classes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda表达式，我们不必手动实现这些函数对象类型作为类。
- en: Initializing variables in capture
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化捕获变量
- en: 'As seen in the previous example, the capture clause initializes member variables
    in the corresponding class. This means that we can also initialize member variables
    inside a lambda. These variables will only be visible from inside the lambda.
    Here is an example of a lambda that initializes a capture variable called `numbers`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，捕获子句初始化了相应类中的成员变量。这意味着我们也可以在lambda中初始化成员变量。这些变量只能在lambda内部可见。下面是一个初始化名为`numbers`的捕获变量的lambda的示例：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The corresponding class would look something like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的类看起来像这样：
- en: '[PRE74]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When initializing a variable inside a capture, you can imagine that there is
    a hidden `auto` keyword in front of the variable name. In this case, you can think
    about `numbers` as being defined like `auto numbers = std::list<int>{4, 2}`. If
    you want to initialize a reference, you can use an ampersand in front of the name,
    which would correspond to `auto&`. Here is an example:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获中初始化变量时，你可以想象在变量名前面有一个隐藏的`auto`关键字。在这种情况下，你可以将`numbers`视为被定义为`auto numbers
    = std::list<int>{4, 2}`。如果你想初始化一个引用，你可以在名称前面使用一个`&`，这对应于`auto&`。下面是一个例子：
- en: '[PRE75]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Again, you have to be very cautious about lifetimes when referencing (and not
    copying) objects outside the lambda.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当引用（而不是复制）lambda外部的对象时，你必须非常小心对象的生命周期。
- en: 'It''s also possible to move an object inside a lambda, which is necessary when
    using move-only types such as `std::unique_ptr`. Here is how it can be done:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda中也可以移动对象，这在使用`std::unique_ptr`等移动类型时是必要的。以下是如何实现的：
- en: '[PRE76]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This also demonstrates that it is possible to use the same name (`x`) for the
    variable. This is not necessary. Instead, we could have used some other name inside
    the lambda, for example `[y = std::move(x)]`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这也表明在lambda中使用相同的名称（`x`）是可能的。这并非必须。相反，我们可以在lambda内部使用其他名称，例如`[y = std::move(x)]`。
- en: Mutating lambda member variables
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变lambda成员变量
- en: 'As the lambda works just like a class with member variables, it can also mutate
    them. However, the function call operator of a lambda is `const` by default, so
    we explicitly need to specify that the lambda can mutate its members by using
    the `mutable` keyword. In the following example, the lambda mutates the `counter`
    variable every time it''s invoked:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda的工作方式就像一个具有成员变量的类，它也可以改变它们。然而，lambda的函数调用运算符默认为`const`，因此我们需要使用`mutable`关键字明确指定lambda可以改变其成员。在下面的示例中，lambda在每次调用时改变`counter`变量：
- en: '[PRE77]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If a lambda only captures variables by reference, we do not have to add the
    `mutable` modifier to the declaration, as the lambda itself doesn''t mutate. The
    difference between mutable and non-mutable lambdas is demonstrated in the following
    code snippets:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果lambda只通过引用捕获变量，我们不必在声明中添加`mutable`修饰符，因为lambda本身不会改变。可变和不可变lambda之间的区别在下面的代码片段中进行了演示：
- en: '| Capture by value | Capture by reference |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 通过值捕获 | 通过引用捕获 |'
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE78]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE79]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Output: `7 8 7` | Output: `7 8 9` |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 输出：`7 8 7` | 输出：`7 8 9` |'
- en: In the example to the right where `v` is captured by reference, the lambda will
    mutate the variable `v`, which is owned by the scope of `some_func()`. The mutating
    lambda in the left column will only mutate a copy of `v`, owned by the lambda
    itself. This is the reason why we will end up with different outputs in the two
    versions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的示例中，`v`被引用捕获，lambda将改变`some_func()`作用域拥有的变量`v`。左侧列中的可变lambda只会改变lambda本身拥有的`v`的副本。这就是为什么我们会得到两个版本中不同的输出的原因。
- en: Mutating member variables from the compiler's perspective
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从编译器的角度改变成员变量
- en: 'To understand what''s going on in the preceding example, take a look at how
    the compiler sees the previous lambda objects:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解前面示例中发生了什么，看一下编译器如何看待前面的lambda对象：
- en: '| Capture by value | Capture by reference |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 通过值捕获 | 通过引用捕获 |'
- en: '|'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE80]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE81]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: As you can see, the first case corresponds to a class with a regular member,
    whereas the capture by reference case simply corresponds to a class where the
    member variable is a reference.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第一种情况对应于具有常规成员的类，而通过引用捕获的情况只是对应于成员变量是引用的类。
- en: You might have noticed that we add the modifier `const` on the `operator()`
    member function of the capture by reference class, and we also do not specify
    `mutable` on the corresponding lambda. The reason this class is still considered
    `const` is that we do not mutate anything inside the actual class/lambda; the
    actual mutation applies to the referenced value, and therefore the function is
    still considered `const`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在通过引用捕获类的`operator()`成员函数上添加了`const`修饰符，并且在相应的lambda上也没有指定`mutable`。这个类仍然被认为是`const`的原因是我们没有在实际的类/lambda内部改变任何东西；实际的改变应用于引用的值，因此函数仍然被认为是`const`的。
- en: Capture all
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获所有
- en: In addition to capturing variables one by one, all variables in the scope can
    be captured by simply writing `[=]` or `[&]`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 除了逐个捕获变量，还可以通过简单地写`[=]`或`[&]`来捕获作用域中的所有变量。
- en: Using `[=]` means that every variable will be captured by value, whereas `[&]`
    captures all variables by reference.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[=]`意味着每个变量都将被值捕获，而`[&]`则通过引用捕获所有变量。
- en: 'If we use lambdas inside a member function, it is also possible to capture
    the entire object by reference using `[this]` or by copy by writing `[*this]`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在成员函数内部使用lambda，也可以通过使用`[this]`来通过引用捕获整个对象，或者通过写`[*this]`来通过复制捕获整个对象：
- en: '[PRE82]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note that using `[=]` does not mean that all variables in the scope are copied
    into the lambda; only the variables actually used inside the lambda are copied.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`[=]`并不意味着作用域内的所有变量都会被复制到lambda中；只有实际在lambda内部使用的变量才会被复制。
- en: 'When capturing all variables by value, you can specify variables to be captured
    by reference (and vice versa). The following table shows the result of different
    combinations in the capture block:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过值捕获所有变量时，可以指定通过引用捕获变量（反之亦然）。以下表格显示了捕获块中不同组合的结果：
- en: '| Capture block | Resulting capture types |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 捕获块 | 结果捕获类型 |'
- en: '|'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE83]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '| Capture `a`, `b`, `c` by value. |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 通过值捕获`a`、`b`、`c`。|'
- en: '|'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE84]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '| Capture `a`, `b`, `c` by reference. |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 通过引用捕获`a`、`b`、`c`。|'
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE85]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '| Capture `a`, `b` by value.Capture `c` by reference. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 通过值捕获`a`、`b`。通过引用捕获`c`。|'
- en: '|'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE86]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '| Capture `a`, `b` by reference.Capture `c` by value. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 通过引用捕获`a`、`b`。通过值捕获`c`。|'
- en: Although it is convenient to capture all variables with `[&]` or `[=]`, I recommend
    capturing variables one by one, as it improves the readability of the code by
    clarifying exactly which variables are used inside the lambda scope.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`[&]`或`[=]`捕获所有变量很方便，但我建议逐个捕获变量，因为这样可以通过明确指出lambda作用域内使用了哪些变量来提高代码的可读性。
- en: Assigning C function pointers to lambdas
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将C函数指针分配给lambda
- en: 'Lambdas without captures can be implicitly converted to function pointers.
    Let''s say you are using a C library, or an older C++ library, that uses a callback
    function as a parameter, like this:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 没有捕获的lambda可以隐式转换为函数指针。假设你正在使用一个C库，或者一个旧的C++库，它使用回调函数作为参数，就像这样：
- en: '[PRE87]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The callback is called with a return code and some downloaded content. It is
    possible to pass a lambda as a parameter when calling `download_webpage()`. Since
    the callback is a regular function pointer, the lambda must not have any captures
    and you have to use a plus (`+`) in front of the lambda:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数将以返回代码和一些下载内容的形式被调用。在调用`download_webpage()`时，可以将lambda作为参数传递。由于回调是常规函数指针，lambda不能有任何捕获，必须在lambda前面加上加号（`+`）：
- en: '[PRE88]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This way, the lambda is converted into a regular function pointer. Note that
    the lambda cannot have any captures at all in order to use this functionality.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，lambda就转换为常规函数指针。请注意，lambda不能有任何捕获，以便使用此功能。
- en: Lambda types
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda类型
- en: 'Since C++20, lambdas without captures are default-constructible and assignable.
    By using `decltype`, it''s now easy to construct different lambda objects that
    have the same type:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++20以来，没有捕获的lambda是可默认构造和可赋值的。通过使用`decltype`，现在可以轻松构造具有相同类型的不同lambda对象：
- en: '[PRE89]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: However, this only applies to lambdas without captures. Lambdas *with* captures
    have their own unique type. Even if two lambda functions with captures are plain
    clones of each other, they still have their own unique type. Therefore, it's not
    possible to assign one lambda with captures to another lambda.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅适用于没有捕获的lambda。具有捕获的lambda有它们自己的唯一类型。即使两个具有捕获的lambda函数是彼此的克隆，它们仍然具有自己的唯一类型。因此，不可能将一个具有捕获的lambda分配给另一个lambda。
- en: Lambdas and std::function
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda和std::function
- en: As mentioned in the previous section, lambdas with captures (stateful lambdas)
    cannot be assigned to each other since they have unique types, even if they look
    exactly the same. To be able to store and pass around lambdas with captures, we
    can use `std::function` to hold a function object constructed by a lambda expression.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，具有捕获的lambda（有状态的lambda）不能相互赋值，因为它们具有唯一的类型，即使它们看起来完全相同。为了能够存储和传递具有捕获的lambda，我们可以使用`std::function`来保存由lambda表达式构造的函数对象。
- en: 'The signature of a `std::function` is defined as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::function`的签名定义如下：'
- en: '[PRE90]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'So, a `std::function` returning nothing and having no parameters is defined
    like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，返回空并且没有参数的`std::function`定义如下：
- en: '[PRE91]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'A `std::function` returning a `bool` with an `int` and a `std::string` as parameters
    is defined like this:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`bool`类型，带有`int`和`std::string`作为参数的`std::function`定义如下：
- en: '[PRE92]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Lambda functions sharing the same signature (same parameters and same return
    type) can be held by the same type of `std::function` objects. A `std::function`
    can also be reassigned at runtime.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 共享相同签名（相同参数和相同返回类型）的lambda函数可以由相同类型的`std::function`对象持有。`std::function`也可以在运行时重新分配。
- en: 'What is important here is that what is captured by the lambda does not affect
    its signature, and therefore both lambdas with and without captures can be assigned
    to the same `std::function` variable. The following code shows how different lambdas
    are assigned to the same `std::function` object called `func`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，lambda捕获的内容不会影响其签名，因此具有捕获和不捕获的lambda可以分配给相同的`std::function`变量。以下代码展示了如何将不同的lambda分配给同一个名为`func`的`std::function`对象：
- en: '[PRE93]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Let's put the `std::function` to use in something that resembles a real-world
    example next.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的一个类似真实世界的例子中使用`std::function`。
- en: Implementing a simple Button class with std::function
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用std::function实现一个简单的Button类
- en: Assume that we set out to implement a `Button` class. We can then use the `std::function`
    to store the action corresponding to clicking the button, so that when we call
    the `on_click()` member function, the corresponding code is executed.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们着手实现一个`Button`类。然后我们可以使用`std::function`来存储与点击按钮对应的动作，这样当我们调用`on_click()`成员函数时，相应的代码就会被执行。
- en: 'We can declare the `Button` class like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样声明`Button`类：
- en: '[PRE94]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can then use it to create a multitude of buttons with different actions.
    The buttons can conveniently be stored in a container because they all have the
    same type:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用它来创建多种具有不同动作的按钮。这些按钮可以方便地存储在容器中，因为它们都具有相同的类型：
- en: '[PRE95]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Iterating the list and calling `on_click()` on each button will execute the
    corresponding function:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表上进行迭代，并对每个按钮调用`on_click()`将执行相应的函数：
- en: '[PRE96]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The preceding example with buttons and click handlers demonstrates some of the
    benefits of using `std::function` in combination with lambdas; even though each
    stateful lambda will have its own unique type, a single `std::function` type can
    wrap lambdas that share the same signature (return type and arguments).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的按钮和点击处理程序示例展示了在lambda与`std::function`结合使用时的一些好处；即使每个有状态的lambda都有其自己独特的类型，一个`std::function`类型可以包装共享相同签名（返回类型和参数）的lambda。
- en: As a side note, you might have noticed that the `on_click()` member function
    is declared `const`. However, it's mutating the member variable `handler_` by
    increasing the `counter` variable in one of the click handlers. This might seem
    like it breaks const-correctness rules, as a const member function of `Button`
    is allowed to call a mutating function on one of its class members. The reason
    it is allowed is the same reason that member pointers are allowed to mutate their
    pointed-to value in a const context. Earlier in this chapter, we discussed how
    to propagate constness for pointer data members.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可能已经注意到`on_click()`成员函数被声明为`const`。然而，它通过增加一个点击处理程序中的`counter`变量来改变成员变量`handler_`。这可能看起来违反了const正确性规则，因为`Button`的const成员函数允许调用其类成员的变异函数。之所以允许这样做，是因为成员指针在const上下文中允许改变其指向的值。在本章的前面，我们讨论了如何传播指针数据成员的const性。
- en: Performance consideration of std::function
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::function的性能考虑
- en: A `std::function` has a few performance losses compared to a function object
    constructed by a lambda expression directly. This section will discuss some of
    the things related to performance to consider when using `std::function`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过lambda表达式直接构造的函数对象相比，`std::function`有一些性能损失。本节将讨论在使用`std::function`时需要考虑的一些与性能相关的事项。
- en: Prevented inline optimizations
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阻止内联优化
- en: When it comes to lambdas, the compiler has the ability to inline the function
    call; that is, the overhead of the function call is eliminated. The flexible design
    of `std::function` make it nearly impossible for the compiler to inline a function
    wrapped in a `std::function`. The prevention of inline optimizations can have
    a negative impact on the performance if small functions wrapped in `std::function`
    are called very frequently.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到lambda时，编译器有能力内联函数调用；也就是说，函数调用的开销被消除了。`std::function`的灵活设计使得编译器几乎不可能内联包装在`std::function`中的函数。如果非常频繁地调用包装在`std::function`中的小函数，那么阻止内联优化可能会对性能产生负面影响。
- en: Dynamically allocated memory for captured variables
  id: totrans-464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获变量的动态分配内存
- en: If a `std::function` is assigned to a lambda with captured variables/references,
    the `std::function` will, in most cases, use heap-allocated memory to store the
    captured variables. Some implementations of `std::function` do not allocate additional
    memory if the size of the captured variable is below some threshold.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`std::function`分配给带有捕获变量/引用的lambda，那么`std::function`在大多数情况下将使用堆分配的内存来存储捕获的变量。如果捕获变量的大小低于某个阈值，一些`std::function`的实现将不分配额外的内存。
- en: This means that not only is there a performance penalty due to the extra dynamic
    memory allocation, but also that it is slower, as heap-allocated memory can increase
    the number of cache misses (read more about cache misses in *Chapter 4*, *Data
    Structures*).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不仅由于额外的动态内存分配而产生性能损失，而且由于堆分配的内存可能增加缓存未命中的次数（在*第4章*的*数据结构*中了解更多关于缓存未命中的信息）。
- en: Additional run-time computation
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的运行时计算
- en: 'Calling a `std::function` is generally a bit slower than executing a lambda,
    as a little more code is involved. For small and frequently called `std::function`s,
    this overhead may become significant. Imagine that we have a really small lambda
    defined like this:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`std::function`通常比执行lambda慢一点，因为涉及到更多的代码。对于小而频繁调用的`std::function`来说，这种开销可能变得很大。想象一下，我们定义了一个非常小的lambda：
- en: '[PRE97]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The benchmark that follows demonstrates the difference between executing 10
    million function calls for a `std::vector` of the explicit lambda type versus
    a `std::vector` of a corresponding `std::function`. We will begin with the version
    using the explicit lambda:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的基准测试演示了对于一个`std::vector`的1000万次函数调用，使用显式lambda类型与相应的`std::function`的`std::vector`之间的差异。我们将从使用显式lambda的版本开始：
- en: '[PRE98]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We only measure the time it takes to execute the loop inside the function.
    The next version wraps our lambda in a `std::function`, and looks like this:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只测量执行函数内部循环所需的时间。下一个版本将我们的lambda包装在`std::function`中，如下所示：
- en: '[PRE99]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: I'm compiling this code on my MacBook Pro from 2018 using Clang with optimizations
    turned on (`-O3`). The first version, `use_lambda()`, executes the loop at roughly
    2 ms, whereas the second version, `use_std_function()`, takes almost 36 ms to
    execute the loop.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用2018年的MacBook Pro上使用Clang编译此代码，并打开了优化（`-O3`）。第一个版本`use_lambda()`在大约2毫秒内执行循环，而第二个版本`use_std_function()`则需要近36毫秒来执行循环。
- en: Generic lambdas
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用lambda
- en: A generic lambda is a lambda accepting `auto` parameters, making it possible
    to invoke it with any type. It works just like a regular lambda, but the `operator()`
    has been defined as a member function template.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通用lambda是一个接受`auto`参数的lambda，使得可以用任何类型调用它。它的工作原理与常规lambda一样，但`operator()`已被定义为成员函数模板。
- en: 'Only the parameters are template variables, not the captured values. In other
    words, the captured value, `v`, in the following example will be of type `int`
    regardless of the types of `v0` and `v1`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 只有参数是模板变量，而不是捕获的值。换句话说，以下示例中捕获的值`v`将始终是`int`类型，而不管`v0`和`v1`的类型如何：
- en: '[PRE100]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If we translate the above lambda to a class, it would correspond to something
    like this:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将上述lambda表达式转换为一个类，它将对应于以下内容：
- en: '[PRE101]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Just like the templated version, the compiler won''t generate the actual function
    until the lambda is invoked. So, if we invoke the previous lambda like this:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 就像模板化版本一样，直到调用lambda表达式，编译器才会生成实际的函数。因此，如果我们像这样调用之前的lambda：
- en: '[PRE102]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'the compiler will generate something similar to the following lambdas:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将生成类似于以下lambda表达式：
- en: '[PRE103]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you might have figured out, these versions are further handled just like
    regular lambdas.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经发现的那样，这些版本将进一步处理，就像常规lambda一样。
- en: 'A new feature of C++20 is that we can use `typename` instead of just `auto`
    for the parameter types of a generic lambda. The following generic lambdas are
    identical:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的一个新特性是，我们可以在通用lambda的参数类型中使用`typename`而不仅仅是`auto`。以下通用lambda是相同的：
- en: '[PRE104]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This makes it possible to name the type or refer to the type inside the body
    of the lambda.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在lambda的主体内部命名类型或引用类型成为可能。
- en: Summary
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to use modern C++ features that will be
    used throughout this book. Automatic type deduction, move semantics, and lambda
    expressions are fundamental techniques that every C++ programmer needs to feel
    comfortable with today.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用现代C++特性，这些特性将在整本书中使用。自动类型推导、移动语义和lambda表达式是每个C++程序员今天都需要熟悉的基本技术。
- en: We also spent some time looking at error handling and how to think about bugs,
    along with valid states and how to recover from runtime errors. Error handling
    is an extremely important part of programming that is easily overlooked. Thinking
    about contracts between callers and callees is a way to make your code correct
    and avoid unnecessary defensive checks in the released version of your program.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间来研究错误处理以及如何思考错误和有效状态，以及如何从运行时错误中恢复。错误处理是编程中极其重要的一部分，很容易被忽视。考虑调用方和被调用方之间的契约是使您的代码正确并避免在程序的发布版本中进行不必要的防御性检查的一种方法。
- en: In the next chapter, we will look into strategies for analyzing and measuring
    performance in C++.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在C++中分析和测量性能的策略。
