- en: Chapter 12
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: The Most Recent C
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最新的C
- en: Change cannot be prevented, and C is no exception. The C programming language
    is standardized by an ISO standard, and it is constantly under revision by a group
    of people who are trying to make it better and bring new features to it. This
    doesn't mean that the language will necessarily get easier, however; we might
    see novel and complex features emerge in the language as new content is added.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 变化是无法阻止的，C语言也不例外。C编程语言由ISO标准标准化，并且由一群试图使其更好并为其带来新特性的群体不断修订。这并不意味着语言一定会变得更容易；我们可能会看到随着新内容的添加，语言中出现新颖和复杂的功能。
- en: In this chapter, we are going to have a brief look at C11's features. You might
    know that C11 has replaced the old C99 standard, and it has been superseded by
    the C18 standard. In other words, C18 is the latest version of the C standard,
    and just before that we had C11.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要地看看C11的特性。你可能知道C11已经取代了旧的C99标准，并且已经被C18标准所取代。换句话说，C18是C标准的最新版本，而在那之前我们有C11。
- en: It's interesting to know that C18 doesn't offer any new features; it just contains
    fixes for the issues found in C11\. Therefore, talking about C11 is basically
    the same as talking about C18, and it will lead us to the most recent C standard.
    As you can see, we are observing constant improvement in the C language… contrary
    to the belief that it is a long-dead language!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，C18没有提供任何新特性；它只是对C11中发现的问题进行了修复。因此，谈论C11基本上等同于谈论C18，这将引导我们到最新的C标准。正如你所看到的，我们在C语言中观察到持续改进……这与它是一个已经死去很长时间的语言的看法相反！
- en: 'This chapter will give a brief overview of the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要概述以下主题：
- en: How to detect the C version and how to write a piece of C code which is compatible
    with various C versions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测C版本以及如何编写兼容各种C版本的C代码
- en: New features for writing optimized and secure code, such as *no-return* functions
    and *bounds-checking* functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写优化和安全的代码的新特性，如*不返回*函数和*边界检查*函数
- en: New data types and memory alignment techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的数据类型和内存对齐技术
- en: Type-generic functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型泛型函数
- en: Unicode support in C11, which was missing from the language in the older standards
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C11中的Unicode支持，这在旧标准中缺失
- en: Anonymous structures and unions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名结构和联合
- en: Standard support for multithreading and synchronization techniques in C11
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C11中标准的多线程和同步技术支持
- en: Let's begin the chapter by talking about C11 and its new features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论C11及其新特性开始本章。
- en: C11
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C11
- en: Gathering a new standard for a technology that has been in use for more than
    30 years is not an easy task. Millions (if not billions!) of lines of C code exist,
    and if you are about to introduce new features, this must be done while keeping
    previous code or features intact. New features shouldn't create new problems for
    the existing programs, and they should be bug-free. While this view seems to be
    idealistic, it is something that we should be committed to.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 收集一个使用超过30年的技术的新的标准并非易事。数百万（如果不是数十亿！）行C代码存在，如果你即将引入新特性，这必须在保持现有代码或特性完整的情况下完成。新特性不应为现有程序带来新问题，并且应该是无错误的。虽然这种观点看似理想化，但这是我们应该致力于做到的。
- en: 'The following PDF document resides on the *Open Standards* website and contains
    the worries and thoughts that people in the C community had in mind before starting
    to shape C11: http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1250.pdf. It would
    be useful to give it a read because it will introduce you to the experience of
    authoring a new standard for a programming language that several thousand pieces
    of software have been built upon.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下PDF文档位于*开放标准*网站上，包含了在开始塑造C11之前C社区中人们的担忧和思考：http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1250.pdf。阅读它会有所帮助，因为它会向你介绍为基于数千个软件构建的编程语言编写新标准时的经验。
- en: 'Finally, with these things in mind, we consider the release of C11\. When C11
    came out, it was not in its ideal form and was in fact suffering from some serious
    defects. You can see the list of these defects he[re: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm).htm.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑到这些因素，我们考虑C11的发布。当C11发布时，它并非处于理想状态，实际上正遭受一些严重的缺陷。你可以看到这些缺陷的列表[这里：http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm)。
- en: Seven years after the launch of C11, C18 was introduced, which came about to
    fix the defects found in C11\. Note that C18 is also *informally* referred to
    as C17, and both C17 and C18 refer to the same C standard. If you open the previous
    link you will see the defects and their current statuses. If the status of a defect
    is "C17," it means that the defect is solved as part of C18\. This shows how hard
    and delicate process it is to assemble a standard that has as many users as C
    does.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C11发布七年之后，推出了C18，这是为了修复在C11中发现的问题。请注意，C18也非正式地被称为C17，C17和C18都指的是相同的C标准。如果您打开前面的链接，您将看到缺陷及其当前状态。如果缺陷的状态是“C17”，这意味着该缺陷作为C18的一部分得到了解决。这显示了构建一个像C一样拥有众多用户的标准的艰难和精细过程。
- en: In the following sections, we'll talk about the new features of C11\. Before
    going through them however, we need a way to be sure that we are really writing
    C11 code, and that we are using a compatible compiler. The following section will
    address this requirement.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论C11的新特性。然而，在通过它们之前，我们需要一种方法来确保我们确实在编写C11代码，并且我们使用的是兼容的编译器。下一节将解决这个问题。
- en: Finding a supported version of C standard
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找支持的C标准版本
- en: At the time of writing, it has been almost 8 years since C11 came out. Therefore,
    it would be expected that many compilers should support the standard, and this
    is indeed the case. Open source compilers such as `gcc` and `clang` both support
    C11 perfectly, and they can switch back to C99 or even older versions of C if
    needed. In this section, we show how to use specific macros to detect the C version
    and, depending on the version, how to use the supported features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，C11发布已有近8年。因此，可以预期许多编译器应该支持该标准，这确实是事实。开源编译器如`gcc`和`clang`都完美支持C11，并且如果需要，它们可以切换回C99或更早的版本。在本节中，我们将展示如何使用特定的宏来检测C版本，以及根据版本如何使用支持的功能。
- en: The first thing that is necessary when using a compiler that supports different
    versions of the C standard is being able to identify which version of the C standard
    is currently in use. Every C standard defines a special macro that can be used
    to find out what version is being used. So far, we have used `gcc` in Linux and
    `clang` in macOS systems. As of version 4.7, `gcc` offers C11 as one of its supported
    standards.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用支持不同C标准版本的编译器时，首先必要的是能够识别当前正在使用的C标准版本。每个C标准都定义了一个特殊的宏，可以用来找出正在使用哪个版本。到目前为止，我们在Linux系统中使用了`gcc`，在macOS系统中使用了`clang`。从版本4.7开始，`gcc`将其支持的标准之一提供为C11。
- en: 'Let''s look at the following example and see how already-defined macros can
    be used to detect the current version of the C standard at runtime:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，看看已经定义的宏如何用于在运行时检测当前的C标准版本：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 12-1 [ExtremeC_examples_chapter12_1.c]: Detecting the version of the
    C standard'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 12-1 [ExtremeC_examples_chapter12_1.c]：检测C标准的版本
- en: As you can see, the preceding code can distinguish between various versions
    of the C standard. In order to see how various C versions can lead to various
    printings, we have to compile the preceding source code multiple times with various
    versions of C standard that are supported by the compiler.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码可以区分不同的C标准版本。为了看到不同的C版本如何导致不同的打印结果，我们必须多次使用编译器支持的C标准版本编译前面的源代码。
- en: 'To ask the compiler to use a specific version of the C standard, we have to
    pass the -`std=CXX` option to the C compiler. Look at the following commands and
    the produced output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要让编译器使用特定的C标准版本，我们必须将`-std=CXX`选项传递给C编译器。查看以下命令和产生的输出：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 12-1: Compiling example 12.1 with various versions of C standard'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 12-1：使用各种C标准版本编译示例12.1
- en: As you can see, the default C standard version in newer compilers is C11\. With
    older versions, you have to specify the version using the `-std` option, if you
    want to enable C11\. Note the comments made at the beginning of the file. I have
    used `/* ... */` comments (multiline comments) instead of `//` comments (one-line
    comments). That's because one-line comments were not supported in standards before
    C99\. Therefore, we had to use multiline comments in order to have the preceding
    code compiled with all C versions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，较新编译器的默认C标准版本是C11。在较旧版本中，如果您想启用C11，必须使用`-std`选项指定版本。注意文件开头所做的注释。我使用了`/*
    ... */`多行注释而不是`//`单行注释。这是因为C99之前的标准中不支持单行注释。因此，我们必须使用多行注释，以便前面的代码能够与所有C版本兼容地编译。
- en: Removal of the gets function
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除 `gets` 函数
- en: In C11, the famous `gets` function is removed. The `gets` function was subject
    to *buffer overflow* attacks, and in older versions it was decided to make the
    function *deprecated*. Later, as part of the C11 standard, it was removed. Therefore,
    older source code that uses the `gets` function won't be compiled using a C11
    compiler.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C11 中，著名的 `gets` 函数被移除。`gets` 函数曾受到 *缓冲区溢出* 攻击，在旧版本中，它被决定为 *已弃用*。后来，作为 C11
    标准的一部分，它被移除。因此，使用 `gets` 函数的旧源代码将无法使用 C11 编译器编译。
- en: 'The `fgets` function can be used instead of `gets`. The following is an excerpt
    from the `gets` manual page (man page) in macOS:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `fgets` 函数代替 `gets`。以下是从 macOS 中 `gets` 手册页（man 页）摘录的内容：
- en: SECURITY CONSIDERATIONS
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 安全考虑
- en: The gets() function cannot be used securely. Because of its lack of bounds checking,
    and the inability for the calling program to reliably determine the length of
    the next incoming line, the use of this function enables malicious users to arbitrarily
    change a running program's functionality through a buffer overflow attack. It
    is strongly suggested that the fgets() function be used in all cases. (See the
    FSA.)
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`gets()` 函数不能安全使用。由于其缺乏边界检查，以及调用程序无法可靠地确定下一行输入的长度，使用此函数会使恶意用户通过缓冲区溢出攻击任意更改正在运行的程序的功能。强烈建议在所有情况下使用
    `fgets()` 函数。（参见 FSA。）'
- en: Changes to fopen function
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`fopen` 函数的更改'
- en: 'The `fopen` function is usually used for opening a file and returning a file
    descriptor to that file. The concept of a file is very general in Unix, and by
    using the term *file*, we don''t necessarily mean a file located on the filesystem.
    The `fopen` function has the following signatures:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen` 函数通常用于打开文件并返回该文件的文件描述符。在 Unix 中，文件的概念非常通用，使用术语 *文件* 并不一定意味着位于文件系统上的文件。`fopen`
    函数有以下签名：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 12-2: Various signatures of the family of fopen functions'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 12-2：`fopen` 函数家族的各种签名
- en: 'As you can see, all of the preceding signatures accept a `mode` input. This
    input parameter is a string that determines how the file should be opened. The
    following description in *Shell Box 12-2* is obtained from the FreeBSD manual
    for the `fopen` function and explains how `mode` should be used:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有前面的签名都接受一个 `mode` 输入。此输入参数是一个字符串，它决定了文件应该如何打开。*Shell Box 12-2* 中的以下描述来自
    FreeBSD 手册中的 `fopen` 函数，并解释了如何使用 `mode`：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 12-2: An excerpt from the fopen''s manual page in FreeBSD'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 12-2：FreeBSD 中 `fopen` 手册页的摘录
- en: The mode `x`, explained in the preceding extract from the `fopen` manual page,
    has been introduced as part of C11\. To open a file in order to write to it, the
    mode `w` or `w+` should be supplied to `fopen`. The problem is that, if the file
    already exists, the `w` or `w+` mode will truncate (empty) the file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fopen` 手册页的前面摘录中解释的 `x` 模式是作为 C11 的一部分引入的。为了写入文件，应向 `fopen` 提供模式 `w` 或 `w+`。问题是，如果文件已经存在，`w`
    或 `w+` 模式将截断（清空）文件。
- en: Therefore, if the programmer wants to append to a file and keep its current
    content, they have to use a different mode, `a`. Hence, they have to check for
    the file's existence, using a filesystem API such as `stat`, before calling `fopen`,
    and then choose the proper mode based on the result. Now however, with the new
    mode `x`, the programmer first tries with the mode `wx` or `w+x`, and if the file
    already exists the `fopen` will fail. Then the programmer can continue with the
    `a` mode.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果程序员想要向文件追加内容并保留其当前内容，他们必须使用不同的模式，即 `a`。因此，他们必须在调用 `fopen` 之前使用文件系统 API（如
    `stat`）检查文件是否存在，然后根据结果选择适当的模式。然而，现在有了新的模式 `x`，程序员首先尝试使用模式 `wx` 或 `w+x`，如果文件已存在，`fopen`
    将失败。然后程序员可以继续使用 `a` 模式。
- en: Thus, less boilerplate code needs to be written to open a file without using
    the filesystem API to check for the file's existence. From now on, `fopen` is
    enough to open a file in every desired mode.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不需要使用文件系统 API 检查文件是否存在的情况下打开文件，需要编写的样板代码更少。从现在开始，`fopen` 就足以以每种所需的模式打开文件。
- en: Another change in C11 was the introduction of the `fopen_s` API. This function
    serves as a secure `fopen`. According to the documentation for `fopen_s` found
    at https://en.cppreference.com/w/c/io/fopen, performs extra checking on the provided
    buffers and their boundaries in order to detect any flaw in them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C11 的另一个变化是引入了 `fopen_s` API。这个函数作为安全的 `fopen`。根据位于 https://en.cppreference.com/w/c/io/fopen
    的 `fopen_s` 文档，对提供的缓冲区和它们的边界进行额外检查，以检测其中的任何缺陷。
- en: Bounds-checking functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界检查函数
- en: One of the serious problems with C programs operating on strings and byte arrays
    is the ability to go easily beyond the boundary defined for a buffer or a byte
    array.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C程序在字符串和字节数组上操作时遇到的一个严重问题是容易超出为缓冲区或字节数组定义的边界。
- en: As a reminder, a buffer is a region of memory that is used as the place holder
    for a byte array or a string variable. Going beyond the boundary of a buffer causes
    a *buffer overflow* and based on that a malicious entity can organize an attack
    (usually called a *buffer overflow attack*). This type of attack either results
    in a **denial of service** (**DOS**) or in *exploitation* of the victim C program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，缓冲区是内存中的一个区域，用作字节数组或字符串变量的占位符。超出缓冲区的边界会导致*缓冲区溢出*，基于此，恶意实体可以组织攻击（通常称为*缓冲区溢出攻击*）。这种攻击要么导致**拒绝服务**（**DOS**），要么在受影响的C程序中进行*利用*。
- en: Most such attacks usually start in a function operating on character or byte
    arrays. String manipulation functions found in `string.h`, such as `strcpy` and
    `strcat`, are among the *vulnerable* functions that lack a boundary checking mechanism
    to prevent buffer overflow attacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数此类攻击通常从一个操作字符或字节数组的函数开始。在`string.h`中找到的字符串操作函数，如`strcpy`和`strcat`，是缺乏边界检查机制以防止缓冲区溢出攻击的*易受攻击*函数。
- en: However, as part of C11, a new set of functions has been introduced. *Bounds-checking*
    functions borrow the same name from the string manipulation functions but with
    an `_s` at the end. The suffix `_s` distinguishes them as a *secure* or *safe*
    flavor of those functions that conduct more runtime checks in order to shut down
    the vulnerabilities. Functions such as `strcpy_s` and `strcat_s` have been introduced
    as part of bounds-checking functions in C11.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为C11的一部分，引入了一套新的函数。*边界检查*函数从字符串操作函数借用相同的名称，但以`_s`结尾。后缀`_s`将它们区分开来，作为*安全*或*安全*版本的函数，这些函数在运行时进行更多的检查，以关闭漏洞。`strcpy_s`和`strcat_s`等函数作为C11中边界检查函数的一部分被引入。
- en: 'These functions accept some extra arguments for the input buffers that restrict
    them from performing dangerous operations. As an example, the `strcpy_s` function
    has the following signature:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接受一些额外的输入缓冲区参数，限制了它们执行危险操作的能力。例如，`strcpy_s`函数具有以下签名：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 12-3: Signature of the strcpy_s function'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框12-3：strcpy_s函数的签名
- en: As you can see, the second argument is the length of the `dest` buffer. Using
    that, the function performs some runtime checks, such as ensuring that the `src`
    string is shorter than or at the same size of the `dest` buffer in order to prevent
    writing to unallocated memory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第二个参数是`dest`缓冲区的长度。使用它，该函数执行一些运行时检查，例如确保`src`字符串的长度短于或与`dest`缓冲区的大小相同，以防止写入未分配的内存。
- en: No-return functions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无返回函数
- en: 'A function call can end either by using the `return` keyword or by reaching
    the end of the function''s block. There are also situations in which a function
    call never ends, and this is usually done intentionally. Look at the following
    code example contained in *Code Box 12-4*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用可以通过使用`return`关键字或到达函数块的末尾来结束。也存在函数调用永远不会结束的情况，这通常是有意为之。看看以下包含在*代码框12-4*中的代码示例：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 12-4: Example of a function that never returns'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框12-4：永不返回的函数示例
- en: As you can see, the function `main_loop` performs the main task of the program,
    and if we return from the function, the program could be considered as finished.
    In these exceptional cases, the compiler can perform some more optimizations,
    but somehow, it needs to know that the function `main_loop` never returns.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数`main_loop`执行程序的主要任务，如果我们从函数返回，则程序可以被认为是结束的。在这些异常情况下，编译器可以执行一些额外的优化，但无论如何，它需要知道函数`main_loop`永远不会返回。
- en: 'In C11, you have the ability to mark a function as a *no-return* function.
    The `_Noreturn` keyword from the `stdnoreturn.h` header file can be used to specify
    that a function never exits. So, the code in *Code Box 12-4* can be changed for
    C11 to look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在C11中，您可以将一个函数标记为*无返回*函数。`stdnoreturn.h`头文件中的`_Noreturn`关键字可以用来指定一个函数永远不会退出。因此，*代码框12-4*中的代码可以修改为C11的如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 12-5: Using the _Noreturn keyword to mark main_loop as a never-ending
    function'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框12-5：使用_Noreturn关键字标记main_loop为永不结束的函数
- en: There are other functions, such as `exit`, `quick_exit` (added recently as part
    of C11 for quick termination of the program), and `abort`, that are considered
    to be no-return functions. In addition, knowing about no-return functions allows
    the compiler to recognize function calls that unintentionally won't return and
    produce proper warnings because they could be a sign of a logical bug. Note that
    if a function marked as `_Noreturn` returns, then this would be an *undefined
    behavior* and it is highly discouraged.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他函数，如`exit`、`quick_exit`（作为C11的一部分最近添加，用于快速终止程序），以及`abort`，被认为是不可返回的函数。此外，了解不可返回函数允许编译器识别那些无意中不会返回的函数调用，并产生适当的警告，因为这些可能是逻辑错误的迹象。请注意，如果一个标记为`_Noreturn`的函数返回，那么这将是一种*未定义的行为*，并且强烈不建议这样做。
- en: Type generic macros
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入通用宏
- en: 'In C11, a new keyword has been introduced: `_Generic`. It can be used to write
    macros that are type-aware at compile time. In other words, you can write macros
    that can change their value based on the type of their arguments. This is usually
    called *generic selection*. Look at the following code example in *Code Box 12-6*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在C11中，引入了一个新的关键字：`_Generic`。它可以用来编写在编译时具有类型感知能力的宏。换句话说，你可以编写可以根据其参数类型改变其值的宏。这通常被称为*泛型选择*。请看以下代码示例在*代码框12-6*：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 12-6: Example of a generic macro'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框12-6：通用宏示例
- en: As you can see in the macro definition, we have used different expressions based
    on the type of the argument `x`. We use `absi` if it is an integer value, and
    `absd` if it is a double value. This feature is not new to C11, and you can find
    it in older C compilers, but it wasn't part of the C standard. As of C11, it is
    now standard, and you can use this syntax to write type-aware macros.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在宏定义中所见，我们根据参数`x`的类型使用了不同的表达式。如果它是整数值，我们使用`absi`；如果是双精度值，我们使用`absd`。这个特性对C11来说并不新鲜，您可以在较老的C编译器中找到它，但它不是C标准的一部分。截至C11，它现在是标准的，您可以使用这种语法来编写类型感知宏。
- en: Unicode
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode
- en: One of the greatest features that has been added to the C11 standard is support
    for Unicode through UTF-8, UTF-16, and UTF-32 encodings. C was missing this feature
    for a long time, and C programmers had to use third-party libraries such as **IBM
    International Components for Unicode** (**ICU**) to fulfill their needs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C11标准中添加的最伟大的特性之一是通过UTF-8、UTF-16和UTF-32编码支持Unicode。C长期以来缺少这个特性，C程序员必须使用第三方库，如**IBM国际组件Unicode**（**ICU**），来满足他们的需求。
- en: Before C11, we only had `char` and `unsigned char` types, which were 8-bit variables
    used to store ASCII and Extended ASCII characters. By creating arrays of these
    ASCII characters, we could create ASCII strings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在C11之前，我们只有`char`和`unsigned char`类型，它们是8位变量，用于存储ASCII和扩展ASCII字符。通过创建这些ASCII字符的数组，我们可以创建ASCII字符串。
- en: '**Note**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**:'
- en: ASCII standard has 128 characters which can be stored in 7 bits. Extended ASCII
    is an extension to ASCII which adds another 128 characters to make them together
    256 characters. Then, an 8-bit or one-byte variable is enough to store all of
    them. In the upcoming text, we will only use the term ASCII, and by that we refer
    to both ASCII standard and Extended ASCII.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII标准有128个字符，可以用7位存储。扩展ASCII是ASCII的扩展，增加了另外128个字符，使总数达到256个。然后，一个8位或单字节变量足以存储所有这些字符。在即将到来的文本中，我们只会使用术语ASCII，并且通过这个术语我们指的是ASCII标准和扩展ASCII。
- en: Note that support for ASCII characters and strings is fundamental, and it will
    never be removed from C. Thus, we can be confident that we will always have ASCII
    support in C. From C11, they have added support for new characters, and therefore
    new strings that use a different number of bytes, not just one byte, for each
    character.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对ASCII字符和字符串的支持是基本的，并且永远不会从C中移除。因此，我们可以确信我们将在C中始终拥有ASCII支持。从C11开始，它们添加了对新字符的支持，因此产生了使用不同字节数的新字符串，而不仅仅是每个字符一个字节。
- en: To explain this further, in ASCII, we have one byte for each character. Therefore,
    the bytes and characters can be used interchangeably, but this is *not* true in
    general. Different encodings define new ways to store a wider range of characters
    in multiple bytes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释，在ASCII编码中，每个字符占用一个字节。因此，字节和字符可以互换使用，但这种情况并不普遍。不同的编码定义了在多个字节中存储更广泛字符的新方法。
- en: In ASCII, altogether we have 256 characters. Therefore, a single one-byte (8-bit)
    character is enough to store all of them. If we are going to have more than 256
    characters, however, we must use more than one byte to store their numerical values
    after 255\. Characters that need more than one byte to store their values are
    usually called *wide characters*. By this definition, ASCII characters are not
    considered as wide characters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASCII编码中，总共有256个字符。因此，一个单字节（8位）的字符就足以存储所有这些字符。然而，如果我们需要超过256个字符，我们必须使用超过一个字节来存储超过255的数值。需要超过一个字节来存储其值的字符通常被称为*宽字符*。根据这个定义，ASCII字符不被认为是宽字符。
- en: 'The Unicode standard introduced various methods of using more than one byte
    to encode all characters in ASCII, Extended ASCII, and wide characters. These
    methods are called *encodings*. Through Unicode, there are three well-known encodings:
    UTF-8, UTF-16, and UTF-32\. UTF-8 uses the first byte for storing the first half
    of the ASCII characters, and the next bytes, usually up to 4 bytes, for the other
    half of ASCII characters together with all other wide characters. Hence, UTF-8
    is considered as a variable-sized encoding. It uses certain bits in the first
    byte of the character to denote the number of actual bytes that should be read
    to retrieve the character fully. UTF-8 is considered a superset of ASCII because
    for ASCII characters (not Extended ASCII characters) the representation is the
    same.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode标准引入了多种使用超过一个字节来编码ASCII、扩展ASCII和宽字符的方法。这些方法被称为*编码*。通过Unicode，有三种著名的编码：UTF-8、UTF-16和UTF-32。UTF-8使用第一个字节来存储ASCII字符的前半部分，接下来的字节，通常最多4个字节，用于存储ASCII字符的后半部分以及所有其他宽字符。因此，UTF-8被认为是一种可变长度的编码。它使用字符的第一个字节中的某些位来表示应该读取多少实际字节才能完全检索字符。UTF-8被认为是一个ASCII的超集，因为对于ASCII字符（不是扩展ASCII字符）的表示是相同的。
- en: Like UTF-8, UTF-16 uses one or two *words* (each word has 16 bits within) for
    storing all characters; hence it is also a variable-sized encoding. UTF-32 uses
    exactly 4 bytes for storing the values of all characters; therefore, it is a fixed-sized
    encoding. UTF-8, and after that, UTF-16, are suitable for the applications in which
    a smaller number of bytes should be used for more frequent characters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与UTF-8类似，UTF-16使用一个或两个*字*（每个字内部有16位）来存储所有字符；因此，它也是一种可变长度的编码。UTF-32使用恰好4字节来存储所有字符的值；因此，它是一种固定长度的编码。UTF-8和UTF-16适用于需要为更频繁出现的字符使用更少字节的程序。
- en: UTF-32 uses a fixed number of bytes even for ASCII characters. So, it consumes
    more memory space to store strings using this encoding compared to others; but
    it requires less computation power when using UTF-32 characters. UTF-8 and UTF-16
    can be considered as compressed encodings, but they need more computation to return
    the actual value of a character.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-32即使在ASCII字符上也使用固定数量的字节。因此，与使用其他编码相比，使用UTF-32编码存储字符串会消耗更多的内存空间；但使用UTF-32字符时所需的计算能力更少。UTF-8和UTF-16可以被认为是压缩编码，但它们需要更多的计算来返回字符的实际值。
- en: '**Note**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: More information about UTF-8, UTF-16, and UTF-32 strings and how to decode them
    can be found on Wik[ipedia or other sources like:](https://unicodebook.readthedocs.io/unicode_encodings.html)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于UTF-8、UTF-16和UTF-32字符串及其解码方式的信息可以在维基百科或其他来源找到，例如：
- en: '[https://unicodebook.readth](https://unicodebook.readthedocs.io/unicode_encodings.html)e[docs.io/unicode_encodings.html](https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://unicodebook.readth](https://unicodebook.readthedocs.io/unicode_encodings.html)e[docs.io/unicode_encodings.html](https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html)'
- en: '[https://javarevisited.blogspot.com/2015/02/difference-be](https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html)t[ween-utf-8-utf-16-and-utf.html](https://unicodebook.readthedocs.io/unicode_encodings.html).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://javarevisited.blogspot.com/2015/02/difference-be](https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html)t[ween-utf-8-utf-16-and-utf.html](https://unicodebook.readthedocs.io/unicode_encodings.html).'
- en: 'In C11 we have support for all the above Unicode encodings. Look at the following
    example, *example 12.3*. It defines various ASCII, UTF-8, UTF-16, and UTF-32 strings,
    and counts the number of actual bytes used to store them and the number of characters
    observed within them. We present the code in multiple steps in order to give additional
    comments on the code. The following code box demonstrates the inclusions and declarations
    required:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C11 中，我们支持所有上述 Unicode 编码。查看以下示例，*example 12.3*。它定义了各种 ASCII、UTF-8、UTF-16
    和 UTF-32 字符串，并计算存储它们的实际字节数和观察到的字符数。我们分多步展示代码，以便对代码进行额外的注释。以下代码框演示了所需的包含和声明：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 12-7 [ExtremeC_examples_chapter12_3.c]: Inclusions and declarations
    required for example 12.3 to get built'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 12-7 [ExtremeC_examples_chapter12_3.c]：示例 12.3 所需的包含和声明
- en: The preceding lines are the `include` statements for *example 12.3*. As you
    can see, in macOS we do not have the `uchar.h` header and we have to define new
    types for the `char16_t` and `char32_t` types. The whole functionality of Unicode
    strings is supported, however. On Linux, we don't have any issues with Unicode
    support in C11.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行是 *example 12.3* 的 `include` 语句。如您所见，在 macOS 上我们没有 `uchar.h` 头文件，我们必须为 `char16_t`
    和 `char32_t` 类型定义新类型。尽管如此，Unicode 字符串的整个功能都得到了支持。在 Linux 上，我们没有 C11 中 Unicode
    支持的问题。
- en: 'The next part of the code demonstrates the functions used for counting the
    number of bytes and characters in various kinds of Unicode strings. Note that
    no utility function is offered by C11 to operate on Unicode strings, therefore
    we have to write a new `strlen` for them. In fact, our versions of `strlen` functions
    do more just than returning the number of characters; they return the number of
    consumed bytes as well. The implementation details won''t be described, but it
    is strongly recommended to give them a read:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分演示了用于计算各种类型 Unicode 字符串的字节数和字符数的函数。请注意，C11 没有提供用于操作 Unicode 字符串的实用函数，因此我们必须为它们编写新的
    `strlen`。实际上，我们的 `strlen` 函数不仅返回字符数，还返回消耗的字节数。实现细节将不会描述，但强烈建议您阅读它们：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 12-8 [ExtremeC_examples_chapter12_3.c]: The definitions of the functions
    used in example 12.3'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 12-8 [ExtremeC_examples_chapter12_3.c]：示例 12.3 中使用的函数的定义
- en: 'The last part is the `main` function. It declares some different strings in
    English, Persian, and some alien language to evaluate the preceding functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是 `main` 函数。它声明了一些英文、波斯语和一些外星语言的字符串，以评估前面的函数：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 12-9 [ExtremeC_examples_chapter12_3.c]: The main function of example
    12.3'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 12-9 [ExtremeC_examples_chapter12_3.c]：示例 12.3 的主函数
- en: 'Now, we must compile the preceding example. Note that the example can only
    be compiled using a C11 compiler. You can try using older compilers and take a
    look at the resulting errors. The following commands compile and run the preceding
    program:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须编译前面的示例。请注意，该示例只能使用 C11 编译器进行编译。您可以尝试使用较旧的编译器并查看产生的错误。以下命令编译并运行前面的程序：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Shell Box 12-3: Compiling and running example 12.3'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 12-3：编译和运行示例 12.3
- en: As you can see, the same string with the same number of characters uses a different
    number of bytes to encode and store the same value. UTF-8 uses the least number
    of bytes, especially when a large number of characters in a text are ASCII characters,
    simply because most of the characters will use only one byte.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，具有相同字符数的相同字符串使用不同数量的字节来编码和存储相同的值。UTF-8 使用最少的字节，尤其是在文本中有大量 ASCII 字符时，因为大多数字符将仅使用一个字节。
- en: As we go through the characters that are more distinct from the Latin characters,
    such as characters in Asian languages, UTF-16 has a better balance between the
    number of characters and the number of used bytes, because most of the characters
    will use up to two bytes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到与拉丁字符更不同的字符时，例如亚洲语言的字符，UTF-16 在字符数和使用的字节数之间有更好的平衡，因为大多数字符将使用最多两个字节。
- en: UTF-32 is rarely used, but it can be used in systems where having a fixed-length
    *code print* for characters is useful; for example, if the system suffers from
    low computational power or is benefiting from some parallel processing pipelines.
    Therefore, UTF-32 characters can be used as keys in mappings from the characters
    to any kind of data. In other words, they can be used to build up some indexes
    to look up data very quickly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-32 很少使用，但它可以用于需要固定长度 *代码打印* 的字符的系统；例如，如果系统计算能力较低或受益于某些并行处理管道。因此，UTF-32 字符可以用作从字符到任何类型数据的映射中的键。换句话说，它们可以用来构建一些索引以快速查找数据。
- en: Anonymous structures and anonymous unions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名结构和匿名联合
- en: 'Anonymous structures and anonymous unions are type definitions without names,
    and they are usually used in other types as a nested type. It is easier to explain
    them with an example. Here, you can see a type that has both an anonymous structure
    and an anonymous union in one place, displayed in *Code Box 12-10*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名结构和匿名联合是没有名称的类型定义，通常用作其他类型的嵌套类型。用示例更容易解释它们。在这里，你可以看到一个类型，它在一个地方同时具有匿名结构和匿名联合，显示在代码框
    12-10 中：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 12-10: Example of an anonymous structure together with an anonymous
    union'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 12-10：匿名结构和匿名联合的示例
- en: 'The preceding type uses the same memory for the anonymous structure and the
    byte array field `data`. The following code box shows how it can be used in a
    real example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型使用相同的内存来存储匿名结构和字节数组字段 `data`。以下代码框显示了它如何在实际示例中使用：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code box 12-11 [ExtremeC_examples_chapter12_4.c]: The main function using an
    anonymous structure together with an anonymous union'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 12-11 [ExtremeC_examples_chapter12_4.c]：使用匿名结构和匿名联合的主函数
- en: 'In this example we are creating an anonymous union that has an anonymous structure
    within. Therefore, the same memory region is used to store an instance of the
    anonymous structure and the two-element integer array. Next, you can see the output
    of the preceding program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了一个包含匿名结构的匿名联合。因此，相同的内存区域用于存储匿名结构的一个实例和两个元素的整数数组。接下来，你可以看到前面程序的输出：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shell Box 12-4: Compiling and running example 12.4'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本框 12-4：编译和运行示例 12.4
- en: As you can see, any changes to the two-element integer array can be seen in
    the structure variable, and vice versa.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对两个元素的整数数组的任何更改都可以在结构变量中看到，反之亦然。
- en: Multithreading
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: Multithreading support has been available in C for a long time via POSIX threading
    functions, or the `pthreads` library. We have covered multithreading thoroughly
    in *Chapter 15*, *Thread Execution*, and *Chapter 16*, *Thread Synchronization*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言通过 POSIX 线程函数或 `pthreads` 库长期以来一直支持多线程。我们在第 15 章“线程执行”和第 16 章“线程同步”中全面介绍了多线程。
- en: The POSIX threading library, as the name implies, is only available in POSIX-compliant
    systems such as Linux and other Unix-like systems. Therefore, if you are on a
    non-POSIX compliant operating system such as Microsoft Windows, you have to use
    the library provided by the operating system. As part of C11, a standard threading
    library is provided that can be used on all systems that are using standard C,
    regardless of whether it's POSIX-compliant or not. This is the biggest change
    we see in the C11 standard.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，POSIX 线程库仅在符合 POSIX 的系统（如 Linux 和其他类 Unix 系统）中可用。因此，如果你使用的是非 POSIX 兼容的操作系统，如
    Microsoft Windows，你必须使用操作系统提供的库。作为 C11 的一部分，提供了一个标准线程库，可以在所有使用标准 C 的系统上使用，无论其是否符合
    POSIX。这是我们在 C11 标准中看到的最大变化。
- en: Unfortunately, C11 threading is not implemented for Linux and macOS. Therefore,
    we cannot provide working examples at the time of writing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C11 线程在 Linux 和 macOS 上没有实现。因此，我们无法在撰写本文时提供工作示例。
- en: A bit about C18
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 C18 的一些信息
- en: 'As we''ve mentioned in the earlier sections, the C18 standard contains all
    the fixes that were made in C11, and no new feature has been introduced as part
    of it. As said before, the following link takes you to a page on which you can
    see the issues created and being tracked for C11 and the discussions around them:
    http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们前面提到的，C18 标准包含了 C11 中所做的所有修复，并且没有在它中引入任何新功能。正如之前所说，以下链接带你到一个页面，你可以看到为 C11
    创建并跟踪的问题以及围绕它们进行的讨论：http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we went through C11, C18, and the most recent C standards,
    and we explored C11's various new features. Unicode support, anonymous structures
    and unions, and the new standard threading library (despite the fact that it is
    not available in recent compilers and platforms to date) are among the most important
    features that have been introduced in modern C. We will look forward to seeing
    new versions of the C standard in the future.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了C11、C18以及最新的C标准，并探讨了C11的各种新特性。Unicode支持、匿名结构和联合体，以及新的标准线程库（尽管到目前为止它尚未在最近的编译器和平台上可用）是现代C语言中引入的最重要特性之一。我们期待着未来看到C标准的新的版本。
- en: In the next chapter, we begin to talk about concurrency and the theory behind
    concurrent systems. This will begin a long journey through six chapters in which
    we'll cover multithreading and multi-processing in order to fulfil our purpose
    to be able to write concurrent systems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始讨论并发以及并发系统的理论。这将开启一段长达六章的漫长旅程，我们将涵盖多线程和多进程，以实现我们编写并发系统的目的。
