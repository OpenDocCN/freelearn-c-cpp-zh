- en: Using the Standard Library Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准库容器
- en: The Standard Library provides several types of containers; each is provided
    through a templated class so that the behavior of the container can be used for
    items of any type. There are classes for sequential containers, where the ordering
    of the items in the container is dependent on the order that the items are inserted
    into the container. Also there are sorted and unsorted associated containers that
    associate a value with a key, and subsequently the value is accessed using the
    key.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几种类型的容器；每种容器都是通过模板类提供的，因此容器的行为可以用于任何类型的项目。有顺序容器的类，其中容器中项目的排序取决于项目插入容器的顺序。还有排序和未排序的关联容器，它们将值与键关联起来，随后使用键访问值。
- en: 'Although not containers themselves, in this chapter we will also cover two
    related classes: `pair` that links two values together in one object, and `tuple`,
    that can hold one or more values in a single object.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们本身不是容器，在本章中我们还将介绍两个相关的类：`pair`将两个值链接在一个对象中，`tuple`可以在一个对象中保存一个或多个值。
- en: Working with pairs and tuples
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对和元组
- en: In many cases you will want to associate two items together; for example, an
    associative container allows you to create a type of array where items other than
    numbers are used as an index. The `<utility>` header file contains a templated
    class called `pair`, which has two data members called `first` and `second`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您将希望将两个项目关联在一起；例如，关联容器允许您创建一种数组类型，其中除数字以外的项目用作索引。`<utility>`头文件包含一个名为`pair`的模板类，它有两个名为`first`和`second`的数据成员。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since the class is templated, it means that you can associate any items, including
    pointers or references. Accessing the members is simple since they are public.
    You can also use the `get` templated function, so for a `pair` object `p` you
    can call `get<0>(p)` rather than `p.first`. The class also has a copy constructor,
    so that you can create an object from another object, and a move constructor.
    There is also a function called `make_pair` that will deduce the types of the
    members from the parameters:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该类是模板化的，这意味着您可以关联任何项目，包括指针或引用。访问成员很简单，因为它们是公共的。您还可以使用`get`模板化函数，因此对于`pair`对象`p`，您可以调用`get<0>(p)`而不是`p.first`。该类还具有复制构造函数，因此您可以从另一个对象创建对象，并且移动构造函数。还有一个名为`make_pair`的函数，它将从参数中推断出成员的类型：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Be wary because the compiler will use the type that it thinks is most appropriate;
    in this case the `pair` object created will be `pair<const char*, int>`, but if
    you want the `first` item to be a `string`, it is simpler to use the constructor.
    You can compare `pair` objects; the comparison is performed on the first member
    and only if they are equal is the second then compared:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心，因为编译器将使用它认为最合适的类型；在这种情况下，创建的`pair`对象将是`pair<const char*，int>`，但是如果要使`first`项目成为`string`，则使用构造函数更简单。您可以比较`pair`对象；比较是在第一个成员上执行的，只有在它们相等时才会比较第二个：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The parameters can be references:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是引用：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `make_pair` function will deduce the types from the parameters. The compiler
    cannot tell the difference between a variable and a reference to a variable. In
    C++11 you can use the `ref` function (in `<functional>`) to specify that the `pair`
    will be for references:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_pair`函数将从参数中推断出类型。编译器无法区分变量和对变量的引用。在C++11中，您可以使用`ref`函数（在`<functional>`中）来指定`pair`将用于引用：'
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to return two values from a function, you could do it via parameters
    passed by reference, but the code is less readable because you expect a return
    value to come through the return of a function rather than through its parameters.
    The `pair` class allows you to return two values in one object. One example is
    the `minmax` function in `<algorithm>`. This returns a `pair` object containing
    the parameters in order of the smallest first, and there is an overload where
    you can provide a predicate object if the default operator `<` should not be used.
    The following will print `{10,20}`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要从函数返回两个值，可以通过引用传递的参数来实现，但是代码不太可读，因为您期望通过函数的返回而不是通过其参数来获得返回值。`pair`类允许您在一个对象中返回两个值。一个例子是`<algorithm>`中的`minmax`函数。这返回一个包含参数的`pair`对象，按最小值的顺序排列，并且有一个重载，如果不应使用默认操作符`<`，则可以提供谓词对象。以下将打印`{10,20}`：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `pair` class associates two items. The Standard Library provides the `tuple`
    class that has a similar functionality, but since the template is variadic it
    means that you can have any number of parameters of any type. However, the data
    members are not named as in `pair`, instead you access them via the templated
    `get` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`pair`类关联两个项目。标准库提供了`tuple`类，具有类似的功能，但由于模板是可变的，这意味着您可以具有任意数量的任何类型的参数。但是，数据成员不像`pair`中那样命名，而是通过模板化的`get`函数访问它们：'
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line creates a `tuple` that holds three `int` items and it is initialized
    using an initialize list (you could use constructor syntax). The `tuple` is then
    printed to the console by accessing each data member in the object using a version
    of the `get` function where the template parameter indicates the index of the
    item. Note that the index is a template parameter, so you cannot provide it at
    runtime using a variable. If this is what you want to do, then it is a clear indication
    that you need to use a container such as `vector`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个包含三个`int`项目的`tuple`，并使用初始化列表进行初始化（您可以使用构造函数语法）。然后通过使用`get`函数的版本访问对象中的每个数据成员将`tuple`打印到控制台，其中模板参数指示项目的索引。请注意，索引是模板参数，因此您无法使用变量在运行时提供它。如果这是您想要做的事情，那么这清楚地表明您需要使用诸如`vector`之类的容器。
- en: 'The `get` function returns a reference, so this can be used to change the value
    of the item. For a `tuple t3`, this code changes the first item to `42` and the
    second to `99`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`函数返回一个引用，因此可以用来更改项目的值。对于`tuple t3`，此代码将第一个项目更改为`42`，第二个项目更改为`99`：'
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also extract all the items with one call, by using the `tie` function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`tie`函数一次提取所有项目。
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `tie` function returns a `tuple` in which each parameter is a reference
    and initialized to the variables that you pass as parameters. The previous code
    is easier to understand if you write it like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`tie`函数返回一个`tuple`，其中每个参数都是引用，并初始化为您传递的参数的变量。如果您这样写，前面的代码更容易理解：'
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A `tuple` object can be created from a `pair` object, and so you can use the
    `tie` function to extract values from a `pair` object too.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`对象可以从`pair`对象创建，因此您也可以使用`tie`函数从`pair`对象中提取值。'
- en: There is a helper function called `make_tuple`, which will deduce the types
    of the parameters. As with the `make_pair` function, you have to be wary of the
    deductions, so a floating-point number will be deduced to be a `double` and an
    integer will be an `int`. If you want the parameters to be references to specific
    variables, you can use the `ref` function or the `cref` function for a `const`
    reference.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`make_tuple`的辅助函数，它将推断参数的类型。与`make_pair`函数一样，您必须注意推断，因此浮点数将被推断为`double`，整数将是`int`。如果要求参数是特定变量的引用，可以使用`ref`函数或`cref`函数用于`const`引用。
- en: You can compare `tuple` objects as long as there are equal numbers of items
    and equivalent types. The compiler will refuse to compile comparisons of `tuple`
    objects that have different numbers of items or if the types of the items of one
    `tuple` objects cannot be converted to the types of the other `tuple` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 只要项目数量相等且类型相等，就可以比较`tuple`对象。如果`tuple`对象的项目数量不同，或者一个`tuple`对象的项目类型无法转换为另一个`tuple`对象的类型，编译器将拒绝编译比较。
- en: Containers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: 'The Standard Library containers allow you to group together zero or more items
    of the same type and access them serially through iterators. Every such object
    has a `begin` method that returns an iterator object to the first item and an
    `end` function that returns an iterator object for the item after the last item
    in the container. The iterator objects support pointer-like arithmetic, so that
    `end() - begin()` will give the number of items in the container. All container
    types will implement the `empty` method to indicate if there are no items in the
    container, and (except for `forward_list`) the `size` method is the number of
    items in the container. You are tempted to iterate through a container as if it
    is an array:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库容器允许您将相同类型的零个或多个项目组合在一起，并通过迭代器顺序访问它们。每个这样的对象都有一个`begin`方法，返回指向第一个项目的迭代器对象，以及一个`end`函数，返回指向容器中最后一个项目后面的项目的迭代器对象。迭代器对象支持类似指针的算术运算，因此`end()
    - begin()`将给出容器中的项目数。所有容器类型都将实现`empty`方法，以指示容器中是否没有项目，并且（除了`forward_list`）`size`方法是容器中项目的数量。您可能会尝试通过容器进行迭代，就像它是一个数组一样：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The problem is that not all containers allow random access, and if you decide
    it is more efficient to use another container, you''ll have to change how the
    container is accessed. This code also does not work well if you want to write
    generic code using templates. The previous code is better written using iterators:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，并非所有容器都允许随机访问，如果您决定使用另一个容器更有效，就必须更改容器的访问方式。如果要使用模板编写通用代码，这段代码也不起作用。最好使用迭代器编写前面的代码：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All of the containers have a `typedef` member called `iterator` that gives the
    type of the iterator returned from the `begin` method. Iterator objects behave
    like pointers, so you can obtain the item an iterator refers to using the dereference
    operator and move to the next item using the increment operator.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都有一个名为`iterator`的`typedef`成员，该成员给出从`begin`方法返回的迭代器的类型。迭代器对象的行为类似于指针，因此可以使用解引用运算符获取迭代器引用的项目，并使用增量运算符移动到下一个项目。
- en: For all containers except for `vector`, there is a guarantee that an iterator
    will remain valid even if other elements are deleted. If you insert items, then
    only `lists`, `forward_lists`, and associated container guarantee that the iterators
    remain valid. Iterators will be covered in more depth later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`vector`之外的所有容器都保证迭代器在删除其他元素时仍然有效。如果插入项目，则只有`lists`、`forward_lists`和相关容器保证迭代器保持有效。稍后将更深入地介绍迭代器。
- en: All containers have to have an exception safe (nothrow) method called `swap`,
    and (with two exceptions) they must have *transactional* semantics; that is, an
    operation must succeed or fail. If the operation fails, the container is in the
    same state as before the operation is called. For every container, this rule is
    relaxed when it comes to multi-element inserts. If you insert many items at a
    time using an iterator range, for example, and the insert fails for one of the
    items in the range, then the method will not be able to undo the previous inserts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都必须具有一个名为`swap`的异常安全（无异常）方法，并且（有两个例外）它们必须具有*事务*语义；也就是说，操作必须成功或失败。如果操作失败，则容器的状态与调用操作之前相同。对于每个容器，在进行多元素插入时，此规则在某种程度上放松。例如，如果使用迭代器范围一次插入多个项目，并且范围中的某个项目插入失败，则该方法将无法撤消先前的插入。
- en: It is important to point out that objects are copied into containers, so the
    type of the objects that you put into a container must have a copy and copy assignment
    operator. Also, be aware that if you put a derived class object into a container
    that requires a base class object, then the copying will slice the object, meaning
    that anything to do with the derived class is removed (data members and virtual
    method pointers).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，对象被复制到容器中，因此放入容器中的对象的类型必须具有复制和复制赋值运算符。还要注意，如果将派生类对象放入需要基类对象的容器中，那么复制将切割对象，这意味着与派生类有关的任何内容都将被删除（数据成员和虚方法指针）。
- en: Sequence containers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列容器
- en: Sequence containers store a series of items and the order that they are stored
    in, and, when you access them with an iterator, the items are retrieved in the
    order in which they were put into the container. After creating a container, you
    can change the sort order with library functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 序列容器存储一系列项目以及它们存储的顺序，当您使用迭代器访问它们时，项目将按照它们放入容器的顺序检索。创建容器后，您可以使用库函数更改排序顺序。
- en: List
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: As the name suggests, a `list` object is implemented by a doubly linked list
    in which each item has a link to the next item and the previous one. This means
    that it is quick to insert items (as the example in [Chapter 2](6ebba475-440c-4e33-acb1-094670bf962e.xhtml),
    *Working with Memory, Arrays, and Pointers*, showed with a singly linked list),
    but since, in a linked list, an item only has access to the items in front and
    behind it, there is no random access with the `[]` indexoperator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，`list`对象是通过双向链表实现的，其中每个项目都有一个链接到下一个项目和上一个项目的链接。这意味着快速插入项目（就像[第2章](6ebba475-440c-4e33-acb1-094670bf962e.xhtml)中的示例所示的那样，使用单链表），但是由于在链表中，项目只能访问其前面和后面的项目，因此没有`[]`索引运算符的随机访问。
- en: 'The class allows you to provide values through the constructor, or you can
    use member methods. For example, the `assign` method allows you fill the container
    in one action using an initializer list, or, with iterators, to a range in another
    container. You can also insert a single item using the `push_back` or `push_front`
    method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该类允许您通过构造函数提供值，或者您可以使用成员方法。例如，`assign`方法允许您使用初始化列表一次填充容器，或者使用迭代器将范围填充到另一个容器。您还可以使用`push_back`或`push_front`方法插入单个项目：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first line creates a `list` object that contains `3`, `5`, and `7`, and
    then pushes `11` and `13` to the end (in that order), so that the `list` contains
    `{3,5,7,11,13}`. The code then pushes the numbers `2` and `1` to the front, so
    that the final `list` is `{1,2,3,5,7,11,13}`. In spite of the names, the `pop_front`
    and `pop_back` methods just remove the item at the front or back of the list,
    but will not return the item. If you want to get the item that has been removed,
    you must *first* access the item through the `front` or `back` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建一个包含`3`、`5`和`7`的`list`对象，然后将`11`和`13`推送到末尾（按顺序），使得`list`包含`{3,5,7,11,13}`。然后代码将数字`2`和`1`推送到前面，使得最终的`list`是`{1,2,3,5,7,11,13}`。尽管名称如此，`pop_front`和`pop_back`方法只是删除列表的前面或后面的项目，但不会返回项目。如果要获取已删除的项目，必须首先通过`front`或`back`方法访问项目：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `clear` method will remove all items in the `list` and the `erase` method
    will delete items. There are two versions: one with an iterator that identifies
    a single item and another that has two iterators that indicate a range. A range
    is indicated by providing the first item in the range and the item *after* the
    range.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear`方法将删除`list`中的所有项目，`erase`方法将删除项目。有两个版本：一个带有标识单个项目的迭代器，另一个带有指示范围的两个迭代器。通过提供范围的第一个项目和范围之后的项目来指示范围。'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a general principle with iterators and the Standard Library containers;
    a range is indicated by iterators by the first item and the item *after* the last
    item. The `remove` method will remove all items with a specified value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与迭代器和标准库容器相关的一般原则；一个范围由迭代器指示，第一个项目和最后一个项目之后的项目。`remove`方法将删除所有具有指定值的项目：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is also a method `remove_if` that takes a predicate and will only remove
    an item if the predicate returns `true`. Similarly, you can insert items into
    a list with an iterator, and the item is inserted before the specified item:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`remove_if`方法，它接受一个谓词，只有在谓词返回`true`时才会删除一个项目。类似地，您可以使用迭代器将项目插入列表，并且项目将在指定项目之前插入：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also indicate that the item should be inserted more than once at that
    position (and if so, how many copies) and you can provide several items to be
    inserted at one point. Of course, if the iterator you pass is obtained by calling
    the `begin` method, then the item is inserted at the beginning of the `list`.
    The same can be achieved by calling the `push_front` method. Similarly, if the
    iterator is obtained by calling the `end` method, then the item is inserted at
    the end of the `list`, which is the same as calling `push_back`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指示应在该位置插入项目多次（如果是这样，还可以提供多少个副本），并且可以在一个位置提供多个项目。当然，如果您传递的迭代器是通过调用`begin`方法获得的，则项目将插入到`list`的开头。通过调用`push_front`方法也可以实现相同的效果。同样，如果迭代器是通过调用`end`方法获得的，则项目将插入到`list`的末尾，这与调用`push_back`相同。
- en: 'When you call the `insert` method, you provide an object that will either be
    copied into the `list` or moved into the `list` (through rvalue semantics). The
    class also provides several **emplace** methods (`emplace`, `emplace_front`, and
    `emplace_back`) that will construct a new object based on the data you provide,
    and insert that object in the `list`. For example, if you have a `point` class
    that can be created from two `double` values, you can either `insert` a constructed
    `point` object or `emplace` a `point` object by providing two `double` values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`insert`方法时，您提供一个要复制或移动到`list`中的对象（通过右值语义）。该类还提供了几个**emplace**方法（`emplace`、`emplace_front`和`emplace_back`），它们将根据您提供的数据构造一个新对象，并将该对象插入`list`中。例如，如果您有一个可以从两个`double`值创建的`point`类，您可以`insert`一个构造的`point`对象或通过提供两个`double`值`emplace`一个`point`对象：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once you have created a `list`, you can manipulate it with member functions.
    The `swap` method takes a suitable `list` object as a parameter, it moves the
    items from the parameter into the current object, and moves the items in the current
    `list` to the parameter. Since the `list` object is implemented using linked lists,
    this operation is quick.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`list`后，可以使用成员函数对其进行操作。`swap`方法接受一个合适的`list`对象作为参数，将参数中的项目移动到当前对象中，并将当前`list`中的项目移动到参数中。由于`list`对象是使用链表实现的，因此此操作很快。
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After this, code `num1` will contain `{3,1,4,5,6,8}` and `num2` will contain
    `{2,7,1,8,2,8}`, as the following illustrates:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，代码`num1`将包含`{3,1,4,5,6,8}`，`num2`将包含`{2,7,1,8,2,8}`，如下所示：
- en: '![](img/18cb70c4-6f3d-413a-8eb2-b45b67438dc2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18cb70c4-6f3d-413a-8eb2-b45b67438dc2.png)'
- en: 'A `list` will hold the items in the order that they were inserted into the
    container; however, you can sort them by calling the `sort` method that will,
    by default, order items in ascending order using the `<` operator for the items
    in the `list` container. You can also pass a function object for a comparison
    operation. Once sorted, you can reverse the order of items by calling the `reverse`
    method. Two sorted lists can be merged, which involves taking the items from the
    argument list and inserting them into the calling list, in order:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`将按照插入容器的顺序保存项目；但是，您可以通过调用`sort`方法对它们进行排序，默认情况下，将使用`<`运算符对`list`容器中的项目进行升序排序。您还可以传递一个函数对象进行比较操作。排序后，可以通过调用`reverse`方法来颠倒项目的顺序。两个排序列表可以合并，这涉及从参数列表中获取项目并按顺序插入到调用列表中：'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Merging two lists may result in duplicates, and these can be removed by calling
    the `unique` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个列表可能会导致重复项，可以通过调用`unique`方法来移除这些重复项：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Forward list
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向列表
- en: As the name suggests, the `forward_list` class is like the `list` class, but
    it only allows items to insert and remove items from the front of the list. It
    also means that the iterators used with the class can only be incremented; the
    compiler will refuse to allow you to decrement such an iterator. The class has
    a subset of the methods of `list`, so it has the `push_front`, `pop_front`, and
    `emplace_front` methods, but not the corresponding `_back` methods. There are
    some other methods that it implements, and, because the list items can only be
    accessed in a forward direction, it means that insertions will occur after an
    existing item, and hence the class implements `insert_after` and `emplace_after`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`forward_list`类类似于`list`类，但它只允许从列表前面插入和移除项目。这也意味着与该类一起使用的迭代器只能递增；编译器将拒绝允许您递减这样的迭代器。该类具有`list`方法的子集，因此具有`push_front`、`pop_front`和`emplace_front`方法，但没有相应的`_back`方法。它还实现了一些其他方法，因为列表项目只能以前向方式访问，这意味着插入将发生在现有项目之后，因此该类实现了`insert_after`和`emplace_after`。
- en: 'Similarly, you can remove items at the beginning of the list (`pop_front`)
    or after a specified item (`erase_after`), or tell the class to iterate in a forward
    direction through the list and remove items with a specific value (`remove` and
    `remove_if`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以从列表开头移除项目（`pop_front`）或在指定项目之后移除项目（`erase_after`），或者告诉类在列表中以前向方式迭代并移除具有特定值的项目（`remove`和`remove_if`）：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, `euler` is initialized with the digits of Euler's number
    and a value of `-1` is pushed to the front. Next, an iterator is obtained that
    points to the first value in the container; that is, to the position of the value
    of `-1`. A value of `-2` is inserted after the position of the iterator; that
    is, `-2` is inserted after the value of `-1`. The last two lines show how to remove
    items; `pop_front` removes the item at the front of the container and `remove_if`
    will remove items that satisfy the predicate (in this case when the item is less
    than zero).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`euler`被初始化为Euler数的数字，并且值为`-1`被推到最前面。接下来，获得一个指向容器中第一个值的迭代器；也就是说，指向值为`-1`的位置。在迭代器的位置之后插入了值为`-2`；也就是说，在值为`-1`之后插入了`-2`。最后两行展示了如何移除项目；`pop_front`移除容器前面的项目，`remove_if`将移除满足谓词的项目（在这种情况下，项目小于零时）。
- en: Vector
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: The `vector` class has the behavior of a dynamic array; that is, there is indexed
    random access to items and the container will grow as more items are inserted
    into it. You can create a `vector` object with an initialization list, and with
    a specified number of copies of an item. You can also base a `vector` on values
    in another container by passing iterators that indicate the range of items in
    that container. You can create a vector with a pre-determined size by providing
    a capacity as the constructor parameter, and the specified number of default items
    will be created in the container. If, at a later stage, you need to specify the
    container size, you can call the `reserve` method to specify the minimum size
    or the `resize` method, which may mean deleting excess items or creating new items
    depending on whether the existing `vector` object is bigger or smaller than the
    requested size.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类具有动态数组的行为；也就是说，可以对项目进行索引随机访问，并且随着插入更多项目，容器将会增长。您可以使用初始化列表创建`vector`对象，并使用指定数量的项目副本。您还可以基于另一个容器中的值创建`vector`，方法是传递指示该容器中项目范围的迭代器。您可以通过提供容量作为构造函数参数来创建具有预定大小的向量，并且容器中将创建指定数量的默认项目。如果在以后的阶段需要指定容器大小，可以调用`reserve`方法来指定最小大小，或者`resize`方法，这可能意味着删除多余的项目或根据现有`vector`对象是更大还是更小来创建新项目。'
- en: When you insert items into a `vector` container and there is not enough memory
    allocated, then the container will allocate enough memory. This will involve allocating
    new memory, copying the existing items into the new memory, creating the new item,
    and, finally, destroying the old copy of the items and deallocating the old memory.
    Clearly, if you know the number of items and you know that the `vector` container
    will not be able to contain them without a new allocation, you should indicate
    how much space you need by calling the `reserve` method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向`vector`容器插入项目并且没有分配足够的内存时，容器将分配足够的内存。这将涉及分配新内存，将现有项目复制到新内存中，创建新项目，最后销毁旧项目的副本并释放旧内存。显然，如果您知道项目的数量，并且知道`vector`容器没有足够的空间来容纳它们而需要新的分配，您应该通过调用`reserve`方法指示需要多少空间。
- en: Inserting items other than the constructor is straightforward. You can use `push_back`
    to insert an item at the end (which is a fast action, assuming no allocation is
    needed) and there is also `pop_back` to remove the last item. You can also use
    the `assign` method to clear the entire container and insert the specified items
    (either a multiple of the same item, an initializer list of items, or items in
    another container specified with iterators). As with `list` objects, you can clear
    the entire `vector`, erase items at a position, or insert items at a specified
    position. However, there is no equivalent of the `remove` method to remove items
    with a specific value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数之外插入项目是简单的。您可以使用“push_back”在末尾插入项目（假设不需要分配，这是一个快速操作），还有“pop_back”来移除最后一个项目。您还可以使用“assign”方法清除整个容器并插入指定的项目（多个相同项目，项目的初始化列表，或使用迭代器指定的另一个容器中的项目）。与“list”对象一样，您可以清除整个“vector”，在特定位置擦除项目，或在指定位置插入项目。但是，没有相当于“remove”方法来删除具有特定值的项目。
- en: 'The main reason to use the `vector` class is to get random access using either
    the `at` method or the `[]` indexing operator:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“vector”类的主要原因是使用“at”方法或“[]”索引运算符进行随机访问：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line creates a `vector` with ten items, and then in the loop the C
    runtime function `rand` is called a thousand times each time to get a pseudo random
    number between 0 and 32767\. The modulus operator is used to get, in approximate
    terms, a random number between 0 and 9\. This random number is then used as an
    index for the `distrib` object to select a specified item, which is then incremented.
    Finally, the distribution is printed out and, as you would expect, this gives
    a value of roughly 100 in each item.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个具有十个项目的“vector”，然后在循环中每次调用C运行时函数“rand”一千次，以获得一个在0和32767之间的伪随机数。使用模运算来获得大约在0和9之间的随机数。然后将这个随机数用作“distrib”对象的索引，以选择指定的项目，然后递增。最后，分布被打印出来，正如你所期望的那样，这给出了每个项目大约100的值。
- en: This code relies on the fact that the `[]` operator returns a reference to the
    item, which is why the item can be incremented in this manner. The `[]` operator
    can be used to read and write to an item in the container. The container gives
    iterator access through the `begin` and `end` methods, and (since they are needed
    by the container adapters) the `front` and `back` methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码依赖于“[]”运算符返回项目的引用这一事实，这就是为什么可以以这种方式递增项目。可以使用“[]”运算符读取和写入容器中的项目。容器通过“begin”和“end”方法提供迭代器访问，并且（因为它们被容器适配器所需）提供“front”和“back”方法。
- en: A `vector` object can hold any type that has a copy constructor and assignment
    operator, which means all the built-in types. As it stands, a `vector` of `bool`
    items would be a waste of memory because a Boolean value can be stored as a single
    bit and the compiler will treat a `bool` as an integer (32 bits). The Standard
    Library has a specialization of the `vector` class for `bool` that stores items
    more efficiently. However, although the class at first sight looks like a good
    idea, the problem is that, since the container holds Boolean values as bits, this
    means that the `[]` operator doesn't return a reference to a `bool` (instead it
    returns an object that behaves like one).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “vector”对象可以保存具有复制构造函数和赋值运算符的任何类型，这意味着所有内置类型。就目前而言，一个“bool”项目的“vector”将是一种浪费内存，因为布尔值可以存储为单个位，并且编译器将把“bool”视为整数（32位）。标准库为“bool”专门化了“vector”类，以更有效地存储项目。然而，尽管这个类乍一看是一个好主意，问题在于，由于容器将布尔值存储为位，这意味着“[]”运算符不会返回对“bool”的引用（而是返回一个像布尔值一样行为的对象）。
- en: If you want to hold Boolean values and manipulate them then, as long as you
    know at compile time how many items there are, the `bitset` class is probably
    a better choice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要保存布尔值并对其进行操作，只要在编译时知道有多少项目，“bitset”类可能是更好的选择。
- en: Deque
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双端队列
- en: The name `deque` means *double-ended queue*, which means that it can grow from
    both ends, and, although you can insert items in the middle, it is more expensive.
    As a queue, it means that the items are ordered, but, because the items can be
    put into the queue from either end, the order is not necessarily the same order
    in which you put items into the container.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 名称“deque”意味着*双端队列*，这意味着它可以从两端增长，尽管您可以在中间插入项目，但这更昂贵。作为队列，这意味着项目是有序的，但是，因为项目可以从任一端放入队列，所以顺序不一定是您将项目放入容器的顺序。
- en: The interface of `deque` is similar to a `vector`, so you have iterator access
    as well as random access using the `at` function and the `[]` operator. As with
    a `vector`, you can access items from the end of a `deque` container using the
    `push_back`, `pop_back`, and `back` methods, but, unlike a `vector`, you can also
    access the front of a `deque` container using the `push_front`, `pop_front`, and
    `front` methods. Although the `deque` class has methods to allow you to insert
    and erase items within the container, and to `resize`, these are expensive operations,
    and if you need to use them then you should reconsider using this container type.
    Furthermore, the `deque` class does not have methods to pre-allocate memory, so,
    potentially, when you add an item to this container, it could cause a memory allocation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “deque”的接口类似于“vector”，因此您可以使用“at”函数和“[]”运算符进行迭代访问以及随机访问。与“vector”一样，您可以使用“push_back”、“pop_back”和“back”方法访问“deque”容器的末尾的项目，但与“vector”不同的是，您还可以使用“push_front”、“pop_front”和“front”方法访问“deque”容器的前端。尽管“deque”类有方法允许您在容器中插入和删除项目，并且“resize”，但这些是昂贵的操作，如果您需要使用它们，那么您应该重新考虑使用这种容器类型。此外，“deque”类没有方法来预先分配内存，因此，潜在地，当您向此容器添加项目时，它可能会导致内存分配。
- en: Associative containers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联容器
- en: With a C-like `array` or a `vector`, each item is associated with its numeric
    index. Earlier this was exploited in one of the examples in the section on `vector`
    in which the index provided the decile of the distribution and, conveniently,
    the distribution was split in a way that the ten deciles of data are numbered.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似C的“数组”或“向量”，每个项目都与其数字索引相关联。早些时候，在“向量”部分的一个示例中，这在分布的十分位数中被利用，方便地，分布被分割成了十个数据的十分位数。
- en: An associative container allows you to provide indexes that are not numeric;
    these are the keys, and you can associate values with them. As you insert key-value
    pairs into the container, they will be ordered so that the container can subsequently
    efficiently access the value by its key. Typically, this order should not matter
    to you since you will not use the container to access items sequentially, and
    instead you will access values by their keys. A typical implementation will use
    a binary tree or a hash table, which means that it is a quick operation to find
    an item according to its key.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器允许您提供非数字索引的键，并且您可以将值与它们关联起来。当您将键值对插入容器时，它们将被排序，以便容器随后可以通过其键有效地访问值。通常，这个顺序对您来说不重要，因为您不会使用容器按顺序访问项目，而是会通过它们的键访问值。典型的实现将使用二叉树或哈希表，这意味着根据其键查找项目是一个快速的操作。
- en: For ordered containers, such as `map`, there will be comparisons carried out
    between the key and the existing keys in the container using `<` (the less predicate).
    The default predicate means that the keys are compared, and if this is, say, a
    smart pointer, then it will be the smart pointer objects that will be compared
    and used for the ordering, not the object that they wrap. In this case, you will
    want to write your own predicate to perform the appropriate comparison and pass
    it as a template parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有序容器，比如`map`，将使用`<`（小于谓词）在容器中的现有键和键之间进行比较。默认谓词意味着将比较键，如果这是一个智能指针，那么将比较并用于排序的将是智能指针对象，而不是它们包装的对象。在这种情况下，您将需要编写自己的谓词来执行适当的比较，并将其作为模板参数传递。
- en: This means it is typically expensive to insert or erase items, and the key is
    treated as immutable, so you cannot alter it for an item. For all associative
    containers, there are no remove methods, but there are erase methods. However,
    for those containers that keep items sorted, erasing an item could affect performance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着插入或删除项目通常是昂贵的，并且键被视为不可变，因此您不能为项目更改它。对于所有关联容器，没有删除方法，但有擦除方法。但是，对于那些保持项目排序的容器，擦除项目可能会影响性能。
- en: There are several types of associative containers, and the main difference is
    how they handle duplicate keys and the level of ordering that occurs. The `map`
    class has key-value pairs sorted by unique keys, so duplicate keys are not allowed.
    If you want to allow duplicate keys, then you can use the `multimap` class. The
    `set` class is essentially a map where the key is the same as the value, which,
    again, does not allow duplicates. The `multiset` class does allow duplicates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的关联容器，主要区别在于它们如何处理重复的键以及发生的排序级别。`map`类具有按唯一键排序的键值对，因此不允许重复的键。如果要允许重复的键，则可以使用`multimap`类。`set`类本质上是一个键与值相同的映射，同样不允许重复。`multiset`类允许重复。
- en: It may seem odd to have an associative class where the key is the same as the
    value, but the reason for including the class in this section is because, like
    the `map` class, the `set` class has a similar interface to find a value. Also
    similar to the `map` class, the `set` class is fast at finding an item.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联类中，键与值相同可能看起来很奇怪，但在本节中包含该类的原因是因为，与`map`类一样，`set`类具有类似的接口来查找值。与`map`类类似，`set`类在查找项目时速度很快。
- en: Maps and multimaps
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射和多重映射
- en: 'A `map` container stores two different items, a key and a value, and it maintains
    the items in an sort order according to the key. A sorted `map` means that it
    is quick to locate an item. The class has the same interface as other containers
    to add items: you can put them into the container via the constructor, or you
    can use member methods `insert` and `emplace`. You also have access to items via
    iterators. Of course, an iterator gives access to a single value, so with a map
    this will be to a `pair` object that has both the key and the value:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`容器存储两个不同的项目，一个键和一个值，并且根据键以排序顺序维护项目。排序的`map`意味着快速定位项目。该类具有与其他容器相同的接口来添加项目：您可以通过构造函数将它们放入容器中，也可以使用成员方法`insert`和`emplace`。您还可以通过迭代器访问项目。当然，迭代器提供对单个值的访问，因此对于`map`来说，这将是对具有键和值的`pair`对象的访问：'
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The calls to `emplace` puts items into the `map` where the key is a `string`
    (the name of a president) and the value is an `int` (the year the president started
    their term of office). The code then obtains an iterator to the first item in
    the container, and the item is accessed by dereferencing the iterator to give
    a `pair` object. Since the items are stored in the `map` in a sorted order, the
    first item will be set to `"Adams"`. You can also insert items as `pair` objects,
    either as objects or through iterators to `pair` objects in another container
    using the `insert` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对`emplace`的调用将项目放入`map`中，其中键是`string`（总统的名字），值是`int`（总统开始任期的年份）。然后，代码获取容器中第一个项目的迭代器，并通过解引用迭代器访问项目以给出`pair`对象。由于项目按排序顺序存储在`map`中，第一个项目将设置为“Adams”。您还可以将项目作为`pair`对象插入，可以是对象，也可以通过`insert`方法使用另一个容器中的`pair`对象的迭代器。
- en: 'Most of the `emplace` and `insert` methods will return a `pair` object of the
    following form, where the `iterator` type is relevant to the `map`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的`emplace`和`insert`方法将返回以下形式的`pair`对象，其中`iterator`类型与`map`相关：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You use this object to test for two things. First, the `bool` indicates if the
    insertion was successful (it will fail if an item with the same key is already
    in the container). Secondly, the `iterator` part of the `pair` either indicates
    the position of the new item or it indicates the position of the existing item
    that will not be replaced (and will cause the insertion to fail).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此对象测试两件事。首先，`bool`指示插入是否成功（如果具有相同键的项目已在容器中，则插入将失败）。其次，`pair`的`iterator`部分指示新项目的位置，或者指示不会被替换的现有项目的位置（并且将导致插入失败）。
- en: The *failure* depends on *equivalence* rather than *equality*. If there is an
    item with a key that is equivalent to the item you are trying to insert, then
    the insertion will fail. The definition of equivalence depends on the comparator
    predicate being used with the `map` object. So, if the `map` uses a predicate
    `comp`, then equivalence between the two items, `a` and `b`, is determined by
    testing `!comp(a,b) && !comp(b,a)`. This is not the same as testing for `(a==b)`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*失败*取决于*等价*而不是*相等*。如果具有等效于您要插入的项目的键的项目，则插入将失败。等效性的定义取决于与`map`对象一起使用的比较器谓词。因此，如果`map`使用谓词`comp`，则两个项目`a`和`b`之间的等效性是通过测试`!comp(a,b)
    && !comp(b,a)`来确定的。这与测试`(a==b)`不同。'
- en: 'Assuming the previous `map` object, you can do this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设先前的`map`对象，您可以这样做：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The second item in the `result` variable is tested to see if the insertion was
    successful, and if not, then the first item is an iterator to a `pair<string,int>`,
    which is the existing item, and the code dereferences the iterator to get the
    `pair` object and then prints out the first item, which is the key (in this case,
    the name of the person).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对`result`变量中的第二个项目进行测试，以查看插入是否成功，如果没有，则第一个项目是指向`pair<string,int>`的迭代器，这是现有项目，代码对迭代器进行解引用以获取`pair`对象，然后打印出第一个项目，这是键（在这种情况下是人的姓名）。
- en: 'If you know where in the `map` the item should go, then you can call `emplace_hint`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道项目应该放在`map`中的位置，那么可以调用`emplace_hint`：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we know that `Polk` comes after `Monroe` so we can pass the iterator to
    `Monroe` as the hint. The class gives access to items via iterators, so you can
    use ranged `for` (which is based on iterator access):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们知道`Polk`在`Monroe`之后，所以我们可以将`Monroe`的迭代器作为提示。该类通过迭代器访问项目，因此您可以使用基于迭代器访问的范围`for`（它基于迭代器访问）：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, there is access to individual items using the `at` method and the
    `[]` operator. In both cases the class will search for an item with the provided
    key and if the item is found, a reference to the item's value is returned. The
    `at` method and the `[]` operator behave differently in a situation where there
    is no item with the specified key.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用`at`方法和`[]`运算符访问单个项目。在这两种情况下，类将搜索具有提供的键的项目，如果找到项目，则返回对项目值的引用。在没有指定键的项目的情况下，`at`方法和`[]`运算符的行为是不同的。
- en: 'If the key does not exist, the `at` method will throw an exception; if the
    `[]` operator cannot find the specified key, it will create a new item using the
    key and calling the default constructor of the value type. The `[]` operator will
    return a reference to the value if the key exists, so you can write code like
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不存在，`at`方法将引发异常；如果`[]`运算符找不到指定的键，它将使用该键创建一个新项目，并调用值类型的默认构造函数。如果键存在，`[]`运算符将返回对值的引用，因此您可以编写如下代码：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second line behaves as you expect: there will be no item with a key of
    `Jackson`, so the `map` will create an item with that key, initialize it by calling
    the default constructor of the value type (`int`, so the value is initialized
    to zero), and then it returns a reference to this value, which is assigned a value
    of `1829`. The first line, however, will look up `Adams`, see that there is an
    item, and return a reference to its value, which is then assigned a value of `1825`.
    There is no indication that the value of an item has been changed as opposed to
    a new item being inserted. You may want this behavior in some circumstances, but
    it is not the intention in this code, where, clearly, an associative container
    that allows duplicate keys (such as `multimap`) is needed. Furthermore, in both
    of these cases, there is a search for the key, a reference is returned, and then
    an assignment is performed. Be aware that, although it is valid to insert items
    this way, it is more efficient to emplace a new key-value pair in the container
    because you do not have this extra assignment.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行的行为与您期望的相同：没有键为`Jackson`的项目，因此`map`将创建一个具有该键的项目，通过调用值类型（`int`）的默认构造函数进行初始化（因此值初始化为零），然后返回对此值的引用，该值被赋予`1829`的值。然而，第一行将查找`Adams`，看到有一个项目，并返回对其值的引用，然后将其赋予`1825`的值。没有迹象表明项目的值已更改，而不是插入了新项目。在某些情况下，您可能希望出现这种行为，但这并不是本代码的意图，显然需要一个允许重复键的关联容器（例如`multimap`）。此外，在这两种情况下，都会搜索键，返回引用，然后执行赋值。请注意，虽然以这种方式插入项目是有效的，但在容器中放置新的键值对更有效，因为您不需要进行额外的赋值。
- en: 'Once you have filled the `map` you can search for a value using the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您填写了`map`，您就可以使用以下方法搜索值：
- en: The `at` method, which is passed a key and returns a reference to the value
    for that key
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`方法，传递一个键并返回该键的值的引用'
- en: The `[]` operator, which when passed a key returns a reference to the value
    for that key
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]`运算符，当传递一个键时，返回该键的值的引用'
- en: The `find` function, which will use the predicate specified in the template
    (unlike the global `find` function, mentioned later) and it will give you an iterator
    to the entire item as a `pair` object
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`函数将使用模板中指定的谓词（与后面提到的全局`find`函数不同），并将为您提供到整个项目的`pair`对象的迭代器'
- en: The `begin` method will give you an iterator to the first item and the `end`
    method will give you an iterator *after* the last item
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`方法将为您提供到第一个项目的迭代器，`end`方法将为您提供到最后一个项目之后的迭代器'
- en: The `lower_bound` method returns an iterator to the item that has a key *equal**to
    or greater* than the key that you pass as a parameter
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower_bound`方法返回一个迭代器，该迭代器指向具有与您传递的键*相等或更大*的键的项目'
- en: The `upper_bound` method returns an iterator of the first item in the map that
    has a key *greater* than the key provided
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upper_bound`方法返回一个迭代器，该迭代器指向具有大于提供的键的键的第一个项目'
- en: The `equal_range` method returns both the lower and upper bounds values in a
    `pair` object
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range`方法返回`pair`对象中的下限和上限值'
- en: Sets and multisets
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和多重集合
- en: 'Sets behave as if they are maps, but the key is the same as the value; for
    example, the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的行为就像它们是映射一样，但键与值相同；例如，以下内容：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will print out *nine* people in alphabetical order because there are two
    items called `Adams`, and the `set` class will reject duplicates. As the items
    are inserted into the set it will be ordered, and in this case the order is determined
    by the lexicon ordering of comparing two `string` objects. If you want to allow
    duplicates, so that ten people will be placed in the container, then you should
    use `multiset` instead.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按字母顺序打印出*九*个人，因为有两个名为`Adams`的项目，而`set`类将拒绝重复。当项目插入到集合中时，它将被排序，而在这种情况下，顺序是由比较两个`string`对象的词典顺序确定的。如果您想允许重复，以便将十个人放入容器中，那么您应该使用`multiset`。
- en: As with a `map`, you cannot change the key of an item in the container because
    the key is used to determine the ordering. For a `set`, the key is the same as
    the value, so this means that you cannot change the item at all. If the intention
    is to perform lookups, then it may be better to use a sorted `vector` instead.
    A `set` will have more memory allocation overhead than a `vector`. Potentially,
    a lookup on a `set` container will be quicker than on a `vector` container if
    the search is sequential, but if you use a call to `binary_search` (explained
    in the *Sorting items* section, later) it could be faster than the associative
    container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与`map`一样，您不能更改容器中项目的键，因为键用于确定排序。对于`set`，键与值相同，这意味着您根本不能更改项目。如果意图是执行查找，那么最好使用排序的`vector`。`set`的内存分配开销比`vector`大。潜在地，如果搜索是顺序的，`set`容器上的查找可能比`vector`容器上的查找更快，但如果使用`binary_search`调用（稍后在*排序项目*部分中解释），它可能比关联容器更快。
- en: The interface to the `set` class is a restricted version of the `map` class,
    so you can `insert` and `emplace` items in the container, assign it to values
    in another container, and you have iterator access (`begin` and `end` methods).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`类的接口是`map`类的受限版本，因此您可以在容器中`insert`和`emplace`项目，将其分配给另一个容器中的值，并且可以使用迭代器访问（`begin`和`end`方法）。'
- en: Since there is no distinct key, it means that the `find` method looks for a
    value, not a key (and similarly with the bounds methods; for example, `equal_range`).
    There is no `at` method, nor an `[]` operator.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有明确的键，这意味着`find`方法寻找值，而不是键（类似地，边界方法也是如此；例如，`equal_range`）。没有`at`方法，也没有`[]`运算符。
- en: Unordered containers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序容器
- en: The `map` and `set` classes allow you to find objects quickly, and this is facilitated
    by these classes holding the items in a sorted order. If you iterate through the
    items (from `begin` to `end`), then you will get those items in the sorted order.
    If you want a selection of objects within a range of the key values, you can make
    calls to the `lower_bound` and `upper_bound` methods, to get iterators to the
    appropriate ranges of keys.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`set`类允许您快速查找对象，这是由这些类以排序顺序保存项目来实现的。如果您遍历项目（从`begin`到`end`），那么您将按排序顺序获取这些项目。如果您想要一系列键值范围内的对象，可以调用`lower_bound`和`upper_bound`方法，以获取适当键范围的迭代器。'
- en: 'This are two important features of these associative containers: lookup and
    sorting. In some cases the actual order of the values is not important, and the
    behavior you want is efficient lookup. In this case, you can use the `unordered_`
    versions of the `map` and `set` classes. Since the order is unimportant, these
    are implemented using a hash table.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关联容器的两个重要特性是查找和排序。在某些情况下，值的实际顺序并不重要，您想要的行为是高效的查找。在这种情况下，您可以使用`map`和`set`类的`unordered_`版本。由于顺序不重要，这些是使用哈希表实现的。
- en: Special purpose containers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊目的容器
- en: The containers described so far are flexible and can be used for all kinds of
    purposes. The Standard Library provides classes that have specific purposes, but,
    because they are implemented by wrapping other classes, they are called **container
    adapters**. For example, a `deque` object can be used as a **first-in first-out**
    (**FIFO**) queue, by pushing objects to the back of the `deque` (with `push_back`)
    and then accessing objects from the front of the queue using the `front` method
    (and removing them with `pop_front`). The Standard Library implements a container
    adapter called `queue` that has this FIFO behavior, and it is based on the `deque`
    class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的容器是灵活的，可以用于各种目的。标准库提供了具有特定目的的类，但由于它们是通过包装其他类实现的，因此它们被称为**容器适配器**。例如，`deque`对象可以通过将对象推到`deque`的后面（使用`push_back`）并使用`front`方法从队列的前面访问对象（并使用`pop_front`删除它们）来用作**先进先出**（**FIFO**）队列。标准库实现了一个名为`queue`的容器适配器，它具有这种FIFO行为，并且基于`deque`类。
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You `push` items into the queue and remove them with `pop`, and the next item
    is accessed using the `front` method. The Standard Library containers that can
    be wrapped by this adapter must implement the `push_back`, `pop_front`, and `front`
    methods. That is, items are put into the container at one end and accessed (and
    removed) from the other end.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`push`将项目推入队列，并使用`pop`将其移除，并使用`front`方法访问下一个项目。可以由此适配器包装的标准库容器实现`push_back`、`pop_front`和`front`方法。也就是说，项目被放入容器的一端，并且从另一端访问（和移除）。
- en: A **last-in first-out** (**LIFO**) container will put in items and access (and
    remove) items from the same end. Again, a `deque` object can be used to implement
    this behavior by pushing items using `push_back`, accessing the items using `front`,
    and removing them with the `pop_back` method. The Standard Library provides an
    adapter class called `stack` to provide this behavior. This has a method called
    `push` to push items into the container, a method called `pop` to remove items,
    but, oddly, you access the next item using the `top` method, even though it is
    implemented using the `back` method of the wrapped container.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 后进先出（LIFO）容器将项目放入并从同一端访问（和移除）项目。同样，deque对象可以通过使用push_back推送项目，使用front访问项目，并使用pop_back方法删除它们来实现此行为。标准库提供了一个适配器类称为stack来提供这种行为。它有一个名为push的方法将项目推入容器，一个名为pop的方法来移除项目，但是奇怪的是，你使用top方法访问下一个项目，尽管它是使用包装容器的back方法实现的。
- en: 'The adapter class `priority_queue`, in spite of the name, is used like the
    `stack` container; that is, items are accessed using the `top` method. The container
    ensures that when an item is pushed in, the top of the queue will always be the
    item with the highest priority. A predicate (the default is `<`) is used to order
    the items in the queue. For example, we could have an aggregate type that has
    the name of a task and the priority in which you must complete the task compared
    to other tasks:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器类priority_queue，尽管名字叫这个，但它的使用方式类似于stack容器；也就是说，使用top方法访问项目。容器确保当一个项目被推入时，队列的顶部始终是具有最高优先级的项目。一个谓词（默认为<）用于对队列中的项目进行排序。例如，我们可以有一个聚合类型，它包含一个任务的名称和你必须完成任务的优先级，与其他任务相比：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The aggregate type is straightforward; it has two data members that are initialized
    by the constructor. So that tasks can be ordered, we need to be able to compare
    two task objects. One option (given earlier) is to define a separate predicate
    class. In this example, we use the default predicate, which the documentation
    says will be `less<task>`, and this compares items based on the `<` operator.
    So that we can use the default predicate, we define the `<` operator for the `task`
    class. Now we can add tasks to a `priority_queue` container:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合类型很简单；它有两个数据成员，这些成员由构造函数初始化。为了能够对任务进行排序，我们需要能够比较两个任务对象。一个选项（前面提到过）是定义一个单独的谓词类。在这个例子中，我们使用默认谓词，文档中说将是less<task>，它根据<运算符比较项目。为了能够使用默认谓词，我们为task类定义<运算符。现在我们可以将任务添加到priority_queue容器中：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of this code is:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结果是：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The queue has ordered the tasks according to the `priority` data item, and the
    combination of `top` and `pop` method calls reads the items in priority order
    and removes them from the queue. Items with the same priority are placed in the
    queue in the order in which they were pushed in.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 队列根据priority数据项对任务进行了排序，并且top和pop方法的组合调用按优先级顺序读取项目并从队列中删除它们。具有相同优先级的项目按照它们被推入的顺序放入队列中。
- en: Using iterators
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: 'So far, in this chapter we have indicated that containers give access to items
    through iterators. The implication is that iterators are simply pointers, and
    this is deliberate because iterators behave *like* pointers. However, they are
    usually objects of iterator classes (see the `<iterator>` header). All iterators
    have the following behaviors:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经指出容器通过迭代器访问项目。这意味着迭代器只是指针，这是有意为之的，因为迭代器的行为类似于指针。但是，它们通常是迭代器类的对象（请参阅<iterator>头文件）。所有迭代器都具有以下行为：
- en: '| **Operator** | **Behaviors** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 行为 |'
- en: '| * | Gives access to the element at the current position |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| * | 访问当前位置的元素 |'
- en: '| ++ | Moves forward to the next element (usually you will use the prefix operator)(this
    is only if the iterator allows forward movement) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| ++ | 向前移动到下一个元素（通常你会使用前缀运算符）（只有在迭代器允许向前移动时才会这样） |'
- en: '| -- | Moves backward to the previous element (usually you will use the prefix
    operator)(this is only if the iterator allows backward movement) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| -- | 向后移动到上一个元素（通常你会使用前缀运算符）（只有在迭代器允许向后移动时才会这样） |'
- en: '| `==` and `!=` | Compares if two iterators are in the same position |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ==和！= | 比较两个迭代器是否在相同位置 |'
- en: '| = | Assigns an iterator |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| = | 分配一个迭代器 |'
- en: Unlike a C++ pointer, which assumes that data is contiguous in memory, iterators
    can be used for more complex data structures, such as linked lists, where the
    items may not be contiguous. The operators `++` and `--` work as expected, regardless
    of the underlying storage mechanism.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++指针不同，迭代器假定数据在内存中是连续的，迭代器可以用于更复杂的数据结构，例如链表，其中项目可能不是连续的。无论底层存储机制如何，++和--运算符都能正常工作。
- en: The `<iterator>` header declares the `next` global function that will increment
    an iterator and the `advance` function that will change an iterator by a specified
    number of positions (forward or backward depending on whether the parameter is
    negative and the direction allowed by the iterator). There is also a `prev` function
    to decrement an iterator by one or more positions. The `distance` function can
    be used to determine how many items are between two iterators.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <iterator>头文件声明了next全局函数，它将增加一个迭代器，以及advance函数，它将按指定数量的位置更改迭代器（向前或向后取决于参数是否为负数以及迭代器允许的方向）。还有一个prev函数，用于将迭代器减少一个或多个位置。distance函数可用于确定两个迭代器之间有多少项。
- en: All containers have a `begin` method, which returns the iterator for the first
    item, and an `end` method, which returns an iterator *after* the last item. This
    means that you can iterate through all items in the container by calling `begin`
    and then incrementing the iterator until it has the value returned from `end`.
    The `*` operator on an iterator gives access to the element in the container,
    and if the iterator is read-write (as it will be if returned from the begin method)
    it means the item can be changed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都有一个`begin`方法，返回第一项的迭代器，和一个`end`方法，返回最后一项*之后*的迭代器。这意味着您可以通过调用`begin`然后递增迭代器直到它具有从`end`返回的值来遍历容器中的所有项。迭代器上的`*`运算符可以访问容器中的元素，如果迭代器是可读写的（如果从begin方法返回的话），这意味着该项可以被更改。
- en: 'Containers also have the `cbegin` and `cend` methods that will return a constant
    iterator that gives just read-only access to elements:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还有`cbegin`和`cend`方法，它们将返回一个只读访问元素的常量迭代器：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here `const` has no effect because the variable is `auto` and the type is deduced
    from the item used to initialize the variable. The `cbegin` method is defined
    to return a `const` iterator, so you cannot alter the item it refers to.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`const`没有效果，因为变量是`auto`，类型是从用于初始化变量的项中推导出来的。`cbegin`方法被定义为返回一个`const`迭代器，因此您不能更改它所引用的项。
- en: 'The `begin` and `cbegin` methods return **forward iterators** so that the `++`
    operator moves the iterator forward. Containers may also support **reverse iterators**,
    where `rbegin` is the last item in the container (that is, the item *before* the
    position returned by `end`) and `rend` is the position *before* the first item.
    (There are also `crbegin` and `crend`, which return `const` iterators.) It is
    important to realize that the `++` operator for a reverse iterator moves *backwards*,
    as in the following example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin`和`cbegin`方法返回**前向迭代器**，因此`++`运算符将迭代器向前移动。容器还可以支持**反向迭代器**，其中`rbegin`是容器中的最后一项（即`end`返回的位置*之前*的项），`rend`是第一项*之前*的位置。（还有`crbegin`和`crend`，它们返回`const`迭代器。）重要的是要意识到反向迭代器的`++`运算符是向*后*移动的，就像以下示例中所示：'
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `++` operator increments the iterator according to the type of the iterator
    that it is applied to. It is important to note that the `!=` operator is used
    here to determine if the looping should end because the `!=` operator will be
    defined on all iterators.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`++`运算符根据应用于的迭代器类型来递增迭代器。重要的是要注意，这里使用`!=`运算符来确定循环是否应该结束，因为`!=`运算符将在所有迭代器上定义。'
- en: 'The iterator type here is ignored by using the `auto` keyword. In fact, all
    containers will have `typedef` for all the iterator types they use, so in the
    previous case we can use the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里忽略了迭代器类型，使用了`auto`关键字。实际上，所有容器都会为它们使用的所有迭代器类型定义`typedef`，所以在前面的例子中我们可以使用以下方式：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Containers that allow forward iteration will have a `typedef` for `iterator`
    and `const_iterator`, and containers that allow reverse iteration will have a
    `typedef` for `reverse_iterator` and `const_reverse_iterator`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 允许前向迭代的容器将为`iterator`和`const_iterator`定义`typedef`，允许反向迭代的容器将为`reverse_iterator`和`const_reverse_iterator`定义`typedef`。
- en: To be complete, containers will also have `typedef` for `pointer` and `const_pointer`
    for the methods that return pointers to the elements, and `reference` and `const_reference`
    for methods that return references to elements. These type definitions enable
    you to write generic code where you do not know the types in a container, but
    the code will still be able to declare variables of the right type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，容器还将为返回指向元素的指针的方法定义`pointer`和`const_pointer`的`typedef`，并为返回元素引用的方法定义`reference`和`const_reference`的`typedef`。这些类型定义使您能够编写通用代码，其中您不知道容器中的类型，但代码仍然能够声明正确类型的变量。
- en: 'Although they look like they are pointers, iterators are often implemented
    by classes. These types may only allow iteration in one direction: a forward iterator
    will only have the `++` operator, a reverse iterator will have the `-` operator,
    or the type may allow iteration in both directions (bidirectional iterators) and
    so they implement both the `++` and `--` operators. For example, the iterators
    on the `list`, `set`, `multiset`, `map`, and `multimap` classes are bidirectional.
    The `vector`, `deque`, `array`, and `string` class have iterators that allow random
    access, so these iterator types have the same behavior as bidirectional iterators,
    but also have pointers like arithmetic, so they can be changed by more than one
    item position at a time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们看起来像指针，但迭代器通常由类实现。这些类型可能只允许单向迭代：前向迭代器只有`++`运算符，反向迭代器有`-`运算符，或者类型可以允许双向迭代（双向迭代器），因此它们实现了`++`和`--`运算符。例如，`list`、`set`、`multiset`、`map`和`multimap`类上的迭代器是双向的。`vector`、`deque`、`array`和`string`类具有允许随机访问的迭代器，因此这些迭代器类型具有与双向迭代器相同的行为，但也具有指针的算术运算，因此它们可以一次更改多个项的位置。
- en: Input and output iterators
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出迭代器
- en: 'As the name suggests, an input iterator will only move forward and will have
    read access, and an output iterator will only move forward but will have write
    access. These iterators do not have random access and they do not allow backward
    movement. For example, an output stream may be used with an output iterator: you
    assign the dereferenced iterator with a data item in order to write that data
    item to the stream. Similarly, an input stream could have an input iterator and
    you dereference the iterator to get access to the next item in the stream. This
    behavior means that for an output iterator the only valid use of the dereference
    operator (`*`) is on the left-hand side of an assignment. It makes no sense to
    check the value of an iterator with `!=`, and you cannot check if assigning a
    value through the output iterator is successful.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，输入迭代器只能向前移动并具有读取访问权限，而输出迭代器只能向前移动但具有写入访问权限。这些迭代器没有随机访问，也不允许向后移动。例如，输出流可以与输出迭代器一起使用：您将数据项分配给解引用的迭代器，以便将该数据项写入流中。类似地，输入流可以具有输入迭代器，您可以解引用迭代器以访问流中的下一个项。这种行为意味着对于输出迭代器，解引用运算符
    (`*`) 的唯一有效用法是在赋值的左侧。检查迭代器的值是否等于 `!=` 是没有意义的，并且您不能检查通过输出迭代器分配值是否成功。
- en: 'For example, the `transform` function takes three iterators and a function.
    The first two iterators are input iterators and indicate a range of items to be
    transformed by the function. The result will be put in a range of items (the same
    size as the range of the input iterator), the first of which is indicated by the
    third iterator, which is an output iterator. One way to do this is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`transform` 函数接受三个迭代器和一个函数。前两个迭代器是输入迭代器，指示要通过函数转换的项目范围。结果将放在项目范围内（与输入迭代器的范围大小相同），第一个由第三个迭代器指示，这是一个输出迭代器。可以按以下方式之一执行此操作：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here the `begin` and `end` methods return iterators on the `data` container
    that are safe to be used as input iterators. The `begin` method on the `results`
    container can only be used as an output iterator as long as the container has
    enough allocated items, and this is the case in this code because they have been
    allocated with `resize`. The function will then transform each input item by passing
    it to the lambda function given in the last parameter (which simply returns the
    square of the value). It is important to reassess what is happening here; the
    third parameter of the `transform` function is an output iterator, which means
    that you should expect the function to write values through this iterator.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `begin` 和 `end` 方法返回 `data` 容器上的迭代器，可以安全地用作输入迭代器。`results` 容器上的 `begin`
    方法只能用作输出迭代器，只要容器有足够分配的项目，这在此代码中是成立的，因为它们已经用 `resize` 分配了。然后，该函数将通过将输入项传递给最后一个参数中给定的
    lambda 函数（简单地返回值的平方）来转换每个输入项。重要的是要重新评估这里发生了什么；`transform` 函数的第三个参数是输出迭代器，这意味着您应该期望该函数通过此迭代器写入值。
- en: 'This code works, but it requires the extra step to allocate the space, and
    you have the extra allocations of default objects in the container just so that
    you can overwrite them. It is also important to mention that the output iterator
    does not have to be to another container. It can be to the same container as long
    as it refers to a range that can be written to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，但需要额外的步骤来分配空间，并且您需要额外分配默认对象以便覆盖它们。还要注意的是，输出迭代器不一定要指向另一个容器。只要它指向可以写入的范围，它就可以指向相同的容器：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `vec` container is resized so that there is space for the results. The range
    of values to transform are from the beginning item to the fifth item (`vec.begin()
    + 5` is the next item), and the place to write the transformed value is the sixth
    to tenth items. If you print out the vector you will get `{1,2,3,4,5,1,4,9,16,25}`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec` 容器被调整大小，以便有空间存放结果。要转换的值范围是从第一个项目到第五个项目（`vec.begin() + 5` 是下一个项目），写入转换值的位置是第六到第十个项目。如果打印出向量，您将得到
    `{1,2,3,4,5,1,4,9,16,25}`。'
- en: 'Another type of output iterator is the inserter. The `back_inserter` is used
    on containers with `push_back`, and `front_inserter` is used on containers with
    `push_front`. As the name suggests, an inserter calls the `insert` method on the
    container. For example, you can use a `back_inserter` like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种输出迭代器是插入器。`back_inserter` 用于具有 `push_back` 的容器，`front_inserter` 用于具有 `push_front`
    的容器。顾名思义，插入器在容器上调用 `insert` 方法。例如，您可以像这样使用 `back_inserter`：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The results of the transformation are inserted into the `results` container
    with the temporary object created from the `back_inserter` class. Using a `back_inserter`
    object ensures that when the `transform` function writes through the iterator
    the item is *inserted* into the wrapped container using `push_back`. Note that
    the results container should be different to the source container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 转换的结果将使用从 `back_inserter` 类创建的临时对象插入到 `results` 容器中。使用 `back_inserter` 对象可以确保当
    `transform` 函数通过迭代器写入时，该项将*插入*到包装容器中，使用 `push_back`。请注意，结果容器应与源容器不同。
- en: 'If you want the values in reverse order, then if the container supports `push_front`
    (for example, `deque`), then you can use a `front_inserter`. The `vector` class
    does not have a `push_front` method, but it does have reverse iterators, so you
    can use them instead:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要以相反顺序获取值，那么如果容器支持 `push_front`（例如 `deque`），则可以使用 `front_inserter`。`vector`
    类没有 `push_front` 方法，但它具有反向迭代器，因此可以使用它们代替：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All you need to do to reverse the order of the results is to change `begin`
    to `rbegin` and `end` to `rend`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转结果的顺序，您只需将 `begin` 更改为 `rbegin`，将 `end` 更改为 `rend`。
- en: Stream iterators
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流迭代器
- en: 'These are adapter classes in `<iterators>` that can be used to read items from
    an input stream or write items to an output stream. For example, so far, we have
    used iterators via ranged `for` loops to print out the contents of a container:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `<iterators>` 中的适配器类，可用于从输入流读取项目或将项目写入输出流。例如，到目前为止，我们已经通过范围 `for` 循环使用迭代器来打印容器的内容：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Instead, you can create an output stream iterator based on `cout`, so that
    the `int` values will be written to the `cout` stream through this iterator using
    the stream operator `<<`. To print out a container of `int` values, you simply
    copy the container to the output iterator:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以基于`cout`创建一个输出流迭代器，这样`int`值将通过这个迭代器使用流操作符`<<`写入`cout`流。要打印出一个`int`值的容器，您只需将容器复制到输出迭代器即可：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first parameter of the `ostream_iterator` class is the output stream it
    will adapt, and the optional second parameter is a delimiter string used between
    each item. The `copy` function (in `<algorithm>`) will copy the items in the range
    indicated by the input iterators, passed as the first two parameters, to the output
    iterator, passed as the last parameter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostream_iterator`类的第一个参数是它将适配的输出流，可选的第二个参数是在每个项目之间使用的分隔符字符串。`copy`函数（在`<algorithm>`中）将复制由输入迭代器指示的范围中的项目，作为前两个参数传递，到作为最后一个参数传递的输出迭代器中。'
- en: Similarly, there is an `istream_iterator` class that will wrap an input stream
    object and provide an input iterator. This class will use the stream `>>` operator
    to extract objects of the specified type, which can be read through the stream
    iterator. However, reading data from a stream is more complicated than writing
    to one, since there must be detection of when there is no more data in the input
    stream for the iterator to read (an end of file situation).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有一个`istream_iterator`类，它将包装一个输入流对象并提供一个输入迭代器。这个类将使用流`>>`操作符来提取指定类型的对象，这些对象可以通过流迭代器读取。然而，从流中读取数据比写入更复杂，因为必须检测输入流中是否还有更多数据供迭代器读取（文件结束情况）。
- en: 'The `istream_iterator` class has two constructors. One constructor has a single
    parameter that is the input stream to read, and the other constructor, the default
    constructor, has no parameters and is used to create an **end of stream iterator**.
    The end of stream iterator is used to indicate that there is no more data in the
    stream:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream_iterator`类有两个构造函数。一个构造函数有一个参数，即要读取的输入流，另一个构造函数，即默认构造函数，没有参数，用于创建一个**流结束迭代器**。流结束迭代器用于指示流中没有更多数据：'
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first call to `copy` provides two input iterators, as the first parameters,
    and an output iterator. The function copies data from the first iterator to the
    output iterator in the last parameter. Since the last parameter is created from
    `back_inserter`, this means that the items are inserted into the `vector` object.
    The input iterators are based on an input stream (`cin`) and thus the `copy` function
    will read `int` values from the console (each one separated by white space) until
    no more are available (for example, if you press *CTRL* + *Z* to end the stream
    or you type a non-numeric item). Since you can initialize a container with a range
    of values given by iterators, you can use `istream_iterator` as constructor parameters:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`copy`提供两个输入迭代器作为第一个参数，并提供一个输出迭代器。该函数将数据从第一个迭代器复制到最后一个参数中的输出迭代器。由于最后一个参数是由`back_inserter`创建的，这意味着项目将插入到`vector`对象中。输入迭代器基于输入流（`cin`），因此`copy`函数将从控制台读取`int`值（每个值由空格分隔），直到没有更多可用的值（例如，如果您按*CTRL*
    + *Z*结束流，或者输入一个非数字项）。由于您可以使用迭代器给定的值范围初始化容器，因此可以使用`istream_iterator`作为构造函数参数：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here the constructor is called using the initializer list syntax; if you use
    parentheses, the compiler will interpret this as the declaration of a function!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，构造函数使用初始化列表语法调用；如果使用括号，编译器将将其解释为函数的声明！
- en: 'As noted earlier, the `istream_iterator` will use the stream''s `>>` operator
    to read objects of the specified type from the stream and this operator uses whitespace
    to delimit the items (and hence it just ignores all whitespace). If you read in
    a container of `string` objects, then each word you type on the console will be
    an item in the container. A `string` is a container of characters, and it can
    be also initialized using iterators, so you could try to input data into a `string`
    from the console using an `istream_iterator`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`istream_iterator`将使用流的`>>`操作符从流中读取指定类型的对象，这个操作符使用空白来分隔项目（因此它只忽略所有空白）。如果读取一个`string`对象的容器，那么您在控制台上键入的每个单词都将成为容器中的一个项目。`string`是一个字符的容器，它也可以使用迭代器进行初始化，因此您可以尝试使用`istream_iterator`从控制台向`string`输入数据：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this case the stream is `cin`, but it could easily be an `ifstream` object
    to a file. The problem is that the `cin` object will strip out the white space,
    so the `string` object will contain everything that you type except for white
    space, so there will be no spaces and no newlines.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，流是`cin`，但它也可以很容易地是一个指向文件的`ifstream`对象。问题在于`cin`对象将剥离空白，因此`string`对象将包含您键入的除空白之外的所有内容，因此不会有空格和换行符。
- en: 'This problem is caused by the `istream_iterator` using the stream''s `>>` operator,
    and can only be avoided by using another class, `istreambuf_iterator`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是由`istream_iterator`使用流的`>>`操作符引起的，只能通过使用另一个类`istreambuf_iterator`来避免。
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This class reads each character from the stream and copies each one into the
    container without the processing of `>>`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类从流中读取每个字符，并将每个字符复制到容器中，而不进行`>>`的处理。
- en: Using iterators with the C Standard Library
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C标准库的迭代器
- en: 'The C Standard Library will often require pointers to data. For example, when
    a C function requires a string, it will need a `const char*` pointer to the character
    array containing the string. The C++ Standard Library has been designed to allow
    you to use its classes with the C Standard Library; indeed, the C Standard Library
    is part of the C++ Standard Library. In the case of `string` objects, the solution
    is simple: when you need a `const char*` pointer, you simply call the `c_str`
    method on a `string` object.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库通常需要指向数据的指针。例如，当C函数需要一个字符串时，它将需要一个指向包含字符串的字符数组的`const char*`指针。C++标准库已经被设计成允许您使用其类与C标准库；事实上，C标准库是C++标准库的一部分。对于`string`对象，解决方案很简单：当您需要一个`const
    char*`指针时，您只需在`string`对象上调用`c_str`方法。
- en: The containers that store data in contiguous memory (`array`, `string`, or `data`)
    have a method called `data` that gives access to the container's data as a C array.
    Further, these containers have `[]` operator access to their data, so you can
    also treat the address of the first item as being `&container[0]` (where `container`
    is the container object), just as you do with C arrays. However, if the container
    is empty, this address will be invalid, so before using it you should call the
    `empty` method. The number of items in these containers is returned from the `size`
    method, so for any C function that takes a pointer to the start of a C array and
    its size, you can call it with `&container[0]` and the value from the `size` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以连续内存存储数据的容器（`array`、`string`或`data`）有一个名为`data`的方法，它将容器的数据作为C数组进行访问。此外，这些容器有`[]`操作符访问它们的数据，因此您也可以将第一个项目的地址视为`&container[0]`（其中`container`是容器对象），就像您对C数组一样。但是，如果容器为空，这个地址将是无效的，因此在使用之前，您应该调用`empty`方法。这些容器中的项目数是从`size`方法返回的，因此对于任何需要指向C数组开头和其大小的指针的C函数，您可以使用`&container[0]`和`size`方法的值来调用它。
- en: You may be tempted to get the beginning of the container that has contiguous
    memory by calling its `begin` function, but this will return an iterator (usually
    an object). So, to get a C pointer to the first item, you should call `&*begin`;
    that is, dereference the iterator returned from the `begin` function to get the
    first item and then use the address operator to get its address. To be frank,
    `&container[0]` is simpler and more readable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被诱惑去调用容器的`begin`函数来获取具有连续内存的容器的开始部分，但这将返回一个迭代器（通常是一个对象）。因此，要获取第一个项目的C指针，您应该调用`&*begin`；也就是说，解引用从`begin`函数返回的迭代器以获取第一个项目，然后使用地址运算符获取其地址。坦率地说，`&container[0]`更简单更易读。
- en: If the container does not store its data in contiguous memory (for example,
    `deque` and `list`), then you can obtain a C pointer by simply copying the data
    into a temporary vector.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器不是以连续内存存储其数据（例如`deque`和`list`），那么您可以通过简单地将数据复制到临时向量中来获得C指针。
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, we have chosen to use a `list` and the routine will manipulate
    the `data` object. Later in the routine, these values will be passed to a C function
    so the `list` is used to initialize a `vector` object, and these values are obtained
    from the `vector`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们选择使用`list`，并且该例程将操作`data`对象。在例程的后面，这些值将被传递给一个C函数，因此`list`用于初始化一个`vector`对象，并且这些值是从`vector`中获取的。
- en: Algorithms
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: The Standard Library has an extensive collection of generic functions in the
    `<algorithm>` header file. By generic we mean that they access data via iterators
    without knowing what the iterators refer to and so it means that you can write
    generic code to work for any appropriate container. However, if you know the container
    type and that container has a member method to perform the same action, you should
    use the member.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在`<algorithm>`头文件中有大量的通用函数集合。通用意味着它们通过迭代器访问数据，而不知道迭代器指的是什么，这意味着您可以编写通用代码来适用于任何适当的容器。但是，如果您知道容器类型，并且该容器有一个成员方法来执行相同的操作，您应该使用该成员。
- en: Iteration of items
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目的迭代
- en: 'Many of the routines in `<algorithm>` will take ranges and iterate over those
    ranges performing some action. As the name suggests, the `fill` function will
    fill a container with a value. The function takes two iterators to specify the
    range and a value that will be placed into each position of the container:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`<algorithm>`中的许多例程将接受范围并迭代这些范围执行某些操作。正如其名称所示，`fill`函数将使用一个值填充容器。该函数需要两个迭代器来指定范围和一个将放入容器每个位置的值：'
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since the `fill` function will be called for a range, it means that you have
    to pass iterators to a container that already has values, and this is the reason
    why this code calls the `resize` method. This code will put the value of `42`
    into each of the items of the container, so when it has completed the `vector`
    contains `{42,42,42,42,42}`. There is another version of this function called
    `fill_n` that specifies the range by a single iterator to the start of the range
    and a count of the items in the range.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fill`函数将被调用用于一个范围，这意味着您必须传递迭代器到已经有值的容器，这就是为什么这段代码调用`resize`方法的原因。这段代码将`42`的值放入容器的每个项目中，因此当它完成后，`vector`包含`{42,42,42,42,42}`。这个函数的另一个版本叫做`fill_n`，它通过单个迭代器到范围的开始和范围中的项目数来指定范围。
- en: 'The `generate` function is similar, but, rather than a single value, it has
    a function, which can be a function, a function object, or a lambda expression.
    The function is called to provide each item in the container, so it has no parameters
    and returns an object of the type accessed by the iterator:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate`函数类似，但是，它不是一个单一的值，而是一个函数，可以是函数、函数对象或lambda表达式。调用该函数来提供容器中的每个项目，因此它没有参数，并返回由迭代器访问的类型的对象：'
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Again, you have to make sure that the `generate` function is passed a range
    that already exists, and this code does this by passing the initial size as a
    constructor parameter. In this example, the lambda expression has a `static` variable,
    which is incremented with each call, so this means that after the `generate` function
    has completed the `vector` contains `{1,2,3,4,5}`. There is another version of
    this function called `generate_n` that specifies the range by a single iterator
    to the start of the range and a count of the items in the range.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您必须确保`generate`函数传递的是已经存在的范围，这段代码通过将初始大小作为构造函数参数来实现这一点。在这个例子中，lambda表达式有一个`static`变量，每次调用都会增加，这意味着在`generate`函数完成后，`vector`包含`{1,2,3,4,5}`。这个函数的另一个版本叫做`generate_n`，它通过单个迭代器到范围的开始和范围中的项目数来指定范围。
- en: 'The `for_each` function will iterate over a range provided by two iterators
    and, for each item in the range, call a specified function. This function must
    have a single parameter that is the same type as the items in the container:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`函数将迭代由两个迭代器提供的范围，并且对于范围中的每个项目，调用指定的函数。这个函数必须有一个与容器中的项目相同类型的单一参数：'
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `for_each` function iterates over all the items specified by the iterators
    (in this case the entire range), dereferences the iterator, and passes the item
    to the function, The effect of this code is to print the contents of the container.
    The function can take the item by value (as in this case) or by reference. If
    you pass the item by reference, then the function can change the item:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`函数遍历迭代器指定的所有项目（在本例中是整个范围），解引用迭代器，并将项目传递给函数。此代码的效果是打印容器的内容。函数可以按值（在本例中）或按引用传递项目。如果通过引用传递项目，则函数可以更改项目：'
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After calling this code, the items in the `vector` will be replaced with the
    squares of those items. If you use a functor or a lambda expression, you can pass
    a container to capture the result of the function; for example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此代码后，`vector`中的项目将被替换为这些项目的平方。如果使用函数对象或lambda表达式，可以传递一个容器来捕获函数的结果；例如：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, a container is declared to accept the results of each call to the lambda
    expression, and the variable is passed by reference to the expression by capturing
    it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，声明了一个容器来接受对lambda表达式的每次调用的结果，并且通过捕获将变量按引用传递给表达式。
- en: Recall from [Chapter 3](ddcfe6af-f0bb-4c28-ad97-9c402bc43799.xhtml), *Using
    Functions*, that the square brackets contain the names of the captured variables
    declared outside the expression. Once captured, it means that the expression is
    able to access the object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾[第3章](ddcfe6af-f0bb-4c28-ad97-9c402bc43799.xhtml)中的*使用函数*，方括号中包含在表达式外声明的捕获变量的名称。一旦捕获，这意味着表达式能够访问该对象。
- en: In this example the result of each iteration (`i*i`) is pushed into the captured
    collection so that the results are stored for later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每次迭代（`i*i`）的结果都被推送到捕获的集合中，以便稍后存储结果。
- en: The `transform` function has two forms; they both provide a function (a pointer,
    functor, or a lambda expression) and they both have an input range of items in
    a container passed via iterators. In this respect, they are similar to `for_each`.
    The `transform` function also allows you to pass an iterator to a container that
    is used to store the results of the function. The function must have a single
    parameter that is the same type as the type (or a reference) of the type referred
    to the input iterators and it must return the type accessed by the output iterator.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`函数有两种形式；它们都提供一个函数（指针、函数对象或lambda表达式），并且它们都有一个通过迭代器传递的容器中项目的输入范围。在这方面，它们类似于`for_each`。`transform`函数还允许您传递一个用于存储函数结果的容器的迭代器。函数必须具有与输入迭代器引用的类型相同的单个参数，并且必须返回由输出迭代器访问的类型。'
- en: 'The other version of `transform` uses a function to combine the values in two
    ranges, so this means that the function must have two parameters (which will be
    the corresponding items in the two iterators) and return the type of the output
    iterator. You only need to give the full range of items in one of the input ranges
    because it is assumed that the other range is at least as large, and hence you
    only have to provide the beginning iterator of the second range:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`的另一个版本使用函数来组合两个范围中的值，因此这意味着函数必须具有两个参数（将是两个迭代器中的相应项目），并返回输出迭代器的类型。您只需要在其中一个输入范围中提供所有项目的完整范围，因为假定另一个范围至少与之一样大，因此您只需要提供第二个范围的开始迭代器：'
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Getting information
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取信息
- en: 'Once you have values in a container, you can call functions to get information
    about those items. The `count` function is used to count the number items with
    a specified value in a range:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器中有值，就可以调用函数来获取有关这些项目的信息。`count`函数用于计算范围中具有指定值的项目数：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This code will return a value of `3` because there are three copies of `6` in
    the container. The return type of the function is the type specified in the `difference_type``typedef`
    of the container, and in this case it will be `int`. The `count_if` function works
    in a similar way, but you pass a predicate that takes a single parameter (the
    current item in the container) and returns a `bool` specifying if this is the
    value that is being counted.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将返回值`3`，因为容器中有三个`6`的副本。函数的返回类型是容器的`difference_type`类型，本例中将是`int`。`count_if`函数的工作方式类似，但您传递一个谓词，该谓词接受一个参数（容器中的当前项目）并返回一个`bool`，指定是否正在计数的值。
- en: The `count` functions count the number of occurrences of a specific value. If
    you want to aggregate all the values, then you can use the `accumulate` function
    in `<numeric>`. This will iterate over the range, access each item and keep a
    running sum of all the items.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`函数计算特定值的出现次数。如果要汇总所有值，则可以使用`<numeric>`中的`accumulate`函数。这将遍历范围，访问每个项目，并保持所有项目的累积总和。'
- en: The sum will be carried out using the `+` operator of the type, but there is
    also a version that takes a binary function (two parameters of the container type
    and returns the same type) that specifies what happens when you add two such types
    together.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 求和将使用类型的`+`运算符进行，但也有一个版本，它接受一个二元函数（容器类型的两个参数并返回相同类型），指定将两个这样的类型相加时会发生什么。
- en: The `all_of`, `any_of`, and `none_of` functions are passed a predicate with
    a single argument of the same type of the container; there are also given iterators
    indicating a range over which they iterate, testing each item with the predicate.
    The `all_of` function will return `true` only if the predicate is `true` for all
    items, the `any_of` function returns `true` if predicate is `true` for at least
    one of the items, and the `none_of` function will return `true` only if the predicate
    is `false` for all items.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`all_of`、`any_of`和`none_of`函数都接受一个谓词，该谓词具有与容器相同类型的单个参数；它们还接受指示迭代范围的迭代器，测试谓词对每个项目的结果。`all_of`函数仅在所有项目的谓词为`true`时返回`true`，`any_of`函数在至少一个项目的谓词为`true`时返回`true`，而`none_of`函数仅在所有项目的谓词为`false`时返回`true`。'
- en: Comparing containers
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较容器
- en: 'If you have two containers of data, there are various ways that you can compare
    them. For every container type, there are `<`, `<=`, `==`, `!=`, `>`, and `>=`
    operators defined. The `==` and `!=` operators compare the containers, both in
    terms of how many items they have and the values of those items. So, if the items
    have different numbers of items, different values, or both, then they are not
    equal. The other comparisons prefer values over the number of items:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有两个数据容器，有各种方法可以比较它们。对于每种容器类型，都定义了`<`、`<=`、`==`、`!=`、`>`和`>=`运算符。`==`和`!=`运算符比较容器，无论它们有多少项目以及这些项目的值。因此，如果项目具有不同数量的项目、不同的值或两者都有，则它们不相等。其他比较更喜欢值而不是项目的数量：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the first comparison, the two vectors have similar items, but `v2` has fewer,
    so `v1` is "greater than" `v2`. In the second case, `v3` has larger values than
    `v1`, but fewer of them, so `v3` is *greater than *`v1`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个比较中，两个向量具有相似的项目，但`v2`的项目较少，因此`v1`“大于”`v2`。在第二种情况下，`v3`的值大于`v1`，但数量较少，因此`v3`*大于*`v1`。
- en: You can also compare ranges with the `equal` function. This is passed two ranges
    (which are assumed to be the same size, so only an iterator to the start of the
    second range is needed), and it compares corresponding items in both ranges using
    the `==` operator for the type accessed by the iterator, or a user-supplied predicate.
    Only if all such comparisons are `true` will the function return `true`. Similarly,
    the `mismatch` function compares corresponding items in two ranges. However, this
    function returns a `pair` object with iterators in each of the two ranges for
    the first item that is not the same. You can also provide a comparison function.
    The `is_permutation is` similar in that it compares the values in two ranges,
    but it returns `true` if the two ranges have the same values but not necessarily
    in the same order.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`equal`函数比较范围。这需要传递两个范围（假定它们的大小相同，因此只需要第二个范围的开始迭代器），并使用`==`运算符或用户提供的谓词比较两个范围中的相应项目。只有在所有这样的比较都为`true`时，函数才会返回`true`。类似地，`mismatch`函数比较两个范围中的相应项目。但是，此函数返回一个`pair`对象，其中包含两个范围中的迭代器，用于第一个不相同的项目。您还可以提供一个比较函数。`is_permutation`类似于它比较两个范围中的值，但是如果两个范围具有相同的值但不一定是相同的顺序，则返回`true`。
- en: Changing Items
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改项目
- en: The **reverse** function acts on a range in a container and reverses the order
    of the items; this means that the iterators must be writeable. The `copy` and
    `copy_n` functions copy every item from one range to another in a forward direction;
    for `copy`, the input range is given by two input iterators, and for `copy_n`,
    the range is an input iterator and a count of items. The `copy_backward` function
    will copy the items, starting at the end of the range, so that the output range
    will have the items in the same order as the original. This means that the output
    iterator will indicate the *end* of the range to copy to. You can also copy items
    only if they satisfy some condition specified by a predicate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: reverse函数作用于容器中的范围，并颠倒项目的顺序；这意味着迭代器必须是可写的。`copy`和`copy_n`函数将一个范围中的每个项目从一个方向复制到另一个方向；对于`copy`，输入范围由两个输入迭代器给出，对于`copy_n`，范围是一个输入迭代器和项目的计数。`copy_backward`函数将复制项目，从范围的末尾开始，以便输出范围中的项目与原始项目的顺序相同。这意味着输出迭代器将指示要复制到的范围的*结束*。您还可以只复制满足谓词指定的某些条件的项目。
- en: The `reverse_copy` function will create a copy in the reverse order to the input
    range; in effect, the function iterates backward through the original and copies
    items to the output range forward.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse_copy`函数将以与输入范围相反的顺序创建副本；实际上，该函数通过原始范围向后迭代并将项目向前复制到输出范围。'
- en: 'In spite of the name, the `move` and `move_backward` functions are semantically
    equivalent to the `copy` and `copy_backward` functions. Thus, in the following,
    the original container will have the same values after the operation:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管名称如此，`move`和`move_backward`函数在语义上等同于`copy`和`copy_backward`函数。因此，在以下情况下，原始容器在操作后将具有相同的值：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This code will copy four items from the first container to the second container,
    starting at the item in the third position.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码将从第一个容器复制四个项目到第二个容器，从第三个位置的项目开始。
- en: The `remove_copy` and `remove_copy_if` functions iterate through the source
    range and copy items other than those with the specified value.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_copy`和`remove_copy_if`函数遍历源范围，并复制除指定值之外的项目。'
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, the `planck` object is left the same as before and the `result` object
    will contain `{2,0,7,0,0,4,0}`. The `remove_copy_if` function behaves similarly,
    but is given a predicate rather than an actual value.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`planck`对象与之前一样，`result`对象将包含`{2,0,7,0,0,4,0}`。`remove_copy_if`函数的行为类似，但是给定的是谓词而不是实际值。
- en: The `remove` and `remove_if` functions don't quite do what their names suggest.
    These functions act on a single range and iterate looking for a specific value
    (`remove`), or pass each item to a predicate that will indicate if the item should
    be removed (`remove_if`). When an item is removed, the items later in the container
    are shifted forward, but the container remains the same size, which means that
    the items at the end remain as they were. The reason the `remove` functions behave
    like this is because they only know about reading and writing items through iterators
    (which is generic for all containers). To erase an item, the function will need
    to have access to the `erase` method of the container, and the `remove` functions
    only have access to iterators.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`和`remove_if`函数并不完全按照它们的名称所暗示的那样。这些函数作用于单个范围，并迭代寻找特定值（`remove`），或将每个项目传递给将指示是否应删除项目的谓词（`remove_if`）。当删除项目时，容器中后面的项目会向前移动，但容器的大小保持不变，这意味着末尾的项目保持不变。`remove`函数的行为之所以如此，是因为它们只知道通过迭代器读取和写入项目（这对所有容器都是通用的）。要擦除项目，函数将需要访问容器的`erase`方法，而`remove`函数只能访问迭代器。'
- en: 'If you want to remove the items at the end, then you must resize the container
    accordingly. Typically, this means calling a suitable `erase` method on the container,
    and this is made possible because the `remove` method returns an iterator to the
    new end position:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要删除末尾的项目，则必须相应地调整容器的大小。通常，这意味着在容器上调用适当的`erase`方法，这是可能的，因为`remove`方法返回指向新末尾位置的迭代器：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `replace` and `replace_if` functions iterate through a single range, and
    if the value is a specified value (`replace`) or returns `true` from a predicate
    (`replace_if`), then the item is replaced with a specified new value. There are
    also two functions, `replace_copy` and `replace_copy_if`, that leave the original
    alone and make the change to another range (similar to `remove_copy` and `remove_copy_if`
    functions).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`和`replace_if`函数遍历单个范围，如果值是指定值（`replace`）或从谓词（`replace_if`）返回`true`，则将使用指定的新值替换该项目。还有两个函数`replace_copy`和`replace_copy_if`，它们保持原始状态并将更改应用于另一个范围（类似于`remove_copy`和`remove_copy_if`函数）。'
- en: 'The `rotate` functions treat the range as if the end is joined to the beginning,
    and so you can shift items forward so that when an item falls off the end it gets
    put in the first position. If you want to move every item forward four places,
    you can do this:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate`函数将范围视为末尾连接到开头，因此您可以将项目向前移动，以便当项目从末尾掉下时，它将放在第一个位置。如果要将每个项目向前移动四个位置，可以这样做：'
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The result of this rotation is `{0,7,0,0,4,0,6,6,2,6}`. The `rotate_copy` function
    does the same thing, but, rather than affecting the original container, it copies
    the items into another container.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个旋转的结果是`{0,7,0,0,4,0,6,6,2,6}`。`rotate_copy`函数执行相同的操作，但是它不会影响原始容器，而是将项目复制到另一个容器中。
- en: The `unique` function acts on a range and "removes" (in the manner explained
    previously) the items that are duplicates of adjacent items, and you can provide
    a predicate for the function to call to test if two items are the same. This function
    only checks adjacent items, so a duplicate later in the container will remain.
    If you want to remove all duplicates, then you should sort the container first,
    so that similar items are adjacent.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique`函数作用于范围，并且“删除”（以前解释的方式）与相邻项目重复的项目，并且您可以为函数提供一个谓词来测试两个项目是否相同。此函数仅检查相邻项目，因此容器中稍后的重复项将保留。如果要删除所有重复项，则应首先对容器进行排序，以便相似的项目相邻。'
- en: 'The `unique_copy` function will copy items from one range to another only if
    they are unique, so one way to remove duplicates is to use this function on a
    temporary container and then assign the original to the temporary:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_copy`函数将仅在项目唯一时将项目从一个范围复制到另一个范围，因此消除重复项的一种方法是在临时容器上使用此函数，然后将原始容器分配给临时容器：'
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After this code, the `planck` container will have `{6,2,6,0,7,0,4,0}`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此代码之后，`planck`容器将为`{6,2,6,0,7,0,4,0}`。
- en: Finally, the `iter_swap` will swap the items indicated by two iterators, and
    the `swap_ranges` function swaps the items in one range to the other range (the
    second range is indicated by one iterator and it is assumed to refer to a range
    of the same size as the first).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`iter_swap`将交换两个迭代器指示的项目，`swap_ranges`函数将一个范围中的项目交换到另一个范围中（第二个范围由一个迭代器指示，并且假定它指的是与第一个范围大小相同的范围）。
- en: Finding Items
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找项目
- en: 'The Standard Library has a wide range of functions to search for items:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库具有广泛的功能来搜索项目：
- en: The `min_element` function will return an iterator to the smallest item in a
    range and the `max_element`function will return an iterator to the maximum item.
    These functions are passed iterators for the range of items to check and a predicator
    that returns a `bool` from the comparison of two items. If you don't provide a
    predicator, the `<` operator for the type will be used.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_element`函数将返回范围中最小项的迭代器，而`max_element`函数将返回最大项的迭代器。这些函数接受要检查的项目范围的迭代器和一个从比较两个项目返回`bool`的谓词。如果不提供谓词，则将使用类型的`<`运算符。'
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `imin` and `imax` values are iterators, which is why they are dereferenced
    to get the value. If you want to get the minimum element and the maximum element
    in one go, you can call the `minmax_element`, which will return a `pair` object
    with iterators to these items. As the name suggests, the `adjacent_find` function
    will return the position of the first two items that have the same value (and
    you can provide a predicate to determine what *same value* means). This allows
    you to search for duplicates and get the position of those duplicates.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imin`和`imax`值是迭代器，这就是为什么要对它们进行取消引用以获取值。如果要一次获取最小元素和最大元素，可以调用`minmax_element`，它将返回一个带有指向这些项目的迭代器的`pair`对象。顾名思义，`adjacent_find`函数将返回具有相同值的前两个项目的位置（您可以提供谓词来确定*相同值*的含义）。这使您可以搜索重复项并获取这些重复项的位置。'
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This code has a sequence of numbers in which there are some numbers duplicated
    that are next to each other. In this case there are *three* adjacent duplicates:
    `4` followed by `4`, and the sequence `7,7,7` is `7` followed by `7`, and `7`
    followed by `7`. The `do` loop calls `adjacent_find` repeatedly until it returns
    the `end` iterator, indicating that it has searched all items. When a duplicate
    pair is found, the code prints out the value and then increments the start position
    for the next search.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码具有一系列数字，其中有一些重复的数字相邻。在这种情况下，有*三个*相邻的重复项：`4`后跟`4`，序列`7,7,7`是`7`后跟`7`，`7`后跟`7`。`do`循环重复调用`adjacent_find`，直到它返回`end`迭代器，表示已搜索所有项目。找到重复对时，代码会打印出该值，然后递增下一次搜索的起始位置。
- en: The `find` function searches a container for a single value, and returns an
    iterator to that item or the `end` iterator if the value cannot be found. The
    `find_if` function is passed a predicate and it returns an iterator to the first
    item it finds that satisfies the predicate; similarly, the `find_if_not` function
    finds the first item that does not satisfy the predicate.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`函数在容器中搜索单个值，并返回指向该项的迭代器，如果找不到该值，则返回`end`迭代器。`find_if`函数接受一个谓词，并返回找到满足谓词的第一个项目的迭代器；类似地，`find_if_not`函数找到不满足谓词的第一个项目。'
- en: There are several functions that are given two ranges, one is the range to search
    and the other has the values to look for. The different functions will either
    look for one of the items in the search criteria or it will look for all of them.
    These functions use the `==` operator for the type that the container holds or
    a predicate.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个函数接受两个范围，一个是要搜索的范围，另一个是要查找的值。不同的函数要么查找搜索条件中的一个项目，要么查找所有项目。这些函数使用`==`运算符来比较容器保存的类型或谓词。
- en: The `find_first_of` function returns the position of the first item that it
    finds in the search list. The `search` function looks for a specific sequence,
    and it returns the *first* position of the whole sequence, whereas the `find_end`
    function returns the *last* position of the entire search sequence. Finally, the
    `search_n` function looks for a sequence that is a value repeated a number of
    times (the value and the repeat are given) in a specified container's range.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_first_of`函数返回它在搜索列表中找到的第一个项目的位置。`search`函数查找特定序列，并返回整个序列的*第一个*位置，而`find_end`函数返回整个搜索序列的*最后*位置。最后，`search_n`函数在指定容器范围内查找重复多次的值（给定值和重复次数）的序列。'
- en: Sorting items
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序项目
- en: The sequence containers can be sorted, and once you have done this you can use
    methods to search for items, to merge containers, or to get the difference between
    the containers. The `sort` function will order the items in a range according
    to the `<` operator or a predicate that you provide. If there are items that are
    equal in the range, then the order of these items after the sort is not guaranteed;
    if this order is important, you should call the `stable_sort` function instead.
    If you want to preserve the input range and copy the sorted items into another
    range, you use the confusingly named `partial_sort_copy` function. This is not
    a partial sort. This function is passed iterators to the input range and iterators
    for the output range, so you have to ensure that output range has a suitable capacity.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 序列容器可以排序，一旦您这样做了，就可以使用方法来搜索项目，合并容器，或获取容器之间的差异。`sort`函数将根据提供的`<`运算符或谓词对范围中的项目进行排序。如果范围中有相等的项目，则排序后这些项目的顺序不能保证；如果这个顺序很重要，您应该调用`stable_sort`函数。如果您想保留输入范围并将排序后的项目复制到另一个范围中，您可以使用令人困惑的`partial_sort_copy`函数。这不是部分排序。该函数接受输入范围的迭代器和输出范围的迭代器，因此您必须确保输出范围具有合适的容量。
- en: You can check if a range is sorted by calling the `is_sorted` function, and
    this will iterate through all items and return `false` if it finds an item that
    is not in sorted order, in which case you can locate the first item that is out
    of sort order by calling the `is_sorted_until` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`is_sorted`函数来检查范围是否已排序，如果找到不按顺序排序的项目，则会遍历所有项目并返回`false`，在这种情况下，您可以通过调用`is_sorted_until`函数找到第一个不按顺序排序的项目。
- en: As the name suggests, the `partial_sort` function does not place every item
    in its exact order relative to every other item. Instead, it will create two groups,
    or partitions, where the first partition will have the smallest items (not necessarily
    in any order) and the other partition will have the biggest items. You are guaranteed
    that the smallest items are in the first partition. To call this function you
    pass three iterators, two of which are the range to sort, and the third is a position
    somewhere between the other two that indicates the boundary before which are the
    smallest values.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，`partial_sort`函数不会将每个项目放在与其他项目的确切顺序相关的位置。相反，它将创建两个组或分区，其中第一个分区将包含最小的项目（不一定按任何顺序），而另一个分区将包含最大的项目。您保证最小的项目在第一个分区中。要调用此函数，您传递三个迭代器，其中两个是要排序的范围，第三个是介于其他两个之间的位置，指示最小值之前的边界。
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example there is a vector of ten items, so we define the `middle` iterator
    as five items from the beginning (this is just a choice, it could be some other
    value depending on how many items you want to obtain). In this example, you can
    see that the five smallest items have been sorted to the first half and the last
    half have the biggest items.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有一个包含十个项目的向量，所以我们将`middle`迭代器定义为距离开头五个项目（这只是一个选择，根据您想要获得多少项目，它可能是其他值）。在这个例子中，您可以看到五个最小的项目已经被排序到了前半部分，而后半部分有最大的项目。
- en: The oddly named `nth_element` function acts like `partial_sort`. You provide
    an iterator to the *nth* element and the function ensures that first *n* items
    in the range are the smallest. The `nth_element` function is faster than `partial_sort`,
    and, although you are guaranteed that the items before the *nth* element are less
    than or equal to the *nth* element, there are no other guarantees of the sort
    order within the partitions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪命名的`nth_element`函数类似于`partial_sort`。您提供一个指向第*n*个元素的迭代器，该函数确保范围中的前*n*个项目是最小的。`nth_element`函数比`partial_sort`更快，尽管您保证*n*元素之前的项目小于或等于*n*元素，但在分区内部的排序顺序没有其他保证。
- en: The `partial_sort` and `nth_element` functions are versions of partitioned sort
    functions. The `partition` function is a more generic version. You pass this function
    a range and a predicate that determines in which of the two partitions an item
    will be placed. The items that meet the predicate will be put in the first partition
    of the range, and the other items will be placed in the range following the first
    partition. The first item of the second partition is called the partition point
    and it is returned from the `partition` function, but you can calculate it later
    by passing iterators to the partitioned range and the predicate to the `partition_point`
    function. The `partition_copy` function will also partition values, but it will
    leave the original range untouched and put the values in a range that has been
    already allocated. These partition functions do not guarantee the order of equivalent
    items, and if this order is important then you should call the `stable_partitian`
    function. Finally, you can determine if a container is partitioned by calling
    the `is_partitioned` function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial_sort`和`nth_element`函数是分区排序函数的版本。`partition`函数是一个更通用的版本。您可以将一个范围和一个确定项目将被放置在哪个分区的谓词传递给这个函数。满足谓词的项目将被放置在范围的第一个分区中，其他项目将被放置在第一个分区后面的范围中。第二个分区的第一个项目称为分区点，并且它从`partition`函数返回，但是您可以稍后通过将迭代器传递给分区范围和谓词传递给`partition_point`函数来计算它。`partition_copy`函数也将分区值，但它将保持原始范围不变，并将值放入已经分配的范围中。这些分区函数不保证等效项目的顺序，如果这个顺序很重要，那么您应该调用`stable_partitian`函数。最后，您可以通过调用`is_partitioned`函数来确定容器是否已分区。'
- en: 'The `shuffle` function will rearrange the items in a container into a random
    order. This function needs a uniform random number generator from the `<random>`
    library. For example, the following will fill a container with ten integers and
    then place them in a random order:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle`函数将容器中的项目重新排列为随机顺序。这个函数需要来自`<random>`库的均匀随机数生成器。例如，以下代码将用十个整数填充一个容器，然后以随机顺序放置它们：'
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A heap is a partially sorted sequence in which the first item is always the
    largest, and items are added and removed from the heap in logarithmic time. Heaps
    are based upon sequence containers and, oddly, rather than the Standard Library
    providing an adapter class, you have to use function calls on an existing container.
    To create a heap from an existing container, you pass the range iterators to the
    `make_heap` function, which will order the container as a heap.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个部分排序的序列，其中第一个项目始终是最大的，并且可以在对数时间内添加和删除堆中的项目。堆基于序列容器，但奇怪的是，标准库没有提供适配器类，而是需要在现有容器上使用函数调用。要从现有容器创建堆，您需要将范围迭代器传递给`make_heap`函数，该函数将对容器进行排序以形成堆。
- en: You can then add new items to the container using its `push_back` method, but
    each time you do this you have to call `push_heap` to re-order the heap. Similarly,
    to get an item from the heap you call the `front` method on the container and
    then remove the item by calling the `pop_heap` function, which ensures that the
    heap is kept ordered. You can test to see if a container is arranged as a heap
    by calling `is_heap`, and if the container is not entirely arranged as a heap
    you can get an iterator to the first item that does not satisfy the heap criteria
    by calling `is_heap_until`. Finally, you can sort a heap into a sorted sequence
    with `sort_heap`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用其`push_back`方法向容器添加新项目，但每次这样做时，您都必须调用`push_heap`来重新排序堆。类似地，要从堆中获取项目，您需要在容器上调用`front`方法，然后通过调用`pop_heap`函数来删除项目，这可以确保堆保持有序。您可以通过调用`is_heap`来测试容器是否排列为堆，如果容器不完全排列为堆，您可以通过调用`is_heap_until`来获取到第一个不满足堆条件的项目的迭代器。最后，您可以使用`sort_heap`将堆排序为排序序列。
- en: 'Once you have sorted a container, there are functions that you can call to
    get information about the sequence. The `lower_bound` and `upper_bound` methods
    have already been described for containers, and the functions behave in the same
    way: `lower_bound` returns the position of the first element that has a value
    greater than or equal to the value provided and `upper_bound` returns the position
    of the next item that is greater than the value provided. The `includes` function
    tests to see if one sorted range contains the items in a second sorted range.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对容器进行了排序，就可以调用函数来获取有关序列的信息。`lower_bound`和`upper_bound`方法已经在容器中进行了描述，并且这些函数的行为方式相同：`lower_bound`返回第一个具有大于或等于提供的值的元素的位置，`upper_bound`返回大于提供的值的下一个项目的位置。`includes`函数用于测试一个排序范围是否包含第二个排序范围中的项目。
- en: The functions beginning with `set_` will combine two sorted sequences into a
    third, container. The `set_difference` function will copy the items that are in
    the first sequence but not in the second sequence. This is not a symmetric action
    because it does not include the items that are in the second sequence but not
    in the first. If you want a symmetric difference, then you should call the `set_symmetric_difference`
    function. The `set_intersection` will copy the items that are in both sequences.
    The `set_union` function will combine the two sequences. There is another function
    that will combine two sequences, which is the `merge` function. The difference
    between these two functions is that with the `set_union` function, if an item
    is in both of the sequences, there will only be one copy put in the results container,
    whereas with `merge` there will be two copies in the results container.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以`set_`开头的函数将两个排序序列合并为第三个容器。`set_difference`函数将复制第一个序列中不在第二个序列中的项目。这不是对称的操作，因为它不包括在第二个序列中但不在第一个序列中的项目。如果您想要对称差异，那么您应该调用`set_symmetric_difference`函数。`set_intersection`将复制两个序列中都存在的项目。`set_union`函数将合并两个序列。还有另一个函数可以合并两个序列，即`merge`函数。这两个函数之间的区别在于，使用`set_union`函数，如果一个项目同时存在于两个序列中，结果容器中只会放入一个副本，而使用`merge`则会在结果容器中放入两个副本。
- en: If a range is sorted, then you can call the `equal_range` function to obtain
    the range of elements that are equivalent to a value passed to the function or
    a predicate. This function returns a pair of iterators that represent the range
    of values in the container.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个范围是排序的，那么您可以调用`equal_range`函数来获取等于函数或谓词传递的值的元素范围。这个函数返回一个表示容器中值范围的迭代器对。
- en: The final method that needs a sorted container is `binary_search`. This function
    is used to test if a value is in the container. The function is passed iterators
    indicating the range to test and a value, and it will return `true` if there is
    an item in the range equal to that value (you can provide a predicate to perform
    this equality test).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 需要排序容器的最后一个方法是`binary_search`。这个函数用于测试值是否在容器中。函数传递了指示要测试的范围和一个值的迭代器，如果范围中有一个等于该值的项目，则返回`true`（您可以提供一个谓词来执行这个相等测试）。
- en: Using the numeric libraries
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数值库
- en: 'The Standard Library has several libraries of classes to perform numeric manipulations.
    In this section we will cover two: compile-time arithmetic, using `<ratio>`, and
    complex numbers, using `<complex>`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有几个类库，用于执行数值操作。在本节中，我们将涵盖两个：使用`<ratio>`进行编译时算术和使用`<complex>`进行复数运算。
- en: Compile time arithmetic
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时算术
- en: Fractions are a problem because there are some for which there are not enough
    significant figures to accurately represent them, resulting in losing accuracy
    when you use them in further arithmetic. Furthermore, computers are binary and
    merely converting decimal fractional parts to binary will lose accuracy. The `<ratio>`
    library provides classes that allow you to represent fractional numbers as objects
    that are ratios of integers, and perform fraction calculations as ratios. Only
    once you have performed all the fractional arithmetic will you convert the number
    to decimal, and this means that the potential loss of accuracy is minimized. The
    calculations performed by the classes in the `<ratio>` library are carried out
    at *compile time* so the compiler will catch errors such as divide by zero and
    overflows.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 分数是一个问题，因为有一些分数没有足够的有效数字来准确表示它们，这会导致在进一步进行算术运算时失去精度。此外，计算机是二进制的，仅将十进制小数部分转换为二进制将会失去精度。`<ratio>`库提供了允许您将分数表示为整数比率的对象，并将分数计算作为比率进行的类。只有在进行了所有分数算术之后，您才会将数字转换为十进制，这意味着最小化了精度损失。`<ratio>`库中的类执行的计算是在*编译时*进行的，因此编译器将捕捉到除以零和溢出等错误。
- en: 'Using the library is simple; you use the `ratio` class, and provide the numerator
    and denominator as template parameters. The numerator and denominator will be
    stored factorized, and you can access these values through the `num` and `den`
    members of the object:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库很简单；您使用`ratio`类，并将分子和分母作为模板参数提供。分子和分母将被分解存储，您可以通过对象的`num`和`den`成员访问这些值：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will print out `3/4`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出`3/4`。
- en: Fractional arithmetic is carried out using templates (these are, in fact, specializations
    of the `ratio` template). At first sight it may appear a little odd, but you soon
    get used to it!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 分数算术是使用模板进行的（实际上，这些是`ratio`模板的特化）。乍一看可能有点奇怪，但很快你就会习惯的！
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will print out `514/187` (you may want to get some paper and do the fractional
    calculations to confirm this). The data members are actually `static` members,
    so it makes little sense to create variables. Furthermore, because arithmetic
    is carried out using *types* rather than *variables*, it is best to access the
    members through those types:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出`514/187`（您可能需要拿一些纸来进行分数计算以确认这一点）。数据成员实际上是`static`成员，因此创建变量没有太多意义。此外，因为算术是使用*类型*而不是*变量*进行的，最好通过这些类型访问成员：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can now use the sum type as a parameter to any of the other operations that
    you can perform. The four binary arithmetic operations are carried out with `ratio_add`,
    `ratio_subtract`, `ratio_multiply`, and `ratio_divide`. Comparisons are carried
    out through `ratio_equal`, `ratio_not_equal`, `ratio_greater`, `ratio_greater_equal`,
    `ratio_less`, and `ratio_less_equal`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将总和类型作为您可以执行的其他操作的参数。四种二进制算术操作是使用`ratio_add`、`ratio_subtract`、`ratio_multiply`和`ratio_divide`进行的。比较是通过`ratio_equal`、`ratio_not_equal`、`ratio_greater`、`ratio_greater_equal`、`ratio_less`和`ratio_less_equal`进行的。
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This operation tests to see if the calculation performed before (`514/187`)
    is greater than the fraction `25/19` (it is). The compiler will pick up divide-by-zero
    errors and overflows, so the following will not compile:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作测试之前执行的计算（`514/187`）是否大于分数`25/19`（是）。编译器将捕捉到除以零和溢出等错误，因此以下内容将不会编译：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'However, it is important to point out that the compiler will issue the error
    on the second line, when the denominator is accessed. There are also typedefs
    of ratio for the SI prefixes. This means that you can perform your calculations
    in nanometers, and when you need to present the data in meters you can use the
    `nano` type to obtain the ratio:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要指出，当访问分母时，编译器将在第二行发出错误。这里还有SI前缀的比率的typedef。这意味着您可以在纳米中执行计算，当您需要以米呈现数据时，可以使用`nano`类型来获取比率：
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we are doing calculations on a sphere in **nanometers** (**nm**). The
    sphere has a radius of 10 nm, so the first calculation gives the volume as 4188.67
    nm3\. The second calculation converts nanometers into meters; the factor is determined
    from the `nano` ratio (note that for volumes the factor is cubed). You could define
    a class to do such conversions:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在以**纳米**（**nm**）为单位对球体进行计算。球体的半径为10纳米，因此第一次计算得到的体积为4188.67立方纳米。第二次计算将纳米转换为米；因子是从`nano`比率中确定的（请注意，对于体积，因子是立方的）。您可以定义一个类来进行这样的转换：
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The class is defined for a particular type of unit, which will be expressed
    through an instantiation of the `ratio` template. The class has a constructor
    to initialize it for values in those units and a constructor to convert from other
    units, and that simply divides the current units by the units of the other type.
    This class can be used like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 该类是为特定类型的单位定义的，这将通过`ratio`模板的实例化来表达。该类有一个构造函数，用于初始化该单位的值，并且有一个构造函数，用于从其他单位转换，它只是将当前单位除以其他类型的单位。这个类可以这样使用：
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first variable is based on `kilo` and hence the units are kilometers. To
    convert this to meters, the second variable type is based on `ratio<1>`, which
    is the same as `ratio<1,1>`. The result is that the values in the `earth_diameter_km`
    are multiplied by 1000 when placed in `in_meters`. The conversion to miles is
    a bit more involved. There are 1609.344 m in a mile. The ratio used for the `in_miles`
    variable is 1609344/1000 or 1609.344\. We are initializing the variable with the
    `earth_diameter_km`, so isn't that value too big by a factor of 1000? No, the
    reason is that the type of `earth_diameter_km` is `dist_units<kilo>`, so the conversion
    between km and miles will include that factor of 1000.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量基于`kilo`，因此单位是千米。要将其转换为米，第二个变量类型基于`ratio<1>`，与`ratio<1,1>`相同。结果是，当放置在`in_meters`中时，`earth_diameter_km`中的值将乘以1000。将其转换为英里就更复杂了。一英里等于1609.344米。用于`in_miles`变量的比率是1609344/1000或1609.344。我们正在用`earth_diameter_km`初始化变量，所以该值是否不是大了1000倍？不，原因在于`earth_diameter_km`的类型是`dist_units<kilo>`，因此千米和英里之间的转换将包括这个1000倍因子。
- en: Complex numbers
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: Complex numbers are not just of mathematical interest, they are also vital in
    engineering and science, so a `complex` type is an important part of any type
    library. A complex number is made of two parts--the real and imaginary parts.
    As the name suggests, an imaginary number is not real, and cannot be treated as
    real.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 复数不仅在数学上有重要意义，而且在工程和科学中也至关重要，因此`complex`类型是任何类型库的重要组成部分。复数由两部分组成--实部和虚部。正如其名称所示，虚数并非真实存在，不能被视为真实存在。
- en: In mathematics, complex numbers are usually represented as coordinates in two-dimensional
    space. If a real number can be thought of as being one of an infinite number of
    points on the x-axis, an imaginary number can be thought of being one of an infinite
    number of points on the y-axis. The only intersection between these two is the
    origin and since zero is zero, is nothing, it can be a zero real number or a zero
    imaginary number. A complex number has both real and imaginary parts, and hence
    this can be visualized as a Cartesian point. Indeed, another way of visualizing
    a complex number is as a polar number where the point is represented as a vector
    of a specified length at a specified angle to the position on the x-axis (the
    positive real number axis).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，复数通常被表示为二维空间中的坐标。如果一个实数可以被认为是x轴上无限多个点中的一个，那么一个虚数可以被认为是y轴上无限多个点中的一个。这两者之间唯一的交点是原点，由于零就是零，什么都不是，它可以是零实数或零虚数。复数既有实部又有虚部，因此可以将其视为笛卡尔坐标点。事实上，另一种可视化复数的方法是将其视为极坐标，其中该点被表示为指定长度和指定角度的矢量，指向x轴上的位置（正实数轴）。
- en: The `complex` class is based on a floating point type, and there are specializations
    for `float`, `double`, and `long double`. The class is simple; it has a constructor
    with two parameters for the real and imaginary parts of the number, and it defines
    operators (member methods and global functions) for assignment, comparisons, `+`,
    `-`, `/`, and `*`, acting on the real and imaginary parts.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`complex`类基于浮点类型，并且有`float`、`double`和`long double`的特化版本。该类很简单；它有一个构造函数，用于实数和虚数部分的初始化，并且定义了操作符（成员方法和全局函数）用于赋值、比较、`+`、`-`、`/`和`*`，作用于实数和虚数部分。'
- en: 'An operation like `+` is simple for a complex number: you just add the real
    parts together and the imaginary parts together, and these two sums are the real
    and imaginary parts of the result. However, multiplication and division are a
    bit more, umm, complex. In multiplication, you get a quadratic: the aggregation
    of the two real parts multiplied, the two imaginary parts multiplied, the two
    values of the real part of the first multiplied with the imaginary part of the
    second, and the imaginary part of the first multiplied with the real part of the
    second. The complication is that two imaginary numbers multiplied is equivalent
    to the multiplication of two equivalent real numbers multiplied by -1\. Furthermore,
    multiplying a real and an imaginary number results in an imaginary number that
    is equivalent in size to the multiplication of two equivalent real numbers.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复数来说，`+`这样的操作很简单：只需将实部相加，虚部相加，这两个和就是结果的实部和虚部。然而，乘法和除法就有点复杂了。在乘法中，你会得到一个二次方程：两个实部相乘的总和，两个虚部相乘的总和，第一个实部的值与第二个虚部的值相乘，以及第一个虚部的值与第二个实部的值相乘。复杂之处在于，两个虚数相乘等同于两个等效实数相乘再乘以-1。此外，实数和虚数相乘会得到一个与两个等效实数相乘等大的虚数。
- en: 'There are also functions to perform trigonometric operations on complex numbers:
    `sin`, `cos`, `tan`, `sinh`, `cosh`, and `tanh`; and basic math operations such
    as `log`, `exp`, `log10`, `pow`, and `sqrt`. You can also call functions to create
    complex numbers and get information about them. So, the `polar` function will
    take two floating-point numbers representing the polar coordinates of the length
    of the vector and the angle. If you have a `complex` number object you can get
    the polar coordinates by calling `abs` (to get the length) and `arg` (to get the
    angle).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些函数可以对复数执行三角函数操作：`sin`、`cos`、`tan`、`sinh`、`cosh`和`tanh`；以及基本的数学运算，如`log`、`exp`、`log10`、`pow`和`sqrt`。你还可以调用函数来创建复数并获取有关它们的信息。因此，`polar`函数将接受两个浮点数，表示矢量长度和角度的极坐标。如果你有一个`complex`数对象，你可以通过调用`abs`（获取长度）和`arg`（获取角度）来获取极坐标。
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The first point to make is that there is an `ostream` insertion operator defined
    for `complex` numbers so you can insert them into the `cout` stream object. The
    output from this code is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要指出的是，对于`complex`数，定义了一个`ostream`插入运算符，因此可以将它们插入到`cout`流对象中。这段代码的输出如下：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The second line shows the limitations of using just five decimal places for
    the square root of 2 and -1/4 pi, this number is, in fact, the complex number
    `(1, -1)`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示了仅使用五位小数来表示2的平方根和-1/4π的局限性，实际上这个数字是复数`(1，-1)`。
- en: Using the Standard Library
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准库。
- en: 'In this example, we will develop a simple parser for **Comma Separated Value**
    (**CSV**) files. The rules we will follow are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将开发一个简单的**逗号分隔值**（**CSV**）文件解析器。我们将遵循的规则如下：
- en: Each record will occupy one line, and newline indicates a new record
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条记录将占据一行，换行符表示一个新的记录。
- en: Fields in the record are separated by commas, unless they are within a quoted
    string
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录中的字段由逗号分隔，除非它们在引用的字符串内部。
- en: Strings can be quoted using single (`'`) or double quotes (`"`), in which case
    they can contain commas as part of the string
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以使用单引号（`'`）或双引号（`"`）进行引用，在这种情况下，它们可以包含逗号作为字符串的一部分。
- en: Quotes immediately repeated (`''` or `""`) is a literal, and a part of the string
    rather than a delimiter of a string
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即重复的引号（`''`或`""`）是一个字面值，是字符串的一部分而不是字符串的分隔符。
- en: If a string is quoted, then spaces outside of the string are ignored
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个字符串被引用，那么字符串外部的空格将被忽略。
- en: This is a very basic implementation, and omits the usual requirement that quoted
    strings can contain newlines.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的实现，省略了带引号的字符串可以包含换行符的通常要求。
- en: In this example, much of the manipulation will be using `string` objects as
    containers of individual characters.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，大部分操作将使用`string`对象作为单个字符的容器。
- en: 'Start by creating a folder for the chapter called `Chapter_08` in the folder
    for this book. In that folder, create a file called `csv_parser.cpp`. Since the
    application will use console output and file input, add the following lines at
    the top of the file:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在这本书的文件夹中创建一个名为`Chapter_08`的章节文件夹。在该文件夹中，创建一个名为`csv_parser.cpp`的文件。由于该应用程序将使用控制台输出和文件输入，因此在文件顶部添加以下行：
- en: '[PRE75]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The application will also take a command line parameter that is the CSV file
    to parse, so add the following code at the bottom of the file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还将接受一个命令行参数，即要解析的CSV文件，因此在文件底部添加以下代码：
- en: '[PRE76]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The application will read a file line by line into a `vector` of `string` objects,
    so add `<vector>` to the list of include files. To make the coding easier, define
    the following above the `usage` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将逐行读取文件到一个`string`对象的`vector`中，因此将`<vector>`添加到包含文件列表中。为了使编码更容易，定义如下内容在`usage`函数之上：
- en: '[PRE77]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `main` function will read the file in line by line and the simplest way
    to do this is to use the `getline` function, so add the `<string>` header file
    to the include file list. Add the following lines to the end of the `main` function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数将逐行读取文件，最简单的方法是使用`getline`函数，因此将`<string>`头文件添加到包含文件列表中。在`main`函数的末尾添加以下行：'
- en: '[PRE78]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The first few lines open the file using an `ifstream` class. If the file cannot
    be found, then the operation to open the file fails and this is tested by calling
    `is_open`. Next, a `vector` of `string` objects is declared and filled with lines
    read from the file. The `getline` function has two parameters: the first is the
    open file stream object and the second is a string to contain the character data.
    This function returns the stream object, which has a `bool` conversion operator,
    and hence the `for` statement will loop until this stream object indicates that
    it can read no more data. When the stream gets to the end of the file, an internal
    end-of-file flag is set and this causes the `bool` conversion operator to return
    a value of `false`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行使用`ifstream`类打开文件。如果找不到文件，则打开文件的操作失败，并通过调用`is_open`进行测试。接下来，声明了一个`string`对象的`vector`并填充了从文件中读取的行。`getline`函数有两个参数：第一个是打开的文件流对象，第二个是包含字符数据的字符串。这个函数返回流对象，它具有`bool`转换运算符，因此`for`语句将循环，直到这个流对象指示它无法再读取更多数据为止。当流到达文件末尾时，内部的文件结束标志被设置，这导致`bool`转换运算符返回`false`值。
- en: If the `getline` function reads a blank line, then the `string` will not be
    able to be parsed, so there is a test for this, and such blank lines are not stored.
    Each legitimate line is pushed into the `vector`, but, since this `string` variable
    will not be used after this operation, we can use move semantics and so this is
    made explicit by calling the `move` function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`getline`函数读取了一个空行，那么`string`将无法解析，因此对此进行了测试，并且这样的空行不会被存储。每个合法的行都被推入`vector`中，但由于这个`string`变量在此操作后将不再被使用，我们可以使用移动语义，因此通过调用`move`函数来明确表示这一点。
- en: 'This code will now compile and run (although it will produce no output). You
    can use it on any CSV file that meets the criteria given previously, but as a
    test file we have used the following file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在可以编译和运行（尽管它不会产生任何输出）。您可以在任何符合先前给定标准的CSV文件上使用它，但作为测试文件，我们使用了以下文件：
- en: '[PRE79]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These are US presidents up to 1845; the first string is the name of the president
    and their affiliation, but when the president has no affiliation then it is missed
    out (Washington and Tyler). The names are then followed by the start and end years
    of their terms of office.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是直到1845年的美国总统；第一个字符串是总统的名字和他们的从属关系，但当总统没有从属关系时，它被省略了（华盛顿和泰勒）。然后是他们的任期开始和结束年份。
- en: 'Next, we want to parse the data in the vector and split the items into individual
    fields according to the rules given previously (fields separated by commas, but
    quotation marks are respected). To do this, we will represent each line as a `list`
    of fields, with each field being a `string`. Add an include for `<list>` near
    the top of the file. At the top of the file, where the `using` declarations are
    made, add the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要解析向量中的数据，并根据先前给定的规则（由逗号分隔的字段，但尊重引号）将项目拆分为单独的字段。为此，我们将每一行表示为字段的`list`，每个字段都是`string`。在文件顶部附近添加`<list>`的包含。在进行`using`声明的地方，添加以下内容：
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, at the bottom of the `main` function, add:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main`函数的底部，添加：
- en: '[PRE81]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The first line creates the `vector` of `list` objects, and the `for` loop iterates
    through each line calling a function called `parse_line` that parses a string
    and returns a `list` of `string` objects. The return value of the function will
    be a temporary object and hence an rvalue, so this means that the version of `push_back`
    with move semantics will be called.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了`vector`的`list`对象，并且`for`循环遍历每一行，调用一个名为`parse_line`的函数，该函数解析一个字符串并返回`string`对象的`list`。函数的返回值将是一个临时对象，因此是一个rvalue，这意味着将调用具有移动语义的`push_back`版本。
- en: 'Above the usage function, add the start of the `parse_line` function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用函数之上，添加`parse_line`函数的开始：
- en: '[PRE82]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The function will treat the string as a container of characters and hence it
    will iterate through the line parameter with a `const_iterator`. The parsing will
    be carried out in a `do` loop, so add the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将把字符串视为字符的容器，因此它将使用`const_iterator`迭代遍历行参数。解析将在`do`循环中进行，因此添加以下内容：
- en: '[PRE83]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The Boolean variables will be explained in a moment. The `do` loop increments
    the iterator, and when it reaches the `end` value, the loop finishes. The `item`
    variable will hold the parsed data (at this point it is empty) and the last line
    will put the value into the `list`; this is so that any unsaved data is stored
    in the `list` before the function finishes. Since the item variable is about to
    be destroyed, the call to `move` ensures that its contents are moved into the
    `list` rather than copied. Without this call, the string copy constructor will
    be called when putting the item into the `list`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量将在下一刻被解释。`do`循环递增迭代器，当它达到`end`值时，循环结束。`item`变量将保存解析的数据（此时为空），最后一行将值放入`list`；这样，在函数结束之前，任何未保存的数据都将存储在`list`中。由于`item`变量即将被销毁，因此调用`move`确保将其内容移入`list`而不是复制。如果没有此调用，将在将项目放入`list`时调用字符串复制构造函数。
- en: 'Next, you need to do the parsing of the data. To do this, add a switch to test
    for the three cases: a comma (to indicate the end of a field), and a quote or
    a double quote to indicate a quoted string. The idea is to read each field and
    build its value up character by character, using the `item` variable.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要对数据进行解析。为此，添加一个`switch`来测试三种情况：逗号（表示字段的结束），引号或双引号（表示引号字符串）。想法是逐个读取每个字段并逐个字符构建其值，使用`item`变量。
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The default action is simple: it copies the character into the temporary string.
    If the character is a single quote, we have two options. Either the quote is within
    a string that is double-quoted, in which case we want the quote to be stored in
    `item`, or the quote is a delimiter, in which case we store whether it is the
    opening or closing quote by setting the `bQuote` value. For the case of a single
    quote, add the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作很简单：它将字符复制到临时字符串中。如果字符是单引号，我们有两个选项。要么引号在双引号引起的字符串中，这种情况下我们希望引号存储在`item`中，要么引号是分隔符，这种情况下我们通过设置`bQuote`值来存储它是开放引号还是闭合引号。对于单引号的情况，添加以下内容：
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This is simple enough. If this is in a double-quoted string (`bDQuote` is set),
    then we store the quote. If not, then we flip the `bQuote bool` so that if this
    is the first quote, we register that the string is quoted, otherwise we register
    that it is the end of a string. If we are at the start of a quoted string, we
    clear the item variable to ignore any spaces between the previous comma (if there
    is one) and the quote. However, this code does not take into account the use of
    two quote marks next to each other, which means that the quote is a literal and
    part of the string. Change the code to add a check for this situation:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。如果这是在双引号字符串中（`bDQuote`已设置），那么我们存储引号。如果不是，那么我们翻转`bQuote`布尔值，以便如果这是第一个引号，我们注册字符串被引用，否则我们注册它是字符串的结尾。如果我们处于引号字符串的开头，我们清除项目变量以忽略前一个逗号（如果有的话）和引号之间的任何空格。但是，此代码没有考虑连续使用两个引号的情况，这意味着引号是字面上的字符串的一部分。更改代码以检查此情况：
- en: '[PRE86]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `if` statement checks to make sure that if we increment the iterator, we
    are not at the end of the line (short-circuiting will kick in here in this case
    and the rest of the expression will not be evaluated). We can test the next item,
    and we then peek at the next item to see if it is a single quote; if it is, then
    we add it to the `item` variable and increment the iterator so that both quotes
    are consumed in the loop.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句检查以确保如果我们递增迭代器，我们不在行的末尾（短路将在这种情况下启动，并且不会评估表达式的其余部分）。我们可以测试下一个项目，然后窥视下一个项目，看看它是否是单引号；如果是，则将其添加到`item`变量中，并递增迭代器，以便在循环中消耗两个引号。'
- en: 'The code for the double quote is similar, but switches over the Boolean variables
    and tests for double quotes:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号的代码类似，但切换布尔变量并测试双引号：
- en: '[PRE87]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, we need code to test for a comma. Again, we have two situations: either
    this is a comma in a quoted string, in which case we need to store the character,
    or it''s the end of a field, in which case we need to finish the parsing for this
    field. The code is quite simple:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要代码来测试逗号。同样，我们有两种情况：要么这是引号中的逗号，在这种情况下，我们需要存储字符，要么这是字段的结尾，在这种情况下，我们需要完成对该字段的解析。代码非常简单：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `if` statement tests to see if we are in a quoted string (in which case
    either `bQuote` or `bDQuote` will be true), and if so, the character is stored.
    If this is the end of the field, we push the `string` into the `list`, but we
    use `move` so that the variable data is moved across and the `string` object left
    in an uninitialized state.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句用于测试我们是否在引号字符串中（在这种情况下，`bQuote`或`bDQuote`将为true），如果是，则存储字符。如果这是字段的结尾，我们将`string`推入`list`，但我们使用`move`，以便数据变量被移动，而`string`对象处于未初始化状态。'
- en: 'This code will compile and run. However, there is still no output, so before
    we redress that, review the code that you have written. At the end of the `main`
    function you will have a `vector` in which each item has a `list` object representing
    each row in the CSV file, and each item in the `list` is a field. You have now
    parsed the file and can use this data accordingly. So that you can see that the
    data has been parsed, add the following lines to the bottom of the `main` function:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将编译并运行。然而，仍然没有输出，所以在纠正之前，回顾一下您编写的代码。在`main`函数的末尾，您将拥有一个`vector`，其中每个项目都有一个代表CSV文件中每一行的`list`对象，而`list`中的每个项目都是一个字段。您现在已经解析了文件，并可以相应地使用这些数据。为了能够看到数据已被解析，将以下行添加到`main`函数的底部：
- en: '[PRE89]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You can now compile the code (use the `/EHsc` switch) and run the application
    passing the name of a CSV file.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编译代码（使用`/EHsc`开关）并运行应用程序，传递CSV文件的名称。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have seen some of the main classes in the C++ Standard
    Library, and investigated in depth the container and iterator classes. One such
    container is the `string` class; this is such an important class that will be
    covered in more depth in the next chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了C++标准库中的一些主要类，并深入研究了容器和迭代器类。其中一个这样的容器是`string`类；这是一个如此重要的类，将在下一章中更深入地介绍。
