- en: Manipulating Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作任务
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖：
- en: Registering a task for an arbitrary data type processing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任意数据类型处理注册任务
- en: Making timers and processing timer events as tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建定时器并将定时器事件作为任务处理
- en: Network communication as a task
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网络通信作为任务
- en: Accepting incoming connections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受传入连接
- en: Executing different tasks in parallel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行执行不同的任务
- en: Pipeline tasks processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道任务处理
- en: Making a nonblocking barrier
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建非阻塞屏障
- en: Storing an exception and making a task from it
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储异常并从中创建任务
- en: Getting and processing system signals as tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和处理系统信号作为任务
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter is all about tasks. We'll be calling the functional object a *task*
    because it is shorter and better reflects what it will do. The main idea of this
    chapter is that we can split all the processing, computations, and interactions
    to functors (tasks), and process each of those tasks almost independently. Moreover,
    we may not block on some slow operations such as receiving data from the socket
    or waiting for the time out, but instead provide a callback task and continue
    working with other tasks. Once the OS finishes, the slow operation, our callback
    is executed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章都是关于任务的。我们将称函数对象为*任务*，因为这样更简洁，更能反映它将要做的事情。这一章的主要思想是，我们可以将所有的处理、计算和交互分解为函数对象（任务），并几乎独立地处理每一个任务。此外，我们可能不会在一些慢操作上阻塞，比如从套接字接收数据或等待超时，而是提供一个回调任务并继续处理其他任务。一旦操作系统完成慢操作，我们的回调就会被执行。
- en: The best way to understand the example is to play with it by modifying, running,
    and extending it. The site, [http://apolukhin.github.io/Boost-Cookbook/](http://apolukhin.github.io/Boost-Cookbook/),
    has all the examples from this chapter, and you can even play with some of them
    online.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理解示例的最佳方法是通过修改、运行和扩展来玩耍。网站[http://apolukhin.github.io/Boost-Cookbook/](http://apolukhin.github.io/Boost-Cookbook/)中有本章的所有示例，甚至可以在线玩耍一些示例。
- en: Before you start
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始之前
- en: This chapter requires at least a basic knowledge of the first, second, and fifth
    chapters. Basic knowledge on C++11 rvalue references and lambdas is required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章至少需要对第一、第二和第五章有基本了解。还需要对C++11的右值引用和lambda有基本了解。
- en: Registering a task for an arbitrary data type processing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为任意数据类型处理注册任务
- en: 'First of all, let''s take care of the class that holds all the tasks and provides
    methods for their execution. We were already doing something like this in the
    [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*, Multithreading,
    Creating a work_queue class* recipe, but some of the following problems were not
    addressed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来处理保存所有任务并提供它们执行方法的类。在[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)的多线程，创建work_queue类的食谱中，我们已经在做类似的事情，但以下一些问题尚未解决：
- en: A `work_queue` class was only storing and returning tasks, but we also need
    to execute existing tasks.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`work_queue`类只存储和返回任务，但我们还需要执行现有任务。'
- en: A task may throw an exception. We need to catch and process exceptions if they
    leave the task boundaries.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可能会抛出异常。如果它们离开任务边界，我们需要捕获和处理异常。
- en: A task may not notice a thread interruption. The next task on the same thread
    may get the interruption instead.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可能不会注意到线程中断。下一个任务可能会收到中断。
- en: We need a way to stop the processing of the tasks.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一种方法来停止任务的处理。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires linking with the `boost_system` and `boost_thread` libraries.
    A basic knowledge of `Boost.Thread` is also required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要链接`boost_system`和`boost_thread`库。还需要对`Boost.Thread`有基本了解。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we use `boost::asio::io_service` instead of `work_queue` from
    the previous chapter. There is a reason for doing this, and we'll see it in the
    following recipes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用`boost::asio::io_service`代替了上一章的`work_queue`。这样做是有原因的，我们将在接下来的食谱中看到。
- en: 'Let''s start from the structure that wraps around a user task:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包装用户任务的结构开始：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For ease of use, we''ll create a function that produces `task_wrapped` from
    the user''s functor:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便使用，我们将创建一个函数，从用户的函数对象产生`task_wrapped`：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we are ready to write the `tasks_processor` class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备编写`tasks_processor`类：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s add the `push_task` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`push_task`方法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s finish this class by adding the member functions for starting and stopping
    a task''s execution loop:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加启动和停止任务执行循环的成员函数来完成这个类：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Done! Now, it is time to test our class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在是时候测试我们的类了：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `main` function may look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数可能是这样的：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `boost::asio::io_service` variable can store and execute tasks posted to
    it. But we may not post a user''s tasks to it directly, because they may receive
    an interruption addressed to other tasks or throw an exception. That is why we
    wrap a user''s task in the `detail::task_wrapped` structure. It resets all the
    previous interruptions by calling:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::io_service`变量可以存储和执行发布到它的任务。但我们可能不能直接将用户的任务发布到它，因为它们可能接收到针对其他任务的中断或抛出异常。这就是为什么我们将用户的任务包装在`detail::task_wrapped`结构中。它通过调用重置所有先前的中断：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`detail::task_wrapped` executes the task in the `try{ } catch()` block making
    sure that no exception leaves the `operator()` bounds.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`detail::task_wrapped`在`try{ } catch()`块中执行任务，确保没有异常离开`operator()`边界。'
- en: Take a look at the `start()` function. The `boost::asio::io_service::run()`
    starts processing tasks posted to the `io_service` variable. If `boost::asio::io_service::run()`
    is not called, then posted tasks are not executed (this can be seen in the `main()`
    function). Task processing may be stopped via a call to `boost::asio::io_service::stop()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`start()`函数。`boost::asio::io_service::run()`开始处理发布到`io_service`变量的任务。如果没有调用`boost::asio::io_service::run()`，则不会执行发布的任务（可以在`main()`函数中看到）。可以通过调用`boost::asio::io_service::stop()`来停止任务处理。
- en: 'The `boost::asio::io_service` class returns from the `run()` function if there
    are no more tasks left, so we force it to continue with the execution using an
    instance of `boost::asio::io_service::work`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`boost::asio::io_service`类从`run()`函数返回，表示没有剩余的任务，因此我们使用`boost::asio::io_service::work`的实例来强制它继续执行：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `iostream` classes and variables, such as `std::cerr` and `std::cout` are
    not thread safe on pre C++11 compilers and may produce interleaved characters
    on C++11 compatible compilers. In real projects, additional synchronization must
    be used to get readable output. For the simplicity of an example, we do not do
    that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在预C++11编译器上，`iostream`类和变量（如`std::cerr`和`std::cout`）不是线程安全的，并且可能在C++11兼容的编译器上产生交错的字符。在实际项目中，必须使用额外的同步来获得可读的输出。为了简单起见，我们没有这样做。
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++17 standard library has no `io_service`. However, a big part of the `Boost.Asio`
    library is proposed as a Networking **Technical Specification** (**TS**) as an
    addition to C++.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C++17标准库没有`io_service`。但是，`Boost.Asio`库的大部分内容被提议作为Networking **Technical Specification**
    (**TS**)作为C++的补充。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The following recipes in this chapter will show you why we choose `boost::asio::io_service`
    instead of using our handwritten code from [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)**,
    Multithreading**
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下示例将向您展示为什么我们选择`boost::asio::io_service`而不是使用我们在[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)**，多线程**中手写的代码
- en: You may consider the documentation of `Boost.Asio` for getting some examples,
    tutorials, and class references at [http://boost.org/libs/asio](http://boost.org/libs/asio)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以考虑阅读`Boost.Asio`的文档，获取一些示例、教程和类引用，网址为[http://boost.org/libs/asio](http://boost.org/libs/asio)
- en: You may also read the *Boost.Asio C++ Network Programming* book, which gives
    a smoother introduction to `Boost.Asio` and covers some details that are not covered
    in this book
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以阅读*Boost.Asio C++ Network Programming*一书，该书对`Boost.Asio`进行了更顺畅的介绍，并涵盖了本书中未涵盖的一些细节
- en: Making timers and processing timer events as tasks
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建定时器并将定时器事件处理为任务
- en: 'It is a common task to check something with specified intervals. For example,
    we need to check some sessions for an activity once in every 5 seconds. There
    are popular solutions for such a problem:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以指定的间隔检查某些内容是一个常见的任务。例如，我们需要每5秒检查一次某些会话的活动情况。对于这样的问题，有一些常见的解决方案：
- en: The bad solution creates a thread that does the checking and then sleeps for
    5 seconds. This is a lame solution that eats a lot of system resources and scales
    badly.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕的解决方案创建一个线程进行检查，然后休眠5秒。这是一个糟糕的解决方案，会消耗大量系统资源，并且扩展性差。
- en: The right solution uses system specific APIs for manipulating timers asynchronously.
    This is a better solution, that requires some work and is not portable, unless
    you use `Boost.Asio`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的解决方案使用特定于系统的API来异步操作定时器。这是一个更好的解决方案，需要一些工作，并且不具有可移植性，除非您使用`Boost.Asio`。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must know how to use C++11 rvalue-references and `unique_ptr`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须知道如何使用C++11的右值引用和`unique_ptr`。
- en: This recipe is based on the code from the previous recipe. See the first recipe
    of this chapter to get information about the `boost::asio::io_service` and `task_queue`
    classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是基于上一个示例的代码。请参阅本章的第一个示例，了解`boost::asio::io_service`和`task_queue`类的信息。
- en: Link this recipe with the `boost_system` and `boost_thread` libraries. Define
    `BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS` to bypass restrictive library checks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例与`boost_system`和`boost_thread`库链接。定义`BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS`以绕过限制性库检查。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We just modify the `tasks_processor` class by adding new methods to run a task
    at some specified time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需通过添加新的方法来修改`tasks_processor`类，以在指定的时间运行任务。
- en: 'Let''s add a method to our `tasks_processor` class for the delayed running
    of a task:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的`tasks_processor`类添加一个延迟运行任务的方法：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As a final step, we create a `timer_task` structure:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，我们创建一个`timer_task`结构：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s how we could use the new functionality:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用新功能的方式：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Where `test_functor` is structure with defined `operator()` and `test_func1`
    is a function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`test_functor`是具有定义的`operator()`的结构，`test_func1`是一个函数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In short, when a specified amount of time is passed, `boost::asio::deadline_timer`
    pushes the task to the instance of `boost::asio::io_service` class for execution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当经过指定的时间后，`boost::asio::deadline_timer`将任务推送到`boost::asio::io_service`类的实例中进行执行。
- en: 'All the nasty stuff is inside the `run_delayed` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有糟糕的东西都在`run_delayed`函数中：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `tasks_processor::run_delayed` function accepts a timeout and a functor
    to call after the timeout. In it, a unique pointer to `boost::asio::deadline_timer`
    is created. `boost::asio::deadline_timer` holds platform-specific stuff for asynchronous
    execution of a task.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasks_processor::run_delayed`函数接受一个超时和一个在超时后调用的函数对象。在其中，创建了一个`boost::asio::deadline_timer`的唯一指针。`boost::asio::deadline_timer`保存了用于异步执行任务的特定于平台的内容。'
- en: '`Boost.Asio` does not manage memory out of the box. The library user has to
    take care of managing resources usually by keeping them in the task. So if we
    need a timer and want some function to execute after the specified timeout, we
    have to move the timer''s unique pointer into the task, get a reference to the
    timer, and pass a task to the timer.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Asio`不会自动管理内存。库用户必须负责管理资源，通常是通过将资源保存在任务中。因此，如果我们需要一个定时器，并且希望在指定的超时后执行某个函数，我们必须将定时器的唯一指针移动到任务中，获取定时器的引用，并将任务传递给定时器。'
- en: 'We are getting a reference to the `deadline_timer` in this line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一行中获取了`deadline_timer`的引用：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we create a `detail::timer_task` object that stores a functor and gets
    the ownership of the `unique_ptr<boost::asio::deadline_timer>` :'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个`detail::timer_task`对象，该对象存储一个函数对象，并获取`unique_ptr<boost::asio::deadline_timer>`的所有权：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `boost::asio::deadline_timer` must not be destroyed until it is triggered,
    and moving it into the `timer_task` functor guarantees that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::deadline_timer`在触发之前不能被销毁，并且将其移动到`timer_task`函数对象中可以保证这一点。'
- en: 'Finally, we instruct the `boost::asio::deadline_timer` to post the `timer_task`
    functor to the `io_service` when the requested amount of time elapses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指示 `boost::asio::deadline_timer` 在请求的时间到达时将 `timer_task` 函数对象发布到 `io_service`
    中。
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Reference to the `io_service` variable is kept inside the `boost::asio::deadline_timer`
    variable. That's why its constructor requires a reference to `io_service` to store
    it and post the task to it as soon as the timeout elapses.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`io_service` 变量的引用被保留在 `boost::asio::deadline_timer` 变量中。这就是为什么它的构造函数需要一个 `io_service`
    的引用来存储它，并在超时结束后将任务发布到它。'
- en: The `detail::timer_task::operator()` method accepts `boost::system::error_code`,
    which contains error description if something bad happened while waiting. If no
    error occurred, we call the user's functor that is wrapped to catch exceptions
    (we re-use the `detail::task_wrapped` structure from the first recipe).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`detail::timer_task::operator()` 方法接受 `boost::system::error_code`，其中包含了等待时发生的错误描述。如果没有发生错误，我们调用用户的函数对象，该函数对象被包装以捕获异常（我们重用了第一个示例中的
    `detail::task_wrapped` 结构）。'
- en: '`boost::asio::deadline_timer::async_wait` does not consume CPU resources or
    thread of execution while waiting for the timeout. You may simply push some further
    into the `io_service` and they will start executing while the timeout is being
    maintained by OS:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::deadline_timer::async_wait` 在等待超时时不会消耗 CPU 资源或执行线程。您可以简单地将一些任务推送到
    `io_service` 中，它们将在超时被操作系统维护的同时开始执行：'
- en: '![](img/00010.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: 'As a rule of thumb: all the resources that are used during the `async_*` calls
    must be stored in the task.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则：在 `async_*` 调用期间使用的所有资源必须存储在任务中。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some exotic/antique platforms have no APIs to implement timers in a good way,
    so the `Boost.Asio` library emulates the behavior of the asynchronous timer using
    an additional thread of execution per `io_service`. There's just no other way
    to do it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些古怪/古老的平台没有好的方式来实现定时器的 API，因此 `Boost.Asio` 库使用每个 `io_service` 的额外执行线程来模拟异步定时器的行为。没有其他方法可以做到这一点。
- en: C++17 has no `Boost.Asio`-like classes in it; however, the Networking TS has
    `async_wait` and `timer` classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 中没有类似于 `Boost.Asio` 的类；然而，Networking TS 中有 `async_wait` 和 `timer` 类。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Reading the first recipe from this chapter will teach you the basics of `boost::asio::io_service`.
    The following recipes will provide you with more examples of `io_service` usage
    and will show you how to deal with network communications, signals, and other
    features using `Boost.Asio`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读本章第一个示例将教会您如何使用 `boost::asio::io_service` 的基础知识。接下来的示例将为您提供更多关于 `io_service`
    使用的示例，并向您展示如何使用 `Boost.Asio` 处理网络通信、信号和其他功能。
- en: You may consider the documentation of `Boost.Asio` for getting some examples,
    tutorials, and class references at [http://boost.org/libs/asio](http://boost.org/libs/asio)
    site.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以考虑查看 `Boost.Asio` 的文档，获取一些示例、教程和类引用，网址为 [http://boost.org/libs/asio](http://boost.org/libs/asio)。
- en: Network communication as a task
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络通信作为一个任务
- en: Receiving or sending data by network is a slow operation. While packets are
    received by the machine, and while OS verifies them and copies the data to the
    user-specified buffer, multiple seconds may pass.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络接收或发送数据是一个缓慢的操作。当机器接收数据包时，操作系统验证它们并将数据复制到用户指定的缓冲区中，可能会花费多秒钟。
- en: We may do a lot of work rather than waiting! Let's modify our `tasks_processor`
    class so that it would be capable of sending and receiving data in an asynchronous
    manner. In nontechnical terms, we ask it to receive at least *N* bytes from the
    remote host and after that is done, call our functor. By the way, do not block
    on this call. Those readers who know about **libev**, **libevent**, or Node.js
    may find a lot of familiar things in this recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会做很多工作，而不是等待！让我们修改我们的 `tasks_processor` 类，使其能够以异步方式发送和接收数据。非技术术语中，我们要求它至少从远程主机接收
    *N* 字节，完成后调用我们的函数对象。顺便说一下，不要在此调用上阻塞。了解 **libev**、**libevent** 或 Node.js 的读者可能会在这个示例中找到很多熟悉的东西。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the previous two recipes. See the first recipe of this
    chapter to get information about the `boost::asio::io_service` and `task_queue`
    classes. See the second recipe review the basics of async processing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例基于前两个示例。请参阅本章的第一个示例，了解有关 `boost::asio::io_service` 和 `task_queue` 类的信息。请参阅第二个示例，复习异步处理的基础知识。
- en: Link this recipe with the `boost_system` and `boost_thread` libraries. Define
    `BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS` to bypass over restrictive library
    checks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例与 `boost_system` 和 `boost_thread` 库链接起来。定义 `BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS`
    以绕过过于严格的库检查。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's extend the code from the previous recipe by adding methods to create connections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加方法来创建连接来扩展前一个示例中的代码。
- en: 'A connection would be represented by a `connection_with_data` class. This class
    is keeping socket to the remote host and a `std::string` for receiving and sending
    data:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接将由 `connection_with_data` 类表示。这个类保持了与远程主机的套接字和一个用于接收和发送数据的 `std::string`：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just like in the previous recipe, class would be mostly used by unique pointer
    to it. Let''s add a `typedef` for simplicity:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一个示例一样，类将主要由唯一指针使用。让我们为简单起见添加一个 `typedef`：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `tasks_processor` class from previous recipe owns the `boost::asio::io_service`
    object. It seems reasonable to make it a factory for constructing connections:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个示例中的 `tasks_processor` 类拥有 `boost::asio::io_service` 对象。将其作为构建连接的工厂似乎是合理的：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the methods for async writing data to remote host:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是将数据异步写入远程主机的方法：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the methods for async reading data from remote host:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是从远程主机异步读取数据的方法：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final part is the `task_wrapped_with_connection` class definition:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一部分是 `task_wrapped_with_connection` 类的定义：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Done! Now, the library user can use the preceding class like this to send the
    data:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，库用户可以像这样使用前面的类来发送数据：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Users may also use it like this to receive data:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也可以像这样使用它来接收数据：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is how a library user may handle the received data:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是库用户处理接收到的数据的方法：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Boost.Asio` library does not manage resources and buffers out of the box.
    So, if we want some simple interface for reading and writing data, the simplest
    solution would be to tie together the socket and buffer for sending/receiving
    data. That's what the `connection_with_data` class does. It holds a `boost::asio::ip::tcp::socket`,
    which is a `Boost.Asio` wrapper around native sockets and a `std::string` variable
    that we use as a buffer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Asio`库不会直接管理资源和缓冲区。因此，如果我们想要一些简单的接口来读取和写入数据，最简单的解决方案就是将套接字和缓冲区绑定在一起以发送/接收数据。这就是`connection_with_data`类所做的事情。它包含一个`boost::asio::ip::tcp::socket`，这是`Boost.Asio`对本机套接字的包装，以及一个我们用作缓冲区的`std::string`变量。'
- en: 'A constructor of the `boost::asio::ip::tcp::socket` class accepts `boost::asio::io_service`
    as almost all the classes in `Boost.Asio`. After we create a socket, it must be
    connected to some remote endpoint:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::ip::tcp::socket`类的构造函数接受`boost::asio::io_service`，几乎所有`Boost.Asio`类都是如此。创建套接字后，它必须连接到某个远程端点：'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Take a look at the writing function. It accepts a unique pointer to the `connection_with_data`
    class and functor `f`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下写函数。它接受一个指向`connection_with_data`类的唯一指针和函数对象`f`：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In it, we get references to socket and buffer:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们获取了套接字和缓冲区的引用：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we ask for asynchronous write:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们请求进行异步写入：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All the interesting things happen in the `boost::asio::async_write` function.
    Just as in the case of timers, asynchronous call returns immediately without executing
    a function. It only tells to post the callback task to the `boost::asio::io_service`
    after some operation finishes (in our case, it''s writing data to the socket).
    `boost::asio::io_service` executes our function in one of the threads that called
    the `io_service::run()` method. The following diagram illustrates this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有趣的事情都发生在`boost::asio::async_write`函数中。就像定时器一样，异步调用立即返回而不执行函数。它只是告诉在某些操作完成后将回调任务发布到`boost::asio::io_service`中。`boost::asio::io_service`在调用`io_service::run()`方法的线程中执行我们的函数。以下图表说明了这一点：
- en: '![](img/00011.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: Now, take a look at `task_wrapped_with_connection::operator()`. It accepts `const
    boost::system::error_code& error` and `std::size_t bytes_count`, because both
    `boost::asio::async_write` and `boost::asio::async_read` functions pass those
    parameters on async operation completion. A call to `c_->data.resize(bytes_count);`
    resizes the buffer to contain only the received/written data. Finally, we call
    the callback that was initially passed to an `async` function and stored as `task_unwrapped_`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下`task_wrapped_with_connection::operator()`。它接受`const boost::system::error_code&
    error`和`std::size_t bytes_count`，因为`boost::asio::async_write`和`boost::asio::async_read`函数在异步操作完成时传递这些参数。调用`c_->data.resize(bytes_count);`将缓冲区的大小调整为仅包含接收/写入的数据。最后，我们调用最初传递给`async`函数并存储为`task_unwrapped_`的回调。
- en: 'What was that all about? That was all about having a simple way for sending
    data! Now, we have an `async_write_data` function that asynchronously writes data
    from the buffer to the socket and executes a callback on operation completion:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切是关于什么？这一切都是为了简单地发送数据！现在，我们有一个`async_write_data`函数，它会将缓冲区中的数据异步写入套接字，并在操作完成时执行回调：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`async_read_data` is pretty close to `async_write_data`. It resizes the buffer,
    creates a `task_wrapped_with_connection` function, and pushes it into `is_service`
    on async operation completion.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`async_read_data`与`async_write_data`非常接近。它调整缓冲区的大小，创建一个`task_wrapped_with_connection`函数，并在异步操作完成时将其推送到`is_service`中。'
- en: 'Note the `async_read_data_at_least` function. In its body, there''s a slightly
    different call to `boost::asio::async_read`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`async_read_data_at_least`函数。在其中，对`boost::asio::async_read`有一个略有不同的调用：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It has a `boost::asio::transfer_at_least(al_least_bytes)` in it. `Boost.Asio`
    has a lot of functors for customizing reads and writes. This one functor says,
    *transfer at least* `at_least_bytes` *bytes before calling the callback. More
    bytes are OK until they fit in buffer*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含`boost::asio::transfer_at_least(al_least_bytes)`。`Boost.Asio`有很多用于自定义读取和写入的函数对象。这个函数对象表示，在调用回调之前*至少传输*`at_least_bytes`*字节。更多的字节是可以的，直到它们适合缓冲区*。
- en: 'Finally, let''s take a look at one of the callbacks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下其中一个回调函数：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, callbacks must accept `connection_ptr` and a `boost::system::error_code`
    variable. A `boost::system::error_code` variable holds information about errors.
    It has an explicit conversion to `bool` operator, so the simple way to check for
    errors is just to write `if (err) { ... }`. If the remote ends transmission and
    closes the socket, `err` may contain `boost::asio::error::eof` error code. This
    is not always bad. In our example, we treat it as a non error behavior:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，回调函数必须接受`connection_ptr`和`boost::system::error_code`变量。`boost::system::error_code`变量包含有关错误的信息。它有一个显式转换为`bool`运算符，所以检查错误的简单方法就是写`if
    (err) { ... }`。如果远程端结束传输并关闭套接字，`err`可能包含`boost::asio::error::eof`错误代码。这并不总是坏事。在我们的例子中，我们将其视为非错误行为：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because we have tied together the socket and the buffer, you can get the received
    data from `soc->data`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经将套接字和缓冲区绑定在一起，所以可以从`soc->data`中获取接收到的数据：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `soc->shutdown()` call is optional, because when `soc` goes out of scope,
    the destructor for it is called. Destructor of `unique_ptr<connection_with_data>`
    calls `~connection_with_data` that has a `shutdown()` in its body.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`soc->shutdown()`的调用是可选的，因为当`soc`超出范围时，会调用其析构函数。`unique_ptr<connection_with_data>`的析构函数调用`~connection_with_data`，其主体中包含`shutdown()`。'
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Our `task_wrapped_with_connection::operator()` is not good enough! User provided
    `task_unwrapped_` callback my throw exceptions and may get interrupted by a `Boost.Thread`
    interruption that does not belong to that particular task. The fix would be to
    wrap the callback into the class from first recipe:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`task_wrapped_with_connection::operator()`还不够好！用户提供的`task_unwrapped_`回调可能会抛出异常，并且可能会被不属于特定任务的`Boost.Thread`中断。修复方法是将回调包装到第一个示例中的类中：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In `task_wrapped_with_connection::operator()`, we create a lambda function named
    `lambda`. On execution, `lambda` resizes the data inside the `connection_with_data`
    class to the `bytes_count` and calls an initially passed callback. Finally, we
    wrap the `lambda` into our safe for execution tasks from the first recipe and
    then execute it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`task_wrapped_with_connection::operator()`中，我们创建了一个名为`lambda`的lambda函数。在执行时，`lambda`将`connection_with_data`类内的数据调整为`bytes_count`，并调用最初传递的回调。最后，我们将`lambda`包装到我们的安全执行任务中，并执行它。
- en: 'You may see a lot of `Boost.Asio` examples on the Internet. Many of those use
    `shared_ptr` instead of a `unique_ptr` for keeping the data around. Approach with
    `shared_ptr` is simpler to implement; however, it has two big drawbacks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在互联网上看到很多`Boost.Asio`的示例。其中许多使用`shared_ptr`而不是`unique_ptr`来保留数据。使用`shared_ptr`的方法更容易实现；但是，它有两个很大的缺点：
- en: 'Efficiency: `shared_ptr` has an atomic counter inside, and modifying it from
    different threads may significantly degrade performance. In one of the next recipes,
    you will see how to process tasks in multiple threads, and that''s the place where
    the differences may be noticeable in cases of high load.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率：`shared_ptr`内部有一个原子计数器，从不同线程修改它可能会显著降低性能。在接下来的一个示例中，您将看到如何在多个线程中处理任务，这是在高负载情况下可能会有所不同的地方。
- en: 'Explicitness: With `unique_ptr`, you always see that the ownership of the connection
    was transferred to somewhere (you see `std::move` in code). With `shared_ptr`,
    you can not understand from the interface whether the function grabs the ownership
    or if it just uses a reference to an object.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确性：使用`unique_ptr`，您总是可以看到连接的所有权已转移到某个地方（在代码中看到`std::move`）。使用`shared_ptr`，您无法从接口中了解函数是否获取了所有权，还是仅使用了对象的引用。
- en: However, you may be forced to use `shared_ptr`, if according to the application's
    logic, the ownership has to be shared across multiple tasks at the same time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果根据应用程序的逻辑，所有权必须在多个任务之间共享，您可能会被迫使用`shared_ptr`。
- en: '`Boost.Asio` is not a part of C++17, but it will be shipped as a Networking
    TS soon, and included into the one of the upcoming C++ standards.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Asio`不是C++17的一部分，但它将很快作为Networking TS发布，并包含在即将到来的C++标准中。'
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the official documentation of `Boost.Asio` for more examples, tutorials,
    full reference at [http://boost.org/libs/asio](http://boost.org/libs/asio), and
    an example of how to use the UDP or ICMP protocols.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅`Boost.Asio`的官方文档，了解更多示例、教程、完整参考资料，以及如何使用UDP或ICMP协议的示例，网址为[http://boost.org/libs/asio](http://boost.org/libs/asio)。
- en: You may also read the *Boost.Asio C++ Network Programming* book, which describes
    `Boost.Asio` in more detail
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以阅读《Boost.Asio C++网络编程》一书，该书更详细地描述了`Boost.Asio`
- en: Accepting incoming connections
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受传入连接
- en: A server-side working with a network often looks like a sequence where we first
    get the new connection, read data, then process it, and then send the result.
    Imagine that we are creating some kind of authorization server that must process
    huge amount of requests per second. In that case, we need to accept, receive,
    send asynchronously, and process tasks in multiple threads.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络一起工作的服务器端通常看起来像一个序列，我们首先获取新连接，然后读取数据，然后处理数据，最后发送结果。想象一下，我们正在创建某种必须每秒处理大量请求的授权服务器。在这种情况下，我们需要异步接受、接收、发送，并在多个线程中处理任务。
- en: In this recipe, we'll see how to extend our `tasks_processor` class to accept
    and process incoming connections, and, in the next recipe, we'll see how to make
    it multithreaded.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何扩展我们的`tasks_processor`类以接受和处理传入连接，在下一个示例中，我们将看到如何使其多线程化。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires a good knowledge of `boost::asio::io_service` basics as
    described in the first recipes of this chapter. Some knowledge about network communications
    will be of help to you. Knowledge of `boost::function` and information from at
    least two previous recipes is also required. Link this recipe with the `boost_system`
    and `boost_thread` libraries. Define `BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS`
    to bypass over restrictive library checks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要对`boost::asio::io_service`的基础知识有很好的了解，就像本章的第一个示例中描述的那样。对网络通信的一些了解将对您有所帮助。还需要对`boost::function`的了解，以及至少两个先前示例中的信息。将此示例与`boost_system`和`boost_thread`库链接。定义`BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS`以绕过过于严格的库检查。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Just like in the previous recipes, we add new methods to our `tasks_processor`
    class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在以前的示例中一样，我们向我们的`tasks_processor`类添加新的方法。
- en: 'We start with adding some `typedefs` to the `tasks_processor`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加一些`typedefs`到`tasks_processor`：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s add a class that ties together the socket for new incoming connections,
    socket to listen to, and a user provided callback for processing new connections:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个类，将新传入连接的套接字、用于监听的套接字以及用户提供的用于处理新连接的回调绑定在一起：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to add a function that starts listening on a specified port:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加一个函数，以在指定端口上开始监听：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Function that starts accepting incoming connections:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始接受传入连接的函数：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also need a functor that handles the new connection:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个处理新连接的函数对象：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Done! Now, we can accept connection in the following manner:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们可以以以下方式接受连接：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The function `add_listener` constructs new `tcp_listener`, that keeps all the
    stuff required for accepting connections. Just as with any asynchronous operation,
    we need to keep resources alive while the operations executes. A unique pointer
    to `tcp_listener` does the job.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`add_listener`构造了新的`tcp_listener`，它保留了接受连接所需的所有内容。就像任何异步操作一样，我们需要在操作执行时保持资源活动。`tcp_listener`的唯一指针可以完成这项工作。
- en: When we construct `boost::asio::ip::tcp::acceptor` specifying the endpoint (see
    *step 3*), it opens a socket at the specified address and gets ready for accepting
    connections.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构造`boost::asio::ip::tcp::acceptor`并指定端点（参见*步骤3*）时，它会在指定地址打开一个套接字，并准备好接受连接。
- en: In *step 4*, we create a new socket and call `async_accept` for that new socket.
    When a new connection comes, `listener->acceptor_` binds this connection to a
    socket and pushes the `tasks_processor::handle_accept` callback into `boost::asio::io_service`.
    As we understood from the previous recipe, all the `async_*` calls return immediately
    and `async_accept` is not a special case.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们创建了一个新套接字，并为该新套接字调用`async_accept`。当新连接到来时，`listener->acceptor_`将此连接绑定到套接字，并将`tasks_processor::handle_accept`回调推送到`boost::asio::io_service`中。正如我们从上一个示例中了解到的，所有的`async_*`调用都会立即返回，`async_accept`也不是特例。
- en: Let's take a closer look at our `handle_accept::operator()`. In it, we create
    a `task_wrapped_with_connection` functor from the previous recipe and move a new
    connection into it. Now, our `listener_ptr` does not have a socket in `new_c_`,
    as it is owned by the functor. We call the function `start_accepting_connection(std::move(listener))`,
    and it creates a new socket in `listener->new_c_` and starts an asynchronous accept.
    An async accept operation does not block, so the program continues execution,
    returns from the `start_accepting_connection(std::move(listener))` function, and
    executes the functor with the connection `task(error, 0)`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的`handle_accept::operator()`。在其中，我们从上一个示例中创建了一个`task_wrapped_with_connection`函数对象，并将一个新连接移动到其中。现在，我们的`listener_ptr`在`new_c_`中没有套接字，因为它是由函数对象拥有的。我们调用函数`start_accepting_connection(std::move(listener))`，它在`listener->new_c_`中创建一个新套接字并开始异步接受。异步接受操作不会阻塞，因此程序继续执行，从`start_accepting_connection(std::move(listener))`函数返回，并执行带有连接`task(error,
    0)`的函数对象。
- en: You've made everything as shown in the example, but the performance of the server
    is not good enough. That's because the example is simplified and many optimizations
    left behind at the scene. The most significant one is to keep a separate small
    buffer in `connection_with_data` and use it for all the internal `Boost.Asio`'s
    callback related allocations. See *Custom memory allocation example* in the official
    documentation of the `Boost.Asio` library for more information on this optimization
    topic.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经按照示例中所示的一切做了，但服务器的性能还不够好。这是因为示例是简化的，许多优化被留在了现场。最重要的一个是在`connection_with_data`中保留一个单独的小缓冲区，并将其用于所有内部`Boost.Asio`回调相关的分配。有关此优化主题的更多信息，请参阅`Boost.Asio`库的官方文档中的*Custom
    memory allocation example*。
- en: When the destructor for the `boost::asio::io_service` is called, destructors
    for all the callbacks are called. This makes the destructor for `tcp_connection_ptr`
    to be called and frees the resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`boost::asio::io_service`的析构函数时，所有回调的析构函数都会被调用。这使得`tcp_connection_ptr`的析构函数被调用并释放资源。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We did not use all the features of the `boost::asio::ip::tcp::acceptor` class.
    It can bind to a specific IPv6 or IPv4 address if we provide a specific `boost::asio::ip::tcp::endpoint`.
    You may also get a native socket via the `native_handle()` method and use some
    OS-specific calls for tuning the behavior. You may set up some options for `acceptor_`
    by calling `set_option`. For example, this is how you may force an `acceptor_`
    to reuse the address:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用`boost::asio::ip::tcp::acceptor`类的所有功能。如果我们提供一个特定的`boost::asio::ip::tcp::endpoint`，它可以绑定到特定的IPv6或IPv4地址。您还可以通过`native_handle()`方法获取本机套接字，并使用一些特定于操作系统的调用来调整行为。您可以通过调用`set_option`为`acceptor_`设置一些选项。例如，这是您可以强制`acceptor_`重用地址的方法：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Reusing the address provides an ability to restart the server quickly after
    it was terminated without correct shutdown. After the server was terminated, a
    socket may be opened for some time, and you won't be able to start the server
    on the same address without the `reuse_address` option.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重用地址可以在服务器在没有正确关闭的情况下快速重新启动。服务器终止后，套接字可能会打开一段时间，如果没有`reuse_address`选项，您将无法在相同的地址上启动服务器。
- en: C++17 has no classes from `Boost.Asio`, but Networking TS with most of the functionality
    is coming soon.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有来自`Boost.Asio`的类，但具有大部分功能的Networking TS即将推出。
- en: See also
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Starting this chapter from the beginning is a good idea to get much more information
    about `Boost.Asio`
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章是获取关于`Boost.Asio`更多信息的好方法
- en: See the official documentation of `Boost.Asio` for more examples, tutorials,
    and a complete reference at [http://boost.org/libs/asio](http://boost.org/libs/asio)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅`Boost.Asio`的官方文档，了解更多示例、教程和完整参考资料，网址为[http://boost.org/libs/asio](http://boost.org/libs/asio)
- en: Executing different tasks in parallel
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行不同的任务
- en: Now, it is time to make our `tasks_processor` process tasks in multiple threads.
    How hard can this be?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候让我们的`tasks_processor`在多个线程中处理任务了。这有多难呢？
- en: Getting started
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need to read the first recipe from this chapter. Some knowledge of
    multithreading is also required, especially reading the *Manipulating a group
    of threads* recipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要阅读本章的第一个示例。还需要一些关于多线程的知识，特别是阅读*Manipulating a group of threads*示例。
- en: Link this recipe with the `boost_system` and `boost_thread` libraries. Define
    `BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS` to bypass restrictive library checks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例与`boost_system`和`boost_thread`库链接。定义`BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS`以绕过限制性库检查。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'All we need to do is to add the `start_multiple` method to our `tasks_processor`
    class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将`start_multiple`方法添加到我们的`tasks_processor`类中：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And now, we are able to do much more work as illustrated in the following diagram:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以做更多的工作，如下图所示：
- en: '![](img/00012.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00012.jpeg)
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::asio::io_service::run` method is thread safe. All we need to do
    is just run the `boost::asio::io_service::run` method from different threads.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::io_service::run`方法是线程安全的。我们只需要从不同的线程运行`boost::asio::io_service::run`方法。'
- en: If you are executing tasks that modify a common resource, you need to add mutexes
    around that resources, or organize your application in a way, that the common
    resource is not used simultaneously by different tasks. It is safe to use resource
    from different tasks without concurrent access to the resource because `boost::asio::io_service`
    takes care of additional synchronization between tasks and forces the modification
    results of one task to be seen by another task.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在执行修改共享资源的任务，则需要在该资源周围添加互斥锁，或者以一种方式组织您的应用程序，使得共享资源不会同时被不同的任务使用。可以安全地从不同的任务中使用资源而不会并发访问资源，因为`boost::asio::io_service`负责在任务之间进行额外的同步，并强制使一个任务的修改结果被另一个任务看到。
- en: See the call to `boost::thread::hardware_concurrency()`. It returns the count
    of threads that can be run concurrently on current hardware. But, it is just a
    hint, and sometimes it may return a `0` value, which is why we are calling the
    `std::max` function for it. `std::max` ensures that `threads_count` stores at
    least the value `1`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅对`boost::thread::hardware_concurrency()`的调用。它返回可以在当前硬件上并发运行的线程数。但是，这只是一个提示，有时可能会返回`0`值，这就是为什么我们对其调用`std::max`函数。`std::max`确保`threads_count`至少存储值`1`。
- en: We wrapped `std::max` in parentheses because some popular compilers define the
    `min()` and `max()` macros, so we need additional tricks to work around this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`std::max`包装在括号中，因为一些流行的编译器定义了`min()`和`max()`宏，所以我们需要额外的技巧来解决这个问题。
- en: There's more...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::thread::hardware_concurrency()` function is a part of C++11; you
    may find it in the `<thread>` header of the `std::` namespace.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread::hardware_concurrency()`函数是C++11的一部分；您可以在`std::`命名空间的`<thread>`头文件中找到它。'
- en: All the `boost::asio` classes are not part of C++17, but they will be available
    soon as a Networking TS.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`boost::asio`类都不是C++17的一部分，但它们将很快作为网络TS提供。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the `Boost.Asio` documentation for more examples and information about different
    classes at [http://boost.org/libs/asio](http://boost.org/libs/asio)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅`Boost.Asio`文档，了解更多示例和有关不同类的信息，网址为[http://boost.org/libs/asio](http://boost.org/libs/asio)
- en: Recipes from [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, (especially the last recipe called *Manipulating a group of
    threads*) will give you information about the `Boost.Thread` usage
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd) *多线程*的配方（特别是最后一个名为*操作一组线程*的配方）将为您提供有关`Boost.Thread`用法的信息
- en: See the `Boost.Thread` documentation for information about `boost::thread_group`
    and `boost::threads` at [http://boost.org/libs/thread](http://boost.org/libs/thread)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅`Boost.Thread`文档，了解`boost::thread_group`和`boost::threads`的信息，网址为[http://boost.org/libs/thread](http://boost.org/libs/thread)
- en: Pipeline tasks processing
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道任务处理
- en: Sometimes, there is a requirement to process tasks in a specified time interval.
    Compared to previous recipes, where we were trying to process tasks in the order
    of their appearance in the queue, this is a big difference.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有一个要求在指定的时间间隔内处理任务。与以前的配方相比，在那里我们试图按照它们在队列中出现的顺序处理任务，这是一个很大的不同。
- en: Consider the example where we are writing a program that connects two subsystems,
    one of which produces data packets and the other writes modified data to the disk
    (something like this can be seen in video cameras, sound recorders, and other
    devices). We need to process data packets one by one in the specified order, smoothly
    with a small jitter, and in multiple threads.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们正在编写一个连接两个子系统的程序，其中一个子系统产生数据包，另一个子系统将修改后的数据写入磁盘（类似于视频摄像机、声音记录仪和其他设备中可以看到的情况）。我们需要按指定顺序逐个处理数据包，平稳地处理，有小的抖动，并且在多个线程中进行。
- en: 'Naive approach does not work here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 天真的方法在这里不起作用：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In a multithreaded environment, we can get *packet #1* in first thread and
    then *packet #2* in the second thread of execution. Because of different processing
    times, OS context switches and scheduling *packet #2* may be processed before
    *packet #1*. There''s no guarantee on packets, processing order. Let''s fix that!'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，我们可以在第一个线程中获取*数据包#1*，然后在第二个执行线程中获取*数据包#2*。由于不同的处理时间、操作系统上下文切换和调度，*数据包#2*可能会在*数据包#1*之前被处理。对于数据包，没有处理顺序的保证。让我们来解决这个问题！
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The *Making a work_queue* recipe from [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, is required for understanding this example. The code must be
    linked against the `boost_thread` and `boost_system` libraries.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd) *多线程*的*制作工作队列*配方中，需要理解这个例子。代码必须链接到`boost_thread`和`boost_system`库。
- en: Basic knowledge of C++11, especially of lambda functions, is required.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本的C++11知识，特别是关于lambda函数。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: This recipe is based on the code of the `work_queue` class from the *Making
    a work_queue* recipe of [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*. We'll make some modifications and will be using a few instances
    of that class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是基于[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd) *多线程*的*制作工作队列*配方中的`work_queue`类的代码。我们将进行一些修改，并将使用该类的几个实例。
- en: 'Let''s start by creating separate queues for data decoding, data compressing,
    and data sending:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先为数据解码、数据压缩和数据发送创建单独的队列：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, it is time to refactor the `process_data` and split it into multiple functions:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候重构`process_data`并将其拆分为多个函数了：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our `work_queue` class from [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, gets some interface changes for stopping and running tasks:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`work_queue`类从[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)
    *多线程*中得到了一些接口更改，用于停止和运行任务：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The implementation of `work_queue`''s `stop()` and `run()` functions must look
    like this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`work_queue`的`stop()`和`run()`函数的实现必须如下所示：'
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That is all! Now, we only need to start the pipeline:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们只需要启动管道：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The pipeline can be stopped like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以这样停止管道：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The trick is to split the processing of a single data packet into some equally
    small subtasks and process them one by one in different `work_queues`. In this
    example, we can split the data process into data decoding, data compressing, and
    data sending.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于将单个数据包的处理分成一些同样小的子任务，并在不同的`work_queues`中逐个处理它们。在这个例子中，我们可以将数据处理分成数据解码、数据压缩和数据发送。
- en: 'Processing of six packets, ideally, would look like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，六个数据包的处理将如下所示：
- en: '| **Time** | **Receiving** | **Decoding** | **Compressing** | **Sending** |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **时间** | **接收** | **解码** | **压缩** | **发送** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Tick 1: | packet #1 |  |  |  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| Tick 1: | 数据包 #1 |  |  |  |'
- en: '| Tick 2: | packet #2 | packet #1 |  |  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| Tick 2: | 数据包 #2 | 数据包 #1 |  |  |'
- en: '| Tick 3: | packet #3 | packet #2 | packet #1 |  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| Tick 3: | 数据包 #3 | 数据包 #2 | 数据包 #1 |  |'
- en: '| Tick 4: | packet #4 | packet #3 | packet #2 | packet #1 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| Tick 4: | 数据包 #4 | 数据包 #3 | 数据包 #2 | 数据包 #1 |'
- en: '| Tick 5: | packet #5 | packet #4 | packet #3 | packet #2 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Tick 5: | 数据包 #5 | 数据包 #4 | 数据包 #3 | 数据包 #2 |'
- en: '| Tick 6: | packet #6 | packet #5 | packet #4 | packet #3 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Tick 6: | 数据包 #6 | 数据包 #5 | 数据包 #4 | 数据包 #3 |'
- en: '| Tick 7: | - | packet #6 | packet #5 | packet #4 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Tick 7: | - | 数据包 #6 | 数据包 #5 | 数据包 #4 |'
- en: '| Tick 8: | - | - | packet #6 | packet #5 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| Tick 8: | - | - | 数据包 #6 | 数据包 #5 |'
- en: '| Tick 9: | - | - | - | packet #6 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| Tick 9: | - | - | - | 数据包 #6 |'
- en: However, our world is not ideal, so some tasks may finish faster than others.
    For example, receiving may work faster than decoding and, in that case, the decoding
    queue will be holding a set of tasks to be done. To avoid queue overflows, try
    hard to make each subsequent task slightly faster than the previous one.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的世界并不理想，因此有些任务可能比其他任务更快完成。例如，接收可能比解码更快，在这种情况下，解码队列将保存一组要完成的任务。为了避免队列溢出，请努力使每个后续任务略微快于前一个任务。
- en: We did not use `boost::asio::io_service` in our example, because it does not
    guarantee that posted tasks are executed in order of their postage.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们没有使用`boost::asio::io_service`，因为它不能保证发布的任务按照它们的发布顺序执行。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All the tools used to create a pipeline in this example are available in C++11,
    so nothing would stop you from creating the same things without a Boost on a C++11
    compatible compiler. However, Boost makes your code more portable and usable on
    the pre-C++11 compilers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中用来创建管线的所有工具都可以在C++11中使用，因此没有什么能阻止您在兼容C++11的编译器上创建相同的东西而不使用Boost。然而，Boost使您的代码更具可移植性，并且可以在C++11之前的编译器上使用。
- en: See also
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This technique is well known and used by processor developers. See [http://en.wikipedia.org/wiki/Instruction_pipeline](http://en.wikipedia.org/wiki/Instruction_pipeline).
    Here, you may find a brief description of all the characteristics of the pipeline.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术是处理器开发人员熟知并使用的。请参阅[http://en.wikipedia.org/wiki/Instruction_pipeline](http://en.wikipedia.org/wiki/Instruction_pipeline)。在这里，您可以找到管线的所有特征的简要描述。
- en: '*The Making a work_queue* from [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading* recipe will give you more information about methods used in this
    recipe.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*来自[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)的制作工作队列*，*多线程*配方将为您提供有关本配方中使用的方法的更多信息。'
- en: Making a nonblocking barrier
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作非阻塞屏障
- en: In multithreaded programming, there is an abstraction called **barrier**. It
    stops threads of execution that reach it until the requested number of threads
    are not blocked on it. After that, all the threads are released and they continue
    with their execution. Consider the following example of where it can be used.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程编程中，有一种称为**屏障**的抽象。它会阻止执行线程到达它，直到请求的线程数没有被阻塞在它上面。之后，所有线程都被释放，它们继续执行。考虑下面的例子，它可以使用在哪里。
- en: 'We want to process different parts of data in different threads and then send
    the data:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在不同的线程中处理数据的不同部分，然后发送数据：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `data_barrier.wait()` method blocks until all the threads fill the data.
    After that, all the threads are released. The thread with the index `0` computes
    data to be sent using `compute_send_data(data)`, while other threads are again
    waiting at the barrier as shown in the following diagram:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_barrier.wait()`方法会阻塞，直到所有线程填充数据。之后，所有线程都被释放。索引为`0`的线程使用`compute_send_data(data)`计算要发送的数据，而其他线程再次在屏障处等待，如下图所示：'
- en: '![](img/00013.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: Looks lame, doesn't it?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很糟糕，不是吗？
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: This recipe requires knowledge of the first recipe of this chapter. Knowledge
    of `Boost.Thread` is also required. Code from this recipe requires linking against
    the `boost_thread` and `boost_system` libraries.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要对本章的第一个配方有所了解。还需要了解`Boost.Thread`。这个配方的代码需要链接`boost_thread`和`boost_system`库。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We do not need to block at all! Let's take a closer look at the example. All
    we need to do is to post four `fill_data` tasks and make the last finished task
    call `compute_send_data(data)`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根本不需要阻塞！让我们仔细看看这个例子。我们所需要做的就是发布四个`fill_data`任务，并让最后完成的任务调用`compute_send_data(data)`。
- en: We'll need the `tasks_processor` class from the first recipe; no changes to
    it need to be done.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要第一篇配方中的`tasks_processor`类；不需要对其进行任何更改。
- en: 'Instead of a barrier, we''ll be using the atomic variable:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用原子变量而不是屏障：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our new runner function will look like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新运行函数将如下所示：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `main` function requires a minor change:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`函数需要进行微小的更改：'
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We do not block at all. Instead of blocking, we count the tasks that finished
    filling the data. This is done by the `counter` atomic variable. The last remaining
    task will have a `counter` variable equal to `data_t::static_size`. Only that
    task must compute and send the data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根本不会阻塞。我们不是阻塞，而是计算完成填充数据的任务。这是通过`counter`原子变量完成的。最后剩下的任务将具有等于`data_t::static_size`的`counter`变量。只有该任务必须计算并发送数据。
- en: After that, we check for the exit condition (1000 iterations are done) and post
    the new data by pushing tasks to the queue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查退出条件（完成1000次迭代），并通过将任务推送到队列来发布新数据。
- en: There's more...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Is this a better solution? Well, first of all, it scales better:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好的解决方案吗？首先，它的扩展性更好：
- en: '![](img/00014.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: This method can also be more effective for situations where a program does a
    lot of different work. Because no threads are waiting in barriers, free threads
    may execute some other tasks while one of the threads computes and sends the data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也可以更有效地处理程序执行大量不同工作的情况。因为没有线程在等待屏障，自由线程可以在一个线程计算和发送数据时执行其他任务。
- en: This recipe could be implemented in C++11 without Boost libraries. You'll only
    need to replace `io_service` inside `tasks_processor` with `work_queue` from [Chapter
    5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd), *Multithreading*. But
    as always, Boost provides better portability, and it is possible to make this
    example run on a pre-C++11, compilers using Boost libraries. You'll only need
    to replace lambda functions with `boost::bind` and `boost::ref`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方可以在没有Boost库的情况下在C++11中实现。您只需要在`tasks_processor`中用[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)的`work_queue`替换`io_service`。但是像往常一样，Boost提供了更好的可移植性，并且可以使这个示例在C++11之前的编译器上运行，使用Boost库只需要用`boost::bind`和`boost::ref`替换lambda函数。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation of `Boost.Asio` may give you more information about `io_service`
    usage at [http://boost.org/libs/asio](http://boost.org/libs/asio)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Asio`的官方文档可能会给您更多关于`io_service`使用的信息，网址为[http://boost.org/libs/asio](http://boost.org/libs/asio)。'
- en: See all the `Boost.Function` related recipes from [Chapter 2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Managing Resources*, and the official documentation at [http://boost.org/libs/function](http://boost.org/libs/function)
    for an overview of how tasks work
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[第2章](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)中与`Boost.Function`相关的所有配方，*资源管理*，以及官方文档[http://boost.org/libs/function](http://boost.org/libs/function)以了解任务的概述。
- en: See the recipes from [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, related to `Boost.Bind` for getting more
    information about what the `boost::bind` function does, or see the official documentation
    at [http://boost.org/libs/bind](http://boost.org/libs/bind)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)的相关内容，了解有关`boost::bind`的更多信息，或者查看官方文档[http://boost.org/libs/bind](http://boost.org/libs/bind)。
- en: Storing an exception and making a task from it
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储异常并从中创建任务
- en: Processing exceptions is not always trivial and may consume a lot of time. Consider
    the situation when an exception must be serialized and sent by the network. This
    may take milliseconds and a few thousands of lines of code. After the exception
    is caught, it is not always the best time and place to process it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常并不总是简单的，可能会消耗大量时间。考虑异常必须被序列化并通过网络发送的情况。这可能需要几毫秒和几千行代码。在捕获异常后，处理它的时间和地点并不总是最佳的。
- en: Can we store exceptions and delay their processing?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能存储异常并延迟它们的处理吗？
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires familiarity with `boost::asio::io_service`, which was described
    in the first recipe of this chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要熟悉`boost::asio::io_service`，这在本章的第一个配方中有描述。
- en: This recipe requires linking with the `boost_system` and `boost_thread` libraries.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要链接`boost_system`和`boost_thread`库。
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: All we need is to have an ability to store exceptions and pass them between
    threads just like a usual variable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要的就是能够存储异常并在线程之间传递它们，就像普通变量一样。
- en: 'Let''s start with the function that stores and processes exceptions:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从存储和处理异常的函数开始：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `operator()` of that functor just outputs the exception to the console:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数对象的`operator()`只是将异常输出到控制台：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s write some functions to demonstrate how exceptions work:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一些函数来演示异常的工作方式：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, if we run the example like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们像这样运行示例：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''ll get the following output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Boost.Exception` library provides an ability to store and re-throw exceptions.
    The `boost::current_exception()` method must be called only from inside of the
    `catch()` block, and it returns an object of the type `boost::exception_ptr`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Exception`库提供了存储和重新抛出异常的功能。`boost::current_exception()`方法只能在`catch()`块内部调用，并返回一个`boost::exception_ptr`类型的对象。'
- en: In the preceding example in `func_test1()`, the `boost::bad_lexical_cast` exception
    is thrown. It is returned by `boost::current_exception()`; a `process_exception`
    task is created from that exception.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在`func_test1()`的前面的示例中，抛出了`boost::bad_lexical_cast`异常。它由`boost::current_exception()`返回；从该异常创建了一个`process_exception`任务。
- en: The only way to restore the exception type from `boost::exception_ptr` is to
    re-throw it using `boost::rethrow_exception(exc)` function. That's what the `process_exception`
    function does.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 从`boost::exception_ptr`中恢复异常类型的唯一方法是使用`boost::rethrow_exception(exc)`函数重新抛出它。这就是`process_exception`函数的作用。
- en: Throwing and catching exceptions is a heavy operation. Throwing may dynamically
    allocate memory, touch cold memory, lock mutex, compute a bunch of addresses,
    and do other stuff. Do not throw exception in performance critical paths without
    very good reasons to do so!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出和捕获异常是一个繁重的操作。抛出可能会动态分配内存，触及冷内存，锁定互斥锁，计算一堆地址，以及做其他事情。在性能关键路径中不要没有非常好的理由就抛出异常！
- en: In `func_test2`, we are throwing a `std::logic_error` exception using the `BOOST_THROW_EXCEPTION`
    macro. This macro does a lot of useful work; it checks that our exception is derived
    from `std::exception`, adds information to our exception about the source filename,
    function name, and the code line number from where the exception was thrown. When
    our `std::logic_error` exception is re-thrown inside the `process_exception::operator()`
    it is caught by `catch(...)`. The `boost::current_exception_diagnostic_information()`
    outputs as much information about the thrown exception as possible.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在`func_test2`中，我们使用`BOOST_THROW_EXCEPTION`宏抛出了一个`std::logic_error`异常。这个宏做了很多有用的工作；它检查我们的异常是否派生自`std::exception`，为我们的异常添加关于源文件名、函数名和抛出异常的代码行号的信息。当我们的`std::logic_error`异常在`process_exception::operator()`内部重新抛出时，它被`catch(...)`捕获。`boost::current_exception_diagnostic_information()`尽可能多地输出关于抛出异常的信息。
- en: There's more...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Usually, `exception_ptr` is used to pass exceptions between threads. For example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`exception_ptr`用于在线程之间传递异常。例如：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `boost::exception_ptr` class may allocate memory through heap multiple times,
    uses atomics, and implements some of the operations by re-throwing and catching
    exceptions. Try not to use it without an actual need.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::exception_ptr`类可能会通过堆多次分配内存，使用原子操作，并通过重新抛出和捕获异常来实现一些操作。除非真正需要，尽量不要使用它。'
- en: C++11 has adopted `boost::current_exception`, `boost::rethrow_exception`, and
    `boost::exception_ptr`. You may find them in the `<exception>` in the `std::`
    namespace. The `BOOST_THROW_EXCEPTION` and `boost::current_exception_diagnostic_information()`
    functions are not in C++17.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: C++11已经采用了`boost::current_exception`、`boost::rethrow_exception`和`boost::exception_ptr`。您可以在`std::`命名空间的`<exception>`中找到它们。`BOOST_THROW_EXCEPTION`和`boost::current_exception_diagnostic_information()`函数不在C++17中。
- en: See also
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation of `Boost.Exception` at [http://boost.org/libs/exception](http://boost.org/libs/exception)
    contains a lot of useful information about implementation and restrictions. You
    may also find some information that is not covered in this recipe (for example,
    how to add additional information to an already thrown exception).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Exception`的官方文档在[http://boost.org/libs/exception](http://boost.org/libs/exception)中包含了关于实现和限制的大量有用信息。您还可以找到一些本配方中未涵盖的信息（例如，如何向已抛出的异常添加附加信息）。'
- en: The first recipe from this chapter gives you information about the `tasks_processor`
    class. The *Converting strings to numbers r*ecipe from [Chapter 3](part0169.html#515F20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Converting and Casting*, describes the `Boost.LexicalCast` library, that was
    used in this recipe.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的第一个配方为您提供了关于`tasks_processor`类的信息。[第3章](part0169.html#515F20-712b4ba1126a4c7c89e1d44de61b4bdd)的*将字符串转换为数字*配方描述了`Boost.LexicalCast`库，该库在本配方中使用。
- en: Getting and processing system signals as tasks
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和处理系统信号作为任务
- en: When writing some server application (especially for Linux OS), catching and
    processing the signals is required. Usually, all the signal handlers are set up
    at server start and do not change during the application's execution.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写一些服务器应用程序（特别是针对Linux操作系统）时，捕获和处理信号是必需的。通常，在服务器启动时设置所有信号处理程序，并且在应用程序执行期间不会更改。
- en: The goal of this recipe is to make our `tasks_processor` class capable of processing
    signals.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的目标是使我们的`tasks_processor`类能够处理信号。
- en: Getting ready
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need code from the first recipe of this chapter. A sound knowledge of
    `Boost.Function` is also required.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要本章的第一个配方中的代码。还需要对`Boost.Function`有扎实的了解。
- en: This recipe requires linking with the `boost_system` and `boost_thread` libraries.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要链接`boost_system`和`boost_thread`库。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This recipe is similar to the recipes from *2* to *4* of this chapter: we have
    `async` signal waiting functions, some `async` signal handlers, and some support
    code.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方类似于本章的第*2*到*4*个配方：我们有`async`信号等待函数，一些`async`信号处理程序和一些支持代码。
- en: 'Let''s start by including the following headers:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从以下头文件开始包括：
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we add a member for signals processing to the `tasks_processor` class:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为`tasks_processor`类添加一个信号处理成员：
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The function that will be called upon signal capture is as follows:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在信号捕获时将被调用的函数如下：
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And now we need a function for registering the signals handler:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数来注册信号处理程序：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'That''s all. Now, we are ready to process signals. The following is a test
    program:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在，我们准备处理信号。以下是一个测试程序：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This will give the following output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE66]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Nothing is difficult here (compared to some previous recipes from this chapter).
    The `register_signals_handler` function adds the signal numbers that will be processed.
    It is done via a call to the `boost::asio::signal_set::add` function for each
    element of the `signals_to_wait`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么困难（与本章之前的一些配方相比）。`register_signals_handler`函数添加将被处理的信号编号。通过对`signals_to_wait`的每个元素调用`boost::asio::signal_set::add`函数来完成。
- en: Next, the `sigs.async_wait` starts the `async` waiting for a signal and calls
    the `tasks_processor::handle_signals` function on the signal capture. The `tasks_processor::handle_signals`
    function immediately starts async wait for the next signal, checks for errors
    and, if there are none, it calls a callback providing a signal number.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`sigs.async_wait`开始`async`等待信号，并在信号捕获时调用`tasks_processor::handle_signals`函数。`tasks_processor::handle_signals`函数立即开始异步等待下一个信号，检查错误，如果没有错误，则调用回调函数提供信号编号。
- en: There is more...
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can do better! We can wrap the user provided callback into our class from
    the first recipe to correctly process exceptions and do other good stuff from
    the first recipe:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好！我们可以将用户提供的回调包装到第一个配方中的类中，以正确处理异常并执行第一个配方中的其他好东西：
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When a thread-safe dynamic adding and removing of signals is required, we may
    modify this example to look like `detail::timer_task` from the *Making timers
    and processing timer events as tasks* recipe of this chapter . When multiple `boost::asio::signal_set`
    objects are registered for waiting on the same signals, a handler from each of
    `signal_set` is called on a single signal.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要线程安全的动态添加和删除信号时，我们可以修改此示例，使其类似于本章的*制作定时器和处理定时器事件作为任务*食谱中的`detail::timer_task`。当多个`boost::asio::signal_set`对象注册等待相同的信号时，每个`signal_set`的处理程序都会在单个信号上被调用。
- en: C++ has been capable of processing signals for a long time using the `signal`
    function from the `<csignal>` header. Networking TS probably will not have the
    `signal_set` functionality.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: C++长期以来一直能够使用`<csignal>`头文件中的`signal`函数处理信号。网络TS可能不会具有`signal_set`功能。
- en: See also
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Storing any functional object in variable* recipe from [Chapter 2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)*,*
    *Managing Resources*, provides information about `boost::function`
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第2章](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)*管理资源*的*将任何功能对象存储在变量中*食谱提供了有关`boost::function`的信息
- en: "See the official documentation of `Boost.Asio` for more information and examples\
    \ on `boost::asio::signal_set` and other features of this great library at [http://boost.org/libs/asio\uFEFF\
    ](http://boost.org/libs/asio)"
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: "有关`boost::asio::signal_set`和此优秀库的其他功能的更多信息和示例，请参阅`Boost.Asio`的官方文档[http://boost.org/libs/asio\uFEFF\
    ](http://boost.org/libs/asio)"
