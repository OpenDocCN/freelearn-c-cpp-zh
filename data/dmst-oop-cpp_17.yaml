- en: '*Chapter 14*: Understanding STL Basics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：理解STL基础知识'
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts, by delving into a core C++ library that has become thoroughly
    integrated into the common usage of the language. We will explore the **Standard
    Template Library** (**STL**) in C++ by examining a subset of this library, representing
    common utilities that can both simplify our programming and make our code more
    easily understood by others who are undoubtedly familiar with the STL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续我们对增加您的C++编程技能库的追求，超越面向对象编程概念，深入研究已经完全融入到语言通用使用中的核心C++库。我们将通过检查该库的一个子集来探索C++中的**标准模板库**（**STL**），这个子集代表了可以简化我们的编程并使我们的代码更容易被熟悉STL的其他人理解的常用工具。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Surveying the contents and purpose of the STL in C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查C++中STL的内容和目的
- en: 'Understanding how to use essential STL containers: `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, `map`, and `map` using a functor'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用基本的STL容器：`list`、`iterator`、`vector`、`deque`、`stack`、`queue`、`priority_queue`、`map`和使用函数器的`map`
- en: Customizing STL containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义STL容器
- en: By the end of this chapter, you will be able to utilize core STL classes to
    enhance your programming skills. Because you already understand the essential
    C++ language and OOP features on which libraries are built, you will see that
    you now have the ability to navigate and understand nearly any C++ class library,
    including the STL. By gaining familiarity with the STL, you will be able to enhance
    your programming repertoire significantly and become a more savvy and valuable
    programmer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够利用核心STL类来增强您的编程技能。因为您已经了解了基本的C++语言和面向对象编程特性，您将会发现您现在有能力浏览和理解几乎任何C++类库，包括STL。通过熟悉STL，您将能够显著增强您的编程技能，并成为一个更精明和有价值的程序员。
- en: Let's increase our C++ toolkit by examining a very heavily utilized class library,
    the STL.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究一个非常广泛使用的类库STL来增加我们的C++工具包。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for the full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter14` in a file named `Chp14-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与当前章节编号相对应，后跟当前章节中的示例编号。例如，本章的第一个完整程序可以在子目录`Chapter14`中的名为`Chp14-Ex1.cpp`的文件中找到，位于上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3ch15A5](https://bit.ly/3ch15A5).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/3ch15A5](https://bit.ly/3ch15A5)。
- en: Surveying the contents and purpose of the STL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查STL的内容和目的
- en: 'The **Standard Template Library** in C++ is a library of standard classes and
    utilities that extend the C++ language. The use of the STL is so pervasive that
    it is as though the STL is a part of the language itself; it is an essential and
    integral part of C++. The STL in C++ has four key components comprising the library:
    **containers**, **iterators**, **functions**, and **algorithms**.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的**标准模板库**是一个扩展C++语言的标准类和工具库。STL的使用是如此普遍，以至于它就像是语言本身的一部分；它是C++的一个基本和不可或缺的部分。C++中的STL有四个组成部分组成库：**容器**、**迭代器**、**函数**和**算法**。
- en: The STL has additionally influenced the C++ Standard Library in providing a
    set of programming standards; the two libraries actually share common features
    and components, most notably containers and iterators. We've already utilized
    components from the Standard Library, namely `<iostream>` for iostreams, `<exception>`
    for exception handling, and `<new>` for the operators `new()` and `delete()`.
    In this chapter, we will explore many overlapping components between the STL and
    the Standard Library in C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: STL还影响了C++标准库，提供了一套编程标准；这两个库实际上共享常见特性和组件，尤其是容器和迭代器。我们已经使用了标准库的组件，即`<iostream>`用于iostreams，`<exception>`用于异常处理，以及`<new>`用于`new()`和`delete()`操作符。在本章中，我们将探索STL和C++标准库之间的许多重叠组件。
- en: 'The STL has a full line of **container** classes. These classes encapsulate
    traditional data structures to allow similar items to be collected together and
    uniformly processed. There are several categories of container classes – sequential,
    associative, and unordered. Let''s summarize these categories and provide a few
    examples of each:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: STL有一整套**容器**类。这些类封装了传统的数据结构，允许相似的项目被收集在一起并统一处理。有几类容器类 - 顺序、关联和无序。让我们总结这些类别并提供每个类别的一些示例：
- en: '`list`, `queue`, or `stack`. It is interesting to note that `queue` and `stack`
    can be thought of as a customized, or an adaptive interface for a more basic container,
    such as a `list`. Nonetheless, a `queue` and `stack` still provide sequential
    access to their elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`、`queue`或`stack`。有趣的是，`queue`和`stack`可以被看作是更基本容器的定制或自适应接口，比如`list`。尽管如此，`queue`和`stack`仍然提供对它们的元素的顺序访问。'
- en: '`set` or `map`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`或`map`。'
- en: '`unordered_set` or `unordered_map`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_set`或`unordered_map`。'
- en: In order for these container classes to be potentially used for any data type
    (and to preserve strong type checking), templates are utilized to abstract and
    genericize the data types of the collected items. In fact, we have built our own
    container classes using templates in [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*, including `LinkList` and `Array`, so we already have
    a basic understanding of templatized container classes!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些容器类能够潜在地用于任何数据类型（并保持强类型检查），模板被用来抽象和泛型化收集项目的数据类型。事实上，在[*第13章*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486)中，我们使用模板构建了自己的容器类，包括`LinkList`和`Array`，因此我们已经对模板化的容器类有了基本的了解！
- en: Additionally, the STL provides a full complement of **iterators** that allow
    us to *walk through* or traverse containers. Iterators keep track of our current
    place without corrupting the content or ordering of the respective collections
    of objects. We will see how iterators allow us to process container classes more
    safely within the STL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，STL提供了一整套**迭代器**，允许我们*遍历*容器。迭代器跟踪我们当前的位置，而不会破坏相应对象集合的内容或顺序。我们将看到迭代器如何让我们更安全地处理STL中的容器类。
- en: The STL also contains a plentiful supply of useful **algorithms**. Examples
    include sorting, counting the number of elements in a collection that may satisfy
    a condition, searching for particular elements or subsequences within elements,
    or copying elements in a variety of manners. Additional examples of algorithms
    include modifying a sequence of objects (replacing, swapping, and removing values),
    partitioning sets into ranges, or merging sets back together. Moreover, the STL
    contains many other useful algorithms and utilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: STL还包含大量有用的**算法**。例如排序、计算集合中满足条件的元素数量、搜索特定元素或子序列、以及以各种方式复制元素。算法的其他示例包括修改对象序列（替换、交换和删除值）、将集合分成范围，或将集合合并在一起。此外，STL还包含许多其他有用的算法和实用程序。
- en: Lastly, the STL includes functions. Actually, it would be more correct to say
    that the STL includes `operator()` (the function call operator), and by doing
    so, allow us to achieve parameterized flexibility through a function pointer.
    Though this is not an elementary feature of the STL we will immediately (or often)
    use, we will see one small, simple example of a functor in this chapter coupled
    with an STL container class, in the upcoming section *Examining STL map using
    a functor*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，STL包括函数。实际上，更正确的说法是STL包括`operator()`（函数调用运算符），通过这样做，允许我们通过函数指针实现参数化灵活性。虽然这不是STL的基本特性，我们将在本章中立即（或经常）使用，我们将在本章中看到一个小而简单的仿函数示例，与即将到来的章节*使用仿函数检查STL
    map*中的STL容器类配对。
- en: In this chapter, we will focus on the container class section of the STL. Though
    we won't examine every STL container class in the STL, we will review a healthy
    assortment of these classes. We will notice that some of these container classes
    are similar to classes that we have built together in previous chapters of this
    book. Incidentally, during the incremental chapter progressions of this book,
    we have also built up our C++ language and OOP skills, which are necessary to
    decode a C++ class library such as STL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于STL的容器类部分。虽然我们不会检查STL中的每个容器类，但我们将回顾一系列这些类。我们会注意到，一些这些容器类与我们在本书的前几章中一起构建的类相似。顺便说一句，在本书的渐进章节进展中，我们也建立了我们的C++语言和面向对象编程技能，这些技能对于解码STL这样的C++类库是必要的。
- en: Let's move forward to take a look at selective STL classes and test our C++
    knowledge as we interpret each class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看选择性的STL类，并在解释每个类时测试我们的C++知识。
- en: Understanding how to use essential STL containers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何使用基本的STL容器
- en: In this section, we will put our C++ skills to the test, decoding various STL
    container classes. We will see that the language features we have mastered from
    core C++ syntax to OOP skills have put us in a position to easily interpret the
    various components of STL we will now examine. Most notably, we will put our knowledge
    of templates to use! Our knowledge of encapsulation and inheritance, for example,
    will guide us to understand how to use various methods in STL classes. However,
    we will notice that virtual functions and abstract classes are extremely rare
    in the STL. The best way to gain competence with a new class within the STL will
    be to embrace the documentation detailing each class. With knowledge of C++, we
    can easily navigate through a given class to decode how to use it successfully.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将运用我们的C++技能，解码各种STL容器类。我们将看到，从核心C++语法到面向对象编程技能，我们掌握的语言特性使我们能够轻松解释我们现在将要检查的STL的各个组件。特别是，我们将运用我们对模板的了解！例如，我们对封装和继承的了解将指导我们理解如何使用STL类中的各种方法。然而，我们会注意到虚函数和抽象类在STL中非常罕见。熟练掌握STL中的新类的最佳方法是接受详细说明每个类的文档。有了C++的知识，我们可以轻松地浏览给定类，解码如何成功使用它。
- en: The container classes in the C++ STL implement various `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, and `map`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL中的容器类实现了各种`list`、`iterator`、`vector`、`deque`、`stack`、`queue`、`priority_queue`和`map`。
- en: Let's begin by examining how to utilize a very basic STL container, `list`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始检查如何利用一个非常基本的STL容器，`list`。
- en: Using STL list
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL list
- en: The STL `list` class encapsulates the data structures necessary to implement
    a linked list. We can say that `list` implements the Abstract Data Type of a linked
    list. Recall, we have made our own linked list through creating `LinkedListElement`
    and `LinkedList` classes in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Inheritance*. STL `list` allows the easy insertion,
    deletion, and sorting of elements. Direct access to individual elements (known
    as *random access*) is not supported. Rather, one must iteratively traverse past
    a prior item in the linked list until one reaches the desired item. A `list` is
    a good example of a sequential container.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: STL `list` 类封装了实现链表所需的数据结构。我们可以说 `list` 实现了链表的抽象数据类型。回想一下，在[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)中，我们通过创建
    `LinkedListElement` 和 `LinkedList` 类来制作自己的链表。STL `list` 允许轻松插入、删除和排序元素。不支持直接访问单个元素（称为*随机访问*）。相反，必须迭代地遍历链表中的先前项，直到达到所需的项。`list`
    是顺序容器的一个很好的例子。
- en: The STL `list` class has an assortment of member functions; we'll start by taking
    a look at a few popular methods in this example to get familiar with basic STL
    container class usage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: STL `list` 类有各种成员函数；我们将从这个例子中开始看一些流行的方法，以熟悉基本的 STL 容器类的用法。
- en: 'Now, let''s take a look at how we can utilize the STL `list` class. This example
    can be found, as a full working program with the necessary class definitions,
    in our GitHub as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 STL `list` 类。这个例子可以在我们的 GitHub 上找到，作为一个完整的工作程序，其中包括必要的类定义：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex1.cpp)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's examine the aforementioned program segment, where we create and utilize
    an STL `list`. First, we `#include <list>` to include the appropriate STL header
    file. Now, in `main()`, we can instantiate a list using `list<Student> studentBody;`.
    Our list will contain `Student` instances. Then we create `Student s1` on the
    stack and `Student *s2` on the heap using an allocation with `new()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查上述程序段，其中我们创建和使用了一个 STL `list`。首先，我们`#include <list>` 包含适当的 STL 头文件。现在，在
    `main()` 中，我们可以使用 `list<Student> studentBody;` 实例化一个列表。我们的列表将包含 `Student` 实例。然后我们在堆栈上创建
    `Student s1` 和使用 `new()` 进行分配在堆上创建 `Student *s2`。
- en: Next, we use `list::push_back()` to add both `s1` and `*s2` to the list. Notice
    that we are passing objects to `push_back()`. As we add `Student` instances to
    the `studentBody` list, the list will make copies of the objects internally and
    will properly clean up these objects when they are no longer members of the list.
    We need to keep in mind that if any of our instances have been allocated on the
    heap, such as `*s2`, we must delete our copy of that instance when we are done
    with it at the end of `main()`. Looking ahead to the end of `main()`, we can see
    that we appropriately `delete s2;`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `list::push_back()` 将 `s1` 和 `*s2` 添加到列表中。请注意，我们正在向 `push_back()` 传递对象。当我们向
    `studentBody` 列表添加 `Student` 实例时，列表将在内部制作对象的副本，并在这些对象不再是列表成员时正确清理这些对象。我们需要记住，如果我们的实例中有任何分配在堆上的实例，比如
    `*s2`，我们必须在 `main()` 结束时删除我们的实例的副本。展望到 `main()` 的末尾，我们可以看到我们适当地 `delete s2;`。
- en: Next, we add three more students to the list. These `Student` instances do not
    have local identifiers. These students are instantiated within the call to `push_back()`,
    for example, `studentBody.push_back(Student("Hana", "Sato", 'U', "Dr.", 3.8, "C++",
    "178PSU"));`. Here, we are instantiating an *anonymous (stack) object*, which
    will be properly popped off the stack and destructed once the call to `push_back()`
    concludes. Keep in mind, `push_back()` will also create its own local copy for
    these instances for their life expectancy within the `list`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向列表中添加三个学生。这些 `Student` 实例没有本地标识符。这些学生是在调用 `push_back()` 中实例化的，例如，`studentBody.push_back(Student("Hana",
    "Sato", 'U', "Dr.", 3.8, "C++", "178PSU"));`。在这里，我们实例化了一个*匿名（堆栈）对象*，一旦 `push_back()`
    调用结束，它将被正确地从堆栈中弹出并销毁。请记住，`push_back()` 也会为这些实例创建它们自己的本地副本，以在 `list` 中存在期间使用。
- en: Now, in a `while` loop, we repeatedly check if the list is `empty()` and if
    not, we examine the `front()` item and call our `Student::Print()` method. We
    then use `pop_front()` to remove that item from the list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在一个 `while` 循环中，我们反复检查列表是否为空，如果不是，则检查 `front()` 项并调用我们的 `Student::Print()`
    方法。然后我们使用 `pop_front()` 从列表中移除该项。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个程序的输出：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have deciphered a simple STL `list` class, let us move forward to
    understand the idea of an `iterator`, to complement a container, such as our `list`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解析了一个简单的 STL `list` 类，让我们继续了解 `iterator` 的概念，以补充容器，比如我们的 `list`。
- en: Using STL iterator
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 STL 迭代器
- en: Quite often, we will need a non-destructive way to iterate through a collection
    of objects. For example, it is important to maintain the first, last, and current
    position in a given container, especially if the set may be accessed by more than
    one method, class, or thread. Using an **iterator**, the STL provides a common
    means to traverse any container class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要一种非破坏性的方式来遍历对象集合。例如，重要的是要维护给定容器中的第一个、最后一个和当前位置，特别是如果该集合可能被多个方法、类或线程访问。使用**迭代器**，STL
    提供了一种通用的方法来遍历任何容器类。
- en: Using iterators has definite benefits. A class can create an `iterator` that
    points to the first member in a collection. Iterators can then be moved to successive
    next members of the collection. Iterators can provide access to elements pointed
    to by the `iterator`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器有明显的好处。一个类可以创建一个指向集合中第一个成员的 `iterator`。然后可以将迭代器移动到集合的连续下一个成员。迭代器可以提供对 `iterator`
    指向的元素的访问。
- en: Overall, the state information of a container can be maintained by an `iterator`.
    Iterators provide a safe means for interleaved access by abstracting the state
    information away from the container and instead into the iterator class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，容器的状态信息可以通过`iterator`来维护。迭代器通过将状态信息从容器中抽象出来，而是放入迭代器类，为交错访问提供了安全的手段。
- en: We can think of an `iterator`, you may unintentionally modify a container without
    another user's knowledge.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个`iterator`，您可能会在不知情的情况下修改容器。
- en: 'Let''s take a look at how we can utilize an STL `iterator`. This example can
    be found, as a complete program, in our GitHub as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用STL`iterator`。这个例子可以在我们的GitHub上找到，作为一个完整的程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex2.cpp)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's take a look at our previously defined code segment. Here, we include both
    the `<list>` and `<iterator>` headers from the STL. As in our previous `main()`
    function, we instantiate a `list` that can contain `Student` instances using `list<Student>
    studentbody;`. We then instantiate several `Student` instances and add them to
    the list using `push_back()`. Again, notice that several `Student` instances are
    *anonymous objects*, having no local identifier in `main()`. These instances will
    be popped off the stack when `push_back()` completes. This is no problem, as `push_back()`
    will create local copies for the list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们之前定义的代码段。在这里，我们从STL中包括了`<list>`和`<iterator>`头文件。与之前的`main()`函数一样，我们实例化了一个`list`，它可以包含`Student`实例，使用`list<Student>
    studentbody;`。然后，我们实例化了几个`Student`实例，并使用`push_back()`将它们添加到列表中。再次注意，几个`Student`实例都是*匿名对象*，在`main()`中没有本地标识符。这些实例将在`push_back()`完成时从堆栈中弹出。这没有问题，因为`push_back()`将为列表创建本地副本。
- en: Now, we can sort the list using `studentBody.sort();`. It is important to note
    that this `list` method required us to overload `operator<` to provide a means
    of comparison between two `Student` instances. Luckily, we have! We have chosen
    to implement `operator<` by comparing `gpa`, but it could also have used `studentId`
    for comparison.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`studentBody.sort();`对列表进行排序。重要的是要注意，这个`list`方法要求我们重载`operator<`，以提供两个`Student`实例之间的比较手段。幸运的是，我们已经做到了！我们选择通过比较`gpa`来实现`operator<`，但也可以使用`studentId`进行比较。
- en: Now that we have a `list`, we can create an `iterator` and establish it to refer
    to the first item of the `list`. We do so by declaring `list <Student>::iterator
    listIter = studentBody.begin();`. With the `iterator` established, we can use
    it to safely loop through the `list` from start (as it is initialized) to `end()`.
    We assign a local reference variable, `temp`, to the loop iteration's current
    first element in the list with `Student &temp = *listIter;`. We then print this
    instance using `temp.Print();`, and then we increment our iterator by one element
    using `listIter++;`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`list`，我们可以创建一个`iterator`，并将其建立为指向`list`的第一个项目。我们通过声明`list <Student>::iterator
    listIter = studentBody.begin();`来实现这一点。有了`iterator`，我们可以使用它来安全地循环遍历`list`，从开始（初始化时）到`end()`。我们将一个本地引用变量`temp`赋给列表中当前第一个元素的循环迭代，使用`Student
    &temp = *listIter;`。然后我们使用`temp.Print();`打印这个实例，然后我们通过`listIter++;`增加一个元素来增加我们的迭代器。
- en: 'Let''s take a look at the sorted output for this program (sorted by `gpa`):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下此程序的排序输出（按`gpa`排序）：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have seen an `iterator` class in action, let's investigate a variety
    of additional STL container classes, starting with a `vector`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`iterator`类的实际应用，让我们来研究一系列其他STL容器类，从`vector`开始。
- en: Using STL vector
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL`vector`
- en: The STL `vector` class implements the Abstract Data Type of a dynamic array.
    Recall, we have made our own dynamic array by creating an `Array` class in [*Chapter
    13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486), *Working with Templates*.
    The STL version, however, will be far more extensive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: STL`vector`类实现了动态数组的抽象数据类型。回想一下，我们通过在[*第13章*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486)中创建一个`Array`类来创建了自己的动态数组，*使用模板工作*。然而，STL版本将更加广泛。
- en: The `vector` (dynamic or resizable array) will expand as necessary to accommodate
    additional elements beyond its initial size. Class `vector` allows direct (that
    is, *random access*) to elements by overloading `operator[]`. A `vector` allows
    elements to be accessed in constant time through direct access. It is not necessary
    to walk past all prior elements to access an element at a specific index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`（动态或可调整大小的数组）将根据需要扩展以容纳超出其初始大小的额外元素。`vector`类允许通过重载`operator[]`直接（即*随机访问*）访问元素。`vector`允许通过直接访问在常量时间内访问元素。不需要遍历所有先前的元素来访问特定索引处的元素。'
- en: However, adding elements in the middle of a `vector` is time-consuming. That
    is, adding to anywhere other than the end of the `vector` requires all elements
    past the insertion point to be internally shuffled; it may also require an internal
    resizing of the `vector`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`vector`中间添加元素是耗时的。也就是说，在除`vector`末尾之外的任何位置添加元素都需要内部重新排列所有插入点后的元素；它还可能需要内部调整`vector`的大小。
- en: Clearly, a `list` and a `vector`, by comparison, have different strengths and
    weaknesses. Each is geared to different requirements of a collection of data.
    We can choose the one that best fits our needs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过比较，`list`和`vector`具有不同的优势和劣势。每个都适用于数据集的不同要求。我们可以选择最适合我们需求的那个。
- en: 'Let''s take a look at an assortment of common `vector` member functions. This
    is far from a complete list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下一些常见的`vector`成员函数。这远非完整列表：
- en: '![](img/Figure_14.1_B15702.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.1_B15702.jpg)'
- en: STL `vector` additionally has an overloaded `operator=` (assignment replaces
    destination vector with source vector), `operator==` (comparison of vectors, element
    by element), and `operator[]` (returns a reference to a requested location, that
    is, writable memory).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: STL `vector`还有一个重载的`operator=`（用源向目标`vector`进行赋值替换），`operator==`（逐个元素比较向量），和`operator[]`（返回所请求位置的引用，即可写内存）。
- en: 'Let''s take a look at how we can utilize the STL `vector` class with some of
    its basic operations. This example can be found, as a full working program, in
    our GitHub as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用STL `vector`类及其基本操作。这个例子可以在我们的GitHub上找到，作为一个完整的工作程序，如下所示：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex3.cpp):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previously listed code segment, we `#include <vector>` to include the
    appropriate STL header file. Now, in `main()`, we can instantiate two vectors
    using `vector<Student> studentBody1, studentBody2;`. We can then use the `vector::push_back()`
    method to add several `Student` instances in succession to our first `vector`.
    Again, notice that the `Student` instances are *anonymous objects* in `main()`.
    That is, there is no local identifier that references them – they are created
    only to be placed into our `vector`, which makes a local copy of each instance
    upon insertion. Once we have elements in our `vector`, we then loop through our
    first `vector`, printing each `Student` using `studentBody1[i].Print();`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列出的代码段中，我们`#include <vector>`来包含适当的STL头文件。现在，在`main()`中，我们可以使用`vector<Student>
    studentBody1, studentBody2;`来实例化两个向量。然后，我们可以使用`vector::push_back()`方法将几个`Student`实例连续添加到我们的第一个`vector`中。再次注意，在`main()`中，`Student`实例是*匿名对象*。也就是说，没有本地标识符引用它们
    - 它们只是被创建用于放入我们的`vector`中，每次插入时都会创建每个实例的本地副本。一旦我们的`vector`中有元素，我们就可以遍历我们的第一个`vector`，使用`studentBody1[i].Print();`打印每个`Student`。
- en: Next, we demonstrate the overloaded assignment operator for `vector` by assigning
    one `vector` to another using `studentBody1 = studentBody2;`. Here, we make a
    deep copy from right to left in the assignment. We can then test whether the two
    vectors are equal using the overloaded comparison operator within a conditional
    statement. That is, `if (studentBody1 == studentBody2)`. We then print out the
    contents of the second vector in a `for` loop using an iterator specified with
    `auto iter = studentBody2.begin();`. The `auto` keyword allows the type of the
    iterator to be determined by its initial usage. Finally, we look through our first
    `vector`, testing if it is `empty()`, and then clear an element one by one using
    `studentBody1.clear();`. We have now seen a sampling of the `vector` methods and
    their capabilities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`studentBody1 = studentBody2;`来演示`vector`的重载赋值运算符。在这里，我们在赋值中从右到左进行深度复制。然后，我们可以使用重载的比较运算符在条件语句中测试这两个向量是否相等。也就是说，`if
    (studentBody1 == studentBody2)`。然后，我们使用指定为`auto iter = studentBody2.begin();`的迭代器在`for`循环中打印出第二个向量的内容。`auto`关键字允许迭代器的类型由其初始使用确定。最后，我们遍历我们的第一个`vector`，测试它是否`empty()`，然后使用`studentBody1.clear();`逐个清除一个元素。我们现在已经看到了`vector`方法及其功能的一部分。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, let's investigate the STL `deque` class to further our knowledge of STL
    containers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们研究STL `deque`类，以进一步了解STL容器。
- en: Using STL deque
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL deque
- en: The STL `deque` class (pronounced *deck*) implements the Abstract Data Type
    of a double-ended queue. This ADT extends the notion that a queue is first in,
    first out. Instead, the `deque` allows greater flexibility. Adding elements at
    either end of the `deque` is quick. Adding elements in the middle of the `deque`
    is time-consuming. A `deque` is a sequential container, though more flexible than
    our `list`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: STL `deque`类（发音为*deck*）实现了双端队列的抽象数据类型。这个ADT扩展了队列先进先出的概念。相反，`deque`允许更大的灵活性。在`deque`的两端快速添加元素。在`deque`的中间添加元素是耗时的。`deque`是一个顺序容器，尽管比我们的`list`更灵活。
- en: You might imagine that a `deque` is a specialization of a `queue`; it is not.
    Instead, the flexible `deque` class will serve as a basis to implement other container
    classes, which we will see shortly. In these cases, private inheritance will allow
    us to conceal `deque` as an underlying implementation (with vast functionality)
    for more restrictive, specialized classes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象`deque`是`queue`的一个特例；它不是。相反，灵活的`deque`类将作为实现其他容器类的基础，我们很快就会看到。在这些情况下，私有继承将允许我们将`deque`隐藏为更严格的专门类的底层实现（具有广泛的功能）。
- en: 'Let''s take a look at an assortment of common `deque` member functions. This
    is far from a complete list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些常见的`deque`成员函数。这远非完整列表：
- en: '![](img/Figure_14.2_B15702.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.2_B15702.jpg)'
- en: STL `deque` additionally has an overloaded `operator=` (assignment of the source
    to destination deque) and `operator[]` (returns a reference to requested location
    – writable memory).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: STL `deque`还有一个重载的`operator=`（将源分配给目标deque）和`operator[]`（返回所请求位置的引用 - 可写内存）。
- en: 'Let''s take a look at how we can utilize the STL `deque` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用STL `deque`类。这个例子可以在我们的GitHub上找到，作为一个完整的工作程序，如下所示：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex4.cpp)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previously listed code segment, we `#include <deque>` to include the
    appropriate STL header file. Now, in `main()`, we can instantiate a `deque` to
    contain `Student` instances using `deque<Student> studentBody;`. We then call
    either `deque::push_back()` or `deque::push_front()` to add several `Student`
    instances (some anonymous objects) to our `deque`. We are getting the hang of
    this! Now, we insert a `Student` past the front of our deck using `studentBody.insert(studentBody.begin()
    + 1, Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++", "299CU"));`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列出的代码段中，我们`#include <deque>`来包含适当的STL头文件。现在，在`main()`中，我们可以实例化一个`deque`来包含`Student`实例，使用`deque<Student>
    studentBody;`。然后，我们调用`deque::push_back()`或`deque::push_front()`来向我们的`deque`中添加几个`Student`实例（一些匿名对象）。我们已经掌握了这个！现在，我们使用`studentBody.insert(studentBody.begin()
    + 1, Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++", "299CU"));`在我们的甲板前面插入一个`Student`。
- en: Next, we take advantage of the overloaded `operator[]` to insert a `Student`
    into our `deque` using `studentBody[0] = s1;`. Please be warned that `operator[]`
    does not do any bounds checking on our `deque`! In this statement, we insert `Student`
    `s1` into the ![](img/B15702_14_002.png) position in the `deque`, instead of the
    `Student` that once occupied that position. A safer bet is to use the `deque::at()`
    method, which will incorporate bounds checking. Regarding the aforementioned assignment,
    we also want to ensure that `operator=` has been overloaded for both `Person`
    and `Student`, as each class has dynamically allocated data members.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们利用重载的`operator[]`将一个`Student`插入我们的`deque`，使用`studentBody[0] = s1;`。请注意，`operator[]`不会对我们的`deque`进行任何边界检查！在这个语句中，我们将`Student`
    `s1`插入到`deque`的![](img/B15702_14_002.png)位置，而不是曾经占据该位置的`Student`。更安全的方法是使用`deque::at()`方法，它将包含边界检查。关于前述的赋值，我们还要确保`operator=`已经被重载为`Person`和`Student`，因为每个类都有动态分配的数据成员。
- en: Now, we loop through until our `deque` is `empty()`, extracting and printing
    the front `element` of the deque using `studentBody.front().Print();`. With each
    iteration we also pop the front item from our `deque` using `studentBody.pop_front();`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们循环直到我们的`deque`为空，使用`studentBody.front().Print();`提取并打印deque的前一个元素。每次迭代，我们还使用`studentBody.pop_front();`从我们的`deque`中弹出前一个项目。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a feel for a `deque`, let's next investigate the STL `stack`
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`deque`有了一些了解，接下来让我们调查STL `stack`类。
- en: Using STL stack
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL stack
- en: The STL `stack` class implements the Abstract Data Type of a stack. The stack
    ADT supports the `stack` includes a public interface that does not advertise its
    underlying implementation. After all, a `stack` might change its implementation;
    the ADT's usage should not depend in any manner on its underlying implementation.
    The STL `stack` is considered an adaptive interface of a basic sequential container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: STL `stack`类实现了堆栈的抽象数据类型。堆栈ADT支持`stack`包括一个不公开其底层实现的公共接口。毕竟，`stack`可能会改变其实现；ADT的使用不应以任何方式依赖其底层实现。STL
    `stack`被认为是基本顺序容器的自适应接口。
- en: Recall, we have made our own `Stack` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Inheritance*, using a private base class of `LinkedList`.
    The STL version will be more extensive; interestingly, it is implemented using
    `deque` as its underlying private base class. With `deque` as a private base class
    of the STL `stack`, the more versatile underlying capabilities of `deque` are
    hidden; only the applicable methods are used to implement the stack's public interface.
    Also, because the means of implementation is hidden, a `stack` may be implemented
    using another container class at a later date without impacting its usage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)中制作了我们自己的`Stack`类，*使用继承实现层次结构*，使用了`LinkedList`作为私有基类。STL版本将更加广泛；有趣的是，它是使用`deque`作为其底层私有基类来实现的。`deque`作为STL
    `stack`的私有基类，隐藏了`deque`更多的通用功能；只有适用的方法被用来实现堆栈的公共接口。此外，因为实现的方式被隐藏了，一个`stack`可以在以后使用另一个容器类来实现，而不会影响其使用。
- en: 'Let''s take a look at an assortment of common `stack` member functions. This
    is far from a complete list. It is important to note that the public interface
    for `stack` is far smaller than that of its private base class, `deque`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一系列常见的`stack`成员函数。这远非完整列表。重要的是要注意，`stack`的公共接口远比其私有基类`deque`要小：
- en: '![](img/Figure_14.5_B15702.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.5_B15702.jpg)'
- en: STL `stack` additionally has an overloaded `operator=` (assignment of the source
    to destination stack), `operator==` and `operator!=` (equality/inequality of two
    stacks), and `operator<` , `operator>`, `operator<=`, and `operator >=` (comparison
    of stacks).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: STL `stack`还有一个重载的`operator=`（将源分配给目标堆栈），`operator==`和`operator!=`（两个堆栈的相等/不相等），以及`operator<`，`operator>`，`operator<=`和`operator
    >=`（堆栈的比较）。
- en: 'Let''s take a look at how we can utilize the STL `stack` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用STL `stack`类。这个例子可以在我们的GitHub上找到，作为一个完整的工作程序，如下所示：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex5.cpp)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex5.cpp)'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the aforementioned code segment, we `#include <stack>` to include the appropriate
    STL header file. Now, in `main()`, we can instantiate a `stack` to contain `Student`
    instances using `stack<Student> studentBody;`. We then call `stack::push()` to
    add several `Student` instances to our `stack`. Notice that we are using the traditional
    `push()` method, which contributes to the ADT of a stack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列出的代码段中，我们`#include <stack>`来包含适当的STL头文件。现在，在`main()`中，我们可以实例化一个`stack`来包含`Student`实例，使用`stack<Student>
    studentBody;`。然后，我们调用`stack::push()`来向我们的`stack`中添加几个`Student`实例。请注意，我们使用传统的`push()`方法，这有助于堆栈的ADT。
- en: We then loop through our `stack` while it is not `empty()`. Our goal is to access
    and print the top element using `studentBody.top().Print();`. We then neatly pop
    our top element off the stack using `studentBody.pop();`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历我们的`stack`，直到它不是`empty()`为止。我们的目标是使用`studentBody.top().Print();`来访问并打印顶部的元素。然后我们使用`studentBody.pop();`来整洁地从栈中弹出我们的顶部元素。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, let's investigate the STL `queue` class to further increase our STL container
    repertoire.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们研究STL `queue`类，以进一步增加我们的STL容器知识。
- en: Using STL queue
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL queue
- en: The STL `queue` class implements the ADT of a queue. As the stereotypical queue
    class, STL's `queue` supports **FIFO** (**first in, first out**) order of insertion
    and removal of members.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: STL `queue`类实现了队列的ADT。作为典型的队列类，STL的`queue`支持**FIFO**（先进先出）的插入和删除成员的顺序。
- en: Recall, we made our own `Queue` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)*,
    Implementing Hierarchies with Inheritance*; we derived our `Queue` from our `LinkedList`
    class using private inheritance. The STL version will be more extensive; STL `queue`
    is implemented using `deque` as its underlying implementation (also using private
    inheritance). Remember, because the means of implementation are hidden with private
    inheritance, a `queue` may be implemented using another data type at a later date
    without impacting its public interface. An STL `queue` is another example of an
    adaptive interface for a basic sequential container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)*，使用继承实现层次结构*中，我们制作了自己的`Queue`类；我们使用私有继承从我们的`LinkedList`类派生了我们的`Queue`。STL版本将更加广泛；STL
    `queue`是使用`deque`作为其底层实现的（同样使用私有继承）。请记住，因为使用私有继承隐藏了实现手段，所以`queue`可以在以后使用另一种数据类型来实现，而不会影响其公共接口。STL
    `queue`是基本顺序容器的另一个自适应接口的例子。
- en: 'Let''s take a look at an assortment of common `queue` member functions. This
    is far from a complete list. It is important to note that the public interface
    of `queue` is far smaller than that of its private base class, `deque`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一系列常见的`queue`成员函数。这远非完整列表。重要的是要注意，`queue`的公共接口远比其私有基类`deque`的接口小得多：
- en: '![](img/Figure_14.6_B15702.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.6_B15702.jpg)'
- en: STL `queue` additionally has an overloaded `operator=` (assignment of the source
    to destination queue), `operator==` and `operator!=` (equality/inequality of two
    queues), and `operator<` , `operator>`, `operator<=`, and `operator >=` (comparison
    of queues).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: STL `queue`还有一个重载的`operator=`（将源队列分配给目标队列），`operator==`和`operator!=`（两个队列的相等/不相等），以及`operator<`，`operator>`，`operator<=`和`operator
    >=`（队列的比较）。
- en: 'Let''s take a look at how we can utilize the STL `queue` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用STL `queue`类。这个例子可以在我们的GitHub上找到，作为一个完整的工作程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex6.cpp)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex6.cpp)'
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code segment, we first `#include <queue>` to include the appropriate
    STL header file. Now, in `main()`, we can instantiate a `queue` to contain `Student`
    instances using `queue<Student> studentBody;`. We then call `queue::push()` to
    add several `Student` instances to our `queue`. Recall, with the queue ADT, `push()`
    implies that we are adding an element at the end of the queue; some programmers
    prefer the term *enqueue* to describe this operation; however, the STL has selected
    to name this operation `push()`. With the queue ADT, `pop()` will remove an item
    from the front of the queue. A better term is *dequeue*; however, that is not
    what STL has chosen. We can adapt.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码段中，我们首先`#include <queue>`来包含适当的STL头文件。现在，在`main()`中，我们可以实例化一个`queue`来包含`Student`实例，使用`queue<Student>
    studentBody;`。然后我们调用`queue::push()`来向我们的`queue`中添加几个`Student`实例。回想一下，使用队列ADT，`push()`意味着我们在队列的末尾添加一个元素；一些程序员更喜欢使用术语*enqueue*来描述这个操作；然而，STL选择了将这个操作命名为`push()`。使用队列ADT，`pop()`将从队列的前面移除一个项目。一个更好的术语是*dequeue*；然而，这不是STL选择的。我们可以适应。
- en: We then loop through our `queue` while it is not `empty()`. Our goal is to access
    and print the front element using `studentBody.front().Print();`. We then neatly
    pop our front element off the `queue` using `studentBody.pop();`. Our work is
    complete.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历我们的`queue`，直到它不是`empty()`为止。我们的目标是使用`studentBody.front().Print();`来访问并打印前面的元素。然后我们使用`studentBody.pop();`来整洁地从`queue`中弹出我们的前面的元素。我们的工作完成了。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have tried a `queue`, let's investigate the STL `priority_queue`
    class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试了`queue`，让我们来研究一下STL `priority_queue`类。
- en: Using STL priority queue
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL优先队列
- en: The STL `priority_queue` class implements the Abstract Data Type of a priority
    queue. The priority queue ADT supports a modified FIFO order of insertion and
    removal of members, such that elements are *weighted*. The front element is of
    the largest value (determined by the overloaded `operator<`) and the rest of the
    elements follow in sequence from the next greatest to the least. STL `priority_queue`
    is considered an adaptive interface for a sequential container.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: STL `priority_queue`类实现了优先队列的抽象数据类型。优先队列ADT支持修改后的FIFO插入和删除成员的顺序，使得元素被*加权*。前面的元素具有最大值（由重载的`operator<`确定），其余元素按顺序从次大到最小。STL
    `priority_queue`被认为是顺序容器的自适应接口。
- en: 'Recall, we implemented our own `PriorityQueue` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Inheritance*. We used public inheritance to allow
    our `PriorityQueue` to specialize our `Queue` class, adding additional methods
    to support the priority (weighted) enqueuing scheme. The underlying implementation
    of `Queue` (with the private base class `LinkedList`) was hidden. By using public
    inheritance, we allowed our `PriorityQueue` to be able to be generalized as a
    `Queue` through upcasting (which we understood once we learned about polymorphism
    and virtual functions in [*Chapter 7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298),
    *Utilizing Dynamic Binding through Polymorphism*). We made an acceptable design
    choice: *PriorityQueue Is-A* (specialization of) *Queue* and at times may be treated
    in its more general form. We also recall that neither a `Queue` nor a `PriorityQueue`
    could be upcast to their underlying implementation of a `LinkedList`, as `Queue`
    was derived privately from `LinkedList`; we cannot upcast past a non-public inheritance
    boundary.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在[*第6章*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)中实现了我们自己的`PriorityQueue`类，*使用继承实现层次结构*。我们使用公共继承来允许我们的`PriorityQueue`专门化我们的`Queue`类，添加额外的方法来支持优先级（加权）入队方案。`Queue`的底层实现（使用私有基类`LinkedList`）是隐藏的。通过使用公共继承，我们允许我们的`PriorityQueue`能够通过向上转型被泛化为`Queue`（这是我们在[*第7章*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298)中学习多态性和虚函数后理解的）。我们做出了一个可以接受的设计选择：*PriorityQueue
    Is-A*（专门化为）*Queue*，有时可以以更一般的形式对待。我们还记得，`Queue`和`PriorityQueue`都不能向上转型为它们的底层实现`LinkedList`，因为`Queue`是从`LinkedList`私有继承的；我们不能越过非公共继承边界向上转型。
- en: Contrastingly, the STL version of `priority_queue` is implemented using the
    STL `vector` as its underlying implementation. Recall, because the means of implementation
    is hidden, a `priority_queue` may be implemented using another data type at a
    later date without impacting its public interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，STL版本的`priority_queue`是使用STL `vector`作为其底层实现。请记住，由于实现方式是隐藏的，`priority_queue`可能会在以后使用另一种数据类型进行实现，而不会影响其公共接口。
- en: The STL `priority_queue` allows inspection, but not a modification, of the top
    element. The STL `priority_queue` does not allow insertion through its elements.
    That is, elements may only be added resulting in an order from greatest to least.
    Accordingly, the top element may be inspected, and the top element may be removed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: STL `priority_queue`允许检查，但不允许修改顶部元素。STL `priority_queue`不允许通过其元素进行插入。也就是说，元素只能按从大到小的顺序添加。因此，可以检查顶部元素，并且可以删除顶部元素。
- en: 'Let''s take a look at an assortment of common `priority_queue` member functions.
    This is not a complete list. It is important to note that the public interface
    of `priority_queue` is far smaller than that of its private base class, `vector`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下一系列常见的`priority_queue`成员函数。这不是一个完整的列表。重要的是要注意，`priority_queue`的公共接口要比其私有基类`vector`要小得多：
- en: '![](img/Figure_14.7_B15702.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.7_B15702.jpg)'
- en: Unlike the previously examined container classes, the STL `priority_queue` does
    not overload operators, including `operator=`, `operator==`, and `operator<`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前检查过的容器类不同，STL `priority_queue`不重载运算符，包括`operator=`, `operator==`, 和 `operator<`。
- en: The most interesting method of `priority_queue` is that of `void emplace(args);`.
    This is the member function that allows the priority enqueuing mechanism to add
    items to this ADT. We also notice that `top()` must be used to return the top
    element (versus `front()`, which a `queue` utilizes). But then again, an STL `priority_queue`
    is not implemented using a `queue`). To utilize `priority_queue`, we `#include
    <queue>`, just as we would for a `queue`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`priority_queue`最有趣的方法是`void emplace(args);`。这是允许优先级入队机制向该ADT添加项目的成员函数。我们还注意到`top()`必须用于返回顶部元素（与`queue`使用的`front()`相反）。但再说一遍，STL
    `priority_queue`并不是使用`queue`实现的）。要使用`priority_queue`，我们需要`#include <queue>`，就像我们为`queue`一样。'
- en: Because the usage of `priority_queue` is so similar to `queue`, we will instead
    explore it further, programming-wise, in our question set at the end of this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`priority_queue`的使用方式与`queue`非常相似，因此我们将在本章末尾的问题集中进一步探讨它的编程方式。
- en: Now that we have seen many examples of sequential container types in STL (including
    adaptive interfaces), let's next investigate the STL `map` class, an associative
    container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了STL中许多顺序容器类型的示例（包括自适应接口），让我们接下来研究STL `map`类，这是一个关联容器。
- en: Examining STL map
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查STL map
- en: The STL `map` class implements the Abstract Data Type of a hash table. The class
    `map` allows elements in the hash table or map to be stored and retrieved quickly
    using a `multimap` can be used instead should there be more than one piece of
    data that needs to be associated with a single key.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: STL `map`类实现了哈希表的抽象数据类型。`map`类允许快速存储和检索哈希表或映射中的元素，如果需要将多个数据与单个键关联起来，则可以使用`multimap`。
- en: Hash tables (maps) are fast for the storage and lookup of data. The performance
    is a guaranteed *O(log(n))*. The STL `map` is considered an associative container,
    as it associates a key to a value to quickly retrieve a value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表（映射）对于数据的存储和查找非常快。性能保证为*O(log(n))*。STL `map`被认为是一个关联容器，因为它将一个键与一个值关联起来，以快速检索值。
- en: 'Let''s take a look at an assortment of common `map` member functions. This
    is not a complete list:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下一系列常见的`map`成员函数。这不是一个完整的列表：
- en: '![](img/Figure_14.8_B15702.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.8_B15702.jpg)'
- en: STL `map` additionally has the overloaded operator `operator==` (comparison
    of maps, element by element), implemented as a global function. STL `map` also
    has overloaded `operator[]` (returns a reference to the map element associated
    with the key that is used as an index; this is writable memory).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: STL `map`还有重载的运算符`operator==`（逐个元素比较映射），实现为全局函数。STL `map`还有重载的`operator[]`（返回与用作索引的键关联的映射元素的引用；这是可写内存）。
- en: 'Let''s take a look at how we can utilize the STL `map` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用STL `map`类。这个例子可以在我们的GitHub上找到，作为一个完整的工作程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex7.cpp)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex7.cpp)'
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's examine the preceding code segment. Again, we include the applicable header
    file with `#include <map>`. Next, we instantiate four `Student` instances. We
    will be making a hash table (`map`) of `Student` instances to be indexed by a
    key (which is their `studentId`). Next, we declare a `map` to hold the collection
    of `Student` instances with `map<const char *, Student> studentBody;`. Here, we
    indicate that the association between the key and element will be between a `const
    char *` and a `Student`. We then declare a map iterator with `map<const char *,
    Student>::iterator mapIter;`, using the same data types.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码段。同样，我们使用`#include <map>`包含适用的头文件。接下来，我们实例化四个`Student`实例。我们将制作一个哈希表（`map`），其中`Student`实例将由键（即它们的`studentId`）索引。接下来，我们声明一个`map`来保存`Student`实例的集合，使用`map<const
    char*，Student> studentBody;`。在这里，我们指示键和元素之间的关联将在`const char*`和`Student`之间进行。然后，我们使用`map<const
    char*，Student>::iterator mapIter;`声明映射迭代器，使用相同的数据类型。
- en: Now, we create three `pair` instances to associate a grouping between each `Student`
    and its key (that is, with their respective `studentId`) using the declaration
    `pair<const char *, Student> studentPair1 (s1.GetStudentId(), s1);`. This may
    seem confusing to read, but let's break this declaration down into its components.
    Here, the instance's data type is `pair<const char *, Student>`, the variable
    name is `studentPair1`, and `(s1.GetStudentId(), s1)` is the arguments passed
    to the specific `pair` instance's constructor.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建三个`pair`实例，将每个`Student`与其键（即其相应的`studentId`）关联起来，使用声明`pair<const char*，Student>
    studentPair1(s1.GetStudentId(), s1);`。这可能看起来令人困惑，但让我们将这个声明分解成其组成部分。在这里，实例的数据类型是`pair<const
    char*，Student>`，变量名是`studentPair1`，`(s1.GetStudentId(), s1)`是传递给特定`pair`实例构造函数的参数。
- en: 'Now, we simply insert the three `pair` instances into the `map`. An example
    of this insertion is `studentBody.insert(studentPair1);`. We then insert a fourth
    `Student`, `s4`, into the `map` using `map`''s overloaded `operator[]` with the
    following statement: `studentBody[s4.GetStudentId()] = s4;`. Notice that the `studentId`
    is used as the index value in `operator[]`; this value will become the key value
    for the `Student` in the hash table.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将三个`pair`实例插入`map`中。一个示例是`studentBody.insert(studentPair1);`。然后，我们使用以下语句将第四个`Student`，`s4`，插入`map`中：`studentBody[s4.GetStudentId()]
    = s4;`。请注意，在`operator[]`中使用`studentId`作为索引值；这个值将成为哈希表中`Student`的键值。
- en: Finally, we establish the map iterator to the beginning of the `map` and then
    process the `map` while it is not at the `end()`. Within the loop, we set a variable,
    `temp`, to the `pair` at the front of the map, indicated by the map iterator.
    We also set `tempS` as a temporary reference to a `Student` in the `map`, which
    is indicated by `temp.second` (the second value in the current `pair` managed
    by the map iterator). We now can print out each `Student` instance's `studentId`
    (the key) using `temp.first` (the first item in the current `pair`). In the same
    statement, we can then print out each `Student` instance's `firstName` using `temp.second.GetFirstName()`
    (since the `Student` corresponding to the key is the second item in the current
    `pair`). Similarly, we could also use `tempS.GetLastName()` to print a student's
    `lastName`, as `tempS` was previously initialized to the second element in the
    current `pair` at the beginning of each loop iteration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将映射迭代器建立到`map`的开头，然后在`end()`之前处理`map`。在循环中，我们将一个变量`temp`设置为映射迭代器指示的`pair`的前端。我们还将`tempS`设置为`map`中的`Student`的临时引用，由`temp.second`（映射迭代器管理的当前`pair`中的第二个值）指示。现在，我们可以使用`temp.first`（当前`pair`中的第一个项目）打印出每个`Student`实例的`studentId`（键）。在同一语句中，我们可以使用`temp.second.GetFirstName()`打印出每个`Student`实例的`firstName`（因为与键对应的`Student`是当前`pair`中的第二个项目）。类似地，我们还可以使用`tempS.GetLastName()`打印出学生的`lastName`，因为`tempS`在每次循环迭代开始时被初始化为当前`pair`中的第二个元素。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let's take a look at an alternative with an STL `map`, which will introduce
    us to the STL `functor` concept.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看使用STL `map`的另一种方法，这将向我们介绍STL `functor`的概念。
- en: Examining STL map using a functor
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数对象检查STL映射
- en: The STL `map` class has great flexibility, like many STL classes. In our past
    `map` example, we assumed that a means for comparison was present in our `Student`
    class. We had, after all, overloaded `operator<` for two `Student` instances.
    What happens, however, if we cannot revise a class that has not provided this
    overloaded operator and we also choose not to overload `operator<` as an external
    function?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: STL `map`类具有很大的灵活性，就像许多STL类一样。在我们过去的`map`示例中，我们假设我们的`Student`类中存在比较的方法。毕竟，我们为两个`Student`实例重载了`operator<`。然而，如果我们无法修改未提供此重载运算符的类，并且我们选择不重载`operator<`作为外部函数，会发生什么呢？
- en: Fortunately, we may specify a third data type for the template type expansion
    when instantiating a `map` or map iterator. This additional data type will be
    a specific type of class, known as a functor. A `operator()`. It is within the
    overloaded `operator()` that we will provide a means of comparison for the objects
    in question. A functor essentially simulates encapsulating a function pointer
    by overloading `operator()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当实例化`map`或映射迭代器时，我们可以为模板类型扩展指定第三种数据类型。这个额外的数据类型将是一种特定类型的类，称为函数对象。一个`operator()`。在重载的`operator()`中，我们将为问题中的对象提供比较的方法。函数对象本质上是通过重载`operator()`来模拟封装函数指针。
- en: 'Let''s take a look at how we might revise our `map` example to utilize a simple
    functor. This example can be found, as a full working program, in our GitHub as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何修改我们的`map`示例以利用一个简单的函数对象。这个例子可以在我们的GitHub上找到，作为一个完整的工作程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex8.cpp)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex8.cpp)'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previously mentioned code fragment, we first introduce a user defined
    type of `comparison`. This can be a `class` or a `struct`. Within this structure
    definition, we have overloaded the function call operator (`operator()`) and provided
    a means of comparison between two `const char *` keys for `Student` instances.
    This comparison will allow `Student` instances to be inserted in an order determined
    by the comparison functor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的代码片段中，我们首先介绍了一个名为`comparison`的用户定义类型。这可以是一个`class`或一个`struct`。在这个结构的定义中，我们重载了函数调用运算符(`operator()`)，并提供了两个`const
    char *`键的`Student`实例之间的比较方法。这个比较将允许`Student`实例按照比较函数对象确定的顺序插入。
- en: Now, when we instantiate our `map` and map iterators, we specify as the third
    parameter for the template type expansion our `comparison` type (the functor).
    And neatly embedded within this type is the overloaded function call operator,
    `operator()`, which will provide our needed comparison. The remaining code will
    be similar to our original map program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们实例化我们的`map`和map迭代器时，我们在模板类型扩展的第三个参数中指定了我们的`comparison`类型（函数对象）。并且在这个类型中嵌入了重载的函数调用运算符`operator()`，它将提供我们所需的比较。其余的代码将类似于我们原来的map程序。
- en: Certainly, functors may be used in additional, more advanced ways beyond what
    we have seen here with the container class `map`. Nonetheless, you now have a
    flavor for how a functor can apply to the STL.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数对象可能会以额外的、更高级的方式被使用，超出了我们在这里使用`map`容器类所见到的。尽管如此，你现在已经对函数对象如何应用于STL有了一定的了解。
- en: Now that we have seen how to utilize a variety of STL container classes, let's
    consider why we may want to customize an STL class, and how to do so.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何利用各种STL容器类，让我们考虑为什么我们可能想要定制一个STL类，以及如何做到这一点。
- en: Customizing STL containers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制STL容器
- en: Most classes in C++ can be customized in some fashion, including classes in
    the STL. However, we must be aware of design decisions made within the STL that
    will limit how we may customize these components. Because the STL container classes
    purposely do not include virtual destructors or other virtual functions, we should
    not use specialization via public inheritance to extend these classes. Note that
    C++ will not stop us, but we know from [*Chapter 7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298),
    *Using Dynamic Binding through Polymorphism*, that we should never override non-virtual
    functions. STL's choice to not include virtual destructors and other virtual functions
    to allow further specialization of these classes was a solid design choice made
    long ago when STL containers were crafted.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的大多数类都可以以某种方式进行定制，包括STL中的类。然而，我们必须注意STL中的设计决策将限制我们如何定制这些组件。因为STL容器类故意不包括虚析构函数或其他虚函数，我们不应该使用公共继承来扩展这些类。请注意，C++不会阻止我们，但我们知道从[*第7章*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298)，*通过多态使用动态绑定*，我们永远不应该覆盖非虚函数。STL选择不包括虚析构函数和其他虚函数，以允许进一步专门化这些类，这是在STL容器被创建时做出的一个坚实的设计选择。
- en: We could, however, use private or protected inheritance, or the concepts of
    containment or association, to use an STL container class as a building block,
    that is, to hide the underlying implementation of a new class, where the STL provides
    a solid, yet hidden, implementation for the new class. We would simply provide
    our own public interface for the new class and under the hood, delegate the work
    to our underlying implementation (whether that be a private or protected base
    class, or to a contained or associated object).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用私有或受保护的继承，或者包含或关联的概念，将STL容器类用作构建块，也就是说，隐藏新类的底层实现，STL为新类提供了一个坚实但隐藏的实现。我们只需为新类提供我们自己的公共接口，在幕后，将工作委托给我们的底层实现（无论是私有或受保护的基类，还是包含或关联的对象）。
- en: Extreme care and caution must be taken when extending any template class, including
    those in the STL using private or protected base classes. This caution will also
    apply to containing or associating to other template classes. Template classes
    are generally not compiled (or syntax checked) until an instance of the template
    class with a specific type is created. This means that any derived or wrapper
    classes that are created can only be fully tested when instances of specific types
    are created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展任何模板类时，包括使用私有或受保护基类的STL中的模板类，必须非常小心谨慎。这种小心谨慎也适用于包含或关联其他模板类。模板类通常不会被编译（或语法检查）直到创建具有特定类型的模板类的实例。这意味着只有当创建特定类型的实例时，任何派生或包装类才能被充分测试。
- en: Appropriate overloaded operators will need to be put in place for new classes
    so that these operators will work automatically with customized types. Keep in
    mind that some operator functions, such as `operator=`, are not inherited from
    base to derived class and need to be written with each new class. This is appropriate
    since derived classes will likely have more work to accomplish than found in the
    generalized versions of `operator=`. Remember, if you cannot modify the class
    definition of a class requiring a selected overloaded operator, you must implement
    that operator function as an external function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 新类需要适当的重载运算符，以便这些运算符能够自动地与定制类型一起工作。请记住，一些运算符函数，比如`operator=`，并不是从基类继承到派生类的，需要在每个新类中编写。这是合适的，因为派生类可能需要完成的工作比`operator=`的通用版本中找到的更多。请记住，如果您无法修改需要选定重载运算符的类的类定义，您必须将该运算符函数实现为外部函数。
- en: In addition to customizing containers, we may also choose to augment an algorithm
    based on an existing algorithm within the STL. In this case, we would use one
    of the many STL functions as part of a new algorithm's underlying implementation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定制容器，我们还可以选择根据STL中现有的算法来增强算法。在这种情况下，我们将使用STL的许多函数之一作为新算法的基础实现的一部分。
- en: Customizing classes from existing libraries comes up routinely in programming.
    For example, consider how we extended the Standard Library `exception` class to
    create customized exceptions in [*Chapter 11*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417),
    *Handling Exceptions* (though that scenario utilized public inheritance, which
    will not apply to customizing STL classes). Keep in mind that the STL offers a
    very full complement of container classes. Rarely will you find the need to augment
    STL classes – perhaps only with a very domain-specific class need. Nonetheless,
    you now know the caveats involved in customizing STL classes. Remember, care and
    caution must always be used when augmenting a class. We can now see the need to
    employ proper OO component testing for any classes we create.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中经常需要定制来自现有库的类。例如，考虑我们如何扩展标准库`exception`类以创建自定义异常[*第11章*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417)中的情况，*处理异常*（尽管该场景使用了公共继承，这不适用于定制STL类）。请记住，STL提供了非常丰富的容器类。您很少会发现需要增强STL类的情况
    - 或许只有在非常特定领域的类需求中。尽管如此，您现在知道了定制STL类所涉及的注意事项。请记住，在增强类时必须始终谨慎小心。我们现在看到了需要为我们创建的任何类使用适当的OO组件测试的必要性。
- en: We have now considered how to potentially customize STL container classes and
    algorithms within our programs. We have also seen quite a few STL container class
    examples in action. Let us now briefly recap these concepts before moving forward
    to our next chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在考虑如何在我们的程序中可能定制STL容器类和算法。我们也看到了一些STL容器类的实际示例。在继续下一章之前，让我们简要回顾一下这些概念。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have furthered our C++ knowledge beyond OOP language features
    to gain familiarity with the C++ Standard Template Library. As this library is
    used so commonly in C++, it is essential that we understand both the scope and
    breadth of the classes it contains. We are now prepared to utilize these useful,
    well-tested classes in our code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进一步扩展了我们的C++知识，超越了面向对象的语言特性，以熟悉C++标准模板库。由于这个库在C++中被如此普遍地使用，我们必须理解它包含的类的范围和广度。我们现在准备在我们的代码中利用这些有用的、经过充分测试的类。
- en: We have looked at quite a few STL examples; by examining selective STL classes,
    we should feel empowered to understand the remainder of the STL (or any C++ library)
    on our own.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查选择的STL类，我们已经看了很多STL的例子，应该有能力自己理解STL的其余部分（或任何C++库）。
- en: We have seen how to use common and essential STL classes such as `list`, `iterator`,
    `vector`, `deque`, `stack`, `queue`, `priority_queue`, and `map`. We have also
    seen how to utilize a functor in conjunction with a container class. We have been
    reminded that we now have the tools to potentially customize any class, even those
    from class libraries such as STL (through private or protected inheritance) or
    with containment or association.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用常见和基本的STL类，比如`list`、`iterator`、`vector`、`deque`、`stack`、`queue`、`priority_queue`和`map`。我们还看到了如何将一个函数对象与容器类结合使用。我们被提醒，我们现在有可能定制任何类的工具，甚至是来自类库如STL的类（通过私有或受保护的继承）或者包含或关联。
- en: We have additionally seen through examining selected STL classes that we have
    the skills to understand the remaining depth and breadth of the STL, as well as
    decoding many additional class libraries that are available to us. As we navigate
    the prototypes of each member function, we notice key language concepts such as
    the use of `const`, or that a method returns a reference to an object representing
    writable memory. Each prototype reveals the mechanics for the usage of the new
    class. It is very exciting to have come this far with our programming endeavors!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查选定的STL类，我们还看到了我们有能力理解STL剩余的深度和广度，以及解码许多可用于我们的额外类库。当我们浏览每个成员函数的原型时，我们注意到关键的语言概念，比如`const`的使用，或者一个方法返回一个表示可写内存的对象的引用。每个原型都揭示了新类的使用机制。能够在编程努力中走到这一步真是令人兴奋！
- en: We have now added additional, useful features to our C++ repertoire through
    browsing the STL in C++. Usage of the STL (to encapsulate traditional data structures)
    will ensure that our code can easily be understood by other programmers who are
    also undoubtedly using the STL. Relying on the well-tested STL for these common
    containers and utilities ensures that our code remains more bug-free.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在C++中浏览STL，我们现在已经为我们的C++技能库增加了额外的有用特性。使用STL（封装传统的数据结构）将确保我们的代码可以轻松地被其他程序员理解，他们无疑也在使用STL。依靠经过充分测试的STL来使用这些常见的容器和实用程序，可以确保我们的代码更少出现错误。
- en: We are now ready to continue forward with [*Chapter 15*](B15702_15_Final_NM_ePub.xhtml#_idTextAnchor572),
    *Testing Classes and Components*. We want to complement our C++ programming skills
    with useful OO component testing skills. Testing skills will help us understand
    whether we have created, extended, or augmented classes in a robust fashion. These
    skills will make us better programmers. Let's continue onward!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续进行[*第15章*]，*测试类和组件*。我们希望用有用的OO组件测试技能来补充我们的C++编程技能。测试技能将帮助我们了解我们是否以稳健的方式创建、扩展或增强了类。这些技能将使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Replace your template `Array` class from your exercise from [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*, with an STL `vector`. Create a `vector` of `Student`
    instances. Use `vector` operations to insert, retrieve, print, compare, and remove
    objects from the vector. Alternatively, utilize an STL `list`. Use this opportunity
    to utilize the STL documentation to navigate the full set of operations available
    for these classes.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用STL`vector`替换您在[*第13章*]（B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486）的练习中的模板`Array`类，*使用模板*。创建`Student`实例的`vector`。使用`vector`操作来插入、检索、打印、比较和从向量中删除对象。或者，利用STL`list`。利用这个机会利用STL文档来浏览这些类的全部操作。
- en: a. Consider what operators, if any, you will need to overload. Consider whether
    you will need an `iterator` to provide safe interleaved access to your collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: a. 考虑您是否需要重载哪些运算符。考虑是否需要一个`iterator`来提供对集合的安全交错访问。
- en: b. Create a second `vector` of `Students`. Assign one to another. Print both
    `vectors`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: b. 创建第二个`vector`的`Students`。将一个分配给另一个。打印两个`vectors`。
- en: Modify the `map` from this chapter to index the hash table (map) of `Student`
    instances based on their `lastName`, rather than `studentId`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改本章的`map`，以根据它们的`lastName`而不是`studentId`来索引`Student`实例的哈希表（map）。
- en: Modify the `queue` example from this chapter to instead utilize `priority_queue`.
    Be sure to make use of the priority enqueueing mechanism `priority_queue::emplace()`
    to add elements into the `priority_queue`. You will also need to utilize `top()`
    instead of `front()`. Note that `priority_queue` can be found in the `<queue>`
    header file.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改本章的`queue`示例，以改用`priority_queue`。确保利用优先级入队机制`priority_queue::emplace()`将元素添加到`priority_queue`中。您还需要利用`top()`而不是`front()`。请注意，`priority_queue`可以在`<queue>`头文件中找到。
- en: Try out an STL algorithm using `sort()`. Be sure to `#include <algorithm>`.
    Sort an array of integers. Keep in mind that many containers have sorting mechanisms
    built in, but native collection types, such as a language-supplied array, will
    not (which is why you should use a basic array of integers).
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`sort()`的STL算法。确保`#include <algorithm>`。对整数数组进行排序。请记住，许多容器都内置了排序机制，但本地集合类型，如语言提供的数组，没有（这就是为什么您应该使用基本整数数组）。
