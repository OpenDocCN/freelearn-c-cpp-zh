- en: Chapter 3. QPainter and 2D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。QPainter和2D图形
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Drawing basic shapes on screen
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上绘制基本形状
- en: Exporting shapes to an SVG file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将形状导出为SVG文件
- en: Coordinate transformation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标变换
- en: Displaying images on screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像
- en: Applying image effects to graphics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像效果应用于图形
- en: Creating a basic paint program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本绘画程序
- en: 2D Canvas in QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的2D画布
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will learn how to render 2D graphics on screen with Qt.
    Internally, Qt uses a low-level class called `QPainter` to render its widgets
    on the main window. Qt allows us to access and use the `QPainter` class for drawing
    vector graphics, text, 2D images, and even 3D graphics. You can make use of the
    `QPainter` class to create your own custom widgets or to create programs that
    rely heavily on computer graphics rendering such as video games, photo editors,
    3D modeling tools, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Qt在屏幕上渲染2D图形。在内部，Qt使用一个低级别的类称为`QPainter`来在主窗口上渲染其小部件。Qt允许我们访问和使用`QPainter`类来绘制矢量图形、文本、2D图像，甚至3D图形。您可以利用`QPainter`类来创建自定义小部件，或者创建依赖于计算机图形渲染的程序，如视频游戏、照片编辑器、3D建模工具等。
- en: Drawing basic shapes on screen
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上绘制基本形状
- en: In this section, we will learn how to draw simple vector shapes (line, rectangle,
    circle, and so on) and display text on the main window using the `QPainter` class.
    We will also learn how to change the drawing style of the vector shapes using
    the `QPen` class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用`QPainter`类在主窗口上绘制简单的矢量形状（线条、矩形、圆形等）并显示文本。我们还将学习如何使用`QPen`类更改矢量形状的绘制样式。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let''s create a new **Qt Widgets Application** project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的**Qt Widgets应用程序**项目：
- en: Open up `mainwindow.ui` and remove the menu bar, main tool bar, and status bar
    so that we get a clean, empty main window. Right-click on the bar widgets and
    select **Remove Menu Bar** from the pop-up menu:![How to do it…](img/B02820_03_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mainwindow.ui`并删除菜单栏、主工具栏和状态栏，以便获得一个干净的空白主窗口。右键单击栏小部件，从弹出菜单中选择**删除菜单栏**：![操作步骤...](img/B02820_03_01.jpg)
- en: 'Then, open up `mainwindow.h` and add the following code to include the `QPainter`
    header file:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`mainwindow.h`并添加以下代码以包含`QPainter`头文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, declare the `paintEvent()` event handler below the class destructor:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类析构函数下面声明`paintEvent()`事件处理程序：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, open up `mainwindow.cpp` and define the `paintEvent()` event handler:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`mainwindow.cpp`并定义`paintEvent()`事件处理程序：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, we will add text to the screen using the `QPainter` class inside
    the `paintEvent()` event handler. We set the text font settings before drawing
    it on the screen at the position `(20, 30)`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将使用`paintEvent()`事件处理程序内的`QPainter`类向屏幕添加文本。我们在屏幕上的位置`(20, 30)`绘制文本之前设置文本字体设置：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we will draw a straight line that starts from `(50, 60)` and ends at
    `(100, 100)`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将绘制一条从`(50, 60)`开始到`(100, 100)`结束的直线：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also easily draw a rectangle shape by calling the `drawRect()` function
    using a `QPainter` class. This time however, we also apply a background pattern
    to the shape before drawing it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`QPainter`类调用`drawRect()`函数轻松绘制一个矩形形状。不过这次，在绘制之前我们还会为形状应用一个背景图案：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, declare a `QPen` class, set its color to `red`, and set its drawing style
    to `Qt::DashDotLine`. Then, apply the `QPen` class to `QPainter` and draw an ellipse
    shape at `(80, 200)` with a horizontal radius of `50` and a vertical radius of
    `20`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个`QPen`类，将其颜色设置为`red`，将其绘制样式设置为`Qt::DashDotLine`。然后，将`QPen`类应用于`QPainter`并在`(80,
    200)`处绘制一个水平半径为`50`，垂直半径为`20`的椭圆形：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use `QPainterPath` class to define a shape before passing it over
    to the `QPainter` class for rendering:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`QPainterPath`类来定义形状，然后将其传递给`QPainter`类进行渲染：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also draw any other shapes by using `QPainterPath`, such as an ellipse:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用`QPainterPath`绘制任何其他形状，比如椭圆：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`QPainter` can also be used to draw an image file onto the screen. In the following
    example, we load an image file called `tux.png` and draw it on the screen at position
    `(100, 150)`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QPainter`也可以用来将图像文件绘制到屏幕上。在下面的示例中，我们加载一个名为`tux.png`的图像文件，并在屏幕上的位置`(100, 150)`绘制它：'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The final result should look something like this:![How to do it…](img/B02820_03_02.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果应该看起来像这样：![操作步骤...](img/B02820_03_02.jpg)
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: If you want to draw something on screen using `QPainter`, basically all you
    need to do is tell it what type of graphics it should be drawing (text, vector
    shape, image, polygon, and so on) with its position and size.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用`QPainter`在屏幕上绘制一些东西，基本上您只需要告诉它应该绘制什么类型的图形（文本、矢量形状、图像、多边形等），以及其位置和大小。
- en: QPen determines what the outline of the graphic should look like, such as its
    color, line width, line style (solid, dashed, dotted, and so on), cap style, join
    style, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: QPen确定了图形的轮廓样式，如颜色、线宽、线型（实线、虚线、点线等）、端点样式、连接样式等。
- en: On the other hand, `QBrush` sets the style of the background of the graphics,
    such as the background color, pattern (solid color, gradient, dense brush, crossing
    diagonal lines, and so on) and pixmap.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`QBrush`设置了图形的背景样式，如背景颜色、图案（纯色、渐变、密集刷、交叉对角线等）和像素图。
- en: The options for the graphics should be set before calling the draw function
    (`drawLine()`, `drawRect()`, `drawEllipse()`, and so on).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用绘制函数（`drawLine()`、`drawRect()`、`drawEllipse()`等）之前应设置图形的选项。
- en: 'If your graphics do not appear on screen and you see warnings such as `QPainter::setPen:
    Painter not active` and `QPainter::setBrush: Painter not active` appearing on
    the application output window in Qt Creator, it means that the `QPainter` class
    is not currently active and your program will not trigger its paint event. To
    solve this problem, set the main window as the parent of the `QPainter` class.
    Usually, if you''re writing code in the `mainwindow.cpp` file, all you need to
    do is to put `this` in the bracket when initializing `QPainter`. For example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你的图形不显示在屏幕上，并且在Qt Creator的应用程序输出窗口中看到警告，比如`QPainter::setPen: Painter not
    active`和`QPainter::setBrush: Painter not active`，这意味着`QPainter`类当前不活动，你的程序不会触发它的绘制事件。要解决这个问题，将主窗口设置为`QPainter`类的父类。通常，如果你在`mainwindow.cpp`文件中编写代码，初始化`QPainter`时只需要在括号中放入`this`。例如：'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`QImage` can load images from both the computer directories and from the program
    resources.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage`可以从计算机目录和程序资源中加载图像。'
- en: There's more…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Think of `QPainter` as a robot with a pen and an empty canvas. You just have
    to tell the robot what type of shape it should be drawing and its location on
    the canvas, then the robot will do its job based on your description. To make
    your life easier, the `QPainter` class also provides numerous functions such as
    `drawArc()`, `drawEllipse()`, `drawLine()`, `drawRect()`, `drawPie()`, and so
    on that allow you to easily render a predefined shape.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 把`QPainter`想象成一个带着笔和空画布的机器人。你只需要告诉机器人应该画什么类型的形状以及它在画布上的位置，然后机器人会根据你的描述完成工作。为了让你的生活更轻松，`QPainter`类还提供了许多函数，比如`drawArc()`、`drawEllipse()`、`drawLine()`、`drawRect()`、`drawPie()`等，让你可以轻松地渲染预定义的形状。
- en: In Qt, all the widget classes (including the main window) have an event handler
    called `QWidget::paintEvent()`. This event handler will be triggered whenever
    the operating system thinks that the main window should re-draw its widgets. Many
    things can lead to that decision, such as the main window being scaled, a widget
    changing its state (that is, a button being pressed), or functions such as `repaint()`
    or `update()` being invoked manually in the code. Different operating system may
    behave differently when it comes to deciding whether or not to trigger the update
    event on the same set of conditions. If you're making a program that requires
    continuous and consistent graphical updates, call `repaint()` or `update()` manually
    with a timer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，所有的窗口部件类（包括主窗口）都有一个名为`QWidget::paintEvent()`的事件处理程序。每当操作系统认为主窗口应该重新绘制其窗口部件时，这个事件处理程序就会被触发。许多事情可能导致这个决定，比如主窗口被缩放，窗口部件改变其状态（即，按钮被按下），或者在代码中手动调用`repaint()`或`update()`等函数。不同的操作系统在决定是否触发相同条件下的更新事件时可能会有不同的行为。如果你正在制作一个需要连续和一致的图形更新的程序，可以使用定时器手动调用`repaint()`或`update()`。
- en: Exporting shapes to SVG files
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将形状导出为SVG文件
- en: '**Scalable Vector Graphics** (**SVG**) is an XML-based language for describing
    two-dimensional vector graphics. Qt provides classes for saving vector shapes
    into an SVG file. This feature can be used to create a simple vector graphics
    editor similar to Adobe Illustrator and Inkscape.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**可伸缩矢量图形**（**SVG**）是一种基于XML的语言，用于描述二维矢量图形。Qt提供了保存矢量形状到SVG文件的类。这个功能可以用来创建一个简单的矢量图形编辑器，类似于Adobe
    Illustrator和Inkscape。'
- en: In the next example, we will continue using the same project file from the previous
    example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将继续使用前一个示例中的相同项目文件。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s learn how to create a simple program that displays SVG graphics on screen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何创建一个简单的程序，在屏幕上显示SVG图形：
- en: First of all, let's create a menu bar by right-clicking the main window widget
    on the hierarchy window and selecting **Create Menu Bar** option from the pop-up
    menu. After that, add a **File** option to the menu bar and a **Save as SVG**
    action underneath it:![How to do it…](img/B02820_03_03.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过右键单击层次结构窗口上的主窗口部件，并从弹出菜单中选择**创建菜单栏**选项来创建一个菜单栏。之后，在菜单栏中添加一个**文件**选项，然后在其下方添加一个**另存为SVG**操作：![如何做…](img/B02820_03_03.jpg)
- en: After that, you will see an item called `actionSave_as_SVG` in the **Action
    Editor** window at the bottom of the Qt Creator window. Right-click on the item
    and choose **Go to slot…** from the pop-up menu. A window will now appear, which
    carries a list of slots available for the particular action. Choose the default
    signal called `triggered()` and click the **OK** button:![How to do it…](img/B02820_03_04.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在Qt Creator窗口底部的**Action Editor**窗口中会看到一个名为`actionSave_as_SVG`的项目。右键单击该项目，从弹出菜单中选择**转到槽…**。现在会出现一个窗口，其中列出了特定操作可用的槽。选择名为`triggered()`的默认信号，然后点击**OK**按钮：![如何做…](img/B02820_03_04.jpg)
- en: 'Once you have clicked the **OK** button, Qt Creator will switch over to the
    script editor. You will realize that a slot called `on_actionSave_as_SVG_triggered()`
    has been automatically added to your main window class. At the bottom of your
    `mainwindow.h`, you will see something like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**OK**按钮后，Qt Creator将切换到脚本编辑器。你会发现一个名为`on_actionSave_as_SVG_triggered()`的槽已经自动添加到你的主窗口类中。在你的`mainwindow.h`的底部，你会看到类似这样的内容：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding function will be called when you clicked on the **Save as SVG**
    option from the menu bar. We will write our code within this function to save
    all the vector graphics into an SVG file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从菜单栏点击**另存为SVG**选项时，将调用上述函数。我们将在这个函数中编写代码，将所有矢量图形保存到一个SVG文件中。
- en: 'To do that, we need to first of all include a class header called `QSvgGenerator`
    at the top of our source file. This header is very important as it''s required
    for generating SVG files. Then, we also need to include another class header called
    `QFileDialog`, which will be used to open the save dialog:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先需要在源文件顶部包含一个名为`QSvgGenerator`的类头文件。这个头文件非常重要，因为它用于生成SVG文件。然后，我们还需要包含另一个名为`QFileDialog`的类头文件，它将用于打开保存对话框：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to add the SVG module to our project file, like so:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在项目文件中添加SVG模块，如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, create a new function called `paintAll()` within `mainwindow.h`, like
    so:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`mainwindow.h`中创建一个名为`paintAll()`的新函数，如下所示：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After that, in `mainwindow.cpp`, move all the code from `paintEvent()` to the
    `paintAll()` function. Then, replace all the individual `QPainter` objects with
    a single, unified `QPainter` for drawing all the graphics. Also, call the `begin()`
    function before drawing anything and call the `end()` function after finishing
    drawing. The code should look like this:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`mainwindow.cpp`中，将所有代码从`paintEvent()`移动到`paintAll()`函数中。然后，用单一统一的`QPainter`替换所有单独的`QPainter`对象来绘制所有图形。还要在绘制任何内容之前调用`begin()`函数，并在完成绘制后调用`end()`函数。代码应该如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since we have moved all the code from `paintEvent()` to `paintAll()`, we shall
    now call the `paintAll()` function inside `paintEvent()`, like so:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已将所有代码从`paintEvent()`移动到`paintAll()`，因此现在我们应该在`paintEvent()`中调用`paintAll()`函数，如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we will write the code for exporting the graphics to an SVG file. The
    code will be written inside the slot function called `on_actionSave_as_SVG_triggered()`,
    which was generated by Qt. We start by calling the save file dialog and obtain
    the directory path with the desired file name from the user:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将编写将图形导出到SVG文件的代码。代码将写在名为`on_actionSave_as_SVG_triggered()`的槽函数中，该函数由Qt生成。我们首先调用保存文件对话框，并从用户那里获取所需文件名的目录路径：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that, create a `QSvgGenerator` object and save the graphics to an SVG
    file by passing the `QSvgGenerator` object to the `paintAll()` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，创建一个`QSvgGenerator`对象，并通过将`QSvgGenerator`对象传递给`paintAll()`函数将图形保存到SVG文件中：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile and run the program now and you should be able to export the graphics
    by going to **File** | **Save as SVG**:![How to do it…](img/B02820_03_05.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行程序，您应该能够通过转到**文件** | **另存为SVG**来导出图形：![如何做...](img/B02820_03_05.jpg)
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By default, `QPainter` will use the paint engine from its parent object to draw
    the graphics assigned to it. If you don't assign any parent to `QPainter`, you
    can manually assign a paint engine to it, which is what we have done in this example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`QPainter`将使用其父对象的绘图引擎来绘制分配给它的图形。如果您没有为`QPainter`分配任何父对象，可以手动为其分配绘图引擎，这就是我们在这个例子中所做的。
- en: 'The reason why we placed the code into `paintAll()` is because we want to reuse
    the same code for two different purposes: for displaying the graphics on the window
    and exporting the graphics to an SVG file. Notice the default value of the `generator`
    variable in the `paintAll()` function is set to `0`, which means no `QSvgGenerator`
    object is required to run the function unless specified. Later on, in the `paintAll()`
    function, we check whether the `generator` object exists. If it does exist, use
    it as the paint engine for the painter, like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放入`paintAll()`的原因是因为我们希望将相同的代码用于两个不同的目的：用于在窗口上显示图形和将图形导出到SVG文件。请注意`paintAll()`函数中`generator`变量的默认值设置为`0`，这意味着除非指定，否则不需要`QSvgGenerator`对象来运行该函数。稍后，在`paintAll()`函数中，我们检查`generator`对象是否存在。如果存在，就像这样将其用作绘图引擎：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Otherwise, pass the main window to the `begin()` function (since we're writing
    the code in `mainwindow.cpp`, we can directly use `this` to refer to main window's
    pointer) so that it will use the paint engine of the main window itself, which
    means the graphics will be drawn onto the surface of the main window.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将主窗口传递给`begin()`函数（因为我们正在`mainwindow.cpp`中编写代码，所以可以直接使用`this`来引用主窗口的指针），这样它将使用主窗口本身的绘图引擎，这意味着图形将绘制在主窗口的表面上。
- en: In this example, it's required to use a single `QPainter` object to save the
    graphics into the SVG file. If you use multiple `QPainter` objects, the resulting
    SVG file will contain multiple XML header definitions and thus the file will be
    deemed to be invalid by any graphics editor software out there.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，需要使用单个`QPainter`对象将图形保存到SVG文件中。如果使用多个`QPainter`对象，生成的SVG文件将包含多个XML头定义，因此任何图形编辑软件都会将文件视为无效。
- en: '`QFileDialog::getSaveFileName()` will open up the native save file dialog for
    the user to choose the save directory and set a desired file name. Once the user
    is done with that, the full path will be returned as a string and we will be able
    to pass that information to the `QSvgGenerator` object to export the graphics.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFileDialog::getSaveFileName()`将为用户打开本机保存文件对话框，以选择保存目录并设置所需的文件名。一旦用户完成，完整路径将作为字符串返回，我们将能够将该信息传递给`QSvgGenerator`对象以导出图形。'
- en: Notice that in the previous screenshot, the penguin in the SVG file has been
    cropped. This is because the canvas size of the SVG was set to follow the size
    of the main window. To help the poor penguin getting its body back, scale the
    window bigger before exporting the SVG file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上一张截图中，SVG文件中的企鹅已被裁剪。这是因为SVG的画布大小设置为跟随主窗口的大小。为了帮助可怜的企鹅找回身体，导出SVG文件之前将窗口放大。
- en: There's more…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**Scalable Vector Graphics** (**SVG**) defines the graphics in XML format.
    Since it is vector graphics, SVG graphics do not lose any quality if they are
    zoomed or resized.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**可缩放矢量图形**（**SVG**）以XML格式定义图形。由于它是矢量图形，所以SVG图形在缩放或调整大小时不会失去任何质量。'
- en: 'SVG allows three types of graphic object: vector graphics, raster graphics,
    and text. Graphical objects, including PNG and JPEG raster images, can be grouped,
    styled, transformed, and composited into previously rendered objects.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SVG允许三种类型的图形对象：矢量图形、光栅图形和文本。包括PNG和JPEG光栅图像在内的图形对象可以分组、样式化、变换和合成到先前渲染的对象中。
- en: You can check out the full specification of SVG graphics at [https://www.w3.org/TR/SVG](https://www.w3.org/TR/SVG).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.w3.org/TR/SVG](https://www.w3.org/TR/SVG)上查看SVG图形的完整规范。
- en: Coordinate transformation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标变换
- en: In this example, we will learn how to use coordinate transformation and a timer
    to create a real-time clock display.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何使用坐标变换和定时器来创建实时时钟显示。
- en: How to do it…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create our first graphical clock display, let''s follow these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个图形时钟显示，请按照以下步骤进行：
- en: First, create a new **Qt Widgets Application** project. Then, open up `mainwindow.ui`
    and remove the menu bar, tool bar, and status bar.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的**Qt Widgets Application**项目。然后，打开`mainwindow.ui`并移除菜单栏、工具栏和状态栏。
- en: 'After that, open up `mainwindow.h` and include the following headers:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，打开`mainwindow.h`并包含以下头文件：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, declare the `paintEvent()` function, like so:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明`paintEvent()`函数，如下所示：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `mainwindow.cpp`, create three arrays to store the shapes of the hour hand,
    minute hand, and second hand, where each of the arrays contains three sets of
    coordinates:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mainwindow.cpp`中，创建三个数组来存储时针、分针和秒针的形状，其中每个数组包含三组坐标：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, add the following code below the arrays to create the painter and
    move it to the center of the main window. Also, we adjust the size of the painter
    so that it fits nicely in the main window, even when the window is being resized:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，将以下代码添加到数组下面，以创建绘图器并将其移动到主窗口的中心。此外，我们调整绘图器的大小，使其在主窗口中很好地适应，即使窗口被调整大小：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you are done with that, we will start drawing the dials by using a `for`
    loop. Each dial is rotated by an increment of 6 degrees, so 60 dials would complete
    a full circle. Also, the dial at every 5 minutes will look slightly longer:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将通过使用`for`循环开始绘制刻度。每个刻度旋转增加6度，所以60个刻度将完成一个完整的圆。此外，每5分钟的刻度看起来会稍微长一些：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we proceed with drawing the hands of the clock. Each hand''s rotation
    is calculated according to the current time and its respective unit over 360 degrees:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续绘制时钟的指针。每个指针的旋转根据当前时间和其相应的单位计算超过360度：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Last but not least, create a timer to refresh the graphics every second so that
    the program will work like a real clock!
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个定时器，每秒刷新一次图形，使程序像一个真正的时钟一样工作！
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run the program now and you should see something like this:![How
    to do it…](img/B02820_03_07.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行程序，你应该会看到类似这样的东西：![如何做...](img/B02820_03_07.jpg)
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each of the arrays contain three `QPoint` data, which form the shape of an elongated
    triangle. The arrays are then passed to the painter and rendered as a convex polygon
    using the `drawConvexPolygon()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都包含三个`QPoint`数据，形成一个细长的三角形。然后将这些数组传递给绘图器，并使用`drawConvexPolygon()`函数呈现为凸多边形。
- en: Before drawing each of the clock hands, we use `painter.save()` to save the
    state of the `QPainter` object and then proceed with drawing the hand using coordinate
    transformation. Once we're done with the drawing, we restore the painter to its
    previous state by calling `painter.restore()`. This function will undo all the
    transformations before `painter.restore()` so that the next clock hand will not
    inherit the transformations of the previous one. Without using `painter.save()`
    and `painter.restore()`, we will have to manually change back the position, rotation,
    and scale before drawing the next hand.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制每个时钟指针之前，我们使用`painter.save()`保存`QPainter`对象的状态，然后使用坐标转换继续绘制指针。完成绘制后，我们通过调用`painter.restore()`将绘图器恢复到先前的状态。这个函数将撤消`painter.restore()`之前的所有转换，以便下一个时钟指针不会继承上一个时钟指针的转换。如果不使用`painter.save()`和`painter.restore()`，我们将不得不在绘制下一个指针之前手动改变位置、旋转和比例。
- en: A good example of not using `painter.save()` and `painter.restore()` is when
    drawing the dials. Since each dial's rotation is an increment of 6 degrees from
    the previous one, we don't need to save the painter's state at all. We just have
    to call `painter.rotate(6.0)` in a loop and each dial will inherit the previous
    dial's rotation. We also use a modulus operator (`%`) to check whether the unit
    represented by the dial can be divided by 5\. If it can, then we draw it slightly
    longer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`painter.save()`和`painter.restore()`的一个很好的例子是绘制刻度。由于每个刻度的旋转是从前一个刻度增加6度，我们根本不需要保存绘图器的状态。我们只需在循环中调用`painter.rotate(6.0)`，每个刻度将继承前一个刻度的旋转。我们还使用模运算符(`%`)来检查刻度所代表的单位是否可以被5整除。如果可以，我们就会稍微拉长它。
- en: Without using a timer to constantly call the `update()` slot, the clock will
    not function properly. This is because `paintEvent()` will not be called by Qt
    when there is no change to the state of the parent widget, which in this case
    is the main window. Therefore, we need to manually tell Qt that we need to refresh
    the graphics by calling `update()`every second.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用定时器不断调用`update()`槽，时钟将无法正常工作。这是因为当父窗口的状态没有改变时，Qt不会调用`paintEvent()`。因此，我们需要手动告诉Qt我们需要通过每秒调用`update()`来刷新图形。
- en: 'We used the `painter.setRenderHint(QPainter::Antialiasing)` function to enable
    anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will
    look very jagged and pixelated:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`painter.setRenderHint(QPainter::Antialiasing)`函数在渲染时启用抗锯齿。没有抗锯齿，图形看起来会非常锯齿和像素化：
- en: '![How it works...](img/B02820_03_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B02820_03_08.jpg)'
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `QPainter` class uses the coordinate system to determine the position and
    size of the graphics before rendering them on screen. This information can be
    altered to make the graphics appear at a different position, rotation, and size.
    This process of altering the coordinate information of a graphic is what we called
    coordinate transformation. There are several types of transformation, among them
    are translation, rotation, scaling and shearing:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`类使用坐标系统来确定在屏幕上呈现图形之前的位置和大小。这些信息可以被改变，使图形出现在不同的位置、旋转和大小。这个改变图形坐标信息的过程就是我们所谓的坐标转换。有几种类型的转换，其中包括平移、旋转、缩放和剪切：'
- en: '![There''s more…](img/B02820_03_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/B02820_03_06.jpg)'
- en: Qt uses a coordinate system that has its origin at the top-left corner, meaning
    the x values increase to the right and the y values increase downwards. This coordinate
    system might be different from the coordinate system used by the physical device,
    such as a computer screen. Qt handles this automatically by using the `QPaintDevice`
    class, which maps Qt's logical coordinates to the physical coordinates.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Qt使用一个坐标系统，其原点位于左上角，意味着x值向右增加，y值向下增加。这个坐标系统可能与物理设备使用的坐标系统不同，比如计算机屏幕。Qt通过使用`QPaintDevice`类自动处理这个问题，将Qt的逻辑坐标映射到物理坐标。
- en: '`QPainter` provides four transform operations to perform different types of
    transformation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`提供了四种变换操作来执行不同类型的变换：'
- en: '`QPainter::translate()`: Offset the graphic''s position by a given set of units'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::translate()`: 通过给定的单位偏移图形的位置'
- en: '`QPainter::rotate()`: Rotate the graphics around the origin in a clockwise
    direction'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::rotate()`: 以顺时针方向围绕原点旋转图形'
- en: '`QPainter::scale()`: Offset the graphic''s size by a given factor'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::scale()`: 通过给定的因子偏移图形的大小'
- en: '`QPainter::shear()`: Twist the graphic''s coordinate system around the origin'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPainter::shear()`: 扭曲图形的坐标系围绕原点'
- en: Displaying images on screen
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像
- en: Qt not only allows us to draw shapes and images on screen, but it also allows
    us to overlay multiple images on top of each other and combine the pixel information
    from all the layers using different types of algorithms to create very interesting
    results. In this example, we will learn how to overlay images on top of each other
    and apply different composition effects to them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Qt不仅允许我们在屏幕上绘制形状和图像，还允许我们将多个图像叠加在一起，并使用不同类型的算法结合所有图层的像素信息，以创建非常有趣的结果。在这个例子中，我们将学习如何将图像叠加在一起，并对它们应用不同的组合效果。
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s create a simple demo that shows the effect of different image compositions
    by following these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的演示，通过以下步骤展示不同图像组合效果的效果：
- en: First, set up a new **Qt Widgets Application** project and remove the menu bar,
    tool bar, and status bar.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，设置一个新的**Qt Widgets Application**项目，并移除菜单栏、工具栏和状态栏。
- en: 'Next, add the QPainter class header to `mainwindow.h`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将QPainter类头文件添加到`mainwindow.h`中：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, declare the `paintEvent()` virtual function like so:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，声明`paintEvent()`虚函数如下：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In `mainwindow.cpp`, we will first load several image files using the `QImage`
    class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mainwindow.cpp`中，我们将首先使用`QImage`类加载几个图像文件：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, create a `QPainter` object and use it to draw two pairs of images, where
    one image is on top of another:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`QPainter`对象，并使用它来绘制两对图像，其中一张图像叠加在另一张图像上：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compile and run the program now and you should see something like this:![How
    to do it…](img/B02820_03_10.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行程序，你应该会看到类似这样的东西：![如何做…](img/B02820_03_10.jpg)
- en: 'Next, we will set the composition mode before drawing each image on screen:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在屏幕上绘制每个图像之前设置组合模式：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Compile and run the program again and you will now see something like this:![How
    to do it…](img/B02820_03_11.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行程序，你现在会看到类似这样的东西：![如何做…](img/B02820_03_11.jpg)
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When drawing images with Qt, the sequence of calling the `drawImage()` function
    will determine which image is being rendered first and which one is rendered later.
    This will affect the depth order of the images and yield different outcomes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Qt绘制图像时，调用`drawImage()`函数的顺序将决定首先渲染哪个图像，以及后渲染哪个图像。这将影响图像的深度顺序，并产生不同的结果。
- en: In the previous example, we called `drawImage()` four times to draw four different
    images on screen. The first `drawImage()` renders `checker.png` and the second
    `drawImage()` renders `tux.png` (the penguin). The image that gets rendered later
    will always appear in front of the others, which is why the penguin is showing
    in front of the checker box. The same goes for the butterfly and the checker on
    the right. The reason why you can still see the checker even though the butterfly
    is rendered in front of it is because the butterfly image is not fully opaque.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们调用了`drawImage()`四次，在屏幕上绘制了四个不同的图像。第一次`drawImage()`渲染了`checker.png`，第二次`drawImage()`渲染了`tux.png`（企鹅）。后渲染的图像将始终出现在其他图像的前面，这就是为什么企鹅显示在棋盘前面。右侧的蝴蝶和棋盘也是如此。尽管蝴蝶被渲染在棋盘前面，你仍然能看到棋盘，这是因为蝴蝶图像不是完全不透明的。
- en: 'Now let''s invert the render sequence and see what happens. We will try to
    render the penguin first, followed by the checker box. The same goes for the other
    pair of images on the right: the butterfly gets rendered first, followed by the
    checker box:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们反转渲染顺序，看看会发生什么。我们将尝试首先渲染企鹅，然后是棋盘。右侧的另一对图像也是如此：蝴蝶首先被渲染，然后是棋盘：
- en: '![How it works...](img/B02820_03_12.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B02820_03_12.jpg)'
- en: To apply a composition effect to the image, we'll have to set the painter's
    composition mode before drawing the image, by calling the `painter.setCompositionMode()`
    function. You can pick a desired composition mode from the auto-complete menu
    by typing `QPainter::CompositionMode`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要对图像应用组合效果，我们必须在绘制图像之前设置绘图者的组合模式，通过调用`painter.setCompositionMode()`函数来选择所需的组合模式。
- en: In the previous example, we applied `QPainter::CompositionMode_Difference` to
    the checker box on the left, which inverted its color. Next, we applied `QPainter::CompositionMode_Overlay`
    to the penguin which makes it blend with the checker and we're able to see both
    images overlaying each other.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们将`QPainter::CompositionMode_Difference`应用到左侧的棋盘上，这使其颜色反转。接下来，我们将`QPainter::CompositionMode_Overlay`应用到企鹅上，使其与棋盘混合，我们能够看到两个图像叠加在一起。
- en: On the right-hand side, we applied `QPainter::CompositionMode_Xor` to the checker,
    where if differences exist between the source and destination, colors are shown;
    otherwise, it will be rendered black. Since it's comparing differences with the
    white background, the non-transparent part of the checker becomes completely black.
    We also applied `QPainter::CompositionMode_SoftLight` to the butterfly image.
    This blends the pixels with the background with reduced contrast.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们将`QPainter::CompositionMode_Xor`应用于棋盘，如果源和目的地之间存在差异，则显示颜色；否则，它将呈现为黑色。由于它正在与白色背景比较差异，棋盘的不透明部分变为完全黑色。我们还将`QPainter::CompositionMode_SoftLight`应用于蝴蝶图像。这会将像素与背景混合，降低对比度。
- en: If you want to disable the composition mode you have just set for the previous
    rendering before proceeding to the next, simply set it back to the default mode,
    which is `QPainter::CompositionMode_SourceOver`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在进行下一个渲染之前禁用刚刚设置的合成模式，请将其设置回默认模式，即`QPainter::CompositionMode_SourceOver`。
- en: There's more…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: For example, we can overlay multiple images on top of each other and use Qt's
    image composition feature to merge them together and calculate the resulting pixels
    on screen, based on the composition mode we used. This is often used in image
    editing software such as Photoshop and GIMP to composite image layers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将多个图像叠加在一起，并使用Qt的图像合成功能将它们合并在一起，并根据我们使用的合成模式计算屏幕上的结果像素。这在图像编辑软件（如Photoshop和GIMP）中经常用于合成图像图层。
- en: 'There are more than 30 types of composition mode available in Qt. Some of the
    most commonly used modes are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中有30多种合成模式可用。一些最常用的模式包括：
- en: '**Clear**: The pixels in the destination are set to fully transparent, independent
    of the source.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**：目的地中的像素被设置为完全透明，与源无关。'
- en: '**Source**: The output is the source pixel. This mode is the inverse of `CompositionMode_Destination`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：输出是源像素。这种模式是`CompositionMode_Destination`的反向。'
- en: '**Destination**: The output is the destination pixel. This means that the blending
    has no effect. This mode is the inverse of `CompositionMode_Source`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地**：输出是目的地像素。这意味着混合没有效果。这种模式是`CompositionMode_Source`的反向。'
- en: '**Source Over**: Often referred to as alpha blending. The alpha of the source
    is used to blend the pixel on top of the destination. This is the default mode
    used by `QPainter`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源上**：通常称为alpha混合。源的alpha值用于将像素混合在目的地的顶部。这是`QPainter`使用的默认模式。'
- en: '**Destination Over**: The alpha of the destination is used to blend it on top
    of the source pixels. This mode is the inverse of `CompositionMode_SourceOver`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地超过**：目的地的alpha值用于在源像素的顶部混合。这种模式是`CompositionMode_SourceOver`的反向。'
- en: '**Source In**: The output is the source, where the alpha is reduced by that
    of the destination.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源入**：输出是源，其中alpha值减少了目标的alpha值。'
- en: '**Destination In**: The output is the destination, where the alpha is reduced
    by that of the source. This mode is the inverse of `CompositionMode_SourceIn`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地内**：输出是目的地，其中alpha值减少了源的alpha值。这种模式是`CompositionMode_SourceIn`的反向。'
- en: '**Source Out**: The output is the source, where the alpha is reduced by the
    inverse of the destination.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源出**：输出是源，其中alpha值减少了目标的倒数。'
- en: '**Destination Out**: The output is the destination, where the alpha is reduced
    by the inverse of the source. This mode is the inverse of `CompositionMode_SourceOut`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地外**：输出是目的地，其中alpha值减少了源的倒数。这种模式是`CompositionMode_SourceOut`的反向。'
- en: '**Source Atop**: The source pixel is blended on top of the destination, with
    the alpha of the source pixel reduced by the alpha of the destination pixel.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源顶部**：源像素在目标的顶部混合，源像素的alpha值减少了目标像素的alpha值。'
- en: '**Destination Atop**: The destination pixel is blended on top of the source,
    with the alpha of the source pixel reduced by the alpha of the destination pixel.
    This mode is the inverse of `CompositionMode_SourceAtop`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地顶部**：目的地像素在源的顶部混合，源像素的alpha值减少了目的地像素的alpha值。这种模式是`CompositionMode_SourceAtop`的反向。'
- en: '**Xor**: This is short for **Exclusive OR**, which is an advanced blending
    mode that is primarily used for image analysis. The source, whose alpha is reduced
    by the inverse of the destination alpha, is merged with the destination, whose
    alpha is reduced by the inverse of the source alpha.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异或**：这是**异或**的缩写，是一种主要用于图像分析的高级混合模式。源的alpha值减少了目的地alpha值的倒数，与目的地合并，目的地的alpha值减少了源alpha值的倒数。'
- en: 'The following image shows the outcome of overlaying two images with different
    composition modes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用不同合成模式叠加两个图像的结果：
- en: '![There''s more…](img/B02820_03_09.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容…](img/B02820_03_09.jpg)'
- en: Applying image effects to graphics
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用图像效果到图形
- en: Qt provides an easy way to add image effects to any graphics drawn using the
    `QPainter` class. In this example, we will learn how to apply different images
    effects, such as drop shadow, blur, colorize, and opacity effects, to a graphic
    before displaying it on screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一种简单的方法，可以在使用`QPainter`类绘制的任何图形上添加图像效果。在这个例子中，我们将学习如何应用不同的图像效果，如阴影、模糊、着色和不透明度效果，以在屏幕上显示图形之前应用到图形上。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s learn how to apply image effects to text and graphics by following these
    steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何通过以下步骤将图像效果应用于文本和图形：
- en: Create a new **Qt Widgets Application** and remove the menu bar, tool bar, and
    status bar.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**Qt小部件应用程序**，并删除菜单栏、工具栏和状态栏。
- en: Create a new resource file by going to **File** | **New File or Project** and
    adding all the images required by the project:![How to do it…](img/B02820_03_13.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件** | **新文件或项目**创建一个新的资源文件，并添加项目所需的所有图像：![如何做…](img/B02820_03_13.jpg)
- en: Next, open up `mainwindow.ui` and add four labels to the window. Two of the
    labels will be text and the two others we will load with the images we have just
    added to the resource file:![How to do it…](img/B02820_03_14.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`mainwindow.ui`并向窗口添加四个标签。其中两个标签将是文本，另外两个将加载我们刚刚添加到资源文件中的图像：![如何做…](img/B02820_03_14.jpg)
- en: 'You may already notice the font sizes are way bigger than the default size.
    That can be achieved by adding a style sheet to the label widget, for example:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到字体大小比默认大小要大得多。例如，可以通过向标签小部件添加样式表来实现：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, open up `mainwindow.cpp` and include the following headers at the
    top of the source code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.cpp`并在源代码顶部包含以下头文件：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, within the constructor of the `MainWindow` class, add the following code
    to create a drop shadow effect, and apply it to one of the labels:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`MainWindow`类的构造函数中，添加以下代码以创建一个投影效果，并将其应用于其中一个标签：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we will create a colorized effect and apply it to one of the images,
    in this case the butterfly. We also set the effect color to red:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个着色效果，并将其应用于其中一幅图像，这里是蝴蝶。我们还将效果颜色设置为红色：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once we''re done with that, create a blur effect and set its radius to `12`.
    Then, apply the graphics effect to the other label:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，创建一个模糊效果，并将其半径设置为`12`。然后，将图形效果应用于另一个标签：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, create an alpha effect and apply it to the penguin image. We set the
    opacity value to `0.2`, which means 20% opacity:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个alpha效果，并将其应用于企鹅图像。我们将不透明度值设置为`0.2`，即20%的不透明度：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Compile and run the program now and you should be able to see something like
    this:![How to do it…](img/B02820_03_15.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行程序，您应该能够看到类似于这样的东西：![如何做…](img/B02820_03_15.jpg)
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Each of the graphic effects is a class of its own that inherits the `QGraphicsEffect`
    parent class. You can create your own custom effect by creating a new class that
    inherits `QGraphicsEffect` and re-implementing some of the functions in it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每种图形效果都是其自己的类，继承自`QGraphicsEffect`父类。您可以通过创建一个新类，该类继承自`QGraphicsEffect`并重新实现其中的一些函数来创建自定义效果。
- en: Each effect has its own set of variables that are specifically created for it.
    For example, you can set the color of the colorized effect, but there is no such
    variable in the blur effect. This is because each effect is vastly different from
    the others, which is also why it needs to be a class of its own rather than using
    the same class for all the different effects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每种效果都有其专门为其创建的一组变量。例如，您可以设置着色效果的颜色，但在模糊效果中没有这样的变量。这是因为每种效果与其他效果大不相同，这也是为什么它需要成为自己的类，而不是使用相同的类来处理所有不同的效果。
- en: It's only possible to add a single graphics effect to a widget at a time. If
    you add more than one effect, only the last one will be applied to the widget
    as it replaces the previous one. Other than that, be aware that if you create
    a graphics effect, say the drop shadow effect, you can't assign it to two different
    widgets as it will only get assigned to the last widget you applied it to. If
    you need to apply the same type of effect to several different widgets, create
    a few graphics effects of the same type and apply each of them to their respective
    widgets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一次只能向小部件添加一个图形效果。如果添加多个效果，只有最后一个效果将应用于小部件，因为它替换了前一个效果。除此之外，要注意，如果创建了一个图形效果，比如投影效果，您不能将其分配给两个不同的小部件，因为它只会分配给您应用它的最后一个小部件。如果需要将相同类型的效果应用于几个不同的小部件，创建几个相同类型的图形效果，并将每个效果应用于各自的小部件。
- en: There's more…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Currently Qt supports blur, drop shadow, colorize, and opacity effects. These
    effects can be used by calling the following classes: `QGraphicsBlurEffect`, `QGraphicsDropShadowEffect`,
    `QGraphicsColorizeEffect`, and `QGraphicsOpacityEffect`. All these classes are
    inherited from the `QGraphicsEffect` class. You can also create your own custom
    image effect by creating a subclass of `QGrapicsEffect` (or any other existing
    effects) and re-implementing the `draw()` function.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Qt支持模糊、投影、着色和不透明度效果。这些效果可以通过调用以下类来使用：`QGraphicsBlurEffect`、`QGraphicsDropShadowEffect`、`QGraphicsColorizeEffect`和`QGraphicsOpacityEffect`。所有这些类都是从`QGraphicsEffect`类继承的。您还可以通过创建`QGrapicsEffect`的子类（或任何其他现有效果）并重新实现`draw()`函数来创建自定义图像效果。
- en: The graphics effect changes only the bounding rectangle of the source. If you
    want to increase the margin of the bounding rectangle, re-implement the virtual
    `boundingRectFor()` function, and call `updateBoundingRect()` to notify the framework
    whenever this rectangle changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图形效果仅改变源的边界矩形。如果要增加边界矩形的边距，可以重新实现虚拟的`boundingRectFor()`函数，并在此矩形更改时调用`updateBoundingRect()`来通知框架。
- en: Creating a basic paint program
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的绘画程序
- en: Since we have learned so much about the `QPainter` class and how to use it to
    display graphics on screen, I guess it's time for us to do something fun so that
    we can put our knowledge into practice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学习了关于`QPainter`类以及如何使用它在屏幕上显示图形，我想现在是时候做一些有趣的事情，这样我们就可以将我们的知识付诸实践了。
- en: In this recipe, we will learn how to make a basic paint program that allows
    us to draw lines on a canvas with different brush sizes and colors. We will also
    learn how to use the `QImage` class and the mouse events in order to construct
    the paint program.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何制作一个基本的绘画程序，允许我们在画布上用不同的画笔大小和颜色绘制线条。我们还将学习如何使用`QImage`类和鼠标事件来构建绘画程序。
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let us start our fun project through the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开始我们有趣的项目：
- en: Again, we start by creating a new **Qt Widgets Application** project and removing
    the tool bar and status bar. We will keep the menu bar this time.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们首先创建一个新的**Qt Widgets Application**项目，并移除工具栏和状态栏。这次我们将保留菜单栏。
- en: After that, set up the menu bar like so:![How to do it…](img/B02820_03_16.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，设置菜单栏如下：![如何做…](img/B02820_03_16.jpg)
- en: 'We will leave the menu bar as it is for the moment and let''s proceed to `mainwindow.h`.
    First, include the following header files as it''s required for the project:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将暂时保留菜单栏，然后继续进行`mainwindow.h`。首先，包括以下头文件，因为它对项目是必需的：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, declare the variables that we''ll be using for this project, like so:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明我们将在此项目中使用的变量，如下所示：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, declare the event callback functions, which are inherited from the `QWidget`
    class. These functions will be triggered by Qt when the respective event happens.
    We will override these functions and tell Qt what to do when these events get
    called:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明事件回调函数，这些函数是从`QWidget`类继承的。这些函数将由Qt在相应事件发生时触发。我们将重写这些函数，并告诉Qt在这些事件被调用时该做什么：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, go to `mainwindow.cpp` and add the following code to the class
    constructor for setting up some of the variables:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，转到`mainwindow.cpp`并在类构造函数中添加以下代码以设置一些变量：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we will construct the `mousePressEvent()` event and tell Qt what to do
    when the left mouse button is pressed:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将构造`mousePressEvent()`事件并告诉Qt当左鼠标按钮被按下时该做什么：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we will construct the `mouseMoveEvent()` event and tell Qt what to do
    when the mouse is moving. In this case, we want to draw the lines on the canvas
    if the left mouse button is being held:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将构造`mouseMoveEvent()`事件并告诉Qt当鼠标移动时该做什么。在这种情况下，如果左鼠标按钮被按住，我们希望在画布上绘制线条：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After that, we will also construct the `mouseReleaseEvent()` event, which will
    be triggered when the mouse button is released:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们还将构造`mouseReleaseEvent()`事件，当鼠标按钮释放时将被触发：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once you''re done with that, we will proceed to the `paintEvent()` event, which
    is surprisingly simple compared to the other examples we have seen in previous
    sections:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将继续进行`paintEvent()`事件，与我们在之前章节中看到的其他示例相比，这个事件非常简单：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remember we have a menu bar sitting around doing nothing? Let's right-click
    on each of the actions below the GUI editor and select **Go to slot…** in the
    pop-up menu. We want to tell Qt what to do when each of these options on the menu
    bar is selected:![How to do it…](img/B02820_03_17.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住我们有一个无所事事的菜单栏吗？让我们右键单击GUI编辑器下面的每个操作，并在弹出菜单中选择**转到槽...**。我们要告诉Qt当菜单栏上的每个选项被选择时该做什么：![如何做到这一点...](img/B02820_03_17.jpg)
- en: 'Then, select the default slot called `triggered()` and press the **OK** button.
    Qt will automatically generate a new slot function in both your `mainwindow.h`
    and `mainwindow.cpp`. Once you are done with all the actions, you should see something
    like this in your `mainwindow.h`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择名为`triggered()`的默认槽，并按下**确定**按钮。Qt将自动生成一个新的槽函数，分别在你的`mainwindow.h`和`mainwindow.cpp`中。完成所有操作后，你应该在`mainwindow.h`中看到类似这样的东西：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will tell Qt what to do when each of these slots is triggered:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将告诉Qt在每个这些槽被触发时该做什么：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we compile and run the program now, we will get a simple but usable paint
    program:![How to do it…](img/B02820_03_18.jpg)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在编译并运行程序，我们将得到一个简单但可用的绘图程序：![如何做到这一点...](img/B02820_03_18.jpg)
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we created a `QImage` widget when the program started. This
    widget acts as the canvas and it will follow the size of the window whenever the
    window gets resized.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当程序启动时，我们创建了一个`QImage`小部件。这个小部件充当画布，当窗口被调整大小时，它将跟随窗口的大小。
- en: In order to draw something on the canvas, we will need to use the mouse events
    provided by Qt. These events will tell us the position of the cursor and we will
    be able to use this information to change the pixels on the canvas.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在画布上绘制东西，我们需要使用Qt提供的鼠标事件。这些事件将告诉我们光标的位置，我们将能够利用这些信息来改变画布上的像素。
- en: We use a Boolean variable called `drawing` to let the program know whether it
    should start drawing when a mouse button is pressed. In this case, when the left
    mouse button is pressed, the variable `drawing` will be set to `true`. We also
    save the current cursor position to the `lastPoint` variable when the left mouse
    button is pressed, so that Qt will know where it should start drawing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`drawing`的布尔变量来让程序知道当鼠标按钮被按下时是否应该开始绘制。在这种情况下，当左鼠标按钮被按下时，变量`drawing`将被设置为`true`。当左鼠标按钮被按下时，我们还将当前光标位置保存到`lastPoint`变量中，这样Qt就会知道从哪里开始绘制。
- en: When the mouse moves, the `mouseMoveEvent()` event will be triggered by Qt.
    This is where we need to check whether the `drawing` variable is set to `true`.
    If it is, then `QPainter` can start drawing the lines onto the `QImage` widget
    based on the brush settings that we provide.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标移动时，Qt将触发`mouseMoveEvent()`事件。这是我们需要检查`drawing`变量是否设置为`true`的地方。如果是，那么`QPainter`可以根据我们提供的画笔设置开始在`QImage`小部件上绘制线条。
- en: The brush settings consist of the brush color as well as the brush size. These
    settings are being saved as variables and can be altered by selecting a different
    setting from the menu bar.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 画笔设置包括画笔颜色和画笔大小。这些设置被保存为变量，并可以通过从菜单栏中选择不同的设置来更改。
- en: Please remember to call the `update()` function when the user is drawing on
    the canvas. Otherwise, the canvas will remain empty even though we have changed
    the pixel information of the canvas. We also have to call the `update()` function
    when we select **File** | **Clear** from the menu bar to reset our canvas.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在用户在画布上绘制时调用`update()`函数。否则，尽管我们已经改变了画布的像素信息，画布仍将保持空白。当我们从菜单栏中选择**文件** |
    **清除**时，我们还必须调用`update()`函数来重置我们的画布。
- en: In this example, we use `QImage::save()` to save the image file, which is very
    easy and straightforward. We use the file dialog to let the user decide where
    to save the image and its desired file name. Then, we pass the information to
    `QImage` and it will do the rest by itself. If we don't specify the file format
    to the `QImage::save()` function, `QImage` will try to figure it out by looking
    at the extension of the desired file name.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`QImage::save()`来保存图像文件，这非常简单和直接。我们使用文件对话框让用户决定在哪里保存图像及其所需的文件名。然后，我们将信息传递给`QImage`，它将自行完成剩下的工作。如果我们没有向`QImage::save()`函数指定文件格式，`QImage`将尝试通过查看所需文件名的扩展名来确定它。
- en: 2D canvas in QML
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的2D画布
- en: In all the previous examples of this chapter, we have discussed the methods
    and techniques used to render 2D graphics with Qt's C++ API. However, we have
    yet to learn how to achieve similar results using the powerful QML script.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有先前示例中，我们已经讨论了使用Qt的C++ API渲染2D图形的方法和技术。然而，我们还没有学习如何使用强大的QML脚本来实现类似的结果。
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this project, we''ll be do something quite different:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将做一些完全不同的事情：
- en: As usual, the first step we should do is to create a new project by going to
    **File** | **New File or Project** and selecting **Qt Quick Application** as the
    project template.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们应该首先创建一个新项目，方法是转到**文件** | **新建文件或项目**，然后选择**Qt Quick Application**作为项目模板。
- en: Once you are done creating the new project, open up `qml.qrc` from the `Resource`
    folder in the project pane by right-clicking on it and selecting **Open in Editor**.
    Then, remove `MainForm.ui.qml` from your project's resources, as we don't need
    it for this project:![How to do it…](img/B02820_03_19.jpg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新项目后，从项目窗格中的`Resource`文件夹中右键单击打开`qml.qrc`。然后，从项目资源中删除`MainForm.ui.qml`，因为我们不需要它：![如何做…](img/B02820_03_19.jpg)
- en: 'Next, open up `main.qml`, which is listed under `qml.rc` in the project pane.
    After that, remove the entire section that references `MainForm`. Now what is
    left is only the `Window` object in `main.qml`. After that, set an ID for the
    window and adjust its width and height to higher values, like so:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`qml.rc`项目窗格下列出的`main.qml`。之后，删除引用`MainForm`的整个部分。现在剩下的只有`main.qml`中的`Window`对象。之后，为窗口设置一个ID，并将其宽度和高度调整为更高的值，如下所示：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, add a `Canvas` object under `myWindow` and call it `myCanvas`. After
    that, we make its width and height the same as `myWindow`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`myWindow`下添加一个`Canvas`对象，并将其命名为`myCanvas`。之后，将其宽度和高度设置为与`myWindow`相同：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we define what will happen when the `onPaint` event is triggered; in
    this case, we will draw a cross on the window:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`onPaint`事件触发时会发生什么；在这种情况下，我们将在窗口上绘制一个十字架：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After that, we add the following code to draw a tick besides the cross:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加以下代码以在十字架旁边绘制一个勾号：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, draw a triangle shape by adding the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过添加以下代码来绘制一个三角形形状：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After that, draw a half circle and a full circle with the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用以下代码绘制一个半圆和一个完整的圆：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we draw a 2D image from a file:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从文件中绘制一个2D图像：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, the preceding code alone will not successfully render an image on
    screen because you must also load the image file beforehand. Add the following
    code within the `Canvas` object to ask QML to load the image file when the program
    is started, then call the `requestPaint()` signal when the image is loaded so
    that the `onPaint()` event slot will be triggered:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，仅仅使用上述代码将无法成功在屏幕上渲染图像，因为您还必须预先加载图像文件。在`Canvas`对象内添加以下代码，以便在程序启动时要求QML加载图像文件，然后在图像加载时调用`requestPaint()`信号，以便触发`onPaint()`事件槽：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Build and run the program now and you should get the following result:![How
    to do it…](img/B02820_03_20.jpg)
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建并运行程序，您应该会得到以下结果：![如何做…](img/B02820_03_20.jpg)
