- en: '*Chapter 11*: Handling Exceptions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：处理异常'
- en: This chapter will begin our quest to expand your C++ programming repertoire
    beyond OOP concepts, with the goal of enabling you to write more robust and extensible
    code. We will begin this endeavor by exploring exception handling in C++. Adding
    language-prescribed methods in our code to handle errors will allow us to achieve
    less buggy and more reliable programs. By using the formal exception handling
    mechanisms *built into the language*, we can achieve uniform handling of errors,
    which leads to more easily maintainable code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始我们的探索，扩展你的C++编程技能，超越面向对象编程的概念，目标是让你能够编写更健壮、更可扩展的代码。我们将通过探索C++中的异常处理来开始这个努力。在我们的代码中添加语言规定的方法来处理错误，将使我们能够实现更少的错误和更可靠的程序。通过使用语言内置的正式异常处理机制，我们可以实现对错误的统一处理，从而实现更易于维护的代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding exception handling basics—`try`, `throw`, and `catch`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异常处理的基础知识——`try`、`throw`和`catch`
- en: Exploring exception handling mechanics—trying code that may raise exceptions,
    raising (throwing), catching, and handling exceptions using several variations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异常处理机制——尝试可能引发异常的代码，引发（抛出）、捕获和处理异常，使用多种变体
- en: Utilizing exception hierarchies with standard exception objects or by creating
    customized exception classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用标准异常对象或创建自定义异常类的异常层次结构
- en: By the end of this chapter, you will understand how to utilize exception handling
    in C++. You will see how to identify an error to raise an exception, transfer
    control of the program to a designated area by throwing an exception, and then
    handle the error by catching the exception and hopefully repairing the problem
    at hand.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，你将了解如何在C++中利用异常处理。你将看到如何识别错误以引发异常，通过抛出异常将程序控制转移到指定区域，然后通过捕获异常来处理错误，并希望修复手头的问题。
- en: You will also learn how to utilize standard exceptions from the C++ Standard
    Library, as well as how to create customized exception objects. A hierarchy of
    exception classes can be designed to add robust error detection and handling capabilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何利用C++标准库中的标准异常，以及如何创建自定义异常对象。可以设计一组异常类的层次结构，以增加健壮的错误检测和处理能力。
- en: Let's increase our understanding of C++ by expanding our programming repertoire
    by exploring the built-in language mechanisms of exception handling.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索内置的语言异常处理机制，扩展我们对C++的理解。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds with the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter11` in a file named `Chp11-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，文件名与所在章节编号相对应，后跟该章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp11-Ex1.cpp`的文件中的子目录`Chapter11`中找到，位于上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3r8LHd5](https://bit.ly/3r8LHd5).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/3r8LHd5](https://bit.ly/3r8LHd5)。
- en: Understanding exception handling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异常处理
- en: Error conditions may occur within an application that would prevent a program
    from continuing correctly. Such error conditions may include data values that
    exceed application limits, necessary input files or databases that have become
    unavailable, heap memory that has become exhausted, or any other imaginable issue.
    C++ exceptions provide a uniform, language-supported manner in which to handle
    program anomalies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中可能会出现错误条件，这些错误条件可能会阻止程序正确地继续运行。这些错误条件可能包括超出应用程序限制的数据值、必要的输入文件或数据库不可用、堆内存耗尽，或者任何其他可能的问题。C++异常提供了一种统一的、语言支持的方式来处理程序异常。
- en: Prior to the introduction of language-supported exception handling mechanisms,
    each programmer would handle errors in their own manner, and sometimes not at
    all. Program errors and exceptions that are not handled imply that somewhere further
    in the application, an unexpected result will occur and the application will most
    often terminate abnormally. These potential outcomes are certainly undesirable!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入语言支持的异常处理机制之前，每个程序员都会以自己的方式处理错误，有时甚至根本不处理。程序错误和未处理的异常意味着在应用程序的其他地方，将会发生意外的结果，应用程序往往会异常终止。这些潜在的结果肯定是不可取的！
- en: C++ **exception handling** provides a language-supported mechanism to detect
    and correct program anomalies so that an application can remain running, rather
    than ending abruptly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++异常处理提供了一种语言支持的机制，用于检测和纠正程序异常，使应用程序能够继续运行，而不是突然结束。
- en: Let's take a look at the mechanics, starting with the language-supported keywords
    `try`, `throw`, and `catch`, which comprise exception handling in C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从语言支持的关键字`try`、`throw`和`catch`开始，来看一下这些机制，它们构成了C++中的异常处理。
- en: Utilizing exception handling with try, throw, and catch
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用try、throw和catch进行异常处理
- en: '**Exception handling** detects a program anomaly, as defined by the programmer
    or by a class library, and passes control to another portion of the application
    where the specific problem may be handled. Only as a last resort will it be necessary
    to exit an application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常处理**检测到程序异常，由程序员或类库定义，并将控制传递到应用程序的另一个部分，该部分可能处理特定的问题。只有作为最后的手段，才需要退出应用程序。'
- en: 'Let''s begin by taking a look at the keywords that support exception handling.
    The keywords are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下支持异常处理的关键字。这些关键字是：
- en: '`try`: Allows programmers to *try* a portion of code that might cause an exception.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`：允许程序员*尝试*可能引发异常的代码部分。'
- en: '`throw`: Once an error is found, `throw` raises the exception. This will cause
    a jump to the catch block below the associated try block. Throw will allow an
    argument to be returned to the associated catch block. The argument thrown may
    be of any standard or user defined type.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`：一旦发现错误，`throw`会引发异常。这将导致跳转到与关联try块下面的catch块。Throw将允许将参数返回到关联的catch块。抛出的参数可以是任何标准或用户定义的类型。'
- en: '`catch`: Designates a block of code designed to seek exceptions that have been
    thrown, to attempt to correct the situation. Each catch block in the same scope
    will handle an exception of a different type.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`：指定一个代码块，旨在寻找已抛出的异常，以尝试纠正情况。同一作用域中的每个catch块将处理不同类型的异常。'
- en: When utilizing exception handling, it is useful to review the idea of backtracking.
    When a sequence of functions is called, we build up, on the stack, state information
    applicable to each successive function call (parameters, local variables, and
    return value space), as well as the return address for each function. When an
    exception is thrown, we may need to unwind the stack to the point of origination
    where this sequence of function calls (or try blocks) began, resetting the stack
    pointer as well. This process is known as **backtracking** and allows a program
    to return to an earlier sequence in the code. Backtracking applies not only to
    function calls but to nested blocks including nested try blocks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用异常处理时，回溯的概念是有用的。当调用一系列函数时，我们在堆栈上建立起与每个连续函数调用相关的状态信息（参数、局部变量和返回值空间），以及每个函数的返回地址。当抛出异常时，我们可能需要解开堆栈，直到这个函数调用序列（或try块）开始的原点，同时重置堆栈指针。这个过程被称为**回溯**，它允许程序返回到代码中的较早序列。回溯不仅适用于函数调用，还适用于包括嵌套try块在内的嵌套块。
- en: 'Here is a simple example to illustrate basic exception handling syntax and
    usage. Though portions of the code are not shown to save space, the complete example
    can be found in our GitHub as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，用来说明基本的异常处理语法和用法。尽管代码的部分没有显示出来以节省空间，但完整的示例可以在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex1.cpp)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code fragment, we can see the keywords `try`, `throw`, and `catch`
    in action. First, let's notice the `Student::Validate()` member function. Imagine,
    in this virtual method, we verify that a `Student` meets admission standards.
    If so, the function ends normally. If not, an exception is thrown. In this example,
    a simple `const char *` is thrown containing the message "`Does not meet prerequisites`".
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们可以看到关键字`try`、`throw`和`catch`的作用。首先，让我们注意`Student::Validate()`成员函数。想象一下，在这个虚方法中，我们验证一个`Student`是否符合入学标准。如果是，函数会正常结束。如果不是，就会抛出异常。在这个例子中，抛出一个简单的`const
    char *`，其中包含消息"`Does not meet prerequisites`"。
- en: In our `main()` function, we first instantiate a `Student`, namely `s1`. Then,
    we nest our call to `s1.Validate()` within a try block. We are literally saying
    that we'd like to *try* this block of code. Should `Student::Validate()` work
    as expected, error-free, our program completes the try block, skips the catch
    block(s) below the try block, and merely continues with the code below any catch
    blocks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们首先实例化一个`Student`，即`s1`。然后，我们将对`s1.Validate()`的调用嵌套在一个try块中。我们实际上是在说，我们想*尝试*这个代码块。如果`Student::Validate()`按预期工作，没有错误，我们的程序将完成try块，跳过try块下面的catch块，并继续执行catch块下面的代码。
- en: However, should `Student::Validate()` throw an exception, we will skip any remaining
    code in our try block and seek an exception matching the type of `const char *`
    in a subsequently defined catch block. Here, in the matching catch block, our
    goal is to correct the error if at all possible. If we are successful, our program
    will continue with the code below the catcher. If not, our job is to end the program
    gracefully.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`Student::Validate()`抛出异常，我们将跳过try块中的任何剩余代码，并在随后定义的catch块中寻找与`const char
    *`类型匹配的异常。在匹配的catch块中，我们的目标是尽可能地纠正错误。如果成功，我们的程序将继续执行catch块下面的代码。如果不成功，我们的工作就是优雅地结束程序。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下上述程序的输出：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let ''s summarize the overall flow of exception handling with the following
    logistics:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们总结一下异常处理的整体流程，具体如下：
- en: When a program completes a try block without encountering any thrown exceptions,
    the code sequence continues with the statement following the catch block. Multiple
    catch blocks (with different argument types) may follow a try block.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序完成try块而没有遇到任何抛出的异常时，代码序列将继续执行catch块后面的语句。多个catch块（带有不同的参数类型）可以跟在try块后面。
- en: When an exception is thrown, the program must backtrack and return to the try
    block containing the originating function call. The program may have to backtrack
    past multiple functions. When backtracking occurs, the objects encountered on
    the stack will be popped off, and hence destructed.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当抛出异常时，程序必须回溯并返回到包含原始函数调用的try块。程序可能需要回溯多个函数。当回溯发生时，遇到的对象将从堆栈中弹出，因此被销毁。
- en: Once a program (with an exception raised) backtracks to the function where the
    try block was executed, the program will continue with the catch block (following
    the try block) whose signature matches the type of the exception that was thrown.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦程序（引发异常）回溯到执行try块的函数，程序将继续执行与抛出的异常类型匹配的catch块（在try块之后）。
- en: Type conversion (with the exception of upcasting objects related through public
    inheritance) will not be done to match potential catch blocks. However, a catch
    block with ellipses (`…`) may be used as the most general type of catch block
    and can catch any type of exception.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换（除了通过公共继承相关的向上转型对象）不会被执行以匹配潜在的catch块。然而，带有省略号（`…`）的catch块可以作为最一般类型的catch块使用，并且可以捕获任何类型的异常。
- en: If a matching `catch` block does not exist, the program will call `terminate()`,
    from the C++ Standard Library. Note that `terminate()` will call `abort()`, however,
    the programmer may instead register another function for `terminate()` to call
    via the `set_terminate()` function.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不存在匹配的`catch`块，程序将调用C++标准库中的`terminate()`。请注意，`terminate()`将调用`abort()`，但程序员可以通过`set_terminate()`函数注册另一个函数供`terminate()`调用。
- en: 'Now, let''s see how to register a function with `set_terminate()`. Though we
    only show key portions of the code here, the complete program can be found in
    our GitHub:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`set_terminate()`注册一个函数。虽然我们这里只展示了代码的关键部分，完整的程序可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex2.cpp)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code fragment, we define our own `AppSpecificTerminate()` function.
    This is the function we wish to have the `terminate()` function call rather than
    its default behavior of calling `abort()`. Perhaps we use `AppSpecificTerminate()`
    to end our application a bit more gracefully, saving key data structures or database
    values. Of course, we would also then `exit()` (or `abort()`) ourselves.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了自己的`AppSpecificTerminate()`函数。这是我们希望`terminate()`函数调用的函数，而不是调用`abort()`的默认行为。也许我们使用`AppSpecificTerminate()`来更优雅地结束我们的应用程序，保存关键数据结构或数据库值。当然，我们也会自己`exit()`（或`abort()`）。
- en: In `main()`, we merely call `set_terminate(AppSpecificTerminate)` to register
    our `terminate` function with `set_terminate()`. Now, when `abort()` would otherwise
    be called, our function will be called instead.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们只需调用`set_terminate(AppSpecificTerminate)`来注册我们的`terminate`函数到`set_terminate()`。现在，当否则会调用`abort()`时，我们的函数将被调用。
- en: It is interesting to note that `set_terminate()` returns a function pointer
    to the previously installed `terminate_handler` (which upon its first call will
    be a pointer to `abort()`). Should we choose to save this value, we can use it
    to reinstate previously registered terminate handlers. Notice that we have not
    opted to save this function pointer in this example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`set_terminate()`返回一个指向先前安装的`terminate_handler`的函数指针（在第一次调用时将是指向`abort()`的指针）。如果我们选择保存这个值，我们可以使用它来恢复先前注册的终止处理程序。请注意，在这个示例中，我们选择不保存这个函数指针。
- en: 'Here is what the output would look like for an uncaught exception using the
    aforementioned code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用上述代码未捕获异常的输出：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that functions such as `terminate()`, `abort()`, and `set_terminate()`
    are from the Standard Library. Though we may precede their names with the library
    name using the scope resolution operator, such as `std::terminate()`, this is
    not necessary.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，诸如`terminate()`、`abort()`和`set_terminate()`之类的函数来自标准库。虽然我们可以使用作用域解析运算符在它们的名称前加上库名称，比如`std::terminate()`，但这并非必需。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Exception handling is not meant to take the place of simple programmer error
    checking; exception handling has greater overhead. Exception handling should be
    reserved for handling more severe programmatic errors in a uniform manner and
    in a common location.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理并不意味着取代简单的程序员错误检查；异常处理的开销更大。异常处理应该保留用于以统一方式和在一个公共位置处理更严重的程序错误。
- en: Now that we have seen the basic mechanics of exception handling, let's take
    a look at slightly more complex exception handling examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了异常处理的基本机制，让我们来看一些稍微复杂的异常处理示例。
- en: Exploring exception handling mechanics with typical variations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索异常处理机制及典型变化
- en: Exception handling can be more sophisticated and flexible than the basic mechanics
    previously illustrated. Let's take a look at various combinations and variations
    of exception handling basics, as each may be applicable to different programming
    situations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可以比之前所示的基本机制更加复杂和灵活。让我们来看看异常处理基础的各种组合和变化，因为每种情况可能适用于不同的编程情况。
- en: Passing exceptions to outer handlers
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将异常传递给外部处理程序
- en: Caught exceptions may be passed up to outer handlers for processing. Alternatively,
    exceptions may be partially handled and then thrown to outer scopes for further
    handling.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获的异常可以传递给外部处理程序进行处理。或者，异常可以部分处理，然后抛出到外部范围进行进一步处理。
- en: 'Let''s build on our previous example to demonstrate this principle. The full
    program can be seen at the following GitHub location:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前的示例基础上演示这个原则。完整的程序可以在以下GitHub位置看到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex3.cpp)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code, let's assume that we have our usual header files
    included and the usual class definition for `Student` defined. We will now augment
    the `Student` class by adding the `Student::Validate()` method (virtual, so that
    it may be overridden) and the `Student::TakePrerequisites()` method (not virtual,
    descendants should use it as-is).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，假设我们已经包含了我们通常的头文件，并且已经定义了`Student`的通常类定义。现在我们将通过添加`Student::Validate()`方法（虚拟的，以便可以被覆盖）和`Student::TakePrerequisites()`方法（非虚拟的，后代应该按原样使用）来增强`Student`类。
- en: Notice that our `Student::Validate()` method throws an exception, which is merely
    a string literal containing a message indicating the issue at hand. We can imagine
    the complete implementation of the `Student::TakePrerequisites()` method verifies
    that the `Student` has met the appropriate prerequisites, and returns a Boolean
    value of `true` or `false` accordingly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的`Student::Validate()`方法抛出一个异常，这只是一个包含指示问题的消息的字符串字面量。我们可以想象`Student::TakePrerequisites()`方法的完整实现验证了`Student`是否满足适当的先决条件，并根据情况返回`true`或`false`的布尔值。
- en: In our `main()` function, we now notice a set of nested try blocks. The purpose
    here is to illustrate an inner try block that may call a method, such as `s1.Validate()`,
    which may raise an exception. Notice that the same level handler as the inner
    try block catches this exception. It is ideal that an exception is handled at
    the level equal to the try block from which it originates, so let's assume that
    the catcher in this scope tries to do so. For example, our innermost catch block
    presumably tries to correct the error and tests whether the correction has been
    made using a call to `s1.TakePrerequisites()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们现在注意到一组嵌套的try块。这里的目的是说明一个内部try块可能调用一个方法，比如`s1.Validate()`，这可能会引发异常。注意到与内部try块相同级别的处理程序捕获了这个异常。理想情况下，异常应该在与其来源的try块相等的级别上处理，所以让我们假设这个范围内的捕获器试图这样做。例如，我们最内层的catch块可能试图纠正错误，并通过调用`s1.TakePrerequisites()`来测试是否已经进行了纠正。
- en: But perhaps this catcher is only able to process the exception partially. Perhaps
    there is the knowledge that an outer-level handler knows how to do the remaining
    corrections. In such cases, it is acceptable to re-throw this exception to an
    outer (nested) level. Our simple `throw;` statement in the innermost catch block
    does just this. Notice that there is a catcher at the outer level. Should the
    thrown exception match, type-wise, this outer level will now have the opportunity
    to further handle the exception and hopefully correct the problem so that the
    application can continue. Only if this outer catch block is unable to correct
    the error, the application should be exited. In our example, each catcher prints
    out the string representing the error message; hence this message occurs twice
    in the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许这个捕获器只能部分处理异常。也许有一个外层处理程序知道如何进行剩余的修正。在这种情况下，将这个异常重新抛出到外层（嵌套）级别是可以接受的。我们在最内层的catch块中的简单的`throw;`语句就是这样做的。注意外层有一个捕获器。如果抛出的异常与外层的类型匹配，现在外层就有机会进一步处理异常，并希望纠正问题，以便应用程序可以继续。只有当这个外部catch块无法纠正错误时，应用程序才应该退出。在我们的例子中，每个捕获器都打印表示错误消息的字符串；因此这条消息在输出中出现了两次。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have seen how to use nested try and catch blocks, let us move forward
    to see how a variety of thrown types and a variety of catch blocks can be used
    together.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用嵌套的try和catch块，让我们继续看看如何一起使用各种抛出类型和各种catch块。
- en: Adding an assortment of handlers
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加各种处理程序
- en: Sometimes, a variety of exceptions may be raised from an inner scope, creating
    the necessity to craft handlers for a variety of data types. Exception handlers
    (that is, catch blocks) can receive an exception of any data type. We can minimize
    the number of catchers we introduce by utilizing catch blocks with base class
    types; we know that derived class objects (related through public inheritance)
    can always be up-cast to their base class type. We can also use the ellipses (`…`)
    in a catch block to allow us to catch anything not previously specified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，内部范围可能会引发各种异常，从而需要为各种数据类型制定处理程序。异常处理程序（即catch块）可以接收任何数据类型的异常。我们可以通过使用基类类型的catch块来最小化引入的捕获器数量；我们知道派生类对象（通过公共继承相关）总是可以向上转换为它们的基类类型。我们还可以在catch块中使用省略号（`…`）来允许我们捕获以前未指定的任何东西。
- en: 'Let''s build on our initial example to illustrate assorted handlers in action.
    Though abbreviated, our full program example can be found in our GitHub as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的初始示例上建立，以说明各种处理程序的操作。虽然缩写，但我们完整的程序示例可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex4.cpp)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the aforementioned segment of code, we first examine the `Student::Graduate()`
    member function. Here, we can imagine that this method runs through many graduation
    requirements, and as such, can potentially raise a variety of different types
    of exceptions. For example, should the `Student` instance have too low of a `gpa`,
    a float is thrown as the exception, indicating the student's poor `gpa`. Should
    the `Student` have too few credits, an integer is thrown, indicating how many
    credits the `Student` still needs to earn their degree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码段中，我们首先检查了`Student::Graduate()`成员函数。在这里，我们可以想象这个方法通过许多毕业要求，并且因此可能引发各种不同类型的异常。例如，如果`Student`实例的`gpa`太低，就会抛出一个浮点数作为异常，指示学生的`gpa`太低。如果`Student`的学分太少，就会抛出一个整数，指示学生还需要多少学分才能获得学位。
- en: Perhaps the most interesting potential error `Student::Graduate()` might raise
    would be if a required `Course` is missing from a student's graduation requirements.
    In this scenario, `Student::Graduate()` would allocate a new `Course` object,
    filling it with the `Course` name and number via construction. Next, the pointer
    to the `Course` is dereferenced and the object is thrown by reference. The handler
    may then catch this object by reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也许`Student::Graduate()`可能引发的最有趣的潜在错误是，如果学生的毕业要求中缺少了一个必需的`Course`。在这种情况下，`Student::Graduate()`将分配一个新的`Course`对象，通过构造函数填充`Course`的名称和编号。接下来，`Course`的指针被解引用，并且对象被引用抛出。处理程序随后可以通过引用捕获这个对象。
- en: In the `main()` function, we merely wrap the call to `Student::Graduate()` within
    a try block, as this statement may raise an exception. A sequence of catchers
    follows the try block – one `catch` statement per type of object that may be thrown.
    The last catch block in this sequence uses ellipses (`…`), indicating that this
    catcher will handle any other type of exception thrown by `Student::Graduate()`,
    which has not been caught by the other catchers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们只是在try块中包装了对`Student::Graduate()`的调用，因为这个语句可能会引发异常。接着try块后面是一系列的catch块
    - 每种可能被抛出的对象类型对应一个`catch`语句。在这个序列中的最后一个catch块使用省略号(`…`)，表示这个catch块将处理`Student::Graduate()`抛出的任何其他类型的异常，这些异常没有被其他catch块捕获到。
- en: The catch block that is actually engaged is the one in which a `Course` is caught
    using `const Course &err`. With the `const` qualifier, we may not modify the `Course`
    in the handler, so we may only apply `const` member functions to this object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上被激活的catch块是使用`const Course &err`捕获`Course`的那个。有了`const`限定符，我们不能在处理程序中修改`Course`，所以我们只能对这个对象应用`const`成员函数。
- en: Note that though each catcher shown above merely prints out an error and then
    exits, ideally, a catcher would try to correct the error so that the application
    would not need to terminate, allowing code below the catch blocks to continue
    onward.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管上面显示的每个catch块只是简单地打印出错误然后退出，但理想情况下，catch块应该尝试纠正错误，这样应用程序就不需要终止，允许在catch块下面的代码继续执行。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have seen a variety of thrown types and a variety of catch blocks,
    let us move forward to understand what we should group together within a single
    try block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了各种抛出的类型和各种catch块，让我们继续向前了解在单个try块中应该将什么内容分组在一起。
- en: Grouping together dependent items within a try block
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在try块中分组相关的项目
- en: It is important to remember that when a line of code in a try block encounters
    an exception, the remainder of the try block is ignored. Instead, the program
    continues with a matching catcher (or calls `terminate()` if no suitable catcher
    exists). Then, if the error is repaired, the code beyond the catcher commences.
    Note that we never return to complete the remainder of the initial try block.
    The implication of this behavior is that you should only group together elements
    within a try block that go together. That is, if one item causes an exception,
    it is no longer important to complete the other item in that grouping.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当try块中的一行代码遇到异常时，try块的其余部分将被忽略。相反，程序将继续执行匹配的catch块（或者如果没有合适的catch块存在，则调用`terminate()`）。然后，如果错误被修复，catch块之后的代码将开始执行。请注意，我们永远不会返回来完成初始try块的其余部分。这种行为的含义是，你应该只在try块中将一起的元素分组在一起。也就是说，如果一个项目引发异常，完成该分组中的其他项目就不再重要了。
- en: 'Keep in mind that the goal of a catcher is to correct an error if at all possible.
    This means that the program may continue forward after the applicable catch block.
    You may ask: Is it now acceptable that an item was skipped in the associated try
    block? Should the answer be no, then rewrite your code. For example, you may want
    to add a loop around the `try`-`catch` grouping such that if an error is corrected
    by a catcher, the whole enterprise is retried starting with the initial try block.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，catch块的目标是尽可能纠正错误。这意味着在适用的catch块之后，程序可能会继续向前。你可能会问：现在跳过了与try块相关的项目是否可以接受？如果答案是否定的，那么请重写你的代码。例如，你可能想在`try`-`catch`分组周围添加一个循环，这样如果catch块纠正了错误，整个企业就会重新开始，从初始的try块开始重试。
- en: Alternatively, make smaller, successive `try`-`catch` groupings. That is, *try*
    only one important task in its own try block (followed by applicable catchers).
    Then *try* the next task in its own try block with its associated catchers and
    so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将较小的、连续的`try`-`catch`分组。也就是说，*try*只在自己的try块中尝试一个重要的任务（后面跟着适用的catch块）。然后在自己的try块中尝试下一个任务，后面跟着适用的catch块，依此类推。
- en: Next, let's take a look at a way to include in a function's prototype the type
    of exceptions it may throw.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一种在函数原型中包含它可能抛出的异常类型的方法。
- en: Examining exception specifications in function prototypes
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查函数原型中的异常规范
- en: We can optionally specify the types of exceptions a C++ function may throw by
    extending the signature of that function to include the object types of what may
    be thrown. However, because a function may throw more than one type of exception
    (or none at all), checking which type is actually thrown must be done at run time.
    For this reason, these augmented specifiers in the function prototype are also
    known as **dynamic exception specifications**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展函数的签名来可选地指定C++函数可能抛出的异常类型，包括可能被抛出的对象类型。然而，因为一个函数可能抛出多种类型的异常（或者根本不抛出异常），所以必须在运行时检查实际抛出的类型。因此，函数原型中的这些增强规范也被称为**动态异常规范**。
- en: 'Let''s see an example using exception types in the extended signature of a
    function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在函数的扩展签名中使用异常类型的例子：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the aforementioned code fragment, we see two member functions of `Student`.
    `Student::Graduate()` includes the `throw` keyword after its parameter list and
    then, as part of this method's extended signature, includes the types of objects
    that may be thrown from this function. Notice that the `Student::Enroll()` method
    merely has an empty list following `throw()` in its extended signature. This means
    that `Student::Enroll()` might throw any type of exception.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们看到了`Student`的两个成员函数。`Student::Graduate()`在其参数列表后包含`throw`关键字，然后作为该方法的扩展签名的一部分，包含了可能从该函数中抛出的对象类型。请注意，`Student::Enroll()`方法在其扩展签名中仅在`throw()`后面有一个空列表。这意味着`Student::Enroll()`可能抛出任何类型的异常。
- en: In both cases, by adding the `throw()` keyword, with optional data types, to
    the signature, we are providing a means to announce to the user of this function
    what types of objects might be thrown. We are then asking programmers to include
    any calls to this method within a try block followed by appropriate catchers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，通过在签名中添加`throw()`关键字和可选的数据类型，我们提供了一种向该函数的用户宣布可能被抛出的对象类型的方法。然后我们要求程序员在try块中包含对该方法的任何调用，然后跟上适当的catcher。
- en: We will see that, though the idea of an extended signature seems very helpful,
    it has unfavorable issues in practice. For this reason, dynamic exception specifications
    have been *deprecated*. Because you may still see these specifications used in
    existing code, including Standard Library prototypes (such as with exceptions),
    this deprecated feature is still supported by compilers, and you will need to
    understand their usage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，尽管扩展签名的想法似乎非常有帮助，但在实践中存在不利问题。因此，动态异常规范已被*弃用*。因为您可能仍然会在现有代码中看到这些规范的使用，包括标准库原型（如异常），编译器仍然支持这个已弃用的特性，您需要了解它们的用法。
- en: 'Though dynamic exceptions (extended function signatures as previously described)
    have been deprecated, a specifier with a similar purpose has been added to the
    language, the `noexcept` keyword. This specifier can be added after the extended
    signature as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管动态异常（如前所述的扩展函数签名）已被弃用，但语言中已添加了具有类似目的的指定符号`noexcept`关键字。此指定符号可以在扩展签名之后添加如下：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nonetheless, let's investigate why unfavorable issues exist relating to dynamic
    exceptions by looking at what happens when our application throws exceptions that
    are not part of a function's extended signature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们调查一下为什么与动态异常相关的不利问题存在，看看当我们的应用程序抛出不属于函数扩展签名的异常时会发生什么。
- en: Dealing with unexpected types of dynamic exceptions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理意外类型的动态异常
- en: Should an exception be thrown of a type other than that which is specified in
    the extended function prototype, `unexpected()`, from the C++ Standard Library,
    will be called. You can register your own function with `unexpected()`, much as
    we registered our own function with `set_terminate()` earlier in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在扩展函数原型中指定的类型之外抛出了异常，C++标准库中的`unexpected()`将被调用。您可以像我们在本章前面注册`set_terminate()`时那样，注册自己的函数到`unexpected()`。
- en: You can allow your `AppSpecificUnexpected()` function to re-throw an exception
    of the type that the originating function should have thrown, however, if that
    does not occur, `terminate()` will then be called. Furthermore, if no possible
    matching catcher exists to handle what is correctly thrown from the originating
    function (or re-thrown by your `AppSpecificUnexpected()`), then `terminate()`
    will be called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以允许您的`AppSpecificUnexpected()`函数重新抛出应该由原始函数抛出的异常类型，但是如果没有发生这种情况，将会调用`terminate()`。此外，如果没有可能匹配的catcher存在来处理从原始函数正确抛出的内容（或者由您的`AppSpecificUnexpected()`重新抛出），那么将调用`terminate()`。
- en: 'Let''s see how to `set_unexpected()` with our own function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用我们自己的函数`set_unexpected()`：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Registering our own function with `set_unexpected()` is very simple, as illustrated
    in the aforementioned code fragment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注册我们自己的函数到`set_unexpected()`非常简单，就像前面章节中所示的代码片段一样。
- en: Historically, one motivating reason for employing an exception specification
    in a function's extended signature was to provide a documentative effect. That
    is, you could see which exceptions a function might possibly throw simply by examining
    its signature. You could then plan to enclose that function call within a try
    block and provide appropriate catchers to handle any potential situation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，在函数的扩展签名中使用异常规范的一个激励原因是提供文档效果。也就是说，您可以通过检查其签名来看到函数可能抛出的异常，然后计划在try块中封装该函数调用，并提供适当的catcher来处理任何潜在情况。
- en: Nonetheless, regarding dynamic exceptions, it is useful to note that compilers
    do not check that the types of exceptions *actually* thrown in a function body
    match the types specified in the function's extended signature. It is up to the
    programmer to ensure that they are in sync. Hence, this deprecated feature can
    be error-prone and, overall, less useful than its original intention.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于动态异常，值得注意的是编译器不会检查函数体中实际抛出的异常类型是否与函数扩展签名中指定的类型匹配。这取决于程序员来确保它们同步。因此，这个已弃用的特性可能容易出错，总体上比其原始意图更少用。
- en: Though well intended, dynamic exceptions are currently unused, except in large
    quantities of library code, such as the C++ Standard Library. Since you will inevitably
    utilize these libraries, it is important to understand these anachronisms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管初衷良好，动态异常目前未被使用，除了在大量的库代码中，比如C++标准库。由于您将不可避免地使用这些库，了解这些过时的特性非常重要。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamic exception specifications (that is, the ability to specify exception
    types in a method's extended signature) have been *deprecated* in C++. This is
    because compilers are not able to validate their use, which must then be delayed
    until run time. Their use, though still supported (many libraries have such specifications),
    is now deprecated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，动态异常规范（即在方法的扩展签名中指定异常类型的能力）已经被*弃用*。这是因为编译器无法验证它们的使用，必须延迟到运行时。尽管它们仍然受支持（许多库具有这种规范），但现在已经被弃用。
- en: Now that we have seen an assortment of exception handling detection, raising,
    catching, and (hopefully) correction schemes, let's take a look at how we might
    create a hierarchy of exception classes to add sophistication to our error handling
    abilities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一系列异常处理检测、引发、捕获和（希望）纠正方案，让我们看看如何创建一系列异常类的层次结构，以增强我们的错误处理能力。
- en: Utilizing exception hierarchies
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用异常层次结构
- en: Creating a class to encapsulate the details relating to a program error seems
    like a useful endeavor. In fact, the C++ Standard Library has created one such
    generic class, `exception`, to provide the basis for building an entire hierarchy
    of useful exception classes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类来封装与程序错误相关的细节似乎是一个有用的努力。事实上，C++标准库已经创建了一个这样的通用类，`exception`，为构建整个有用的异常类层次结构提供了基础。
- en: Let's take a look at the `exception` class with its Standard Library descendants,
    and then how we may extend `exception` with our own classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看带有其标准库后代的`exception`类，然后看看我们如何用自己的类扩展`exception`。
- en: Using standard exception objects
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准异常对象
- en: 'The `<exception>` header. The `exception` class includes a virtual function
    with the following signature: `virtual const char *what() const throw()`. This
    signature indicates that derived classes should redefine `what()` to return a
    `const char *` with a description of the error at hand. The `const` keyword after
    `what()` indicates that this is a `const` member function; it will not change
    any members of the derived class. The `throw()` in the extended signature indicates
    that this function may throw any type. The usage of `throw()` in the signature
    is a deprecated anachronism.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`<exception>`头文件。`exception`类包括一个带有以下签名的虚函数：`virtual const char *what() const
    throw()`。这个签名表明派生类应该重新定义`what()`，返回一个描述手头错误的`const char *`。`what()`后面的`const`关键字表示这是一个`const`成员函数；它不会改变派生类的任何成员。扩展签名中的`throw()`表示这个函数可能抛出任何类型。在签名中使用`throw()`是一个已弃用的陈词滥调。'
- en: The `std::exception` class is the base class of a variety of pre-defined C++
    exception classes, including `bad_alloc`, `bad_cast`, `bad_exception`, `bad_function_call`,
    `bad_typeid`, `bad_weak_ptr`, `logic_error`, `runtime_error`, and nested class
    `ios_base::failure`. Many of these derived classes have descendants themselves,
    adding additional standard exceptions to the predefined hierarchy of exceptions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::exception`类是各种预定义的C++异常类的基类，包括`bad_alloc`、`bad_cast`、`bad_exception`、`bad_function_call`、`bad_typeid`、`bad_weak_ptr`、`logic_error`、`runtime_error`和嵌套类`ios_base::failure`。这些派生类中的许多都有自己的后代，为预定义的异常层次结构添加了额外的标准异常。'
- en: Should a function throw any of the aforementioned exceptions, these exceptions
    may be caught by either catching the base class type, `exception`, or by catching
    an individual derived class type. Depending on what course of action your handler
    will take, you can decide whether you wish to catch one such exception as its
    generalized base class type or as its specific type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数抛出了上述任何异常，这些异常可以通过捕获基类类型`exception`或捕获单个派生类类型来捕获。根据处理程序将采取的行动，您可以决定是否希望将这样的异常作为其广义基类类型或特定类型捕获。
- en: Just as the Standard Library has set up a hierarchy of classes based on the
    `exception` class, so may you. Let's next take a look at how we might do just
    this!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准库基于`exception`类建立了一系列类的层次结构一样，你也可以。接下来让我们看看我们可能如何做到这一点！
- en: Creating customized exception classes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义异常类
- en: As a programmer, you may decide that it is advantageous to establish your own
    specialized exception types. Each type can pack useful information into an object
    detailing just what went wrong with the application. Additionally, you may be
    able to pack clues into the object (that will be thrown) as to how to correct
    the error at hand. Simply derive your class from the Standard `exception` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，您可能会认为建立自己的专门异常类型是有利的。每种类型可以将有用的信息打包到一个对象中，详细说明应用程序出了什么问题。此外，您可能还可以将线索打包到（将被抛出的）对象中，以指导如何纠正手头的错误。只需从标准`exception`类派生您的类。
- en: 'Let''s take a look at how easily this may be done by examining the critical
    portions of our next example, which can be found as a full program in our GitHub:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查我们下一个示例的关键部分来看看这是如何轻松实现的，完整的程序可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex5.cpp)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex5.cpp)'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's take a few minutes to examine the previous segment of code. Foremost,
    notice that we define our own exception class, `StudentException`. It is a derived
    class from the C++ Standard Library `exception` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟来检查前面的代码段。首先，注意我们定义了自己的异常类，`StudentException`。它是从C++标准库`exception`类派生的类。
- en: The `StudentException` class contains data members to hold an error code as
    well as alphanumeric details describing the error condition using data members
    `errCode` and `details`, respectively. We have two simple access functions, `StudentException`
    `::GetCode()` and `StudentException::GetDetails()`, to easily retrieve these values.
    As these methods do not modify the object, they are `const` member functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`StudentException`类包含数据成员来保存错误代码以及使用数据成员`errCode`和`details`描述错误条件的字母数字细节。我们有两个简单的访问函数，`StudentException::GetCode()`和`StudentException::GetDetails()`，可以轻松地检索这些值。由于这些方法不修改对象，它们是`const`成员函数。'
- en: We notice that the `StudentException` constructor initializes the two data members
    – one through the member initialization list and one in the body of the constructor.
    We also override the `virtual const char *what() const throw()` method as introduced
    by the `exception` class. Notice that the `exception::what()` method utilizes
    the deprecated `throw()` specification in its extended signature – this is something
    you must do as well with your overridden method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`StudentException`构造函数通过成员初始化列表初始化了两个数据成员，一个在构造函数的主体中初始化。我们还重写了`exception`类引入的`virtual
    const char *what() const throw()`方法。请注意，`exception::what()`方法在其扩展签名中使用了不推荐的`throw()`规范，这也是你必须在你的重写方法中做的事情。
- en: Next, let's examine our `Student::Graduate()` method. This method may throw
    a `StudentException`. If an exception must be thrown, we allocate one using `new()`,
    construct it with diagnostic data, and then `throw` the dereferenced pointer from
    this function (so that we are throwing a referenceable object, not a pointer to
    an object). Note that the object thrown has no local identifier in this method
    – there's no need, as any such local variable name would soon be popped off the
    stack after the `throw` occurred.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查一下我们的`Student::Graduate()`方法。这个方法可能会抛出一个`StudentException`。如果必须抛出异常，我们使用`new()`分配一个异常，用诊断数据构造它，然后从这个函数中`throw`解引用指针（这样我们抛出的是一个可引用的对象，而不是一个对象的指针）。请注意，在这个方法中抛出的对象没有本地标识符
    - 没有必要，因为任何这样的本地变量名很快就会在`throw`发生后从堆栈中弹出。
- en: In our `main()` function, we wrap our call to `s1.Graduate()` within a try block
    and it is followed by a catch block that accepts a reference (`&`) to a `StudentException`,
    which we treat as `const`. Here, we first call our overridden `what()` method
    and then print out the diagnostic details from within the exception, `e`. Ideally,
    we would use this information to try to correct the error at hand and only exit
    the application if truly necessary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们将对`s1.Graduate()`的调用包装在一个try块中，后面是一个接受`StudentException`的引用（`&`）的catch块，我们将其视为`const`。在这里，我们首先调用我们重写的`what()`方法，然后从异常`e`中打印出诊断细节。理想情况下，我们将使用这些信息来尝试纠正手头的错误，只有在真正必要时才退出应用程序。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下上述程序的输出：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Though the most usual way to create a customized exception class is to derive
    a class from the Standard `exception` class, one may also wish to utilize a different
    technique, that of an embedded exception class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建自定义异常类的最常见方式是从标准的`exception`类派生一个类，但也可以利用不同的技术，即嵌套异常类。
- en: Creating a nested exception class
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建嵌套异常类
- en: As an alternative implementation, exception handling may be embedded into a
    class by adding a nested class definition in the public access region for a particular
    outer class. The inner class will represent the customized exception class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种实现，异常处理可以通过在特定外部类的公共访问区域添加嵌套类定义来嵌入到一个类中。内部类将代表自定义异常类。
- en: Objects of nested, user defined types may be created and thrown to catchers
    anticipating such types. These nested classes are built into the public access
    region of the outer class, making them easily available for derived class usage
    and specialization. In general, exception classes built into an outer class must
    be public so that the instances of nested types thrown can be caught and handled
    outside the scope of the outer class (that is, in the scope where the primary,
    outer instance exists).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的、用户定义的类型的对象可以被创建并抛出给预期这种类型的catcher。这些嵌套类内置在外部类的公共访问区域，使它们很容易为派生类的使用和特化而使用。一般来说，内置到外部类中的异常类必须是公共的，以便可以在外部类的范围之外（即在主要的外部实例存在的范围内）捕获和处理抛出的嵌套类型的实例。
- en: 'Let''s take a look at this alternate implementation of an exception class by
    examining key segments of code, which can be found as a full program in our GitHub:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查代码的关键部分来看一下异常类的另一种实现，完整的程序可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex6.cpp)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter11/Chp11-Ex6.cpp)'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code fragments, we expand our `Student` class to include a private,
    nested class called `StudentException`. Though the class shown is overly simplified,
    the nested class ideally should define a means to catalog the error in question
    as well as to collect any useful diagnostic information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们扩展了`Student`类，包括一个名为`StudentException`的私有嵌套类。尽管所示的类过于简化，但嵌套类理想上应该定义一种方法来记录相关错误以及收集任何有用的诊断信息。
- en: In our `main()` function, we instantiate a `Student`, namely `s1`. In a try
    block, we then call `s1.Graduate();`. Our `Student::Graduate()` method presumably
    checks that the `Student` has met graduation requirements, and if not, throws
    an exception of the nested class type `Student::StudentException` (which it instantiates
    as needed).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们实例化了一个`Student`，名为`s1`。然后在try块中调用`s1.Graduate()`。我们的`Student::Graduate()`方法可能会检查`Student`是否符合毕业要求，如果不符合，则抛出一个嵌套类类型`Student::StudentException`的异常（根据需要实例化）。
- en: Notice that our corresponding `catch` block utilizes scope resolution to specify
    the inner class type for `err`, the referenced object (that is, `const Student::StudentException
    &err`). Though we ideally would like to correct the program error within the handler,
    if we cannot, we simply print a message and `exit()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们相应的`catch`块利用作用域解析来指定`err`的内部类类型（即`const Student::StudentException &err`）。虽然我们理想情况下希望在处理程序内部纠正程序错误，但如果我们无法这样做，我们只需打印一条消息并`exit()`。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Understanding how to create our own exception class (both as a nested class
    or derived from `std::exception`) is useful. We may additionally wish to create
    a hierarchy of application-specific exceptions. Let's move ahead to see how to
    do so.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建我们自己的异常类（作为嵌套类或派生自`std::exception`）是有用的。我们可能还希望创建一个特定于应用程序的异常的层次结构。让我们继续看看如何做到这一点。
- en: Creating hierarchies of user-defined exception types
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户定义异常类型的层次结构
- en: An application may wish to define a series of classes that support exception
    handling to raise specific errors, and hopefully also to provide a means to collect
    diagnostics for an error so that the error may be addressed in an appropriate
    segment of the code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可能希望定义一系列支持异常处理的类，以引发特定错误，并希望提供一种收集错误诊断信息的方法，以便在代码的适当部分处理错误。
- en: You may wish to create a sub-hierarchy, derived from the Standard Library `exception`,
    of your own exception classes. Be sure to use public inheritance. When utilizing
    these classes, you will instantiate an object of your desired exception type (filling
    it with valuable diagnostic information), and then throw that object. Keep in
    mind, you'll want the newly allocated object to exist on the heap so that it won't
    be popped off the stack when a function returns (so allocate it with `new`). Simply
    dereference this object before throwing it, so that it can be caught as a reference
    to that object, which is standard practice.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望创建一个从标准库`exception`派生的子层次结构，属于您自己的异常类。确保使用公共继承。在使用这些类时，您将实例化所需异常类型的对象（填充有有价值的诊断信息），然后抛出该对象。请记住，您希望新分配的对象存在于堆上，以便在函数返回时不会从堆栈中弹出（因此使用`new`进行分配）。在抛出之前简单地对这个对象进行解引用，以便它可以被捕获为对该对象的引用，这是标准做法。
- en: Also, if you create a hierarchy of exception types, your catchers can catch
    specific derived class types or more general base class types. The option is yours,
    depending on how you plan to handle the exception. Keep in mind, however, that
    if you have a catcher for both the base and derived class types, place the derived
    class types first – otherwise your thrown object will first match to the base
    class type catcher without realizing that a more appropriate derived class match
    is available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您创建异常类型的层次结构，您的catcher可以捕获特定的派生类类型或更一般的基类类型。选择权在您手中，取决于您计划如何处理异常。但请记住，如果您对基类和派生类类型都有catcher，请将派生类类型放在前面
    - 否则，您抛出的对象将首先匹配到基类类型的catcher，而不会意识到更合适的派生类匹配是可用的。
- en: We have now seen both the hierarchy of C++ Standard Library exception classes,
    as well as how to create and utilize your own exception classes. Let's now briefly
    recap the exception features we've learned about in this chapter, before moving
    forward to our next chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了C++标准库异常类的层次结构，以及如何创建和利用自己的异常类。让我们在继续前进到下一章之前，简要回顾一下本章中我们学到的异常特性。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have begun expanding our C++ programming repertoire beyond
    OOP language features to include features that will enable us to write more robust
    programs. User code can inevitably be error-prone by nature; using language-supported
    exception handling can help us achieve less buggy and more reliable code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始将我们的C++编程技能扩展到OOP语言特性之外，以包括能够编写更健壮程序的特性。用户代码不可避免地具有错误倾向；使用语言支持的异常处理可以帮助我们实现更少错误和更可靠的代码。
- en: We have seen how to utilize the core exception handling features with `try`,
    `throw`, and `catch`. We've seen a variety of uses of these keywords – throwing
    exceptions to outer handlers, using an assortment of handlers featuring various
    types, and selectively grouping program elements together within a single try
    block, for example. We have seen how to register our own functions with `set_terminate()`
    and `set_unexpected()`. We have seen how to utilize the existing C++ Standard
    Library `exception` hierarchy. We have additionally explored defining our own
    exception classes to extend this hierarchy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`try`、`throw`和`catch`来利用核心异常处理特性。我们已经看到了这些关键字的各种用法 - 将异常抛出到外部处理程序，使用各种类型的处理程序，以及在单个try块内有选择地将程序元素分组在一起，例如。我们已经看到如何使用`set_terminate()`和`set_unexpected()`注册我们自己的函数。我们已经看到了如何利用现有的C++标准库`exception`层次结构。我们还探讨了定义我们自己的异常类以扩展此层次结构。
- en: We have added key features to our C++ skills by exploring exception handling
    mechanisms. We are now ready to move forward to [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Friends and Operator Overloading*, so that we can continue expanding our C++
    programming repertoire with useful language features that will make us better
    programmers. Let's move forward!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索异常处理机制，我们已经为我们的C++技能增加了关键特性。现在我们准备继续前进到[*第12章*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453)，*友元和运算符重载*，以便我们可以继续扩展我们的C++编程技能，使用有用的语言特性，使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Add exception handling to your previous `Student` / `University` exercise from
    [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386), *Implementing
    Association, Aggregation, and Composition*:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将异常处理添加到您之前的`Student` / `University`练习中[*第10章*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386)，*实现关联、聚合和组合*：
- en: a. Should a `Student` try to enroll in more than the `MAX` defined number of
    allowable courses per `Student`, throw a `TooFullSchedule` exception. This class
    may be derived from the Standard Library `exception` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果一个`学生`尝试注册超过每个`学生`允许的`最大`定义课程数量，抛出`TooFullSchedule`异常。这个类可以从标准库`exception`类派生。
- en: b. Should a `Student` try to enroll in a `Course` that is already full, have
    the `Course::AddStudent(Student *)` method throw a `CourseFull` exception. This
    class may be derived from the Standard Library `exception` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果一个`学生`尝试注册一个已经满员的`课程`，让`Course::AddStudent(Student *)`方法抛出一个`CourseFull`异常。这个类可以从标准库`exception`类派生。
- en: c. There are many other areas in the `Student` / `University` application that
    could utilize exception handling. Decide which areas should employ simple error
    checking and which are worthy of exception handling.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: c. `学生`/`大学`申请中还有许多其他领域可以利用异常处理。决定哪些领域应该采用简单的错误检查，哪些值得异常处理。
