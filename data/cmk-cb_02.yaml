- en: From a Simple Executable to Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单的可执行文件到库
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Compiling a single source file into an executable
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单个源文件编译成可执行文件
- en: Switching generators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换生成器
- en: Building and linking static and shared libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和链接静态和共享库
- en: Controlling compilation with conditionals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件控制编译
- en: Presenting options to the user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示选项
- en: Specifying the compiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定编译器
- en: Switching the build type
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换构建类型
- en: Controlling compiler flags
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制编译器标志
- en: Setting the standard for the language
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置语言标准
- en: Using control flow constructs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制流结构
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'The recipes in this chapter will walk you through fairly basic tasks needed
    to build your code: compiling an executable, compiling a library, performing build
    actions based on user input, and so forth. CMake is a *build system generator*
    particularly suited to being platform- and compiler-independent. We have striven
    to show this aspect in this chapter. Unless stated otherwise, all recipes are
    independent of the operating system; they can be run without modifications on
    GNU/Linux, macOS, and Windows.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将引导您完成构建代码所需的基本任务：编译可执行文件、编译库、根据用户输入执行构建操作等。CMake是一个*构建系统生成器*，特别适合于平台和编译器无关。我们努力在本章中展示这一方面。除非另有说明，所有示例都与操作系统无关；它们可以在不加修改的情况下在GNU/Linux、macOS和Windows上运行。
- en: The recipes in this book are mainly designed for C++ projects and demonstrated
    using C++ examples, but CMake can be used for projects in other languages, including
    C and Fortran. For any given recipe and whenever it makes sense, we have tried
    to include examples in C++, C, and Fortran. In this way, you will be able to choose
    the recipe in your favorite flavor. Some recipes are tailor-made to highlight
    challenges to overcome when a specific language is chosen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例主要针对C++项目，并使用C++示例进行演示，但CMake也可用于其他语言的项目，包括C和Fortran。对于任何给定的示例，只要合理，我们都尝试包括C++、C和Fortran的示例。这样，您就可以选择您喜欢的语言的示例。有些示例是专门为突出特定语言选择时需要克服的挑战而定制的。
- en: Compiling a single source file into an executable
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单个源文件编译成可执行文件
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-01)
    and has C++, C, and Fortran examples. The recipe is valid with CMake version 3.5
    (and higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-01)找到，并提供了C++、C和Fortran的示例。本示例适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this recipe, we will demonstrate how to run CMake to configure and build
    a simple project. The project consists of a single source file for a single executable.
    We will discuss the project in C++, but examples for C and Fortran are available
    in the GitHub repository.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将演示如何运行CMake来配置和构建一个简单的项目。该项目由单个源文件组成，用于单个可执行文件。我们将讨论C++项目，但GitHub存储库中提供了C和Fortran的示例。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We wish to compile the following source code into a single executable:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将以下源代码编译成一个单独的可执行文件：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: Alongside the source file, we need to provide CMake with a description of the
    operations to perform to configure the project for the build tools. The description
    is done in the CMake language, whose comprehensive documentation can be found
    online at [https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/).
    We will place the CMake instructions into a file called `CMakeLists.txt`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源文件外，我们还需要向CMake提供一个描述，说明如何为构建工具配置项目。描述使用CMake语言完成，其全面的文档可以在[https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/)在线找到。我们将把CMake指令放入一个名为`CMakeLists.txt`的文件中。
- en: The name of the file is *case sensitive*; it has to be called `CMakeLists.txt`
    for CMake to be able to parse it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名是*区分大小写*的；它必须被称为`CMakeLists.txt`，以便CMake能够解析它。
- en: 'In detail, these are the steps to follow:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 详细来说，以下是遵循的步骤：
- en: Open a text file with your favorite editor. The name of this file will be `CMakeLists.txt`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器打开一个文本文件。该文件将被命名为`CMakeLists.txt`。
- en: 'The first line sets a minimum required version for CMake. A fatal error will
    be issued if a version of CMake lower than that is used:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行设置CMake的最低要求版本。如果使用的CMake版本低于该版本，将发出致命错误：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second line declares the name of the project (recipe-01) and the supported
    language (`CXX` stands for C++):'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二行声明了项目的名称（recipe-01）和支持的语言（`CXX`代表C++）：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We instruct CMake to create a new *target*: the executable `hello-world`. This
    executable is generated by compiling and linking the source file `hello-world.cpp`.
    CMake will use default settings for the compiler and build automation tools selected:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指示CMake创建一个新的*目标*：可执行文件`hello-world`。这个可执行文件是通过编译和链接源文件`hello-world.cpp`生成的。CMake将使用所选编译器和构建自动化工具的默认设置：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the file in the same directory as the source file `hello-world.cpp`. Remember
    that it can only be named `CMakeLists.txt`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存在与源文件`hello-world.cpp`相同的目录中。请记住，它只能被命名为`CMakeLists.txt`。
- en: 'We are now ready to configure the project by creating and stepping into a build
    directory:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备通过创建并进入构建目录来配置项目：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If everything went well, the configuration for the project has been generated
    in the build directory. We can now compile the executable:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，项目配置已经在构建目录中生成。我们现在可以编译可执行文件了：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In this recipe, we have used a simple `CMakeLists.txt` to build a "Hello world"
    executable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了一个简单的`CMakeLists.txt`来构建一个“Hello world”可执行文件：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The CMake language is case *insensitive*, but the arguments are case *sensitive*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CMake语言是不区分大小写的，但参数是区分大小写的。
- en: In CMake, C++ is the default programming language. However, we suggest to always
    explicitly state the project’s language in the `project` command using the `LANGUAGES`
    option.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CMake中，C++是默认的编程语言。然而，我们建议始终在`project`命令中使用`LANGUAGES`选项明确声明项目的语言。
- en: 'To configure the project and generate its build system, we have to run CMake
    through its command-line interface (CLI). The CMake CLI offers a number of switches,
    `cmake --help` will output to screen the full help menu listing all of the available
    switches. We will learn more about them throughout the book. As you will notice
    from the output of `cmake --help`, most of them will let you access the CMake
    manual. The typical series of commands issued for generating the build system
    is the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置项目并生成其构建系统，我们必须通过命令行界面（CLI）运行CMake。CMake CLI提供了许多开关，`cmake --help`将输出屏幕上列出所有可用开关的完整帮助菜单。我们将在本书中了解更多关于它们的信息。正如您将从`cmake
    --help`的输出中注意到的，大多数开关将允许您访问CMake手册。生成构建系统的典型命令序列如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we created a directory, `build`, where the build system will be generated,
    we entered the `build` directory, and invoked CMake by pointing it to the location
    of `CMakeLists.txt` (in this case located in the parent directory). It is possible
    to use the following invocation to achieve the same effect:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个目录，`build`，其中将生成构建系统，我们进入了`build`目录，并通过指向`CMakeLists.txt`的位置调用了CMake（在这种情况下位于父目录中）。可以使用以下调用来实现相同的效果：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This invocation is cross-platform and introduces the `-H` and `-B` CLI switches.
    With `-H.` we are instructing CMake to search for the root `CMakeLists.txt` file
    in the current directory. `-Bbuild` tells CMake to generate all of its files in
    a directory called `build`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用是跨平台的，并引入了`-H`和`-B`CLI开关。使用`-H.`我们指示CMake在当前目录中搜索根`CMakeLists.txt`文件。`-Bbuild`告诉CMake在名为`build`的目录中生成所有文件。
- en: 'Note that the `cmake -H. -Bbuild` invocation of CMake is still undergoing standardization:
    [https://cmake.org/pipermail/cmake-developers/2018-January/030520.html](https://cmake.org/pipermail/cmake-developers/2018-January/030520.html).
    This is the reason why we will instead use the traditional approach in this book
    (create a build directory, step into it, and configure the project by pointing
    CMake to the location of `CMakeLists.txt`).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`cmake -H. -Bbuild`调用CMake仍在进行标准化：[https://cmake.org/pipermail/cmake-developers/2018-January/030520.html](https://cmake.org/pipermail/cmake-developers/2018-January/030520.html)。这就是为什么我们在这本书中将使用传统方法（创建一个构建目录，进入它，并通过指向`CMakeLists.txt`的位置来配置项目）。
- en: 'Running the `cmake` command outputs a series of status messages to inform you
    of the configuration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cmake`命令会输出一系列状态消息来通知您配置情况：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running `cmake .` in the same directory as `CMakeLists.txt` would in principle
    be enough to configure a project. However, CMake would then write all generated
    files into the **root **of the project. This would be an *in-source build* and
    is generally undesirable, as it mixes the source and the build tree of the project.
    The *out-of-source* build we have demonstrated is the preferred practice.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CMakeLists.txt`所在的同一目录中运行`cmake .`原则上足以配置项目。但是，CMake随后会将所有生成的文件写入项目的**根目录**。这将是一个*源内构建*，通常是不希望的，因为它混合了项目的源代码和构建树。我们演示的*源外构建*是首选实践。
- en: CMake is a build system *generator*. You describe what type of operations the
    build system, such as Unix Makefiles, Ninja, Visual Studio, and so on, will have
    to run to get your code compiled. In turn, CMake *generates* the corresponding
    instructions for the chosen build system. By default, on GNU/Linux and macOS systems,
    CMake employs the Unix Makefiles generator. On Windows, Visual Studio is the default
    generator. We will take a closer look at generators in the next recipe and also
    revisit generators in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml), *Alternative
    Generators and Cross-compilation*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一个*生成器*构建系统。您描述了构建系统（如Unix Makefiles、Ninja、Visual Studio等）需要执行的操作类型，以便编译您的代码。然后，CMake为所选的构建系统*生成*相应的指令。默认情况下，在GNU/Linux和macOS系统上，CMake使用Unix
    Makefiles生成器。在Windows上，Visual Studio是默认生成器。我们将在下一个配方中更详细地了解生成器，并在[第13章](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml)，*替代生成器和交叉编译*中重新审视生成器。
- en: 'On GNU/Linux, CMake will by default generate Unix Makefiles to build the project:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU/Linux上，CMake将默认生成Unix Makefiles以构建项目：
- en: '`Makefile`: The set of instructions that `make` will run to build the project.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`：`make`将运行以构建项目的一组指令。'
- en: '`CMakeFiles`: Directory which contains temporary files, used by CMake for detecting
    the operating system, compiler, and so on. In addition, depending on the chosen
    *generator,* it also contains project-specific files.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeFiles`：该目录包含CMake用于检测操作系统、编译器等的临时文件。此外，根据所选的*生成器*，它还包含特定于项目的文件。'
- en: '`cmake_install.cmake`: A CMake script handling install rules, which is used
    at install time.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake_install.cmake`：一个CMake脚本，用于处理安装规则，在安装时使用。'
- en: '`CMakeCache.txt`: The CMake cache, as the filename suggests. This file is used
    by CMake when re-running the configuration.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeCache.txt`：正如文件名所示，这是CMake的缓存文件。在重新运行配置时，CMake会使用此文件。'
- en: 'To build the example project, we ran this command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建示例项目，我们运行了以下命令：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command is a generic, cross-platform wrapper to the native build command
    for the chosen *generator*, `make` in this case. We should not forget to test
    our example executable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令是一个通用的跨平台包装器，用于所选*生成器*的本地构建命令，在本例中为`make`。我们不应忘记测试我们的示例可执行文件：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we should point out that CMake does not enforce a specific name or
    a specific location for the build directory. We could have placed it completely
    outside the project path. This would have worked equally well:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该指出，CMake不强制要求特定的名称或特定的位置用于构建目录。我们可以将其完全放置在项目路径之外。这将同样有效：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is more
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'The official documentation at [https://cmake.org/runningcmake/](https://cmake.org/runningcmake/)
    gives a concise overview on running CMake. The build system generated by CMake,
    the `Makefile` in the example given above, will contain targets and rules to build
    object files, executables, and libraries for the given project. The `hello-world`
    executable was our only target in the current example, but running the command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档位于[https://cmake.org/runningcmake/](https://cmake.org/runningcmake/)，提供了运行CMake的简明概述。由CMake生成的构建系统，在上面的示例中为`Makefile`，将包含构建给定项目的对象文件、可执行文件和库的目标和规则。在当前示例中，`hello-world`可执行文件是我们唯一的目标，但是运行命令：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'reveals that CMake generates more targets than those strictly needed for building
    the executable itself. These targets can be chosen with the `cmake --build . --target
    <target-name>` syntax and achieve the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示了CMake生成的目标比仅构建可执行文件本身所需的目标更多。可以使用`cmake --build . --target <target-name>`语法选择这些目标，并实现以下目标：
- en: '`all` (or `ALL_BUILD` with the Visual Studio generator) is the default target
    and will build all other targets in the project.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`（或使用Visual Studio生成器时的`ALL_BUILD`）是默认目标，将构建项目中的所有其他目标。'
- en: '`clean`, is the target to choose if one wants to remove all generated files.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clean`，是选择删除所有生成的文件的目标。'
- en: '`depend`, will invoke CMake to generate the dependecies, if any, for the source
    files.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depend`，将调用CMake为源文件生成任何依赖项。'
- en: '`rebuild_cache`, will once again invoke CMake to rebuild the `CMakeCache.txt`.
    This is needed in case new entries from the source need to be added.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rebuild_cache`，将再次调用CMake来重建`CMakeCache.txt`。如果需要从源代码中添加新条目，这是必要的。'
- en: '`edit_cache`, this target will let you edit cache entries directly.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit_cache`，这个目标将允许你直接编辑缓存条目。'
- en: 'For more complex projects, with a test stage and installation rules, CMake
    will generate additional convenience targets:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的项目，包括测试阶段和安装规则，CMake将生成额外的便利目标：
- en: '`test` (or `RUN_TESTS` with the Visual Studio generator) will run the test
    suite with the help of CTest. We will discuss testing and CTest extensively in
    [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running
    Tests*.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`（或使用Visual Studio生成器时的`RUN_TESTS`）将使用CTest运行测试套件。我们将在[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*中详细讨论测试和CTest。'
- en: '`install`, will execute the installation rules for the project. We will discuss
    installation rules in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install`，将执行项目的安装规则。我们将在[第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)，*编写安装程序*中讨论安装规则。'
- en: '`package`, this target will invoke CPack to generate a redistributable package
    for the project. Packaging and CPack will be discussed in [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml),
    *Packaging Projects*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`，这个目标将调用CPack来为项目生成可重新分发的包。打包和CPack将在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*中讨论。'
- en: Switching generators
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换生成器
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-02)
    and has a C++, C, and Fortran example. The recipe is valid with CMake version
    3.5 (and higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-02)找到，并提供了C++、C和Fortran的示例。本配方适用于CMake
    3.5（及以上）版本，并在GNU/Linux、macOS和Windows上进行了测试。
- en: CMake is a build system generator and a single `CMakeLists.txt` can be used
    to configure projects for different toolstacks on different platforms. You describe
    in `CMakeLists.txt` the operations the build system will have to run to get your
    code configured and compiled. Based on these instructions, CMake will generate
    the corresponding instructions for the chosen build system (Unix Makefiles, Ninja,
    Visual Studio, and so on). We will revisit generators in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml), *Alternative
    Generators and Cross-compilation*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一个构建系统生成器，单个`CMakeLists.txt`可以用于为不同平台上的不同工具链配置项目。你可以在`CMakeLists.txt`中描述构建系统需要运行的操作来配置和编译你的代码。基于这些指令，CMake将为所选构建系统（Unix
    Makefiles、Ninja、Visual Studio等）生成相应的指令。我们将在[第13章](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml)，*替代生成器和交叉编译*中重新讨论生成器。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'CMake supports an extensive list of native build tools for different platforms.
    Both command-line tools, such as Unix Makefiles and Ninja, and integrated development
    environment (IDE) tools are supported. You can find an up-to-date list of the
    generators available on your platform and for your installed version of CMake
    by running the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CMake支持大量不同平台的原生构建工具。无论是命令行工具，如Unix Makefiles和Ninja，还是集成开发环境（IDE）工具，都得到支持。你可以通过运行以下命令来获取你平台和已安装的CMake版本上可用的生成器的最新列表：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of this command will list all options to the CMake command-line
    interface. At the bottom, you will find the list of available generators. For
    example, this is the output on a GNU/Linux machine with CMake 3.11.2 installed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将列出CMake命令行界面的所有选项。在底部，你将找到可用生成器的列表。例如，这是在安装了CMake 3.11.2的GNU/Linux机器上的输出：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this recipe, we will show how easy it is to switch generators for the same
    project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本配方，我们将展示为同一项目切换生成器是多么容易。
- en: How to do it
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: We will reuse `hello-world.cpp` and `CMakeLists.txt` from the previous recipe.
    The only difference is in the invocation of CMake, since we will now have to pass
    the generator explicitly with the `-G` CLI switch.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用之前的配方中的`hello-world.cpp`和`CMakeLists.txt`。唯一的区别在于CMake的调用方式，因为我们现在必须使用`-G`命令行开关显式传递生成器。
- en: 'First, we configure the project using the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用以下命令配置项目：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second step, we build the project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步，我们构建项目：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'We have seen that the output of the configuration step was unchanged compared
    to the previous recipe. The output of the compilation step and the contents of
    the build directory will however be different, as every generator has its own
    specific set of files:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，配置步骤的输出与之前的配方相比没有变化。然而，编译步骤的输出和构建目录的内容将会有所不同，因为每个生成器都有其特定的文件集：
- en: '`build.ninja` and `rules.ninja`: Contain all the build statements and build
    rules for Ninja.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.ninja` 和 `rules.ninja`：包含 Ninja 的所有构建语句和构建规则。'
- en: '`CMakeCache.txt`: CMake always generates its own cache in this file, regardless
    of the chosen generator.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeCache.txt`：无论选择哪种生成器，CMake 总是会在此文件中生成自己的缓存。'
- en: '`CMakeFiles`: Contains temporary files generated by CMake during configuration.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeFiles`：包含 CMake 在配置过程中生成的临时文件。'
- en: '`cmake_install.cmake`: CMake script handling install rules and which is used
    at install time.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake_install.cmake`：处理安装规则的 CMake 脚本，用于安装时使用。'
- en: Note how `cmake --build .` wrapped the `ninja` command in a unified, cross-platform
    interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `cmake --build .` 是如何将 `ninja` 命令包装在一个统一的跨平台接口中的。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We will discuss alternative generators and cross-compilation in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml), *Alternative
    Generators and Cross-compilation*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第13章](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml)，*替代生成器和交叉编译*中讨论替代生成器和交叉编译。
- en: The CMake documentation is a good starting point to learn more about generators: [https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 文档是了解生成器的良好起点：[https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)。
- en: Building and linking static and shared libraries
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和链接静态和共享库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-03)
    and has a C++ and Fortran example. The recipe is valid with CMake version 3.5
    (and higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在 [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-03)
    获取，并提供了 C++ 和 Fortran 的示例。本配方适用于 CMake 3.5（及以上）版本，并在 GNU/Linux、macOS 和 Windows
    上进行了测试。
- en: A project almost always consists of more than a single executable built from
    a single source file. Projects are split across multiple source files, often spread
    across different subdirectories in the source tree. This practice not only helps
    in keeping source code organized within a project, but greatly favors modularity,
    code reuse, and separation of concerns, since common tasks can be grouped into
    libraries. This separation also simplifies and speeds up recompilation of a project
    during development. In this recipe, we will show how to group sources into libraries
    and how to link targets against these libraries.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目几乎总是由多个源文件构建的单个可执行文件组成。项目被拆分到多个源文件中，通常分布在源树的不同子目录中。这种做法不仅有助于在项目中组织源代码，而且极大地促进了模块化、代码重用和关注点分离，因为可以将常见任务分组到库中。这种分离还简化了项目开发过程中的重新编译并加快了速度。在本配方中，我们将展示如何将源分组到库中，以及如何将目标链接到这些库。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let us go back to our very first example. However, instead of having one single
    source file for the executable, we will now introduce a class to wrap the message
    to be printed out to screen. This is our updated `hello-world.cpp`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到最初的例子。然而，我们不再使用单一的源文件来编译可执行文件，而是引入一个类来封装要打印到屏幕的消息。这是我们更新的 `hello-world.cpp`：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Message` class wraps a string, provides an overload for the `<<` operator,
    and consists of two source files: the `Message.hpp` header file and the corresponding
    `Message.cpp` source file. The `Message.hpp` interface file contains the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 类封装了一个字符串，提供了对 `<<` 操作符的重载，并由两个源文件组成：`Message.hpp` 头文件和相应的 `Message.cpp`
    源文件。`Message.hpp` 接口文件包含以下内容：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The corresponding implementation is contained in `Message.cpp`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的实现包含在 `Message.cpp` 中：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'These two new files will also have to be compiled and we have to modify `CMakeLists.txt`
    accordingly. However, in this example we want to compile them first into a library,
    and not directly into the executable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新文件也需要编译，我们需要相应地修改 `CMakeLists.txt`。然而，在这个例子中，我们希望先将它们编译成一个库，而不是直接编译成可执行文件：
- en: 'Create a new *target*, this time a static library. The name of the library
    will be the name of the target and the sources are listed as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 *目标*，这次是静态库。库的名称将是目标的名称，源代码列表如下：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The creation of the target for the `hello-world` executable is unmodified:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `hello-world` 可执行文件的目标未作修改：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, tell CMake that the library target has to be linked into the executable
    target:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，告诉 CMake 库目标需要链接到可执行目标：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can configure and build with the same commands as before. This time a library
    will be compiled, alongside the `hello-world` executable:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用与之前相同的命令进行配置和构建。这次将编译一个库，与 `hello-world` 可执行文件一起：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The previous example introduced two new commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例介绍了两个新命令：
- en: '`add_library(message STATIC Message.hpp Message.cpp)`: This will generate the
    necessary build tool instructions for compiling the specified sources into a library.
    The first argument to `add_library` is the name of the target. The same name can
    be used throughout `CMakeLists.txt` to refer to the library. The actual name of
    the generated library will be formed by CMake by adding the prefix `lib` in front
    and the appropriate extension as a suffix. The library extension is determined
    based on the second argument, `STATIC` or `SHARED`, and the operating system.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_library(message STATIC Message.hpp Message.cpp)`：这将生成将指定源代码编译成库所需的构建工具指令。`add_library`
    的第一个参数是目标的名称。在整个 `CMakeLists.txt` 中可以使用相同的名称来引用该库。生成的库的实际名称将由 CMake 通过在前面添加前缀
    `lib` 和作为后缀的适当扩展名来形成。库扩展名是根据第二个参数 `STATIC` 或 `SHARED` 以及操作系统来确定的。'
- en: '`target_link_libraries(hello-world message)`: Links the library into the executable.
    This command will also guarantee that the `hello-world` executable properly depends
    on the message library. We thus ensure that the message library is always built
    before we attempt to link it to the `hello-world` executable.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_link_libraries(hello-world message)`：将库链接到可执行文件。此命令还将确保 `hello-world`
    可执行文件正确依赖于消息库。因此，我们确保消息库总是在我们尝试将其链接到 `hello-world` 可执行文件之前构建。'
- en: After successful compilation, the build directory will contain the `libmessage.a` static
    library (on GNU/Linux) and the `hello-world` executable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 成功编译后，构建目录将包含 `libmessage.a` 静态库（在 GNU/Linux 上）和 `hello-world` 可执行文件。
- en: 'CMake accepts other values as valid for the second argument to `add_library`
    and we will encounter all of them in the rest of the book:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 接受 `add_library` 的第二个参数的其他有效值，我们将在本书的其余部分遇到所有这些值：
- en: '`STATIC`, which we have already encountered, will be used to create static
    libraries, that is, archives of object files for use when linking other targets,
    such as executables.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATIC`，我们已经遇到过，将用于创建静态库，即用于链接其他目标（如可执行文件）的对象文件的归档。'
- en: '`SHARED` will be used to create shared libraries, that is, libraries that can
    be linked dynamically and loaded at runtime. Switching from a static library to
    a dynamic shared object (DSO) is as easy as using `add_library(message SHARED
    Message.hpp Message.cpp)` in `CMakeLists.txt`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHARED` 将用于创建共享库，即可以在运行时动态链接和加载的库。从静态库切换到动态共享对象（DSO）就像在 `CMakeLists.txt` 中使用
    `add_library(message SHARED Message.hpp Message.cpp)` 一样简单。'
- en: '`OBJECT` can be used to compile the sources in the list given to `add_library`
    to object files, but then neither archiving them into a static library nor linking
    them into a shared object. The use of object libraries is particularly useful
    if one needs to create both static and shared libraries in one go. We will demonstrate
    this in this recipe.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJECT` 可用于将传递给 `add_library` 的列表中的源代码编译成目标文件，但不将它们归档到静态库中，也不将它们链接到共享对象中。如果需要一次性创建静态库和共享库，使用对象库尤其有用。我们将在本示例中演示这一点。'
- en: '`MODULE` libraries are once again DSOs. In contrast to `SHARED` libraries,
    they are not linked to any other target within the project, but may be loaded
    dynamically later on. This is the argument to use when building a runtime plugin.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE` 库再次是 DSOs。与 `SHARED` 库不同，它们不在项目内链接到任何其他目标，但可能会在以后动态加载。这是构建运行时插件时要使用的参数。'
- en: 'CMake is also able to generate special types of libraries. These produce no
    output in the build system but are extremely helpful in organizing dependencies
    and build requirements between targets:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 还能够生成特殊类型的库。这些库在构建系统中不产生输出，但在组织目标之间的依赖关系和构建要求方面非常有帮助：
- en: '`IMPORTED`, this type of library target represents a library located *outside*
    the project. The main use for this type of library is to model pre-existing dependencies
    of the project that are provided by upstream packages. As such `IMPORTED` libraries
    are to be treated as immutable. We will show examples of using `IMPORTED` libraries
    throughout the rest of the book. See also: [https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMPORTED`，这种类型的库目标代表位于项目*外部*的库。这种类型的库的主要用途是模拟项目上游包提供的预先存在的依赖项。因此，`IMPORTED`库应被视为不可变的。我们将在本书的其余部分展示使用`IMPORTED`库的示例。另请参见：[https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets)'
- en: '`INTERFACE`, this special type of CMake library is similar to an `IMPORTED`
    library, but is mutable and has no location. Its main use case is to model usage
    requirements for a target that is outside our project. We will show a use case
    for `INTERFACE` libraries in Recipe 5, *Distributing a project with dependencies
    as Conda package*, in [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml),
    *Packaging Projects*. See also: [https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#interface-libraries](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#interface-libraries)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE`，这种特殊的CMake库类型类似于`IMPORTED`库，但它是可变的，没有位置。它的主要用例是模拟项目外部目标的使用要求。我们将在第5个配方中展示`INTERFACE`库的使用案例，即*将依赖项作为Conda包分发项目*，在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*中。另请参见：[https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#interface-libraries](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#interface-libraries)'
- en: '`ALIAS`, as the name suggests, a library of this type defines an alias for
    a pre-existing library target within the project. It is thus not possible to choose
    an alias for an `IMPORTED` library. See also: [https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#alias-libraries](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#alias-libraries)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALIAS`，顾名思义，这种类型的库为目标定义了一个别名。因此，不可能为`IMPORTED`库选择别名。另请参见：[https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#alias-libraries](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#alias-libraries)'
- en: In this example, we have collected the sources directly using `add_library`.
    In later chapters, we demonstrate the use of the `target_sources` CMake command
    to collect sources, in particular in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*. See also this wonderful blog post by Craig Scott: [https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/](https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/)
    which further motivates the use of the `target_sources` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们直接使用`add_library`收集源文件。在后面的章节中，我们将展示使用`target_sources`CMake命令来收集源文件，特别是在[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)，*项目结构化*中。也可以参考Craig
    Scott的这篇精彩博文：[https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/](https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/)，它进一步说明了使用`target_sources`命令的动机。
- en: There is more
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Let us now show the use of the object library functionality made available
    in CMake. We will use the same source files, but modify `CMakeLists.txt`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们展示CMake中提供的对象库功能的使用。我们将使用相同的源文件，但修改`CMakeLists.txt`：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, notice that the `add_library` command changed to `add_library(message-objs
    OBJECT Message.hpp Message.cpp)`. Additionally, we have to make sure that the
    compilation to object files generates position-independent code. This is done
    by setting the corresponding *property* of the `message-objs` target, with the
    `set_target_properties` command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`add_library`命令已更改为`add_library(message-objs OBJECT Message.hpp Message.cpp)`。此外，我们必须确保编译为对象文件生成位置无关代码。这是通过使用`set_target_properties`命令设置`message-objs`目标的相应*属性*来完成的。
- en: The need to explicitly set the `POSITION_INDEPENDENT_CODE` property for the
    target might only arise on certain platforms and/or using older compilers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标显式设置`POSITION_INDEPENDENT_CODE`属性的需求可能只在某些平台和/或使用旧编译器时才会出现。
- en: 'This object library can now be used to obtain both the static library, called
    `message-static`, and the shared library, called `message-shared`. It is important
    to note the *generator expression syntax* used to refer to the object library: `$<TARGET_OBJECTS:message-objs>`.
    Generator expressions are constructs that CMake evaluates at generation time,
    right after configuration time, to produce configuration-specific build output.
    See also: [https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html).
    We will delve into generator expressions later in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*. Finally, the `hello-world` executable
    is linked with the static version of the `message` library.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个对象库可以用来获取静态库（称为`message-static`）和共享库（称为`message-shared`）。需要注意的是，用于引用对象库的*生成器表达式语法*：`$<TARGET_OBJECTS:message-objs>`。生成器表达式是CMake在生成时（即配置时间之后）评估的构造，以产生特定于配置的构建输出。另请参阅：[https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html)。我们将在[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)，*配置时间和构建时间操作*中深入探讨生成器表达式。最后，`hello-world`可执行文件与`message`库的静态版本链接。
- en: 'Is it possible to have CMake generate the two libraries with the same name?
    In other words, can both of them be called `message` instead of `message-static`
    and `message-shared`? We will need to modify the properties of these two targets:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以让CMake生成两个同名的库？换句话说，它们是否可以都称为`message`而不是`message-static`和`message-shared`？我们需要修改这两个目标的属性：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Can we link against the DSO? It depends on the operating system and compiler:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以链接DSO吗？这取决于操作系统和编译器：
- en: On GNU/Linux and macOS, it will work, regardless of the chosen compiler.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GNU/Linux和macOS上，无论选择哪个编译器，它都能正常工作。
- en: On Windows, it will not work with Visual Studio, but it will work with MinGW
    and MSYS2.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，它无法与Visual Studio配合使用，但可以与MinGW和MSYS2配合使用。
- en: Why? Generating good DSOs requires the programmer to limit *symbol visibility*.
    This is achieved with the help of the compiler, but conventions are different
    on different operating systems and compilers. CMake has a powerful mechanism for
    taking care of this and we will explain how it works in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？生成好的DSO需要程序员限制*符号可见性*。这是通过编译器的帮助实现的，但在不同的操作系统和编译器上约定不同。CMake有一个强大的机制来处理这个问题，我们将在[第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)，*编写安装程序*中解释它是如何工作的。
- en: Controlling compilation with conditionals
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件控制编译
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-04)找到，并包含一个C++示例。本节适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'So far, we have looked at fairly simple projects, where the execution flow
    for CMake was linear: from a set of source files to a single executable, possibly
    *via* static or shared libraries. To ensure complete control over the execution
    flow of all the steps involved in building a project, configuration, compilation,
    and linkage, CMake offers its own language. In this recipe, we will explore the
    use of the conditional construct `if-elseif-else-endif`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们研究的项目相对简单，CMake的执行流程是线性的：从一组源文件到一个单一的可执行文件，可能*通过*静态或共享库。为了确保对项目构建过程中所有步骤的执行流程有完全的控制，包括配置、编译和链接，CMake提供了自己的语言。在本节中，我们将探讨使用条件结构`if-elseif-else-endif`。
- en: 'The CMake language is fairly large and consists of basic control constructs,
    CMake-specific commands, and infrastructure for modularly extending the language
    with new functions. A complete overview can be found online here: [https://cmake.org/cmake/help/latest/manual/cmake-language.7.html](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CMake语言相当庞大，包括基本控制结构、CMake特定命令以及用于模块化扩展语言的新函数的基础设施。完整的概述可以在线找到：[https://cmake.org/cmake/help/latest/manual/cmake-language.7.html](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html)。
- en: How to do it
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us start with the same source code as for the previous recipe. We want
    to be able to toggle between two behaviors:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从与上一个配方相同的源代码开始。我们希望能够在这两种行为之间切换：
- en: Build `Message.hpp` and `Message.cpp` into a library, static or shared, and
    then link the resulting library into the `hello-world` executable.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message.hpp`和`Message.cpp`编译成一个库，无论是静态还是共享，然后将生成的库链接到`hello-world`可执行文件中。
- en: Build `Message.hpp`, `Message.cpp`, and `hello-world.cpp` into a single executable,
    without producing the library.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message.hpp`、`Message.cpp`和`hello-world.cpp`编译成一个单一的可执行文件，不生成库。
- en: 'Let us construct `CMakeLists.txt` to achieve this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建`CMakeLists.txt`以实现这一点：
- en: 'We start out by defining the minimum CMake version, project name, and supported
    language:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义最小CMake版本、项目名称和支持的语言：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We introduce a new variable, `USE_LIBRARY`. This is a logical variable and
    its value will be set to `OFF`. We also print its value for the user:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入了一个新变量，`USE_LIBRARY`。这是一个逻辑变量，其值将被设置为`OFF`。我们还打印其值供用户查看：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set the `BUILD_SHARED_LIBS` global variable, defined in CMake, to `OFF`. Calling `add_library` and
    omitting the second argument will build a static library:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将CMake中定义的`BUILD_SHARED_LIBS`全局变量设置为`OFF`。调用`add_library`并省略第二个参数将构建一个静态库：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then introduce a variable, `_sources`, listing `Message.hpp` and `Message.cpp`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们引入一个变量`_sources`，列出`Message.hpp`和`Message.cpp`：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then introduce an `if-else` statement based on the value of `USE_LIBRARY`.
    If the logical toggle is true, `Message.hpp` and `Message.cpp` will be packaged
    into a library:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们根据`USE_LIBRARY`的值引入一个`if-else`语句。如果逻辑开关为真，`Message.hpp`和`Message.cpp`将被打包成一个库：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can again build with the same set of commands. Since `USE_LIBRARY` is set
    to `OFF`, the `hello-world` executable will be compiled from all sources. This
    can be verified by running the `objdump -x` command on GNU/Linux.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次使用相同的命令集进行构建。由于`USE_LIBRARY`设置为`OFF`，所有源文件将被编译成`hello-world`可执行文件。这可以通过在GNU/Linux上运行`objdump
    -x`命令来验证。
- en: How it works
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We have introduced two variables: `USE_LIBRARY` and `BUILD_SHARED_LIBS`. Both
    of them have been set to `OFF`. As detailed in the CMake language documentation,
    true or false values can be expressed in a number of ways:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了两个变量：`USE_LIBRARY`和`BUILD_SHARED_LIBS`。两者都设置为`OFF`。正如CMake语言文档中所详述的，真或假值可以用多种方式表达：
- en: 'A logical variable is true if it is set to any of the following: `1`, `ON`,
    `YES`, `TRUE`, `Y`, or a non-zero number.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑变量在以下情况下为真：设置为`1`、`ON`、`YES`、`TRUE`、`Y`或非零数字。
- en: A logical variable is false if it is set to any of the following: `0`, `OFF`,
    `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`, an empty string, or it ends in the suffix
    `-NOTFOUND`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑变量在以下情况下为假：设置为`0`、`OFF`、`NO`、`FALSE`、`N`、`IGNORE`、`NOTFOUND`、空字符串或以`-NOTFOUND`结尾。
- en: The `USE_LIBRARY` variable will toggle between the first and the second behavior.
    `BUILD_SHARED_LIBS` is a global flag offered by CMake. Remember that the `add_library`
    command can be invoked without passing the `STATIC`/`SHARED`/`OBJECT` argument.
    This is because, internally, the `BUILD_SHARED_LIBS` global variable is looked
    up; if false or undefined, a static library will be generated.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`USE_LIBRARY`变量将在第一种和第二种行为之间切换。`BUILD_SHARED_LIBS`是CMake提供的一个全局标志。记住，`add_library`命令可以在不传递`STATIC`/`SHARED`/`OBJECT`参数的情况下调用。这是因为，内部会查找`BUILD_SHARED_LIBS`全局变量；如果为假或未定义，将生成一个静态库。'
- en: This example shows that it is possible to introduce conditionals to control
    the execution flow in CMake. However, the current setup does not allow the toggles
    to be set from outside, that is, without modifying `CMakeLists.txt` by hand. In
    principle, we want to be able to expose all toggles to the user, so that configuration
    can be tweaked without modifying the code for the build system. We will show how
    to do that in a moment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在CMake中引入条件语句以控制执行流程是可能的。然而，当前的设置不允许从外部设置开关，也就是说，不通过手动修改`CMakeLists.txt`。原则上，我们希望将所有开关暴露给用户，以便在不修改构建系统代码的情况下调整配置。我们将在稍后展示如何做到这一点。
- en: The `()` in `else()` and `endif()` may surprise you when starting to read and
    write CMake code. The historical reason for these is the ability to indicate the
    scope. For instance, it is possible instead to use `if(USE_LIBRARY) ... else(USE_LIBRARY)
    ... endif(USE_LIBRARY)` if this helps the reader. This is a matter of taste.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`else()`和`endif()`中的`()`可能会在你开始阅读和编写CMake代码时让你感到惊讶。这些的历史原因是能够指示作用域。例如，如果这有助于读者理解，可以使用`if(USE_LIBRARY)
    ... else(USE_LIBRARY) ... endif(USE_LIBRARY)`。这是一个品味问题。'
- en: When introducing the `_sources` variable, we have indicated to readers of this
    code that this is a local variable that should not be used outside the current
    scope by prefixing it with an underscore.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`_sources`变量时，我们向代码的读者表明这是一个不应在当前作用域外使用的局部变量，方法是将其前缀加上一个下划线。
- en: Presenting options to the user
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户展示选项
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-05)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-05)找到，并包含一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'In the previous recipe, we introduced conditionals in a rather rigid fashion:
    by introducing variables with a given truth value hardcoded. This can be useful
    sometimes, but it prevents users of your code from easily toggling these variables.
    Another disadvantage of the rigid approach is that the CMake code does not communicate
    to the reader that this is a value that is expected to be modified from outside.
    The recommended way to toggle behavior in the build system generation for your
    project is to present logical switches as options in your `CMakeLists.txt` using
    the `option()` command. This recipe will show you how to use this command.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一食谱中，我们以相当僵硬的方式引入了条件：通过引入具有硬编码真值的变量。有时这可能很有用，但它阻止了代码用户轻松切换这些变量。僵硬方法的另一个缺点是，CMake代码没有向读者传达这是一个预期从外部修改的值。在项目构建系统生成中切换行为的推荐方法是使用`option()`命令在`CMakeLists.txt`中将逻辑开关作为选项呈现。本食谱将向您展示如何使用此命令。
- en: How to do it
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us have a look at our static/shared library example from the previous recipe.
    Instead of hardcoding `USE_LIBRARY` to `ON` or `OFF`, we will now prefer to expose
    it as an option with a default value that can be changed from the outside:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下上一食谱中的静态/共享库示例。我们不再将`USE_LIBRARY`硬编码为`ON`或`OFF`，而是更倾向于将其作为具有默认值的选项公开，该默认值可以从外部更改：
- en: 'Replace the `set(USE_LIBRARY OFF)` command of the previous recipe with an option.
    The option will have the same name and its default value will be `OFF`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一食谱中的`set(USE_LIBRARY OFF)`命令替换为具有相同名称和默认值为`OFF`的选项。
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can switch the generation of the library by passing the information
    to CMake *via* its `-D` CLI option:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将信息传递给CMake的`-D` CLI选项来切换库的生成：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `-D` switch is used to set any type of variable for CMake: logicals, paths,
    and so forth.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D`开关用于为CMake设置任何类型的变量：逻辑值、路径等。'
- en: How it works
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `option` command accepts three arguments:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`option`命令接受三个参数：'
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`<option_variable>` is the name of variable representing the option.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<option_variable>`是代表选项的变量名。'
- en: '`"help string"` is a string documenting the option. This documentation becomes
    visible in terminal-based or graphical user interfaces for CMake.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"帮助字符串"`是记录选项的字符串。此文档在CMake的终端或图形用户界面中可见。'
- en: '`[initial value]` is the default value for the option, either `ON` or `OFF`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[初始值]`是选项的默认值，可以是`ON`或`OFF`。'
- en: There is more
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Sometimes there is the need to introduce options that are dependent on the
    value of other options. In our example, we might wish to offer the option to either
    produce a static or a shared library. However, this option would have no meaning
    if the `USE_LIBRARY` logical was not set to `ON`. CMake offers the `cmake_dependent_option()`
    command to define options that depend on other options:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要引入依赖于其他选项值的选项。在我们的示例中，我们可能希望提供生成静态或共享库的选项。但是，如果`USE_LIBRARY`逻辑未设置为`ON`，则此选项将没有意义。CMake提供了`cmake_dependent_option()`命令来定义依赖于其他选项的选项：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If `USE_LIBRARY` is `ON`, `MAKE_STATIC_LIBRARY` defaults to `OFF`, while `MAKE_SHARED_LIBRARY`
    defaults to `ON`. So we can run this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`USE_LIBRARY`设置为`ON`，则`MAKE_STATIC_LIBRARY`默认为`OFF`，而`MAKE_SHARED_LIBRARY`默认为`ON`。因此，我们可以运行以下命令：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will still not build a library, since `USE_LIBRARY` is still set to `OFF`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不会构建库，因为`USE_LIBRARY`仍然设置为`OFF`。
- en: As mentioned earlier, CMake has mechanisms in place to extend its syntax and
    capabilities through the inclusion of *modules*, either shipped with CMake itself
    or custom ones. In this case, we have included a module called `CMakeDependentOption`.
    Without the include statement, the `cmake_dependent_option()` command would not
    be available for use. See also [https://cmake.org/cmake/help/latest/module/CMakeDependentOption.html](https://cmake.org/cmake/help/latest/module/CMakeDependentOption.html).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CMake通过包含*模块*来扩展其语法和功能，这些模块可以是CMake自带的，也可以是自定义的。在这种情况下，我们包含了一个名为`CMakeDependentOption`的模块。如果没有包含语句，`cmake_dependent_option()`命令将不可用。另请参阅[https://cmake.org/cmake/help/latest/module/CMakeDependentOption.html](https://cmake.org/cmake/help/latest/module/CMakeDependentOption.html)。
- en: The manual page for any module can also be accessed from the command line using
    `cmake --help-module <name-of-module>`. For example, `cmake --help-option CMakeDependentOption`
    will print the manual page for the module just discussed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 任何模块的手册页也可以使用`cmake --help-module <name-of-module>`从命令行访问。例如，`cmake --help-option
    CMakeDependentOption`将打印刚刚讨论的模块的手册页。
- en: Specifying the compiler
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定编译器
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-06)
    and has a C++/C example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-06)获取，并包含一个C++/C示例。该食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: One aspect that we have not given much thought to so far is the selection of
    compilers. CMake is sophisticated enough to select the most appropriate compiler
    given the platform and the generator. CMake is also able to set compiler flags
    to a sane set of defaults. However, often we wish to control the choice of the
    compiler, and in this recipe we will show how this can be done. In later recipes,
    we will also consider the choice of build type and show how to control compiler
    flags.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有过多考虑的一个方面是编译器的选择。CMake足够复杂，可以根据平台和生成器选择最合适的编译器。CMake还能够将编译器标志设置为一组合理的默认值。然而，我们通常希望控制编译器的选择，在本食谱中，我们将展示如何做到这一点。在后面的食谱中，我们还将考虑构建类型的选择，并展示如何控制编译器标志。
- en: How to do it
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'How can we select a specific compiler? For example, what if we want to use
    the Intel or Portland Group compilers? CMake stores compilers for each language
    in the `CMAKE_<LANG>_COMPILER` variable, where `<LANG>` is any of the supported
    languages, for our purposes `CXX`, `C`, or `Fortran`. The user can set this variable
    in one of two ways:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何选择特定的编译器？例如，如果我们想使用Intel或Portland Group编译器怎么办？CMake为每种语言的编译器存储在`CMAKE_<LANG>_COMPILER`变量中，其中`<LANG>`是任何受支持的语言，对我们来说，`CXX`、`C`或`Fortran`。用户可以通过以下两种方式之一设置此变量：
- en: 'By using the `-D` option in the CLI, for example:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在CLI中使用`-D`选项，例如：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By exporting the environment variables `CXX` for the C++ compiler, `CC` for
    the C compiler, and `FC` for the Fortran compiler. For example, use this command
    to use clang++ as the C++ compiler:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导出环境变量`CXX`用于C++编译器，`CC`用于C编译器，`FC`用于Fortran编译器。例如，使用此命令将clang++作为C++编译器：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Any of the recipes discussed so far can be configured for use with any other
    compiler by passing the appropriate option.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的任何配方都可以通过传递适当的选项配置为与任何其他编译器一起使用。
- en: CMake is aware of the environment and many options can either be set *via* the `-D` switch
    of its CLI or *via* an environment variable. The former mechanism overrides the
    latter, but we suggest to always set options explicitly with `-D`. **Explicit
    is better than implicit**, since environment variables might be set to values
    that are not suitable for the project at hand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: CMake了解环境，并且许多选项可以通过其CLI的`-D`开关*或*通过环境变量设置。前者机制覆盖后者，但我们建议始终使用`-D`显式设置选项。**显式优于隐式**，因为环境变量可能设置为不适合当前项目的值。
- en: We have here assumed that the additional compilers are available in the standard
    paths where CMake does its lookups. If that is not the case, the user will need
    to pass the *full path* to the compiler executable or wrapper.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里假设额外的编译器在CMake进行查找的标准路径中可用。如果不是这种情况，用户需要传递编译器可执行文件或包装器的*完整路径*。
- en: We recommend to set the compilers using the `-D CMAKE_<LANG>_COMPILER` CLI options
    instead of exporting `CXX`, `CC`, and `FC`. This is the only way that is guaranteed
    to be cross-platform and compatible with non-POSIX shells. It also avoids polluting
    your environment with variables, which may affect the environment for external
    libraries built together with your project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`-D CMAKE_<LANG>_COMPILER` CLI选项设置编译器，而不是导出`CXX`，`CC`和`FC`。这是唯一保证跨平台兼容且与非POSIX
    shell兼容的方法。它还可以避免用可能影响与项目一起构建的外部库的环境的变量污染您的环境。
- en: How it works
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: At configure time, CMake performs a series of platform tests to determine which
    compilers are available and if they are suitable for the project at hand. A suitable
    compiler is not only determined by the platform we are working on, but also by
    the generator we want to use. The first test CMake performs is based on the name
    of the compiler for the project language. For example, if `cc` is a working C
    compiler, then that is what will be used as the default compiler for a C project.
    On GNU/Linux, using Unix Makefiles or Ninja, the compilers in the GCC family will
    be most likely chosen by default for C++, C, and Fortran. On Microsoft Windows,
    the C++ and C compilers in Visual Studio will be selected, provided Visual Studio
    is the generator. MinGW compilers are the default if MinGW or MSYS Makefiles were
    chosen as generators.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置时，CMake执行一系列平台测试，以确定哪些编译器可用，以及它们是否适合手头的项目。合适的编译器不仅由我们工作的平台决定，还由我们要使用的生成器决定。CMake执行的第一个测试基于项目语言的编译器名称。例如，如果`cc`是一个工作的C编译器，那么它将用作C项目的默认编译器。在GNU
    / Linux上，使用Unix Makefiles或Ninja，GCC家族的编译器将最有可能被默认选择用于C ++，C和Fortran。在Microsoft
    Windows上，如果选择Visual Studio作为生成器，则将选择Visual Studio中的C ++和C编译器。如果选择MinGW或MSYS Makefiles作为生成器，则默认使用MinGW编译器。
- en: There is more
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Where can we find which default compilers and compiler flags will be picked
    up by CMake for our platform? CMake offers the `--system-information` flag, which
    will dump all information about your system to the screen or a file. To see this,
    try the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在哪里找到CMake将为我们平台选择哪些默认编译器和编译器标志？CMake提供了`--system-information`标志，该标志会将有关您系统的所有信息转储到屏幕或文件中。要查看此信息，请尝试以下操作：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Searching through the file (in this case, `information.txt`), you will find
    the default values for the `CMAKE_CXX_COMPILER`, `CMAKE_C_COMPILER`, and `CMAKE_Fortran_COMPILER`
    options, together with their default flags. We will have a look at the flags in
    the next recipe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件（在本例中为`information.txt`）中搜索，您将找到`CMAKE_CXX_COMPILER`，`CMAKE_C_COMPILER`和`CMAKE_Fortran_COMPILER`选项的默认值，以及它们的默认标志。我们将在下一个配方中查看这些标志。
- en: 'CMake provides additional variables to interact with compilers:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了其他变量来与编译器交互：
- en: '`CMAKE_<LANG>_COMPILER_LOADED`: This is set to `TRUE` if the language, `<LANG>`,
    was enabled for the project.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_COMPILER_LOADED`：如果为项目启用了语言`<LANG>`，则设置为`TRUE`。'
- en: '`CMAKE_<LANG>_COMPILER_ID`: The compiler identification string, unique to the
    compiler vendor. This is, for example, `GCC` for the GNU Compiler Collection, `AppleClang` for
    Clang on macOS, and `MSVC` for Microsoft Visual Studio Compiler. Note, however,
    that this variable is not guaranteed to be defined for all compilers or languages.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_COMPILER_ID`：编译器识别字符串，对于编译器供应商是唯一的。例如，对于GNU编译器集合，这是`GCC`，对于macOS上的Clang，这是`AppleClang`，对于Microsoft
    Visual Studio编译器，这是`MSVC`。但是请注意，不能保证此变量对所有编译器或语言都定义。'
- en: '`CMAKE_COMPILER_IS_GNU<LANG>`: This logical variable is set to `TRUE` if the
    compiler for the language `<LANG>` is part of the GNU Compiler Collection. Notice
    that the `<LANG>` portion of the variable name follows the GNU convention: it
    will be `CC` for the C language, `CXX` for the C++ language, and `G77` for the
    Fortran language.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_COMPILER_IS_GNU<LANG>`：如果语言`<LANG>`的编译器是GNU编译器集合的一部分，则此逻辑变量设置为`TRUE`。请注意，变量名称的`<LANG>`部分遵循GNU约定：对于C语言，它将是`CC`，对于C
    ++语言，它将是`CXX`，对于Fortran语言，它将是`G77`。'
- en: '`CMAKE_<LANG>_COMPILER_VERSION`: This variable holds a string with the version
    of the compiler for the given language. The version information is given in the `major[.minor[.patch[.tweak]]]`
    format. However, as for `CMAKE_<LANG>_COMPILER_ID`, this variable is not guaranteed
    to be defined for all compilers or languages.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_COMPILER_VERSION`：此变量包含给定语言的编译器版本的字符串。版本信息以`major[.minor[.patch[.tweak]]]`格式给出。但是，与`CMAKE_<LANG>_COMPILER_ID`一样，不能保证此变量对所有编译器或语言都定义。'
- en: 'We can try to configure the following example `CMakeLists.txt` with different
    compilers. In this example, we will use CMake variables to probe what compiler
    we are using and what version:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用不同的编译器配置以下示例`CMakeLists.txt`。在这个例子中，我们将使用CMake变量来探测我们正在使用的编译器及其版本：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Observe that this example does not contain any targets, so there is nothing
    to build and we will only focus on the configuration step:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例不包含任何目标，因此没有要构建的内容，我们只关注配置步骤：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The output will of course depend on the available and chosen compilers and compiler
    versions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出当然取决于可用和选择的编译器以及编译器版本。
- en: Switching the build type
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换构建类型
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-07)
    and has a C++/C example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-07)找到，并包含一个C++/C示例。该配方适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'CMake has the notion of build types or configurations, such as `Debug`, `Release`,
    and so forth. Within one configuration, one can collect related options or properties,
    such as compiler and linker flags, for a `Debug` or `Release` build. The variable
    governing the configuration to be used when generating the build system is `CMAKE_BUILD_TYPE`.
    This variable is empty by default, and the values recognized by CMake are:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CMake具有构建类型或配置的概念，例如`Debug`、`Release`等。在一种配置中，可以收集相关选项或属性，例如编译器和链接器标志，用于`Debug`或`Release`构建。控制生成构建系统时使用的配置的变量是`CMAKE_BUILD_TYPE`。该变量默认情况下为空，CMake识别的值包括：
- en: '`Debug` for building your library or executable without optimization and with
    debug symbols,'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Debug` 用于构建您的库或可执行文件，不带优化且带有调试符号，'
- en: '`Release` for building your library or executable with optimization and without
    debug symbols,'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Release` 用于构建您的库或可执行文件，带有优化且不带调试符号，'
- en: '`RelWithDebInfo` for building your library or executable with less aggressive
    optimizations and with debug symbols,'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RelWithDebInfo` 用于构建您的库或可执行文件，具有较不激进的优化和调试符号，'
- en: '`MinSizeRel` for building your library or executable with optimizations that
    do not increase object code size.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MinSizeRel` 用于构建您的库或可执行文件，优化不会增加对象代码大小。'
- en: How to do it
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'In this recipe, we will show how the build type can be set for an example project:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将展示如何为示例项目设置构建类型：
- en: 'We start out by defining the minimum CMake version, project name, and supported
    languages:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义了最小CMake版本、项目名称和支持的语言：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we set a default build type (in this case, `Release`) and print it in
    a message for the user. Note that the variable is set as a `CACHE` variable, so
    that it can be subsequently edited through the cache:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置了一个默认构建类型（在这种情况下，`Release`），并将其打印在消息中供用户查看。请注意，该变量被设置为`CACHE`变量，以便随后可以通过缓存进行编辑：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we print corresponding compile flags set by CMake as a function of
    the build type:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打印出由CMake根据构建类型设置的相应编译标志：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let us now verify the output of a default configuration:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们验证默认配置的输出：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And now, let us switch the build type:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们切换构建类型：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: We have demonstrated how to set a default build type and how to override it
    from the command line. With this, we can control whether a project is built with
    optimization flags or with all optimizations turned off, and instead debugging
    information on. We have also seen what kind of flags are used for the various
    available configurations, as this depends on the compiler of choice. Instead of
    printing the flags explicitly during a run of CMake, one can also peruse the output
    of running `cmake --system-information` to find out what the presets are for the
    current combination of platform, default compiler, and language. In the next recipe,
    we will discuss how to extend or adjust compiler flags for different compilers
    and different build types.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了如何设置默认构建类型以及如何从命令行覆盖它。通过这种方式，我们可以控制项目是使用优化标志构建，还是关闭所有优化并启用调试信息。我们还看到了不同可用配置使用的标志类型，这取决于所选的编译器。除了在CMake运行期间明确打印标志外，还可以通过运行`cmake
    --system-information`来查看当前平台、默认编译器和语言组合的预设。在下一个配方中，我们将讨论如何为不同的编译器和不同的构建类型扩展或调整编译器标志。
- en: There is more
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'We have shown how the variable `CMAKE_BUILD_TYPE` (documented at this link:
    [https://cmake.org/cmake/help/v3.5/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_BUILD_TYPE.html))
    defines the configuration of the generated build system. It is often helpful to
    build a project both in `Release` *and* `Debug` configurations, for example when
    assessing the effect of compiler optimization levels. For *single-configuration*
    generators, such as Unix Makefiles, MSYS Makefiles or Ninja, this requires running
    CMake twice, that is a full reconfiguration of the project. CMake however also
    supports *multiple-configuration* generators. These are usually project files
    offered by integrated-development environments, most notably Visual Studio and
    Xcode which can handle more than one configuration simultaneously. The available
    configuration types for these generators can be tweaked with the `CMAKE_CONFIGURATION_TYPES`
    variable which will accept a list of values (documentation available at this link:
    [https://cmake.org/cmake/help/v3.5/variable/CMAKE_CONFIGURATION_TYPES.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_CONFIGURATION_TYPES.html)).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了`CMAKE_BUILD_TYPE`变量（文档链接：[https://cmake.org/cmake/help/v3.5/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_BUILD_TYPE.html)）如何定义生成的构建系统的配置。在评估编译器优化级别的影响时，例如，构建项目的`Release`和`Debug`配置通常很有帮助。对于*单配置*生成器，如Unix
    Makefiles、MSYS Makefiles或Ninja，这需要运行CMake两次，即对项目进行完全重新配置。然而，CMake还支持*多配置*生成器。这些通常是由集成开发环境提供的项目文件，最著名的是Visual
    Studio和Xcode，它们可以同时处理多个配置。这些生成器的可用配置类型可以通过`CMAKE_CONFIGURATION_TYPES`变量进行调整，该变量将接受一个值列表（文档链接：[https://cmake.org/cmake/help/v3.5/variable/CMAKE_CONFIGURATION_TYPES.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_CONFIGURATION_TYPES.html)）。
- en: 'The following CMake invocation with the Visual Studio:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Visual Studio的CMake调用：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'will generate a build tree for both the `Release` and `Debug` configuration.
    You can then decide which of the two to build by using the `--config` flag:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成`Release`和`Debug`配置的构建树。然后，您可以使用`--config`标志决定构建哪一个：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When developing code with single-configuration generators, create separate build
    directories for the `Release` and `Debug` build types, both configuring the same
    source. With this, you can switch between the two without triggering a full reconfiguration
    and recompilation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单配置生成器开发代码时，为`Release`和`Debug`构建类型创建单独的构建目录，两者都配置相同的源代码。这样，您可以在两者之间切换，而不会触发完全重新配置和重新编译。
- en: Controlling compiler flags
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制编译器标志
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08)找到，并包含一个C++示例。本示例适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'The previous recipes showed how to probe CMake for information on the compilers
    and how to tune compiler optimizations for all targets in your project. The latter
    task is a subset of the general need to control which compiler flags are used
    in your project. CMake offers a lot of flexibility for adjusting or extending
    compiler flags and you can choose between two main approaches:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何向CMake查询有关编译器的信息，以及如何调整项目中所有目标的编译器优化。后一项任务是控制项目中使用哪些编译器标志的一般需求的一个子集。CMake提供了调整或扩展编译器标志的很大灵活性，您可以选择两种主要方法之一：
- en: CMake treats compile options as properties of targets. Thus, one can set compile
    options on a per target basis, without overriding CMake defaults.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake将编译选项视为目标的属性。因此，可以在不覆盖CMake默认设置的情况下，为每个目标设置编译选项。
- en: You can directly modify the `CMAKE_<LANG>_FLAGS_<CONFIG>` variables by using
    the `-D` CLI switch. These will affect all targets in the project and override
    or extend CMake defaults.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`-D` CLI开关，您可以直接修改`CMAKE_<LANG>_FLAGS_<CONFIG>`变量。这些变量将影响项目中的所有目标，并覆盖或扩展CMake的默认设置。
- en: In this recipe, we will show both approaches.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将展示这两种方法。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will compile an example program to calculate the area of different geometric
    shapes. The code has a `main` function in a file called `compute-areas.cpp`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编译一个计算不同几何形状面积的示例程序。代码在名为`compute-areas.cpp`的文件中有一个`main`函数：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The implementations of the various functions are contained in other files:
    each geometric shape has a header file and a corresponding source file. In total,
    we have four header files and five source files to compile:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 各种函数的实现包含在其他文件中：每个几何形状都有一个头文件和一个对应的源文件。总共，我们有四个头文件和五个源文件需要编译：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will not provide listings for all these files but rather refer the reader
    to [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为所有这些文件提供列表，而是引导读者参考[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-08)。
- en: How to do it
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now that we have the sources in place, our goal will be to configure the project
    and experiment with compiler flags:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了源文件，我们的目标将是配置项目并尝试使用编译器标志：
- en: 'We set the minimum required version of CMake:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置CMake的最低要求版本：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We declare the name of the project and the language:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明项目的名称和语言：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we print the current set of compiler flags. CMake will use these for
    all C++ targets:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印当前的编译器标志集。CMake将使用这些标志来编译所有C++目标：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We prepare a list of flags for our targets. Some of these will not be available
    on Windows and we make sure to account for that case:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为我们的目标准备了一份标志列表。其中一些在Windows上可能不可用，我们确保考虑到这种情况：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We add a new target, the `geometry` library and list its source dependencies:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个新的目标，`geometry`库及其源依赖项：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We set compile options for this library target:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个库目标设置编译选项：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We then add a target for the `compute-areas` executable:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`compute-areas`可执行文件添加一个目标：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also set compile options for the executable target:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为可执行目标设置编译选项：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we link the executable to the `geometry` library:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将可执行文件链接到`geometry`库：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In this example, the warning flags `-Wall`, `-Wextra`, and `-Wpedantic` will
    be added to the compile options for the `geometry` target; both the `compute-areas` and
    `geometry` targets will use the `-fPIC` flag. Compile options can be added with
    three levels of visibility: `INTERFACE`, `PUBLIC`, and `PRIVATE`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，警告标志`-Wall`、`-Wextra`和`-Wpedantic`将被添加到`geometry`目标的编译选项中；`compute-areas`和`geometry`目标都将使用`-fPIC`标志。编译选项可以通过三种可见性级别添加：`INTERFACE`、`PUBLIC`和`PRIVATE`。
- en: 'The visibility levels have the following meaning:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性级别具有以下含义：
- en: With the `PRIVATE` attribute, compile options will only be applied to the given
    target and not to other targets consuming it. In our examples, compiler options
    set on the `geometry` target will not be inherited by the `compute-areas`, even
    though `compute-areas` will link against the `geometry` library.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PRIVATE`属性，编译选项将仅应用于给定目标，而不会应用于其他消费它的目标。在我们的示例中，设置在`geometry`目标上的编译器选项不会被`compute-areas`继承，尽管`compute-areas`会链接到`geometry`库。
- en: With the `INTERFACE` attribute, compile options on a given target will only
    be applied to targets consuming it.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`INTERFACE`属性，给定目标的编译选项将仅应用于消费它的目标。
- en: With the `PUBLIC` attribute, compile options will be applied to the given target
    and all other targets consuming it.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PUBLIC`属性，编译选项将应用于给定目标以及所有其他消费它的目标。
- en: The visibility levels of target properties are at the core of a modern usage
    of CMake and we will revisit this topic often and extensively throughout the book.
    Adding compile options in this way does not pollute the `CMAKE_<LANG>_FLAGS_<CONFIG>` global
    CMake variables and gives you granular control over what options are used on which
    targets.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的可见性级别是现代CMake使用的核心，我们将在本书中经常并广泛地回顾这个主题。以这种方式添加编译选项不会污染`CMAKE_<LANG>_FLAGS_<CONFIG>`全局CMake变量，并给你对哪些选项用于哪些目标的精细控制。
- en: 'How can we verify whether the flags are correctly used as we intended to? Or
    in other words, how can you discover which compile flags are actually used by
    a CMake project? One approach is the following and it uses CMake to pass additional
    arguments, in this case the environment variable `VERBOSE=1`, to the native build
    tool:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何验证标志是否如我们所愿正确使用？换句话说，你如何发现一个CMake项目实际上使用了哪些编译标志？一种方法是使用CMake传递额外的参数，在这种情况下是环境变量`VERBOSE=1`，给本地构建工具：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding output confirms that the compile flags were correctly set according
    to our instructions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出确认编译标志根据我们的指示正确设置。
- en: 'The second approach to controlling compiler flags involves no modifications
    to `CMakeLists.txt`. If one wants to modify compiler options for the `geometry`
    and `compute-areas` targets in this project, it is as easy as invoking CMake with
    an additional argument:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 控制编译器标志的第二种方法不涉及对`CMakeLists.txt`的任何修改。如果想要为该项目中的`geometry`和`compute-areas`目标修改编译器选项，只需使用一个额外的参数调用CMake即可。
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you might have guessed, this command will compile the project, deactivating
    exceptions and runtime type identification (RTTI).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这个命令将编译项目，禁用异常和运行时类型识别（RTTI）。
- en: 'The two approaches can also be coupled. One can use a basic set of flags globally,
    while keeping control of what happens on a per target basis. We can use `CMakeLists.txt`
    and running this command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法也可以结合使用。可以使用一组基本的标志全局设置，同时保持对每个目标发生的情况的控制。我们可以使用`CMakeLists.txt`并运行这个命令：
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will configure the `geometry` target with `-fno-exceptions -fno-rtti -fPIC
    -Wall -Wextra -Wpedantic`, while configuring `compute-areas` with `-fno-exceptions
    -fno-rtti -fPIC`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`-fno-exceptions -fno-rtti -fPIC -Wall -Wextra -Wpedantic`配置`geometry`目标，同时使用`-fno-exceptions
    -fno-rtti -fPIC`配置`compute-areas`。
- en: In the rest of the book, we will generally set compiler flags on a per target
    basis and this is the practice that we recommend for your projects. Using `target_compile_options()`
    not only allows for a fine-grained control over compilation options, but it also
    integrates better with more advanced features of CMake.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们通常会为每个目标设置编译器标志，这是我们推荐您项目采用的做法。使用 `target_compile_options()` 不仅允许对编译选项进行细粒度控制，而且还更好地与CMake的更高级功能集成。
- en: There is more
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Most of the time, flags are compiler-specific. Our current example will only
    work with GCC and Clang; compilers from other vendors will not understand many,
    if not all, of those flags. Clearly, if a project aims at being truly cross-platform,
    this problem has to be solved. There are three approaches to this.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，标志是编译器特定的。我们当前的示例仅适用于GCC和Clang；其他供应商的编译器将不理解许多，如果不是全部，这些标志。显然，如果一个项目旨在真正跨平台，这个问题必须解决。有三种方法可以解决这个问题。
- en: The most typical approach will append a list of desired compiler flags to each
    configuration type CMake variable, that is, to `CMAKE_<LANG>_FLAGS_<CONFIG>`.
    These flags are set to what is known to work for the given compiler vendor, and
    will thus be enclosed in
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最典型的方法是将所需的一组编译器标志附加到每个配置类型的CMake变量，即 `CMAKE_<LANG>_FLAGS_<CONFIG>`。这些标志设置为已知适用于给定编译器供应商的内容，因此将包含在
- en: '`if-endif` clauses that check the `CMAKE_<LANG>_COMPILER_ID` variable, for
    example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-endif` 子句检查 `CMAKE_<LANG>_COMPILER_ID` 变量，例如：'
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A more refined approach does not tamper with the `CMAKE_<LANG>_FLAGS_<CONFIG>`
    variables at all and rather defines project-specific lists of flags:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更精细的方法根本不修改 `CMAKE_<LANG>_FLAGS_<CONFIG>` 变量，而是定义项目特定的标志列表：
- en: '[PRE64]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Later on, it uses generator expressions to set compiler flags on a per-configuration
    and per-target basis:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，它使用生成器表达式以每个配置和每个目标为基础设置编译器标志：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have shown both approaches in the current recipe and have clearly recommended
    the latter (project-specific variables and `target_compile_options`) over the
    former (CMake variables).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在当前的配方中展示了这两种方法，并明确推荐后者（项目特定变量和 `target_compile_options()`）而不是前者（CMake变量）。
- en: Both approaches work and are widely used in many projects. However, they have
    shortcomings. As we have already mentioned, `CMAKE_<LANG>_COMPILER_ID` is not
    guaranteed to be defined for all compiler vendors. In addition, some flags might
    become deprecated or might have been introduced in a later version of the compiler.
    Similarly to `CMAKE_<LANG>_COMPILER_ID`, the `CMAKE_<LANG>_COMPILER_VERSION` variable is
    not guaranteed to be defined for all languages and vendors. Although checking
    on these variables is quite popular, we think that a more robust alternative would
    be to check whether a desired set of flags works with the given compiler, so that
    only effectively working flags are actually used in the project. Combined with
    the use of project-specific variables, `target_compile_options`, and generator
    expressions, this approach is quite powerful. We will show how to use this check-and-set
    pattern in Recipe 3, *Writing a f**unction to test and set compiler flags*, in [Chapter
    7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring Projects*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有效，并在许多项目中广泛使用。然而，它们也有缺点。正如我们已经提到的，`CMAKE_<LANG>_COMPILER_ID`并不保证为所有编译器供应商定义。此外，某些标志可能会被弃用，或者可能在编译器的较新版本中引入。与`CMAKE_<LANG>_COMPILER_ID`类似，`CMAKE_<LANG>_COMPILER_VERSION`变量并不保证为所有语言和供应商定义。尽管检查这些变量非常流行，但我们认为更稳健的替代方案是检查给定编译器是否支持所需的标志集，以便仅在项目中实际使用有效的标志。结合使用项目特定变量、`target_compile_options`和生成器表达式，这种方法非常强大。我们将在第3个示例中展示如何使用这种检查和设置模式，即[第7章](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml)中的“编写一个函数来测试和设置编译器标志”。
- en: Setting the standard for the language
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置语言标准
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09)
    and has a C++ and Fortran example. The recipe is valid with CMake version 3.5
    (and higher) and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09)获取，包含C++和Fortran示例。本示例适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'Programming languages have different standards available, that is, different
    versions that offer new and improved language constructs. Enabling new standards
    is accomplished by setting the appropriate compiler flag. We have shown in the
    previous recipe how this can be done, either on a per-target basis or globally.
    With its 3.1 version, CMake introduced a platform- and compiler-independent mechanism
    for setting the language standard for C++ and C: setting the `<LANG>_STANDARD`
    property for targets.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有不同的标准可供选择，即提供新改进语言结构的不同版本。启用新标准是通过设置适当的编译器标志来实现的。我们在前面的示例中展示了如何做到这一点，无论是针对特定目标还是全局设置。CMake
    3.1版本引入了针对C++和C语言标准的平台和编译器无关机制：为目标设置`<LANG>_STANDARD`属性。
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the following example, we will require a C++ compiler compliant with the
    C++14 standard or later. The code for this recipe defines a polymorphic hierarchy
    of animals. We use `std::unique_ptr` for the base class in the hierarchy:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下示例，我们将要求C++编译器符合C++14标准或更高版本。本示例代码定义了一个动物的多态层次结构。我们在层次结构的基类中使用`std::unique_ptr`：
- en: '[PRE66]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Instead of explicitly using constructors for the various subtypes, we use an
    implementation of the factory method. The factory is implemented using C++11 *variadic
    templates*. It holds a map of creation functions for each object in the inheritance
    hierarchy:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有明确使用各种子类型的构造函数，而是使用工厂方法的实现。工厂使用C++11的*可变参数模板*实现。它保存了继承层次结构中每个对象的创建函数映射：
- en: '[PRE67]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It dispatches them based on a preassigned tag, so that creation of objects
    will look like the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据预先分配的标签进行分派，以便对象的创建将如下所示：
- en: '[PRE68]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The tags and creation functions are registered to the factory prior to its
    use:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在工厂使用之前，将标签和创建函数注册到工厂：
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are defining the creation functions using C++11 *lambda* functions. Notice
    the use of `std::make_unique` to avoid introducing the naked `new` operator. This
    helper was introduced in C++14.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C++11的*lambda*函数定义创建函数。注意使用`std::make_unique`来避免引入裸`new`操作符。这个辅助函数是在C++14中引入的。
- en: This functionality of CMake was added in version 3.1 and is ever-evolving. Later
    versions of CMake have added better and better support for later versions of the
    C++ standard and different compilers. We recommend that you check whether your
    compiler of choice is supported on the documentation webpage: [https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此CMake功能是在版本3.1中添加的，并且一直在不断发展。CMake的后续版本为C++标准的后续版本和不同的编译器提供了越来越好的支持。我们建议您检查您的首选编译器是否受支持，请访问文档网页：[https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers)。
- en: How to do it
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We will construct the `CMakeLists.txt` step by step and show how to require
    a certain standard (in this case C++14):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步构建 `CMakeLists.txt` 并展示如何要求特定的标准（在本例中为C++14）：
- en: 'We state the minimum required CMake version, project name, and language:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了所需的最低CMake版本、项目名称和语言：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We request all library symbols to be exported on Windows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要求在Windows上导出所有库符号：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We need to add a target for the library. This will compile the sources into
    a shared library:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为库添加一个目标。这将编译源代码成一个共享库：
- en: '[PRE72]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We now set the `CXX_STANDARD`, `CXX_EXTENSIONS`, and `CXX_STANDARD_REQUIRED` properties for
    the target. We also set the `POSITION_INDEPENDENT_CODE` property, to avoid issues
    when building the DSO with some compilers:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为目标设置 `CXX_STANDARD`、`CXX_EXTENSIONS` 和 `CXX_STANDARD_REQUIRED` 属性。我们还设置了
    `POSITION_INDEPENDENT_CODE` 属性，以避免在某些编译器上构建DSO时出现问题：
- en: '[PRE73]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we add a new target for the `animal-farm` executable and set its properties:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为 `animal-farm` 可执行文件添加一个新的目标并设置其属性：
- en: '[PRE74]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, we link the executable to the library:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将可执行文件链接到库：
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let us also check what our example cat and dog have to say:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也检查一下我们的例子中的猫和狗有什么要说的：
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In steps 4 and 5, we set a number of properties for the `animals` and `animal-farm`
    targets:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤4和5中，我们为 `animals` 和 `animal-farm` 目标设置了一系列属性：
- en: '`CXX_STANDARD` mandates the standard that we would like to have.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX_STANDARD` 规定了我们希望采用的标准。'
- en: '`CXX_EXTENSIONS` tells CMake to only use compiler flags that will enable the
    ISO C++ standard, without compiler-specific extensions.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX_EXTENSIONS` 告诉CMake只使用将启用ISO C++标准的编译器标志，而不使用编译器特定的扩展。'
- en: '`CXX_STANDARD_REQUIRED` specifies that the version of the standard chosen is
    required. If this version is not available, CMake will stop configuration with
    an error. When this property is set to `OFF`, CMake will look for next latest
    version of the standard, until a proper flag has been set. This means to first
    look for C++14, then C++11, then C++98.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX_STANDARD_REQUIRED` 指定所选标准版本是必需的。如果该版本不可用，CMake将以错误停止配置。当此属性设置为 `OFF` 时，CMake将查找下一个最新的标准版本，直到设置了适当的标志。这意味着首先查找C++14，然后是C++11，然后是C++98。'
- en: At the time of writing, there is no `Fortran_STANDARD` property available yet,
    but the standard can be set using `target_compile_options`; see [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，还没有 `Fortran_STANDARD` 属性可用，但可以使用 `target_compile_options` 设置标准；请参阅 [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-09)。
- en: If the language standard is a global property shared by all targets, you can
    set the `CMAKE_<LANG>_STANDARD`, `CMAKE_<LANG>_EXTENSIONS`, and `CMAKE_<LANG>_STANDARD_REQUIRED` variables to
    their desired values. The corresponding properties on all targets will be set
    with these values.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语言标准是所有目标共享的全局属性，您可以将 `CMAKE_<LANG>_STANDARD`、`CMAKE_<LANG>_EXTENSIONS` 和
    `CMAKE_<LANG>_STANDARD_REQUIRED` 变量设置为所需值。所有目标上的相应属性将使用这些值进行设置。
- en: There is more
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: CMake offers an even finer level of control over the language standard by introducing
    the concept of *compile features*. These are features introduced by the language
    standard, such as variadic templates and lambdas in C++11, and automatic return
    type deduction in C++14\. You can ask for certain features to be available for
    specific targets with the `target_compile_features()` command and CMake will automatically
    set the correct compiler flag for the standard. It is also possible to have CMake
    generate compatibility headers for optional compiler features.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: CMake通过引入*编译特性*的概念，提供了对语言标准的更精细控制。这些特性是由语言标准引入的，例如C++11中的可变参数模板和lambda，以及C++14中的自动返回类型推导。您可以通过`target_compile_features()`命令要求特定目标支持某些特性，CMake会自动为该标准设置正确的编译器标志。CMake还可以为可选的编译器特性生成兼容性头文件。
- en: 'We recommend reading the online documentation for `cmake-compile-features`
    to get a complete overview of how CMake can handle compile features and language
    standards: [https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议阅读`cmake-compile-features`的在线文档，以全面了解CMake如何处理编译特性和语言标准：[https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html)。
- en: Using control flow constructs
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制流结构
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-10)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-01/recipe-10)找到，并附有一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'We have used `if-elseif-endif` constructs in previous recipes of this chapter.
    CMake also offers language facilities for creating loops: `foreach-endforeach`
    and `while-endwhile`. Both can be combined with `break` for breaking from the
    enclosing loop early. This recipe will show you how to use `foreach` to loop over
    a list of source files. We will apply such a loop to lower the compiler optimization
    for a set of source files without introducing a new target.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前的食谱中，我们已经使用了`if-elseif-endif`结构。CMake还提供了创建循环的语言设施：`foreach-endforeach`和`while-endwhile`。两者都可以与`break`结合使用，以提前从封闭循环中跳出。本食谱将向您展示如何使用`foreach`遍历源文件列表。我们将对一组源文件应用这样的循环，以降低编译器优化，而不引入新的目标。
- en: Getting ready
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will reuse the geometry example introduced in Recipe 8, *Controlling compiler
    flags*. Our goal will be to fine-tune the compiler optimization for some of the
    sources by collecting them into a list.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用本章第8个食谱中引入的`geometry`示例，*控制编译器标志*。我们的目标是通过将它们收集到一个列表中，对一些源文件的编译器优化进行微调。
- en: How to do it
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'These are the detailed steps to follow in `CMakeLists.txt`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`CMakeLists.txt`中需要遵循的详细步骤：
- en: 'As in Recipe 8, *Controlling compiler flags*, we specify the minimum required
    version of CMake, project name, and language, and declare the `geometry` library
    target:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第8个食谱，*控制编译器标志*一样，我们指定了所需的最低CMake版本、项目名称和语言，并声明了`geometry`库目标：
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We decide to compile the library with the `-O3` compiler optimization level.
    This is set as a `PRIVATE` compiler option on the target:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们决定以`-O3`编译器优化级别编译库。这作为目标的`PRIVATE`编译选项设置：
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, we generate a list of source files to be compiled with lower optimization:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成一份需要以较低优化级别编译的源文件列表：
- en: '[PRE79]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We loop over these source files to tune their optimization level down to `-O2`.
    This is done using their source file properties:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历这些源文件，将它们的优化级别调整至`-O2`。这是通过使用它们的源文件属性来完成的：
- en: '[PRE80]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To make sure source properties were set, we loop once again and print the `COMPILE_FLAGS`
    property on each of the sources:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保设置了源属性，我们再次遍历并打印每个源的`COMPILE_FLAGS`属性：
- en: '[PRE81]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we add the `compute-areas` executable target and link it against the
    `geometry` library:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了`compute-areas`可执行目标，并将其与`geometry`库链接：
- en: '[PRE82]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let us verify that the flags were correctly set at the configure step:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证在配置步骤中标志是否正确设置：
- en: '[PRE83]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, also check the build step with `VERBOSE=1`. You will see that the
    `-O2` flag gets appended to the `-O3` flag but the last optimization level flag
    (in this case `-O2`) "wins":'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`VERBOSE=1`检查构建步骤。您将看到`-O2`标志被附加到`-O3`标志上，但最终的优化级别标志（在这种情况下是`-O2`）“胜出”：
- en: '[PRE84]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The `foreach-endforeach` syntax can be used to express the repetition of certain
    tasks over a list of variables. In our case, we used it to manipulate, set, and
    get the compiler flags of specific files in the project. This CMake snippet introduced
    two additional new commands:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach-endforeach`语法可以用来表达对一组变量的重复任务。在我们的例子中，我们使用它来操作、设置和获取项目中特定文件的编译器标志。这个CMake代码片段引入了两个额外的新的命令：'
- en: '`set_source_files_properties(file PROPERTIES property value)`, which sets the
    property to the passed value for the given file. Much like targets, files also
    have properties in CMake. This allows for extremely fine-grained control over
    the build system generation. The list of available properties for source files
    can be found here: [https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#source-file-properties](https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#source-file-properties).'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_source_files_properties(file PROPERTIES property value)`，它为给定文件设置属性到传递的值。与目标类似，文件在CMake中也有属性。这允许对构建系统生成进行极其精细的控制。源文件可用属性的列表可以在这里找到：[https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#source-file-properties](https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#source-file-properties)。'
- en: '`get_source_file_property(VAR file property)`, which retrieves the value of
    the desired property for the given file and stores it in the CMake `VAR` variable.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_source_file_property(VAR file property)`，它检索给定文件的所需属性的值，并将其存储在CMake的`VAR`变量中。'
- en: In CMake, lists are semicolon-separated groups of strings. A list can be created
    either by the `list` or the `set` commands. For example, both `set(var a b c d
    e)` and `list(APPEND a b c d e)` create the list `a;b;c;d;e`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中，列表是由分号分隔的字符串组。列表可以通过`list`命令或`set`命令创建。例如，`set(var a b c d e)`和`list(APPEND
    a b c d e)`都创建了列表`a;b;c;d;e`。
- en: To lower optimization for a set of files, it would probably be cleaner to collect
    them into a separate target (library) and set the optimization level explicitly
    for this target instead of appending a flag, but in this recipe our focus was
    on `foreach-endforeach`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降低一组文件的优化级别，将它们收集到一个单独的目标（库）中，并为该目标显式设置优化级别，而不是附加一个标志，这可能更清晰。但在本例中，我们的重点是`foreach-endforeach`。
- en: There is more
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'The `foreach()` construct can be used in four different ways:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach()`构造可以以四种不同的方式使用：'
- en: '`foreach(loop_var arg1 arg2 ...)`: Where a loop variable and an explicit list
    of items are provided. This form was used when printing the compiler flag sets
    for the items in `sources_with_lower_optimization`. Note that if the list of items
    is in a variable, it has to be explicitly expanded; that is, `${sources_with_lower_optimization}`
    has to be passed as an argument.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach(loop_var arg1 arg2 ...)`：提供了一个循环变量和一个明确的项列表。当打印`sources_with_lower_optimization`中项的编译器标志集时，使用了这种形式。请注意，如果项列表在一个变量中，它必须被显式展开；也就是说，必须将`${sources_with_lower_optimization}`作为参数传递。'
- en: As a loop over integer numbers by specifying a range, such as `foreach(loop_var
    RANGE total)` or alternatively
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对整数的循环，通过指定一个范围，例如`foreach(loop_var RANGE total)`，或者替代地
- en: '`foreach(loop_var RANGE start stop [step])`.'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`foreach(loop_var RANGE start stop [step])`。'
- en: As a loop over list-valued variables, such as `foreach(loop_var IN LISTS [list1
    [...]])`. The arguments are interpreted as lists and their contents automatically
    expanded accordingly.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对列表值变量的循环，例如`foreach(loop_var IN LISTS [list1 [...]])`。参数被解释为列表，并且它们的内含物会自动相应地展开。
- en: As a loop over items, such as `foreach(loop_var IN ITEMS [item1 [...]])`. The
    contents of the arguments are not expanded.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对项的循环，例如`foreach(loop_var IN ITEMS [item1 [...]])`。参数的内容不会展开。
