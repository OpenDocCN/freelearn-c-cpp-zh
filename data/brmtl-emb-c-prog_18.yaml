- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Power Management and Energy Efficiency in Embedded Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统中的电源管理和能源效率
- en: In this chapter, we will delve into power management and energy efficiency in
    embedded systems, a critical aspect in today’s technology-driven world. Efficient
    power management is vital for prolonging battery life and ensuring optimal performance
    in embedded devices. This chapter aims to equip you with the necessary knowledge
    and skills to implement effective power management techniques in your designs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究嵌入式系统中的电源管理和能源效率，这是当今技术驱动世界的一个关键方面。有效的电源管理对于延长电池寿命和确保嵌入式设备的最佳性能至关重要。本章旨在为你提供实施有效电源管理技术的必要知识和技能。
- en: We will begin by exploring various power management techniques, laying the foundation
    to understand how to reduce power consumption in embedded systems. Following this,
    we will examine the different sleep modes and low-power states available in STM32F4
    microcontrollers, providing detailed insights into their configurations and applications.
    Then, we will discuss the wake-up sources and triggers in the STM32F4, which are
    essential to ensure that the microcontroller can respond promptly to external
    events. Finally, we will put theory into practice by developing a driver to enter
    standby mode and wake up the microcontroller, demonstrating how to apply these
    concepts in real-world scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨各种电源管理技术，为理解如何在嵌入式系统中降低功耗奠定基础。随后，我们将检查STM32F4微控制器中可用的不同睡眠模式和低功耗状态，提供它们配置和应用的详细见解。然后，我们将讨论STM32F4中的唤醒源和触发器，这对于确保微控制器能够迅速响应外部事件至关重要。最后，我们将通过开发一个进入待机模式和唤醒微控制器的驱动程序来将理论应用于实践，展示如何在现实场景中应用这些概念。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: An overview of power management techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源管理技术概述
- en: Low-power modes in STM32F4
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32F4中的低功耗模式
- en: Wake-up sources and triggers in STM32F4
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32F4中的唤醒源和触发器
- en: Developing a driver to enter standby mode and wake up
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发进入待机模式和唤醒的驱动程序
- en: By the end of this chapter, you will have a thorough understanding of power
    management in embedded systems and be able to implement energy-efficient designs
    using STM32F4 microcontrollers. This knowledge will enable you to create embedded
    systems that optimize power consumption and extend battery life, essential for
    modern applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将彻底理解嵌入式系统中的电源管理，并能够使用STM32F4微控制器实现节能设计。这些知识将使你能够创建优化功耗并延长电池寿命的嵌入式系统，这对于现代应用至关重要。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: An overview of power management techniques
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电源管理技术概述
- en: In this section, we will explore the world of power management techniques, a
    crucial aspect of embedded systems design. As our devices become more advanced
    and our expectations for battery life increase, understanding how to manage power
    effectively is more important than ever. Let’s dive into the various power management
    techniques and how they are implemented, taking a look at some case studies to
    see these techniques in action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索电源管理技术的世界，这是嵌入式系统设计的一个关键方面。随着我们的设备变得更加先进，我们对电池寿命的期望也在增加，了解如何有效管理电源比以往任何时候都更重要。让我们深入了解各种电源管理技术及其实现方式，通过一些案例研究来观察这些技术在实际中的应用。
- en: Power management in embedded systems involves a combination of hardware and
    software strategies designed to reduce energy consumption. This is particularly
    important for battery-powered devices, where efficient power usage can significantly
    extend battery life. The main techniques we’ll cover include **Dynamic Voltage
    and Frequency Scaling** (**DVFS**), clock gating, power gating, and utilizing
    low-power modes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中的电源管理涉及一系列硬件和软件策略，旨在降低能耗。这对于电池供电设备尤为重要，高效的电源使用可以显著延长电池寿命。我们将涵盖的主要技术包括**动态电压和频率缩放**（**DVFS**）、时钟门控、电源门控以及利用低功耗模式。
- en: Let’s start with DVFS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从DVFS开始。
- en: Dynamic Voltage and Frequency Scaling (DVFS)
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态电压和频率缩放（DVFS）
- en: DVFS is a method where the voltage and frequency of a microcontroller are adjusted
    based on the workload. By lowering the voltage and frequency during periods of
    low activity, power consumption can be greatly reduced. Conversely, during periods
    of high demand, the voltage and frequency are increased to ensure performance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DVFS是一种根据工作负载调整微控制器电压和频率的方法。在低活动期间降低电压和频率可以大大减少功耗。相反，在高需求期间，电压和频率会增加以确保性能。
- en: How is DVFS implemented?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DVFS是如何实现的？
- en: In STM32 microcontrollers, DVFS can be managed through specific power control
    registers. These registers allow a system to dynamically adjust the operating
    points based on the required performance levels. For example, the STM32F4 series
    has several power modes that can be configured to adjust the system clock and
    core voltage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32微控制器中，可以通过特定的电源控制寄存器管理DVFS。这些寄存器允许系统根据所需的性能级别动态调整工作点。例如，STM32F4系列具有几种可以配置以调整系统时钟和核心电压的电源模式。
- en: An example use case – mobile phones
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个用例示例——智能手机
- en: Mobile phones are a prime example of DVFS in action. When a phone is idle, it
    reduces the CPU frequency and voltage to save the battery. As soon as you start
    using an app or playing a game, the CPU ramps up its frequency and voltage to
    provide the necessary performance. This balance between performance and power
    savings is what makes modern smartphones so efficient.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 智能手机是DVFS应用的典型例子。当手机处于空闲状态时，它会降低CPU频率和电压以节省电池。一旦开始使用应用程序或玩游戏，CPU会提高其频率和电压以提供必要的性能。这种性能与节能之间的平衡使得现代智能手机如此高效。
- en: Another common technique is clock gating.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的技术是时钟门控。
- en: Clock gating
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟门控
- en: Clock gating is a technique where the clock signal to certain parts of a microcontroller
    is turned off when they are not in use. This prevents unnecessary switching of
    transistors, which in turn saves power.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟门控是一种技术，当微控制器的某些部分未使用时，会关闭其时钟信号。这防止了不必要的晶体管切换，从而节省了电力。
- en: How is clock gating implemented?
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟门控是如何实现的？
- en: Clock gating is typically controlled through clock control registers. In the
    STM32 series, each peripheral’s clock can be enabled or disabled individually
    using these registers. For instance, if a particular peripheral such as the ADC
    is not needed, its clock can be disabled to save power.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟门控通常通过时钟控制寄存器进行控制。在STM32系列中，可以通过这些寄存器单独启用或禁用每个外设的时钟。例如，如果某个外设如ADC不需要，其时钟可以被禁用以节省功耗。
- en: An example use case – smart home devices
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个用例示例——智能家居设备
- en: Smart home devices such as smart thermostats or lights use clock gating to manage
    power efficiently. These devices spend a significant amount of time in a low-power
    state, waking up only to perform specific tasks. By gating the clock to unused
    peripherals, these devices can conserve energy and extend their battery life.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居设备，如智能恒温器或灯光，使用时钟门控来高效管理电力。这些设备大部分时间处于低功耗状态，仅在执行特定任务时唤醒。通过关闭未使用外设的时钟，这些设备可以节约能源并延长电池寿命。
- en: Another technique is power gating.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是电源门控。
- en: Power gating
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电源门控
- en: Power gating takes power savings a step further by completely shutting off the
    power to certain parts of a microcontroller. This technique ensures zero power
    consumption for the powered-down sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 电源门控通过完全关闭微控制器某些部分的电源，将节能提升到一个新的层次。这种技术确保了关闭部分的零功耗。
- en: How is power gating implemented?
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电源门控是如何实现的？
- en: Power gating is more complex than clock gating and often involves dedicated
    power management units within a microcontroller. These units control the power
    supply to various domains of the microcontroller. In STM32 microcontrollers, power
    gating can be configured using the power control registers to turn off specific
    peripherals, or even entire sections of the microcontroller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 电源门控比时钟门控更复杂，通常涉及微控制器内部的专用电源管理单元。这些单元控制微控制器各个域的电源。在STM32微控制器中，可以通过电源控制寄存器配置电源门控，以关闭特定的外设，甚至整个微控制器的部分。
- en: An example use case – wearable devices
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个用例示例——可穿戴设备
- en: Wearable devices, such as fitness trackers, benefit greatly from power gating.
    These devices need to operate for extended periods on a single charge. By powering
    down sensors and other components when they are not in use, wearables can achieve
    longer battery life without compromising functionality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴设备，如健身追踪器，从电源门控技术中受益匪浅。这些设备需要单次充电长时间运行。通过在不用时关闭传感器和其他组件的电源，可穿戴设备可以在不牺牲功能的情况下实现更长的电池寿命。
- en: Next, let’s discuss low-power modes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论低功耗模式。
- en: Low-power modes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低功耗模式
- en: Low-power modes are predefined states within microcontrollers that significantly
    reduce power consumption by disabling or reducing the functionality of various
    components. These modes range from simple CPU sleep modes to more complex deep
    sleep or standby modes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 低功耗模式是微控制器中预定义的状态，通过禁用或减少各种组件的功能，可以显著降低功耗。这些模式从简单的CPU睡眠模式到更复杂的深度睡眠或待机模式不等。
- en: How are low-power modes implemented?
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现低功耗模式？
- en: Low-power modes are implemented through the power control registers. The STM32F4
    microcontrollers, for example, offer several low-power modes, including **sleep**,
    **stop**, and **standby**. Each mode provides a different balance between power
    savings and wake-up time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 低功耗模式通过电源控制寄存器实现。例如，STM32F4微控制器提供多种低功耗模式，包括**睡眠**、**停止**和**待机**。每种模式都提供了不同的节能和唤醒时间之间的平衡。
- en: An example use case – remote sensors
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个用例示例 – 远程传感器
- en: Remote sensors used in agriculture or environmental monitoring often use low-power
    modes. These sensors might spend the majority of their time in a low-power state,
    waking up periodically to take measurements and transmit data. By leveraging low-power
    modes, these sensors can operate for months or even years on a single battery
    charge.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在农业或环境监测中使用的远程传感器通常使用低功耗模式。这些传感器可能大部分时间处于低功耗状态，定期唤醒以进行测量和传输数据。通过利用低功耗模式，这些传感器可以在单次电池充电下运行数月甚至数年。
- en: Now, let’s take a closer look at a couple of case studies that illustrate how
    a combination of these power management techniques is used in real-world applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地研究几个案例研究，这些研究说明了这些电源管理技术在现实世界应用中的组合使用。
- en: Case study 1 – an energy-efficient smartwatch
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究1 – 高效智能手表
- en: 'Smartwatches are a great example of a device that relies heavily on power management
    techniques. These devices need to balance performance with battery life, as users
    expect them to run for days on a single charge. Let’s break down the roles the
    different techniques play in an energy-efficient smartwatch design:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 智能手表是依赖电源管理技术的一个很好的例子。这些设备需要在性能和电池寿命之间取得平衡，因为用户期望它们在单次充电下运行数天。让我们分析一下不同技术在高效智能手表设计中的作用：
- en: '**DVFS**: The smartwatch uses DVFS to adjust the CPU frequency based on the
    current workload. When the user interacts with the watch, the CPU frequency increases
    to provide a smooth experience. When the watch is idle, the frequency is lowered
    to save power.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态电压频率调整（DVFS）**：智能手表使用DVFS根据当前的工作负载调整CPU频率。当用户与手表交互时，CPU频率增加以提供流畅的体验。当手表空闲时，频率降低以节省电力。'
- en: '**Clock gating**: Peripherals such as the GPS or heart rate monitor are only
    powered when needed. When these features are not in use, their clocks are gated
    to conserve energy.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟门控**：如GPS或心率监测器等外围设备仅在需要时供电。当这些功能不使用时，它们的时钟被门控以节省能源。'
- en: '**Power gating**: Components like the display driver are powered down completely
    when the display is off.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源门控**：当显示器关闭时，像显示驱动器这样的组件会完全断电。'
- en: '**Low-power modes**: The watch enters deep sleep mode during periods of inactivity,
    waking up only to check for notifications or user interactions.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低功耗模式**：在非活动期间，手表进入深度睡眠模式，仅在检查通知或用户交互时唤醒。'
- en: By combining these techniques, smartwatches can achieve impressive battery life
    without compromising on functionality. Another excellent example is solar-powered
    environmental monitoring.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些技术，智能手表可以在不牺牲功能的情况下实现令人印象深刻的电池寿命。另一个优秀的例子是太阳能环境监测。
- en: Case study 2 – a solar-powered environmental monitor
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究2 – 太阳能环境监测器
- en: 'A solar-powered environmental monitor deployed in remote locations must operate
    efficiently to ensure continuous data collection and transmission. The roles are
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 部署在偏远地区的太阳能环境监测器必须高效运行，以确保连续的数据收集和传输。其角色如下：
- en: '**DVFS**: The monitor adjusts its operating frequency based on the intensity
    of sunlight and battery charge. During peak sunlight hours, it operates at a higher
    frequency to process more data.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态电压频率调整（DVFS）**：监控器根据阳光强度和电池充电量调整其工作频率。在阳光最强烈的小时，它以更高的频率运行以处理更多数据。'
- en: '**Clock gating**: Sensors such as temperature, humidity, and air quality are
    only active during data collection intervals. The clocks to these sensors are
    gated when not in use.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟门控**：例如温度、湿度和空气质量等传感器仅在数据收集间隔期间活跃。当不使用时，这些传感器的时钟会被门控。'
- en: '**Power gating**: Non-essential components are completely powered down during
    nighttime or cloudy periods to conserve energy.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源门控**：在夜间或阴天期间，非必要组件完全关闭电源以节省能源。'
- en: '**Low-power modes**: The monitor enters deep sleep mode between data collection
    intervals, waking up periodically to take measurements and transmit data.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低功耗模式**：监控器在数据收集间隔之间进入深度睡眠模式，定期醒来进行测量和传输数据。'
- en: With these power management techniques, the monitor can operate autonomously
    for extended periods, relying solely on solar power.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些电源管理技术，监控器可以自主运行很长时间，仅依靠太阳能。
- en: Power management is a vital aspect of embedded system design, especially as
    devices become more portable and battery-dependent. By understanding and implementing
    techniques such as DVFS, clock gating, power gating, and low-power modes, we can
    design embedded systems that are both powerful and energy-efficient. Whether it’s
    a smartwatch, a remote sensor, or any other battery-powered device, effective
    power management ensures longer battery life and better overall performance. As
    we continue to push the boundaries of what embedded systems can do, mastering
    these power management techniques will be more important than ever.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 电源管理是嵌入式系统设计的重要方面，尤其是在设备变得更加便携和依赖电池的情况下。通过理解和实施DVFS、时钟门控、电源门控和低功耗模式等技术，我们可以设计出既强大又节能的嵌入式系统。无论是智能手表、远程传感器还是任何其他电池供电设备，有效的电源管理确保了更长的电池寿命和更好的整体性能。随着我们不断推动嵌入式系统能力的边界，掌握这些电源管理技术将比以往任何时候都更加重要。
- en: In the next section, we will explore the low-power modes in our STM32F4 microcontroller.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索STM32F4微控制器中的低功耗模式。
- en: Low-power modes in STM32F4
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4的低功耗模式
- en: In this section, we will learn about the low-power modes available in STM32F4
    microcontrollers. We’ll cover the various low-power modes, how to configure them,
    and the practical aspects of using them in your projects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习STM32F4微控制器中可用的低功耗模式。我们将涵盖各种低功耗模式、如何配置它们以及在项目中使用它们的实际方面。
- en: Let’s start by understanding these low-power modes. Low-power modes in the STM32F4
    microcontrollers are designed to reduce power consumption by disabling or limiting
    the functionality of certain components. The STM32F4 offers several low-power
    states, each providing a different balance between power savings and wake-up latency.
    These modes include sleep, stop, and standby modes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解这些低功耗模式开始。STM32F4微控制器中的低功耗模式旨在通过禁用或限制某些组件的功能来降低功耗。STM32F4提供几种低功耗状态，每个状态在节能和唤醒延迟之间提供不同的平衡。这些模式包括睡眠、停止和待机模式。
- en: We can put our system into low-power mode by executing the`SLEEPONEXIT` bit
    in the **Cortex®-M4 with FPU system control register** on return from an ISR.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在从中断服务例程（ISR）返回时执行**Cortex®-M4 with FPU系统控制寄存器**中的`SLEEPONEXIT`位来将我们的系统置于低功耗模式。
- en: Let’s dive into the details of each low-power mode, starting with sleep mode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每种低功耗模式的细节，从睡眠模式开始。
- en: Sleep mode
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 睡眠模式
- en: Sleep mode is the most basic low-power mode, where the CPU clock is stopped
    but peripherals continue to operate. This mode offers a **quick wake-up time**,
    making it ideal for applications that require frequent transitions between active
    and low-power states.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠模式是最基本的低功耗模式，在这种模式下，CPU时钟停止，但外设继续运行。这种模式提供了**快速唤醒时间**，使其非常适合需要频繁在活动状态和低功耗状态之间切换的应用。
- en: 'To enter sleep mode, we need to clear the `SLEEPDEEP` bit in the **System Control
    Register** (**SCR**) and then execute the WFI or WFE instruction, as shown in
    the following snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入睡眠模式，我们需要清除**系统控制寄存器**（**SCR**）中的`SLEEPDEEP`位，然后执行WFI或WFE指令，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The microcontroller **exits Sleep mode upon any interrupt or event**. Since
    the peripherals remain active, any configured interrupt from a peripheral can
    wake the CPU.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器在**任何中断或事件发生时退出睡眠模式**。由于外设保持活跃，任何配置的外设中断都可以唤醒CPU。
- en: An example use case is **sensor monitoring**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例用例是**传感器监控**。
- en: For applications such as continuous sensor monitoring, sleep mode provides an
    efficient way to reduce power consumption without sacrificing responsiveness.
    The microcontroller can wake up quickly to process sensor data and then return
    to sleep mode.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连续传感器监控等应用，睡眠模式提供了一种在不过度牺牲响应性的情况下有效降低功耗的方法。微控制器可以快速唤醒以处理传感器数据，然后返回睡眠模式。
- en: The next mode is stop mode.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个模式是停止模式。
- en: Stop mode
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止模式
- en: Stop mode offers a **deeper power-saving state than sleep mode** by stopping
    the main internal regulator and halting the system clock. Only the low-speed clock
    (LSI or LSE) remains active. This mode provides a **moderate wake-up time** and
    significant power savings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 停止模式通过停止主内部稳压器和系统时钟提供了比睡眠模式**更深层次的节能状态**。只有低速时钟（LSI或LSE）保持活跃。这种模式提供了**适中的唤醒时间**和显著的节能效果。
- en: 'To enter stop mode, set the `SLEEPDEEP` bit in the (`PWR_CR`), and then execute
    the WFI or WFE instruction, as shown in the following snippet. Additional configuration
    can also be applied to further reduce power consumption in stop mode:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入停止模式，在`PWR_CR`中设置`SLEEPDEEP`位，然后执行WFI或WFE指令，如下面的代码片段所示。还可以应用其他配置以进一步降低停止模式下的功耗：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The MCU exits stop mode upon any **external interrupt** or **wake-up event from****configured
    EXTI lines**, **RTC alarms**, or other configured wake-up sources. The wake-up
    time from stop mode is longer than from sleep mode, but it still allows for a
    relatively quick return to full operation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生任何**外部中断**或**配置的EXTI线上的唤醒事件**、**RTC警报**或其他配置的唤醒源时，MCU将退出停止模式。从停止模式唤醒的时间比从睡眠模式长，但它仍然允许相对快速地返回到完全操作状态。
- en: An example use case is **periodic** **data logging**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例用例是**周期性** **数据记录**。
- en: In applications such as data logging, a microcontroller can remain in stop mode
    and wake up periodically, based on RTC alarms, to log data, and then return to
    stop mode. This significantly reduces power consumption while ensuring regular
    data logging.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据记录等应用中，微控制器可以保持在停止模式，并根据RTC警报定期唤醒以记录数据，然后返回停止模式。这显著降低了功耗，同时确保了定期数据记录。
- en: The final mode is standby mode.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种模式是等待模式。
- en: Standby mode
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待模式
- en: Standby mode provides the **highest power savings** by turning off most internal
    circuitry, including the main regulator. Only a small portion of the microcontroller
    remains powered to monitor wake-up sources. This mode has the **longest wake-up
    time** but offers the lowest power consumption.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 等待模式通过关闭大部分内部电路，包括主稳压器，提供了**最高的节能效果**。只有微控制器的一小部分保持供电以监控唤醒源。这种模式具有**最长的唤醒时间**，但提供了最低的功耗。
- en: 'To enter standby mode, set the `PDDS` and `SLEEPDEEP` bits in the Power Control
    (`PWR_CR`) register, and then configure the wake-up sources. This snippet demonstrates
    how to enter standby mode:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入等待模式，在电源控制（`PWR_CR`）寄存器中设置`PDDS`和`SLEEPDEEP`位，然后配置唤醒源。以下代码片段演示了如何进入等待模式：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The microcontroller exits standby mode upon a **wake-up event from an external
    wake-up pin (WKUP)**, an RTC alarm, or a reset event. When the microcontroller
    wakes up from standby mode, it **undergoes a full reset sequence**, and the execution
    starts from the reset vector.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当微控制器从等待模式唤醒时，它**执行完整的复位序列**，并从复位向量开始执行。
- en: An example use case is **remote** **IoT devices**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例用例是**远程** **物联网设备**。
- en: Standby mode is perfect for remote IoT devices that need to operate for extended
    periods on battery power. These devices can remain in standby mode most of the
    time and wake up only for critical events or scheduled tasks, thus maximizing
    battery life.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 等待模式非常适合需要长时间在电池供电下运行远程物联网设备。这些设备大部分时间可以保持在等待模式，仅在关键事件或计划任务时唤醒，从而最大化电池寿命。
- en: Now that we understand how to enter the various low-power modes, we will look
    at how to wake up from them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何进入各种低功耗模式，我们将探讨如何从这些模式中唤醒。
- en: Wake-up sources and triggers from low-power modes in STM32F4
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32F4低功耗模式中的唤醒源和触发器
- en: While low-power modes help conserve energy, ensuring that a microcontroller
    can wake up promptly when needed is equally important. The STM32F4 microcontroller
    series provides a variety of wake-up sources and triggers to handle this effectively.
    In this section, we’ll explore these wake-up sources, how they function, and their
    practical applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然低功耗模式有助于节省能源，但确保微控制器在需要时能够迅速唤醒同样重要。STM32F4微控制器系列提供了各种唤醒源和触发器来有效处理这种情况。在本节中，我们将探讨这些唤醒源、它们的工作方式以及它们的实际应用。
- en: Understanding wake-up sources
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解唤醒源
- en: Wake-up sources are mechanisms that bring a microcontroller out of a low-power
    state. The STM32F4 offers several types of wake-up sources, each suited for different
    scenarios. These include external interrupts, RTC alarms, watchdog timers, and
    various internal events. By understanding these triggers, we can design systems
    that balance power efficiency with responsiveness.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 唤醒源是使微控制器从低功耗状态唤醒的机制。STM32F4提供了多种唤醒源，每种都适用于不同的场景。这些包括外部中断、RTC闹钟、看门狗定时器和各种内部事件。通过理解这些触发器，我们可以设计出在功耗效率和响应性之间取得平衡的系统。
- en: 'The wake-up sources can be grouped as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 唤醒源可以分为以下几类：
- en: External interrupts
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部中断
- en: '**Real-Time Clock** (**RTC**) alarms'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时时钟**（**RTC**）闹钟'
- en: Internal events
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部事件
- en: Let’s delve into each of these wake-up sources to understand how they work and
    their typical use cases.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这些唤醒源，以了解它们的工作原理和典型用例。
- en: External interrupts
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部中断
- en: External interrupts are one of the primary wake-up sources for STM32F4 microcontrollers.
    These interrupts can be triggered by events on specific GPIO pins. When a microcontroller
    is in a low-power mode, an external signal, such as a button press or sensor output,
    can wake it up.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 外部中断是STM32F4微控制器的主要唤醒源之一。这些中断可以由特定GPIO引脚上的事件触发。当微控制器处于低功耗模式时，外部信号，如按钮按下或传感器输出，可以唤醒它。
- en: 'Here’s how it works:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: '**GPIO configuration**: Configure the GPIO pins to act as interrupt sources.
    This involves setting pin mode and enabling the interrupt on the desired edge
    (rising, falling, or both).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO配置**：配置GPIO引脚作为中断源。这涉及到设置引脚模式并在所需的边缘（上升沿、下降沿或两者）上启用中断。'
- en: '**EXTI configuration**: Each GPIO pin can be mapped to an EXTI line, which
    can be configured to generate an interrupt.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXTI配置**：每个GPIO引脚都可以映射到一个EXTI线路，该线路可以配置为生成中断。'
- en: '**NVIC configuration**: Enable the EXTI line interrupt in the **Nested Vectored
    Interrupt Controller** (**NVIC**) to ensure that the microcontroller responds
    to the external event.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NVIC配置**：在**嵌套向量中断控制器**（**NVIC**）中启用EXTI线路中断，以确保微控制器能够响应外部事件。'
- en: Example use cases are a **smart doorbell system and** **smart lighting**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例子用例包括**智能门铃系统**和**智能照明**。
- en: Imagine a smart doorbell system. The microcontroller remains in a low-power
    mode to conserve battery life. When someone presses the doorbell button (connected
    to a GPIO pin), an external interrupt is triggered, waking the microcontroller
    to process the event and send a notification to the homeowner. Another excellent
    example is smart home lighting systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个智能门铃系统。微控制器保持低功耗模式以节省电池寿命。当有人按下门铃按钮（连接到GPIO引脚）时，会触发一个外部中断，唤醒微控制器以处理事件并向房主发送通知。另一个优秀的例子是智能家居照明系统。
- en: A smart home lighting system needs to conserve energy while being responsive
    to user inputs. The microcontroller stays in a low-power mode until an external
    interrupt (e.g., a motion sensor detecting movement) wakes it up. Upon waking,
    the microcontroller processes the event, turns on the lights, and then goes back
    to sleep after a predefined period of inactivity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居照明系统需要在节省能源的同时对用户输入做出响应。微控制器保持低功耗模式，直到外部中断（例如，运动传感器检测到运动）唤醒它。唤醒后，微控制器处理事件，打开灯光，然后在预定义的不活动期间后再次进入睡眠状态。
- en: The next wake-up source we will examine is the RTC Alarm.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要检查的下一个唤醒源是RTC闹钟。
- en: RTC alarms
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RTC闹钟
- en: The RTC is a versatile peripheral that can generate wake-up events at specific
    intervals or predefined times. It is particularly useful for applications requiring
    periodic wake-ups, such as data logging or scheduled tasks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RTC是一个多功能的外围设备，可以在特定间隔或预定义的时间生成唤醒事件。它特别适用于需要定期唤醒的应用，如数据记录或计划任务。
- en: 'Here’s how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: '**RTC configuration**: Configure the RTC to generate alarms or periodic wake-up
    events. This involves setting the RTC clock source, enabling the wake-up timer,
    and setting the alarm time.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RTC 配置**：配置 RTC 以生成报警或周期性唤醒事件。这包括设置 RTC 时钟源、启用唤醒定时器以及设置报警时间。'
- en: '**Interrupt handling**: Enable the RTC alarm or wake-up interrupt in the NVIC
    to ensure that the microcontroller wakes up when the alarm or timer event occurs.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断处理**：在 NVIC 中启用 RTC 报警或唤醒中断，以确保微控制器在报警或定时器事件发生时唤醒。'
- en: '*An example use case* is an **environmental** **monitoring system**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个示例用例*是**环境****监测系统**。'
- en: Consider a remote environmental monitoring system that logs temperature and
    humidity data. The microcontroller can be put into low-power mode, waking up at
    regular intervals (e.g., every hour) using RTC alarms to read sensors and log
    data, and then return to the low-power state.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个远程环境监测系统，该系统记录温度和湿度数据。微控制器可以被置于低功耗模式，使用 RTC 报警定期唤醒（例如，每小时一次），以读取传感器并记录数据，然后返回到低功耗状态。
- en: The final wake-up sources we will examine are **internal events**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后唤醒源是**内部事件**。
- en: Internal events
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部事件
- en: 'Apart from external triggers, internal events can also wake up a microcontroller
    from low-power modes. These events include the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了外部触发器之外，内部事件也可以从低功耗模式唤醒微控制器。这些事件包括以下内容：
- en: '**Peripheral events**: Events generated by internal peripherals, such as ADC
    conversions or communication interface activity'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围事件**：由内部外围设备生成的事件，例如 ADC 转换或通信接口活动'
- en: '**System events**: Internal system events such as power voltage detection or
    clock stability issues'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统事件**：如电源电压检测或时钟稳定性问题等内部系统事件'
- en: 'Here’s how it works:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: '**Peripheral configuration**: Configure the peripheral to generate interrupts
    upon specific events. For instance, an ADC can generate an interrupt when a conversion
    is complete.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围配置**：配置外围设备，使其在特定事件发生时生成中断。例如，ADC 可以在转换完成后生成中断。'
- en: '**Event handling**: Enable the relevant interrupts in the NVIC to handle these
    internal events and wake the microcontroller.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**：在 NVIC 中启用相关中断以处理这些内部事件并唤醒微控制器。'
- en: '*An example use case* is a **fitness tracker**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个示例用例*是**健身追踪器**'
- en: A wearable fitness tracker that monitors heart rate can use the ADC to read
    sensor data. The microcontroller stays in a low-power mode and wakes up when the
    ADC completes a conversion, allowing it to process and store the heart rate data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个监测心率的可穿戴健身追踪器可以使用 ADC 读取传感器数据。微控制器处于低功耗模式，当 ADC 完成转换时唤醒，从而允许其处理和存储心率数据。
- en: Before we conclude this section, let’s summarize some key practical considerations
    to keep in mind when configuring wake-up sources.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结本节之前，让我们总结一些在配置唤醒源时需要记住的关键实际考虑因素。
- en: Practical considerations
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际考虑因素
- en: 'When configuring wake-up sources, you must consider the following practical
    aspects:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置唤醒源时，您必须考虑以下实际方面：
- en: '**Response time**: Ensure the chosen wake-up source can provide the required
    response time for your application. External interrupts typically offer the fastest
    wake-up times.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：确保所选唤醒源可以提供您应用所需的最快响应时间。外部中断通常提供最快的唤醒时间。'
- en: '**Power consumption**: Balance power consumption with wake-up requirements.
    RTC alarms and watchdog timers can be configured for periodic wake-ups with minimal
    power overhead.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功耗**：平衡功耗和唤醒需求。RTC 报警和看门狗定时器可以配置为周期性唤醒，同时功耗最小化。'
- en: '**Reliability**: Choose reliable wake-up sources for critical applications.
    Watchdog timers are essential for safety-critical systems to ensure that a microcontroller
    can recover from faults.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：为关键应用选择可靠的唤醒源。看门狗定时器对于确保微控制器可以从故障中恢复的安全关键系统至关重要。'
- en: '**Peripheral configuration**: Ensure that peripherals needed for wake-up are
    properly configured and their clocks remain enabled, even in low-power states.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围配置**：确保所需的唤醒外围设备已正确配置，并且即使在低功耗状态下，它们的时钟也保持启用。'
- en: Understanding and properly configuring these wake-up sources ensures that your
    embedded systems are both energy-efficient and reliable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并正确配置这些唤醒源确保您的嵌入式系统既节能又可靠。
- en: In the next section, we will learn how to develop a driver to enter standby
    mode and subsequently wake up the system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何开发一个驱动程序以进入待机模式，并随后唤醒系统。
- en: Developing a driver to enter standby mode and wake up
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发进入待机模式和唤醒的驱动程序
- en: Create a copy of your previous project in your IDE, following the steps outlined
    in earlier chapters. Rename this copied project `StandByModeWithWakeupPin`. Next,
    create a new file named `standby_mode.c` in the `Src` folder, and then another
    file named `standby_mode.h` in the `Inc` folder.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中创建您之前项目的副本，按照前面章节中概述的步骤进行。将此复制的项目重命名为`StandByModeWithWakeupPin`。接下来，在`Src`文件夹中创建一个名为`standby_mode.c`的新文件，然后在`Inc`文件夹中创建一个名为`standby_mode.h`的新文件。
- en: 'Populate your `standby_mode.c` file with the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`standby_mode.c`文件中填充以下代码：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function is responsible for configuring `PA0` to be used as a wake-up
    pin for exiting low-power mode. It sets `PA0` as an input pin by clearing the
    corresponding bits in the `GPIOA` mode register, and then it configures the pin
    with no pull-up or pull-down resistors:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责配置`PA0`作为退出低功耗模式的唤醒引脚。它通过清除`GPIOA`模式寄存器中的相应位将`PA0`设置为输入引脚，然后配置该引脚不带上拉或下拉电阻：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function prepares the microcontroller to enter standby mode and ensures
    that it can wake up via the configured wake-up pin. It begins by waiting for the
    wake-up pin to be released, ensuring that the pin is in a stable state before
    proceeding. The function then disables the wake-up pin to clear any residual settings,
    followed by clearing all wake-up flags to reset the wake-up status. After re-enabling
    the wake-up pin, the function sets the power mode to Standby by configuring the
    appropriate power control register. Finally, the function executes the WFI instruction,
    placing the microcontroller into standby mode until an interrupt occurs, triggering
    the wake-up process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使微控制器准备进入待机模式，并确保它可以通过配置的唤醒引脚唤醒。它首先等待唤醒引脚释放，确保在继续之前引脚处于稳定状态。然后该函数禁用唤醒引脚以清除任何残留设置，随后清除所有唤醒标志以重置唤醒状态。重新启用唤醒引脚后，该函数通过配置适当的电源控制寄存器将电源模式设置为待机。最后，该函数执行WFI指令，将微控制器置于待机模式，直到发生中断，触发唤醒过程：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function checks the current state of the wake-up pin (`PA0`). It reads
    the input data register (`IDR`) for `GPIOA` and performs a bitwise `AND` operation
    with the wake-up pin’s bit mask (`WK_PIN`). This operation isolates the state
    of `PA0`. The function then compares this result to the bit mask itself to determine
    whether the pin is high. If `PA0` is high, the function returns `true`; otherwise,
    it returns `false`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检查唤醒引脚（`PA0`）的当前状态。它读取`GPIOA`的输入数据寄存器（`IDR`）并执行与唤醒引脚位掩码（`WK_PIN`）的位与操作。此操作隔离了`PA0`的状态。然后该函数将此结果与位掩码本身进行比较，以确定引脚是否为高。如果`PA0`为高，则函数返回`true`；否则，返回`false`：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function configures the power mode of the STM32F4 microcontroller by modifying
    specific bits in `PWR_CR`. This function takes a parameter, `pwr_mode`, which
    specifies the desired power mode settings. It uses the `MODIFY_REG` macro to update
    the `PWR_CR` register, specifically targeting the bits related to different power
    modes such as **PDDS** (**Power Down Deepsleep**), **LPDS** (**Low-Power Deepsleep**),
    **FPDS** (**Flash Power Down in Stop Mode**), **LPLVDS** (**Low-Power Regulator
    in Low Voltage in Deepsleep**), and **MRLVDS** (**Main Regulator in Low Voltage**
    **in Deepsleep**).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过修改`PWR_CR`中的特定位来配置STM32F4微控制器的电源模式。此函数接受一个参数`pwr_mode`，它指定所需的电源模式设置。它使用`MODIFY_REG`宏来更新`PWR_CR`寄存器，具体针对与不同电源模式相关的位，如**PDDS**（**深度睡眠掉电**）、**LPDS**（**低功耗深度睡眠**）、**FPDS**（**停止模式中闪存掉电**）、**LPLVDS**（**深度睡眠中低电压下的低功耗稳压器**）和**MRLVDS**（**深度睡眠中低电压下的主稳压器**）。
- en: 'Next, we will populate the `standby_mode.h` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将填充`standby_mode.h`文件：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#include <stdio.h>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include <string.h>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <string.h>'
- en: '#include "standby_mode.h"'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "standby_mode.h"'
- en: '#include "gpio_exti.h"'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "gpio_exti.h"'
- en: '#include "uart.h"'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: uint8_t g_btn_press;
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: uint8_t g_btn_press;
- en: static void check_reset_source(void);
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: static void check_reset_source(void);
- en: int main(void)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: uart_init();
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: uart_init();
- en: wakeup_pin_init();
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: wakeup_pin_init();
- en: /*Find reset source*/
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: /*查找复位源*/
- en: check_reset_source();
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: check_reset_source();
- en: /*Initialize EXTI*/
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: /*初始化EXTI*/
- en: pc13_exti_init();
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: pc13_exti_init();
- en: while(1)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: static void check_reset_source(void)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: static void check_reset_source(void)
- en: '{'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Enable clock access to PWR*/
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: /*启用对PWR的时钟访问*/
- en: RCC->APB1ENR |= RCC_APB1ENR_PWREN;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: RCC->APB1ENR |= RCC_APB1ENR_PWREN;
- en: if ((PWR->CSR & PWR_CSR_SBF) == (PWR_CSR_SBF))
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: if ((PWR->CSR & PWR_CSR_SBF) == (PWR_CSR_SBF))
- en: '{'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Clear Standby flag*/
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: /*清除待机标志*/
- en: PWR->CR |= PWR_CR_CSBF;
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: PWR->CR |= PWR_CR_CSBF;
- en: printf("System resume from Standby.....\n\r");
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: printf("系统从待机恢复.....\n\r");
- en: /*Wait for wakeup pin to be released*/
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: /*等待唤醒引脚释放*/
- en: while(get_wakeup_pin_state() == 0){}
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: while(get_wakeup_pin_state() == 0){}
- en: '}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: /*Check and Clear Wakeup flag*/
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: /*检查并清除唤醒标志位*/
- en: if((PWR->CSR & PWR_CSR_WUF) == PWR_CSR_WUF )
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: if((PWR->CSR & PWR_CSR_WUF) == PWR_CSR_WUF )
- en: '{'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: PWR->CR |= PWR_CR_CWUF;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: PWR->CR |= PWR_CR_CWUF;
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: static void exti_callback(void)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: static void exti_callback(void)
- en: '{'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: standby_wakeup_pin_setup();
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: standby_wakeup_pin_setup();
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: void EXTI15_10_IRQHandler(void) {
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: void EXTI15_10_IRQHandler(void) {
- en: if((EXTI->PR & LINE13)!=0)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: if((EXTI->PR & LINE13) != 0)
- en: '{'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Clear PR flag*/
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: /*清除PR标志位*/
- en: EXTI->PR |=LINE13;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: EXTI->PR |= LINE13;
- en: //Do something...
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: //执行某些操作...
- en: exti_callback();
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: exti_callback();
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
