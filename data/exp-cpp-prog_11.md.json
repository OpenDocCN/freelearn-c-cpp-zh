["```cpp\n #include <pthread.h>\n int pthread_create(\n              pthread_t *thread,\n              const pthread_attr_t *attr,\n              void *(*start_routine)(void*),\n              void *arg\n )\n```", "```cpp\nint pthread_join ( pthread_t *thread, void **retval )\n```", "```cpp\nint pthread_exit ( void *retval )\n```", "```cpp\npthread_t pthread_self(void)\n```", "```cpp\n#include <pthread.h>\n#include <iostream>\n\nusing namespace std;\n\nvoid* threadProc ( void *param ) {\n  for (int count=0; count<3; ++count)\n    cout << \"Message \" << count << \" from \" << pthread_self()\n         << endl;\n  pthread_exit(0);\n}\n\nint main() {\n  pthread_t thread1, thread2, thread3;\n\n  pthread_create ( &thread1, NULL, threadProc, NULL );\n  pthread_create ( &thread2, NULL, threadProc, NULL );\n  pthread_create ( &thread3, NULL, threadProc, NULL );\n\n  pthread_join( thread1, NULL );\n  pthread_join( thread2, NULL );\n\n  pthread_join( thread3, NULL );\n\n  return 0;\n\n}\n```", "```cpp\ng++ main.cpp -lpthread\n```", "```cpp\nint main() {\n    values.push_back(42);\n```", "```cpp\n    thread tr1(threadFnc, 1);\n    thread tr2(threadFnc, 2);\n    thread tr3(threadFnc, 3);\n    thread tr4(threadFnc, 4);\n```", "```cpp\n    tr1.join();\n    tr2.join();\n    tr3.join();\n    tr4.join();\n```", "```cpp\nvoid threadFnc(int tid) {\n    cout_mtx.lock();\n    cout << \"Starting thread \" << tid << \".n\";\n    cout_mtx.unlock();\n```", "```cpp\n    values_mtx.lock();\n    int val = values[0];\n    values_mtx.unlock();\n```", "```cpp\n    int rval = randGen(0, 10);\n    val += rval;\n```", "```cpp\nint randGen(const int& min, const int& max) {\n    static thread_local mt19937 generator(hash<thread::id>() (this_thread::get_id()));\n    uniform_int_distribution<int> distribution(min, max);\n    return distribution(generator);\n}\n```", "```cpp\n    cout_mtx.lock();\n    cout << \"Thread \" << tid << \" adding \" << rval << \". New value: \" << val << \".n\";\n    cout_mtx.unlock();\n\n    values_mtx.lock();\n    values.push_back(val);\n    values_mtx.unlock();\n}\n```", "```cpp\n    variables\n        wants_to_enter : array of 2 booleans\n        turn : integer\n\n    wants_to_enter[0] \u2190 false\n    wants_to_enter[1] \u2190 false\n    turn \u2190 0 // or 1\np0:\n    wants_to_enter[0] \u2190 true\n    while wants_to_enter[1] {\n        if turn \u2260 0 {\n            wants_to_enter[0] \u2190 false\n            while turn \u2260 0 {\n                // busy wait\n            }\n            wants_to_enter[0] \u2190 true\n        }\n    }\n    // critical section\n    ...\n    turn \u2190 1\n    wants_to_enter[0] \u2190 false\n    // remainder section\np1:\n    wants_to_enter[1] \u2190 true\n    while wants_to_enter[0] {\n        if turn \u2260 1 {\n            wants_to_enter[1] \u2190 false\n            while turn \u2260 1 {\n                // busy wait\n            }\n            wants_to_enter[1] \u2190 true\n        }\n    }\n    // critical section\n    ...\n    turn \u2190 0\n    wants_to_enter[1] \u2190 false\n    // remainder section\n```", "```cpp\n#include <iostream>\n#include <future>\nusing namespace std;\n\nvoid sayHello( ) {\n  cout << endl << \"Hello Concurrency support library!\" << endl;\n}\n\nint main ( ) {\n  future<void> futureObj = async ( launch::async, sayHello );\n  futureObj.wait( );\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\nusing namespace std;\n\nvoid sayHello( promise<string> promise_ ) {\n  promise_.set_value ( \"Hello Concurrency support library!\" );\n}\n\nint main ( ) {\n  promise<string> promiseObj;\n\n  future<string> futureObj = promiseObj.get_future( );\n  async ( launch::async, sayHello, move( promiseObj ) );\n  cout << futureObj.get( ) << endl;\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <promise>\n#include <thread>\n#include <functional>\nusing namespace std;\n\nint main ( ) {\n     packaged_task<int (int, int)>\n        addTask ( [] ( int firstInput, int secondInput ) {\n              return firstInput + secondInput;\n     } );\n\n     future<int> output = addTask.get_future( );\n     addTask ( 15, 10 );\n\n     cout << \"The sum of 15 + 10 is \" << output.get() << endl;\n     return 0;\n}\n```", "```cpp\naddTask ( [] ( int firstInput, int secondInput ) {\n              return firstInput + secondInput;\n}); \n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <thread>\n#include <functional>\nusing namespace std;\n\nint add ( int firstInput, int secondInput ) {\n  return firstInput + secondInput;\n}\n\nint main ( ) {\n  packaged_task<int (int, int)> addTask( add);\n\n  future<int> output = addTask.get_future( );\n\n  thread addThread ( move(addTask), 15, 10 );\n\n  addThread.join( );\n\n  cout << \"The sum of 15 + 10 is \" << output.get() << endl;\n\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <string>\nusing namespace std;\n\nint add ( int firstInput, int secondInput ) {\n  return firstInput + secondInput;\n}\n\nint main ( ) {\n\n  packaged_task<int (int,int)> addTask( add );\n  future<int> output = addTask.get_future();\n  thread addThread ( move(addTask), 15, 10);\n  addThread.join();\n  cout << \"The sum of 15 + 10 is \" << output.get() << endl;\n  return 0;\n}\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\n#include <promise>\nusing namespace std;\n\nvoid add ( int firstInput, int secondInput, promise<int> output ) {\n  try {\n         if ( ( INT_MAX == firstInput ) || ( INT_MAX == secondInput ) )\n             output.set_exception( current_exception() ) ;\n        }\n  catch(...) {}\n\n       output.set_value( firstInput + secondInput ) ;\n\n}\n\nint main ( ) {\n\n     try {\n    promise<int> promise_;\n          future<int> output = promise_.get_future();\n    async ( launch::deferred, add, INT_MAX, INT_MAX, move(promise_) );\n          cout << \"The sum of INT_MAX + INT_MAX is \" << output.get ( ) << endl;\n     }\n     catch( exception e ) {\n  cerr << \"Exception occured\" << endl;\n     }\n}\n\n```", "```cpp\ng++ main.cpp -o concurrency.exe -std=c++17 -lpthread\n```"]