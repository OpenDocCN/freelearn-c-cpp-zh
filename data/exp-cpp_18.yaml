- en: Using C++ in Machine Learning Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在机器学习任务中使用C++
- en: '**Artificial intelligence** (**AI**) and **machine learning** (**ML**) have
    become more and more popular recently. From a simple food delivery website to
    complex industrial robots, AI has been declared as one of the main features powering
    software and hardware. While, most of the time, the terms are used to make the
    product look more serious, some companies are intensively researching and incorporating
    AI into their systems.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能（AI）和机器学习（ML）最近变得越来越受欢迎。从简单的食品送货网站到复杂的工业机器人，AI已被宣称为支持软件和硬件的主要特性之一。虽然大多数时候这些术语被用来使产品看起来更严肃，但一些公司正在密集地研究并将AI纳入其系统中。
- en: Before we go further, take into account the fact that this chapter is a gentle
    introduction to ML from a C++ programmer's perspective. For more comprehensive
    literature, refer to the list of books at the end of the chapter. In this chapter,
    we will introduce the concepts of AI and ML. While it is preferred to have a mathematical
    background, we almost don't use any math in this chapter. If you are planning
    to enlarge your skillset and dive into ML, you must consider studying mathematics
    first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请考虑到这一章是从C++程序员的角度对机器学习进行温和介绍。对于更全面的文献，请参考本章末尾的书籍列表。在本章中，我们将介绍人工智能和机器学习的概念。虽然最好有数学背景，但在本章中我们几乎不使用任何数学。如果你打算扩展你的技能并深入机器学习，你必须先考虑学习数学。
- en: Besides introducing the concepts, the chapter also provides examples of tasks
    in ML. We are going to implement them and give you a basic idea of how you should
    research and move forward with solving more complex tasks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了介绍概念，本章还提供了机器学习任务的示例。我们将实施它们，并给你一个如何研究和解决更复杂任务的基本思路。
- en: 'We will cover the following topics in the chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Introduction to AI and ML in general
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能和机器学习的介绍
- en: Categories and applications of ML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习的类别和应用
- en: Designing a C++ class for calculations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为计算设计一个C++类
- en: Neural network structure and implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络结构和实现
- en: Regression analysis and clustering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归分析和聚类
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the `-std=c++2a`  option is used to compile the examples
    throughout the chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，使用g++编译器和`-std=c++2a`选项来编译示例。你可以在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)找到本章中使用的源文件。
- en: Introduction to AI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能的介绍
- en: The simplest definition of AI is robots acting like humans. It is the intelligence
    demonstrated by machines. And here goes the discussion around the definition of
    intelligence. How can we define it for machines, and at what level should we shout
    out loud that we are dealing with an intelligent machine?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能的最简单定义是机器表现得像人类一样。这是机器所展示的智能。接下来讨论智能的定义。我们如何为机器定义智能，以及在什么程度上我们应该大声宣布我们正在处理一个智能机器？
- en: If you are not familiar with the different tests to verify the intelligence
    of a machine, one of the popular ways to do so is the Turing test. The idea is
    to have an interrogator asking questions to two people, one of them being a machine
    and the other a human. If the interrogator can't make a clear distinction between
    those two, the machine should be considered intelligent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉用不同的测试来验证机器智能的方法，其中一种流行的方法是图灵测试。其思想是让一个询问者向两个人提问，其中一个是机器，另一个是人类。如果询问者无法清楚区分这两者，那么这台机器就应该被认为是智能的。
- en: The Turing test is named after Alan Turing. The test was introduced in his paper
    *Computing Machinery and Intelligence* in 1950\. He proposed using the imitation
    game to determine whether a machine thinks like a human.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵测试是以艾伦·图灵命名的。这项测试是在他1950年的论文《计算机器和智能》中提出的。他建议使用模拟游戏来确定机器是否像人类一样思考。
- en: 'The people being interrogated are behind a wall so that the interrogator can''t
    see them. The interrogator then asks several questions to both the participants.
    The following diagram demonstrates how the interrogator communicates with the
    human and the machine, but can''t physically see them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 被询问的人在墙后，以便询问者看不见他们。然后询问者向两个参与者提出几个问题。以下图表演示了询问者如何与人类和机器进行交流，但无法亲自看到他们：
- en: '![](img/34dd7f9a-7753-4539-9a3a-526fa0f79ee3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34dd7f9a-7753-4539-9a3a-526fa0f79ee3.png)'
- en: 'When you start diving into the field of AI, the definition of intelligence
    gets more and more vague. Questions can be asked to a machine in any form: in
    text, in audio, in visual form, and so on. There are numerous things that might
    never be available in machines, such as the look on their face. Sometimes people
    understand each other''s mood by the look on their faces. You can''t be sure whether
    a robot will understand or will even be able to imitate the mood on its face.
    No one taught us to look angry when we are angry. No one taught us to have emotions.
    They are just there. It''s hard to tell whether some day, something similar might
    be achieved for machines.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始深入研究人工智能领域时，智能的定义变得越来越模糊。可以以任何形式向机器提问：文字、音频、视觉等等。有许多东西可能永远不会出现在机器中，比如他们的表情。有时人们通过对方的表情来理解彼此的情绪。你无法确定机器是否会理解，甚至能够模仿他们脸上的情绪。没有人教我们在生气时看起来生气。没有人教我们有情感。它们就在那里。很难说有一天，类似的事情是否会被机器实现。
- en: 'When speaking about AI, most of the time we presume it''s about a robot that
    talks and behaves similar to humans. But when you try to dissect it as a programmer,
    you meet a lot of sub-fields, each of which takes a lot of time to understand.
    Many of the fields have a lot of tasks in progress or are in the early research
    phase. Here are some of the sub-fields in AI that you might be interested in focusing
    on in your career:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到人工智能时，我们大多数时候认为它是关于一个与人类类似的说话和行为的机器人。但当你试图将其作为程序员进行分解时，你会遇到许多子领域，每个子领域都需要花费大量时间来理解。许多领域有许多正在进行的任务或处于早期研究阶段。以下是一些你可能有兴趣在职业生涯中专注的人工智能子领域：
- en: '**Computer vision**: Designing algorithms for visual object recognition and
    understanding objects by analyzing their visual representation. It''s easy for
    humans to spot a familiar face in the crowd, but implementing a similar functionality
    for machines might take a lot of time to gain accuracy equal to humans.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机视觉**：设计用于视觉对象识别和通过分析它们的视觉表示来理解对象的算法。人类很容易在人群中发现熟悉的面孔，但为机器实现类似的功能可能需要很长时间才能达到与人类相同的准确性。'
- en: '**Natural language processing** (**NLP**): A linguistic analysis of text by
    machines. It has applications in various segments, such as machine translation.
    Imagine the computer completely understands human written text so that we can
    tell it what to do instead of spending months learning a programming language.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自然语言处理**（**NLP**）：机器对文本进行语言分析。它在各个领域都有应用，比如机器翻译。想象一下，计算机完全理解人类书面文本，这样我们就可以告诉它该做什么，而不是花几个月学习编程语言。'
- en: '**Knowledge reasoning**:This might seem the obvious goal for machines to behave
    intelligently. Knowledge reasoning is concerned with making machines reason and
    provide solutions based on the information they have; for example, provide a diagnosis
    by examining medical conditions.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识推理**：这似乎是机器表现智能的明显目标。知识推理涉及让机器根据它们所拥有的信息进行推理并提供解决方案；例如，通过检查医疗状况来提供诊断。'
- en: '**ML**: A field of study of algorithms and statistical models used by machines
    to perform tasks without explicit instructions. Instead of direct instructions,
    ML algorithms rely on patterns and inference. That said, ML allows machines to
    do the job on their own, without human involvement.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习**：机器用于执行任务的算法和统计模型的研究领域。机器学习算法不依赖于直接指令，而是依赖于模式和推理。也就是说，机器学习允许机器自行完成工作，无需人类参与。'
- en: Let's discuss the preceding sub-fields separately and then concentrate on ML.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别讨论前面的子领域，然后集中讨论机器学习。
- en: Computer vision
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机视觉
- en: Computer vision is a comprehensive field of study and has a lot of ongoing research
    projects. It is concerned with almost everything related to visual data processing.
    It has wide applications in various areas; for example, face recognition software
    processing data from various cameras spread over the city to find and determine
    criminal suspects, or optical character recognition software that produces text
    from images containing it. Combined with some **augmented reality **(**AR**) technologies,
    the software is able to translate text in images to language familiar to the user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉是一个广泛的研究领域，有许多正在进行的研究项目。它涉及几乎与视觉数据处理相关的一切。它在各个领域都有广泛的应用；例如，人脸识别软件处理来自城市各处摄像头的数据，以查找和确定犯罪嫌疑人，或者光学字符识别软件从包含文本的图像中生成文本。结合一些**增强现实**（**AR**）技术，软件能够将图像中的文本翻译成用户熟悉的语言。
- en: 'Study in this field is making progress by the day. Combined with AI systems,
    computer vision is the field that makes machines perceive the world as we do.
    A simple task for us, however, is challenging to implement in terms of computer
    vision. For example, when we see an object in an image, we easily spot its dimensions.
    For example, the following image represents the front view of a bicycle:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这一领域的研究正在日益取得进展。结合人工智能系统，计算机视觉是使机器感知世界的领域。对我们来说是简单的任务，但在计算机视觉方面实现起来是具有挑战性的。例如，当我们在图像中看到一个物体时，我们很容易看出它的尺寸。例如，以下图像代表了一辆自行车的前视图：
- en: '![](img/1e417264-3431-4087-a127-a74603e541bf.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e417264-3431-4087-a127-a74603e541bf.png)'
- en: 'Even if we don''t mention that it''s a bicycle, it''s not so hard for a human
    to determine it. It''s obvious for us that the black bold line at bottom center
    is the front wheel of the bicycle. It''s hard to tell the computer to understand
    that it is a wheel. All the computer sees is a collection of pixels, some of which
    have the same color:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不提到它是一辆自行车，人类也不难确定它。对我们来说，图像底部中央的黑色粗线是自行车的前轮是显而易见的。很难告诉计算机理解它是一个车轮。计算机所看到的只是一堆像素，其中一些颜色相同：
- en: '![](img/1f146977-eca9-4201-8f08-c4874284568e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f146977-eca9-4201-8f08-c4874284568e.png)'
- en: Besides understanding the wheel of the bicycle, it also should deduce that this
    bicycle must have another wheel that is not visible in the image. And again, we
    might have a guess for the approximate size of the bicycle, while it's a comprehensive
    task for the computer to determine it from the image. That said, the simple thing
    in our perspective might become a real challenge in computer vision.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解自行车的车轮，它还应该推断这辆自行车必须有另一辆在图像中看不见的车轮。而且，我们可能对自行车的大致尺寸有一个猜测，而对于计算机来说，从图像中确定它是一个全面的任务。也就是说，我们视角中的简单事物可能在计算机视觉中成为一个真正的挑战。
- en: We suggest using the OpenCV library for computer vision tasks. It is a cross-platform
    library written in C and C++. OpenCV represents a set of functions aimed at real-time
    computer vision, including ,but not limited to, facial recognition, gesture recognition,
    motion understanding, motion tracking, and other features.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在计算机视觉任务中使用OpenCV库。这是一个用C和C++编写的跨平台库。OpenCV代表了一组旨在实时计算机视觉的功能，包括但不限于人脸识别、手势识别、动作理解、运动跟踪和其他功能。
- en: Typical tasks in computer vision include object recognition, identification,
    and detection. Object recognition is the understanding that the object is a vehicle
    from the preceding image. Identification is the recognizing of an individual instance
    of an object, for example, the wheel of the bicycle in the preceding image. Object
    detection tasks might include finding corrupted areas of a bicycle from its image.
    All of these tasks combined with ML algorithms might comprise a comprehensive
    software that understands its surroundings close to the way humans do.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉中的典型任务包括对象识别、识别和检测。对象识别是理解对象是前一图像中的车辆。识别是识别对象的个别实例，例如前一图像中自行车的车轮。对象检测任务可能包括在自行车图像中找到损坏的区域。所有这些任务结合机器学习算法可能构成一个全面的软件，它能够以接近人类方式理解周围环境。
- en: NLP
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NLP
- en: 'Another interesting field of study is NLP. NLP makes efforts to make computers
    understand human languages. A more generalized approach is automatic speech recognition
    and natural language understanding; a key feature of virtual assistants. Today,
    it''s not magic anymore to talk with your phone and ask it to search for something
    on the web, for example. All of the process is powered by complex algorithms in
    speech and text analysis. The following diagram shows the high-level view of the
    process happening behind the conversational agents:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的研究领域是自然语言处理。自然语言处理致力于使计算机理解人类语言。更一般化的方法是自动语音识别和自然语言理解；这是虚拟助手的关键特性。今天，和手机交谈并要求它在网络上搜索某些内容已经不再是魔术。整个过程都由语音和文本分析中的复杂算法驱动。以下图表显示了发生在对话代理背后的高层视图：
- en: '![](img/2afbe1d3-4236-437b-8728-a7a864c33172.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2afbe1d3-4236-437b-8728-a7a864c33172.png)'
- en: 'Many language processing tasks are related to the web. A search engine processing
    the user input to search among millions of documents on the web is one of the
    top applications of NLP. In the next chapter, we are diving a lot deeper into
    search engine design and implementation. One of the main concerns in search engine
    design is processing the text data. The search engine cannot just store all the
    websites and respond to the user for the first match for the query. There are
    numerous tasks in NLP that have complex implementations. Suppose that we are designing
    a program that is fed with a text document and we should output sentences within
    the document. Recognizing the beginning and the end of a sentence is one of the
    complex tasks. The following sentence is a simple example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言处理任务与网络相关。搜索引擎处理用户输入以在网络上数百万文档中搜索是自然语言处理的顶级应用之一。在下一章中，我们将深入探讨搜索引擎的设计和实现。搜索引擎设计的主要关注点之一是处理文本数据。搜索引擎不能只存储所有网站并对用户的查询返回第一个匹配项。自然语言处理中有许多复杂的任务。假设我们正在设计一个程序，该程序接收文本文档并应输出文档中的句子。识别句子的开始和结束是其中的一个复杂任务。以下句子是一个简单的例子：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The program will output two sentences:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将输出两个句子：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In terms of a coding task, we just search for the . (dot) character at the end
    and make sure the first word started with the capital letter. How would the program
    behave if one of the sentences had the following form?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码任务方面，我们只需搜索句子末尾的 .（句号）字符，并确保第一个单词以大写字母开头。如果其中一句话的形式如下，程序会如何行为？
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As there is an exclamation point at the end of the sentence, we should revisit
    our program to add another rule for recognizing the ending of a sentence. What
    if a sentence ends like this?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于句子末尾有感叹号，我们应该重新审视我们的程序，添加另一个规则来识别句子的结束。如果一句话是这样结束的呢？
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One by one, more and more rules and definitions are introduced to have a fully
    functional sentence extractor. Leveraging ML moves us to a smarter direction when
    solving NLP tasks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 逐一引入更多规则和定义，以实现一个完全功能的句子提取器。在解决自然语言处理任务时，利用机器学习将我们引向更智能的方向。
- en: Another language-related task is machine translation that, which automatically
    translates a document from one language to another. Also, note that building a
    comprehensive NLP system will benefit other fields of study, such as knowledge
    reasoning.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与语言相关的任务是机器翻译，它可以自动将一种语言的文档翻译成另一种语言。此外，需要注意的是，构建一个全面的自然语言处理系统将有益于其他研究领域，比如知识推理。
- en: Knowledge reasoning
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知识推理
- en: 'Knowledge reasoning is making computers think and reason in a similar way to
    humans. Imagine having a conversation with a machine, starting like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 知识推理是使计算机以类似于人类的方式思考和推理。想象一下和机器进行对话，开始如下：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can program the machine to answer specific questions or understand complex
    text input by user, but it''s a lot harder to make the machine reason based on
    previous experience. For example, the following reasoning is one of the goals
    of the study:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编程让机器回答特定问题或理解用户输入的复杂文本，但要让机器基于以前的经验进行推理就要困难得多。例如，以下推理是研究的目标之一：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While it might seem easy to spot the connection between catching a cold and
    the rain, it takes a lot of effort for the program to deduce it. It must associate
    the rain with cold and having a temperature with catching a cold. It also should
    remember the previous input to use it for intelligently keeping the dialog.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然似乎很容易发现感冒和雨之间的联系，但让程序推断这一点需要付出很大的努力。它必须将雨与感冒联系起来，并将有温度与感冒联系起来。它还应该记住先前的输入，以便在智能地保持对话中使用它。
- en: All of the preceding mentioned fields of study are exciting areas for a programmer
    to dive deeper. Finally, ML in general is something that sits at the fundament
    for all other fields in terms of designing algorithms and models for each specific
    application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的所有研究领域对于程序员来说都是令人兴奋的深入领域。最后，机器学习通常是设计算法和模型的基础，用于每个特定应用领域。
- en: ML
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习
- en: ML takes us to a whole new level of making machines execute tasks the way humans
    do, maybe even better. Compared to the fields we introduced previously, the goal
    of ML is to build systems that are able to do things without specific instructions.
    In the journey of inventing artificially intelligent machines, we should take
    a closer look at human intelligence. When it is born, a child doesn't express
    intelligent behavior but starts to slowly become familiar with the surrounding
    world. There is no recorded evidence of any 1-month-old child solving differential
    equations or composing music. In the same way a child learns and discovers the
    world, ML is concerned with building the foundational models that directly perform
    the tasks, but rather are able to learn how to do it. That's the fundamental difference
    between setting the system to carry out predefined instructions and letting it
    figure it out on its own.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习使我们达到了一个全新的水平，让机器执行任务的方式与人类一样，甚至可能更好。与我们之前介绍的领域相比，机器学习的目标是构建能够在没有具体指令的情况下执行任务的系统。在发明人工智能机器的过程中，我们应该更加关注人类智慧。当一个孩子出生时，并不表现出智能行为，而是开始慢慢熟悉周围的世界。没有记录表明一个月大的婴儿解决微分方程或创作音乐。就像孩子学习和发现世界一样，机器学习关注的是构建直接执行任务的基础模型，而不是直接执行任务，而是学会如何执行任务。这是设置系统执行预定义指令和让系统自行解决问题之间的根本区别。
- en: When a child starts walking, taking things, talking, and asking questions, they
    are gaining knowledge about the world step by step. She or he takes a book, tries
    its flavor, and sooner or later stops chewing books as something edible. Years
    pass and the child now opens the pages of the book and looks for images in it
    and the little figures comprising the text. A few more years pass and, the child
    starts to read them. Over the years, the brain gets more and more complicated
    and creates more and more connections between its neurons. The child becomes an
    intelligent human being.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个孩子开始行走、拿东西、说话和提问时，他们正在逐步获取关于世界的知识。他或她拿起一本书，尝试它的味道，不久之后就不再把书当作食物来咀嚼。几年过去了，孩子现在打开书的页面，寻找其中的图像和构成文本的小图形。再过几年，孩子开始阅读它们。多年过去了，大脑变得越来越复杂，它的神经元之间建立了越来越多的连接。孩子变成了一个聪明的人类。
- en: 'Imagine a system that has some magical algorithms and models in it. After feeding
    it with a bunch of data, it will be able to understand more and more, the same
    way the child gets to know the world by processing the input data in the form
    of visual data (looking through their eyes), or smell, or flavor. Later on, by
    developing a way to ask questions, the child gets to understand words and associates
    those words with objects in the real world, and even intangible concepts. ML systems
    act almost in the same way. They process the input data and produce some output
    that conforms to the results expected by us. The following diagram illustrates
    the idea:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个系统，其中有一些神奇的算法和模型。在输入了大量数据之后，它将能够越来越理解，就像孩子通过处理视觉数据（通过他们的眼睛观察）、气味或味道的输入数据来了解世界一样。后来，通过提出问题的方式，孩子开始理解单词，并将这些单词与现实世界中的对象，甚至是无形的概念联系起来。机器学习系统几乎以相同的方式行事。它们处理输入数据并产生一些输出，符合我们期望的结果。下图说明了这个想法：
- en: '![](img/e1574aeb-59e5-4890-a1cb-0c31e04315f3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1574aeb-59e5-4890-a1cb-0c31e04315f3.png)'
- en: Let's now dive deeper into ML. As always, the best way to understand something
    new is to try to implement it first.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解机器学习。和往常一样，理解新事物的最好方法是先尝试实现它。
- en: Understanding ML
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解机器学习
- en: ML is a big field of study with a lot of research in progress and is expanding
    rapidly. To understand ML, we should first understand the nature of learning.
    Thinking and reasoning are the key concepts that make us – humans – special. The
    core of ML is to make the system learn and use the knowledge to act upon tasks.
    You might recall your first steps in studying programming. We are sure it wasn't
    easy. You had to learn new concepts, build abstractions, and make your brain understand
    what's going on under the hood of program execution. After that, you were supposed
    to build complex systems using those small building blocks described in primers
    as keywords, instructions, conditional statements, functions, classes, and so
    on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个庞大的研究领域，正在快速扩展。要理解机器学习，我们首先应该了解学习的本质。思考和推理是使我们——人类——特殊的关键概念。机器学习的核心是使系统学习并利用知识来执行任务。你可能还记得学习编程的第一步。我们相信那并不容易。你必须学习新概念，构建抽象，并让你的大脑理解程序执行的底层原理。之后，你需要使用那些在入门指南中描述的关键字、指令、条件语句、函数、类等小构件来构建复杂系统。
- en: 'However, an ML program differs from the programs we usually create. Take a
    look at the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，机器学习程序与我们通常创建的程序不同。看一下下面的代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The simple precedent program does what we instructed it to do. It contains
    several simple instructions that lead to the variable `c` representing the sum
    of `a` and `b`. We can modify the function to take user input as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的前述程序按照我们的指示执行。它包含了几个简单的指令，导致变量`c`表示`a`和`b`的和。我们可以修改函数以接受用户输入，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding function will never gain any intelligence. It doesn''t matter
    how many times we call the `calculate()` function. It also doesn''t matter what
    numbers we provide as its input. The function represents a collection of instructions.
    We might say even a collection of hardcoded instructions. That is, the function
    will never modify its own instructions to behave differently based on the input.
    However, we can introduce some logic; let''s say we make it return 0 each time
    it receives negative numbers:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数永远不会获得任何智能。无论我们调用`calculate()`函数多少次都无所谓。无论我们提供什么数字作为输入都无所谓。该函数代表了一系列指令。我们甚至可以说是一系列硬编码的指令。也就是说，该函数永远不会修改自己的指令以根据输入的不同行为。然而，我们可以引入一些逻辑；比如说，我们让它在收到负数时每次返回0：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The conditional statement introduced the simplest form of a decision that the
    function makes based on its input. We can add more and more conditionals so that
    the function will grow and have a complex implementation. However, no number of
    conditional statements will make it smarter because it is not something that the
    code comes up with its own. And here comes the limit that we face when dealing
    with programs. They don't think; they act as we programmed them to act. We are
    the ones who decide how they must behave. And they always obey. Well, as long
    as we didn't introduce bugs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句引入了函数基于其输入所做决定的最简单形式。我们可以添加更多的条件语句，使函数增长并具有复杂的实现。然而，无论添加多少条件语句，它都不会变得更聪明，因为它不是代码自己想出来的。这就是我们在处理程序时所面临的限制。它们不会思考；它们会按照我们编程的方式行事。我们决定它们必须如何行事。它们总是服从。嗯，只要我们没有引入错误。
- en: 'Now, imagine an ML algorithm in action. Suppose the `calculate()` function
    has some magic in it, so that it returns a value based on the input. Let''s say
    it has the following form:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下ML算法在行动。假设`calculate()`函数中有一些魔法，以便它根据输入返回一个值。假设它具有以下形式：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, suppose that we are calling `calculate()` and passing `2` and `4` as its
    arguments, hoping that it will calculate their sum and return `6`. Also, imagine
    that we can somehow tell it whether the result is what we expected. After a while,
    the function behaves in a way that it understands how to use those input values
    and return their sum. The following class that we are building represents our
    first steps toward understanding ML.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们正在调用`calculate()`并将`2`和`4`作为参数传递，希望它将计算它们的总和并返回`6`。此外，想象一下，我们可以以某种方式告诉它结果是否符合我们的预期。过了一会儿，函数以一种方式行事，以便它了解如何使用这些输入值并返回它们的总和。我们正在构建的以下类代表了我们对理解ML的第一步。
- en: Designing an algorithm that learns
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个学习的算法
- en: 'The following class represents a calculation machine. It comprises four arithmetic
    operations and expects that we provide examples of how it should calculate the
    input values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类代表一个计算机。它包括四种算术运算，并期望我们提供如何计算输入值的示例：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before using the `calculate()` function, we should provide a list of examples
    for the `setExamples()` function. Here''s a sample of the examples that we provide
    to `CalculationMachine`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`calculate()`函数之前，我们应该为`setExamples()`函数提供一个示例列表。以下是我们提供给`CalculationMachine`的示例的示例：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first two numbers in each line represent the input arguments; the third
    number is the result of the operation. The `setExamples()`  function is how the
    `CalculationMachine` learns to use the correct arithmetic function. The same way
    we can guess what''s going on from the preceding examples, the same way  `CalculationMachine`
    tries to find the best fit for its operations. It goes through examples and defines
    which of the functions it should use when `calculate()` is called. The implementation
    is similar to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每行中的前两个数字代表输入参数；第三个数字是操作的结果。`setExamples()`函数是`CalculationMachine`学习如何使用正确的算术函数。我们可以从前面的例子中猜出正在发生的事情，同样`CalculationMachine`试图找到最适合其操作的方法。它通过示例并定义在调用`calculate()`时应该使用哪个函数。实现方式类似于以下内容：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see from the preceding example, the function calls all the arithmetic
    functions and compares their return value with the example output. Each time the
    result is correct, it increases the count of correct answers for the specific
    function. Finally, the function having the maximum number of correct answers is
    assigned to `fptr_` that is used by the `calculate()` function as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，该函数调用所有算术函数并将它们的返回值与示例输出进行比较。每次结果正确时，它会增加特定函数的正确答案计数。最后，具有最多正确答案的函数被分配给`fptr_`，该函数由`calculate()`函数使用如下：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have devised a simple learning algorithm. The `setExamples()` function might
    be renamed `setDataSet()` or `trainWithExamples()` or something similar. The point
    of the example with `CalculationMachine` is that we define a model and algorithm
    working with it and we can call it ML. It learns from data. Or, even better, it
    learns from experiences. Each record in the vector of examples that we provided
    to `CalculationMachine` can be regarded as an experience. We say that the performance
    of the calculation improves with experience. That is, the more we provide examples,
    the more it becomes confident in choosing the right function to perform the task.
    And the task is calculating the value based on two input arguments. The process
    of learning itself is not the task. Learning is what leads to performing the task.
    Tasks are usually described as how the system should process an example, where
    an example is a collection of features. Although, in ML terms, an example is represented
    as a vector (mathematical) where each entry is another feature, the choice of
    the vector data structure is just a coincidence. As one of the fundamental principles
    is the training of the system, ML algorithms can be categorized as supervised
    or unsupervised. Let's examine their differences and then establish various applications
    of ML systems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一个简单的学习算法。`setExamples()`函数可以被重命名为`setDataSet()`或`trainWithExamples()`或类似的名称。`CalculationMachine`的例子的重点在于我们定义了一个模型和算法来处理它，并且我们可以称之为ML。它从数据中学习。或者，更好的是，它从经验中学习。我们提供给`CalculationMachine`的示例向量中的每个记录都可以被视为一种经验。我们说计算的性能随着经验的增加而提高。也就是说，我们提供的示例越多，它在选择正确的函数执行任务时就越有信心。而任务就是根据两个输入参数计算值。学习过程本身不是任务。学习是导致执行任务的原因。任务通常被描述为系统应该如何处理一个示例，其中一个示例是一组特征。尽管在ML术语中，一个示例被表示为一个向量（数学），其中每个条目都是另一个特征，但向量数据结构的选择只是一个巧合。作为系统训练的基本原则之一，ML算法可以被分类为监督或无监督。让我们检查它们的区别，然后建立ML系统的各种应用。
- en: Categories of ML
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ML的分类
- en: 'The following diagram illustrates the categorization of ML:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了ML的分类：
- en: '![](img/57c4aa6a-343d-43e9-8060-f24d62dee7b3.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57c4aa6a-343d-43e9-8060-f24d62dee7b3.png)'
- en: Categorization of ML algorithms depends on the kind of experience they have
    during the learning process. We usually call the collection of examples a *dataset*.
    Some books also use the term *data points*. A dataset is basically a collection
    of data representing anything useful to the target system. It might include measurements
    of weather for periods of time, a list of prices for the stock of some company
    or companies, or any other set of data. While the dataset might be unprocessed
    or so-called raw, there are also datasets having additional information for each
    contained experience. In the `CalculationMachine` example, we used a raw dataset,
    although we already programmed the system to recognize that the first two values
    are the operands of the operation and the third value is its result. As already
    mentioned, we categorize ML algorithms into supervised and unsupervised.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ML算法的分类取决于它们在学习过程中的经验类型。我们通常称示例的集合为*数据集*。有些书籍也使用术语*数据点*。数据集基本上是代表对目标系统有用的任何数据的集合。它可能包括一段时间内的天气测量，某家公司或多家公司的股票价格列表，或任何其他数据集。虽然数据集可能是未经处理的或所谓的原始数据，但也有数据集包含每个经验的附加信息。在`CalculationMachine`的示例中，我们使用了一个原始数据集，尽管我们已经编程系统识别前两个值是操作的操作数，第三个值是其结果。如前所述，我们将ML算法分类为监督和无监督。
- en: Supervised learning algorithms learn from labeled datasets; that is, each record
    contains additional information describing the data. `CalulcationMachine` is an
    example of a supervised learning algorithm. Supervised learning is also known
    as **training with an instructor**. The instructor teaches the system using the
    dataset.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '监督学习算法从带标签的数据集中学习；也就是说，每条记录都包含描述数据的附加信息。`CalulcationMachine`是监督学习算法的一个例子。监督学习也被称为**带教练训练**。教练使用数据集来教授系统。 '
- en: 'The supervised learning algorithm will be able to label new unknown data after
    learning from experiences  provided. The following diagram describes it best:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 监督学习算法将能够在从提供的经验中学习后标记新的未知数据。下图最好描述了它：
- en: '![](img/3c11cb39-8e0b-48ed-af2b-e498f0345c35.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c11cb39-8e0b-48ed-af2b-e498f0345c35.png)'
- en: A good example of an application of supervised learning algorithms is the spam
    filter in email applications. Users label emails as spam or not and the system
    then tries to find patterns in new incoming emails to detect potential spam emails.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 监督学习算法的一个应用示例是电子邮件应用中的垃圾邮件过滤器。用户将电子邮件标记为垃圾邮件或非垃圾邮件，然后系统试图在新收到的电子邮件中找到模式以检测潜在的垃圾邮件。
- en: 'The example with `CalculationMachine` is another case for supervised learning.
    We fed it with the following dataset:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculationMachine`的示例是监督学习的另一个案例。我们用以下数据集来喂它：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We programmed `CalculationMachine` to read the first two numbers as input arguments,
    and the third number as the output produced by a function applied to the input.
    This way, we provided necessary information on what exactly the system should get
    as a result.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编程`CalculationMachine`以读取前两个数字作为输入参数，第三个数字作为应用于输入的函数产生的输出。这样，我们提供了关于系统应该得到什么结果的必要信息。
- en: 'Unsupervised learning algorithms are even more complex— they process the dataset
    containing a bunch of features and then try to find useful properties of the features.
    Unsupervised learning algorithms are mostly left alone to define what''s in the
    dataset on their own. In terms of intelligence, an unsupervised learning approach
    meets the description of an intelligent creature more than supervised learning
    algorithms. In contrast, supervised learning algorithms are trying to predict
    which input values map to the output values, while unsupervised algorithms perform
    several operations to discover patterns in a dataset. Following the same association
    in the preceding diagram, the following diagram describes an unsupervised learning
    algorithm:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督学习算法更加复杂——它们处理包含大量特征的数据集，然后试图找到特征的有用属性。无监督学习算法大多是独立定义数据集中的内容。就智能而言，无监督学习方法更符合智能生物的描述，而不是监督学习算法。相比之下，监督学习算法试图预测哪些输入值映射到输出值，而无监督算法执行多个操作来发现数据集中的模式。根据前面图表中的关联，下图描述了一个无监督学习算法：
- en: '![](img/3957f1b0-47f6-4f5f-9fd7-d789c436e981.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3957f1b0-47f6-4f5f-9fd7-d789c436e981.png)'
- en: Examples of applications of unsupervised learning algorithms are recommendation
    systems. We will be discussing one in the next chapter, where we design a web
    search engine. Recommendation systems analyze user activity to recommend similar
    data, for example, movie recommendations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督学习算法的应用示例包括推荐系统。我们将在下一章中讨论一个例子，设计一个网络搜索引擎。推荐系统分析用户活动以推荐类似的数据，例如电影推荐。
- en: As you can see from the preceding illustration, there is also *reinforcement
    learning*. This is the category of algorithms that learns from mistakes. There
    is a feedback loop between the learning system and its experiences so that reinforcement
    learning algorithms interact with an environment. It might make a lot of mistakes
    in the beginning and, after processing the feedback, correct itself to improve
    the algorithm. The learning process becomes part of task execution. Imagine that `CalculationMachine` receives
    only input numbers but not the result of the calculation. For each experience,
    it will produce a result by applying one of the arithmetic operations and then
    receive a feedback. Let's say it subtracts the numbers and then modifies itself
    to calculate the sum based on the feedback.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的插图中可以看出，还有*强化学习*。这是一类从错误中学习的算法。学习系统和其经验之间存在反馈循环，因此强化学习算法与环境进行交互。它可能在开始时犯很多错误，经过处理反馈后，纠正自身以改进算法。学习过程成为任务执行的一部分。想象一下，`CalculationMachine`只接收输入数字而不是计算结果。对于每个经验，它将通过应用算术运算之一产生结果，然后接收反馈。假设它减去数字，然后根据反馈修改自身以计算总和。
- en: Applications of ML
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ML的应用
- en: Understanding the categorization of ML helps apply it better to various kinds
    of tasks. There is a wide range of tasks that can be solved with ML. We have already
    mentioned *classification* as one of the tasks solved with ML algorithms. Basically,
    classification is the process of filtering and ordering the input to specify the
    categories the input belongs to. Solving classification with ML usually means
    that it produces a function that maps input to specific output. Outputting a probability
    distribution over classes is also a type of classification task. One of the best
    examples of a classification task is object recognition. The input is a set of
    pixel values (in other words, an image) and the output is a value identifying
    the object in the image. Imagine a robot that can recognize different kinds of
    tools and deliver them to workers on command.;that is, a mechanic working in garage
    has an assistant robot that is able to recognize a screwdriver and bring it on
    command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 了解机器学习的分类有助于更好地将其应用于各种任务。有许多任务可以通过机器学习来解决。我们已经提到*分类*是机器学习算法解决的任务之一。基本上，分类是过滤和排序输入以指定输入所属的类别的过程。用机器学习解决分类通常意味着它产生一个将输入映射到特定输出的函数。输出类别的概率分布也是一种分类任务。分类任务的最佳示例之一是对象识别。输入是一组像素值（换句话说，是一幅图像），输出是标识图像中物体的值。想象一下一个能够识别不同种类的工具并在命令下将它们交给工人的机器人；也就是说，一个在车库里工作的机械师有一个能够识别螺丝刀并在命令下将其带来的助手机器人。
- en: More challenging is classification with missing inputs. In the preceding example,
    it's similar to asking the robot to bring something to screw the bolts. When some
    of the input is missing, the learning algorithm must operate with more than one
    function to achieve a successful result. For example, the assistant robot might
    bring pliers first and then come up with a screwdriver as the correct solution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更具挑战性的是具有缺失输入的分类。在前面的例子中，这类似于要求机器人带来螺丝钉的东西。当一些输入缺失时，学习算法必须使用多个函数来实现成功的结果。例如，助手机器人可能首先带来钳子，然后找到螺丝刀作为正确的解决方案。
- en: Similar to classification is *regression*, where the system is asked to predict
    a numerical value given some input that is provided. The difference is the format
    of the output. An example of a regression task is prediction of future prices
    of stocks. These and other applications of ML are making it rapidly grow as a
    field of study. Learning algorithms are not just a list of conditional statements
    as they might feel at first. They are based on more comprehensive constructs modeled
    after human brain neurons and their connections. This leads us to the next section,
    the study of **artificial neural networks** (**ANNs**).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与分类类似的是*回归*，在这种情况下，系统被要求根据提供的一些输入来预测一个数值。不同之处在于输出的格式。回归任务的一个例子是预测股票未来价格。这些以及其他机器学习的应用使其迅速成为一个研究领域。学习算法不仅仅是一系列条件语句，尽管一开始可能感觉是这样。它们是基于更全面的构造，模仿人脑神经元及其连接而建模的。这将我们带到下一节，即**人工神经网络**（**ANNs**）的研究。
- en: Neural networks
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络
- en: 'Neural networks are designed to recognize patterns. They are modeled after
    the human brain; more specifically, we speak about neurons of the brain and their
    artificial counterparts – artificial neurons. A neuron in the human brain is illustrated
    in the following diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络被设计用于识别模式。它们是模仿人脑的；更具体地说，我们谈论的是大脑神经元及其人工对应物——人工神经元。人类大脑中的神经元在下图中有所说明：
- en: '![](img/2ae9ed94-046b-41d3-b973-d49240e60d96.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae9ed94-046b-41d3-b973-d49240e60d96.png)'
- en: A neuron communicates with other neurons via *synapses*. The basic functionality
    of a neuron is processing a portion of data and producing signals based on that
    data. In programming terms, a neuron takes a set of inputs and produces an output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 神经元通过*突触*与其他神经元进行通信。神经元的基本功能是处理部分数据并根据该数据产生信号。在编程术语中，神经元接受一组输入并产生输出。
- en: 'That''s why the following diagram makes it clear why an artificial neuron is
    similar to the human brain neuron structure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么下面的图表清楚地说明了为什么人工神经元类似于人脑神经元结构：
- en: '![](img/c5ab77e8-d399-4ea8-8266-87af81434f8b.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5ab77e8-d399-4ea8-8266-87af81434f8b.png)'
- en: 'An ANN is a much simplified model of a natural neural network. It represents
    a group of interconnected nodes, each node representing a model after a neuron.
    Each node connection can transmit signals similar to synapses in biological brain
    neurons. Neural networks are a set of algorithms that help to cluster and classify.
    As you can see from the preceding diagram, the neural network consists of three
    layers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ANN是自然神经网络的一个简化模型。它代表了一组相互连接的节点，每个节点代表一个神经元模型。每个节点连接可以传输类似于生物大脑神经元中突触的信号。神经网络是一组帮助进行聚类和分类的算法。正如您从前面的图表中看到的，神经网络由三层组成：
- en: Input layer
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入层
- en: Hidden layer
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏层
- en: Output layer
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出层
- en: The input and output layers speak for themselves; the initial inputs are external
    data, for example, images, audio, or text files. The output is the accomplishment
    of the task, such as classification of the text content or the recognized objects
    in images. The hidden layer is what makes the network produce reasonable results.
    The transition of input to output goes through the hidden layer, which does the
    heavy analyzing, processing, and modifications necessary to produce the output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输入层和输出层不言自明；初始输入是外部数据，例如图像、音频或文本文件。输出是任务的完成，例如对文本内容的分类或图像中识别的对象。隐藏层是使网络产生合理结果的关键。输入到输出的转换经过隐藏层，隐藏层进行了必要的分析、处理和修改以产生输出。
- en: Consider the preceding diagram; it shows that a neuron can have multiple input
    and output connections. Usually, each connection has a weight that specifies the
    importance of the connection. The layering in the preceding diagram tells us that
    neurons in each layer are connected to neurons of the immediately preceding and
    immediately following layers. You should note that there might be several hidden
    layers between the input and output layers. While the primary purpose of input
    and output layers is reading external data and returning calculated (or deduced)
    output, the purpose of hidden layers is to adapt by learning. Learning also involves
    adjusting connections and weights aiming to improve the output accuracy. This
    is the part where ML comes to play. So, if we create a complex neural network
    with several hidden layers ready to learn and improve, we get an AI system. For
    example, let's examine the clustering problem and then move on to regression analysis.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的图表；它显示一个神经元可以有多个输入和输出连接。通常，每个连接都有一个权重，指定连接的重要性。前面图表中的分层告诉我们，每一层的神经元都连接到紧邻的前一层和后一层的神经元。您应该注意，输入和输出层之间可能有几个隐藏层。虽然输入和输出层的主要目的是读取外部数据并返回计算（或推断）的输出，但隐藏层的目的是通过学习来适应。学习还涉及调整连接和权重，以提高输出的准确性。这就是机器学习发挥作用的地方。因此，如果我们创建一个复杂的神经网络，其中包含几个隐藏层，准备学习和改进，我们就得到了一个人工智能系统。例如，让我们先来研究聚类问题，然后再进行回归分析。
- en: Clustering
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类
- en: 'Clustering is concerned with grouping a set of objects to distribute them in
    groups of similar objects. Also known as **cluster analysis**, it is a set of
    techniques and algorithms intended to group similar objects together, producing
    clusters. The simplest illustrative introduction would be grouping a set of colored
    objects into different groups consisting of objects of the same color, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类涉及将一组对象分组以将它们分布在相似对象的组中。也称为**聚类分析**，它是一组旨在将相似对象分组在一起的技术和算法。最简单的说明是将一组有颜色的对象分成不同的组，每组由相同颜色的对象组成，如下所示：
- en: '![](img/3ef57b1e-05f2-4d19-a942-b7d6b85c8d95.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ef57b1e-05f2-4d19-a942-b7d6b85c8d95.png)'
- en: 'Although we are discussing AI tasks in this chapter, we suggest you first try
    to solve problems with the knowledge base that you have so far. That is, let''s
    think about how we would categorize objects by similarity. First of all, we should
    have a basic idea of what the object will look like. In the preceding example,
    an object  `shape`,  `color`, dimensions (`width` and `height` for a 2D object),
    and so on. Without going much deeper, a basic object representation might look
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本章讨论AI任务，但我们建议您首先尝试用到目前为止所掌握的知识库来解决问题。也就是说，让我们想一想如何通过相似性对对象进行分类。首先，我们应该对对象的外观有一个基本的概念。在前面的例子中，一个对象的表示可能是这样的：`形状`，`颜色`，尺寸（2D对象的`宽度`和`高度`），等等。不深入探讨，基本对象表示可能是这样的：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s consider the fact that values for color and shapes are in a some range
    of predefined values. We could use enumerations for better readability. Clustering
    analysis involves analyzing objects to categorize them somehow. The first thing
    that comes to mind is having a function that accepts a list of objects. Let''s
    try to define one:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑颜色和形状的值在一定范围内的事实。我们可以使用枚举来提高可读性。聚类分析涉及分析对象以某种方式对其进行分类。首先想到的是有一个接受对象列表的函数。让我们试着定义一个：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Think for a moment about the implementation details. We need to define the
    clustering points. It might be the color, or the type of the shape. The challenging
    thing is that it might be unknown. That said, to cover everything just in case,
    we categorize objects for every property as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想实现细节。我们需要定义聚类点。它可能是颜色，也可能是形状的类型。具有挑战性的是，它可能是未知的。也就是说，为了以防万一，我们对每个属性的对象进行分类如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Objects with a similar color or shape are grouped together in a hash table.
    While the preceding code is rather simple, it bears the basic idea for grouping
    objects by some similarity criterion. What we did in the previous example is more
    likely to be described as hard clustering. An object either belongs to a cluster
    or it doesn't. On the contrary, soft clustering (also known as **fuzzy clustering**)
    describes an object's belonging to a cluster to a certain degree.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相似颜色或形状的对象被分组在一个哈希表中。虽然前面的代码相当简单，但它包含了按某种相似性标准对对象进行分组的基本思想。在前面的例子中，我们更可能将其描述为硬聚类。一个对象要么属于一个簇，要么不属于。相反，软聚类（也称为模糊聚类）描述了对象对某个簇的归属程度。
- en: For example, the similarity of objects for the shape property could be defined
    by the result of a function applied to the objects. That is, the function defines
    whether object A and object B have a similar shape if, let's say, object A's shape
    is a square and object B's shape is a rhombus. That means we should update the
    logic in the previous example to compare objects against several values and define
    their shape as a group. By developing this idea further, we will sooner or later
    arrive at different strategies and algorithms of clustering, such as K-means clustering.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，形状属性的对象相似性可以由应用于对象的函数的结果来定义。也就是说，如果对象A的形状是正方形，对象B的形状是菱形，那么函数定义了对象A和对象B是否具有相似的形状。这意味着我们应该更新前面例子中的逻辑，以便根据几个值来比较对象并定义它们的形状为一组。通过进一步发展这个想法，我们迟早会到达不同的聚类策略和算法，比如K均值聚类。
- en: Regression analysis
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归分析
- en: 'Regression analysis is concerned with finding the deviations for one value
    from another. The simplest way of understanding regression analysis is through
    the graphs for functions in mathematics. You might recall the graph for the function
    f(x) = y:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回归分析涉及找出一个值对另一个值的偏差。理解回归分析的最简单方法是通过数学函数的图表。您可能还记得函数f(x) = y的图表：
- en: '![](img/378390fd-c0b2-4a73-86ea-cc2108a8afa0.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/378390fd-c0b2-4a73-86ea-cc2108a8afa0.png)'
- en: For every value of `x`, the function results in a fixed value for `y`. Regression
    analysis is somewhat similar to the preceding graph as it is concerned with finding
    a relationship between variables. More specifically, it estimates relationships
    between a dependent variable and several independent variables. The dependent
    variable is also know as an **outcome**, while the independent variables are also referred
    to as **features**. The number of features might be one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`x`的值，函数都会得出一个固定的`y`值。回归分析与前面的图表有些相似，因为它涉及查找变量之间的关系。更具体地说，它估计因变量和几个自变量之间的关系。因变量也被称为**结果**，而自变量也被称为**特征**。特征的数量可能是一个。
- en: 'The most common form of regression analysis is linear regression. It looks
    similar to the preceding graph. Here''s an example representing the relationship
    between hours spent on testing programs and the number of bugs discovered in the
    release version:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的回归分析形式是线性回归。它看起来与前面的图表相似。以下是一个例子，表示测试程序所花费的时间与发布版本中发现的错误数量之间的关系：
- en: '![](img/85954804-fb7b-4621-8295-dd72845621b6.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85954804-fb7b-4621-8295-dd72845621b6.png)'
- en: 'There are two types of regression: a negative regression is the one shown in
    the preceding diagram, as the independent values decrease while the dependent
    variable increases. Positive regressions, on the contrary other hand, have increasing
    values for independent variables.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的回归：负回归是前面图表中显示的一种，因为自变量的值减少而因变量增加。相反，正回归具有自变量增加的值。
- en: Regression analysis in ML is used as a way of forecasting. You might develop
    a program to predict an outcome based on the values for dependent variables. As
    you have already guessed so far, ML is a big field with a wide range of topics.
    Although programmers tend to use math as little as possible, ML makes it impossible.
    You still need to grasp some of the math subjects to get the most out of ML. Regression
    analysis strongly depends on math statistics.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习中的回归分析被用作一种预测的方式。你可能会开发一个程序，根据自变量的数值来预测结果。正如你到目前为止已经猜到的那样，机器学习是一个涵盖广泛主题的大领域。尽管程序员倾向于尽可能少地使用数学，但在机器学习中却是不可能的。你仍然需要掌握一些数学知识，以充分利用机器学习。回归分析在很大程度上依赖于数学统计。
- en: C++ and ML
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++和机器学习
- en: It's now no longer a secret that ML is more about math than programming. Computer
    science has its roots in mathematics and, in the early years, computer scientists
    were mathematicians first. You might be familiar with several eminent scientists,
    including Alan Turing, John von Neuman, Claude Shannon, Norbert Wiener, Niklaus
    Wirth, Donald Knuth, and many others. All of them are mathematicians with a special
    love for technology. During its development, computer programming became a more
    friendly field to newcomers. In the last two or three decades, a computer programmer
    stopped being forced to learn math before developing useful programs. Languages
    evolved into more and more high-level tools that allow almost everyone to code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经不再是秘密，机器学习更多地涉及数学而不是编程。计算机科学的根源在数学中，在早期，计算机科学家首先是数学家。你可能熟悉一些杰出的科学家，包括艾伦·图灵、约翰·冯·诺伊曼、克劳德·香农、诺伯特·维纳、尼古劳斯·维尔特、唐纳德·克努斯等。他们都是数学家，对技术有着特殊的热爱。在其发展过程中，计算机编程成为了一个更加友好的领域，对新手更加友好。在过去的二三十年里，计算机程序员不再被迫在开发有用的程序之前学习数学。编程语言演变成了越来越高级的工具，几乎每个人都可以编写代码。
- en: There are plenty of frameworks that make the job easier for programmers. It
    now takes a matter of weeks to grasp some framework or a high-level programming
    language and create a new program. Programs, however, tend to repeat themselves.
    It's not so hard to build something nowadays because there are a lot of patterns
    and best practices that help us along the way. The role of mathematics has been
    pushed back and more and more people become programmers without even the slightest
    need to use math. That's not actually an issue; it's more like a natural flow
    for the technology to evolve. In the end, the aim for technology is to make the
    human living more comfortable. The same relates to engineers. While, back in the
    1960s, engineers at NASA made calculations using computers, they were not computers
    as we know them today. Those were real human beings with this special specialty
    called being a *computer*, although being a computer meant being great in mathematics
    and solving equations much faster than others.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多框架可以让程序员的工作更轻松。现在只需要几周的时间就可以掌握一些框架或高级编程语言，并创建一个新的程序。然而，程序往往会重复自己。现在构建一些东西并不那么困难，因为有很多模式和最佳实践可以帮助我们。数学的作用已经被推到了后台，越来越多的人成为程序员，甚至根本不需要使用数学。这实际上并不是一个问题；这更像是技术发展的自然流动。最终，技术的目标是让人类生活更加舒适。工程师也是如此。然而，在20世纪60年代，NASA的工程师使用计算机进行计算，但那时的计算机并非我们今天所知的计算机。那些都是真正的人类，拥有一种特殊的专业称为“计算机”，尽管成为计算机意味着在数学上非常出色，比其他人更快地解决方程。
- en: Now we are part of the new age in computer science where mathematics is back
    again. ML engineers are now using mathematics the same way mathematicians used
    programming languages in the 1970s or 1980s. It's now not enough to know a programming
    language or a framework to devise a new algorithm or incorporate ML into your
    applications. You should also be good at least in some sub-fields of mathematics,
    such as linear algebra, statistics, and probability theory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们是计算机科学的新时代的一部分，数学再次回归。机器学习工程师现在使用数学的方式，就像数学家在20世纪70年代或80年代使用编程语言一样。现在仅仅知道一种编程语言或一个框架已经不够了，要设计一个新的算法或将机器学习应用到你的应用程序中，你还应该至少在一些数学子领域表现出色，比如线性代数、统计学和概率论。
- en: Almost the same logic applies to C++. Modern languages provide a wide range
    of functionality out of the box, while C++ developers are still striving to design
    flawless programs with manual memory management. If you do some quick research
    into the field of ML, you will find that most of the libraries or examples out
    there are using Python. At first, this might be seen as the default language to
    use in ML tasks. However, ML engineers are starting to touch a new threshold in
    evolution – performance. This threshold is not new; lots of tools out there are
    still using C++ in parts where they need performance. Game development, operating
    systems, mission-critical systems, and many other fundamental areas are using
    C++ (and C) as the *de facto* standard. It's now time for C++ to conquer a new
    area. Our best advice to the reader would be to study both ML and C++ because
    it is slowly becoming critical for ML engineers to incorporate C++ to get the
    best performance out there.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎相同的逻辑也适用于C++。现代语言提供了广泛的功能，而C++开发人员仍在努力设计具有手动内存管理的无缺陷程序。如果您对ML领域进行一些快速研究，您会发现大多数库或示例都在使用Python。起初，这可能被视为在ML任务中使用的默认语言。然而，ML工程师开始触及一个新的进化阈值——性能。这个阈值并不新鲜；许多工具仍在需要性能的部分使用C++。游戏开发、操作系统、关键任务系统以及许多其他基本领域都在使用C++（和C）作为*事实*标准。现在是C++征服新领域的时候了。我们对读者的最好建议是学习ML和C++，因为将C++纳入其中对于ML工程师来说慢慢变得至关重要，以获得最佳性能。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have introduced ML with its categories and applications. It is a rapidly
    growing field of study having numerous applications in building intelligent systems.
    We have categorized ML into supervised, unsupervised, and reinforcement learning
    algorithms. Each of the categories have their applications in solving tasks such
    as classification, clustering, regression, and machine translation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了ML及其类别和应用。这是一个快速增长的研究领域，在构建智能系统方面有着众多应用。我们将ML分类为监督、无监督和强化学习算法。每个类别都在解决分类、聚类、回归和机器翻译等任务中有应用。
- en: We have implemented a simple learning algorithm that defines a calculation function
    based on experiences provided as an input. We called it a dataset that we used
    to train the system. Training with datasets (called **experiences**) is one of
    the key properties in ML systems.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个简单的学习算法，它根据提供的经验定义了一个计算函数。我们称之为我们用来训练系统的数据集。使用数据集（称为**经验**）进行训练是ML系统中的关键属性之一。
- en: Finally, we introduced and discussed ANNs applied to recognize patterns. ML
    and neural networks go hand in hand in solving tasks. The chapter provides you
    with the necessary introduction to the field along with several examples of tasks
    so that you can spend some time diving into the topic. This will help you to have
    a general idea of AI and ML as it's becoming increasingly necessary for engineers
    in real-world application development. In the next chapter, we will learn how
    to implement a dialog-based search engine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍并讨论了应用于识别模式的人工神经网络。ML和神经网络在解决任务时息息相关。本章为您提供了领域的必要介绍以及几个任务的示例，以便您花一些时间深入了解该主题。这将帮助您对AI和ML有一个大致的了解，因为在实际应用开发中，对工程师来说这变得越来越必要。在下一章中，我们将学习如何实现基于对话的搜索引擎。
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is ML?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是ML？
- en: What are the differences between supervised and unsupervised learning algorithms?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监督学习和无监督学习算法之间有什么区别？
- en: Give some examples of ML applications.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一些ML应用的例子。
- en: How would you modify the `CalculationMachine` class to change its behavior after
    training it with a different set of experiences?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何修改`CalculationMachine`类以在用不同的经验集训练后改变其行为？
- en: What is the purpose of neural networks?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 神经网络的目的是什么？
- en: Further reading
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Artificial Intelligence and Machine Learning Fundamentals*, at [https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals](https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人工智能和机器学习基础*，网址为[https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals](https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals)'
- en: '*Machine Learning Fundamentals*, at [https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals](https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器学习基础*，网址为[https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals](https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals)'
- en: '*Hands-On Machine Learning for Algorithmic Trading, *at [https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading](https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算法交易的实践机器学习*，网址为[https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading](https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading)'
