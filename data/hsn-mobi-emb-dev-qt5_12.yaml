- en: Sounds and Visions - Qt Multimedia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音与视觉 - Qt Multimedia
- en: Applications that need to play sounds or show videos are usually games, while
    others are full-blown multimedia apps. Qt Multimedia can handle both.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 需要播放声音或显示视频的应用程序通常是游戏，而其他则是完整的多媒体应用程序。Qt Multimedia 可以处理这两者。
- en: Qt Multimedia can be used with both Qt Widgets and Qt Quick, or even without
    a GUI interface. It has both C++ and QML APIs, but the QML API has a few special
    treats and tricks. A little-known fact is that Qt can also play 3D positional
    audio in Qt Quick. You can control the gain and pitch with three dimensions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Multimedia 可以与 Qt Widgets 和 Qt Quick 一起使用，甚至在没有 GUI 界面的情况下使用。它具有 C++ 和 QML
    API，但 QML API 有一些特殊的特性和技巧。一个鲜为人知的事实是，Qt 还可以在 Qt Quick 中播放 3D 位置音频。你可以用三个维度来控制增益和音调。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Sonic vibrations – audio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音振动 - 音频
- en: Image sensors – camera
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像传感器 - 相机
- en: Visual media – playing video
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉媒体 - 播放视频
- en: Tuning it in – FM radio tuner
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调谐它 - FM 收音机调谐器
- en: Sonic vibrations – audio
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音振动 - 音频
- en: I have a relationship with audio that goes way back—before computers were household
    things, when Mylar tape and magnets ruled the sonic realms. Things have progressed
    since then. Now, mobile phones fit into our pockets and light bulbs can play music.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我与音频的关系可以追溯到很久以前——在计算机成为家庭用品之前，当 Mylar 磁带和磁铁统治着声音领域的时候。从那时起，事物已经进步了。现在，移动电话可以放入我们的口袋，灯泡可以播放音乐。
- en: 3D audio in Qt is supported through the OpenAL API. If you are using Linux,
    the default Qt binaries from Qt Company do not ship with the needed Qt Audio Engine
    API. You will have to install the OpenAL development package and then compile
    Qt Multimedia for yourself. OpenAL is not supported on Android, so no joy there.
    Luckily, it is supported by default on Apple Mac and iOS. So, that is where I
    am going to develop this next section. Let's grab the nearest MacBook and head
    over there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 中的 3D 音频通过 OpenAL API 支持。如果你使用的是 Linux，Qt 公司提供的默认 Qt 二进制文件不包含所需的 Qt 音频引擎
    API。你必须安装 OpenAL 开发包，然后自行编译 Qt Multimedia。OpenAL 在 Android 上不受支持，所以在这方面没有乐趣。幸运的是，它在
    Apple Mac 和 iOS 上默认支持。所以，我将在下一个部分进行开发。让我们拿起最近的 MacBook，前往那里。
- en: 3D audio is audio in three dimensions, just like 3D graphics—not just left and
    right, but also up, down, front, and back placement of audio. The term *positional
    audio* might explain this better.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 音频是三维空间中的音频，就像 3D 图形一样——不仅仅是左右，还有上下、前后位置。术语 *位置音频* 可能能更好地解释这一点。
- en: With Qt, 3D audio is only supported using Qt Quick.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，3D 音频仅通过 Qt Quick 支持。
- en: The source code for this chapter can be found in the Git repository under the `Chapter09-3dAudio` directory,
    in the `cp9` branch.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在 Git 仓库的 `Chapter09-3dAudio` 目录下的 `cp9` 分支中找到。
- en: 'To use Qt Multimedia, you need to edit the project `.pro` file and add the
    following line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Qt Multimedia，你需要编辑项目的 `.pro` 文件并添加以下行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit the `qml` file that you want to use the 3D audio in, and add the `import`
    line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你想要在 3D 音频中使用的 `qml` 文件，并添加 `import` 行：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 3D space is made up of three axes named x, y, and z, which correspond to horizontal/vertical
    and up/down in 3-dimensional space.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 空间由三个轴组成，分别命名为 x、y 和 z，它们对应于三维空间中的水平/垂直和上下方向。
- en: '`AudioEngine` and other associated classes use the `Qt.vector3d` value type.
    It is essential to understand this element to use 3D audio.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioEngine` 和其他相关类使用 `Qt.vector3d` 值类型。理解这个元素对于使用 3D 音频至关重要。'
- en: Qt.vector3d
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt.vector3d
- en: '`Qt.vector3d` is an array of values that represents the x, y, and z axes—x
    being horizontal, y being vertical, and z being up or down. Each value is a single-precision
    `qreal`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt.vector3d` 是一个表示 x、y 和 z 轴的值数组——x 表示水平，y 表示垂直，z 表示向上或向下。每个值都是一个单精度 `qreal`。'
- en: It can be used like `Qt.vector3d(15, -5, 0)` or `"15, -5, 0"` as a `String`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以使用如 `Qt.vector3d(15, -5, 0)` 或 `"15, -5, 0"` 作为 `String`。
- en: The positioning of the audio is controlled through the use of the `vector3d`
    property value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 音频的位置是通过使用 `vector3d` 属性值来控制的。
- en: '`Qt.vector3d` is used to position the audio in 3 dimensional space.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt.vector3d` 用于在三维空间中定位音频。'
- en: The main component for using 3D audio in QML is called `AudioEngine`. The other
    components we will use can be children of this component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 中使用 3D 音频的主要组件称为 `AudioEngine`。我们将使用的其他组件可以是此组件的子组件。
- en: AudioEngine
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频引擎
- en: '`AudioEngine` is the central container for the other 3D audio items that you
    will use.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioEngine` 是你将使用的其他 3D 音频项的中心容器。'
- en: 'We can set up the component easily enough:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松设置组件：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `dopplerFactor` property creates a Doppler shift effect. The `speedOfSound`
    value reflects the speed of sound in which the Doppler effect is calculated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`dopplerFactor` 属性创建多普勒频移效果。`speedOfSound` 值反映了计算多普勒效应时声音的速度。'
- en: You assign a `listener` through the `listener` property. We will get to that
    later in the *AudioListener* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `listener` 属性分配一个 `listener`。我们将在 *AudioListener* 部分中稍后讨论。
- en: We have an audio sample we want to load and use, so we declare at least one `AudioSample`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个想要加载并使用的音频样本，因此至少声明一个 `AudioSample`。
- en: AudioSample
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AudioSample
- en: '`AudioSample` can be defined as a child of an `AudioEngine` component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioSample` 可以定义为 `AudioEngine` 组件的子组件：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It can also be added using the `AudioEngine.addAudioSample()` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以使用 `AudioEngine.addAudioSample()` 方法添加：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `source` property holds the sample's filename and a name to refer to it
    with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 属性包含样本的文件名和一个用于引用它的名称。'
- en: Now, we are ready to play the sound using the `Sound` component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用 `Sound` 组件播放声音。
- en: Sound
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sound
- en: 'The `Sound` element is a container for one or more samples that will play with
    different parameters and variances. In other words, you can define a `PlayVariation`
    item, which defines how a `Sound` plays an `AudioSample`, with maximum or minimum
    values in pitch and gain. You can also declare the sample to be `looping`, which
    means it plays over and over:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound` 元素是一个容器，可以包含一个或多个样本，这些样本将以不同的参数和变化播放。换句话说，您可以定义一个 `PlayVariation` 项目，它定义了
    `Sound` 如何播放 `AudioSample`，包括音调和增益的最大值和最小值。您还可以声明样本为 `looping`，这意味着它会反复播放：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `attenuationModel` property controls the way the sound volume level falls
    off, or fades over time. It can be one of these values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`attenuationModel` 属性控制声音音量水平下降的方式，或者随时间淡出。它可以取以下值之一：'
- en: Linear is a straight falloff
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性是直线下降
- en: Inverse is a more natural, non-linear curve
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向是一个更自然、非线性的曲线
- en: You can control this using the `start`, `end`, and `rolloff` properties.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `start`、`end` 和 `rolloff` 属性来控制这一点。
- en: AudioListener
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AudioListener
- en: 'The `AudioListener` component represents the `listener` and its position in
    the 3D realm. There is only one `listener`. It can either be constructed as the
    `listener` property of the `AudioEngine` component, or as a definable element:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioListener` 组件代表 `listener` 以及其在 3D 空间的位置。只有一个 `listener`。它可以构建为 `AudioEngine`
    组件的 `listener` 属性，或者作为一个可定义的元素：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A `SoundInstance` is the component that a `Sound` uses to play the sample.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundInstance` 是 `Sound` 用于播放样本的组件。'
- en: SoundInstance
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SoundInstance
- en: '`SoundInstance` has a few properties that you can use to adjust the sound:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundInstance` 有一些属性，您可以使用它们来调整声音：'
- en: '`direction`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`'
- en: '`gain`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gain`'
- en: '`pitch`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pitch`'
- en: '`position`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`'
- en: These properties take a `vector3d` value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性接受一个 `vector3d` 值。
- en: 'The `sound` property of the `SoundInstance` element takes a string that represents
    the name of a `Sound` component:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundInstance` 元素的 `sound` 属性接受一个字符串，表示 `Sound` 组件的名称：'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, I start playing the sound when the component is completed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我在组件完成时开始播放声音。
- en: Now, we just need some mechanism to move the sound position around. We can use
    the `Accelerometer` values if we have an accelerometer on the device. I'm just
    going to use the mouse. Remember that on a touchscreen, a `MouseArea` also includes
    touch input.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要一些机制来移动声音位置。如果我们设备上有加速度计，我们可以使用加速度计的值。我只会使用鼠标。记住，在触摸屏上，`MouseArea` 也包括触摸输入。
- en: 'We must enable `hover` in order to track the mouse without clicking:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须启用 `hover` 才能跟踪鼠标而不点击：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To propagate the mouse clicks to buttons or other items when using `MouseArea`,
    put the `MouseArea` at the top of the file, as Qt Quick will set the z order in
    the order of the components from the top of the file, down to the bottom. You
    could also set the `z` property of the buttons and set the `z` property of the
    `MouseArea` to the lowest value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `MouseArea` 时，为了将鼠标点击传播到按钮或其他项目，请将 `MouseArea` 放在文件顶部，因为 Qt Quick 会按照从文件顶部到底部的组件顺序设置
    z 轴顺序。您也可以设置按钮的 `z` 属性，并将 `MouseArea` 的 `z` 属性设置为最低值。
- en: 'I previously declared three values in my `Window` component to use in the positioning
    of the audio:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前在 `Window` 组件中声明了三个值，用于音频的位置：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, when you move the mouse around, the audio will appear to move around.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您移动鼠标时，音频将看起来在移动。
- en: But there is no mouse on a phone. There is a touch point, but no scrolling.
    I could use an `Accelerometer` as it has the z axis, or use `PinchArea` to control
    the up and down position.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但手机上没有鼠标。有一个触摸点，但没有滚动。我可以使用`加速度计`，因为它有z轴，或者使用`PinchArea`来控制上下位置。
- en: Let's look at a few other ways to deal with audio.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理音频的几种其他方法。
- en: Audio
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频
- en: The `Audio` element is probably the easiest way to play audio. It only takes
    a few lines. It would be good for playing sound effects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Audio`元素可能是播放音频最简单的方法。它只需要几行代码。它非常适合播放音效。'
- en: The source code can be found in this book's Git repository under the `Chapter09-1` directory,
    in the `cp9` branch.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码也可以在本书的Git仓库中找到，位于`Chapter09-1`目录下的`cp9`分支。
- en: 'We will use the following `import` statement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下`import`语句：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s a simple stanza that will play the `.mp3` file named `sample.mp3`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的段落，将播放名为`sample.mp3`的`.mp3`文件：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `source` property is where you declare which file to play. Now, you just
    have to call the `play()` method to have this `sample.wav` file play:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`属性是声明要播放哪个文件的地方。现在，你只需要调用`play()`方法来播放这个`sample.wav`文件：'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can also set the `autoPlay` property to `true` instead of calling `play`,
    and that would play the file once the component is completed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`autoPlay`属性设置为`true`，而不是调用`play`，这样组件完成后就会播放文件。
- en: 'Setting the volume is as easy as declaring the `volume` property and setting
    a decimal value between 0 and 1—1 being full volume and 0 being muted:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设置音量就像声明`volume`属性并设置一个介于0和1之间的十进制值一样——1表示全音量，0表示静音：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Getting the metadata or ID tags from the file is not obvious, as they only become
    available after the `metaDataChanged` signal gets emitted. This is only emitted
    by the `Audio` element's `metaData` object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中获取元数据或ID标签并不明显，因为它们只有在`metaDataChanged`信号发出后才会可用。这个信号只由`Audio`元素的`metaData`对象发出。
- en: 'Sometimes, you might need to display a file''s metadata, or the extra data
    that can be within the audio file''s headers. The `Audio` component has a `metaData`
    property that can be used like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要显示文件的元数据，或者可以包含在音频文件头部的额外数据。`Audio`组件有一个`metaData`属性，可以像这样使用：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you need to access the microphone and record audio, you will need to dive
    into C++, so let's take a look at `QAudioRecorder`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问麦克风并录制音频，你需要深入到C++，让我们看看`QAudioRecorder`。
- en: QAudioRecorder
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QAudioRecorder
- en: Recording audio is one of my passions. Recording audio, or more specifically
    using the microphone, may require user permissions on some platforms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 录制音频是我的一项爱好。录制音频，或者更具体地说使用麦克风，在某些平台上可能需要用户权限。
- en: The recording of audio, called taping back in my day, can be implemented by
    using the `QAudioRecorder` class. Recording properties are controlled by the `QAudioEncoderSettings`
    class, from which you can control the codec that's used, the channel count, the
    bit rate, and the sample rate. You can either explicitly set the bit rate and
    sample rate, or use the more generic `setQuality` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 音频的录制，在我那个时代被称为录音，可以通过使用`QAudioRecorder`类来实现。录制属性由`QAudioEncoderSettings`类控制，你可以从中控制使用的编解码器、通道数、比特率和采样率。你可以显式设置比特率和采样率，或者使用更通用的`setQuality`函数。
- en: The source code can be found in this book's Git repository under the `Chapter09-2` directory,
    in the `cp9` branch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在本书的Git仓库中找到，位于`Chapter09-2`目录下的`cp9`分支。
- en: 'You might want to query the input devices and see which settings are available.
    To do that, you would query using `QAudioDeviceInfo`, iterating through `QAudioDeviceInfo::availableDevices(QAudio::AudioInput)`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想查询输入设备并查看哪些设置可用。为此，你会使用`QAudioDeviceInfo`进行查询，遍历`QAudioDeviceInfo::availableDevices(QAudio::AudioInput)`：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Qt Multimedia uses the term sample sizes for the more common term bit depth.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Qt多媒体使用“样本大小”这个术语来指代更常见的“位深度”。
- en: 'As you can see from my laptop, I have a few different audio input devices.
    The laptop''s built-in audio chip got fried from an electrical spike, which is
    why it isn''t seen here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如从我笔记本电脑上所见，我有几个不同的音频输入设备。笔记本电脑的内置音频芯片因电涌而损坏，这就是为什么它在这里没有显示：
- en: '![](img/a5acaf2c-000a-4c42-9ccb-ada79d0bf846.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5acaf2c-000a-4c42-9ccb-ada79d0bf846.png)'
- en: 'For iPhone, it is different. It has only one audio device, named `default`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iPhone，情况不同。它只有一个音频设备，名为`default`：
- en: '![](img/4ef5a2e6-b9df-4ad1-ab1a-60cc43d0dd76.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ef5a2e6-b9df-4ad1-ab1a-60cc43d0dd76.png)'
- en: My Linux desktop reports a lot of audio input devices because of the ALSA Driver,
    which I won't include here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我的Linux桌面因为ALSA驱动程序报告了大量的音频输入设备，这里不包括在内。
- en: 'We need to set up the recording encoder settings with the type of audio file
    we want to record. This includes the number of channels, the code, sample rate,
    and bit rate:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置录音编码设置，包括我们想要录制的音频文件的类型、通道数、编码、采样率和比特率：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you want to let the system decide on the various settings, it is quicker
    and takes less code to use the `setQuality` function, which can take one of the
    following values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让系统决定各种设置，使用`setQuality`函数会更快捷，代码也更少，该函数可以接受以下值之一：
- en: '`QMultimedia::VeryLowQuality`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMultimedia::VeryLowQuality`'
- en: '`QMultimedia::LowQuality`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMultimedia::LowQuality`'
- en: '`QMultimedia::NormalQuality`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMultimedia::NormalQuality`'
- en: '`QMultimedia::HighQuality`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMultimedia::HighQuality`'
- en: '`QMultimedia::VeryHighQuality`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMultimedia::VeryHighQuality`'
- en: 'Let''s choose `NormalQuality`, which will give the same results:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择`NormalQuality`，这将给出相同的结果：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `QAudioRecorder` class is used to record the audio, so let''s construct
    a `QAudioRecorder` and set the encoding settings:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAudioRecorder`类用于录音，所以让我们构建一个`QAudioRecorder`并设置编码设置：'
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also specify which audio input to use, but first you will need to get
    a list of available audio input:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定要使用的音频输入，但首先您需要获取可用音频输入的列表：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you don''t want to bother about which audio device to use, you can specify
    it using the default device with the `defaultAudioInput()` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想麻烦选择哪个音频设备，您可以使用`defaultAudioInput()`函数指定默认设备：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can save it to a file, or even a network location, as the `setOutputLocation`
    function takes a `QUrl`. We will just specify a local file to save it to:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它保存到文件，甚至网络位置，因为`setOutputLocation`函数接受一个`QUrl`。我们只需指定一个本地文件来保存：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the file is relative, like it is here, you can get the actual output location
    using `outputLocation()` once the recording has started.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件是相对的，就像这里一样，一旦开始录音，您可以使用`outputLocation()`获取实际输出位置。
- en: 'Finally, we can start the recording process:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始录音过程：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are also the `stop()` and `pause()` methods to control the recording operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些方法来控制录音操作，比如`stop()`和`pause()`。
- en: 'Of course, you will want to connect to the error signal, because errors can
    and will happen from time to time. Again, note the use of the `QOverload` syntax
    that''s used in error-reporting signals:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您会想连接到错误信号，因为错误有时会发生。再次注意在错误报告信号中使用的`QOverload`语法：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, now that we have recorded some audio, we might want to listen to it. This
    is where `QMediaPlayer` comes in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经录制了一些音频，我们可能想听听它。这就是`QMediaPlayer`发挥作用的地方。
- en: QMediaPlayer
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMediaPlayer
- en: '`QMediaPlayer` is fairly straightforward. It can play both audio and video,
    but here we will only be playing audio. First, we need to set up the media to
    play by calling `setMedia`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMediaPlayer`相当简单。它可以播放音频和视频，但在这里我们只会播放音频。首先，我们需要通过调用`setMedia`来设置要播放的媒体。'
- en: 'We can use `QAudioRecorder` to get the output file and use it to play:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`QAudioRecorder`获取输出文件并使用它来播放：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will have to monitor the current playing position, so we will connect the
    `positionChanged` signal to a progress bar:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不监控当前播放位置，因此我们将`positionChanged`信号连接到一个进度条：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Connect the error signal and its `QOverload` syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 连接错误信号及其`QOverload`语法：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, just call `play()` on the `QMediaPlayer` object:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需在`QMediaPlayer`对象上调用`play()`即可：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even set the playback volume:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以设置播放音量：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you need access to the media data, let's say for getting the volume level
    of the data as it plays, you will want to use something other than `QMediaPlayer`
    to play your file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要访问媒体数据，比如说获取播放时的音量级别，您可能需要使用除了`QMediaPlayer`之外的其他方式来播放您的文件。
- en: QAudioOutput
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QAudioOutput
- en: '`QAudioOutput` provides a way to send audio to an audio output device:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAudioOutput`提供了一种将音频发送到音频输出设备的方式：'
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `QAudioOutput`, you will need to set up the exact format of your file.
    To get the format of your file, you could use `QMediaResource`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QAudioOutput`，您需要设置文件的精确格式。要获取文件的格式，您可以使用`QMediaResource`。
- en: 'Scratch that—`QMediaResource` is being depreciated in Qt 6.0, and does not
    do what the docs say it is supposed to do, and doesn''t work like it should. We
    need to hardcode the data format, so we will use the basic good-quality stereo
    format. `QAudioFormat` is the way to do this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，`QMediaResource`在Qt 6.0中被弃用，并且它并没有按照文档所说的那样工作，也没有像预期的那样工作。我们需要硬编码数据格式，因此我们将使用基本的优质立体声格式。`QAudioFormat`是这样做的方式：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will iterate through the audio devices and check that `QAudioDeviceInfo`
    supports this format:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历音频设备并检查`QAudioDeviceInfo`是否支持此格式：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, I connected to the `stateChanged` signal and tested whether the state
    is `StoppedState`; we know there might be an error, so we check the `error()`
    of the `QAudioOutput` object. Otherwise, we can play the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我连接到了`stateChanged`信号并测试了状态是否为`StoppedState`；我们知道可能存在错误，因此我们检查`QAudioOutput`对象的`error()`。否则，我们可以播放文件：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We see now that Qt Multimedia has various ways of playing audio. Now, let's
    take a look at the camera and recording video.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到Qt多媒体有各种播放音频的方式。现在，让我们来看看相机和录制视频。
- en: Image sensors – camera
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像传感器 - 相机
- en: First, we should establish whether the device has any cameras. This helps us
    determine specifics about the use of the camera and other camera specifications,
    such as the orientation or position on the device.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该确定设备是否有任何相机。这有助于我们确定相机使用的具体细节以及其他相机规格，例如设备上的方向或位置。
- en: For this, we will use `QCameraInfo`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此操作，我们将使用`QCameraInfo`。
- en: QCameraInfo
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QCameraInfo
- en: 'We can get a list of cameras using the `QCameraInfo::availableCameras()` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`QCameraInfo::availableCameras()`函数获取相机列表：
- en: The source code can be found in this book's Git repository under the `Chapter09-4` directory,
    in the `cp9` branch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在本书的Git仓库的`Chapter09-4`目录下的`cp9`分支中找到。
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On my Android device, I see two cameras, named `back` and `front`. You can
    also check for `front` and `back` cameras using `QCameraInfo::position()`, which
    will return one of the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Android设备上，我看到了两个相机，分别命名为`back`和`front`。您也可以使用`QCameraInfo::position()`检查`front`和`back`相机，它将返回以下之一：
- en: '`QCamera::UnspecifiedPosition`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::UnspecifiedPosition`'
- en: '`QCamera::BackFace`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::BackFace`'
- en: '`QCamera::FrontFace`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::FrontFace`'
- en: '`FrontFace` means that the camera lens is on the same side as the screen. You
    can then use `QCameraInfo` to construct a `QCamera` object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrontFace`表示相机镜头与屏幕在同一侧。然后您可以使用`QCameraInfo`来构建`QCamera`对象：'
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, check for the capture modes the camera supports, which can be one of the
    following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查相机支持的捕获模式，这可以是以下之一：
- en: '`QCamera::CaptureViewfinder`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::CaptureViewfinder`'
- en: '`QCamera::CaptureStillImage`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::CaptureStillImage`'
- en: '`QCamera::CaptureVideo`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::CaptureVideo`'
- en: 'Let''s do a quick still image shot first. We need to tell the camera to use
    the `QCamera::CaptureStillImage` mode:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先进行一次快速静态图像拍摄。我们需要告诉相机使用`QCamera::CaptureStillImage`模式：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `statusChanged` signal is used to monitor the status, which can be one
    of the following values:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`statusChanged`信号用于监控状态，可以是以下值之一：'
- en: '`QCamera::UnavailableStatus`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::UnavailableStatus`'
- en: '`QCamera::UnloadedStatus`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::UnloadedStatus`'
- en: '`QCamera::UnloadingStatus`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::UnloadingStatus`'
- en: '`QCamera::LoadingStatus`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::LoadingStatus`'
- en: '`QCamera::LoadedStatus`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::LoadedStatus`'
- en: '`QCamera::StandbyStatus`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::StandbyStatus`'
- en: '`QCamera::StartingStatus`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::StartingStatus`'
- en: '`QCamera::StoppingStatus`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::StoppingStatus`'
- en: '`QCamera::ActiveStatus`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCamera::ActiveStatus`'
- en: 'Let''s connect to the `statusChanged` signal so that we can see status changes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接到`statusChanged`信号，这样我们就可以看到状态变化：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you need to fiddle with any of the camera settings, you will have to `load()`
    it before you can get access to the `QCameraImageProcessing` object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要调整任何相机设置，您必须在获取对`QCameraImageProcessing`对象的访问权限之前先`load()`它：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the `QCameraImageProcessing` class, you can set configurations, such as
    brightness, contrast, saturation, and sharpening.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QCameraImageProcessing`类，您可以设置配置，例如亮度、对比度、饱和度和锐化。
- en: Before we call start on the camera, we need to set up a `QMediaRecorder` object
    for the camera. Since `QCamera` is inherited from `QMediaObject`, we can feed
    it to the `QMediaRecorder` object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对相机调用`start`之前，我们需要为相机设置一个`QMediaRecorder`对象。由于`QCamera`是从`QMediaObject`继承的，我们可以将其馈送到`QMediaRecorder`对象。
- en: Qt Multimedia Widgets are not supported on Android.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Qt多媒体小部件在Android上不受支持。
- en: I tried `QCamera` version 5.12 on both Mac and iOS, but it kept crashing when
    I tried to `start()` the camera. I was successful on Linux desktop. On Android,
    since multimedia widgets are not supported, the camera viewfinder widget did not
    work, but I could still capture images from the image sensor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Mac和iOS上尝试了`QCamera`版本5.12，但在尝试`start()`相机时它总是崩溃。在Linux桌面上我成功了。在Android上，由于多媒体小部件不受支持，相机取景器小部件无法工作，但我仍然可以从图像传感器捕获图像。
- en: Maybe you'll have better luck with the QML side of things. QML APIs are usually
    optimized for easy use.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在QML方面会有更好的运气。QML API通常针对易于使用进行了优化。
- en: Camera
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Camera
- en: 'Yes, the QML `Camera` is so much easier to implement. Really, there are only
    two components you need to take a photo: `Camera` and `VideoOutput`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，QML的`Camera`实现起来要容易得多。实际上，您只需要两个组件来拍照：`Camera`和`VideoOutput`。
- en: '`VideoOutput` is the element to use for the viewfinder. It is also used when
    you are recording video:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoOutput`是用于取景器的元素。在您录制视频时也会使用它：'
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `position` property controls which camera to use, especially on a mobile
    device that may have a front-facing and rear-facing camera. Here, I am not only
    using the rear camera. You would use the `FrontFace` position to take a selfie.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`position`属性控制使用哪个相机，尤其是在可能具有前置和后置相机的移动设备上。在这里，我不仅使用后置相机。您可以使用`FrontFace`位置来拍摄自拍。'
- en: '`imageCaptured` pertains to the `CameraCapture` sub-element. We can handle
    the `onImageCaptured` signal to preview the image or to alert the user that a
    photo has been taken.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`imageCaptured`与`CameraCapture`子元素相关。我们可以处理`onImageCaptured`信号来预览图像或提醒用户已拍照。'
- en: 'The other properties of the `Camera` object can be controlled by their corresponding
    components:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`对象的其余属性可以通过它们相应的组件进行控制：'
- en: '`focus : CameraFocus`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus : CameraFocus`'
- en: '`flash : CameraFlash`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash : CameraFlash`'
- en: '`exposure : CameraExposure`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`曝光 : CameraExposure`'
- en: '`imageProcessing : CameraImageProcessing`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageProcessing : CameraImageProcessing`'
- en: '`imageCapture : CameraCapture`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageCapture : CameraCapture`'
- en: '`videoRecorder: CameraRecorder`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`videoRecorder: CameraRecorder`'
- en: '`CameraRecorder` is what you would use to controls saturation, brightness,
    color filters, contrast, and other settings.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraRecorder`是您用来控制饱和度、亮度、颜色滤镜、对比度和其他设置的元素。'
- en: '`CameraExposure` controls things such as aperture, exposure compensation, and
    shutter speed.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraExposure`控制诸如光圈、曝光补偿和快门速度等事项。'
- en: '`CameraFlash` can turn the flash on, off, or use auto mode. It can also set
    red-eye compensation and video (constant) mode.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraFlash`可以打开、关闭闪光灯或使用自动模式。它还可以设置红眼消除和视频（恒定）模式。'
- en: We need a view finder to see what the heck we are trying to capture, so let's
    take a look at the `VideoOutput` element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个取景器来查看我们试图捕捉的是什么，让我们看看`VideoOutput`元素。
- en: VideoOutput
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频输出
- en: '`VideoOutput` is the component we use to view what the camera is sensing.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoOutput`是我们用来查看相机所感知内容的组件。'
- en: The source code can be found on the Git repository under the `Chapter09-5` directory,
    in the `cp9` branch.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter09-5`目录下的`cp9`分支中找到。
- en: 'To implement the `VideoOutput` component, you need to define the `source` property.
    Here, we are using the camera:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`VideoOutput`组件，您需要定义`source`属性。在这里，我们使用的是相机：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `autoOrientation` property is used to allow the `VideoOutput` component
    to compensate for the device orientation of the image sensor. Without this being
    true, the image might show up in the view finder with the wrong orientation and
    confuse the user, making it harder to take a good photo or video.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoOrientation`属性用于允许`VideoOutput`组件补偿图像传感器的设备方向。如果没有这个属性为真，图像可能会以错误的方向显示在取景器中，从而混淆用户，使得拍摄好照片或视频变得更加困难。'
- en: 'Let''s make this `VideoOutput` clickable by adding a `MouseArea`, where I will
    use the `onClicked` and `onPressAndHold` signals to focus and actually capture
    an image:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个`MouseArea`来使这个`VideoOutput`可点击，我将使用`onClicked`和`onPressAndHold`信号来聚焦并实际捕捉图像：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I also added a `Switch` component from Qt Quick Controls to control whether
    the user wants a still photo or video recorded.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了来自Qt Quick Controls的`Switch`组件来控制用户是否想要记录静态照片或视频。
- en: To focus the camera, call the `searchAndLock()` method, which starts focus,
    white balance, and exposure computations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要聚焦相机，请调用`searchAndLock()`方法，它将启动聚焦、白平衡和曝光计算。
- en: 'Let''s add support for recording videos. We will add a `CameraRecorder` container
    to the `Camera` component:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加录制视频的支持。我们将向`Camera`组件添加一个`CameraRecorder`容器：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can set certain aspects for the video, such as bit rate, frame rate, number
    of audio channels, and what container to use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为视频设置某些方面，例如比特率、帧率、音频通道数以及要使用的容器。
- en: 'We need to also change the way our `onPressAndHold` signal works to make sure
    we record video when the user has specified it, by the use of the switch:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改`onPressAndHold`信号的工作方式，以确保当用户通过开关指定时，我们记录视频。
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We need some way to stop recording, so let''s modify the `onClicked` signal
    handler to stop the recording when it is in `RecordingState`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种停止录制的方法，所以让我们修改`onClicked`信号处理程序，以便在`RecordingState`时停止录制。
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we need to actually see the video we just recorded. Let's move on and look
    at how to play a video.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要真正看到我们刚刚录制的视频。让我们继续并看看如何播放视频。
- en: Visual media – playing video
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉媒体 - 播放视频
- en: Playing a video with QML is much like playing audio using `MediaPlayer`, only
    using a `VideoOutput` instead of an `AudioOutput` component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QML播放视频与使用`MediaPlayer`播放音频类似，只是使用`VideoOutput`组件代替`AudioOutput`组件。
- en: The source code can be found on the Git repository under the `Chapter09-6` directory,
    in the `cp9` branch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter09-6`目录下的`cp9`分支中找到。
- en: 'We begin by implementing a `MediaPlayer` component:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现一个`MediaPlayer`组件：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The property named `autoPlay` will control the automatic starting of the video
    once the component is completed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`autoPlay`的属性将控制组件完成后自动开始视频。
- en: 'Here, the `source` property is set to the filename of our video:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`source`属性设置为我们的视频文件名：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then create a `VideoOutput` component, with the source being our `MediaPlayer`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个`VideoOutput`组件，源为我们的`MediaPlayer`：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `MouseArea`, which is the entire application, is used here to start playing
    the video when you click anywhere on the application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`MouseArea`，即整个应用程序，用于在您点击应用程序的任何地方时开始播放视频。
- en: With C++, you would use the `QMediaPlayer` class with a `QGraphicsVideoItem`, `QVideoWidget`, or
    something else.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++，您会使用`QMediaPlayer`类与`QGraphicsVideoItem`、`QVideoWidget`或其他类似的东西。
- en: Since `QMultimediaWidgets` have limited support on mobile devices, I will leave
    this as an exercise for the reader.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QMultimediaWidgets`在移动设备上的支持有限，我将把这留作读者的练习。
- en: Qt Multimedia also supports FM, AM, and some other radios, providing your device
    has a radio in it as well.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Qt多媒体也支持FM、AM以及一些其他收音机，前提是您的设备中也有收音机。
- en: Tuning it in – FM radio tuner
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调谐它 – FM收音机调谐器
- en: Some Android phones have an FM radio receiver. Mine does! It requires the wired
    headphones to be inserted to work as the antenna.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一些安卓手机有FM收音机接收器。我的手机就有！它需要插入有线耳机才能作为天线工作。
- en: 'We start by implementing a `Radio` component:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现一个`Radio`组件：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Radio` element has a `band` property that you can use to configure the
    radio''s frequency band use. They are one of the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Radio`元素有一个`band`属性，您可以使用它来配置收音机的频率波段使用。它们是以下之一：'
- en: '`Radio.AM` : 520 - 1610 kHz'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.AM` : 520 - 1610 kHz'
- en: '`Radio.FM` : 87.5 - 108 MHz, Japan 76 - 90 MHz'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.FM` : 87.5 - 108 MHz，日本 76 - 90 MHz'
- en: '`Radio.SW` : 1.711 to 30 MHz'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.SW` : 1.711到30 MHz'
- en: '`Radio.LW` : 148.5 to 283.5 kHz'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.LW` : 148.5到283.5 kHz'
- en: '`Radio.FM2` : Range not defined'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.FM2` : 范围未定义'
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `availability` property can return the following different values:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`availability`属性可以返回以下不同的值：'
- en: '`Radio.Available`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.Available`'
- en: '`Radio.Busy`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.Busy`'
- en: '`Radio.Unavailable`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.Unavailable`'
- en: '`Radio.ResourceMissing`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.ResourceMissing`'
- en: 'The first thing the user will do with a radio is scan for stations, which can
    be accomplished by using the `searchAllStations` method, which takes one of the
    following values:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用户首先会用收音机搜索电台，这可以通过使用`searchAllStations`方法完成，该方法接受以下值之一：
- en: '`Radio.SearchFast`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.SearchFast`'
- en: '`Radio.SearchGetStationId`: Like `SearchFast`, it emits the `stationFound`
    signal'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radio.SearchGetStationId`: 与`SearchFast`类似，它发出`stationFound`信号'
- en: The `stationsFound` signal returns an `int` `frequency` and `stationId` string
    for each station that's tuned in. You could collect these in a model-based component,
    such as `ListView`, using a `ListModel`. The `ListView` would use the `ListModel`
    as its model.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`stationsFound`信号为每个调谐的电台返回一个`int`类型的`frequency`和一个`stationId`字符串。您可以在基于模型的组件中收集这些信息，例如`ListView`，使用`ListModel`。`ListView`将使用`ListModel`作为其模型。'
- en: You can cancel the scan by calling the `cancelScan()` method. The `scanUp()`
    and `scanDown()` methods are similar to `searchAllStations`, except it does not
    remember the stations it found. The `tuneUp` and `tuneDown` methods will tune
    the frequency up or down one step, according to the `frequencyStep`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`cancelScan()`方法取消扫描。`scanUp()`和`scanDown()`方法与`searchAllStations`类似，但不会记住它找到的电台。`tuneUp`和`tuneDown`方法将根据`frequencyStep`调整频率上下一个步长。
- en: 'Here are some other interesting properties:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他有趣的属性：
- en: '`antennaConnected`: True if an antenna is connected'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antennaConnected`: 如果连接了天线则为True'
- en: '`signalStrength`: Strength of the signal in %'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signalStrength`: 信号强度，百分比%'
- en: '`frequency`: Holds and sets the frequency that the radio is tuned to'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frequency`: 保存和设置收音机调谐到的频率'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the different aspects of the big API of Qt Multimedia.
    You should now be able to position sound in a 3-dimensional way for 3D games.
    We learned how to record and play audio and video, and control and use the camera
    to take a selfie. We also touched on using QML to listen to radio stations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Qt 多媒体大 API 的不同方面。你现在应该能够以三维方式定位声音，用于三维游戏。我们学习了如何录制和播放音频和视频，以及如何控制和使用摄像头来拍摄自拍。我们还简要介绍了如何使用
    QML 来收听电台。
- en: In the next chapter, we will dig into using `QSqlDatabase` to access databases.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何使用 `QSqlDatabase` 访问数据库。
