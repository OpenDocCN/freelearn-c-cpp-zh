- en: Low-Level Programming with C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++进行低级编程
- en: Initially, C++ was perceived as the successor of the C language; however, since
    then it has evolved into something big, sometimes scary, and even untamable. With
    recent language updates, it now represents a complex beast that requires time
    and patience to tame. We will start this chapter with the basic constructs that
    almost every language supports, such as data types, conditional and loop statements,
    pointers, structs, and functions. We will look at those constructs from the perspective
    of a low-level systems programmer, curious how even a simple instruction can be
    executed by the computer. A deep understanding of these basic constructs is mandatory
    in building a solid base for more advanced and abstract topics such as object-oriented
    programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，C++被视为C语言的继承者；然而，自那时以来，它已经发展成为一个庞大的东西，有时甚至令人生畏，甚至难以驾驭。通过最近的语言更新，它现在代表着一个复杂的怪物，需要时间和耐心来驯服。我们将从几乎每种语言都支持的基本构造开始这一章，如数据类型、条件和循环语句、指针、结构体和函数。我们将从低级系统程序员的角度来看待这些构造，好奇地了解即使是一个简单的指令也可以被计算机执行。对这些基本构造的深入理解是建立更高级和抽象主题的坚实基础的必要条件，比如面向对象的编程。
- en: 'In this chapter, we will learn more about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The details of program execution and its entry point
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序执行的细节及其入口点
- en: Special properties of the `main()` function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`函数的特殊属性'
- en: Intricacies behind the function call and recursion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用和递归背后的复杂性
- en: Memory segments and addressing fundamentals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存段和寻址基础
- en: Data types and how variables reside in memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型和变量在内存中的存储位置
- en: Pointers and arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针和数组
- en: The low-level details of conditionals and loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件和循环的低级细节
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the option `--std=c++2a` is used to compile the examples
    throughout the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用选项`--std=c++2a`来编译g++编译器中的示例。
- en: You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章中使用的源文件在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)中找到。
- en: Program execution
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序执行
- en: In [Chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml), *Building C++ Applications*,
    we learned that the compiler generates an executable file after compiling the
    source code. The executable file contains machine code that can be copied to the
    memory of the computer to be run by the **Central Processing Unit** (**CPU**).
    The copying is done by an internal tool of the OS called a loader. So the **operating
    system** (**OS**) copies the contents of the program to the memory and starts
    executing the program by passing its first instruction to the CPU.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml)中，*构建C++应用程序*，我们了解到编译器在编译源代码后生成可执行文件。可执行文件包含可以复制到计算机内存中由**中央处理单元**（**CPU**）运行的机器代码。复制是由操作系统的内部工具加载器完成的。因此，**操作系统**（**OS**）将程序的内容复制到内存中，并通过将其第一条指令传递给CPU来开始执行程序。
- en: main()
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main()
- en: 'Program execution starts with the `main()` function, the *designated start
    of the program* as stated in the standard. A simple program outputting the `Hello,
    World!` message will look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行始于`main()`函数，作为标准中指定的*程序的指定开始*。一个简单的输出`Hello, World!`消息的程序将如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may have encountered or used in your programs the arguments of the `main()`
    function. It has two arguments, `argc` and `argv,` allowing strings to be passed
    from the environment, usually referred to as the **command-line arguments**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经遇到或在您的程序中使用了`main()`函数的参数。它有两个参数，`argc`和`argv`，允许从环境中传递字符串，通常称为**命令行参数**。
- en: 'The names `argc` and `argv` are conventional and can be replaced with anything
    you want. The `argc` argument holds the number of command-line arguments passed
    to the `main()` function; the `argv` argument holds the arguments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`argc`和`argv`的名称是传统的，可以用任何你想要的东西替换。`argc`参数保存传递给`main()`函数的命令行参数的数量；`argv`参数保存参数：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, we can compile and run the preceding example with the following
    arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下参数编译和运行前面的示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will output the following to the screen:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上输出以下内容：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you look at the number of arguments, you'll notice that it is `5`. The
    first argument is always the name of the program; that's why we skipped it in
    the example by starting the loop from number `1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看参数的数量时，您会注意到它是`5`。第一个参数始终是程序的名称；这就是为什么我们在示例中从数字`1`开始循环的原因。
- en: Rarely, you can see a widely supported but not standardized third argument,
    most commonly named `envp`. The type of `envp` is an array of `char` pointers
    and it holds the environment variables of the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很少见到一个广泛支持但未标准化的第三个参数，通常称为`envp`。`envp`的类型是`char`指针数组，它保存系统的环境变量。
- en: 'The program can contain lots of functions, but the execution of the program
    always starts with the `main()` function, at least from the programmer''s perspective.
    Let''s try to compile the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以包含许多函数，但程序的执行始终从`main()`函数开始，至少从程序员的角度来看。让我们尝试编译以下代码：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'g++ raises an error on the `foo();` call `C++ requires a type specifier for
    all declarations`. The call was parsed as a declaration rather than an instruction
    to execute. The way we tried to call a function before `main()` might seem silly
    for seasoned developers, so let''s try another way. What if we declare something
    that calls a function during its initialization? In the following example, we
    define a `BeforeMain` struct with a constructor printing a message, and then we
    declare an object of type `BeforeMain` in the global scope:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: g++在`foo();`调用上引发错误`C++需要为所有声明指定类型说明符`。该调用被解析为声明而不是执行指令。我们在`main()`之前尝试调用函数的方式对于经验丰富的开发人员可能看起来很愚蠢，所以让我们尝试另一种方式。如果我们声明一个在初始化期间调用函数的东西会怎样？在下面的示例中，我们定义了一个带有打印消息的构造函数的`BeforeMain`结构，然后在全局范围内声明了一个`BeforeMain`类型的对象：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The example successfully compiles and the program outputs the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例成功编译，并且程序输出以下内容：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What if we add a member function to `BeforeMain` and try to call it? See the
    following code to understand this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`BeforeMain`添加一个成员函数并尝试调用它会发生什么？请看以下代码以了解这一点：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The call to `test()` won''t be successful. So we cannot call a function before
    `main()`, but we can declare variables- objects that would be initialized by default.
    So there is definitely something that does an *initialization* before `main()`
    is actually called. It turns out that the `main()` function is not the true starting
    point of a program. The actual starting function of the program prepares the environment,
    that is, collects the arguments passed to the program, and then calls the `main()`
    function. This is required because C++ supports global and static objects that
    need to be initialized before the program begins, which means before the `main()`
    function is called. In the Linux world, this function is referred to as `__libc_start_main`.
    The compiler augments the generated code with the call of `__libc_start_main`,
    which in turn may or may not call other initialization functions before the `main()`
    function gets called. Going abstract, just imagine that the preceding code will
    be altered to something similar to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对`test()`的调用将不成功。因此我们不能在`main()`之前调用函数，但我们可以声明变量-对象将被默认初始化。因此，在`main()`实际调用之前肯定有一些*初始化*的操作。事实证明，`main()`函数并不是程序的真正起点。程序的实际起始函数准备环境，即收集传递给程序的参数，然后调用`main()`函数。这是必需的，因为C++支持需要在程序开始之前初始化的全局和静态对象，这意味着在调用`main()`函数之前。在Linux世界中，这个函数被称为`__libc_start_main`。编译器通过调用`__libc_start_main`来增强生成的代码，然后可能调用其他初始化函数，然后调用`main()`函数。抽象地说，想象一下上面的代码将被修改为类似以下的内容：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will examine the entry point in more detail in the upcoming chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地研究入口点。
- en: Special properties of main()
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main()的特殊属性
- en: 'We concluded that `main()` is not actually the entry point of the program,
    though the standard states that it is the designated start. The compiler pays
    special attention to `main()`. It behaves like a regular C++ function, but besides
    being the first function to be called, it has other special properties. First
    of all, it is the only function that could omit the `return` statement:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，`main()`实际上并不是程序的入口点，尽管标准规定它是指定的起点。编译器特别关注`main()`。它的行为类似于常规的C++函数，但除了是第一个被调用的函数之外，它还具有其他特殊属性。首先，它是唯一一个可以省略`return`语句的函数：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The returned value indicates the success of the execution. By returning `0`,
    we aim to tell the control that `main()` ended successfully, so if the control
    reaches the end without encountering a corresponding `return` statement, it will
    consider the call successful and the effect is the same as `return 0;`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值表示执行的成功。通过返回`0`，我们旨在告诉控制`main()`成功结束，因此如果控制在没有遇到相应的`return`语句的情况下到达末尾，它将认为调用成功，效果与`return
    0;`相同。
- en: 'Another interesting property of the `main()` function is that its return type
    cannot be deduced automatically. It is not allowed to use the `auto` placeholder
    type specifier, which indicates that the return type will be deduced from function''s
    `return` statement. Here''s how it works for regular functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的另一个有趣属性是它的返回类型不能自动推断。不允许使用`auto`占位类型说明符，该说明符表示返回类型将从函数的`return`语句中推断。这是正常函数的工作原理：'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By placing the `auto` specifier, we tell the compiler to automatically deduce
    the `return` type. With C++11, we also placed the type name after the arrow (`->`)
    although the second syntax is shorter. Consider the `get_ratio()` function, which
    returns the standard ratio as an integer:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过放置`auto`说明符，我们告诉编译器自动推断`return`类型。在C++11中，我们还在箭头(`->`)之后放置了类型名称，尽管第二种语法更短。考虑`get_ratio()`函数，它将标准比率作为整数返回：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To successfully compile C++ code containing new features specified in C++11,
    C++14, C++17, or C++20, you should use proper compiler flags. When compiling with
    g++, use the `--std` flag and specify the standard version. The recommended value
    is **`--std=c++2a`**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功编译包含C++11、C++14、C++17或C++20中指定的新特性的C++代码，应使用适当的编译器标志。在使用g++编译时，使用`--std`标志并指定标准版本。推荐的值是**`--std=c++2a`**。
- en: 'The example compiles successfully, but look at what happens when we try the
    same trick with the `main()` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例成功编译，但是当我们尝试在`main()`函数中使用相同的技巧时会发生什么：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The compiler will produce the following errors:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将产生以下错误：
- en: '`cannot initialize return object of type ''auto'' with an rvalue of type ''int''`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法使用类型为'auto'的返回对象初始化rvalue类型为'int'的对象
- en: '`''main'' must return ''int''`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''main'' must return ''int''`。'
- en: Something strange is going on with the `main()` function. This is because the
    `main()` function allows omitting the `return` statement, but for the compiler,
    the `return` statement must exist to support automatic `return` type deduction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数出现了一些奇怪的情况。这是因为`main()`函数允许省略`return`语句，但对于编译器来说，`return`语句必须存在以支持自动`return`类型推断。'
- en: 'It''s important to remember that if there are multiple `return` statements,
    they must all deduce to the same type. Let''s suppose we need an updated version
    of the function, which returns an integer value (as shown in the previous example),
    and if specified, returns a more precise `float` value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，如果有多个`return`语句，它们必须都推断为相同的类型。假设我们需要函数的更新版本，它返回一个整数值（如前面的示例所示），如果指定，还返回一个更精确的`float`值：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code won't compile successfully because there are two `return`
    statements with different deduced types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有两个具有不同推断类型的`return`语句，上述代码将无法成功编译。
- en: constexpr
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: constexpr
- en: 'The `constexpr` specifier declares that the value of the function is possible
    to evaluate at compile time. The same definition applies to variables as well.
    The name itself consists of `const` and `expression`. This is a useful feature
    because it allows optimizing your code to the fullest. Let''s take a look at the
    following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`说明符声明函数的值可以在编译时计算。同样的定义也适用于变量。名称本身由`const`和`expression`组成。这是一个有用的特性，因为它允许您充分优化代码。让我们看下面的例子：'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s see how the compiler modifies the `main()` function in the preceding
    example. Supposing the compiler won''t optimize the `double_it()` function on
    its own (for example, making it an *inline* function), the `main()` function will
    take the following form:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器如何修改前面示例中的`main()`函数。假设编译器不会自行优化`double_it()`函数（例如，使其成为*内联*函数），`main()`函数将采用以下形式：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`constexpr` is not a guarantee that the function value will be computed at
    compile time; however, the compiler is able to do so if the input of the `constexpr`
    function is known at compile time. That''s why the preceding example transformed
    directly to a computed value of `126` for the  `tripled` variable and had no effect on
    the `another_tripled`  variable as the input is not known to the compiler (and
    nor us).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`并不保证函数值将在编译时计算；然而，如果`constexpr`函数的输入在编译时是已知的，编译器就能够这样做。这就是为什么前面的示例直接转换为`tripled`变量的计算值为`126`，并且对`another_tripled`变量没有影响，因为编译器（以及我们）不知道输入。'
- en: '**C++20** introduces the `consteval` specifier, allowing you to insist on the
    compile-time evaluation of the function result. In other words, a `consteval`
    function produces a constant expression at compile time. The specifier makes the
    function an *immediate* one, which will produce an error if the function call
    cannot lead to a constant expression. The `main()` function cannot be declared
    as `constexpr`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++20**引入了`consteval`说明符，允许您坚持对函数结果进行编译时评估。换句话说，`consteval`函数在编译时产生一个常量表达式。该说明符使函数成为*立即*函数，如果函数调用无法导致常量表达式，则会产生错误。`main()`函数不能声明为`constexpr`。'
- en: C++20 also introduces the `constinit` specifier. We use `constinit` to declare
    a variable with static or thread storage duration. We will discuss thread storage
    duration in [Chapter 8](fc8fb840-e179-4725-9e44-403b63be460d.xhtml), *Concurrency
    and Multithreading*. The most notable difference with `constinit` is that we can
    use it with objects that have no `constexpr` destructor. This is because `constexpr`
    requires the object to have static initialization and constant destruction. Furthermore,
    `constexpr` makes the object const-qualified while `constinit` does not. However,
    `constinit` requires the object to have static initialization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: C++20还引入了`constinit`说明符。我们使用`constinit`来声明具有静态或线程存储期的变量。我们将在[第8章](fc8fb840-e179-4725-9e44-403b63be460d.xhtml)中讨论线程存储期，即*并发和多线程*。与`constinit`最显著的区别是，我们可以将其用于没有`constexpr`析构函数的对象。这是因为`constexpr`要求对象具有静态初始化和常量销毁。此外，`constexpr`使对象成为const限定，而`constinit`则不会。但是，`constinit`要求对象具有静态初始化。
- en: Recursion
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'Another special property of `main()` is that it cannot be called recursively.
    From the perspective of the OS, the `main()` function is the entry point of the
    program, so calling it again would mean starting everything over; therefore, it
    is prohibited. However, calling a function recursive just because it calls itself
    is partially correct. For example, the `print_number()` function calls itself
    and never stops:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`的另一个特殊属性是它不能被递归调用。从操作系统的角度来看，`main()`函数是程序的入口点，因此再次调用它意味着重新开始一切；因此，这是被禁止的。然而，仅仅因为一个函数调用自身就递归调用是部分正确的。例如，`print_number()`函数调用自身并且永远不会停止：'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Calling the `print_number(1)` function will output numbers `1`, `2`, `3`, and
    so on. This is more like a function that calls itself infinitely rather than a
    correct recursive function. We should add a couple more properties to make the `print_number()`
    function a useful recursive one. First of all, the recursive function must have
    a base case, a scenario when further function calls stop, which means the recursion
    stops propagating. We can make such a scenario for the `print_number()` function
    if, for example, we want to print numbers up to 100:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`print_number(1)`函数将输出数字`1`、`2`、`3`等。这更像是一个无限调用自身的函数，而不是一个正确的递归函数。我们应该添加一些属性，使`print_number()`函数成为一个有用的递归函数。首先，递归函数必须有一个基本情况，即进一步的函数调用停止的情况，这意味着递归停止传播。例如，如果我们想打印数字直到100，我们可以为`print_number()`函数创建这样的情况：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is one more property for a function to be recursive: solving smaller
    problems that will eventually lead to the base case. In the preceding example,
    we already had it by solving a smaller problem for the function, that is, by printing
    one number. After printing one number, we move to the next small problem: printing
    the next number. Finally, we get to the base case and we are done. There isn''t
    any magic in a function calling itself; think of it as a function calling a different
    function with the same implementation. What''s really interesting is how a recursive
    function affects the program execution overall. Let''s take a look at a simple
    example of calling a function from an other function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数递归的另一个属性是解决最终导致基本情况的较小问题。在前面的示例中，我们通过解决函数的一个较小问题来实现这一点，即打印一个数字。打印一个数字后，我们转移到下一个小问题：打印下一个数字。最后，我们到达基本情况，完成了。函数调用自身并没有什么神奇之处；可以将其视为调用具有相同实现的不同函数。真正有趣的是递归函数如何影响整体程序执行。让我们看一个从另一个函数调用函数的简单示例：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When a function is called, memory space is allocated for its arguments and
    local variables. The program starts with the `main()` function, which in this
    example simply calls the `calculate()` function by passing literal values `11`
    and `22`. The control *jumps* to the `calculate()` function and the `main()` function
    is kind of *on hold*; it waits until the `calculate()` function returns to continue
    its execution. The `calculate()` function has two arguments, `a` and `b`; although
    we named parameters of the `sum()`, `max()`, and `calculate()` differently, we
    could use the same names in all the functions. Memory space is allocated for these
    two arguments. Let''s suppose that an int takes 4 bytes of memory, therefore a
    minimum of 8 bytes are required for the `calculate()` function to be executed
    successfully. After allocating 8 bytes, the values `11` and `22` should be copied
    to the corresponding locations (see the following diagram for details):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，会为其参数和局部变量分配内存空间。程序从`main()`函数开始，在这个例子中，它只是通过传递字面值`11`和`22`来调用`calculate()`函数。控制*跳转*到`calculate()`函数，而`main()`函数有点*保持*状态；它等待`calculate()`函数返回以继续执行。`calculate()`函数有两个参数，`a`和`b`；尽管我们在`sum()`、`max()`和`calculate()`的参数中使用了不同的名称，但我们可以在所有函数中使用相同的名称。为这两个参数分配了内存空间。假设一个int类型占用4个字节的内存，因此`calculate()`函数成功执行需要至少8个字节。分配了8个字节之后，值`11`和`22`应该被复制到相应的位置（详细信息请参见以下图表）：
- en: '![](img/094082a9-5d6c-4a64-8dcf-6480fc9f38e9.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/094082a9-5d6c-4a64-8dcf-6480fc9f38e9.png)'
- en: 'The `calculate()` function calls the functions `sum()` and `max()` and passes
    its argument values to them. Correspondingly, it waits for both functions to be
    executed sequentially in order to form the value to return to the `main()`. The
    `sum()` and `max()` functions are not called simultaneously. First, `sum()` is
    called, which leads to a copy of the values of variables `a` and `b` to the locations
    allocated for the arguments of `sum()`, named `n` and `m`, which again take eight
    bytes in total. Take a look at the following diagram to understand this better:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate()`函数调用了`sum()`和`max()`函数，并将其参数值传递给它们。相应地，它等待这两个函数按顺序执行，以形成要返回给`main()`的值。`sum()`和`max()`函数不是同时调用的。首先调用`sum()`，这导致变量`a`和`b`的值被复制到为`sum()`分配的参数的位置，命名为`n`和`m`，总共再次占用了8个字节。请看下面的图表以更好地理解这一点：'
- en: '![](img/04c7e009-48fb-448d-b6aa-1909c9f31f6d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04c7e009-48fb-448d-b6aa-1909c9f31f6d.png)'
- en: Their sum is calculated and returned. After the function is done and it returns
    a value, the memory space is  freed. This means that variables `n` and `m` are
    not accessible anymore and their locations can be reused.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的和被计算并返回。函数完成并返回一个值后，内存空间被释放。这意味着变量`n`和`m`不再可访问，它们的位置可以被重用。
- en: We don't consider temporary variables at this point. We will revisit this example
    later to show the hidden details of function execution, including temporary variables
    and how to avoid them as much as possible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们不考虑临时变量。我们将在以后重新访问这个例子，以展示函数执行的隐藏细节，包括临时变量以及如何尽量避免它们。
- en: 'After `sum()` has returned a value, the `max()` function is called. It follows
    the same logic: memory is allocated to the arguments `x` and `y`, and to the `res` variable.
    We intentionally store the result of the ternary operator `(?:)` in the `res`
    variable to make the `max()` function allocate more space for this example. So,
    12 bytes are allocated to the `max()` function in total. At this point, the x `main()` function is
    still on hold and waits for `calculate()`, which in turn, is on hold and waits
    for the `max()`  function to complete (see the following diagram for details):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sum()`返回一个值之后，调用了`max()`函数。它遵循相同的逻辑：内存被分配给参数`x`和`y`，以及`res`变量。我们故意将三元运算符`(?:)`的结果存储在`res`变量中，以便使`max()`函数为这个例子分配更多的空间。因此，`max()`函数总共分配了12个字节。在这一点上，`main()`函数仍然保持等待状态，等待`calculate()`，而`calculate()`又在等待`max()`函数完成（详细信息请参见以下图表）：
- en: '![](img/1a6cd36b-9a99-4e1f-9f25-38221c7045e6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a6cd36b-9a99-4e1f-9f25-38221c7045e6.png)'
- en: When `max()` is done, the memory allocated to it is freed and its return value
    is used by  `calculate()` to form a value to return. Similarly, when  `calculate()`
    returns, the memory is freed and the `main()` function's local variable result
    will contain the value returned by `calculate()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当`max()`完成时，为其分配的内存被释放，并且其返回值被`calculate()`使用以形成一个要返回的值。同样，当`calculate()`返回时，内存被释放，`main()`函数的局部变量result将包含`calculate()`返回的值。
- en: The `main()` function then finishes its work and the program exits, that is,
    the OS frees the memory allocated for the program and can reuse it later for other
    programs. The described process of allocating and freeing memory (deallocating
    it) for functions is done using a concept called a stack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`main()`函数完成其工作，程序退出，也就是说，操作系统释放了为程序分配的内存，并可以在以后为其他程序重用。为函数分配和释放内存（解除分配）的描述过程是使用一个叫做栈的概念来完成的。
- en: A stack is a data structure *adapter*, which has its rules to insert and access
    the data inside of it. In the context of function calls, the stack usually means
    a memory segment provided to the program that automatically manages itself following
    the rules of the stack data structure adapter. We will discuss this in more detail
    later in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种数据结构*适配器*，它有自己的规则来插入和访问其中的数据。在函数调用的上下文中，栈通常意味着为程序提供的内存段，它会自动遵循栈数据结构适配器的规则进行自我管理。我们将在本章后面更详细地讨论这一点。
- en: 'Going back to recursion, when the function calls itself, memory should be allocated
    to the newly called function''s arguments and local variables (if any). The function
    calls itself again, which means the stack will continue to grow (to provide space
    for the new functions). It doesn''t matter that we call the same function; from
    the stack perspective, each new call is a call to a completely different function,
    so it allocates space for it with a serious look on its face while whistling its
    favorite song. Take the look at the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到递归，当函数调用自身时，必须为新调用的函数参数和局部变量（如果有）分配内存。函数再次调用自身，这意味着堆栈将继续增长（为新函数提供空间）。不管我们调用的是同一个函数，从堆栈的角度来看，每次新调用都是对完全不同的函数的调用，因此它会为其分配空间，一边认真地看着，一边吹着它最喜欢的歌。看一下下面的图表：
- en: '![](img/bf484616-ddb5-4701-b9f2-f35a455c23b0.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf484616-ddb5-4701-b9f2-f35a455c23b0.png)'
- en: The first call of the recursive function is on hold and waits for the second
    call of the same function, which in turn is on hold and waits for the third call
    to finish and return a value, which is in turn on hold, and so on. If there is
    a bug in the function or the recursion base is difficult to reach, the stack will
    sooner or later overgrow, which will lead to a program crash with the reason known
    as **stack overflow**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的第一个调用被挂起，并等待同一函数的第二次调用，而第二次调用又被挂起，并等待第三次调用完成并返回一个值，依此类推。如果函数中存在错误，或者递归基本条件难以达到，堆栈迟早会溢出，导致程序崩溃，原因是**堆栈溢出**。
- en: Though recursion provides more elegant solutions to a problem, try to avoid
    recursion in your programs and use the iterative approach (loops). In mission-critical
    system development guidelines such as the navigation system of a Mars rover, using
    recursion is completely prohibited.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管递归为问题提供了更优雅的解决方案，但在程序中尽量避免递归，而使用迭代方法（循环）。在诸如火星探测车导航系统之类的关键任务系统开发指南中，完全禁止使用递归。
- en: In [chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml), *Building C++ Applications*,
    we mentioned coroutines. Although we will discuss them in detail later in the
    book, you should note that the main function cannot be a coroutine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml)中，*构建C++应用程序*，我们提到了协程。尽管我们将在本书的后面详细讨论它们，但您应该注意，主函数不能是协程。
- en: Working with data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: 'When we refer to computer memory, we consider the **Random Access Memory** (**RAM**)
    by default, and also the RAM is a general term for either SRAM or DRAM; we will
    mean DRAM by default unless otherwise stated. To clear things out, let''s take
    a look at the following diagram, which illustrates the memory hierarchy:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到计算机内存时，默认情况下我们考虑**随机存取存储器**（**RAM**），RAM也是SRAM或DRAM的通用术语；除非另有说明，我们默认指的是DRAM。为了澄清事情，让我们看一下下面的图表，它说明了内存层次结构：
- en: '![](img/547620d9-ff05-460c-b5ea-b029ffc5fb94.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/547620d9-ff05-460c-b5ea-b029ffc5fb94.png)'
- en: When we compile a program, the compiler stores the final executable file in
    the hard drive. To run the executable file, its instructions are loaded into the
    RAM and are then executed by the CPU one by one. This leads us to the conclusion
    that any instruction required to be executed should be in the RAM. This is partially
    true. The environment that is responsible for running and monitoring programs
    plays the main role.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译程序时，编译器将最终的可执行文件存储在硬盘中。要运行可执行文件，其指令将被加载到RAM中，然后由CPU逐个执行。这导致我们得出结论，任何需要执行的指令都应该在RAM中。这在某种程度上是正确的。负责运行和监视程序的环境扮演着主要角色。
- en: Programs we write are executed in the hosted environment, which is in the OS.
    The OS loads the contents of the program (its instructions and data, that is,
    the process) not directly into the RAM, but the**virtual memory**, a mechanism
    that makes it possible both to handle processes conveniently and to share resources
    between processes. Whenever we refer to the memory that a process is loaded to,
    we mean the virtual memory, which in turn *maps* its contents to the RAM.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的程序在托管环境中执行，即在操作系统中。操作系统将程序的内容（指令和数据，即进程）加载到的不是RAM，而是**虚拟内存**，这是一种使处理进程变得方便并在进程之间共享资源的机制。每当我们提到进程加载到的内存时，我们指的是虚拟内存，它又*映射*其内容到RAM。
- en: Most of the time, we use the terms RAM, DRAM, virtual memory, and memory interchangeably,
    considering virtual memory as an abstraction around the physical memory (the DRAM).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将RAM、DRAM、虚拟内存和内存这些术语互换使用，将虚拟内存视为物理内存（DRAM）周围的抽象。
- en: Let's begin with an introduction to the memory structure and then investigate
    data types within the memory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍内存结构开始，然后研究内存中的数据类型。
- en: Virtual memory
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: The memory consists of lots of boxes, each of which is able to store a specified
    amount of data. We will refer to these boxes as *memory cells*, considering that
    each cell can store 1 byte representing 8 bits. Each memory cell is unique even
    if they store the same value. The uniqueness is achieved by addressing the cells
    so that each cell has its unique address in the memory. The first cell has the
    address **0**, the second cell **1**, and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 内存由许多盒子组成，每个盒子都能够存储一定数量的数据。我们将这些盒子称为*内存单元*，考虑到每个单元可以存储1字节，表示8位。即使它们存储相同的值，每个内存单元也是独一无二的。通过为每个单元分配唯一的地址来实现独特性。第一个单元的地址为**0**，第二个单元为**1**，依此类推。
- en: 'The following diagram illustrates an excerpt of the memory, each cell with
    its unique address and ability to store 1 byte of data:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了内存的一部分，每个单元都有唯一的地址，能够存储1字节的数据：
- en: '![](img/17fe7523-4981-49a8-902e-a920b256354e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17fe7523-4981-49a8-902e-a920b256354e.png)'
- en: The preceding diagram can be used to abstractly represent both physical and
    virtual memories. The point of having an additional layer of abstraction is the
    ease of managing processes and providing more functionality than with physical
    memory. For example, OSes can execute programs greater than physical memory. Take
    a computer game as an example of a program taking almost 2 GB of space and a computer
    with a physical memory of 512 MB. Virtual memory allows the OS to load the program
    portion by portion by unloading old parts from the physical memory and mapping
    new parts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表可以用来抽象地表示物理和虚拟内存。增加一个抽象层的目的是更容易管理进程，并提供比物理内存更多的功能。例如，操作系统可以执行大于物理内存的程序。以一个占用近2GB空间的计算机游戏为例，而计算机的物理内存只有512MB。虚拟内存允许操作系统逐部分加载程序，通过从物理内存中卸载旧部分并映射新部分来实现。
- en: 'Virtual memory also better supports having more than one program in memory,
    thus supporting parallel (or pseudo-parallel) execution of multiple programs.
    This also provides efficient use of shared code and data, such as dynamic libraries.
    Whenever two different programs require the same library to work with, the single
    instance of the library could exist in memory and be used by both programs without
    them knowing about each other. Take a look at the following diagram, which depicts
    three programs loaded into memory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存还更好地支持在内存中有多个程序运行，从而支持并行（或伪并行）执行多个程序。这也提供了对共享代码和数据的有效使用，比如动态库。当两个不同的程序需要同一个库来工作时，库的单个实例可以存在于内存中，并且被两个程序使用，而它们互相不知道。看一下下面的图表，它描述了加载到内存中的三个程序。
- en: '![](img/f09b9ec9-be4f-4cf1-a8ab-8ad6a6af1ae5.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f09b9ec9-be4f-4cf1-a8ab-8ad6a6af1ae5.png)'
- en: There are three running programs in the preceding diagram; each of the programs
    takes up some space in virtual memory. **My Program** is fully contained in the
    physical memory while the **Calculator** and **Text Editor** are partially mapped
    to it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中有三个运行中的程序；每个程序在虚拟内存中占据一些空间。**我的程序**完全包含在物理内存中，而**计算器**和**文本编辑器**部分映射到其中。
- en: Addressing
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址分配
- en: As mentioned earlier, each memory cell has its unique **address**, which is
    the guarantee of the uniqueness of each cell. An address is usually represented
    in a *hexadecimal* form because it's shorter and it's faster to convert to **binary**
    rather than decimal numbers. A program that is loaded into virtual memory operates
    and sees *logical* addresses. These addresses, also called virtual addresses,
    are *fake* and provided by the OS, which *translates* them to physical addresses
    when needed. To optimize the translation, the CPU provides **Translation Lookaside
    Buffer**, a part of its **Memory Management Unit** (**MMU**). Translation Lookaside
    Buffer caches recent translations of virtual addresses to physical addresses.
    So the efficient address translation is a software/hardware task. We will dive
    into the address structure and translation details in [Chapter 5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml),
    *Memory Management and Smart Pointers*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个存储单元都有其独特的地址，这是确保每个单元唯一性的保证。地址通常以十六进制形式表示，因为它更短，转换为二进制比十进制更快。加载到虚拟内存中的程序操作并看到逻辑地址。这些地址，也称为虚拟地址，是由操作系统提供的，需要时将其转换为物理地址。为了优化转换，CPU提供了**转换查找缓冲区**，它是其**内存管理单元**（**MMU**）的一部分。转换查找缓冲区缓存了虚拟地址到物理地址的最近转换。因此，高效的地址转换是一个软件/硬件任务。我们将在[第5章](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml)中深入探讨地址结构和转换细节，*内存管理和智能指针*。
- en: The length of the address defines the size of total the memory that can be operated
    by the system. When you encounter statements such as a 32 bits system or a 64
    bits system, it actually means the length of the address, that is, the address
    is 32 bits or 64 bits long. The longer the address, the bigger the memory. To
    make things clear, let's compare an 8 bits long address with a 32 bits long one.
    As agreed earlier, each memory cell is able to store 1 byte of data and has a
    unique address. If the address length is 8 bits, the address of the first memory
    cell is all zeros— **0000 0000**. The address of the next cell is greater by one,
    that is, it's **0000 0001**, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 地址长度定义了系统可以操作的总内存大小。当你遇到32位系统或64位系统这样的说法时，实际上是指地址的长度，即地址是32位或64位长。地址越长，内存越大。为了搞清楚问题，让我们比较一个8位长地址和一个32位长地址。如前所述，每个存储单元能够存储1字节的数据，并且有一个唯一的地址。如果地址长度为8位，第一个存储单元的地址全为零—**0000
    0000**。下一个存储单元的地址比前一个大一，即**0000 0001**，依此类推。
- en: 'The biggest value that can be represented by 8 bits is **1111 1111**. So, how
    many memory cells can be represented with an address length of 8 bits? This question
    is worth answering in more detail. How many different values can be represented
    by 1 bit? Two! Why so? Because 1 bit can represent either **1** or **0**. How
    many different values can be represented by 2 bits? Well, **00** is one value,
    **01** is another value, **10**, and finally, **11**. So, four different values
    in total can be represented by 2 bits. Let''s make a table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 8位可以表示的最大值是**1111 1111**。那么，用8位地址长度可以表示多少个存储单元？这个问题值得更详细地回答。1位可以表示多少不同的值？两个！为什么？因为1位可以表示**1**或**0**。2位可以表示多少不同的值？嗯，**00**是一个值，**01**是另一个值，**10**，最后是**11**。因此，2位可以表示四个不同的值。让我们做一个表格：
- en: '![](img/c23f0a1a-555a-4752-95ea-7a5494a651aa.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c23f0a1a-555a-4752-95ea-7a5494a651aa.png)'
- en: We can see a pattern here. Each position (each bit) in a number can have two
    values, so we can calculate the number of different values represented by *N*
    bits by finding *2^N*; therefore, the number of different values represented by
    8 bits is *2⁸ = 256*. This means that an 8 bits system can address up to 256 memory
    cells. On the other hand, a 32-bit system is able to address *2^(32) = 4 294 967
    296* memory cells, each storing 1 byte of data, that is, storing *4294967296 * 1
    byte = 4 GB *of data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个模式。数字中的每个位置（每个位）可以有两个值，因此我们可以通过找到*2^N*来计算*N*位表示的不同值的数量；因此，8位表示的不同值的数量为*2⁸
    = 256*。这意味着8位系统最多可以寻址256个存储单元。另一方面，32位系统能够寻址*2^(32) = 4 294 967 296*个存储单元，每个存储1字节的数据，也就是说，存储*4294967296
    * 1字节 = 4 GB*的数据。
- en: Data types
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'What''s the point of having data types at all? Why can''t we program in C++
    using some `var` keyword to declare variables and forget about variables such
    as `short`, `long`, `int`, `char`, `wchar`, and so on? Well, C++ does support
    a similar construct, the `auto` keyword that we have already used previously in
    this chapter, a so-called *placeholder type specifier*. It''s named a placeholder
    because it is, indeed, a placeholder. We cannot (and we must not ever be able
    to) declare a variable and then change its type during runtime. The following
    code might be valid JavaScript code, but it is definitely not valid C++ code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有数据类型的意义何在？为什么我们不能使用一些`var`关键字在C++中编程来声明变量，然后忘记`short`，`long`，`int`，`char`，`wchar`等变量？好吧，C++确实支持类似的构造，即我们在本章中已经使用过的`auto`关键字，所谓的*占位符类型说明符*。它被称为占位符，因为它确实是一个占位符。我们不能（也绝不能）在运行时声明变量，然后更改其类型。以下代码可能是有效的JavaScript代码，但绝对不是有效的C++代码：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Imagine the C++ compiler could compile this code. How many bytes of memory should
    be allocated for the  `a` variable? When declaring `var a = 12;`, the compiler
    could deduce its type to `int` and specify 4 bytes of memory space, but when the
    variable changes its value to `Hello, World!`, the compiler has to reallocate
    the space, or invent a new hidden variable named `a1` of type `std::string` .
    Then the compiler tries to find every access to the variable in the code that
    accesses it as a string and not as an integer or a double and replace the variable
    with the hidden `a1`. The compiler might just quit and start to ask itself the
    meaning of life.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，C++编译器可以编译此代码。应为`a`变量分配多少字节的内存？在声明`var a = 12;`时，编译器可以推断其类型为`int`并指定4字节的内存空间，但当变量将其值更改为`Hello,
    World!`时，编译器必须重新分配空间，或者发明一个名为`a1`的新隐藏变量，类型为`std::string`。然后编译器尝试找到代码中访问它的每个访问变量的地方，将其作为字符串而不是整数或双精度浮点数访问，并用隐藏的`a1`替换变量。编译器可能会退出并开始询问生命的意义。
- en: 'We can declare something similar to the preceding code in C++ as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在C++中声明类似于前面代码的内容，如下所示：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The difference between the previous two examples is that the second example
    declares three different variables of three different types. The previous non-C++
    code declared just one variable and then assigned values of different types to
    it. You can't change the type of a variable in C++, but the compiler allows you
    to use the `auto` placeholder and deduces the type of the variable by the value
    assigned to it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例之间的区别在于第二个示例声明了三个不同类型的变量。之前的非C++代码只声明了一个变量，然后为其分配了不同类型的值。在C++中，您不能更改变量的类型，但编译器允许您使用`auto`占位符，并通过分配给它的值推断变量的类型。
- en: It is crucial to understand that the type is deduced at compile time, while
    languages such as JavaScript allow you to deduce the type at runtime. The latter
    is possible because such programs are run in environments such as virtual machines,
    while the only environment that runs the C++ program is the OS. The C++ compiler
    must generate a valid executable file that could be copied into the memory and
    run without a support system. This forces the compiler to know beforehand the
    actual size of the variable. Knowing the size is important to generate the final
    machine code because accessing a variable requires its address and size, allocating
    memory space to a variable requires the number of bytes that it should take.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 至关重要的是要理解类型是在编译时推断的，而诸如JavaScript之类的语言允许您在运行时推断类型。后者是可能的，因为这些程序在诸如虚拟机之类的环境中运行，而运行C++程序的唯一环境是操作系统。C++编译器必须生成一个有效的可执行文件，可以将其复制到内存中并在没有支持系统的情况下运行。这迫使编译器事先知道变量的实际大小。知道大小对于生成最终的机器代码很重要，因为访问变量需要其地址和大小，为变量分配内存空间需要它应该占用的字节数。
- en: 'The C++ type system classifies types into two major categories:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++类型系统将类型分类为两个主要类别：
- en: '**Fundamental types** (`int`, `double`, `char`, `void`)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本类型**（`int`，`double`，`char`，`void`）'
- en: '**Compound types** (pointers, arrays, classes)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合类型**（指针，数组，类）'
- en: 'The language even supports special type traits, `std::is_fundamental` and `std::is_compound`,
    to find out the category of a type, for example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言甚至支持特殊的类型特征，`std::is_fundamental`和`std::is_compound`，以找出类型的类别，例如：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We used `std::is_fundamental_v` and `std::is_compound_v` helper variable templates,
    defined as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`std::is_fundamental_v`和`std::is_compound_v`辅助变量模板，定义如下：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The program outputs: `0 1 1 0`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序输出：`0 1 1 0`。
- en: You can use the `std::boolalpha` I/O manipulator before printing the type categories
    to print `true` or `false` instead of `1` or `0`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在打印类型类别之前使用`std::boolalpha` I/O操纵器，以打印`true`或`false`，而不是`1`或`0`。
- en: 'Most of the fundamental types are arithmetic types such as `int` or `double`;
    even the `char` type is arithmetic. It actually holds a number rather than a character,
    for example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基本类型都是算术类型，例如`int`或`double`；甚至`char`类型也是算术类型。它实际上保存的是一个数字，而不是一个字符，例如：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A `char` variable holds 1 byte of data, which means it can represent 256 different
    values (because 1 byte is 8 bits, and 8 bits can be used in *2⁸* ways to represent
    a number). What if we use one of the bits as a *sign* bit, for example, allowing
    the type to support negative values as well? That leaves us with 7 bits for representing
    the actual value, and following the same logic, it allows us to represent 27 different
    values, that is, 128 (including 0) different values of positive numbers and the
    same amount of negative values. Excluding 0 gives us the range -127 to +127 for
    the signed `char`. This signed versus unsigned representation applies to almost
    all integral types.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`变量保存1个字节的数据，这意味着它可以表示256个不同的值（因为1个字节是8位，8位可以以*2⁸*种方式表示一个数字）。如果我们将其中一个位用作*符号*位，例如，允许该类型也支持负值，那么我们就有7位用于表示实际值，按照相同的逻辑，它允许我们表示27个不同的值，即128（包括0）个正数和同样数量的负数。排除0后，我们得到了有符号`char`的范围为-127到+127。这种有符号与无符号的表示法适用于几乎所有整数类型。'
- en: So whenever you encounter that, for example, the size of an int is 4 bytes,
    which is 32 bits, you should already know that it is possible to represent the
    numbers 0 to 2^(32) in an unsigned representation, and the values -2^(31) to +2^(31)
    in a signed representation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每当你遇到，例如，int的大小是4个字节，即32位时，你应该已经知道可以用无符号表示法表示0到2^(32)之间的数字，以及用有符号表示法表示-2^(31)到+2^(31)之间的值。
- en: Pointers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: 'C++ is a unique language in the way that it provides access to low-level details
    such as addresses of variables. We can take the address of any variable declared
    in the program using the `&` operator as shown:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种独特的语言，因为它提供了访问低级细节的方式，比如变量的地址。我们可以使用`&`运算符来获取程序中声明的任何变量的地址，如下所示：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code will output something similar to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出类似于这样的内容：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the hexadecimal representation of the address. Although this value is
    just an integer, it is used to store in a special variable called a pointer. A
    pointer is just a variable that is able to store address values and supports the
    `*` operator (dereferencing), allowing us to find the actual value stored at the
    address.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意地址的十六进制表示。尽管这个值只是一个整数，但它用于存储在一个称为指针的特殊变量中。指针只是一个能够存储地址值并支持`*`运算符（解引用）的变量，使我们能够找到存储在地址中的实际值。
- en: 'For example, to store the address of the variable answer in the preceding example,
    we can declare a pointer and assign the address to it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的例子中存储变量answer的地址，我们可以声明一个指针并将地址分配给它：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The variable answer is declared as an `int`, which usually takes 4 bytes of
    memory space. We already agreed that each byte has its own unique address. Can
    we conclude that the answer variable has four unique addresses? Well, yes and
    no. It does acquire four distinct but contiguous memory bytes, but when the address
    operator is used against the variable, it returns the address of its first byte.
    Let''s take a look at a portion of code that declares a couple of variables and
    then illustrate how they are placed in the memory:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 变量answer声明为`int`，通常占用4个字节的内存空间。我们已经同意每个字节都有自己独特的地址。我们可以得出结论，answer变量有四个唯一的地址吗？是的和不。它确实获得了四个不同但连续的内存字节，但当使用地址运算符针对该变量时，它返回其第一个字节的地址。让我们看一下一段代码的一部分，它声明了一对变量，然后说明它们如何放置在内存中：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The size of a data type is implementation-defined, though the C++ standard
    states the minimum supported range of values for each type. Let''s suppose the
    implementation provides 4 bytes for an `int`, 8 bytes for a double, and 1 byte
    for `char`. The memory layout for the preceding code should look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的大小是实现定义的，尽管C++标准规定了每种类型的最小支持值范围。假设实现为`int`提供了4个字节，为double提供了8个字节，为`char`提供了1个字节。前面代码的内存布局应该如下所示：
- en: '![](img/f7b01d3f-b5b7-43ec-be24-1612dd507b39.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7b01d3f-b5b7-43ec-be24-1612dd507b39.png)'
- en: Pay attention to  `ivar` in the memory layout; it resides in four contiguous
    bytes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意内存布局中的`ivar`；它位于四个连续的字节中。
- en: 'Whenever we take the address of a variable, whether it resides in a single
    byte or more than one byte, we get the address of the first byte of the variable.
    If the size doesn''t affect the logic behind the address operator, then why do
    we have to declare the type of the pointer? In order to store the address of `ivar`
    in the preceding example, we should declare the pointer as an `int*`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 无论变量存储在单个字节还是多个字节中，每当我们获取变量的地址时，我们都会得到该变量第一个字节的地址。如果大小不影响地址运算符背后的逻辑，那么为什么我们必须声明指针的类型呢？为了存储前面例子中`ivar`的地址，我们应该将指针声明为`int*`：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code is depicted in the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在下图中描述：
- en: '![](img/957b67f2-4da3-4fa0-8a68-cd0cdd02ec7d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/957b67f2-4da3-4fa0-8a68-cd0cdd02ec7d.png)'
- en: 'Turns out, the type of the pointer is crucial in accessing the variable using
    that very pointer. C++ provides the dereferencing operator (the `*` symbol before
    the pointer name):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，指针的类型在使用该指针访问变量时至关重要。C++提供了解引用运算符（指针名称前的`*`符号）：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It basically works like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是这样工作的：
- en: Reads the contents of the pointer
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取指针的内容
- en: Finds the address of the memory cell that is equal to the address in the pointer
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到与指针中的地址相等的内存单元的地址
- en: Returns the value that is stored in that memory cell
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回存储在该内存单元中的值
- en: The question is, what if the pointer points to the data that resides in more
    than one memory cell? That's where the type of the pointer comes in. When dereferencing
    the pointer, its type is used to determine how many bytes it should read and return
    starting from the memory cell that it points to.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，如果指针指向的数据存储在多个内存单元中怎么办？这就是指针类型的作用。当解引用指针时，它的类型用于确定应从指向的内存单元开始读取和返回多少字节。
- en: Now that we know that a pointer stores the address of the first byte of the
    variable, we can actually read any byte of the variable by moving the pointer
    forward. We should remember that the address is just a number, so adding or subtracting
    another number from it will produce another address. What if we point to an integer
    variable with a `char` pointer?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道指针存储变量的第一个字节的地址，我们实际上可以通过移动指针来读取变量的任何字节。我们应该记住地址只是一个数字，因此从中添加或减去另一个数字将产生另一个地址。如果我们用`char`指针指向整数变量会怎么样？
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we try to dereference the `p` pointer, it will return only the first byte
    of `ivar`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对`p`指针进行解引用时，它将仅返回`ivar`的第一个字节。
- en: 'Now, if we want to move to the next byte of `ivar`, we add `1` to the `char`
    pointer:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想移动到`ivar`的下一个字节，我们将`1`添加到`char`指针：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Take a look at the following diagram; it clearly shows how we access bytes
    of the `ivar` integer:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表；它清楚地显示了我们如何访问`ivar`整数的字节：
- en: '![](img/b595b562-70fe-45cf-990d-c1b6b939ff9d.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b595b562-70fe-45cf-990d-c1b6b939ff9d.png)'
- en: 'If you want to read the first or the last two bytes, you can use a short pointer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想读取第一个或最后两个字节，可以使用短指针：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should be careful with pointer arithmetics, as adding or subtracting a number
    will actually move the pointer by the defined size of the data type. Adding 1
    to an `int` pointer will add `sizeof(int) * 1` to the actual address.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该小心指针算术，因为添加或减去一个数字实际上会将指针移动到数据类型的定义大小。将1添加到`int`指针将使实际地址增加`sizeof(int) *
    1`。
- en: What about the size of a pointer? As mentioned previously, a pointer is just
    a variable that is special in the way that it can store a memory address and provide
    a dereferencing operator that returns the data located at that address. So if
    the pointer is just a variable, it should reside in memory as well. We might consider
    that the size of a `char` pointer is less than the size of an `int` pointer just
    because the size of a `char` is less than the size of an `int`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的大小如何？如前所述，指针只是一个变量，它可以存储内存地址并提供一个解引用运算符，该运算符返回该地址处的数据。因此，如果指针只是一个变量，它也应该驻留在内存中。我们可能认为`char`指针的大小小于`int`指针的大小，只是因为`char`的大小小于`int`的大小。
- en: 'Here''s the catch: the data that is stored in the pointer has nothing to do
    with the type of data the pointer points to. Both `char` and `int` pointers store
    the address of the variable, so to define the size of the pointer, we should consider
    the size of the address. The size of the address is defined by the system we work
    in. For example, in a 32-bit system, the address size is 32 bits long, and in
    a 64-bit system, the address size is 64 bits long. This leads us to a logical
    conclusion: the size of the pointer is the same regardless of the type of data
    it points to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于：存储在指针中的数据与指针指向的数据类型无关。`char`和`int`指针都存储变量的地址，因此要定义指针的大小，我们应该考虑地址的大小。地址的大小由我们所在的系统定义。例如，在32位系统中，地址大小为32位长，在64位系统中，地址大小为64位长。这导致我们得出一个逻辑结论：指针的大小是相同的，无论它指向的数据类型是什么：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It will output `4 = 4 = 4` in a 32-bit system, and `8 = 8 = 8` in a 64-bit system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位系统中，它将输出`4 = 4 = 4`，在64位系统中，它将输出`8 = 8 = 8`。
- en: Memory segments
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存段
- en: The memory consists of segments and the program segments are distributed through
    these memory segments during the loading. These are artificially divided ranges
    of memory addresses that make it easier to manage the program by the OS. A binary
    file is also divided into segments, such as code and data. We previously mentioned
    code and data as sections. Sections are the division of a binary file needed for
    the linker, which uses the sections that are meant for the proper work of the
    linker and combines the sections that are meant for the loader into segments.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 内存由段组成，程序段在加载期间通过这些内存段分布。这些是人为划分的内存地址范围，使操作系统更容易管理程序。二进制文件也被划分为段，例如代码和数据。我们之前提到代码和数据作为部分。部分是链接器所需的二进制文件的划分，链接器使用为加载器准备的部分，并将为加载器准备的部分组合成段。
- en: 'Basically, when we discuss a binary file from the runtime perspective, we mean
    segments. The data segment contains all the data required and used by the program,
    and the code segment contains the actual instructions that process the very same
    data. However, when we mention data, we don''t mean every single piece of data
    used in the program. Let''s take a look at this example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当我们从运行时的角度讨论二进制文件时，我们指的是段。数据段包含程序所需和使用的所有数据，代码段包含处理相同数据的实际指令。但是，当我们提到数据时，我们并不是指程序中使用的每一小段数据。让我们看一个例子：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code segment of the preceding program consists of the instructions of the
    `main()` and `max()` functions, where `main()` prints the message using the `operator<<`
    of the `cout` object and then calls the `max()` function. What data actually resides
    in the data segment? Does it contain `a` and `b` arguments of the `max()` function? As
    it turns out, the only data that is contained in the data segment is the string
    `The maximum of 11 and 22 is:`, along with other static, global, or constant data.
    We didn't declare any global or static variables, so the only data is the mentioned
    message.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的代码段由`main()`和`max()`函数的指令组成，其中`main()`使用`cout`对象的`operator<<`打印消息，然后调用`max()`函数。数据段实际上包含什么数据？它包含`max()`函数的`a`和`b`参数吗？事实证明，数据段中包含的唯一数据是字符串`The
    maximum of 11 and 22 is:`，以及其他静态、全局或常量数据。我们没有声明任何全局或静态变量，所以唯一的数据就是提到的消息。
- en: The interesting thing comes with values the `11` and `22`. These are literal
    values, which means they have no address; therefore they are not located anywhere
    in the memory. If they are not located anywhere, the only logical explanation
    of how they are located within the program is that they reside in the code segment.
    They are a part of the `max()` call instruction.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是`11`和`22`的值。这些是字面值，这意味着它们没有地址；因此它们不位于内存中的任何位置。如果它们没有位于任何位置，它们在程序中的唯一合乎逻辑的解释是它们驻留在代码段中。它们是`max()`调用指令的一部分。
- en: 'What about the `a` and `b` arguments of the `max()` function? And here comes
    the segment in the virtual memory that is responsible for storing variables that
    have automatic storage duration— the stack. As already mentioned previously, the
    stack automatically handles the allocation/deallocation of memory space for local
    variables and function arguments. The arguments `a` and `b` will be located in
    the stack when the `max()` function is called. In general, if an object is said
    to have automatic storage duration, the memory space will be allocated at the
    beginning of the enclosing block. So when the function is called, its arguments
    are pushed into the stack:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`函数的`a`和`b`参数怎么样？这就是负责存储具有自动存储期限的变量的虚拟内存中的段——栈。如前所述，栈自动处理局部变量和函数参数的内存空间的分配/释放。当调用`max()`函数时，参数`a`和`b`将位于栈中。通常，如果说对象具有自动存储期限，内存空间将在封闭块的开头分配。因此，当调用函数时，其参数将被推入栈中：'
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the function is done, the automatically allocated space will be freed at
    the end of the enclosing code block.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数完成时，自动分配的空间将在封闭代码块的末尾被释放。
- en: The enclosing code block represents not only the function body but also the
    block of the conditional statements and loops.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭代码块不仅代表函数体，还代表条件语句和循环的块。
- en: It's said that the arguments (or local variables) are popped out of the stack. **Push**
    and **pop** are terms used within the context of the stack. You insert data into
    the stack by *pushing* it, and you retrieve (and remove) data out of the stack
    by *popping* it. You might have encountered the **LIFO** term, which stands for
    **last in, first out**. That perfectly describes the push and pop operations of
    the stack.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 据说参数（或局部变量）从栈中弹出。**推**和**弹**是栈的上下文中使用的术语。通过*推*数据将数据插入栈中，通过*弹*数据将数据从栈中检索（并删除）。您可能遇到过**LIFO**术语，它代表**后进先出**。这完美地描述了栈的推和弹操作。
- en: When the program is run, the OS provides the fixed size of the stack. The stack
    is able to grow in size and if it grows to the extent that no more space is left,
    it crashes because of the stack overflow.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，操作系统提供了栈的固定大小。栈能够按需增长，如果增长到没有更多空间的程度，就会因为栈溢出而崩溃。
- en: The heap
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: 'We described the stack as a manager of variables with *automatic storage duration*.
    The word *automatic* suggests that programmers shouldn''t care about the actual
    memory allocation and deallocation. Automatic storage duration could be achieved
    only if the size of data or a collection of the data is known beforehand. This
    way, the compiler is aware of the number and type of function arguments and local
    variables. At this point, it seems more than fine, but programs tend to work with
    dynamic data— data of an unknown size. We will study dynamic memory management
    in detail in [Chapter 5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml), *Memory
    Management and Smart Pointers; *for now, let''s look at a simplified diagram of
    memory segments and find out what the heap is used for:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将栈描述为*自动存储期限*变量的管理器。*自动*一词表明程序员不必关心实际的内存分配和释放。只有在数据的大小或数据集合的大小事先已知的情况下，才能实现自动存储期限。这样，编译器就知道函数参数和局部变量的数量和类型。在这一点上，似乎已经足够了，但程序往往要处理动态数据——大小未知的数据。我们将在[第5章](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml)中详细研究动态内存管理，*内存管理和智能指针*；现在，让我们看一下内存段的简化图表，并找出堆的用途：
- en: '![](img/18f5425d-2362-474c-8e4c-3fd91432d3ad.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18f5425d-2362-474c-8e4c-3fd91432d3ad.png)'
- en: 'The program uses the heap segment in order to request more memory space than
    has been required before. This is done at runtime, which means the memory is being
    allocated dynamically during the program execution. The program requests the OS
    for new memory space whenever required. The OS doesn''t actually know whether
    the memory is required for an integer, or for a user-defined `Point`, or even
    for an array of user-defined `Point`. The program requests the memory by passing
    the actual size of bytes that it requires. For example, to request a space for
    an object of type `Point`, the `malloc()` function can be used as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用堆段来请求比以前需要的更多的内存空间。这是在运行时完成的，这意味着内存在程序执行期间是动态分配的。程序在需要时向操作系统请求新的内存空间。操作系统实际上并不知道内存是为整数、用户定义的`Point`还是用户定义的`Point`数组而请求的。程序通过传递实际需要的字节数来请求内存。例如，要为`Point`类型的对象请求空间，可以使用`malloc()`函数如下：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `malloc()` function came from the C language and to use it we need to include
    the `<cstdlib>` header file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()`函数来自C语言，使用它需要包含`<cstdlib>`头文件。'
- en: 'The `malloc()` function allocates a contiguous memory space of `sizeof(Point)`
    bytes— let''s say 8 bytes. It then returns the address of the first byte of that
    memory as it is the only way to provide access to space. And the thing is, `malloc()`
    doesn''t actually know whether we requested memory space for a `Point` object
    or an `int`, and it simply returns  `void*`. `void*` stores the address of the
    first byte of allocated memory, but it definitely cannot be used to fetch the
    actual data by dereferencing the pointer simply because `void` does not define
    the size of the data. Take a look at the following diagram; it shows that `malloc`
    allocates memory on the heap:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()`函数分配了`sizeof(Point)`字节的连续内存空间，比如说8字节。然后它返回该内存的第一个字节的地址，因为这是提供访问空间的唯一方式。而且，`malloc()`实际上并不知道我们是为`Point`对象还是`int`请求了内存空间，它只是简单地返回`void*`。`void*`存储了分配内存的第一个字节的地址，但它绝对不能用于通过解引用指针来获取实际数据，因为`void`没有定义数据的大小。看一下下面的图示；它显示了`malloc`在堆上分配内存：'
- en: '![](img/762fa3db-fc1e-4137-b71c-ee80cffd43f5.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/762fa3db-fc1e-4137-b71c-ee80cffd43f5.png)'
- en: 'To actually use the memory space, we need to cast the `void` pointer to the
    desired type:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用内存空间，我们需要将`void`指针转换为所需的类型：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or, simply declare and initialize the pointer with a cast result:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，只需声明并初始化指针并进行类型转换：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'C++ solves this headache by introducing the `new` operator, which automatically
    fetches the size of the memory space to be allocated and converts the result to
    the desired type:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: C++通过引入`new`运算符来解决这个头疼的问题，该运算符自动获取要分配的内存空间的大小，并将结果转换为所需的类型：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Dynamic memory management is a manual process; there is no similar construct
    to the stack that automatically deallocates the memory space if it is not required
    anymore. To manage the memory resource correctly, we should use the `delete` operator
    when we want to deallocate the space. We will find out the details in [Chapter
    5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml) *Memory Management and Smart Pointers*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存管理是一个手动过程；没有类似于堆栈的构造，可以在不再需要时自动释放内存空间。为了正确管理内存资源，我们应该在想要释放空间时使用`delete`运算符。我们将在[第5章](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml)中了解细节，*内存管理和智能指针*。
- en: 'What happens when we access the members of the `Point` object pointed to by
    `p`? Dereferencing `p` returns the full `Point` object, so to change the value
    of member `x`, we should do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问`p`指向的`Point`对象的成员时会发生什么？对`p`进行解引用会返回完整的`Point`对象，所以要更改成员`x`的值，我们应该这样做：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or, better still, access it with the arrow operator:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的方法是使用箭头运算符访问它：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will dive into the user-defined types and structs in particular in [Chapter
    3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details of Object-Oriented Programming.*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml)中特别深入讨论用户定义类型和结构体，*面向对象编程的细节。*
- en: Arrays
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is the basic data structure that provides a collection of data contiguously
    stored in memory. Many adapters, such as the stack, are implemented using arrays.
    Their uniqueness is that array elements are all of the same type, which plays
    a key role in accessing array elements. For example, the following declaration
    creates an array of 10 integers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种基本的数据结构，它提供了在内存中连续存储的数据集合。许多适配器，如堆栈，都是使用数组实现的。它们的独特之处在于数组元素都是相同类型的，这在访问数组元素中起着关键作用。例如，以下声明创建了一个包含10个整数的数组：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The name of the array decays to a pointer to its first element. Considering
    the fact that array elements have the same type, we can access any element of
    the array by advancing the pointer to its first element. For example, the following
    code prints the third element of the array:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的名称会衰减为指向其第一个元素的指针。考虑到数组元素都是相同类型，我们可以通过推进指针到其第一个元素来访问数组的任何元素。例如，以下代码打印了数组的第三个元素：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The same goes with the first element; the following three lines of code are
    doing the same thing:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素也是如此；以下三行代码都在做同样的事情：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To make sure that `arr[2]` and `*(arr + 2)` do the exact same thing, we can
    do the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`arr[2]`和`*(arr + 2)`做了完全相同的事情，我们可以这样做：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Moving the `2` behind the `+` won''t affect the result, so the following code
    is valid as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将`2`移到`+`的后面不会影响结果，所以下面的代码也是有效的：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And it prints the third element of the array.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会打印数组的第三个元素。
- en: 'An array element is accessed in constant time, which means accessing the first
    and the last elements of the array takes the same amount of time. It''s because
    every time we access an array element, we do the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素的访问时间是恒定的，这意味着访问数组的第一个和最后一个元素需要相同的时间。这是因为每次访问数组元素时，我们都会执行以下操作：
- en: Advance the pointer by adding the corresponding numeric value
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加相应的数值来推进指针
- en: Read the contents of memory cells placed at the result pointer
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取结果指针所指的内存单元的内容
- en: 'The type of the array indicates how many memory cells should be read (or written).
    The following diagram illustrates the access:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型指示应读取（或写入）多少个内存单元。以下图示了访问的过程：
- en: '![](img/cbb9a70d-2cfc-471f-ae05-4d6e28d2ffca.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbb9a70d-2cfc-471f-ae05-4d6e28d2ffca.png)'
- en: 'This idea is crucial when creating dynamic arrays, which are arrays that are
    located in the heap rather than the stack. As we already know, allocating memory
    from the heap gives the address of its first byte, so the only chance to access
    elements other than the first one, is by using pointer arithmetic:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法在创建动态数组时至关重要，动态数组位于堆而不是堆栈中。正如我们已经知道的，从堆中分配内存会给出其第一个字节的地址，所以除了第一个元素之外，访问其他元素的唯一机会就是使用指针算术：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We will discuss more about the structure of arrays and other data structures
    in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml), *Digging into Data
    Structures and Algorithms in STL.*
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)中更多地讨论数组的结构和其他数据结构，*深入数据结构和STL中的算法。*
- en: Control flow
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: The most basic concepts of almost any programming language are conditional statements
    and loops. We are going to explore them in detail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何编程语言的最基本概念都是条件语句和循环。我们将详细探讨它们。
- en: Conditionals
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'It''s hard to imagine a program that doesn''t contain a conditional statement.
    It''s almost a habit to check the input arguments of functions securing their
    safe execution. For example, the `divide()`  function takes two arguments, divides
    one by the other, and returns the result. It''s pretty clear that we need to make
    sure that the divisor is not zero:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个不包含条件语句的程序。检查函数的输入参数以确保它们的安全执行几乎成了一种习惯。例如，`divide()`函数接受两个参数，将一个除以另一个，并返回结果。很明显，我们需要确保除数不为零：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Conditionals are at the core of programming languages; after all, a program
    is a collection of actions and decisions. For example, the following code uses
    conditional statements to find the maximum value out of two input arguments:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是编程语言的核心；毕竟，程序是一系列动作和决策。例如，以下代码使用条件语句来找出两个输入参数中的最大值：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding example is oversimplified on purpose to express the usage of
    the `if`-`else` statement as is. However, what interests us the most is the implementation
    of such a conditional statement. What does the compiler generate when it encounters
    an `if` statement? The CPU executes instructions sequentially one by one, and
    instructions are simple commands doing exactly one thing. We can use complex expressions
    in a single line in a high-level programming language such as C++, while the assembly
    instructions are simple commands that can do only one simple operation in one
    cycle: `move`, `add`, `subtract`, and so on.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是故意过于简化，以表达`if`-`else`语句的使用。然而，最让我们感兴趣的是这样一个条件语句的实现。当编译器遇到`if`语句时会生成什么？CPU按顺序逐个执行指令，指令是简单的命令，只能执行一个操作。在高级编程语言（如C++）中，我们可以在一行中使用复杂表达式，而汇编指令是简单的命令，每个周期只能执行一个简单操作：`move`、`add`、`subtract`等。
- en: The CPU fetches the instruction from the code memory segment, decodes it to
    find out what it should exactly do (move data, add numbers, subtract them), and
    executes the command.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: CPU从代码存储段中获取指令，对其进行解码以找出它应该做什么（移动数据，加法，减法），然后执行命令。
- en: To run at its fastest, the CPU stores the operands and the result of the execution
    in storage units called **registers**. You can think of registers as temporary
    variables of the CPU. Registers are physical memory units that are located within
    the CPU so the access is much faster compared to the RAM. To access the registers
    from an assembly language program, we use their specified names, such as `rax`,
    `rbx`, `rdx`, and so on. The CPU commands operate on registers rather than the
    RAM cells; that's why the CPU has to copy the contents of the variable from the
    memory to registers, execute operations and store the results in a register, and
    then copy the value of the register back to the memory cell.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以最快的速度运行，CPU将操作数和执行结果存储在称为**寄存器**的存储单元中。您可以将寄存器视为CPU的临时变量。寄存器是位于CPU内部的物理内存单元，因此访问速度比RAM快得多。要从汇编语言程序中访问寄存器，我们使用它们的指定名称，如`rax`、`rbx`、`rdx`等。CPU命令操作寄存器而不是RAM单元；这就是CPU必须将变量的内容从内存复制到寄存器，执行操作并将结果存储在寄存器中，然后将寄存器的值复制回内存单元的原因。
- en: 'For example, the following C++ expression takes just a single line of code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下C++表达式只需要一行代码：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It would look similar to the following assembly representation (comments are
    added after semicolons):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来类似于以下汇编表示（分号后添加了注释）：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A conditional statement suggests that a portion of the code should be skipped.
    For example, calling `max(11, 22)` means the `if` block will be omitted. To express
    this in the assembly language, the idea of jumps is used. We compare two values
    and, based on the result, we jump to a specified portion of the code. We label
    the portion to make it possible to find the set of instructions. For example,
    to skip adding `42` to the register `rbx`, we can *jump* to the portion labeled
    `UNANSWERED` using the unconditional jump instruction `jpm` as shown:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句表明应跳过代码的一部分。例如，调用`max(11, 22)`意味着`if`块将被省略。为了在汇编语言中表达这一点，使用了跳转的概念。我们比较两个值，并根据结果跳转到代码的指定部分。我们使用标签来标记部分，以便找到一组指令。例如，要跳过将`42`添加到寄存器`rbx`，我们可以使用无条件跳转指令`jpm`*跳转*到标记为`UNANSWERED`的部分，如下所示：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `jmp` instruction performs an unconditional jump; that means it starts
    the execution of the first instruction at a specified label without any condition
    check. The good news is that the CPU provides conditional jumps as well. The body
    of the `max()` function will translate into the following assembly code (simplified),
    where the `jg` and `jle` commands are interpreted as *jump if greater than* and
    *jump if less than or equal*, respectively (based on the results of the comparison
    using the `cmp` instruction):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp`指令执行无条件跳转；这意味着它开始执行指定标签下的第一条指令，而不进行任何条件检查。好消息是，CPU也提供了条件跳转。`max()`函数的主体将转换为以下汇编代码（简化），其中`jg`和`jle`命令被解释为*如果大于*和*如果小于或等于*，分别（基于使用`cmp`指令进行比较的结果）：'
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding code, the labels `GREATER` and `LESSOREQUAL` represent the
    `if` and `else` clauses of the `max()` function implemented earlier.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，标签`GREATER`和`LESSOREQUAL`代表先前实现的`max()`函数的`if`和`else`子句。
- en: The switch statement
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: 'Conditionals such as the `switch` statement use the same logic as shown:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`switch`语句之类的条件语句使用与上述相同的逻辑：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s suppose `rax` represents the age, `rbx` represents `can_drink`, and
    `rdx` represents  `can_code`. The preceding example will translate into the following
    assembly instructions (simplified to express the basic idea):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`rax`表示年龄，`rbx`表示`can_drink`，`rdx`表示`can_code`。前面的示例将转换为以下汇编指令（简化以表达基本思想）：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Each `break` statement translates into jumping to the `BEYOND_SWITCH` label,
    so if we forget the `break` keyword, for example, in the case where `age` is `18`, the
    execution will reach through  `CASE_21` as well. That's why you should not forget
    the `break` statement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`break`语句都会转换为跳转到`BEYOND_SWITCH`标签，所以如果我们忘记了`break`关键字，例如在`age`为`18`的情况下，执行将会通过`CASE_21`。这就是为什么你不应该忘记`break`语句。
- en: Let's find a way to avoid using conditionals in the source, both to make the
    code shorter and possibly faster. We will use function pointers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到一种方法来避免在源代码中使用条件语句，以使代码更短，可能更快。我们将使用函数指针。
- en: Replacing conditionals with function pointers
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用函数指针替换条件语句
- en: Previously, we looked at memory segments, and one of the most important segments
    is the code segment (also called a text segment). This segment contains the program
    image, which is the instructions of the program that should be executed. Instructions
    are usually grouped into functions, which provide a unique name allowing us to
    call them from other functions. Functions reside in the code segment of the executable
    file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看过内存段，其中最重要的一个是代码段（也称为文本段）。这个段包含程序图像，也就是应该执行的程序指令。指令通常被分组成函数，这些函数提供了一个唯一的名称，允许我们从其他函数中调用它们。函数驻留在可执行文件的代码段中。
- en: 'A function has its address. We can declare a pointer that takes the address
    of the function and then use it later to call that function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数有它的地址。我们可以声明一个指针，取函数的地址，然后稍后使用它来调用该函数：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The function pointer can be called the same way as the original function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针可以像原始函数一样被调用：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Let's suppose we are writing a program that takes two numbers and a character
    from the input and executes an arithmetic operation on the numbers. The operation
    is specified by the character, whether it's `+`, `-`, `*`, or `/`. We implement
    four functions, `add()`, `subtract()`, `multiply()`, and `divide()`, and call
    one of them based on the value of the character input.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个程序，从输入中获取两个数字和一个字符，并对数字执行算术运算。操作由字符指定，无论是`+`，`-`，`*`，还是`/`。我们实现四个函数，`add()`，`subtract()`，`multiply()`和`divide()`，并根据字符输入的值调用其中一个。
- en: 'Instead of checking the value of the character in a bunch of `if` statements
    or a `switch` statement, we will map the type of the operation to the specified
    function using a hash table:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在一堆`if`语句或`switch`语句中检查字符的值，我们将使用哈希表将操作的类型映射到指定的函数：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, `std::unordered_map` maps `char` to a function pointer defined
    as `(*)(int, int)`. That is, it can point to any function that takes two integers
    and returns an integer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`std::unordered_map`将`char`映射到一个函数指针，定义为`(*)(int, int)`。也就是说，它可以指向任何接受两个整数并返回一个整数的函数。
- en: The hash table is represented by `std::unordered_map`, defined in the `<unordered_map>`
    header. We will discuss it in detail in  [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml), *Digging
    into Data Structures and Algorithms in STL*
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表由`<unordered_map>`头文件中定义的`std::unordered_map`表示。我们将在[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)中详细讨论它，*深入STL中的数据结构和算法*
- en: 'Now we don''t need to write the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不需要写以下内容：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Instead, we simply call the function mapped by the character:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只需调用由字符映射的函数：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Though the use of a hash table is much prettier and looks more professional,
    you should take care of unexpected cases, such as invalid user input.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用哈希表更加美观，看起来更专业，但你应该注意意外情况，比如无效的用户输入。
- en: Functions as types
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为类型
- en: The second argument for `unordered_map` is `int (*)(int, int)`, which literally
    means a pointer to a function taking two integers and returning an integer. C++
    supports the class template `std::function` as a general-purpose function wrapper
    allowing us to store callable objects including ordinary functions, lambda expressions,
    functions objects, and so on. The stored object is referred to as the target of
    `std::function` and if it doesn't have a target, it will throw the `std::bad_function_call`
    exception if invoked. This helps us both to make the `operations` hash table accept
    any callable object as its second parameter and to handle exceptional cases such
    as invalid character input, mentioned earlier.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered_map`的第二个参数是`int (*)(int, int)`，它字面上意味着指向接受两个整数并返回一个整数的函数的指针。C++支持类模板`std::function`作为通用函数包装器，允许我们存储可调用对象，包括普通函数、lambda表达式、函数对象等。存储的对象被称为`std::function`的目标，如果它没有目标，那么在调用时将抛出`std::bad_function_call`异常。这不仅帮助我们使`operations`哈希表接受任何可调用对象作为它的第二个参数，还帮助我们处理异常情况，比如前面提到的无效字符输入。'
- en: 'The following code block illustrates this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块说明了这一点：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice the argument for `std::function`; it has the form `int(int, int)` rather
    than `int(*)(int, int)`. Using `std::function` helps us to handle exceptional
    situations. For example, calling `operations['x'](num1, num2);` will lead to,
    creation of the empty `std::function` mapped to the character `x`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`std::function`的参数；它的形式是`int(int, int)`而不是`int(*)(int, int)`。使用`std::function`帮助我们处理异常情况。例如，调用`operations['x'](num1,
    num2);`将导致创建一个空的`std::function`映射到字符`x`。
- en: 'And calling it will throw an exception, so we can ensure the safety of the
    code by properly handling the call:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它将抛出异常，因此我们可以通过正确处理调用来确保代码的安全性：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we can use *lambda expressions—* unnamed functions constructed in
    place and able to capture variables in scope. For example, instead of declaring
    the preceding functions and then inserting them into the hash table, we can create
    a lambda expression right before inserting it into the hash table:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用*lambda表达式* - 在现场构造的未命名函数，能够捕获范围内的变量。例如，我们可以在将其插入哈希表之前创建一个lambda表达式，而不是声明前面的函数然后将其插入哈希表中：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Lambda expressions will be covered throughout the book.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式将在整本书中涵盖。
- en: Loops
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loops may be perceived as repeatable `if` statements, which again should be
    translated into CPU comparison and jump instructions. For example, we can calculate
    the sum of numbers from 0 to 10 using the `while` loop:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 循环可以被视为可重复的`if`语句，再次应该被转换为CPU比较和跳转指令。例如，我们可以使用`while`循环计算从0到10的数字的和：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This will translate to the following assembly code (simplified):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换为以下汇编代码（简化）：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'C++17 introduced init statements that can be used in conditionals and loops.
    The `num` variable declared outside of the `while` loop may now be moved into
    the loop:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: C++17引入了可以在条件语句和循环中使用的init语句。现在，在`while`循环之外声明的`num`变量可以移入循环中：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The same rule applies to the `if` statement, for example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的规则适用于`if`语句，例如：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'C++11 introduced the range-based `for` loop, which makes the syntax much clearer.
    For example, let''s call all the arithmetic operations we defined earlier using
    the new `for` loop:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了基于范围的`for`循环，使语法更加清晰。例如，让我们使用新的`for`循环调用我们之前定义的所有算术操作：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Iterating  `unordered_map` returns a pair with the first and second members,
    the first being the key, and the second being the value mapped to that key. C++17
    moved us even further, allowing us to write the same loop as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代`unordered_map`返回一个带有第一个和第二个成员的pair，第一个是键，第二个是映射到该键的值。C++17进一步推动我们，允许我们将相同的循环写成如下形式：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Knowing what the compiler actually generates is key in designing and implementing
    efficient software. We touched on the low-level details of conditionals and loops,
    which are at the base of almost every program.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 了解编译器实际生成的内容对于设计和实现高效软件至关重要。我们涉及了条件语句和循环的低级细节，这些细节是几乎每个程序的基础。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the details of program execution. We discussed
    functions and the `main()` function with some of its special properties. We found
    out how the recursion works and that the `main()` function cannot be called recursively.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了程序执行的细节。我们讨论了函数和`main()`函数及其一些特殊属性。我们了解了递归的工作原理以及`main()`函数不能递归调用。
- en: As C++ is one of the few high-level languages that supports low-level programming
    concepts such as accessing memory bytes by their address, we studied how data
    resides in the memory and how can we incorporate pointers in accessing that data.
    Understanding these details is a must for a professional C++ programmer.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++是为数不多支持低级编程概念（例如通过地址访问内存字节）的高级语言之一，我们研究了数据驻留在内存中的方式以及如何在访问数据时可以使用指针。了解这些细节对于专业的C++程序员来说是必不可少的。
- en: Lastly, we touched on the topic of conditionals and loops from the perspective
    of an assembly language. Throughout the chapter, we introduced C++20 features.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从汇编语言的角度讨论了条件语句和循环的主题。在整个章节中，我们介绍了C++20的特性。
- en: In the next chapter, we will learn more about **object-oriented programming**
    (**OOP**), including the inner details of the language object model. We will dive
    into the details of virtual functions and see how to use polymorphism.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地了解**面向对象编程**（**OOP**），包括语言对象模型的内部细节。我们将深入研究虚函数的细节，并了解如何使用多态性。
- en: Questions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How many parameters does the `main()` function have?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()`函数有多少个参数？'
- en: What is the `constexpr` specifier used for?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constexpr`限定符用于什么目的？'
- en: Why is it advised to use iteration over recursion?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么建议使用迭代而不是递归？
- en: What's the difference between the stack and the heap?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆栈和堆之间有什么区别？
- en: What is the size of the `ptr` if it is declared as `int*`?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果声明为`int*`，`ptr`的大小是多少？
- en: Why is access to an array element considered a constant time operation?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么访问数组元素被认为是一个常数时间操作？
- en: What will happen if we forget the `break` keyword in any case of the `switch`
    statement?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在`switch`语句的任何情况下忘记了`break`关键字会发生什么？
- en: How would you implement the `multiply()` and `divide()` functions from the arithmetic
    operations example as lambda expressions?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将算术操作示例中的`multiply()`和`divide()`函数实现为lambda表达式？
- en: Further reading
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can refer to the following book for more information on the topics covered
    in this chapter: *C++ High Performance*, by Viktor Sehr and Bjorn Andrist ([https://www.amazon.com/gp/product/1787120953](https://www.amazon.com/gp/product/1787120953)).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下书籍，了解本章涵盖的主题的更多信息：*C++ High Performance*，作者Viktor Sehr和Bjorn Andrist（[https://www.amazon.com/gp/product/1787120953](https://www.amazon.com/gp/product/1787120953)）。
