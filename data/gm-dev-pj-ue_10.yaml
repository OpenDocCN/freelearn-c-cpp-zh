- en: 11\. Blend Spaces 1D, Key Bindings, and State Machines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.混合空间1D、键绑定和状态机
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter begins by creating the Blend Space asset needed to allow movement
    animation blending from idle to walking, and finally to running, based on the
    speed of the player character. We will then implement new key mappings and use
    those mappings in C++ to code gameplay functionality for the player character,
    like sprinting. Lastly, we will create a new animation state machine within our
    character animation blueprint so that the player animations can smoothly transition
    between movement and jumping.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先创建所需的混合空间资产，以允许从空闲到行走，最终到奔跑的移动动画混合，根据玩家角色的速度。然后，我们将实现新的键映射，并在C++中使用这些映射来为玩家角色编写游戏功能，如冲刺。最后，我们将在角色动画蓝图中创建一个新的动画状态机，以便玩家动画可以在移动和跳跃之间平滑过渡。
- en: By the end of this chapter, you will have the `SuperSideScroller` player character
    animating correctly when moving around the environment and moving in a way that
    feels best for the game. This means that the player will support an idle, walking,
    and sprinting animation, while also supporting the animations needed for jumping.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，当“SuperSideScroller”玩家角色在环境中移动时，将正确地进行动画处理，并以最适合游戏的方式移动。这意味着玩家将支持空闲、行走和冲刺动画，同时还支持跳跃所需的动画。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we had a high-level look at animation and the development
    of the game design for your `SuperSideScroller` project. You were provided with
    just the beginning steps in the development of the project itself. You also prepared
    the player' characters' animation blueprint, character blueprint, and imported
    all of the required skeletal and animation assets.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对动画和“SuperSideScroller”项目的游戏设计开发进行了高层次的审视。您只是在项目开发的最初阶段。您还准备了玩家角色的动画蓝图、角色蓝图，并导入了所有必需的骨骼和动画资产。
- en: At this point, the character can move around the level, but is stuck in the
    T-Pose and does not animate at all. This can be fixed by creating a new Blend
    Space for the player character, which will be done in the very first exercise
    of this chapter. Once the Blend Space is complete, you will implement this in
    the character animation blueprint in order for the character to animate while
    moving.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，角色可以在关卡中移动，但却被困在T形姿势中，根本没有动画。通过为玩家角色创建一个新的混合空间，可以解决这个问题，这将在本章的第一个练习中完成。完成混合空间后，您将在角色动画蓝图中实现这一点，以便角色在移动时进行动画处理。
- en: In this chapter, you will be working with many new functions, asset types, and
    variables in order to achieve the desired movement of the player character. Some
    of these include the `Try Get Pawn Owner` function within the `Animation Blueprint`,
    the `1D Blend space asset` type, and `Input Bindings` in the project configuration
    files.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用许多新的函数、资产类型和变量，以实现玩家角色的期望移动。其中一些包括“动画蓝图”中的“尝试获取所有者”函数、“1D混合空间资产”类型和项目配置文件中的“输入绑定”。
- en: Let's start this chapter by first learning about Blend Spaces and then creating
    your Blend Space asset that you will need in order to get the player character
    animating while moving.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过学习混合空间，然后创建您需要的混合空间资产，以便在移动时使玩家角色进行动画处理。
- en: Blend Spaces
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合空间
- en: 'Blend Spaces, as the name suggests, allow you to blend between multiple animations
    based on one or more conditions. Blend Spaces are used in different types of video
    games, but, more often than not, in games where the player can view the entire
    character. Blend spaces are not usually used when the player can only see the
    character arms, such as in the First-Person template project provided in Unreal
    Engine 4, as shown below:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，混合空间允许您根据一个或多个条件在多个动画之间进行混合。混合空间在不同类型的视频游戏中使用，但通常在玩家可以看到整个角色的游戏中使用。在虚幻引擎4提供的第一人称模板项目中，通常不使用混合空间，因为玩家只能看到角色的手臂，如下所示：
- en: '![Figure 11.1: The first-person perspective of the default character in the
    First-Person project template in Unreal Engine 4.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1：虚幻引擎4中第一人称项目模板中默认角色的第一人称视角。'
- en: '](img/B16183_11_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_01.jpg)'
- en: 'Figure 11.1: The first-person perspective of the default character in the First-Person
    project template in Unreal Engine 4.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：虚幻引擎4中第一人称项目模板中默认角色的第一人称视角。
- en: 'It is more common in third-person games where there is a need to use Blend
    Spaces to smoothly blend movement-based animations of the character. A good example
    is the Third-Person template project provided in Unreal Engine 4, as shown below:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要平滑混合角色基于移动的动画的第三人称游戏中，混合空间更常见。一个很好的例子是虚幻引擎4提供的第三人称模板项目，如下所示：
- en: '![Figure 11.2: The third-person perspective of the default character, in the
    First-Person project template in Unreal Engine 4'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2：虚幻引擎4中第一人称项目模板中默认角色的第三人称视角'
- en: '](img/B16183_11_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_02.jpg)'
- en: 'Figure 11.2: The third-person perspective of the default character, in the
    First-Person project template in Unreal Engine 4'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：虚幻引擎4中第一人称项目模板中默认角色的第三人称视角
- en: Blend Spaces allow the player character to blend between animations based on
    a variable, or a set of variables. For example, in the case of *Joel,* from *The
    Last of Us*, his movement animation is based on the speed at which he is moving,
    and this speed is provided by the player through the controller sticks (or joystick).
    With increased speeds, his animation updates from walking, to running, and then
    to sprinting. This is what we are trying to achieve with our character in this
    chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间允许玩家角色根据变量或一组变量在动画之间进行混合。例如，在《最后生还者》中的乔尔，他的移动动画是基于他的移动速度的，这个速度是由玩家通过控制器摇杆（或摇杆）提供的。随着速度的增加，他的动画从行走更新到奔跑，然后到冲刺。这就是我们在本章中要实现的目标。
- en: Let's look at the Blend Space asset provided by Unreal Engine when creating
    the `Side Scroller` project template by opening `/Mannequin/Animations/ThirdPerson_IdleRun_2D`.
    This is a 1D Blend Space asset created for the `Side Scroller` mannequin skeletal
    mesh so that the player character can smoothly blend between idle, walking, and
    running animations based on the speed of the character.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Unreal Engine提供的混合空间资产，在创建`侧向滚动`项目模板时，通过打开`/Mannequin/Animations/ThirdPerson_IdleRun_2D`。这是为`侧向滚动`人体模型骨骼网格创建的1D混合空间资产，以便玩家角色可以根据角色的速度在空闲、行走和奔跑动画之间平滑过渡。
- en: If you check `Persona`, in the `Asset Details` panel on the left-hand side,
    you will see the `Axis Settings` category with the `Horizontal Axis` parameter
    where we have settings for this axis, which essentially acts as a variable that
    we can reference in our animation blueprint. Please refer to the image below to
    see the `Axis Settings` within `Persona`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`Persona`中检查，在左侧的`资产详情`面板中，你会看到`轴设置`类别，其中有`水平轴`参数，我们可以在我们的动画蓝图中引用的变量。请参考下面的图像查看`Persona`中的`轴设置`。
- en: '![Figure 11.3: Shown here are the axis settings for the 1D Blend Space'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：这里显示了1D混合空间的轴设置'
- en: '](img/B16183_11_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_03.jpg)'
- en: 'Figure 11.3: Shown here are the axis settings for the 1D Blend Space'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：这里显示了1D混合空间的轴设置
- en: Below the preview window, we will also see a small graph with points along the
    line from left to right; one of these points will be highlighted `green`, while
    the others are `white`. We can *left-click* and drag this `green` point along
    the horizontal axis to preview the blended animation based on its value. At speed
    `0`, our character is in `Idle` and, as we move our preview along the axis, the
    animation will begin to blend Walking, followed by `Running`. Please refer the
    following image to view the single-axis graph.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览窗口下方，我们还会看到一个小图表，沿着从左到右的线有点；其中一个点将被突出显示为`绿色`，而其他点为`白色`。我们可以*左键单击*并沿着水平轴拖动这个`绿色`点，以预览基于其值的混合动画。在速度为`0`时，我们的角色处于`空闲`状态，当我们沿着轴移动我们的预览时，动画将开始混合行走，然后是`奔跑`。请参考下面的图像查看单轴图表。
- en: '![Figure 11.4: Highlighted here is the key frame timeline of the 1D Blend Space'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4：这里突出显示了1D混合空间的关键帧时间轴'
- en: '](img/B16183_11_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_04.jpg)'
- en: 'Figure 11.4: Highlighted here is the key frame timeline of the 1D Blend Space'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：这里突出显示了1D混合空间的关键帧时间轴
- en: In the next section, we will be looking at 1D Blend Spaces vis-à-vis a normal
    Blend Space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究1D混合空间与普通混合空间的区别。
- en: 1D Blend Space vs Normal Blend Space
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1D混合空间与普通混合空间
- en: Before moving forward with the 1D Blend Space, let's take a moment to distinguish
    the main differences between a Blend Space and a 1D Blend Space in Unreal Engine 4\.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用Unreal Engine 4中的1D混合空间之前，让我们花点时间区分混合空间和1D混合空间之间的主要区别。
- en: The Blend Space asset in Unreal is controlled by two variables, represented
    by the *X* and *Y* axes of the Blend Space graph.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal中的混合空间资产由两个变量控制，由混合空间图的*X*和*Y*轴表示。
- en: On the other hand, the 1D Blend Space only supports one axis.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，1D混合空间只支持一个轴。
- en: Try to imagine this as a 2D graph. As you know that each axis has its own direction,
    you can better visualize why and when you would need to use this Blend Space rather
    than a 1D Blend Space, which only supports a single axis.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 试着把这个想象成一个2D图表。你知道每个轴都有自己的方向，你可以更好地想象出为什么以及何时需要使用这个混合空间，而不是只支持单一轴的1D混合空间。
- en: 'Say, for example, you wanted to make the player character strafe left and right
    while also supporting forward and backward movement. If you were to map this movement
    out on a graph, it would look like the following figure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设你想让玩家角色在左右移动的同时也支持前后移动。如果你要在图表上映射这种移动，它会看起来像下面的图：
- en: '![Figure 11.5: This is what a Blend Space movement would look like on a simple
    graph'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5：这是一个简单图表上混合空间运动的样子'
- en: '](img/B16183_11_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_05.jpg)'
- en: 'Figure 11.5: This is what a Blend Space movement would look like on a simple
    graph'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：这是一个简单图表上混合空间运动的样子
- en: Now, visualize the movement for the player character, keeping in mind the fact
    that the game is a `Side Scroller`. The character won't be supporting left or
    right strafing or forward and backward movement. The player character will only
    need to animate in one direction because the `Side Scroller` character rotates
    toward the direction of movement by default. Having to only support one direction
    is why you are using a 1D Blend Space instead of a normal Blend Space.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下玩家角色的移动，记住游戏是一个`侧向滚动`。角色不会支持左右平移或前后移动。玩家角色只需要在一个方向上进行动画，因为`侧向滚动`角色默认会朝着移动方向旋转。只需要支持一个方向是你使用1D混合空间而不是普通混合空间的原因。
- en: We will need to set up this type of Blend Space asset for our main character
    and use the Blend Space for the same purpose, for movement-based animation blending.
    In the next exercise, let's start by creating the Blend Space asset together using
    our custom animation assets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的主角设置这种类型的混合空间资产，并将其用于相同的目的，即基于移动的动画混合。在下一个练习中，让我们一起使用我们的自定义动画资产创建混合空间资产。
- en: 'Exercise 11.01: Creating the CharacterMovement 1D Blend Space'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.01：创建角色移动1D混合空间
- en: In order to get the player character to animate while he moves, you need to
    first create a Blend Space as discussed previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家角色在移动时进行动画，你需要首先创建一个如前所述的混合空间。
- en: In this exercise, you will create the Blend Space asset, add the idle animation,
    and update the `CharacterMovement` component so that you assign an appropriate
    walking speed value that corresponds with the Blend Space.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建混合空间资产，添加空闲动画，并更新`CharacterMovement`组件，以便分配与混合空间相对应的适当行走速度值。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: Navigate to the `/MainCharacter/Animation` folder in `Content Browser`, where
    all the new animations you imported in the last chapter are located.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`中导航到`/MainCharacter/Animation`文件夹，其中包含您在上一章中导入的所有新动画。
- en: Now, *right-click* in the main area of `Content Browser` and, from the drop-down
    menu, hover over the option for `Animation` and, from its additional drop-down
    menu, select `Blend Space 1D` by *left-clicking*.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Content Browser`的主区域中*右键单击*，从下拉菜单中悬停在`Animation`选项上，然后从其附加的下拉菜单中*左键单击*选择`Blend
    Space 1D`。
- en: Make sure to select `MainCharacter_Skeleton`, and not `UE4_Mannequin_Skeleton`,
    as the skeleton for the Blend Space.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择`MainCharacter_Skeleton`，而不是`UE4_Mannequin_Skeleton`，作为混合空间的骨骼。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you apply the incorrect skeleton, the Blend Space will not be functional
    for the player character and its custom skeletal mesh when selecting the skeleton
    for assets such as Blend Spaces or animation blueprints that require one. Here,
    you are telling this asset with which skeleton it is compatible. By doing so,
    in the case of a Blend Space, you are able to use animations that are made for
    this skeleton and thereby ensure that everything is compatible with everything
    else.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用了不正确的骨骼，那么在为需要骨骼的资产（如混合空间或动画蓝图）选择骨骼时，混合空间对于玩家角色和其自定义骨骼网格将无法正常工作。在这里，您正在告诉这个资产它与哪个骨骼兼容。通过这样做，在混合空间的情况下，您可以使用为该骨骼制作的动画，并确保一切与其他一切兼容。
- en: Name this Blend Space asset `SideScroller_IdleRun_1D`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此混合空间资产命名为`SideScroller_IdleRun_1D`。
- en: 'Next, open the `SideScroller_IdleRun_1D` Blend Space asset. You can see the
    single-axis graph below the preview window:![Figure 11.6: The editing tool used
    to create Blend Spaces in Unreal Engine 4'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`SideScroller_IdleRun_1D`混合空间资产。您可以在预览窗口下方看到单轴图表：![图11.6：Unreal Engine
    4中用于创建混合空间的编辑工具
- en: '](img/B16183_11_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_06.jpg)'
- en: 'Figure 11.6: The editing tool used to create Blend Spaces in Unreal Engine
    4'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：Unreal Engine 4中用于创建混合空间的编辑工具
- en: On the left-hand side of the editor, you have the `Asset Details` panel that
    contains the `Axis Settings` category. It is here that you will label the axis
    and provide both a minimum and maximum float value that will later be of use to
    you in the `Animation Blueprint` for the player character. Please refer to the
    figure below to see the default values set for `Horizontal Axis`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器的左侧，您有包含`Axis Settings`类别的`Asset Details`面板。在这里，您将标记轴并提供最小和最大浮点值，这些值稍后将在玩家角色的`Animation
    Blueprint`中对您有用。请参考下面的图表，查看为`Horizontal Axis`设置的默认值。
- en: '![Figure 11.7: The axis settings that affect the axis of the Blend Space'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7：影响混合空间轴的轴设置'
- en: '](img/B16183_11_07.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_07.jpg)'
- en: 'Figure 11.7: The axis settings that affect the axis of the Blend Space'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：影响混合空间轴的轴设置
- en: 'Now, rename the `Horizontal Axis` as `Speed`:![Figure 11.8: The horizontal
    axis is now named Speed'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`Horizontal Axis`重命名为`Speed`：![图11.8：水平轴现在命名为Speed
- en: '](img/B16183_11_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_08.jpg)'
- en: 'Figure 11.8: The horizontal axis is now named Speed'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：水平轴现在命名为Speed
- en: The next step is to establish `Minimum Axis Value` and `Maximum Axis Value`.
    You will want the minimum value to be `0.0f`, which is set by default, because
    the player character will be in `Idle` when he is not moving at all.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是建立`Minimum Axis Value`和`Maximum Axis Value`。您希望最小值默认为`0.0f`，因为玩家角色在完全不移动时将处于`Idle`状态。
- en: 'But what about the `Maximum Axis Value`? This one is a little trickier because
    you need to bear the following points in mind:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但`Maximum Axis Value`呢？这个有点棘手，因为您需要记住以下几点：
- en: You will be supporting a sprinting behavior for the character that allows the
    player to move faster when holding down the *Left Shift* keyboard button. When
    released, the player will return to the default walking speed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将支持角色的冲刺行为，允许玩家在按住*左Shift*键盘按钮时移动得更快。释放时，玩家将返回默认行走速度。
- en: The walking speed to match the characters' `Max Walk Speed` parameter of the
    `CharacterMovementComponent`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行走速度要匹配`CharacterMovementComponent`的角色`Max Walk Speed`参数。
- en: Before you set the `Maximum Axis Value`, you need to set the character's `Max
    Walk Speed` to a value that suits the `SuperSideScroller` game.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`Maximum Axis Value`之前，您需要将角色的`Max Walk Speed`设置为适合`SuperSideScroller`游戏的值。
- en: 'For this, navigate to `/Game/MainCharacter/Blueprints/` and open the `BP_SuperSideScroller_MainCharacter`
    blueprint:![Figure 11.9: The directory of the SuperSideScroller main character
    blueprint'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，导航到`/Game/MainCharacter/Blueprints/`并打开`BP_SuperSideScroller_MainCharacter`蓝图：![图11.9：SuperSideScroller主角蓝图的目录
- en: '](img/B16183_11_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_09.jpg)'
- en: 'Figure 11.9: The directory of the SuperSideScroller main character blueprint'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：SuperSideScroller主角蓝图的目录
- en: 'Select the `Character Movement` component and, in the `Details` panel, under
    the `Character Movement: Walking` category, find the `Max Walk Speed` parameter
    and set this value to `300.0f`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择`Character Movement`组件，在`Details`面板中，在`Character Movement: Walking`类别下，找到`Max
    Walk Speed`参数，并将该值设置为`300.0f`。'
- en: With the `Max Walk Speed` parameter set, return to the `SideScroller_IdleRun_1D`
    Blend Space and set the `Maximum Axis Value` parameter. If the walking speed was
    `300.0f`, what should the maximum value be? Keeping in mind that you will support
    sprinting for the player character, this maximum value needs to be more than the
    walking speed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Max Walk Speed`参数设置后，返回到`SideScroller_IdleRun_1D`混合空间，并设置`Maximum Axis Value`参数。如果行走速度为`300.0f`，最大值应该是多少？请记住，您将支持玩家角色的冲刺，因此这个最大值需要大于行走速度。
- en: Update the `Maximum Axis Value` parameter to a value of `500.0f`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Maximum Axis Value`参数更新为`500.0f`。
- en: Lastly, set the `Number of Grid Divisions` parameter to a value of `5`. The
    reason for this is that when working with divisions, a `100` unit spacing between
    each grid point makes it easier to work with since `Maximum Axis Value` is `500.0f`.
    This is useful in the case of grid point snapping when you apply the movement
    animations along the grid.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Number of Grid Divisions`参数设置为`5`。这样做的原因是，在处理分区时，每个网格点之间的`100`单位间距使得更容易处理，因为`Maximum
    Axis Value`是`500.0f`。在应用动画沿网格时，这对于网格点捕捉非常有用。
- en: 'Leave the remaining properties set as their defaults:![Figure 11.10: The final
    axis settings for the Blend Space'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的属性设置为默认值：![图11.10：混合空间的最终轴设置
- en: '](img/B16183_11_10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_10.jpg)'
- en: 'Figure 11.10: The final axis settings for the Blend Space'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：混合空间的最终轴设置
- en: What you have done here with these settings is that you are telling the Blend
    Space to use an incoming float value between `0.0f` and `500.0f` to blend between
    the animations that you will place in the next step and the activity. By dividing
    the grid into `5` divisions, you are able to easily add the animations needed
    at the correct float value along the axis graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些设置，您告诉混合空间使用`0.0f`到`500.0f`之间的传入浮点值来在下一步和活动中混合动画。通过将网格分成`5`个部分，您可以轻松地在轴图表上的正确浮点值处添加所需的动画。
- en: Let's continue creating the Blend Space by adding the first animation to the
    axis graph, the `Idle` animation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建混合空间，通过将第一个动画添加到轴图表中，即`Idle`动画。
- en: To the right of the grid, there is the `Asset Browser` tab. Notice that the
    list of assets includes all of the animations of the player character that you
    imported in *Chapter 12*, *Animation Blending and Montages*. This is because you
    selected the `MainCharacter_Skeleton` asset when creating the Blend Space.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网格的右侧，有`Asset Browser`选项卡。请注意，资产列表包括您在*第12章* *动画混合和蒙太奇*中导入的玩家角色的所有动画。这是因为您在创建混合空间时选择了`MainCharacter_Skeleton`资产。
- en: 'Next, *left-click* and drag the `Idle` animation to our grid at position `0.0`:![Figure
    11.11: Dragging the Idle animation to the grid position 0.0'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键单击*并将`Idle`动画拖动到我们的网格位置`0.0`：![图11.11：将Idle动画拖动到网格位置0.0
- en: '](img/B16183_11_11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_11.jpg)'
- en: 'Figure 11.11: Dragging the Idle animation to the grid position 0.0'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：将Idle动画拖动到网格位置0.0
- en: 'Notice that when dragging this animation to the grid, it will snap to the grid
    point. Once the animation is added to the Blend Space, the player character changes
    from its default T-Pose and starts to play the `Idle` animation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将此动画拖动到网格时，它将捕捉到网格点。一旦动画添加到混合空间中，玩家角色就会从其默认T形状改变，并开始播放`Idle`动画：
- en: '![Figure 11.12: With the Idle animation added to the 1D Blend Space,'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12：将Idle动画添加到1D混合空间，'
- en: the player character begins to animate
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色开始动画
- en: '](img/B16183_11_12.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_12.jpg)'
- en: 'Figure 11.12: With the Idle animation added to the 1D Blend Space, the player
    character begins to animate'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：将Idle动画添加到1D混合空间，玩家角色开始动画
- en: With this exercise complete, you now have an understanding of how to create
    a 1D Blend Space and, more importantly, you know the differences between a 1D
    Blend Space and a normal Blend Space. Additionally, you know the importance of
    aligning the values between the player character movement component and the Blend
    Space and why you need to ensure that the walking speed correlates appropriately
    with the values in the Blend Space.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，您现在了解了如何创建1D混合空间，更重要的是，您知道了1D混合空间和普通混合空间之间的区别。此外，您知道了在玩家角色移动组件和混合空间之间对齐值的重要性，以及为什么需要确保行走速度与混合空间中的值适当地相关。
- en: Let's now move on to the first activity of this chapter, where you will be applying
    the remaining `Walking` and `Running` animations to the Blend Space just as you
    added the `Idle` animation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续进行本章的第一个活动，在这个活动中，您将像添加`Idle`动画一样，将剩余的`Walking`和`Running`动画应用到混合空间中。
- en: 'Activity 11.01: Adding the Walking and Running Animations to the Blend Space'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.01：将Walking和Running动画添加到混合空间
- en: The 1D movement Blend Space is coming together nicely so far, but you are missing
    the walking and running animations. In this activity, you will finish the Blend
    Space by adding these animations to the Blend Space at the appropriate horizontal
    axis values that make sense for the main character.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，1D运动混合空间进展顺利，但您缺少行走和奔跑动画。在本活动中，您将通过将这些动画添加到适合主角的水平轴值的混合空间来完成混合空间。
- en: 'Using the knowledge acquired from *Exercise 11.01*, *Creating the CharacterMovement
    1D Blend Space*, perform the following steps to finish up the character movement
    Blend Space:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从*练习11.01* *创建CharacterMovement 1D混合空间*中获得的知识，执行以下步骤来完成角色移动混合空间：
- en: Continuing on from *Exercise 11.01*, *Creating the CharacterMovement 1D Blend
    Space*, head back to `Asset Browser`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '继续进行*练习11.01* *创建CharacterMovement 1D混合空间*，返回`Asset Browser`。 '
- en: Now, add the `Walking` animation to the horizontal grid position `300.0f`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`Walking`动画添加到水平网格位置`300.0f`。
- en: Finally, add the `Running` animation to the horizontal grid position `500.0f`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Running`动画添加到水平网格位置`500.0f`。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can *left-click* and drag the green preview grid point along
    the grid axis to see how the animation blends together based on the axis value,
    so pay attention to the character animation preview window to make sure that it
    looks correct.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以*左键单击*并沿着网格轴拖动绿色预览网格点，以查看动画根据轴值如何混合在一起，因此请注意角色动画预览窗口，以确保它看起来正确。
- en: 'The expected output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 11.13: The Running animation in the Blend Space'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13：混合空间中的Running动画'
- en: '](img/B16183_11_13.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_13.jpg)'
- en: 'Figure 11.13: The Running animation in the Blend Space'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：混合空间中的Running动画
- en: When this activity is complete, you will have a functional Blend Space that
    blends the character movement animations from `Idle` to `Walking` to `Running`
    based on the value of the horizontal axis that represents the player character's
    speed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个活动完成时，你将拥有一个功能性的混合空间，根据代表玩家角色速度的水平轴的值，将角色的移动动画从`Idle`混合到`Walking`再到`Running`。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Main Character Animation Blueprint
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主角动画蓝图
- en: With the animations added to the Blend Space, you should be able to walk around
    and see those animations at work, right? Well, no. If you select Play-In-Editor,
    you will notice that the main character is still moving in the T-Pose. The reason
    is because you aren't yet telling the animation blueprint to use our Blend Space
    asset, which you will do later in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将动画添加到混合空间后，你应该能够四处走动并看到这些动画在起作用，对吗？嗯，不是的。如果选择在编辑器中播放，你会注意到主角仍然以T形姿势移动。原因是因为你还没有告诉动画蓝图使用我们的混合空间资产，这将在本章后面进行。
- en: Animation Blueprints
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画蓝图
- en: Before jumping into using the animation blueprint you created in the last chapter,
    let's briefly discuss what this type of blueprint is, and what its main function
    is. An animation blueprint is a type of blueprint that allows you to control the
    animation of a skeleton and skeletal mesh, in this instance, the player character
    skeleton and mesh you imported in the last chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳入上一章创建的动画蓝图之前，让我们简要讨论一下这种类型的蓝图是什么，以及它的主要功能是什么。动画蓝图是一种蓝图，允许你控制骨骼和骨骼网格的动画，此处指的是上一章导入的玩家角色骨骼和网格。
- en: 'An animation blueprint is broken into two main graphs:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图分为两个主要图表：
- en: Event Graph
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件图
- en: Anim Graph
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画图
- en: The Event Graph works as in a normal blueprint where you can use events, functions,
    and variables to script gameplay logic. The Anim Graph, on the other hand, is
    unique to an animation blueprint, and this is where you use logic to determine
    the final pose of the skeleton and skeletal mesh at any given frame. It is here
    where you can use elements such as state machines, anim slots, Blend Spaces, and
    other animation-related nodes to then output to the final animation for the character.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事件图的工作方式与普通蓝图相同，你可以使用事件、函数和变量来编写游戏逻辑。另一方面，动画图是动画蓝图独有的，这是你在其中使用逻辑来确定骨骼和骨骼网格在任何给定帧的最终姿势。在这里，你可以使用状态机、动画插槽、混合空间和其他与动画相关的节点，然后输出给角色的最终动画。
- en: Have a look at the following example (you can follow along).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例（你可以跟着做）。
- en: Open the `AnimBP_SuperSideScroller_MainCharacter` animation blueprint in the
    `MainCharacter/Blueprints` directory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainCharacter/Blueprints`目录中打开`AnimBP_SuperSideScroller_MainCharacter`动画蓝图。
- en: By default, `AnimGraph` should open where you can see the character preview,
    our `Asset Browser` tab, and the main graph. It is inside this `AnimGraph` that
    you will implement the Blend Space you just created in order to have the player
    character animate correctly when moving around the level.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`AnimGraph`应该打开，你可以在其中看到角色预览、我们的`Asset Browser`选项卡和主图表。就是在这个`AnimGraph`中，你将实现刚刚创建的混合空间，以便在关卡中移动时玩家角色能够正确地进行动画。
- en: Let's get started with the next exercise, where we will do this and learn more
    about animation blueprints.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始下一个练习，我们将在这个练习中做这个，并学习更多关于动画蓝图的知识。
- en: 'Exercise 11.02: Adding the Blend Space to the Character Animation Blueprint'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：将混合空间添加到角色动画蓝图
- en: For this exercise, you will add the Blend Space to the animation blueprint and
    prepare the necessary variable to help control this Blend Space based on the movement
    speed of the player character. Let's begin by adding the Blend Space to `AnimGraph`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将把混合空间添加到动画蓝图，并准备必要的变量来控制这个混合空间，根据玩家角色的移动速度。让我们从将混合空间添加到`AnimGraph`开始。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Add the Blend Space to `AnimGraph` by finding the `Asset Browser` on the right-hand
    side, and *left-click* and drag the `SideScroller_IdleRun_1D` Blend Space asset
    into `AnimGraph`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在右侧找到`Asset Browser`，*左键单击*并将`SideScroller_IdleRun_1D`混合空间资产拖入`AnimGraph`中，将混合空间添加到`AnimGraph`。
- en: Notice that the variable input for this Blend Space node is labeled `Speed`,
    just like the horizontal axis inside the Blend Space. Please refer to *Figure
    11.14* to see the Blend Space in `Asset Browser`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个混合空间节点的变量输入标签为`Speed`，就像混合空间内部的水平轴一样。请参考*图11.14*，看看`Asset Browser`中的混合空间。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you were to name the `Horizontal Axis` differently, the new name would be
    shown as the input parameter of the Blend Space.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给`Horizontal Axis`取了不同的名字，新名字会显示为混合空间的输入参数。
- en: '![Figure 11.14: Asset Browser gives you access to all animation assets related
    to the MainCharacter_Skeleton'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14：Asset Browser让你访问与MainCharacter_Skeleton相关的所有动画资产'
- en: '](img/B16183_11_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_14.jpg)'
- en: 'Figure 11.14: Asset Browser gives you access to all animation assets related
    to the MainCharacter_Skeleton'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：Asset Browser让你访问与MainCharacter_Skeleton相关的所有动画资产
- en: 'Next, connect the `Output Pose` asset of the Blend Space node to the `Result`
    pin of the `Output Pose` node. Now, the animation pose in the preview shows the
    character in the `Idle` animation pose:![Figure 11.15: You now have limited control
    of the Blend Space and can manually enter values into the Speed parameter to update
    the character movement animations'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将混合空间节点的`Output Pose`资产连接到`Output Pose`节点的`Result`引脚。现在，在预览中的动画姿势显示为角色的`Idle`动画姿势：![图11.15：你现在对混合空间有了有限的控制，并可以手动输入值到Speed参数中来更新角色的移动动画
- en: '](img/B16183_11_15.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_15.jpg)'
- en: 'Figure 11.15: You now have limited control of the Blend Space and can manually
    enter values into the Speed parameter to update the character movement animations'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：你现在对混合空间有了有限的控制，并可以手动输入值到Speed参数中来更新角色的移动动画
- en: 'If you use `PIE,`(`Idle` animation instead of remaining in the T-Pose:![Figure
    11.16: The player character now plays the Idle animation in-game'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用`PIE`，(`Idle`动画而不是保持T-Pose:![图11.16：玩家角色现在在游戏中播放Idle动画
- en: '](img/B16183_11_16.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_16.jpg)'
- en: 'Figure 11.16: The player character now plays the Idle animation in-game'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：玩家角色现在在游戏中播放Idle动画
- en: 'Now, you have the ability to control our Blend Space with our `Speed` input
    variable. With the ability to use the Blend Space in place, you need a way to
    store the character''s movement speed, and pass that value to the `Speed` input
    parameter of the Blend Space. This is what you will need to do:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`Speed`输入变量来控制我们的混合空间。有了使用混合空间的能力，你需要一种方法来存储角色的移动速度，并将该值传递给混合空间的`Speed`输入参数。这就是你需要做的：
- en: 'Navigate to the `Event Graph` of our animation blueprint. By default, there
    will be the `Event Blueprint Update Animation` event and a pure `Try Get Pawn
    Owner` function. Please refer to *Figure 11.17* to see the default setup of `Event
    Graph`. The event is updated each frame that the animation is updated, and returns
    the `SuperSideScroller` player character blueprint class before attempting to
    get any more information.![Figure 11.17: Animation blueprints include this event
    and function pair'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们的动画蓝图的`事件图`。默认情况下，会有`事件蓝图更新动画`事件和一个纯`Try Get Pawn Owner`函数。请参考*图11.17*，查看`事件图`的默认设置。该事件在每帧动画更新时更新，并在尝试获取更多信息之前返回`SuperSideScroller`玩家角色蓝图类。![图11.17：动画蓝图包括此事件和函数对
- en: by default to use in your Event Graph
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下在你的事件图中使用
- en: '](img/B16183_11_17.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_17.jpg)'
- en: 'Figure 11.17: Animation blueprints include this event and function pair by
    default to use in your Event Graph'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：动画蓝图包括此事件和函数对，默认情况下在你的事件图中使用
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between a `Pure` and `Impure` function in Unreal Engine
    4 is that a `Pure` function implies that the logic it contains will not modify
    a variable or member of the class in which it is being used. In the case of `Try
    Get Pawn Owner`, it is simply returning a reference to the `Pawn` owner of the
    animation blueprint. `Impure` functions do not have this implication and are free
    to modify any variable or member it wants.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，`Pure`函数和`Impure`函数的主要区别在于，`Pure`函数意味着它包含的逻辑不会修改它所使用的类的变量或成员。在`Try Get
    Pawn Owner`的情况下，它只是返回动画蓝图的`Pawn`所有者的引用。`Impure`函数没有这个含义，并且可以自由修改任何它想要修改的变量或成员。
- en: 'Get the `Return Value` from the `Try Get Pawn Owner` function and, from the
    `Context Sensitive` menu that appears, search for the cast to `SuperSideScrollerCharacter`:![Figure
    11.18: The context-sensitive menu finds the related function or variable on which
    basis actions can be taken on the object you are checking from'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Try Get Pawn Owner`函数获取`Return Value`，然后从出现的`上下文敏感`菜单中搜索转换为`SuperSideScrollerCharacter`：![图11.18：上下文敏感菜单可以找到相关的函数或变量，基于这些可以对所检查的对象采取行动
- en: '](img/B16183_11_18.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_18.jpg)'
- en: 'Figure 11.18: The context-sensitive menu finds the related function or variable
    on which basis actions can be taken on the object you are checking from'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：上下文敏感菜单可以找到相关的函数或变量，基于这些可以对所检查的对象采取行动
- en: 'Connect the execution output pin from `Event Blueprint Update Animation` to
    the execution input pin of the cast:![Figure 11.19: Inside the Event Graph, use
    the Try Get Pawn Owner function to cast the returned Pawn object to the SuperSideScrollerCharacter
    class'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`事件蓝图更新动画`的执行输出引脚连接到转换的执行输入引脚：![图11.19：在事件图中，使用Try Get Pawn Owner函数将返回的Pawn对象转换为SuperSideScrollerCharacter类
- en: '](img/B16183_11_19.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_19.jpg)'
- en: 'Figure 11.19: Inside the Event Graph, use the Try Get Pawn Owner function to
    cast the returned Pawn object to the SuperSideScrollerCharacter class'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：在事件图中，使用Try Get Pawn Owner函数将返回的Pawn对象转换为SuperSideScrollerCharacter类
- en: The character blueprint you created inherits from the `SuperSideScrollerCharacter`
    class. Since the owning pawn of this animation blueprint is your `BP_SuperSideScroller_MainCharacter`
    character blueprint and this blueprint inherits from the `SuperSideScrollerCharacter`
    class, the cast function will execute successfully.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的角色蓝图继承自`SuperSideScrollerCharacter`类。由于这个动画蓝图的拥有者是你的`BP_SuperSideScroller_MainCharacter`角色蓝图，并且这个蓝图继承自`SuperSideScrollerCharacter`类，所以转换函数将成功执行。
- en: Next, store the returned value from the cast to its own variable; that way,
    we have a reference to it in case we need to use it again in our animation blueprint.
    Refer to *Figure 11.20* and make sure to name this new variable `MainCharacter`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将转换后的返回值存储到自己的变量中；这样，我们在动画蓝图中需要再次使用它时就有一个引用。参考*图11.20*，确保将这个新变量命名为`MainCharacter`。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is the option in the context-sensitive dropdown for `Promote to Variable`,
    which allows you to store any valid value type to its own variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文敏感的下拉菜单中有`提升为变量`的选项，它允许你将任何有效值类型存储到自己的变量中。
- en: '![Figure 11.20: As long as the cast is successful, you will want to keep'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20：只要转换成功，你就会想要保留'
- en: track of the owning character
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪所拥有的角色
- en: '](img/B16183_11_20.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_20.jpg)'
- en: 'Figure 11.20: As long as the cast is successful, you will want to keep track
    of the owning character'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：只要转换成功，你就会想要跟踪所拥有的角色
- en: 'Now, to track the character''s speed, use the `Get Velocity` function from
    the `MainCharacter` variable. Every object from the `Actor` class has access to
    this function that returns the magnitude and direction vector that the object
    is moving in:![Figure 11.21: The GetVelocity function can be found under Utilities/Transformation'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要跟踪角色的速度，使用`MainCharacter`变量中的`Get Velocity`函数。`Actor`类的每个对象都可以访问这个函数，它返回对象移动的大小和方向向量：![图11.21：GetVelocity函数可以在Utilities/Transformation下找到
- en: '](img/B16183_11_21.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_21.jpg)'
- en: 'Figure 11.21: The GetVelocity function can be found under Utilities/Transformation'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：GetVelocity函数可以在Utilities/Transformation下找到
- en: 'From `Get Velocity`, you can use the `VectorLength` function to get the actual
    speed:![Figure 11.22: The VectorLength function returns the magnitude of the vector,'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“获取速度”中，您可以使用“VectorLength”函数来获取实际速度：![图11.22：VectorLength函数返回矢量的大小，
- en: but not the direction
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但不返回方向
- en: '](img/B16183_11_22.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_22.jpg)'
- en: 'Figure 11.22: The VectorLength function returns the magnitude of the vector,
    but not the direction'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22：VectorLength函数返回矢量的大小，但不返回方向
- en: '`Return Value` from the `VectorLength` function can then be promoted to its
    own variable named `Speed`:![Figure 11.23: Every actor has the Get Velocity function
    that returns the magnitude and direction of the actor''s movement'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“VectorLength”函数的“Return Value”然后可以提升为自己的变量命名为“Speed”：![图11.23：每个角色都有Get Velocity函数，返回角色移动的大小和方向
- en: '](img/B16183_11_23.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_23.jpg)'
- en: 'Figure 11.23: Every actor has the Get Velocity function that returns the magnitude
    and direction of the actor''s movement'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：每个角色都有Get Velocity函数，返回角色移动的大小和方向
- en: In this exercise, you were able to obtain the player character speed by using
    the `GetVelocity` function. The vector returned from the `GetVelocity` function
    gives the length of the vector to ascertain the actual speed. By storing this
    value in the `Speed` variable, you can now reference this value in the `AnimGraph`
    of the animation blueprint to update your Blend Space, which you will do in the
    next exercise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您可以使用“GetVelocity”函数获得玩家角色的速度。从“GetVelocity”函数返回的矢量给出了矢量的长度以确定实际速度。通过将这个值存储在“Speed”变量中，您现在可以在动画蓝图的“AnimGraph”中引用这个值来更新您的混合空间，在下一个练习中将会这样做。
- en: Velocity Vectors
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度矢量
- en: Before moving on to the next step, let's explain what you are doing when you
    get the velocity of the character and promote the vector length of that vector
    to the `Speed` variable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，让我们解释一下当您获取角色的速度并将该矢量的矢量长度提升为“Speed”变量时，您正在做什么。
- en: What is velocity? Velocity is a vector that has a given `GetVelocity` function
    and the `VectorLength` function on the returned velocity vector; you are getting
    the value of the `Speed` variable of our character. That is why you store that
    value in a variable and use it to control the Blend Space, as shown in the following
    figure, which is an example of vectors. Where one has a positive (right) direction
    with a magnitude of `100`, the other has a negative (left) direction with a magnitude
    of `35`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是速度？速度是一个具有给定“GetVelocity”函数和返回速度矢量上的“VectorLength”函数的矢量；您正在获取我们角色的“Speed”变量的值。这就是为什么您将该值存储在变量中并将其用于控制混合空间的原因，如下图所示，这是矢量的一个示例。其中一个具有正（右）方向，大小为“100”，另一个具有负（左）方向，大小为“35”。
- en: '![Figure 11.24: Figure showing two different vectors'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.24：显示两个不同的矢量的图'
- en: '](img/B16183_11_24.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_24.jpg)'
- en: 'Figure 11.24: Figure showing two different vectors'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：显示两个不同的矢量的图
- en: 'Exercise 11.03: Adding the Blend Space to the Character Animation Blueprint'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.03：将混合空间添加到角色动画蓝图
- en: Now that you have a better understanding of `Vectors` and how to store the `Speed`
    variable of the player character from the previous exercise, you can follow these
    next steps to apply the speed to the 1D Blend Space you created earlier in this
    chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对“矢量”以及如何存储玩家角色的“Speed”变量有了更好的理解，您可以按照以下步骤将速度应用于本章前面创建的1D混合空间。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Navigate to the `AnimGraph` within your `AnimBP_SuperSideScroller_MainCharacter`
    animation blueprint.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的“AnimBP_SuperSideScroller_MainCharacter”动画蓝图中的“AnimGraph”。
- en: 'Use the `Speed` variable to update the Blend Space in real time in the `AnimGraph`
    by *left-clicking* and dragging the `Speed` variable onto the graph, and connecting
    the variable to the input of the `Blendspace Player` function:![Figure 11.25:
    You can now use the Speed variable to update the Blend Space in every frame when
    the animation is updated'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“Speed”变量通过*左键单击*并将其拖动到“AnimGraph”中实时更新混合空间，并将变量连接到“Blendspace Player”函数的输入：![图11.25：现在您可以在每帧更新动画时使用Speed变量来更新混合空间
- en: '](img/B16183_11_25.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_25.jpg)'
- en: 'Figure 11.25: You can now use the Speed variable to update the Blend Space
    in every frame when the animation is updated'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25：现在您可以在每帧更新动画时使用Speed变量来更新混合空间
- en: Next, compile the animation blueprint.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编译动画蓝图。
- en: 'You now have the ability to update the Blend Space based on the speed of the
    player character. When you use `PIE`, you can see the character in `Idle` and
    in the `Walking` animation when you move:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以根据玩家角色的速度更新混合空间。当您使用“PIE”时，您可以看到角色在移动时处于“Idle”和“Walking”动画中：
- en: '![Figure 11.26: The player character is finally able to walk around in the
    level'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.26：玩家角色最终能够在关卡中四处走动'
- en: '](img/B16183_11_26.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_26.jpg)'
- en: 'Figure 11.26: The player character is finally able to walk around in the level'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26：玩家角色最终能够在关卡中四处走动
- en: Finally, the main character is using the movement animations based on movement
    speed. In the next activity, you will update the character movement component
    so that you can preview the character running animation from the Blend Space.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主角正在使用基于移动速度的移动动画。在下一个活动中，您将更新角色移动组件，以便可以从混合空间预览角色奔跑动画。
- en: 'Activity 11.02: Previewing the Running Animation In-Game'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.02：在游戏中预览奔跑动画
- en: With the animation blueprint updating and getting the speed of the player character,
    you are now able to preview the `Idle` and `Walking` animations in-game.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新动画蓝图并获取玩家角色的速度，您现在可以在游戏中预览“Idle”和“Walking”动画。
- en: In this activity, you will update the `CharacterMovement` component of the player
    character blueprint so that you can preview the `Running` animation in-game as
    well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将更新玩家角色蓝图的“CharacterMovement”组件，以便您还可以在游戏中预览“Running”动画。
- en: 'Perform the following steps to achieve this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现这一点：
- en: Navigate to, and open, the `BP_SuperSideScroller_MainCharacter` player character
    blueprint.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到并打开“BP_SuperSideScroller_MainCharacter”玩家角色蓝图。
- en: Access the `CharacterMovement` component.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问“CharacterMovement”组件。
- en: Modify the `Max Walk Speed` parameter to a value of `500.0` so that your character
    can move fast enough to blend its animation from the `Idle` to `Walking` and finally,
    to `Running`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“最大行走速度”参数修改为“500.0”，以便您的角色可以快速移动，从“空闲”到“行走”，最终到“奔跑”时混合其动画。
- en: At the end of this activity, you will have allowed the player character to reach
    a speed that allows you to preview the `Running` animation in-game.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动结束时，您将允许玩家角色达到一定速度，以便在游戏中预览“奔跑”动画。
- en: 'The expected output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 11.27: The player character running'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.27：玩家角色奔跑'
- en: '](img/B16183_11_27.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_27.jpg)'
- en: 'Figure 11.27: The player character running'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27：玩家角色奔跑
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网址找到此活动的解决方案：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Now that you have handled the player character movement blending from `Idle`
    to `Walk` and finally to `Run`, let's move on to the next step to add the functionality
    to allow the player character to move even quicker by sprinting.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经处理了玩家角色从“空闲”到“行走”，最终到“奔跑”的混合移动，让我们继续下一步，添加功能以允许玩家角色通过奔跑移动得更快。
- en: Input Bindings
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入绑定
- en: Every game requires input from the player, whether it is the keys on a keyboard
    such as *W*, *A*, *S*, and *D* for moving the player character, or the thumb sticks
    on a controller; this is what makes video games an interactive experience. Unreal
    Engine 4 allows us to map keyboard, mouse, gamepad, and other types of controls
    to labeled actions or axes that you can then reference in Blueprint or C++ to
    allow character or gameplay functionality to occur. It is important to point out
    that each unique action or axis mapping can have one or more key bindings, and
    that the same key binding can be used for multiple mappings. Input bindings are
    saved into an initialization file called `DefaultInput.ini` and can be found in
    the `Config` folder of your project directory.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都需要玩家的输入，无论是键盘上的按键，如*W*、*A*、*S*和*D*，用于移动玩家角色，还是控制器上的摇杆；这就是使视频游戏成为互动体验的原因。虚幻引擎4允许我们将键盘、鼠标、游戏手柄和其他类型的控件映射到标记的动作或轴上，然后您可以在蓝图或C++中引用这些动作或轴，以允许角色或游戏功能发生。重要的是要指出，每个独特的动作或轴映射可以有一个或多个按键绑定，并且同一个按键绑定可以用于多个映射。输入绑定保存在名为“DefaultInput.ini”的初始化文件中，并且可以在项目目录的“Config”文件夹中找到。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Input bindings can be edited directly from the `DefaultInput.ini` file or through
    `Project Settings` in the editor itself; the latter being more easily accessible
    and less error-prone when editing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输入绑定可以直接从“DefaultInput.ini”文件或通过编辑器中的“项目设置”进行编辑；后者在编辑时更容易访问，且更少出错。
- en: Let's add a new input binding for the player character's `Sprint` functionality.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为玩家角色的“奔跑”功能添加一个新的输入绑定。
- en: 'Exercise 11.04: Adding Input for Sprinting and Throwing'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.04：添加奔跑和投掷输入
- en: With the player character moving around the level, you will now implement a
    unique character class for the player character that derives from the base `SuperSideScrollerCharacter`
    C++ class. The reason to do this is so that you can easily differentiate between
    classes of the player character and the enemy later on, instead of relying solely
    on unique blueprint classes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着玩家角色在关卡中移动，您现在将为玩家角色实现一个独特的角色类，该类源自基本的“SuperSideScrollerCharacter”C++类。这样做的原因是，您可以轻松区分玩家角色和敌人的类，而不仅仅依赖于独特的蓝图类。
- en: While creating the unique C++ character class, you will implement the *sprinting*
    behavior to allow the player character to *walk* and *sprint* as desired.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建独特的C++角色类时，您将实现“奔跑”行为，以允许玩家角色根据需要“行走”和“奔跑”。
- en: 'Let''s begin by implementing the `Sprinting` mechanic by first adding the input
    binding for `Sprint`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过添加“奔跑”的输入绑定来实现“奔跑”机制：
- en: Navigate to the `Edit` option on the toolbar at the top of the editor and, from
    the drop-down list, select `Project Settings`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器顶部的工具栏上导航到“编辑”选项，然后从下拉列表中选择“项目设置”。
- en: Within `Project Settings`, navigate to the `Input` option under the `Engine`
    category on the left-hand side. By default, the `Side Scroller` template project
    provided by Unreal Engine comes with Action Mappings for `Jump` with the keys
    *W*, *Up Arrow Key*, *Space Bar*, and *Gamepad Face Button Bottom* bound to it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“项目设置”中，导航到左侧“引擎”类别下的“输入”选项。默认情况下，虚幻引擎提供的“Side Scroller”模板项目为“跳跃”提供了动作映射，键为*W*、*上箭头键*、*空格键*和*游戏手柄底部按钮*。
- en: 'Add new `Action Mapping` by *left-clicking* on the `+` button next to `Action
    Mappings`. Label this mapping `Sprint` and add two keys for its controls; `Left
    Shift` and `Gamepad Right Shoulder`. Please refer to the figure below for the
    updated bindings.![Figure 11.28: The Jump and Sprint Action Mappings applied to
    key bindings'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*左键单击*“动作映射”旁边的“+”按钮添加新的“动作映射”。将此映射标记为“奔跑”，并为其控件添加两个键；“左Shift”和“游戏手柄右肩”。请参考下面的图示以获取更新后的绑定。![图11.28：应用于按键绑定的跳跃和奔跑动作映射
- en: '](img/B16183_11_28.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_28.jpg)'
- en: 'Figure 11.28: The Jump and Sprint Action Mappings applied to key bindings'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28：应用于按键绑定的跳跃和奔跑动作映射
- en: With the `Sprint` input binding in place, you need to create a new C++ class
    for the player character based on the `SuperSideScroller` character class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有了“奔跑”输入绑定后，您需要为基于“SuperSideScroller”角色类的玩家角色创建一个新的C++类。
- en: Head back inside the editor, navigate to `File` and, from the drop-down list,
    select the `New C++ Class` option.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器，导航到“文件”，然后从下拉列表中选择“新建C++类”选项。
- en: 'The new player character class will inherit from the `SuperSideScrollerCharacter`
    parent class because this base class has a majority of the functionality needed
    for the player character. After selecting the parent class, *left-click* on `Next`.
    Please refer to the following image to see how to find the `SuperSideScrollerCharacter`
    class.![Figure 11.29: Selecting the SuperSideScrollerCharacter parent class'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的玩家角色类将继承自SuperSideScrollerCharacter父类，因为这个基类具有玩家角色所需的大部分功能。选择父类后，*左键单击*“下一步”。请参考以下图片，看看如何找到SuperSideScrollerCharacter类。![图11.29：选择SuperSideScrollerCharacter父类
- en: '](img/B16183_11_29.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_29.jpg)'
- en: 'Figure 11.29: Selecting the SuperSideScrollerCharacter parent class'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29：选择SuperSideScrollerCharacter父类
- en: Name this new class `SuperSideScroller_Player`. Leave the path as the default
    that Unreal Engine provides for you, unless you have a need to adjust the file
    directory of this new class. After naming the new class and selecting the directory
    to save the class in, *left-click* `Create Class`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新类命名为“SuperSideScroller_Player”。除非您有必要调整这个新类的文件目录，否则将路径保留为Unreal Engine为您提供的默认路径。在命名新类并选择要保存类的目录之后，*左键单击*“创建类”。
- en: After selecting `Create Class`, Unreal Engine will generate the source and header
    files for you and Visual Studio will automatically open these files. You will
    notice that both the header file and the source file are almost empty. This is
    OK because you are inheriting from the `SuperSideScrollerCharacter` class and
    much of the logic you want is done in that class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“创建类”后，Unreal Engine将为您生成源文件和头文件，并且Visual Studio将自动打开这些文件。您会注意到头文件和源文件几乎是空的。这没关系，因为您是从SuperSideScrollerCharacter类继承的，您想要的大部分逻辑都在那个类中完成了。
- en: 'In `SuperSideScroller_Player`, you will add only the functionality you need
    on top of what you inherit. You can view the line where the inheritance is taking
    place inside `SuperSideScroller_Player.h`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SuperSideScroller_Player中，您只会添加您需要的功能。您可以在SuperSideScroller_Player.h文件中查看继承正在发生的地方：
- en: '[PRE0]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class declaration is saying that the new `ASuperSideScroller_Player` class
    inherits from the `ASuperSideScrollerCharacter` class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明表示新的ASuperSideScroller_Player类继承自ASuperSideScrollerCharacter类。
- en: By completing this exercise, you were able to add the necessary `Input Binding`
    for the `Sprint` mechanic that can then be referenced in C++ and used to allow
    the player to sprint. Now that you have also created the C++ class for the player
    character, you can update the code with the `Sprint` functionality, but first
    you will need to update the `Blueprint` character and the animation blueprint
    to reference this new class. Let's do this in the next exercise.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您可以为“冲刺”机制添加必要的“输入绑定”，然后可以在C++中引用并用于允许玩家进行冲刺。现在您还创建了玩家角色的C++类，您可以更新代码以添加“冲刺”功能，但首先您需要更新“蓝图”角色和动画蓝图以引用这个新类。让我们在下一个练习中完成这个任务。
- en: What happens when you reparent a blueprint to a new class? Each blueprint inherits
    from a parent class. In most cases, this is `Actor`, but in the case of your character
    blueprint, its parent class is `SuperSideScrollerCharacter`. Inheriting from a
    parent class allows a blueprint to inherit the functionality and variables of
    that class so that logic can be reused on the blueprint level.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将蓝图重新设置为新类时会发生什么？每个蓝图都继承自一个父类。在大多数情况下，这是“Actor”，但在您的角色蓝图的情况下，它的父类是“SuperSideScrollerCharacter”。从父类继承允许蓝图继承该类的功能和变量，以便逻辑可以在蓝图级别上重用。
- en: For example, when inheriting from the `SuperSideScrollerCharacter` class, the
    blueprint inherits components such as the `CharacterMovement` component and the
    `Mesh` skeletal mesh component, that can then be modified in Blueprint.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当从SuperSideScrollerCharacter类继承时，蓝图会继承诸如CharacterMovement组件和Mesh骨骼网格组件之类的组件，然后可以在蓝图中进行修改。
- en: 'Exercise 11.05: Reparenting the Character Blueprint'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.05：重新设置角色蓝图的父类
- en: Now that you have created a new character class for the player character, you
    need to update the `BP_SuperSideScroller_MainCharacter` blueprint to use the `SuperSideScroller_Player`
    class as its parent class. If you don't, then any logic you add to the new class
    will not affect the character made in Blueprint.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为玩家角色创建了一个新的角色类，您需要更新“BP_SuperSideScroller_MainCharacter”蓝图，以使用“SuperSideScroller_Player”类作为其父类。如果不这样做，那么您添加到新类的任何逻辑都不会影响蓝图中创建的角色。
- en: 'Follow these steps to reparent the blueprint to the new character class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将蓝图重新设置为新的角色类：
- en: Navigate to `/Game/MainCharacter/Blueprints/` and open the `BP_SuperSideScroller_MainCharacter`
    blueprint.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“/Game/MainCharacter/Blueprints/”，并打开“BP_SuperSideScroller_MainCharacter”蓝图。
- en: Select the `File` option on the toolbar and, from the drop-down menu, select
    the `Reparent Blueprint` option.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏上选择“文件”选项，然后从下拉菜单中选择“重新设置父蓝图”选项。
- en: When selecting the `Reparent Blueprint` option, Unreal will ask for the new
    class to reparent the blueprint to. Search for `SuperSideScroller_Player` and
    select the option from the dropdown by *left-clicking*.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“重新设置父蓝图”选项时，Unreal会要求您为蓝图重新设置父类。搜索“SuperSideScroller_Player”，然后通过*左键单击*从下拉菜单中选择该选项。
- en: Once you select the new parent class for the blueprint, Unreal will reload the
    blueprint and recompile it, both of which will happen automatically for you.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为蓝图选择了新的父类，Unreal将重新加载蓝图并重新编译它，这两个过程都将自动进行。
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when reparenting blueprints to new parent classes because this can
    lead to compile errors or settings to be erased or reverted back to class defaults.
    Unreal Engine will display any warnings or errors that may occur after compiling
    the blueprint after reparenting to a new class. These warnings and errors usually
    occur if there is blueprint logic that references variables or other class members
    that no longer exist in the new parent class. Even if there are no compile errors,
    it is best to confirm that any logic or settings you have made to your blueprint
    are still present after the reparenting before moving on with your work.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在将蓝图重新父类化为新的父类时要小心，因为这可能导致编译错误或设置被擦除或恢复为类默认值。虚幻引擎将在将蓝图重新父类化为新类后显示任何可能发生的警告或错误。这些警告和错误通常发生在蓝图逻辑引用不再存在于新父类中的变量或其他类成员的情况下。即使没有编译错误，最好确认在重新父类化之后您对蓝图所做的任何逻辑或设置仍然存在，然后再继续工作。
- en: Now that your character blueprint is correctly reparented to the new `SuperSideScroller_Player`
    class, you need to also update the `AnimBP_SuperSideScroller_MainCharacter` animation
    blueprint to ensure that you are casting to the correct class when using the `Try
    Get Pawn Owner` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的角色蓝图已正确重新父类化为新的`SuperSideScroller_Player`类，您还需要更新`AnimBP_SuperSideScroller_MainCharacter`动画蓝图，以确保在使用`尝试获取所有者`函数时转换为正确的类。
- en: Next, navigate to the `/MainCharacter/Blueprints/` directory and open the `AnimBP_SuperSideScroller_MainCharacter`
    animation blueprint.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到`/MainCharacter/Blueprints/`目录，并打开`AnimBP_SuperSideScroller_MainCharacter`动画蓝图。
- en: 'Open `Event Graph`. From the `Return Value` of the `Try Get Pawn Owner` function,
    search for `Cast` to `SuperSideScroller_Player`:![Figure 11.30: Instead of casting
    to the base SuperSideScrollerCharacter class, you can cast to the new SuperSideScroller_Player
    class'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`事件图`。从`尝试获取所有者`函数的`返回值`中，搜索`转换`为`SuperSideScroller_Player`：![图11.30：与转换为基本SuperSideScrollerCharacter类不同，您可以转换为新的SuperSideScroller_Player类
- en: '](img/B16183_11_30.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_30.jpg)'
- en: 'Figure 11.30: Instead of casting to the base SuperSideScrollerCharacter class,
    you can cast to the new SuperSideScroller_Player class'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30：与转换为基本SuperSideScrollerCharacter类不同，您可以转换为新的SuperSideScroller_Player类
- en: 'You can then connect the output as a `SuperSideScroller_Player` cast to the
    `MainCharacter` variable. This works because the `MainCharacter` variable is of
    the `SuperSideScrollerCharacter` type and the new `SuperSideScroller_Player` class
    inherits from that class:![Figure 11.31: You can still use the MainCharacter variable
    because SuperSideScroller_Player is based on the SuperSideScrollerCharacter due
    to inheritance'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将输出连接为`SuperSideScroller_Player`转换为`MainCharacter`变量。这是因为`MainCharacter`变量是`SuperSideScrollerCharacter`类型，而新的`SuperSideScroller_Player`类继承自该类：![图11.31：您仍然可以使用MainCharacter变量，因为SuperSideScroller_Player基于SuperSideScrollerCharacter进行继承
- en: '](img/B16183_11_31.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_31.jpg)'
- en: 'Figure 11.31: You can still use the MainCharacter variable because SuperSideScroller_Player
    is based on the SuperSideScrollerCharacter due to inheritance'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31：您仍然可以使用MainCharacter变量，因为SuperSideScroller_Player基于SuperSideScrollerCharacter进行继承
- en: Now that both the `BP_SuperSideScroller_MainCharacter` character blueprint and
    the `AnimBP_SuperSideScroller_MainCharacter` animation blueprint are referencing
    your new `SuperSideScroller_Player` class, it is now safe to move forward into
    C++ and code the character sprint functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`BP_SuperSideScroller_MainCharacter`角色蓝图和`AnimBP_SuperSideScroller_MainCharacter`动画蓝图都引用了您的新`SuperSideScroller_Player`类，现在可以安全地进入C++并编写角色冲刺功能。
- en: 'Exercise 11.06: Coding the Character Sprint Functionality'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.06：编写角色冲刺功能
- en: With the new `SuperSideScroller_Player` class reference correctly implemented
    in blueprints following the previous exercise, it is time to start coding the
    functionality that will allow the player character to sprint.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一次练习中正确实现了新的`SuperSideScroller_Player`类引用后，现在是时候开始编写功能，允许玩家角色进行冲刺了。
- en: 'Perform the following steps to add the `Sprinting` mechanic to the character:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将`冲刺`机制添加到角色中：
- en: The first thing to take care of is the constructor of the `SuperSideScroller_Player`
    class. Navigate back to Visual Studio and open the `SuperSideScroller_Player.h`
    header file.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要处理的是`SuperSideScroller_Player`类的构造函数。返回Visual Studio并打开`SuperSideScroller_Player.h`头文件。
- en: 'You will use the `constructor` function later in this exercise to set initialized
    values for variables. For now, it will be an empty constructor. Make sure that
    the declaration is made under the `public` access modifier heading, as seen in
    the following code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在本练习的后面使用`构造函数`来为变量设置初始化值。现在，它将是一个空的构造函数。确保声明是在`public`访问修饰符标题下进行的，就像下面的代码中所示：
- en: '[PRE1]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the constructor declared, create the constructor function definition in
    the `SuperSideScroller_Player.cpp` source file:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数声明后，在`SuperSideScroller_Player.cpp`源文件中创建构造函数定义：
- en: '[PRE2]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the constructor in place, it's time to create the `SetupPlayerInputComponent`
    function so that you can use the key bindings created earlier to call functions
    within the `SuperSideScroller_Player` class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数就位后，现在可以创建`SetupPlayerInputComponent`函数，以便您可以使用之前创建的按键绑定来调用`SuperSideScroller_Player`类中的函数。
- en: The `SetupPlayerInputComponent` function is a function that the character class
    has built-in by default, so you need to declare it as a `virtual` function with
    the `override` specifier. This tells Unreal that you are using this function and
    intend to redefine its functionality in this new class. Make sure that the declaration
    is made under the `Protected` access modifier heading.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupPlayerInputComponent`函数是角色类默认内置的函数，因此您需要将其声明为带有`override`修饰符的`虚拟`函数。这告诉虚幻引擎您正在使用此函数，并打算在这个新类中重新定义其功能。确保声明是在`Protected`访问修饰符标题下进行的。'
- en: 'The `SetupPlayerInputComponent` function requires an object of the `UInputComponent`
    class to be passed into the function, like so:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetupPlayerInputComponent`函数需要将`UInputComponent`类的对象传递到函数中，如下所示：'
- en: '[PRE3]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UInputComponent* PlayerInputComponent` variable is inherited from the `UCharacter`
    base class that our `ASuperSideScroller_Player()` class derives from, and therefore,
    must be used as the input parameter of the `SetupPlayerInputComponent()` function.
    Using any other name will result in a compilation error.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`UInputComponent* PlayerInputComponent`变量是从我们的`ASuperSideScroller_Player()`类继承的`UCharacter`基类中继承的，因此必须用作`SetupPlayerInputComponent()`函数的输入参数。使用其他任何名称都将导致编译错误。'
- en: 'Now, in the source file, create the definition of the `SetupPlayerInputComponent`
    function. In the body of the function, we will use the `Super` keyword to call
    it:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在源文件中创建`SetupPlayerInputComponent`函数的定义。在函数的主体中，我们将使用`Super`关键字来调用它：
- en: '[PRE4]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Super` keyword enables us to call the `SetupPlayerInputComponent` parent
    method. With the `SetupPlayerInputComponent` function ready, you need to include
    the following header files in order to continue with this exercise without any
    compile errors:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Super`关键字使我们能够调用`SetupPlayerInputComponent`父方法。有了`SetupPlayerInputComponent`函数准备好了，您需要包含以下头文件，以便在继续进行此练习时不会出现任何编译错误：'
- en: '`#include "Components/InputComponent.h"`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "Components/InputComponent.h"`'
- en: '`#include "GameFramework/CharacterMovementComponent.h"`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "GameFramework/CharacterMovementComponent.h"`'
- en: 'You will need to include the header for the input component in order to bind
    the key mappings to the sprint functions you will be creating next. The header
    for the `Character Movement` component will be necessary for the sprint functions
    because you will be updating the `Max Walk Speed` parameter based on whether the
    player is sprinting. The following code is all of the headers that need to be
    included for the player character:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要包含输入组件的头文件，以便将键映射绑定到接下来将创建的冲刺功能上。`Character Movement`组件的头文件将对冲刺功能是必需的，因为您将根据玩家是否正在冲刺来更新`Max
    Walk Speed`参数。以下是所有需要包含的玩家角色的头文件：
- en: '[PRE5]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the necessary headers included in the source file of the `SuperSideScroller_Player`
    class, you can now create the sprint functions used to make the player character
    move faster. Let's begin by declaring the required variable and functions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Player`类的源文件中包含了必要的头文件后，您现在可以创建用于使玩家角色移动更快的冲刺功能。让我们首先声明所需的变量和函数。
- en: 'Under the `Private` access modifier in the header file of the `SuperSideScroller_Player`
    class, declare a new Boolean variable called `bIsSprinting`. This variable will
    be used as a failsafe in order to know for certain whether the player character
    is sprinting before making any changes to the movement speed:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Player`类的头文件中的`Private`访问修饰符下，声明一个名为`bIsSprinting`的新布尔变量。这个变量将被用作一个保险措施，以确切地知道玩家角色在进行任何移动速度更改之前是否正在冲刺：
- en: '[PRE6]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, declare two new functions, `Sprint();` and `StopSprinting();`. These
    two functions will not take any arguments and will not return anything. Declare
    the functions under the `Protected` access modifier:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明两个新函数，`Sprint();`和`StopSprinting();`。这两个函数不需要任何参数，也不返回任何内容。在`Protected`访问修饰符下声明这些函数：
- en: '[PRE7]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Sprint();` function will be called when the player *presses/holds* the
    `Sprint` keys mapping to the binding, and `StopSprinting()` will be called when
    the player *releases* the keys mapped to the binding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家*按住/释放*与绑定的`Sprint`键映射相对应的键时，将调用`Sprint();`函数，并且当玩家*释放*与绑定的键相对应的键时，将调用`StopSprinting()`函数。
- en: 'Start with the definition of the `Sprint();` function. In the source file of
    the `SuperSideScroller_Player` class, create the definition for this function,
    as shown here:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Sprint();`函数的定义开始。在`SuperSideScroller_Player`类的源文件中，创建此函数的定义，如下所示：
- en: '[PRE8]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within the function, you will first want to check the value of the `bIsSprinting`
    variable. If the player is `bIsSprinting` is `False`, then move forward with the
    rest of the function.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，您首先要检查`bIsSprinting`变量的值。如果玩家`bIsSprinting`为`False`，则继续执行函数的其余部分。
- en: 'Within the `If` statement, set the `bIsSprinting` variable to `True`. Then,
    you can access the `GetCharacterMovement()` function and modify the `MaxWalkSpeed`
    parameter. Set `MaxWalkSpeed` to `500.0f`. Remember that the `Maximum Axis Value`
    parameter of the movement Blend Space is `500.0f`. This means that the player
    character will reach the speed necessary to use the `Running` animation:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`If`语句内，将`bIsSprinting`变量设置为`True`。然后，您可以访问`GetCharacterMovement()`函数并修改`MaxWalkSpeed`参数。将`MaxWalkSpeed`设置为`500.0f`。请记住，移动混合空间的`Maximum
    Axis Value`参数为`500.0f`。这意味着玩家角色将达到使用`Running`动画所需的速度：
- en: '[PRE9]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `StopSprinting()` function will look almost identical to the `Sprint()`
    function you just wrote, but it works in the opposite manner. You first want to
    check whether the player *is* sprinting, meaning that `bIsSprinting` is `True`.
    If so, move forward with the rest of the function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopSprinting()`函数几乎与您刚刚编写的`Sprint()`函数相同，但它的工作方式相反。您首先要检查玩家是否正在冲刺，也就是`bIsSprinting`为`True`。如果是，就继续执行函数的其余部分。'
- en: 'Inside the `If` statement, set `bIsSprinting` to `False`. Then, access the
    `GetCharacterMovement()` function to modify `MaxWalkSpeed`. Set `MaxWalkSpeed`
    back to `300.0f`, the default speed for the player character walking. This means
    that the player character will reach only the speed necessary for the `Walking`
    animation:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`If`语句内，将`bIsSprinting`设置为`False`。然后，访问`GetCharacterMovement()`函数来修改`MaxWalkSpeed`。将`MaxWalkSpeed`设置回`300.0f`，这是玩家角色行走的默认速度。这意味着玩家角色只会达到`Walking`动画所需的速度：
- en: '[PRE10]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you have the functions needed for sprinting, it is time to bind these
    functions to the action mappings you created earlier. In order to do this, perform
    the following steps within the `SetupPlayerInputComponent` function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了需要进行冲刺的功能，是时候将这些功能绑定到您之前创建的动作映射上了。为了做到这一点，在`SetupPlayerInputComponent`函数中执行以下步骤。
- en: Let's begin by binding the `Sprint()` function. Inside the `SetupPlayerInputComponent`
    function, use the `PlayerInputComponent` variable that is passed to the function
    so as to call the `BindAction` function.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始绑定`Sprint()`函数。在`SetupPlayerInputComponent`函数内部，使用传递给函数的`PlayerInputComponent`变量来调用`BindAction`函数。
- en: 'The parameters we need for `BindAction` are the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`BindAction`的参数如下：
- en: The name of the action mapping as written in `Project Settings` that you set
    up earlier in this exercise, in this case, `Sprint`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Project Settings`中写入的动作映射的名称，这是您在此练习中之前设置的，这种情况下是`Sprint`。
- en: The enumerator value of the `EInputEvent` type that you want to use for this
    binding; in this case you will use `IE_Pressed` because this binding will be for
    when the `Sprint` key(s) are pressed.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EInputEvent`类型的枚举值，您想要用于此绑定；在这种情况下，您将使用`IE_Pressed`，因为这个绑定将是当按下`Sprint`键时。'
- en: '[PRE11]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will do the same thing for the `StopSprinting()` function, but this time
    you need to use the `IE_Released` enumerator value, and reference the `StopSprinting`
    function:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将对`StopSprinting()`函数做同样的事情，但这次您需要使用`IE_Released`枚举值，并引用`StopSprinting`函数：
- en: '[PRE12]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With `Action Mappings` bound to the sprint functions, the last thing you need
    to do is set default initialized values of the `bIsSprinting` variable and the
    `MaxWalkSpeed` parameter from the `Character Movement` component.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Action Mappings`绑定到奔跑功能，您需要做的最后一件事是设置`bIsSprinting`变量和`Character Movement`组件的`MaxWalkSpeed`参数的默认初始化值。
- en: Inside the `constructor` function in the source file of your `SuperSideScroller_Player`
    class, add the `bIsSprinting = false` line. This variable is constructed as false
    because the player character should not be sprinting by default.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`SuperSideScroller_Player`类的源文件中的`constructor`函数中，添加`bIsSprinting = false`行。这个变量被构造为false，因为玩家角色默认情况下不应该在奔跑。
- en: 'Finally, set the `MaxWalkSpeed` parameter of the character movement component
    to `300.0f` by adding the line `GetCharacterMovement()->MaxWalkSpeed = 300.0f`.
    Please review the following code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过添加一行`GetCharacterMovement()->MaxWalkSpeed = 300.0f`，将角色移动组件的`MaxWalkSpeed`参数设置为`300.0f`。请查看以下代码：
- en: '[PRE13]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the initialization of the variables added to the constructor, the `SuperSideScroller_Player`
    class is done, for now. Return to Unreal Engine and *left-click* on the `Compile`
    button on the toolbar. This will recompile the code and perform a hot-reload of
    the editor.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在构造函数中初始化变量，`SuperSideScroller_Player`类现在已经完成。返回到虚幻引擎，*左键单击*工具栏上的`Compile`按钮。这将重新编译代码并执行编辑器的热重载。
- en: After recompiling and hot-reloading the editor, you can Play-In-Editor and see
    the fruits of your labor. The base movement behavior is the same as before, but
    now if you hold *Left Shift* or *Gamepad Right Shoulder* on a controller, the
    player character will sprint and begin to play the `Running` animation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译和热重载编辑器后，您可以在编辑器中进行播放，并看到您努力的成果。基本移动行为与以前相同，但现在如果您按住*左Shift*或*游戏手柄右肩*，玩家角色将奔跑并开始播放`Running`动画。
- en: '![Figure 11.32: The player character can now sprint'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.32：玩家角色现在可以奔跑'
- en: '](img/B16183_11_32.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_32.jpg)'
- en: 'Figure 11.32: The player character can now sprint'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32：玩家角色现在可以奔跑
- en: With the player character able to sprint, let's move on to the next activity,
    where you will implement the base `Throw` functionality in a very similar way.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色能够奔跑后，让我们继续下一个活动，在这个活动中，您将以非常相似的方式实现基本的`Throw`功能。
- en: 'Activity 11.03: Implementing the Throwing Input'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.03：实现投掷输入
- en: One of the features included with this game is the ability for the player to
    throw projectiles at the enemy. You won't be creating the projectile or implementing
    the animation in this chapter, but you will set up the key bindings and the C++
    implementation for use in the next chapter.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏包含的一个功能是玩家能够向敌人投掷抛射物。在本章中，您不会创建抛射物或实现动画，但您将设置按键绑定和C++实现，以便在下一章中使用。
- en: In this activity, you need to set up the key bindings for the `Throw` projectile
    functionality and implement a debug log in C++ for when the player presses the
    key(s) mapped to `Throw` by doing the following.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您需要为`Throw`投射功能设置按键绑定，并在C++中实现调试日志，当玩家按下与`Throw`映射的按键时，执行以下操作。
- en: Add a new `Throw` input to `Project Settings` in the input binding. Name this
    binding `ThrowProjectile` and bind it to *Left-Mouse Button* and *Gamepad Right
    Trigger*.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入绑定中的`Project Settings`中添加一个新的`Throw`输入。将此绑定命名为`ThrowProjectile`，并将其绑定到*左鼠标按钮*和*游戏手柄右扳机*。
- en: Within Visual Studio, add a new function to the header file of `SuperSideScroller_Player`.
    Name this function `ThrowProjectile()`. This will be a void function without parameters.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，向`SuperSideScroller_Player`的头文件中添加一个新的函数。将这个函数命名为`ThrowProjectile()`。这将是一个没有参数的void函数。
- en: Create the definition in the source file of the `SuperSideScroller_Player` class.
    In the definition of this function, use `UE_LOG` to print a message letting you
    know that the function is being called successfully.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Player`类的源文件中创建定义。在这个函数的定义中，使用`UE_LOG`打印一条消息，让您知道函数被成功调用。
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about `UE_LOG` here: [https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里了解更多关于`UE_LOG`的信息：[https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime)。
- en: The expected result by the end of this activity is that when you use the *left
    mouse button* or the *gamepad right trigger*, a log will appear in the `Output
    Log`, letting you know that the `ThrowProjectile` function is being called successfully.
    You will use this function later on to spawn your projectile.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动结束时的预期结果是，当您使用*左鼠标按钮*或*游戏手柄右扳机*时，`输出日志`中将出现一条日志，让您知道`ThrowProjectile`函数被成功调用。稍后您将使用这个函数来生成您的抛射物。
- en: 'The expected output is as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 11.33: The expected output log'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.33：预期的输出日志'
- en: '](img/B16183_11_33.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_33.jpg)'
- en: 'Figure 11.33: The expected output log'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33：预期的输出日志
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在这里找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: With this activity complete, you now have functionality in-place for when you
    create the player projectile in *Chapter 13*, *Enemy Artificial Intelligence*.
    You also now have the knowledge and experience of adding new key mappings to your
    game, and implementing functionality in C++ that utilizes these mappings to enable
    gameplay functionality. Now, you will continue with updating player character
    movement to allow the jumping animation to play correctly when the player jumps.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，您现在已经在*第13章* *敌人人工智能*中创建了玩家投射物的功能。您现在也已经掌握了向游戏添加新的键映射的知识和经验，并且实现了利用这些映射来启用游戏功能的C++功能。现在，您将继续更新玩家角色移动，以允许玩家跳跃时正确播放跳跃动画。
- en: Animation State Machines
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画状态机
- en: Now, let's get to know what state machines are in the context of Unreal Engine
    4 and in animation. State machines are a means of categorizing an animation, or
    sets of animations, into their own state. A state can be thought of as a condition
    that the player character is in at a specific time. Is the player currently walking?
    Is the player jumping? In many third-person games such as *The Last of Us*, this
    is the separation of movement, jumping, crouching, and climbing animations into
    their own state. Each state is then accessible when certain conditions are met
    while the game is played. Conditions can include whether the player is jumping,
    the speed of the player character, and whether or not the player is in the crouched
    state. The job of the state machine is to transition between each state using
    logical decisions called **Transition Rules**. When you create multiple states
    with multiple transition rules that intertwine with one another, the state machine
    begins to look like a web.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下在虚幻引擎4和动画中状态机的概念。状态机是将动画或一组动画分类到它们自己的状态中的一种方式。状态可以被认为是玩家角色在特定时间内的条件。玩家当前是在走路吗？玩家在跳跃吗？在许多第三人称游戏中，比如*最后的生还者*，这是将移动、跳跃、蹲下和攀爬动画分离到它们自己的状态中。每个状态在游戏进行时都是可访问的。条件可以包括玩家是否在跳跃、玩家角色的速度以及玩家是否处于蹲下状态。状态机的工作是使用称为**转换规则**的逻辑决策在各个状态之间进行转换。当您创建多个状态和相互交织的多个转换规则时，状态机开始看起来像一个网络。
- en: Please refer to the following image to see how the state machine looks for the
    `ThirdPerson_AnimBP` animation blueprint.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图片，查看`ThirdPerson_AnimBP`动画蓝图的状态机外观。
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A general overview of state machines can be found here: [https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.html)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到状态机的一般概述：[https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.html)
- en: '![Figure 11.34: The state machine of ThirdPerson_AnimBP that is included with
    the SideScroller project template'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.34：ThirdPerson_AnimBP的状态机，包含在SideScroller项目模板中'
- en: '](img/B16183_11_34.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_34.jpg)'
- en: 'Figure 11.34: The state machine of ThirdPerson_AnimBP that is included with
    the SideScroller project template'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34：ThirdPerson_AnimBP的状态机，包含在SideScroller项目模板中
- en: In the case of the state machine for the player character, this state machine
    will handle the states of default player movement and jumping. Currently, you
    have the player character animating simply by using a Blend Space that is controlled
    by the speed of the character. What you will do in the next exercise is create
    a new state machine and move the movement Blend Space logic into its own state
    within that state machine. Let's begin by creating the new state machine.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家角色的状态机，这个状态机将处理默认玩家移动和跳跃的状态。目前，玩家角色通过使用由角色速度控制的混合空间来简单地进行动画。在下一个练习中，您将创建一个新的状态机，并将移动混合空间逻辑移动到该状态机内的自己状态。让我们开始创建新的状态机。
- en: 'Exercise 11.07: Player Character Movement and Jump State Machine'
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.07：玩家角色移动和跳跃状态机
- en: In this exercise, you will implement a new animation state machine and integrate
    the existing movement Blend Space into the state machine. Additionally, you will
    set up the states for when the player jump starts, and for when the player is
    in the air during that jump.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将实现一个新的动画状态机，并将现有的移动混合空间集成到状态机中。此外，您将设置玩家跳跃开始时的状态，以及玩家在跳跃期间的状态。
- en: 'Let''s start by adding this new state machine:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加这个新状态机开始：
- en: Navigate to the `/MainCharacter/Blueprints/` directory and open the `AnimBP_SuperSideScroller_MainCharacter`
    animation blueprint.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/MainCharacter/Blueprints/`目录，并打开`AnimBP_SuperSideScroller_MainCharacter`动画蓝图。
- en: In `AnimGraph`, *right-click* in the empty space of the graph and search for
    `state machine` inside the context-sensitive search to find the `Add New State
    Machine` option. Name this new state machine `Movement`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AnimGraph`中，在图表的空白处*右键单击*，并在上下文敏感搜索中搜索`state machine`，以找到`Add New State Machine`选项。将这个新状态机命名为`Movement`。
- en: 'Now, instead of plugging the output pose of the `SideScroller_IdleRun` Blend
    Space, we can connect the output post of the new state machine, `Movement`, to
    the output pose of the animation:![Figure 11.35: The new Movement state machine
    replaces the old Blend Space'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以连接新状态机`Movement`的输出姿势到动画的输出姿势，而不是连接`SideScroller_IdleRun`混合空间的输出姿势：![图11.35：新的Movement状态机替换了旧的混合空间
- en: '](img/B16183_11_35.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_35.jpg)'
- en: 'Figure 11.35: The new Movement state machine replaces the old Blend Space'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.35：新的Movement状态机替换了旧的混合空间
- en: Connecting an empty state machine into the `Output Pose` of the animation blueprint
    will result in the warnings displayed below. All this means is that there is nothing
    happening within that state machine and that the result will be invalid to `Output
    Pose`. Don't worry; you will fix this next.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 将空状态机连接到动画蓝图的`Output Pose`将导致显示下面的警告。这意味着在该状态机中没有任何操作，结果将无效到`Output Pose`。不要担心；您将在下一步中解决这个问题。
- en: '![Figure 11.36: The empty state machine results in compile warnings'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.36：空状态机导致编译警告'
- en: '](img/B16183_11_36.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_36.jpg)'
- en: 'Figure 11.36: The empty state machine results in compile warnings'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.36：空状态机导致编译警告
- en: '*Double left-click* on the `Movement` state machine to open the state machine
    itself. The image below shows what this looks like.![Figure 11.37: This is the
    empty state machine that is created'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*`Movement`状态机以打开状态机本身。下面的图像显示了这是什么样子。![图11.37：这是创建的空状态机'
- en: '](img/B16183_11_37.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_37.jpg)'
- en: 'Figure 11.37: This is the empty state machine that is created'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.37：这是创建的空状态机
- en: You will start by adding a new state that will handle what the character was
    doing before; `Idle`, `Walking`, and `Running`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先添加一个新状态，该状态将处理角色之前的操作；`空闲`，`行走`和`奔跑`。
- en: 'From the `Entry` point, *left-click* and drag out to open the context-sensitive
    search. You will notice that there are only two options – `Add Conduit` and `Add
    State`. For right now, you will add a new state and name this state `Movement`.
    Refer to the following images to see the `Movement` state created.![Figure 11.38:
    Inside the state machine, you need to add a new state that will handle the movement
    Blend Space you created earlier'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Entry`点，*左键单击*并拖动以打开上下文敏感搜索。您会注意到只有两个选项-`添加导管`和`添加状态`。现在，您将添加一个新状态并将此状态命名为`Movement`。请参考以下图像，查看已创建的`Movement`状态。![图11.38：在状态机内部，您需要添加一个新状态，该状态将处理您之前创建的移动混合空间
- en: '](img/B16183_11_38.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_38.jpg)'
- en: 'Figure 11.38: Inside the state machine, you need to add a new state that will
    handle the movement Blend Space you created earlier'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38：在状态机内部，您需要添加一个新状态，该状态将处理您之前创建的移动混合空间
- en: '![Figure 11.39: The new Movement state'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.39：新的移动状态'
- en: '](img/B16183_11_39.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_39.jpg)'
- en: 'Figure 11.39: The new Movement state'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39：新的移动状态
- en: 'Copy and paste the logic you had where you connected the `Speed` variable to
    the `SideScroller_IdleRun` Blend Space into the new `Movement` state created in
    the last step. Connect it to the `Result` pin of the `Output Animation Pose` node
    of this state:![Figure 11.40: Connecting the output pose of the Blend Space'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴您在上一步中连接`Speed`变量到`SideScroller_IdleRun`混合空间的逻辑到新创建的`Movement`状态。将其连接到此状态的`Output
    Animation Pose`节点的`Result`引脚：![图11.40：连接混合空间的输出姿势
- en: to the output pose of this state
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到此状态的输出姿势
- en: '](img/B16183_11_40.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_40.jpg)'
- en: 'Figure 11.40: Connecting the output pose of the Blend Space to the output pose
    of this state'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40：将混合空间的输出姿势连接到此状态的输出姿势
- en: Now, if you recompile the animation blueprint, you will notice first that the
    warnings you saw earlier are now gone. This is because you added a new state that
    outputs an animation to `Output Animation Pose` instead of having an empty state machine.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果重新编译动画蓝图，您会注意到首先看到的警告现在已经消失。这是因为您添加了一个新状态，该状态将动画输出到`Output Animation Pose`，而不是拥有一个空状态机。
- en: By completing this exercise, you have constructed your very first state machine.
    Although it is a very simple one, you are now telling the character to enter and
    use the `Movement` state by default. If you now PIE, you will see that the player
    character is now moving around like he was earlier prior to making the state machine.
    This means that your state machine is functioning, and you can continue to the
    next step, which will be adding the initial states required for jumping. Let's
    start by creating the `JumpStart` state.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经构建了您的第一个状态机。虽然这是一个非常简单的状态机，但现在您正在告诉角色默认进入并使用`Movement`状态。如果您现在PIE，您会看到玩家角色现在像之前制作状态机之前一样移动。这意味着您的状态机正在运行，并且您可以继续下一步，即添加跳跃所需的初始状态。让我们从创建`JumpStart`状态开始。
- en: Transition Rules
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换规则
- en: Conduits are a way of telling each state the conditions under which it can transition
    from one state to another. In this case, a transition rule is created as a connection
    between the `Movement` and `JumpStart` states. This is indicated by the directional
    arrow of the connection between the states again. The tool-tip mentions the term
    *transition rule*, and this means that you need to define how the transition between
    these states will happen, using a Boolean value to do so.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 导管是告诉每个状态可以在何种条件下从一个状态转换到另一个状态的一种方式。在这种情况下，转换规则被创建为`Movement`和`JumpStart`状态之间的连接。这由连接状态之间的方向箭头指示。工具提示提到术语*转换规则*，这意味着您需要定义这些状态之间的转换如何发生，使用布尔值来实现。
- en: '![Figure 11.41: There needs to be a transition rule to go from movement'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.41：需要有一个转换规则从移动'
- en: to the start of the character's jump
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 到角色跳跃的开始
- en: '](img/B16183_11_41.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_41.jpg)'
- en: 'Figure 11.41: There needs to be a transition rule to go from movement to the
    start of the character''s jump'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.41：需要有一个转换规则从移动到角色跳跃的开始
- en: 'Exercise 11.08: Adding States and Transition Rules to the State Machine'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.08：向状态机添加状态和转换规则
- en: In the case of transitioning from the player character's default movement Blend
    Space to the beginning of the jump animation, you will need to know when the player
    decides to jump. This can be done using a useful function called `IsFalling` from
    the `Character Movement` component of the player character. You will want to track
    whether the player is currently falling in order to transition in and out of jumping.
    The best way to do this is to store the result of the `IsFalling` function in
    its own variable, just like how you did when tracking the player's speed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在从玩家角色的默认移动混合空间过渡到跳跃动画的情况下，您需要知道玩家何时决定跳跃。这可以使用玩家角色的`Character Movement`组件中的一个有用函数`IsFalling`来完成。您将希望跟踪玩家当前是否正在下落，以便在跳跃中进行过渡。这样做的最佳方式是将`IsFalling`函数的结果存储在自己的变量中，就像您在跟踪玩家速度时所做的那样。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Back in the overview of the state machine itself, *left-click* and drag from
    the edge of the `Movement` state to open the context-sensitive menu again.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到状态机的概述，*左键单击*并从`Movement`状态的边缘拖动以再次打开上下文敏感菜单。
- en: 'Select the option to `Add State` and name this state `JumpStart`. When you
    do this, Unreal will automatically connect these states and implement an empty
    `Transition Rule` for you:![Figure 11.42: The Transition Rule that Unreal automatically
    creates'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Add State`选项并将此状态命名为`JumpStart`。当您这样做时，虚幻将自动连接这些状态并为您实现一个空的`Transition Rule`：![图11.42：虚幻自动创建的Transition
    Rule
- en: for you when connecting two states
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接两个状态时
- en: '](img/B16183_11_42.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_42.jpg)'
- en: 'Figure 11.42: The Transition Rule that Unreal automatically creates for you
    when connecting two states'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.42：虚幻自动为您连接两个状态时创建的Transition Rule
- en: 'Navigate back to `Event Graph` inside the animation blueprint, where you had
    used the Event Blueprint update animation event to store the `Speed` of the player
    character.![Figure 11.43: EventGraph of the SuperSideScroller player animation
    blueprint'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到动画蓝图中的`Event Graph`，在那里您使用了事件蓝图更新动画事件来存储玩家角色的`Speed`。![图11.43：SuperSideScroller玩家动画蓝图的EventGraph
- en: '](img/B16183_11_43.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_43.jpg)'
- en: 'Figure 11.43: EventGraph of the SuperSideScroller player animation blueprint'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.43：SuperSideScroller玩家动画蓝图的EventGraph
- en: 'Create a getter variable for the `MainCharacter` and access the `Character
    Movement` component. From the `Character Movement` component, *left-click* and
    drag to access the context-sensitive menu. Search for `IsFalling`:![Figure 11.44:
    How to find the IsFalling function'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`MainCharacter`创建一个getter变量并访问`Character Movement`组件。从`Character Movement`组件，*左键单击*并拖动以访问上下文敏感菜单。搜索`IsFalling`：![图11.44：如何找到IsFalling函数
- en: '](img/B16183_11_44.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_44.jpg)'
- en: 'Figure 11.44: How to find the IsFalling function'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.44：如何找到IsFalling函数
- en: 'The character movement component can tell you whether the player character
    is currently in the air with the help of the `IsFalling` function:![Figure 11.45:
    The character movement component showing the state of player character'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色移动组件可以通过`IsFalling`函数告诉您玩家角色当前是否在空中：![图11.45：角色移动组件显示玩家角色的状态
- en: '](img/B16183_11_45.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_45.jpg)'
- en: 'Figure 11.45: The character movement component showing the state of player
    character'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.45：角色移动组件显示玩家角色的状态
- en: 'From the `Return Value` Boolean of the `IsFalling` function, *left-click* and
    drag to search for the `Promote to Variable` option from the context-sensitive
    menu. Name this variable `bIsInAir`. When promoting to a variable, the Return
    Value output pin should automatically connect to the input pin of the newly promoted
    variable. If it does not, remember to connect them.![Figure 11.46: A new variable,
    bIsInAir, that contains the value of the IsFalling function'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`IsFalling`函数的`Return Value`布尔值，*左键单击*并拖动以搜索上下文敏感菜单中的`Promote to Variable`选项。将此变量命名为`bIsInAir`。在提升为变量时，返回值输出针应自动连接到新提升的变量的输入针。如果没有，请记得连接它们。![图11.46：包含IsFalling函数值的新变量bIsInAir
- en: '](img/B16183_11_46.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_46.jpg)'
- en: 'Figure 11.46: A new variable, bIsInAir, that contains the value of the IsFalling
    function'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.46：包含IsFalling函数值的新变量bIsInAir
- en: Now that you are storing the state of the player and whether or not they are
    falling, this is the perfect candidate for the transition rule between the `Movement`
    and `JumpStart` states.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在存储玩家的状态以及他们是否正在下落，这是`Movement`和`JumpStart`状态之间的过渡规则的完美候选者。
- en: 'In the `Movement State` machine, *double left-click* on the `Transition Rule`
    to enter its graph. You will find only one output node, `Result`, with the parameter
    `Can Enter Transition`. All you need to do here is use the `bIsInAir` variable
    and connect it to that output. Now, the `Transition Rule` is saying that if the
    player is in the air, the transition between the `Movement` state and the `JumpStart`
    states can happen.![Figure 11.47: When in the air, the player will transition
    to the start of the jumping animation'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Movement State`机器中，*双击*`Transition Rule`进入其图表。您将只找到一个输出节点`Result`，带有参数`Can
    Enter Transition`。在这里，您只需要使用`bIsInAir`变量并将其连接到该输出。现在，`Transition Rule`表示如果玩家在空中，则可以发生`Movement`状态和`JumpStart`状态之间的过渡。![图11.47：当在空中时，玩家将过渡到跳跃动画的开始
- en: '](img/B16183_11_47.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_47.jpg)'
- en: 'Figure 11.47: When in the air, the player will transition to the start of the
    jumping animation'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.47：当在空中时，玩家将过渡到跳跃动画的开始
- en: With `Transition Rule` in place between the `Movement` and `JumpStart` states
    ready, all that is left to do is to tell the `JumpStart` state which animation
    to use.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Movement`和`JumpStart`状态之间放置了`Transition Rule`后，剩下的就是告诉`JumpStart`状态使用哪个动画。
- en: 'From the state machine graph, *double left-click* on the `JumpStart` state
    to enter its graph. From `Asset Browser`, *left-click* and drag the `JumpingStart`
    animation to the graph:![Figure 11.48: Make sure to have the JumpingStart animation
    selected in Asset Browser before left-clicking and dragging it into the state'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态机图中，*双击*“JumpStart”状态以进入其图表。从“资产浏览器”中，*左键单击*并将“JumpingStart”动画拖到图表中：![图11.48：在左键单击并将其拖入状态之前，确保在资产浏览器中选择了JumpingStart动画
- en: '](img/B16183_11_48.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_48.jpg)'
- en: 'Figure 11.48: Make sure to have the JumpingStart animation selected in Asset
    Browser before left-clicking and dragging it into the state'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.48：在左键单击并将其拖入状态之前，确保在资产浏览器中选择了JumpingStart动画
- en: 'Connect the output of the `Play JumpingStart` node to the `Result` pin of the
    `Output Animation Pose` node:![Figure 11.49: Connecting the JumpingStart animation
    to the Output'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Play JumpingStart”节点的输出连接到“Output Animation Pose”节点的“Result”引脚：![图11.49：将JumpingStart动画连接到输出
- en: Animation Pose of the JumpStart state
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: JumpStart状态的动画姿势
- en: '](img/B16183_11_49.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_49.jpg)'
- en: 'Figure 11.49: Connecting the JumpingStart animation to the Output Animation
    Pose of the JumpStart state'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.49：将JumpingStart动画连接到JumpStart状态的输出动画姿势
- en: Before you can move forward with the next state, there are settings that need
    to be changed on the `JumpingStart` animation node.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个状态之前，需要更改“JumpingStart”动画节点上的设置。
- en: '*Left-click* on the `Play JumpingStart` animation node and update the `Details`
    panel to have the following settings:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*“Play JumpingStart”动画节点，并更新“详细信息”面板以具有以下设置：'
- en: '`Loop Animation = False`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “循环动画=假”
- en: '`Play Rate = 2.0`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “播放速率=2.0”
- en: Please refer to the following figure to see the final settings for the `Play
    JumpingStart` animation node.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表，查看“Play JumpingStart”动画节点的最终设置。
- en: '![Figure 11.50: Due to the slowness of the JumpStart animation, increasing
    the play rate will result in a smoother jumping animation overall'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.50：由于JumpStart动画的缓慢，增加播放速率将导致整体跳跃动画更加流畅'
- en: '](img/B16183_11_50.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_50.jpg)'
- en: 'Figure 11.50: Due to the slowness of the JumpStart animation, increasing the
    play rate will result in a smoother jumping animation overall'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.50：由于JumpStart动画的缓慢，增加播放速率将导致整体跳跃动画更加流畅
- en: You are setting the `Loop Animation` parameter to `False` because there is no
    reason that this animation should loop; it should only play once in any case.
    The only way that this animation would loop is if the player character is somehow
    stuck in this state, but this will never happen because of the next state you
    will create. The reason for setting `Play Rate` to `3.0` is because the animation
    itself, `JumpingStart`, is too long for the purposes of the game you are making.
    The animation has the character bend their knees drastically, and jump upward
    over the course of more than a second. For the `JumpStart` state, you want the
    character to play this animation quicker so that it is more fluid and offers a
    smoother transition to the next state; the `JumpLoop`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您将将“循环动画”参数设置为“False”，因为没有理由让这个动画循环；无论如何它都应该只播放一次。这个动画循环的唯一方式是玩家角色在这个状态下被卡住，但由于您将创建的下一个状态，这永远不会发生。将“播放速率”设置为“3.0”的原因是因为动画本身，“JumpingStart”，对于您正在制作的游戏来说太长了。动画让角色急剧弯曲膝盖，并在一秒多的时间内向上跳跃。对于“JumpStart”状态，您希望角色更快地播放这个动画，以使其更流畅，并提供更平滑的过渡到下一个状态；“JumpLoop”。
- en: Once the player character has begun the `JumpStart` animation, there is a point
    in time during that animation where the player is in the air and should transition
    to a new state. This new state will loop until the player is no longer in the
    air and can transition into the final state of ending the jump. Next, let's create
    this new state that will transition from the `JumpStart` state.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家角色开始“JumpStart”动画，动画中会有一个时间点，此时玩家在空中，并应该过渡到一个新状态。这个新状态将循环，直到玩家不再在空中，并可以过渡到结束跳跃的最终状态。接下来，让我们创建这个新状态，它将从“JumpStart”状态过渡。
- en: 'From the state machine graph, *left-click* and drag from the `JumpStart` state
    and select the `Add State` option. Name this new state `JumpLoop`. As before,
    Unreal will automatically provide you with a `Transition Rule` between these states
    that you will add to in the next exercise. Finally, recompile the Animation Blueprint
    and ignore any warnings that may appear under Compiler Results.![Figure 11.51:
    Creating another state that will handle the animation of the character while in
    the air after the initial jump start'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态机图中，*左键单击*并从“JumpStart”状态拖动并选择“添加状态”选项。将此新状态命名为“JumpLoop”。与以前一样，虚幻将自动为您提供这些状态之间的“转换规则”，您将在下一个练习中添加。最后，重新编译动画蓝图，并忽略编译器结果下可能出现的任何警告。![图11.51：创建另一个状态，将处理角色在初始跳跃后空中的动画
- en: '](img/B16183_11_51.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_51.jpg)'
- en: 'Figure 11.51: Creating another state that will handle the animation of the
    character while in the air after the initial jump start'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.51：创建另一个状态，将处理角色在初始跳跃后空中的动画
- en: By completing this exercise, you have added and connected your own states for
    `JumpStart` and `JumpLoop`. Each of these states is connected via a `Transition
    Rule` and you now have a better understanding of how states within a state machine
    transition from one to another via the rules established in each transition rule.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经为“JumpStart”和“JumpLoop”添加并连接了自己的状态。这些状态通过“转换规则”连接，现在您对状态机中的状态如何通过每个转换规则中建立的规则从一个状态过渡到另一个状态有了更好的理解。
- en: In the next exercise, you will look more into how to transition from the `JumpStart`
    state to the `JumpLoop` state via a function, `Time Remaining Ratio`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将更深入地了解如何通过函数“剩余时间比例”从“JumpStart”状态过渡到“JumpLoop”状态。
- en: 'Exercise 11.09: Time Remaining Ratio Function'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.09：剩余时间比例函数
- en: In order for the `JumpStart` state to smoothly transition to the `JumpLoop`
    state, you need to take a moment to think exactly how you want this transition
    to work. Based on how the `JumpStart` and `JumpLoop` animations work, it is best
    to transition in the `JumpLoop` animation after a specified set of time has elapsed
    on the `JumpStart` animation. That way, the `JumpLoop` state plays smoothly after
    `X` seconds of the `JumpStart` animation playing.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使“跳跃开始”状态顺利过渡到“跳跃循环”状态，您需要花一点时间思考确切地想要这个过渡如何工作。基于“跳跃开始”和“跳跃循环”动画的工作方式，最好在“跳跃开始”动画播放一定时间后过渡到“跳跃循环”动画。这样，“跳跃循环”状态就会在“跳跃开始”动画播放“X”秒后平稳播放。
- en: 'Perform the following steps to achieve this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现这一点：
- en: '*Double left-click* on the `Transition Rule` between `JumpStart` and `JumpLoop`
    to open its graph. The `Transition Rule` you will apply here is to check how much
    time is remaining from the `JumpingStart` animation. This is done because a certain
    percentage of time remains in the `JumpingStart` animation, and you can safely
    assume that the player is in the air and is ready to transition to the `JumpingLoop`
    animation state.'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“跳跃开始”和“跳跃循环”之间的“过渡规则”以打开其图表。您将应用的“过渡规则”是检查“跳跃开始”动画剩余多少时间。这是因为“跳跃开始”动画还剩下一定比例的时间，您可以安全地假设玩家在空中并准备过渡到“跳跃循环”动画状态。'
- en: To do this, first make sure that the `JumpingStart` animation is selected in
    `Asset Browser`, and then *right-click* in `Event Graph` of the `Transition Rule`
    and find the `Time Remaining Ratio` function.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，首先确保在“资源浏览器”中选择了“跳跃开始”动画，然后在“过渡规则”的“事件图”中*右键单击*并找到“时间剩余比率”函数。
- en: Let's take a moment to talk about the `Time Remaining Ratio` function and what
    it is doing. This function returns a float between `0.0f` and `1.0f` that tells
    you how much time is remaining in the specified animation. The values `0.0f` and
    `1.0f` can directly be translated to a percentage value so that they are easier
    to consider. In the case of the `JumpingStart` animation, you would want to know
    whether less than 60% of the animation is remaining in order to transition successfully
    to the `JumpingLoop` state. This is what you will do now.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来谈谈“时间剩余比率”函数及其作用。该函数返回一个在“0.0f”和“1.0f”之间的浮点数，告诉您指定动画剩余多少时间。值“0.0f”和“1.0f”可以直接转换为百分比值，以便更容易考虑。在“跳跃开始”动画的情况下，您希望知道动画剩余的百分比是否小于60%，以成功过渡到“跳跃循环”状态。这就是您现在要做的。
- en: 'From the `Return Value` float output parameter of the `Time Remaining Ratio`
    function, search for the `Less Than comparative operative` node from the context-sensitive
    search menu. Since you are working with a returned value between `0.0f` and `1.0f`,
    in order to know whether less than 60% of the animation remains, you need to compare
    this returned value with a value of `0.6f`. The final result is as follows:![Figure
    11.52: You will need to know how much time is left in the JumpingStart animation
    before transitioning to the JumpLoop animation'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“时间剩余比率”函数的“返回值”浮点输出参数中，从上下文敏感搜索菜单中搜索“小于比较操作”节点。由于您正在处理一个在“0.0f”和“1.0f”之间的返回值，为了知道动画剩余的百分比是否小于60%，您需要将这个返回值与“0.6f”进行比较。最终结果如下：![图11.52：在过渡到跳跃循环动画之前，您需要知道跳跃开始动画剩余多少时间
- en: '](img/B16183_11_52.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_52.jpg)'
- en: 'Figure 11.52: You will need to know how much time is left in the JumpingStart
    animation before transitioning to the JumpLoop animation'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.52：在过渡到跳跃循环动画之前，您需要知道跳跃开始动画剩余多少时间
- en: With this `Transition Rule` in place, all that is left to do is to add the `JumpLoop`
    animation to the `JumpLoop` state.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个“过渡规则”，剩下的就是将“跳跃循环”动画添加到“跳跃循环”状态中。
- en: 'In the `Movement` state machine, *double left-click* on the `JumpLoop` state
    to enter its graph. With the `JumpLoop` animation asset selected in `Asset Browser`,
    *left-click* and drag it onto the graph. Connect its output to the `Result` input
    of `Output Animation Pose`, as shown below. The default settings of the `Play
    JumpLoop` node will remain unchanged.![Figure 11.53: The JumpLoop animation connected
    to Output'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“移动”状态机中，*双击*“跳跃循环”状态以进入其图表。在“资源浏览器”中选择“跳跃循环”动画资产，*单击*并将其拖放到图表中。将其输出连接到“输出动画姿势”的“结果”输入，如下所示。默认设置的“播放跳跃循环”节点将保持不变。![图11.53：跳跃循环动画连接到输出
- en: Animation Pose of the new state
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 新状态的动画姿势
- en: '](img/B16183_11_53.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_53.jpg)'
- en: 'Figure 11.53: The JumpLoop animation connected to Output Animation Pose of
    the new state'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.53：跳跃循环动画连接到新状态的输出动画姿势
- en: 'With the `JumpLoop` animation in place in the `JumpLoop` state, you can now
    compile the animation blueprint and PIE. You will notice that the movement and
    sprinting animations are still present, but what happens when you try to jump?
    The player character begins the `JumpStart` state and plays the `JumpLoop` animation
    while in the air. This is great, the state machine is working, but what happens
    when the player character reaches the ground and is no longer in the air? The
    player character does not transition back to the `Movement` state, which makes
    sense because you have not yet added the state for `JumpEnd` or the transitions
    between `JumpLoop` and `JumpEnd`, and from `JumpEnd` back to the `Movement` state.
    You will do this in the next activity. See below for an example of a player character
    stuck in the `JumpLoop` state:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 将“跳跃循环”动画放置在“跳跃循环”状态中后，您现在可以编译动画蓝图并进行PIE。您会注意到移动和奔跑动画仍然存在，但当您尝试跳跃时会发生什么？玩家角色开始“跳跃开始”状态，并在空中播放“跳跃循环”动画。这很棒，状态机正在工作，但当玩家角色到达地面并不再在空中时会发生什么？玩家角色不会过渡回“移动”状态，这是有道理的，因为您还没有添加“跳跃结束”状态或“跳跃循环”和“跳跃结束”之间的过渡，以及从“跳跃结束”回到“移动”状态。您将在下一个活动中完成这些。请参见下面的示例，其中玩家角色被困在“跳跃循环”状态中：
- en: '![Figure 11.54: The player character can now play the JumpingStart animation
    and the JumpLoop animation, but cannot transition back to the default movement'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.54：玩家角色现在可以播放跳跃开始动画和跳跃循环动画，但无法过渡回默认移动状态'
- en: '](img/B16183_11_54.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_54.jpg)'
- en: 'Figure 11.54: The player character can now play the JumpingStart animation
    and the JumpLoop animation, but cannot transition back to the default movement'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.54：玩家角色现在可以播放跳跃开始动画和跳跃循环动画，但无法过渡回默认移动状态
- en: By completing this exercise, you were able to successfully transition from the
    `JumpStart` state to the `JumpLoop` state by using the `Time Remaining Ratio`
    function. This function allows you to know how far along an animation has played,
    and with this information, you had the state machine transition into the `JumpLoop`
    state. The player can now successfully transition from the default `Movement`
    state to the `JumpStart` state and then to the `JumpLoop` state, resulting in
    an interesting issue. The player is now stuck in the `JumpLoop` state because
    the state machine does not contain the transition back to the `Movement` state.
    Let's fix this in the next activity.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已成功使用`Time Remaining Ratio`函数从`JumpStart`状态过渡到`JumpLoop`状态。这个函数允许您知道动画播放到哪个阶段，有了这个信息，状态机就可以过渡到`JumpLoop`状态。玩家现在可以成功地从默认的`Movement`状态过渡到`JumpStart`状态，然后到`JumpLoop`状态，导致一个有趣的问题。玩家现在被困在`JumpLoop`状态，因为状态机没有包含回到`Movement`状态的过渡。让我们在下一个活动中解决这个问题。
- en: 'Activity 11.04: Finishing the Movement and Jumping State Machine'
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.04：完成移动和跳跃状态机
- en: With half of the state machine completed, it's time to add the state for when
    the jump ends, as well as the Transition Rules that allow you to transition from
    the `JumpLoop` state to this new state, and the transition from this new state
    back to the `Movement` state.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了一半的状态机，现在是时候添加跳跃结束的状态，以及允许您从`JumpLoop`状态过渡到这个新状态的过渡规则，以及从这个新状态过渡回`Movement`状态的过渡规则。
- en: 'Do the following to complete the `Movement` state machine:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`Movement`状态机的以下操作：
- en: Add a new state for `Jump End` that transitions from `JumpLoop`. Name this state
    `JumpEnd`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`Jump End`状态，从`JumpLoop`过渡。将此状态命名为`JumpEnd`。
- en: Add the `JumpEnd` animation to the new `JumpEnd` state.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`JumpEnd`动画添加到新的`JumpEnd`状态。
- en: Based on the `JumpEnd` animation and how quickly we want to transition between
    the `JumpLoop`, `JumpEnd`, and `Movement` states, consider modifying the parameters
    of the animation like you did for the `JumpStart` animation. The `loop animation`
    parameter needs to be `False` and the `Play Rate` parameter needs to be set to
    `3.0`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`JumpEnd`动画以及我们希望在`JumpLoop`、`JumpEnd`和`Movement`状态之间快速过渡的方式，考虑修改动画的参数，就像你为`JumpStart`动画所做的那样。`循环动画`参数需要设置为`False`，`播放速率`参数需要设置为`3.0`。
- en: Add a `Transition Rule` from the `JumpLoop` state to the `JumpEnd` state based
    on the `bIsInAir` variable.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`JumpLoop`状态到`JumpEnd`状态添加一个`过渡规则`，基于`bIsInAir`变量。
- en: Add a `Transition Rule` from the `JumpEnd` state to the `Movement` state based
    on the `Time Remaining Ratio` function of the `JumpEnd` animation. (Look at the
    `JumpStart` to `JumpLoop` Transition Rule).
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`JumpEnd`动画的`Time Remaining Ratio`函数，从`JumpEnd`状态到`Movement`状态添加一个`过渡规则`。（查看`JumpStart`到`JumpLoop`的过渡规则）。
- en: By the end of this activity, you will have a fully functioning movement state
    machine that allows the player character to idle, walk, and sprint, as well as
    being able to jump and animate correctly at the start of the jump, while in the
    air, and when landing.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本次活动，您将拥有一个完全运作的移动状态机，允许玩家角色空闲、行走、冲刺，以及能够跳跃并在跳跃开始时正确地进行动画，以及在空中和着陆时进行动画。
- en: 'The expected output is as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 11.55: Player character with idle, walk, sprint, and jump animation'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.55：玩家角色的空闲、行走、冲刺和跳跃动画'
- en: '](img/B16183_11_55.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_11_55.jpg)'
- en: 'Figure 11.55: Player character with idle, walk, sprint, and jump animation'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.55：玩家角色的空闲、行走、冲刺和跳跃动画
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下链接找到此活动的解决方案：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: By completing this activity, you have now finished the movement state machine
    for the player character. By adding the remaining `JumpEnd` state and the `Transition
    Rules` to transition to the state from the `JumpLoop` state, and to transition
    from the `JumpEnd` state back to the `Movement` state, you successfully created
    your first animation state machine. Now, you can run around the map and jump onto
    elevated platforms, all while animating correctly and transitioning between movement
    and jump states.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，您现在已经完成了玩家角色的移动状态机。通过添加剩余的`JumpEnd`状态和从`JumpLoop`状态过渡到该状态的`过渡规则`，以及从`JumpEnd`状态回到`Movement`状态的`过渡规则`，您成功地创建了您的第一个动画状态机。现在，您可以在地图上奔跑并跳上高处的平台，同时正确地进行动画并在移动和跳跃状态之间过渡。
- en: Summary
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With the player movement Blend Space created and the player character animation
    blueprint using a state machine to transition from movement to jumping, you are
    ready to move on to the next chapter, where you will prepare the required animation
    slot, animation montage, and update the animation blueprint for the throw animation
    that will use only the upper body of the character.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家移动混合空间已创建，玩家角色动画蓝图使用状态机从移动到跳跃的过渡，您已准备好进入下一章，在那里您将准备所需的动画插槽、动画剪辑，并更新动画蓝图，以使用角色的上半身进行投掷动画。
- en: From the exercises and activities in this chapter, you learned how to create
    a 1D Blend Space that allows the smooth blending of movement-based animations
    such as idling, walking, and running using the speed of the player character to
    control the blending of animations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的练习和活动，您学会了如何创建一个1D混合空间，允许平滑地混合基于移动的动画，如空闲、行走和奔跑，使用玩家角色的速度来控制动画的混合。
- en: Additionally, you learned how to integrate new key bindings into the project
    settings and bind those keys in C++ to enable character gameplay mechanics such
    as sprinting and throwing.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您还学会了如何将新的按键绑定集成到项目设置中，并在C++中绑定这些按键，以启用角色的游戏机制，如冲刺和投掷。
- en: Lastly, you learned how to implement your very own animation state machine within
    the character animation blueprint in order for the player to have the ability
    to transition between movement animations, to the various states of jumping, and
    back to movement again. With all of this logic in place, in the next chapter let's
    move on and create the assets and logic for allowing the player character to play
    the throwing animation, and set up the base class for the enemy.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学会了如何在角色动画蓝图中实现自己的动画状态机，以便玩家能够在移动动画之间进行过渡，跳跃的各种状态，然后再回到移动状态。有了所有这些逻辑，让我们在下一章继续创建资产和逻辑，允许玩家角色播放投掷动画，并设置敌人的基础类。
