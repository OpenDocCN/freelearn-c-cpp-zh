- en: '*Chapter 11*: Undefined Behavior and Performance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：未定义行为和性能'
- en: This chapter has a dual focus. On the one hand, it explains the dangers of the
    kinds of undefined behavior that programmers often ignore when attempting to squeeze
    the most performance from their code. On the other hand, it explains how to take
    advantage of the undefined behavior to improve performance and how to properly
    specify and document such situations. Overall, the chapter offers a somewhat unusual
    but more relevant way to understand the issue of the undefined behavior compared
    to the usual "*anything can happen.*"
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有双重重点。一方面，它解释了程序员在试图从他们的代码中挤取最佳性能时经常忽视的未定义行为的危险。另一方面，它解释了如何利用未定义行为来提高性能，以及如何正确地指定和记录这种情况。总的来说，与通常的“*任何事都可能发生*”相比，本章提供了一种更为不寻常但更相关的理解未定义行为的方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding undefined behavior and why it exists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解未定义行为及其存在的原因
- en: Understanding the truth versus the myths about undefined behavior
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解未定义行为的真相与神话
- en: Which undefined behavior is dangerous and must be avoided
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些未定义行为是危险的，必须避免
- en: How to take advantage of undefined behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用未定义行为
- en: Learning the connection between undefined behavior and efficiency and how to
    exploit it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习未定义行为与效率之间的联系以及如何利用它
- en: You will learn to recognize undefined behavior when it is encountered in (somebody
    else's) code and understand how undefined behavior is related to performance.
    This chapter also teaches you how to use undefined behavior for good by intentionally
    allowing it, documenting it, and placing safeguards around it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学会在（别人的）代码中遇到未定义行为时如何识别它，并了解未定义行为与性能的关系。本章还教会您如何通过有意允许未定义行为、记录它并在其周围设置保障措施来利用未定义行为。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As before, you will need a C++ compiler. In this chapter, we use GCC and Clang,
    but any modern compiler will do. The code accompanying this chapter can be found
    at [https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter11](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter11).
    You will also need a way to examine the assembly code generated by the compiler.
    Many development environments have an option to display assembly code, GCC and
    Clang can write out the assembly code instead of the object code, debuggers and
    other tools can generate assembly code from the object code (disassemble it);
    it's a matter of personal preference which tool you use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，您将需要一个C++编译器。在本章中，我们使用GCC和Clang，但任何现代编译器都可以。本章附带的代码可以在[https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter11](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter11)找到。您还需要一种方法来检查编译器生成的汇编代码。许多开发环境都有显示汇编代码的选项，GCC和Clang可以将汇编代码写出而不是目标代码，调试器和其他工具可以从目标代码生成汇编代码（反汇编）；您可以根据个人喜好选择使用哪种工具。
- en: What is undefined behavior?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是未定义行为？
- en: 'The concept of `comp.std.c` warns, *"When the compiler encounters (an undefined
    construct), it is legal for it to make demons fly out of your nose."* Launching
    nuclear missiles and neutering your cat (even if you don''t own a cat) have been
    mentioned in a similar context. One of the tangential goals of this chapter is
    to demystify UB: while the ultimate goal is to explain the relationship between
    UB and performance and to show how to take advantage of UB, we cannot do that
    until we can discuss the concept rationally.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`comp.std.c`的概念警告说，“当编译器遇到（未定义的结构）时，它可以合法地让恶魔从你的鼻子里飞出来。”在类似的情境中，还提到了发射核导弹和阉割你的猫（即使你没有猫）。本章的一个旁枝目标是揭开UB的神秘面纱：虽然最终目标是解释UB与性能之间的关系，并展示如何利用UB，但在我们能理性地讨论这个概念之前，我们无法做到这一点。'
- en: 'First of all, what is UB in the context of C++ (or any other programming language)?
    There are specific places in the standard where the words *the behavior is undefined*
    or *the program is ill-formed* are used. The standard further says that if the
    behavior is undefined, the standard *imposes no requirements* on the results.
    The corresponding situations are referred to as UB. For example, refer to the
    following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在C++（或任何其他编程语言）的上下文中，什么是UB？标准中有特定的地方使用了“行为未定义”或“程序不合法”的词语。标准进一步指出，如果行为未定义，标准对结果“不做要求”。相应的情况被称为UB。例如，请参考以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The standard says that the result of the preceding code is undefined if the
    addition causes integer overflow (that is, if `k` is greater than `INT_MAX-10`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 标准规定，如果加法导致整数溢出（即，如果`k`大于`INT_MAX-10`），则上述代码的结果是未定义的。
- en: 'When UB is mentioned, the discussion tends to go toward one of the two extremes.
    The first one we have just seen. The exaggerated language may be well-intentioned
    as a warning against the danger of UB, but it is also a barrier to a rational
    explanation. Your nose is quite safe from the wrath of the compiler, and so is
    your cat. The compiler will, in the end, generate some code from your program,
    and you will run this code. It is not going to give your computer any superpowers:
    anything this program does, you could accomplish intentionally, for example, by
    writing an identical sequence of instructions by hand in assembler. If there is
    no way for you to execute machine instructions that result in launching nuclear
    missiles, your compiler will be unable to do that, UB or no UB (of course, if
    you are programming the missile launch controller, it''s a different game altogether).
    The bottom line is, when your program''s behavior is undefined, according to the
    standard, the compiler can generate code you do not expect, but this code cannot
    do anything that you could not do already.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到UB时，讨论往往会朝着两个极端之一发展。我们刚刚看到的第一个。夸大的语言可能是出于对UB危险的警告，但它也是对理性解释的障碍。你的鼻子对于编译器的愤怒是相当安全的，你的猫也是如此。编译器最终会从你的程序生成一些代码，你将运行这些代码。它不会给你的计算机带来任何超能力：这个程序做的任何事情，你都可以有意地完成，例如，通过在汇编语言中手动编写相同的指令序列。如果你没有办法执行导致发射核导弹的机器指令，你的编译器也无法做到这一点，无论有没有UB（当然，如果你正在编写导弹发射控制器，那就是完全不同的游戏了）。最重要的是，当你的程序行为是未定义的时候，根据标准，编译器可以生成你意料不到的代码，但这些代码不能做任何你已经做过的事情。
- en: 'While overstating the dangers of UB is not helpful, on the flip side, there
    is a tendency to *reason* about UB, which is also an unfortunate practice. For
    example, consider this code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然夸大UB的危险是没有帮助的，但另一方面，有一种倾向于*推理*UB，这也是一种不幸的做法。例如，考虑这段代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the C++ standards have progressively tightened the rules on executing
    this kind of expression, the result of this particular one remains undefined in
    C++17\. Many programmers underestimate the danger of this situation. They say,
    *"the compiler will either evaluate k++ first or evaluate k + k first."* To explain
    why this is wrong and dangerous, we have to first split some hairs in the standard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++标准逐渐收紧了执行这种表达式的规则，但在C++17中，这个特定表达式的结果仍然是未定义的。许多程序员低估了这种情况的危险。他们说，“编译器要么首先评估k++，要么首先评估k
    + k。”为了解释为什么这是错误和危险的，我们首先必须在标准中分清一些细微之处。
- en: 'The C++ Standard has three related and often confused categories of behavior:
    `k++ + k` must take place (that would be unspecified behavior, which is not what
    the standard says). The standard says that the entire program is ill-formed and
    imposes no restrictions on its outcome (but before you panic and fear for your
    nose, remember that the result is restricted to some executable code).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准有三个相关的并经常混淆的行为类别：`k++ + k`必须发生（这将是未指定的行为，这不是标准所说的）。标准规定整个程序是不良构造的，并且对其结果没有任何限制（但在你惊慌和担心你的鼻子之前，记住结果被限制为一些可执行代码）。
- en: 'A counter-argument is often made stating that whatever the compiler does when
    it compiles the line with UB, it still has to handle the rest of the code in a
    Standard-mandated way, so (the argument goes) the damage is limited to one of
    the possible outcomes from that particular line. Just like it is important to
    not overstate the danger, it is important to understand why this argument is wrong.
    The compiler is written on the assumption that the program is well defined and
    is required to produce the correct results in this case and only in this case.
    There are no preconceptions of what happens if the assumption is violated. One
    way to describe the situation is to say that the compiler is not required to condone
    the UB. Let us go back to our first example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 反驳常常是这样的，即使编译器在编译具有未定义行为的代码时会做些什么，它仍然必须以标准规定的方式处理代码的其余部分，所以（论点是）损害仅限于该特定行的可能结果之一。就像重视危险一样重要，理解为什么这个论点是错误的也很重要。编译器是在程序被定义良好的假设下编写的，并且在这种情况下只有在这种情况下才需要产生正确的结果。没有预设如果假设被违反会发生什么。描述这种情况的一种方式是说编译器不需要容忍未定义行为。让我们回到我们的第一个例子：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the program is ill-defined for a large enough `k` to cause an integer
    overflow, the compiler is allowed to assume that this will never happen. What
    if it does happen? Well, if you compile this function by itself (in a separate
    compilation unit), the compiler will generate some code that produces correct
    results for all `k <= INT_MAX-10`. If there are no whole-program transformations
    in your compiler and linker, the same code will *probably* execute for a larger
    `k`, and the result will be whatever your hardware does in this case. The compiler
    could insert a check for `k`, but it probably won't (with some compiler options,
    it might, though).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序对于足够大的`k`来导致整数溢出是不明确的，编译器允许假设这永远不会发生。如果发生了呢？如果你单独编译这个函数（在一个单独的编译单元中），编译器将生成一些代码，为所有`k
    <= INT_MAX-10`产生正确的结果。如果你的编译器和链接器没有整个程序的转换，相同的代码将*可能*对更大的`k`执行，并且结果将是在这种情况下你的硬件所做的任何事情。编译器可以插入对`k`的检查，但它可能不会这样做（尽管有一些编译器选项，它可能会这样做）。
- en: 'What if the function is a part of a larger compilation unit? That is where
    things get interesting: the compiler now knows that the input argument to the
    `f()` function is restricted. That knowledge can be used for optimization. For
    example, refer to the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是较大编译单元的一部分呢？这就是事情变得有趣的地方：编译器现在知道`f()`函数的输入参数是受限制的。这种知识可以用于优化。例如，参考以下代码：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the definition of the `f()` function is visible to the compiler, the compiler
    can deduce that the printout never happens: if `k` is large enough for this program
    to print, then the entire program is ill-formed and the standard does not require
    it to print anything. If the value of `k` is within the bounds of defined behavior,
    the program will never print anything. Either way, printing nothing is a valid
    result according to the standard. Note that just because your compiler does not
    currently do this optimization, it does not mean that it never will: this type
    of optimization is becoming more aggressive in newer compilers.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`f()`函数的定义对编译器可见，编译器可以推断打印永远不会发生：如果`k`足够大，以至于程序打印，那么整个程序就是不合法的，标准不要求它打印任何东西。如果`k`的值在定义行为的范围内，程序将永远不会打印任何东西。无论哪种方式，不打印任何东西都是标准允许的结果。请注意，仅因为您的编译器目前不执行此优化，并不意味着它永远不会：这种类型的优化在较新的编译器中变得更加激进。
- en: 'So what about our second example? The result of the expression `k++ + k` is
    always undefined for any value of `k`. What can the compiler do with that? Again,
    remember: the compiler is not required to condone UB. The only way this program
    can remain well defined is if this line is never executed. The compiler is allowed
    to assume that this is the case and then reason backward: the function containing
    this code is never called, any conditions necessary for that to happen must be
    true, and so on, up to, possibly, the conclusion that the entire program will
    never be executed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们的第二个例子呢？表达式`k++ + k`的结果对于任何`k`的值都是未定义的。编译器能做什么？再次记住：编译器不需要容忍未定义行为。这个程序能保持良好定义的唯一方式是这行代码永远不被执行。编译器可以假设这是情况，并进行推理：包含这段代码的函数从未被调用，任何必要的条件都必须成立，等等，最终可能得出整个程序永远不会被执行的结论。
- en: 'If you think that *real compilers don''t do that sort of stuff*, I have a surprise
    for you:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为*真正的编译器不会做那种事情*，我有一个惊喜给你：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The natural expectation for this program is to print `Before` and hang forever.
    When compiled with GCC (version 9, optimization O3), that is precisely what it
    does. When compiled with Clang (version 13, also O3), it prints `Before`, then
    `After`, and then terminates immediately without any errors (it doesn't crash,
    it just exits). Both outcomes are valid because the results of a program that
    encounters an infinite loop are undefined (unless certain conditions are met,
    none of which apply here).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的自然期望是打印`Before`并永远挂起。使用GCC（版本9，优化O3）编译时，它确实如此。使用Clang（版本13，也是O3）编译时，它打印`Before`，然后打印`After`，然后立即终止而不会出现任何错误（它不崩溃，只是退出）。这两种结果都是有效的，因为遇到无限循环的程序的结果是未定义的（除非满足某些条件，这里都不适用）。
- en: The preceding example is very instructive for understanding why we have UB at
    all. In the next section, we are going to lift the veil and explain the reasons
    for UB.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子非常有教育意义，可以帮助我们理解为什么我们会有未定义行为。在下一节中，我们将揭开面纱，解释未定义行为的原因。
- en: Why have undefined behavior?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么会有未定义行为？
- en: 'The obvious question that arises from the last section is, why does the standard
    have UB at all? Why doesn''t it specify the result for every situation? A slightly
    subtler question that acknowledges the reality that C++ is used on a wide variety
    of hardware with very different properties is this: why doesn''t the standard
    fall back on implementation-defined behavior instead of leaving it undefined?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中产生的明显问题是，为什么标准会有未定义行为？为什么它不为每种情况指定结果？一个稍微微妙的问题是，承认C++被用于各种硬件，具有非常不同的属性，这是为什么标准不退而使用实现定义的行为，而不是将其留在未定义状态？
- en: 'The last example from the previous section provides us with a perfect demonstration
    vehicle for the rationale behind the existence of UB. The statement is that an
    infinite loop is UB; another way of saying that is that the standard does not
    require a specific outcome from a program that enters an infinite loop (the standard
    is more nuanced than that, and some forms of infinite loops will cause the program
    to hang, but these details are not important at the moment). To understand why
    the rule is there, consider the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的最后一个例子为我们提供了一个完美的演示工具，解释了为什么存在未定义行为。说法是无限循环是未定义的；另一种说法是标准不要求进入无限循环的程序产生特定的结果（标准比这更微妙，某些形式的无限循环会导致程序挂起，但这些细节目前并不重要）。要理解为什么规则存在，考虑以下代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The loops are identical, so we are paying the overhead of the loop (increment
    of the loop variable and comparison) twice. The compiler clearly should do the
    following optimization by folding the loops together:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个循环是相同的，所以我们要支付两次循环的开销（循环变量的增量和比较）。编译器显然应该通过将循环折叠在一起来进行以下优化：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note, however, that this transformation is valid only if the first loop terminates;
    otherwise, the count `n2` should never be incremented at all. It is impossible
    to know during compilation whether the loop terminates – it depends on the value
    of `n`. If `n` is odd, the loop runs forever (unlike signed integer overflow,
    incrementing the unsigned type `size_t` past its maximum value is well defined,
    and the value rolls over back to zero). In general, it is not possible for the
    compiler to prove that a particular loop eventually terminates (this is a known
    NP-complete problem). The decision was made to assume that every loop eventually
    terminates and to allow the optimizations that would otherwise be invalid. Because
    these optimizations can make a program with an infinite loop invalid, such loops
    are considered UB, meaning the compiler does not have to preserve the behavior
    of a program with an infinite loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，此转换仅在第一个循环终止时才有效；否则，`n2`的计数根本不应该被递增。在编译期间不可能知道循环是否终止 - 这取决于`n`的值。如果`n`是奇数，则循环将永远运行（与有符号整数溢出不同，递增无符号类型`size_t`超过其最大值是良定义的，并且该值将回滚到零）。通常情况下，编译器无法证明特定循环最终会终止（这是一个已知的NP完全问题）。决定假设每个循环最终都会终止，并允许否则无效的优化。因为这些优化可能使具有无限循环的程序无效，这样的循环被视为UB，这意味着编译器不必保留具有无限循环的程序的行为。
- en: To avoid oversimplifying the issue, we must mention that not all types of UB
    defined in the C++ Standard have similar reasoning behind them. Some UB is introduced
    because the language has to be supported on different types of hardware, and some
    of these cases can be considered obsolete today. As this is a book on performance,
    we will focus on examples of UB that exist for reasons of efficiency or that can
    be used to improve certain optimizations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过分简化问题，我们必须提到，并非C++标准中定义的所有UB类型背后都有类似的推理。一些UB是因为语言必须在不同类型的硬件上得到支持，其中一些情况今天可以被认为是过时的。由于这是一本关于性能的书，我们将重点关注存在于效率原因或可用于改进某些优化的UB示例。
- en: In the next section, we will see more examples of how the compiler can use UB
    to its (and your) advantage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到更多关于编译器如何利用UB来实现优化的示例。
- en: Undefined behavior and C++ optimization
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未定义行为和C++优化
- en: 'We have just seen one example in the previous section, where, by assuming that
    every loop in the program eventually terminates, the compiler is able to optimize
    certain loops and the code containing these loops. The fundamental logic used
    by the optimizer is always the same: first, we assume that the program does not
    exhibit UB. Then, we deduce the conditions that must be true in order for this
    assumption to hold and assume that these conditions are indeed always true. Finally,
    any optimization that is valid under such assumptions may proceed. The code generated
    by the optimizer will do *something* if the assumptions are violated, but we have
    no way of knowing what it will be (beyond the already mentioned restrictions that
    it''s still the same computer executing some sequence of instructions).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们刚刚看到一个例子，通过假设程序中的每个循环最终都会终止，编译器能够优化某些循环和包含这些循环的代码。优化器使用的基本逻辑始终相同：首先，我们假设程序不会出现UB。然后，我们推断出必须满足的条件，以使这一假设成立，并假设这些条件确实总是成立。最后，任何在这些假设下有效的优化都可以进行。优化器生成的代码在违反这些假设时会执行*某些操作*，但我们无法知道它将执行什么操作（除了已经提到的限制，即仍然是同一台计算机执行某些指令的情况）。
- en: Almost every case of UB documented in the standard can be converted into an
    example of a possible optimization (whether a particular compiler takes advantage
    of this is a different matter). We are going to see several more examples now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 标准中记录的几乎每种UB情况都可以转化为可能优化的示例（特定编译器是否利用这一点是另一回事）。我们现在将看到更多示例。
- en: 'As we have already mentioned, the result of overflowing a signed integer is
    undefined. The compiler is allowed to assume that this never happens and that
    incrementing a signed integer by a positive number always results in a greater
    integer. Do the compilers actually perform this optimization? Let''s find out.
    Compare these two functions, `f()` and `g()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，有符号整数溢出的结果是未定义的。编译器可以假设这种情况永远不会发生，并且通过正数递增有符号整数总是会得到更大的整数。编译器实际上执行了这种优化吗？让我们来看看。比较这两个函数，`f()`和`g()`：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Within the realm of well-defined behavior, these functions are identical. We
    could try to benchmark them to determine whether the compiler optimizes away the
    entire expression in `f()` but, as we have seen in the previous chapter, there
    is a more reliable way. If both functions generate the same machine code, they
    are definitely identical.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在良定义的行为范围内，这些函数是相同的。我们可以尝试对它们进行基准测试，以确定编译器是否优化了`f()`中的整个表达式，但是，正如我们在上一章中所看到的，有一种更可靠的方法。如果两个函数生成相同的机器代码，它们肯定是相同的。
- en: '![Figure 11.1 – x86 assembly output generated by GCC9 for the f() (left) and
    g() (right) functions'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 由GCC9生成的f()（左）和g()（右）函数的x86汇编输出'
- en: '](img/Figure_10.1_B16229.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B16229.jpg)'
- en: Figure 11.1 – x86 assembly output generated by GCC9 for the f() (left) and g()
    (right) functions
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 由GCC9生成的f()（左）和g()（右）函数的x86汇编输出
- en: 'In *Figure 11.1*, we can see that with optimization turned on, GCC indeed generates
    the same code for both functions (so does Clang). The names of the functions that
    show up in the assembly are so-called mangled names: since C++ allows functions
    with different parameter lists to have the same name, it has to generate a unique
    name for each of such functions. It does so by encoding the types of all parameters
    into the name that is actually used in the object code.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.1*中，我们可以看到，打开优化后，GCC确实为这两个函数生成了相同的代码（Clang也是如此）。汇编中出现的函数名称是所谓的mangled
    names：由于C++允许具有不同参数列表的函数具有相同的名称，因此必须为每个这样的函数生成唯一的名称。它通过将所有参数的类型编码到实际在目标代码中使用的名称中来实现。
- en: 'If you want to validate that this code indeed does not have any trace of the
    `?:` operator, the easiest way is to compare the `f()` function with a function
    that does the same computation using unsigned integers. Refer to the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想验证此代码确实没有任何`?:`运算符的痕迹，最简单的方法是将`f()`函数与使用无符号整数进行相同计算的函数进行比较。参考以下代码：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Overflow of unsigned integers is well defined, and it is, in general, not true
    that `i + 1` is always greater than `i`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数的溢出是明确定义的，并且通常并非总是`i + 1`始终大于`i`。
- en: '![Figure 11.2 – X86 assembly output generated by GCC9 for the f() (left) and
    h() (right) functions'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 由GCC9生成的f()（左）和h()（右）函数的X86汇编输出'
- en: '](img/Figure_10.2_B16229.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B16229.jpg)'
- en: Figure 11.2 – X86 assembly output generated by GCC9 for the f() (left) and h()
    (right) functions
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 由GCC9生成的f()（左）和h()（右）函数的X86汇编输出
- en: The `h()` function produces different code, and you can guess that the `cmp`
    instruction does a comparison even if you are not fluent in X86 assembly. On the
    left, the function `f()` loads the constant value of `0x1`, otherwise known as
    `true` for Booleans, into the register EAX that is used to return the result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`h()`函数生成不同的代码，即使您不熟悉X86汇编，也可以猜到`cmp`指令进行比较。在左边，函数`f()`将常量值`0x1`的值加载到用于返回结果的寄存器EAX中。'
- en: 'This example also demonstrates the danger of trying to reason about UB or treat
    it as implementation-defined: if you were to say that the program will do *some
    kind of addition* for the integers and if it overflows, the particular hardware
    would do whatever it does, and you would be very wrong. A compiler may, and some
    do, generate code with no increment instructions at all.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也展示了试图推断未定义行为或将其视为实现定义的危险：如果你说程序将对整数进行*某种加法*，如果溢出，特定的硬件将执行它的操作，那么你将非常错误。编译器可能会生成根本没有递增指令的代码。
- en: 'We now, finally, have enough knowledge to fully elucidate the mystery whose
    seeds were planted all the way at the beginning of the book, in [*Chapter 2*](B16229_02_Epub_AM.xhtml#_idTextAnchor026),
    *Performance Measurements*. In that chapter, we observed an unexpected performance
    difference between two almost identical implementations of the same function.
    The function''s job was to compare two strings, character by character, and return
    `true` if the first string is lexicographically greater. This was our most compact
    implementation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于有足够的知识来完全阐明这个谜团，这个谜团的种子从书的一开始就播下了，在[*第2章*](B16229_02_Epub_AM.xhtml#_idTextAnchor026)中，*性能测量*。在那一章中，我们观察到了同一函数的两个几乎相同的实现之间出乎意料的性能差异。该函数的工作是逐个字符比较两个字符串，并在第一个字符串在字典顺序上更大时返回`true`。这是我们最简洁的实现：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function was used to sort strings, so the benchmark measured the time
    of sorting a particular input set of strings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于对字符串进行排序，因此基准测试测量了对特定输入字符串集进行排序所需的时间：
- en: '![Figure 11.3 – Sorting benchmark using the compare1() function for string
    comparison'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - 使用compare1()函数进行字符串比较的排序基准'
- en: '](img/Figure_2.4_B16229.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B16229.jpg)'
- en: Figure 11.3 – Sorting benchmark using the compare1() function for string comparison
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 使用compare1()函数进行字符串比较的排序基准
- en: 'The comparison implementation is as compact as it gets; there is nothing unnecessary
    in this code. However, the surprising result was that this was one of the worst-performing
    versions of the code. The best-performing version was almost the same:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 比较实现尽可能紧凑；在这段代码中没有多余的东西。然而，令人惊讶的结果是，这是代码的性能最差的版本之一。性能最佳的版本几乎相同：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The only difference is the type of the loop variable: `unsigned int` in `compare1()`
    versus `int` in `compare2()`. Since the indices are never negative, this should
    make no difference whatsoever, but it does:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是循环变量的类型：`compare1()`中是`unsigned int`，而`compare2()`中是`int`。由于索引永远不会是负数，这应该没有任何区别，但实际上有：
- en: '![Figure 11.4 – Sorting benchmark using the compare2() function for string
    comparison'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 - 使用compare2()函数进行字符串比较的排序基准'
- en: '](img/Figure_2.5_B16229.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B16229.jpg)'
- en: Figure 11.4 – Sorting benchmark using the compare2() function for string comparison
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 使用compare2()函数进行字符串比较的排序基准
- en: 'The reason for this significant performance difference again has to do with
    UB. To understand what is going on, we will have to examine the assembly code
    again. *Figure 11.5* shows the code generated by GCC for both functions (only
    the most relevant part, the string comparison loop, is shown):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显著的性能差异的原因再次与未定义行为有关。要理解发生了什么，我们将不得不再次检查汇编代码。*图11.5*显示了GCC为两个函数生成的代码（只显示了最相关的部分，即字符串比较循环）：
- en: '![Figure 11.5 – X86 assembly generated for the compare1() (left) and compare2()
    (right) functions'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 - 由GCC生成的compare1()（左）和compare2()（右）函数的X86汇编代码'
- en: '](img/Figure_10.5_B16229.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B16229.jpg)'
- en: Figure 11.5 – X86 assembly generated for the compare1() (left) and compare2()
    (right) functions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 由GCC生成的compare1()（左）和compare2()（右）函数的X86汇编代码
- en: 'The code looks pretty similar, with one exception: on the right (`compare2()`),
    you can see the `add` instruction, which is used to increment the loop index by
    1 (the compiler optimized the code by replacing two loop variables with just one).
    On the left, there is nothing that looks like an addition or increment. Instead,
    there is the `lea` instruction, which stands for Load and Extend Address, but
    is used here to increment the index variable by 1 (the same optimization is done;
    there is only one loop variable).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来非常相似，只有一个例外：在右边（`compare2()`）可以看到`add`指令，用于将循环索引递增1（编译器通过用一个循环变量替换两个循环变量来优化代码）。在左边，没有看起来像加法或递增的东西。相反，有`lea`指令，它代表加载和扩展地址，但在这里用于将索引变量递增1（进行了相同的优化；只有一个循环变量）。
- en: 'With everything you have learned up to now, you should be able to guess why
    the compiler has to generate different code: while the programmer expects the
    index to never overflow, the compiler, in general, cannot make this assumption.
    Note that both versions use 32-bit integers, but the code is generated for a 64-bit
    machine. If a 32-bit signed `int` overflows, the result is undefined, so in this
    case, the compiler does make the assumption that the overflow never happens. If
    the operation does not overflow, the `add` instruction produces the correct result.
    For `unsigned int`, the compiler has to allow for the possibility of the overflow:
    incrementing `UINT_MAX` should give 0\. It turns out that the `add` instruction
    on x86-64 does not have these semantics. Instead, it extends the result to become
    a 64-bit integer. The best option for 32-bit unsigned integer arithmetic on X86
    is the `lea` instruction; it does the job but is much slower.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，根据你学到的一切，你应该能够猜到编译器为什么必须生成不同的代码：尽管程序员期望索引永远不会溢出，但编译器通常不能做出这种假设。请注意，两个版本都使用32位整数，但代码是为64位机器生成的。如果32位有符号`int`溢出，结果是未定义的，所以在这种情况下，编译器确实假设溢出永远不会发生。如果操作没有溢出，`add`指令会产生正确的结果。对于`unsigned
    int`，编译器必须考虑溢出的可能性：递增`UINT_MAX`应该得到0。结果表明，x86-64上的`add`指令没有这些语义。相反，它扩展结果成为64位整数。在X86上进行32位无符号整数算术的最佳选项是`lea`指令；它可以完成任务，但速度要慢得多。
- en: This example demonstrates how, by reasoning backward from the assumption that
    the program is well defined and UB never happens, the compiler can enable a very
    effective optimization that ends up making the entire sort operation several times
    faster.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了通过从程序是良好定义的假设和UB永远不会发生的假设逆向推理，编译器可以实现非常有效的优化，最终使整个排序操作的速度提高了数倍。
- en: 'Now that we understand what is going on in our code, we can explain the behavior
    of several other versions of the code. First of all, using 64-bit integers, signed
    or unsigned, will give us the same fast performance as the 32-bit signed integers:
    in all cases, the compiler will use `add` (for 64-bit unsigned values, it does
    have the correct overflow semantics). Second, if the maximum index, or the string
    length, is used, the compiler will deduce that the index cannot overflow:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了我们的代码中发生了什么，我们可以解释代码的其他版本的行为。首先，使用64位整数，有符号或无符号，将给我们与32位有符号整数相同的快速性能：在所有情况下，编译器都将使用`add`（对于64位无符号值，它确实具有正确的溢出语义）。其次，如果使用最大索引或字符串长度，编译器将推断索引不会溢出：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The unnecessary comparison with the length makes this version slightly slower
    than the best variant. The most reliable way to avoid accidentally running into
    this problem is to always use signed loop variables or use the unsigned integer
    of the size native to the hardware (so, avoid doing `unsigned int` math on 64-bit
    processors unless you really need it).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与长度的不必要比较使得这个版本比最佳变体稍慢。避免意外遇到这个问题的最可靠方法是始终使用有符号的循环变量或使用硬件本机的无符号整数（因此，除非确实需要，避免在64位处理器上进行`unsigned
    int`数学运算）。
- en: 'We can construct similar demonstrations using almost any other situation described
    as undefined behavior in the standard (although there is no guarantee that a particular
    compiler will take advantage of a possible optimization). Here is one more example
    that uses pointer dereference:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准中描述的几乎任何其他未定义行为的情况来构造类似的演示（尽管不能保证特定的编译器会利用可能的优化）。这里是另一个使用指针解引用的例子：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a simplification of a pretty common situation where the programmer
    has coded pointer checks to protect against null pointers, but hasn''t done so
    everywhere. The second line (the increment) is UB if the input argument is a null
    pointer. This means the entire program''s behavior is undefined, so the compiler
    can assume it never happens. Examination of the assembly code shows that, indeed,
    the comparison in the third line is eliminated:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当常见的情况的简化，程序员已经编写了指针检查来防止空指针，但并非在所有地方都这样做。如果输入参数是空指针，第二行（递增）就是UB。这意味着整个程序的行为是未定义的，因此编译器可以假设它永远不会发生。对汇编代码的检查显示，的确，第三行的比较被消除了：
- en: '![Figure 11.6 – X86 assembly generated for the f() function with (left) and
    without (right) the ?: operator'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 - 生成带有（左）和不带有（右）?:运算符的f()函数的X86汇编'
- en: '](img/Figure_10.6_B16229.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B16229.jpg)'
- en: 'Figure 11.6 – X86 assembly generated for the f() function with (left) and without
    (right) the ?: operator'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - 生成带有（左）和不带有（右）?:运算符的f()函数的X86汇编
- en: 'The same happens if we do the pointer check first:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先进行指针检查，情况也是一样的：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again, an examination of the assembly code will show that the pointer comparison
    is eliminated, even though the program behavior up to this point is well defined.
    The reasoning is the same: if the pointer `p` is not null, the comparison is redundant
    and can be omitted. If `p` is null, the behavior of the program is undefined,
    which means the compiler can do whatever it wants, and what it wants is to omit
    the comparison. The end result is, whether `p` is null or not, the comparison
    can be eliminated.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，对汇编代码的检查将显示指针比较被消除了，尽管到目前为止程序的行为是良好定义的。推理是相同的：如果指针`p`不是空的，比较是多余的，可以省略。如果`p`为空，程序的行为是未定义的，这意味着编译器可以做任何它想做的事情，它想要省略比较。最终结果是，无论`p`是否为空，比较都可以被消除。
- en: 'In the last chapter, when we studied compiler optimizations, we devoted a great
    deal of time to the analysis of what optimizations are possible because the compiler
    can prove that they are safe. We are going to revisit this issue because, first,
    it is absolutely essential for understanding compiler optimizations, and second,
    there is a connection with UB. We have just seen that when the compiler deduces
    some information from a particular statement (such as `p is non-null` deduced
    from the `return` statement), that knowledge is used to optimize not just following
    but also preceding code. The limitations on propagating such knowledge arise from
    what else the compiler can prove with certainty. To demonstrate, let''s modify
    the previous example slightly:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们研究编译器优化时，我们花了大量时间分析了哪些优化是可能的，因为编译器可以证明它们是安全的。我们将重新讨论这个问题，因为首先，这对于理解编译器优化是绝对必要的，其次，它与UB有关。我们刚刚看到，当编译器从特定语句（例如从`return`语句推断出`p`不为空）推断出一些信息时，这些知识不仅用于优化后续代码，还用于优化前面的代码。传播这种知识的限制来自编译器能够确定的其他内容。为了证明这一点，让我们稍微修改前面的例子：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, the compiler will not eliminate the pointer check, which can
    be seen in the produced assembly code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器不会消除指针检查，这可以从生成的汇编代码中看出：
- en: '![Figure 11.7 – X86 assembly generated for the f() function with (left) and
    without (right) the pointer check'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - 用于f()函数的X86汇编代码（左）和不带指针检查的X86汇编代码（右）'
- en: '](img/Figure_10.7_B16229.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.7_B16229.jpg)'
- en: Figure 11.7 – X86 assembly generated for the f() function with (left) and without
    (right) the pointer check
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 用于f()函数的X86汇编代码（左）和不带指针检查的X86汇编代码（右）
- en: The `test` instruction does a comparison with null (zero) and is followed by
    a conditional jump – this is what the `if` statement looks like in assembly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`指令对空（零）进行比较，然后是条件跳转 - 这就是汇编中`if`语句的样子。'
- en: Why didn't the compiler optimize away the check? To answer this question, you
    have to figure out under what conditions this optimization would have changed
    the *well-defined* behavior of the program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么编译器没有优化掉这个检查？要回答这个问题，你必须弄清楚在什么条件下，这种优化会改变程序的*良好定义*行为。
- en: 'The following two things are needed to make the optimization invalid:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使优化无效需要以下两个条件：
- en: 'First, the `g()` function must know whether the pointer `p` is null. This is
    possible: for example, `p` could also be stored in a global variable by the caller
    of `f()`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`g()`函数必须知道指针`p`是否为空。这是可能的：例如，`p`也可以由`f()`的调用者存储在全局变量中。
- en: 'Second, if `p` is null, the `return` statement must not be executed. This is
    also possible: `g()` may throw an exception if `p` is null.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，如果`p`为空，`return`语句就不应该被执行。这也是可能的：如果`p`为空，`g()`可能会抛出异常。
- en: 'For our final example of C++ optimizations that are strongly related to UB,
    we are going to look at something very different: the effect of the `const` keyword
    on the optimization. Again, this will teach us just as much about why the compiler
    cannot optimize certain code as it does with successful optimizations. We are
    going to start with the code fragment we saw earlier:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们最后一个与UB密切相关的C++优化示例，我们将看一些非常不同的东西：`const`关键字对优化的影响。同样，这将教会我们为什么编译器不能优化某些代码，就像成功的优化一样。我们将从我们之前看到的代码片段开始：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An optimizing compiler will, as we have seen, eliminate all the code from this
    function and replace it with `return true`. Now we will make the function do some
    more work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 优化编译器将会消除这个函数中的所有代码，并用`return true`替换它。现在我们将让函数做更多的工作：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same optimization is, of course, possible, since the code can be rewritten
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，同样的优化是可能的，因为代码可以重写如下：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The call to `g()` must be made, but the function still returns `true`: the
    comparison cannot produce anything else without lapsing into undefined behavior.
    Again, most compilers will do this optimization. We can confirm this by comparing
    the assembly generated from our original code with that generated from the fully
    hand-optimized code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`g()`必须进行，但函数仍然返回`true`：比较不能产生其他结果，否则会陷入未定义的行为。再次强调，大多数编译器都会进行这种优化。我们可以通过比较从原始代码生成的汇编和从完全手动优化的代码生成的汇编来确认这一点：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only reason the optimization is possible is because the `g()` function
    does not change its argument. In the same code, if `g()` takes the argument by
    reference, the optimization is no longer possible:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 优化之所以可能是因为`g()`函数不会改变其参数。在同样的代码中，如果`g()`通过引用获取参数，那么这种优化就不再可能：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now the `g()` function could change the value of `y`, so the comparison has
    to be made every time. If the intent for the function `g()` is not to change its
    arguments, we could, of course, just pass them by value (as we have already seen).
    The other option is to pass by `const` reference; while there is no reason to
    do so for small types, such as integers, template code often generates such functions.
    In this case, our code looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`g()`函数可能会改变`y`的值，因此每次都必须进行比较。如果函数`g()`的意图不是改变其参数，当然我们可以通过值传递参数（正如我们已经看到的）。另一个选择是通过`const`引用传递；虽然对于小类型（如整数）没有必要这样做，但模板代码通常会生成这样的函数。在这种情况下，我们的代码如下：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A quick examination of the assembler shows that the `return` statement is not
    optimized: it still does the comparison. Of course, the fact that a particular
    compiler does not do a certain optimization proves nothing: no optimizer is perfect.
    But in this case, there is a reason for it. Despite what the code says, the C++
    Standard does not guarantee that the `g()` function does not change its argument!
    Here is an entirely Standard-compliant implementation that elucidates the issue:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查汇编程序显示`return`语句没有被优化：它仍然进行比较。当然，某个特定编译器不执行某个优化并不能证明什么：没有优化器是完美的。但在这种情况下，是有原因的。尽管代码中这样写，但C++标准并不保证`g()`函数不会改变其参数！以下是一个完全符合标准的实现，阐明了这个问题：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Yes, a function is allowed to cast away `const`. The result is well defined
    and is specified in the standard (which does not make it a *good* code, just a
    valid one). There is one exception, however: casting away `const` from an object
    that was declared `const` at the point of its creation is UB. To illustrate, this
    is well defined (but ill-advised):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，函数允许去除`const`。结果是明确定义的，并且在标准中有规定（这并不意味着这是*好*的代码，只是有效的）。然而，有一个例外：从在其创建时被声明为`const`的对象中去除`const`是未定义行为。为了说明，这是明确定义的（但不建议）：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is UB:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未定义行为：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can try to take advantage of this by declaring the intermediate variable
    `y` as `const`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试利用这一点，通过将中间变量`y`声明为`const`：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the compiler can assume that the function always returns `true`: the only
    way to change that is to invoke UB, and the compiler is not required to condone
    UB. At the time of the writing of this book, we are not aware of any compiler
    that actually does this optimization.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器可以假定该函数总是返回`true`：改变这一点的唯一方法是调用未定义行为，而编译器并不需要容忍未定义行为。在撰写本书时，我们并不知道有任何编译器实际上进行了这种优化。
- en: With this in mind, what can be recommended with regard to the use of `const`
    to promote optimization?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，关于使用`const`来促进优化，可以推荐什么？
- en: If a value is not changing, declare it as `const`. While correctness is the
    main benefit, this does enable some optimizations, especially when the compiler
    can propagate the `const` by evaluating expressions at compile time.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个值不会改变，将其声明为`const`。虽然正确性是主要的好处，但这确实可以实现一些优化，特别是当编译器可以通过在编译时评估表达式来传播`const`时。
- en: Even better for the optimization, if the value is known at compile-time, declare
    it `constexpr`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了优化，如果值在编译时已知，声明为`constexpr`。
- en: Passing parameters by `const` reference to functions does next to nothing for
    optimization since the compiler has to assume that the function may cast away
    `const` (if the function is inlined, the compiler knows exactly what's going on,
    but then it doesn't matter how the parameters are declared). On the other hand,
    this is the only way you can pass a `const` object to a function, so yes, declare
    references to be `const` whenever possible (the more important result is the clarity
    of the intent).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`const`引用传递参数对于优化几乎没有什么作用，因为编译器必须假设函数可能会去除`const`（如果函数是内联的，编译器知道发生了什么，但参数的声明方式就不重要了）。另一方面，这是您可以将`const`对象传递给函数的唯一方式，因此，尽可能声明引用为`const`（更重要的结果是意图的清晰度）。
- en: For small types, pass-by-value can be more efficient than pass-by-reference
    (this does not apply to inlined functions). This is difficult to reconcile with
    generic functions generated by templates (don't assume that the templates are
    always inlined; large template functions often aren't). There are ways to force
    pass-by-value for specific types, but they make your template code much more cumbersome.
    Never start by writing such code; do it only if the measurements show that, for
    a particular piece of code, the effort is justified.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小类型，按值传递可能比按引用传递更有效（这不适用于内联函数）。这很难与模板生成的通用函数协调一致（不要假设模板总是内联的；大型模板函数通常不是）。有办法强制对特定类型进行按值传递，但这会使您的模板代码变得更加繁琐。不要从编写这样的代码开始；只有在测量表明对于特定代码片段来说，这种努力是合理的时候才这样做。
- en: We have explored in detail how UB in C++ affects the optimization of C++ code.
    It is now time to turn the tables and learn how to take advantage of UB in your
    own programs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细探讨了C++中未定义行为如何影响C++代码的优化。现在是时候扭转局面，学习如何利用未定义行为来优化您自己的程序。
- en: Using undefined behavior for efficient design
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用未定义行为进行高效设计
- en: In this section, we are going to talk about UB not as it is specified by the
    standard and applies to C++, but as it is specified by you, the programmer, and
    applies to your software. To get there, it is helpful first to consider UB from
    a different point of view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论未定义行为，不是作为标准规定并适用于C++，而是作为您，程序员，规定并适用于您的软件。为了达到这个目的，首先从不同的角度考虑未定义行为是有帮助的。
- en: All the examples of UB that we have seen so far can be divided into two kinds.
    The first kind is code such as `++k + k`. These are bugs, since such code has
    no defined behavior at all. The second kind is code such as `k + 1`, where `k`
    is a signed integer. This code is everywhere, and most of the time, it works just
    fine. Its behavior is well defined except for certain values of the variables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有未定义行为示例可以分为两种。第一种是诸如`++k + k`之类的代码。这些是错误，因为这样的代码根本没有定义的行为。第二种是诸如`k
    + 1`之类的代码，其中`k`是有符号整数。这种代码随处可见，大多数情况下都能正常工作。它的行为是明确定义的，除了某些变量值。
- en: 'In other words, the code has implicit preconditions: as long as these preconditions
    are satisfied, the program is well behaved. Note that in the larger context of
    the program, these preconditions may or may not be implicit: the program may validate
    the inputs or intermediate results and guard against values that would cause UB.
    Either way, the programmer has defined a contract with the user: if the inputs
    obey certain restrictions, the results are guaranteed to be correct; in other
    words, the program behaves in a well-defined way.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，代码具有隐含的前提条件：只要这些前提条件得到满足，程序就会表现良好。请注意，在程序的更大上下文中，这些前提条件可能是隐含的，也可能不是：程序可能会验证输入或中间结果，并防范会导致未定义行为的值。无论哪种方式，程序员都与用户定义了一个合同：如果输入遵守某些限制，结果就保证是正确的；换句话说，程序的行为是明确定义的。
- en: What happens when the restrictions are violated?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当违反限制时会发生什么？
- en: 'There are the following two possibilities:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有以下两种可能性：
- en: First, the program may detect that the inputs are out of contract and handle
    the error. This behavior is still well defined and is a part of the specification.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，程序可能会检测到输入违反了合同并处理错误。这种行为仍然是明确定义的，并且是规范的一部分。
- en: Second, the program may fail to detect that the contract is violated and proceed
    as it usually does. Since the contract was essential to guarantee the correct
    result, the program now operates in uncharted territory, and there is, generally,
    no way to predict what is going to happen.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，程序可能无法检测到合同被违反，并像通常一样继续进行。由于合同对于保证正确结果至关重要，程序现在在未知领域操作，通常情况下无法预测会发生什么。
- en: We just described UB.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述了UB。
- en: Now that we understand that UB is simply the behavior of the program that is
    operating outside of the specified contract, let's think about how it applies
    to our software.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了UB只是程序在规定合同之外运行的行为，让我们想想它如何适用于我们的软件。
- en: Most programs that are complex enough have preconditions on their inputs, a
    contract with the user. One could argue that these preconditions should always
    be checked and any errors reported. However, this can be a very expensive requirement.
    Again, let's consider an example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数足够复杂的程序都对其输入有前提条件，与用户有合同。有人可能会认为这些前提条件应该始终被检查并报告任何错误。然而，这可能是一个非常昂贵的要求。再次，让我们考虑一个例子。
- en: 'We want to write a program that scans an image drawn on a piece of paper (or
    etched on a printed circuit board) and converts it to a graph data structure.
    The input to the program may look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想编写一个程序，扫描在纸上绘制的图像（或蚀刻在印刷电路板上），并将其转换为图形数据结构。程序的输入可能如下所示：
- en: '![Figure 11.8 – Graph drawing is an input to the graph construction program'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 - 图形绘制是图形构建程序的输入'
- en: '](img/Figure_10.8_B16229.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B16229.jpg)'
- en: Figure 11.8 – Graph drawing is an input to the graph construction program
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 图形绘制是图形构建程序的输入
- en: The program acquires the image, recognizes rectangles, creates graph nodes from
    each one, recognizes the lines, for each line figures out which two rectangles
    it connects, and creates a corresponding edge in the graph.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序获取图像，识别矩形，从每个矩形创建图节点，识别线条，对于每条线条找出它连接的两个矩形，并在图中创建相应的边。
- en: Let's assume that we have an image acquisition and analysis library that gives
    us a set of shapes (rectangles and lines) with all their coordinates. All we have
    to do now is figure out which lines connect which rectangles. We have all the
    coordinates, so it's pure geometry from now on. One of the simplest ways to represent
    this graph is as a table of edges. We can use any container (say, a vector) for
    the table, and if we assign each node a unique numeric ID, an edge is just a pair
    of numbers. We can use any number of computational geometry algorithms to detect
    intersections between lines and rectangles and construct this table (and, with
    it, the graph itself) edge by edge.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个图像获取和分析库，可以为我们提供一组形状（矩形和线条）及其所有坐标。现在我们所要做的就是弄清楚哪些线连接哪些矩形。我们已经有了所有坐标，所以从现在开始就是纯几何。表示这个图形的最简单方法之一是作为边的表格。我们可以使用任何容器（比如说，一个向量）来存储表格，如果我们为每个节点分配一个唯一的数字ID，那么一条边就是一对数字。我们可以使用任意数量的计算几何算法来检测线条和矩形之间的交点，并构建这个表格（以及图形本身）一条边一条边地。
- en: 'Sounds simple enough, and we have a natural representation of the data that
    is fairly compact and easy to work with. Unfortunately, we also have an implicit
    contract with the user: we ask that every line intersects exactly two rectangles
    (also, that rectangles do not intersect each other, but one mess at a time).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来足够简单，我们有一个自然的数据表示，相当紧凑且易于处理。不幸的是，我们还与用户有一个隐含的合同：我们要求每条线都恰好与两个矩形相交（还有，矩形之间不相交，但一次只处理一个混乱）。
- en: '![Figure 11.9 – Invalid input for the graph recognition program'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9 - 图形识别程序的无效输入'
- en: '](img/Figure_10.9_B16229.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B16229.jpg)'
- en: Figure 11.9 – Invalid input for the graph recognition program
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 图形识别程序的无效输入
- en: 'In *Figure 11\. 9*, we see an example of input that violates the contract:
    one of the lines connects three rectangles, while the other touches just one.
    As we discussed earlier, we have two options: we can detect and report the input
    errors, or we can ignore them. The first option makes our program robust but carries
    a significant performance penalty: our original program could stop looking for
    rectangles connected to a given edge after it found the second such rectangle
    and just ignore the edge from then on. The gain from this optimization turns out
    to be considerable: for a graph that looks like *Figure 11.8* (but much larger),
    it may cut the run time by half. Enforcing input validation wastes a lot of time
    if the input ends up being correct and frustrates the users who have other ways
    of ensuring that the input is valid. Not validating the input leads to UB: if
    we have a line connecting three rectangles, the algorithm will stop after finding
    the first two in whatever order it processes them (and this order may be data-dependent,
    so all you can really say about this situation is that an edge will be created
    between two of the nodes involved).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.9*中，我们看到了一个违反合同的输入示例：一条线连接了三个矩形，而另一条线只接触了一个。正如我们之前讨论的，我们有两个选择：我们可以检测并报告输入错误，或者我们可以忽略它们。第一种选择使我们的程序更加健壮，但带来了显著的性能损失：我们的原始程序在找到第二个连接到给定边的矩形后可能会停止寻找，并且从那时起忽略该边。这种优化的收益是相当可观的：对于一个看起来像*图11.8*的图形（但规模更大），它可能将运行时间减少一半。强制执行输入验证会浪费大量时间，如果输入最终是正确的，会让用户感到沮丧，因为他们有其他方法来确保输入是有效的。不验证输入会导致UB：如果我们有一条线连接了三个矩形，算法将在找到前两个矩形后停止（并且这个顺序可能依赖于数据，所以你真正能说的是，边将在涉及的两个节点之间创建）。
- en: 'If the performance difference was insignificant (or the overall runtime was
    so short that doubling it doesn''t matter), the best solution would be clear:
    validate the inputs. But in this and many other cases, validation is easily as
    expensive as finding the solution. What should be done in such cases?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能差异微不足道（或者总运行时间如此之短，使其加倍无关紧要），最佳解决方案将是明显的：验证输入。但在这种情况下以及许多其他情况下，验证很容易与找到解决方案一样昂贵。在这种情况下应该怎么办？
- en: First and foremost, we must be clear about the contract we are imposing on the
    user. We should clearly specify and document what constitutes a valid input. After
    that, the best practice for performance-critical programs is to deliver the best
    performance. A broader contract (the one that imposes fewer restrictions) is always
    better than a narrow contract, so if there are some invalid inputs we can easily
    detect and handle with minimal overhead, this should be done. Beyond that, all
    we can do is document the conditions when the behavior of the program is undefined,
    just like it is done in the C++ Standard.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须明确用户所承担的契约。我们应该清楚地指定和记录什么构成有效输入。之后，对于性能关键的程序，最佳实践是提供最佳性能。更广泛的契约（对限制较少的那种）总是比较窄的契约更好，因此，如果有一些无效输入，我们可以轻松检测并以最小的开销处理，那就应该这样做。除此之外，我们所能做的就是记录程序行为未定义的条件，就像C++标准中所做的那样。
- en: 'There is some extra effort that we can make: we can offer our users an input
    validation tool, either as an optional step in the program or as a separate piece
    of software. Running it will take time, but if the user is getting strange results
    from the main program, they can check to make sure the inputs are valid. This
    is highly preferable to simply describing when the behavior is undefined (however,
    there are cases where such validation is too expensive to be practical).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些额外的努力：我们可以为用户提供一个输入验证工具，可以作为程序中的可选步骤或作为一个独立的软件。运行它会花费时间，但如果用户从主程序中获得奇怪的结果，他们可以检查确保输入是有效的。这比简单地描述行为何时未定义要好得多（然而，有些情况下，这种验证成本太高而不切实际）。
- en: 'Wouldn''t it be nice if the C++ compiler developers made the same extra effort
    for us, the programmers, and gave us an optional tool to detect UB in our code?
    As it turns out, the developers thought so too: many compilers today have an option
    to enable the UB sanitizer (often called **UBSan**). This is how it works. Let''s
    start with some code that can result in UB:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器开发人员是否可以为我们程序员做出同样的额外努力，并为我们提供一个可选工具来检测代码中的UB，这不是很好吗？事实证明，开发人员也这样认为：如今许多编译器都有启用UB
    sanitizer（通常称为**UBSan**）的选项。它的工作原理如下。让我们从一些可能导致UB的代码开始：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write a program that calls this function with a large enough argument (greater
    than `INT_MAX-10`) and compile it with the UBSan enabled. For Clang or GCC, the
    option is `-fsanitize=undefined`. Here''s an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个调用此函数的程序，参数足够大（大于`INT_MAX-10`），并启用UBSan编译。对于Clang或GCC，选项是`-fsanitize=undefined`。以下是一个例子：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the program, and you will see something like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你会看到类似以下的内容：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Just like in our graph example, UB detection takes time and makes the program
    slower, so this is something you should do in testing and debugging. Make sanitized
    runs part of your regular regression testing, and do take the reported errors
    seriously: just because your program produces correct results today does not mean
    that the next compiler will not generate some very different code and change the
    results.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的图表示例一样，UB检测需要时间并使程序变慢，因此这是你在测试和调试中应该做的事情。将经过消毒处理的运行作为常规回归测试的一部分，并且要认真对待报告的错误：仅仅因为你的程序今天产生了正确的结果，并不意味着下一个编译器不会生成一些非常不同的代码并改变结果。
- en: We have learned about UB, why it is sometimes a necessary evil, and how to take
    advantage of it to improve performance. Before you flip the page, let's recap
    what we have learned.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了UB，为什么它有时是一个必要的恶，并且如何利用它来提高性能。在翻页之前，让我们回顾一下我们学到的内容。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have a whole chapter dedicated to the subject of UB in C++ and in programs
    in general. Why? Because this subject is inextricably linked to performance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门讨论C++中UB的整章，为什么呢？因为这个主题与性能密切相关。
- en: First of all, understand that UB occurs when the program receives an input that
    is outside of the contract that specifies the program's behavior. In addition,
    the specification also says that the program is not required to detect such input
    and issue a diagnostic. This is true for the UB as defined by the C++ Standard
    and for the UB of your own program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要理解当程序接收到超出规定程序行为的契约的输入时，就会发生UB。此外，规范还表示程序不需要检测此类输入并发出诊断。这适用于C++标准定义的UB以及您自己程序中的UB。
- en: 'Next, the reason the specification (or the standard) does not cover all possible
    inputs and defining the results is mostly related to performance: UB is often
    introduced when it would be very expensive to produce a specific result reliably.
    For UB in C++, the variety of processor and memory architectures also leads to
    cases that are difficult to handle uniformly. Without a viable way to guarantee
    a specific result, the standard leaves the outcome undefined.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，规范（或标准）未涵盖所有可能的输入并定义结果的原因主要与性能有关：当需要可靠地产生特定结果时，引入UB通常会非常昂贵。对于C++中的UB，处理器和内存架构的多样性也导致了难以统一处理的情况。在没有可行的方法来保证特定结果的情况下，标准将结果留空。
- en: 'Finally, the reason the program is not required to at least detect, if not
    handle, the invalid input is that such detection may also be very costly: sometimes
    it takes longer to confirm that the input is valid than to compute the result.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序不需要至少检测，如果不处理无效输入的原因是，这样的检测可能也非常昂贵：有时确认输入有效比计算结果花费的时间更长。
- en: 'You should keep these considerations in mind when designing software: it is
    always desirable to have a broad contract that defines the outcome for any or
    almost any input. But doing so can impose performance overhead on users who only
    provide the typical or "normal" input. When offered a choice between faster execution
    of a task the user wants to do and reliable execution of a task the user never
    wants to solve in the first place, most users will choose performance. As a compromise,
    you can offer the users a way to validate the inputs; if this validation is costly,
    it should be optional.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计软件时，你应该牢记这些考虑因素：始终希望有一个广泛的合同，为任何或几乎任何输入定义结果。但这样做可能会给只提供典型或“正常”输入的用户带来性能开销。当用户面临更快地执行所需任务和可靠地执行用户根本不想解决的任务之间的选择时，大多数用户会选择性能。作为一种妥协，你可以为用户提供一种验证输入的方式；如果这种验证是昂贵的，它应该是可选的。
- en: When it comes to UB laid out by the C++ Standard, the tables are turned, and
    you are the user. It is essential to understand that if a program includes code
    with UB, the entire program is ill-defined, not just the one line in question.
    This is because the compiler can assume that UB never happens at runtime and reason
    backward from that to make the corresponding optimizations to your code. Modern
    compilers all do that to some extent, and future compilers will only be more aggressive
    in their deductions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到C++标准规定的UB时，情况就变了，你成了用户。重要的是要理解，如果程序包含具有UB的代码，整个程序就是不明确定义的，不仅仅是问题中的一行代码。这是因为编译器可以假设在运行时永远不会发生UB，并从此进行推理，以对代码进行相应的优化。现代编译器在某种程度上都这样做，未来的编译器只会更加积极地进行推理。
- en: Finally, many compiler developers also offer validation tools that can detect
    undefined behavior at run time – UB sanitizers. Just like a validator for the
    input of your own program, these tools take time to run, which is why the sanitizer
    is an optional tool. You should take advantage of it in your software testing
    and development process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多编译器开发者还提供可以在运行时检测未定义行为的验证工具 - UB消毒剂。就像你自己程序的输入验证器一样，这些工具需要时间运行，这就是为什么消毒剂是一个可选工具。你应该在软件测试和开发过程中利用它。
- en: We are almost at the end of the book; in the next, which is the final chapter,
    we will review everything we have learned with an eye for the implications and
    lessons for designing software.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到了书的结尾；在下一章，也就是最后一章中，我们将以考虑设计软件的含义和教训的眼光回顾我们所学到的一切。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is undefined behavior?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是未定义行为？
- en: Why can't we define the results for any situation the program may encounter?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不能为程序可能遇到的任何情况定义结果？
- en: If I write code the standard labels as UB, test the result, and verify that
    the code works, I'm OK, right?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我编写了标准标记为UB的代码，测试结果，并验证代码有效，我没问题，对吗？
- en: Why would I want to intentionally design a program that has documented undefined
    behavior?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我要故意设计一个具有记录的未定义行为的程序？
