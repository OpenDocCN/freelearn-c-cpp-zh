- en: '*Chapter 6*: Building an Abstract Renderer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：构建抽象渲染器'
- en: This book focuses on animation, not rendering. However, rendering an animated
    model is important. In order to avoid getting caught up in any specific graphics
    APIs, in this chapter, you will build an abstraction layer on top of OpenGL. This
    will be a thin abstraction layer, but it will let you work on your animation in
    later chapters without having to do anything OpenGL-specific.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书侧重于动画，而不是渲染。然而，渲染动画模型是很重要的。为了避免陷入任何特定的图形API中，在本章中，您将在OpenGL之上构建一个抽象层。这将是一个薄的抽象层，但它将让您在后面的章节中处理动画，而无需执行任何特定于OpenGL的操作。
- en: The abstract renderer you will implement in this chapter is very lightweight.
    It doesn't have a lot of features, only the ones you need to display animated
    models. This should make porting the renderer to other APIs straightforward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中您将实现的抽象渲染器非常轻量。它没有很多功能，只有您需要显示动画模型的功能。这应该使得将渲染器移植到其他API变得简单。
- en: 'By the end of this chapter, you should be able to render some debug geometry
    to the window using the abstract rendering code you will create. On a higher level,
    you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够使用您创建的抽象渲染代码在窗口中渲染一些调试几何体。在更高的层次上，您将学到以下内容：
- en: How to create shaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建着色器
- en: How to store mesh data in buffers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在缓冲区中存储网格数据
- en: How to bind those buffers as shader attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将这些缓冲区绑定为着色器属性
- en: How to send uniform data to a shader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向着色器发送统一数据
- en: How to render with index buffers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用索引缓冲区进行渲染
- en: How to load textures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载纹理
- en: Basic OpenGL concepts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的OpenGL概念
- en: Creating and working with simple shaders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用简单的着色器
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Some familiarity with OpenGL will make this chapter much easier to follow. OpenGL,
    lighting models, and shader tricks are out of the scope of this book. For more
    information on these topics, check out [https://learnopengl.com/](https://learnopengl.com/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对OpenGL的一些了解将使本章更容易理解。OpenGL、光照模型和着色器技巧不在本书的范围之内。有关这些主题的更多信息，请访问[https://learnopengl.com/](https://learnopengl.com/)。
- en: Working with shaders
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用着色器
- en: The most important part of the abstraction layer is the `Shader` class. To draw
    something, you must bind a shader and attach some attributes and uniforms to it.
    The shader describes how the thing being drawn should be transformed and shaded,
    while attributes define what is being drawn.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层中最重要的部分是`Shader`类。要绘制某物，您必须绑定一个着色器并将一些属性和统一附加到它上。着色器描述了被绘制的东西应该如何变换和着色，而属性定义了正在被绘制的内容。
- en: In this section, you will implement a `Shader` class that can compile vertex
    and fragment shaders. The `Shader` class will also return uniform and attribute
    indices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将实现一个`Shader`类，它可以编译顶点和片段着色器。`Shader`类还将返回统一和属性索引。
- en: The Shader class declaration
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器类声明
- en: 'When implementing the `Shader` class, you will need to declare several protected
    helper functions. These functions will keep the public API of the class clean;
    they are used for things such as reading a file into a string or calling an OpenGL
    code to compile the shader:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`Shader`类时，您需要声明几个受保护的辅助函数。这些函数将保持类的公共API清晰；它们用于诸如将文件读入字符串或调用OpenGL代码来编译着色器的操作：
- en: 'Create a new file to declare the `Shader` class in; call it `Shader.h`. The
    `Shader` class should have a handle to the OpenGL shader object and maps for attribute
    and uniform indices. These dictionaries have a string for a key (the name of the
    attribute or uniform) and `unsigned int` for a value (the index of the uniform
    or attribute):'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件来声明`Shader`类，命名为`Shader.h`。`Shader`类应该有一个指向OpenGL着色器对象的句柄，以及属性和统一索引的映射。这些字典有一个字符串作为键（属性或统一的名称）和一个`unsigned
    int`作为值（统一或属性的索引）：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The copy constructor and assignment operator of the `Shader` class should be
    disabled. The `Shader` class is not intended to be copied by value since it holds
    a handle to a GPU resource:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Shader`类的复制构造函数和赋值运算符应该被禁用。`Shader`类不打算通过值进行复制，因为它持有一个GPU资源的句柄：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you need to declare the helper function in the `Shader` class. The `ReadFile`
    function will read the contents of a file into `std::string`. The `CompileVertexShader`
    and `CompileFragmentShader` functions compile shader source code and return an
    OpenGL handle. The `LinkShader` function will link two shaders into a shader program.
    The `PopulateAttribute` and `PopulateUniform` functions will fill out the attribute
    and uniform dictionaries:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要在`Shader`类中声明辅助函数。`ReadFile`函数将文件内容读入`std::string`中。`CompileVertexShader`和`CompileFragmentShader`函数编译着色器源代码并返回OpenGL句柄。`LinkShader`函数将两个着色器链接成一个着色器程序。`PopulateAttribute`和`PopulateUniform`函数将填充属性和统一字典：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The default constructor of the class will create an empty `Shader` object.
    The overload constructor will call the `Load` method, which loads shaders from
    files and compiles them. The destructor will release the OpenGL shader handle
    that the `Shader` class is holding on to:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的默认构造函数将创建一个空的`Shader`对象。重载构造函数将调用`Load`方法，从文件加载着色器并编译它们。析构函数将释放`Shader`类持有的OpenGL着色器句柄：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before a shader is used, it will need to be bound with the `Bind` function.
    Similarly, after it is no longer in use, it can be unbound with the `UnBind` function.
    The `GetAttribute` and `GetUniform` functions perform lookups in the appropriate
    dictionaries. The `GetHandle` function returns the shader''s OpenGL handle:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用着色器之前，需要使用`Bind`函数绑定它。同样，在不再使用时，可以使用`UnBind`函数解绑它。`GetAttribute`和`GetUniform`函数在适当的字典中执行查找。`GetHandle`函数返回着色器的OpenGL句柄：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that the `Shader` class declaration is done, you will implement it in the
    next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Shader`类声明完成后，您将在下一节中实现它。
- en: Implementing the Shader class
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现着色器类
- en: Create a new file, `Shader.cpp`, to implement the `Shader` class in. The `Shader`
    class implementation hides almost all of the actual OpenGL code from the caller.
    Because most OpenGL calls are abstracted this way, in later chapters, you only
    have to call the abstraction layer, not the OpenGL functions, directly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Shader.cpp`，来实现`Shader`类。`Shader`类的实现几乎将所有实际的OpenGL代码隐藏在调用者之外。因为大多数OpenGL调用都是通过这种方式抽象的，在后面的章节中，您只需要调用抽象层，而不是直接调用OpenGL函数。
- en: 'Uniform arrays are used throughout this book. When a uniform array is encountered
    in a shader (for example, `modelMatrices[120]`) the uniform name returned by `glGetActiveUniform`
    is the first element of the array. In this example, that would be `modelMatrices[0]`.
    When you encounter a uniform array, you want to loop through all the array indices
    and get the explicit uniform indices for each element, but you also want to store
    the uniform name without any subscripts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中始终使用统一数组。当在着色器中遇到统一数组（例如`modelMatrices[120]`），`glGetActiveUniform`返回的统一名称是数组的第一个元素。在这个例子中，那将是`modelMatrices[0]`。当遇到统一数组时，您希望循环遍历所有数组索引，并为每个元素获取显式的统一索引，但您还希望存储没有任何下标的统一名称：
- en: 'Both `Shader` constructors must create a new shader program handle by calling
    `glCreateProgram`. The constructor variant that takes two strings calls the `Load`
    function with the strings. Since `mHandle` is always a program handle, the destructor
    needs to delete the handle:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个`Shader`构造函数必须通过调用`glCreateProgram`创建一个新的着色器程序句柄。接受两个字符串的构造函数变体调用`Load`函数处理这些字符串。由于`mHandle`始终是一个程序句柄，析构函数需要删除该句柄：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ReadFile` helper function converts a file into a string using `std::ifstream`
    to read the contents of the file into `std::stringstream`. The string stream can
    be used to return the contents of the file as a string:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadFile`辅助函数使用`std::ifstream`将文件转换为字符串，以读取文件的内容到`std::stringstream`中。字符串流可用于将文件内容作为字符串返回：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `CompileVertexShader` function is boilerplate code for compiling an OpenGL
    vertex shader. First, create the shader object with `glCreateShader`, then set
    the source for the shader with `glShaderSource`. Finally, compile the shader with
    `glCompileShader`. Check for errors with `glGetShaderiv`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompileVertexShader`函数是用于编译OpenGL顶点着色器的样板代码。首先，使用`glCreateShader`创建着色器对象，然后使用`glShaderSource`为着色器设置源。最后，使用`glCompileShader`编译着色器。使用`glGetShaderiv`检查错误：'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `CompileFragmentShader` function is almost identical to the `CompileVertexShader`
    function. The only real difference is the argument to `glCreateShader`, indicating
    that you are creating a fragment shader, not a vertex shader:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompileFragmentShader`函数与`CompileVertexShader`函数几乎完全相同。唯一的真正区别是`glCreateShader`的参数，表明您正在创建一个片段着色器，而不是顶点着色器：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `LinkShaders` helper function is also boilerplate. Attach the shaders to
    the shader program handle that the constructor created. Link the shaders by calling
    `glLinkProgram` and check for errors with `glGetProgramiv`. Once the shaders are
    linked, you only need the program; the individual shader objects can be deleted
    with `glDeleteShader`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LinkShaders`辅助函数也是样板。将着色器附加到构造函数创建的着色器程序句柄。通过调用`glLinkProgram`链接着色器，并使用`glGetProgramiv`检查错误。一旦着色器被链接，您只需要程序；可以使用`glDeleteShader`删除各个着色器对象：'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `PopulateAttributes` function enumerates all the attributes stored inside
    the shader program, then stores them as a key-value pair, where the key is the
    name of the attribute and the value is its location. You can count the number
    of active attributes in a shader program with the `glGetProgramiv` function, passing
    `GL_ACTIVE_ATTRIBUTES` as the parameter name. Then, loop through all the attributes
    by index and use `glGetActiveAttrib` to get the name of each attribute. Finally,
    call `glGetAttribLocation` to get the location of each attribute:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PopulateAttributes`函数枚举存储在着色器程序中的所有属性，然后将它们存储为键值对，其中键是属性的名称，值是其位置。您可以使用`glGetProgramiv`函数计算着色器程序中活动属性的数量，将`GL_ACTIVE_ATTRIBUTES`作为参数名称传递。然后，通过索引循环遍历所有属性，并使用`glGetActiveAttrib`获取每个属性的名称。最后，调用`glGetAttribLocation`获取每个属性的位置：'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `PopulateUniforms` helper function is very similar to the `PopulateAttributes`
    helper function. `glGetProgramiv` needs to take `GL_ACTIVE_UNIFORMS` as the parameter
    name and you need to call `glGetActiveUniform` and `glGetUniformLocation`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PopulateUniforms`辅助函数与`PopulateAttributes`辅助函数非常相似。`glGetProgramiv`需要以`GL_ACTIVE_UNIFORMS`作为参数名称，并且您需要调用`glGetActiveUniform`和`glGetUniformLocation`：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When a valid uniform is encountered, you need to determine whether the uniform
    is an array or not. To do this, search for the array bracket (`[`) in the uniform
    name. If the bracket is found, the uniform is an array:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当遇到有效的统一时，您需要确定该统一是否是一个数组。为此，在统一名称中搜索数组括号（`[`）。如果找到括号，则该统一是一个数组：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you encounter a uniform array, erase everything out of the string, starting
    with `[`. This will leave you with only the uniform name. Then, enter a loop where
    you try to retrieve every index from the array by appending `[ + index + ]` to
    the uniform name. Once the first invalid index is found, break the loop:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到一个统一数组，从`[`开始擦除字符串中的所有内容。这将使您只剩下统一的名称。然后，进入一个循环，尝试通过将`[ + index + ]`附加到统一名称来检索数组中的每个索引。一旦找到第一个无效的索引，就打破循环：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, `uniformName` contains the name of the uniform. If that uniform
    was an array, the `[0]` part of the name has been removed. Store the uniform index
    by name in `mUniforms`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，`uniformName`包含统一的名称。如果该统一是一个数组，则名称的`[0]`部分已被移除。按名称将统一索引存储在`mUniforms`中：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final helper function is the `Load` function, which is responsible for
    loading the actual shaders. This function takes two strings, which are either
    filenames or inline shader definitions. Once the shaders are read, call the `Compile`,
    `Link`, and `Populate` helper functions to load the shader:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个辅助函数是`Load`函数，负责加载实际的着色器。此函数接受两个字符串，可以是文件名或内联着色器定义。一旦读取了着色器，调用`Compile`、`Link`和`Populate`辅助函数来加载着色器：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Bind` function needs to set the current shader program to active, while
    `UnBind` should make sure no `Shader` objects are active. The `GetHandle` helper
    function returns the OpenGL handle to the `Shader` object:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bind`函数需要将当前着色器程序设置为活动状态，而`UnBind`应确保没有活动的`Shader`对象。`GetHandle`辅助函数返回`Shader`对象的OpenGL句柄：'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, you need a way of retrieving the bind slots for attributes and uniforms.
    The `GetAttribute` function will check whether a given attribute name is present
    in the attribute map. If it is, the integer representing it is returned. If it
    is not, `0` is returned. `0` is a valid attribute index, so in case of an error,
    an error message is logged as well:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要一种方法来检索属性和统一的绑定槽。`GetAttribute`函数将检查给定的属性名称是否存在于属性映射中。如果存在，则返回表示它的整数。如果没有，则返回`0`。`0`是有效的属性索引，因此在出现错误的情况下，还会记录错误消息：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `GetUniform` function is implemented almost identically to the `GetAttribute`
    function, except instead of the attribute map, it works on the uniform map:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetUniform`函数的实现几乎与`GetAttribute`函数相同，只是它不是在属性映射上工作，而是在统一映射上工作：'
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Shader` class has methods to retrieve indices for uniforms and attributes.
    In the next section, you will start implementing an `Attribute` class to hold
    vertex data that is passed to shaders.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shader`类有方法来检索统一和属性的索引。在下一节中，您将开始实现一个`Attribute`类来保存传递给着色器的顶点数据。'
- en: Working with buffers (attributes)
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓冲区（属性）
- en: 'Attributes are per-vertex data in the graphics pipeline. A vertex is made up
    of attributes. For example, a vertex has a position and a normal, which are both
    attributes. The most common attributes are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是图形管道中的每个顶点数据。一个顶点由属性组成。例如，一个顶点有一个位置和一个法线，这两个都是属性。最常见的属性如下：
- en: 'Position: Often in local space'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：通常在局部空间中
- en: 'Normal: The direction the vertex points in'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法线：顶点指向的方向
- en: 'UV or texture coordinate: The normalized (*x*,*y*) coordinate on a texture'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UV或纹理坐标：纹理上的标准化（*x*，*y*）坐标
- en: 'Color: A `vector3` representing the color of a vertex'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色：表示顶点颜色的`vector3`
- en: Attributes can have different data types. Throughout this book, you will implement
    support for integers, floats, and vector attributes. For vector attributes, two-,
    three-, and four-dimensional vectors will be supported.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以具有不同的数据类型。在本书中，您将实现对整数、浮点数和矢量属性的支持。对于矢量属性，将支持二维、三维和四维向量。
- en: The Attribute class declaration
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Attribute`类声明'
- en: 'Create a new file, `Attribute.h`. The `Attribute` class will be declared in
    this new file. The `Attribute` class will be templated. This will ensure that
    if an attribute is meant to be `vec3`, you cannot accidentally load `vec2` into
    it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Attribute.h`。`Attribute`类将在这个新文件中声明。`Attribute`类将被模板化。这将确保如果一个属性被认为是`vec3`，您不能意外地将`vec2`加载到其中：
- en: 'The attribute class will contain two member variables, one for the OpenGL attribute
    handle one to count how much data the `Attribute` class contains. Since the attribute
    data lives on the GPU and you don''t want to have multiple handles to the same
    data, the copy constructor and `assignment operator` should be disabled:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性类将包含两个成员变量，一个用于OpenGL属性句柄，一个用于计算`Attribute`类包含的数据量。由于属性数据存储在GPU上，您不希望有多个句柄指向相同的数据，因此应禁用复制构造函数和`赋值运算符`：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `SetAttribPointer` function is special, as it will need to be implemented
    once for each type of attribute that will be supported. This will be done explicitly
    in the `.cpp` file, later:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetAttribPointer`函数很特殊，因为它需要为每种支持的属性类型实现一次。这将在`.cpp`文件中明确完成：'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Declare the constructor and destructor of the Attribute class as public functions:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Attribute`类的构造函数和析构函数声明为公共函数：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Attribute` class needs a `Set` function, which will upload an array of
    data to the GPU. Each element in the array represents the attribute for one vertex.
    We need a way of binding and unbinding attributes from bind slots defined by the
    shader, as well as accessors for the count and handle of the attribute:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attribute`类需要一个`Set`函数，它将数组数据上传到GPU。数组中的每个元素表示一个顶点的属性。我们需要一种从着色器定义的绑定槽中绑定和解绑属性的方法，以及属性的计数和句柄的访问器：'
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that you have declared the `Attribute` class, you will be implementing it
    in the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经声明了`Attribute`类，您将在下一节中实现它。
- en: Implementing the Attribute class
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`Attribute`类
- en: 'Create a new file, `Attribtue.cpp`. You will be implementing the `Attribute`
    class in this file as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Attribtue.cpp`。您将在此文件中实现`Attribute`类如下：
- en: 'The `Attribute` class is templated, but none of its functions are marked as
    inline. The template specializations for each attribute type will live in the
    `Attribute.cpp` file. Add specializations for the integer, floating point, `vec2`,
    `vec3`, `vec4`, and `ivec4` types:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attribute`类是模板的，但它的函数都没有标记为内联。每种属性类型的模板特化将存在于`Attribute.cpp`文件中。为整数、浮点数、`vec2`、`vec3`、`vec4`和`ivec4`类型添加特化：'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The constructor should generate an OpenGL buffer and store it in the handle
    of the `Attribute` class. The destructor is responsible for freeing the handle
    that the `Attribute` class is holding on to:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数应生成一个OpenGL缓冲区并将其存储在`Attribute`类的句柄中。析构函数负责释放`Attribute`类持有的句柄：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Attribute` class has two simple getters, one to retrieve the count and
    one to retrieve the OpenGL handle. The count represents how many total attributes
    there are:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attribute`类有两个简单的getter，一个用于检索计数，一个用于检索OpenGL句柄。计数表示总共有多少个属性：'
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Set` function takes an array and a length. It then binds the buffer that
    the `Attribute` class is holding on to and uses `glBufferData` to fill the buffer
    with data. There is a convenience function for `Set` that takes a vector reference
    instead of an array. It calls the actual `Set` function:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Set`函数接受一个数组和一个长度。然后绑定`Attribute`类持有的缓冲区，并使用`glBufferData`填充缓冲区数据。有一个方便的`Set`函数，它接受一个向量引用而不是数组。它调用实际的`Set`函数：'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `SetAttribPointer` function wraps `glVertesAttribPointer` or `glVertesAttribIPointer`.
    The arguments and which function to call are different based on what the type
    of the `Attribute` class is. To remove any ambiguity, provide explicit implementations
    for all supported template types. Start by implementing the `int`, `ivec4`, and
    `float` types:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetAttribPointer`函数包装了`glVertesAttribPointer`或`glVertesAttribIPointer`。根据`Attribute`类的类型，参数和要调用的函数是不同的。为了消除任何歧义，为所有支持的模板类型提供显式实现。首先实现`int`、`ivec4`和`float`类型：'
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `vec2`, `vec3`, and `vec4` types next. These are all very similar
    to the `float` type. The only difference is the second argument to `glVertexAttribPointer`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来实现`vec2`、`vec3`和`vec4`类型。这些都与`float`类型非常相似。唯一的区别是`glVertexAttribPointer`的第二个参数：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last two functions of the `Attribute` class need to bind and unbind the
    attribute to a slot specified in the `Shader` class. Since the `glVertexAttribPointer`
    function is different based on the templated type of the `Attribute` class, `Bind`
    will call the `SetAttribPointer` helper function:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attribute`类的最后两个函数需要将属性绑定到`Shader`类中指定的槽位，并解除绑定。由于`Attribute`类的模板类型不同，`Bind`将调用`SetAttribPointer`辅助函数：'
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Attribute` data changes per vertex. There is another type of data you will
    need to set: uniforms. Unlike attributes, uniforms remain the same throughout
    the execution of your shader program. You will implement uniforms in the next
    section.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute`数据每个顶点都会发生变化。您需要设置另一种类型的数据：uniforms。与属性不同，uniforms在着色器程序执行期间保持不变。您将在下一节中实现uniforms。'
- en: Working with uniforms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用uniforms
- en: Unlike attributes, uniforms are constant data; they are set once. The value
    of a uniform remains the same for all vertices processed. Uniforms can be created
    as arrays, a feature you will use in later chapters to implement mesh skinning.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性不同，uniforms是常量数据；它们只设置一次。uniform的值对所有处理的顶点保持不变。uniforms可以创建为数组，这是您将在后续章节中用来实现网格蒙皮的功能。
- en: 'Like the `Attribute` class, the `Uniform` class will also be templated. Unlike
    attributes, however, there will never be an instance of a `Uniform` class. It
    only needs public static functions. For each uniform type, there are three functions:
    one to set an individual uniform value, one to set an array of uniform values,
    and a convenience function that sets an array of values but uses a vector for
    input.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Attribute`类一样，`Uniform`类也将是模板化的。但与属性不同，永远不会有`Uniform`类的实例。它只需要公共静态函数。对于每种uniform类型，有三个函数：一个用于设置单个uniform值，一个用于设置一组uniform值，一个便利函数用于设置一组值，但使用向量作为输入。
- en: The Uniform class declaration
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Uniform类声明
- en: 'Create a new file, `Uniform.h`. You will be implementing the `Uniform` class
    in this new file. The `Uniform` class will never be instantiated since there won''t
    be any instances of this class. Disable the constructor and copy the constructor,
    assignment operator, and destructor. What the class will have is three overloads
    of a static `Set` function. The `Set` function will need to be specified for each
    template type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`Uniform.h`。您将在这个新文件中实现`Uniform`类。`Uniform`类永远不会被实例化，因为不会有这个类的实例。禁用构造函数和复制构造函数、赋值运算符和析构函数。该类将具有三个静态`Set`函数的重载。`Set`函数需要为每种模板类型指定：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You just finalized the declaration of the `Uniform` class. In the next section,
    you will start implementing the `Uniform` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚完成了`Uniform`类的声明。在下一节中，您将开始实现`Uniform`类。
- en: Implementing the Uniform class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Uniform类
- en: Create a new file, `Uniform.cpp`. You will be implementing the `Uniform` class
    in this new file. Like the `Attribute` class, the `Uniform` class is also templated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`Uniform.cpp`。您将在这个新文件中实现`Uniform`类。与`Attribute`类一样，`Uniform`类也是模板化的。
- en: In OpenGL, uniforms are set with the `glUniform***` family of functions. There
    are different functions for integers, floating point numbers, vectors, matrices,
    and so on. You want to provide implementations for the `Set` method for each of
    these types but avoid writing nearly identical code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，uniforms是使用`glUniform***`系列函数设置的。有不同的函数用于整数、浮点数、向量、矩阵等。您希望为每种类型的`Set`方法提供实现，但避免编写几乎相同的代码。
- en: 'To avoid having to write code that''s almost identical, you will declare a
    #`define` macro. This macro will take three arguments—the OpenGL function to call,
    the template type of the Uniform class, and the data type of the OpenGL function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免编写几乎相同的代码，您将声明一个`#define`宏。这个宏将接受三个参数——要调用的OpenGL函数，Uniform类的模板类型和OpenGL函数的数据类型：
- en: 'Add the following code to define the template specifications for the supported
    uniform types:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以定义支持的uniform类型的模板规范：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You only need to implement one of the `Set` methods for each type—the one that
    takes an array and a length. The other `Set` method overloads are for convenience.
    Implement the two convenience overloads—one of them is for setting a single uniform,
    the other is for setting a vector. Both overloads should just call the `Set` function:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只需要为每种类型实现一个`Set`方法，即接受数组和长度的方法。其他`Set`方法重载是为了方便起见。实现两个便利重载——一个用于设置单个uniform，另一个用于设置向量。两个重载应该只调用`Set`函数：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `UNIFORM_IMPL` macro. The first argument will be which OpenGL function
    to call, the second is the type of structure that is being used, and the last
    argument is the data type of the same structure. The `UNIFORM_IMPL` macro assembles
    these pieces of information into a function declaration:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`UNIFORM_IMPL`宏。第一个参数是要调用的OpenGL函数，第二个是正在使用的结构类型，最后一个参数是相同结构的数据类型。`UNIFORM_IMPL`宏将这些信息组装成一个函数声明：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Call the `UNIFORM_IMPL` macro for each uniform data type to generate the appropriate
    `Set` functions. The only data type this method won''t work for is `mat4`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种uniform数据类型调用`UNIFORM_IMPL`宏以生成适当的`Set`函数。这种方法无法适用于`mat4`数据类型：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Set` function for matrices needs to be specified manually; otherwise,
    the `UNIFORM_IMPL` macro won''t work. This is because the `glUniformMatrix4fv`
    function takes an additional Boolean argument asking whether the matrix should
    be transposed or not. Set the transposed Boolean to `false`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵的`Set`函数需要手动指定；否则，`UNIFORM_IMPL`宏将无法工作。这是因为`glUniformMatrix4fv`函数需要一个额外的布尔参数，询问矩阵是否应该被转置。将转置布尔值设置为`false`：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this section, you built an abstraction layer on top of the concept of uniforms.
    In the next section, you will implement index buffers, which are like attributes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你在统一的概念上构建了一个抽象层。在下一节中，你将实现类似属性的索引缓冲区。
- en: Working with index buffers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引缓冲区
- en: Index buffers are a type of attribute. Unlike attributes, an index buffer is
    bound to `GL_ELEMENT_ARRAY_BUFFER` and can be used to draw primitives. Because
    of this, you will implement index buffers in their own class, rather than reuse
    the `Attribute` class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 索引缓冲区是一种属性。与属性不同，索引缓冲区绑定到`GL_ELEMENT_ARRAY_BUFFER`，可以用于绘制基本图元。因此，你将在它们自己的类中实现索引缓冲区，而不是重用`Attribute`类。
- en: The IndexBuffer class declaration
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IndexBuffer类声明
- en: Create a new file, `IndexBuffer.h`. You will be adding the declaration of the
    `IndexBuffer` class to this new file. Like an `Attribute` object, `IndexBuffer`
    will contain an OpenGL handle and a count, with getter functions for both.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`IndexBuffer.h`。你将在这个新文件中添加`IndexBuffer`类的声明。像`Attribute`对象一样，`IndexBuffer`将包含一个OpenGL句柄和一个计数，同时有getter函数。
- en: 'The copy constructor and assignment operator need to be disabled to avoid having
    multiple `IndexBuffer` objects referencing the same OpenGL buffer. The `Set` function
    takes an unsigned integer array and the length of the array, but there is a convenience
    overload that takes a vector as well:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免多个`IndexBuffer`对象引用同一个OpenGL缓冲区，需要禁用复制构造函数和赋值运算符。`Set`函数接受一个无符号整数数组和数组的长度，但也有一个方便的重载，接受一个向量：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this section, you declared a new `IndexBuffer` class. In the next section,
    you will start to implement the actual index buffer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你声明了一个新的`IndexBuffer`类。在下一节中，你将开始实现实际的索引缓冲区。
- en: Implementing the IndexBuffer class
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现IndexBuffer类
- en: 'An index buffer allows you to render a model using indexed geometry. Think
    of a human model; almost all triangles in the mesh will be connected. This means
    many triangles might share a single vertex. Instead of storing every single vertex,
    only unique vertices are stored. A buffer that indexes into the list of unique
    vertices, the index buffer, is used to create triangles out of the unique vertices,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 索引缓冲区允许你使用索引几何体渲染模型。想象一个人体模型；网格中几乎所有的三角形都是相连的。这意味着许多三角形可能共享一个顶点。而不是存储每个单独的顶点，只存储唯一的顶点。索引到唯一顶点列表的缓冲区，即索引缓冲区，用于从唯一顶点创建三角形，如下所示：
- en: 'Create a new file, `IndexBuffer.cpp`. You will be implementing the `IndexBuffer`
    class in this file. The constructor needs to generate a new OpenGL buffer and
    the destructor needs to delete that buffer:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`IndexBuffer.cpp`。你将在这个文件中实现`IndexBuffer`类。构造函数需要生成一个新的OpenGL缓冲区，析构函数需要删除该缓冲区：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The getter functions for count and the OpenGL handle inside of the `IndexBuffer`
    object are trivial:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IndexBuffer`对象内部的计数和OpenGL句柄的getter函数是微不足道的：'
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Set` function of the `IndexBuffer` class needs to bind `GL_ELEMENT_ARRAY_BUFFER`.
    Other than that, the logic is the same as it was for attributes:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IndexBuffer`类的`Set`函数需要绑定`GL_ELEMENT_ARRAY_BUFFER`。除此之外，逻辑与属性的逻辑相同：'
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this section, you built an abstraction around index buffers. In the next
    section, you will learn how index buffers and attributes can be used to render
    geometry.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你围绕索引缓冲区构建了一个抽象。在下一节中，你将学习如何使用索引缓冲区和属性来渲染几何体。
- en: Rendering geometry
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染几何体
- en: You have classes for dealing with vertex data, uniforms, and index buffers,
    but no code to draw any of it. Drawing will be handled by four global functions.
    You will have two `Draw` functions and two `DrawInstanced` functions. You will
    be able to draw geometry with or without an index buffer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了处理顶点数据、统一和索引缓冲区的类，但没有任何代码来绘制它们。绘制将由四个全局函数处理。你将有两个`Draw`函数和两个`DrawInstanced`函数。你将能够使用或不使用索引缓冲区来绘制几何体。
- en: 'Create a new file, `Draw.h`. You will be implementing the `Draw` function in
    this file, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`Draw.h`。你将在这个文件中实现`Draw`函数，如下所示：
- en: 'Declare an `enum` class that defines what primitive should be used for drawing.
    Most of the time, you will only need lines, points, or triangles, but some additional
    types may be useful:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`enum`类，定义绘制时应该使用的基本图元。大多数情况下，你只需要线、点或三角形，但有些额外的类型可能也会有用：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, declare the `Draw` function. There are two overloads for the `Draw` function—one
    takes an index buffer and a draw mode and the other takes a vertex count and a
    draw mode:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`Draw`函数。`Draw`函数有两个重载——一个接受索引缓冲区和绘制模式，另一个接受顶点数量和绘制模式：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Like `Draw`, declare two `DrawInstanced` functions. These functions have a
    similar signature but take an extra argument—`instanceCount`. This `instanceCount`
    variable controls how many instances of the geometry will be rendered:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像`Draw`一样，声明两个`DrawInstanced`函数。这些函数具有类似的签名，但多了一个参数——`instanceCount`。这个`instanceCount`变量控制着几何体的实例数量将被渲染：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new file, `Draw.cpp`. You will implement the drawing-related functionality
    in this file, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`Draw.cpp`。你将在这个文件中实现与绘制相关的功能，如下所示：
- en: 'You need to be able to convert the `DrawMode` enum into `GLenum`. We will do
    this with a static helper function. The only thing this function needs to do is
    figure out what the input draw mode is and return the appropriate `GLenum` value:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要能够将`DrawMode`枚举转换为`GLenum`。我们将使用一个静态辅助函数来实现这一点。这个函数唯一需要做的事情就是弄清楚输入的绘制模式是什么，并返回适当的`GLenum`值：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Draw` and `DrawInstanced` functions that take a vertex count are simple
    to implement. `Draw` needs to call `glDrawArrays` and `DrawInstanced` needs to
    call `glDrawArraysInstanced`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受顶点数的`Draw`和`DrawInstanced`函数很容易实现。`Draw`需要调用`glDrawArrays`，而`DrawInstanced`需要调用`glDrawArraysInstanced`：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Draw` and `Drawinstanced` functions that take an index buffer need to
    bind the index buffer to `GL_ELEMENT_ARRAY_BUFFER` and then call `glDrawElements`
    and `glDrawElementsInstanced`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受索引缓冲区的`Draw`和`Drawinstanced`函数需要将索引缓冲区绑定到`GL_ELEMENT_ARRAY_BUFFER`，然后调用`glDrawElements`和`glDrawElementsInstanced`：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So far, you have written code to load shaders, create and bind GPU buffers,
    and pass uniforms to shaders. Now that the drawing code is implemented as well,
    you can start displaying geometry.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经编写了加载着色器、创建和绑定GPU缓冲区以及将统一变量传递给着色器的代码。现在绘图代码也已实现，您可以开始显示几何图形了。
- en: In the next section, you will learn how to work with textures to make the rendered
    geometry look more interesting.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何使用纹理使渲染的几何图形看起来更有趣。
- en: Working with textures
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理
- en: All the shaders you will write in this book assume that the diffused color of
    what is being rendered comes from a texture. Textures will be loaded from `.png`
    files. All image loading will be done through `stb_image`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中编写的所有着色器都假定正在渲染的漫反射颜色来自纹理。纹理将从`.png`文件加载。所有图像加载都将通过`stb_image`完成。
- en: '`Stb` is a collection of single-file public domain libraries. We''re only going
    to use the image loader; you can find the entire `stb` collection on GitHub at
    [https://github.com/nothings/stb](https://github.com/nothings/stb).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stb`是一组单文件公共领域库。我们只会使用图像加载器；您可以在GitHub上找到整个`stb`集合[https://github.com/nothings/stb](https://github.com/nothings/stb)。'
- en: Adding stb_image
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加stb_image
- en: You will be loading textures using `stb_image`. You can get a copy of the header
    file from [https://github.com/nothings/stb/blob/master/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h).
    Add the `stb_image.h` header file to the project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`stb_image`加载纹理。您可以从[https://github.com/nothings/stb/blob/master/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h)获取头文件的副本。将`stb_image.h`头文件添加到项目中。
- en: 'Create a new file, `stb_image.cpp`. This file just needs to declare the `stb_image`
    implementation macro and include the header file. It should look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`stb_image.cpp`。这个文件只需要声明`stb_image`实现宏并包含头文件。它应该是这样的：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Texture class declaration
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理类声明
- en: Create a new file, `Texture.h`. You will be declaring the `Texture` class in
    this file. The `Texture` class only needs a few important functions. It needs
    to be able to load a texture from a file, bind a texture index to a uniform index,
    and deactivate a texture index.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Texture.h`。您将在这个文件中声明`Texture`类。`Texture`类只需要一些重要的函数。它需要能够从文件加载纹理，将纹理索引绑定到统一索引，并取消激活纹理索引。
- en: 'In addition to the core functions, the class should have a default constructor,
    a convenience constructor that takes a file path, a destructor, and a getter for
    the OpenGL handle contained inside of the `Texture` class. The copy constructor
    and assignment operator should be disabled to avoid having two `Texture` classes
    reference the same OpenGL texture handle:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心函数之外，该类还应该有一个默认构造函数、一个方便的构造函数（接受文件路径）、一个析构函数和一个获取`Texture`类内包含的OpenGL句柄的getter。复制构造函数和赋值运算符应该被禁用，以避免两个`Texture`类引用相同的OpenGL纹理句柄：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implementing the Texture class
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现纹理类
- en: Create a new file, `Texture.cpp`. The definition of the `Texture` class will
    go in this file. The default constructor of the `Texture` class needs to set all
    member variables to `0`, then generate an OpenGL handle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Texture.cpp`。`Texture`类的定义将放在这个文件中。`Texture`类的默认构造函数需要将所有成员变量设置为`0`，然后生成一个OpenGL句柄。
- en: 'The `Load` function is probably the most important function in the `Texture`
    class; it''s responsible for loading image files. The actual parsing of the image
    files will be handled by `stbi_load`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Load`函数可能是`Texture`类中最重要的函数；它负责加载图像文件。图像文件的实际解析将由`stbi_load`处理：'
- en: 'The convenience constructor generates a new handle, then calls the `Load` function,
    which will initialize the rest of the class member variables, since every instance
    of the `Texture` class holds a valid texture handle:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方便的构造函数生成一个新的句柄，然后调用`Load`函数，该函数将初始化`Texture`类的其余成员变量，因为`Texture`类的每个实例都持有一个有效的纹理句柄：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`stbi_load` takes a path to the image file and references to the width, height,
    and number of channels in the image. The last argument specifies the number of
    components per pixel. By setting it to `4`, all textures are loaded with RGBA
    channels. Next, use `glTexImage2D` to upload the texture to the GPU and `glGenerateMipmap`
    to generate the appropriate mipmaps for the image. Set the wrap mode to repeat:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stbi_load`需要一个图像文件的路径以及图像的宽度、高度和通道数的引用。最后一个参数指定每个像素的组件数。通过将其设置为`4`，所有纹理都将以RGBA通道加载。接下来，使用`glTexImage2D`将纹理上传到GPU，并使用`glGenerateMipmap`生成图像的适当mipmap。将包装模式设置为重复：'
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Set` function needs to activate a texture unit, bind the handle that the
    `Texture` class contains to that texture unit, then set the specified uniform
    index to contain the texture unit that is currently bound. The `Unset` function
    unbinds the current texture from the specified texture unit:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Set`函数需要激活一个纹理单元，将`Texture`类包含的句柄绑定到该纹理单元，然后将指定的统一索引设置为当前绑定的纹理单元。`Unset`函数取消绑定指定纹理单元的当前纹理：'
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `GetHandle` getter function is simple:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetHandle`获取函数很简单：'
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `Texture` class will always load textures using the same mipmap level and
    wrapping parameters. For the samples in this book, that should be enough. You
    may want to try adding getters and setters for these properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Texture`类将始终使用相同的mipmap级别和包装参数加载纹理。对于本书中的示例，这应该足够了。您可能希望尝试为这些属性添加getter和setter。'
- en: In the next section, you will implement vertex and fragment shader programs,
    which is the last step needed to draw something.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将实现顶点和片段着色器程序，这是绘制所需的最后一步。
- en: Simple shaders
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的着色器
- en: The rendering abstraction is done. Before drawing anything, you need to write
    shaders to direct how things are going to be drawn. In this section, you will
    write a vertex and a fragment shader. The fragment shader will be used throughout
    the rest of this book and the vertex shaders used in later sections of this book
    will be variations of the one presented here.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染抽象已完成。在绘制任何东西之前，您需要编写着色器来指导绘制的方式。在本节中，您将编写一个顶点着色器和一个片段着色器。片段着色器将在本书的其余部分中使用，而本书后面部分使用的顶点着色器将是这里介绍的一个变体。
- en: The vertex shader
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The vertex shader is responsible for putting each vertex of a model through
    the model, view, and projection pipeline and for passing any required lighting
    data to the fragment shader. Create a new file, `static.vert`. You will be implementing
    the vertex shader in this file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器负责将模型的每个顶点通过模型、视图和投影管道，并将任何所需的光照数据传递给片段着色器。创建一个新文件，`static.vert`。您将在这个文件中实现顶点着色器。
- en: The vertex shader takes three uniforms—a model, a view, and a projection matrix.
    These uniforms are needed to transform a vertex. Each individual vertex is made
    up of three attributes—a position, a normal, and some texture coordinates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器需要三个uniform变量——模型、视图和投影矩阵。这些uniform变量需要用来转换顶点。每个单独的顶点由三个属性组成——位置、法线和一些纹理坐标。
- en: 'The vertex shader outputs three variables to the fragment shader, the normal
    and fragment positions in the world space, and the texture coordinates:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器将三个变量输出到片段着色器中，即世界空间中的法线和片段位置，以及纹理坐标：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is a minimal vertex shader; it only puts the vertex through a model view
    and projection pipeline. This shader can be used to display static geometry or
    CPU skinned meshes. In the next section, you will implement a fragment shader.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小的顶点着色器；它只将顶点通过模型视图和投影管道。这个着色器可以用来显示静态几何图形或CPU蒙皮网格。在下一节中，您将实现一个片段着色器。
- en: The fragment shader
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段着色器
- en: Create a new file, `lit.frag`. The fragment shader in this file will be used
    throughout the rest of the book. Some chapters will introduce new vertex shaders,
    but the fragment shader is always going to remain as this one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`lit.frag`。这个文件中的片段着色器将在本书的其余部分中使用。一些章节将介绍新的顶点着色器，但片段着色器始终保持不变。
- en: 'The fragment shader takes the object''s diffused color from a texture, then
    applies a single-directional light. The lighting model is just *N* dot *L*. Because
    there is no ambient term to the light, some parts of the model can appear as all
    black:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器从纹理中获取对象的漫反射颜色，然后应用单向光。光照模型只是*N*点*L*。由于光没有环境项，模型的某些部分可能会呈现全黑：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Important information:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息：
- en: Want to learn more about lighting models in OpenGL? Go to [https://learnopengl.com/Lighting/Basic-Lighting](https://learnopengl.com/Lighting/Basic-Lighting).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于OpenGL中光照模型的知识？请访问[https://learnopengl.com/Lighting/Basic-Lighting](https://learnopengl.com/Lighting/Basic-Lighting)。
- en: This is a simple fragment shader; the diffuse color is obtained by sampling
    a texture and the intensity is a simple directional light.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的片段着色器；漫反射颜色是通过对纹理进行采样获得的，强度是一个简单的定向光。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to write an abstraction layer on top of the
    OpenGL API. For the most part, you will be using these classes to draw things
    throughout the rest of the book, but a few stray OpenGL calls might find their
    way into our code here and there.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何在OpenGL API的顶层编写一个抽象层。在本书的大部分时间里，您将使用这些类来绘制东西，但是一些零散的OpenGL调用可能会在我们的代码中找到它们的位置。
- en: Abstracting OpenGL in this fashion will let future chapters focus on animation
    without having to worry about the underlying API. It should be straightforward
    to port this API to other backends as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式抽象化OpenGL将让未来的章节专注于动画，而不必担心底层API。将这个API移植到其他后端也应该很简单。
- en: There are two samples for this chapter—`Chapter06/Sample00`, which is the code
    used up to this point, and `Chapter06/Sample01`, which shows a simple textured
    and lit plane rotating in place. `Sample01` is a good example of how to use the
    code you have written so far.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有两个示例——`Chapter06/Sample00`，这是到目前为止使用的代码，以及`Chapter06/Sample01`，显示一个简单的纹理和光照平面在原地旋转。`Sample01`是如何使用到目前为止编写的代码的一个很好的例子。
- en: '`Sample01` also includes a utility class, `DebugDraw`, that won''t be covered
    in this book. The class is found in `DebugDraw.h` and `DebugDraw.cpp`. The `DebugDraw`
    class can be used to draw debug lines quickly with a simple API. The `DebugDraw`
    class is not very efficient; it''s only meant to be used for debugging.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample01`还包括一个实用类`DebugDraw`，本书不会涉及。该类位于`DebugDraw.h`和`DebugDraw.cpp`中。`DebugDraw`类可以用于快速绘制调试线，具有简单的API。`DebugDraw`类效率不高；它只用于调试目的。'
- en: In the next chapter, you will start to explore the glTF file format. glTF is
    a standard format that can store both mesh and animation data. It's the format
    that the rest of this book will be using.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将开始探索glTF文件格式。glTF是一种可以存储网格和动画数据的标准格式。这是本书其余部分将使用的格式。
