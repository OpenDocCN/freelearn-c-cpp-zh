- en: Protecting Data and Synchronizing Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护数据和同步任务
- en: What do race conditions, corrupt data, and missed real-time deadlines all have
    in common? Well, for one, they are all mistakes that can be easily made when operations
    are performed in parallel. These are also mistakes that are avoidable (in part)
    through using the right tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件、数据损坏和错过实时截止日期有什么共同之处？好吧，首先，它们都是在并行操作时容易犯的错误。这些错误（部分）可以通过使用正确的工具来避免。
- en: This chapter covers many of the mechanisms that are used to synchronize tasks
    and protect shared data. All the explanations in this chapter will contain example
    code and analysis that will have been performed using Ozone and SystemView.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了用于同步任务和保护共享数据的一些机制。本章中的所有解释都将包含使用Ozone和SystemView执行的示例代码和分析。
- en: First, we will explore the differences between semaphores and mutexes. Then,
    you will understand how, when, and why to use a semaphore. You'll also learn about
    race conditions and see how a mutex can avoid such situations. Example code will
    be provided throughout. The concept of race conditions will be introduced and
    fixed using a mutex in live code that can be run and analyzed on the Nucleo development
    board. Finally, FreeRTOS software timers will be introduced and a discussion of
    common real-world use cases for RTOS-based software timers and MCU hardware peripheral
    timers will be provided.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨信号量和互斥锁之间的区别。然后，您将了解何时、如何以及为什么使用信号量。您还将了解竞态条件和了解互斥锁如何避免此类情况。示例代码将贯穿始终。将使用可以在Nucleo开发板上运行和分析的实时代码引入并修复竞态条件概念。最后，将介绍FreeRTOS软件定时器，并讨论基于RTOS的软件定时器和MCU硬件外围定时器的常见实际应用案例。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using semaphores
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量
- en: Using mutexes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁
- en: Avoiding race conditions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免竞态条件
- en: Using software timers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用软件定时器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on exercises in this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的动手练习，您将需要以下内容：
- en: Nucleo F767 development board
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767开发板
- en: Micro USB cable
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB线
- en: ST/Atollic STM32CubeIDE and its source code (the instructions for this can be
    found in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)*, Selecting an
    IDE – Setting Up Our IDE*)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ST/Atollic STM32CubeIDE及其源代码（有关这些说明，请参阅[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)*，选择IDE
    – 设置我们的IDE*)
- en: SEGGER JLink, Ozone, and SystemView ([Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER JLink、Ozone和SystemView ([第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*)
- en: 'The easiest way to build the examples in this chapter is to build all Eclipse
    *configurations* at once, and then load and view them using Ozone. To do this,
    follow these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 构建本章中的示例最简单的方法是一次性构建所有Eclipse *配置*，然后使用Ozone加载和查看它们。为此，请按照以下步骤操作：
- en: In STM32CubeIDE, right-click on the project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在STM32CubeIDE中，右键单击项目。
- en: Select Build.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择构建。
- en: Select Build All. All the examples will be built into their own named subdirectory
    (this may take a while).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择构建所有。所有示例都将构建到它们自己的命名子目录中（这可能需要一段时间）。
- en: In Ozone, you can now quickly load each `<exampleName>.elf` file. See [Chapter
    6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),* Debugging Tools for Real-Time
    Systems*, for instructions on how to do this. The correct source files that are
    linked in the executable will be automatically displayed.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ozone中，您现在可以快速加载每个`<exampleName>.elf`文件。有关如何操作的说明，请参阅[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*。链接到可执行文件的正确源文件将自动显示。
- en: All the source code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_8](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_8).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码都可以在[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_8](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_8)找到。
- en: Using semaphores
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号量
- en: We've mentioned several times now that tasks are meant to be programmed so that
    they're *running in parallel*. This means that, by default, they have no relation
    to one another in time. No assumptions can be made as to where tasks are in their
    execution with respect to one another – unless they are explicitly synchronized.
    Semaphores are one mechanism that's used to provide synchronization between tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，任务应该被编程为并行运行。这意味着，默认情况下，它们在时间上没有相互关系。不能假设任务相对于彼此的执行位置——除非它们被显式同步。信号量是用于在任务之间提供同步的一种机制。
- en: Synchronization via semaphores
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过信号量进行同步
- en: 'The following is a diagram of the abstract example we covered back in [Chapter
    2](a410ddd6-10eb-4e97-965e-e390f4dc2890.xhtml), *Task Signaling and Communication
    Mechanisms*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前在[第2章](a410ddd6-10eb-4e97-965e-e390f4dc2890.xhtml)中讨论的抽象示例的图示，*任务信号和通信机制*：
- en: '![](img/d82cc6e2-4a19-4439-ba39-632cfccaedb0.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d82cc6e2-4a19-4439-ba39-632cfccaedb0.png)'
- en: The preceding diagram shows `TaskB` waiting on a semaphore from `TaskA`. Each
    time `TaskB` acquires the desired semaphore, it will continue its loop. `TaskA`
    repeatedly *gives* a semaphore, which effectively synchronizes when `TaskB` runs.
    Now that we have a full development environment set up, let's take a look at what
    this looks like with some actual code. Then, we'll run it on hardware and blink
    a few LEDs to see exactly what this behavior looks like in the real world.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了`TaskB`正在等待来自`TaskA`的信号量。每次`TaskB`获取到所需的信号量时，它将继续其循环。`TaskA`会重复地`give`信号量，这实际上同步了`TaskB`的运行。现在我们已经搭建了完整的发展环境，让我们看看实际的代码是什么样的。然后，我们将在硬件上运行它，闪烁几个LED，以了解在现实世界中这种行为是什么样的。
- en: Setting up the code
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: 'First, the semaphore needs to be created, and its handle (or pointer) has to
    be stored so that it can be used between tasks. The following excerpt has been
    taken from `mainSemExample.c`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要创建信号量，并存储其句柄（或指针），以便在任务之间使用。以下摘录来自`mainSemExample.c`：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The semaphore pointer, that is, `semPtr`, needs to be placed in a location that
    is accessible to other functions that need access to the semaphore. For example,
    don't declare `semPtr` as a local variable inside a function – it won't be available
    to other functions and it will go out of scope as soon as the function returns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量指针，即`semPtr`，需要放置在一个可以被需要访问信号量的其他函数访问的位置。例如，不要在函数内部将`semPtr`声明为局部变量——它将无法被其他函数访问，并且一旦函数返回，它就会超出作用域。
- en: To see what's going on with the source code *and* see how the system is reacting,
    we'll associate a few different LEDs with task A and task B.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看源代码的情况以及了解系统是如何反应的，我们将几个不同的LED与任务A和任务B关联起来。
- en: '`Task A` will toggle the green LED and *give* a semaphore every five times
    it''s run through the blinking loop, as shown in the following excerpt from `mainSemExample.c`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task A`将在闪烁循环中每运行五次时切换绿色LED并`give`信号量，如下面的`mainSemExample.c`摘录所示：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Task B`, on the other hand, will rapidly blink the blue LED three times after
    successfully *taking* the semaphore, as shown in the following excerpt from `mainSemExample.c`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Task B`在成功`take`到信号量后，将快速闪烁蓝色LED三次，如下面的`mainSemExample.c`摘录所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great! Now that our code is ready, let's see what this behavior looks like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们的代码准备好了，让我们看看这种行为是什么样的。
- en: FreeRTOS allows for indefinite delays in certain circumstances through the use
    of `portMAX_DELAY`. As long as `#define INCLUDE_vTaskSuspend 1` is present in `FreeRTOSConfig.h`,
    the calling task will be suspended indefinitely and the return value of `xSemaphoreTake()`
    can be safely ignored. When `vTaskSuspend()` is not defined as 1, `portMAX_DELAY`
    will result in a very long delay (0xFFFFFFF RTOS ticks (~ 49.7 days) on our system),
    but not an infinite one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS通过使用`portMAX_DELAY`允许在某些情况下进行无限期延迟。只要`FreeRTOSConfig.h`中存在`#define INCLUDE_vTaskSuspend
    1`，调用任务将被无限期挂起，并且可以安全地忽略`xSemaphoreTake()`的返回值。当`vTaskSuspend()`未定义为1时，`portMAX_DELAY`将导致非常长的延迟（在我们的系统中为0xFFFFFFF
    RTOS滴答，约49.7天），但不是无限期。
- en: Understanding the behavior
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为
- en: 'Here''s what this example looks like when viewed using SystemView:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用SystemView查看时的示例外观：
- en: '![](img/61787d72-0a4f-4239-8f1c-e77633e1f56a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61787d72-0a4f-4239-8f1c-e77633e1f56a.png)'
- en: 'Notice the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: Blocking with semaphores is efficient as each task is only using 0.01% of the
    CPU time.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量进行阻塞是高效的，因为每个任务只使用了0.01%的CPU时间。
- en: A task that is blocked because it is waiting on a semaphore won't run until
    it is available. This is true even if it is the highest-priority task in the system
    and no other tasks are currently `READY`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于任务正在等待信号量而阻塞的任务，将不会运行，直到它可用。即使它是系统中优先级最高的任务，并且没有其他任务处于`READY`状态，也是如此。
- en: Now that you've seen an efficient way of synchronizing tasks with a semaphore,
    let's have a look at another way of achieving the same behavior using polling.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了使用信号量同步任务的效率方法，让我们看看另一种使用轮询实现相同行为的方法。
- en: Wasting cycles – synchronization by polling
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浪费周期——通过轮询进行同步
- en: The following example has the exact same behavior as when we're looking at LEDs
    from the outside of the board – the observable pattern of the LEDs is exactly
    the same as the previous example. The difference is how much CPU time is being
    used by continuously reading the same variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例与从板外观察LED时的行为完全相同——LED的可观察模式与上一个示例完全相同。区别在于连续读取相同变量所使用的CPU时间量。
- en: Setting up the code
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: 'Here''s the updated `GreenTaskA()` – only a single line has changed. This excerpt
    has been taken from `mainPolledExample.c`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是更新后的`GreenTaskA()`——只有一行发生了变化。这段摘录来自`mainPolledExample.c`：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead of calling `xSmeaphoreGive()`, we're simply setting the `flag` variable
    to `1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是调用`xSemaphoreGive()`，而是简单地设置`flag`变量为`1`。
- en: 'A similar small change has been made to `BlueTaskB()`, trading out a `while`
    loop that polls on `flag`, instead of using `xSemaphoreTake()`. This can be seen
    in the following excerpt from `mainPolledExample.c`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对`BlueTaskB()`也进行了类似的微小更改，用轮询`flag`的`while`循环替换了`xSemaphoreTake()`。这可以在以下来自`mainPolledExample.c`的摘录中看到：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are the only changes that are required. `BlueTaskB()` will wait to move
    on (indefinitely) until `flag` is set to something other than `0`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是所需的唯一更改。`BlueTaskB()`将等待（无限期地）直到`flag`被设置为非`0`的值。
- en: To run this example, use the `Chapter_8/polledExample` file's build configuration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请使用`Chapter_8/polledExample`文件中的构建配置。
- en: Understanding the behavior
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为
- en: 'Since only a few changes were made, we might not expect there to be *that*
    much of a difference in terms of how the MCU is behaving, given the new code.
    However, the output that can be observed with SystemView tells a different story:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更改很少，我们可能不会期望在新的代码下，MCU的行为会有太大的差异。然而，SystemView的输出告诉我们一个不同的故事：
- en: '![](img/06f10d4a-30cf-4cfb-9886-9e31036a2b96.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06f10d4a-30cf-4cfb-9886-9e31036a2b96.png)'
- en: 'Note the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: '`BlueTaskB` is now using 100% of the CPU time while polling the value of `flag`
    (the 70% CPU load is lower because the task is sleeping while actually blinking
    the LED).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueTaskB`现在正在使用100%的CPU时间来轮询`flag`（70%的CPU负载较低，因为任务在闪烁LED时处于睡眠状态）。'
- en: Even though `BlueTaskB` is hogging the CPU, `GreenTaskA` still runs consistently
    since it has a higher priority. `GreenTaskA` would be starved of CPU if it was
    a lower priority than `BlueTaskB`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使`BlueTaskB`正在占用CPU，`GreenTaskA`仍然持续运行，因为它具有更高的优先级。如果`GreenTaskA`的优先级低于`BlueTaskB`，它将无法获得CPU。
- en: 'So, synchronizing tasks by polling on a variable *does* work as expected, but
    there are some side effects: increased CPU utilization and a strong dependency
    on task priorities. Of course, there are ways of reducing the CPU load of `BlueTaskB`.
    We could have added a delay between polling, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过轮询变量来同步任务确实按预期工作，但有一些副作用：CPU利用率增加，对任务优先级的强烈依赖。当然，有方法可以减少`BlueTaskB`的CPU负载。我们可以在轮询之间添加延迟，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will reduce the CPU load of `BlueTaskB` to around 5%. Beware, though, that
    this delay also guarantees that `BlueTaskB` has a worst-case delay of at *least*
    1 RTOS tick period (1 ms, in our setup).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`BlueTaskB`的CPU负载降低到大约5%。但是，请注意，这个延迟也保证了`BlueTaskB`在最坏情况下的延迟至少为1个RTOS滴答周期（在我们的设置中为1毫秒）。
- en: Time-bound semaphores
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间限制信号量
- en: 'Earlier, we mentioned that one of the critical aspects of RTOSes was their
    ability to provide a way to time-bound operations; that is, they can guarantee
    a call doesn''t stop a task from executing any longer than is desirable. An RTOS
    *does not guarantee the successful timeliness of an operation*. It only promises
    that the call will be returned in an amount of time. Let''s have another look
    at the call for taking a semaphore:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到RTOS的一个重要方面是它们提供了一种时间限制操作的方法；也就是说，它们可以保证调用不会使任务执行超过期望的时间。RTOS *不保证操作的成功及时性*。它只承诺调用将在一定时间内返回。让我们再次看看获取信号量的调用：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the preceding code, we can see the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到以下内容：
- en: '`semPtr` is just a pointer to the semaphore.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semPtr` 只是一个指向信号量的指针。'
- en: '`maxDelay` is the interesting part of this call – it specifies the maximum
    amount of time to wait for the semaphore (in RTOS *tick* units).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxDelay` 是这个调用中有趣的部分——它指定了等待信号量的最大时间（以RTOS *tick* 单位计）。'
- en: The return value is `pdPASS` (the semaphore was taken in time) or `pdFALSE`
    (the semaphore was not taken in time). *It is extremely important to check this
    return value.*
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是 `pdPASS`（信号量及时获取）或 `pdFALSE`（信号量未及时获取）。*检查这个返回值非常重要*。
- en: If a semaphore were to be taken successfully, the return value would be `pdPASS`.
    This is the only case where the task will continue because a semaphore was given.
    If the return value is not `pdPASS`, the call to `xSemaphoreTake()` has failed,
    either because of a timeout or a programming error (such as passing in an invalid
    `SemaphoreHandle_t`). Let's take a more in-depth look at this with an example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功获取信号量，返回值将是 `pdPASS`。这是任务将继续的唯一情况，因为给出了信号量。如果返回值不是 `pdPASS`，则 `xSemaphoreTake()`
    调用失败，可能是由于超时或编程错误（例如传递无效的 `SemaphoreHandle_t`）。让我们通过一个例子更深入地了解这一点。
- en: Setting up the code
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: 'In this example, we''ll be using all three LEDs on the dev board to indicate
    different states:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用开发板上的所有三个LED来指示不同的状态：
- en: '**Green LED**: `GreenTaskA()` blinks at a steady 5 Hz with a 50% duty cycle.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色LED**：`GreenTaskA()` 以稳定的5赫兹频率闪烁，占空比为50%。'
- en: '**Blue LED**: Rapid blinks three times when `TaskB()` receives the semaphore
    within 500 ms.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色LED**：当 `TaskB()` 在500毫秒内收到信号量时，快速闪烁三次。'
- en: '**Red LED**: Turned on after a timeout from `xSemaphoreTake()`. This is left
    on until it''s reset by `TaskB()`, as long as it receives the semaphore within
    500 ms of starting to wait for it.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色LED**：在 `xSemaphoreTake()` 超时后开启。只要在开始等待信号量后的500毫秒内收到信号量，它就会保持开启状态，直到被
    `TaskB()` 重置。'
- en: In many systems, missing a deadline can be a cause for (major) concern. It all
    depends on what it is you're implementing. This example is just a simple loop
    with a red light for when a deadline is missed. However, other systems may require
    (emergency) procedures to be taken to prevent significant failure/damage if a
    deadline is missed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，错过截止日期可能是一个（重大）关注的问题。这完全取决于你正在实施的内容。这个例子只是一个简单的循环，当错过截止日期时会有红灯亮起。然而，其他系统可能需要采取（紧急）程序来防止错过截止日期导致重大故障/损坏。
- en: '`GreenTaskA()` has two responsibilities:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreenTaskA()` 有两个职责：'
- en: Blink the green LED
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁绿色LED
- en: '*Give* the semaphore at pseudo-random intervals'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在伪随机间隔内发出* 信号量'
- en: 'These responsibilities can be seen in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些职责可以在以下代码中看到：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`TaskB()` also has two responsibilities:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskB()` 也具有两个职责：'
- en: Blink the blue LED (as long as the semaphore shows up within 500 ms).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁蓝色LED（只要信号量在500毫秒内出现）。
- en: 'Turn on the red LED (if the semaphore doesn''t show up within 500 ms). The
    red LED will stay on until the semaphore has successfully been taken within 500
    ms of starting to wait for it:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号量在500毫秒内没有出现，则开启红色LED。红色LED将保持开启状态，直到在开始等待信号量后的500毫秒内成功获取信号量：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This setup guarantees that `TaskB() ` will be taking some action *at least*
    every 500 ms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置保证了 `TaskB()` 至少每500毫秒会采取一些行动。
- en: Understanding the behavior
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为
- en: 'When building and loading the firmware included in the `semaphoreTimeBound` build
    configuration, you''ll see something similar to the following when using SystemView:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用SystemView构建和加载 `semaphoreTimeBound` 构建配置中包含的固件时，你会看到以下类似的内容：
- en: '![](img/c0f7a646-6c8c-4ca0-ac34-905facf9676c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0f7a646-6c8c-4ca0-ac34-905facf9676c.png)'
- en: 'Note the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: '**Marker 1** indicates `TaskB` didn''t receive the semaphore within 500 ms.
    Notice there is no followup execution from `TaskB` – it immediately went back
    to taking the semaphore again.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记1**表示`TaskB`在500 ms内没有接收到信号量。注意，`TaskB`没有后续执行——它立即返回再次获取信号量。'
- en: '**Marker 2** indicates `TaskB` received the semaphore within 500 ms. Looking
    at the graph, we can see it was actually around 200 ms. The periodic lines (circled
    in the preceding image) in the `TaskB` lane are the blue LED turning on and off.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记2**表示`TaskB`在500 ms内接收到了信号量。从图表中我们可以看到实际上是在大约200 ms。`TaskB`通道中的周期性线条（在前面的图像中圈出）是蓝色LED的开启和关闭。'
- en: After blinking the blue LED, `TaskB` goes back to waiting for the semaphore.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在闪烁蓝色LED后，`TaskB`返回等待信号量。
- en: Log messages are indicated by blue *i* icons within the timeline, which helps
    to associate descriptive comments in code while visualizing behavior. Double-clicking
    the blue boxes automatically jumps the terminal to the associated log message.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息由时序中的蓝色*i*图标表示，这有助于在可视化行为的同时将代码中的描述性注释关联起来。双击蓝色框会自动将终端跳转到相关的日志消息。
- en: You'll notice that the blue LED doesn't always blink – occasionally, the red
    LED blinks instead. Each time the red LED blinks, this indicates that `semPtr`
    was not taken within 500 ms. This shows that the code is attempting to take a
    semaphore as an upper bound on the amount of time acceptable before *giving up*
    on the semaphore, possibly triggering an error condition.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到蓝色LED并不总是闪烁——偶尔，红色LED会闪烁。每次红色LED闪烁，这表明在500 ms内没有获取到`semPtr`。这表明代码正在尝试获取一个信号量，将其作为在放弃信号量之前可接受的最高时间上限，这可能会触发一个错误条件。
- en: As an exercise, see if you can capture a red blink and track where the timeout
    occurred using the terminal output (on the right) and the timeline output (on
    the bottom) – how much time elapsed from when `TaskB` attempted to *take the semaphore* and
    when the red LED blinked? Now, modify the 500 ms timeout in the source code, compile
    and upload it with Ozone, and watch for the change in SystemView.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，看看你是否能捕获红色闪烁并使用终端输出（在右侧）和时序输出（在底部）跟踪超时发生的位置——从`TaskB`尝试**获取信号量**到红色LED闪烁之间经过了多少时间？现在，修改源代码中的500
    ms超时，使用Ozone编译并上传，观察SystemView中的变化。
- en: Counting semaphores
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数信号量
- en: While binary semaphores can only have values between 0 and 1, counting semaphores
    can have a wider range of values. Some use cases for counting semaphores include
    simultaneous connections in a communication stack or static buffers from a memory
    pool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然二进制信号量只能有0到1之间的值，但计数信号量可以有更宽的范围。计数信号量的某些用例包括通信堆栈中的同时连接或内存池中的静态缓冲区。
- en: For example, let's say we have a TCP/IP stack that supports multiple simultaneous
    TCP sessions, but the MCU only has enough RAM to support three simultaneous TCP
    sessions. This would be a perfect use case for a counting semaphore.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个支持多个同时TCP会话的TCP/IP堆栈，但MCU只有足够的RAM来支持三个同时TCP会话。这将是一个计数信号量的完美用例。
- en: 'The counting semaphore for this application needs to be defined so that it
    has a maximum count of `3` and an initial value of `3` (three TCP sessions are
    available):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的计数信号量需要定义为最大计数为`3`，初始值为`3`（有三个TCP会话可用）：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code that requests to open a TCP session would *take* `semPtr`, reducing
    its count by 1:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请求打开TCP会话的代码会**获取**`semPtr`，将其计数减少1：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Whenever a TCP session is closed, the code closing the session *gives* `semPtr`,
    increasing its count by 1:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当关闭一个TCP会话时，关闭会话的代码会**释放**`semPtr`，将其计数增加1：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By using a counting semaphore, you can control access to a limited number of
    available TCP sessions. By doing this, we''re accomplishing two things:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用计数信号量，你可以控制对有限数量的可用TCP会话的访问。通过这样做，我们实现了两个目标：
- en: Limiting the number of simultaneous TCP sessions, thus keeping resource usage
    in check.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制同时TCP会话的数量，从而控制资源使用。
- en: Providing time-bound access for creating a TCP session. This means the code
    is able to specify how long it will wait for a session to become available.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为创建TCP会话提供时间限制的访问。这意味着代码能够指定它将等待会话可用多长时间。
- en: Counting semaphores are useful for controlling access to a shared resource when
    more than one instance is available.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 计数信号量在控制对多个实例可用的共享资源的访问时非常有用。
- en: Priority inversion (how not to use semaphores)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先级反转（如何不使用信号量）
- en: Since semaphores are used to synchronize multiple tasks and guard shared resources,
    does this mean we can use them to protect a piece of data that's being shared
    between two tasks? Since each task needs to know when it is safe to access the
    data, the tasks need to be synchronized, right? The danger with this approach
    is that semaphores have no concept of task priority. A higher-priority task waiting
    on a semaphore being held by a lower-priority task will wait, regardless of what
    else might be going on in the system. An example of *why* this can become a problem
    will be shown here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信号量用于同步多个任务并保护共享资源，这意味着我们可以使用它们来保护两个任务之间共享的数据吗？由于每个任务都需要知道何时可以安全地访问数据，因此任务需要同步，对吧？这种方法的危险在于信号量没有任务优先级的概念。一个高优先级任务在等待一个被低优先级任务持有的信号量时将会等待，无论系统中可能发生什么。这里将展示一个*为什么*这可能会成为问题的例子。
- en: 'Here''s the conceptual example we covered in [Chapter 3](a410ddd6-10eb-4e97-965e-e390f4dc2890.xhtml)*,
    Task Signaling and Communication Mechanisms*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们之前在[第3章](a410ddd6-10eb-4e97-965e-e390f4dc2890.xhtml)*，任务信号和通信机制*中讨论的概念示例：
- en: '![](img/470ca651-eb41-4c68-98c5-0f8b92f88990.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/470ca651-eb41-4c68-98c5-0f8b92f88990.png)'
- en: The main problems with this sequence are *steps 3* and *4*. `TaskB` shouldn't
    be able to preempt `TaskC` if a higher-priority (`TaskA`) task is waiting on the
    semaphore. Let's look at an example of this *in the wild* with some real code
    and observe the behavior first-hand!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的主要问题是*步骤3*和*步骤4*。如果有一个高优先级（`TaskA`）的任务正在等待信号量，`TaskB`不应该能够抢占`TaskC`。让我们通过一些真实的代码和观察其行为来查看这个例子！
- en: Setting up the code
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: For the actual example, we'll maintain the exact same function names as the
    theoretical example we covered previously. The *shared resource* will be the function
    that's used to blink the LEDs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际示例，我们将保持与之前讨论的理论示例完全相同的函数名。*共享资源*将是用于闪烁LED的函数。
- en: The *shared LEDs* are only an example. In practice, you'll often find that data
    that's been shared between tasks needs to be protected. There is also the chance
    that the multiple tasks may attempt to use the same hardware peripheral, in which
    case access to that resource may need to be protected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*共享LED*只是一个例子。在实践中，你经常会发现任务之间共享的数据需要被保护。还有可能多个任务尝试使用相同的硬件外设，在这种情况下，可能需要保护对该资源的访问。'
- en: To provide some visual feedback, we'll also assign some LEDs to the various
    tasks. Let's have a look at the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一些视觉反馈，我们还将一些LED分配给各种任务。让我们看看代码。
- en: Task A (highest priority)
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务A（最高优先级）
- en: Task A is responsible for blinking the green LED, but only *after* `semPtr` has
    been taken (within 200 ms of requesting it). The following excerpt has been taken
    from `mainSemPriorityInversion.c`*:*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 任务A负责闪烁绿色LED，但只有在`semPtr`被获取之后（在请求后的200毫秒内）。以下摘录来自`mainSemPriorityInversion.c`：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This task is the primary focal point of this example, so make sure that you
    have a solid understanding of the conditional statements around the semaphore
    being taken within the specified period of time. The semaphore won't always be
    taken in time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务是本例的主要焦点，所以请确保你对在指定时间内获取信号量的条件语句有扎实的理解。信号量并不总是能及时获取。
- en: Task B (medium priority)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务B（中等优先级）
- en: 'Task B periodically utilizes the CPU. The following excerpt has been taken
    from `mainSemPriorityInversion.c`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 任务B定期使用CPU。以下摘录来自`mainSemPriorityInversion.c`：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This task sleeps between 75 and 150 ticks (which doesn't consume CPU cycles)
    and then performs a busy loop for a variable number of cycles using the `lookBusy()` function.
    Note that `TaskB` is the medium priority task.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务在75到150个tick之间睡眠（这不会消耗CPU周期），然后使用`lookBusy()`函数进行可变周期的忙等待。请注意，`TaskB`是中等优先级任务。
- en: Task C (low priority)
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务C（低优先级）
- en: 'Task C is responsible for blinking the blue LED, but only *after* the `semPtr` has
    been taken (within 200 ms of requesting it). The following excerpt has been taken
    from `mainSemPriorityInversion.c`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 任务C负责闪烁蓝色LED，但只有在`semPtr`被获取之后（在请求后的200毫秒内）。以下摘录来自`mainSemPriorityInversion.c`：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`TaskC()` is relying on the same semaphore as `TaskA()`. The only difference
    is that `TaskC()` is blinking the blue LED to indicate the semaphore was taken
    successfully.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskC()`依赖于与`TaskA()`相同的信号量。唯一的区别是`TaskC()`正在闪烁蓝色LED以指示信号量已被成功获取。'
- en: Understanding the behavior
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为
- en: Using Ozone, load `Chapter8_semaphorePriorityInversion.elf` and start the processor.
    Then, open SystemView and observe the runtime behavior, which will be analyzed
    here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ozone，加载`Chapter8_semaphorePriorityInversion.elf`并启动处理器。然后，打开SystemView并观察运行时行为，这将在下面进行分析。
- en: 'There are a few key aspects to keep in mind when looking at this trace:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个跟踪时，有几个关键方面需要记住：
- en: '`TaskA` is the highest-priority task in the system. Ideally, if `TaskA` is
    ready to run, it should be running. Because `TaskA` shares a resource with a lower-priority
    task (`TaskC`), it will be delayed while `TaskC` is running (if `TaskC` is holding
    the resource).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskA`是系统中的最高优先级任务。理想情况下，如果`TaskA`准备好运行，它应该正在运行。因为`TaskA`与一个低优先级任务（`TaskC`）共享资源，所以当`TaskC`运行时（如果`TaskC`持有资源），它将被延迟。'
- en: '`TaskB` should not run when `TaskA`* could* run since `TaskA` has a higher
    priority.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`TaskA`*可以*运行时，`TaskB`不应该运行，因为`TaskA`具有更高的优先级。
- en: 'We''ve used the terminal output of SystemView (as well as turned on the red
    LED) to provide a notification when either `TaskA` or `TaskC` has failed to acquire
    `semPtr` in time:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了SystemView的终端输出（以及打开了红色LED）来提供通知，当`TaskA`或`TaskC`未能及时获取`semPtr`时：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s how this will look in SystemView:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这在SystemView中的样子如下：
- en: '![](img/adf42c90-b716-439b-b1f0-cdc628b436ed.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adf42c90-b716-439b-b1f0-cdc628b436ed.png)'
- en: 'The numbers in this graph line up with the theoretical example, so if you''ve
    been following along closely, you may already know what to expect:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图中的数字与理论示例相匹配，所以如果你一直密切跟踪，你可能已经知道预期结果是什么：
- en: '`TaskC` (the lowest-priority task in the system) acquires a binary semaphore
    and starts to do some work (blinking the blue LED).'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskC`（系统中的最低优先级任务）获取了一个二进制信号量并开始做一些工作（闪烁蓝色LED）。'
- en: Before `TaskC` completes its work, `TaskB` does some work.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TaskC`完成其工作之前，`TaskB`做一些工作。
- en: The highest-priority task (`TaskA`) interrupts and attempts to acquire the same
    semaphore, but is forced to wait because `TaskC` has already acquired the semaphore.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最高优先级任务（`TaskA`）中断并尝试获取相同的信号量，但被迫等待，因为`TaskC`已经获取了信号量。
- en: '`TaskA` times out after 200 ms because `TaskC` didn''t have a chance to run
    (the higher-priority task, `TaskB`, was running instead). It lights up the red
    LED because of the failure.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskA`在200毫秒后超时，因为`TaskC`没有机会运行（更高优先级的任务`TaskB`正在运行）。由于失败，它点亮了红色LED。'
- en: The fact that the lower-priority task (`TaskB`) was running while a higher-priority
    task was ready to run (`TaskA`) but waiting on a shared resource is called *priority
    inversion*. This is a reason to avoid using semaphores to protect shared resources.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个低优先级任务（`TaskB`）正在运行，而一个高优先级任务（`TaskA`）准备运行但正在等待共享资源时，这种情况被称为*优先级反转*。这是避免使用信号量来保护共享资源的原因之一。
- en: If you look closely at the example code, you'll realize that a semaphore was
    acquired and then the task holding the semaphore was put to sleep... DON'T EVER
    DO THIS in a real system. Keep in mind that this is a contrived example *designed
    to visibly fail.* See the *Using mutexes* section for more information on critical
    sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看示例代码，你会意识到信号量被获取了，然后持有信号量的任务被置于睡眠状态...永远不要在真实系统中这样做。记住，这是一个为了明显失败而设计的*人为的例子*。有关临界区的更多信息，请参阅*使用互斥锁*部分。
- en: Luckily, there is an RTOS primitive that has been *specifically designed* for
    protecting shared resources, all while minimizing the effect of priority inversion
    – the mutex.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个RTOS原语是专门设计用来保护共享资源，同时最大限度地减少优先级反转的影响——互斥锁。
- en: Using mutexes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁
- en: '**Mutex** stands for **mutual exclusion** – they are explicitly designed to
    be used in situations where access to a shared resource should be mutually exclusive
    – meaning the shared resource can only be used by one piece of code at a time.  At
    their heart, mutexes are simply binary semaphores with one (very important) difference:
    priority inheritance. In the previous example, we saw the highest-priority task
    waiting on two lower-priority tasks to complete, which caused a priority inversion.
    Mutexes address this issue with something called *priority inheritance*.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁**代表**互斥**——它们被明确设计用于在应该互斥访问共享资源的情况下使用——这意味着共享资源一次只能被一段代码使用。在本质上，互斥锁是具有一个（非常重要）区别的二进制信号量：优先级继承。在先前的例子中，我们看到最高优先级任务在等待两个低优先级任务完成，这导致了优先级反转。互斥锁通过所谓的*优先级继承*来解决这个问题。'
- en: When a higher-priority task attempts to take a mutex and is blocked, the scheduler
    will elevate the priority of the task that holds the mutex to the same level as
    the blocked task. This guarantees that the high-priority task will acquire the
    mutex and run as soon as possible.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个高优先级任务尝试获取互斥锁并被阻塞时，调度器会将持有互斥锁的任务的优先级提升到与阻塞任务相同的级别。这保证了高优先级任务将尽快获取互斥锁并运行。
- en: Fixing priority inversion
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决优先级反转问题
- en: Let's have another try at protecting the shared resource, but this time, we'll
    use a mutex instead of a semaphore. Using a mutex should help *minimize *priority
    inversion since it will effectively prevent the mid-priority task from running.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试保护共享资源，但这次，我们将使用互斥锁而不是信号量。使用互斥锁应该有助于 *最小化* 优先级反转，因为它将有效地防止中等优先级任务运行。
- en: Setting up the code
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: 'There are only two significant differences in this example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中只有两个显著的不同点：
- en: We'll use `xSemaphoreCreateMutex()` instead of `xSemaphoreCreateBinarySemaphore()`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `xSemaphoreCreateMutex()` 而不是 `xSemaphoreCreateBinarySemaphore()`。
- en: No initial `xSemaphoreGive()` call is required since the mutex will be initialized
    with a value of 1\. Mutexes are designed to be taken only when needed and then
    given back.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要初始的 `xSemaphoreGive()` 调用，因为互斥锁将初始化为值 1。互斥锁的设计是为了在需要时获取，然后返回。
- en: 'Here''s our updated example with the only significant change. This excerpt
    can be found in `mainMutexExample.c`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的更新示例，唯一的重大变化。这段摘录可以在 `mainMutexExample.c` 中找到：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are some additional name changes related to the `semPtr` to `mutexPtr` variable
    name change, but there is nothing functionally different.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `semPtr` 到 `mutexPtr` 变量名更改相关的某些名称更改，但在功能上没有不同。
- en: Understanding the behavior
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为
- en: 'Using Ozone, load `Chapter8_mutexExample.elf` and run the MCU. Here''s what
    to expect when looking at the board:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ozone，加载 `Chapter8_mutexExample.elf` 并运行 MCU。查看板子时可以期待以下情况：
- en: You'll see double blinking green and blue LEDs. The LED blinks of each color
    will not overlap one another, thanks to the mutex.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会看到绿色和蓝色 LED 双重闪烁。由于互斥锁的存在，每种颜色的 LED 闪烁不会相互重叠。
- en: There will only be a few red LED blips every once in a while. This reduction
    is caused by `TaskB` not being allowed to take priority over `TaskC` (and blocking
    `TaskA`). This is a  lot better than before, but why are we still seeing red occasionally?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时不时地只会出现几个红色 LED 闪烁。这种减少是由于 `TaskB` 不被允许优先于 `TaskC`（并阻塞 `TaskA`）。这比之前好多了，但为什么我们偶尔还会看到红色？
- en: 'By opening SystemView, we''ll see something like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开 SystemView，我们会看到以下类似的内容：
- en: '![](img/8fb2b978-2760-4b89-a8b4-a28c3d4b0b09.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fb2b978-2760-4b89-a8b4-a28c3d4b0b09.png)'
- en: Looking through the terminal messages, you'll notice that `TaskA` – the highest-priority
    task in the system – has never missed a mutex. This is what we expect since it
    has priority over everything else in the system. Why does `TaskC` occasionally miss
    a mutex (causing a red LED)?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看终端消息，你会注意到 `TaskA` —— 系统中优先级最高的任务 —— 从未错过任何互斥锁。这是我们所期待的，因为它在系统中的优先级高于其他所有任务。为什么
    `TaskC` 偶尔会错过互斥锁（导致红色 LED）？
- en: '`TaskC` attempts to take the mutex, but it is being held by `TaskA`.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskC` 尝试获取互斥锁，但它被 `TaskA` 持有。'
- en: '`TaskA` returns the mutex, but it is immediately taken again. This is caused
    by a variable amount of delay in `TaskA` between calls to the mutex. When there
    is no delay, `TaskC` isn''t allowed to run between when `TaskA` returns the mutex
    and attempts to take it again. This is reasonable since `TaskA` has a higher priority
    (though this might not be desirable in your system).'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskA` 返回互斥锁，但它立即又被拿走。这是由于 `TaskA` 在调用互斥锁之间的延迟量是可变的。当没有延迟时，`TaskC` 不被允许在 `TaskA`
    返回互斥锁并尝试再次获取它之间运行。这是合理的，因为 `TaskA` 的优先级更高（尽管这可能在你的系统中不是所希望的）。'
- en: '`TaskC` times out, waiting for the mutex.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskC` 超时，等待互斥锁。'
- en: So, we've improved our condition. `TaskA`, which is the highest-priority task,
    isn't missing any mutexes any more. But what are some best practices to follow
    when using mutexes? Read on to find out.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经改进了我们的条件。最高优先级的任务 `TaskA` 不再错过任何互斥锁。但使用互斥锁时有哪些最佳实践要遵循？继续阅读以了解详情。
- en: Avoiding mutex acquisition failure
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免互斥锁获取失败
- en: While mutexes *help* to provide protection against some priority inversion,
    we can take an additional step to make sure the mutex doesn't become an unnecessary
    crutch. The section of code that's protected by the mutex is referred to as a
    *critical section:*
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然互斥锁*有助于*提供对某些优先级反转的保护，但我们可以采取额外的步骤来确保互斥锁不会成为一个不必要的拐杖。被互斥锁保护的代码部分被称为*临界区*：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Taking steps to ensure this critical section is as short as possible will help
    in a few areas:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 采取措施确保这个临界区尽可能短，将在几个方面有所帮助：
- en: Less time in the critical section makes the shared data more available. The
    less time a mutex is being held, the more likely it is that another task will
    gain access in time.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临界区的时间越短，共享数据就越容易访问。互斥锁被持有的时间越短，另一个任务在时间上获得访问权限的可能性就越大。
- en: Minimizing the amount of time low priority tasks hold mutexes also minimizes
    the amount of time they spend in an elevated priority (if they have a high priority).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化低优先级任务持有互斥锁的时间，也可以最小化它们在高优先级（如果它们有高优先级）时花费的时间。
- en: If a low priority task is blocking a higher-priority task from running, the
    high priority task will have more variability (also known as jitter) in how quickly
    it is able to react to events.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果低优先级任务阻止了高优先级任务运行，高优先级任务在快速响应事件方面将具有更多的可变性（也称为抖动）。
- en: 'Avoid the temptation to acquire a mutex at the beginning of a long function.
    Instead, access data throughout the function and return the mutex before exiting:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在长函数的开始处获取互斥锁的诱惑。相反，在整个函数中访问数据，并在退出之前返回互斥锁：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code can be rewritten to minimize the critical section. This
    still accomplishes the same goals as providing mutual exclusion for `protectedData`,
    but the amount of time the mutex is held for is reduced:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以被重写以最小化临界区。这仍然实现了与为`protectedData`提供互斥相同的目标，但减少了互斥锁被持有的时间：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding examples, there were no `else` statements listed in case the
    action didn't complete in time. Remember, it is extremely important that the consequences
    of a missed deadline are understood and that the appropriate action is taken.
    If you *don't* have a good understanding of the required timing (and the consequences
    of missing it), then it is time to get the team together for a discussion.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，没有列出`else`语句，以防操作没有及时完成。记住，理解错过截止日期的后果并采取适当的行动是极其重要的。如果你对所需的时序（以及错过它的影响）没有很好的理解，那么是时候召集团队进行讨论了。
- en: Now that we have a basic understanding of mutexes, we'll take a look at how
    they can be used to protect data that's being shared across multiple tasks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对互斥锁有了基本的了解，我们将看看它们如何被用来保护多个任务之间共享的数据。
- en: Avoiding race conditions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免竞争条件
- en: So, when do we need to use mutexes and semaphores? Any time there is a shared
    resource between multiple tasks, either a mutex or a semaphore should be used.
    Standard binary semaphores *can* be used for resource protection, so in some special
    cases (such as semaphores being accessed from ISRs), semaphores can be desirable.
    However, you must understand how waiting on the semaphore will affect the system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在什么时候需要使用互斥锁和信号量呢？只要多个任务之间存在共享资源，就应该使用互斥锁或信号量。标准二进制信号量*可以*用于资源保护，所以在某些特殊情况下（例如从中断服务例程访问信号量），信号量可能是可取的。然而，你必须理解等待信号量将如何影响系统。
- en: We'll see an example of a semaphore being used to protect a shared resource
    in [Chapter 10](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml), *Drivers and ISRs.*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章中看到一个使用信号量保护共享资源的示例，*驱动程序和中断服务例程*。
- en: We saw a mutex in action in the previous example, but what would it look like
    if there was no mutex and we only wanted one of the blue or green LEDs to be on
    at a time?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的示例中看到了互斥锁的作用，但如果没有互斥锁，我们只想让蓝色或绿色LED中的一个在任意时刻亮起，会是什么样子？
- en: Failed shared resource example
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失败的共享资源示例
- en: In our previous mutex example, the LEDs were the shared resource being protected
    by the mutex. Only one LED was able to blink at a time – either green or blue.
    It would perform the entire double blink before the next double blink.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的互斥锁示例中，LED是互斥锁保护的共享资源。一次只能有一个LED闪烁——绿色或蓝色。它会在下一次双闪烁之前完成整个双闪烁。
- en: Let's take a look at why this is important with a more realistic example. In
    the real world, you'll often find shared data structures and hardware peripherals
    among the most common resources that need to be protected.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个更现实的例子来看看为什么这很重要。在现实世界中，你经常会发现共享数据结构和硬件外围设备是需要保护的最常见的资源。
- en: 'Accessing a data structure in an atomic fashion is very important when the
    structure contains multiple pieces of data that must be correlated with one another.
    An example would be a multi-axis accelerometer providing three readings for the
    X, Y, and Z axes. In a high-speed environment, it is important for all three readings
    to be correlated with one another to accurately determine the device''s movement
    over time:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构体包含多个必须相互关联的数据时，以原子方式访问数据结构非常重要。一个例子是多轴加速度计提供 X、Y 和 Z 轴的三个读数。在高速环境中，确保所有三个读数相互关联对于准确确定设备随时间的变化非常重要：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Task1()` is responsible for updating the data in the structure:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task1()` 负责更新结构体中的数据：'
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the other hand, `Task2()` is responsible for reading the data from the structure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Task2()` 负责从结构体中读取数据：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If one of the readings isn''t properly correlated with the others, we''ll wind
    up with an incorrect estimation of the device''s movement. `Task1` may be attempting
    to update all three readings, but in the middle of gaining access, `Task2` comes
    along and attempts to read the values. As a result, `Task2` receives an incorrect
    representation of the data because it was in the middle of being updated:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个读数与其他读数没有正确关联，我们最终会得到设备运动的错误估计。`Task1` 可能正在尝试更新所有三个读数，但在获取访问权限的过程中，`Task2`
    出现并尝试读取值。因此，由于数据正在更新中，`Task2` 收到的数据表示是错误的：
- en: '![](img/206b11b9-a073-439f-98d6-f2e84c1c2774.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/206b11b9-a073-439f-98d6-f2e84c1c2774.png)'
- en: 'Access to this data structure can be protected by putting all access to the
    shared data inside a critical section. We can do this by wrapping access in a
    mutex:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将所有对共享数据的访问放在临界区中来保护对数据结构的访问。我们可以通过在访问周围包装互斥锁来实现这一点：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is important to wrap the read accesses as well:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 包装读访问也很重要：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that data protection has been covered, we'll take another look at inter-task
    synchronization. Semaphores were used for this previously, but what if your application
    calls for actions to occur at a consistent rate? FreeRTOS software timers are
    one possible solution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据保护已经介绍完毕，我们将再次审视任务间的同步问题。之前曾使用信号量来完成这项任务，但如果你需要以一致的速度执行操作，FreeRTOS 软件定时器可能是一个解决方案。
- en: Using software timers
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用软件定时器
- en: 'Just like the name states, software timers are timers that are implemented
    with software. In MCUs, it is extremely common to have many different hardware
    peripheral timers available. These are often high resolution and have many different
    modes and features that are used to offload work from the CPU. However, there
    are two downsides to hardware timers:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，软件定时器是使用软件实现的定时器。在 MCU 中，拥有许多不同的硬件外围定时器是非常常见的。这些定时器通常具有高分辨率，并且具有许多不同的模式和功能，用于从
    CPU 中卸载工作。然而，硬件定时器有两个缺点：
- en: Since they are part of the MCU, you'll need to create an abstraction above them
    to prevent your code from becoming tightly coupled to the underlying MCU hardware.
    Different MCUs will have slightly different implementations for timers. Because
    of this, it is easy for code to become dependent on the underlying hardware.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们是 MCU 的一部分，你需要创建一个抽象层来防止你的代码与底层 MCU 硬件紧密耦合。不同的 MCU 将会有略微不同的定时器实现。正因为如此，代码很容易依赖于底层硬件。
- en: They will generally take more development time to set up than using the software-based
    timer that has already been provided by the RTOS.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常需要比使用 RTOS 已经提供的基于软件的定时器更多的开发时间来设置。
- en: Software timers alleviate this coupling by implementing multiple timer channels
    via software, rather than hardware. So, instead of an application being dependent
    on specific hardware, it can be used (without modification) on any platform the
    RTOS supports, which is extremely convenient.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 软件定时器通过软件实现多个定时器通道来减轻这种耦合，因此，应用程序不需要依赖于特定的硬件，它可以在 RTOS 支持的任何平台上使用（无需修改），这非常方便。
- en: There are techniques we can use to reduce the firmware's tight coupling to the
    underlying hardware. *[Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml),
    Tips on Creating Well Abstracted Architecture*, will outline some of the techniques
    that can be used to eliminate the tight coupling between hardware and firmware.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些技术来减少固件与底层硬件的紧密耦合。*[第12章](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)，创建良好抽象架构的技巧*将概述一些可以用来消除硬件和固件之间紧密耦合的技术。
- en: 'You may have noticed a task called `TmrSvc` in the SystemView screenshots.
    This is the software timer service task. Software timers are implemented as a
    FreeRTOS task, using many of the same underlying primitives that are available.
    They have a few configuration options, all of which can be set in `FreeRTOSConfig.h`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了SystemView截图中的一个名为`TmrSvc`的任务。这是软件定时器服务任务。软件定时器作为FreeRTOS任务实现，使用了许多相同的底层原语。它们有一些配置选项，所有这些都可以在`FreeRTOSConfig.h`中设置：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In order to have access to software timers, `configUSE_TIMERS` must be defined
    as `1`. As shown in the preceding snippet, the priority of the timer task, as
    well as the queue length (number of available timers) and stack depth, can all
    be configured through `FreeRTOSConfig.h`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问软件定时器，`configUSE_TIMERS`必须定义为`1`。如前所述的片段所示，定时器任务的优先级、队列长度（可用定时器的数量）和堆栈深度都可以通过`FreeRTOSConfig.h`进行配置。
- en: '*But software timers are a FreeRTOS feature – why do **I** need to worry about
    stack depth?!*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是软件定时器是FreeRTOS的功能——为什么我需要担心堆栈深度？！*'
- en: 'There''s one thing to keep in mind with software timers: *the code that''s
    executed when the timer fires is executed inside the context of the Software Timer
    Task.* This means two things:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用软件定时器时，需要注意的一点是：定时器触发时执行的代码是在软件定时器任务上下文中执行的。这意味着两件事：
- en: Each callback function executes on the `TmrSvc` task's stack. Any RAM (that
    is, local variables) that's used in the callback will come from the `TmrSvc` task.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个回调函数都在`TmrSvc`任务的堆栈上执行。在回调中使用任何RAM（即局部变量）都将来自`TmrSvc`任务。
- en: Any long actions that are performed will block other software timers from running,
    so treat the callback function you pass to the software timer similar to the way
    you would an ISR – don't deliberately delay the task, and keep everything as short
    as possible.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何执行较长时间的操作都会阻塞其他软件定时器的运行，因此将传递给软件定时器的回调函数视为中断服务例程（ISR）一样处理——不要故意延迟任务，并尽可能保持一切尽可能简短。
- en: The best way to get familiar with software timers is to actually use them in
    a real system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉软件定时器的最佳方式是实际在一个真实系统中使用它们。
- en: Setting up the code
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代码
- en: 'Let''s have a look at a few simple examples to see software timers in action.
    There are two main ways of using software timers: oneshot and repeat.  We''ll
    cover each with an example.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个简单的例子，看看软件定时器是如何工作的。使用软件定时器主要有两种方式：单次触发和重复触发。我们将通过示例来介绍每种方式。
- en: Oneshot timers
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单次触发定时器
- en: A *oneshot* is a timer that fires only *one* time. These types of timers are
    common in both hardware and software and come in very handy when a fixed delay
    is desired. A oneshot timer can be used when you wish to execute a *short* piece
    of code after a fixed delay, without blocking the calling code by using `vTaskDelay()`.
    To set up a oneshot timer, a timer callback must be specified and a timer created.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*单次触发*的定时器只会触发一次。这类定时器在硬件和软件中都很常见，当需要固定延迟时非常有用。当您希望在固定延迟后执行一小段代码，而不通过`vTaskDelay()`阻塞调用代码时，可以使用单次触发定时器。要设置单次触发定时器，必须指定定时器回调并创建定时器。'
- en: 'The following is an excerpt from `mainSoftwareTimers.c`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`mainSoftwareTimers.c`的摘录：
- en: Declare a `Timer` callback function that can be passed to `xTimerCreate()`.
    This callback is executed when the timer fires. Keep in mind that the callback
    is executed within the timer task, so it needs to be non-blocking!
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Timer`回调函数，该函数可以传递给`xTimerCreate()`。当定时器触发时，将执行此回调。请注意，回调在定时器任务中执行，因此它需要是非阻塞的！
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a timer. Arguments define whether or not the timer is a oneshot or repeating
    timer (repeating timers *auto-reload* in FreeRTOS).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个定时器。参数定义定时器是单次触发定时器还是重复定时器（在FreeRTOS中，重复定时器会*自动重载*）。
- en: Perform some due diligence checks to make sure the timer was created successfully
    by checking that the handle is not `NULL`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行一些尽职调查检查，以确保定时器创建成功，方法是检查句柄是否不是`NULL`。
- en: 'Issue a call to `xTimerStart()` and ensure the `uxAutoReload` flag is set to
    `false` (again, the prototype for `xTimerCreate()` is as follows):'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出一个对`xTimerStart()`的调用，并确保`uxAutoReload`标志设置为`false`（再次，`xTimerCreate()`的原型如下）：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, to create a *one-shot* timer, we need to set `uxAutoReload` to `false`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，要创建一个*单次*定时器，我们需要将`uxAutoReload`设置为`false`：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`oneShotCallBack()` will simply turn off the blue LED after 1 second has elapsed:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`oneShotCallBack()`将在1秒后简单地关闭蓝色LED：'
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Remember that the code that is executing inside the software timer must be kept
    short. All software timer callbacks are serialized (if one callback performs long
    operations, it could potentially delay others from executing).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在软件定时器内部执行的代码必须保持简短。所有软件定时器回调都是序列化的（如果一个回调执行长时间操作，可能会延迟其他回调的执行）。
- en: Repeat timers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复定时器
- en: Repeat timers are similar to oneshot timers, but instead of getting called only
    *once*, they get called *repeatedly*. After a repeat timer has been started, its
    callback will be executed repeatedly every `xTimerPeriod` ticks after being started.
    Since repeat timers are executed within the `TmrSvc` task, they can provide a
    lightweight alternative to tasks for short, non-blocking functions that need to
    be run periodically. The same considerations regarding stack usage and execution
    time apply to oneshot timers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重复定时器与单次定时器类似，但它们不是只被调用一次，而是被反复调用。重复定时器启动后，其回调函数将在启动后的每个`xTimerPeriod`周期后重复执行。由于重复定时器是在`TmrSvc`任务中执行的，因此它们可以为需要定期运行的短的非阻塞函数提供一个轻量级的任务替代方案。关于堆栈使用和执行时间方面的考虑与单次定时器相同。
- en: 'The steps are essentially the same for repeat timers: just set the value of
    the auto-reload flag to `pdTRUE`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重复定时器，步骤基本上是相同的：只需将自动重载标志的值设置为`pdTRUE`。
- en: 'Let''s take a look at the code in `mainSoftwareTimers.c`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`mainSoftwareTimers.c`中的代码：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The repeating timer will toggle the green LED:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 重复定时器将切换绿色LED：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, a static variable is used for the `counter` variable
    so that its value persists across function calls, while still hiding the variable
    from all the code outside of the `repeatCallBack()` function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用静态变量来为`counter`变量赋值，以便其值在函数调用之间保持不变，同时仍然隐藏该变量，使其不在`repeatCallBack()`函数之外的所有代码中可见。
- en: Understanding the behavior
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解行为
- en: Upon performing a reset, you'll see the blue LED turn on. To start the FreeRTOS
    scheduler and the timers, push the blue *USER* button, *B1*, in the lower left
    of the board. The blue LED will turn off after 2.2 seconds. This only happens
    once since the blue LED has been set up as a oneshot timer.  The green LED toggles
    every 500 ms since it was set up with a repeat timer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 执行复位操作后，你会看到蓝色LED点亮。要启动FreeRTOS调度器和定时器，请按下位于板子左下角的蓝色*USER*按钮，即*B1*。2.2秒后，蓝色LED会熄灭。这只会发生一次，因为蓝色LED已被设置为单次定时器。绿色LED每500毫秒切换一次，因为它被设置为重复定时器。
- en: 'Let''s take a look at the output of the SystemView terminal. In the terminal,
    all the times are relative to the start of the RTOS scheduler. The blue LED oneshot
    is only executed once, 2.2 seconds in, while the green LED is toggled every 500
    ms:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看SystemView终端的输出。在终端中，所有时间都是相对于RTOS调度器的开始。蓝色LED单次定时器只执行一次，在2.2秒时执行，而绿色LED每500毫秒切换一次：
- en: '![](img/f8ef5719-e49e-42e7-b672-54d0d91c69c3.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8ef5719-e49e-42e7-b672-54d0d91c69c3.png)'
- en: 'This same information is also available on the timeline. Note that the times
    are relative to the cursor on the timeline; they are not absolute like they are
    in the terminal:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的信息也显示在时间轴上。请注意，时间相对于时间轴上的光标；它们不是绝对时间，就像在终端中那样：
- en: '![](img/28b0dad1-ce2d-4327-a51a-1b8c833ba74f.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b0dad1-ce2d-4327-a51a-1b8c833ba74f.png)'
- en: Now that we know how to set up software timers and understand their behavior,
    let's discuss when they can be used.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何设置软件定时器并理解了它们的行为，让我们讨论一下它们何时可以使用。
- en: Software timer guidelines
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件定时器指南
- en: Software times can be really useful, especially since they're so easy to set
    up. They are also fairly lightweight because of the way they have been coded in
    FreeRTOS – they don't require significant code or CPU resources when used.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 软件定时器非常有用，尤其是它们设置起来非常简单。由于它们在FreeRTOS中的编码方式，它们相当轻量级——在使用时不需要大量的代码或CPU资源。
- en: Example use cases
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例用例
- en: 'Here are some use cases to help you out:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用例可以帮助你：
- en: To periodically perform an action (auto-reload mode). For example, a timer callback
    function could give a semaphore to a reporting task to provide periodic updates
    about the system.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了定期执行一个动作（自动重载模式）。例如，定时器回调函数可以向报告任务发送信号量，以提供有关系统的定期更新。
- en: To perform an event only once at some point in the future, without blocking
    the calling task in the meantime (which would be required if `vTaskDelay()` was
    used instead).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未来的某个时刻仅执行一次事件，同时不阻塞调用任务（如果使用`vTaskDelay()`则会发生这种情况）。
- en: Considerations
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑因素
- en: 'Keep these considerations in mind:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住以下考虑因素：
- en: The priority of the timer service task can be configured in `FreeRTOSConfig.h`
    by setting `configTIMER_TASK_PRIORITY`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器服务任务优先级可以通过在`FreeRTOSConfig.h`中设置`configTIMER_TASK_PRIORITY`来配置。
- en: Timers can be modified after being created, restarted, and deleted.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器创建后可以修改，可以重新启动，也可以删除。
- en: Timers can be created statically (similar to static task creation) to avoid
    dynamic allocation from the FreeRTOS heap.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器可以创建为静态（类似于静态任务创建）以避免从FreeRTOS堆中动态分配。
- en: All callbacks are executed in the Software Timer Service Task  – they must be
    kept short and not block!
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有回调都在软件定时器服务任务中执行 —— 它们必须保持简短且不阻塞！
- en: Limitations
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局限性
- en: 'So, what''s not to love about software timers? Not too much, as long as the
    following are kept in mind:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，软件定时器有什么不好呢？只要记住以下几点，就不会太多：
- en: '**Jitter**: Since the callbacks are executed within the context of a task,
    their exact execution time will depend on all the interrupts in the system, as
    well as any higher-priority tasks. FreeRTOS allows this to be tuned by adjusting
    the priority of the timer task being used (which must be balanced with the responsiveness
    of other tasks in the system).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抖动**：由于回调是在任务上下文中执行的，它们的精确执行时间将取决于系统中的所有中断以及任何更高优先级的任务。FreeRTOS允许通过调整所使用的定时器任务的优先级来调整这一点（这必须与其他任务的响应性相平衡）。'
- en: '**Single Priority**: All software timer callbacks execute inside the same task.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单优先级**：所有软件定时器回调都在同一任务中执行。'
- en: '**Resolution**: A software timer''s resolution is only as precise as the FreeRTOS
    tick rate (defined as 1 ms for most ports).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：软件定时器的分辨率仅与FreeRTOS滴答率（在大多数端口中定义为1 ms）一样精确。'
- en: If lower jitter or higher resolution is required, it probably makes sense to
    use a hardware timer with ISRs instead of software timers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更低的抖动或更高的分辨率，可能使用带有中断服务例程（ISRs）的硬件定时器而不是软件定时器是有意义的。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered many different aspects of synchronizing tasks and
    protecting shared data between tasks. We also covered semaphores, mutexes, and
    software timers. Then, we got our hands dirty by writing some code for each of
    these types and took a deep dive into analyzing the code's behavior using our
    Nucleo development board and SystemView.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了同步任务和保护任务之间共享数据的许多不同方面。我们还介绍了信号量、互斥锁和软件定时器。然后，我们通过为这些类型编写一些代码并使用我们的Nucleo开发板和SystemView深入分析代码行为来亲自动手。
- en: Now, you have some tools at your disposal for solving synchronization problems,
    such as one task notifying another that an event has occurred (semaphores). This
    means you're able to safely share data between tasks by properly wrapping access
    in a mutex. You also know how to save a bit of RAM when performing simple operations,
    that is, by using software timers for small periodic operations, instead of dedicated
    tasks.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经掌握了一些解决同步问题的工具，例如一个任务通知另一个任务事件已发生（信号量）。这意味着您可以通过在互斥锁中正确封装访问来安全地在任务之间共享数据。您也知道如何在执行简单操作时节省一些RAM，即通过使用软件定时器进行小周期性操作，而不是专用任务。
- en: In the next chapter, we'll cover more crucial RTOS primitives that are used
    for inter-task communication and provide the foundations for many RTOS-based applications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍更多用于任务间通信和为许多基于RTOS的应用程序提供基础的至关重要的RTOS原语。
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude this chapter, here is a list of questions for you to test your
    knowledge regarding this chapter''s material. You will find the answers in the
    *Assessments* section of the Appendix:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章内容之际，这里有一系列问题供您测试对本章内容的理解。您将在附录的*评估*部分找到答案：
- en: What are semaphores most useful for?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号量最有用的用途是什么？
- en: Why is it dangerous to use semaphores for data protection?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用信号量进行数据保护是危险的？
- en: What does mutex stand for?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: mutex代表什么？
- en: Why are mutexes better for protecting shared data?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么互斥锁更适合保护共享数据？
- en: With an RTOS, there is no need for any other type of timer since many instances
    of software timers are available.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实时操作系统（RTOS）中，由于许多软件定时器的实例可用，因此不需要任何其他类型的定时器。
- en: 'True'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Further reading
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A Microsoft paper that provides more detail on problems with semaphores: [https://www.microsoft.com/en-us/research/publication/implementing-condition-variables-with-semaphores/](https://www.microsoft.com/en-us/research/publication/implementing-condition-variables-with-semaphores/)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇微软论文，提供了关于信号量问题的更多细节：[https://www.microsoft.com/en-us/research/publication/implementing-condition-variables-with-semaphores/](https://www.microsoft.com/en-us/research/publication/implementing-condition-variables-with-semaphores/)
- en: 'Phillip Koopman on race conditions: [http://course.ece.cmu.edu/~ece642/lectures/26_raceconditions.pdf](http://course.ece.cmu.edu/~ece642/lectures/26_raceconditions.pdf)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彼得·库普曼关于竞态条件的内容：[http://course.ece.cmu.edu/~ece642/lectures/26_raceconditions.pdf](http://course.ece.cmu.edu/~ece642/lectures/26_raceconditions.pdf)
