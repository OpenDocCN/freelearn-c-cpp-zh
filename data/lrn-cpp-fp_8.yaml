- en: Creating and Debugging Application in Functional Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数式方法中创建和调试应用程序
- en: We discussed some basic techniques to develop functional programming in the
    previous chapters that include a first-class function, a pure function, and an
    immutable object. In this chapter, we will use all the techniques we have learned
    in the previous chapters to produce an application in a functional way. It will
    also explain how to debug an application that is built using the C++ language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章讨论了一些基本的技术，以函数式编程的方式开发，包括一等函数、纯函数和不可变对象。在本章中，我们将使用我们在前几章中学到的所有技术，以函数式的方式产生一个应用程序。它还将解释如何调试使用C++语言构建的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing an imperative code as a base code to be transformed to the functional
    code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个命令式代码作为基本代码，以便转换为函数式代码
- en: Implementing the pure function to the base code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现纯函数到基本代码
- en: Implementing the template metaprogramming to the base code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模板元编程到基本代码
- en: Implementing the filtering technique to the base code using the Lambda expression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda表达式实现基本代码的过滤技术
- en: Implementing the recursion technique to the base code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现递归技术到基本代码
- en: Implementing the memoization technique to the base code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现备忘录技术到基本代码
- en: Debugging the code to solve, if we get an unexpected result
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试代码以解决，如果我们得到了意外的结果
- en: Preparing an imperative class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备一个命令式类
- en: We will now develop the functional class so we can consume it to our functional
    program. Before that, let's prepare a new imperative class named `Customer`. The
    class will have an `int` property named `id` as a unique customer ID number. It
    also has four string properties to store the information about our customer--`name`,
    `address`, `phoneNumber`, and `email`. The class also has a flag--`isActive`--to
    indicate whether or not our customer is active. If the customer has signed a contract
    with us, they are regarded as an active customer. Another property is `registeredCustomers`,
    to save all registered customers we have, regardless of the active customer. We
    will make the `registeredCustomers` member become `static` so we can fill it from
    outside the class and can keep the list of the `Customer` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开发功能类，这样我们就可以将其用于我们的功能程序。在那之前，让我们准备一个名为`Customer`的新的命令式类。该类将有一个名为`id`的`int`属性，作为唯一的客户ID号。它还有四个字符串属性，用于存储关于我们客户的信息--`name`、`address`、`phoneNumber`和`email`。该类还有一个标志--`isActive`--用于指示我们的客户是否活跃。如果客户与我们签订了合同，他们被视为活跃客户。另一个属性是`registeredCustomers`，用于保存我们所有已注册的客户，无论是否活跃。我们将使`registeredCustomers`成员变为`static`，这样我们就可以从类外部填充它，并且可以保持`Customer`类的列表。
- en: 'Besides these properties, our class will also have four methods to access the
    list of our properties. They will be the following methods:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些属性，我们的类还将有四个方法来访问我们属性的列表。它们将是以下方法：
- en: '`GetActiveCustomerNames()`: This can be used to get the list of active customer
    names'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerNames()`: 这可以用来获取活跃客户的名称列表'
- en: '`GetActiveCustomerAddresses()`: This can be used to get the list of active
    customer addresses'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerAddresses()`: 这可以用来获取活跃客户的地址列表'
- en: '`GetActiveCustomerPhoneNumbers()`: This can be used to get the list of active
    customer phone numbers'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerPhoneNumbers()`: 这可以用来获取活跃客户的电话号码列表'
- en: '`GetActiveCustomerEmails()`: This can be used to get the list of active customer
    emails'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerEmails()`: 这可以用来获取活跃客户的电子邮件列表'
- en: 'Now, let''s take a look at the following `Customer.h` code that we can find
    in the `Step01` folder to accommodate our preceding scenario:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们可以在`Step01`文件夹中找到的以下`Customer.h`代码，以适应我们之前的情景：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the preceding code, we have four public methods that haven''t been defined
    yet. Now, let''s define them as we can see in the following `Customer.cpp` code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们有四个尚未定义的公共方法。现在，让我们定义它们，就像我们在以下`Customer.cpp`代码中所看到的那样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding code, we can see the definition of the four methods we have
    in the `Customer` class. For instance, in the `GetActiveCustomerNames()` method,
    the code loops each element in the `registeredCustomers` vector to find out the
    active customer. If it finds them, the code will extract the name of each customer
    and store it to the `returnList` vector. After finishing the method process, the
    method will feed the `returnList` result to the method user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到`Customer`类中我们有四个方法的定义。例如，在`GetActiveCustomerNames()`方法中，代码循环遍历`registeredCustomers`向量中的每个元素，以找出活跃客户。如果找到了，代码将提取每个客户的名称并将其存储到`returnList`向量中。方法完成后，方法将把`returnList`的结果提供给方法用户。
- en: 'Now, let''s consume the preceding class using the following `main.cpp` code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下`main.cpp`代码来使用前面的类：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the preceding code, in the `main()` method, we can see that we first register
    our customer from the `RegisterCustomers()` method. There, we fill the static
    public property of the `Customer` class, `registeredCustomers`, with a bunch of
    our customer information. After that, the code instances the `Customer` class
    and invokes the method of the class named `GetActiveCustomerNames()`. As we can
    see, the method returns a vector of string that contains the list of active customer
    names that we will then store in the `activeCustomerNames` vector. Now, we can
    iterate the vector to extract the list of the active customer names. The following
    is the output we should see in the console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，在`main()`方法中，我们可以看到我们首先从`RegisterCustomers()`方法中注册我们的客户。在那里，我们用一堆我们的客户信息填充了`Customer`类的静态公共属性`registeredCustomers`。之后，代码实例化了`Customer`类，并调用了类的名为`GetActiveCustomerNames()`的方法。正如我们所看到的，该方法返回一个包含我们将在`activeCustomerNames`向量中存储的活跃客户名称列表的字符串向量。现在，我们可以迭代向量以提取活跃客户名称的列表。以下是我们应该在控制台中看到的输出：
- en: '![](img/0c74fd8b-73c6-4039-b261-75edddd462dd.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c74fd8b-73c6-4039-b261-75edddd462dd.png)'
- en: As we can see in the `RegisterCustomer()` method, only five from ten customers
    are active, so not all of the names will be listed in the preceding output. We
    can try the remaining three methods to the information about the active customers
    specifically, their addresses, phone numbers, and email addresses. Our goal in
    this chapter is to use the concepts we've learned in the previous chapters and
    make an application using the functional approach. So, let's see how we can achieve
    that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`RegisterCustomer()`方法中所看到的，十个客户中只有五个是活跃的，所以并不是所有的名字都会在前面的输出中列出。我们可以尝试剩下的三种方法来获取关于活跃客户的信息，特别是他们的地址、电话号码和电子邮件地址。本章的目标是利用我们在前几章学到的概念，使用函数式方法来制作一个应用程序。所以，让我们看看我们如何能够实现这一点。
- en: Refactoring the imperative class to become a functional class
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构命令式类为函数式类
- en: Indeed, the preceding `Customer` class can work well, and we have successfully
    invoked its methods. However, the class can still be tweaked by transforming it
    into a functional class. As we can see in the preceding code, we can implement
    a pure function, first-class function, higher-order function, and memoization
    to it to make it become functional. So, in this section, we will refactor the
    `Customer` class to become a functional class and use the knowledge we have from
    the previous chapters. In the upcoming section, we will implement the functional
    method that we have discussed in the previous chapter, which is the first-class
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前面的`Customer`类可以很好地工作，我们已经成功地调用了它的方法。然而，这个类仍然可以通过将其转换为一个函数式类来进行调整。正如我们在前面的代码中所看到的，我们可以实现一个纯函数、一等函数、高阶函数和记忆化，使其变得函数式。因此，在本节中，我们将重构`Customer`类，使其成为一个函数式类，并使用我们从前几章学到的知识。在接下来的部分，我们将实现我们在前一章中讨论过的函数式方法，即一等函数。
- en: Passing a function as a parameter
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: 'As we discussed in [Chapter 2](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, we can rewrite the function
    to be a first-class function, which means we can pass a function to another function.
    We will simplify the definition of all the four methods we have in the `Step01`
    code, then we will call the function by passing it to another method named `GetActiveCustomerByFunctionField()`.
    We will also create a new method named `GetActiveCustomerByField()` to select
    the correct method we should run. The definition of the `Customer` class is now
    like the following `Customer.h` code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](a1baf007-8f40-4616-8718-9887f95120b0.xhtml)中讨论的*函数式编程中的函数操作*，我们可以重写函数成为一等函数，这意味着我们可以将一个函数传递给另一个函数。我们将简化`Step01`代码中所有四个方法的定义，然后通过将其传递给另一个名为`GetActiveCustomerByFunctionField()`的方法来调用该函数。我们还将创建一个名为`GetActiveCustomerByField()`的新方法来选择我们应该运行的正确方法。`Customer`类的定义现在如下`Customer.h`代码所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see in the preceding header file, besides the four private methods,
    we add a new public method named `GetActiveCustomerByFunctionField()`, which we
    will invoke when we need a list of one of the properties. Now, let''s define the
    four methods we create in the preceding header file. The code should be as the
    following `Customer.cpp` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的头文件中所看到的，除了四个私有方法之外，我们还添加了一个名为`GetActiveCustomerByFunctionField()`的新公共方法，当我们需要一个属性列表时，我们将调用它。现在，让我们定义前面头文件中创建的四个方法。代码应该如下`Customer.cpp`文件所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Comparing with the `Step01` code, the implementation of the `GetActiveCustomerNames()`,
    `GetActiveCustomerAddresses()`, `GetActiveCustomerPhoneNumbers()`, and `GetActiveCustomerEmails()`
    methods is more concise now. They only contain a single line code. However, we
    need a new method to accommodate the process to get a list of the class'' private
    properties, that is the `GetActiveCustomerByField()` method. The method is passed
    to the function to make it a first-class function, as we can see in the preceding
    code. In this `Step02` folder, the `main.cpp` code should be as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Step01`代码相比，`GetActiveCustomerNames()`、`GetActiveCustomerAddresses()`、`GetActiveCustomerPhoneNumbers()`和`GetActiveCustomerEmails()`方法的实现现在更加简洁。它们只包含一行代码。然而，我们需要一个新的方法来容纳获取类的私有属性列表的过程，即`GetActiveCustomerByField()`方法。该方法被传递给函数，使其成为一等函数，正如我们在前面的代码中所看到的。在这个`Step02`文件夹中，`main.cpp`代码应该如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see in the preceding `main.cpp` code, we will now invoke the `GetActiveCustomerByField()`
    method instead of `GetActiveCustomerNames()`, as we do in `Step01`. We just need
    to pass a field name in string data type to the `GetActiveCustomerNames()` method
    and it will call the appropriate method to retrieve the properties value. For
    instance, we will retrieve the `name` properties value because we pass `name`
    in the `GetActiveCustomerByField()` method. And, if we run the preceding `Step02`
    code, we should see the following screenshot, which is exactly the same as what
    we see in the `Step01` code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的`main.cpp`代码中所看到的，我们现在将调用`GetActiveCustomerByField()`方法，而不是像在`Step01`中那样调用`GetActiveCustomerNames()`。我们只需要将一个字符串数据类型的字段名传递给`GetActiveCustomerNames()`方法，它就会调用适当的方法来检索属性值。例如，我们将检索`name`属性值，因为我们在`GetActiveCustomerByField()`方法中传递了`name`。如果我们运行前面的`Step02`代码，我们应该会看到以下的截图，这与我们在`Step01`代码中看到的完全相同：
- en: '![](img/793236ef-020b-465c-b392-8edceb8b9408.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/793236ef-020b-465c-b392-8edceb8b9408.png)'
- en: Although we have the code running properly, there's a problem we will face if
    we want to add more fields or properties to the class, and then need to collect
    the list of that new field. By using the preceding code, we have to add a new
    `else` section in the `GetActiveCustomerByFunctionField()` method. Next, we will
    find the solution to counter it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的代码可以正常运行，但如果我们想要向类中添加更多的字段或属性，然后需要收集该新字段的列表，我们将面临一个问题。通过使用前面的代码，我们必须在`GetActiveCustomerByFunctionField()`方法中添加一个新的`else`部分。接下来，我们将找到解决方法来解决这个问题。
- en: Adding a base class
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个基类
- en: 'If we want to add more fields in the class and want to access the list of it
    easily every time we add a new field, we have to create a new class that derives
    from a base class containing a virtual function. By doing this, we can derive
    the base class virtual method and implement the correct code to it. We will also
    gain the power of template metaprogramming here, since we will design the base
    class as a template. The declaration of the base class will be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在类中添加更多字段，并且每次添加新字段时都希望轻松访问它的列表，我们必须创建一个从包含虚函数的基类派生出来的新类。通过这样做，我们可以派生出基类的虚方法，并为其实现正确的代码。在这里，我们还将获得模板元编程的能力，因为我们将设计基类为模板。基类的声明应该如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can declare four new classes derived from the base class for the four
    methods in the class. The declaration of the classes should be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从基类派生出四个新类，用于类中的四种方法。类的声明应该如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to modify the argument type for the `GetActiveCustomerByFunctionField()`
    method, so the signature of the method should be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`GetActiveCustomerByFunctionField()`方法的参数类型也需要修改，因此方法的签名应该如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, the complete header file for this `Step03` code that implements
    the preceding codes should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实现了前述代码的`Step03`代码的完整头文件应该如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, each method in each preceding class has a different task and can be identified
    by the class'' name. We will also modify the `GetActiveCustomerByFunctionField()`
    method implementation since it''s now passed a new argument type, which is the
    class name. By passing a class, it''s now easier to pass our desired task that
    lied in the class'' method. The implementation of the `GetActiveCustomerByFunctionField()`
    method should be as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个前述类中的方法都有不同的任务，并且可以通过类名进行识别。我们还将修改`GetActiveCustomerByFunctionField()`方法的实现，因为它现在传递了一个新的参数类型，即类名。通过传递一个类，现在更容易传递我们在类方法中的期望任务。`GetActiveCustomerByFunctionField()`方法的实现应该如下：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the preceding method can run the method of the class we have
    passed, which is `classField`. Moreover, since the class we have is derived from
    the `BaseClass` class, we can notify the method to receive the parameter typed
    `BaseClass`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，前面的方法可以运行我们传递的类的方法，即`classField`。此外，由于我们的类是从`BaseClass`类派生出来的，我们可以通知方法接收类型为`BaseClass`的参数。
- en: 'Now we can implement the public method that we have declared in the header
    file-- the `GetActiveCustomerNames()`, `GetActiveCustomerAddresses()`, `GetActiveCustomerPhoneNumbers()`,
    and `GetActiveCustomerEmails()` methods. These four methods will invoke the `GetActiveCustomerByFunctionField()`
    method and pass the definition of the `InvokeFunction()` method. The code should
    be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现在头文件中声明的公共方法--`GetActiveCustomerNames()`、`GetActiveCustomerAddresses()`、`GetActiveCustomerPhoneNumbers()`和`GetActiveCustomerEmails()`方法。这四个方法将调用`GetActiveCustomerByFunctionField()`方法，并传递`InvokeFunction()`方法的定义。代码应该如下：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we will have a complete `Customer.cpp` file as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将得到一个完整的`Customer.cpp`文件，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By having the `Customer.h` and `Customer.cpp` code in this `Step03` folder,
    it''s now easier for us to fetch the list of the properties we have in the `Customer`
    class. For instance, if we want to retrieve a list of active customers, we can
    directly invoke the `GetActiveCustomerNames()` method, as we can see in the following
    `main.cpp` code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Step03`文件夹中拥有`Customer.h`和`Customer.cpp`代码，我们现在更容易获取`Customer`类中的属性列表。例如，如果我们想要检索活跃客户的列表，我们可以直接调用`GetActiveCustomerNames()`方法，就像我们在下面的`main.cpp`代码中看到的那样：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s run the program in the `Step03` folder. We should see the following
    screenshot on the console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`Step03`文件夹中运行程序。我们应该在控制台上看到以下截图：
- en: '![](img/5bc3935e-3059-4f30-b414-8e04a2a1086a.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bc3935e-3059-4f30-b414-8e04a2a1086a.png)'
- en: Again, we've got the exact same output comparing the previous step. We will
    make the `Customer` class become pure in the next section. So, keep going!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到了与上一步相同的输出。我们将在下一节中使`Customer`类变得纯净。所以，继续前进！
- en: Transforming the class to become pure
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类转换为纯净的
- en: As we discussed in [Chapter 2](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, we have to create a pure function
    in functional programming to avoid the side effect. If we come back to the previous
    `GetActiveCustomerByFunctionField()` method definition, it iterates a `registeredCustomers`
    static member that is a global variable. It will be a problem since the `GetActiveCustomerByFunctionField()`
    method will feed a different output, although with the exact same passed as an
    argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](a1baf007-8f40-4616-8718-9887f95120b0.xhtml)中讨论的*函数式编程中的函数操作*，我们必须在函数式编程中创建一个纯函数以避免副作用。如果我们回到之前的`GetActiveCustomerByFunctionField()`方法定义，它迭代了一个全局变量`registeredCustomers`。这将是一个问题，因为`GetActiveCustomerByFunctionField()`方法将提供一个不同的输出，尽管传递的参数完全相同。
- en: 'To counter this problem, we have to abolish this global variable. We then have
    to modify the method definition as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须废除这个全局变量。然后，我们必须修改方法的定义如下：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we don''t have the `registeredCustomers` properties anymore, we also
    have to pass a registered customer list to the `GetActiveCustomerByFunctionField()`
    method. The method will then iterate the customer list we pass, to find the active
    customer. Moreover, because we have modified the method signature, we also have
    to modify the method declaration in the `Customer.h` file as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再拥有`registeredCustomers`属性，我们还必须将注册的客户列表传递给`GetActiveCustomerByFunctionField()`方法。然后，该方法将迭代我们传递的客户列表，以找到活跃客户。此外，由于我们修改了方法签名，我们还必须修改`Customer.h`文件中的方法声明，如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We discussed that the `GetActiveCustomerByFunctionField()` method is called
    by the other methods in the `Customer` class. As a result, we also have to modify
    the method implementation, as we can see in the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了`GetActiveCustomerByFunctionField()`方法是由`Customer`类中的其他方法调用的。因此，我们还必须修改方法的实现，就像我们在下面的代码片段中看到的那样：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to modify the method declarations in the `Customer.h` file, as
    shown in the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`Customer.h`文件中的方法声明，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, the `Customer.h` file will contain the following complete code block:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Customer.h`文件将包含以下完整的代码块：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And, the `Customer.cpp` file will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，`Customer.cpp`文件将如下所示：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since the `Customer` class has been changed and has no `registeredCustomer`
    variable anymore, we also need to modify the `RegisterCustomers()` method in the
    `main.cpp` file. The previous version of the method returns nothing. Now, we will
    make the code return the list of customers. We also need to modify the `main()`
    method since we have to consume the new `RegisterCustomers()` method in the `Main.cpp`
    file. The file will contain the following block of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Customer`类已经更改，不再有`registeredCustomer`变量，我们还需要修改`main.cpp`文件中的`RegisterCustomers()`方法。方法的先前版本没有返回值。现在，我们将使代码返回客户列表。我们还需要修改`main()`方法，因为我们必须在`Main.cpp`文件中使用新的`RegisterCustomers()`方法。该文件将包含以下代码块：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see in the preceding `main()` method, we invoke the `GetActiveCustomerNames()`
    method and pass the result of the `RegisterCustomers()` method. Now, let''s try
    the code by running the program in the `Step06` folder. We should get the following
    output on the console when we run the program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的`main()`方法中所看到的，我们调用了`GetActiveCustomerNames()`方法，并传递了`RegisterCustomers()`方法的结果。现在，让我们尝试在`Step06`文件夹中运行程序。当我们运行程序时，控制台应该输出以下内容：
- en: '![](img/83af4fa6-23aa-4db0-a7a2-860c55bfc133.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83af4fa6-23aa-4db0-a7a2-860c55bfc133.png)'
- en: Again, we've got the exact same output we saw in the previous step, but with
    a new approach in functional programming. Next, we will refactor the code to use
    a Lambda expression to ease the filtering task.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到了与之前步骤中相同的输出，但采用了函数式编程的新方法。接下来，我们将重构代码，使用Lambda表达式来简化过滤任务。
- en: Filtering the condition and implementing a Lambda expression
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤条件并实现Lambda表达式
- en: 'Let''s focus on the `GetActiveCustomerByFunctionField()` method. There, we
    can find an `if` structure to filter the active customer. As we discussed in the
    previous chapters, we can use the `copy_if()` method to filter the condition.
    The following code snippet implements the `copy_if()` method to filter the active
    customer:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于`GetActiveCustomerByFunctionField()`方法。在那里，我们可以找到一个`if`结构来过滤活跃客户。正如我们在前几章中讨论的，我们可以使用`copy_if()`方法来过滤条件。以下代码片段实现了`copy_if()`方法来过滤活跃客户：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the preceding code snippet, we create an anonymous method
    that returns true if the customer instance we pass is active. Also, we can refactor
    the preceding `GetActiveCustomerByFunctionField()` method so it will use an anonymous
    method again, as we can see in the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码片段中所看到的，我们创建了一个匿名方法，如果我们传递的客户实例是活跃的，则返回true。此外，我们还可以重构前面的`GetActiveCustomerByFunctionField()`方法，使其再次使用匿名方法，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to implementing the filtering technique using the Lambda expression,
    we will also add a method to the `Customer` class named `CountActiveCustomers()`.
    The method will count the active customers. The definition of this method should
    be as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Lambda表达式实现过滤技术之外，我们还将在`Customer`类中添加一个名为`CountActiveCustomers()`的方法。该方法将计算活跃客户的数量。该方法的定义应该如下：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we will have the `Customer.cpp` code in this `Step05` code block as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`Step05`代码块中有`Customer.cpp`代码如下：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Don''t forget to modify the `Customer.h` file as well, since we have added
    a new method to the class. The file should contain the following piece of code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记修改`Customer.h`文件，因为我们已经向类中添加了一个新方法。该文件应包含以下代码片段：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we will invoke the `CountActiveCustomers()` method in our `main()` function.
    We will see how we do that by examining the following `Main.cpp` code block:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的`main()`函数中调用`CountActiveCustomers()`方法。我们将通过检查以下`Main.cpp`代码块来看看我们是如何做到的：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see in the preceding code, we invoke the `CountActiveCustomers()`
    method and pass the output of the `RegisterCustomers()` method as the argument.
    We also add a simple stopwatch to calculate how long the code needs to run the
    program. The output of the preceding code should be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们调用了`CountActiveCustomers()`方法，并将`RegisterCustomers()`方法的输出作为参数传递。我们还添加了一个简单的秒表来计算程序运行所需的时间。前面代码的输出应该如下：
- en: '![](img/b6c381e2-85f3-4717-9990-031a1a9fb7f3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6c381e2-85f3-4717-9990-031a1a9fb7f3.png)'
- en: As we can see, we need `0.997` milliseconds to run the code in this step. However,
    we can optimize the preceding code to run faster by implementing recursion and
    memoization, which we will discuss in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们需要`0.997`毫秒来运行这一步的代码。然而，我们可以通过实现递归和记忆化来优化前面的代码，使其运行更快，这将在下一节中讨论。
- en: 'Indeed, we can find out the total of the active customers by running the method
    of `activeCustomerNames.size()` to get the number of elements in the vector after
    we run the following code line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以通过运行`activeCustomerNames.size()`方法来找出活跃客户的总数，以获取运行以下代码行后向量中元素的数量：
- en: '`vector<string> activeCustomerNames ='
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector<string> activeCustomerNames =`'
- en: customer.GetActiveCustomerNames(RegisterCustomers())`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: customer.GetActiveCustomerNames(RegisterCustomers())`
- en: However, the preceding code example wants to show us how the `for` loop can
    be transformed into recursion, to optimize the speed of execution. We will discuss
    this in the upcoming
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的代码示例想要向我们展示如何将`for`循环转换为递归，以优化执行速度。我们将在接下来讨论这个问题
- en: section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 部分。
- en: Implementing recursion and memoization techniques to the Customer class
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`Customer`类中实现递归和记忆化技术
- en: 'If we look at the `CountActiveCustomers()` method definition in `Step05`, we
    use the `for` loop to count the active customers. However, we can rewrite the
    method to use the recursion technique. Let''s take a look at the following code,
    which is the new definition for the `CountActiveCustomers()` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`Step05`中`CountActiveCustomers()`方法的定义，我们使用`for`循环来计算活跃客户。然而，我们可以重写该方法以使用递归技术。让我们看一下以下代码，这是`CountActiveCustomers()`方法的新定义：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see in the preceding code snippet, we use tail recursion for the `CountActiveCustomers()`
    method. We just need to increment the `add` variable every time we find an active
    customer in the `customer` vector. The code then removes the first element of
    the `customer` vector and passes it to the `CountActiveCustomers()` method again.
    We recurse this process until the element of the `customer` vector is empty.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面的代码片段中所看到的，我们使用尾递归来实现`CountActiveCustomers()`方法。我们只需要在`customer`向量中找到一个活跃的客户时每次增加`add`变量。然后，代码会删除`customer`向量的第一个元素，并将其传递给`CountActiveCustomers()`方法。我们递归这个过程，直到`customer`向量的元素为空为止。
- en: 'Also, we use the `Memoization` class we discussed in [Chapter 5](aaf78dc0-36c9-41f9-bf10-efcbd979c096.xhtml),
    *Procrastinating the Execution Process Using Lazy Evaluation*, to optimize our
    code. We will modify the `main()` function in the `Main.cpp` file so the `main()`
    function contains the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还使用了我们在[第5章](aaf78dc0-36c9-41f9-bf10-efcbd979c096.xhtml)中讨论的`Memoization`类，即**使用惰性求值推迟执行过程**，来优化我们的代码。我们将修改`Main.cpp`文件中的`main()`函数，使`main()`函数包含以下代码片段：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see in the preceding code snippet, we now run the `GetActiveCustomerNames()`
    method from the `Memoization` instance by calling the `Fetch()` method. If we
    run the `Step06` code, we should see the following output on the console:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们现在通过调用`Fetch()`方法从`Memoization`实例运行`GetActiveCustomerNames()`方法。如果我们运行`Step06`代码，我们应该在控制台上看到以下输出：
- en: '![](img/75cf002b-d6a6-4118-a72b-89ccb548a3d4.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75cf002b-d6a6-4118-a72b-89ccb548a3d4.png)'
- en: The code now only needs `0.502` milliseconds to run. Compared to the `Step05`
    code, the speed of code execution is almost twice as fast. It proves that, by
    using the functional approach, we can gain not only a better code structure, but
    also speed optimization.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该代码只需要`0.502`毫秒来运行。与`Step05`代码相比，代码执行的速度几乎快了一倍。这证明，通过使用功能性方法，我们不仅可以获得更好的代码结构，还可以进行速度优化。
- en: Debugging the code
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试代码
- en: Sometimes, in the coding process, when we run the code, we've got an unexpected
    result from one or more variables. It might happen in the middle of the execution.
    To avoid getting stuck in this situation, we can analyze our program by running
    it step-by-step. We can use the debugger tool that is included in the GCC compiler--**GDB**
    (**The GNU Project Debugger**). This tool allows us to figure out what happens
    inside the target program while it executes, or what it was doing at the moment
    it crashed. In this section, we will apply the GDB to ease our programming task
    and find a solution for the problem and deal with it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在编码过程中，当我们运行代码时，一个或多个变量会出现意外的结果。这可能发生在执行过程中。为了避免陷入这种情况，我们可以通过逐步运行程序来分析我们的程序。我们可以使用GCC编译器中包含的调试器工具--**GDB**（**GNU项目调试器**）。这个工具允许我们弄清楚目标程序在执行时发生了什么，或者在它崩溃时正在做什么。在本节中，我们将应用GDB来简化我们的编程任务，并找到问题的解决方案并处理它。
- en: Starting the debugging tool
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动调试工具
- en: 'Now, let''s prepare the executable file we will analyze. We will use the code
    from the `Step01` folder since it''s a simple code, and we can learn easily from
    it. We have to recompile the code using the `-g` option and name the executable
    as `customer.exe`. The following are the three commands to compile the code so
    it can be debugged:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备要分析的可执行文件。我们将使用`Step01`文件夹中的代码，因为它是一个简单的代码，我们可以很容易地从中学习。我们必须使用`-g`选项重新编译代码，并将可执行文件命名为`customer.exe`。以下是编译代码以便进行调试的三个命令：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: GDB can only analyze the executable file that contains the debugging information
    and symbols that are important in the debugging process. We can insert the `-g`
    option when we compile the source so the debugging information and symbol will
    be added to the executable file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: GDB只能分析包含调试信息和符号的可执行文件，这些信息和符号在调试过程中很重要。我们可以在编译源代码时插入`-g`选项，以便将调试信息和符号添加到可执行文件中。
- en: 'Typing `gdb customer` on the console will open the debugger tool and load the
    debugger information and symbol from the `customer.exe` file. We will then see
    the following screenshot on the console:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台上输入`gdb customer`将打开调试器工具，并加载来自`customer.exe`文件的调试器信息和符号。然后我们将在控制台上看到以下截图：
- en: '![](img/075cb3bb-6396-46a8-aa8d-6cb3bd8b24b6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/075cb3bb-6396-46a8-aa8d-6cb3bd8b24b6.png)'
- en: 'As we can see in the preceding screenshot, it has successfully read the symbol
    from the `customer.exe` file. Then, type `start` in the GDB console to start the
    analyzing process. The debugger will create a temporary breakpoint in the first
    line of the `main()` method. We will see the following screenshot on the console
    after starting the GDB:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一张截图中所看到的，它已成功从`customer.exe`文件中读取了符号。然后，在GDB控制台中输入`start`来启动分析过程。调试器将在`main()`方法的第一行创建一个临时断点。启动GDB后，我们将在控制台上看到以下截图：
- en: '![](img/c1fb49c2-5b72-40fa-9555-4cb2a43d7635.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1fb49c2-5b72-40fa-9555-4cb2a43d7635.png)'
- en: Now, the program is in the debugging process. We can continue the process to
    analyze what is going on with the program. In the next section, we can choose
    between continuing step by step or running the program until the next breakpoint
    is found.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，程序正在进行调试过程。我们可以继续分析程序的运行情况。在下一节中，我们可以选择逐步进行或者运行程序直到找到下一个断点。
- en: To start the debugging process, we can either call the `run` or `start` command.
    The former will start our program under GDB, while the latter will behave similarly
    but will execute the code line by line. The difference is, if we don't have the
    breakpoint yet, the program will run as usual, just like it does when we call
    the `run` command, while the debugger will automatically set the breakpoint in
    the main block of code and the program will stop when it reaches that breakpoint,
    if we start with the `start` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试过程，我们可以调用`run`或`start`命令。前者将在GDB下启动我们的程序，而后者将类似地行为，但将逐行执行代码。区别在于，如果我们还没有设置断点，程序将像调用`run`命令时一样运行，而调试器将自动在主代码块中设置断点，如果我们使用`start`命令开始，程序将在达到该断点时停止。
- en: Continuing and stepping the debugging process
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续和步进调试过程
- en: 'There are three commands to continue the step in the preceding section. They
    are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中有三个继续步骤的命令。它们如下：
- en: '`continue`: This resumes the execution of the program until our program completes
    normally. If it finds a breakpoint, the execution will stop at the line where
    the breakpoint is set.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`: 这将恢复程序的执行，直到程序正常完成。如果找到断点，执行将停在设置断点的行。'
- en: '`step`: This executes just one more step of our program. The step might mean
    either one line of source code or one machine instruction. If it finds the invocation
    of a function, it will come into the function and run one more step inside the
    function.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`: 这只执行程序的下一步。步骤可能是源代码的一行，也可能是一条机器指令。如果找到函数的调用，它将进入函数并在函数内再运行一步。'
- en: '`next`: This continues to the next line in the current stack frame. In other
    words, if the next command finds the invocation of a function, it will not enter
    the function.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`: 这将继续执行当前堆栈帧中的下一行。换句话说，如果`next`命令找到函数的调用，它将不会进入函数。'
- en: 'Since we haven''t set the breakpoint yet, let''s type the `next` command so
    the debugging pointer goes to the next line of the code. We will run the `next`
    command multiple times until the end of the code is reached (or until we can see
    that the process is exited normally). We should see the following screenshot when
    we apply the `next` command multiple times:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有设置断点，让我们输入`next`命令，这样调试指针就会移到代码的下一行。我们将多次运行`next`命令，直到到达代码的末尾（或者直到我们看到进程正常退出）。当我们多次应用`next`命令时，应该看到以下截图：
- en: '![](img/99f37d0c-0b09-4a03-8fe5-dca276cb92e6.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99f37d0c-0b09-4a03-8fe5-dca276cb92e6.png)'
- en: As we can see in the preceding screenshot, we can analyze our program by running
    it step by step. Next, we will set the breakpoint if we have a suspect object
    to be analyzed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，我们可以逐步运行程序来分析我们的程序。接下来，如果我们有怀疑的对象需要分析，我们将设置断点。
- en: We just need to press the `Enter` key to run the previous command in GDB. Pressing
    the *Q* key will make the debugging console exit to the window console.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要按下`Enter`键来运行GDB中的上一个命令。按下*Q*键将使调试控制台退出到窗口控制台。
- en: Setting and deleting the breakpoint
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和删除断点
- en: 'Let''s exit from the debugging console by typing the *Q* key. We need to restart
    the debugging, so we need to type `gdb customer` again on the window console.
    After that, instead of typing the `start` command, let''s set the breakpoint before
    we continue the process. Let''s type `break 68` and `break Customer.cpp:15` respectively
    in the GDB console. The output is shown as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输入*Q*键退出调试控制台。我们需要重新启动调试，因此我们需要在窗口控制台上再次输入`gdb customer`。之后，我们不需要输入`start`命令，而是在继续进程之前设置断点。在GDB控制台中分别输入`break
    68`和`break Customer.cpp:15`。输出如下所示：
- en: '![](img/e49ce2b0-4515-4fe4-bb5a-9b6ad9bd43dc.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e49ce2b0-4515-4fe4-bb5a-9b6ad9bd43dc.png)'
- en: 'Now, we have two breakpoint in separate files--`Main.cpp` and `Customer.cpp`.
    We can now start the debugger by typing `run` in GDB console, as we can see in
    the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在不同文件中有两个断点--`Main.cpp`和`Customer.cpp`。我们现在可以在GDB控制台中输入`run`来启动调试器，如下截图所示：
- en: '![](img/a98825ab-5bc8-4cdb-8ee1-23f8afd0f400.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a98825ab-5bc8-4cdb-8ee1-23f8afd0f400.png)'
- en: Since the debugger hit the `GetActiveCustomerNames()` method first, it stops
    in the line where we put the breakpoint in that method, which is line `15` in
    the `Customer.cpp` file. Just type the `continue` command and press *Enter* multiple
    times until it hits the breakpoint in the `Main.cpp` file, line `69`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调试器首先命中了`GetActiveCustomerNames()`方法，它停在我们在该方法中设置断点的行，即`Customer.cpp`文件中的第`15`行。只需输入`continue`命令，然后多次按*Enter*，直到它在`Main.cpp`文件的第`69`行命中断点。
- en: Printing the object value
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印对象值
- en: 'Let''s rerun the debugger by setting the breakpoint on line `68` in the `Main.cpp`
    file, then start the debugger until it hits the breakpoint. After the breakpoint
    is hit, type `print name` to see what the value of the name variable is. The following
    screenshot shows the steps of the process:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Main.cpp`文件的第`68`行设置断点，然后启动调试器，直到它命中断点。命中断点后，输入`print name`来查看`name`变量的值。以下截图显示了该过程的步骤：
- en: '![](img/7a03fa03-bbf0-4f84-bb7c-b253f53ac888.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a03fa03-bbf0-4f84-bb7c-b253f53ac888.png)'
- en: As we can see in the preceding screenshot, the value of the `name` variable
    is `Aiden`. We can continue the debugging by typing the `continue` command so
    the debugger hits the breakpoint again in the `for` loop, then typing `print name`
    to find out the next name value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，`name`变量的值是`Aiden`。我们可以通过输入`continue`命令来继续调试，这样调试器就会再次在`for`循环中触发断点，然后输入`print
    name`来找出下一个名称的值。
- en: 'There are so many commands in the GDB that, will be overloaded if they are
    written in this book. If you need to find more commands in the GDB, refer to the
    following link:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: GDB中有很多命令，如果在本书中写出来会很多。如果您需要在GDB中找到更多命令，请参考以下链接：
- en: '[https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)'
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the last chapter of this book, we developed the functional class successfully
    by refactoring it from the imperative class that we can use to create a more complex
    program with. We implemented what we learned in the previous chapters. We also
    discussed the debugging technique, which is a useful weapon when we face an unexpected
    result or get a crash in the middle of the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们成功地通过重构将功能类从命令式类中开发出来，我们可以使用它来创建一个更复杂的程序。我们实现了前几章学到的知识。我们还讨论了调试技术，这是一种在面对意外结果或程序中间崩溃时非常有用的武器。
