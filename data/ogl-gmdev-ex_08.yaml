- en: Chapter 8. Expanding Your Horizons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。拓展视野
- en: 'Until this point, we have limited our coding to two dimensions. Now, it is
    time to expand to the third dimension. In many ways, this will not be as intimidating
    as it sounds. After all, instead of specifying a position using two coordinates
    (*x* and *y*), we will now simply add a third coordinate (*z*). However, there
    are some areas where the third dimension will add considerable complexity, and
    it is my job to help you master that complexity. In this chapter, we will start
    with the basic understanding of placing an object in a 3D world, including:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的编码仅限于二维。现在，是时候扩展到三维了。在许多方面，这并不会像听起来那么令人畏惧。毕竟，我们不再使用两个坐标（*x* 和 *y*）来指定位置，而是现在简单地添加一个第三个坐标（*z*）。然而，有一些领域，第三维会增加相当大的复杂性，我的工作就是帮助你掌握这种复杂性。在本章中，我们将从在三维世界中放置对象的基本理解开始，包括：
- en: '**3D coordinate systems**: You already mastered the Cartesian coordinate system
    (*x* and *y* coordinates). We will discuss how to expand this into a third axis.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维坐标系**：你已经掌握了笛卡尔坐标系（*x* 和 *y* 坐标）。我们将讨论如何将其扩展到第三个轴。'
- en: '**3D cameras**: The camera in a 2D game is pretty much fixed while the objects
    move past it. In 3D game programming, we often move the camera forward, backward,
    side-to-side, or even in circles around the objects in the game.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维摄像机**：在二维游戏中，摄像机基本上是固定的，而物体则在其周围移动。在三维游戏编程中，我们经常将摄像机向前、向后、向侧面移动，甚至围绕游戏中的物体旋转。'
- en: '**3D views**: How exactly does a 2D computer screen represent 3D games? You
    will learn the basics of how 3D gets transformed by the graphics pipeline.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维视图**：2D计算机屏幕是如何精确地表示3D游戏的？你将学习3D如何通过图形管道进行转换的基础知识。'
- en: '**3D transformations**: Moving around in 3D space is quite a bit more complicated
    than moving in 2D space. In fact, we use a whole new form of mathematics to do
    so. You will learn the basics of matrices, and how they can be used to move, rotate,
    and change the size of 3D objects.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维变换**：在三维空间中移动比在二维空间中移动要复杂得多。实际上，我们使用一种全新的数学形式来做到这一点。你将学习矩阵的基础知识，以及如何使用它们来移动、旋转和改变三维对象的大小。'
- en: Into the third dimension!
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入第三维度！
- en: You already live in a world with three dimensions. You can walk forward and
    backward, side to side, and jump up or duck. The reality of three dimensions becomes
    even more apparent if you are flying or even swimming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经生活在一个三维的世界里。你可以前后走动，左右移动，跳跃或蹲下。如果你在飞行或甚至游泳，三维的现实变得更加明显。
- en: Most 2D games operate by allowing the player to move left and right, or jump
    up or down. This is what we did when we created RoboRacer2D. In this type of 2D
    game, the missing dimension is depth. Our Robot could not move further away from
    us or closer to us. Considering that we were drawing him on a flat screen, it
    shouldn't be too surprising that he was limited to two dimensions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数二维游戏通过允许玩家左右移动，或上下跳跃来操作。这就是我们创建 RoboRacer2D 时所做的事情。在这种类型的二维游戏中，缺失的维度是深度。我们的机器人不能离我们更远或更近。考虑到我们是在一个平面上画他，他仅限于二维也就不足为奇了。
- en: Simulating 3D
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟三维
- en: 'Of course, artists found a way around this limitation hundreds of years ago
    by observing that as an object gets farther away from us, it gets smaller, and
    as it gets closer to us it gets larger. So, a simple way to represent 3D in a
    2D world is to simply draw the more distant objects as smaller objects. 2D games
    learned this trick early on and used it to simulate 3D:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，艺术家们早在几百年前就找到了一种绕过这种限制的方法，他们观察到，当一个物体离我们越来越远时，它会变得越小，而当我们靠近它时，它会变得越大。因此，在二维世界中表示三维的一个简单方法就是简单地画出更远的物体作为更小的物体。二维游戏很早就学会了这个技巧，并用来模拟三维：
- en: '![Simulating 3D](img/8199OS_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![模拟三维](img/8199OS_08_01.jpg)'
- en: In the preceding image, the larger tank appears to be closer than the smaller
    tank.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，较大的水箱看起来比较小的水箱更近。
- en: 'Another important aspect of depth is **perspective**. Artists learned that
    parallel lines appear to converge toward the center as they move farther away.
    The point where they seem to converge is known as the **vanishing point**:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 深度的一个重要方面是**透视**。艺术家们了解到，当平行线远离时，它们似乎会向中心汇聚。它们似乎汇聚的点被称为**消失点**：
- en: '![Simulating 3D](img/8199OS_08_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![模拟三维](img/8199OS_08_02.jpg)'
- en: In the preceding image, the walls and floor panels are all parallel, but they
    appear to converge inward toward the center of the image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，墙壁和地板面板都是平行的，但它们似乎向图像的中心汇聚。
- en: A third aspect of 3D motion is that objects that are farther away appear to
    travel more slowly than objects that are closer. Thus, when you are driving, the
    telephone poles pass you by much faster than the distant mountains. Some 2D games
    take advantage of this phenomenon, called **parallax**, by creating a background
    layer in the game that moves much slower than the foreground. In fact, this is
    exactly what we did in RoboRacer2D because the Robot in the foreground moves more
    quickly than the objects in the background.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 3D运动的第三个方面是，远离我们的物体看起来比靠近我们的物体移动得慢。因此，当你驾驶时，电线杆会比你远处的山移动得快得多。一些2D游戏利用这种现象，称为**视差**，通过在游戏中创建一个移动速度远慢于前景的背景层。实际上，这正是我们在RoboRacer2D中所做的，因为前景中的机器人移动速度比背景中的物体快。
- en: 2D games have used all of these features—size, perspective, and parallax—to
    simulate 3D long before we ever had hardware and graphics cards to do them for
    us. One of the first games to do this in a convincing way was Pole Position. The
    game that really blew everyone away was Doom, which was probably the first game
    that allowed the player to freely move in a 3D world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏在硬件和显卡为我们做这些之前就已经使用了所有这些特性——大小、透视和视差——来模拟3D。最早以令人信服的方式做到这一点的游戏之一是Pole Position。真正让人震惊的游戏是Doom，这可能是第一个允许玩家在3D世界中自由移动的游戏。
- en: Real 3D
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实3D
- en: Modern 3D games take the idea of simulating 3D to the next level. In the simulating
    3D section that we just discussed, it is the programmers' task to scale the image
    so that it appears smaller as it gets further away, take care of perspective,
    and handle parallax. This is now handled by the 3D graphics card.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代3D游戏将模拟3D的想法提升到了新的水平。在我们刚才讨论的模拟3D部分中，程序员的任务是调整图像的大小，使其看起来越远越小，处理透视，并处理视差。现在这些任务由3D显卡处理。
- en: '![Real 3D](img/8199OS_08_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![真实3D](img/8199OS_08_03.jpg)'
- en: The preceding image shows a 3D **model** of a tank. These models are created
    using special software, such as Maya or 3ds Max. This model is fundamentally different
    than the 2D tank image we showed you previously because it represents the tank
    in three dimensions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像展示了一个坦克的3D**模型**。这些模型是使用特殊软件创建的，例如Maya或3ds Max。这个模型与我们之前展示的2D坦克图像在本质上不同，因为它以三维的形式表示坦克。
- en: We will discuss 3D modeling in more detail in a future chapter. For now, the
    important concept is that the data for a 3D tank is sent to the graphics card,
    and the graphics card takes care of size, perspective, and parallax as the tank
    is positioned in a 3D space. This takes a lot of the load off the programmer!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中更详细地讨论3D建模。目前，重要的概念是3D坦克的数据被发送到显卡，而显卡负责在坦克位于3D空间中的尺寸、透视和视差。这大大减轻了程序员的负担！
- en: 3D Coordinate Systems
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D坐标系统
- en: Now that you have a fundamental idea of how the illusion of 3D is created on
    a 2D screen, let's learn how adding another dimension affects our coordinate system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对如何在2D屏幕上创建3D幻觉有了基本的了解，让我们学习增加另一个维度是如何影响我们的坐标系统的。
- en: In [Chapter 2](ch02.html "Chapter 2. Your Point of View"), *Your Point of View*
    I introduced you to the 2D coordinate system that is used by many game systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html "第二章。你的视角")中，我向你介绍了许多游戏系统使用的2D坐标系。
- en: '![3D Coordinate Systems](img/8199OS_08_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![3D坐标系统](img/8199OS_08_04.jpg)'
- en: 'The preceding diagram shows a car placed at coordinate position (**5, 5**).
    Let''s add the third dimension and see how it compares:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了一辆位于坐标位置（**5, 5**）的汽车。现在让我们加入第三个维度，看看它是如何比较的：
- en: '![3D Coordinate Systems](img/8199OS_08_05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![3D坐标系统](img/8199OS_08_05.jpg)'
- en: Notice that we added a third axis and labeled it as the Z-axis. Positive values
    on the Z-axis are closer to us, while negative values on the Z-axis are farther
    away. The car is now placed at coordinate (**5, 5, -5**) in 3D space. As the car
    is farther away, it also appears smaller than it did in the previous 2D image
    (you can think of 2D space as a space where all of the *z* coordinates are 0).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了第三个轴，并将其标记为Z轴。Z轴上的正值离我们更近，而Z轴上的负值离我们更远。现在汽车位于3D空间中的坐标（**5, 5, -5**）。随着汽车距离更远，它看起来也比之前2D图像中的小（你可以将2D空间视为所有*z*坐标都是0的空间）。
- en: The preceding diagram shows the Z-axis at an angle, but it is important to understand
    that the Z-axis is actually perpendicular to the plane of the computer screen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了Z轴以一个角度呈现，但重要的是要理解Z轴实际上是与计算机屏幕的平面垂直的。
- en: '![3D Coordinate Systems](img/8199OS_08_06.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![3D坐标系](img/8199OS_08_06.jpg)'
- en: Think of the Z-axis as a line the pierces through the center of the monitor
    from the front and travels out the back!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将Z轴想象成从屏幕前方穿过中心并延伸到后面的线！
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are actually many ways to represent the axes in a 3D world. One distinction
    between OpenGL and DirectX is the Z-axis. In OpenGL, positive *z* values are closer
    to the player. In DirectX, Microsoft's 3D rendering engine, negative z values
    are closer to the player. It's just a good thing to know because you will very
    likely work with both systems. OpenGL is known as a **right-hand** coordinate
    system, while DirectX is a **left-hand** coordinate system. It's a little hard
    to explain how they got these names, so perform an Internet search if you would
    like to learn more!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在3D世界中表示轴的方法有很多。OpenGL和DirectX之间的一个区别是Z轴。在OpenGL中，正的*z*值更靠近玩家。在DirectX（微软的3D渲染引擎）中，负的z值更靠近玩家。了解这一点是很好的，因为你很可能需要与这两个系统一起工作。OpenGL被称为**右手**坐标系，而DirectX是**左手**坐标系。解释它们如何得到这些名称有点困难，所以如果你想了解更多，请在互联网上搜索！
- en: The camera
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机
- en: In [Chapter 2](ch02.html "Chapter 2. Your Point of View"), *Your Point of View*
    we compared creating games to making a video recording. Your video camera captures
    a part of the view in front of you. If objects move into or out of that field
    of view, they are no longer in the video recording.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。你的视角")*你的视角*中，我们将创建游戏与制作视频录制进行了比较。你的摄像机捕捉了你面前的一部分视图。如果对象进入或离开该视野，它们将不再出现在视频录制中。
- en: '3D games use a camera as well. OpenGL allows you to move the game camera on
    six axes: up, down, left, right, in, and out. As you move the game camera, the
    objects that are in its view change.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 3D游戏也使用摄像机。OpenGL允许你在六个轴上移动游戏摄像机：上、下、左、右、进、出。当你移动游戏摄像机时，其视野中的对象会发生变化。
- en: Let's say that you center the camera on the car in the scene and pan to the
    left or right. The car will move in and out of the field of view. Of course the
    same occurs if you pan the camera up or down. Move back (or zoom out) and the
    car appears smaller. Move forward (or zoom in) and the car appears larger. Tilt
    the camera and the car will appear to be going uphill, downhill, or even appear
    upside down!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将摄像机对准场景中的汽车，并向左或向右平移。汽车将进入或离开视野。当然，如果你向上或向下平移摄像机，也会发生相同的情况。后退（或缩小）时，汽车看起来会更小。向前（或放大）时，汽车看起来会更大。倾斜摄像机，汽车看起来就像在上坡、下坡，甚至可能颠倒过来！
- en: Remember those home movies?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记得那些家庭电影吗？
- en: Remember those home movies where the whole scene would jump around as the camera
    moved? Obviously, the position and movement of the camera has a lot to do with
    the appearance of the car. The same is true in the game world.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那些随着摄像机移动整个场景会跳动的家庭电影吗？显然，摄像机的位置和运动与汽车的外观有很大关系。在游戏世界中也是如此。
- en: OpenGL uses the concept of a camera to determine exactly what shows up on the
    screen, and how it shows up. You have the ability to move the camera up or down,
    and left or right. You can rotate or tilt the camera. You have complete control!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL使用摄像机概念来确定屏幕上显示的内容以及如何显示。你可以上下移动摄像机，也可以左右移动。你可以旋转或倾斜摄像机。你拥有完全的控制权！
- en: Steady as she goes!
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持稳定！
- en: Although you have complete control over moving the camera, some games simply
    place the camera at a particular spot and then leave it fixed. This is similar
    to taking your home video camera and attaching it to a tripod.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你对移动摄像机有完全的控制权，但有些游戏只是将摄像机放置在特定的位置，然后将其固定。这类似于将你的家庭摄像机固定在三脚架上。
- en: Many 2D games use a fixed camera, and this is exactly what we did in RoboRacer2D.
    All of the motion in the game came from changing the position of the objects in
    the game, not from changing the position of the camera.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多2D游戏使用固定摄像机，这正是我们在RoboRacer2D中所做的。游戏中的所有运动都来自于改变游戏对象的位置，而不是改变摄像机的位置。
- en: In 3D games, it is very common to move both the camera and objects in the game.
    Imagine that we have a 3D scene with a moving car. If the camera remained fixed,
    the car would eventually move out of the scene. In order to keep the car in the
    scene, we need to move the camera so that it follows the car. Both the car and
    the camera need to move.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D游戏中，同时移动摄像机和游戏中的对象是非常常见的。想象一下，我们有一个带有移动汽车的3D场景。如果摄像机保持固定，汽车最终会移出场景。为了保持汽车在场景中，我们需要移动摄像机以跟随汽车。汽车和摄像机都需要移动。
- en: The viewport
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视口
- en: 'In game terminology, the area that can be seen by the camera at any time is
    called the **viewport**. The viewport defines the area of the game world that
    the camera can see:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏术语中，任何时刻相机可以看到的区域称为**视口**。视口定义了相机可以看到的游戏世界的区域：
- en: '![The viewport](img/8199OS_08_07.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![视口](img/8199OS_08_07.jpg)'
- en: The preceding illustration shows a viewport with a certain width and height.
    If the car moves outside of these boundaries, it will no longer be visible. In
    a 3D world, we must also define the depth of the image that we want to capture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上一幅图显示了具有特定宽度和高度的视口。如果汽车移动到这些边界之外，它将不再可见。在3D世界中，我们还必须定义我们想要捕捉的图像的深度。
- en: '![The viewport](img/8199OS_08_08.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![视口](img/8199OS_08_08.jpg)'
- en: 'The preceding image shows how the 3D viewport is defined:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上一幅图显示了如何定义3D视口：
- en: The front clipping plane defines how close things can get to the camera. Anything
    closer than the front clipping plane will not be rendered on the screen.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前裁剪平面定义了物体可以离相机多近。任何比前裁剪平面更近的物体都不会在屏幕上渲染。
- en: The rear clipping plane defines how far things can get from the camera. Anything
    beyond the rear clipping plane will not be rendered on the screen.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后裁剪平面定义了物体可以离相机多远。任何超出后裁剪平面的物体都不会在屏幕上渲染。
- en: The area between the front and back clipping planes is called the frustum. Objects
    inside the frustum will be rendered to the screen.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前后裁剪平面的区域称为锥体。锥体内的对象将被渲染到屏幕上。
- en: The field of view determines how tall and wide the angle of view is from the
    camera. A wide field of view will render more area, while a narrow field of view
    will render less area. A wider angle will also introduce more distortion to the
    image.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视场决定了从相机看去的视角的高度和宽度。宽视场将渲染更多区域，而窄视场将渲染较少区域。更宽的视角也会在图像中引入更多的扭曲。
- en: Entering the matrix
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入矩阵
- en: 'Now for the topic that strikes fear into the heart of all new game programmers:
    **matrices**. Matrices are a mathematical device (part of linear algebra) that
    makes it easier to work with large sets of related numbers.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是所有新游戏程序员心中恐惧的主题：**矩阵**。矩阵是一种数学工具（线性代数的一部分），它使得处理大量相关数字变得更加容易。
- en: 'In its simplest form, a **matrix** is a table of numbers. Let''s say that I
    wanted to represent a coordinate in space. I could write its value down as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，**矩阵**是一个数字表。比如说，我想表示空间中的一个坐标。我可以将其值写下如下：
- en: '![Entering the matrix](img/8199OS_08_entering_the_matrix.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![进入矩阵](img/8199OS_08_entering_the_matrix.jpg)'
- en: Vectors
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: A single row or single column of a matrix is called a **vector**. Vectors are
    important because they can be used to both position things and move things.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的单行或单列称为**向量**。向量很重要，因为它们可以用来定位和移动物体。
- en: 'The typical matrix used in games contains four values: *x*, *y*, *z*, and *w*.
    These *x*, *y*, and *z* components typically refer to a position in the 3D coordinate
    system, while the *w* is a switch:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中常用的矩阵包含四个值：*x*，*y*，*z*和*w*。这些*x*，*y*和*z*分量通常指的是3D坐标系中的位置，而*w*是一个开关：
- en: The value 1 means that this vector is a position
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值1表示这个向量是一个位置
- en: The value 0 means that this vector is a velocity
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值0表示这个向量是一个速度
- en: 'Here''s an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: The vector, (`1, 5, 10, 1`), represents a point at x = `1`, y = `5`, and z =
    `10` in a 3D coordinate system.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量（`1, 5, 10, 1`）代表在3D坐标系中x = `1`，y = `5`，z = `10`的点。
- en: The vector, (`1, 5, 10, 0`), is a point that moves 1 unit in the *x* direction,
    5 units in the *y* direction, and 10 units in the *z* direction
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量（`1, 5, 10, 0`）是一个在*x*方向上移动1个单位，在*y*方向上移动5个单位，在*z*方向上移动10个单位的点
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that vectors can be represented as a series of numbers inside of a parenthesis.
    This is much easier than having to draw a table every time you need to write down
    a vector!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向量可以用括号内的一系列数字来表示。这比每次写向量时都要画一个表格要容易得多！
- en: Combining vectors
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量组合
- en: 'The real power of vectors comes when they are combined. The most common way
    to combine vectors is to multiply them. Look at the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的真正力量在于它们组合在一起时。组合向量的最常见方式是乘法。看看以下例子：
- en: '![Combining vectors](img/8199OS_08_combining_vectors.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![组合向量](img/8199OS_08_combining_vectors.jpg)'
- en: The matrix on the left is known as a **translation matrix** because when you
    multiply it by a positional vector, the result will be a new position (moving
    things in a 3D space is known as **translation**). In this case, the point at
    (**2, 1, 0**) has been translated to a new position at (**3, 6, 6**).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的矩阵被称为**平移矩阵**，因为当你用它乘以一个位置向量时，结果将是一个新的位置（在3D空间中移动事物被称为**平移**）。在这种情况下，点(**2,
    1, 0**)已经平移到了新的位置(**3, 6, 6**)。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember: the last **1** in (**1, 5, 6, 1**) and (**2, 1, 0, 1**) is the *w*
    value that simply tells us we are working with a position. Notice that the *w*
    value remained **1** in the final result as well!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：在(**1, 5, 6, 1**)和(**2, 1, 0, 1**)中的最后一个**1**是*w*值，它简单地告诉我们我们正在处理一个位置。注意，*w*值在最终结果中也保持为**1**！
- en: 'If you are paying attention, you must be wondering how we got the third matrix!
    It turns out that multiplying two matrices is actually more complex that it seems.
    In order to multiply the two matrices shown earlier, the following operations
    had to occur:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在关注，你肯定在想我们是如何得到第三个矩阵的！实际上，乘以两个矩阵比看起来要复杂得多。为了乘以前面显示的两个矩阵，必须执行以下操作：
- en: (1 * 2) + (0 * 1) + (0 * 0) + (1 * 1) = 3
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (1 * 2) + (0 * 1) + (0 * 0) + (1 * 1) = 3
- en: (0 * 2) + (1 * 1) + (0 * 0) + (5 * 1) = 6
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0 * 2) + (1 * 1) + (0 * 0) + (5 * 1) = 6
- en: (0 * 2) + (0 * 1) + (1 * 0) + (6 * 1) = 6
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0 * 2) + (0 * 1) + (1 * 0) + (6 * 1) = 6
- en: (0 * 2) + (0 * 1) + (0 * 0) + (1 * 1) = 1
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0 * 2) + (0 * 1) + (0 * 0) + (1 * 1) = 1
- en: Each cell in each row of the first matrix is multiplied by each cell in each
    column of the second matrix.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个矩阵的每一行中的每个单元格都会与第二个矩阵的每一列中的每个单元格相乘。
- en: This might seem like a lot of trouble just to move a point, but when it comes
    to quickly moving 3D objects around in a game, matrix math is much faster than
    other techniques.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来只是为了移动一个点而费尽周折，但当涉及到在游戏中快速移动3D对象时，矩阵数学比其他技术要快得多。
- en: 'Don''t worry! This is about all we are going to say about matrices and vectors.
    You should know that OpenGL uses matrices to calculate **transformations**, including:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心！这就是我们要说的关于矩阵和向量的全部内容。你应该知道OpenGL使用矩阵来计算**变换**，包括：
- en: Moving
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: Scaling
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放
- en: Rotating
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you ever work with both OpenGL and DirectX, you will need to be aware that
    there is a difference in the way they handle matrices. OpenGL uses a **row major**
    order, while DirectX users a **column major order**. In a row major matrix, all
    of the cells in the first column are adjacent, followed by all of the cells in
    the next row, and so forth. In a column major matrix, all of the cells in the
    first column are adjacent, followed by all of the cells in the next column, and
    so forth. This makes a huge difference in how you manipulate and calculate the
    matrices!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经同时使用OpenGL和DirectX，你必须意识到它们在处理矩阵的方式上存在差异。OpenGL使用**行主序**，而DirectX使用**列主序**。在行主序矩阵中，第一列的所有单元格都是相邻的，然后是下一行的所有单元格，依此类推。在列主序矩阵中，第一列的所有单元格都是相邻的，然后是下一列的所有单元格，依此类推。这在你操作和计算矩阵时会产生巨大的差异！
- en: Identity matrix
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位矩阵
- en: 'I will mention one more special matrix:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提到另一个特殊的矩阵：
- en: '| 1 | 0 | 0 | 0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 | 0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 0 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 |'
- en: '| 0 | 0 | 0 | 1 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 1 |'
- en: The preceding matrix is known as an identity matrix. If you multiply any matrix
    by an identity matrix, the result is the original matrix (just like multiplying
    any number by 1 results in the original number). Whenever we want to initialize
    a matrix, we set it to an identity matrix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的矩阵被称为单位矩阵。如果你将任何矩阵乘以单位矩阵，结果将是原始矩阵（就像将任何数字乘以1的结果是原始数字一样）。每次我们想要初始化一个矩阵时，我们将其设置为单位矩阵。
- en: There are special matrices in OpenGL, and you will be introduced to some of
    them in the next code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL中有特殊的矩阵，你将在接下来的代码中了解到一些。
- en: Coding in 3D
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D中进行编码
- en: It's time for us to put our theory into practice and create our first 3D scene.
    To keep things simple, we will go through the steps of placing a cube in 3D space.
    This is also going to be the start of our 3D game, so let's start by creating
    a brand new project in Visual Studio.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的理论付诸实践，创建我们的第一个3D场景了。为了保持简单，我们将通过在3D空间中放置一个立方体的步骤进行。这也将是我们3D游戏的开始，所以让我们在Visual
    Studio中创建一个全新的项目。
- en: Creating the project
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: When we created a project for our 2D game, we started with a standard Windows
    project and then removed (or ignored) the items that we didn't need to use. In
    fact, the standard Windows project has a lot of overhead that we don't need. This
    is because the Windows project template assumes that Windows is going to be in
    charge of rendering and processing. This came in useful for our 2D project, but
    just adds a lot of extra code that we don't need.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们的2D游戏创建项目时，我们从一个标准的Windows项目开始，然后删除（或忽略）了我们不需要使用的项目。事实上，标准的Windows项目有很多不必要的开销。这是因为Windows项目模板假设Windows将负责渲染和处理。这对我们的2D项目很有用，但只是添加了我们不需要的大量额外代码。
- en: 'For this project, we will start with a blank Windows project and then add the
    necessary code to initialize and create an OpenGL window. Then, we will work our
    way up from there:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将从一个空的Windows项目开始，然后添加必要的代码来初始化和创建一个OpenGL窗口。然后，我们将从这里开始逐步进行：
- en: Begin by opening Visual Studio.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开Visual Studio。
- en: Once Visual Studio is open, create a new project by clicking on **File**, **New**,
    **Project**. From the **Visual C++** branch choose **Empty Project**.![Creating
    the project](img/8199OS_08_09.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Visual Studio打开后，通过点击**文件**，**新建**，**项目**来创建一个新的项目。从**Visual C++**分支选择**空项目**。![创建项目](img/8199OS_08_09.jpg)
- en: '**Name** the project `SpaceRacer3D`, place it in the location of your choice,
    and click **OK**. The result is a project that has no code. Let''s solve that
    problem by creating our main game file.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**命名**项目为`SpaceRacer3D`，将其放置在你选择的地点，然后点击**确定**。结果是没有任何代码的项目。让我们通过创建我们的主游戏文件来解决这个问题。'
- en: Right-click on the **Source Files** folder in the **Solution Explorer** panel.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**面板的**源文件**文件夹上右键单击。
- en: Choose **Add**, **New Item…**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加**，**新建项…**。
- en: Click on **C++ File (.cpp)**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**C++文件(.cpp)**。
- en: Type `SpaceRacer3D.cpp` for **Name** and click **Add**.![Creating the project](img/8199OS_08_10.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`SpaceRacer3D.cpp`作为**名称**并点击**添加**。![创建项目](img/8199OS_08_10.jpg)
- en: Retrieving OpenGL files
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取OpenGL文件
- en: The standard OpenGL library is already installed when you install Visual Studio.
    However, the OpenGL utilities library may not be. To make things simple, we will
    simply copy the files that we need from our RoboRacer2D project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Visual Studio时，标准的OpenGL库已经安装好了。然而，OpenGL实用工具库可能没有安装。为了简化事情，我们将简单地从我们的RoboRacer2D项目中复制所需的文件。
- en: 'Open the **RoboRacer2D** project folder and select the following files:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**RoboRacer2D**项目文件夹，并选择以下文件：
- en: '`glut.h`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut.h`'
- en: '`glut32.dll`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut32.dll`'
- en: '`glut32.lib`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glut32.lib`'
- en: Now copy these files into the **SpaceRacer3D** source folder. This will be the
    same folder that your `SpaceRacer3D.cpp` file is located.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这些文件复制到**SpaceRacer3D**源文件夹中。这将与你的`SpaceRacer3D.cpp`文件所在的文件夹相同。
- en: Linking projects to OpenGL libraries
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将项目链接到OpenGL库
- en: Now that we have a project and the relevant OpenGL files, we need to link to
    the OpenGL libraries. This is done by accessing the project properties.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了项目和相关的OpenGL文件，我们需要链接到OpenGL库。这是通过访问项目属性来完成的。
- en: 'In the **Solution Explorer** panel perform the following actions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**面板中执行以下操作：
- en: Right-click on the project name (not the solution), and choose **Properties**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目名称（不是解决方案），然后选择**属性**。
- en: Open the **Linker** branch under **Configuration Properties**, and select **Input**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置属性**下的**链接器**分支中打开，并选择**输入**。
- en: Click on **Additional Dependencies** and then click the drop-down arrow that
    appears.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**附加依赖项**，然后点击出现的下拉箭头。
- en: Click on **<Edit…>**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**<编辑…**>。
- en: Add `OpenGL32.lib` and `GLu32.lib` in the **Additional Dependencies** dialog
    window.![Linking projects to OpenGL libraries](img/8199OS_08_11.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加依赖项**对话框窗口中添加`OpenGL32.lib`和`GLu32.lib`。![将项目链接到OpenGL库](img/8199OS_08_11.jpg)
- en: Setting up the OpenGL window
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置OpenGL窗口
- en: 'We are now going to add the code required to create an OpenGL window. We did
    this once for RoboRacer2D, but now, we are creating a 3D game and there will be
    some differences. Here''s a look at what we need to do:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加创建OpenGL窗口所需的代码。我们之前为RoboRacer2D做过一次，但现在，我们正在创建一个3D游戏，会有一些不同。以下是我们需要做的：
- en: Include header files.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含头文件。
- en: Define global variables.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局变量。
- en: Create the OpenGL window.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建OpenGL窗口。
- en: Initialize the OpenGL window.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化OpenGL窗口。
- en: Size the OpenGL window.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整OpenGL窗口的大小。
- en: Remove the OpenGL window.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除OpenGL窗口。
- en: Create the Windows event handler.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Windows事件处理程序。
- en: Create the `WinMain` function.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`WinMain`函数。
- en: Notice that we still have to create some code to satisfy Windows. We need an
    event handler to process Windows events, and we still need a main function to
    serve as the program entry point and run the main program loop. Everything else
    in this list is used to set up the OpenGL environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然需要编写一些代码来满足Windows的要求。我们需要一个事件处理程序来处理Windows事件，我们仍然需要一个主函数作为程序的入口点并运行主程序循环。列表中的其他一切都是用来设置OpenGL环境的。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I listed the functions tasks that we need in an order that makes logical sense.
    When we actually implement the code, we will create things in a slightly different
    order. This is because some functions require another function to already be defined.
    For example, the function to create the OpenGL window calls the function to initialize
    the OpenGL window, so the initialize function is coded first.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我按照逻辑顺序列出了我们需要的功能任务。当我们实际编写代码时，我们将以稍微不同的顺序创建事物。这是因为某些函数需要另一个函数已经定义。例如，创建OpenGL窗口的函数会调用初始化OpenGL窗口的函数，因此初始化函数是首先编写的。
- en: Including header files
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含头文件
- en: 'The first step is to in include the appropriate headers. Add the following
    headers at the top of `SpaceRacer3D.cpp`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是包含适当的头文件。在`SpaceRacer3D.cpp`的顶部添加以下头文件：
- en: '[PRE0]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are the same files that we used in the 2D project, but here is a quick
    description of each one so that you don''t have to flip back:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件与我们在2D项目中使用的相同，但这里有一个快速描述，以便你不必翻回：
- en: We are still running in Windows, so we must include `windows.h`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍在Windows上运行，因此必须包含`windows.h`
- en: The core header for OpenGL is `GL.h`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL的核心头文件是`GL.h`
- en: There are some great utilities to make our lives easier in `GLU.h`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GLU.h`中有一些非常棒的实用工具可以简化我们的工作
- en: There are also useful utilities in `glut.h`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`glut.h`中也有一些有用的工具
- en: Defining global variables
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义全局变量
- en: 'We need some global variables to hold onto references to Windows and OpenGL
    objects. Add the following lines of code just under the header lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些全局变量来保存对Windows和OpenGL对象的引用。在标题行下方添加以下代码行：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a quick list of what these variables are for:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速列表，说明这些变量用于什么：
- en: '`hInstance`: This holds a reference to this instance of the application'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hInstance`：这保存了对应用程序此实例的引用'
- en: '`hDC`: This holds a reference to the GDI device context which is used for drawing
    in native Windows'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hDC`：这保存了对用于在原生Windows中绘图的GDI设备上下文的引用'
- en: '`hRC`: This holds a reference to the OpenGL rendering context, used for rendering
    3D'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hRC`：这保存了对OpenGL渲染上下文的引用，用于渲染3D'
- en: '`hWnd`: This holds a reference to the actual window the application is running
    in'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hWnd`：这保存了应用程序实际运行的窗口的引用'
- en: We have also included a global `fullscreen` variable. If you set this to `true`,
    the game will run in `fullscreen` mode. If you set this to `false`, the game will
    run in windowed mode.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了一个全局的`fullscreen`变量。如果你将其设置为`true`，游戏将以全屏模式运行。如果你将其设置为`false`，游戏将以窗口模式运行。
- en: Creating a function to create the OpenGL window
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建创建OpenGL窗口的函数
- en: 'We will also include a forward reference to the Windows event handler. Add
    the following line of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将包含对Windows事件处理程序的前向引用。添加以下代码行：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A forward reference allows us to define a function whose actual implementation
    will appear later in the code. The code for `WndProc` will be added later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前向引用允许我们定义一个实际实现将在代码后面出现的函数。`WndProc`的代码将在稍后添加。
- en: Sizing the OpenGL window
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整OpenGL窗口大小
- en: 'Next, we will create the function to size the OpenGL window. This function
    is called when the program starts as well as any time the window that the application
    is running in is resized. Add the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个调整OpenGL窗口大小的函数。当程序启动以及应用程序运行的窗口大小调整时都会调用此函数。添加以下代码：
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code sets the size of the OpenGL window and prepares the window for rendering
    in 3D:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了OpenGL窗口的大小，并准备在3D中渲染窗口：
- en: First, we take the width and height (ensuring that the height is never equal
    to 0), and use them to define the size viewport using the `glViewport` function.
    The first two parameters are the *x* and *y* value of the lower left-hand corner
    of the viewport, followed by the width and the height. These four parameters define
    the size and location of the viewport.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们获取宽度和高度（确保高度永远不会等于0），并使用它们通过`glViewport`函数定义视口的大小。前两个参数是视口左下角*x*和*y*的值，然后是宽度和高度。这四个参数定义了视口的大小和位置。
- en: 'Next, we have to define the frustum. After telling OpenGL to use the projection
    matrix, we use the `gluPerspective` function, which takes four parameters: the
    field of view (in degrees, not radians), the aspect ratio, the distance of the
    front clipping plane, and the distance of the rear clipping plane. The field of
    view is the angle from the center of the camera. The aspect ratio is the width
    divided by the height. These four parameters define the size of the frustum.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义视锥体。在告诉OpenGL使用投影矩阵之后，我们使用`gluPerspective`函数，它接受四个参数：视野（以度为单位，不是弧度），纵横比，前裁剪平面的距离和后裁剪平面的距离。视野是从相机中心的角度。纵横比是宽度除以高度。这四个参数定义了视锥体的大小。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After you complete this chapter, you may try playing with the values of this
    function to see how it changes the rendering.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此章节后，你可以尝试调整此函数的值，看看它如何改变渲染效果。
- en: Finally, we tell OpenGL to use the model view from this point forward.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们告诉OpenGL从此点开始使用模型视图。
- en: 'If you compare this function to the `GLSize` function that we used in RoboRacer2D,
    you will note one significant difference: we do not make a call to `glOrtho`.
    Remember, RoboRacer2D was a 2D game. 2D games use an **orthographic projection**
    that removes perspective when the scene is rendered. You don''t need perspective
    in a 2D game. Most 3D games use a **perspective projection**, which is defined
    by the `gluPerspective` call.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此函数与我们用于RoboRacer2D的`GLSize`函数进行比较，你会注意到一个显著的区别：我们没有调用`glOrtho`。记住，RoboRacer2D是一个2D游戏。2D游戏在渲染场景时使用**正交投影**，这会移除透视。在2D游戏中不需要透视。大多数3D游戏使用**透视投影**，它由`gluPerspective`调用定义。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**OpenGL Matrices**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL矩阵**'
- en: 'Just before the `gluPerspective` call, you will notice two functions: `glMatrixMode`,
    and `glLoadIdentity`. Remember from our discussion of matrices that a matrix is
    used to hold a set of values. OpenGL has many standard matrices, and one of them
    is the projection matrix, which is used to define the view frustum.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gluPerspective`调用之前，你会注意到两个函数：`glMatrixMode`和`glLoadIdentity`。记得我们讨论矩阵时提到，矩阵用于存储一组值。OpenGL有许多标准矩阵，其中之一是投影矩阵，它用于定义视图视锥体。
- en: If we want to set the values of a matrix, we must first tell OpenGL that we
    want to work with this matrix. Next, we typically initialize the matrix, and finally,
    we make a call that sets the values of the matrix.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要设置矩阵的值，我们必须首先告诉OpenGL我们想要使用这个矩阵。接下来，我们通常初始化矩阵，最后，我们进行一个设置矩阵值的调用。
- en: 'Looking at the code to set the view frustum, this is exactly what we do:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看看设置视图视锥体的代码，这正是我们做的：
- en: '`glMatrixMode(GL_PROJECTION)`: This tells OpenGL that we want to work with
    the projection matrix. Any matrix operations after this call will be applied to
    the projection matrix.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glMatrixMode(GL_PROJECTION)`：这告诉OpenGL我们想要使用投影矩阵。在此调用之后的任何矩阵操作都将应用于投影矩阵。'
- en: '`glLoadIdentity()`: This sets the projection matrix to an identity matrix,
    thus, clearing any previous values.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glLoadIdentity()`：这设置投影矩阵为单位矩阵，因此清除任何之前的值。'
- en: '`gluPerspective(45.0f, (GLfloat)w / (GLfloat)h, 0.1f, 100.0f)`: This sets the
    values of the projection matrix.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gluPerspective(45.0f, (GLfloat)w / (GLfloat)h, 0.1f, 100.0f)`：这设置投影矩阵的值。'
- en: 'You should get used to this pattern because it is used often in OpenGL: set
    a matrix to work with, initialize the matrix, then set the values of the matrix.
    For example, at the end of this function we tell OpenGL to use the model view
    matrix and initialize it. Any operations after this will affect the model view.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该习惯这种模式，因为它在OpenGL中经常被使用：设置一个矩阵来工作，初始化矩阵，然后设置矩阵的值。例如，在此函数的末尾，我们告诉OpenGL使用模型视图矩阵并初始化它。之后的任何操作都将影响模型视图。
- en: Initializing the OpenGL window
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化OpenGL窗口
- en: 'Add the following code to initialize OpenGL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码以初始化OpenGL：
- en: '[PRE4]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function initializes OpenGL by defining important settings that determine
    how a scene will be rendered:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过定义确定场景如何渲染的重要设置来初始化OpenGL：
- en: '`glShadeModel`: This tells OpenGL that we want it to smooth the edges of the
    vertices. This greatly improves the look of our images.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glShadeModel`：这告诉OpenGL我们想要它平滑顶点的边缘。这大大提高了我们图像的外观。'
- en: '`glClearColor`: This sets the color that is used each time `glClear` is called
    to clear out the rendering buffer. It is also the default color that will show
    in the scene.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glClearColor`：此设置每次调用`glClear`清除渲染缓冲区时使用的颜色。它也是场景中显示的默认颜色。'
- en: '`glClearDepth(1.0f)`: This tells OpenGL that we want the entire depth buffer
    cleared each time `glClear` is called. Remember, we are working in 3D now, and
    the depth buffer is roughly synonymous with the Z-axis.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glClearDepth(1.0f)`: 这告诉 OpenGL，每次调用 `glClear` 时，我们希望清除整个深度缓冲区。记住，我们现在正在 3D
    环境中工作，深度缓冲区大致等同于 Z 轴。'
- en: '`glEnable(GL_DEPTH_TEST)`: This turns on depth checking. Depth checking is
    used to determine if a particular piece of data will be rendered.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glEnable(GL_DEPTH_TEST)`: 这打开深度检查。深度检查用于确定特定数据是否将被渲染。'
- en: '`glDepthFunc(GL_LEQUAL)`: This tells OpenGL how you want to perform the depth
    test. `LEQUAL` tells OpenGL to write the data only if the z value of the incoming
    data is less than or equal to the z value of the existing data.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glDepthFunc(GL_LEQUAL)`: 这告诉 OpenGL 你希望如何执行深度测试。`LEQUAL` 告诉 OpenGL 只有当传入数据的
    z 值小于或等于现有数据的 z 值时才写入数据。'
- en: '`glHint((GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST))`: This is an interesting
    function. `glHint` means that this function is going to suggest that OpenGL use
    the settings passed as parameters. However, as there are many different types
    of devices, there is no guarantee that these settings will actually be enforced.
    The `GL_PERSPECTIVE` hint tells OpenGL to use the highest quality when rendering
    perspective, while `GL_NICEST` means focus on rendering quality rather than speed.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glHint((GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST))`: 这是一个有趣的函数。`glHint` 表示此函数将建议
    OpenGL 使用作为参数传递的设置。然而，由于存在许多不同类型的设备，无法保证这些设置实际上会被强制执行。`GL_PERSPECTIVE` 提示告诉 OpenGL
    在渲染透视时使用最高质量，而 `GL_NICEST` 表示在渲染质量与速度之间更注重质量。'
- en: Creating a function to remove the OpenGL window
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于删除 OpenGL 窗口的函数
- en: 'Eventually, we will want to shut things down. Good programming dictates that
    we release the resources that were being used by the OpenGL window. Add the following
    function to our code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们可能需要关闭这些操作。良好的编程实践要求我们释放 OpenGL 窗口所使用的资源。将以下函数添加到我们的代码中：
- en: '[PRE5]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we tell Windows to exit fullscreen mode (if we were running fullscreen)
    and turn the cursor back on. Then, we check each object that had a resource attached,
    release that object, then set it to null. The objects that need to be released
    are:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉 Windows 退出全屏模式（如果我们在全屏运行），并将光标恢复。然后，我们检查每个附加了资源的对象，释放该对象，然后将其设置为 null。需要释放的对象包括：
- en: '`hRC`: This is the OpenGL rendering context'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hRC`: 这是指 OpenGL 渲染上下文'
- en: '`hDC`: This is the Windows device context'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hDC`: 这是指 Windows 设备上下文'
- en: '`hWnd`: This is the handle to the Window'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hWnd`: 这是指向窗口的句柄'
- en: '`hInstance`: This is the handle to the application'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hInstance`: 这是指向应用程序的句柄'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may notice the two functions that start with `wgl` (`wglMakeCurrent` and
    `wglDeleteContext)`. This stands for Windows GL and these are special OpenGL functions
    that only work in Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到以 `wgl` 开头的两个函数（`wglMakeCurrent` 和 `wglDeleteContext`）。这代表 Windows GL，这些是仅在
    Windows 中工作的特殊 OpenGL 函数。
- en: Creating the OpenGL window
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 OpenGL 窗口
- en: 'Now that we have the other OpenGL support functions defined, we can add the
    function to actually create the OpenGL window. Add the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了其他 OpenGL 支持函数，我们可以添加用于实际创建 OpenGL 窗口的函数。添加以下代码：
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The purpose of `CreateGLWindow` is to create a window with settings that allow
    it to work with OpenGL. The main tasks accomplished by this function are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGLWindow` 的目的是创建一个可以与 OpenGL 一起工作的窗口。此函数完成的主要任务如下：'
- en: Set the window properties
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置窗口属性
- en: Register the application with Windows—`RegisterClass`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序注册到 Windows 中—`RegisterClass`
- en: Set up full screen mode if required—`ChangeDisplaySettings`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，设置全屏模式—`ChangeDisplaySettings`
- en: Create the Window—`CreateWindowEx`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建窗口—`CreateWindowEx`
- en: Get a Windows device context—`GetDC`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Windows 设备上下文—`GetDC`
- en: Set the OpenGL pixel format—`SetPixelFormat`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 OpenGL 像素格式—`SetPixelFormat`
- en: Create an OpenGL rendering context—`wglCreateContext`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 OpenGL 渲染上下文—`wglCreateContext`
- en: Bind the Windows device context and OpenGL rendering context together—`wglMakeCurrent`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Windows 设备上下文和 OpenGL 渲染上下文绑定在一起—`wglMakeCurrent`
- en: Show the window—`ShowWindow`, `SetForegroundWindow(hWnd)`, and `SetFocus(hWnd)`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示窗口—`ShowWindow`, `SetForegroundWindow(hWnd)`, 和 `SetFocus(hWnd)`
- en: Initialize the OpenGL Window—`ReSizeGLScene`, `InitGL`; create the `WinMain`
    function
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 OpenGL 窗口—`ReSizeGLScene`, `InitGL`; 创建 `WinMain` 函数
- en: 'The `WinMain` function is the entry point for the application. Add the following
    code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinMain` 函数是应用程序的入口点。添加以下代码：'
- en: '[PRE7]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It calls all of the other functions to initialize Windows, and OpenGL then starts
    the main message loop, which we hijack and adapt to be our game loop. As we explained
    all of this code in [Chapter 1](ch01.html "Chapter 1. Building the Foundation"),
    *Building the Foundation* we won't do it again here.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用所有其他函数来初始化Windows，然后OpenGL启动主消息循环，我们劫持并适配它成为我们的游戏循环。正如我们在[第1章](ch01.html
    "第1章. 建立基础")中解释的所有这些代码，*建立基础*，我们在这里不再重复。
- en: Creating the Windows event handler
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Windows事件处理器
- en: 'Finally, we have to have an event handler to receive events from Windows and
    process them. We created the forward declaration at the top of the code, and now
    we will actually implement the handler. Add the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须有一个事件处理器来接收来自Windows的事件并处理它们。我们在代码顶部创建了前向声明，现在我们将实际实现处理器。添加以下代码：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function will be called any time Windows sends an event to our program.
    We handle two events: `WM_DESTROY` and `WM_SIZE`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将在Windows向我们的程序发送事件时被调用。我们处理两个事件：`WM_DESTROY`和`WM_SIZE`：
- en: '`WM_DESTROY` is triggered when the window is closed. When this happens we use
    `PostQuitMessage` to tell our main game loop that it is time to stop.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WM_DESTROY`在窗口关闭时触发。当发生这种情况时，我们使用`PostQuitMessage`告诉主游戏循环是时候停止了。'
- en: '`WM_SIZE` is triggered when the window is resized. When this happens, we call
    `ReSizeGLScene`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WM_SIZE`在窗口大小改变时触发。当发生这种情况时，我们调用`ReSizeGLScene`。'
- en: The Game loop
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: 'We still need to add some stub functions for our game functions: `StartGame`,
    `Update`, `Render`, `EndGame`, and `GameLoop`. Add the following code before the
    `WinMain` function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要为我们的游戏函数添加一些存根函数：`StartGame`、`Update`、`Render`、`EndGame`和`GameLoop`。在`WinMain`函数之前添加以下代码：
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These functions serve the same purpose that they did in RoboRacer2D. `GameLoop`
    is called from the Windows main loop, and in turn calls `Update` and `Render`.
    `StartGame` is called before the Windows main loop, and `EndGame` is called when
    the game ends.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与RoboRacer2D中相同。`GameLoop`从Windows主循环中被调用，然后调用`Update`和`Render`。`StartGame`在Windows主循环之前被调用，`EndGame`在游戏结束时被调用。
- en: The finale
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结尾
- en: 'If you run the game right now, you will see a nice black window. This is because
    we haven''t told the program to draw anything yet! It seemed unfair to do all
    this work and get a black screen, so if you want to do a little extra work, add
    the following code just before the `StartGame` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会看到一个漂亮的黑色窗口。这是因为我们还没有告诉程序去绘制任何东西！做所有这些工作却得到一个黑色屏幕似乎不太公平，所以如果你想做一些额外的工作，请在`StartGame`函数之前添加以下代码：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, you need to make sure to declare the following global variable:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要确保声明以下全局变量：
- en: '[PRE11]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now run the program, and you should see a colorful rotating cube. Don't worry
    about how this works yet—we will learn that in the next chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序，你应该会看到一个五彩斑斓的旋转立方体。不用担心它是如何工作的——我们将在下一章中学习。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered a lot of new material related to creating a 3D game.
    You learned how the game camera worked just like a video camera. Anything in the
    camera's frustum will be rendered to the screen. You also learned about the 3D
    coordinate system that is used to place objects in a 3D world. Finally, you learned
    about matrices and vectors, which form the underpinning of how 3D objects are
    manipulated.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了创建3D游戏相关的大量新内容。你学习了游戏摄像头是如何像视频摄像头一样工作的。摄像头视锥体内的任何东西都将被渲染到屏幕上。你还学习了用于在3D世界中放置对象的3D坐标系。最后，你学习了矩阵和向量，它们是3D对象操作的基础。
- en: Finally, we started with a blank project and walked through all of the code
    required to set up a 3D game that will use OpenGL to render. Remember, you will
    never have to memorize this code! But, it is important that you have a basic understanding
    of what purpose each line of code serves.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从一个空白项目开始，走过了设置使用OpenGL渲染的3D游戏所需的所有代码。记住，你永远不需要记住这段代码！但是，了解每一行代码的作用是很重要的。
- en: In the next chapter, you will learn to create and load 3D models from modeling
    program.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何从建模程序创建和加载3D模型。
