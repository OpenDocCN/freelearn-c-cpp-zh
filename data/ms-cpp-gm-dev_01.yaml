- en: C++ for Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++游戏开发
- en: 'Ever since I was young, I was told, whether it was the pursuit of perfection
    in a sport, learning a musical instrument, or even a new technical skill, strong
    understanding of the fundamentals and practice is what makes the difference. Game
    development with C++ is no different. Before you can master the process, you have
    to perfect the fundamentals. That is what the first chapter of this book is all
    about, covering the foundational concepts that will be used throughout the book.
    The chapter is broken down into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从我小时候起，我就被告知，无论是追求体育运动的完美，学习乐器，甚至是新的技术技能，对基本原理的深刻理解和实践是决定成败的关键。用C++进行游戏开发也是如此。在你掌握这个过程之前，你必须完善基础知识。这就是本书第一章的内容，涵盖了将在整本书中使用的基础概念。本章分为以下几个部分：
- en: An overview of advanced C++ concepts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级C++概念概述
- en: Working with types and containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型和容器
- en: Game programming patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏编程模式
- en: The conventions used in the book
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书中使用的约定
- en: Throughout the book, you will encounter code snippets and examples. To keep
    the code readable and uniform, I will follow a few basic coding conventions. While
    the topic of coding standards is a complicated and lengthy discussion, I do think
    it is important to lay out some guidelines for any advanced project. Having an
    accessible guide to what is the expected notation and the naming conventions,
    at the very least, should be considered necessary before any work can begin. If
    you are interested in knowing more about common code standards used in C++, a
    great place to start is the coding standards frequently asked question section
    on the ISO C++ site at [https://isocpp.org/wiki/faq/coding-standards](https://isocpp.org/wiki/faq/coding-standards).
    There, you will find a wealth of commonly used standards for various situations
    and a pile of suggested reading links to expand your knowledge even further.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将遇到代码片段和示例。为了保持代码的可读性和统一性，我将遵循一些基本的编码约定。虽然编码标准的话题是一个复杂而冗长的讨论，但我认为为任何高级项目制定一些指导方针是很重要的。至少应该考虑在任何工作开始之前，制定一个可访问的指南，说明预期的符号和命名约定。如果你想了解更多关于C++中常用的编码标准，一个很好的起点是ISO
    C++网站上关于编码标准常见问题解答部分的链接[https://isocpp.org/wiki/faq/coding-standards](https://isocpp.org/wiki/faq/coding-standards)。在那里，你将找到各种情况下常用的标准以及一堆建议阅读的链接，以进一步扩展你的知识。
- en: The standards and conventions used in this book are based on some of the core
    C++ guidelines, industry best practices, and my own personal experience. We will
    be using the latest ISO C++ standard, C++14 throughout the book. However, at times,
    we may make use of some of the functionality in the latest proposed revision,
    C++17, also known as C++1y. When this occurs, a note will be made explaining why.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的标准和约定基于一些核心C++指南、行业最佳实践和我的个人经验。我们将在整本书中使用最新的ISO C++标准，即C++14。然而，有时我们可能会使用最新提议的修订版C++17的一些功能，也被称为C++1y。当发生这种情况时，将会做出说明。
- en: 'Classes and function names will follow the *MixedCase* style, while variables
    will follow a *camelCase* style. Some examples would look like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类和函数名称将遵循*MixedCase*风格，而变量将遵循*camelCase*风格。一些示例看起来会像下面这样：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another important convention used in this book that you should be aware of
    is the use of scope prefixes. Scope prefixes are a quick way of improving readability
    for other developers, and yourself when you enviably forget what scope a variable
    belongs to. The following is a list of the prefixes used:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的另一个重要约定是你应该了解的作用域前缀的使用。作用域前缀是提高其他开发人员和你自己在不可避免地忘记变量所属作用域时的可读性的一种快速方法。以下是使用的前缀列表：
- en: '`m_`: This is used for class member variables. These are `private` and by using
    the prefix, tells anyone using the variable that it is available plainly in the
    class or through getters or setters if external, for example, `m_numberOfPlayers`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_`：这用于类成员变量。这些是`private`，通过使用前缀，告诉任何使用变量的人，它在类中是明显可用的，或者通过外部的getter或setter，例如`m_numberOfPlayers`。'
- en: '`s_`: This is used for static class members. This tells anyone using this variable
    that only one copy exists across all instances of the class and that it is static,
    for example, `s_objDesc`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_`：这用于静态类成员。这告诉任何使用这个变量的人，在类的所有实例中只存在一个副本，并且它是静态的，例如`s_objDesc`。'
- en: '`g_`: This is used for global variables. This tells anyone using this variable
    that it is available everywhere. We will not see many of these in the book, for
    example, `g_playerInfo`.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_`：这用于全局变量。这告诉任何使用这个变量的人，它在任何地方都是可用的。我们在书中不会看到很多这样的变量，例如`g_playerInfo`。'
- en: An overview of advanced C++ concepts
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级C++概念概述
- en: Before we jump into building our tools, libraries, and other game components,
    it is probably a good idea to run over some of the more common concepts that will
    show up often as we continue throughout the book. In this section, we will take
    a quick look at some of the advanced topics. This is not meant to be a complete
    list, and the goal is not to be a comprehensive overview of each subject instead
    the object is more of a review and explanation of the concepts when it comes to
    game development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建工具、库和其他游戏组件之前，最好先复习一下在整本书中会经常出现的一些更常见的概念。在本节中，我们将快速浏览一些高级主题。这并不意味着要列出一个完整的清单，目标也不是对每个主题进行全面的概述，而是在游戏开发时对概念进行回顾和解释。
- en: We will take a look at some simple examples and highlight some of the issues
    that could arise when working with these concepts. Some of the more seasoned C++
    developers might be able to skip this section, but since these topics will play
    an influential role in the rest of the book, it is important to have a firm understanding
    of each of them. If you are looking for a broader review or a deeper explanation
    of the topics, check out some of the suggested reading in the *Summary* section
    at the end of the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些简单的例子，并强调在处理这些概念时可能出现的一些问题。一些经验丰富的 C++ 开发人员可能能够跳过这一部分，但由于这些主题将在本书的其余部分中发挥重要作用，因此重要的是对它们每一个都有牢固的理解。如果您正在寻找更广泛的回顾或更深入的解释，请查看本章末尾*总结*部分中的一些建议阅读。
- en: Working with namespaces
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: 'Namespaces might not seem like a very advanced topic when compared to, say,
    smart pointers, but as you advance in your C++ game development adventure, namespaces
    will become an important part of your development toolkit. For a quick review,
    a namespace is a declaration that provides scope for all the variables, types,
    and functions inside of its encapsulation. This is important because it gives
    us a way of organizing our code into logical groups. By breaking our code up into
    these groups, we not only make it easier to read but also prevent what is known
    as **name collisions**. Name collisions occur when you have more than one class,
    function, or type with the same name. This becomes a big problem when you start
    to work with multiple libraries. Using namespaces prevents this through its use
    of scope. For example, say we had an implementation for a specialized string class
    for a certain platform. To keep this specialized version from interfering and
    colliding with the standard library implementation, we can wrap our type in a
    namespace like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与智能指针等相比，命名空间可能看起来不是一个非常高级的主题，但随着您在 C++ 游戏开发中的进展，命名空间将成为开发工具包的重要组成部分。简单回顾一下，命名空间是一个声明，为其封装内部的所有变量、类型和函数提供范围。这很重要，因为它为我们提供了一种将代码组织成逻辑组的方式。通过将代码分成这些组，我们不仅使其更易于阅读，还可以防止所谓的**名称冲突**。当您开始使用多个库时，名称冲突就会成为一个大问题。使用命名空间通过其作用域来防止这种情况。例如，假设我们为某个平台的专用字符串类实现了一个实现。为了防止这个专用版本干扰并与标准库实现发生冲突，我们可以像这样将我们的类型包装在一个命名空间中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we can call our particular string implementation like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样调用我们特定的字符串实现：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, if we did not want to keep typing the `ConsoleHelper` part over
    and over again, we could add a `using` statement that will tell the compiler to
    use a particular namespace to find the functions, types, and variables we are
    using. You can do that for our namespace with the following line of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们不想一遍又一遍地输入`ConsoleHelper`部分，我们可以添加一个`using`语句，告诉编译器使用特定的命名空间来查找我们正在使用的函数、类型和变量。您可以使用以下代码行为我们的命名空间做到这一点：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The only problem with this is that it will include all of the `ConsoleHelper`
    libraries. If we only wanted to include a specific member of the namespace, we
    can do that with the following syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是它将包括所有`ConsoleHelper`库。如果我们只想包括命名空间的特定成员，我们可以使用以下语法：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would include just the string member and not the whole namespace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只包括字符串成员，而不是整个命名空间。
- en: Inheritance and polymorphism
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和多态
- en: Inheritance and polymorphism are topics that could easily fill their own chapters.
    They are complex and very powerful components of C++. My goal in this section
    is not to cover the entire ins and outs of inheritance and polymorphism. Instead,
    I want to take a quick look at how these concepts can be used to help you build
    your code structure. We will cover the highlights, but I am going to assume that
    you have a basic understanding of object-oriented development concepts and are
    familiar with topics such as access modifiers and friendship.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和多态是可以轻松填满自己的章节的主题。它们是 C++ 非常复杂和强大的组成部分。我在这一部分的目标不是覆盖继承和多态的所有细节。相反，我想快速看一下这些概念如何帮助您构建代码结构。我们将涵盖重点，但我假设您对面向对象开发概念有基本的理解，并熟悉访问修饰符和友元等主题。
- en: 'To begin with, we will focus on inheritance. The concept of inheritance is
    an important part of modern object-oriented design and development. While the
    ability of inheritance to save keystrokes is a huge plus, inheritance really shows
    its power when allowing a programmer to develop complex hierarchies of derived
    classes. Let''s take a look at the use of inheritance through a simple example.
    In this example, we have created a simple `Enemy` class. This class will handle
    things like the entity''s health, weapons, damage to deal, AI scripts, and so
    on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将专注于继承。继承的概念是现代面向对象设计和开发的重要部分。虽然继承的能力可以节省击键，但当允许程序员开发派生类的复杂层次结构时，继承真正显示其力量。让我们通过一个简单的例子来看一下继承的使用。在这个例子中，我们创建了一个简单的`Enemy`类。这个类将处理实体的健康、武器、要造成的伤害、AI
    脚本等等：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we start to implement more enemies to the game, we will probably start adding
    some different conditional statements to allow for some more variation in our
    enemies. Adding more and more `if` statements, maybe even a couple cases in a
    switch inserted here and there. This quickly becomes a tangled, hard-to-read,
    mess of code. What happens if we decide to add a slightly different enemy-one
    that has its own possible conditionals, for our example, a boss enemy type. This
    new boss enemy type has a similar structure as the original `Enemy` class and
    shares many of the same types and functions. We could just copy the overlapping
    code into our new `Boss` class. This would work, but it is not the ideal solution.
    We would have a lot of code duplication, and with this needless duplication comes
    more chances for bugs. Then if you do have to fix a bug, you now have to make
    the fix in multiple places. This is an unnecessary maintenance headache. Instead,
    we can use inheritance. If our new boss enemy type inherits from the original
    enemy type, this means we can use the types and functions that the original class
    has available to us. What makes inheritance even more powerful is the fact that
    we not only can adopt the functions of the inherited class, we can override them
    with our own implementations. The new `Boss` class can then be written something
    like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始向游戏中添加更多的敌人时，我们可能会开始添加一些不同的条件语句，以允许敌人有更多的变化。添加越来越多的`if`语句，甚至在这里和那里插入一些switch语句。这很快就变成了一团纠缠、难以阅读的代码混乱。如果我们决定添加一个略有不同的敌人-一个有自己可能的条件语句的敌人，比如一个boss敌人类型。这个新的boss敌人类型与原始的`Enemy`类有相似的结构，并且共享许多相同的类型和函数。我们可以将重叠的代码复制到我们的新`Boss`类中。这样可以运行，但这并不是理想的解决方案。我们会有很多代码重复，而这种不必要的重复会增加出错的机会。然后，如果你不得不修复一个bug，现在你必须在多个地方进行修复。这是一个不必要的维护头痛。相反，我们可以使用继承。如果我们的新boss敌人类型继承自原始敌人类型，这意味着我们可以使用原始类提供给我们的类型和函数。继承的更强大之处在于，我们不仅可以采用继承类的函数，还可以用我们自己的实现来覆盖它们。新的`Boss`类可以这样写：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This type of structure is commonly referred to as a **parent** and **child**
    hierarchy where the `Boss` class is a child of the `Enemy` class. This means that
    `Boss` will now have all the required structure from the `Enemy` class. I should
    point out that we only inherited the functions and variables that are declared
    `public`. That is because when using inheritance, the `public` methods and variables
    of the class are exposed to everyone using the class. The `protected` methods
    and variables are only available to the class itself and any classes derived.
    The `private` methods and variables are only available to that class, no one else
    has access, even derived clas
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构通常被称为**父**和**子**层次结构，其中`Boss`类是`Enemy`类的子类。这意味着`Boss`现在将拥有从`Enemy`类中继承的所有必需的结构。我应该指出，我们只继承了被声明为`public`的函数和变量。这是因为在使用继承时，类的`public`方法和变量对所有使用该类的人都是可见的。`protected`方法和变量只对类本身和任何派生类可用。`private`方法和变量只对该类可用，其他人无法访问，即使是派生类。
- en: 've overwritten the implementation of the `Update()` function with a special
    version for the new `Boss` class. Now, in our code, we could write something like
    the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了`Update()`函数的实现，为新的`Boss`类提供了一个特殊版本。现在，在我们的代码中，我们可以写出以下内容：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When this code is run, it will call each of the separate implementations of
    the `Update()` function for the object. On the flip side of this, consider that
    we have the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行时，它将调用对象的`Update()`函数的各个独立实现。另一方面，考虑到我们有以下代码：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we have not overwritten the `RunAIScripts()` function, as it does not inherit
    the original class's implementation of the function. While this is a very basic
    example, it does demonstrate the abilities of single inheritance, which brings
    me to my next topic-multiple inheritance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有覆盖`RunAIScripts()`函数，因为它不继承原始类的函数实现。虽然这是一个非常基本的例子，但它确实展示了单一继承的能力，这让我想到了我的下一个主题-多重继承。
- en: 'Suppose we continue with the previous example, and we decide we want to add
    a new enemy type, a boss that can fly. We have a `Boss` class, an `Enemy` class,
    and even a `FlyingEnemy` class that inherits from the `Enemy` class, which looks
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们继续前面的例子，我们决定要添加一个新的敌人类型，一个可以飞行的boss。我们有一个`Boss`类，一个`Enemy`类，甚至一个从`Enemy`类继承的`FlyingEnemy`类，看起来像这样：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The problem is we want the functionality of `FlyingEnemy`, but we also want
    some of the functionalities of `Boss`. Again, we could just copy the code chunks
    we want into a new class, but C++ provides us with an even better solution, **multiple
    inheritance**. As the name suggests, multiple inheritance allows us to derive
    our class from multiple sources. We can then build classes that have two or more
    parent classes leading to complex hierarchies, but as we will see, this can also
    lead to some problematic situations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们想要`FlyingEnemy`的功能，但我们也想要`Boss`的一些功能。同样，我们可以将我们想要的代码块复制到一个新的类中，但C++为我们提供了一个更好的解决方案，**多重继承**。顾名思义，多重继承允许我们从多个来源派生我们的类。然后我们可以构建具有两个或更多父类的类，导致复杂的层次结构，但正如我们将看到的，这也可能导致一些问题。
- en: 'To continue with our example, our new `FlyingBoss` class would look something
    like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的例子，我们的新`FlyingBoss`类会看起来像下面这样：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At first glance, this looks like the perfect class, we have inherited the functions
    and variables we needed from both of the parent classes. However, there are a
    few issues that can start to come into play when working with multiple inheritance.
    First is the issue of ambiguity. Ambiguity happens when two or more of the classes
    that are being inherited from have functions or variables with the same name.
    For instance, in our example, if we did not override the `Update()` function,
    and we called `Update()` on the object, the compiler would look at the classes
    we inherited from for the implementation. Since they both have an implementation
    of the same name, the compiler throws a compiler time error complaining of ambiguity
    in the call. To solve this problem, we have to use a prefix on the function call
    to identify the class with the implementation we want to use. To do this, we use
    the scope operator (`::`) in our code to call the implementation from the `FlyingEnemy`
    class, which would look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来像是完美的类，我们从两个父类中继承了我们需要的函数和变量。然而，在使用多重继承时，会出现一些问题。首先是歧义的问题。当被继承的两个或更多个类具有相同名称的函数或变量时，就会出现歧义。例如，在我们的例子中，如果我们没有覆盖`Update()`函数，并且在对象上调用`Update()`，编译器会查看我们从中继承的类的实现。由于它们都有相同名称的实现，编译器会抛出编译时错误，抱怨调用中的歧义。为了解决这个问题，我们必须在函数调用上使用前缀来标识我们想要使用的实现类。为此，我们在代码中使用作用域运算符(`::`)来从`FlyingEnemy`类中调用实现，代码看起来像这样：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second issue might be a little less obvious; it has to deal with the way
    the class inheritance tree is structured in our example. On the surface, everything
    looks good; the `FlyingBoss` class inherits from the `Boss` class and the `FlyingEnemy`
    class. The problem lies one step up the inheritance tree, both the `Boss` and
    `FlyingEnemy` classes inherit from the `Enemy` class. This creates the dreaded
    diamond of death pattern in the class hierarchy. This might not seem like a big
    deal, but having this pattern causes some unfortunate issues. First is again the
    issue of ambiguity. Every time you try and access any member variable or function
    of the `Enemy` class from the `FlyingBoss` class, it is ambiguous. This is because
    there are multiple paths to each variable and function. To solve this, we can
    specify which path we want to follow by again using the scope operator (`::`).
    Another issue that the diamond of death pattern causes is the problem of duplication.
    When we create a `FlyingBoss` object, it will have two copies of everything it
    inherits from the `Boss` class. This is because both `FlyingEnemy` and `Boss`
    classes have copies from the `Enemy` class that they have inherited. As you can
    see, this is messy and can lead to all kinds of headaches. Fortunately, C++ provides
    us with a solution, the concept of **virtual inheritance**. With virtual inheritance,
    we can make sure that a parent class only appears in any children classes once.
    To implement virtual inheritance, we simply use the `virtual` keyword when declaring
    the class we want to inherit from. In our example, the class declaration would
    then look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题可能不太明显；它与类继承树在我们的例子中的结构有关。表面上看，一切都很好；`FlyingBoss`类从`Boss`类和`FlyingEnemy`类继承。问题出现在继承树的上一层，`Boss`和`FlyingEnemy`类都从`Enemy`类继承。这在类层次结构中创建了可怕的死亡之钻模式。这可能看起来不是什么大问题，但是这种模式会导致一些不幸的问题。首先是再次出现歧义的问题。每当您尝试从`FlyingBoss`类访问`Enemy`类的任何成员变量或函数时，都会出现歧义。这是因为每个变量和函数都有多条路径。为了解决这个问题，我们可以通过再次使用作用域运算符(`::`)来指定我们想要遵循的路径。死亡之钻模式引起的另一个问题是重复的问题。当我们创建一个`FlyingBoss`对象时，它将拥有从`Boss`类继承的一切的两个副本。这是因为`FlyingEnemy`和`Boss`类都有从`Enemy`类继承的副本。正如您所看到的，这很混乱，可能会导致各种头痛。幸运的是，C++为我们提供了一个解决方案，即**虚拟继承**的概念。通过虚拟继承，我们可以确保父类只在任何子类中出现一次。要实现虚拟继承，我们只需在声明要继承的类时使用`virtual`关键字。在我们的例子中，类声明看起来会像这样：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now the `FlyingBoss` class only has one instance of anything gained through
    inheritance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`FlyingBoss`类只有一个通过继承获得的实例。
- en: While this does solve the issue of the diamond of death and other possible hierarchy
    issues, these issues are usually a sign of the underlying design issues. I would
    suggest researching all other options before automatically jumping to virtual
    inheritance as a solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实解决了死亡之钻和其他可能的层次问题，但这些问题通常是潜在设计问题的迹象。我建议在自动转向虚拟继承作为解决方案之前，研究所有其他选项。
- en: 'Finally, I want to quickly mention two important topics that work hand in hand
    to make inheritance the incredible tool it is, polymorphism and virtual functions.
    Boiling it down to the basics, polymorphism is the ability to use an object of
    a class as if it was part of another class. To make this simple, let''s examine
    the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想快速提到两个重要的主题，它们共同使继承成为了不可思议的工具，多态和虚函数。归结为基础知识，多态是将一个类的对象用作另一个类的一部分的能力。为了简单起见，让我们来看一下：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This line of code creates a pointer to a new `FlyingBoss` object, nothing new
    here. However, we can also create a new pointer like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码创建了一个指向新的`FlyingBoss`对象的指针，这里没有什么新鲜的。然而，我们也可以这样创建一个新的指针：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This works thanks to inheritance and polymorphism. We are able to refer to
    the `FlyBoss` object as if it was a `Boss` class object. It might seem simple
    now, but as you progress in your understanding of C++, you will start to see just
    how powerful this concept can be. It also leads us to the last topic I want to
    touch on with inheritance, virtual functions. Since we can create pointers to
    objects like this, what happens if we call the `Update()` function on `Boss*`
    of the `FlyingBoss` object? This is where virtual functions come in. If a function
    is marked with the `virtual` keyword like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这得益于继承和多态。我们能够将`FlyBoss`对象称为`Boss`类对象。现在可能看起来很简单，但随着你对C++的理解不断深入，你会开始意识到这个概念有多么强大。它还引出了我想要在继承中谈到的最后一个话题，虚函数。由于我们可以创建这样的对象指针，如果我们在`FlyingBoss`对象的`Boss*`上调用`Update()`函数会发生什么？这就是虚函数发挥作用的地方。如果一个函数被标记为`virtual`关键字，就像这样：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This tells the compiler to use the type of object calling the function to determine
    which implementation should be used in that situation. So in our example if we
    were to use a virtual function in the `FlyingBoss` implementation, it would use
    that implementation when called from the `Boss*` of the `FlyingBoss` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器使用调用函数的对象类型来确定在该情况下应该使用哪个实现。因此，在我们的例子中，如果我们在`FlyingBoss`实现中使用虚函数，那么当从`FlyingBoss`对象的`Boss*`调用时，它将使用该实现。
- en: Pointers and referencing
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针和引用
- en: One of the most misunderstood and feared concepts in C++ is the concepts of
    pointers and references. It is often the reason new developers shy away from continuing
    their study of C++. There have been many books and tutorials written, trying to
    demystify the topic and to be quite honest I could easily write a chapter or even
    a separate book on the ins and outs of pointers and referencing. By now I am hoping
    you have come to peace with the topic of pointers and references in the classical
    sense and have built a healthy appreciation for their power and flexibility. So,
    in this section, we are not going to cover the core principles, but instead, look
    at the more important uses of, the older, or classical pointers and references
    and briefly cover the new pointers designed to help remove some of the mysticism
    and memory management concerns.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: C++中最被误解和害怕的概念之一就是指针和引用的概念。这往往是新开发人员放弃继续学习C++的原因。已经有许多书籍和教程试图揭开这个话题的神秘面纱，坦率地说，我很容易就能写一章甚至一本专门讨论指针和引用的内部和外部知识。我希望你现在已经对经典意义上的指针和引用这个话题感到满意，并对它们的力量和灵活性有了健康的欣赏。因此，在这一部分，我们不打算涵盖核心原则，而是看看更重要的用途，即经典指针和引用的用途，并简要介绍旨在帮助消除一些神秘感和内存管理问题的新指针。
- en: 'We will start out with the classical pointers and references. While you will
    quickly see the benefits of using the newer pointers, I still believe, as do a
    lot of C++ game developers, that the older versions still have their place. One
    of these places is when dealing with the passing of data to functions. When calling
    a function, it is often quite tempting to write something like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从经典指针和引用开始。虽然你很快就会看到使用新指针的好处，但我仍然相信，像许多C++游戏开发人员一样，旧版本仍然有其存在的价值。其中一个地方就是在处理向函数传递数据时。在调用函数时，往往很容易写出以下代码：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While this code is totally legal, if the object is more than a negligible size,
    it can pose a serious performance concern. When passing an object like this, the
    compiler automatically creates a copy of the object in memory. In most cases,
    this is not what we want. To prevent the compiler from creating a copy in memory,
    we can pass the object using a classic pointer or reference. The previous code
    would then look something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码完全合法，但如果对象的大小不容忽视，它可能会带来严重的性能问题。当传递这样的对象时，编译器会自动在内存中创建对象的副本。在大多数情况下，这不是我们想要的。为了防止编译器在内存中创建副本，我们可以使用经典指针或引用传递对象。前面的代码看起来会像这样：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, it would look like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它看起来会像这样：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now the object is not copied into memory and allows us to operate on the actual
    object through dereferencing. This is one of the more common, continued uses of
    the classical pointers and references. Another common use of the classical pointers
    and references is when working with string literals and when moving objects. This
    type of application is still seen in many game development libraries. As such
    you should be comfortable with seeing code like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对象不会被复制到内存中，并允许我们通过解引用对实际对象进行操作。这是经典指针和引用的更常见和持续的用途之一。经典指针和引用的另一个常见用途是在处理字符串文字和移动对象时。这种类型的应用在许多游戏开发库中仍然很常见。因此，你应该习惯看到类似以下的代码：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the move to modern C++ and the C++11 standards, came a new set of managed
    pointers to help simplify the understanding and use of pointers. These new pointers
    are much like the classic pointers except for one crucial difference; they are
    managed. What this really boils down to is that these new pointers will handle
    their own memory allocation and deletion. Since one of the major issues with the
    classic pointer was the necessary manual memory and the problem of ownership,
    as in who is going to delete it and when this makes the use of pointers a little
    more welcoming and a lot more flexible. These managed pointers (`unique_ptr` and
    `shared_ptr`) are commonly used in the more modern game development libraries.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代C++和C++11标准的推出，出现了一组新的托管指针，以帮助简化指针的理解和使用。这些新指针与经典指针非常相似，除了一个关键的区别；它们是托管的。这实际上意味着这些新指针将处理它们自己的内存分配和释放。由于经典指针的一个主要问题是必须手动管理内存和所有权的问题，这使得指针的使用更加受欢迎和更加灵活。这些托管指针（`unique_ptr`和`shared_ptr`）通常在更现代的游戏开发库中使用。
- en: unique_ptr and shared_ptr
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unique_ptr和shared_ptr
- en: The `unique_ptr` or unique pointer, is considered a smart pointer. The reason
    it is called unique is because this type of object holds sole ownership of its
    pointer. This means that no two `unique_ptr` pointers can manage the same object,
    it is unique. One of the biggest advantages of `unique_ptr` is that it manages
    its own lifetime. What this means is that when the pointer goes out of scope,
    it automatically destroys itself and deallocates its memory. This solves the dreaded
    dangling pointer issues and avoids memory leaks. This also removes the issue of
    ownership since now it is explicit who deletes the pointer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`或唯一指针被认为是智能指针。之所以称其为唯一，是因为这种类型的对象拥有其指针的唯一所有权。这意味着没有两个`unique_ptr`指针可以管理相同的对象，它是唯一的。`unique_ptr`的最大优势之一是它管理自己的生命周期。这意味着当指针超出范围时，它会自动销毁自身并释放其内存。这解决了可怕的悬空指针问题，并避免了内存泄漏。这也消除了所有权的问题，因为现在明确了谁删除了指针。'
- en: 'Since the C++14 standard, we can now use a handy little function to create
    a unique pointer, `make_unique`. The `make_unique` function creates an object
    of type `T` and then wraps it in a unique pointer. The syntax for creating the `unique_ptr` pointer
    with `make_unique` would look something like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++14标准以来，我们现在可以使用一个方便的小函数来创建唯一指针，`make_unique`。`make_unique`函数创建了一个`T`类型的对象，然后将其包装在唯一指针中。使用`make_unique`创建`unique_ptr`指针的语法如下：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once created, you can use the pointer much like a classic pointer. The dereference
    operators, `*` and `->`, work just like they normally would. Again the big difference
    here is that the pointer is automatically destroyed when it goes out of scope,
    freeing us from having to track every exit point manually to avoid any memory
    leak issues.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，您可以像使用经典指针一样使用指针。解引用运算符`*`和`->`的工作方式与通常情况下一样。这里的最大区别再次在于，当指针超出范围时，它会自动销毁，使我们不必手动跟踪每个退出点以避免任何内存泄漏问题。
- en: The `shared_ptr` or shared pointer is a lot like the unique pointer. It is considered
    a smart pointer, it handles deletion and deallocation of memory automatically.
    The difference is that the shared pointer *shares* ownership of the object. This
    means that, unlike the unique pointer, a shared pointer can be one of many shared
    pointers, pointing to a single object. This means that if a shared pointer goes
    out of scope or is pointed to another object, through `reset()` or the `=` operator,
    the object still remains. It is only destroyed and its memory deallocated when
    all the `shared_ptr` objects owning the object are either destroyed, go out of
    scope, or are reassigned to another pointer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`或共享指针与唯一指针非常相似。它被认为是智能指针，可以自动处理内存的删除和释放。不同之处在于共享指针*共享*对象的所有权。这意味着，与唯一指针不同，共享指针可以是指向单个对象的多个共享指针之一。这意味着如果共享指针超出范围或指向另一个对象，通过`reset()`或`=`运算符，对象仍然存在。只有当拥有对象的所有`shared_ptr`对象被销毁、超出范围或重新分配给另一个指针时，对象才会被销毁并释放其内存。'
- en: 'Again, like the unique pointer, the shared pointer also has a handy function
    for creation. The `make_shared` function creates an object of type `T` and then
    wraps it in a shared pointer. The syntax for creating the `shared_ptr` function
    using the `make_shared` function would look like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与唯一指针一样，共享指针也有一个用于创建的方便函数。`make_shared`函数创建了一个`T`类型的对象，然后将其包装在共享指针中。使用`make_shared`函数创建`shared_ptr`函数的语法如下：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Also, like the unique pointer, the shared pointer has the typical dereference
    operators, `*` and `->`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与唯一指针一样，共享指针也有典型的解引用运算符`*`和`->`。
- en: const correctness
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: const正确性
- en: The topic of `const` correctness can be a contentious one in the C++ community.
    The instructor of my first C++ course went as far as to say that the `const` keyword
    was one of the most important keywords in the language. Of course, I have also
    heard the other side, with developers telling me how they never use `const` and
    it is a complete waste of keystrokes. I like to think I fall somewhere in the
    middle on `const`; I believe that it has important uses, but it can be overused
    just like any other feature. In this section, I want to show some of the better
    uses for `const`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++社区中，`const`正确性可能是一个有争议的话题。我第一门C++课程的讲师甚至说`const`关键字是语言中最重要的关键字之一。当然，我也听到了另一种说法，开发人员告诉我他们从不使用`const`，这完全是在浪费击键。我认为我在`const`方面处于中间位置；我相信它有重要的用途，但它可能像任何其他特性一样被过度使用。在这一部分，我想展示一些更好的`const`使用方法。
- en: 'As a quick review, the `const` keyword is used as a type qualifier to let the
    compiler know that this value or object cannot change, it is constant. When first
    starting out with C++ game development, your first exposure to `const` will probably
    come early on. Most commonly, the introduction to using *const-ness* has been
    in the defining of important values that we want to have easy access to, say something
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`const`关键字用作类型限定符，让编译器知道这个值或对象是不可变的。在开始学习C++游戏开发时，你对`const`的第一次接触可能会很早。最常见的情况是，在定义我们想要轻松访问的重要值时，我们引入了*const-ness*的使用，比如这样：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This then gives us a named value that we can easily use many times in other
    parts of our code. The big advantage of doing this is that if we then decided
    to change the value, in this case, the maximum amount of bullets, we can just
    change this constant value instead of having to change numerous amounts of hardcoded
    values scattered throughout the codebase.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在代码的其他部分轻松多次使用这个命名值。这样做的最大优势是，如果我们决定更改值，比如子弹的最大数量，在这种情况下，我们只需更改这个常量值，而不必更改代码库中散布的大量硬编码值。
- en: As you get deeper into C++ development, the `const` keyword will become a more
    familiar site. It is used heavily in libraries and engine code in a variety of
    ways. It is also utilized in the definition of parameters for functions or used
    as a modifier for a function definition. Let's briefly take a look at these.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您深入C++开发，`const`关键字将变得更加熟悉。它在库和引擎代码中以各种方式大量使用。它还用于函数参数的定义或用作函数定义的修饰符。让我们简要地看一下这些。
- en: 'First, when used in the definition of parameters, it becomes an insurance that
    the function we are giving the value to is not going to modify it in any way.
    Take the following code, for example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在参数的定义中使用它，可以确保我们给定值的函数不会以任何方式修改它。例如，看下面的代码：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Okay, this is a very simple example, but if you did call a function like this,
    unaware of the fact that it could modify the object, you would end up with results
    you might not have been expecting. There are two ways that the `const` keyword
    helps solve this possible issue. One is by using the `const` keyword when passing
    the value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个非常简单的例子，但如果您调用这样的函数，却不知道它可能会修改对象，您最终会得到您可能没有预期的结果。`const`关键字有两种方式可以帮助解决这个可能的问题。一种是在传递值时使用`const`关键字：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This now makes it impossible to modify the value passed in anywhere in the function,
    keeping it constant.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就不可能在函数中的任何地方修改传递的值，使其保持不变。
- en: 'The other way is by creating functions that are `const` safe. When you define
    a function as being a `const` function, it then allows `const` objects to call
    it. By default, `const` objects cannot call non `const` functions. However, non
    `const` objects can still call `const` functions. To define a function as being
    a `const` function, we can add the `const` keyword to modify the function definition
    itself. You simply add `const` to the end of the function signature, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建“const”安全的函数。当您将函数定义为“const”函数时，它允许“const”对象调用它。默认情况下，“const”对象不能调用非“const”函数。但是，非“const”对象仍然可以调用“const”函数。要将函数定义为“const”函数，我们可以添加“const”关键字来修改函数定义本身。您只需在函数签名的末尾添加“const”，如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is my preferred method of writing any function that is not going to modify
    any objects or values. It allows some flexibility in ensuring that it can be called
    from `const` objects in the future, and it also allows other developers using
    the function in their code to easily identify that the function will not modify
    any object or value used in combination with it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我编写任何不会修改任何对象或值的函数的首选方法。它允许在将来可以从“const”对象调用它，并且还允许在其代码中使用该函数的其他开发人员轻松识别该函数不会修改与其组合使用的任何对象或值。
- en: Memory management
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: The idea of **memory management** in C++ is often the topic of nightmares for
    beginners. I have commonly heard developers make statements like *I don't use
    C++ because of its manual memory management*. The truth is manual memory management
    is very rare in the vast majority of projects. These days with modern concepts
    like managed smart pointers, hand built memory management systems is of little
    importance for day-to-day development. It is only when you get to high-performance
    computing, such as game development, does the idea of controlling memory allocation
    and deallocation become a concern. When it comes to game development, the overall
    memory availability and speed on consoles continue to be a concern for developers,
    which is also true for most mobile devices, despite the rapid growth of affordable
    high memory devices. Over this next section, we will take a refresher look at
    the stack and heap, and the differences in how to handle memory allocation. This
    will lay the groundwork for the next chapter where we will see an example of a
    custom memory manager system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，**内存管理**的概念经常是初学者的噩梦话题。我经常听到开发人员说*我不使用C++是因为它的手动内存管理*。事实上，在绝大多数项目中手动内存管理是非常罕见的。如今，随着现代概念如托管智能指针，手动构建的内存管理系统在日常开发中变得不那么重要。只有当涉及高性能计算，如游戏开发时，控制内存分配和释放才成为一个问题。在游戏开发中，控制内存分配和释放的概念仍然是开发人员关注的焦点，这也适用于大多数移动设备，尽管价格实惠的高内存设备不断增长。在接下来的部分，我们将重新审视堆栈和堆，以及处理内存分配的方法的差异。这将为下一章奠定基础，我们将看到一个自定义内存管理系统的示例。
- en: 'Let''s start with the stack, the appropriately named, **memory construct**,
    which you can think of much like a stack of plates or dishes. When you create
    an object or variable on the stack, it is placed on the top of the pile. When
    the object or variable goes out of scope, this is analogous to the plate or dish
    being removed from the stack. An allocation on the stack would look something
    like this in the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从堆栈开始，这个名字很贴切的**内存结构**，你可以把它想象成一堆盘子或碟子。当您在堆栈上创建一个对象或变量时，它被放在堆的顶部。当对象或变量超出范围时，这类似于从堆栈中移除盘子或碟子。在代码中，堆栈上的分配看起来像这样：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line creates an integer value, and assigns it the value of `10`. The
    memory needed to store the integer is allocated on the stack. The second line
    has exactly the same idea, just for a `Player` object instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建一个整数值，并将其赋值为`10`。存储整数所需的内存在堆栈上分配。第二行具有完全相同的想法，只是针对`Player`对象而已。
- en: A good thing about using the stack is that any memory we allocate will be cleaned
    up for us when the object or variable goes out of scope. This can, however, be
    a double-edged sword; a lot of newer developers run into issues where they look
    for or make calls to objects after they have gone out of scope because they used
    the stack to store them. The other issue with the stack is that it is limited
    in size, which depends on the platform and compiler settings. This can become
    an issue if you have a lot of objects being created and held for an extended period
    of time. Trying to allocate more memory than available on the stack will throw
    a runtime error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆栈的一个好处是，当对象或变量超出范围时，我们分配的任何内存都将被清理。然而，这可能是一把双刃剑；许多新开发人员遇到的问题是，他们在对象超出范围后仍然查找或调用对象，因为他们使用堆栈来存储它们。堆栈的另一个问题是其大小受限，这取决于平台和编译器设置。如果创建了大量对象并长时间保存，这可能会成为一个问题。尝试分配超出堆栈可用内存的内存将引发运行时错误。
- en: 'The alternative is the heap, which you can think of as being a large blob or
    container of memory. Unlike the stack, this heap of memory is unordered and can
    easily become fragmented. The good news is modern memory, and operating system
    implementations offer a low-level mechanism for dealing with this fragmentation,
    commonly known as **memory virtualization**. Another bonus of this virtualization
    is that it provides access to more heap storage than the physical memory provides,
    by swapping memory out to the hard drive when needed. To allocate and destroy
    memory on the heap, you use the keywords `new` and `delete`, and `new[]` and `delete[]`
    for containers of objects. The code will look something like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是堆，你可以将其视为一大块或一大容器的内存。与堆栈不同，这个内存堆是无序的，很容易变得碎片化。好消息是，现代内存和操作系统实现提供了一种低级机制来处理这种碎片化，通常称为**内存虚拟化**。这种虚拟化的另一个好处是，它提供了对比物理内存更多的堆存储的访问权限，通过在需要时将内存交换到硬盘。要在堆上分配和销毁内存，你可以使用关键字`new`和`delete`，以及`new[]`和`delete[]`用于对象的容器。代码看起来会像这样：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first two lines create a `Player` object and a character array on the heap.
    The next two lines delete these objects, respectively. It is important to remember
    for every chunk of memory you create on the heap, you must call delete to destroy
    or release that chunk of memory. Failure to do so can cause memory leaks, where
    your application continues to consume more and more memory until the device runs
    out and crashes. This is a common issue and can be hard to track out and debug.
    Memory leaks are one of the reasons new developers tend to think C++ memory management
    is hard.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行创建了一个`Player`对象和一个堆上的字符数组。接下来的两行分别删除了这些对象。重要的是要记住，对于在堆上创建的每个内存块，你必须调用delete来销毁或释放该内存块。如果不这样做，可能会导致内存泄漏，使你的应用程序继续消耗更多内存，直到设备耗尽并崩溃。这是一个常见的问题，很难追踪和调试。内存泄漏是新开发人员认为C++内存管理困难的原因之一。
- en: So what should you use, the stack or the heap? Well, it really depends on the
    implementation and the object or value being stored. A good rule of thumb I recommend
    is that if you can get away with using the stack for your allocation, that should
    be your default. If you do find yourself needing to use the heap, try and use
    a manager system to handle the creation and deletion. This will cut down on the
    chances of memory leaks and other issues that arise from handling your own memory
    management. We will look at how to build your own memory manager as part of your
    core libraries in the next chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该使用堆栈还是堆？嗯，这实际上取决于实现和要存储的对象或值。我建议的一个经验法则是，如果可以使用堆栈进行分配，那应该是你的默认选择。如果确实需要使用堆，尝试使用管理系统来处理创建和删除。这将减少内存泄漏和其他与处理自己的内存管理相关的问题的几率。我们将在下一章中讨论如何构建自己的内存管理器作为核心库的一部分。
- en: Dealing with errors
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: I wish I could say that every line of code I write works flawlessly the first
    time. The reality is that I am human and prone to making errors. Dealing with
    these mistakes and tracking down the bugs can be where most development time is
    spent. Having a good way to catch and deal with these any other issues that occur
    during the running time of your game is crucial. This section covers some of the
    C++ techniques used for finding and handling errors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我能说我写的每一行代码都能一次性无缺地运行。现实是我是人，容易犯错误。处理这些错误并追踪错误可能是大部分开发时间所花费的地方。有一个良好的方法来捕捉和处理在游戏运行时发生的错误和其他问题是至关重要的。本节介绍了一些用于查找和处理错误的C++技术。
- en: 'One technique that you can use when you hit an issue is to gracefully let the
    program crash. Meaning that instead of having the computer crash on its own, we
    tell the computer to stop the execution of our code and exit immediately. To do
    this in C++, we can use the `assert()` method. An example would look something
    like the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到问题时，可以使用一种技术优雅地让程序崩溃。这意味着，我们告诉计算机停止执行我们的代码并立即退出，而不是让计算机自行崩溃。在C++中，我们可以使用`assert()`方法来做到这一点。一个例子看起来会像下面的代码：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the computer hits the line of code `assert(number != NULL);` it checks
    to see whether the integer number is `NULL`, whether this evaluates to true, in
    this case, it will cause an assertion failure that immediately stops execution
    and exits the program. This allows us, at least, some control. We can use the
    opportunity provided by the `assert()` function to capture more information to
    create a crash report. We can print out the file, line, and even a description
    of the error as a custom message. While this does work, it leaves a lot to be
    desired.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机遇到代码行`assert(number != NULL);`时，它会检查整数number是否为`NULL`，如果是，这将导致断言失败，立即停止执行并退出程序。这至少让我们有些控制。我们可以利用`assert()`函数提供的机会来捕获更多信息，以创建崩溃报告。我们可以打印出文件、行，甚至错误的描述作为自定义消息。虽然这样做有效，但还有很多需要改进的地方。
- en: 'Another technique that handles errors which can provide a little more flexibility
    is exceptions. Exceptions work like this; when the program runs into an issue,
    it can throw an exception that halts the execution. The program then looks for
    the nearest exception handling block. If it is unable to find that block in the
    function that threw the exception, it then looks to the parent function for a
    handling block. This process unwinds the stack, meaning that all objects created
    on the stack will be destroyed in the order they were passed in. This process
    will continue until the program finds a handling block or hits the top of the
    stack at which point the default exception handler will be called, and the program
    will quit. The overall the syntax used to handle exceptions in C++ is pretty straightforward.
    To throw an exception, you use the keyword `throw`. This will trigger the program
    to look for a handling block, denoted with the keyword `Catch`. A `Catch` block
    must be located right after a `Try` block, which encapsulates the code that might
    throw the exception. A simple example of this would be:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理错误的技术是异常，它可以提供更多的灵活性。异常的工作原理是这样的：当程序遇到问题时，它可以抛出一个异常来停止执行。然后程序会寻找最近的异常处理块。如果在抛出异常的函数中找不到该块，那么程序会在父函数中寻找处理块。这个过程会展开堆栈，意味着堆栈上创建的所有对象都会按照它们被传入的顺序被销毁。这个过程会一直持续，直到程序找到一个处理块或者到达堆栈的顶部，此时会调用默认的异常处理程序，程序将退出。总的来说，在C++中处理异常的语法非常简单。要抛出异常，你可以使用关键字`throw`。这将触发程序寻找一个处理块，用关键字`Catch`表示。`Catch`块必须位于`Try`块的后面，`Try`块封装了可能抛出异常的代码。一个简单的例子是：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also catch and handle specific errors by passing the exception type
    as an argument to the Catch block, as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将异常类型作为参数传递给Catch块来捕获和处理特定错误，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The advantage of using exceptions is that we have the flexibility to handle
    the error any way we want. We could, if the situation allows, correct this issue
    that caused the error and continue on, or we could simply dump some information
    to a log file and exit the program. The choice is ours.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常的优势在于我们可以灵活地处理错误。如果情况允许，我们可以纠正导致错误的问题并继续进行，或者我们可以简单地将一些信息转储到日志文件中并退出程序。选择权在我们手中。
- en: Which solution you implement to handle errors is completely up to you and the
    project you are working on. Some developers do, in fact, choose just to ignore
    handling errors all together. I, however, highly recommend using some sort of
    error handling system. In the example code used for the demos throughout the book,
    I implement an exception handling system. I recommend looking at that implementation
    as a starting reference. The suggested reading section at the end of this chapter
    also contains some great references on handling errors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您实现的处理错误的解决方案完全取决于您所在的项目。事实上，一些开发人员选择完全忽略处理错误。然而，我强烈建议使用某种错误处理系统。在本书的演示示例代码中，我实现了一个异常处理系统。我建议将其作为起始参考。本章末尾的建议阅读部分还包含一些关于处理错误的优秀参考资料。
- en: Working with types and containers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理类型和容器
- en: C++ is a strongly-typed unsafe language. It provides an incredible amount of
    control, but it ultimately expects the programmer to know what they are doing.
    Understanding how to work with types at an advanced level is paramount to mastering
    game library and core system programming. Game development relies heavily on the
    flexibility of types in C++, it also relies on the advanced libraries available
    like the **Standard Template Library** (**STL**). Over the next few sections,
    we will look at some of the more common containers used in game development and
    their STL implementations. We will also cover how to create generic code through
    use templating. Finally, we will wrap up the topic of types and containers with
    a look at type inference and its more often seen use cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种强类型的不安全语言。它提供了令人难以置信的控制能力，但最终期望程序员知道自己在做什么。在高级水平上理解如何处理类型对于掌握游戏库和核心系统编程至关重要。游戏开发在很大程度上依赖于C++中类型的灵活性，它还依赖于可用的高级库，比如**标准模板库**（**STL**）。在接下来的几节中，我们将看一些在游戏开发中常用的容器及其STL实现。我们还将介绍如何通过使用模板创建通用代码。最后，我们将通过查看类型推断及其更常见的用例来结束类型和容器的主题。
- en: STL generic containers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL通用容器
- en: The C++ STL is a collection of container classes that allow storage of data
    in different structures, with iterators that provide access to elements of the
    container, and algorithms that can perform operations on the containers and the
    elements they hold. These structures, iterators, and algorithms are extremely
    optimized and in most cases use the latest implementations of the C++ language
    standard. The STL makes extensive use of the templating feature in C++ to allow
    easy adaptation for use with our own types. We will take a look at templating
    in the next section. The STL is a huge topic, with many books written on the concepts
    and implementation. If you have had little experience with the STL, I highly recommend
    reading some of the amazing books that have been written on the subject. I have
    listed a few in the *Summary* section at the end of this chapter. This section
    will concentrate on highlighting some of the STL containers that are more commonly
    used in game development. I am going to assume that you have a basic understanding
    of containers and that you have had some experience using iterators to traverse
    elements in a container.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL是一组容器类的集合，允许以不同的结构存储数据，具有提供对容器元素访问的迭代器，以及可以对容器和它们持有的元素执行操作的算法。这些结构、迭代器和算法都经过了极其优化，在大多数情况下使用了C++语言标准的最新实现。STL广泛使用C++中的模板特性，以便轻松地适应我们自己的类型。我们将在下一节中看一下模板化。STL是一个庞大的主题，有许多关于概念和实现的书籍。如果你对STL的经验很少，我强烈建议阅读一些关于这个主题的精彩书籍。我在本章末尾的*总结*部分列出了一些书籍。本节将集中介绍在游戏开发中更常用的一些STL容器。我假设你对容器有基本的了解，并且有一些使用迭代器遍历容器中的元素的经验。
- en: Let's start with two sequence containers, vector and list. The reason they are
    referred to as **sequence containers** is because they store their elements in
    a specific order. This allows elements to be added or removed anywhere in that
    order, or sequence. Vector and list are some of the most popular STL sequence
    containers you will come across. Knowing some key facts will help you decide which
    one is the best for a particular task. I have included a few suggestions to help
    guide you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个序列容器vector和list开始。它们被称为**序列容器**是因为它们按特定顺序存储它们的元素。这允许在该顺序或序列的任何位置添加或删除元素。Vector和list是你将遇到的最受欢迎的STL序列容器之一。了解一些关键事实将有助于您决定哪一个最适合特定任务。我已经包括了一些建议来帮助指导您。
- en: Vector
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: '**Vector** is one of the most basic containers offered in the STL. While it
    is comparatively simple, it is highly flexible and is one of the most widely used
    containers in game development. The place you are most likely to see it is in
    replacement of a C array. One of the bigger drawbacks that comes with using arrays
    is that you have to define the size of the array at declaration. This means, in
    most cases, you will need to know the maximum amount of elements needed, or you
    need to allocate more than you will ever need. Luckily for us vectors do not have
    this, predefined size, drawback; a vector will grow to accommodate new elements
    that are added. To create a vector of integers, we can use the following syntax:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector**是STL中提供的最基本的容器之一。虽然它相对简单，但它非常灵活，是游戏开发中最广泛使用的容器之一。你最有可能看到它的地方是替代C数组。使用数组带来的一个更大的缺点是你必须在声明时定义数组的大小。这意味着在大多数情况下，你需要知道所需元素的最大数量，或者你需要分配比你所需的更多。幸运的是，对于我们来说，向量没有这个预定义大小的缺点；向量将增长以容纳添加的新元素。要创建一个整数向量，我们可以使用以下语法：'
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You probably noticed `std::` before `vector`, that is because the `vector` class
    is part of the `std` namespace, so we need to identify that we wish to use that
    implementation. See the *Working with namespaces* section earlier in the chapter
    for a review. We can avoid having to type this by adding a `using namespace std;`
    statement at the beginning of the code file. I prefer to add `std::` to my standard
    library calls, or any other specific namespace call. Since game development uses
    so many libraries having a lot of `using` statements can become messy and error
    prone. Although it takes a few extra keystrokes, it can save a pile of headaches.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到在`vector`之前有`std::`，这是因为`vector`类是`std`命名空间的一部分，所以我们需要确定我们希望使用该实现。请参阅本章前面的*使用命名空间*部分进行复习。我们可以通过在代码文件开头添加`using
    namespace std;`语句来避免输入这个。我更喜欢在我的标准库调用或任何其他特定命名空间调用中添加`std::`。由于游戏开发使用了很多库，使用很多`using`语句可能会变得混乱且容易出错。虽然需要多按几下键盘，但可以避免很多麻烦。
- en: I personally use vectors in place of arrays in most cases, and would suggest
    you do too. Before you go changing all of your arrays to vectors, though, it is
    important to note one aspect of vectors that could potentially cause issues. When
    you create a vector, one contiguous block of memory is allocated for it. The amount
    of memory depends on the amount of elements in the vector. There will always be
    room for all the elements currently in the vector plus a little extra to allow
    for the addition of new elements. This is the trick of a vector, as you add more
    elements, and ultimately start to run out of space, the vector will grab more
    memory so that it always has room for new elements. It does this by first creating
    a new block of memory, copying all the contents of the first block of memory and
    then deleting it. This is where the issues can creep in. To prevent constant allocation,
    copy, and deletion, when a vector allocates new memory, it generally doubles the
    previous size. Since a vector can never shrink, if we have used a vector in a
    way that creates large additions and subtractions of elements, this can easily
    become a memory issue, especially for lower memory devices. Knowing this should
    not prevent you from using vectors, when implemented in the right situations this
    should rarely become a problem and can be easily mitigated through refactoring
    if it does arise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人在大多数情况下使用向量代替数组，并建议您也这样做。不过，在将所有数组更改为向量之前，有一点很重要，那就是向量可能会导致问题的一个方面。当你创建一个向量时，会为它分配一个连续的内存块。内存的大小取决于向量中的元素数量。始终会有足够的空间来容纳向量中当前的所有元素，再加上一点额外的空间以便添加新元素。这就是向量的诀窍，随着添加更多的元素，最终开始耗尽空间，向量将获取更多的内存，以便始终有空间容纳新元素。它首先创建一个新的内存块，复制第一个内存块的所有内容，然后删除它。这就是问题可能出现的地方。为了防止不断的分配、复制和删除，当向量分配新内存时，通常会将前一个大小加倍。由于向量永远不会缩小，如果我们以一种方式使用向量，导致大量添加和删除元素，这很容易成为一个内存问题，特别是对于内存较低的设备。了解这一点不应该阻止您使用向量，在正确的情况下实现时，这应该很少成为问题，并且如果出现问题，可以通过重构来轻松解决。
- en: Some perfect examples of when to use a vector would be in cases like; a list
    of players, character animation lists, player weapons, really any list that you
    might add to and remove from infrequently. This will avoid the possible memory
    issues while giving you access to vector's iterators, algorithms, and other benefits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用向量的完美例子包括；玩家列表，角色动画列表，玩家武器，任何你可能不经常添加或删除的列表。这将避免可能的内存问题，同时让你可以使用向量的迭代器、算法和其他优点。
- en: List
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'A **list** is another type of sequence container you are likely to see when
    developing games with C++. To create a list container of integer values the syntax
    would look something like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是在使用C++开发游戏时可能会看到的另一种序列容器类型。要创建一个整数值的列表容器，语法看起来会像这样：'
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The list container is quite different from the vector in its implementation
    and general usage in development. The key difference is that unlike a vector,
    the list container does not store all its elements in one large contiguous block
    of memory. Instead, it stores its elements as nodes in a doubly linked list. Where
    each of these nodes holds a pointer to the next and previous nodes. This, of course,
    makes the extra memory allocation issues of the vector disappear since only the
    memory for each element in the list is allocated beforehand. When a new element
    is added only memory for the new node is created, saving the wasted memory you
    might see in a vector implementation. This also allows elements to be added anywhere
    in the list with far better performance compared to a vector container. There
    are some drawbacks, though. Due to this setup of individual nodes in memory, each
    operation on the list will more than likely end up causing a memory allocation.
    With each node possibly scattered around memory in no guaranteed ordered, this
    constant memory allocation might be a potential issue on systems with slower dynamic
    memory. This also means that a list is slower to traverse through its elements
    than a vector is. Again this is not meant to discourage you from using lists in
    your projects. I would give the advice to use a list wherever you have a group
    of objects or elements that you plan on adding to or deleting from frequently.
    A good example would be of a list game objects or meshes to render in each frame.
    A list should not be thought of as a replacement for a vector. Each has its own
    advantages and disadvantages, finding the best choice for a solution is often
    the hardest part.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表容器在其实现和开发中的一般用法上与向量有很大的不同。关键的区别在于，与向量不同，列表容器不会将所有元素存储在一个大的连续内存块中。相反，它将其元素存储为双向链表中的节点。每个节点都保存着指向下一个和上一个节点的指针。当然，这使得向量的额外内存分配问题消失了，因为列表中只有每个元素的内存是预先分配的。当添加新元素时，只会创建新节点的内存，节省了在向量实现中可能看到的浪费内存。这也允许在列表中的任何位置添加元素，与向量容器相比，性能要好得多。然而，也有一些缺点。由于内存中的单独节点设置，列表上的每个操作很可能最终会导致内存分配。由于每个节点可能散布在内存中，没有保证的顺序，这种不断的内存分配可能是在动态内存较慢的系统上的潜在问题。这也意味着列表遍历其元素比向量要慢。但这并不是要阻止您在项目中使用列表。我建议在您经常添加或删除的对象或元素组中使用列表。一个很好的例子是在每一帧中渲染的游戏对象或网格的列表。列表不应被视为向量的替代品。每种都有其优点和缺点，找到最佳解决方案通常是最困难的部分。
- en: Finally, the last container we will take a look at is a commonly used **associative
    container**. Unlike sequence containers, associative containers do not preserve
    the relative positions of the elements in them. Instead associative containers
    are built for speed, more specifically element lookup speed. Without getting into
    **Big O notation**, these associative containers, and their corresponding algorithms
    far outperformed vector and list when it comes to looking up specific elements.
    The reason they are referred to as associative containers is that they usually
    provide a key/data pair that facilitates this faster lookup. It should be noted
    that sometimes the key in the container is the data itself. The one we will be
    focusing on here is the map container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将要看的最后一个容器是一个常用的**关联容器**。与序列容器不同，关联容器不保留其中元素的相对位置。相反，关联容器是为了速度而构建的，更具体地说是元素查找速度。不用进入**大O符号**，这些关联容器及其对应的算法在查找特定元素时远远优于向量和列表。它们被称为关联容器的原因是它们通常提供一个键/数据对，以便实现更快的查找。值得注意的是，有时容器中的键就是数据本身。我们将在这里关注的是地图容器。
- en: Map
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: Maps are very handy containers for a multiple of uses in game development. What
    makes maps unique compared to vectors or list, is that each map is made up of
    two pieces of data. The first piece of data is a key and the second is the actual
    element stored. This is what makes maps so performant at looking up elements.
    An easy way of thinking of this is that maps are like arrays, but instead of using
    integer values to index elements, maps use keys, that can be of any type, to index
    its elements. Maps even have a specialized `[]` operator that allows you to access
    elements using the familiar array syntax.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 地图在游戏开发中有多种用途。与向量或列表相比，地图的独特之处在于每个地图由两部分数据组成。第一部分数据是一个键，第二部分是实际存储的元素。这就是使地图在查找元素时如此高效的原因。一个简单的思考方式是，地图就像数组，但是它不是使用整数值来索引元素，而是使用可以是任何类型的键来索引其元素。地图甚至有一个专门的`[]`运算符，允许您使用熟悉的数组语法访问元素。
- en: 'To create a map with an integer as the key and strings as the element type
    or value, our code would look something like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个以整数作为键和字符串作为元素类型或值的地图，我们的代码看起来会像下面这样：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When it comes to memory usage, maps are different from both the list and vector
    containers. Maps do not store their data in contiguous blocks like vectors, instead
    they hold their elements in nodes, much like a list. The difference in how the
    list and map handle their allocation is in the way the nodes are structured. The
    nodes in a map have pointers to the next node and previous node, like the list,
    but these nodes are arranged in a tree pattern. This tree pattern autobalances
    itself with the addition and deletion of nodes. The good news is that this balancing
    act does not add any new allocations. The performance of a map is very similar
    to a list, since the memory management is similar, the only time you might see
    a difference is in the very slight overhead of the automatic balancing of the
    node tree.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存使用方面，地图与列表和向量容器都不同。地图不像向量那样将数据存储在连续的块中，而是将元素保存在节点中，就像列表一样。列表和地图处理它们的分配方式的不同之处在于节点的结构方式。地图中的节点具有指向下一个节点和上一个节点的指针，就像列表一样，但这些节点是以树状模式排列的。这种树状模式会随着节点的添加和删除而自动平衡。好消息是，这种平衡行为不会增加任何新的分配。地图的性能与列表非常相似，因为内存管理是相似的，唯一可能看到差异的时候是节点树的自动平衡所带来的非常轻微的开销。
- en: 'One way maps are often used is in the form of a dictionary. They provide very
    fast lookup of unique values through their key; because of this, some good example
    maps in game development are: a list of game elements with unique IDs, a list
    of multiplayer clients with unique IDs for keys, and for almost any situation
    in which you have a group of elements that you want to store with some sort of
    key-value pair.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 地图经常被用作字典的形式。它们通过键提供非常快速的唯一值查找；因此，在游戏开发中一些很好的地图示例包括：具有唯一ID的游戏元素列表，具有唯一ID的多人游戏客户端列表，以及几乎任何你想要以某种键值对存储的元素组。
- en: Templating
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Templates are a newer concept in the C++ language. Templates help solve the
    all too common issue of having to rewrite the same code when different datatypes
    or classes are being used. This allows us to write what is referred to as generic
    code. We can then use this generic code in other parts of our project. As of the
    C++14 standard, there are now three types of templates that can be used: **class
    templates**, **function templates**, and **variable templates**. Let''s take a
    closer look at each of them in the upcoming sections.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++语言中的一个较新概念。模板有助于解决当使用不同的数据类型或类时不得不重写相同代码的普遍问题。这使我们能够编写所谓的通用代码。然后我们可以在项目的其他部分使用这个通用代码。截至C++14标准，现在有三种可以使用的模板类型：**类模板**，**函数模板**和**变量模板**。让我们在接下来的部分更仔细地看看它们。
- en: Class templates
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类模板
- en: Using class templates, we can create abstract classes that can be defined without
    specifying what datatype will be handled by the functions of the class. This becomes
    very useful when building libraries and containers. In fact, the C++ Standard
    library makes extensive use of class templates, including the `vector` class we
    saw earlier in the chapter. Let's take a look at a simple implementation of a
    `Rectangle` class. This could be a useful class for finding screen coordinates,
    buttons and other GUI pieces, and even simple 2D collision detection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类模板，我们可以创建抽象类，可以在不指定类的函数将处理什么数据类型的情况下进行定义。在构建库和容器时，这变得非常有用。事实上，C++标准库广泛使用类模板，包括我们在本章中早些时候看到的`vector`类。让我们来看一个`Rectangle`类的简单实现。这可能是一个有用的类，用于查找屏幕坐标、按钮和其他GUI元素，甚至简单的2D碰撞检测。
- en: 'A basic implementation without using class templates will look something like
    this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用类模板的基本实现将看起来像这样：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This works fine in most cases, but if we want to use this rectangle in a different
    coordinate system that uses values of say 0.0 to 1.0, we will have to make some
    changes. We could just copy the code and change the integer datatypes to float,
    that would work just fine, but using class templates we can avoid this code duplication.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下这是有效的，但是如果我们想在使用0.0到1.0的值的不同坐标系中使用这个矩形，我们将不得不做一些改变。我们可以只是复制代码并将整数数据类型更改为浮点数，这样也可以正常工作，但是使用类模板我们可以避免这种代码重复。
- en: 'Using templates, the new `Rectangle` class will look something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板，新的`Rectangle`类将看起来像这样：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first change you will notice is the inclusion of `template<class T>` right
    before our class definition. This tells the compiler that this class is a template.
    The `T` is a placeholder for a datatype. The second change is that all the integer
    datatypes have been replaced with this placeholder. So now we can create a rectangle
    using the `int` datatype like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的第一个变化是在我们的类定义之前包含了`template<class T>`。这告诉编译器这个类是一个模板。`T`是一个数据类型的占位符。第二个变化是所有的整数数据类型都被替换为这个占位符。所以现在我们可以像这样使用`int`数据类型创建一个矩形：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the compiler comes across this line of code, it goes through the template
    class and replaces all the instances of the placeholder with `int`, and then compiles
    the new class on-the-fly. To create a rectangle using float values, we could then
    use the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到这行代码时，它会通过模板类并用`int`替换所有占位符的实例，然后即时编译新的类。使用浮点值创建一个矩形，我们可以使用以下代码：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can do this for any datatype we like; the only restriction is that the types
    must be supported in the operations of the class. If they are not, a runtime error
    will be thrown. An example of this would be a class template that has the multiplication
    function and is trying to use that template with a string.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对任何我们喜欢的数据类型这样做；唯一的限制是这些类型必须在类的操作中得到支持。如果不支持，就会抛出运行时错误。一个例子是一个具有乘法函数的类模板，试图使用该模板与一个字符串。
- en: Function templates
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数模板
- en: 'The concept of function templates is very similar to class templates; the big
    difference is that function templates do not need to be explicitly instantiated.
    They are created automatically based on the datatypes passed in. The following
    will swap two values, but it is not specific to any class type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板的概念与类模板非常相似；最大的区别是函数模板不需要显式实例化。它们是根据传入的数据类型自动创建的。以下将交换两个值，但它不特定于任何类类型：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can then pass integer values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以传递整数值：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In fact, you can use this function with any type that supports assignment operators
    and a copy constructor. The restriction here is that both datatypes must be of
    the same type. This is true even if the datatype has an implicit conversion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以将这个函数用于任何支持赋值运算符和复制构造函数的类型。这里的限制是两个数据类型必须是相同的类型。即使数据类型具有隐式转换，这也是正确的。
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Variable templates
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量模板
- en: 'The last type of template I want to mention quickly is the variable template,
    not to be confused with **variadic templates**. Introduced in C++14, the variable
    template allows the wrapping of a variable within a templated struct or class.
    The conical example often used is for the mathematic construct of pi:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我想快速提到的最后一种模板类型是变量模板，不要与**可变参数模板**混淆。在C++14中引入的变量模板允许将一个变量包装在一个模板化的结构或类中。经常使用的例子是数学构造中的pi：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This then means you can refer to `pi` as a `float`, `int`, or `double` variable
    and use it in generic functions, for example, to compute the area of a circle
    with a given radius:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将`pi`作为`float`、`int`或`double`变量，并在通用函数中使用它，例如，计算给定半径的圆的面积：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And again this templated function can be used with various datatypes, so you
    can return an area as an integer, a floating point value, or any other supported
    datatype. You may not see variable templates used that often, yet. They are still
    considered a new idea in C++, but it is important to be aware of their existence.
    They do have some unique cases and may one day help you solve a difficult problem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板函数可以用于各种数据类型，因此你可以返回一个整数、一个浮点数，或者任何其他支持的数据类型作为面积。你可能不经常看到变量模板的使用。它们在C++中仍然被认为是一个新的概念，但是了解它们的存在是很重要的。它们确实有一些独特的情况，也许有一天会帮助你解决一个困难的问题。
- en: As you can see, templates do have their benefits, and I encourage you to use
    them where it makes sense. However, it is important to note some of the possible
    drawbacks when implementing templates. The first potential drawback is that all
    templates must have their entire implementation in the same file, usually the
    header. The `export` keyword corrects this, but not all commercial compilers support
    it. Another drawback of templates is that they are notorious for being hard to
    debug. Compilers tend to give cryptic errors when the issue resides inside of
    the templated code. My biggest advice is to use them with caution, just like every
    other feature. Just because a feature is advanced does not mean it's a good fit.
    Finally, check your compiler for exact details on implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模板确实有它们的好处，我鼓励你在合适的地方使用它们。然而，重要的是要注意在实现模板时可能出现的一些潜在缺点。第一个潜在的缺点是所有的模板必须在同一个文件中有它们的整个实现，通常是头文件。`export`关键字可以纠正这一点，但并非所有商业编译器都支持它。模板的另一个缺点是它们以难以调试而臭名昭著。当问题存在于模板代码内部时，编译器往往会给出晦涩的错误。我的最大建议是谨慎使用它们，就像其他功能一样。仅仅因为一个功能是先进的，并不意味着它就是一个好选择。最后，查看你的编译器以获取实现的确切细节。
- en: Type inference and when to use it
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断及其使用时机
- en: With the C++11 standard came some very useful **type interference** capabilities.
    These new capabilities give programmers, even more, tools to create generic, flexible
    code. In this section, we will look at these new capabilities in more depth.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准带来了一些非常有用的**类型推断**能力。这些新的能力给程序员提供了更多的工具来创建通用、灵活的代码。在这一部分，我们将更深入地研究这些新的能力。
- en: 'We will begin with a new, powerful keyword. The `auto` keyword allows you to
    have the compiler infer the variable type, if possible, at the time of declaration.
    This means that instead of defining a variable like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的强大关键字开始。`auto`关键字允许您在声明时让编译器推断变量类型，如果可能的话。这意味着，与其像这样定义一个变量：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can now just use `auto`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以只使用`auto`：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: However, this is not the best use of the `auto` keyword, in fact, this is a
    perfect example of what you should not do. As tempting as it might be to use `auto`
    when declaring any variable, this not only adds completely unnecessary overhead
    to compiles, it makes your code harder to read and follow. That's what you should
    not do with `auto`, so what should you do with `auto`? Well, where `auto` really
    shows its helpfulness, is when it is used in concert with templates. When coupled
    with the `auto` keyword, templates can become extremely flexible and powerful.
    Let's take a look at a quick example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是`auto`关键字的最佳用法，事实上，这是一个完美的例子，说明你不应该这样做。尽管在声明任何变量时使用`auto`可能很诱人，但这不仅会给编译增加完全不必要的开销，还会使您的代码更难阅读和理解。这就是你不应该用`auto`做的事情，那么你应该怎么用`auto`呢？嗯，`auto`真正显示其帮助之处的地方是与模板一起使用。与`auto`关键字配合使用时，模板可以变得非常灵活和强大。让我们来看一个快速的例子。
- en: 'In this example, we have a simple templated function that creates some game
    objects for us, something like the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个简单的模板函数，为我们创建一些游戏对象，类似于以下内容：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To call this code, we will use the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这段代码，我们将使用以下代码：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code works fine, but it could be a little more flexible and easier to
    read with the use of the `auto` keyword. Our code will now look something like
    the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行良好，但使用`auto`关键字可以使其更加灵活和易于阅读。我们的代码现在看起来像这样：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And then our code to call this function will be:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用这个函数的代码将是：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While this is an oversimplification, it should allow you to see the possibilities
    that `auto` can provide. By not defining what type the object factory will return,
    we allow the factory more freedom in its implementation, which in return allows
    for greater uses of the factory in our code base.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个过度简化，但它应该让您看到`auto`可以提供的可能性。通过不定义对象工厂将返回的类型，我们允许工厂在其实现中更加自由，从而允许在我们的代码库中更广泛地使用工厂。
- en: 'One of the places you will tend to see the `auto` keyword in action, outside
    of templates, is in the declaration of iterators in for loops. This has become
    the common practice in a lot of the more modern libraries. You will often see
    for loops written like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板之外，您将经常看到`auto`关键字的应用之一是在for循环中迭代器的声明中。这已经成为许多更现代的库中的常见做法。您经常会看到for循环写成这样：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `auto` keyword has a helper keyword, `decltype`, which extracts the type
    from a variable. So where `auto` is used to let the compiler infer what the variable
    type is, the `decltype` is utilized to determine what a variable''s type is. This
    becomes very useful when you add in the last part of the `auto` keywords functionality,
    as a `return` value. Before C++11 and the `auto` keyword, `return` values had
    to be declared before the function name, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字有一个辅助关键字`decltype`，它从变量中提取类型。因此，`auto`用于让编译器推断变量类型是什么，而`decltype`用于确定变量的类型是什么。当您加入`auto`关键字功能的最后一部分作为`return`值时，这变得非常有用。在C++11之前和`auto`关键字之前，`return`值必须在函数名之前声明，如下所示：'
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This means that the `CreateObject` function must return a `TreeObject` type,
    but as mentioned earlier, letting the compiler infer what `objFactory.MakeObject();`
    returns allows greater flexibility. In order to infer the type of object returned
    from a function, we can use the concept of `auto`, `decltype`, and the new `return`
    syntax. Our new function will now look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`CreateObject`函数必须返回一个`TreeObject`类型，但正如前面提到的，让编译器推断`objFactory.MakeObject();`返回的对象类型可以提供更大的灵活性。为了推断函数返回的对象类型，我们可以使用`auto`、`decltype`和新的`return`语法的概念。我们的新函数现在看起来像这样：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Also note that `auto` and `decltype` do add some overhead to our compile time.
    In most cases this will be insignificant, but in certain circumstances it could
    become an issue, so be conscious of this when incorporating these new keywords
    in your codebase.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，`auto`和`decltype`会增加我们的编译时间开销。在大多数情况下，这将是微不足道的，但在某些情况下可能会成为一个问题，因此在将这些新关键字纳入您的代码库时要意识到这一点。
- en: As you continue to build more libraries and toolsets, having the ability to
    build more generic, flexible code will become crucial. Tricks like using `auto`,
    `decltype`, and the new `return` syntax are just some of the ways to accomplish
    this. In the next sections and chapters, we will see more of these useful concepts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您继续构建更多的库和工具集，构建更通用、灵活的代码的能力将变得至关重要。像使用`auto`、`decltype`和新的`return`语法这样的技巧只是实现这一目标的一些方法。在接下来的章节中，我们将看到更多有用的概念。
- en: Game programming patterns
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏编程模式
- en: A programming pattern or development pattern, simply put, is a solution to a
    commonly faced or reoccurring problem. It is a description or template that provides
    a solution that can be used in many different situations. These patterns are formalized
    best practices, often developed through years of iterations. By using patterns
    in your project, you can make your code more performant, stronger, and more adaptable.
    They allow you to build structured code that is decoupled by nature. Having this
    decoupling is what makes your code more generic and easier to work with. You no
    longer have to cram the entire program into your mind to understand what a particular
    section of code is trying to accomplish. Instead, you can focus on smaller chunks
    that function independently. This is the true power of object-oriented design.
    This decoupling will also make it easier to track down bugs during testing by
    isolating the issue or issues to a certain segment of code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 编程模式或开发模式，简单来说，是常见或经常遇到的问题的解决方案。它是一个描述或模板，提供了可以在许多不同情况下使用的解决方案。这些模式是正式的最佳实践，通常是通过多年的迭代开发而形成的。通过在项目中使用模式，你可以使你的代码更具性能、更强大和更具适应性。它们允许你构建结构化的代码，天生就是解耦的。这种解耦是使你的代码更通用且更易于使用的原因。你不再需要将整个程序塞进脑海中，以理解特定代码段试图实现什么。相反，你可以专注于独立运行的小块。这就是面向对象设计的真正力量。这种解耦也将使得在测试过程中更容易追踪错误，通过将问题隔离到某个代码段。
- en: Having a solid understanding of, at the least, the most fundamental patterns
    will be critical as you start to build your own libraries and engine structure.
    In the next few sections, we will look at some of these basic patterns.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 至少对最基本的模式有扎实的理解，将对你开始构建自己的库和引擎结构至关重要。在接下来的几节中，我们将看一些这些基本模式。
- en: Working with loops
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环进行工作
- en: Arguably, one of the most important concepts in game development is the concept
    of loops. If you have ever built a game before, I can almost guarantee that you
    have used some sort of loop. Even though loops are common, the particular implementation
    of a loop is often not. Patterns give developers guidelines and structure to build
    performant, flexible loops.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，游戏开发中最重要的概念之一是循环的概念。如果你以前曾经制作过游戏，我几乎可以保证你曾经使用过某种形式的循环。尽管循环很常见，但循环的特定实现通常并非如此。模式为开发人员提供了构建高性能、灵活循环的指导方针和结构。
- en: 'One of the most common loop patterns is the **game loop pattern**. The intent
    of the game loop pattern is to provide a mechanism to decouple the passage of
    game time from the user input and other events, regardless of the processor''s
    clock speed. An easy way to explain it is: a game loop runs continuously during
    the operation of the game, or during a specific state, see state machines in a
    later section. During this continuous looping, each tick or turn of the loop,
    we have a chance to update parts of the game. This usually includes updating the
    current game state, checking and updating any user input, without blocking, and
    a call to draw or render any game objects. Many platforms and almost all engines
    have their own implementation. It is important to note whether the platform or
    engine you are using does have their own game loop. If it does, you will then
    have to hook your code and loop structure into the provided mechanism.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的循环模式之一是**游戏循环模式**。游戏循环模式的目的是提供一种机制，将游戏时间的流逝与用户输入和其他事件分离，而不受处理器时钟速度的影响。简单来说，游戏循环在游戏运行期间或特定状态下持续运行，参见后面章节的状态机。在这个持续循环中，每个循环的时刻或轮次，我们都有机会更新游戏的各个部分。这通常包括更新当前游戏状态，检查和更新任何用户输入，而不会阻塞，并调用绘制或渲染任何游戏对象。许多平台和几乎所有引擎都有自己的实现。重要的是要注意你正在使用的平台或引擎是否有自己的游戏循环。如果有，你将需要将你的代码和循环结构连接到提供的机制中。
- en: As an example, the Unity game engine abstracts the looping process, they expose
    connectivity to the internal game loop through the `Update()` function inherited
    by all game objects. This Unity structure is an excellent example of how the game
    loop pattern can be combined with other patterns like the update pattern to build
    a cascading loop system that allows the main game loop to drive the internal looping
    mechanism of each object. We won't build a complete example right now, but as
    we continue through the book, we will see more of how structures like this are
    built. The next few sections will continue this idea of combining patterns to
    build a complete game system flow.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，Unity游戏引擎抽象了循环过程，它通过所有游戏对象继承的`Update()`函数暴露了与内部游戏循环的连接。这种Unity结构是游戏循环模式如何与其他模式（如更新模式）结合，构建一个级联循环系统的绝佳示例，允许主游戏循环驱动每个对象的内部循环机制。我们现在不会构建一个完整的示例，但随着我们继续阅读本书，我们将看到更多这样的结构是如何构建的。接下来的几节将继续探讨如何结合模式来构建完整的游戏系统流程。
- en: 'To help picture how a game loop is constructed, let''s take a look at a typical,
    slightly simple example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解游戏循环是如何构建的，让我们看一个典型的、稍微简单的例子：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first line of code, `double lastTime = getSystemTime();`, stores the time
    before the first run of the loop. Next we have a simple `while` loop, in this
    situation, the loop will continue to run while the variable `gameOver` is not
    true. Inside the `while` loop, first we get the current time. Next we create a
    `deltaTime` variable, which is the amount of time that has passed since the last
    step of the loop. We then make calls to run the other components of the game:
    `Input`, `Update`, and `Draw`. This is the key to the game loop pattern; we use
    this standard running loop to drive the game forward. You might notice that we
    pass `deltaTime` through to the `Update` method. This is another important component
    of the loop, without getting too deep into the update pattern, by passing along
    the time that has elapsed between loops we are able to modify things like the
    game object physics using proper time slices, which is important to keep everything
    in sink and looking smooth. This style of the game loop pattern implementation
    is called a **variable time step** pattern since the loop steps are based on the
    amount of time the update takes. The longer the update code takes, the longer
    the time between the steps will be. This means each step of the loop will determine
    how much real time has passed. Using this method means that the game will run
    at a consistent rate on different hardware, it also means users with powerful
    machines will be rewarded with smoother gameplay. This implementation is far from
    perfect though. It doesn''t optimize the rendering or deal with lag that can occur
    between steps, but it''s a good start. Understanding what is happening under the
    hood is a significant step. In the next section, we will look at a pattern that
    allows us to create code paths based on events, this coupled with loops is the
    natural evolution of the game system flow.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行，`double lastTime = getSystemTime();`，在循环的第一次运行之前存储了时间。接下来是一个简单的`while`循环，在这种情况下，只要变量`gameOver`不为真，循环就会继续运行。在`while`循环内，首先我们获取当前时间。接下来我们创建一个`deltaTime`变量，它是自上次循环步骤以来经过的时间。然后我们调用游戏的其他组件：`Input`，`Update`和`Draw`。这是游戏循环模式的关键；我们使用这个标准的运行循环来推动游戏向前发展。你可能会注意到我们将`deltaTime`传递给`Update`方法。这是循环的另一个重要组成部分，不深入研究更新模式，通过传递循环之间经过的时间，我们能够修改诸如游戏对象物理等东西，使用适当的时间片，这对保持一切同步和流畅非常重要。这种游戏循环模式实现的风格被称为**可变时间步**模式，因为循环步骤是基于更新所需的时间量。更新代码所需的时间越长，循环步骤之间的时间就越长。这意味着循环的每一步将决定经过了多少真实时间。使用这种方法意味着游戏将在不同硬件上以一致的速率运行，这也意味着拥有强大机器的用户将获得更流畅的游戏体验。然而，这种实现还远非完美。它没有优化渲染或处理步骤之间可能发生的延迟，但这是一个很好的开始。了解发生在幕后的事情是一个重要的步骤。在下一节中，我们将看一种允许我们基于事件创建代码路径的模式，这与循环的结合是游戏系统流的自然演变。
- en: State machines
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机
- en: The next pattern we will examine is the **state pattern**; more specifically,
    we will look at finite state machines. State machines are an extremely powerful
    engineering concept. While not a common pattern in most programming disciplines,
    except maybe AI development, finite state machines play a significant role in
    building branching code. It might be surprising to know that many mechanical logic
    circuits found in our day-to-day life are constructed from forms of finite state
    machines.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的下一个模式是**状态模式**；更具体地说，我们将看有限状态机。状态机是一个非常强大的工程概念。虽然在大多数编程学科中并不常见，除了可能是AI开发，有限状态机在构建分支代码中扮演着重要的角色。也许令人惊讶的是，我们日常生活中发现的许多机械逻辑电路都是由有限状态机的形式构建而成的。
- en: 'A real-world example would be a set of traffic lights, which changes state
    based on cars waiting (maybe not fast enough sometimes). A finite state machine
    can be boiled down to an abstract system where the machine can be in one, and
    only one, of a limited number of states. The machine will stay in this state,
    referred to as the current state, until an event or triggered condition causes
    a transition. Let''s look at an example that demonstrates this concept:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实世界的例子是一组交通信号灯，它根据等待的车辆改变状态（有时可能不够快）。有限状态机可以归结为一个抽象系统，其中机器只能处于有限数量的状态之一。机器将保持在这个状态，称为当前状态，直到事件或触发条件导致转换。让我们看一个演示这个概念的例子：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To begin with, we have an `enum` structure that houses our game states. Next,
    we create a `GameState` variable type to hold the current game state that the
    machine is in. Then in an `Update` loop, we implement a `switch case` construct
    that controls the flow of transitions from state to state. The key to this implementation
    is that each state of the machine has a transition state to the next. This keeps
    the machine running and allows us to perform different actions depending on the
    current state the machine is in. While this is probably one of the most basic
    forms of a game state machine, it does demonstrate the usefulness of the finite
    state pattern. As you move on to the creation of libraries and other components,
    you will start to see more and more uses for these incredible tools. There are
    many other, more complicated implementations and, even more, patterns to help
    describe them. Some of these will be seen in the later chapters of this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个包含游戏状态的`enum`结构。接下来，我们创建一个`GameState`变量类型来保存机器当前所处的游戏状态。然后在一个`Update`循环中，我们实现了一个控制从状态到状态转换流的`switch
    case`结构。这种实现的关键在于机器的每个状态都有一个到下一个状态的转换状态。这保持了机器的运行，并允许我们根据机器当前的状态执行不同的操作。虽然这可能是游戏状态机的最基本形式之一，但它确实展示了有限状态模式的用处。当你开始创建库和其他组件时，你会开始看到这些令人难以置信的工具的更多用途。还有许多其他更复杂的实现和更多的模式来帮助描述它们。这些将在本书的后面章节中看到。
- en: Event listeners
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件监听器
- en: Very often in the game development process, you will find cases where you have
    a need for certain code to execute based on some user input, or from a condition
    fired from another chunk of code. Maybe you just need a solid way for game object
    communicate. This is where the idea of using an event or message passing system
    comes in. Numerous patterns have been created to help solve this problem, including
    **Overseer**, **Model View Controller**, and others. Each of these patterns implements
    a different mechanic for handling events; many actually build off of each other.
    However, before we jump into using one of these patterns, I believe it is important
    to understand the foundation of what is happening under the hood to power all
    these solutions. By building our own solution, we will gain a better understanding
    of the problem, and more appreciation for the patterns that solve it. In our example,
    we will use the concepts we have learned throughout the chapter to build a simple,
    but reusable event systems that could be used in your own projects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发过程中经常会遇到这样的情况，即根据用户输入或来自其他代码块触发的条件执行某些代码。也许你只是需要一种可靠的方式让游戏对象进行通信。这就是使用事件或消息传递系统的想法产生的地方。已经创建了许多模式来帮助解决这个问题，包括**Overseer**，**Model
    View Controller**等。这些模式中的每一个都实现了处理事件的不同机制；许多实际上是基于彼此构建的。然而，在我们开始使用这些模式之前，我认为了解在幕后支持所有这些解决方案的基础是很重要的。通过构建我们自己的解决方案，我们将更好地理解问题，并更加欣赏解决它的模式。在我们的示例中，我们将使用本章学到的概念来构建一个简单但可重用的事件系统，可以在您自己的项目中使用。
- en: 'The first approach we could take uses the simple version of the state machine
    we just looked at. In this approach, we use a `switch case` construct to branch
    the code based on the type of event passed in. To save space and time, some basic
    structure code has been omitted:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的第一种方法是使用我们刚刚看到的状态机的简单版本。在这种方法中，我们使用`switch case`结构来根据传入的事件类型分支代码。为了节省空间和时间，一些基本结构代码已被省略：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is a quick and dirty implementation, and will work in some very basic situations.
    If we use a struct or union for our event type, we could add some simple message
    capability which would make it even more useful. Unfortunately, this approach
    ultimately has too many significant issues. First is the fact that we need to
    have a single source of event types. We then have to edit this source every time
    we want to add a new event type. Second is the `switch case` construct, again
    every time we wish to add a new event type we have to append and modify this section.
    All this is very tedious, prone to errors, and is bad design in an OOP-enabled
    language.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速而粗糙的实现，在一些非常基本的情况下可以工作。如果我们为我们的事件类型使用结构体或联合体，我们可以添加一些简单的消息功能，这将使其更加有用。不幸的是，这种方法最终存在太多重大问题。首先是我们需要有一个事件类型的单一来源。然后我们必须每次想要添加新的事件类型时编辑这个来源。其次是`switch
    case`结构，同样，每次我们希望添加新的事件类型时，我们都必须追加和修改这个部分。所有这些都非常繁琐，容易出错，并且在面向对象的语言中是不好的设计。
- en: A second approach we can take relies on the capabilities of **Run-time type
    information** (**RTTI**), which is the concept of determining the type of a variable
    at runtime. Using RTTI gives us the ability to use `dynamic_cast` to determine
    the event type in our solution. I should point out that not all RTTI implementations
    are the same, and may not be turned on by default in all compilers. Check your
    compiler's documentation for exact information.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的第二种方法依赖于**运行时类型信息**（**RTTI**）的能力，这是在运行时确定变量类型的概念。使用RTTI使我们能够在解决方案中使用`dynamic_cast`来确定事件类型。我应该指出，并非所有的RTTI实现都是相同的，并且可能并非在所有编译器中默认打开。查看您的编译器的文档以获取确切信息。
- en: 'To start off with, we create a simple base class for all of the specific events
    we will create:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们将创建的所有特定事件创建一个简单的基类：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now it is simply a matter of using `dynamic_cast` to determine the type of
    event and passing along the message info to the object''s own handling function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要使用`dynamic_cast`来确定事件的类型，并将消息信息传递给对象自己的处理函数：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is a more elegant solution than the first one we saw. It provides more
    flexibility and is easier to maintain. However, we can refactor this code to make
    it even simpler. Using the concept of templates we learned earlier, and good old
    fashion overloading, our new code can be structured like so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比我们看到的第一个更优雅的解决方案。它提供了更多的灵活性，并且更容易维护。然而，我们可以重构这段代码，使其更加简单。使用我们之前学到的模板的概念，以及老式的重载，我们的新代码可以被构造如下：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Like the other examples in this chapter, this example is meant to be basic.
    While it is true that this new approach is cleaner and more adaptable than the
    first, it does have some drawbacks of its own. This includes the overhead of `dynamic_cast`,
    which is entirely dependent on the structure of the class hierarchy. The problem
    of maintenance and error-prone code still exists with the `if...else` chain. Plus,
    we also have the bigger, much more important issue of improper type detection.
    For example, with this approach, if we have a type that is inherited from another,
    say a `LargeExplosion` class from the `Explosion` class. If the queries to the
    object's type are out of order, the event pointer is cast to the `Explosion` class
    first, when in actuality it is pointing to the `LargeExplosion` class, the compiler
    will improperly detect the type and call the wrong version of the function. A
    somewhat more ideal solution would be to have an `EventHandler` class that would
    handle the registration, storage, and polymorphic functions for all events. You
    could then have member function handlers that would implement specific event types,
    which could, in turn, inherit from a handler function base class. This would solve
    many of the issues we have seen with the other two approaches while giving us
    a more generic, reusable implementation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的其他示例一样，这个示例是基本的。虽然这种新方法比第一种更清晰、更具适应性，但它也有一些缺点。这包括`dynamic_cast`的开销，这完全取决于类层次结构。维护和容易出错的代码问题仍然存在于`if...else`链中。此外，我们还有更重要的不正确类型检测的问题。例如，使用这种方法，如果我们有一个从另一个类继承的类型，比如从`Explosion`类继承的`LargeExplosion`类。如果对对象类型的查询顺序不正确，事件指针首先被转换为`Explosion`类，而实际上它指向`LargeExplosion`类，编译器将不正确地检测类型并调用函数的错误版本。一个更理想的解决方案是有一个`EventHandler`类，它将处理所有事件的注册、存储和多态函数。然后你可以有成员函数处理程序来实现特定的事件类型，这些成员函数处理程序可以从处理程序函数基类继承。这将解决我们在其他两种方法中看到的许多问题，同时给我们一个更通用、可重复使用的实现。
- en: We'll stop our implementation here, though. Since event handling systems play
    such a strong role in many different parts of game systems, from the toolchain
    to user input and networking, we will see a lot more of these patterns and techniques
    used throughout the rest of the book.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里停止我们的实现。由于事件处理系统在游戏系统的许多不同部分中起着如此重要的作用，从工具链到用户输入和网络，我们将在本书的其余部分中看到更多这些模式和技术的应用。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a lot in this chapter. We discussed some of the more advanced C++
    topics used in modern game development. We looked at inheritance and polymorphism,
    pointers, referencing and the common STL generic containers. The concept of templating
    and building generic code with class, function, and variable templates. Type inference
    and the new language keywords `auto` and `decltype` and their uses in combination
    with the new `return` value syntax. Finally, we closed out the chapter looking
    at some core game patterns used today.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。我们讨论了一些现代游戏开发中使用的更高级的C++主题。我们看了继承和多态性，指针，引用和常见的STL通用容器。模板化的概念以及使用类、函数和变量模板构建通用代码。类型推断和新语言关键字`auto`和`decltype`以及它们与新的`return`值语法的组合使用。最后，我们在本章结束时看了一些当今使用的核心游戏模式。
- en: In the next chapter, we will look at how we can use these key concepts to create
    core libraries that can be used and reused in our game development projects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用这些关键概念来创建可以在我们的游戏开发项目中使用和重复使用的核心库。
