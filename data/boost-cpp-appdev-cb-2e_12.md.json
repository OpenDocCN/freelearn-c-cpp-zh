["```cpp\n#include <boost/graph/adjacency_list.hpp> \n#include <string> \n\ntypedef std::string vertex_t; \ntypedef boost::adjacency_list< \n    boost::vecS \n    , boost::vecS \n    , boost::bidirectionalS \n    , vertex_t \n> graph_type; \n```", "```cpp\nint main() {\n    graph_type graph; \n```", "```cpp\n    static const std::size_t vertex_count = 5; \n    graph.m_vertices.reserve(vertex_count); \n```", "```cpp\n    typedef boost::graph_traits<\n        graph_type\n    >::vertex_descriptor descriptor_t;\n\n    descriptor_t cpp\n        = boost::add_vertex(vertex_t(\"C++\"), graph);\n    descriptor_t stl\n        = boost::add_vertex(vertex_t(\"STL\"), graph);\n    descriptor_t boost\n        = boost::add_vertex(vertex_t(\"Boost\"), graph);\n    descriptor_t guru\n        = boost::add_vertex(vertex_t(\"C++ guru\"), graph);\n    descriptor_t ansic\n        = boost::add_vertex(vertex_t(\"C\"), graph);\n```", "```cpp\n    boost::add_edge(cpp, stl, graph); \n    boost::add_edge(stl, boost, graph); \n    boost::add_edge(boost, guru, graph); \n    boost::add_edge(ansic, guru, graph); \n} // end of main()\n```", "```cpp\ninline void find_and_print(\n    const graph_type& graph, boost::string_ref name)\n{\n```", "```cpp\n    typedef typename boost::graph_traits<\n        graph_type\n    >::vertex_iterator vert_it_t;\n\n    vert_it_t it, end;\n    boost::tie(it, end) = boost::vertices(graph);\n```", "```cpp\n    typedef typename boost::graph_traits<\n        graph_type\n    >::vertex_descriptor desc_t;\n\n    for (; it != end; ++ it) {\n        const desc_t desc = *it;\n        const vertex_t& vertex = boost::get(\n            boost::vertex_bundle, graph\n        )[desc];\n\n        if (vertex == name.data()) {\n            break;\n        }\n    }\n\n    assert(it != end);\n    std::cout << name << '\\n';\n} /* find_and_print */\n```", "```cpp\n vertex_descriptor desc = boost::add_vertex(graph);\n boost::get(boost::vertex_bundle, g_)[desc] = std::move(vertex_data);\n```", "```cpp\n#include <boost/graph/graphviz.hpp>\n\nstd::ostream& operator<<(std::ostream& out, const graph_type& g) {\n    detail::vertex_writer<graph_type> vw(g);\n    boost::write_graphviz(out, g, vw);\n\n    return out;\n}\n```", "```cpp\n#include <iosfwd>\n\nnamespace detail {\n    template <class GraphT>\n    class vertex_writer {\n        const GraphT& g_;\n\n    public:\n        explicit vertex_writer(const GraphT& g)\n            : g_(g)\n        {}\n\n        template <class VertexDescriptorT>\n        void operator()(\n            std::ostream& out,\n            const VertexDescriptorT& d) const\n        {\n            out << \" [label=\\\"\"\n                << boost::get(boost::vertex_bundle, g_)[d] \n                << \"\\\"]\"; \n        }\n    }; // vertex_writer\n} // namespace detail\n```", "```cpp\n    $ dot -Tpng -o dot.png\n\n    digraph G {\n    0 [label=\"C++\"];\n    1 [label=\"STL\"];\n    2 [label=\"Boost\"];\n    3 [label=\"C++ guru\"];\n    4 [label=\"C\"];\n    0->1 ;\n    1->2 ;\n    2->3 ;\n    4->3 ;\n    }\n\n```", "```cpp\n#include <boost/config.hpp> \n#include <boost/random/random_device.hpp> \n#include <boost/random/uniform_int_distribution.hpp>\n```", "```cpp\nint main() {\n    static const std::string provider = \n#ifdef BOOST_WINDOWS \n        \"Microsoft Strong Cryptographic Provider\" \n#else \n        \"/dev/urandom\" \n#endif \n    ; \n```", "```cpp\n    boost::random_device device(provider); \n```", "```cpp\n    boost::random::uniform_int_distribution<unsigned short> random(1000);\n```", "```cpp\n#include <boost/math/special_functions.hpp> \n#include <cassert> \n```", "```cpp\ntemplate <class T> \nvoid check_float_inputs(T value) { \n    assert(!boost::math::isinf(value)); \n    assert(!boost::math::isnan(value)); \n```", "```cpp\n    if (boost::math::signbit(value)) { \n        value = boost::math::changesign(value); \n    } \n\n    // ... \n} // check_float_inputs \n```", "```cpp\n#include <stdexcept> \nstruct foo { \n    int val_; \n\n    operator int() const; \n    bool is_not_null() const; \n    void throws() const; // throws(std::logic_error) \n}; \n```", "```cpp\n#define BOOST_TEST_MODULE test_module_name \n#include <boost/test/unit_test.hpp> \n```", "```cpp\nBOOST_AUTO_TEST_CASE(test_no_1) { \n```", "```cpp\n    foo f1 = {1}, f2 = {2}; \n    BOOST_CHECK(f1.is_not_null());\n```", "```cpp\n    BOOST_CHECK_NE(f1, f2); \n```", "```cpp\n    BOOST_CHECK_THROW(f1.throws(), std::logic_error); \n} // BOOST_AUTO_TEST_CASE(test_no_1) \n```", "```cpp\nBOOST_AUTO_TEST_CASE(test_no_2) { \n    foo f1 = {1}, f2 = {2}; \n    BOOST_REQUIRE_NE(f1, f2); \n    // ... \n} // BOOST_AUTO_TEST_CASE(test_no_2) \n```", "```cpp\nRunning 2 test cases... \nmain.cpp(15): error in \"test_no_1\": check f1.is_not_null() failed \nmain.cpp(17): error in \"test_no_1\": check f1 != f2 failed [0 == 0] \nmain.cpp(19): error in \"test_no_1\": exception std::logic_error is expected \nmain.cpp(24): fatal error in \"test_no_2\": critical check f1 != f2 failed [0 == 0] \n\n*** 4 failures detected in test suite \"test_module_name\" \n```", "```cpp\n#define BOOST_TEST_MODULE test_module_name \n#include <boost/test/unit_test.hpp> \n```", "```cpp\n// developer1.cpp \n#include <boost/test/unit_test.hpp> \n#include \"foo.hpp\" \nBOOST_AUTO_TEST_CASE(test_no_1) { \n    // ... \n} \n// developer2.cpp \n#include <boost/test/unit_test.hpp> \n#include \"foo.hpp\" \nBOOST_AUTO_TEST_CASE(test_no_2) { \n    // ... \n} \n```", "```cpp\n    ./testing_advanced -run=test_no_1\n```", "```cpp\n    ./testing_advanced -run=test_no_1,test_no_2\n```", "```cpp\n#include <boost/gil/gil_all.hpp> \n#include <boost/gil/extension/io/png_dynamic_io.hpp> \n#include <string> \n```", "```cpp\nint main(nt argc, char *argv[]) {\n    typedef boost::mpl::vector<\n            boost::gil::gray8_image_t,\n            boost::gil::gray16_image_t,\n            boost::gil::rgb8_image_t\n    > img_types;\n```", "```cpp\n    std::string file_name(argv[1]); \n    boost::gil::any_image<img_types> source; \n    boost::gil::png_read_image(file_name, source);\n```", "```cpp\n    boost::gil::apply_operation( \n        view(source), \n        negate() \n    ); \n```", "```cpp\n    boost::gil::png_write_view(\"negate_\" + file_name, const_view(source)); \n```", "```cpp\nstruct negate { \n    typedef void result_type; // required \n\n    template <class View> \n    void operator()(const View& source) const { \n        // ... \n    } \n}; // negate \n```", "```cpp\ntypedef typename View::value_type value_type; \ntypedef typename boost::gil::channel_type<value_type>::type channel_t; \n```", "```cpp\nconst std::size_t channels = boost::gil::num_channels<View>::value; \nconst channel_t max_val = (std::numeric_limits<channel_t>::max)(); \n\nfor (unsigned int y = 0; y < source.height(); ++y) { \n    for (unsigned int x = 0; x < source.width(); ++x) { \n        for (unsigned int c = 0; c < channels; ++c) { \n            source(x, y)[c] = max_val - source(x, y)[c]; \n        } \n    } \n} \n```"]