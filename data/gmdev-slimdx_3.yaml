- en: Chapter 3. Rendering 2D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。渲染2D图形
- en: One of the biggest aspects in a video game is the graphics. It's why we call
    them video games after all! So how do we create images on the screen? As we did
    with user input in the previous chapter, we have a couple of options here. They
    are **Direct2D** and **Direct3D** . We will focus on Direct2D in this chapter
    and save Direct3D for a later chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，最大的一个方面就是图形。这也是为什么我们称之为视频游戏！那么我们如何在屏幕上创建图像呢？就像我们在上一章中处理用户输入一样，我们这里有几个选择。它们是**Direct2D**和**Direct3D**。在本章中，我们将专注于Direct2D，并将Direct3D留到以后的章节中。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a Direct2D game window class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Direct2D游戏窗口类
- en: Drawing a rectangle on the screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上绘制矩形
- en: Creating a 2D tile-based game world and entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基于2D瓦片的游戏世界和实体
- en: Creating a Direct2D game window class
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Direct2D游戏窗口类
- en: We are finally ready to put some graphics on the screen! The first step for
    us is to create a new game window class that will use Direct2D. This new game
    window class will derive from our original game window class, while adding the
    Direct2D functionality.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好在屏幕上放置一些图形了！对我们来说，第一步是创建一个新的游戏窗口类，它将使用Direct2D。这个新的游戏窗口类将派生自我们的原始游戏窗口类，同时添加Direct2D功能。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll need to download the code for this chapter as some code is omitted to
    save space.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要下载本章的代码，因为为了节省空间，一些代码被省略了。
- en: 'Open Visual Studio and we will get started with our `Ch03` project. Add a new
    class to the `Ch03` project called `GameWindow2D`. We need to change its declaration
    to:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio，我们将开始我们的`Ch03`项目。向`Ch03`项目添加一个名为`GameWindow2D`的新类。我们需要将其声明更改为：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it inherits from the `GameWindow` class meaning that it has
    all of the public and protected members of the `GameWindow` class, as though we
    had implemented them again in this class. It also implements the `IDisposable`
    interface, just as the `GameWindow` class does. Also, don't forget to add a reference
    to SlimDX to this project if you haven't already.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它继承自`GameWindow`类，这意味着它具有`GameWindow`类的所有公共和受保护成员，就像我们在这个类中再次实现了它们一样。它还实现了`IDisposable`接口，就像`GameWindow`类一样。另外，如果您还没有这样做，请别忘了将SlimDX添加到这个项目中。
- en: 'We need to add some `using` statements to the top of this class file as well.
    They are all the same `using` statements that the `GameWindow` class has, plus
    one more. The new one is `SlimDX.Direct2D`. They are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在这个类文件顶部添加一些`using`语句。它们都是`GameWindow`类中相同的`using`语句，再加上一个。新的一个是`SlimDX.Direct2D`。它们如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to create a handful of member variables:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一些成员变量：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first variable is a `WindowRenderTarget` object. The term **render target**
    is used to refer to the surface we are going to draw on. In this case, it is our
    game window. However, this is not always the case. Games can render to other places
    as well. For example, rendering into a texture object is used to create various
    effects. One example would be a simple security camera effect. Say, we have a
    security camera in one room and a monitor in another room. We want the monitor
    to display what our security camera sees. To do this, we can render the camera's
    view into a texture, which can then be used to texture the screen of the monitor.
    Of course, this has to be re-done in every frame so that the monitor screen shows
    what the camera is currently seeing. This idea is useful in 2D too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量是一个`WindowRenderTarget`对象。术语**渲染目标**用于指代我们将要绘制的表面。在这种情况下，它就是我们的游戏窗口。然而，情况并不总是如此。游戏也可以渲染到其他地方。例如，将渲染到纹理对象用于创建各种效果。一个例子就是一个简单的安全摄像头效果。比如说，我们在一个房间里有一个安全摄像头，在另一个房间里有一个监视器。我们想让监视器显示安全摄像头所看到的内容。为此，我们可以将摄像头的视图渲染到纹理中，然后可以使用这个纹理来纹理化监视器的屏幕。当然，这必须在每一帧重新执行，以便监视器屏幕显示摄像头当前看到的内容。这个想法在2D中也很实用。
- en: Back to our member variables, the second one is a `Factory` object that we will
    be using to set up our Direct2D stuff. It is used to create Direct2D resources
    such as `RenderTargets`. The third variable is a `PathGeometry` object that will
    hold the geometry for the first thing we will draw, which will be a rectangle.
    The last three variables are all `SolidColorBrush` objects. We use these to specify
    the color we want to draw something with. There is a little more to them than
    that, but that's all we need right now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的成员变量，第二个是一个`Factory`对象，我们将用它来设置我们的Direct2D相关内容。它用于创建Direct2D资源，例如`RenderTargets`。第三个变量是一个`PathGeometry`对象，它将保存我们将要绘制的第一个图形的几何形状，这将是一个矩形。最后三个变量都是`SolidColorBrush`对象。我们使用这些对象来指定我们想要用其绘制的颜色。它们还有更多功能，但现阶段我们只需要这些。
- en: The constructor
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Let''s turn our attention now to the constructor of our Direct2D game window
    class. It will do two things. Firstly, it will call the base class constructor
    (remember the base class is the original `GameWindow` class), and it will then
    get our Direct2D stuff initialized. The following is the initial code for our
    constructor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向我们的Direct2D游戏窗口类的构造函数。它将做两件事。首先，它将调用基类构造函数（记住基类是原始的`GameWindow`类），然后初始化我们的Direct2D相关内容。以下是我们构造函数的初始代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the line starting with a colon is calling the constructor
    of the base class for us. This ensures that everything inherited from the base
    class is initialized. In the body of the constructor, the first line creates a
    new `Factory` object and stores it in our `m_Factory` member variable. Next, we
    create a `WindowRenderTargetProperties` object and store the handle of our `RenderForm`
    object in it. Note that `FormObject` is one of the properties defined in our `GameWindow`
    base class in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    but it is one of those properties that we haven't discussed in detail in the book.
    You can see it in the downloadable code for this book. Remember that the `RenderForm`
    object is a SlimDX object that represents a window for us to draw on. The next
    line saves the size of our game window in the `PixelSize` property. The `WindowRenderTargetProperties`
    object is basically how we specify the initial configuration for a `WindowRenderTarget`
    object when we create it. The last line in our constructor creates our `WindowRenderTarget`
    object, storing it in our `m_RenderTarget` member variable. The two parameters
    we pass in are our `Factory` object and the `WindowRenderTargetProperties` object
    we just created. A `WindowRenderTarget` object is a render target that refers
    to the client area of a window. We use the `WindowRenderTarget` object to draw
    in a window.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以冒号开始的行是在为我们调用基类构造函数。这确保了从基类继承的所有内容都被初始化。在构造函数的主体中，第一行创建了一个新的`Factory`对象，并将其存储在我们的`m_Factory`成员变量中。接下来，我们创建了一个`WindowRenderTargetProperties`对象，并将我们的`RenderForm`对象的句柄存储在其中。请注意，`FormObject`是我们定义在[第1章](ch01.html
    "第1章。入门")，*入门*中`GameWindow`基类中的一个属性，但我们没有在书中详细讨论这个属性。你可以在本书的可下载代码中看到它。记住，`RenderForm`对象是一个SlimDX对象，它代表了一个我们可以绘制的窗口。下一行将游戏窗口的大小保存到`PixelSize`属性中。`WindowRenderTargetProperties`对象基本上是我们创建`WindowRenderTarget`对象时指定其初始配置的方式。构造函数中的最后一行创建我们的`WindowRenderTarget`对象，并将其存储在我们的`m_RenderTarget`成员变量中。我们传递的两个参数是我们刚刚创建的`Factory`对象和`WindowRenderTargetProperties`对象。`WindowRenderTarget`对象是一个指向窗口客户端区域的渲染目标。我们使用`WindowRenderTarget`对象在窗口中绘制。
- en: Creating our rectangle
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的矩形
- en: 'Now that our render target is set up, we are ready to draw stuff, but first
    we need to create something to draw! So, we will add a bit more code at the bottom
    of our constructor. First, we need to initialize our three `SolidColorBrush` objects.
    Add these three lines of code at the bottom of the constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了渲染目标，我们准备开始绘制内容，但首先我们需要创建一些可以绘制的东西！因此，我们将在构造函数的底部添加一些额外的代码。首先，我们需要初始化我们的三个`SolidColorBrush`对象。在构造函数的底部添加以下三行代码：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is fairly simple. For each brush, we pass in two parameters. The first
    parameter is the render target we will use this brush on. The second parameter
    is the color of the brush, which is an **ARGB** (**Alpha Red Green Blue**) value.
    The first parameter we give for the color is `1.0f`. The `f` character on the
    end indicates that this number is of the `float` data type. We set alpha to `1.0`
    because we want the brush to be completely opaque. A value of `0.0` will make
    it completely transparent, and a value of `0.5` will be 50 percent transparent.
    Next, we have the red, green, and blue parameters. These are all `float` values
    in the range of `0.0` to `1.0` as well. As you can see for the red brush, we set
    the red channel to `1.0f` and the green and blue channels are both set to `0.0f`.
    This means we have maximum red, but no green or blue in our color.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单。对于每个画笔，我们传入两个参数。第一个参数是我们将在其上使用此画笔的渲染目标。第二个参数是画笔的颜色，它是一个 **ARGB**（**Alpha
    红绿蓝**）值。我们给颜色的第一个参数是 `1.0f`。末尾的 `f` 字符表示这个数字是 `float` 数据类型。我们将 alpha 设置为 `1.0`，因为我们希望画笔是完全不透明的。值为
    `0.0` 将使其完全透明，值为 `0.5` 将是 50% 透明。接下来，我们有红色、绿色和蓝色参数。这些都是在 `0.0` 到 `1.0` 范围内的 `float`
    值。正如您所看到的，对于红色画笔，我们将红色通道设置为 `1.0f`，绿色和蓝色通道都设置为 `0.0f`。这意味着我们颜色中有最大红色，但没有绿色或蓝色。
- en: 'With our `SolidColorBrush` objects set up, we now have three brushes we can
    draw with, but we still lack something to draw! So, let''s fix that by adding
    some code to make our rectangle. Add this code to the end of the constructor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了 `SolidColorBrush` 对象，现在我们有三个画笔可以用来绘制，但我们仍然缺少绘制的内容！所以，让我们通过添加一些代码来创建我们的矩形。将以下代码添加到构造函数的末尾：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is a bit longer, but it's still fairly simple. The first line creates
    a new `PathGeometry` object and stores it in our `m_Geometry` member variable.
    The next line starts the `using` block and creates a new `GeometrySink` object
    that we will use to build the geometry of our rectangle. The `using` block will
    automatically dispose of the `GeometrySink` object for us when program execution
    reaches the end of the `using` block.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码稍微长一些，但仍然相当简单。第一行创建了一个新的 `PathGeometry` 对象，并将其存储在我们的 `m_Geometry` 成员变量中。下一行开始
    `using` 块，并创建了一个新的 `GeometrySink` 对象，我们将使用它来构建矩形的几何形状。`using` 块将在程序执行到达 `using`
    块的末尾时自动为我们释放 `GeometrySink` 对象。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `using` blocks only work with objects that implement the `IDisposable` interface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 块仅与实现 `IDisposable` 接口的对象一起工作。'
- en: The next four lines calculate where each edge of our rectangle will be. For
    example, the first line calculates the vertical position of the top edge of the
    rectangle. In this case, we are making the rectangle's top edge be 25 percent
    of the way down from the top of the screen. Then, we do the same thing for the
    other three sides of our rectangle. The second group of four lines of code creates
    four `Point` objects and initializes them using the values we just calculated.
    These four `Point` objects represent the corners of our rectangle. A point is
    also often referred to as a **vertex**. When we have more than one vertex, we
    call them **vertices** (pronounced as *vert-is-ces*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四行计算矩形的每条边的位置。例如，第一行计算矩形顶边的垂直位置。在这种情况下，我们使矩形的顶边从屏幕顶部向下延伸的 25%。然后，我们对矩形的其他三边做同样的处理。第二组四行代码创建了四个
    `Point` 对象，并使用我们刚刚计算出的值初始化它们。这四个 `Point` 对象代表矩形的角点。一个点也常被称为 **顶点**。当我们有多个顶点时，我们称它们为
    **顶点**（发音为 *vert-is-ces*）。
- en: The final group of code has six lines. They use the `GeometrySink` and the `Point`
    objects we just created to set up the geometry of our rectangle inside the `PathGeometry`
    object. The first line uses the `BeginFigure()` method to begin the creation of
    a new geometric figure. The next three lines each add one more line segment to
    the figure by adding another point or vertex to it. With all four vertices added,
    we then call the `EndFigure()` method to specify that we are done adding vertices.
    The last line calls the `Close()` method to specify that we are finished adding
    geometric figures, since we can have more than one if we want. In this case, we
    are only adding one geometric figure, our rectangle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码有六行。它们使用我们刚刚创建的`GeometrySink`和`Point`对象来设置矩形在`PathGeometry`对象内部的几何形状。第一行使用`BeginFigure()`方法开始创建一个新的几何图形。接下来的三行各自通过添加另一个点或顶点来向图形添加一个线段。当所有四个顶点都添加完毕后，我们调用`EndFigure()`方法来指定我们已完成顶点的添加。最后一行调用`Close()`方法来指定我们已完成几何图形的添加，因为我们可能想要添加多个。在这种情况下，我们只添加了一个几何图形，即我们的矩形。
- en: Drawing our rectangle
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制我们的矩形
- en: 'Since our rectangle never changes, we don''t need to add any code to our `UpdateScene()`
    method. We will override the base class''s `UpdateScene()` method anyway, in case
    we need to add some code in here later, which is given as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的矩形从不改变，所以我们不需要在我们的`UpdateScene()`方法中添加任何代码。无论如何，我们都会覆盖基类的`UpdateScene()`方法，以防我们以后需要在这里添加一些代码，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we only have one line of code in this `override` modifier of
    the base class's `UpdateScene()` method. It simply calls the base class version
    of this method. This is important because the base class's `UpdateScene()` method
    contains our code that gets the latest user input data each frame, as you may
    recall from the previous chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这个基类`UpdateScene()`方法的`override`修饰符中只有一行代码。它只是调用基类版本的此方法。这很重要，因为基类的`UpdateScene()`方法包含我们每帧获取最新用户输入数据的代码，您可能还记得上一章的内容。
- en: 'Now, we are finally ready to write the code that will draw our rectangle on
    the screen! We will override the `RenderScene()` method so we can add our custom
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好编写代码，将我们的矩形绘制到屏幕上了！我们将覆盖`RenderScene()`方法，以便我们可以添加我们的自定义代码：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we have an `if` statement, which happens to be identical to the one we
    put in the base class's `RenderScene()` method. This is because we are not calling
    the base class's `RenderScene()` method, since the only code in it is this `if`
    statement. Not calling the base class version of this method will give us a slight
    performance boost, since we don't have the overhead of that function call. We
    could do the same thing with the `UpdateScene()` method as well. In this case
    we didn't though, because the base class version of that method has a lot more
    code in it. In your own projects you may want to copy and paste that code into
    your override of the `UpdateScene()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个`if`语句，碰巧与我们在基类的`RenderScene()`方法中放置的那个相同。这是因为我们没有调用基类的`RenderScene()`方法，因为其中唯一的代码就是这个`if`语句。不调用这个方法的基类版本将给我们带来轻微的性能提升，因为我们没有函数调用的开销。我们也可以用`UpdateScene()`方法做同样的事情。在这种情况下我们没有这样做，因为基类版本的该方法中有很多代码。在你的项目中，你可能想要将那段代码复制粘贴到你的`UpdateScene()`方法覆盖版本中。
- en: The next line of code calls the render target's `BeginDraw()` method to tell
    it that we are ready to begin drawing. Then, we clear the screen on the next line
    by filling it with the color stored in the `ClearColor` property that is defined
    by our `GameWindow` base class. The last three lines draw our geometry twice.
    First, we draw it using the `FillGeometry()` method of our render target. This
    will draw our rectangle filled in with the specified brush (in this case, solid
    blue). Then, we draw the rectangle a second time, but this time with the `DrawGeometry()`
    method. This draws only the lines of our shape but doesn't fill it in, so this
    draws a border on our rectangle. The extra parameter on the `DrawGeometry()` method
    is optional and specifies the width of the lines we are drawing. We set it to
    `1.0f`, which means the lines will be one-pixel wide. And the last line calls
    the `EndDraw()` method to tell the render target that we are finished drawing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码调用渲染目标的 `BeginDraw()` 方法，告诉它我们已准备好开始绘制。然后，在下一条代码中，我们通过填充由我们的 `GameWindow`
    基类定义的 `ClearColor` 属性中存储的颜色来清除屏幕。最后三条代码绘制我们的几何形状两次。首先，我们使用渲染目标的 `FillGeometry()`
    方法绘制它。这将使用指定的画笔（在这种情况下，纯蓝色）填充我们的矩形。然后，我们再次绘制矩形，但这次使用 `DrawGeometry()` 方法。这次只绘制形状的线条，不填充它，因此在矩形上绘制一个边框。`DrawGeometry()`
    方法上的额外参数是可选的，并指定了我们正在绘制的线条的宽度。我们将其设置为 `1.0f`，这意味着线条将是一像素宽。最后一行调用 `EndDraw()` 方法，告诉渲染目标我们已经完成绘制。
- en: Cleanup
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: As usual, we need to clean things up after ourselves when the program closes.
    So, we need to add `override` of the base class's `Dispose(bool)` method, just
    as we did in the last chapter. We've already done this a few times, so it should
    be somewhat familiar and is not shown here. Check out the downloadable code for
    this chapter to see this code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，当程序关闭后，我们需要自己清理。因此，我们需要添加基类 `Dispose(bool)` 方法的 `override`，就像我们在上一章所做的那样。我们已经做过几次了，所以这应该相当熟悉，这里不再展示。查看本章的可下载代码以查看此代码。
- en: '![Cleanup](img/7389OS_03_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![清理](img/7389OS_03_01.jpg)'
- en: Our blue rectangle with a red border
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们带有红色边框的蓝色矩形
- en: As you might guess, there is a lot more you can do with drawing geometry. You
    can draw curved line segments and draw shapes with gradient brushes too for example.
    You can also draw text on the screen using the render target's `DrawText()` method.
    But since we have limited space on these pages, we're going to look at how to
    draw bitmap images on the screen. These images are something that makes up the
    graphics of most 2D games.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，你可以用绘制几何图形做更多的事情。例如，你可以绘制曲线线段，也可以使用渐变画笔绘制形状。你还可以使用渲染目标的 `DrawText()` 方法在屏幕上绘制文本。但由于这些页面空间有限，我们将探讨如何在屏幕上绘制位图图像。这些图像构成了大多数二维游戏图形的一部分。
- en: Rendering bitmaps
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位图渲染
- en: Instead of doing a simple demo of drawing a single bitmap on the screen, we
    will make a small 2D tile-based world. In 2D graphics, the term tile refers to
    a small bitmap image that represents one square of space in the 2D world. A **tile
    set** or **tile sheet** is a single bitmap file that contains numerous tiles.
    A single 2D graphic tile is also referred to as a **sprite** . To get started,
    add a new project named `TileWorld` to the `SlimFramework` solution. So far, we've
    directly used the game window classes we made. This time, we will see how we will
    do this in a real-world game project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会简单地演示在屏幕上绘制单个位图，而是将创建一个小的二维基于瓦片的游戏世界。在二维图形中，瓦片是指代表二维世界中一个空间方格的小位图图像。**瓦片集**或**瓦片图**是一个包含多个瓦片的单个位图文件。单个二维图形瓦片也被称为**精灵**。要开始，请向
    `SlimFramework` 解决方案中添加一个名为 `TileWorld` 的新项目。到目前为止，我们直接使用了我们制作的游戏窗口类。这次，我们将看看如何在现实世界的游戏项目中这样做。
- en: Add a new class file to the `TileWorld` project and name it `TileGameWindow.cs`.
    As you may have guessed, we will make this new class inherit from the `GameWindow`
    class in our `SlimFramework` project. But first, we need to add a reference to
    the `SlimFramework` project. We've already covered this, so go ahead and add the
    reference. Don't forget to add a reference to SlimDX as well. You will also need
    to add a reference to `System.Drawing` if there isn't one already. Also, don't
    forget to set `TileWorld` as the startup project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `TileWorld` 项目添加一个新类文件，并将其命名为 `TileGameWindow.cs`。正如你可能猜到的，我们将使这个新类继承自 `SlimFramework`
    项目中的 `GameWindow` 类。但首先，我们需要添加对 `SlimFramework` 项目的引用。我们已经讨论过这一点，所以请继续添加引用。别忘了也要添加对
    SlimDX 的引用。如果你还没有，你还需要添加对 `System.Drawing` 的引用。另外，别忘了将 `TileWorld` 设置为启动项目。
- en: 'Next, we need to add our `using` statements to the top of the `TileGameWindow.cs`
    file. We will need to add the following `using` statements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`using`语句添加到`TileGameWindow.cs`文件的顶部。我们需要添加以下`using`语句：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to create a couple of structs and member variables. First, let''s
    define the following **constant** at the top of this class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建几个结构体和成员变量。首先，让我们在这个类的顶部定义以下**常量**：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This constant defines the movement speed of the player. A constant is just
    a variable whose value can never be changed after it is initialized, so its value
    is always the same. Now, we need a place to store the information about our player
    character. We will create a structure named `Player`. Just add it right below
    the constant we just made with the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个常量定义了玩家的移动速度。常量只是一个初始化后其值不能改变的变量，因此其值始终相同。现在，我们需要一个地方来存储关于我们的玩家角色的信息。我们将创建一个名为`Player`的结构体。只需在以下代码中将其添加到我们刚刚创建的常量下方：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first two member variables in this struct store the player's current location
    within the 2D world. The `AnimFrame` variable keeps track of the current animation
    frame that the player character is on, and the last variable keeps track of how
    long the player character has been on the current animation frame. This is used
    to ensure that the animation runs at about the same speed regardless of how fast
    your PC is.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体的前两个成员变量存储玩家在2D世界中的当前位置。`AnimFrame`变量跟踪玩家角色当前所在的动画帧，最后一个变量跟踪玩家角色在当前动画帧上的时间。这是为了确保动画的运行速度大致相同，无论您的PC速度有多快。
- en: 'We need to add a second struct below this one now. We will name this struct
    `Tile`. It stores information on a single tile. As you might guess, we will be
    creating a list of these structures containing one for each tile type in our game
    world. The following is the `Tile` struct:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在这个结构体下方添加第二个结构体。我们将把这个结构体命名为`Tile`。它存储单个瓦片的信息。正如你可能猜到的，我们将创建一个包含我们游戏世界中每种瓦片类型的结构体列表。以下是一个`Tile`结构体的示例：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first variable indicates whether this tile is solid or not. If a tile is
    solid, it means that the player cannot walk on it or through it. So, for example,
    a brick wall tile would have this set to `true`, since we don't want our players
    to be walking through brick walls! The last two member variables of this struct
    hold the coordinates of the tile's image within the tile sheet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量表示这个瓦片是否是实心的。如果一个瓦片是实心的，这意味着玩家不能在其上或穿过它行走。例如，砖墙瓦片将设置为`true`，因为我们不希望玩家穿过砖墙！这个结构体的最后两个成员变量持有瓦片图像在瓦片图中的坐标。
- en: 'Next, let''s turn our attention to creating the member variables for the `TileGameWindow`
    class. You can add these just below the structs we just created as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将注意力转向为`TileGameWindow`类创建成员变量。您可以将这些变量添加到我们刚刚创建的结构体下方，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first two member variables should be familiar from the rectangle program
    that we wrote at the beginning of this chapter. The `m_Player` variable holds
    a `Player` object. This is the first struct we created earlier. The next two variables
    will hold the bitmap images we will use for this program. One holds the sprites
    that make up the animation for our player character, and the other one will hold
    the tile sheet that we will use to draw the game world. The next variable is a
    list named `m_TileList`. We will fill this with one entry for each tile type that
    we have. The `m_Map` variable, as you might guess, will contain a map of our game
    world. And lastly, we have a `SolidColorBrush` member variable named `m_DebugBrush`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个成员变量应该与我们本章开头编写的矩形程序中熟悉。`m_Player`变量持有`Player`对象。这是我们之前创建的第一个结构体。接下来的两个变量将持有我们将用于此程序的位图图像。一个持有组成玩家角色动画的精灵，另一个将持有我们将用于绘制游戏世界的瓦片图。下一个变量是一个名为`m_TileList`的列表。我们将为每种瓦片类型添加一个条目。`m_Map`变量，正如你可能猜到的，将包含我们的游戏世界地图。最后，我们有一个名为`m_DebugBrush`的`SolidColorBrush`成员变量。
- en: Initialization
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: 'Now, it''s time to create the constructor and start initializing everything.
    First, we need to set up the render target. This is very similar to how we did
    it in the program for creating a rectangle, but slightly different. The following
    is the code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建构造函数并开始初始化一切了。首先，我们需要设置渲染目标。这与我们在创建矩形的程序中所做的方法非常相似，但略有不同。以下是一段代码：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we did in the program for creating a rectangle, we first create the factory
    object. After that, things differ slightly. This time we need to create two properties
    objects instead of one. The new one is a `RenderTargetProperties` object. We use
    it to set the pixel format for our render target. As you can see, we are using
    a 32-bit format with 8 bits for each of the four channels (blue, green, red, and
    alpha). Yes, this is backwards from the ARGB format we've already discussed earlier.
    That's OK though because our `LoadBitmap()` method will flip the ARGB format to
    BGRA for us. The next line of code creates a `WindowRenderTargetProperties` object,
    just as we did in the *Rectangle* program earlier in this chapter. We use this
    to specify the handle of the window we want to draw on as well as the size of
    the window. And lastly, we create the render target object and initialize our
    debug brush to be an opaque yellow brush.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在创建矩形的程序中所做的那样，我们首先创建工厂对象。然后，事情略有不同。这次我们需要创建两个属性对象而不是一个。新的一个是 `RenderTargetProperties`
    对象。我们使用它来设置渲染目标的像素格式。正如你所见，我们正在使用一个 32 位格式，每个通道（蓝色、绿色、红色和 alpha）有 8 位。是的，这与我们之前讨论过的
    ARGB 格式相反。不过没关系，因为我们的 `LoadBitmap()` 方法会为我们将 ARGB 格式翻转成 BGRA。下一行代码创建了一个 `WindowRenderTargetProperties`
    对象，就像我们在本章早些时候的 *Rectangle* 程序中所做的那样。我们使用这个对象来指定我们想要绘制的窗口句柄以及窗口的大小。最后，我们创建渲染目标对象，并将我们的调试画笔初始化为不透明的黄色画笔。
- en: 'So, we''re done initializing stuff now, right? Well, no; not yet. We still
    have a few things that need to be initialized. But first, we need to create our
    `LoadBitmap()` method so that we can load in our graphics! The following is the
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们现在已经完成了初始化工作，对吧？嗯，不；还不是。我们还有一些东西需要初始化。但首先，我们需要创建我们的 `LoadBitmap()` 方法，这样我们就可以加载我们的图形了！以下就是代码：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method is a little confusing, so I've kept the comments present in this
    code listing. You may have noticed that in the line with the call to the `LockBits()`
    method, there is a pixel format parameter, but it is different from what we saw
    a bit earlier in the chapter; it is `System.Drawing.Imaging.PixelFormat.Format32bppPArgb`.
    This is the same format we are using, but what is that `P` in there for? The `P`
    is short for **precalculated alpha** . This basically means that the red, green,
    and blue channels are automatically adjusted based on the alpha value before rendering.
    So, if you have the red channel at maximum and the alpha channel at 50 percent,
    the intensity of the red channel will be reduced by half.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有点令人困惑，所以我保留了代码列表中的注释。你可能已经注意到，在调用 `LockBits()` 方法的行中，有一个像素格式参数，但它与我们本章稍早前看到的格式不同；它是
    `System.Drawing.Imaging.PixelFormat.Format32bppPArgb`。这是我们正在使用的相同格式，但那里的 `P` 是什么意思呢？`P`
    是指 **预先计算的 alpha**。这基本上意味着在渲染之前，红色、绿色和蓝色通道会根据 alpha 值自动调整。所以，如果你将红色通道设置为最大值，而
    alpha 通道为 50%，红色通道的强度将减半。
- en: There is also **straight alpha** which is less efficient than precalculated
    alpha. The values of the red, green, and blue channels are left alone. Their intensity
    is adjusted based on the value of the alpha channel during rendering. Precalculated
    alpha is a bit faster since it adjusts the color channels once before any rendering
    happens, whereas straight alpha has to adjust the color channels each time we
    render a new frame. And lastly, there is also an **ignore alpha** mode. In this
    mode, the alpha channel is completely ignored, and thus you cannot use transparent
    bitmaps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 **直接 alpha**，它比预先计算的 alpha 效率低。红色、绿色和蓝色通道的值保持不变。它们的强度根据渲染时的 alpha 通道值进行调整。预先计算的
    alpha 比较快，因为它在渲染发生之前只调整一次颜色通道，而直接 alpha 每次我们渲染新帧时都必须调整颜色通道。最后，还有一个 **忽略 alpha**
    模式。在这个模式下，alpha 通道被完全忽略，因此你不能使用透明位图。
- en: We are using the precalculated alpha mode in this case and this is important.
    If you don't do this, the player character will have white in all of the transparent
    areas of the robot image, which looks rather silly. We used the `LockBits()` method
    to lock the memory holding the bitmap because if any other code on another thread
    accesses that memory while we are messing with it, this can cause crashes and
    other odd behavior.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们正在使用预先计算的 alpha 模式，并且这很重要。如果你不这样做，玩家角色在机器人图像的所有透明区域都会有白色，这看起来相当滑稽。我们使用
    `LockBits()` 方法锁定包含位图的内存，因为如果在另一个线程上的其他代码在访问该内存的同时我们在对其进行操作，这可能会导致崩溃和其他奇怪的行为。
- en: 'Now, let''s return to the constructor and initialize the player character,
    which will be a rather silly robot. Add the following code at the bottom of the
    constructor:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到构造函数，初始化玩家角色，它将是一个相当愚蠢的机器人。在构造函数的底部添加以下代码：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line of code uses our `LoadBitmap()` method to load the robot sprite
    sheet and store it in the `m_PlayerSprites` member variable. The second line creates
    the player object to hold information about the player character. Finally, the
    last two lines set the starting position for the player. Note that the coordinates
    (0, 0) represent the upper-left corner of the screen. The robot sprite sheet is
    just a series of animation frames for our robot that we will display one after
    another in quick succession to animate the robot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行使用我们的`LoadBitmap()`方法来加载机器人精灵图集并将其存储在`m_PlayerSprites`成员变量中。第二行创建玩家对象以保存有关玩家角色的信息。最后两行设置玩家的起始位置。请注意，坐标（0，0）代表屏幕的左上角。机器人精灵图集只是我们机器人的一系列动画帧，我们将快速连续显示这些帧来动画化机器人。
- en: 'Now that the player object is initialized, we need to initialize the game world!
    The following is the first part of the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家对象已经初始化，我们需要初始化游戏世界！以下代码是第一部分：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line calls our `LoadBitmap()` method again to load in the tile sheet
    and store it in the `m_TileSheet` member variable. The second line creates our
    tile list object. This will store information for each tile type. The eight lines
    of code at the bottom create entries in the tile list for all of the tiles in
    the first row of the tile sheet. Of course, the tile sheet has more than one row
    of tiles in it, but I will not show the code for the other rows here, since it
    is very similar and would take up several pages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行再次调用我们的`LoadBitmap()`方法来加载瓦片图集并将其存储在`m_TileSheet`成员变量中。第二行创建我们的瓦片列表对象。这将存储有关每种瓦片类型的信息。底部八行代码在瓦片列表中为瓦片图集的第一行的所有瓦片创建条目。当然，瓦片图集中有不止一行瓦片，但在这里我不会展示其他行的代码，因为它非常相似，并且会占用几页纸。
- en: 'We have one more thing to do to finish initializing the game world. It consists
    of initializing the map. The map is simply a two-dimensional array. Each element
    in the array represents a tile position in the game world. As such, the array
    is of type `int`; it is of type `int` because each element stores a numeric index
    in the tile list. So basically, each element in the array holds a number that
    tells us which type of tile is at this position in the game world. As the code
    that fills in this array is much too wide to fit on the page, I will show a brief
    example of how it is initialized here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成初始化游戏世界，我们还有一件事要做。这包括初始化地图。地图简单地是一个二维数组。数组中的每个元素代表游戏世界中的一个瓦片位置。因此，数组的数据类型是`int`；它是`int`类型，因为每个元素存储一个瓦片列表中的数字索引。所以基本上，数组中的每个元素都包含一个数字，告诉我们游戏世界中这个位置上的瓦片类型。由于填充这个数组的代码太宽，无法适应页面，我将在这里展示一个简短的初始化示例：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we are creating a new two-dimensional `int` array. In this sample
    code, we have a 3 x 3 world. We are using tile type `14` (a brick wall tile) to
    make a wall around the outer border of this small world. In the center, we have
    tile type `0`, which in our game demo is a grass tile. Each row of values gets
    its own pair of enclosing brackets (`{}`), followed by a comma. This is basically
    how you set up a 2D tile map. Of course you can get a lot fancier with this. For
    example, you can implement animated tile types in your game. These would be animated
    very similarly to how we will animate our robot character. Check out the downloadable
    code for this chapter to see the complete array initialization code, which is
    much larger than the earlier example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在创建一个新的二维`int`数组。在这个示例代码中，我们有一个3 x 3的世界。我们使用瓦片类型`14`（一块砖墙瓦片）来围绕这个小世界的边缘建造墙壁。在中心，我们有瓦片类型`0`，在我们的游戏演示中，这是一个草地瓦片。每个值行都有一对括号`{}`，后面跟着一个逗号。这基本上就是设置2D瓦片地图的方法。当然，你可以使它更加复杂。例如，你可以在游戏中实现动画瓦片类型。这些动画将与我们将要动画化的机器人角色非常相似。查看本章的可下载代码，以查看完整的数组初始化代码，它比之前的示例要大得多。
- en: Rendering the game world
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染游戏世界
- en: 'For clarity, we will create a couple of different render methods that will
    each be called from our `RenderScene()` method. Since the first thing we need
    to draw is the game world itself, let''s create that method first. We will name
    this method `RenderWorld`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们将创建几个不同的渲染方法，每个方法都将从我们的 `RenderScene()` 方法中调用。由于我们需要首先绘制的是游戏世界本身，让我们首先创建这个方法。我们将把这个方法命名为
    `RenderWorld`：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code is fairly straightforward. The first line creates a `Tile` object
    variable. Next, we have two nested `for` loops that loop through every tile position
    in the game world. Inside the inner `for` loop, we get the tile type for this
    position on the map and look it up in the tile list. We store the result in the
    variable `s` so that we can use it easily afterwards. The last line renders the
    tile. The first parameter here is the bitmap containing the tiles. The second
    parameter is a rectangle specifying where we want to draw the tile on the screen.
    The third parameter is the opacity. We have it set to `1.0f` so that the tile
    is completely opaque. The third parameter is the interpolation mode. And the last
    parameter is another rectangle, which specifies what portion of the tile sheet
    we want to draw on the screen. For this, we specify the part of the tile sheet
    containing the tile we want to draw. For the x and y coordinates of both rectangle
    parameters, you may have noticed that we are multiplying by 32\. This is because
    each tile is 32 x 32 pixels in size. So, we have to multiply by 32 to get the
    position of the tile within the tile sheet correctly. The fact that our tiles
    are 32 x 32 pixels in size is also why both rectangles we created here specify
    the value `32` for their `width` and `height` parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直接。第一行创建了一个 `Tile` 对象变量。接下来，我们有两个嵌套的 `for` 循环，它们遍历游戏世界中每个瓦片的位置。在内层 `for`
    循环中，我们获取地图上这个位置的瓦片类型，并在瓦片列表中查找它。我们将结果存储在变量 `s` 中，这样我们就可以方便地之后使用它。最后一行渲染瓦片。这里的第一个参数是包含瓦片的位图。第二个参数是一个矩形，指定我们在屏幕上想要绘制瓦片的位置。第三个参数是不透明度。我们将其设置为
    `1.0f`，这样瓦片就完全不透明。第三个参数是插值模式。最后一个参数是另一个矩形，它指定我们在屏幕上想要绘制瓦片图的一部分。为此，我们指定包含我们想要绘制的瓦片的瓦片图的一部分。对于两个矩形参数的
    x 和 y 坐标，你可能已经注意到我们正在乘以 32。这是因为每个瓦片的大小是 32 x 32 像素。因此，我们必须乘以 32 来正确获取瓦片在瓦片图中的位置。我们的瓦片大小为
    32 x 32 像素的事实也是为什么我们在这里创建的两个矩形都指定了它们的 `width` 和 `height` 参数的值为 `32`。
- en: Rendering the player character
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染玩家角色
- en: 'Now that we have code to draw the world, we need to draw the player character!
    For this, we will create a method called `RenderPlayer()`. It''s pretty short
    compared to the `RenderWorld()` method. The following is the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了绘制世界的代码，我们需要绘制玩家角色！为此，我们将创建一个名为 `RenderPlayer()` 的方法。与 `RenderWorld()`
    方法相比，这个方法相当简短。以下是对应的代码：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method contains only one line. It is very similar to the code we used to
    draw each tile in the `RenderWorld()` method. But this time we are using the player
    sprites sheet rather than the tile sheet. You may also notice that we determine
    which sprite to draw based on the player object's `AnimFrame` variable, which
    we use to keep track of which animation frame the robot is currently on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只包含一行。它与我们在 `RenderWorld()` 方法中用来绘制每个瓦片的代码非常相似。但这次我们使用的是玩家精灵图，而不是瓦片图。你可能也会注意到，我们是根据玩家对象的
    `AnimFrame` 变量来确定要绘制哪个精灵的，我们使用这个变量来跟踪机器人当前所在的动画帧。
- en: Rendering debug information
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染调试信息
- en: 'This is not strictly necessary, but it''s a good thing to know how to do. We
    will create a new method called `RenderDebug()`. It will draw a yellow border
    on every solid tile in the game world. The following is the code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是严格必要的，但了解如何做总是一件好事。我们将创建一个新的方法，称为 `RenderDebug()`。它将在游戏世界中每个实心瓦片上绘制一个黄色边框。以下是对应的代码：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, this method looks very similar to the `RenderWorld()` method;
    it loops through every position in the game world just as that method does. The
    one major difference is that we use the `DrawRectangle()` method here rather than
    the `DrawBitmap()` method. Using our yellow debug brush, it draws a yellow border
    on any tile in the game world that is solid.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个方法看起来与 `RenderWorld()` 方法非常相似；它像那个方法一样遍历游戏世界中的每个位置。唯一的重大区别是我们在这里使用的是
    `DrawRectangle()` 方法，而不是 `DrawBitmap()` 方法。使用我们的黄色调试画笔，它会在游戏世界中任何实心瓦片上绘制一个黄色边框。
- en: Finishing the rendering code
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成渲染代码
- en: 'Now we need to add code into the `RenderScene()` method to call these methods
    we just made. The following is the `RenderScene()` code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`RenderScene()`方法中添加代码来调用我们刚才创建的方法。以下是`RenderScene()`代码：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, our rendering code is now complete. The `if` statement at the top
    prevents the program from crashing when it is first starting up or shutting down.
    The next two lines tell the render target we are ready to begin drawing by calling
    the `BeginDraw()` method, and then clear the screen by calling the `Clear()` method.
    The next line calls our `RenderWorld()` method to draw the game world. But then,
    the call to the `RenderDebug()` method is preceded by `#if DEBUG` and followed
    by `#endif`. These are known as **preprocessor directives**. This one checks if
    a symbol named `DEBUG` is defined, and if so, the code inside this `if` directive
    will be compiled into the program. Preprocessor directives are processed by the
    **preprocessor,** which runs before the compiler when you compile your code. After
    the preprocessor has finished its job, the compiler will run. There are a bunch
    of other preprocessor directives besides `#if`, but they are beyond the scope
    of this text. When you compile your code under the `Debug` configuration, the
    `DEBUG` symbol is automatically defined for us, meaning our call to `RenderDebug()`
    will be compiled into the game. In Visual Studio, you can change the compile configuration
    using the drop-down list box that is just to the right of the **Start** button,
    which you click on to compile and run your program. Visual Studio provides `Debug`
    and `Release` configurations. You can also run a program by pressing the *F5*
    key.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的渲染代码现在已经完成。顶部的`if`语句防止程序在启动或关闭时崩溃。接下来的两行通过调用`BeginDraw()`方法通知渲染目标我们准备开始绘制，然后通过调用`Clear()`方法清除屏幕。下一行调用我们的`RenderWorld()`方法来绘制游戏世界。但是，调用`RenderDebug()`方法之前是`#if
    DEBUG`，之后是`#endif`。这些被称为**预处理器指令**。这个指令检查一个名为`DEBUG`的符号是否已定义，如果是，则这个`if`指令内部的代码将被编译进程序。预处理器指令由**预处理器**处理，它在编译代码之前运行。预处理器完成工作后，编译器将运行。除了`#if`之外，还有许多其他的预处理器指令，但它们超出了本文的范围。当你以`Debug`配置编译代码时，`DEBUG`符号会自动为我们定义，这意味着我们的`RenderDebug()`调用将被编译进游戏。在Visual
    Studio中，你可以通过点击位于**开始**按钮右侧的下拉列表框来更改编译配置，点击该按钮以编译和运行你的程序。Visual Studio提供`Debug`和`Release`配置。你也可以通过按*F5*键来运行程序。
- en: The next line calls our `RenderPlayer()` method to draw the player character
    using the appropriate animation frame from the robot's sprite sheet. And lastly,
    we call the `EndDraw()` method to tell the render target that we are done rendering
    this frame.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用我们的`RenderPlayer()`方法，使用机器人精灵图集中的适当动画帧来绘制玩家角色。最后，我们调用`EndDraw()`方法来告知渲染目标我们已经完成了这一帧的渲染。
- en: Handling user input
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: 'Now, we need to add some code into our `UpdateScene()` method to handle player
    input:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的`UpdateScene()`方法中添加一些代码来处理玩家输入：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line calls the base class's `UpdateScene()` method, so it can perform
    its stuff. The next four lines may look a bit odd though. Why do we need to find
    out which grid square each corner of the player sprite is in? It has to do with
    how our player's movement will work. Specifically, this is used by our collision
    detection code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行调用基类的`UpdateScene()`方法，以便它能够执行其功能。接下来的四行可能看起来有些奇怪。为什么我们需要找出玩家精灵每个角落所在的网格方块？这与我们的玩家移动方式有关。具体来说，这是由我们的碰撞检测代码使用的。
- en: 'You may also notice that the first four lines of code are skewing all four
    corners inward by 25 percent. You can think of these four corners as our bounding
    box for collision detection. Shrinking the bounding box like this makes it easier
    for the player to enter narrow spaces that are only one block wide. Note that
    `TL` is short for top-left, `TR` is top-right, `BL` is bottom-left, and `BR` is
    bottom-right. The following is the first part of our collision detection code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会注意到，前四行代码将四个角落向内倾斜了25%。你可以将这些四个角落视为我们的碰撞检测边界框。以这种方式缩小边界框使得玩家更容易进入只有一格宽的狭窄空间。注意，`TL`代表左上角，`TR`代表右上角，`BL`代表左下角，`BR`代表右下角。以下是我们碰撞检测代码的第一部分：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code starts with a compound `if` statement, checking whether the user is
    pressing the *A* key or the left arrow key. Yes, you can control our game character
    using either of the *W*, *A*, *S*, or *D* keys or the arrow keys if you wish to
    move the character using the keyboard. Next, we have another `if` statement. This
    `if` statement checks to see if moving the player to the left will cause a collision.
    If not, we move the player to the left. As you can see, we use the `PLAYER_MOVE_SPEED`
    constant that we created earlier in this chapter to control how much the robot
    moves. Obviously, we need three more of these `if` statements to handle the right,
    up, and down directions. As the code is very similar, I will not describe it here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从一个复合的`if`语句开始，检查用户是否按下了*A*键或左箭头键。是的，你可以使用*W*、*A*、*S*或*D*键，或者如果你希望使用键盘移动角色，可以使用箭头键来控制我们的游戏角色。接下来，我们还有一个`if`语句。这个`if`语句检查将玩家向左移动是否会导致碰撞。如果没有，我们就将玩家向左移动。正如你所见，我们使用了我们在本章早期创建的`PLAYER_MOVE_SPEED`常量来控制机器人移动的距离。显然，我们需要再添加三个这样的`if`语句来处理右、上和下方向。由于代码非常相似，这里我就不再描述了。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The downloadable code for this chapter also supports controlling the robot using
    joysticks/gamepads. It adds a member variable named `m_UseDirectInput` to the
    `TileGameWindow` class. Set this variable to `true` to use DirectInput for joystick/gamepad
    controls, or set this variable to `false` to have the program use XInput for joystick/gamepad
    controls. We need the `m_UseDirectInput` member variable because if we used both
    DirectInput and XInput at the same time for the same game controller device, this
    will cause the player to get moved twice per frame.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的可下载代码也支持使用摇杆/游戏手柄来控制机器人。它向`TileGameWindow`类添加了一个名为`m_UseDirectInput`的成员变量。将此变量设置为`true`以使用DirectInput进行摇杆/游戏手柄控制，或将此变量设置为`false`以使程序使用XInput进行摇杆/游戏手柄控制。我们需要`m_UseDirectInput`成员变量，因为如果我们同时使用DirectInput和XInput来控制同一个游戏控制器设备，这将导致玩家每帧移动两次。
- en: Animating the player character
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家角色的动画
- en: 'With the user input and collision detection code done, there is now only one
    thing left to do in `UpdateScene()`. We need to add a bit of code to animate the
    player character:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入和碰撞检测代码完成后，现在在`UpdateScene()`中只剩下一件事要做。我们需要添加一些代码来动画化玩家角色：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code is fairly simple. The first line adds `frameTime` to the player object's
    `LastFrameChange` variable. Remember that `frameTime` is the parameter of the
    `UpdateScene()` method, and it contains the amount of time that has elapsed since
    the previous frame. Next, we have an `if` statement that checks if the player
    object's `LastFrameChange` variable has a value greater than `0.1`. If this is
    the case, it means that it has been 1/10th of a second or more since the last
    time we changed the animation frame, so we will change it again. Inside the `if`
    statement, we reset the `LastFrameChange` variable to `0`, so we will know when
    to change the animation frame again. The next line increments the value of the
    player object's `AnimFrame` variable. And lastly, we have another `if` statement
    that checks if the new value of the `AnimFrame` variable is too large. If it is,
    we reset it to a value of `0` and the animation starts all over again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单。第一行将`frameTime`添加到玩家对象的`LastFrameChange`变量中。记住，`frameTime`是`UpdateScene()`方法的参数，它包含了自上一帧以来经过的时间量。接下来，我们有一个`if`语句，检查玩家对象的`LastFrameChange`变量是否有大于`0.1`的值。如果是这样，这意味着自上次我们更改动画帧以来已经过去了1/10秒或更长时间，因此我们将再次更改它。在`if`语句内部，我们将`LastFrameChange`变量重置为`0`，这样我们就会知道何时再次更改动画帧。下一行增加玩家对象的`AnimFrame`变量的值。最后，我们还有一个`if`语句，检查`AnimFrame`变量的新值是否太大。如果是，我们将它重置为`0`，动画从头开始。
- en: Running the game
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: We are almost ready to run the game, but don't forget that you need to add the
    `Dispose(bool)` method. In this program, there are only four objects it needs
    to dispose off. They are `m_RenderTarget`, `m_Factory`, `m_TileSheet`, and `m_DebugBrush`.
    They should be disposed of in the managed section of the `Dispose(bool)` method.
    You can see this in the downloadable code for this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好运行游戏了，但别忘了你需要添加`Dispose(bool)`方法。在这个程序中，只有四个对象需要释放。它们是`m_RenderTarget`、`m_Factory`、`m_TileSheet`和`m_DebugBrush`。它们应该在`Dispose(bool)`方法的托管部分被释放。你可以在本章的可下载代码中看到这一点。
- en: With the cleanup code in place, we are ready to run the game. As you can see,
    you control a rather goofy robot. Note that the player sprites are in the `Robot.png`
    file and the tile sheet is saved in the `TileSheet.png` file. Both of these files
    are, of course, included with the downloadable code for this chapter. The screenshot
    following the explanation shows what the game window looks like with the debug
    overlay off.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理代码就绪后，我们就可以运行游戏了。正如你所见，你控制着一个相当滑稽的机器人。请注意，玩家精灵在`Robot.png`文件中，而瓦片图集保存在`TileSheet.png`文件中。当然，这两个文件都包含在本章可下载的代码中。随后的截图显示了关闭调试覆盖层时的游戏窗口外观。
- en: You may have noticed that we didn't implement the fullscreen mode. This is because
    Direct2D unfortunately does not natively support the fullscreen mode. It is, however,
    possible to have the fullscreen mode in a Direct2D application. To do this, you
    will create a Direct3D render target and share it with Direct2D. This would then
    allow you to draw on it with Direct2D and also be able to use the fullscreen mode.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有实现全屏模式。这是因为Direct2D不幸地不支持全屏模式。然而，在Direct2D应用程序中实现全屏模式是可能的。要做到这一点，你需要创建一个Direct3D渲染目标并将其与Direct2D共享。这样你就可以用Direct2D在上面绘制，并且能够使用全屏模式。
- en: '![Running the game](img/7389OS_03_02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![运行游戏](img/7389OS_03_02.jpg)'
- en: Our 2D game in action
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的2D游戏
- en: The following screenshot shows our game with the debug overlay turned on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了开启调试覆盖层时的游戏。
- en: '![Running the game](img/7389OS_03_03.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![运行游戏](img/7389OS_03_03.jpg)'
- en: Our 2D game in action with the debug overlay turned on
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 开启调试覆盖层时的2D游戏运行情况
- en: Entities
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: This 2D game demo we created only has one **entity** in it (the player character).
    In game development, the term entity refers to an object that can interact with
    the game world or other objects in the game world. An entity would typically be
    implemented as a class. So, we would create a class to represent our player object.
    In this demo, our player object was very simple and had no methods in it, so we
    just made it a struct instead. In a real-game engine, you might have an `Entity`
    base class that all other entity classes would inherit from. This base class would
    define methods such as `Update()` and `Draw()` so that every entity has them.
    Each entity class would then override them to provide its own custom update and
    draw code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的这个2D游戏演示中只有一个**实体**（玩家角色）。在游戏开发中，实体这个术语指的是可以与游戏世界或其他游戏世界中的对象交互的对象。实体通常会被实现为一个类。因此，我们会创建一个类来表示我们的玩家对象。在这个演示中，我们的玩家对象非常简单，里面没有方法，所以我们只是将它做成一个结构体。在一个真正的游戏引擎中，你可能会有一个`Entity`基类，所有其他的实体类都会从这个基类继承。这个基类会定义如`Update()`和`Draw()`等方法，以便每个实体都有这些方法。然后每个实体类会重写它们以提供自己的自定义更新和绘制代码。
- en: A single level or game world can have hundreds of entities in it, so how do
    we manage them? One way is to create an `EntityManager` class that simply holds
    the collection of entities that are in the currently loaded level or world. The
    `EntityManager` class will have an `Update()` method and a `Draw()` method. The
    `Update()` method would, of course, get called once per frame by the `UpdateScene()`
    method of our game window class. Likewise, the `Draw()` method would be called
    once per frame by the `RenderScene()` method. The entity manager's `Update()`
    method would iterate through all of the entities and call each one's `Update()`
    method so that the entity can update itself. And of course, the entity manager's
    `Draw()` method would do the same thing, but instead it would call each entity's
    `Draw()` method so that the entity can draw itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的水平或游戏世界可以有数百个实体，那么我们如何管理它们呢？一种方法是为当前加载的水平或世界中的实体集合创建一个`EntityManager`类。`EntityManager`类将有一个`Update()`方法和一个`Draw()`方法。`Update()`方法当然会被我们的游戏窗口类的`UpdateScene()`方法每帧调用一次。同样，`Draw()`方法也会被`RenderScene()`方法每帧调用一次。实体管理器的`Update()`方法会遍历所有实体并调用每个实体的`Update()`方法，以便实体可以更新自己。当然，实体管理器的`Draw()`方法也会做同样的事情，但它会调用每个实体的`Draw()`方法，以便实体可以绘制自己。
- en: In some games, entities are able to communicate with each other via a messaging
    system of sorts. A good example of this is the inputs and outputs system used
    in `Half-Life 2`. For example, there is a button on a wall next to a door. We
    will set up an output on the button that fires when the button is pressed. We
    will connect it to the input on the door that makes the door open. So, basically,
    when the output of the button fires, it activates the specified input on the door.
    In short, the button sends a message to the door telling it to open. The output
    of one object can potentially send parameters to its target input as well. The
    big benefit here is that many interactions between objects can be handled like
    this and don't need to be specifically coded as a result, but instead can simply
    be set up in the game's level editor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些游戏中，实体可以通过某种消息系统相互通信。一个很好的例子是《半条命2》中使用的输入和输出系统。例如，在门旁边墙上有一个按钮。我们将在按钮上设置一个输出，当按钮被按下时触发。我们将将其连接到门的输入，使门打开。所以，基本上，当按钮的输出触发时，它会激活门上的指定输入。简而言之，按钮向门发送一条消息，告诉它打开。一个对象的输出可以潜在地向其目标输入发送参数。这里的重大好处是，许多对象之间的交互可以像这样处理，并且不需要专门编码，而只需在游戏关卡编辑器中简单设置即可。
- en: Component-based entities
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于组件的实体
- en: There is another way to implement our entities as well. It implements an `Entity`
    class that is used to represent any possible entity. The difference is that this
    `Entity` class contains a collection of `Components`. A **component** is a class
    that represents a certain action or feature that an object in the game world can
    have. So, for example, you might have an **Armor** component that allows an entity
    to have an armor value, or a **Health** component that allows the entity to have
    health and the ability to take damage. This Health component would probably have
    a property to set the maximum health for the entity and another one that is used
    to get the current health value for the entity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的实体还有另一种方法。它实现了一个用于表示任何可能实体的`Entity`类。不同之处在于，这个`Entity`类包含了一组`Components`。**组件**是一个类，它代表游戏世界中一个对象可以拥有的特定动作或特性。例如，你可能有一个**装甲**组件，允许实体拥有装甲值，或者一个**健康**组件，允许实体拥有健康和承受伤害的能力。这个健康组件可能有一个属性来设置实体的最大健康值，另一个属性用于获取实体的当前健康值。
- en: This is a very powerful approach because you can give any entity health (and
    the ability to take damage) just by adding the Health component into that entity.
    So, as you can see, each entity is represented by the basic `Entity` class and
    gets all of its features and properties from the components that are added into
    it. This is what makes this approach so powerful. You write the Health code once
    and then you can re-use it on any number of entities without having to rewrite
    it for each one. The component-based entities are a bit trickier to program than
    regular entities though. For example, we would need to add a method on the `Entity`
    class that lets you pass in a component type to specify which component you would
    like to access. It would then find the component of the specified type and return
    it for you to use. You would usually make your entity system such that it will
    not allow an entity to have more than one component of any given type as this
    generally wouldn't make much sense anyway. For example, giving one entity two
    Health components doesn't make much sense.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常强大的方法，因为你可以通过将健康组件（以及承受伤害的能力）添加到任何实体中，来赋予任何实体健康（和承受伤害的能力）。所以，正如你所看到的，每个实体都由基本的`Entity`类表示，并从添加到其中的组件中获得所有特性和属性。这就是这种方法如此强大的原因。你只需编写一次健康代码，然后就可以在任意数量的实体上重用它，而无需为每个实体重新编写。然而，基于组件的实体编程比常规实体要复杂一些。例如，我们需要在`Entity`类上添加一个方法，让你可以传入一个组件类型来指定你想要访问哪个组件。然后它会找到指定类型的组件，并将其返回给你使用。你通常会设计你的实体系统，使其不允许一个实体拥有任何给定类型的多个组件，因为这通常也没有太多意义。例如，给一个实体添加两个健康组件就没有太多意义。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we first made a simple demo application that drew a rectangle
    on the screen. Then we got a bit more ambitious and built a 2D tile-based game
    world. In the process, we covered how to render bitmaps on the screen, basic collision
    detection, and reviewed some basic user input handling. We also looked at how
    to create a handy debug overlay. Of course, this debug overlay is pretty simple,
    but they can show all sorts of useful information. They are a very powerful tool
    when it comes to solving bugs. In the next chapter, we will look at playing music
    and sound effects to add more life to our 2D game world that we built in this
    chapter!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先创建了一个简单的演示应用程序，它在屏幕上绘制了一个矩形。然后，我们变得更加雄心勃勃，构建了一个基于2D瓦片的游戏世界。在这个过程中，我们介绍了如何在屏幕上渲染位图、基本的碰撞检测以及回顾了一些基本的用户输入处理。我们还探讨了如何创建一个实用的调试覆盖层。当然，这个调试覆盖层相当简单，但它们可以显示各种有用的信息。当涉及到解决bug时，它们是非常强大的工具。在下一章中，我们将探讨播放音乐和音效，以增加我们在这章中构建的2D游戏世界的活力！
