- en: Exploring Type Erasure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索类型擦除
- en: In this chapter, you will learn what type erasure (also known as type erasing)
    is as well as how to use it in your own applications. This chapter is important
    because type erasing provides the ability to work with objects of different types
    without the need for the object to share a common base class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习类型擦除（也称为类型擦除）是什么，以及如何在自己的应用程序中使用它。本章很重要，因为类型擦除提供了在不需要对象共享公共基类的情况下使用不同类型对象的能力。
- en: This chapter starts with a simple explanation of type erasure by explaining
    how type erasure works in the C language as well as how to perform type erasure
    in C++ using inheritance. The next recipe will provide a different approach to
    type erasure using C++ templates, which will teach you how C++ concepts are used
    to define a type's specifications instead of the type itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从简单解释类型擦除开始，解释了在C语言中类型擦除的工作原理，以及如何在C++中使用继承来执行类型擦除。下一个示例将提供使用C++模板的不同方法来进行类型擦除，这将教会您如何使用C++概念来定义类型的规范，而不是类型本身。
- en: Next, we will walk through the classic C++ type erasure pattern. This recipe
    will teach you the skills to erase type information, providing the ability to
    create type-safe, generic code. Finally, we will conclude with a comprehensive
    example of using type erasure to implement the delegate pattern, which is a pattern
    that provides the ability to wrap callable objects of any type and is used heavily
    by languages such as ObjC.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习经典的C++类型擦除模式。本示例将教会您擦除类型信息的技能，从而能够创建类型安全的通用代码。最后，我们将通过一个全面的示例来结束，该示例使用类型擦除来实现委托模式，这是一种提供包装任何类型的可调用对象的能力的模式，并且被诸如ObjC等语言广泛使用。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例如下：
- en: How to erase a type with inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用继承来擦除类型
- en: Using C++ templates to write generic functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++模板编写通用函数
- en: Learning the C++ type eraser pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习C++类型擦除模式
- en: Implementing the delegate pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现委托模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有对运行Ubuntu 18.04的计算机的管理访问权限，并且具有正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter09](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter09).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter09](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter09)找到。
- en: How to erase a type with inheritance
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用继承来擦除类型
- en: In this recipe, we will learn how to erase types using inheritance. When type
    erasing is discussed, inheritance is not usually considered, but in reality, it
    is the most common form of type erasing used in C++. This recipe is important
    because it will discuss what type erasing is and why it is so useful in everyday
    applications without simply removing type information—a practice that is common
    in C.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何使用继承来擦除类型。当讨论类型擦除时，通常不考虑继承，但实际上，继承是C++中最常见的类型擦除形式。本示例很重要，因为它将讨论类型擦除是什么，以及为什么它在日常应用中非常有用，而不仅仅是简单地移除类型信息——这在C中很常见。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本示例中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try this recipe with the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试按照以下步骤进行本示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to lessons being taught in this
    recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Type erasure (or type erasing) is simply the act of removing, hiding, or reducing
    type information about an object, function, and so on. In the C language, type
    erasure is used all the time. Check out this example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除（或类型擦除）简单地是移除、隐藏或减少有关对象、函数等的类型信息。在C语言中，类型擦除经常被使用。看看这个例子：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, we create an array of `10` elements, and then we
    use the `memset()` function to clear the array to all zeros. The `memset()` function
    in C looks something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个包含`10`个元素的数组，然后使用`memset()`函数将数组清零。在C中，`memset()`函数看起来像这样：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in the preceding code snippet, the first parameter the `memset()` function
    takes is `void*`. The array in our preceding example, however, is an array of
    integers. The `memset()` function doesn't actually care what type you provide,
    so long as you provide a pointer to the type and a size that represents the total
    size of the type in bytes. The `memset()` function then proceeds to type cast
    the provided pointer to a type that represents a byte (in C, this is usually `char` or
    unsigned `char`), and then sets the value of the type, byte by byte.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`memset()`函数的第一个参数是`void*`。然而，在我们之前的例子中，数组是一个整数数组。`memset()`函数实际上并不关心你提供的是什么类型，只要你提供了指向该类型的指针和表示该类型总字节数的大小。然后，`memset()`函数将提供的指针强制转换为表示字节的类型（在C中通常是`char`或无符号`char`），然后逐字节设置类型的值。
- en: The use of `void*` in C is a form of type erasure. This type (pun intended)
    of erasure in C++ is typically discouraged as the only way to get the type information
    back is to use `dynamic_cast()`, which is slow (it requires a runtime type information
    lookup). Although there are many ways to perform type erasure in C++ without the
    need for a `void *`, let's focus on inheritance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中使用`void*`是一种类型擦除的形式。在C++中，这种类型（双关语）的擦除通常是不鼓励的，因为要恢复类型信息的唯一方法是使用`dynamic_cast()`，这很慢（需要运行时类型信息查找）。尽管有许多种方法可以在C++中执行类型擦除而不需要`void*`，让我们专注于继承。
- en: Inheritance is not generally described as type erasure in most literature, but
    it is likely the most widely used form of it. To better explore how this works,
    let's look at a common example. Suppose we are creating a game with multiple superheroes
    the user can choose from. Each superhero at some point has to attack the bad guy,
    but how the superhero attacks the bad guy varies from hero to hero.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在大多数文献中通常不被描述为类型擦除，但它很可能是最广泛使用的形式之一。为了更好地探讨这是如何工作的，让我们看一个常见的例子。假设我们正在创建一个游戏，其中用户可以选择多个超级英雄。每个超级英雄在某个时候都必须攻击坏家伙，但超级英雄如何攻击坏家伙因英雄而异。
- en: 'For example, consider the following code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码片段：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As shown in the preceding code snippet, our first hero doesn''t care whether
    the bad guy is on the ground or in the air (that is, the hero will successfully
    hit the bad guy regardless of the bad guy''s vertical distance), but will miss
    the bad guy if they are not in a specific horizontal position. Likewise, we might
    also have another hero as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，在我们的第一个英雄中，不关心坏家伙是在地面上还是在空中（也就是说，无论坏家伙的垂直距离如何，英雄都能成功击中坏家伙），但如果坏家伙不在特定的水平位置，英雄就会错过坏家伙。同样，我们可能还有另一个英雄如下：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second hero is the complete opposite of our first. This hero can successfully
    hit the bad guy anywhere on the ground but will miss if the bad guys is anywhere
    above the ground (the hero probably cannot reach them).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个英雄与我们的第一个完全相反。这个英雄可以成功地击中地面上的坏家伙，但如果坏家伙在地面以上的任何地方，他就会错过（英雄可能无法到达他们）。
- en: 'In the following example, both superheroes are fighting the bad guy at the
    same time:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，两个超级英雄同时与坏家伙战斗：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although we could call each superhero one at a time during the fight, it would
    be a lot more convenient if we could just loop through each hero in the fight
    and check to see which hero hits the bad guy versus which hero misses the bad
    guy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在战斗中一个一个地召唤每个超级英雄，但如果我们可以只循环遍历每个英雄并检查哪个英雄击中了坏家伙，哪个英雄错过了坏家伙，那将更加方便。
- en: In the preceding example, we have a hypothetical array of heroes that we loop
    through, checking to see which hero hits versus which hero misses. In this example,
    we don't care about the hero's type (that is, we don't care whether the hero is
    specifically our first or second hero), we simply care that each hero is actually
    a hero (and not an inanimate object) and that the hero is capable of attacking
    the bad guy. In other words, we need a way to erase each superhero's type so that
    we can put both heroes into a single array (which is not possible unless each
    hero is the same).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们有一个假想的英雄数组，我们循环遍历，检查哪个英雄击中了，哪个英雄错过了。在这个例子中，我们不关心英雄的类型（也就是说，我们不关心英雄是否特别是我们的第一个还是第二个英雄），我们只关心每个英雄实际上是一个英雄（而不是一个无生命的物体），并且英雄能够攻击坏家伙。换句话说，我们需要一种方法来擦除每个超级英雄的类型，以便我们可以将两个英雄放入单个数组中（除非每个英雄都是相同的，否则这是不可能的）。
- en: 'As you probably have already guessed, the most common way to accomplish this
    in C++ is to use inheritance (but as we will show later on in this chapter, it
    is not the only way). To start, we must first define a base class called `hero`,
    which each hero will inherit from, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，在C++中实现这一点的最常见方法是使用继承（但正如我们将在本章后面展示的那样，这并不是唯一的方法）。首先，我们必须定义一个名为`hero`的基类，每个英雄都将从中继承，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our example, the only common function between each hero is that they both
    can attack the bad guy, the `attack()` function is the same for all heroes. As
    a result, we have created a pure virtual base class with a single pure virtual
    function called `attack()` that each hero must implement. It should also be noted
    that for a class to be pure virtual all member functions must be set to `0`, and
    the class's destructor must be explicitly labeled as `virtual`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，每个英雄之间唯一的共同函数是它们都可以攻击坏家伙，`attack()`函数对所有英雄都是相同的。因此，我们创建了一个纯虚基类，其中包含一个名为`attack()`的单个纯虚函数，每个英雄都必须实现。还应该注意的是，为了使一个类成为纯虚类，所有成员函数必须设置为`0`，并且类的析构函数必须显式标记为`virtual`。
- en: 'Now that we have defined what a hero is, we can modify our heroes to inherit
    this pure virtual base class, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了什么是英雄，我们可以修改我们的英雄，使其继承这个纯虚基类，如下所示：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As shown, both heroes inherit from the pure virtual definition of a hero and
    override the `attack()` function as required. With this modification, we can now
    create our list of heroes as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，两个英雄都继承了英雄的纯虚定义，并根据需要重写了`attack()`函数。通过这种修改，我们现在可以按以下方式创建我们的英雄列表：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the preceding code, we observe the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中，我们观察到以下内容：
- en: We create an array of `hero` pointers (using `std::unique_ptr` to store the
    lifetime of the hero, a topic that will be discussed in the next chapter).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`hero`指针数组（使用`std::unique_ptr`来存储英雄的生命周期，这是下一章将讨论的一个主题）。
- en: This array is then initialized to contain two heroes (one of each).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，该数组被初始化为包含两个英雄（每个英雄一个）。
- en: Finally, we loop through each hero to see whether the hero successfully attacks
    the bad guy or misses.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历每个英雄，看英雄是否成功攻击坏人或者错过。
- en: When the `hero::attack()` function is called, the call is routed automatically
    to the correct `spiderman::attack()` and `captain_america::attack()` functions
    as needed through the use of inheritance.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`hero::attack()`函数时，调用会自动路由到正确的`spiderman::attack()`和`captain_america::attack()`函数，通过继承来实现。
- en: The array is erasing the type information of each hero in a type-safe manner
    to place each hero into a single container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该数组以类型安全的方式擦除了每个英雄的类型信息，将每个英雄放入单个容器中。
- en: Using C++ templates to write generic functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++模板编写通用函数
- en: In this recipe, we will learn how to erase (or ignore) type information leveraging
    C++ templates. You will learn how C++ templates can be used to implement a C++
    concept and how this type of erasure is used in the C++ Standard Library. This
    recipe is important as it will teach you how to better design your APIs as specifications
    that do not rely on specific types (or, in other words, how to write generic code).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何使用C++模板来擦除（或忽略）类型信息。您将学习如何使用C++模板来实现C++概念，以及这种类型擦除在C++标准库中的使用。这个示例很重要，因为它将教会您如何更好地设计您的API，使其不依赖于特定类型（或者换句话说，如何编写通用代码）。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本示例中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try this recipe with the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To compile the source code, run the following:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，可以通过运行以下命令来执行本文中的每个示例：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将逐个步骤地介绍每个示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the oldest and most widely used features of C++ is C++ templates. Like
    inheritance, C++ templates are not generally described as a form of type erasure,
    but they are. Type erasure is nothing more than the act of removing or, in this
    case, ignoring type information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: C++最古老和最广泛使用的功能之一是C++模板。与继承一样，C++模板通常不被描述为一种类型擦除，但它们实际上是。类型擦除只不过是删除或在这种情况下忽略类型信息的行为。
- en: 'Unlike the C language, however, type erasure in C++ generally attempts to avoid
    removing type information in favor of working around a type''s strict definition
    while retaining type safety. One way to accomplish this is through the use of
    C++ templates. To better explain this, let''s start with a simple example of a
    C++ template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与C语言不同，C++中的类型擦除通常试图避免删除类型信息，而是绕过类型的严格定义，同时保留类型安全。实现这一点的一种方法是通过使用C++模板。为了更好地解释这一点，让我们从一个C++模板的简单示例开始：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding example, we have created a simple function that calculates
    the power of two for any given input. For example, we can call this function as
    follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个简单的函数，用于计算任何给定输入的平方。例如，我们可以这样调用这个函数：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the compiler sees the use of the `pow2()` function, it automatically generates
    the following code for you (behind the scenes):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器看到`pow2()`函数的使用时，它会在幕后自动生成以下代码：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As shown in the preceding code snippet, the compiler creates two versions of
    the `pow2()` function: a version that takes an unsigned value and returns an unsigned
    one, and a version that takes an integer and returns an integer. The compiler
    created these two versions because the first time we used the `pow2()` function,
    we provided it with an unsigned value, while the second time we used the `pow2()`
    function, we provided it with `int`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，编译器创建了`pow2()`函数的两个版本：一个接受无符号值并返回无符号值，另一个接受整数并返回整数。编译器创建了这两个版本，是因为我们第一次使用`pow2()`函数时，我们提供了一个无符号值，而第二次使用`pow2()`函数时，我们提供了`int`。
- en: As far as our code is concerned, however, we don't actually care what type the
    function is provided, so long as the type that is provided can successfully execute
    `operator*()`. In other words, both the user of the `pow2()` function and the
    author of the `pow2()` function are safely ignoring (or erasing) the type information
    that is passed to and returned from the function from a conceptual point of view.
    The compiler, however, is very much aware of the types that are being provided
    and must safely handle each type as needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的代码而言，我们实际上并不关心函数提供的类型是什么，只要提供的类型能够成功执行`operator*()`。换句话说，`pow2()`函数的使用者和`pow2()`函数的作者都安全地忽略（或擦除）了从概念上传递给函数的类型信息。然而，编译器非常清楚正在提供的类型，并且必须根据需要安全地处理每种类型。
- en: This form of type erasure performs the erasure at the specification of the API,
    and in C++, this specification is called a concept. Unlike most APIs that dictate
    both input and output types (for example, the `sleep()` function takes an unsigned
    integer and only an unsigned integer), a concept specifically ignores the type
    in favor of defining, instead, what properties a given type must provide.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型擦除形式在API的规范处执行擦除，在C++中，这种规范被称为概念。与大多数API不同，后者规定了输入和输出类型（例如，`sleep()`函数接受一个无符号整数，只接受无符号整数），概念特别忽略类型，而是定义了给定类型必须提供的属性。
- en: 'For example, the preceding `pow2()` function has the following requirements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的`pow2()`函数有以下要求：
- en: The provided type must either be an integer type or provide an `operator *()`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的类型必顺要么是整数类型，要么提供`operator *()`。
- en: The provided type must be either copy-constructible or move-constructible.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的类型必须是可复制构造或可移动构造的。
- en: 'As shown in the previous code snippet, the `pow2()` function doesn''t care
    what type it is given so long as the type provided meets certain minimum requirements.
    Let''s examine a more complicated example to demonstrate how C++ templates can
    be used as a form of type erasure. Suppose we have two different heroes that are
    fighting a bad guy, and each hero provides the ability to attack the bad guy,
    which is shown with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，`pow2()`函数不关心它所接收的类型，只要所提供的类型满足一定的最小要求。让我们来看一个更复杂的例子，以演示C++模板如何被用作类型擦除的一种形式。假设我们有两个不同的英雄在与一个坏家伙战斗，每个英雄都提供了攻击坏家伙的能力，如下所示：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As shown in the preceding code snippet, each hero provides the ability to attack
    a bad guy, but neither hero shares anything in common other than the fact that
    both happen to provide an `attack()` function with the same function signature.
    We also do not have the ability to add inheritance to each hero (maybe our design
    cannot handle the extra `vTable` overhead that inheritance adds, or maybe the
    hero definition is provided to us).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，每个英雄都提供了攻击坏家伙的能力，但除了两者都提供具有相同函数签名的`attack()`函数之外，两者没有任何共同之处。我们也无法为每个英雄添加继承（也许我们的设计无法处理继承所增加的额外`vTable`开销，或者英雄定义是由其他人提供的）。
- en: 'Now suppose we have a complicated function that must call the `attack()` function
    for each hero. We could write the same logic for each hero (that is, manually
    duplicate the logic), or we could write a C++ template function to handle this
    for us, which is shown as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个复杂的函数，必须为每个英雄调用`attack()`函数。我们可以为每个英雄编写相同的逻辑（即手动复制逻辑），或者我们可以编写一个C++模板函数来处理这个问题，如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As shown in the preceding code snippet, we can leverage the type erasing properties
    of C++ templates to encapsulate our attack logic into a single template function.
    The preceding code doesn't care about what type it is provided so long as the
    type provides an `attack()` function that takes two integer types and returns
    an integer type (preferably `bool`, but any integer would work). In other words,
    so long as the type provided adheres to an agreed-upon concept, this template
    function will work, providing the compiler with a means to handle the type-specific
    logic for us.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们可以利用C++模板的类型擦除特性，将我们的攻击逻辑封装到一个单一的模板函数中。前面的代码不关心所提供的类型是什么，只要该类型提供了一个接受两个整数类型并返回一个整数类型（最好是`bool`，但任何整数都可以）的`attack()`函数。换句话说，只要所提供的类型符合约定的概念，这个模板函数就会起作用，为编译器提供一种处理类型特定逻辑的方法。
- en: 'We can call the preceding function as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式调用前面的函数：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This results in the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/70426f57-68a7-48bf-ac42-6ee95388297b.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70426f57-68a7-48bf-ac42-6ee95388297b.png)'
- en: Although this example shows how C++ templates can be used as a form of type
    erasure (at least for a specification to create a concept), when type erasure
    is discussed, there is a specific pattern called the type erasure pattern or just
    type erasure. In the next recipe, we will explore how we can leverage what we
    have learned in the first two recipes to erase type information generically while
    still supporting simple things such as containers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个示例展示了C++模板如何被用作类型擦除的一种形式（至少用于创建概念的规范），但是当讨论类型擦除时，有一种特定的模式称为类型擦除模式或者只是类型擦除。在下一个示例中，我们将探讨如何利用我们在前两个示例中学到的知识来擦除类型信息，同时仍然支持诸如容器之类的简单事物。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we learned how concepts can be used to ignore (or erasing) type-specific
    knowledge in favor of requiring a type to implemented a minimum set of features.
    These features can be enforce using SFINAE, a topic we discussed in greater detail
    in [Chapter 4](aff3ffea-2bdd-4d69-9e32-0edae7142703.xhtml), *Using Templates for
    Generic Programming*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们学习了如何使用概念来忽略（或擦除）特定类型的知识，而是要求类型实现一组最小的特性。这些特性可以使用SFINAE来强制执行，这是我们在[第4章](aff3ffea-2bdd-4d69-9e32-0edae7142703.xhtml)中更详细讨论的一个主题，*使用模板进行通用编程*。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In [Chapter 13](69ea92ce-8503-4c3f-95c7-9733bd86d039.xhtml), *Bonus – Using
    C++20 Features*, we will also discuss how the enforcement of a concept can be
    done using new features being added to C++20.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](69ea92ce-8503-4c3f-95c7-9733bd86d039.xhtml)中，*奖励-使用C++20功能*，我们还将讨论如何使用C++20新增的功能来执行概念的强制执行。
- en: Learning the C++ type eraser pattern
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习C++类型擦除模式
- en: In this recipe, we will learn what the type erasure pattern is in C++, and how
    we can leverage it to generically erase type information without sacrificing type-safety
    or requiring our types to inherit pure virtual base classes. This recipe is important
    as the type erasure pattern is used heavily in the C++ Standard Library and provides
    a simple way to encapsulate data types that do not share anything in common, other
    than providing a similar set of APIs, while still supporting things such as containers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习C++中类型擦除模式是什么，以及我们如何利用它来通用地擦除类型信息，而不会牺牲类型安全性或要求我们的类型继承纯虚拟基类。这个菜谱很重要，因为类型擦除模式在C++标准库中被大量使用，并提供了一种简单的方式来封装不共享任何共同之处的数据类型，除了提供一组类似的API，同时还支持诸如容器之类的东西。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本菜谱中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try this recipe with the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下步骤来制作这个菜谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端中，运行以下命令来下载源代码：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To compile the source code, run the following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码，请运行以下命令：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本菜谱中的每个示例：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它与本菜谱中所教授的课程的关系。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we typically think of C++ type erasure, this is the example we think of.
    The type erasure pattern is needed when we must leverage a set of objects as if
    they are related, that may or may not share a common base class (that is, they
    either do not use inheritance or if they do use inheritance, it is possible they
    do not inherit from the same set of classes).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通常考虑C++类型擦除时，这就是我们想到的例子。当我们必须将一组对象视为相关对象使用时，可能并不共享一个共同的基类（也就是说，它们要么不使用继承，要么如果使用继承，可能它们不继承自相同的一组类）时，就需要类型擦除模式。
- en: 'For example, suppose we have the following classes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下类：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As shown in the preceding code snippet, each class defines a different type
    of hero. We would like to do something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，每个类定义了不同类型的英雄。我们想要做的事情如下：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The problem is, each class doesn''t inherit from a similar base class, so we
    cannot just create an instance of each class and add them to `std::array` as the
    compiler would complain about the classes not being the same. We could store a
    raw `void *` pointer of each class in `std::array`, but then when it comes time
    to use `void *`, we would have to `dynamic_cast()` back to each type to do anything
    useful, like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，每个类都不继承自相似的基类，所以我们不能只创建每个类的实例并将它们添加到`std::array`中，因为编译器会抱怨这些类不相同。我们可以在`std::array`中存储每个类的原始`void
    *`指针，但是当使用`void *`时，我们将不得不使用`dynamic_cast()`来将其转换回每种类型以执行任何有用的操作，如下所示：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The use of `void *` is a form of type erasure, but this is far from ideal as
    the use of `dynamic_cast()` is slow, each new type that we add would only increase
    the number of `if` statements, and this implementation is far from C++ Core Guideline
    compliant.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`void *`是一种类型擦除的形式，但这远非理想，因为使用`dynamic_cast()`很慢，每添加一种新类型都只会增加`if`语句的数量，而且这种实现远非符合C++核心指南。
- en: 'There is another way, however, that we can address this problem. Suppose we
    wish to run the `attack()` function, which happens to be the same between each
    hero class (that is, each hero class at least adheres to a shared concept). If
    each class had used the following base class, we could just use inheritance, as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种方法可以解决这个问题。假设我们希望运行`attack()`函数，这个函数在每个英雄类之间是相同的（也就是说，每个英雄类至少遵循一个共享概念）。如果每个类都使用了以下基类，我们可以使用继承，如下所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The problem is, our hero classes do not inherit from this base class. So, instead,
    let''s create a wrapper class that does, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们的英雄类没有继承这个基类。因此，让我们创建一个继承它的包装器类，如下所示：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown in the preceding code snippet, we have created a template wrapper class
    that inherits from our base class. This wrapper stores an instance to whatever
    type it is given, and then overrides the `attack()` function that is defined in
    the pure virtual base class, which forwards a call to it, to the instance that
    the wrapper is storing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们创建了一个模板包装类，它继承自我们的基类。这个包装器存储给定类型的实例，然后覆盖了在纯虚拟基类中定义的`attack()`函数，该函数将调用转发给包装器存储的实例。
- en: 'Now, we can create our array as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的数组，如下所示：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`std::array` stores `std::unique_ptr` to our base class, and then we create
    our wrapper class (which inherits the base class) with each type we need, to store
    in the array. The compiler creates a version of the wrapper for each type that
    we need to store in the array, and since the wrapper inherits the base class,
    no matter what type we give the wrapper, the array can always store the resulting
    wrapper as needed.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array`存储了指向我们基类的`std::unique_ptr`，然后我们使用每种需要的类型创建我们的包装器类（它继承自基类），以存储在数组中。编译器为我们需要存储在数组中的每种类型创建了包装器的版本，由于包装器继承了基类，无论我们给包装器什么类型，数组总是可以按需存储结果包装器。'
- en: 'Now, from this array, we can do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从这个数组中执行以下操作：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And there you have it: type erasure in C++. This pattern leverages C++ templates
    to give an object the same properties of inheritance even if the object doesn''t
    directly use inheritance itself.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：C++中的类型擦除。这种模式利用C++模板，即使对象本身没有直接使用继承，也可以给对象赋予继承的相同属性。
- en: Implementing delegates with type erasing
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型擦除实现委托
- en: In this recipe, we will learn how to implement the delegate pattern, which is
    a pattern that has been around for years (and is heavily used by some other languages,
    such as ObjC). This recipe is important as it will teach you what a delegate is,
    and how to leverage this pattern in your own applications to provide better extensibility
    without requiring your APIs to use inheritance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何实现委托模式，这是一个已经存在多年的模式（并且被一些其他语言，比如ObjC，广泛使用）。这个示例很重要，因为它将教会你什么是委托，以及如何在你自己的应用程序中利用这种模式，以提供更好的可扩展性，而不需要你的API使用继承。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中的示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try this recipe with the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端中，运行以下命令来下载源代码：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To compile the source code, run the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令执行本示例中的每个示例：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you have ever read a book on C++, you have likely seen the apples and oranges
    example, which demonstrates how object-oriented programming works. The idea goes
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经读过一本关于C++的书，你可能已经看过苹果和橙子的例子，它演示了面向对象编程的工作原理。思路如下：
- en: An apple is a fruit.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果是一种水果。
- en: An orange is a fruit.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙子是一种水果。
- en: An apple is not an orange but both are fruit.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果不是橙子，但两者都是水果。
- en: This example is meant to teach how to organize your code into logical objects
    using inheritance. A logic that is shared by both an apple and an orange is written
    into an object called `fruit` while logic that is specific to an apple or an orange
    is written into the `apple` or `orange` objects that inherit from the base `fruit`
    object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子旨在教你如何使用继承将代码组织成逻辑对象。一个苹果和一个橙子共享的逻辑被写入一个叫做`fruit`的对象中，而特定于苹果或橙子的逻辑被写入继承自基类`fruit`的`apple`或`orange`对象中。
- en: This example is also, however, showing how to extend the functionality of a
    fruit. By subclassing a fruit, I can create an apple that is capable of doing
    more than the `fruit` base class. This idea of *extending* the functionality of
    a class is common in C++, and oftentimes, we think of using inheritance to implement
    it. In this recipe, we will explore how to do this without the need for the apple
    or the orange to leverage inheritance with something called a delegate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也展示了如何扩展水果的功能。通过对水果进行子类化，我可以创建一个苹果，它能够做比`fruit`基类更多的事情。这种*扩展*类功能的想法在C++中很常见，通常我们会考虑使用继承来实现它。在这个示例中，我们将探讨如何在不需要苹果或橙子使用继承的情况下实现这一点，而是使用一种称为委托的东西。
- en: Suppose you are creating a game, and you wish to implement a battlefield where
    heroes and bad guys are fighting. At some point in your code, each hero in the
    battle will need to attack the bad guys. The problem is heroes come and go within
    the fight as they need time to recover, and so you really need to maintain a list
    of heroes that are capable of attacking the bad guys, and you simply need to loop
    through this dynamically changing list of heroes to see whether their attacks
    succeed or not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个游戏，并希望实现一个英雄和坏人在战斗中战斗的战场。在代码的某个地方，战斗中的每个英雄都需要攻击坏人。问题是英雄在战斗中来来去去，因为他们需要时间恢复，所以你真的需要维护一个能够攻击坏人的英雄列表，并且你只需要循环遍历这个动态变化的英雄列表，看看他们的攻击是否成功。
- en: Each hero could store a list of heroes that subclass a common base class and
    then run an `attack()` function that each hero overrides, but this would require
    the use of inheritance, which might not be desired. We could also use the type
    erasure pattern to wrap each hero and then store pointers to our wrapper's base
    class, but this would be specific to our `attack()` function, and we believe there
    will be other instances where these types of extensions will be needed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个英雄都可以存储一个子类化共同基类的英雄列表，然后运行一个`attack()`函数，每个英雄都会重写，但这将需要使用继承，这可能不是期望的。我们也可以使用类型擦除模式来包装每个英雄，然后存储指向我们包装器的基类的指针，但这将特定于我们的`attack()`函数，并且我们相信将需要其他这些类型的扩展的情况。
- en: 'Enter the delegate pattern, which is an extension to the type erasure pattern.
    With the delegate pattern, we can write code like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 进入委托模式，这是类型擦除模式的扩展。使用委托模式，我们可以编写如下代码：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in the preceding code snippet, we have defined an instance of two different
    classes that are not alike, and then we have created an array that stores three
    delegates. The delegate's template parameter takes a function signature of `bool(int,
    int)`, while the delegate itself appears to be created from a function pointer
    as well as two member function pointers from the class instances we created earlier.
    We are then able to loop through each of the delegates and call them, effectively
    calling the function pointer and each member function pointer independently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们定义了两个不同的类的实例，然后创建了一个存储三个委托的数组。委托的模板参数采用`bool(int, int)`的函数签名，而委托本身似乎是从函数指针以及我们之前创建的类实例的两个成员函数指针创建的。然后我们能够循环遍历每个委托并调用它们，有效地独立调用函数指针和每个成员函数指针。
- en: The delegate pattern provides the ability to encapsulate different callable
    objects into a single object with a common type that is capable of calling the
    callable objects so long as they share the same function signature. More importantly,
    delegates can encapsulate both function pointers and member function pointers,
    providing the user of the API with the ability to store a private state if needed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 委托模式提供了将不同的可调用对象封装到一个具有共同类型的单个对象中的能力，该对象能够调用可调用对象，只要它们共享相同的函数签名。更重要的是，委托可以封装函数指针和成员函数指针，为API的用户提供了必要时存储私有状态的能力。
- en: 'To explain how this works, we will start simple and then build upon our example
    until we reach the final implementation. Let''s start with a base class as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这是如何工作的，我们将从简单的开始，然后逐步构建我们的示例，直到达到最终实现。让我们从一个基类开始：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As shown in the preceding code snippet, we have created a template of a pure
    virtual base class. The template arguments are `RET` (which defines a return value)
    and `ARGS...` (which define a variadic list of arguments). We then create a function
    called `func()`, which takes our list of arguments and returns the template return
    type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们创建了一个纯虚基类的模板。模板参数是`RET`（定义返回值）和`ARGS...`（定义可变参数列表）。然后我们创建了一个名为`func()`的函数，它接受我们的参数列表并返回模板返回类型。
- en: 'Next, let''s define a wrapper that inherits from the base class using the type
    erasure pattern (if you have not read the previous recipe, please do so now):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个从基类继承的包装器，使用类型擦除模式（如果您还没有阅读之前的示例，请现在阅读）：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Just like the type eraser pattern, we have a wrapper class that stores an instance
    of our type and then provides a function that the wrapper can call. The difference
    is the function that can be called is not statically defined and instead is defined
    by the template arguments that are provided. Furthermore, we also store a function
    pointer with the same function signature, which is initialized by the wrapper's
    constructor and called in the `func()` function using `std::invoke`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类型擦除模式一样，我们有一个包装器类，它存储我们的类型的实例，然后提供包装器可以调用的函数。不同之处在于可以调用的函数不是静态定义的，而是由提供的模板参数定义的。此外，我们还存储具有相同函数签名的函数指针，该函数指针由包装器的构造函数初始化，并在`func()`函数中使用`std::invoke`调用。
- en: This additional logic, compared to the typical type erasure example, provides
    the ability to define any function signature that we wish to call from the object
    we are storing in the wrapper instead of defining it ahead of time (meaning the
    function we wish to call can be determined at runtime and not compile time).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与典型的类型擦除示例相比，这个额外的逻辑提供了定义我们希望从我们在包装器中存储的对象中调用的任何函数签名的能力，而不是提前定义（意味着我们希望调用的函数可以在运行时而不是编译时确定）。
- en: 'We can then create our delegate class as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建我们的委托类如下：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As with the type erasure pattern, we store a pointer to the wrapper, which is
    created from the constructor of the delegate. The important detail to recognize
    here is the `T` type is not defined in the delegate itself. Instead, the `T` type is
    only known during the construction of the delegate which is used to create an
    instantiation of the wrapper. This means that each instance of a delegate is the
    same, even if the delegate is storing a wrapper that wraps different types. This
    allows us to use the delegate as follows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型擦除模式一样，我们将指针存储在包装器中，该包装器是从委托的构造函数中创建的。要注意的重要细节是`T`类型在委托本身中未定义。相反，`T`类型仅在创建委托时才知道，用于创建包装器的实例。这意味着每个委托实例都是相同的，即使委托存储了包装不同类型的包装器。这使我们可以像下面这样使用委托。
- en: 'Suppose we have two heroes that do not share a common base, but do provide
    an `attack()` function with the same signature:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个英雄，它们没有共同的基类，但提供了相同签名的`attack()`函数：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can leverage our delegate class to store an instance of our hero classes
    and call their attack functions as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们的委托类来存储我们的英雄类的实例，并调用它们的攻击函数如下：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This results in the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/36666375-3829-4923-ab93-fc4ef67966c3.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36666375-3829-4923-ab93-fc4ef67966c3.png)'
- en: 'Although we have already made significant progress in creating our delegate
    (it at least works), there are a few issues with this early implementation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经在创建我们的委托中取得了重大进展（它至少可以工作），但这个早期实现还存在一些问题：
- en: The delegate's signature is `bool, int, int`, which is misleading as we really
    want a function signature such as `bool(int, int)` so that the code is self-documenting
    (the delegate's type is a single function signature, not three different types).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托的签名是`bool, int, int`，这是误导性的，因为我们真正想要的是一个函数签名，比如`bool(int, int)`，这样代码就是自说明的（委托的类型是单个函数签名，而不是三种不同的类型）。
- en: This delegate cannot handle functions marked `const`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个委托不能处理标记为`const`的函数。
- en: We have to store an instance of the delegated object inside our wrapper, which
    prevents us from creating delegates to more than one function for the same object.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在包装器内部存储被委托对象的实例，这样我们就无法为同一对象创建多个函数的委托。
- en: We do not have support for non-member functions.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不支持非成员函数。
- en: Let's address each of these.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解决这些问题。
- en: Adding a function signature to our delegate
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的代理添加函数签名
- en: 'Although adding a function signature to our delegate as the template parameter
    can be done without the need for C++17, user-defined type deduction in C++17 makes
    this process simple. The following code snippet shows this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在不需要C++17的情况下可以向我们的代理添加函数签名作为模板参数，但是C++17中的用户定义类型推导使这个过程变得简单。以下代码片段展示了这一点：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As shown in the preceding code snippet, the user-defined type deduction tells
    the compiler how to take our delegate constructor and convert it into the template
    signature that we wish to use. Without this user-defined type deduction guide,
    the `delegate(RET(T::*)(ARGS...))` constructor would result in the delegate being
    deduced as `delegate<RET, ARGS...>`, which is not what we want. Instead, we would
    like the compiler to deduce `delegate<RET(ARGS...)>`. Nothing else about our delegate
    implementation needs to change. We simply need to tell the compiler how to perform
    type deduction.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示的代码片段显示，用户定义的类型推导告诉编译器如何将我们的代理构造函数转换为我们希望使用的模板签名。没有这个用户定义的类型推导指南，`delegate(RET(T::*)(ARGS...))`构造函数将导致代理被推断为`delegate<RET,
    ARGS...>`，这不是我们想要的。相反，我们希望编译器推断`delegate<RET(ARGS...)>`。我们的代理实现的其他方面都不需要改变。我们只需要告诉编译器如何执行类型推断。
- en: Adding const support to our delegate
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的代理添加const支持
- en: 'Our delegate currently cannot take a member function marked as `const` as we
    have not provided our delegate with a wrapper capable of doing so. For example,
    our heroes'' `attack()` function currently looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代理目前无法接受标记为`const`的成员函数，因为我们没有为我们的代理提供能够这样做的包装器。例如，我们英雄的`attack()`函数目前看起来像这样：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We would, however, like our hero `attack()` functions to look like the following
    since they do not modify any private member variables:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望我们的英雄`attack()`函数看起来像以下这样，因为它们不修改任何私有成员变量：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To support this change, we must create a wrapper that supports this, shown
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个改变，我们必须创建一个支持这一点的包装器，如下所示：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As shown in the preceding, this wrapper is the same as our previous wrapper
    with the difference being that the function signature that we store has an added
    `const` instance. For the delegate to use this additional wrapper, we must also
    provide an additional delegate constructor as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，这个包装器与我们之前的包装器相同，不同之处在于我们存储的函数签名具有额外的`const`实例。为了使代理使用这个额外的包装器，我们还必须提供另一个代理构造函数，如下所示：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This means we will also need an additional user-defined type deduction guide,
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们还需要另一个用户定义的类型推导指南，如下所示：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With these modifications, we can now support member functions marked with `const`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，我们现在可以支持标记为`const`的成员函数。
- en: Adding support for one-to-many to our delegate
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的代理添加一对多的支持
- en: 'Currently, our wrappers store an instance to each type. This approach is often
    used with type erasure, but in our case, it prevents the ability to create many
    delegates for the same object (that is, no support for one-to-many). To fix this,
    we will store a pointer to an object in our wrappers instead of the object itself,
    as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的包装器存储每种类型的实例。这种方法通常与类型擦除一起使用，但在我们的情况下，它阻止了为同一个对象创建多个代理的能力（即不支持一对多）。为了解决这个问题，我们将在我们的包装器中存储对象的指针，而不是对象本身，如下所示：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As shown in the preceding, the only change we have made is we store a pointer
    to the object we are wrapping instead of the object itself, which also means we
    need to initialize this pointer in our constructor. To use this new wrapper, we
    must modify our delegate constructor as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们所做的唯一改变是我们存储一个指向我们包装的对象的指针，而不是对象本身，这也意味着我们需要在构造函数中初始化这个指针。为了使用这个新的包装器，我们必须修改我们的代理构造函数如下：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This, in turn, means we must update our user-defined type deduction guides
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这又意味着我们必须更新我们的用户定义类型推导指南，如下所示：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With these modifications, we can now create our delegates as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，我们现在可以创建我们的代理，如下所示：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As shown in the preceding, the delegate takes a pointer to each object, which
    means we can create as many of these delegates as we wish, including the ability
    to create delegates to other member function pointers if needed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，代理接受每个对象的指针，这意味着我们可以创建任意数量的这些代理，包括根据需要创建对其他成员函数指针的代理的能力。
- en: Adding support for non-member functions to our delegate
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的代理添加对非成员函数的支持
- en: 'Finally, we need to modify the delegate to add support for non-member functions.
    Check out this example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改代理以支持非成员函数。看看这个例子：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To do this, we simply need to add another wrapper as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们只需要添加另一个包装器，如下所示：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As shown in the preceding, as with our original wrapper, we store a pointer
    to the function we wish to call, but in this case, we do not need to store a pointer
    to an object as there is no object (as this is a  non-member function wrapper).
    To use this new wrapper, we must add another delegate constructor as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，与我们的原始包装器一样，我们存储我们希望调用的函数的指针，但在这种情况下，我们不需要存储对象的指针，因为没有对象（因为这是一个非成员函数包装器）。为了使用这个新的包装器，我们必须添加另一个代理构造函数，如下所示：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This means we must also provide another user-defined type deduction guide as
    follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们还必须提供另一个用户定义的类型推导指南，如下所示：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With all of the modifications, we are finally able to use our delegate as defined
    at the beginning of this recipe:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些修改，我们最终能够使用我们在本篇文章开头定义的代理：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When this is executed, we get the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个被执行时，我们得到以下输出：
- en: '![](img/59994462-e91d-48fa-bcaf-1538fa6e4e37.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59994462-e91d-48fa-bcaf-1538fa6e4e37.png)'
- en: This delegate could further be extended to support lambda functions by adding
    yet another set of wrappers, and the need for `std::unique_pointer` in the delegate
    could be removed in favor of a placement new, using a small buffer the size of
    the member function wrapper (or, in other words, removing the dynamic memory allocation),
    which is sometimes referred to as a small size optimization.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个委托可以进一步扩展以支持lambda函数，方法是添加另一组包装器，并且可以通过使用一个小缓冲区来替换委托中的`std::unique_pointer`，从而避免动态内存分配，这个小缓冲区的大小与成员函数包装器相同（或者换句话说，实现小尺寸优化）。
