- en: 12\. Animation Blending and Montages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12\. 动画混合和蒙太奇
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to use the `Animation Montage`
    tool to create a unique throwing animation using the `Throw` animation sequence
    you imported in *Chapter 10*, *Creating a SuperSideScroller Game*. With this montage,
    you will create and use Anim Slots that will allow you to blend animations in
    the Animation Blueprint for the player character. You will also get to know how
    to use blending nodes to effectively blend the movement and throwing animations
    of the character.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，你将能够使用`动画蒙太奇`工具来创建一个独特的投掷动画，使用你在*第10章*中导入的`投掷`动画序列。通过这个蒙太奇，你将创建并使用动画插槽，允许你在玩家角色的动画蓝图中混合动画。你还将了解如何使用混合节点有效地混合角色的移动和投掷动画。
- en: After finalizing the player character animation, you will create the required
    class and assets for the enemy AI and learn more about Materials and `Material
    Instances`, which will give this enemy a unique visual color so that it can be
    differentiated in-game. Finally, the enemy will be ready for *Chapter 13*, *Enemy
    Artificial Intelligence*, where you will begin to create the AI behavior logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成玩家角色动画后，你将为敌人AI创建所需的类和资产，并学习更多关于材质和`材质实例`，这将使这个敌人在游戏中具有独特的视觉颜色，以便可以进行区分。最后，敌人将准备好进入*第13章*，*敌人人工智能*，在那里你将开始创建AI行为逻辑。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the last chapter, you were able to bring the player character to life by
    implementing movement animations in a `Blend Space` and using that `Blend Space`
    in an Animation Blueprint to drive the animations based on the player's speed.
    You were then able to implement functionality in C++ based on player input to
    allow the character to sprint. Lastly, you took advantage of the animation state
    machine built-in Animation Blueprints to drive the character movement state and
    jumping states to allow fluid transitions between walking and jumping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你通过在`混合空间`中实现移动动画，并在动画蓝图中使用该`混合空间`来根据玩家速度驱动动画，使玩家角色栩栩如生。然后，你能够基于玩家输入在C++中实现功能，允许角色奔跑。最后，你利用动画蓝图内置的动画状态机来驱动角色的移动状态和跳跃状态，以实现在行走和跳跃之间流畅过渡。
- en: With the player character Animation Blueprint and state machine working, it's
    time to introduce Animation Montages and Anim Slots by implementing the character's
    `Throw` animation. In this chapter, you will learn more about animation blending,
    see how Unreal Engine handles the blending of multiple animations by creating
    an `Animation Montage`, and work with a new `Save Cached Pose` and `Layered blend
    per bone` so that the player can correctly blend the movement animations you handled
    in the previous chapter with the new throwing animation you will implement in
    this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着玩家角色动画蓝图和状态机的工作，现在是时候通过实现角色的“投掷”动画来介绍动画蒙太奇和动画插槽了。在本章中，你将学习更多关于动画混合的知识，看看虚幻引擎如何通过创建`动画蒙太奇`来处理多个动画的混合，并使用新的`保存缓存姿势`和`骨骼层叠混合`，以便玩家可以正确地将你在上一章中处理的移动动画与你将在本章实现的新投掷动画进行混合。
- en: Let's start by learning about what Animation Montages and Anim Slots are and
    how they can be used for character animation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先学习一下什么是动画蒙太奇和动画插槽，以及它们如何用于角色动画。
- en: Animation Blending, Anim Slots, and Animation Montages
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画混合、动画插槽和动画蒙太奇
- en: Animation blending is the process of transitioning between multiple animations
    on a skeletal mesh as seamlessly as possible. You are already familiar with the
    techniques of animation blending because you created a `Blend Spaces` asset for
    the player character in *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State
    Machines*. In this `Blend Space`, the character smoothly blends between the `Idle`,
    `Walking`, and `Running` animations. You will now extend this knowledge by exploring
    and implementing new additive techniques to combine the movement animations of
    the character with a throwing animation. Through the use of an `Anim Slot`, you
    will send the throwing animation to a set of upper body bones, and its children's
    bones, to allow movement and throwing animations to apply at the same time without
    negatively impacting the other. But first, let's talk more about Animation Montages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 动画混合是在骨骼网格上尽可能无缝地过渡多个动画之间的过程。你已经熟悉了动画混合的技术，因为你在*第11章*中为玩家角色创建了一个`混合空间`资产，其中角色在“空闲”、“行走”和“奔跑”动画之间平滑过渡。现在，你将通过探索和实现新的叠加技术来扩展这些知识，以将角色的移动动画与投掷动画结合起来。通过使用`动画插槽`，你将把投掷动画发送到一组上半身骨骼和其子骨骼，以便允许移动和投掷动画同时应用而不会对其他动画产生负面影响。但首先，让我们更多地谈谈动画蒙太奇。
- en: Animation Montages are a very powerful asset that allows you to combine multiple
    animations and split these combined animations into what is called **Sections**.
    Sections can then be played back individually, in a specific sequence, or even
    looped.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蒙太奇是一个非常强大的资产，它允许你将多个动画组合在一起，并将这些组合动画分割成所谓的**部分**。部分可以单独播放，按特定顺序播放，甚至循环播放。
- en: Animation Montages are also useful because you can control animations through
    montages from Blueprints or C++; this means you can call logic, update variables,
    replicate data, and so on based on the animation section being played, or if any
    `Notifies` are called within the montage. In C++, there is the `UAnimInstance`
    object, which you can use to call functions such as `UAnimInstance::Montage_Play`,
    which allows you to access and play montages from C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蒙太奇也很有用，因为你可以通过蓝图或C++来控制动画蒙太奇中的动画；这意味着你可以根据正在播放的动画部分或蒙太奇中调用的任何“通知”来调用逻辑、更新变量、复制数据等。在C++中，有一个`UAnimInstance`对象，你可以使用它来调用诸如`UAnimInstance::Montage_Play`之类的函数，这允许你从C++中访问和播放蒙太奇。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method will be used in *Chapter 14*, *Spawning the Player Projectile*,
    when you begin to add polish to the game. More information about how animations
    and `Notifies` are handled by Unreal Engine 4 in C++ can be found at [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将在*第14章*“生成玩家投射物”中使用，当您开始为游戏添加细节时。关于动画和`Notifies`在Unreal Engine 4中如何通过C++处理的更多信息可以在[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/AnimNotifies/UAnimNotifyState/index.html)找到。
- en: You will learn more about `Notifies` in the first exercise of this chapter,
    and you will code your own notify state in *Chapter 14*, *Spawning the Player Projectile*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章的第一个练习中了解更多关于`Notifies`的内容，并且您将在*第14章*“生成玩家投射物”中编写自己的通知状态。
- en: 'The image below shows the `Persona` editor for Animation Montages. However,
    this will be broken down even further in *Exercise 12.01*, *Setting Up the Animation
    Montage*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片显示了动画蒙太奇的`Persona`编辑器。然而，这将在*练习12.01*“设置动画蒙太奇”中进一步拆分：
- en: '![Figure 12.1: The Persona editor, which opens when editing an Animation Montage'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：Persona编辑器，在编辑动画蒙太奇时打开'
- en: '](img/B16183_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_01.jpg)'
- en: 'Figure 12.1: The Persona editor, which opens when editing an Animation Montage'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：Persona编辑器，在编辑动画蒙太奇时打开
- en: Just like in Animation Sequences, Animation Montages allow `Notifies` to be
    triggered along the timeline of a section of an animation, which can then trigger
    sounds, particle effects, and events. `Event` `Notifies` will allow us to call
    logic from Blueprint or C++. Epic Games provides an example in their documentation
    of a weapon reload `Animation Montage` that is split between animations for `reload
    start`, `reload loop`, and `reload complete`. By splitting these animations and
    applying `Notifies` for `sounds` and `events`, developers have complete control
    over how long the `reload loop` will play based on internal variables, and control
    over any additional sounds or effects to play during the course of the animation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在动画序列中一样，动画蒙太奇允许在动画的时间轴上触发`Notifies`，这样可以触发声音、粒子效果和事件。`Event` `Notifies`将允许我们从蓝图或C++中调用逻辑。Epic
    Games在他们的文档中提供了一个武器重新加载`Animation Montage`的示例，该示例分为`reload start`、`reload loop`和`reload
    complete`的动画。通过拆分这些动画并应用`Notifies`来触发`sounds`和`events`，开发人员可以完全控制`reload loop`根据内部变量播放多长时间，以及在动画过程中播放任何额外的声音或效果。
- en: Lastly, Animation Montages support what are called **Anim Slots**. Anim Slots
    allow you to categorize an animation, or a set of animations, that can later be
    referenced in Animation Blueprints to allow unique blending behavior based on
    the slot. This means that you can define an Anim Slot that can later be used in
    Animation Blueprints to allow animations using this slot to blend on top of the
    base movement animations in any way you want; in our case, only affecting the
    upper body of the player character and not the lower body.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，动画蒙太奇支持所谓的**Anim Slots**。Anim Slots允许您对动画或一组动画进行分类，稍后可以在Animation Blueprint中引用，以允许基于插槽的独特混合行为。这意味着您可以定义一个Anim
    Slot，稍后可以在Animation Blueprint中使用，以允许使用此插槽的动画以任何您想要的方式在基本移动动画的基础上混合；在我们的情况下，只影响玩家角色的上半身而不影响下半身。
- en: Let's begin by creating the `Animation Montage` for the player character's `Throw`
    animation in the first exercise.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为玩家角色的`Throw`动画创建`Animation Montage`，这是第一个练习。
- en: 'Exercise 12.01: Setting Up the Animation Montage'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：设置动画蒙太奇
- en: One of the last things you need to do for the player character is to set up
    the Anim Slot that will separately categorize this animation as an upper body
    animation. You will use this Anim Slot in conjunction with blending functions
    in the Animation Blueprint to allow the player character to throw a projectile,
    while still correctly animating the lower body while moving and jumping.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色的最后一件事是设置Anim Slot，这将单独将此动画分类为上半身动画。您将在Animation Blueprint中使用此Anim Slot，结合混合函数，允许玩家角色投掷投射物，同时在移动和跳跃时正确地对下半身进行动画处理。
- en: By the end of this exercise, the player character will be able to play the `Throw`
    animation only with their upper body, while their lower body will still use the
    `movement animation` that you defined in the previous chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习结束时，玩家角色将能够仅使用上半身播放`Throw`动画，而下半身仍将使用您在上一章中定义的`movement animation`。
- en: 'Let''s begin by creating the `Animation Montage` for the character, throwing
    and setting up the Anim Slot there:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为角色创建`Animation Montage`，投掷并设置那里的Anim Slot：
- en: First, navigate to the `/MainCharacter/Animation` directory, which is where
    all of the animation assets are located.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到`/MainCharacter/Animation`目录，这是所有动画资产的位置。
- en: Now, *right-click* in the content browser and hover over the `Animation` option
    from the available drop-down menu.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在内容浏览器中*右键单击*，悬停在可用下拉菜单中的`Animation`选项上。
- en: Then, *left-click* to select the `Animation Montage` option from the additional
    drop-down menu that appears.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*左键单击*以选择从出现的附加下拉菜单中的`Animation Montage`选项。
- en: Just as with creating other animation-based assets, such as `Blend Spaces` or
    `Animation Blueprints`, Unreal Engine will ask you to assign a `Skeleton` object
    for this `Animation Montage`. In this case, select `MainCharacter_Skeleton`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像创建其他基于动画的资产一样，比如`Blend Spaces`或`Animation Blueprints`，Unreal Engine会要求您为这个`Animation
    Montage`分配一个`Skeleton`对象。在这种情况下，选择`MainCharacter_Skeleton`。
- en: 'Name the new `Animation Montage` `AM_Throw`. Now, *double-left-click* to open
    the montage:![Figure 12.2: You have successfully created an Animation Montage
    asset'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`Animation Montage`命名为`AM_Throw`。现在，*双击*打开蒙太奇：![图12.2：您已成功创建了一个动画蒙太奇资产
- en: '](img/B16183_12_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_02.jpg)'
- en: 'Figure 12.2: You have successfully created an Animation Montage asset'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：您已成功创建了一个动画蒙太奇资产
- en: When you open the `Animation Montage` asset, you are presented with a similar
    editor layout, as you would when opening an `Animation Sequence`. There is a `Preview`
    window that shows the main character skeleton in the default T pose, but once
    you add animations to this montage, the skeleton will update to reflect those changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“动画剪辑”资产时，您会看到类似的编辑器布局，就像打开“动画序列”时一样。有一个“预览”窗口，显示默认的T形主角骨架，但一旦您向这个剪辑添加动画，骨架将更新以反映这些变化。
- en: With this exercise complete, you have successfully created an `Animation Montage`
    asset for the `Super SideScroller` project. Now it is time to learn more about
    Animation Montages and how you can add the `Throw` animation and Anim Slot you
    need in order to blend the `Throw` animation with the existing character movement animations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已成功为“超级横向卷轴”项目创建了一个“动画剪辑”资产。现在是时候了解更多关于动画剪辑以及如何添加您需要的“投掷”动画和动画插槽，以便将“投掷”动画与现有角色移动动画混合。
- en: Animation Montages
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画剪辑
- en: 'Have a look at the following figure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图：
- en: '![Figure 12.3: The animation Preview window in the Animation Montage Persona
    editor'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：动画剪辑Persona编辑器中的动画预览窗口'
- en: '](img/B16183_12_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_03.jpg)'
- en: 'Figure 12.3: The animation Preview window in the Animation Montage Persona
    editor'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：动画剪辑Persona编辑器中的动画预览窗口
- en: 'Underneath the `Preview` window, you have the main montage timeline, in addition
    to other sections; let''s evaluate these sections from top to bottom:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在“预览”窗口下方，您有主要剪辑时间轴，以及其他部分；让我们从上到下评估这些部分：
- en: '`Montage` section is a collection of animations that can add one or more animations
    to. You can also *right-click* on any point in the timeline to create a `Sections`
    area.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “剪辑”部分是可以添加一个或多个动画的动画集合。您还可以*右键单击*时间轴上的任何点以创建“部分”区域。
- en: '**Sections**: Sections, as mentioned before, allow you to set the order of
    how the individual animation sequences are played and whether a section should
    loop.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分**：如前所述，部分允许您设置单个动画序列的播放顺序以及部分是否应该循环。'
- en: 'For the purposes of the throw montage, you do not need to use this feature
    since you will only be using one animation in this montage:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了投掷剪辑的目的，您不需要使用此功能，因为您只会在此剪辑中使用一个动画：
- en: '![Figure 12.4: The Preview window and the Montage and Sections areas'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：预览窗口和剪辑和部分区域'
- en: '](img/B16183_12_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_04.jpg)'
- en: 'Figure 12.4: The Preview window and the Montage and Sections areas'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：预览窗口和剪辑和部分区域
- en: '`Elemental Timing` section gives you a preview of the montage and the sequential
    order of the varied aspects of the montage. The playback order of `Notifies`,
    the `Montage` section, and other elements will be visually displayed here to give
    you a quick preview of how the montage will work.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “元素定时”部分为您提供了剪辑的预览以及剪辑各个方面的顺序。通知的播放顺序，“剪辑”部分和其他元素将在这里进行可视化显示，以便您快速预览剪辑的工作方式。
- en: '`Notifies` gives you the ability to add points to an animation time frame that
    can then notify other systems to perform an action or to call logic from both
    Blueprints and C++. Notify options, such as `Play Sound` or `Play Particle Effect`,
    allow you to play a sound or particle at a specific time in the animation. One
    example is during a reload animation of a weapon; you can add a notify to the
    timeline of the animation to play a reload sound at the precise moment of reloading.
    You will use these `Notifies` later on in this project when you implement the
    throwing projectile:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通知”使您能够在动画时间轴上添加点，然后通知其他系统执行操作或从蓝图和C++中调用逻辑。通知选项，如“播放声音”或“播放粒子效果”，允许您在动画的特定时间播放声音或粒子。一个例子是在武器重新装填的动画中；您可以在动画的时间轴上添加通知，以在重新装填的精确时刻播放重新装填声音。在实现投掷投射物时，您将在项目的后续阶段使用这些“通知”：
- en: '![Figure 12.5: The Element Timing and Notifies areas'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：元素定时和通知区域'
- en: '](img/B16183_12_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_05.jpg)'
- en: 'Figure 12.5: The Element Timing and Notifies areas'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：元素定时和通知区域
- en: Now that you are familiar with the interface for Animation Montages, you can
    add the `Throw` animation to the montage by following the next exercise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了动画剪辑的界面，您可以按照下一个练习将“投掷”动画添加到剪辑中。
- en: 'Exercise 12.02: Adding the Throw Animation to the Montage'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：将投掷动画添加到剪辑中
- en: 'Now that you have a better understanding of what Animation Montages are and
    how these assets work, it is time to add the `Throw` animation to the montage
    you created in *Exercise 12.01*, *Setting Up the Animation Montage*. Although
    you will only be adding one animation to this montage, it is important to emphasize
    that you can add multiple unique animations to a montage that you can then play
    back. Now, let''s start by adding the `Throw` animation you imported into the
    project in *Chapter 10*, *Creating a SuperSideScroller Game*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对动画剪辑是什么以及这些资产如何工作有了更好的理解，是时候将“投掷”动画添加到您在*练习12.01*中创建的剪辑中了，*设置动画剪辑*。尽管您只会向此剪辑添加一个动画，但重要的是要强调您可以向剪辑添加多个独特的动画，然后播放。现在，让我们开始通过添加您在*第10章*中导入项目的“投掷”动画来开始：
- en: 'In `Asset Browser`, find the `Throw` animation asset. Then, *left-click* and
    drag it onto the timeline under the `Montage` section:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在“资产浏览器”中找到“投掷”动画资产。然后，*左键单击*并将其拖放到“剪辑”部分下的时间轴上：
- en: '![Figure 12.6: The Asset Browser window with animation-based assets'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：带有基于动画的资产的资产浏览器窗口'
- en: '](img/B16183_12_06.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_06.jpg)'
- en: 'Figure 12.6: The Asset Browser window with animation-based assets'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：带有基于动画的资产的资产浏览器窗口
- en: 'Once an animation is added to the Animation Montage, the character skeleton
    in the `Preview` window will update to reflect this change and begin playing the
    animation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将动画添加到动画剪辑中，预览窗口中的角色骨架将更新以反映此更改并开始播放动画：
- en: '![Figure 12.7: The player character begins to animate'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：玩家角色开始动画'
- en: '](img/B16183_12_07.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_07.jpg)'
- en: 'Figure 12.7: The player character begins to animate'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：玩家角色开始动画
- en: Now that the `Throw` animation has been added to the Animation Montage, you
    can move on to create the `Anim Slot`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`投掷`动画已经添加到动画蒙太奇中，您可以继续创建`动画槽`。
- en: The `Anim Slot Manager` tab should be docked next to the `Asset Browser` tab
    on the right-hand side. If you don't see the `Anim Slot Manager` tab, you can
    access it by navigating to the `Window` tab in the toolbar at the top of the `Animation
    Montage` editor window. There, *left-click* to select the option for `Anim Slot
    Manager` and the window will appear.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`动画槽管理器`选项卡应该停靠在右侧的`资产浏览器`选项卡旁边。如果您看不到`动画槽管理器`选项卡，可以通过导航到顶部`动画蒙太奇`编辑器窗口的工具栏中的`窗口`选项卡来访问它。在那里，*左键单击*选择`动画槽管理器`选项，窗口将出现。'
- en: With this exercise complete, you have added the `Throw` animation to your new
    Animation Montage and you were able to play back the animation to preview how
    it looks in the editor through `Persona`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您已经将`投掷`动画添加到了新的动画蒙太奇中，并且可以回放动画，以预览它在`Persona`编辑器中的外观。
- en: Now, you can move on to learn more about Anim Slots and `Anim Slot Manager`
    before adding your own unique Anim Slot to use for animation blending later in
    this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以继续学习有关动画槽和`动画槽管理器`的知识，然后在本章后面的部分中添加自己独特的动画槽，以便用于动画混合。
- en: Anim Slot Manager
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画槽管理器
- en: '`Anim Slot Manager` is where you, as the name suggests, manage your `Anim Slots`.
    From this tab, you can create new `Group` by *left-clicking* on the `Add Group`
    option and labeling it `Face` to articulate to others that the slots within this
    group affect the face of the character. By default, Unreal Engine provides you
    with a `Group` called `DefaultGroup` and an `Anim Slot` called `DefaultSlot` that
    is in that group.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`动画槽管理器`是您管理`动画槽`的地方，正如其名称所示。从该选项卡中，您可以通过*左键单击*`添加组`选项创建新的`组`，并将其标记为`Face`，以向其他人说明该组中的槽影响角色的面部。默认情况下，虚幻引擎为您提供了一个名为`DefaultGroup`的`组`和一个名为`DefaultSlot`的`动画槽`，该槽位于该组中。'
- en: Let's create a new Anim Slot.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的动画槽。
- en: 'Exercise 12.03: Adding a New Anim Slot'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：添加新的动画槽
- en: Now that you have a better understanding of Anim Slots and `Anim Slot Manager`,
    you can follow these steps to create a new Anim Slot, which you will call `Upper
    Body`. Once you have this new slot created, it can then be used and referenced
    in your Animation Blueprint to handle animation blending, which you will do in
    a later exercise.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对动画槽和`动画槽管理器`有了更好的理解，您可以按照以下步骤创建一个名为`上半身`的新动画槽。创建了这个新槽后，它可以在动画蓝图中使用和引用，以处理动画混合，这将在以后的练习中进行。
- en: 'Let''s create the Anim Slot by doing the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建动画槽：
- en: In `Anim Slot Manager`, *left-click* on the `Add Slot` option.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`动画槽管理器`中，*左键单击*`添加槽`选项。
- en: When adding a new slot, Unreal will ask you to give this `Anim Slot` a name.
    Name this slot `Upper Body`. Anim Slot naming is important, much like naming any
    other assets and parameters, because you will be referencing this slot in the
    Animation Blueprint later.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加新槽时，虚幻将要求您给这个`动画槽`命名。将此槽命名为`上半身`。动画槽的命名很重要，就像命名其他任何资产和参数一样，因为您稍后将在动画蓝图中引用此槽。
- en: With the Anim Slot created, you can now update the slot used for the `Throw` montage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了动画槽后，现在可以更新用于`投掷`蒙太奇的槽。
- en: 'In the `Montage` section, there is a drop-down menu that displays the applied
    `Anim Slot`; by default, it''s set to `DefaultGroup.DefaultSlot`. *Left-click*,
    and from the drop-down menu, select `DefaultGroup.Upper Body`:![Figure 12.8: The
    new Anim Slot will appear in the drop-down list'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Montage`部分，有一个下拉菜单显示应用的`动画槽`；默认情况下，它设置为`DefaultGroup.DefaultSlot`。*左键单击*，然后从下拉菜单中选择`DefaultGroup.Upper
    Body`：![图12.8：新的动画槽将出现在下拉列表中
- en: '](img/B16183_12_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_08.jpg)'
- en: 'Figure 12.8: The new Anim Slot will appear in the drop-down list'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：新的动画槽将出现在下拉列表中
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After changing `Anim Slot`, you may notice that the player character stops animating
    and returns to the T pose. Don't worry – if this happens, just close the `Animation
    Montage` and reopen it. Once reopened, the character will play the `Throw` animation
    again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`动画槽`后，您可能会注意到玩家角色停止动画并返回到T形状。不用担心-如果发生这种情况，只需关闭`动画蒙太奇`，然后重新打开它。重新打开后，角色将再次播放`投掷`动画。
- en: With your `Anim Slot` created and in place in the `Throw` montage, it is now
    time for you to update the Animation Blueprint so that the player character is
    aware of this slot and animates correctly based on it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了您的`动画槽`并放置在`投掷`蒙太奇中后，现在是时候更新动画蓝图，以便玩家角色意识到这个槽，并根据它正确地进行动画。
- en: Navigate to the `AnimBP_SuperSideScroller_MainCharacter` asset in the `/MainCharacter/Blueprints/`
    directory.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/MainCharacter/Blueprints/`目录中的`AnimBP_SuperSideScroller_MainCharacter`资产。
- en: Open this asset by *double-left-clicking* and opening `Anim Graph`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*双击*打开此资产并打开`动画图`。
- en: With this exercise complete, you have created your first Anim Slot using `Anim
    Slot Manager`, available in the Animation Montage. With this slot in place, it
    can now be used and referenced in the player character Animation Blueprint to
    handle the animation blending required to blend the `Throw` animation and the
    movement animations you implemented in the previous chapter. Before you do this,
    you need to learn more about the `Save Cached Pose` node in Animation Blueprints.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您已经使用`动画槽管理器`在动画蒙太奇中创建了您的第一个动画槽。有了这个槽，现在可以在玩家角色动画蓝图中使用和引用它，以处理在上一章中实现的`投掷`动画和移动动画之间所需的动画混合。在执行此操作之前，您需要了解有关动画蓝图中`保存缓存姿势`节点的更多信息。
- en: Save Cached Pose
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存缓存姿势
- en: There are cases when working with complex animations and characters requires
    you to reference a pose that is outputted by a state machine in more than one
    place. If you hadn't noticed already, the output pose from your `Movement` state
    machine cannot be connected to more than one other node. This is where the `Save
    Cached Pose` node comes in handy; it allows you to cache, or store, a pose that
    can then be referenced in multiple places at once. You will need to use this to
    set up the new Anim Slot for the upper body animation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复杂动画和角色时，有时需要在多个地方引用状态机输出的姿势。如果你还没有注意到，你的“Movement”状态机的输出姿势不能连接到多个其他节点。这就是“Save
    Cached Pose”节点派上用场的地方；它允许你缓存或存储一个姿势，然后可以在多个地方引用。你需要使用它来设置上半身动画的新Anim Slot。
- en: Let's get started.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Exercise 12.04: Save Cached Pose of the Movement State Machine'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：保存Movement状态机的缓存姿势
- en: 'To effectively blend the `Throw` animation, which uses the `Upper Body Anim
    Slot` you created in the previous exercise with the movement animations already
    in place for the player character, you need to be able to reference the `Movement`
    state machine in the Animation Blueprint. To do this, do the following to implement
    the `Save Cached Pose` node in the Animation Blueprint:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地混合使用上一练习中创建的“Upper Body Anim Slot”和已经存在的玩家角色的移动动画的“Throw”动画，你需要能够在动画蓝图中引用“Movement”状态机。为了实现这一点，按照以下步骤在动画蓝图中实现“Save
    Cached Pose”节点：
- en: 'In `Anim Graph`, *right-click* and search for `New Save Cached Pose`. Name
    this `Movement Cache`:![Figure 12.9: The Pose will be evaluated once per frame
    and then cached'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Anim Graph”中，*右键单击*并搜索“New Save Cached Pose”。将其命名为“Movement Cache”：![图12.9：姿势将在每帧评估一次，然后被缓存
- en: '](img/B16183_12_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_09.jpg)'
- en: 'Figure 12.9: The Pose will be evaluated once per frame and then cached'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：姿势将在每帧评估一次，然后被缓存
- en: 'Now, instead of connecting your `Movement` state machine directly to the output
    pose, connect it to the cache node:![Figure 12.10: The Movement state machine
    is being cached'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，不要直接将你的“Movement”状态机连接到输出姿势，而是连接到缓存节点：![图12.10：Movement状态机正在被缓存
- en: '](img/B16183_12_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_10.jpg)'
- en: 'Figure 12.10: The Movement state machine is being cached'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：Movement状态机正在被缓存
- en: With the `Movement` state machine pose being cached, all you have to do now
    is reference it. This can be done by searching for the `Use Cached Pose` node.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用缓存的“Movement”状态机姿势，现在你只需要引用它。这可以通过搜索“使用缓存的姿势”节点来实现。
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All cached poses will show in the context-sensitive menu. Just make sure you
    select the cached pose with the name you gave it in *Step 1*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有缓存的姿势都会显示在上下文敏感菜单中。只需确保选择你在*步骤1*中给它的名字的缓存姿势。
- en: 'With the cached pose node available, connect it to `Output Pose` of the `AnimGraph`:![Figure
    12.11: This is identical to having the Movement state'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了缓存姿势节点后，将其连接到“AnimGraph”的“Output Pose”：![图12.11：这与将Movement状态机直接连接到输出姿势相同
- en: machine directly connected to Output Pose
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 直接连接到输出姿势
- en: '](img/B16183_12_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_11.jpg)'
- en: 'Figure 12.11: This is identical to having the Movement state machine directly
    connected to Output Pose'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：这与将Movement状态机直接连接到输出姿势相同
- en: You will notice now, after *Step 4*, that the main character will animate correctly
    and move as you expect after the last chapter. This proves that the caching of
    the `Movement` state machine is working. The image below shows the player character
    back in his `Idle` animation in the preview window of the Animation Blueprint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*之后，你会注意到主角在最后一章之后会正确地进行动画并移动。这证明了“Movement”状态机的缓存正在工作。下面的图片显示了玩家角色在动画蓝图的预览窗口中回到了“Idle”动画。
- en: 'Now that you have the caching of the `Movement` state machine working, you
    will use this cache to blend animations through the skeleton based on the `Anim
    Slot` you created:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“Movement”状态机的缓存工作正常，你将使用这个缓存来通过骨骼上的“Anim Slot”混合动画：
- en: '![Figure 12.12: The main character is animating as expected'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：主角正在按预期进行动画'
- en: '](img/B16183_12_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_12.jpg)'
- en: 'Figure 12.12: The main character is animating as expected'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：主角正在按预期进行动画
- en: With this exercise complete, you now have the ability to reference the cached
    `Movement` state machine pose anywhere you would like within the Animation Blueprint.
    With this accessibility in place, you can now use the cached pose to begin the
    blending between the cached movement pose and the `Upper Body` Anim Slot using
    a function called `Layered blend per bone`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你现在可以在动画蓝图中任何你想要的地方引用缓存的“Movement”状态机姿势。有了这个便利，你现在可以使用缓存的姿势开始在缓存的移动姿势和“Upper
    Body” Anim Slot之间进行混合，使用一个叫做“Layered blend per bone”的函数。
- en: Layered blend per bone
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Layered blend per bone
- en: The node that you will use to blend animations here is `Layered blend per bone`.
    This node masks out a set of bones on the character skeleton for an animation
    to ignore those bones.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这里使用的节点是“Layered blend per bone”。这个节点可以屏蔽角色骨骼上的一组骨骼，使动画忽略这些骨骼。
- en: In the case of our player character and the `Throw` animation, you will mask
    out the lower body so that only the upper body animates. The goal is to be able
    to perform the throw and movement animations at the same time and have these animations
    blend together; otherwise, when you perform the throw, the movement animations
    would completely break.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的玩家角色和“Throw”动画，你将屏蔽下半身，以便只有上半身进行动画。目标是能够同时执行投掷和移动动画，并使这些动画混合在一起；否则，当你执行投掷时，移动动画会完全中断。
- en: 'Exercise 12.05: Blending Animation with the Upper Body Anim Slot'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05：使用上半身Anim Slot混合动画
- en: The `Layered blend per bone` function allows us to blend the `Throw` animation
    with the movement animations you implemented in the previous chapter, and give
    you control over how much influence the `Throw` animation will have on the player
    character skeleton.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: “每个骨骼的分层混合”功能允许我们将“投掷”动画与您在上一章中实现的移动动画混合，并控制“投掷”动画对玩家角色骨骼的影响程度。
- en: In this exercise, you will use the `Layered blend per bone` function to completely
    mask out the lower body of the character when playing the `Throw` animation so
    that it does not influence the character movement animation of the lower body.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用“每个骨骼的分层混合”功能完全屏蔽角色的下半身，当播放“投掷”动画时，以便它不会影响角色下半身的移动动画。
- en: 'Let''s begin by adding the `Layered blend per bone` node and discuss its input
    parameters and its settings:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加“每个骨骼的分层混合”节点开始，并讨论其输入参数和设置：
- en: Inside the Animation Blueprint, *right-click* and search for `Layered blend
    per bone` in the `Context Sensitive` search.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画蓝图中，*右键单击*并在“上下文敏感”搜索中搜索“每个骨骼的分层混合”。
- en: '*Figure 12.13* shows the `Layered blend per bone` node and its parameters.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.13*显示了“每个骨骼的分层混合”节点及其参数。'
- en: The first parameter, `Base Pose`, is for the base pose of the character; in
    this case, the cached pose of the `Movement` state machine will be the base pose.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数“基础姿势”是角色的基础姿势；在这种情况下，“移动”状态机的缓存姿势将是基础姿势。
- en: The second parameter is the `Blend Pose 0` node that you want to layer on top
    of `Base Pose`; keep in mind that selecting `Add Pin` will create additional `Blend
    Pose` and `Blend Weights` parameters. For now, you will only be working with one
    `Blend Pose` node.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是您想要在“基础姿势”上叠加的“混合姿势0”节点；请记住，选择“添加引脚”将创建额外的“混合姿势”和“混合权重”参数。现在，您只会使用一个“混合姿势”节点。
- en: 'The last parameter is `Blend Weights`, which is how much `Blend Pose` will
    affect `Base Pose` on a scale from `0.0` to `1.0` as an alpha:![Figure 12.13:
    The Layered blend per bone node'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是“混合权重”，它是“混合姿势”对“基础姿势”的影响程度，范围从“0.0”到“1.0”作为alpha值：![图12.13：每个骨骼的分层混合节点
- en: '](img/B16183_12_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_13.jpg)'
- en: 'Figure 12.13: The Layered blend per bone node'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：每个骨骼的分层混合节点
- en: Before you connect anything to this node, you will need to add a layer to its properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接任何内容到此节点之前，您需要向其属性中添加一个层。
- en: '*Left-click* to select the node and navigate to `Details`. You will need to
    *left-click* on the arrow next to `Layer Setup` to find the first index, `0`,
    of this setup. *Left-click* on `+` next to `Branch Filters` to create a new filter.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*选择节点并导航到“详细信息”。您需要*左键单击*“层设置”旁边的箭头，以找到此设置的第一个索引“0”。*左键单击*“分支过滤器”旁边的“+”以创建新的过滤器。'
- en: 'There are again two parameters here, namely the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次有两个参数，即以下参数：
- en: '`Bone Name`: The bone to specify where the blending will take place and determine
    the child hierarchy of bones masked out. In the case of the main character skeleton
    for this project, set `Bone Name` to `Spine`. *Figure 12.14* shows how the `Spine`
    bone and its children are unassociated with the lower body of the main character.
    This can be seen in the `Skeleton` asset, `MainCharacter_Skeleton`:![Figure 12.14:
    The Spine bone and its children are associated'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “骨骼名称”：指定混合将发生的骨骼，并确定被屏蔽的骨骼的子层次结构。在本项目的主角骨架中，将“骨骼名称”设置为“脊柱”。*图12.14*显示了“脊柱”骨及其子骨与主角的下半身不相关联。这可以在“骨架”资产“MainCharacter_Skeleton”中看到：![图12.14：脊柱骨及其子骨与主角的下半身不相关联
- en: with the upper body of the main character
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与主角的上半身
- en: '](img/B16183_12_14.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_14.jpg)'
- en: 'Figure 12.14: The Spine bone and its children are associated with the upper
    body of the main character'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：脊柱骨及其子骨与主角的上半身相关联
- en: '`Blend Depth`: The depth in which bones and their children will be affected
    by the animation. A value of `0` will not affect the rooted children of the selected bone.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “混合深度”：骨骼及其子骨受动画影响的深度。值为“0”将不会影响所选骨骼的根子骨。
- en: '`Mesh Space Rotation Blend`: Determines whether or not to blend bone rotations
    in `mesh space` or in `local space`. `Mesh Space` rotation refers to the skeletal
    mesh''s bounding box as its base rotation, while `Local Space` rotation refers
    to the local rotation of the bone name in question. In this case, we want the
    rotation blend to occur in mesh space, so we will set this parameter to true.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “网格空间旋转混合”：确定是否在“网格空间”或“本地空间”中混合骨骼旋转。“网格空间”旋转是指骨架网格的边界框作为其基本旋转，而“本地空间”旋转是指所讨论的骨骼名称的局部旋转。在这种情况下，我们希望旋转混合发生在网格空间中，因此我们将将此参数设置为true。
- en: 'Blending is propagated to all the children of a bone to stop blending on particular
    bones, add them to the array, and make their blend depth value `0`. The final
    result is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 混合传播到骨骼的所有子骨，以停止在特定骨骼上的混合，将它们添加到数组中，并将它们的混合深度值设为“0”。最终结果如下：
- en: '![Figure 12.15: You can set up multiple layers with one blend node'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15：您可以使用一个混合节点设置多个层'
- en: '](img/B16183_12_15.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_15.jpg)'
- en: 'Figure 12.15: You can set up multiple layers with one blend node'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：您可以使用一个混合节点设置多个层
- en: 'With the settings in place on the `Layered blend per bone` node, you can connect
    the `Movement Cache` cached pose into the `Base Pose` node of the layered blend.
    Make sure you connect the output of the `Layered blend per bone` node to `Output
    Pose` of the Animation Blueprint:![Figure 12.16: Add the cached pose for the Movement
    state machine'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“每个骨骼的分层混合”节点上设置好参数后，您可以将“移动缓存”缓存姿势连接到分层混合的“基础姿势”节点。确保将“每个骨骼的分层混合”节点的输出连接到动画蓝图的“输出姿势”：![图12.16：添加移动状态机的缓存姿势
- en: to the Layered blend per bone node
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到每个骨骼的分层混合节点
- en: '](img/B16183_12_16.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_16.jpg)'
- en: 'Figure 12.16: Add the cached pose for the Movement state machine to the Layered
    blend per bone node'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：将移动状态机的缓存姿势添加到每个骨骼的分层混合节点
- en: Now it's time to use the Anim Slot you created earlier to filter only the animations
    using this slot through the `Layered blend per bone` node.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用您之前创建的Anim Slot，通过“Layered blend per bone”节点仅过滤使用此插槽的动画了。
- en: '*Right-click* in the `AnimGraph` and search for `DefaultSlot`. *Left-click*
    to select the `Slot` node and navigate to `Details`. There, you will find the
    `Slot Name` property. *Left-click* on this drop-down to find and select the `DefaultGroup.Upper
    Body` slot.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AnimGraph`中*右键单击*，搜索`DefaultSlot`。*左键单击*选择`Slot`节点并导航到`Details`。在那里，您会找到`Slot
    Name`属性。*左键单击*此下拉菜单，找到并选择`DefaultGroup.Upper Body`插槽。
- en: When changing the `Slot Name` property, the `Slot` node will update to represent
    this new name. The `Slot` node requires a source pose, which will again be a reference
    to the `Movement` state machine. This means that you need to create another `Use
    Cached Pose` node for the `Movement Cache` pose.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改“Slot Name”属性时，“Slot”节点将更新以表示这个新名称。“Slot”节点需要一个源姿势，这将再次是对“Movement”状态机的引用。这意味着您需要为“Movement
    Cache”姿势创建另一个“Use Cached Pose”节点。
- en: 'Connect the cached pose into the source of the `Slot` node:![Figure 12.17:
    Filtering the cached Movement pose through the Anim Slot'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓存的姿势连接到“Slot”节点的源：![图12.17：通过Anim Slot过滤缓存的Movement姿势
- en: '](img/B16183_12_17.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_17.jpg)'
- en: 'Figure 12.17: Filtering the cached Movement pose through the Anim Slot'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：通过Anim Slot过滤缓存的Movement姿势
- en: 'All that is left to do now is connect the `Upper Body` slot node to the `Blend
    Pose 0` input. Then, connect the final pose of `Layered blend per bone` to the
    result of the `Output Pose` Animation Blueprint:![Figure 12.18: The final setup
    of the main character''s Animation Blueprint'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的就是将“Upper Body”插槽节点连接到“Blend Pose 0”输入。然后，将“Layered blend per bone”的最终姿势连接到“Output
    Pose”动画蓝图的结果：![图12.18：主角动画蓝图的最终设置
- en: '](img/B16183_12_18.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_18.jpg)'
- en: 'Figure 12.18: The final setup of the main character''s Animation Blueprint'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：主角动画蓝图的最终设置
- en: With the Anim Slot and the `Layered blend per bone` node in place within the
    main character's Animation Blueprint, you are finally done with the animation
    side of the main character.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在主角动画蓝图中放置了Anim Slot和“Layered blend per bone”节点后，您终于完成了主角的动画部分。
- en: Next, let's have a brief discussion about the importance of animation blending
    for the `Throw` animation and what the `Throw` animation will be used for, before
    you move on to *Exercise 12.06*, *Previewing the Throw Animation*, where you will
    preview the `Throw` animation in the game.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要讨论一下“投掷”动画的动画混合的重要性以及“投掷”动画将用于什么，然后再继续*练习12.06*，在那里您将在游戏中预览“投掷”动画。
- en: The Throw Animation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投掷动画
- en: So far, you have put a lot of work into ensuring that the `Throw` animation
    blends correctly with the `Movement` animations that you set up in the Animation
    Blueprint in the previous chapter. The main reason behind this effort is to ensure
    the visual fidelity of the character when performing multiple animations at once.
    You will learn first-hand the visual consequences of incorrectly setting up animation
    blending in the exercises and activity ahead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经投入了大量的工作，以确保“投掷”动画与之前章节中在动画蓝图中设置的“移动”动画正确融合。这一努力的主要原因是确保角色在执行多个动画时的视觉保真度。在接下来的练习和活动中，您将亲身体会到错误设置动画混合的视觉后果。
- en: Getting back to the `Throw` animation, every modern video game implements animation
    blending in one form or another, so long as the art direction and the game mechanics
    require such a feature. An example of a modern game franchise that extraordinarily
    uses animations is the *Uncharted* series developed by *Naughty Dog*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到“投掷”动画，每款现代视频游戏都以某种形式实现动画混合，只要美术指导和游戏机制需要这样的功能。一个极好地运用动画的现代游戏系列的例子是由*Naughty
    Dog*开发的*Uncharted*系列。
- en: 'If you are unfamiliar with the franchise, you can watch the full gameplay of
    the latest installment here: [https://www.youtube.com/watch?v=5evF_funE8A](https://www.youtube.com/watch?v=5evF_funE8A).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这个系列不熟悉，您可以在这里观看最新版本的完整游戏玩法：[https://www.youtube.com/watch?v=5evF_funE8A](https://www.youtube.com/watch?v=5evF_funE8A)。
- en: 'What the *Uncharted* series does very well is use thousands of animations and
    blending techniques to give the player character an incredible sense of *realism*,
    *weight*, and *movement* that feels really good while you play the game. Although
    the `Super SideScroller` project will not be anywhere as polished as this, you
    are learning the basics of what is needed to make incredible animations for video
    games:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*Uncharted*系列非常擅长使用成千上万的动画和混合技术，为玩家角色带来令人难以置信的*真实感*、*重量感*和*动感*，让您在玩游戏时感觉非常良好。虽然*Super
    SideScroller*项目不会像这样精致，但您正在学习制作视频游戏中不可思议动画所需的基础知识：'
- en: 'Exercise 12.06: Previewing the Throw Animation'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.06：预览投掷动画
- en: 'In the previous exercise, you did a lot of work to allow animation blending
    between the player character''s `Movement` animations and the `Throw` animation
    by using the `Save Cached Pose` and `Layered blend per bone` nodes. Perform the
    following steps to preview the `Throw` animation in-game and see the fruits of
    your labor:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您做了很多工作，通过使用“Save Cached Pose”和“Layered blend per bone”节点，允许玩家角色的“Movement”动画和“Throw”动画之间进行动画混合。执行以下步骤，在游戏中预览“Throw”动画，并看到您劳动的成果：
- en: Navigate to the `/MainCharacter/Blueprints/` directory and open the character's
    `BP_SuperSideScroller_MainCharacter` Blueprint.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/MainCharacter/Blueprints/`目录，并打开角色的`BP_SuperSideScroller_MainCharacter`蓝图。
- en: If you recall, in the last chapter you created `Input Action` for throwing with
    the `ThrowProjectile` name.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还记得，在上一章中，您为投掷创建了名为“ThrowProjectile”的“Input Action”。
- en: Inside `Event Graph` of the character's Blueprint, *right-click* and search
    for `ThrowProjectile` in the `Context Sensitive` drop-down search. Select it with
    a *left-click* to create the event node in the graph.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色蓝图的“事件图”中，*右键单击*并在“上下文敏感”下拉搜索中搜索“ThrowProjectile”。用*左键单击*选择它，在图表中创建事件节点。
- en: With this event in place, you need a function that allows you to play an `Animation
    Montage` when the player uses the *left mouse button* to throw.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个事件，您需要一个函数，允许您在玩家使用*左鼠标按钮*投掷时播放“动画蒙太奇”。
- en: '*Right-click* in `Event Graph` and search for `Play Montage`. Make sure not
    to confuse this with a similar function `Play Anim Montage`.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*在“事件图”中搜索“Play Montage”。确保不要将其与类似的函数“Play Anim Montage”混淆。'
- en: 'The `Play Montage` function requires two important inputs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “Play Montage”函数需要两个重要的输入：
- en: '`Montage to Play`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Montage to Play”
- en: '`In Skeletal Mesh Component`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在骨骼网格组件”
- en: Let's first handle `Skeletal Mesh Component`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先处理“骨骼网格组件”。
- en: 'The player character has a `Skeletal Mesh Component` that can be found in the
    Components tab labeled `Mesh`. Left-click and drag out a `Get` reference to this
    variable and connect it to the `In Skeletal Mesh Component` input of this function:![Figure
    12.19: The mesh of the player character connected'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家角色有一个“骨骼网格组件”，可以在标记为“网格”的组件选项卡中找到。左键单击并拖动一个“Get”引用到这个变量，并将其连接到此函数的“In Skeletal
    Mesh Component”输入：![图12.19：玩家角色的网格连接
- en: to the In Skeletal Mesh Component input
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到In Skeletal Mesh Component输入
- en: '](img/B16183_12_19.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_19.jpg)'
- en: 'Figure 12.19: The mesh of the player character connected to the In Skeletal
    Mesh Component input'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：玩家角色的网格连接到In Skeletal Mesh Component输入
- en: 'The last thing to do now is to tell this function which montage to play. Luckily
    for you, there is only one montage that exists in this project: `AM_Throw`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要做的最后一件事是告诉这个函数播放哪个蒙太奇。幸运的是，这个项目中只有一个蒙太奇存在：“AM_Throw”。
- en: '*Left-click* on the drop-down menu under the `Montage to Play` input and *left-click*
    to select `AM_Throw`.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Montage to Play”输入下的下拉菜单上*左键单击*，然后*左键单击*选择“AM_Throw”。
- en: 'Finally, connect the `Pressed` execution output of the `ThrowProjectile` event
    to the execution input pin of the `Play Montage` function:![Figure 12.20: When
    the player presses the ThrowProjectile input actions, the AM_Throw montage will
    be played'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“ThrowProjectile”事件的“Pressed”执行输出连接到“Play Montage”函数的执行输入引脚：![图12.20：当玩家按下ThrowProjectile输入动作时，将播放AM_Throw蒙太奇
- en: '](img/B16183_12_20.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_20.jpg)'
- en: 'Figure 12.20: When the player presses the ThrowProjectile input actions, the
    AM_Throw montage will be played'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：当玩家按下ThrowProjectile输入动作时，将播放AM_Throw蒙太奇
- en: Now, when you click your *left mouse button*, the player character will play
    the throwing `Animation Montage`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您点击*左鼠标按钮*时，玩家角色将播放投掷“动画蒙太奇”。
- en: 'Notice now how you can walk and run at the same time as throwing, and each
    animation blends together so as to not interfere with one another:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注意一下，您可以同时行走和奔跑，同时投掷，每个动画都会混合在一起，不会相互干扰：
- en: '![Figure 12.21: The player character can now move and throw'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.21：玩家角色现在可以移动和投掷'
- en: '](img/B16183_12_21.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_21.jpg)'
- en: 'Figure 12.21: The player character can now move and throw'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：玩家角色现在可以移动和投掷
- en: Don't worry about any bugs you might see when using the *left mouse button*
    action repeatedly to play the `Throw` montage; these issues will be addressed
    when you implement the projectile that will be thrown in a later chapter for this
    project. For now, you just want to know that the work done on the `Anim Slot`
    and the `Animation Blueprint` give the desired result for animation blending.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心重复使用*左鼠标按钮*动作播放“Throw”蒙太奇时可能出现的任何错误；在后面的章节中，当您实现将要投掷的抛射物时，这些问题将得到解决。现在，您只想知道在“Anim
    Slot”和“Animation Blueprint”上所做的工作是否能够实现所需的动画混合结果。
- en: Let's continue with the `SuperSideScroller` project by now creating the C++
    class, the Blueprints, and the Materials necessary to set up the enemy for use
    in the next chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过现在创建C++类、蓝图和材质来设置敌人，以便在下一章中使用。
- en: The Super Side Scroller Game Enemy
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级横向卷轴游戏敌人
- en: With the player character animating correctly when moving and performing the
    `Throw` animation, it is time to talk about the enemy type that the `SuperSideScroller`
    game will feature. We will have a simple type of enemy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色在移动和执行“Throw”动画时正确播放动画时，现在是时候谈论“SuperSideScroller”游戏将呈现的敌人类型了。我们将有一个简单类型的敌人。
- en: This enemy will have a basic back-and-forth movement pattern and will not support
    any attacks; only by colliding with the player character will it be able to inflict
    damage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个敌人将有一个基本的来回移动模式，不支持任何攻击；只有与玩家角色碰撞时才能造成伤害。
- en: In the next exercise, you will set up the base enemy class in C++ for the first
    enemy type and configure the enemy's Blueprint and Animation Blueprint in preparation
    for *Chapter 13*, *Enemy Artificial Intelligence*, where you will implement the
    AI of this enemy. For the sake of efficiency and time, you will use the assets
    already provided by Unreal Engine 4 in the `SideScroller` template for the enemy.
    This means you will be using the skeleton, skeletal mesh, animations, and the
    Animation Blueprint of the default mannequin asset. Let's begin by creating the
    first enemy class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将为第一种敌人类型设置基础敌人类的C++，并配置敌人的蓝图和动画蓝图，为*第13章*“敌人人工智能”做准备，在那里您将实现这个敌人的人工智能。为了效率和时间考虑，您将使用Unreal
    Engine 4在“SideScroller”模板中已经提供的资产用于敌人。这意味着您将使用默认人偶资产的骨架、骨骼网格、动画和动画蓝图。让我们开始创建第一个敌人类。
- en: 'Exercise 12.07: Creating the Enemy Base C++ Class'
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.07：创建敌人基础C++类
- en: 'The goal of this exercise is to create a new enemy class from scratch and to
    have the enemy ready to use in *Chapter 13*, *Enemy Artificial Intelligence*,
    when you develop the AI. To start, create a new enemy class in C++ by following
    these steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是从头开始创建一个新的敌人类，并在 *第 13 章* *敌人人工智能* 中准备好使用敌人。首先，按照以下步骤在 C++ 中创建一个新的敌人类：
- en: In the editor, navigate to `File` and select `New C++ Class` to get started
    with creating your new enemy class.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，导航到 `文件` 并选择 `新建 C++ 类` 来开始创建新的敌人类。
- en: Next, make sure you check the `Show All Classes` box toward the top of the `Choose
    Parent Class` window prompt before attempting to search for a class. Then, search
    for `SuperSideScrollerCharacter` and *left-click* it to select it as the parent
    class.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请确保在尝试搜索类之前，检查 `选择父类` 窗口提示的顶部的 `显示所有类` 复选框。然后，搜索 `SuperSideScrollerCharacter`
    并 *左键单击* 选择它作为父类。
- en: Lastly, you need to give this class a name and select a directory. Name this
    class `EnemyBase` and do not change the directory path. When ready, *left-click*
    on the `Create Class` button to have Unreal Engine create the new class for you.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要给这个类起一个名字并选择一个目录。将这个类命名为 `EnemyBase`，并不要更改目录路径。准备好后，*左键单击* `Create Class`
    按钮，让虚幻引擎为您创建新的类。
- en: When you create a new class, Unreal Engine will automatically open Visual Studio
    for you with the `.cpp` and `.h` files ready to go. For now, you will not make
    any changes to the code, so close Visual Studio.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新类时，虚幻引擎会自动为您打开 Visual Studio，并准备好 `.cpp` 和 `.h` 文件。目前，您不会对代码进行任何更改，因此关闭
    Visual Studio。
- en: Let's create the folder structure in the content browser for the enemy assets next.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为敌人资产在内容浏览器中创建文件夹结构。接下来。
- en: 'Head back to the Unreal Engine 4 editor, navigate to the content browser, and
    create a new folder called `Enemy`:![Figure 12.22: New folders are created by
    right-clicking on existing'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到虚幻引擎 4 编辑器，导航到内容浏览器，并创建一个名为 `Enemy` 的新文件夹：![图 12.22：通过右键单击现有文件夹创建新文件夹
- en: folders and selecting New Folder
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹并选择新文件夹
- en: '](img/B16183_12_22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_22.jpg)'
- en: 'Figure 12.22: New folders are created by right-clicking on existing folders
    and selecting New Folder'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22：通过右键单击现有文件夹并选择新文件夹来创建新文件夹
- en: In the `Enemy` folder, create another folder called `Blueprints`, where you
    will create and save the Blueprint assets for the enemy.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Enemy` 文件夹中，创建另一个名为 `Blueprints` 的文件夹，您将在其中创建并保存敌人的蓝图资产。
- en: 'In the `/Enemy/Blueprints` directory, *right-click* and select `Blueprint Class`.
    From `Pick Parent Class`, search for the new C++ class you just made, `EnemyBase`,
    as shown:![Figure 12.23: Now, the new EnemyBase class is available for you to
    create a Blueprint from'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/Enemy/Blueprints` 目录中，*右键单击* 并选择 `蓝图类`。从 `选择父类` 中搜索您刚刚创建的新 C++ 类 `EnemyBase`，如图所示：![图
    12.23：现在，新的 EnemyBase 类可供您创建蓝图
- en: '](img/B16183_12_23.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_23.jpg)'
- en: 'Figure 12.23: Now, the new EnemyBase class is available for you to create a
    Blueprint from'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23：现在，新的 EnemyBase 类可供您创建蓝图
- en: Name this `BP_Enemy`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `BP_Enemy`。
- en: Now that you have the `Blueprint` for the first enemy using the `EnemyBase`
    class as the parent class, it is time to handle the `Animation Blueprint`. You
    will use the default `Animation Blueprint` that is provided to you by Unreal Engine
    in the `SideScroller` template project. Follow the steps in the next exercise
    to create a duplicate of the existing `Animation Blueprint` and move it to the
    `/Enemy/Blueprints` directory.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经使用 `EnemyBase` 类作为父类为第一个敌人创建了 `蓝图`，是时候处理 `动画蓝图` 了。您将使用虚幻引擎在 `SideScroller`
    模板项目中提供给您的默认 `动画蓝图`。按照下一个练习中的步骤创建现有 `动画蓝图` 的副本并将其移动到 `/Enemy/Blueprints` 目录。
- en: 'Exercise 12.08: Creating and Applying the Enemy Animation Blueprint'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.08：创建和应用敌人动画蓝图
- en: In the previous exercise, you created a `Blueprint` for the first enemy using
    the `EnemyBase` class as the parent class. In this exercise, you will be working
    with the Animation blueprint.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您创建了使用 `EnemyBase` 类作为父类的第一个敌人的 `蓝图`。在这个练习中，您将处理动画蓝图。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Navigate to the `/Mannequin/Animations` directory and find the `ThirdPerson_AnimBP`
    asset.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/Mannequin/Animations` 目录，并找到 `ThirdPerson_AnimBP` 资产。
- en: 'Now, duplicate the `ThirdPerson_AnimBP` asset. There are two ways to duplicate
    an asset:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制 `ThirdPerson_AnimBP` 资产。有两种方法可以复制资产：
- en: Select the desired asset in the content browser and press *CTRL* + *W*.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内容浏览器中选择所需的资产，然后按 *CTRL* + *W*。
- en: '*Right-click* on the desired asset in the content browser and select `Duplicate`
    from the drop-down menu.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内容浏览器中 *右键单击* 所需的资产，然后从下拉菜单中选择 `复制`。
- en: Now, *left-click* and drag this duplicate asset into the `/Enemy/Blueprints`
    directory and select the option to move when you release the *left-click* mouse button.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，*左键单击* 并拖动此重复的资产到 `/Enemy/Blueprints` 目录，并在释放 *左键单击* 鼠标按钮时选择移动选项。
- en: 'Name this duplicate asset `AnimBP_Enemy`. It is best to create a duplicate
    of an asset that you can later modify if you so desire without risking the functionality
    of the original:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此重复的资产命名为 `AnimBP_Enemy`。最好创建一个资产的副本，以便稍后根据需要进行修改，而不会影响原始资产的功能：
- en: With the enemy `Blueprint` and `Animation Blueprint` created, it's time to update
    the enemy Blueprint to use the default `Skeletal Mesh` mannequin and the new `Animation
    Blueprint` duplicate.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人 `蓝图` 和 `动画蓝图` 创建完成后，现在是时候更新敌人蓝图，以使用默认的 `骨骼网格` 人体模型和新的 `动画蓝图` 副本了。
- en: Navigate to `/Enemy/Blueprints` and open `BP_Enemy`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/Enemy/Blueprints` 并打开 `BP_Enemy`。
- en: 'Next, navigate to the `Mesh` component and select it to access its `Details`
    panel. First, assign `SK_Mannequin` to the `Skeletal Mesh` parameter, as shown:![Figure
    12.24: You will use the default SK_Mannequin skeletal mesh for the new enemy'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到 `Mesh` 组件并选择它以访问其 `详细信息` 面板。首先，将 `SK_Mannequin` 分配给 `骨骼网格` 参数，如图所示：![图
    12.24：您将使用默认的 SK_Mannequin 骨骼网格为新敌人
- en: '](img/B16183_12_24.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_24.jpg)'
- en: 'Figure 12.24: You will use the default SK_Mannequin skeletal mesh for the new
    enemy'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：您将使用默认的SK_Mannequin骨骼网格作为新敌人的角色
- en: 'Now you need to apply the `AnimBP_Enemy Animation Blueprint` to the `Mesh`
    component. Navigate to the `Animation` category of the `Mesh` component''s `Details`
    panel, and under `Anim Class`, assign `AnimBP_Enemy`:![Figure 12.25: Assign the
    new AnimBP_Enemy Animation Blueprint as the Anim'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将“AnimBP_Enemy动画蓝图”应用到“Mesh”组件上。导航到“Mesh”组件的“详细信息”面板的“动画”类别，在“动画类”下，分配“AnimBP_Enemy”：![图12.25：将新的AnimBP_Enemy动画蓝图分配为动画
- en: Class for the enemy character
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 类别为敌人角色
- en: '](img/B16183_12_25.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_25.jpg)'
- en: 'Figure 12.25: Assign the new AnimBP_Enemy Animation Blueprint as the Anim Class
    for the enemy character'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：将新的AnimBP_Enemy动画蓝图分配为敌人角色的动画类
- en: 'Lastly, you will notice that the character mesh is positioned and rotated incorrectly
    when previewing the character in the `Preview` window. Fix this by setting the
    `Transform` property of the `Mesh` component to the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当在“预览”窗口中预览角色时，您会注意到角色网格的位置和旋转不正确。通过将“Mesh”组件的“变换”属性设置为以下内容来修复这个问题：
- en: '`Location`: (`X` = `0.000000`, `Y` = `0.000000`, `Z` = `-90.000000`)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “位置”：（“X”=“0.000000”，“Y”=“0.000000”，“Z”=“-90.000000”）
- en: '`Rotation`: (Roll= `0.000000`, Pitch= `0`, Yaw= `-90.000000`)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “旋转”：（Roll=“0.000000”，Pitch=“0”，Yaw=“-90.000000”）
- en: '`Scale`: (`X` = `1.000000`, `one` = `1.000000`, `Z` = `1.000000`)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “缩放”：（“X”=“1.000000”，“one”=“1.000000”，“Z”=“1.000000”）
- en: 'The `Transform` settings will appear as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: “变换”设置将如下所示：
- en: '![Figure 12.26: These are the transform settings so that your character'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.26：这些是变换设置，以便您的角色'
- en: is positioned and rotated correctly
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 被正确定位和旋转
- en: '](img/B16183_12_26.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_26.jpg)'
- en: 'Figure 12.26: These are the transform settings so that your character is positioned
    and rotated correctly'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：这些是变换设置，以便您的角色被正确定位和旋转
- en: 'The following figure shows the settings of the `Mesh` component so far. Please
    make sure your settings match what is displayed here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了迄今为止“Mesh”组件的设置。请确保您的设置与此处显示的相匹配：
- en: '![Figure 12.27: The settings for the Mesh component of your enemy character'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.27：敌人角色的Mesh组件的设置'
- en: '](img/B16183_12_27.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_27.jpg)'
- en: 'Figure 12.27: The settings for the Mesh component of your enemy character'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27：敌人角色的Mesh组件设置
- en: The last thing to do here is to create a `Material Instance` of the mannequin's
    primary material so that this enemy can have a unique color that helps differentiate
    it from the other enemy type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要做的最后一件事是创建人体模型主要材质的“材质实例”，以便这个敌人可以拥有一个独特的颜色，有助于将其与其他敌人类型区分开来。
- en: Let's begin by first learning more about Materials and `Material Instances`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解更多关于材质和“材质实例”的知识。
- en: Materials and Material Instances
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质和材质实例
- en: Before moving on to the next exercise, we need to first briefly discuss what
    Materials and `Material Instances` are before you can work with these assets and
    apply them to the new enemy character. Although this book is more focused on the
    technical aspects of game development using Unreal Engine 4, it is still important
    that you know, on a surface level, what Materials and `Material Instances` are
    and how they are used in video games.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个练习之前，我们需要先简要讨论一下材质和“材质实例”是什么，然后您才能使用这些资产并将它们应用到新的敌人角色上。尽管本书更加关注使用虚幻引擎4进行游戏开发的技术方面，但您仍然需要知道材质和“材质实例”是什么以及它们在视频游戏中的使用方式。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about Materials, please refer to the following Epic Games
    documentation: [https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.html](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.html).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有关材质的更多信息，请参考以下Epic Games文档：[https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.html](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/index.html)。
- en: 'A Material is a type of asset that can be applied to a mesh that will then
    control how the mesh looks in-game. The `Material` editor gives you control over
    many parts of how the end visual result will look, including control over parameters
    such as `Textures`, `Emissive`, and `Specular`, among others. The following image
    shows the default mannequin skeletal mesh with the `M_UE4Man_Body`-applied `Material` asset:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 材质是一种可以应用于网格的资产类型，然后控制网格在游戏中的外观的资产。 “材质”编辑器让您控制最终视觉结果的许多部分，包括对“纹理”、“自发光”和“高光”等参数的控制。以下图显示了应用了“M_UE4Man_Body”材质的默认人体模型骨骼网格：
- en: '![Figure 12.28: The default mannequin skeletal mesh with a basic Material applied'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.28：默认的人体模型骨骼网格应用了基本材质'
- en: '](img/B16183_12_28.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_28.jpg)'
- en: 'Figure 12.28: The default mannequin skeletal mesh with a basic Material applied'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28：默认的人体模型骨骼网格应用了基本材质
- en: A `Material Instance` is an extension of a `Material` where you do not have
    access or control over the base `Material` from which the `Material Instance`
    derives, but you do have control over the parameters that the creator of the `Material`
    exposes to you. Many parameters can be exposed to you to work with from inside
    `Material Instances`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: “材质实例”是“材质”的扩展，您无法访问或控制“材质实例”派生的基本“材质”，但您可以控制“材质”创建者向您公开的参数。许多参数可以从“材质实例”内部向您公开以供使用。
- en: 'Unreal Engine provides us with an example of a `Material Instance` in the `Side
    Scroller` template project called `M_UE4Man_ChestLogo`, found in the `/Mannequin/Character/Materials/`
    directory. The following image shows the set of exposed parameters given to the
    `Material Instance` based on the parent material, `M_UE4Man_Body`. The most important
    parameter to focus on is the `Vector` parameter, called `BodyColor`. You will
    use this parameter in the `Material Instance` you create in the next exercise
    to give the enemy a unique color:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine在“侧向滚动”模板项目中为我们提供了一个“Material Instance”的示例，名为“M_UE4Man_ChestLogo”，位于“/Mannequin/Character/Materials/”目录中。以下图片显示了基于父材质“M_UE4Man_Body”给“Material
    Instance”提供的一组暴露参数。要重点关注的最重要的参数是名为“BodyColor”的“Vector”参数。您将在下一个练习中使用这个参数来为敌人角色提供独特的颜色：
- en: '![Figure 12.29: The list of parameters for the M_UE4Man_ChestLogo Material
    Instance asset'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.29：M_UE4Man_ChestLogo Material Instance资产的参数列表'
- en: '](img/B16183_12_29.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_29.jpg)'
- en: 'Figure 12.29: The list of parameters for the M_UE4Man_ChestLogo Material Instance
    asset'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29：M_UE4Man_ChestLogo Material Instance资产的参数列表
- en: 'Exercise 12.09: Creating and Applying the Enemy Material Instance'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.09：创建并应用敌人材质实例
- en: Now that you have a basic understanding of what materials and material instances
    are, it is time to create your own `Material Instance` from the `M_UE4ManBody`
    asset. With this `Material Instance`, you will adjust the `BodyColor` parameter
    to give the enemy character a unique visual representation. Let's start by creating
    the new `Material Instance`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经基本了解了材质和材质实例是什么，是时候从“M_UE4ManBody”资产创建您自己的“Material Instance”了。通过这个“Material
    Instance”，您将调整“BodyColor”参数，为敌人角色提供独特的视觉表现。让我们从创建新的“Material Instance”开始。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Navigate to the `/Mannequin/Character/Materials` directory to find the `Material`
    used by the default mannequin character, `M_UE4ManBody`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“/Mannequin/Character/Materials”目录，找到默认人体模型角色“M_UE4ManBody”使用的“材质”。
- en: 'A `Material Instance` can be created by *right-clicking* on the `Material`
    asset, `M_UE4Man_Body`, and *left-clicking* on the `Create Material Instance`
    option. Name this asset `MI_Enemy01`.![Figure 12.30: Any material can be used
    to create a Material Instance'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过*右键单击*“材质”资产“M_UE4Man_Body”，然后*左键单击*“创建材质实例”选项来创建“Material Instance”。将此资产命名为“MI_Enemy01”。![图12.30：任何材质都可以用来创建材质实例
- en: '](img/B16183_12_30.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_30.jpg)'
- en: 'Figure 12.30: Any material can be used to create a Material Instance'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30：任何材质都可以用来创建材质实例
- en: 'Create a new folder called `Materials` in the `Enemy` folder. *Left-click*
    and drag the `Material Instance` into the `/Enemy/Materials` directory to move
    the asset to this new folder:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Enemy”文件夹中创建一个名为“Materials”的新文件夹。*左键单击*并将“Material Instance”拖放到“/Enemy/Materials”目录中，将资产移动到这个新文件夹中：
- en: '![Figure 12.31: Rename the Material Instance MI_Enemy'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.31：重命名Material Instance MI_Enemy'
- en: '](img/B16183_12_31.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_31.jpg)'
- en: 'Figure 12.31: Rename the Material Instance MI_Enemy'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31：重命名Material Instance MI_Enemy
- en: '*Double-left-click* the `Material Instance` and find the `Details` panel on
    the left-hand side. There, you will find a `Vector Parameter` property called
    `BodyColor`. Make sure the checkbox is checked to enable this parameter, and then
    change its value to a red color. Now, `Material Instance` should be colored red,
    as shown:![Figure 12.32: Now, the enemy material is red'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“Material Instance”，在左侧找到“Details”面板。在那里，您会找到一个名为“BodyColor”的“Vector Parameter”属性。确保复选框被选中以启用此参数，然后将其值更改为红色。现在，“Material
    Instance”应该呈现红色，如图所示：![图12.32：现在，敌人的材质是红色
- en: '](img/B16183_12_32.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_32.jpg)'
- en: 'Figure 12.32: Now, the enemy material is red'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32：现在，敌人的材质是红色
- en: 'Save the `Material Instance` asset and navigate back to the `BP_Enemy01` Blueprint.
    Select the `Mesh` component and update the `Element 0` material parameter to `MI_Enemy`:![Figure
    12.33: Assigning the new Material Instance asset, MI_Enemy,'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存“Material Instance”资产，并导航回“BP_Enemy01”蓝图。选择“Mesh”组件，并更新“元素0”材料参数为“MI_Enemy”：![图12.33：分配新的Material
    Instance资产MI_Enemy，
- en: to Element 0 of the materials for the Mesh component
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将材料实例移到Mesh组件的材料的元素0
- en: '](img/B16183_12_33.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_33.jpg)'
- en: 'Figure 12.33: Assigning the new Material Instance asset, MI_Enemy, to Element
    0 of the materials for the Mesh component'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33：将新的Material Instance资产MI_Enemy分配给Mesh组件的材料的元素0
- en: 'Now, the first enemy type is visually ready and has the appropriate `Blueprint`
    and Animation Blueprint assets prepared for the next chapter, where you will develop
    its AI:![Figure 12.34: The final enemy character set up'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，第一种敌人类型在视觉上已经准备就绪，并且已经准备好适用于下一章的AI的适当的“Blueprint”和动画蓝图资产：![图12.34：最终敌人角色设置
- en: '](img/B16183_12_34.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_34.jpg)'
- en: 'Figure 12.34: The final enemy character set up'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34：最终敌人角色设置
- en: With this exercise complete, you have now created a `Material Instance` and
    applied it to the enemy character so that it has a unique visual representation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您现在已经创建了一个“Material Instance”并将其应用于敌人角色，使其具有独特的视觉表现。
- en: Let's conclude this chapter by moving on to a short activity that will help
    you better understand the blending of animations using the `Layered blend per
    bone` node that was used in the earlier exercises.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进行一个简短的活动来结束本章，这将帮助您更好地理解使用“Layered blend per bone”节点来混合动画，这是在之前的练习中使用的。
- en: 'Activity 12.01: Updating Blend Weights'
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：更新混合权重
- en: At the end of *Exercise 12.06*, *Previewing the Throw Animation*, you were able
    to blend the movement animations and the `Throw` animation so that they both could
    be played in tandem without negatively influencing each other. The result is the
    player character animating correctly when walking or running, while also performing
    the `Throw` animation on the upper body.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在“练习12.06”结束时，“预览投掷动画”，您能够混合移动动画和“投掷”动画，以便它们可以同时播放而不会对彼此产生负面影响。结果是玩家角色在行走或奔跑时能够正确执行动画，同时在上半身执行“投掷”动画。
- en: In this activity, you will experiment with the blend bias values and parameters
    of the `Layered blend per bone` node to have a better understanding of how animation
    blending works.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将尝试使用“Layered blend per bone”节点的混合偏差值和参数，以更好地理解动画混合的工作原理。
- en: 'The following steps will help you complete the activity:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Update the `Blend Weights` input parameter of the `Layered blend per bone` node
    so that there is absolutely no blending of the `Throw` animation additive pose
    with the base movement pose. Try using values here such as `0.0f` and `0.5f` to
    compare the differences in the animation.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新“Layered blend per bone”节点的“Blend Weights”输入参数，以确保“Throw”动画的附加姿势与基础移动姿势完全不混合。尝试在这里使用值，如“0.0f”和“0.5f”，以比较动画中的差异。
- en: Note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to return this value to `1.0f` after you are done so as not to affect
    the blending you set up in the previous exercise.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在完成后将此值返回为“1.0f”，以免影响您在上一个练习中设置的混合。
- en: Update the settings of the `Layered blend per bone` node to change which bone
    is affected by the blend so that the whole character's body is affected by the
    blend. It's a good idea to start with the root bone in the skeleton hierarchy
    of the `MainCharacter_Skeleton` asset.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新“Layered blend per bone”节点的设置，以更改受混合影响的骨骼，以便整个角色的身体都受到混合的影响。从“MainCharacter_Skeleton”资产的骨骼层次结构中的根骨骼开始是个好主意。
- en: Keeping the settings from the previous step in place, add a new array element
    to the branch filters and, in this new array element, add the bone name and a
    blend depth value of `–1.0f`, which allows only the character's left leg to continue
    to animate the movement correctly when blending the `Throw` animation.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持上一步的设置不变，向分支过滤器添加一个新的数组元素，并在这个新的数组元素中，添加骨骼名称和混合深度值“-1.0f”，这样只有角色的左腿在混合Throw动画时才能继续正确地播放移动动画。
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After this activity, make sure to return the settings of the `Layered blend
    per bone` node to the values you set at the end of the first exercise to ensure
    no progress is lost in the character's animation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，请确保将“Layered blend per bone”节点的设置返回到第一个练习结束时设置的值，以确保角色动画不会丢失任何进展。
- en: 'The expected outputs are as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 12.35: Output showing the entire character body affected'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.35：显示整个角色身体受影响的输出'
- en: '](img/B16183_12_35.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_35.jpg)'
- en: 'Figure 12.35: Output showing the entire character body affected'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35：显示整个角色身体受影响的输出
- en: '![Figure 12.36: The left leg continues to animate the movement correctly'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.36：左腿继续正确地播放移动动画'
- en: when blending the Throw animation
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 混合Throw动画时
- en: '](img/B16183_12_36.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_36.jpg)'
- en: 'Figure 12.36: The left leg continues to animate the movement correctly when
    blending the Throw animation'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36：当混合Throw动画时，左腿继续正确地播放移动动画
- en: '![Figure 12.37: The character''s right leg animating while moving'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.37：角色的右腿在移动时播放'
- en: with the end of the Throw animation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与Throw动画的结尾
- en: '](img/B16183_12_37.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_12_37.jpg)'
- en: 'Figure 12.37: The character''s right leg animating while moving with the end
    of the Throw animation'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37：角色的右腿在移动时播放Throw动画的结尾
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下链接找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: 'Before concluding this activity, please return the `Layered blend per bone`
    settings to the values you set at the end of *Exercise 12.05*, *Blending Animation
    with the Upper Body Anim Slot*. If you do not return these values back to their
    original settings, the animation results in upcoming exercises and activities
    in the next chapters will not be the same. You can either set back the original
    values manually or refer to the file with these settings at the following link:
    [https://packt.live/2GKGMxM](https://packt.live/2GKGMxM).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本活动之前，请将“Layered blend per bone”设置返回到*练习12.05*“使用上半身动画插槽混合动画”的最后设置的值。如果您不将这些值恢复到原始设置，那么下一章节中即将进行的练习和活动中的动画结果将不同。您可以手动设置回原始值，或者参考以下链接中具有这些设置的文件：[https://packt.live/2GKGMxM](https://packt.live/2GKGMxM)。
- en: With this activity complete, you now have a stronger understanding of how animation
    blending works and how blending weighting can affect the influence of additive
    poses on base poses using the `Layered blend per bone` node.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，您现在对动画混合的工作原理和混合权重如何影响“Layered blend per bone”节点上的附加姿势对基础姿势的影响有了更深入的理解。
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot of techniques for animation blending that you haven't used in
    this project, and it's strongly recommended that you research these techniques,
    starting with the documentation at [https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.html](https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.html).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您还没有使用许多动画混合技术，强烈建议您研究这些技术，首先查看[https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.html](https://docs.unrealengine.com/en-US/Engine/Animation/AnimationBlending/index.html)上的文档。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With the enemy set up with the C++ class, Blueprint, and Material, you are ready
    to move on to the next chapter, where you will create the AI for this enemy by
    taking advantage of systems such as Behavior Trees in Unreal Engine 4.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用C++类、蓝图和材质设置敌人，您已经准备好进入下一章节，在那里您将利用虚幻引擎4中的行为树等系统为这个敌人创建AI。
- en: From the exercises and activities of this chapter, you learned how to create
    an `Animation Montage` that allows the playing of animations. You also learned
    how to set up an Anim Slot within this montage to categorize it for the player
    character's upper body.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章的练习和活动中，您学会了如何创建一个“动画蒙太奇”，允许播放动画。您还学会了如何在这个蒙太奇中设置一个动画插槽，以便为玩家角色的上半身进行分类。
- en: Next, you learned how to cache the output pose of a state machine by using the
    `Use Cached Pose` node so that this pose can be referenced in multiple instances
    for more complex Animation Blueprints. Then, by learning about the `Layered blend
    per bone` function, you were able to blend the base movement pose with the additive
    layer of the `Throw` animation by using the Anim Slot.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何使用“使用缓存姿势”节点来缓存状态机的输出姿势，以便在更复杂的动画蓝图中可以引用这个姿势的多个实例。然后，通过学习“每骨层混合”功能，您可以使用动画插槽将基本移动姿势与“投掷”动画的附加层进行混合。
- en: Lastly, you put together the base of the enemy by creating the C++ class, Blueprint,
    and other assets so that they will be ready for the next chapter. With the enemy
    ready, let's move on to creating the AI of the enemy so that it can interact with
    the player.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将通过创建C++类、蓝图和其他资产来组建敌人的基础，以便为下一章做好准备。敌人准备就绪后，让我们继续创建敌人的人工智能，以便它可以与玩家进行互动。
