- en: Variables and Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和内存
- en: To write your C++ game program, you will need your computer to remember a lot
    of things, such as where in the world the player is, how many hit points they
    have, how much ammunition they have left, where the items are in the world, what
    power-ups they provide, and the letters that make up the player's screen name.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写你的C++游戏程序，你需要让你的计算机记住很多东西，比如玩家在世界的位置，他们有多少生命值，还剩下多少弹药，世界中物品的位置，它们提供的增益效果，以及组成玩家屏幕名字的字母。
- en: 'The computer that you have actually has a sort of electronic sketchpad inside
    it called **memory***,* or RAM. Physically, computer memory is made out of silicon
    and it looks similar to what is shown in the following photograph:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机实际上有一种叫做**内存**或RAM的电子素描板。从物理上讲，计算机内存是由硅制成的，看起来与下面的照片相似：
- en: '![](img/50811780-25ce-481b-a8d4-3f90d20df7fc.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50811780-25ce-481b-a8d4-3f90d20df7fc.png)'
- en: Does this RAM look like a parking garage? Because that's the metaphor we're
    going to use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这块RAM看起来像停车场吗？因为这就是我们要使用的隐喻。
- en: RAM is short for random access memory. It is called random access because you
    can access any part of it at any time. If you still have some CDs lying around,
    they are an example of non-random access. CDs are meant to be read and played
    back in order. I still remember jumping tracks on Michael Jackson's *Dangerous*
    album way back when switching tracks on a CD took a lot of time! Hopping around
    and accessing different cells of RAM, however, doesn't take much time at all.
    RAM is a type of fast memory access known as flash memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RAM是随机存取存储器的缩写。它被称为随机存取，因为你可以随时访问它的任何部分。如果你还有一些CD在身边，它们就是非随机存取的例子。CD是按顺序读取和播放的。我还记得很久以前在CD上切换曲目需要很长时间！然而，跳跃和访问RAM的不同单元并不需要太多时间。RAM是一种快速存储器访问的类型，称为闪存存储器。
- en: RAM is called volatile flash memory because when the computer is shut down,
    the RAM's contents are cleared, and the old contents of the RAM are lost unless
    they were saved to the hard disk first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: RAM被称为易失性闪存存储器，因为当计算机关闭时，RAM的内容被清除，除非它们首先保存到硬盘上，否则RAM的旧内容将丢失。
- en: 'For permanent storage, you have to save your data to a hard disk. There are
    two main types of hard disks:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于永久存储，你必须把你的数据保存到硬盘上。有两种主要类型的硬盘：
- en: Platter-based **hard disk drives** (**HDDs**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于盘片的**硬盘驱动器**（**HDDs**）
- en: '**Solid-state drives** (**SSDs**)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固态硬盘**（**SSD**）'
- en: SSDs are more modern than platter-based HDDs, since they use RAM's fast access
    (flash) memory principle. Unlike RAM, however, the data on an SSD persists after
    the computer is shut down. If you can get an SSD, I'd highly recommend that you
    use it! Platter-based drives are outdated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SSD比基于盘片的HDD更现代，因为它们使用RAM的快速访问（闪存）存储原理。然而，与RAM不同，SSD上的数据在计算机关闭后仍然存在。如果你能得到一个SSD，我强烈建议你使用它！基于盘片的驱动器已经过时了。
- en: While a program is running, it is much faster to access data stored in the RAM
    than it is to access it from either HDDs or SSDs, so we need a way to reserve
    a space on the RAM and read and write from it. Fortunately, C++ makes this easy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，访问存储在RAM中的数据比从HDD或SSD中访问要快得多，所以我们需要一种方法来在RAM上保留空间并从中读取和写入。幸运的是，C++使这变得容易。
- en: Variables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: A saved location in computer memory that we can read or write to is called a
    **variable**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机内存中保存的位置，我们可以读取或写入，称为**变量**。
- en: A variable is a component whose value can vary. In a computer program, you can
    think of a variable as a container in which you can store some data. In C++, these
    data containers (variables) have types, and names you can use to refer to them.
    You have to use the right type of data container to save your data in your program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个值可以变化的组件。在计算机程序中，你可以把变量看作是一个容器，可以在其中存储一些数据。在C++中，这些数据容器（变量）有类型和名称，你可以用来引用它们。你必须使用正确类型的数据容器来保存你的程序中的数据。
- en: If you want to save an integer, such as 1, 0, or 20, you will use an `int` type
    container. You can use float-type containers to carry around floating-point (decimal)
    values, such as 38.87, and you can use string variables to carry around strings
    of letters (think of it as a *string of pearls*, where each letter is a pearl).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保存一个整数，比如1、0或20，你将使用`int`类型的容器。你可以使用float类型的容器来携带浮点（小数）值，比如38.87，你可以使用字符串变量来携带字母字符串（把它想象成一串珍珠，其中每个字母都是一颗珍珠）。
- en: 'You can think of your reserved spot in RAM like reserving a parking space in
    a parking garage: once we declare our variable and get a spot for it, no one else
    (not even other programs running on the same machine) will be given that piece
    of RAM by the operating system. The RAM beside your variable might be unused or
    it might be used by other programs.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把你在RAM中保留的位置看作是在停车场预留一个停车位：一旦我们声明了我们的变量并为它获得了一个位置，操作系统就不会把那块RAM的其他部分分配给其他程序（甚至是在同一台机器上运行的其他程序）。你的变量旁边的RAM可能未被使用，也可能被其他程序使用。
- en: The operating system exists to keep programs from stepping on each other's toes
    and accessing the same bits of computer hardware at the same time. In general,
    civil computer programs should not read or write to each other's memory. However,
    some types of cheat programs (for example, maphacks) secretly access your program's
    memory. Programs such as PunkBuster were introduced to prevent cheating in online
    games.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的存在是为了防止程序相互干扰，同时访问计算机硬件的相同位。一般来说，文明的计算机程序不应该读取或写入其他程序的内存。然而，一些类型的作弊程序（例如，地图黑客）会秘密访问你程序的内存。像PunkBuster这样的程序被引入来防止在线游戏中的作弊。
- en: Declaring variables – touching the silicon
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量——触摸硅
- en: Reserving a spot in computer memory using C++ is easy. We want to name our chunk
    of memory that we will store our data in with a good, descriptive name.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++在计算机内存中保留一个位置很容易。我们想要用一个好的、描述性的名字来命名我们将在其中存储数据的内存块。
- en: 'For example, say we know that player **hit points** (**hp**) will be an integer
    (whole) number, such as 1, 2, 3, or 100\. To get a piece of silicon to store the
    player''s `hp` in memory, we will declare the following line of code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们知道玩家的**生命值**（**hp**）将是一个整数（整数）数字，例如1、2、3或100。为了让硅片在内存中存储玩家的`hp`，我们将声明以下代码行：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line of code reserves a small chunk of RAM to store an integer (`int`
    is short for integer) called `hp`. The following is an example of our chunk of
    RAM used to store the player''s `hp`. This reserves a parking space for us in
    the memory (among all the other parking spaces), and we can refer to this space
    in memory by its label (`hp`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码保留了一小块RAM来存储称为`hp`的整数（`int`是整数的缩写）。以下是我们用来存储玩家`hp`的RAM块的示例。这在内存中为我们保留了一个停车位（在所有其他停车位中），我们可以通过其标签（`hp`）引用内存中的这个空间：
- en: '![](img/43575241-0eb0-41bd-b8e3-0e5d9ce0182b.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43575241-0eb0-41bd-b8e3-0e5d9ce0182b.png)'
- en: Among all the other spaces in memory, we get one spot to store our hp data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中的所有其他空间中，我们有一个地方来存储我们的hp数据。
- en: When you name a variable, there are a few rules. Variable names can't start
    with a number, and there are certain "reserved words" the compiler won't let you
    use (usually because they are used by C++ itself). You will learn these as you
    learn more C++, or you can look for lists of reserved words online.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您命名变量时，有一些规则。变量名称不能以数字开头，编译器不允许使用某些“保留字”（通常是因为它们被C++本身使用）。随着您学习更多的C++，您将学到这些，或者您可以在网上寻找保留字列表。
- en: Notice how the variable space is type-marked in this diagram as `int` if it
    is a space for a double or a different type of variable. C++ remembers the spaces
    that you reserve for your program in memory not only by name, but by the type
    of variable it is as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变量空间在此图中标记为`int`，如果它是双精度或其他类型的变量空间。C++不仅通过名称记住您在内存中为程序保留的空间，还通过变量的类型记住它。
- en: Notice that we haven't put anything in hp's box yet! We'll do that later—right
    now, the value of the `hp` variable is not set, so it will have the value that
    was left in that parking space by the previous occupant (the value left behind
    by another program, perhaps). Telling C++ the type of the variable is important!
    Later, we will declare a variable to store decimal values, such as 3.75.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有把任何东西放在hp的盒子里！我们稍后会这样做——现在，`hp`变量的值尚未设置，因此它将具有上一个占用者（也许是另一个程序留下的值）留在那个停车位上的值。告诉C++变量的类型很重要！稍后，我们将声明一个变量来存储十进制值，例如3.75。
- en: Reading and writing to your reserved spot in memory
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入内存中保留的位置
- en: 'Writing a value into memory is easy! Once you have an `hp` variable, you just
    write to it using the `=` sign:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将值写入内存很容易！一旦有了`hp`变量，您只需使用`=`符号写入它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Voila! The player has 500 hp.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！玩家有500 hp。
- en: 'Reading the variable is equally simple. To print out the value of the variable,
    simply put the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 读取变量同样简单。要打印变量的值，只需输入以下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print the value stored inside the `hp` variable. The `cout` object
    is smart enough to figure out what type of variable it is and print the contents. 
    If you change the value of `hp` and then use `cout` again, the most up-to-date
    value will be printed, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印存储在`hp`变量中的值。`cout`对象足够聪明，可以弄清楚它是什么类型的变量，并打印内容。如果您更改`hp`的值，然后再次使用`cout`，将打印最新的值，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Numbers and math
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字和数学
- en: The heading says it all; in this section, we'll dive into the importance of
    numbers and math in C++.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 标题说明了一切；在本节中，我们将深入探讨C++中数字和数学的重要性。
- en: Numbers are everything
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字就是一切
- en: Something that you need to get used to when you start computer programming is
    that a surprising number of things can be stored in computer memory as just numbers.
    A player's hp? As we just saw in the previous section, hp can just be an integer
    number. If the player gets hurt, we reduce this number. If the player gains health,
    we increase the number.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开始计算机编程时，你需要习惯的一件事是，令人惊讶的是，许多东西可以仅以数字形式存储在计算机内存中。玩家的生命值？正如我们在前一节中所看到的，生命值可以只是一个整数。如果玩家受伤，我们减少这个数字。如果玩家获得健康，我们增加这个数字。
- en: 'Colors can be stored as numbers too! If you''ve used standard image editing
    programs, there may be sliders that indicate color as how much red, green, and
    blue are being used, such as Pixelmator''s color sliders, if you''ve used that.
    Photoshop doesn''t have sliders but does show you the numbers and allow you to
    edit them directly to change the color. A color is then represented by three numbers.
    The purple color shown in the following screenshot is (R: `127`, G: `34`, B: `203`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色也可以存储为数字！如果您使用标准的图像编辑程序，可能会有滑块指示颜色使用了多少红色、绿色和蓝色，例如Pixelmator的颜色滑块，如果您使用过的话。Photoshop没有滑块，但会显示数字，并允许您直接编辑以更改颜色。然后，颜色由三个数字表示。以下截图中显示的紫色是（R:`127`，G:`34`，B:`203`）：
- en: '![](img/31daffe0-b152-444a-a39a-c7b14167ab65.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31daffe0-b152-444a-a39a-c7b14167ab65.png)'
- en: As you can see, Photoshop allows you to use other numbers to represent colors,
    such as HSB (hue, saturation, brightness), an alternate way of representing color,
    or CMYK (cyan, magenta, yellow, black) which is used for printing, since professional
    printing presses use those color inks in printing. For viewing on a computer monitor,
    you will generally stick to RGB color representation since that is what monitors
    use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Photoshop允许您使用其他数字来表示颜色，例如HSB（色调、饱和度、亮度），这是表示颜色的另一种方式，或者CMYK（青色、品红色、黄色、黑色），用于印刷，因为专业印刷机使用这些颜色油墨进行印刷。对于在计算机显示器上查看，您通常会坚持使用RGB颜色表示，因为这是显示器使用的颜色。
- en: 'What about world geometry? These are also just numbers; all we have to do is
    store a list of 3D space points (*x*, *y*, and *z* coordinates) and then store
    another list of points that explain how those points can be connected to form
    triangles. In the following screenshot, we can see how 3D space points are used
    to represent world geometry:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 世界几何呢？这些也只是数字；我们所要做的就是存储一组3D空间点（*x*、*y*和*z*坐标），然后存储另一组解释这些点如何连接以形成三角形的点。在下面的屏幕截图中，我们可以看到3D空间点是如何用来表示世界几何的：
- en: '![](img/ed292664-eb2e-4e40-94eb-3b3187163583.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed292664-eb2e-4e40-94eb-3b3187163583.png)'
- en: The combination of numbers for colors and numbers for 3D space points will let
    you draw large and colored landscapes in your game world.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色和3D空间点的数字组合将让您在游戏世界中绘制大型且彩色的景观。
- en: The trick with the preceding examples is how we interpret the stored numbers
    so that we can make them mean what we want them to mean.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的技巧在于我们如何解释存储的数字，以便使它们意味着我们想要的意思。
- en: More on variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关变量的更多信息
- en: 'You can think of variables as pet carriers. A cat carrier can be used to carry
    a cat but not a dog. Similarly, you should use a float-type variable to carry
    decimal-valued numbers. If you store a decimal value inside an `int` variable,
    it will not fit:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将变量看作宠物携带者。猫笼可以用来携带猫，但不能携带狗。同样，您应该使用浮点类型的变量来携带小数值。如果您将小数值存储在`int`变量中，它将不适合：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What's really happening here is that C++ does an automatic type conversion on
    `38.87`, *transmogrifying* it to an integer to fit in the `int` carrying case.
    It drops the decimal to convert `38.87` into the integer value `38`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正发生的是C++对`38.87`进行了自动类型转换，将其转换为整数以适应`int`的容器。它舍弃了小数部分，将`38.87`转换为整数值`38`。
- en: 'So, for example, we can modify the code to include the use of three types of
    variables, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，我们可以修改代码以包括使用三种类型的变量，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the first three lines, we declare three boxes to store our data parts in,
    as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三行中，我们声明了三个盒子来存储我们的数据部分，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These three lines reserve three spots in memory (like parking spaces). The
    next three lines fill the variables with the values we desire, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行在内存中保留了三个位置（就像停车位）。接下来的三行将变量填充为我们想要的值，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In computer memory, this will look like the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机内存中，这将看起来像以下图表：
- en: '![](img/91199601-5d19-43f5-98e6-a7dea05d3d5d.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91199601-5d19-43f5-98e6-a7dea05d3d5d.png)'
- en: 'You can change the contents of a variable at any time. You can write a variable
    using the `=` assignment operator, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时更改变量的内容。您可以使用`=`赋值运算符来写入变量，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also read the contents of a variable at any time. That''s what the
    next three lines of code do, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以随时读取变量的内容。代码的下三行就是这样做的，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take a look at the following line:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下行：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are two uses of the word `hp` in this line. One is between double quotes,
    while the other is not. Words between double quotes are always output exactly
    as you typed them. When double quotes are not used (for example, `<< hp <<`),
    a variable lookup is performed. If the variable does not exist, then you will
    get a compiler error (undeclared identifier).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，单词`hp`有两种用法。一种是在双引号之间，而另一种则不是。双引号之间的单词总是精确输出为您键入的样子。当不使用双引号（例如`<< hp <<`）时，将执行变量查找。如果变量不存在，那么您将收到编译器错误（未声明的标识符）。
- en: There is a space in memory that is allocated for the name, a space for how many
    `goldPieces` the player has, and a space for the hp of the player.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中有一个为名称分配的空间，一个为玩家拥有的`goldPieces`分配的空间，以及一个为玩家的hp分配的空间。
- en: 'This is what you should see when you run the program:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，您应该看到以下内容：
- en: '![](img/aa24ff21-3d49-4d67-9c0c-ddd78d56a222.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa24ff21-3d49-4d67-9c0c-ddd78d56a222.png)'
- en: In general, you should always try to store the right type of data inside the
    right type of variable. If you happen to store the wrong type of data, your code
    may misbehave. For example, accidentally storing a float into an `int` variable
    will make you lose the decimal points, and storing the value of a char in an `int`
    will give you the ASCII value, but will no longer treat it as a letter. Sometimes,
    it even doesn't have any type of automatic type conversion so it won't know how
    to handle the value at all.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您应该始终尝试将正确类型的数据存储在正确类型的变量中。如果您存储了错误类型的数据，您的代码可能会表现异常。例如，意外地将浮点数存储到`int`变量中将使您丢失小数点，并且将字符的值存储在`int`中将给出ASCII值，但不再将其视为字母。有时，甚至没有任何类型的自动类型转换，因此它将不知道如何处理该值。
- en: Math in C++
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的数学运算
- en: 'Math in C++ is easy to do; `+` (plus), `-` (minus), `*` (times), and `/` (divide
    by) are all common C++ operations, and the proper **brackets**, **exponents***,*
    **division**, **multiplication**, **addition**, and **subtraction** (**BEDMAS**) order
    will be followed. For example, we can do as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的数学运算很容易；`+`（加）、`-`（减）、`*`（乘）、`/`（除）都是常见的C++操作，将遵循正确的**括号**、**指数**、**除法**、**乘法**、**加法**和**减法**（**BEDMAS**）顺序。例如，我们可以按照以下代码中所示的方式进行：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of course, if you want to be absolutely sure of the order, it is always a good
    idea to use parentheses. Another operator that you might not be familiar with
    yet is % (modulus). Modulus (for example, 10 % 3) finds the remainder when `x`
    (10) is divided by `y` (3). See the following table for examples:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想要绝对确定顺序，使用括号总是一个好主意。你可能还不熟悉的另一个运算符是%（取模）。取模（例如，10 % 3）找到`x`（10）除以`y`（3）时的余数。请参考以下表格中的示例：
- en: '| Operator (name) | Example | Answer |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 运算符（名称） | 示例 | 答案 |'
- en: '| + (plus) | 7 + 3 | 10 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| + (plus) | 7 + 3 | 10 |'
- en: '| - (minus) | 8 - 5 | 3 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| - (minus) | 8 - 5 | 3 |'
- en: '| * (times) | 5*6 | 30 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| * (times) | 5*6 | 30 |'
- en: '| / (division) | 12/6 | 2 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| / (division) | 12/6 | 2 |'
- en: '| % (modulus) | 10 % 3 | 1 (because 10/3 is 3 and the remainder = 1). |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| % (modulus) | 10 % 3 | 1（因为10/3是3，余数=1）。 |'
- en: However, we often don't want to do math in this manner. Instead, we usually
    want to change the value of a variable by a certain computed amount. This is a
    concept that is harder to understand. Say the player encounters an imp and is
    dealt 15 damage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常不希望以这种方式进行数学运算。相反，我们通常希望按一定计算的数量更改变量的值。这是一个更难理解的概念。假设玩家遇到一个小恶魔并受到15点伤害。
- en: 'The following line of code will be used to reduce the player''s `hp` by `15`
    (believe it or not):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将用于减少玩家的`hp` `15`（信不信由你）：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might ask why. Because on the right-hand side, we are computing a new value
    for hp (`hp-15`). After the new value for hp is found (15 less than what it was
    before), the new value is written into the `hp` variable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么。因为在右侧，我们正在计算hp的新值（`hp-15`）。找到hp的新值（比以前少15），然后将新值写入`hp`变量。
- en: Think of `hp` as a painting at a specific spot on a wall. `-15` tells you to
    draw a mustache on the painting but leave it in the same place. The new, mustachioed
    painting is now `hp`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将`hp`视为墙上特定位置的绘画。`-15`告诉您在绘画上画上胡须，但保持在原地。新的、留着胡须的绘画现在是`hp`。
- en: Pitfall
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱
- en: An uninitialized variable has the bit pattern that was held in memory for it
    before. Declaring a variable does not clear the memory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的变量具有在内存中保存的位模式。声明变量不会清除内存。
- en: 'So, say we used the following line of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设我们使用以下行代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second line of code reduces the hp by 15 from its previous value. What was
    its previous value if we never set `hp = 100` or so? It could be 0, but not always.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代码将hp从其先前的值减少15。如果我们从未设置`hp = 100`或其他值，那么它的先前值是多少？它可能是0，但并非总是如此。
- en: One of the most common errors is to proceed with using a variable without initializing
    it first.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的错误之一是在未初始化变量的情况下继续使用变量。
- en: 'The following is a shorthand syntax for doing this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是进行此操作的简写语法：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Besides `-=`, you can use `+=` to add an amount to a variable, `*=` to multiply
    a variable by an amount, and `/=` to divide a variable by an amount.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`-=`，您还可以使用`+=`将一定数量添加到变量，`*=`将变量乘以一定数量，`/=`将变量除以一定数量。
- en: 'If you''re using an `int` and want to increment (or decrement) it by 1, you
    can shorten the syntax. You don''t need to write the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`int`并希望将其增加（或减少）1，可以缩短语法。您不需要编写以下内容：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can instead do any of the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以执行以下任何操作：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Putting it before the variable increments or decrements it before the value
    is used (if you're using it in a larger statement). Putting it after updates the
    variable after it is used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将其放在变量之前会在使用变量之前递增或递减变量（如果您在较大的语句中使用它）。将其放在后面会在使用变量后更新变量。
- en: Exercises
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write down the value of `x` after performing the following operations, then
    check with your compiler:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作后写下`x`的值，然后与您的编译器进行检查：
- en: '| Exercises | Solutions |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 练习 | 解决方案 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int x = 4; x += 4;` | `8` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 4; x += 4;` | `8` |'
- en: '| `int x = 9; x-=2;` | `7` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 9; x-=2;` | `7` |'
- en: '| `int x = 900; x/=2;` | `450` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 900; x/=2;` | `450` |'
- en: '| `int x = 50; x*=2;` | `100` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 50; x*=2;` | `100` |'
- en: '| `int x = 1; x += 1;` | `2` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 1; x += 1;` | `2` |'
- en: '| `int x = 2; x -= 200;` | `-198` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 2; x -= 200;` | `-198` |'
- en: '| `int x = 5; x*=5;` | `25` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 5; x*=5;` | `25` |'
- en: Generalized variable syntax
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广义变量语法
- en: 'In the previous section, you learned that every piece of data that you save
    in C++ has a type. All variables are created in the same way; in C++, variable
    declarations are of the following form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您了解到您在C++中保存的每个数据都有一个类型。所有变量都是以相同的方式创建的；在C++中，变量声明的形式如下：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `variableType` object tells you what type of data we are going to store
    in our variable. The `variableName` object is the symbol we'll use to read or
    write to that piece of memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`variableType`对象告诉您我们将在变量中存储什么类型的数据。`variableName`对象是我们将用来读取或写入该内存块的符号。'
- en: Primitive types
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: We previously talked about how all the data inside a computer will at some point
    be a number. Your computer code is responsible for interpreting that number correctly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前谈到计算机内部的所有数据最终都将是一个数字。您的计算机代码负责正确解释该数字。
- en: 'It is said that C++ only defines a few basic data types, as shown in the following
    table:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 据说C++只定义了一些基本数据类型，如下表所示：
- en: '| `Char` | A single letter, such as *a*, *b*, or *+*. It is stored as a number
    value from -127 to 127 using ASCII, a standard that assigns specific number values
    to each character. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Char` | 单个字母，例如*a*，*b*或*+*。它以ASCII存储为-127到127的数字值，ASCII是一种为每个字符分配特定数字值的标准。
    |'
- en: '| `Short` | An integer from `-32,767` to `+32,768`. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | 从`-32,767`到`+32,768`的整数。 |'
- en: '| `Int` | An integer from `-2,147,483,647` to `+2,147,483,648`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | 从`-2,147,483,647`到`+2,147,483,648`的整数。 |'
- en: '| `Long` | An integer from `-2,147,483,647` to `+2,147,483,648`. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Long` | 从`-2,147,483,647`到`+2,147,483,648`的整数。 |'
- en: '| `Float` | Any decimal value from approx. `-1x10^(38)` to `1x10^(38)`. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | 从约`-1x10^(38)`到`1x10^(38)`的任何小数值。 |'
- en: '| `Double` | Any decimal value from approx. `-1x10^(308)` to `1x10^(308)`.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `Double` | 从约`-1x10^(308)`到`1x10^(308)`的任何小数值。 |'
- en: '| `Bool` | True or false. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | 真或假。 |'
- en: There are unsigned versions of each of the variable types mentioned in the preceding
    table (except of course Bool, which wouldn't really make sense). An unsigned variable
    can contain natural numbers, including 0 (x >= 0). An unsigned `short`, for example,
    might have a value between `0` and `65535`. You can also get even bigger integers
    if necessary using `long long` or `long long int`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中提到的每种变量类型都有无符号版本（当然，Bool除外，这实际上没有什么意义）。无符号变量可以包含自然数，包括0（x >= 0）。例如，无符号`short`的值可能在`0`和`65535`之间。如果需要，您还可以使用`long
    long`或`long long int`获得更大的整数。
- en: The size of variables can sometimes be different for different compilers, or
    depending on whether you are compiling for a 32-bit or 64-bit operating system.
    Keep that in mind if you find yourself working on something different in the future.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的大小有时在不同的编译器中可能会有所不同，或者取决于您是为32位还是64位操作系统进行编译。如果您将来发现自己在处理不同的东西，请记住这一点。
- en: In this case, we are focusing on Visual Studio or Xcode and (most likely) 64-bit.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们关注的是Visual Studio或Xcode和（很可能）64位。
- en: If you're interested in the difference between float and double, please feel
    free to look it up on the internet. I will keep my explanations only for the most
    important C++ concepts used for games. If you are curious about something that's
    not covered by this text, feel free to look it up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对浮点数和双精度之间的区别感兴趣，请随时在互联网上查找。我只会解释用于游戏的最重要的C++概念。如果你对这个文本未涵盖的内容感到好奇，请随时查找。
- en: Advanced variable topics
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级变量主题
- en: Newer versions of C++ have added a few new features related to variables, and
    there are others that haven't been mentioned yet. Here are a few things you should
    keep in mind.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C++的更新版本添加了一些与变量相关的新功能，还有一些尚未提及的功能。以下是一些你应该记住的事情。
- en: Automatically detecting type
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动检测类型
- en: 'Starting with C++ 11, there is a new variable *type* you can use for cases
    where you may not be sure what type you are expecting to get. This new type is
    called `auto`. What it means is that it will detect the type of whatever value
    you first assign to it and then use that. Say you type the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++ 11开始，有一种新的变量*类型*，可以用于你可能不确定期望得到的类型的情况。这种新类型叫做`auto`。它的意思是它将检测你首先分配给它的任何值的类型，然后使用它。比如你输入以下内容：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you do this, `x` will automatically be a float and `y` will be a Boolean.
    In general, you want to use the actual variable type if you know it (and most
    of the time you will), and as a beginner it is better to avoid using it. You should
    be able to recognize it when you see it, however, and know about it if you do
    run into a case where you need it eventually.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，`x`将自动成为一个浮点数，`y`将成为一个布尔值。一般来说，如果你知道变量的实际类型（大多数情况下你会知道），最好避免使用它。然而，你应该能够在看到它时识别它，并且在最终需要它的情况下了解它。
- en: Enums
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enums have existed for a long time, but starting with C++ 11 you have more
    control over them. The idea behind an enum is sometimes you want to track different
    types of things in a game, and you just want an easy way to give each a value
    that tells you what it is, and that you can later check. An enum looks like the
    following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型已经存在很长时间了，但是从C++ 11开始，你可以更好地控制它们。枚举的想法有时是你想要在游戏中跟踪不同类型的东西，你只是想要一种简单的方法来给每个值，告诉你它是什么，以及你以后可以检查它。枚举看起来像下面这样：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This creates each of these weapon types and assigns each a unique value by
    adding 1 to each, so knife would be equal to 1, axe to 2, and so on. Note that
    you do not need to set the first one to 0 (it does that automatically) but if
    you want to start with a different number you can do that (and it''s not just
    the first one that can be set to a specific value). You can also assign any `enum`
    member to a different one and it will have the same value (in this example, `defaultWeapon`
    has the same value as `mace`: 3). Any time you assign a specific value anywhere
    in the enum list, any types you add after that on the list will start going up
    by 1 from that value.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建每种武器类型，并通过为每种武器类型加1来分配每种武器类型一个唯一的值，因此刀将等于1，斧头将等于2，依此类推。请注意，你不需要将第一个设置为0（它会自动设置），但如果你想从不同的数字开始，你可以这样做（不仅仅是第一个可以设置为特定的值）。你还可以将任何`enum`成员分配给另一个不同的成员，它将具有相同的值（在这个例子中，`defaultWeapon`具有与`mace`相同的值：3）。在枚举列表中的任何地方分配特定值时，列表中之后添加的任何类型将从该值开始递增1。
- en: 'Enums have always contained an int value, but starting with C++ 11 you have
    the ability to specify a variable type. For example, you might want to do something
    like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型一直包含一个int值，但是从C++ 11开始，你可以指定一个变量类型。例如，你可能想做类似以下的事情：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While you could do this with 0 and 1, you might find this more convenient in
    some cases.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以用0和1来做到这一点，但在某些情况下，你可能会发现这更方便。
- en: const variables
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量变量
- en: Sometimes you will have a value you do not want to change ever during the game.
    You don't want things such as the number of lives, your maximum hp, the amount
    of xp you need to reach a specific level, or your movement speed to change (unless
    your character does reach that level, in which case you might switch to a different
    constant value).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会有一个值，你不希望在游戏过程中改变。你不希望像生命值、最大生命值、达到特定级别所需的经验值或移动速度这样的东西改变（除非你的角色确实达到了那个级别，在这种情况下，你可能会切换到另一个常量值）。
- en: 'In some cases, an `enum` will work for this, but for single values it''s easier
    to create a new variable and declare it to be `const`. Here''s an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`enum`可以解决这个问题，但对于单个值，更容易创建一个新变量并声明它为`const`。这里有一个例子：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Putting `const` in front of the variable type tells the program to never allow
    that value to be changed, and if you try it will give you an error. Putting `k`
    in front of the variable name is a common naming convention for `const` variables.
    Many companies will insist that you follow that standard.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量类型前面放置`const`告诉程序永远不要允许该值被更改，如果你尝试，它会给你一个错误。在变量名前面放置`k`是`const`变量的常见命名约定。许多公司会坚持要求你遵循这个标准。
- en: Building more complex types
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建更复杂的类型
- en: It turns out that these simple data types alone can be used to construct arbitrarily
    complex programs. *How?* you ask. Isn't it hard to build a 3D game using just
    floats and integers?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，这些简单的数据类型本身可以用来构建任意复杂的程序。*怎么做？* 你会问。仅仅使用浮点数和整数来构建3D游戏难吗？
- en: It is not really difficult to build a game from `float` and `int`, but more
    complex data types help. It would be tedious and messy to program if we used loose
    floats for the player's position.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从`float`和`int`构建游戏并不是真的很困难，但更复杂的数据类型会有所帮助。如果我们使用松散的浮点数来表示玩家的位置，编程将会很乏味和混乱。
- en: Object types – struct
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类型 - 结构
- en: 'C++ gives you structures to group variables together, which will make your
    life a lot easier. Take the example of the following block of code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: C++为你提供了将变量组合在一起的结构，这将使你的生活变得更加轻松。以以下代码块为例：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The way this looks in memory is pretty intuitive; a **Vector** is just a chunk
    of memory with three floats, as shown in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中的显示方式非常直观；**Vector**只是一个具有三个浮点数的内存块，如下图所示：
- en: '![](img/f0a7f2fa-edae-43ba-8254-665d7b7eec5a.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0a7f2fa-edae-43ba-8254-665d7b7eec5a.png)'
- en: Don't confuse the `struct Vector` in the preceding screenshot with the `std::vector`
    of the **Standard Template Library** (**STL**)—we'll get into that later. The
    preceding `Vector` object is meant to represent a three-space vector, while the
    STL's `std::vector` type represents a collection of values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将前面的屏幕截图中的`struct Vector`与**标准模板库**（**STL**）的`std::vector`混淆-我们稍后会介绍这一点。前面的`Vector`对象用于表示三维向量，而STL的`std::vector`类型表示一组值。
- en: Here are a couple of review notes about the preceding code listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码清单，这里有一些复习注意事项。
- en: 'First, even before we use our `Vector` object type, we have to define it. C++
    does not come with built-in types for math vectors (it only supports scalar numbers,
    and they thought that was enough!). So, C++ lets you build your own object constructions
    to make your life easier. We first had the following definition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，甚至在我们使用“Vector”对象类型之前，我们必须定义它。C++没有内置的数学向量类型（它只支持标量数字，他们认为这已经足够了！）。因此，C++允许您构建自己的对象构造以使您的生活更轻松。我们首先有以下定义：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This tells the computer what a `Vector` is (it's three floats, all of which
    are declared to be sitting next to each other in the memory). The way a `Vector`
    will look in the memory is shown in the preceding diagram.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉计算机“Vector”是什么（它是三个浮点数，所有这些都被声明为坐在内存中的相邻位置）。在前面的图中显示了“Vector”在内存中的样子。
- en: 'Next, we use our `Vector` object definition to create a Vector instance called
    `v`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们的“Vector”对象定义来创建一个名为“v”的Vector实例：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once you have an instance of a `Vector`, you can access the variables inside
    it using what we call **dot syntax**. You access the variable `x` on Vector `v`
    using `v.x`. The `struct` Vector definition doesn't actually create a Vector object,
    it just defines the object type. You can't do `Vector.x = 1`. Which object instance
    are you talking about? the C++ compiler will ask. You need to create a Vector
    instance first, such as Vector `v`. That creates an instance of a Vector and names
    it `v`. Then, you can do assignments on the `v` instance, such as `v.x = 0`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了“Vector”的实例，您就可以使用我们称之为**点语法**来访问其中的变量。您可以使用`v.x`在Vector `v`上访问变量`x`。`struct`
    Vector定义实际上并不创建Vector对象，它只是定义了对象类型。您不能做`Vector.x = 1`。您在谈论哪个对象实例？C++编译器会问。您需要首先创建一个Vector实例，例如Vector
    `v`。这将创建一个Vector的实例并将其命名为`v`。然后，您可以对`v`实例进行赋值，例如`v.x = 0`。
- en: 'We then use this instance to write values into `v`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这个实例来写入`v`中的值：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We used commas in the preceding code to initialize a bunch of variables on the
    same line. This is okay in C++. Although you can do each variable on its own line,
    the approach shown here is okay too.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中使用逗号来初始化同一行上的一堆变量。这在C++中是可以的。虽然您可以将每个变量放在自己的一行上，但在这里显示的方法也是可以的。
- en: 'This makes `v` look as in the preceding image. Then, we print them out:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得“v”看起来像前面的图像。然后，我们将它们打印出来：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In both the lines of code here, we access the individual data members inside
    the object by simply using a dot (`.`); `v.x` refers to the `x` member inside
    the object `v`. Each Vector object will have exactly three floats inside it: one
    called `x`, one called `y`, and one called `z`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的两行代码中，我们通过简单地使用点（`.`）访问对象内的各个数据成员；`v.x`指的是对象`v`内的`x`成员。每个Vector对象内部将恰好有三个浮点数：一个称为`x`，一个称为`y`，一个称为`z`。
- en: Exercise – player
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-玩家
- en: Define a C++ data struct for a `Player` object. Then, create an instance of
    your `Player` struct and fill each of the data members with values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为“Player”对象定义一个C++数据结构。然后，创建您的“Player”结构的一个实例，并为每个数据成员填充值。
- en: Solution
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Let''s declare our `Player` object. We want to group together everything to
    do with the player into the `Player` object. We do this so that the code is neat
    and tidy. The code you read in Unreal Engine will use objects such as these everywhere,
    so pay attention:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明我们的“Player”对象。我们希望将与玩家有关的所有内容都放入“Player”对象中。我们这样做是为了使代码整洁。您在Unreal Engine中阅读的代码将在各个地方使用这样的对象，因此请注意：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The line `me.position.x = me.position.y = me.position.z=0;` means `me.position.z`
    is set to `0`, and then that value is passed on to set `me.position.y` to 0, and
    then it is passed along and sets `me.position.x` to `0`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 行`me.position.x = me.position.y = me.position.z=0;`意味着`me.position.z`设置为`0`，然后将该值传递给`me.position.y`设置为0，然后传递并设置`me.position.x`为`0`。
- en: The `struct Player` definition is what tells the computer how a `Player` object
    is laid out in memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: “struct Player”定义告诉计算机如何在内存中布置“Player”对象。
- en: I hope you noticed the mandatory semicolon at the end of the struct declaration.
    Struct object declarations need to have a semicolon at the end, but functions
    do not (we'll go over functions later). This is just a C++ rule that one must
    remember.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您注意到了结构声明末尾的必需分号。结构对象声明需要在末尾加上分号，但函数不需要（我们稍后会讨论函数）。这只是一个必须记住的C++规则。
- en: Inside a `Player` object, we declared a string for the player's name, a float
    for their hp, and a `Vector` object for their complete `x`, `y`, and `z` position.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Player”对象内部，我们声明了一个字符串用于玩家的名称，一个浮点数用于他们的hp，以及一个“Vector”对象用于他们完整的“x”，“y”和“z”位置。
- en: When I say object, I mean a C++ struct (later, we will introduce the term *class*).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说对象时，我的意思是C++结构（稍后我们将介绍术语*类*）。
- en: Wait! We put a Vector object inside a Player object! Yes, you can do that. Just
    make sure the Vector is defined in the same file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们把一个Vector对象放在一个Player对象里！是的，你可以这样做。只要确保Vector在同一个文件中定义。
- en: After the definition of what a `Player` object has inside it, we actually create
    a `Player` object instance called `me` and assign it some values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了“Player”对象内部的内容之后，我们实际上创建了一个名为“me”的“Player”对象实例，并为其分配了一些值。
- en: Pointers
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: A particularly tricky concept to grasp is the concept of pointers. Pointers
    aren't that hard to understand but can take a while to get a firm handle on. Pointers
    basically contain an address in memory where an object is stored, so they "point
    to" the object in memory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别棘手的概念是指针的概念。指针并不难理解，但可能需要一段时间才能牢固掌握。指针基本上包含一个对象存储的内存地址，因此它们在内存中“指向”对象。
- en: 'Say we have, as before, declared a variable of the type `Player` in memory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在内存中声明了一个`Player`类型的变量：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now declare a pointer to the `Player`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在声明一个指向`Player`的指针：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `*` changes the meaning of the variable type. The `*` is what makes `ptrMe`
    a pointer to a `Player` object instead of a regular `Player` object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`改变了变量类型的含义。`*`是使`ptrMe`成为`Player`对象的指针而不是常规`Player`对象的原因。'
- en: 'We now want to link `ptrMe` to `me`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要将`ptrMe`链接到`me`：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This linkage step is very important. If you don't link the pointer to an object
    before you use the pointer, you will get a memory access violation—an error that
    you are trying to access memory that you didn't set, so it could contain random
    data or even part of another program!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种链接步骤非常重要。如果在使用指针之前不将指针链接到对象，将会出现内存访问违规错误——尝试访问未设置的内存，因此可能包含随机数据甚至其他程序的一部分！
- en: 'The `ptrMe` pointer now points to the same object as `me`. Changing the values
    of the variables in the object `ptrMe` points to will change them in `me`, as
    shown in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrMe`指针现在指向与`me`相同的对象。更改`ptrMe`指向的对象中的变量的值将在`me`中更改，如下图所示：'
- en: '![](img/39c61393-1da4-452f-a007-f0252648101b.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39c61393-1da4-452f-a007-f0252648101b.png)'
- en: What can pointers do?
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针能做什么？
- en: When we set up the linkage between the pointer variable and what it is pointing
    to, we can manipulate the variable that it is pointed to through the pointer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们建立指针变量和它所指向的东西之间的链接时，我们可以通过指针操纵它所指向的变量。
- en: One use of pointers is to refer to the same object from several different locations
    in the code. You may want to store a pointer to it locally if you'll be constantly
    trying to access it, to make it easier to access. The `Player` object is a good
    candidate for being pointed to, since many places in your code could be accessing
    it constantly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的一个用途是在代码中的多个不同位置引用同一个对象。如果您经常尝试访问它，您可能希望在本地存储一个指向它的指针，以便更容易访问。`Player`对象是一个很好的指向候选对象，因为您的代码中的许多地方可能会不断地访问它。
- en: You can create as many pointers as you wish to the same object, but you'll want
    to keep track of them all (unless you use smart pointers, which we will get to
    later). Objects that are pointed to do not necessarily know that they are being
    pointed at, but changes can be made to the object through the pointers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建任意数量的指针指向同一个对象，但您需要跟踪它们所有（除非您使用智能指针，我们稍后会介绍）。被指向的对象不一定知道自己被指向，但可以通过指针对对象进行更改。
- en: 'For instance, say the player got attacked. A reduction in their hp will be
    the result, and this reduction will be done using the pointer, as shown in the
    following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设玩家受到了攻击。他们的hp减少将是结果，并且这种减少将使用指针来完成，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When using a pointer, you need to use `->` instead of `.` to access the variables
    in the object pointed to.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针时，您需要使用`->`而不是`.`来访问指向的对象中的变量。
- en: 'Here''s how the `Player` object looks now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Player`对象的外观如下：
- en: '![](img/aa4316de-1a4a-43bc-a029-729cf5c3125e.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4316de-1a4a-43bc-a029-729cf5c3125e.png)'
- en: So, we changed `me.name` by changing `ptrMe->name`. Because `ptrMe` points to
    `me`, changes through `ptrMe` affect `me` directly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过改变`ptrMe->name`来改变`me.name`。因为`ptrMe`指向`me`，所以通过`ptrMe`的更改会直接影响`me`。
- en: Address of operator (&)
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址运算符（&）
- en: Notice the use of the `&` symbol in the preceding code example. The `&` operator
    gets the memory address where a variable is stored. A variable's memory address
    is a location in the computer memory space that is reserved to store the variable's
    value. C++ is able to get the memory address of any object in your program's memory.
    The address of a variable is unique and also kind of random.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的代码示例中使用了`&`符号。`&`运算符获取变量存储的内存地址。变量的内存地址是计算机内存空间中保留存储变量值的位置。C++能够获取程序内任何对象的内存地址。变量的地址是唯一的，也有点随机。
- en: 'Say we print the address of an integer variable, `x`, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们打印一个整数变量`x`的地址，如下所示：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On the first run of the program, my computer prints the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第一次运行中，我的计算机打印如下：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This number (the value of `&x`) is just the memory cell where the `x` variable is
    stored. What this means is that in this particular launch of the program, the `x`
    variable is located at memory cell number `0023F744`, as shown in the following
    diagram:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字（`&x`的值）只是存储`x`的内存单元。这意味着在程序的这次启动中，`x`变量位于内存单元编号`0023F744`，如下图所示：
- en: '![](img/6bdb0610-ff05-47f6-a361-5b6026e67f61.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bdb0610-ff05-47f6-a361-5b6026e67f61.png)'
- en: You may wonder why the preceding number contains an `F`. Addresses are in hexadecimal
    (base 16) so since you run out of numerical digits after 9, but you can't really
    fit two digits in 1, you set the values that would be 10-15 to A-F instead. So
    A = 10, B = 11, and in this case F = 15.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么前面的数字包含一个`F`。地址是十六进制（基数16），因此在9之后数字位用完了，但实际上1中无法容纳两个数字，因此将值设置为10-15分别为A-F。因此A
    = 10，B = 11，在这种情况下F = 15。
- en: 'Now, create and assign a pointer variable to the address of `x`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建并将指针变量分配给`x`的地址：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What we''re doing here is storing the memory address of `x` inside the `px`
    variable. So, we are metaphorically pointing to the `x` variable using another
    different variable called `px`. This might look similar to what is shown in the
    following diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是将`x`的内存地址存储在`px`变量中。因此，我们用另一个不同的变量`px`来指向`x`变量。这可能看起来类似于以下图示中所示的内容：
- en: '![](img/6e560752-06c4-46e1-b673-7e7486f96405.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e560752-06c4-46e1-b673-7e7486f96405.png)'
- en: 'Here, the `px` variable has the address of the `x` variable inside it. In other
    words, the `px` variable is a reference to another variable. De-referencing `px`
    means to access the variable that `px` is referencing. De-referencing is done
    using the `*` symbol:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`px`变量中包含了`x`变量的地址。换句话说，`px`变量是对另一个变量的引用。对`px`进行解引用意味着访问`px`引用的变量。解引用使用`*`符号进行：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using nullptr
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nullptr
- en: The `nullptr` variable is a pointer variable with the value `0`. In general,
    most programmers like to initialize pointers to `nullptr` (`0`) on the creation
    of new pointer variables. Computer programs, in general, can't access the memory
    address `0` (it is reserved), so if you try to reference a null pointer, your
    program will crash.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullptr`变量是一个值为`0`的指针变量。一般来说，大多数程序员喜欢在创建新指针变量时将指针初始化为`nullptr`（`0`）。一般来说，计算机程序无法访问内存地址`0`（它是保留的），因此如果尝试引用空指针，程序将崩溃。'
- en: '*Pointer Fun with Binky* is a fun video about pointers. Take a look at [http://www.youtube.com/watch?v=i49_SNt4yfk](http://www.youtube.com/watch?v=i49_SNt4yfk).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pointer Fun with Binky*是一个关于指针的有趣视频。请查看[http://www.youtube.com/watch?v=i49_SNt4yfk](http://www.youtube.com/watch?v=i49_SNt4yfk)。'
- en: Smart pointers
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针
- en: Pointers can be hard to manage. Once we start creating and deleting new objects
    later in this book, we may not know where all the pointers are that point to a
    specific object. It can be too easy to delete an object that another pointer is
    still using (leading to a crash), or to stop pointing to an object from the only
    pointer to it and leave it floating in memory with nothing referencing it (this
    is called a memory leak, and will slow down your computer).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可能很难管理。一旦我们在本书的后面开始创建和删除新对象，我们可能不知道所有指向特定对象的指针在哪里。删除仍在使用的另一个指针指向的对象可能太容易（导致崩溃），或者停止指向对象的唯一指针并使其漂浮在内存中而没有任何引用（这称为内存泄漏，并会减慢计算机的速度）。
- en: Smart pointers keep track of how many references exist to a specific object,
    and will automatically increment or decrement this number as things change in
    the code. This makes it much easier to control what is happening, and in real-world
    programming it is preferable to using regular pointers when possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针跟踪特定对象存在多少引用，并将随着代码中的变化自动增加或减少这个数字。这使得更容易控制发生的事情，在实际编程中，尽可能使用普通指针更可取。
- en: People used to have to write their own smart pointers, but not since C++ 11\.
    There is now a `shared_ptr` template available (we'll talk about templates and
    the STL later). This will automatically keep track of pointers to an object, and
    will automatically delete that object if nothing else is referencing it, preventing
    memory leaks. This is why it is better to use smart pointers than pointers, since
    regular pointers could wind up pointing to objects that have been deleted elsewhere
    in the code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 人们过去必须编写自己的智能指针，但自从C++ 11以来就不再需要了。现在有一个`shared_ptr`模板可用（我们稍后会讨论模板和STL）。这将自动跟踪指向对象的指针，并在没有其他引用它时自动删除该对象，防止内存泄漏。这就是为什么最好使用智能指针而不是指针，因为普通指针可能最终指向已在代码的其他地方被删除的对象。
- en: Input and output
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出
- en: In programming, you constantly have to pass information to the user, or get
    information from the user. For simple cases, such as the ones we will be starting
    with (and many times for finding errors later), you need to input and output standard
    text and numbers. C++ makes this easy.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，您不断需要向用户传递信息，或者从用户那里获取信息。对于我们将要开始的简单情况（以及后来查找错误的许多情况），您需要输入和输出标准文本和数字。C++使这变得很容易。
- en: The cin and cout objects
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cin和cout对象
- en: 'We''ve already seen how `cout` works in previous examples. The `cin` object
    is the way C++ traditionally takes input from the user into the program. The `cin` object
    is easy to use, because it looks at the type of variable it will put the value
    into and uses that to determine the type being put inside it. For example, say
    we want to ask the user his age and store it in an `int` variable. We can do that
    as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的例子中看到了`cout`的工作原理。`cin`对象是C++传统上从用户输入程序中获取输入的方式。`cin`对象易于使用，因为它查看将值放入的变量类型，并使用该类型来确定放入其中的类型。例如，假设我们想要询问用户的年龄并将其存储在`int`变量中。我们可以这样做：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you run this, it will print `What is your age?` and wait for your response.
    Type in a response and hit *Enter* to input it. You might want to try typing in
    other things besides `int` variables just to see what happens!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，它将打印`What is your age?`并等待您的回答。输入一个回答并按*Enter*进行输入。您可能想尝试输入除`int`变量之外的其他内容，以查看会发生什么！
- en: The printf() function
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: printf()函数
- en: Although we have used `cout` to print out variables so far, you should also
    know about another common function that is used to print to the console. This
    function is called the `printf` function, and it originally comes from C. The
    `printf` function is included in the `<iostream>` library, so you don't have to
    `#include` anything extra to use it. Some people in the gaming industry prefer
    `printf` to `cout`, so let's introduce it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止我们已经使用`cout`打印变量，但您还应该了解另一个常用函数，用于打印到控制台。这个函数称为`printf`函数，最初来自C。`printf`函数包含在`<iostream>`库中，因此您无需`#include`任何额外的内容即可使用它。游戏行业的一些人更喜欢`printf`而不是`cout`，因此让我们介绍一下。
- en: 'Let''s proceed to how `printf()` works, as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讲解`printf()`的工作原理，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Downloading the example code
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt books you have purchased. If you purchased this book elsewhere,
    you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，用于您购买的所有Packt图书。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: 'We start with a format string. The format string is like a picture frame, and
    the variables will get plugged in at the locations of the `%` in the format string.
    Then, the entire thing gets dumped out to the console. In the preceding example,
    the integer variable will be plugged into the location of the first `%` (`%d`),
    and the character will be plugged into the location of the second `%` (`%c`),
    as shown in the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个格式字符串开始。格式字符串就像一个画框，变量将被插入到格式字符串中`%`的位置。然后，整个东西被倾倒到控制台上。在前面的例子中，整数变量将被插入到格式字符串中第一个`%`（`%d`）的位置，字符将被插入到格式字符串中第二个`%`（`%c`）的位置，如下面的屏幕截图所示：
- en: '![](img/0f75934f-d8a3-4f1f-92c3-8e724477863f.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f75934f-d8a3-4f1f-92c3-8e724477863f.png)'
- en: 'You have to use the right format code to get the output to format correctly;
    take a look at the following table:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用正确的格式代码才能使输出正确格式化；请看下表：
- en: '| Data type | Format code |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 格式代码 |'
- en: '| `Int` | `%d` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | `%d` |'
- en: '| `Char` | `%c` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `Char` | `%c` |'
- en: '| `String` | `%s` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `%s` |'
- en: 'To print a C++ string, you must use the `string.c_str()` function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印C++字符串，您必须使用`string.c_str()`函数：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `s.c_str()` function accesses the C pointer to the string, which `printf`
    needs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.c_str()`函数访问字符串的C指针，这是`printf`所需要的。'
- en: If you use the wrong format code, the output won't appear correctly or the program
    might crash.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用错误的格式代码，输出将不会正确显示，或者程序可能会崩溃。
- en: You may also find cases where you need to use this type of formatting to set
    up strings, so it is good to know. But if you'd prefer to avoid having to remember
    these different format codes, just use `cout`. It will figure the type out for
    you. Just make sure you use whatever standard the company you eventually work
    for prefers. It's generally a good idea to do that with most things in programming.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现需要使用这种类型的格式来设置字符串的情况，所以了解这一点是很好的。但是，如果您更喜欢避免记住这些不同的格式代码，只需使用`cout`。它会为您找出类型。只要确保您使用您最终工作的公司所偏好的标准。在大多数编程事情中，这通常是一个好主意。
- en: Exercise
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Ask the user their name and age and take them in using `cin`. Then, issue a
    greeting for them at the console using `printf()` (not `cout`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户姓名和年龄，并使用`cin`将它们输入。然后，使用`printf()`在控制台上为他们发出问候（而不是`cout`）。
- en: Solution
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is how the program will look:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将如下所示：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A string is actually an object type. Inside, it is just a bunch of chars!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串实际上是一种对象类型。在内部，它只是一堆字符！
- en: Namespaces
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'We''ve seen namespaces so far in the case of `std`, and we''ve mostly avoided
    that issue by putting the following at the top of the files:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在`std`的情况下看到了命名空间，并且大多数情况下通过在文件顶部放置以下内容来避免这个问题：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But, you should know what that means for the future.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您应该知道这对未来意味着什么。
- en: Namespaces are ways to group together code that is related, and it allows you
    to use the same variable names in different namespaces without any naming conflicts
    (unless of course you put `using namespace` for both at the top, which is why
    many people prefer to not use that).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是将相关代码分组在一起的方式，它允许您在不同的命名空间中使用相同的变量名称而不会出现任何命名冲突（当然，除非您在顶部为两者都使用了`using
    namespace`，这就是为什么许多人更喜欢不使用它的原因）。
- en: 'You can create your own namespace in a C++ file like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样在C++文件中创建自己的命名空间：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you''ve created your namespace, you can then access that code like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了命名空间，您就可以像这样访问该代码：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Or, you can put in a using statement at the top (just make sure the name isn't
    used for something else). But, in general you don't want to use this for more
    complex programs, since a namespace allows you to reuse the same variable name
    in different namespaces, so if you use it with a namespace with a variable in
    it that has the same name as one in the current namespace and try to access it,
    the compiler won't know which one you are referring to, which would cause a conflict.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在顶部放入一个使用语句（只要确保该名称没有用于其他用途）。但是，一般来说，您不希望在更复杂的程序中使用这个，因为命名空间允许您在不同的命名空间中重用相同的变量名称，因此如果您将其与一个包含当前命名空间中具有相同名称的变量的命名空间一起使用，并尝试访问它，编译器将不知道您指的是哪一个，这将导致冲突。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we spoke about variables and memory. We talked about mathematical
    operations on variables and how simple they were in C++.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了变量和内存。我们谈到了关于变量的数学运算，以及它们在C++中是多么简单。
- en: We also discussed how arbitrarily complex data types can be built using a combination
    of these simpler data types, such as floats, integers, and characters. Constructions
    such as this are called objects. In the next chapter, we will start talking about
    what we can do with these objects!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何使用这些更简单的数据类型（如浮点数、整数和字符）的组合来构建任意复杂的数据类型。这样的构造被称为对象。在下一章中，我们将开始讨论我们可以用这些对象做什么！
