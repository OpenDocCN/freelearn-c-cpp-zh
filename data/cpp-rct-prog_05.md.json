["```cpp\n//-------------------- Observer.cpp \n#include <iostream> \n#include  <vector> \n#include <memory> \nusing namespace std; \n//---- Forward declaration of event sink \ntemplate<class T> \nclass EventSourceValueObserver; \n//----------A toy implementation of EventSource\ntemplate<class T> \nclass EventSourceValueSubject{ \n   vector<EventSourceValueObserver<T> *> sinks;  \n   T State; // T is expected to be a value type \n  public: \n   EventSourceValueSubject() { State = 0; } \n   ~EventSourceValueSubject() { \n       sinks.clear(); \n   } \n   bool Subscribe( EventSourceValueObserver<T> *sink ) { sinks.push_back(sink);} \n   void NotifyAll() { for (auto sink : sinks) { sink->Update(State); }} \n   T GetState() { return State; } \n   void SetState(T pstate) { State = pstate; NotifyAll(); } \n};\n```", "```cpp\n//--------------------- An event sink class for the preceding EventSources \ntemplate <class T> \nclass EventSourceValueObserver{ \n    T OldState; \n  public: \n    EventSourceValueObserver() { OldState = 0; } \n    virtual ~EventSorceValueObserver() {} \n    virtual void Update( T State ) { \n       cout << \"Old State \" << OldState << endl; \n       OldState = State; \n       cout << \"Current State \" << State << endl;  \n    } \n}; \n```", "```cpp\n//------------ A simple specialized Observe \nclass AnotherObserver : public EventSourceValueObserver<double> { \n  public: \n    AnotherObserver():EventSourceValueObserver() {} \n    virtual ~AnotherObserver() {} \n    virtual void Update( double State )  \n    { cout << \" Specialized Observer\" << State <<  endl; } \n};\n```", "```cpp\nint main() { \n   unique_ptr<EventSourceValueSubject<double>> \n                 evsrc(new EventSourceValueSubject<double>()); \n    //---- Create Two instance of Observer and Subscribe \n   unique_ptr<AnotherObserver> evobs( new AnotherObserver());\n   unique_ptr<EventSourceValueObserver<double>> \n               evobs2( new EventSourceValueObserver<double>());\n   evsrc->Subscribe( evobs.get() );\n   evsrc->Subscribe( evobs2.get());\n   //------ Change the State of the EventSource \n   //------ This should trigger call to Update of the Sink \n   evsrc->SetState(100); \n} \n```", "```cpp\n#include <iostream> \n#include <memory> \n#include <list> \n#include <stack> \n#include <functional> \n#include <thread> \n#include <future> \n#include <random> \n#include \"FuncCompose.h\" // available int the code base \nusing namespace std; \n//---------------------List of operators supported by the evaluator \nenum class OPERATOR{ ILLEGAL,PLUS,MINUS,MUL,DIV,UNARY_PLUS,UNARY_MINUS };  \n```", "```cpp\n//------------ forward declarations for the Composites  \nclass Number;  //----- Stores IEEE double precision floating point number  \nclass BinaryExpr; //--- Node for Binary Expression \nclass UnaryExpr;  //--- Node for Unary Expression \nclass IExprVisitor; //---- Interface for the Visitor  \n//---- Every node in the expression tree will inherit from the Expr class \nclass Expr { \n  public: \n   //---- The standard Visitor double dispatch method \n   //---- Normally return value of accept method are void.... and Concrete\n   //---- classes store the result which can be retrieved later\n   virtual double accept(IExprVisitor& expr_vis) = 0; \n   virtual ~Expr() {} \n}; \n//----- The Visitor interface contains methods for each of the concrete node  \n//----- Normal practice is to use \nstruct IExprVisitor{ \n   virtual  double Visit(Number& num) = 0; \n   virtual  double Visit(BinaryExpr& bin) = 0; \n   virtual  double Visit(UnaryExpr& un)=0 ; \n}; \n```", "```cpp\n//---------A class to represent IEEE 754 interface \nclass Number : public Expr { \n   double NUM; \n  public: \n   double getNUM() { return NUM;}    \n   void setNUM(double num)   { NUM = num; } \n   Number(double n) { this->NUM = n; } \n   ~Number() {} \n   double accept(IExprVisitor& expr_vis){ return expr_vis.Visit(*this);} \n}; \n```", "```cpp\n//-------------- Modeling Binary Expresison  \nclass BinaryExpr : public Expr { \n   Expr* left; Expr* right; OPERATOR OP; \n  public: \n   BinaryExpr(Expr* l,Expr* r , OPERATOR op ) { left = l; right = r; OP = op;} \n   OPERATOR getOP() { return OP; } \n   Expr& getLeft() { return *left; } \n   Expr& getRight() { return *right; } \n   ~BinaryExpr() { delete left; delete right;left =0; right=0; } \n   double accept(IExprVisitor& expr_vis) { return expr_vis.Visit(*this);} \n};  \n```", "```cpp\n//-----------------Modeling Unary Expression \nclass UnaryExpr : public Expr { \n   Expr * right; OPERATOR op; \n  public: \n   UnaryExpr( Expr *operand , OPERATOR op ) { right = operand;this-> op = op;} \n   Expr& getRight( ) { return *right; } \n   OPERATOR getOP() { return op; } \n   virtual ~UnaryExpr() { delete right; right = 0; } \n   double accept(IExprVisitor& expr_vis){ return expr_vis.Visit(*this);} \n};  \n```", "```cpp\n//--------An Evaluator for Expression Composite using Visitor Pattern  \nclass TreeEvaluatorVisitor : public IExprVisitor{ \n  public: \n   double Visit(Number& num){ return num.getNUM();} \n   double Visit(BinaryExpr& bin) { \n     OPERATOR temp = bin.getOP(); double lval = bin.getLeft().accept(*this); \n     double rval = bin.getRight().accept(*this); \n     return (temp == OPERATOR::PLUS) ? lval + rval: (temp == OPERATOR::MUL) ?  \n         lval*rval : (temp == OPERATOR::DIV)? lval/rval : lval-rval;   \n   } \n   double Visit(UnaryExpr& un) { \n     OPERATOR temp = un.getOP(); double rval = un.getRight().accept(*this); \n     return (temp == OPERATOR::UNARY_PLUS)  ? +rval : -rval; \n   } \n};\n```", "```cpp\n//------------A Visitor to Print Expression in RPN\nclass ReversePolishEvaluator : public IExprVisitor {\n    public:\n    double Visit(Number& num){cout << num.getNUM() << \" \" << endl; return 42;}\n    double Visit(BinaryExpr& bin){\n        bin.getLeft().accept(*this); bin.getRight().accept(*this);\n        OPERATOR temp = bin.getOP();\n        cout << ( (temp==OPERATOR::PLUS) ? \" + \" :(temp==OPERATOR::MUL) ?\n        \" * \" : (temp == OPERATOR::DIV) ? \" / \": \" - \" ) ; return 42;\n    }\n    double Visit(UnaryExpr& un){\n        OPERATOR temp = un.getOP();un.getRight().accept(*this);\n        cout << (temp == OPERATOR::UNARY_PLUS) ?\" (+) \" : \" (-) \"; return 42;\n    }\n};\n```", "```cpp\nint main( int argc, char **argv ){ \n     unique_ptr<Expr>   \n            a(new BinaryExpr( new Number(10) , new Number(20) , OPERATOR::PLUS)); \n     unique_ptr<IExprVisitor> eval( new TreeEvaluatorVisitor()); \n     double result = a->accept(*eval); \n     cout << \"Output is => \" << result << endl; \n     unique_ptr<IExprVisitor>  exp(new ReversePolishEvaluator()); \n     a->accept(*exp); \n}\n```", "```cpp\n//////////////////////////// \n// A enum to store discriminator -> Operator or a Value? \nenum class ExprKind{  ILLEGAL_EXP,  OPERATOR , VALUE }; \n// A Data structure to store the Expression node. \n// A node will either be a Operator or Value \nstruct EXPR_ITEM { \n    ExprKind knd; double Value; OPERATOR op; \n    EXPR_ITEM():op(OPERATOR::ILLEGAL),Value(0),knd(ExprKind::ILLEGAL_EXP){} \n    bool SetOperator( OPERATOR op ) \n    {  this->op = op;this->knd = ExprKind::OPERATOR; return true; } \n    bool SetValue(double value)  \n    {  this->knd = ExprKind::VALUE;this->Value = value;return true;} \n    string toString() {DumpContents();return \"\";} \n   private: \n      void DumpContents() { //---- Code omitted for brevity } \n}; \n```", "```cpp\n//---- A Flattener for Expressions \nclass FlattenVisitor : public IExprVisitor { \n        list<EXPR_ITEM>  ils; \n        EXPR_ITEM MakeListItem(double num) \n        { EXPR_ITEM temp; temp.SetValue(num); return temp; } \n        EXPR_ITEM MakeListItem(OPERATOR op) \n        { EXPR_ITEM temp;temp.SetOperator(op); return temp;} \n        public: \n        list<EXPR_ITEM> FlattenedExpr(){ return ils;} \n        FlattenVisitor(){} \n        double Visit(Number& num){ \n           ils.push_back(MakeListItem(num.getNUM()));return 42; \n        } \n        double Visit(BinaryExpr& bin) { \n            bin.getLeft().accept(*this);bin.getRight().accept(*this); \n            ils.push_back(MakeListItem(bin.getOP()));return 42; \n        } \n         double Visit(UnaryExpr& un){ \n            un.getRight().accept(*this); \n            ils.push_back(MakeListItem(un.getOP())); return 42; \n        } \n};  \n```", "```cpp\nlist<EXPR_ITEM> ExprList(Expr* r) { \n   unique_ptr<FlattenVisitor> fl(new FlattenVisitor()); \n    r->accept(*fl); \n    list<EXPR_ITEM> ret = fl->FlattenedExpr();return ret; \n }\n```", "```cpp\n//-------- A minimal stack to evaluate RPN expression \nclass DoubleStack : public stack<double> { \n   public: \n    DoubleStack() { } \n    void Push( double a ) { this->push(a);} \n    double Pop() { double a = this->top(); this->pop(); return a; } \n};  \n```", "```cpp\n//------Iterator through eachn element of Expression list \ndouble Evaluate( list<EXPR_ITEM> ls) { \n   DoubleStack stk; double n; \n   for( EXPR_ITEM s : ls ) { \n     if (s.knd == ExprKind::VALUE) { stk.Push(s.Value); } \n     else if ( s.op == OPERATOR::PLUS) { stk.Push(stk.Pop() + stk.Pop());} \n     else if (s.op == OPERATOR::MINUS ) { stk.Push(stk.Pop() - stk.Pop());} \n     else if ( s.op ==  OPERATOR::DIV) { n = stk.Pop(); stk.Push(stk.Pop() / n);} \n     else if (s.op == OPERATOR::MUL) { stk.Push(stk.Pop() * stk.Pop()); } \n     else if ( s.op == OPERATOR::UNARY_MINUS) { stk.Push(-stk.Pop()); } \n    } \n   return stk.Pop(); \n} \n//-----  Global Function Evaluate an Expression Tree \ndouble Evaluate( Expr* r ) { return Evaluate(ExprList(r)); } \n```", "```cpp\nint main( int argc, char **argv ){      \n     unique_ptr<Expr>\n         a(new BinaryExpr( new Number(10) , new Number(20) , OPERATOR::PLUS)); \n     double result = Evaluate( &(*a)); \n     cout << result << endl; \n} \n```", "```cpp\ntemplate <typename R, typename F> \nR Map(R r , F&& fn) { \n      std::transform(std::begin(r), std::end(r), std::begin(r), \n         std::forward<F>(fn)); \n      return r; \n} \n```", "```cpp\ntemplate <typename R, typename F> \nR Filter( R r , F&& fn ) { \n   R ret(r.size()); \n   auto first = std::begin(r), last = std::end(r) , result = std::begin(ret);  \n   bool inserted = false; \n   while (first!=last) { \n    if (fn(*first)) { *result = *first; inserted = true; ++result; }  \n    ++first; \n   } \n   if ( !inserted ) { ret.clear(); ret.resize(0); } \n   return ret; \n}\n```", "```cpp\n//------------------ Global Function to Iterate through the list  \nvoid Iterate( list<EXPR_ITEM>& s ){ \n    for (auto n : s ) { std::cout << n.toString()  << 'n';} \n} \n```", "```cpp\nint main( int argc, char **argv ){ \n     unique_ptr<Expr>   \n        a(new BinaryExpr( new Number(10.0) , new Number(20.0) , OPERATOR::PLUS)); \n      //------ExprList(Expr *) will flatten the list and Filter will by applied \n      auto cd = Filter( ExprList(&(*a)) , \n            [](auto as) {  return as.knd !=   ExprKind::OPERATOR;} ); \n      //-----  Square the Value and Multiply by 3... used | as composition Operator \n      //---------- See FuncCompose.h for details \n      auto cdr = Map( cd, [] (auto s ) {  s.Value *=3; return s; } |  \n                  [] (auto s ) { s.Value *= s.Value; return s; } ); \n      Iterate(cdr);  \n} \n```", "```cpp\n//----------------- OBSERVER interface \nstruct  OBSERVER { \n    int id; \n    std::function<void(const double)> ondata; \n    std::function<void()> oncompleted; \n    std::function<void(const std::exception &)> onexception; \n}; \n//--------------- Interface to be implemented by EventSource \nstruct OBSERVABLE { \n   virtual bool Subscribe( OBSERVER * obs ) = 0; \n    // did not implement unsuscribe  \n}; \n```", "```cpp\n//------------------A toy implementation of EventSource \ntemplate<class T,class F,class M, class Marg, class Farg > \nclass EventSourceValueSubject : public OBSERVABLE { \n   vector<OBSERVER> sinks;  \n   T *State;  \n   std::function<bool(Farg)> filter_func; \n   std::function<Marg(Marg)> map_func;\n```", "```cpp\n  public: \n   EventSourceValueSubject(Expr *n,F&& filter, M&& mapper) { \n       State = n; map_func = mapper; filter_func = filter; NotifyAll();  \n   } \n   ~EventSourceValueSubject() {  sinks.clear(); } \n   //------ used Raw Pointer ...In real life, a shared_ptr<T>\n   //------ is more apt here\n   virtual  bool Subscribe( OBSERVER  *sink ) { sinks.push_back(*sink); return true;} \n```", "```cpp\n   void NotifyAll() { \n      double ret = Evaluate(State); \n      list<double> ls; ls.push_back(ret); \n      auto result = Map( ls, map_func);; // Apply Mapping Logic \n      auto resulttr = Filter( result,filter_func); //Apply Filter \n      if (resulttr.size() == 0 ) { return; } \n```", "```cpp\n      double dispatch_number = resulttr.front(); \n      for (auto sink : sinks) {  \n           std::packaged_task<int()> task([&]()  \n           { sink.ondata(dispatch_number); return 1;  }); \n           std::future<int> result = task.get_future();task(); \n           double dresult = result.get(); \n         } \n     }\n```", "```cpp\n      T* GetState() { return State; } \n      void SetState(T *pstate) { State = pstate; NotifyAll(); } \n}; \n```", "```cpp\nExpr *getRandomExpr(int start, int end) { \n    std::random_device rd; \n    std::default_random_engine reng(rd()); \n    std::uniform_int_distribution<int> uniform_dist(start, end); \n    double mean = uniform_dist(reng); \n    return  new  \n          BinaryExpr( new Number(mean*1.0) , new Number(mean*2.0) , OPERATOR::PLUS); \n} \n```", "```cpp\nint main( int argc, char **argv ){ \n     unique_ptr<Expr>   \n         a(new BinaryExpr( new Number(10) , new Number(20) , OPERATOR::PLUS)); \n     EventSourceValueSubject<Expr,std::function<bool(double)>, \n                    std::function<double(double)>,double,double>  \n                    temp(&(*a),[] (auto s ) {   return s > 40.0;  }, \n                    []  (auto s ) { return s+ s ; }  | \n                    []  (auto s ) { return s*2;} ); \n```", "```cpp\n     OBSERVER obs_one ;     OBSERVER obs_two ; \n     obs_one.ondata = [](const double  r) {  cout << \"*Final Value \" <<  r << endl;}; \n     obs_two.ondata = [] ( const double r ){ cout << \"**Final Value \" << r << endl;};\n```", "```cpp\n     temp.Subscribe(&obs_one); temp.Subscribe(&obs_two);   \n```", "```cpp\n     Expr *expr = 0; \n     for( int i= 0; i < 10; ++i ) { \n           cout << \"--------------------------\" <<  i << \" \"<< endl; \n           expr = getRandomExpr(i*2, i*3 ); temp.SetState(expr); \n           std::this_thread::sleep_for(2s); delete expr; \n     } \n} \n```"]