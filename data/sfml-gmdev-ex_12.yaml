- en: Chapter 12. Can You Hear Me Now? – Sound and Music
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章.你现在能听到我吗？——声音和音乐
- en: 'There''s nothing quite like the enjoyment of being immersed in a virtual environment.
    From the movies we watch to the games we play, appeal to and usage of as many
    human senses as possible can either make or break the captivation that a form
    of media can hold. Creating a living and breathing atmosphere can rarely, if ever,
    be only down to visual effects. Throughout this chapter, we will briefly close
    our eyes and engage in the auditory side of this project by covering subjects
    such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸在虚拟环境中的享受是独一无二的。从我们观看的电影到我们玩的游戏，尽可能多地吸引和利用人类感官可以决定一种媒体能否吸引人。创造一个生机勃勃的氛围很少，如果不是永远，仅仅依靠视觉效果。在本章中，我们将暂时闭上眼睛，通过涵盖以下主题来参与这个项目的听觉方面：
- en: Basics of sound and music in SFML
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML中声音和音乐的基本知识
- en: Placement of sounds and the listener in 3D space
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D空间中声音和听者的位置
- en: Proper management and recycling of sound instances
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确管理和回收声音实例
- en: Expansion of the entity component system to allow for sounds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展实体组件系统以允许声音
- en: We have a long way to go until our first sonic boom, so let's dive right in!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离第一次声爆还有很长的路要走，所以让我们直接进入正题！
- en: Use of copyrighted resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用受版权保护的资源
- en: 'Before we jump into managing sounds, let''s give credit where it is due. Throughout
    this chapter, we''re going to use the following resources:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入声音管理之前，让我们给予应有的赞誉。在本章中，我们将使用以下资源：
- en: '*Fantozzi''s Footsteps (Grass/Sand & Stone)* by *Fantozzi* under the CC0 license
    (public domain): [http://opengameart.org/content/fantozzis-footsteps-grasssand-stone](http://opengameart.org/content/fantozzis-footsteps-grasssand-stone)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Fantozzi*创作的、受CC0许可（公共领域）的*Fantozzi的脚步声（草地/沙石与石头）*：[http://opengameart.org/content/fantozzis-footsteps-grasssand-stone](http://opengameart.org/content/fantozzis-footsteps-grasssand-stone)
- en: '*Electrix* (NES Version) by *Snabisch* under the CC-BY 3.0 license: [http://opengameart.org/content/electrix-nes-version](http://opengameart.org/content/electrix-nes-version)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Snabisch*创作的、受CC-BY 3.0许可的*NES版本Electrix*：[http://opengameart.org/content/electrix-nes-version](http://opengameart.org/content/electrix-nes-version)
- en: '*Town Theme RPG* by *cynicmusic* under the CC-BY 3.0 license: [http://opengameart.org/content/town-theme-rpg](http://opengameart.org/content/town-theme-rpg)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*cynicmusic*创作的、受CC-BY 3.0许可的*城镇主题RPG*：[http://opengameart.org/content/town-theme-rpg](http://opengameart.org/content/town-theme-rpg)
- en: Preparing the project for sound
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目准备声音
- en: 'In order to successfully compile a project that uses SFML audio, we need to
    make sure these additional dependency `.lib` files are included:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功编译使用SFML音频的项目，我们需要确保包含这些额外的依赖`.lib`文件：
- en: '`sfml-audio-s.lib`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfml-audio-s.lib`'
- en: '`openal32.lib`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openal32.lib`'
- en: '`flac.lib`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flac.lib`'
- en: '`ogg.lib`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ogg.lib`'
- en: '`vorbis.lib`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vorbis.lib`'
- en: '`vorbisenc.lib`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vorbisenc.lib`'
- en: '`vorbisfile.lib`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vorbisfile.lib`'
- en: Additionally, the executable file must always be accompanied by the `openal32.dll`
    file, which comes with SFML and can be found inside the `bin` folder of the library.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可执行文件必须始终附带SFML提供的`openal32.dll`文件，该文件位于库的`bin`文件夹中。
- en: Basics of SFML sound
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML声音的基本知识
- en: 'Anything audio related falls into one of two categories within SFML: `sf::Sound`
    that represents short sound effects, or `sf::Music` that is used to play longer
    audio tracks. It''s prudent that we understand how these two classes are used
    before continuing further. Let''s talk about each one individually.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何与音频相关的内容在SFML中都属于以下两个类别之一：代表短声音效果的`sf::Sound`，或用于播放较长时间音频片段的`sf::Music`。在继续之前，了解这两个类如何使用是明智的。让我们分别讨论每一个。
- en: Playing sounds
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放声音
- en: 'The `sf::Sound` class is extremely lightweight and should only ever be used
    to play short sound effects that don''t take up a lot of memory. The way it stores
    and utilizes actual audio files is by using a `sf::SoundBuffer` instance. It is
    analogous to `sf::Sprite` and the way it uses an instance of `sf::Texture` for
    drawing. The `sf::SoundBuffer` is used to hold audio data in memory, which the
    `sf::Sound` class then reads and plays from. It can be used as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Sound`类非常轻量级，应该仅用于播放短小的声音效果，不应占用大量内存。它存储和利用实际音频文件的方式是通过使用`sf::SoundBuffer`实例。这与`sf::Sprite`及其使用`sf::Texture`实例进行绘制的方式类似。`sf::SoundBuffer`用于在内存中存储音频数据，然后`sf::Sound`类从这些数据中读取并播放。它可以如下使用：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, a sound buffer can be attached to an instance of `sf::Sound`
    by either passing it to the sound's constructor or by using the `setBuffer` method
    of a sound instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可以通过将声音缓冲区传递给声音的构造函数或使用声音实例的`setBuffer`方法，将声音缓冲区附加到`sf::Sound`实例。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As long as the sound is expected to be playing, the `sf::SoundBuffer` instance
    *shouldn't* be destroyed!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 只要预期声音正在播放，就不应该销毁 `sf::SoundBuffer` 实例！
- en: 'After the sound buffer loads the sound file and is attached to an instance
    of `sf::Sound`, it can be played by invoking the `play()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在声音缓冲区加载声音文件并将其附加到 `sf::Sound` 实例之后，可以通过调用 `play()` 方法来播放：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It can also be paused and stopped by using the appropriately named `pause()`
    and `stop()` methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用相应命名的 `pause()` 和 `stop()` 方法来暂停和停止：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Obtaining the current status of a sound to determine if it''s playing, paused,
    or stopped can be done like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定声音是否正在播放、暂停或停止，以获取当前状态，可以这样做：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The status it returns is a simple enumeration of three values: `stopped`, `paused`,
    and `playing`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的状态是三个值的简单枚举：`stopped`、`paused` 和 `playing`。
- en: 'Lastly, we can adjust the sound''s volume, pitch, whether it loops or not,
    and how far the sound has progressed by using these methods respectively:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过使用这些方法分别调整声音的音量、音高、是否循环以及声音已播放的进度：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Audio pitch is simply a numeric value that represents frequency of the sound.
    Values above 1 will result in the sound playing at a higher pitch, while anything
    below 1 has the opposite effect. If the pitch is changed, it also changes the
    sound's playing speed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 音频音高是一个表示声音频率的数值。大于 1 的值会导致声音以更高的音高播放，而小于 1 的值则产生相反的效果。如果改变音高，也会改变声音的播放速度。
- en: Playing music
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音乐
- en: Any `sf::Music` instance supports all of the methods discussed previously, except
    `setBuffer`. As you already know, `sf::Sound` uses instances of `sf::SoundBuffer`
    that it reads from. This means that the entire sound file has to be loaded in
    memory for it to be played. With larger files, this quickly becomes inefficient,
    and that's the reason `sf::Music` exists. Instead of using buffer objects, it
    streams the data from the file itself as the music plays, only loading as much
    data as it needs for the time being.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `sf::Music` 实例都支持之前讨论的所有方法，除了 `setBuffer`。正如你所知道的那样，`sf::Sound` 使用它从中读取的
    `sf::SoundBuffer` 实例。这意味着整个声音文件必须加载到内存中才能播放。对于较大的文件，这很快就会变得低效，这就是 `sf::Music`
    存在的原因。它不是使用缓冲区对象，而是在音乐播放时从文件本身流式传输数据，只加载当前所需的数据。
- en: 'Let''s take a look at an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the name of the method `openFromFile`. In contrast, where sound buffers
    load files, `sf::Music` merely opens it and reads from it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法名称 `openFromFile`。相比之下，当声音缓冲区加载文件时，`sf::Music` 只打开它并从中读取。
- en: 'A very important thing to mention here is that `sf::Music` is a non-copyable
    class! This means that any sort of assignment by value will automatically result
    in an error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要提到的一个重要的事情是 `sf::Music` 是一个不可复制的类！这意味着任何形式的值赋值都会自动导致错误：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Passing a music instance to a function or a method by value would also produce
    the same results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递音乐实例到函数或方法也会产生相同的结果。
- en: Sound spatialization
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音空间化
- en: Both `sf::Sound` and `sf::Music` also support spatial positioning. It takes
    advantage of left and right audio channels and makes it feel like the sound is
    actually playing around you. There is a catch, though. Every sound or music instance
    that is desired to be spatial has to only have a single channel. It is more commonly
    known as a monophonic or mono sound, as opposed to stereo that already decides
    how the speakers are used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Sound` 和 `sf::Music` 也支持空间定位。它利用左右音频通道，让人感觉声音实际上是在你周围播放。不过有一个问题。任何希望实现空间化的声音或音乐实例都必须只有一个通道。这更常见地被称为单声道或单声，与已经决定了扬声器如何使用的立体声相对。'
- en: 'The way sounds are perceived in three-dimensional space is manipulated through
    a single, static class: `sf::Listener`. It''s static because there can only ever
    be one listener per application. The main two aspects of this class we''re interested
    in are the position and direction of the listener. Keep in mind that although
    we may be working on a 2D game, SFML sounds exist in 3D space. Let''s take a look
    at an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维空间中感知声音的方式是通过一个单一、静态的类：`sf::Listener`。它是静态的，因为每个应用程序只能有一个监听器。我们感兴趣的该类的主要两个方面是监听器的位置和方向。记住，尽管我们可能在制作
    2D 游戏，SFML 声音存在于 3D 空间中。让我们看看一个例子：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, let''s address the three-dimensional coordinates. In SFML, the default
    up vector is on the positive *Y* axis. Look at the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈三维坐标。在 SFML 中，默认的向上向量位于正 *Y* 轴上。看看下面的图：
- en: '![Sound spatialization](img/B04284_12_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![声音空间化](img/B04284_12_01.jpg)'
- en: Each axis the character is on represents a direction vector in three dimensions
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 角色所在的每个轴代表三维空间中的一个方向向量
- en: This arrangement of axes is known as a *right-handed Cartesian coordinate system*
    and is the standard for OpenGL, which is the basis of SFML. What this means is
    that what we've been calling the *Y* axis in two dimensions is really the *Z*
    axis in a three dimensional space. That's important to keep in mind if we want
    to have correct results when moving sound through space.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轴的排列被称为右手笛卡尔坐标系，是OpenGL的标准，而SFML就是基于OpenGL的。这意味着我们所说的二维空间的*Y*轴实际上是三维空间中的*Z*轴。如果我们想在空间移动声音时得到正确的结果，这一点很重要要记住。
- en: 'The listener direction is represented by something called a unit vector, also
    referred to as a normalized vector, which means it can only have a maximum magnitude
    of 1\. When setting the listener''s direction, the vector provided is normalized
    again, so these two lines of code would produce equivalent results of a south-east
    direction:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 听众的方向由一个称为单位向量的东西表示，也称为归一化向量，这意味着它只能有一个最大幅度为1。当设置听众的方向时，提供的向量将被再次归一化，因此这两行代码将产生等效的东南方向结果：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For our purposes, however, we're not going to need to use diagonal directions,
    as our main character, who will obviously be the sole listener, can only face
    four possible directions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们来说，我们不需要使用对角方向，因为我们的主要角色，显然将是唯一的听众，只能面向四个可能的方向。
- en: Placing sounds in space
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在空间中放置声音
- en: 'Much like how sprites are positioned in two-dimensional space, sounds can be
    positioned as well by using the method with the same name:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像精灵在二维空间中的位置一样，声音也可以通过同名的方法进行定位：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s say that the listener is facing in the positive *X* direction *(1.f,
    0.f, 0.f)*. The sound that we just placed at coordinates *(5.f, 0.f, 5.f)* would
    be five units ahead and five units to the right of our listener and would be heard
    through the right speaker. How loud would it have to be, though? That''s where
    the minimum sound distance and attenuation come in:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设听众面向正*X*方向 *(1.f, 0.f, 0.f)*。我们刚刚放置在坐标 *(5.f, 0.f, 5.f)* 的声音将位于听众前方五单位，右侧五单位，将通过右扬声器听到。然而，它需要多大声呢？这就是最小声音距离和衰减发挥作用的地方：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sound minimum distance is the threshold at which the sound begins to lose volume
    and gets quieter. In the preceding example, if the listener is closer or exactly
    six units of distance away from the sound source, full volume of the sound will
    be heard. Otherwise, the sound begins to fade. How fast it fades is determined
    by the attenuation factor. Consider this figure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 声音最小距离是声音开始失去音量并变弱的下限。在先前的例子中，如果听众距离声音源更近或正好六单位距离，将听到声音的全音量。否则，声音开始减弱。减弱的速度由衰减因子决定。考虑这个图示：
- en: '![Placing sounds in space](img/B04284_12_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![在空间中放置声音](img/B04284_12_02.jpg)'
- en: The circle with a radius of Min_Distance represents an area, where the sound
    can be heard at maximum volume. After the minimum distance is exceeded, the attenuation
    factor is applied to the volume.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 半径为Min_Distance的圆代表一个区域，在这个区域内可以听到最大音量的声音。超过最小距离后，将应用衰减因子到音量上。
- en: Attenuation is simply a multiplicative factor. The higher it is, the faster
    sound fades over distance. Setting attenuation to 0 would result in a sound heard
    everywhere, while a value like 100 would mean that it is heard only when the listener
    is very close to it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 衰减是一个乘法因子。它越高，声音随距离的衰减越快。将衰减设置为0会导致声音无处不在都能听到，而像100这样的值则意味着只有在听众非常接近时才能听到。
- en: Remember that although we're not going to be taking advantage of it, music in
    SFML behaves under the same rules of spatialization as sound, as long as it only
    has one channel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，尽管我们不会利用它，但只要它只有一个通道，SFML中的音乐在空间化方面遵循与声音相同的规则。
- en: Audio manager
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频管理器
- en: 'Similar to what we did for textures and fonts, we''re going to need a way to
    manage `sf::SoundBuffer` instances easily. Luckily, our `ResourceManager` class
    is there to make it extremely convenient, so let''s create the `AudioManager.h`
    file and define the way sound buffers are set up:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对纹理和字体所做的一样，我们需要一种方法来轻松管理`sf::SoundBuffer`实例。幸运的是，我们的`ResourceManager`类可以使其变得极其方便，因此让我们创建`AudioManager.h`文件并定义声音缓冲区的设置方式：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can tell already, the sound interface is pretty much exactly the same
    as that of textures or fonts. Similar to the previous resource managers, we also
    provide a file that paths are loaded from. In this case, it is the `audio.cfg`
    file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，声音接口几乎与纹理或字体完全相同。类似于之前的资源管理器，我们也提供了一个文件，路径是从该文件加载的。在这种情况下，它是 `audio.cfg`
    文件：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once again, it is just like dealing with textures or fonts. So far, so good!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这就像处理纹理或字体一样。到目前为止，一切顺利！
- en: Defining sound properties
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义声音属性
- en: 'Sound, much like any other medium, has a few different properties of interest
    that are up for tweaking. The effects we''re going to be playing in our game don''t
    just have varying sources, but also different volumes, pitch values, the distance
    a sound can cover, and a factor that represents how fast that sound fades. How
    we''re going to store this information is defined in `SoundProps.h`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 声音，就像任何其他媒介一样，有几个有趣的属性可以调整。我们将在游戏中播放的效果不仅有不同的来源，还有不同的音量、音调值、声音可以覆盖的距离以及表示声音衰减速度的系数。我们将如何存储这些信息在
    `SoundProps.h` 中定义：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to the qualities described earlier, it is also necessary to store
    the identifier of the audio file that a sound is going to be using. A typical
    sound file for our application would look something like `footstep.sound`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前描述的品质之外，还需要存储声音将要使用的音频文件的标识符。我们应用程序的典型声音文件可能看起来像 `footstep.sound`：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this out of the way, we can actually jump right into managing the `sf::Sound`
    instances!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题解决之后，我们实际上可以直接进入管理 `sf::Sound` 实例的阶段！
- en: Managing sounds
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理声音
- en: 'Due to the limitations on the number of sounds we can have in an application,
    it''s best to have a centralized way of handling and recycling them. This is where
    the `SoundManager` class comes in. Let''s begin aliasing a data type for sound
    IDs:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序中我们可以拥有的声音数量有限制，最好有一个集中处理和回收声音的方法。这就是 `SoundManager` 类发挥作用的地方。让我们开始为声音
    ID 赋予别名数据类型：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A simple integer type is more than qualified for the job of keeping sounds identified.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的整数类型完全能够胜任保持声音识别的工作。
- en: 'Additionally, we''ll want to store some information with the sound instance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想与声音实例存储一些信息：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In order to properly deallocate resources when it counts, we're going to want
    to store the string identifier of the audio file that the sound is using. Keeping
    track of whether the sound has been paused automatically or not is important for
    consistency. That's what the `m_manualPaused` Boolean flag is there for.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在关键时刻正确地释放资源，我们需要存储声音使用的音频文件的字符串标识符。跟踪声音是否被自动暂停对于一致性很重要。这就是 `m_manualPaused`
    布尔标志的作用。
- en: 'Lastly, before we delve deeper into the sound manager, looking at a few type
    definitions used here is essential:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们深入探讨声音管理器之前，查看这里使用的几个类型定义是至关重要的：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `SoundProperties` type is just a map that associates the name of a sound
    to a structure that contains its properties. `SoundContainer` is another map that
    ties a `SoundID` to a pair that contains the `SoundInfo` structure, as well as
    the actual instance of the `sf::Sound` object. The `Sounds` data type is responsible
    for grouping these sound containers by `State`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundProperties` 类型只是一个将声音名称与其属性包含的结构相关联的映射。`SoundContainer` 是另一个映射，它将 `SoundID`
    与包含 `SoundInfo` 结构以及实际的 `sf::Sound` 对象实例的配对绑定。`Sounds` 数据类型负责根据 `State` 对这些声音容器进行分组。'
- en: Further down the line, as sounds get recycled, they need to be moved to a different
    container of type `RecycledSounds`. It stores the sound ID and name alongside
    the `sf::Sound` instance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在声音被回收的过程中，它们需要被移动到不同类型的 `RecycledSounds` 容器中。它存储了声音 ID 和名称，以及 `sf::Sound` 实例。
- en: The last type definition we're going to be dealing with here is a container
    for `sf::Music` instances. Just like sounds, they're grouped by states. One major
    difference here is the fact that we're only allowing one instance of `sf::Music`
    per state, which is stored together with a `SoundInfo` structure.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的最后一个类型定义是一个用于 `sf::Music` 实例的容器。就像声音一样，它们按状态分组。这里的一个主要区别是我们只允许每个状态有一个
    `sf::Music` 实例，它与 `SoundInfo` 结构一起存储。
- en: 'Now that we have everything we need, let''s take a look at the sound manager
    header file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，让我们来看看声音管理器的头文件：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As mentioned previously, it's a good idea to keep the number of `sf::Sound`
    and `sf::Music` instances in your application down to a designated limit that
    never exceeds 256\. In this case, we're playing it pretty safe by using static
    data members for setting a limit of 150 sounds loaded in memory at the same time.
    In addition to that, we're also setting a limit to how many sound instances can
    be recycled before they're used again, which is 75\. These values can obviously
    be tweaked to your liking.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将应用程序中`sf::Sound`和`sf::Music`实例的数量限制在不超过256个的指定限制是一个好主意。在这种情况下，我们通过使用静态数据成员来设置同时加载到内存中的声音限制为150个，这样做相当安全。此外，我们还设置了一个限制，即在使用之前可以回收多少个声音实例，这个数字是75。这些值显然可以根据您的喜好进行调整。
- en: Let's talk about the private data members of this class before we get into implementation
    details. As expected, the sound and music containers are stored in this class
    under the names `m_audio` and `m_music`. Additionally, we're storing all of the
    sound properties in this class, alongside the recycled sound container. Because
    sound functionality is state based, the `m_currentState` data member is necessary
    for keeping tabs on what state the application is running in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解实现细节之前，让我们谈谈这个类的私有数据成员。正如预期的那样，声音和音乐容器存储在这个类中，分别命名为`m_audio`和`m_music`。此外，我们还将所有声音属性存储在这个类中，以及回收的声音容器。由于声音功能是基于状态的，因此`m_currentState`数据成员对于跟踪应用程序运行在哪个状态是必要的。
- en: In order to assign sound IDs properly, keeping track of the last ID is a good
    idea, hence `m_lastID`. Also, since enforcing restrictions on how many instances
    of `sf::Sound` and `sf::Music` can be "alive" at the same time is of paramount
    importance; `m_numSounds` is used to keep track of every instance of these two
    classes. We're also going to need to check time passage in our application, which
    is what `m_elapsed` will be used for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确分配声音ID，跟踪最后一个ID是一个好主意，因此有`m_lastID`。此外，由于强制限制`sf::Sound`和`sf::Music`实例同时“存活”的数量至关重要，`m_numSounds`用于跟踪这两个类的每个实例。我们还需要在我们的应用程序中检查时间流逝，这将是`m_elapsed`所用的。
- en: Finally, a pointer to the audio manager is kept around for resource management
    and retrieval.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，保留对音频管理器的指针，用于资源管理和检索。
- en: Implementing the sound manager
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现声音管理器
- en: 'Let''s begin, as always, by looking at the constructor and destructor of this
    class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，让我们从查看这个类的构造函数和析构函数开始：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A pointer to an `AudioManager` instance is obtained through the argument list
    of the constructor and initialized in the initializer list, alongside other data
    members and their default values. The destructor simply invokes another method
    called `Cleanup()`, which is responsible for the de-allocation of memory. It will
    be covered shortly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造函数的参数列表获取指向`AudioManager`实例的指针，并在初始化列表中初始化，与其他数据成员及其默认值一起。析构函数简单地调用另一个名为`Cleanup()`的方法，该方法负责释放内存。这将在稍后进行介绍。
- en: 'We have already discussed the role that application states play in sound management.
    Now, let''s take a look at actually defining the behavior of sound when states
    are changed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了应用状态在良好管理中所扮演的角色。现在，让我们来看看当状态改变时，声音行为的实际定义：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Upon the application state being altered, a `PauseAll` method is invoked with
    the argument of `m_currentState`. It's responsible for effectively silencing every
    sound that is currently playing. We don't want to be hearing fights and explosions
    of the in-game action while we're in the main menu. The `UnpauseAll` method is
    called next, with the identifier of the state being changed to being passed in
    as the argument. Obviously, if we're in the main menu and we're switching back
    to the game state, we want all of the action to resume and this includes all of
    the sound effects. The data member that holds the current state information is
    then altered.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用状态被改变时，会调用`PauseAll`方法，并传递`m_currentState`作为参数。它负责有效地静音当前正在播放的所有声音。在我们处于主菜单时，我们不想听到游戏中的战斗和爆炸声。接下来调用`UnpauseAll`方法，将状态改变的状态标识符作为参数传递。显然，如果我们处于主菜单并切换回游戏状态，我们希望所有动作都恢复，这包括所有声音效果。然后修改保存当前状态信息的数据成员。
- en: The last few lines of code in this method are responsible for making sure that
    the music container has information about the new state. If nothing is found,
    some blank information is inserted into the `m_music` container in order to signify
    that the current state currently has no music playing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法的最后几行代码中，负责确保音乐容器有关于新状态的信息。如果没有找到任何内容，就会在`m_music`容器中插入一些空白信息，以表示当前状态目前没有播放音乐。
- en: 'Next, let''s talk about what happens when a state is removed from the application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈当从应用程序中移除状态时会发生什么：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The sound container is first obtained for the state that is being removed. Every
    sound in that state is then iterated over and recycled via the `RecycleSound`
    method, which takes in the sound ID, pointer to the `sf::Sound` instance, and
    the sound name. Once that is done, all of the state information is erased from
    the `m_audio` container. Additionally, if an instance of `sf::Music` is found
    in that state, the memory for it is deallocated and the number of sounds currently
    existing in memory is decreased.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取要移除的状态的声音容器。然后遍历该状态中的每个声音，并通过`RecycleSound`方法进行回收，该方法接受声音ID、指向`sf::Sound`实例的指针和声音名称。完成这些后，所有状态信息都会从`m_audio`容器中删除。此外，如果在那个状态中找到了`sf::Music`实例，它的内存将被释放，并且当前内存中存在的声音数量会减少。
- en: 'Good memory management is extremely important in an application and is one
    of the main reasons we''re using manager classes instead of simply having resources
    scattered all over the place. The method responsible for cleaning up the mess
    in this case might look a little something like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，良好的内存管理非常重要，这也是我们使用管理类而不是简单地将资源散布各处的主要原因之一。负责清理这种混乱的方法可能看起来像这样：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we iterate over the container of currently playing sounds and release
    the audio resources that are being used. The dynamic memory for the sound is then
    deleted safely instead of being recycled. The exact same process is repeated one
    more time for all of the sounds that exist in the `m_recycled` container. Finally,
    all of the music instances are also deleted. Once all containers are properly
    cleared, the number of sounds is set back to 0, along with the last sound ID.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们遍历当前播放的声音容器，释放正在使用的音频资源。然后安全地删除声音的动态内存，而不是进行回收。对于`m_recycled`容器中存在的所有声音，重复上述过程。最后，删除所有音乐实例。一旦所有容器都得到适当清理，声音的数量将重置为0，以及最后一个声音ID。
- en: 'Now that we''ve covered all of the "housekeeping" details, let''s take a look
    at how we can make a system like this tick through its `Update` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有的“家务”细节，让我们看看我们如何通过`Update`方法使这样的系统运行起来：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: An important thing to keep in mind here is that we really don't need to run
    this chunk of code every single tick of the application. Instead, we keep track
    of time passing and check the `m_elapsed` data member each cycle to see if it's
    time to run our code yet. The `0.33f` value is arbitrary in this case and can
    be set to anything within a reasonable range.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的一个重要事项是，我们真的不需要在应用程序的每个tick都运行这段代码。相反，我们跟踪时间的流逝，并在每个周期检查`m_elapsed`数据成员，看是否是运行我们代码的时候了。在这个情况下，`0.33f`的值是任意的，可以设置在合理的范围内。
- en: If enough time has passed, we loop over every sound in the current state and
    check its status. If the sound has stopped, we can safely recycle it by invoking
    the `RecycleSound` method and then remove it from our primary sound container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经过去了足够的时间，我们就遍历当前状态中的每个声音并检查其状态。如果声音已经停止，我们可以通过调用`RecycleSound`方法安全地回收它，然后从我们的主要声音容器中移除它。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When an element in an STL container is removed, all iterators of said container
    become invalid. If left unattended, this can lead to elements being skipped or
    out of bounds accesses. It can be addressed by setting the iterator to the return
    value of the `erase` method, as it returns a valid iterator to an element *after*
    the one that has been erased. It increments the iterator only if an element hasn't
    been erased during the current cycle of the loop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个STL容器中的元素被移除时，该容器的所有迭代器都变为无效。如果置之不理，可能会导致元素被跳过或越界访问。可以通过将迭代器设置为`erase`方法的返回值来解决，因为它返回一个指向被删除元素之后元素的合法迭代器。只有当循环的当前周期中没有元素被删除时，迭代器才会递增。
- en: In this system, music follows the exact same treatment and is removed if it's
    no longer playing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，音乐遵循相同的处理方式，如果不再播放，就会被移除。
- en: 'Next, let''s look at providing a way for the users of this class to play sounds:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看为这个类的用户提供播放声音的方法：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We begin by obtaining a pointer to the sound properties structure by using the
    `GetSoundProperties` method, which we will be covering later. If it returned a
    `nullptr` value, -1 is returned by the `Play` method to signify a loading error.
    Otherwise, we proceed by creating a sound ID instance that is going to be passed
    in *by reference* to the `CreateSound` method, along with the identifier of the
    audio sound buffer. If the sound was created successfully, it returns a pointer
    to the `sf::Sound` instance that is ready to be used.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用`GetSoundProperties`方法获取声音属性结构的指针，该方法我们将在后面介绍。如果它返回`nullptr`值，则`Play`方法返回-1以表示加载错误。否则，我们继续创建一个将要传递给`CreateSound`方法的声声音ID实例，并附带音频声音缓冲区的标识符。如果声音创建成功，它将返回一个指向`sf::Sound`实例的指针，该实例已准备好使用。
- en: The `SetUpSound` method is then invoked with pointers to the `sf::Sound` instance
    and properties being passed in as arguments, as well as two Boolean flags for
    whether the sound should loop and be relative to the listener. The latter two
    are passed in as arguments to the `Play` method we're currently implementing.
    The sound is then positioned in space and stored in the `m_audio` container, along
    with the `SoundInfo` structure that is set up just one line before and holds the
    audio identifier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`SetUpSound`方法，将`sf::Sound`实例和属性作为参数传递，以及两个布尔标志，表示声音是否应该循环和相对于听者。后两个作为参数传递给当前正在实现的`Play`方法。然后，声音在空间中被定位并存储在`m_audio`容器中，以及设置在上一行并包含音频标识符的`SoundInfo`结构。
- en: The final step is then calling the `play()` method of our sound instance and
    returning the ID of said sound for later manipulations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用我们的声音实例的`play()`方法，并返回该声音的ID以供后续操作。
- en: 'As the header file suggests, there are two versions of the `Play` method. Let''s
    cover the other one now:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如头文件所示，`Play`方法有两个版本。现在让我们来看看另一个版本：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This version of the `Play` method only takes in a single argument of the sound
    ID and returns a Boolean flag. It's meant to start an already existing sound,
    which begins by it being located in the sound container. If the sound has been
    found, its `play` method is invoked and the `m_manualPaused` flag is set to `false`,
    showing that it is no longer paused.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`Play`方法只接受一个声音ID参数并返回一个布尔标志。它的目的是启动一个已经存在的声音，该声音首先位于声音容器中。如果找到了声音，它的`play`方法将被调用，并将`m_manualPaused`标志设置为`false`，表示它不再处于暂停状态。
- en: 'Stopping a sound works in a very similar fashion:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 停止声音的工作方式非常相似：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only difference here is that the `stop` method is invoked instead, and the
    `m_manualPaused` flag is set to `true` to signify that it has been paused in a
    non-automatic fashion.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是调用`stop`方法，并将`m_manualPaused`标志设置为`true`，以表示它以非自动方式被暂停。
- en: 'One more method that follows the exact same pattern is the `Pause` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个遵循完全相同模式的函数是`Pause`方法：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now it''s time to move on from sound and to music, specifically how it can
    be played:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候从声音转向音乐，特别是如何播放它：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, the music element for the current state is located. The path to the actual
    audio file is then obtained by using our newly added `GetPath` method and checked
    for being blank. If it isn't, we check whether an actual instance of `sf::Music`
    exists for the current state and create one if it doesn't. The `openFromFile`
    method of the `sf::Music` instance is then called in an `if` statement in order
    to check if it was successful or not. If it wasn't, the `sf::Music` instance is
    deleted and the number of sounds is decreased. Otherwise, the music instance is
    set to the volume and loop preferences provided as arguments and played. Note
    that we're setting every music instance to also be relative to the listener. While
    it is possible to make music positional, we have no need for it at this point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定位当前状态的音元素。然后，通过使用我们新添加的`GetPath`方法获取实际音频文件的路径，并检查其是否为空。如果不为空，我们检查当前状态是否存在`sf::Music`的实际实例，如果不存在则创建一个。随后，在`if`语句中调用`sf::Music`实例的`openFromFile`方法，以检查其是否成功。如果不成功，则删除`sf::Music`实例并减少声音的数量。否则，将音乐实例设置为提供的音量和循环偏好，并播放。请注意，我们正在将每个音乐实例设置为相对于听者的相对位置。虽然可以制作位置音乐，但我们目前不需要它。
- en: 'Because we want the same functionality for music as we do for any given sound,
    we have a fairly similar line-up of methods for manipulating music as well:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望音乐具有与任何给定声音相同的功能，因此我们也有类似的函数列表来操作音乐：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s get back to sound now. Since we''re going to be utilizing its spatial
    qualities, it''s a good idea to have a method that can be used for setting its
    position in space:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到声音上来。由于我们将利用其空间特性，因此有一个可以用来设置其在空间中位置的方法是个好主意：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method simply locates the sound instance in its container and sets its
    position to the one provided as an argument.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法只是在其容器中定位声音实例，并将其位置设置为提供的参数。
- en: 'What if we want to check if a sound is still playing? No problem! That''s what
    the `IsPlaying` method is for:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检查一个声音是否仍在播放？没问题！这正是`IsPlaying`方法的作用：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Due to the fact that sound status is a simple enumeration table, it can be forced
    into a Boolean value. Since we don't care about the "paused" state, returning
    the status as a Boolean works just fine.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音状态是一个简单的枚举表，它可以被强制转换为布尔值。由于我们不关心“暂停”状态，将状态作为布尔值返回就可以正常工作。
- en: 'Next, we have a way for obtaining the sound properties:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一种方法可以获取声音属性：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because sound properties aren't loaded during start-up, simply not finding the
    right information might simply mean that it was never loaded. If that's the case,
    the `LoadProperties` method is invoked. It returns a Boolean value that informs
    us of a failure, in which case a `nullptr` value is returned. Otherwise, the properties
    structure is searched for again and then returned at the end of this method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音属性在启动时没有加载，简单地找不到正确的信息可能仅仅意味着它从未被加载。如果是这种情况，将调用`LoadProperties`方法。它返回一个布尔值，告诉我们是否失败，在这种情况下返回`nullptr`值。否则，将再次在属性结构中搜索，并在该方法结束时返回。
- en: 'As we''re on the subject of loading properties, let''s actually take a look
    at how they''re loaded from the `.sound` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论加载属性的过程中，我们实际上可以看看它们是如何从`.sound`文件中加载的：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Having loaded many files in the past, this should be nothing new. So, let's
    just breeze right through it. A temporary `SoundProps` instance called `props`
    is created on the stack with a default audio name that is blank. The file is then
    processed and checked line by line for relevant keywords. The information is then
    loaded directly into the temporary properties instance using the `>>` operator.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去加载了许多文件之后，这应该没有什么新奇的。所以，我们就直接快速浏览一下。在栈上创建了一个临时的`SoundProps`实例，名为`props`，默认音频名称为空。然后逐行处理并检查文件中的相关关键词。信息随后使用`>>`运算符直接加载到临时的属性实例中。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For extra credit, the `if else` chain could be replaced with some sort of associative
    container of lambda functions, but let's keep the logic as it is for the sake
    of simplicity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得额外加分，可以将`if else`链替换为某种类型的关联lambda函数容器，但为了简单起见，我们还是保持原有的逻辑。
- en: Once the file has all been read in, it is closed and the audio name of the properties
    instance is checked for not being a blank, as it should've been loaded during
    the process. If the name is, in fact, something other than a blank, the `SoundProps`
    instance is inserted into the property container and true is returned for success.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件全部读取完毕，它将被关闭，并检查属性实例的音频名称是否不为空，因为它应该在过程中被加载。如果名称实际上不是空，则将`SoundProps`实例插入到属性容器中，并返回成功为`true`。
- en: 'As we were covering changing states, a few methods for pausing and starting
    all sounds were introduced. Let''s take a look at one of them now:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论状态变化时，介绍了一些暂停和启动所有声音的方法。现在让我们看看其中之一：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `PauseAll` method first obtains the container of all sounds for the provided
    state. It iterates over each one and checks if the sound is actually stopped or
    not. If it is, the sound is simply recycled and the element is erased. Otherwise,
    the sound's `pause` method is called. Music for the provided state is also paused,
    provided that it exists.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`PauseAll`方法首先获取提供状态的所有声音的容器。它遍历每一个，检查声音是否实际上已经停止。如果是，声音将被简单地回收，元素被删除。否则，将调用声音的`pause`方法。如果存在提供状态的音乐，也会暂停。'
- en: 'The `UnpauseAll` method is simpler, as it has no reason to recycle sounds:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnpauseAll`方法比较简单，因为它没有理由回收声音：'
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The catch here is that the sounds and music are only played again if they weren't
    manually paused by their respective `Pause` methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，只有当声音没有被相应的`Pause`方法手动暂停时，声音和音乐才会再次播放。
- en: 'Now, let''s implement arguably the most important piece of this class that
    is responsible for actual creation and recycling of the `sf::Sound` instances:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现这个类中可能最重要的部分，它负责实际的`sf::Sound`实例的创建和循环使用：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A local variable named `sound` is first set up with the value of `nullptr`,
    and it will be manipulated throughout the rest of this method. The size of the
    recycled sound container is then checked, along with whether the number of maximum
    sounds overall or maximum cached sounds has been exceeded.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先设置一个名为`sound`的局部变量，其值为`nullptr`，并在整个方法中对其进行操作。然后检查循环声音容器的尺寸，以及整体最大声音数量或最大缓存声音数量是否已超过。
- en: If the number of sounds is too high on either count and the recycled container
    isn't empty, we know we're going to be recycling an already existing sound. This
    process begins by first attempting to find a sound that already uses the same
    `sf::SoundBuffer` instance. In the case of such sound not existing, we simply
    pop the first element from the recycled container, store its ID in the variable
    `l_id` and release the resource that was used by the sound being recycled. The
    `l_id` argument takes a reference to a `SoundID` that it modifies, which serves
    as a way to let the outside code know the ID that has been assigned to the sound
    instance. The new resource that our sound is going to use is then reserved and
    our sound variable is set to point to the recycled sound instance, which is then
    set to use a new sound buffer. Our refurbished sound is removed from the recycled
    container. On the other hand, if a sound that uses the same `sf::SoundBuffer`
    instance was found, it doesn't need any additional setting up and can simply be
    returned after its ID is stored and it's erased from the `m_recycled` container.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声音的数量过高，无论是总数还是循环容器不为空，我们知道我们将要循环使用已经存在的声音。这个过程首先尝试找到一个已经使用相同`sf::SoundBuffer`实例的声音。如果这样的声音不存在，我们就简单地从循环容器中弹出第一个元素，将其ID存储在变量`l_id`中，并释放被循环声音使用的资源。`l_id`参数接受一个对`SoundID`的引用，它修改该引用，这作为让外部代码知道分配给声音实例的ID的一种方式。然后为新资源预留空间，并将我们的声音变量设置为指向循环声音实例，然后将其设置为使用新的声音缓冲区。我们的翻新声音从循环容器中移除。另一方面，如果找到了使用相同`sf::SoundBuffer`实例的声音，它不需要任何额外的设置，只需在存储其ID并将其从`m_recycled`容器中删除后即可返回。
- en: 'If there were no recycled sounds available or we had extra space to spare,
    a new sound is created instead of using a recycled one. The ID of the sound is
    set to match that of `m_lastID`, which is then incremented (same as `m_numSounds`).
    After the sound''s buffer is set up, it can safely be returned for further processing,
    such as in the `SetUpSound` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的循环声音或者我们有额外的空间可以用来创建新的声音，那么就会创建一个新的声音而不是使用循环声音。声音的ID被设置为匹配`m_lastID`，然后递增（与`m_numSounds`相同）。在声音的缓冲区设置完成后，它可以安全地返回以进行进一步处理，例如在`SetUpSound`方法中：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main idea of this method is simply reducing code wherever possible. It sets
    up the volume, pitch, minimum distance, attenuation, looping, and relativity of
    the sound all based on the arguments provided.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的主要思想是尽可能减少代码。它根据提供的参数设置声音的音量、音调、最小距离、衰减、循环和相对性。
- en: 'Let''s wrap this class up with a relatively simple yet commonly used piece
    of code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一段相对简单但常用的代码来结束这个类：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method is only responsible for pushing the information provided as arguments
    into the recycled container for later use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅负责将作为参数提供的信息推送到循环容器中，以供以后使用。
- en: Adding support for sound
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音支持
- en: 'In order to make our entities emit sounds, some preparations have to be made.
    For now, we''re only going to concern ourselves with simply adding the sound of
    footsteps whenever a character walks. Doing so requires a slight modification
    of the `EntityMessage` enumeration in `EntityMessages.h`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的实体发出声音，必须做一些准备工作。目前，我们只关心在角色行走时简单地添加脚步声。这样做需要对`EntityMessages.h`中的`EntityMessage`枚举进行轻微修改：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The highlighted bits are what we're going to be focusing on. `Frame_Change`
    is a new type of message that's been added in this chapter, and `Direction_Changed`
    will be used to manipulate the sound listener's direction. In order to detect
    when a frame changes during the animation process, however, we're going to need
    to make a few more adjustments to our code base.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注突出显示的部分。`Frame_Change`是本章中添加的新类型消息，而`Direction_Changed`将用于操纵声音监听器的方向。然而，为了检测动画过程中帧的变化，我们还需要对我们的代码库进行一些调整。
- en: Animation system hooks
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画系统钩子
- en: 'In order to have the ability to send out the `Frame_Change` message we''ve
    just created, our animation system is going to need a few minor additions, starting
    with `Anim_Base.h`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够发送我们刚刚创建的`Frame_Change`消息，我们的动画系统将需要一些小的补充，从`Anim_Base.h`开始：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we''re adding a new data member and a method to check if the current
    frame of an animation has recently been changed. Let''s actually integrate this
    code in `Anim_Base.cpp`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的数据成员和一个方法来检查动画的当前帧是否最近已被更改。让我们实际上在`Anim_Base.cpp`中集成这段代码：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the constructor, it's important to remember to set the newly added data member
    to a default value, which in this case is `false`. The actual `CheckMoved` method
    is a very basic chunk of code that returns the value of `m_hasMoved` but sets
    it to `false` at the same time in order to avoid false positives.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，重要的是要记住将新添加的数据成员设置为默认值，在这个例子中是`false`。实际的`CheckMoved`方法是一段非常基础的代码块，它返回`m_hasMoved`的值，但同时也将其设置为`false`，以避免出现误报。
- en: 'Now that we have an active flag that is going to be used to check for frame
    changes, all that''s missing is simply setting it to `true` in the `SetFrame`
    method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个将被用来检查帧变化的激活标志，所缺少的只是简单地在`SetFrame`方法中将它设置为`true`：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice the return value is now a Boolean instead of void. This additional change
    makes it very easy to do error checking, which is very important for making our
    last alteration in `Anim_Directional.cpp`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回值现在是一个布尔值而不是`void`。这个额外的变化使得进行错误检查变得非常容易，这对于我们在`Anim_Directional.cpp`中进行的最后修改非常重要：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The difference here is subtle but relevant. We essentially went from incrementing
    the current frame by hand by using `m_frameCurrent` to only using the `SetFrame`
    method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别微妙但相关。我们实际上是从手动通过`m_frameCurrent`递增当前帧，转变为仅使用`SetFrame`方法。
- en: Entity component system expansion
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体组件系统扩展
- en: 'With adjustments made previously, we can now put down our last piece of the
    puzzle in making this work by sending out the `Frame_Change` message in `S_SheetAnimation.cpp`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 经过之前的调整，我们现在可以通过在`S_SheetAnimation.cpp`中发送`Frame_Change`消息来放下最后一部分拼图，使其工作：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Update` method, as you might recall, already handles other types of messages
    that are related to entities attacking and dying, so this is already gift-wrapped
    for us. The `CheckMoved` method we added earlier comes in handy and aids us in
    checking for changes. If there has been a change, the current frame is obtained
    and stored in the message, which is shortly followed by a `Dispatch` call.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，`Update`方法已经处理了与实体攻击和死亡相关的其他类型的消息，所以这已经为我们准备好了。我们之前添加的`CheckMoved`方法现在派上了用场，并帮助我们检查变化。如果有变化，当前帧将被获取并存储在消息中，随后很快就会调用`Dispatch`。
- en: The sound emitter component
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音发射组件
- en: 'Within the entity component system paradigm, every possible entity parameter
    or feature is represented as a component. Emitting sounds is definitely one of
    those features. In order for that to happen, we do have some setting up to do,
    starting with creating and implementing it in the `C_SoundEmitter.h` header. Before
    that, however, let''s define the types of sounds an entity can have:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体组件系统范式内，每一个可能的实体参数或特性都表示为一个组件。发出声音无疑是这些特性之一。为了实现这一点，我们确实需要进行一些设置，从在`C_SoundEmitter.h`头文件中创建和实现它开始。然而，在此之前，让我们定义实体可以拥有的声音类型：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, we're only going to be working with four types of sound, one
    of which is going to be implemented in this chapter. A `None` value is also set
    up in order to make error checking easier.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只将与四种类型的音效打交道，其中之一将在本章中实现。还设置了一个`None`值，以便于进行错误检查。
- en: 'Every sound that an entity can emit will most likely have different frames
    it plays during, which calls for a new data structure that encapsulates such information:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实体可以发出的每一个声音很可能会在不同的帧中播放，这需要一个新的数据结构来封装此类信息：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since sounds are going to be tied to specific frames of animation, we need to
    define the maximum possible number of frames that can have sounds attached to
    them. The static constant named `Max_SoundFrames` is used for that purpose here.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音将被绑定到动画的特定帧上，我们需要定义可以附加声音的最大帧数。名为`Max_SoundFrames`的静态常量在这里用于此目的。
- en: The constructor of the `SoundParameters` structure initializes the entire array
    of frames to a value of -1\. This is going to allow us to check this information
    in a slightly more efficient way, as the check can be over whenever the first
    -1 value is encountered. In addition to an array of frame numbers, this structure
    also stores the name of the sound that is to be emitted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundParameters`结构的构造函数将整个帧数组初始化为-1的值。这将允许我们以稍微高效一些的方式检查这个信息，因为检查可以在遇到第一个-1值时停止。除了帧数字组之外，这个结构还存储了要发出的声音的名称。'
- en: 'Now, we can finally begin implementing the sound emitter component:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以开始实现声音发射组件了：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, another static constant is created in order to denote the number of entity
    sounds that are going to exist. The component itself only has two data members.
    The first one is a sound ID that will be used for emitting sounds that should
    not be played repeatedly and have to wait until the previous sound is finished.
    The second data member is an array of sound parameters for each possible type
    of entity sound.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建了一个新的静态常量，用来表示将要存在的实体声音的数量。该组件本身只有两个数据成员。第一个是一个声音ID，它将被用来发射不应重复播放且必须等待前一个声音播放完毕的声音。第二个数据成员是每个可能的实体声音类型的参数数组。
- en: 'Let''s begin implementing the component, starting with its constructor:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组件的构造函数开始实现组件：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Apart from the typical invocation of the `C_Base` constructor with the component
    type passed in, the sound ID data member is initialized to -1 as well to signify
    that this component currently is not playing any sounds.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用传递的组件类型调用`C_Base`构造函数之外，声音ID数据成员也被初始化为-1，以表示该组件当前没有播放任何声音。
- en: 'In order for the future sound system to know what sounds to play, we''re going
    to provide a way sound information can be extracted from this component:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让未来的声音系统知道播放哪些声音，我们将提供一种从该组件中提取声音信息的方法：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By simply providing one of the enumerated values of `EntitySound` as an argument,
    outside classes can retrieve information about which sound to play given the circumstances.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地提供一个`EntitySound`枚举值作为参数，外部类可以获取在特定情况下应该播放哪个声音的信息。
- en: 'Additionally, in order to know if a sound should be played or not, the sound
    system will need a way to tell if the current frame of animation should be emitting
    sound or not. This is where the `IsSoundFrame` method comes in:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了知道是否应该播放声音，声音系统将需要一个方法来判断当前动画帧是否应该发出声音。这就是`IsSoundFrame`方法的作用所在：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If the provided sound argument is larger than the highest supported entity sound
    ID, `false` is returned. Otherwise, all of the frames for the given sound are
    iterated over. If a -1 value is encountered, `false` is returned right away. However,
    if the frame provided as an argument matches a sound frame in the array, this
    method returns `true`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的声音参数大于最高支持的实体声音ID，则返回`false`。否则，将迭代给定声音的所有帧。如果遇到-1值，则立即返回`false`。然而，如果提供的帧参数与数组中的声音帧匹配，则此方法返回`true`。
- en: 'Next, we''re going to need a few helper methods to set and get certain information:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些辅助方法来设置和获取某些信息：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before we get to reading in this component''s information from the entity file,
    let''s take a gander at what it might look like. This snippet can be found inside
    `Player.entity`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从实体文件中读取此组件的信息之前，让我们看看它可能的样子。这个片段可以在`Player.entity`文件中找到：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After the component ID, we''re going to be reading in the name of the sound
    effect to be played, followed by a set of frames delimited by commas. The name
    of the sound itself is separated from the frame information by a colon. Let''s
    write this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件ID之后，我们将读取要播放的声音效果的名称，然后是一系列由逗号分隔的帧。声音本身的名称与帧信息之间由冒号分隔。让我们写下这个：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After the delimiter information is set up, we iterate once for each possible
    entity sound and read in the contents of the next segment of the line into a string
    named `chunk`. If that string is actually empty, we break out of the loop as there''s
    clearly no more information to be loaded. Otherwise, the chunk is split into two
    parts right at the colon delimiter: `sound` and `frames`. The entity sound is
    then stored inside the parameters structure.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置分隔符信息之后，我们针对每个可能的实体声音迭代一次，并将行中的下一个段的内容读入一个名为`chunk`的字符串。如果该字符串实际上是空的，则退出循环，因为显然没有更多的信息需要加载。否则，将块在冒号分隔符处分成两部分：`sound`和`frames`。然后，实体声音存储在参数结构体中。
- en: 'Lastly, it''s necessary to process the frame information, which is delimited
    by commas. Two local variables are set up to help us with this: `pos` that stores
    the position of the comma delimiter if one is found and `frameNum` that is used
    to make sure the `Max_SoundFrames` limit is honored. Inside the `while` loop,
    the frame delimiter is first located using the `find` method of the `std::string`
    class. If a delimiter was found, the frame is extracted from the string and converted
    to an integer, which is stored inside the variable `frame`. That entire segment,
    including the delimiter, is then erased from the string `frames` and the extracted
    information is stored inside the parameters structure. In a case where a delimiter
    wasn''t found, however, the loop is stopped right after the frame information
    has been extracted.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有必要处理帧信息，这些信息由逗号分隔。为此设置了两个局部变量来帮助我们：`pos`用于存储逗号分隔符的位置（如果找到的话），而`frameNum`用于确保遵守`Max_SoundFrames`限制。在`while`循环内部，首先使用`std::string`类的`find`方法定位帧分隔符。如果找到了分隔符，则从字符串中提取帧并将其转换为整数，存储在变量`frame`中。然后，包括分隔符在内的整个段被从字符串`frames`中删除，提取的信息存储在参数结构体中。然而，如果没有找到分隔符，循环将在提取帧信息后立即停止。
- en: The sound listener component
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音监听器组件
- en: 'In order to properly implement spatial sounds, there has to be a listener within
    our game world. That listener is, of course, the player of the game. Fortunately,
    there isn''t a lot of information we need to process or store when creating a
    component for an audio listener:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确实现空间声音，我们的游戏世界中必须有一个监听器。当然，这个监听器是游戏玩家。幸运的是，在创建音频监听器组件时，我们不需要处理或存储大量的信息：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Yes, that's it! In its most essential form, this class simply represents a sign
    that its owner entity should be treated as a listener in the auditory world.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是这样！在其最基本的形式中，这个类仅仅表示一个标志，表示其所有者实体应在听觉世界中被视为监听器。
- en: Implementing the sound system
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现声音系统
- en: With both sound emitter and sound listener components out of the way, we have
    a green light to begin implementing the sound system that is going to bring all
    of this code to life. Let's get it started!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完声音发射器和声音监听器组件之后，我们可以开始实现将所有这些代码激活的声音系统。让我们开始吧！
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Apart from the typical methods that a system is required to implement and a
    few custom ones, we also have two data members that point to instances of the
    `AudioManager` and `SoundManager` classes. Let''s begin actually implementing
    the sound system:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统需要实现的典型方法和一些自定义方法之外，我们还有两个数据成员，它们指向`AudioManager`和`SoundManager`类的实例。让我们开始实际实现声音系统：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The constructor, predictably enough, sets up two possible versions of the requirement
    bitmask, both of which require the position component to be present. It then subscribes
    to the two message types we discussed previously.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，不出所料，设置了两个可能的要求掩码版本，这两个版本都需要位置组件存在。然后，它订阅了我们之前讨论的两个消息类型。
- en: 'Since we''re going to need access to both the audio manager and sound manager,
    a method like this can definitely come in handy:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要访问音频管理器和声音管理器，这样的方法肯定很有用：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, let''s take a jab at implementing the `Update` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试实现`Update`方法：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Each entity in this system first has its position and elevation obtained and
    stored inside a few local variables. It also determines if the current entity
    is the sound listener or not and stores that information inside a Boolean variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，每个实体首先获取其位置和高度，并将这些信息存储在几个局部变量中。它还确定当前实体是否是声音监听器，并将该信息存储在布尔变量中。
- en: If the current entity has a sound emitter component and its sound ID is not
    equal to -1, it's safe to deduce that the sound is currently still being played.
    If the current entity is not a sound listener, we attempt to update the sound's
    position and catch the result of that in an `if` statement. If the position update
    fails, the sound ID is set back to -1, since it means the sound is no longer active.
    If the entity is, in fact, a listener, we don't need to update the sound's position
    at all. Instead, we determine if the sound is still playing or not by calling
    the `IsPlaying` method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前实体具有声音发射器组件且其声音ID不等于-1，可以安全地推断声音目前正在播放。如果当前实体不是声音监听者，我们尝试更新声音的位置并在`if`语句中捕获结果。如果位置更新失败，则将声音ID设置回-1，因为这表示声音不再活跃。如果实体实际上是监听者，我们根本不需要更新声音的位置。相反，我们通过调用`IsPlaying`方法来确定声音是否仍在播放。
- en: Afterwards, it's necessary to update the position of the `sf::Listener` class
    if the current entity has the listener component. Note the use of the `MakeSoundPosition`
    method here, as well as in the previous chunk of code. It returns a `sf::Vector3f`
    based on the position and elevation of an entity. We're going to cover this method
    shortly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果当前实体具有监听器组件，有必要更新`sf::Listener`类的位置。注意这里以及之前代码块中`MakeSoundPosition`方法的使用。它根据实体的位置和高度返回一个`sf::Vector3f`。我们将在稍后介绍这个方法。
- en: 'Let''s work on handling both of the message types we''ve discussed previously
    next:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理之前讨论的两种消息类型：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In case the entity's direction has changed and it is the sound listener, we
    obviously need to change the direction of the `sf::Listener` to match the one
    that is carried inside the message. On the other hand, if we receive a message
    about a frame changing, the `EmitSound` method is called with the entity ID, sound
    type, two Boolean flags indicating whether the sound should loop and whether it
    should be relative to the listener or not, and the current frame the animation
    is in all passed in as arguments. The sound relativity to the listener in the
    scene is simply decided by whether the current entity itself is a listener or
    not.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体的方向已改变且它是声音监听者，我们显然需要改变`sf::Listener`的方向以匹配消息中携带的方向。另一方面，如果我们收到有关帧改变的消息，将使用实体ID、声音类型、两个布尔标志（指示声音是否应该循环以及是否相对于监听者）和动画当前帧作为参数调用`EmitSound`方法。场景中声音相对于监听者的相对性简单由当前实体本身是否是监听者来决定。
- en: 'Positioning sounds in space is also a huge part of this whole system working
    correctly. Let''s take a look at the `MakeSoundPosition` method:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间中定位声音也是整个系统正确工作的重要组成部分。让我们看看`MakeSoundPosition`方法：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Due to the default up vector in SFML being the positive *Y* axis, the two dimensional
    coordinates of an entity position are passed in as X and Z arguments. Meanwhile,
    the *Y* argument is simply the entity's elevation multiplied by the `Tile_Size`
    value, found inside the `Map.h` header, which results in entity elevation simulating
    the height.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SFML中的默认向上向量是正*Y*轴，因此将实体位置的二维坐标作为X和Z参数传入。同时，*Y*参数简单地是实体高度乘以`Tile_Size`值，该值在`Map.h`头文件中找到，这导致实体高度模拟高度。
- en: 'Last but definitely not least, we have a chunk of code that is responsible
    for entities emitting all their sounds that we need to take a look at:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但绝对重要的是，我们有一段负责实体发射所有声音的代码，我们需要看看：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first task is obviously checking if the sound system has an entity with
    the provided ID, and if the entity is a sound emitter. If it is, the sound emitter
    component is obtained and the sound ID it stores is checked for being equal to
    -1\. The code still proceeds, however, if an entity is already emitting another
    sound but the `l_useId` argument is set to `false`, which tells us that a sound
    should be emitted regardless. Next, the frame passed in as an argument is checked
    for either being equal to -1, which means the sound should be played regardless,
    or for it being one of the sound frames defined inside the sound emitter component.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是显然检查声音系统是否有具有提供ID的实体，并且该实体是否是声音发射器。如果是，就获取声音发射器组件并检查它存储的声音ID是否等于-1。然而，如果实体已经发射了另一个声音但`l_useId`参数设置为`false`，这告诉我们应该发出声音。接下来，检查传入的帧参数是否等于-1，这意味着应该播放声音，或者检查它是否是声音发射器组件内部定义的声音帧之一。
- en: Once we commit to playing the sound, the entity's position component is obtained
    and used to calculate the position of the sound. If it should be relative to the
    listener, the position is simply set to be at the absolute zero coordinate of
    all axes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定播放声音，就会获取实体的位置组件并用于计算声音的位置。如果它应该是相对于听者的，则位置简单地设置为所有轴的绝对零坐标。
- en: If we want to only keep a single instance of a particular sound, the `Play`
    method of the sound manager is invoked within the `SetSoundID` argument list of
    the sound emitter component to catch the returned ID. It only has two arguments
    passed in, as the other two Boolean flags hold the default values of `false`.
    Otherwise, if this particular sound should be played irrespective of whether the
    entity is already emitting another sound or not, the `Play` method of our sound
    manager is called by itself and the Boolean flag for sound being relative to the
    listener is passed in as the last argument.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想保留特定声音的单个实例，声音管理器的`Play`方法将在声音发射组件的`SetSoundID`参数列表中调用，以捕获返回的ID。它只传递了两个参数，因为其他两个布尔标志持有`false`的默认值。否则，如果这个特定的声音应该播放，无论实体是否已经发出另一个声音，我们的声音管理器的`Play`方法将自行调用，并将声音相对于听者的布尔标志作为最后一个参数传递。
- en: Integrating our code
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合我们的代码
- en: 'In order to prevent sounds or music from playing at inappropriate times, our
    state manager must notify the sound manager of any state changes:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在不适当时播放声音或音乐，我们的状态管理器必须通知声音管理器任何状态变化：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Since the sound manager also cares about states being removed, let''s tell
    it when that happens:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音管理器也关心状态的移除，让我们在发生这种情况时通知它：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The only thing we have left to do now is actually integrating everything we
    worked on into the rest of our code base, starting with `SharedContext.h`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一要做的就是将我们所有的工作整合到我们的代码库中，从`SharedContext.h`开始：
- en: '[PRE64]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, instantiating and managing these two new classes inside the shared context
    is of utmost importance. Let''s start by modifying the `Game.h` header:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在共享上下文中实例化和管理这两个新类至关重要。让我们先从修改`Game.h`头文件开始：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As always, we keep these manager classes inside `Game` in order to manage their
    lifetime properly. For some of them, however, merely existing isn''t enough. They
    require to be set up like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将这些管理类放在`Game`中，以便正确管理它们的生命周期。然而，对于其中的一些，仅仅存在是不够的。它们需要像这样设置：
- en: '[PRE66]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After both classes are created, their addresses are passed to the shared context.
    One more important detail that's easy to overlook is actually setting up the sound
    system at this point. It needs to have access to both the audio and the sound
    manager.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这两个类之后，它们的地址被传递到共享上下文中。一个容易被忽视的重要细节是在这一点上实际上设置声音系统。它需要访问音频和声音管理器。
- en: 'Let''s not forget to also update the sound manager properly during the flow
    of the entire application:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们别忘了在整个应用程序流程中正确更新声音管理器：
- en: '[PRE67]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'With the creation of new components and systems comes the responsibility of
    making sure they can actually be created automatically, by adding the component
    types to the entity manager:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新组件和系统的创建，我们也有责任确保它们可以自动创建，通过将组件类型添加到实体管理器：
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Our sound system also needs to be created inside the system manager:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的声音系统也需要在系统管理器内部创建：
- en: '[PRE69]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Having all of that done, we can finally add some music to our game! Let''s
    start by making sure we have an intro soundtrack by modifying `State_Intro.cpp`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们终于可以为我们的游戏添加音乐了！让我们先通过修改`State_Intro.cpp`来确保我们有一个开场音乐：
- en: '[PRE70]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Also, it would be nice to have some background music during actual game-play,
    so let''s modify `State_Game.cpp` as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在游戏实际进行时有一些背景音乐会很好，所以让我们按照以下方式修改`State_Game.cpp`：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: And voila! Just like that, we now have music and dynamic sound effects baked
    into our RPG!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！就这样，我们现在在我们的RPG中有了音乐和动态音效！
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With possibilities ranging anywhere from simple ambiance to complex musical
    scores tugging at the heart strings of the player, our game world starts to develop
    a sense of character and presence. All of the hard work we put in towards making
    sure our project isn't mute adds up to yet another major leap in the direction
    of quality. However, as we begin to approach the end of this book with only two
    chapters remaining, the most challenging part is still yet to come.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏世界开始发展出一种角色感和存在感，从简单的氛围到复杂的音乐曲目牵动着玩家的心弦。我们投入的所有努力，确保我们的项目不会沉默无声，累积起来又是一次向质量方向的重大飞跃。然而，随着我们开始接近这本书的结尾，只剩下两章，最具挑战性的部分仍然还在前方。
- en: In the next chapter, we will be exploring the vast world of networking and how
    it can help us turn our lonely, quiet RPG into a battle zone of multiple other
    players. See you there!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索广阔的网络世界以及它是如何帮助我们把我们孤独、安静的角色扮演游戏转变为多个玩家战斗区的。那里见！
