- en: '*Chapter 9*: Exploring Multiple Inheritance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：探索多重继承'
- en: This chapter will continue broadening our knowledge of object-oriented programming
    in C++. We will begin by examining a controversial OO concept, **multiple inheritance**
    (**MI**), understanding why it is controversial, how it can reasonably be used
    to support OO designs, as well as when alternative designs may be more appropriate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续扩展我们对C++中面向对象编程的知识。我们将从检查一个有争议的面向对象概念，**多重继承**（**MI**）开始，了解为什么它有争议，如何可以合理地用于支持面向对象设计，以及何时替代设计可能更合适。
- en: Multiple inheritance can be implemented in C++ with *direct language support*.
    In doing so, we will be faced with several OO design issues. We will be asked
    to critically evaluate an inheritance hierarchy, asking ourselves if we are using
    the best design possible to represent a potential set of object relationships.
    Multiple inheritance can be a powerful OOP tool; using it wisely is paramount.
    We will learn when to use MI to sensibly extend our hierarchies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承可以在C++中通过*直接语言支持*来实现。这样做，我们将面临几个面向对象设计问题。我们将被要求对继承层次结构进行批判性评估，问自己是否使用最佳设计来表示潜在的对象关系集。多重继承可以是一个强大的面向对象编程工具；明智地使用它是至关重要的。我们将学习何时使用多重继承来合理地扩展我们的层次结构。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding multiple inheritance mechanics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多重继承的机制
- en: Examining reasonable uses for multiple inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查多重继承的合理用途
- en: Creating diamond-shaped hierarchies and exploring issues arising from their
    usage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菱形层次结构并探讨由其使用引起的问题
- en: Using virtual base classes to resolve diamond-shaped hierarchy duplication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚基类解决菱形层次结构的重复
- en: Applying discriminators to evaluate the worthiness of a diamond-shaped hierarchy
    and MI in a design, as well as considering design alternatives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用判别器来评估菱形层次结构和设计中多重继承的价值，以及考虑设计替代方案
- en: By the end of this chapter, you will understand the OO concept of multiple inheritance,
    and how to implement this idea in C++. You will understand not only the simple
    mechanics of MI but also the reasons for its usage (mix-in, Is-A, or controversially,
    Has-A).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解多重继承的面向对象概念，以及如何在C++中实现这个想法。您将不仅了解多重继承的简单机制，还将了解其使用的原因（混入，Is-A，或有争议的Has-A）。
- en: You will see why MI is controversial in OOP. Having more than one base class
    can lead to oddly shaped hierarchies, such as diamond-shaped; these types of hierarchies
    come with potential implementation issues. We will see how C++ incorporates a
    language feature (virtual base classes) to solve these conundrums, but the solution
    is not always ideal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到为什么多重继承在面向对象编程中是有争议的。拥有多个基类可能会导致形状奇怪的层次结构，比如菱形层次结构；这些类型的层次结构带来潜在的实现问题。我们将看到C++如何整合一种语言特性（虚基类）来解决这些难题，但解决方案并不总是理想的。
- en: Once we understand the complexities caused by multiple inheritance, we will
    use OO design metrics, such as discriminators, to evaluate whether a design using
    MI is the best solution to represent a set of object relationships. We'll look
    at alternative designs, and you will then be better equipped to understand not
    only what multiple inheritance is, but also when it's best utilized. Let us expand
    our understanding of C++ as a "*you can do anything*" OOP language by moving forward
    with MI.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了多重继承带来的复杂性，我们将使用面向对象设计度量标准，如判别器，来评估使用多重继承的设计是否是表示一组对象关系的最佳解决方案。我们将研究替代设计，然后您将更好地理解多重继承不仅是什么，还有何时最好地利用它。让我们通过多重继承继续扩展我们对C++作为“*你可以做任何事情*”面向对象编程语言的理解。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter09` in a file named `Chp9-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与所在章节编号相对应，后跟破折号，再跟着所在章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp9-Ex1.cpp`的文件中的子目录`Chapter09`中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3f4qjDo](https://bit.ly/3f4qjDo).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接观看：[https://bit.ly/3f4qjDo](https://bit.ly/3f4qjDo)。
- en: Understanding multiple inheritance mechanics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多重继承的机制
- en: In C++, a class can have more than one immediate base class. This is known as
    **multiple inheritance**, and is a very controversial topic in both OO designs
    and OOP. Let's begin with the simple mechanics; we will then move forward to the
    design issues and programming logistics surrounding MI during the progression
    of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个类可以有多个直接基类。这被称为**多重继承**，在面向对象设计和面向对象编程中是一个非常有争议的话题。让我们从简单的机制开始；然后我们将在本章的进展过程中讨论多重继承的设计问题和编程逻辑。
- en: With multiple inheritance, the derived class specifies what each of its immediate
    ancestors or base classes are, using the base class list in its class definition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多重继承，派生类在其类定义中使用基类列表指定其每个直接祖先或基类是什么。
- en: 'In a similar fashion to single inheritance, the constructors and destructors
    are invoked all the way up the hierarchy, as objects of the derived class type
    are instantiated and destroyed. Reviewing and expanding for MI the subtleties
    of construction and destruction, we are reminded of the following logistics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与单一继承类似，构造函数和析构函数在整个继承结构中被调用，因为派生类类型的对象被实例化和销毁。回顾并扩展多重继承的构造和析构的微妙之处，我们想起了以下的逻辑：
- en: The calling sequence for a constructor starts with the derived class, but immediately
    passes control to a base constructor, and so on up the hierarchy. Once the calling
    sequence passes control to the top of the hierarchy, the execution sequence begins.
    All the highest-level base class constructors at the same level are first executed,
    and so on down the hierarchy until we arrive at the derived class constructor,
    whose body is executed last in the construction chain.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的调用顺序从派生类开始，但立即将控制权传递给基类构造函数，依此类推，直到达到继承结构的顶部。一旦调用顺序传递控制到继承结构的顶部，执行顺序就开始了。所有最高级别的基类构造函数首先被执行，以此类推，直到我们到达派生类构造函数，在构造链中最后执行。
- en: The derived class destructor is invoked and executed first, followed by all
    the immediate base class destructors, and so on, as we progress up the inheritance
    hierarchy.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类的析构函数首先被调用和执行，然后是所有直接基类的析构函数，依此类推，随着我们向上继承层次结构的进展。
- en: The member initialization list in the derived class constructor may be used
    to specify which constructor for each immediate base class should be invoked.
    In the absence of this specification, the default constructor will be used for
    that base class' constructor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类构造函数中的成员初始化列表可以用来指定应该调用每个直接基类的构造函数。如果没有这个规定，那么将使用该基类的默认构造函数。
- en: 'Let''s take a look at a typical multiple inheritance example to implement a
    quintessential application of MI from an OO design, as well as to understand basic
    MI syntax in C++. This example will be broken into many segments; the full program
    can be found in the following GitHub location:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个典型的多重继承示例，以实现面向对象设计中多重继承的典型应用，并理解C++中基本的多重继承语法。这个例子将被分成许多部分；完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex1.cpp)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code segment, we have an expected class definition for `Person`,
    containing the class elements that we are accustomed to defining.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们有一个`Person`的预期类定义，其中包含我们习惯于定义的类元素。
- en: 'Next, let''s see the accompanying member functions for this class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个类的相关成员函数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous segment of code, the member function definitions for `Person`
    are as expected. Nonetheless, it is useful to see the `Person` class defined,
    as this class will serve as a building block, and portions of it will be directly
    accessed in upcoming code segments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，`Person`的成员函数定义如预期的那样。然而，看到`Person`类的定义是有用的，因为这个类将作为一个构建块，并且它的部分将直接在接下来的代码段中被访问。
- en: 'Now, let''s define a new class, `BillableEntity`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个新的类`BillableEntity`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous `BillableEntity` class, we define a class containing simple
    functionality to encapsulate a billing structure. That is, we have an invoice
    amount and methods such as `Pay()` and `GetBalance()`. Notice that the copy constructor
    is private; this will prohibit copies, which seems appropriate given the nature
    of this class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`BillableEntity`类中，我们定义了一个包含简单功能的类来封装一个计费结构。也就是说，我们有一个发票金额和`Pay()`、`GetBalance()`等方法。请注意，复制构造函数是私有的；这将禁止复制，考虑到这个类的性质，这似乎是合适的。
- en: 'Next, let''s combine the two aforementioned base classes, `Person` and `BillableEntity`,
    to serve as base classes for our `Student` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将前面提到的两个基类`Person`和`BillableEntity`组合起来，作为`Student`类的基类：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding class definition for `Student`, two public base classes, `Person`
    and `BillableEntity`, are specified in the base class list for `Student`. These
    two base classes are merely comma-separated in the `Student` base class list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Student`的前面的类定义中，在`Student`的基类列表中指定了两个公共基类`Person`和`BillableEntity`。这两个基类只是在`Student`的基类列表中用逗号分隔。
- en: 'Let''s further see what accommodations must be made in the remainder of the
    `Student` class by examining its member functions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步看看在`Student`类的其余部分中必须做出哪些调整，通过检查其成员函数：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's consider the previous code segment. In the default constructor for `Student`,
    due to the lack of base class constructor specification in the member initialization
    list, the default constructors will be called for both the `Person` and `BillableEntity`
    base classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑前面的代码段。在`Student`的默认构造函数中，由于在成员初始化列表中缺少基类构造函数的规定，将调用`Person`和`BillableEntity`基类的默认构造函数。
- en: However, notice that in the alternate `Student` constructor, we merely comma
    separate our two base class constructor choices in the member initialization list—that
    is, `Person(const char *, const char *, char, const char *)` and `BillableEntity(float)`—and
    then pass various parameters from the `Student` constructor to the base class
    constructors using this list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，注意在另一个`Student`构造函数中，我们只是在成员初始化列表中用逗号分隔了我们的两个基类构造函数选择，即`Person(const char
    *, const char *, char, const char *)`和`BillableEntity(float)`，然后将各种参数从`Student`构造函数传递给基类构造函数。
- en: 'Finally, let''s take a look at our `main()` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们的`main()`函数：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our `main()` function in the previous code, we instantiate several `Student`
    instances. Notice that `Student` instances can utilize any methods in the public
    interface of `Student`, `Person`, or `BillableEntity`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的代码的 `main()` 函数中，我们实例化了几个 `Student` 实例。请注意，`Student` 实例可以利用 `Student`、`Person`
    或 `BillableEntity` 的公共接口中的任何方法。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看上述程序的输出：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have now seen the language mechanics for MI with a typically implemented
    OO design. Now, let's move forward by looking at the typical reasons for employing
    multiple inheritance in OO designs, some of which are more widely accepted than
    others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了通常实现的面向对象设计中多重继承的语言机制。现在，让我们继续通过查看在面向对象设计中使用多重继承的典型原因，其中一些原因比其他原因更被广泛接受。
- en: Examining reasonable uses for MI
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审视 MI 的合理用法
- en: Multiple inheritance is a controversial concept that arises when creating OO
    designs. Many OO designs avoid MI; other designs embrace it with strict usage.
    Some OOP languages, such as Java, do not explicitly provide direct language support
    of multiple inheritance. Instead, they offer interfaces, such as what we modeled
    in C++ by creating interface classes using abstract classes (restricted to contain
    only pure virtual functions) in [*Chapter 8*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335),
    *Mastering Abstract Classes*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是在创建面向对象设计时出现的一个有争议的概念。许多面向对象设计避免多重继承；其他设计则严格使用它。一些面向对象编程语言，比如 Java，不明确提供直接支持多重继承的语言支持。相反，它们提供接口，就像我们在
    C++ 中通过创建只包含纯虚函数的抽象类（限制为只包含纯虚函数）来建模的那样，在[*第8章*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335)中，*掌握抽象类*。
- en: Of course, in C++, inheriting from two interface classes is still a use of multiple
    inheritance. Though C++ does not include interface classes within the language,
    this concept can be simulated by employing a more restrictive use of MI. For example,
    we can programmatically streamline abstract classes to include only pure virtual
    functions (no data members, and no member functions with definitions) to mimic
    the OO design idea of an interface class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 C++ 中，从两个接口类继承仍然是多重继承的一种用法。虽然 C++ 不在语言中包括接口类，但这个概念可以通过更严格地使用多重继承来模拟。例如，我们可以通过编程方式简化抽象类，只包括纯虚函数（没有数据成员，也没有带有定义的成员函数），以模仿面向对象设计中接口类的概念。
- en: Typical MI conundrums form the basis as to why MI is contentious in OOP. Classic
    MI quandaries will be detailed in this chapter, and can be avoided by restricting
    MI to the usage of interface classes only, or through redesign. This is why some
    OOP languages only support interface classes versus allowing unrestricted MI.
    In C++ you can carefully consider each OO design, and choose when to utilize MI,
    when to utilize a restrictive form of MI (interface classes), or when to employ
    a redesign eliminating MI.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的多重继承困境构成了为什么多重继承在面向对象编程中具有争议的基础。经典的多重继承困境将在本章详细介绍，并可以通过将多重继承限制为仅使用接口类，或通过重新设计来避免。这就是为什么一些面向对象编程语言只支持接口类而不支持无限制的多重继承。在
    C++ 中，你可以仔细考虑每个面向对象设计，并选择何时使用多重继承，何时使用一种受限制的多重继承形式（接口类），或何时使用重新设计来消除多重继承。
- en: C++ is a "*you can do anything*" programming language. As such, C++ allows multiple
    inheritance without restrictions or reservations. As an OO programmer, we will
    look more closely at typical reasons to embrace MI. As we move further into this
    chapter, we will evaluate issues that arise by using MI and how C++ solves these
    issues with additional language features. These MI issues will allow us to then
    apply metrics to understand more reasonably when we should use MI and when a redesign
    may be more appropriate.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是一个“你可以做任何事情”的编程语言。因此，C++ 允许无限制或保留地进行多重继承。作为一个面向对象的程序员，我们将更仔细地看待接受多重继承的典型原因。随着我们在本章的深入，我们将评估使用多重继承时出现的问题，以及
    C++ 如何通过额外的语言特性解决这些问题。这些多重继承的问题将使我们能够应用度量标准，更合理地了解何时应该使用多重继承，何时应该进行重新设计。
- en: Let's begin our pursuit of reasonable uses of MI by considering Is-A and mix-in
    relationships, and then move to examine the controversial use of MI to implement
    Has-A relationships.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始追求合理使用 MI 的过程，首先考虑 Is-A 和混合关系，然后再来审视使用 MI 实现 Has-A 关系的有争议的用法。
- en: Supporting Is-A and mix-in relationships
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持 Is-A 和混合关系
- en: As we have learned with single inheritance, an Is-A relationship is most often
    used to describe the relationship between two inherited classes. For example,
    a `Student` *Is-A* `Person`. The same desired ideal continues with MI; Is-A relationships
    are primary motivations to specify inheritance. In pure OO designs and programming,
    inheritance should be used only to support Is-A relationships.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在单一继承中学到的那样，Is-A 关系最常用于描述两个继承类之间的关系。例如，`Student` *Is-A* `Person`。相同的理想继续在多重继承中，Is-A
    关系是指定继承的主要动机。在纯粹的面向对象设计和编程中，继承应该只用于支持 Is-A 关系。
- en: Nonetheless, as we learned when we looked at interface classes (a concept modeled
    in C++ using abstract classes with the restriction of containing only pure virtual
    functions), mix-in relationships often apply when we inherit from an interface.
    Recall, a mix-in relationship is when we use inheritance to mix in the functionality
    of another class, simply because that functionality is useful or meaningful for
    the derived class to have. The base class need not be an abstract or interface
    class, but employing an ideal OO design, it would be as such.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，正如我们在查看接口类时所学到的（这是在 C++ 中使用抽象类模拟的概念，限制为只包含纯虚函数），混合关系通常适用于当我们从一个接口继承时。请记住，混合关系是当我们使用继承来混合另一个类的功能时，仅仅是因为这个功能对于派生类来说是有用或有意义的。基类不一定是抽象或接口类，但在理想的面向对象设计中，它应该是这样的。
- en: The mix-in base class represents a class in which an Is-A relationship does
    not apply. Mix-ins exist more so with MI, at least as the reason supporting the
    necessity of one of the (many) base classes. Since C++ has direct language support
    for multiple inheritance, MI can be used to support implementing mix-ins (whereas
    languages like Java may only use interface classes). In practice, MI is often
    used to inherit from one class to support an Is-A relationship, and to also inherit
    from another class to support a mix-in relationship. In our last example, we saw
    that a `Student` *Is-A* `Person`, and a `Student` chooses to *mix-in* `BillableEntity`
    capabilities.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 混合基类代表一个不适用Is-A关系的类。混合存在于MI中更多，至少作为支持（许多）基类之一的必要性的原因。由于C++直接支持多重继承，MI可用于支持实现混合（而像Java这样的语言可能只使用接口类）。在实践中，MI经常用于继承自一个类以支持Is-A关系，并且还继承自另一个类以支持混合关系。在我们的最后一个例子中，我们看到`Student`
    *Is-A* `Person`，并且`Student`选择*混合* `BillableEntity`的功能。
- en: Reasonable uses of MI in C++ include supporting both Is-A and mix-in relationships;
    however, our discussion would not be complete without next considering an unusual
    use of MI—implementing Has-A relationships.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中合理使用MI的包括支持Is-A和混合关系；然而，我们的讨论将不完整，如果不考虑下一个不寻常的MI使用——实现Has-A关系。
- en: Supporting Has-A relationships
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持Has-A关系
- en: Less commonly, and much more controversially, MI can be used to implement a
    Has-A relationship. That is, to model containment, or a whole versus part relationship.
    We will see in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*, a more widely accepted
    implementation for Has-A relationships; however, MI provides a very simple implementation.
    Here, the parts serve as the base classes. The whole inherits from the parts,
    automatically including the parts in its memory layout, also automatically inheriting
    the parts' members and functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 较少见，也更有争议的是，MI可以用于实现Has-A关系。也就是说，模拟包含或整体与部分的关系。在[*第10章*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386)中，*实现关联、聚合和组合*，我们将看到Has-A关系的更广泛接受的实现；然而，MI提供了一个非常简单的实现。在这里，部分作为基类。整体继承自部分，自动包含部分在其内存布局中，还自动继承部分的成员和功能。
- en: For example, a `Student` *Is-A* `Person` and a `Student` *Has-A(n)* `Id`; the
    usage of the second base class (`Id`) is for containment. `Id` will serve as a
    base class and `Student` will be derived from `Id` to factor in all that an `Id`
    offers. The `Id` public interface is immediately usable to `Student`. In fact,
    any class that inherits from `Id` will inherit a uniform interface when utilizing
    its `Id` parts. This simplicity is a driving reason why inheritance is sometimes
    used to model containment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Student` *Is-A* `Person`，`Student` *Has-A(n)* `Id`；第二个基类（`Id`）的使用是为了包含。`Id`将作为一个基类，`Student`将从`Id`派生，以考虑`Id`提供的一切。`Id`的公共接口对`Student`是立即可用的。实际上，任何从`Id`继承的类在使用其`Id`部分时都将继承一个统一的接口。这种简单性是继承有时被用来模拟包含的驱动原因。
- en: However, using inheritance to implement Has-A relationships can cause unnecessary
    usage of MI, which can then complicate an inheritance hierarchy. Unnecessary usage
    of MI is the primary reason why using inheritance to model Has-A relationships
    is very controversial and is quite frankly frowned upon in pure OO designs. Nonetheless,
    we mention it because you will see some C++ applications using MI for Has-A implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用继承来实现Has-A关系可能会导致不必要的MI使用，从而使继承层次结构复杂化。不必要使用MI是使用继承来模拟Has-A关系非常有争议的主要原因，而且在纯OO设计中相当受到反对。尽管如此，我们还是提到它，因为你会看到一些C++应用程序使用MI来实现Has-A。
- en: Let's move forward to explore other controversial designs employing MI, namely
    that of a diamond-shaped hierarchy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨其他有争议的MI设计，即菱形层次结构。
- en: Creating a diamond-shaped hierarchy
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菱形层次结构
- en: When using multiple inheritance, sometimes it is tempting to utilize sibling
    (or cousin) classes as base classes for a new derived class. When this happens,
    the hierarchy is no longer a tree in shape, but rather, a graph containing a *diamond*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多重继承时，有时会诱人地利用兄弟（或表亲）类作为新派生类的基类。当这种情况发生时，层次结构不再是树形的，而是一个包含*菱形*的图形。
- en: Whenever an object of the derived class type is instantiated in such a situation,
    two copies of the common base class will be present in the instance of the derived
    class. Duplication of this sort obviously wastes space. Additional time is also
    wasted by calling duplicate constructors and destructors for this repeated sub-object
    and by maintaining two parallel copies of a sub-object (most likely unnecessarily).
    Ambiguities also result when trying to access members from this common base class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在这种情况下实例化派生类类型的对象时，派生类的实例中将存在两个公共基类的副本。这种重复显然浪费空间。还会通过调用重复的构造函数和析构函数以及维护两个平行的子对象的副本（很可能是不必要的）来浪费额外的时间。当尝试访问来自这个公共基类的成员时，也会产生歧义。
- en: 'Let''s see an example detailing this issue, starting with abbreviated class
    definitions of `LifeForm`, `Horse`, and `Person`. Though only portions of the
    full program example are shown, the program in its entirety can be found in our
    GitHub as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个详细说明这个问题的例子，从`LifeForm`、`Horse`和`Person`的缩写类定义开始。虽然只显示了完整程序示例的部分，但整个程序可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex2.cpp)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex2.cpp)'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous fragment of code shows skeleton class definitions for `LifeForm`,
    `Person`, and `Horse`. Each class shows a default constructor, which merely serves
    as an example to show how `lifeExpectancy` is set for each class. In the default
    constructors for `Person` and `Horse`, the member initialization list is used
    to pass a value of `35` or `80` to the `LifeForm` constructor to set this value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段显示了`LifeForm`，`Person`和`Horse`的骨架类定义。每个类都显示了一个默认构造函数，仅仅是为了演示如何为每个类设置`lifeExpectancy`。在`Person`和`Horse`的默认构造函数中，成员初始化列表用于将值`35`或`80`传递给`LifeForm`构造函数以设置这个值。
- en: Though the previous class definitions are abbreviated (that is, purposely incomplete)
    to save space, let's assume that each class has appropriate additional constructors
    defined, an appropriate destructor, and other necessary member functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的类定义是缩写的（即故意不完整）以节省空间，让我们假设每个类都有适当的额外构造函数定义，适当的析构函数和其他必要的成员函数。
- en: We notice that `LifeForm` is an abstract class, in that it offers pure virtual
    functions `Print()`, `IsA()`, and `Speak()`. Both `Horse` and `Person` are concrete
    classes and will be instantiable because they override these pure virtual functions
    with virtual functions. These virtual functions are shown inline, only to make
    the code compact for viewing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`LifeForm`是一个抽象类，因为它提供了纯虚函数`Print()`，`IsA()`和`Speak()`。`Horse`和`Person`都是具体类，并且可以实例化，因为它们用虚函数重写了这些纯虚函数。这些虚函数是内联显示的，只是为了使代码紧凑以便查看。
- en: 'Next, let''s look at a new derived class that will introduce the graph, or
    diamond shape, in our hierarchy:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个新的派生类，它将在我们的层次结构中引入图形或菱形：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous fragment, we define a new class, `Centaur`, using multiple inheritance.
    At a first glance, we truly do mean to assert the Is-A relationship between `Centaur`
    and `Person`, and also between `Centaur` and `Horse`. However, we'll soon challenge
    our assertion to test if it is more of a combination than a true Is-A relationship.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们使用多重继承定义了一个新的类`Centaur`。乍一看，我们确实是要断言`Centaur`与`Person`之间的Is-A关系，以及`Centaur`与`Horse`之间的Is-A关系。然而，我们很快会挑战我们的断言，以测试它是否更像是一种组合而不是真正的Is-A关系。
- en: We will assume that all of the necessary constructors, the destructor, and member
    functions exist to make `Centaur` a well-defined class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设所有必要的构造函数、析构函数和成员函数都存在，使`Centaur`成为一个定义良好的类。
- en: 'Now, let''s move forward to look at a potential `main()` function we may utilize:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看一下我们可能会利用的潜在`main()`函数：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, in `main()`, we instantiate a `Centaur`; we name the instance `beast`.
    We easily call two polymorphic operations on `beast`, namely `Speak()` and `IsA()`.
    Then we try to call the public, inherited `GetLifeExpectancy()`, which is defined
    in `LifeForm`. Its implementation is included in `Lifeform` so that `Person`,
    `Horse`, and `Centaur` do not need to provide a definition (nor should they—it's
    not a virtual function meant to be redefined).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们实例化了一个`Centaur`；我们将实例命名为`beast`。我们轻松地在`beast`上调用了两个多态操作，即`Speak()`和`IsA()`。然后我们尝试调用公共的继承`GetLifeExpectancy()`，它在`LifeForm`中定义。它的实现包含在`Lifeform`中，因此`Person`，`Horse`和`Centaur`不需要提供定义（也不应该这样做——它不是一个虚函数，意味着要重新定义）。
- en: Unfortunately, calls to `GetLifeExpectancy()` via `Centaur` instances are ambiguous.
    This is because there are two `LifeForm` sub-objects in the `beast` instance.
    Remember, a `Centaur` is derived from `Horse`, which is derived from `LifeForm`,
    providing the memory layout for all the aforementioned base class data members
    (`Horse` and `LifeForm`). And a `Centaur` is derived also from `Person`, which
    is derived from `LifeForm`, which contributes the memory layout for `Person` and
    `LifeForm` to `Centaur` as well. The `LifeForm` piece is duplicated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，通过`Centaur`实例调用`GetLifeExpectancy()`是模棱两可的。这是因为`beast`实例中有两个`LifeForm`子对象。记住，`Centaur`是从`Horse`派生的，`Horse`是从`LifeForm`派生的，为所有前述的基类数据成员（`Horse`和`LifeForm`）提供了内存布局。`Centaur`也是从`Person`派生的，`Person`是从`LifeForm`派生的，它也为`Centaur`提供了`Person`和`LifeForm`的内存布局。`LifeForm`部分是重复的。
- en: There are two copies of the inherited data member `lifeExpectancy`. There are
    two sub-objects of `LifeForm` within the `Centaur` instance. Therefore, when we
    try to call `GetLifeExpectancy()` through the `Centaur` instance, the method call
    is ambiguous. Which `lifeExpectancy` are we trying to initialize? Which `LifeForm`
    sub-object will serve as the `this` pointer when `GetLifeExpectancy()` is called?
    It is simply not clear, so the compiler will not choose for us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的数据成员`lifeExpectancy`有两个副本。在`Centaur`实例中有两个`LifeForm`的子对象。因此，当我们尝试通过`Centaur`实例调用`GetLifeExpectancy()`时，方法调用是模棱两可的。我们试图初始化哪个`lifeExpectancy`？在调用`GetLifeExpectancy()`时，哪个`LifeForm`子对象将作为`this`指针？这是不清楚的，所以编译器不会为我们选择。
- en: To disambiguate the `GetLifeExpectancy()` function call, we must use the scope
    resolution operator. We precede the `::` operator with the intermediate base class
    from which we desire the `LifeForm` sub-object. Notice that we call, for example,
    `beast.Horse::GetLifeExpectancy()` to choose the `lifeExpectancy` from the `Horse`
    sub-object's path which will include `LifeForm`. This is awkward, as neither `Horse`
    nor `Person` includes the ambiguous member; `lifeExpectancy` is found in `LifeForm`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除对`GetLifeExpectancy()`函数调用的歧义，我们必须使用作用域解析运算符。我们在`::`运算符之前加上我们希望从中获取`LifeForm`子对象的中间基类。请注意，我们调用，例如`beast.Horse::GetLifeExpectancy()`来选择`lifeExpectancy`，从`Horse`子对象的路径中包括`LifeForm`。这很尴尬，因为`Horse`和`Person`都不包括这个模棱两可的成员；`lifeExpectancy`是在`LifeForm`中找到的。
- en: 'Let''s consider the output for the aforementioned program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上述程序的输出：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that designing a hierarchy that includes a diamond shape has drawbacks.
    These conundrums include programming ambiguities that need to be resolved in an
    awkward fashion, duplication in memory of repeated sub-objects, plus time to construct
    and destruct these duplicate sub-objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，设计一个包含菱形形状的层次结构有缺点。这些难题包括需要以尴尬的方式解决的编程歧义，重复子对象的内存重复，以及构造和销毁这些重复子对象所需的时间。
- en: Luckily, C++ has a language feature to alleviate these hardships with diamond-shaped
    hierarchies. After all, C++ is a language that will allow us to do anything. Knowing
    when and whether we should utilize these features is another concern. Let's first
    take a look at the C++ language solution to deal with diamond-shaped hierarchies
    and their inherent problems, by looking at virtual base classes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++有一种语言特性来减轻这些菱形层次结构的困难。毕竟，C++是一种允许我们做任何事情的语言。知道何时以及是否应该利用这些特性是另一个问题。让我们首先看一下C++语言解决菱形层次结构及其固有问题的解决方案，通过查看虚基类。
- en: Utilizing virtual base classes to eliminate duplication
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用虚基类来消除重复
- en: We have just seen the MI implementation issues that quickly arise when a diamond
    shape is included in an OO design—duplication in memory for a repeated sub-object,
    ambiguity accessing that sub-object (even through inherited member functions),
    and the duplication of construction and destruction. For these reasons, pure OO
    designs will not include graphs in a hierarchy (that is, no diamond shapes). Yet,
    we know C++ is a powerhouse of a language and anything is possible. As such, C++
    will provide us with a solution to these issues.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了MI实现中出现的问题，当一个菱形形状包含在OO设计中时会迅速出现内存重复的子对象，访问该子对象的歧义（即使通过继承的成员函数），以及构造和销毁的重复。因此，纯OO设计不会在层次结构中包括图形（即没有菱形形状）。然而，我们知道C++是一种强大的语言，一切皆有可能。因此，C++将为我们提供解决这些问题的方法。
- en: '`virtual` is placed in the base class list between the access label and the
    base class name of the sibling or cousin class, which may *later* be used as a
    base class for the same derived class. Note that knowing two sibling classes may
    later be combined as common base classes for a new derived class can be difficult.
    It is important to note that sibling classes that do not specify a virtual base
    class will demand their own copy of the (otherwise) shared base class.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`被放置在访问标签和兄弟或堂兄类的基类名称之间，这些类可能*稍后*被用作同一个派生类的基类。需要注意的是，知道两个兄弟类可能稍后被合并为新派生类的共同基类可能是困难的。重要的是要注意，没有指定虚基类的兄弟类将要求它们自己的副本（否则共享的）基类。'
- en: 'Virtual base classes should be used sparingly in implementation because they
    place restrictions and overhead on instances that have such a class as an ancestor
    class. Restrictions to be aware of include:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中应该谨慎使用虚基类，因为这会对具有这样一个祖先类的实例施加限制和开销。需要注意的限制包括：
- en: An instance having a virtual base class can use more memory than its non-virtual
    counterpart.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有虚基类的实例可能会使用比其非虚拟对应物更多的内存。
- en: Casting from an object of a base class type to a derived class type is prohibited
    when a virtual base class is in the ancestor hierarchy.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当虚基类在祖先层次结构中时，禁止从基类类型的对象向派生类类型进行转换。
- en: The member initialization list of the most derived class must be used to specify
    which constructor of the shared object type should be used for initialization.
    If this specification is ignored, the default constructor will be used to initialize
    this sub-object.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最派生类的成员初始化列表必须用于指定应该用于初始化的共享对象类型的构造函数。如果忽略了这个规定，将使用默认构造函数来初始化这个子对象。
- en: 'Let us now look at a full program example that employs virtual base classes.
    As usual, the full program can be found in our GitHub as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个使用虚基类的完整程序示例。通常情况下，完整程序可以在我们的GitHub上找到，链接如下：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex3.cpp)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex3.cpp)'
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous segment of code, we see the full class definition of `LifeForm`.
    Notice that the member functions with bodies are inlined in the class definition.
    Of course, the compiler will not actually make inline substitutions for constructors
    or the destructor; knowing this, it is convenient to write the methods as inline
    to make the class compact for reviewing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们看到了`LifeForm`的完整类定义。请注意，具有函数体的成员函数在类定义中被内联。当然，编译器实际上不会为构造函数或析构函数进行内联替换；知道这一点，将方法写成内联以使类紧凑以便审查是方便的。
- en: 'Next, let''s see the class definition for `Horse`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`Horse`的类定义：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous segment of code, we have the full class definition for `Horse`.
    Keep in mind that though certain methods are written as inline for compactness,
    the compiler will never actually inline a constructor or destructor. Nor can a
    virtual function be inlined, as its whole point is to have the appropriate method
    determined at runtime.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们有`Horse`的完整类定义。请记住，尽管某些方法被写成内联以节省空间，但编译器实际上永远不会内联构造函数或析构函数。虚函数也不能被内联，因为它的整个目的是在运行时确定适当的方法。
- en: Here, `LifeForm` is a virtual base class of `Horse`. This means that if `Horse`
    ever has a sibling (or cousin) that also inherits from `LifeForm` using a virtual
    base class, and those siblings serve as base classes for a derived class, then
    those siblings will *share* their copy of `LifeForm`. The virtual base class will
    reduce storage and extra constructor and destructor calls, and eliminate ambiguity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LifeForm`是`Horse`的虚基类。这意味着如果`Horse`有一个同级（或堂兄）也使用虚基类从`LifeForm`继承的兄弟，那些兄弟将*共享*它们的`LifeForm`副本。虚基类将减少存储和额外的构造函数和析构函数调用，并消除歧义。
- en: Notice the `Horse` constructors, which specify a constructor specification of
    `LifeForm(35)` in their member initialization lists. This base class initialization
    will be ignored if `LifeForm` actually is a shared virtual base class, though
    these constructor specifications are certainly valid for instances of `Horse`
    or for instances of descendants of `Horse` in which the diamond-shaped hierarchy
    does not apply. In hierarchies where `Horse` is combined with a sibling class
    to truly serve as a virtual base class, the `LifeForm(35)` specification will
    be ignored and instead either the default `LifeForm` constructor will be called
    or another will be selected at a lower (and unusual) level in the hierarchy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`Horse`构造函数，在其成员初始化列表中指定了`LifeForm(35)`的构造函数规范。如果`LifeForm`实际上是一个共享的虚基类，那么这个基类初始化将被忽略，尽管这些构造函数规范对于`Horse`的实例或者`Horse`的后代的实例是有效的，其中菱形层次结构不适用。在`Horse`与一个兄弟类真正作为虚基类组合的层次结构中，`LifeForm(35)`规范将被忽略，而是将调用默认的`LifeForm`构造函数或者在层次结构中的较低（不寻常的）级别选择另一个构造函数。
- en: 'Next, let''s see more of this program by looking at additional class definitions,
    beginning with `Person`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过查看其他类定义来看更多关于这个程序的内容，从`Person`开始：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the prior segment of code, we see that `Person` has a public virtual base
    class of `LifeForm`. Should `Person` and a sibling of `Person` ever be combined
    using multiple inheritance to be base classes for a new derived class, those siblings
    who have indicated a virtual base class of `LifeForm` will agree to share a single
    sub-object of `LifeForm`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们看到`Person`有一个公共虚基类`LifeForm`。如果`Person`和`Person`的兄弟类通过多重继承组合成一个新的派生类，那些指定`LifeForm`为虚基类的兄弟类将同意共享一个`LifeForm`的子对象。
- en: 'Moving onward, let''s review the member functions of `Person`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，让我们回顾一下`Person`的成员函数：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the above-mentioned methods of `Person`, we see few details that surprise
    us; the methods are largely as expected. However, as a reminder, note that the
    `LifeForm(80)` specifications in the member initialization lists of the `Person`
    constructor will be ignored if `Person` is combined in a diamond-shaped hierarchy
    where the `LifeForm` sub-object becomes shared, rather than duplicated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Person`的方法中，我们看到一些让我们惊讶的细节；这些方法大部分都是预期的。然而，请注意，如果`Person`在一个菱形层次结构中与`LifeForm`子对象变为共享而不是重复，那么`Person`构造函数中成员初始化列表中的`LifeForm(80)`规范将被忽略。
- en: 'Next, let''s take a look at where MI comes into play, with the definition of
    the `Centaur` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看多重继承是如何发挥作用的，以`Centaur`类的定义为例：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the aforementioned `Centaur` class definition, we can see that `Centaur`
    has public base classes of `Horse` and `Person`. We are implying that `Centaur`
    *Is-A* `Horse` and `Centaur` *Is-A* `Person`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`Centaur`类定义中，我们可以看到`Centaur`有`Horse`和`Person`的公共基类。我们暗示`Centaur` *是一个*
    `Horse`和`Centaur` *是一个* `Person`。
- en: Notice, however, the keyword `virtual` is not used in the base class list with
    the `Centaur` class definition. Yet, `Centaur` is the level in the hierarchy where
    the diamond shape is introduced. This means that we had to plan ahead, in our
    design stage, to know to utilize the `virtual` keyword in the base class list
    for our `Horse` and `Person` class definitions. This is an example of why a proper
    design session is critical, versus just jumping into implementation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在`Centaur`类定义的基类列表中没有使用关键字`virtual`。然而，`Centaur`是引入菱形形状的层次结构的级别。这意味着我们在设计阶段必须提前计划，知道在`Horse`和`Person`类定义的基类列表中利用`virtual`关键字。这是一个合适的设计会议至关重要的例子，而不是仅仅跳入实现。
- en: Also, quite unusually, notice the base class list of `Person(fn, ln, mi, title),
    Horse(fn), LifeForm(1000)` in the `Centaur` alternate constructor. Here, we not
    only specify the preferred constructor of our immediate base classes of `Person`
    and `Horse`, but also the preferred constructor for *their* common base class
    of `LifeForm`. This is highly unusual. Without `LifeForm` as a virtual base class
    for `Horse` and `Person`, `Centaur` would not be able to specify how to construct
    the shared `LifeForm` piece (that is, by choosing a constructor for anything other
    than its immediate base classes). The virtual base class usage makes the `Person`
    and `Horse` classes less reusable for other applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样非常不寻常的是，注意`Centaur`的替代构造函数中的`Person(fn, ln, mi, title), Horse(fn), LifeForm(1000)`的基类列表。在这里，我们不仅指定了我们的直接基类`Person`和`Horse`的首选构造函数，还指定了*它们*的共同基类`LifeForm`的首选构造函数。这是非常不寻常的。如果`LifeForm`不是`Horse`和`Person`的虚基类，`Centaur`将无法指定如何构造共享的`LifeForm`片段（即选择除了其直接基类之外的构造函数）。虚基类的使用使得`Person`和`Horse`类对于其他应用的可重用性降低。
- en: 'Let''s take a look at what our `main()` function entails:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的`main()`函数包含什么：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similar to our `main()` function in our non-virtual base class example, we can
    see that `Centaur` is likewise instantiated and that virtual functions such as
    `Speak()`, `IsA()`, and `Print()` are easily called. Now, however, when we call
    `GetLifeExpectancy()` through our `beast` instance, the call is no longer ambiguous.
    There is only one sub-object of `LifeForm`, whose `LifeExpectancy` has been initialized
    to `1000`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们非虚基类示例中的`main()`函数类似，我们可以看到`Centaur`同样被实例化，并且可以轻松调用`Speak()`、`IsA()`和`Print()`等虚函数。然而，当我们通过`beast`实例调用`GetLifeExpectancy()`时，调用不再是模棱两可的。只有一个`LifeForm`的子对象，其`LifeExpectancy`已经初始化为`1000`。
- en: 'Here is the output for the full program example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整程序示例的输出：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Virtual base classes have solved a difficult MI conundrum. But we have also
    seen that the code required to do so is less flexible for future expansion and
    reuse. As such, virtual base classes should be carefully and sparingly used, only
    when the design truly supports a diamond-shaped hierarchy. With that in mind,
    let's consider the OO concept of a discriminator, and consider when alternate
    designs may be more appropriate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虚基类解决了一个困难的MI难题。但我们也看到，为此所需的代码对于未来的扩展和重用来说不够灵活。因此，虚基类应该谨慎和节制地使用，只有当设计真正支持菱形层次结构时才使用。考虑到这一点，让我们考虑鉴别器的面向对象概念，并考虑何时备用设计可能更合适。
- en: Considering discriminators and alternate designs
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑鉴别器和备用设计
- en: A **discriminator** is an object-oriented concept that helps outline the reasons
    why a given class is derived from its base class. **Discriminators** tend to characterize
    the types of groupings of specializations that exist for a given base class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**鉴别器**是一个面向对象的概念，它有助于概述为什么给定类是从其基类派生的原因。**鉴别器**倾向于表征为给定基类存在的专门化类型的分组。'
- en: 'For example, in the aforementioned program examples with diamond-shaped hierarchies,
    we have the following discriminators (shown in parentheses), outlining our purpose
    for specializing a new class from a given base class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面提到的具有菱形层次结构的程序示例中，我们有以下鉴别器（用括号表示），概述了我们从给定基类专门化新类的目的：
- en: '![Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators](img/Figure_9.1_B15702.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1-显示带有鉴别器的多重继承菱形设计](img/Figure_9.1_B15702.jpg)'
- en: Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1-显示带有鉴别器的多重继承菱形设计
- en: 'Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining
    the discriminators can help us decide whether the design is reasonable, or if
    perhaps an alternate design would prove better. Here are some good design metrics
    to consider:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每当诱惑导致创建菱形层次结构时，检查鉴别器可以帮助我们决定设计是否合理，或者也许备用设计会更好。以下是一些要考虑的良好设计指标：
- en: If the discriminators for the sibling classes that are being brought back together
    are the same, then the diamond-shaped hierarchy is better off redesigned.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在重新组合的兄弟类的鉴别器相同，则最好重新设计菱形层次结构。
- en: When the sibling classes do not have unique discriminators, the attributes and
    behaviors they will introduce will consist of duplications stemming from having
    a like discriminator. Consider making the discriminator a class to house those
    commonalities.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当兄弟类没有唯一的鉴别器时，它们引入的属性和行为将由于具有相似的鉴别器而产生重复。考虑将鉴别器作为一个类来容纳这些共同点。
- en: If the discriminators for the sibling classes are unique, then the diamond-shaped
    hierarchy may be warranted. In this case, virtual base classes will prove helpful
    and should be added in the appropriate locations in the hierarchy.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果兄弟类的鉴别器是唯一的，那么菱形层次结构可能是合理的。在这种情况下，虚基类将会很有帮助，并且应该在层次结构的适当位置添加。
- en: In the previous example, the discriminator detailing why `Horse` specializes
    `LifeForm` is `Equine`. That is, we are specializing `LifeForm` with equine characteristics
    and behaviors (hooves, galloping, neighing, etcetera). Had we derived classes
    such as `Donkey` or `Zebra` from `LifeForm`, the discriminator for these classes
    would also be `Equine`. Considering the same aforementioned example, the `Person`
    class would have a `Humanoid` discriminator when specializing `LifeForm`. Had
    we derived classes such as `Martian` or `Romulan` from `LifeForm`, these classes
    would also have `Humanoid` as a discriminator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，详细说明`Horse`为什么专门化`LifeForm`的鉴别器是`Equine`。也就是说，我们正在用马的特征和行为（蹄，奔跑，嘶鸣等）专门化`LifeForm`。如果我们从`LifeForm`派生类，如`Donkey`或`Zebra`，这些类的鉴别器也将是`Equine`。考虑到前面提到的例子，当专门化`LifeForm`时，`Person`类将具有`Humanoid`鉴别器。如果我们从`LifeForm`派生类，如`Martian`或`Romulan`，这些类也将具有`Humanoid`作为鉴别器。
- en: Bringing `Horse` and `Person` together as base classes for `Centaur` is combining
    two base classes with different discriminators, `Equine` and `Humanoid`. As such,
    wholly different types of characteristics and behaviors are factored in by each
    base class. Though an alternate design may be possible, this design is acceptable
    (except to OO design purists), and virtual base classes may be used in C++ to
    eliminate duplication of the otherwise-replicated `LifeForm` piece. Bringing two
    classes together that share a common base class and specialize the base class
    using distinct discriminators is an example of where MI and virtual base classes
    are reasonable in C++.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Horse`和`Person`作为`Centaur`的基类组合在一起，将两个具有不同鉴别器的基类`Equine`和`Humanoid`组合在一起。因此，每个基类都考虑了完全不同类型的特征和行为。虽然备用设计可能是可能的，但这种设计是可以接受的（除了面向对象设计纯粹主义者），并且可以在C++中使用虚基类来消除否则会复制的`LifeForm`部分。将两个共享共同基类并使用不同鉴别器专门化基类的类组合在一起是C++中MI和虚基类是合理的一个例子。
- en: 'However, bringing two classes, such as `Horse` and `Donkey` (both derived from
    `LifeForm`), together in a derived class, such as `Mule`, also creates a diamond-shaped
    hierarchy. Examining the discriminators for `Horse` and `Donkey` reveals that
    both have a discriminator of `Equine`. In this case, bringing together these two
    classes using a diamond-shaped design is not the optimal design choice. Another
    design choice is possible and preferred. In this case, a preferred solution would
    be to make the discriminator, `Equine`, its own class, and then derive `Horse`,
    `Donkey`, and `Mule` from `Equine`. This would avoid MI and a diamond-shaped hierarchy.
    Let''s take a look at the two design options:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将两个类，比如`Horse`和`Donkey`（都是从`LifeForm`派生的），放在一个派生类，比如`Mule`中，也会创建一个菱形层次结构。检查`Horse`和`Donkey`的鉴别器会发现它们都有一个`Equine`的鉴别器。在这种情况下，使用菱形设计将这两个类放在一起并不是最佳的设计选择。还有其他的设计选择是可能的，也更可取。在这种情况下，一个更可取的解决方案是将鉴别器`Equine`作为自己的类，然后从`Equine`派生`Horse`，`Donkey`和`Mule`。这将避免多重继承和菱形层次结构。让我们来看看这两种设计选项：
- en: '![ Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI](img/Figure_9.2_B15702.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 - 重新设计的菱形多重继承，没有多重继承](img/Figure_9.2_B15702.jpg)'
- en: Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - 重新设计的菱形多重继承，没有多重继承
- en: Reminder
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: In a diamond-shaped hierarchy, if the discriminators for the *combined* classes
    are the same, a better design is possible (by making the discriminator its own
    class). However, if the discriminators are different, consider keeping the diamond-shaped
    MI hierarchy, and use virtual base classes to avoid duplication of the common
    base class sub-object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在菱形层次结构中，如果*组合*类的鉴别器相同，可以有更好的设计（通过使鉴别器成为自己的类）。然而，如果鉴别器不同，考虑保持菱形多重继承层次结构，并使用虚基类来避免共同基类子对象的重复。
- en: We have now thoroughly examined the OO concept of a discriminator and have seen
    how discriminators can be used to help evaluate the reasonableness of a design.
    In many cases, designs using diamond-shaped hierarchies can be re-designed to
    not only eliminate the diamond shape, but to also eliminate multiple inheritance
    altogether. Let's briefly recap the MI issues and OO concepts we've covered in
    this chapter before moving onward to our next chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经彻底研究了鉴别器的面向对象概念，并看到了鉴别器如何帮助评估设计的合理性。在许多情况下，使用菱形层次结构的设计可以重新设计，不仅消除菱形形状，还可以完全消除多重继承。在继续前进到下一章之前，让我们简要回顾一下本章涵盖的多重继承问题和面向对象概念。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have marched onward with our quest for understanding object-oriented
    programming by exploring a controversial OOP topic, that of multiple inheritance.
    First, in this chapter, we have understood the simple mechanics of multiple inheritance.
    Equally important, we have reviewed reasons for building inheritance hierarchies
    and possible reasons for using MI (that is, specifying Is-A, mix-in, and Has-A
    relationships). We have been reminded that using inheritance to specify Is-A relationships
    supports pure OO designs. We have also seen using MI to implement mix-in relationships.
    We have also taken a look at the controversial use of MI to quickly implement
    a Has-A relationship; we'll see in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*, a preferred implementation
    for Has-A.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探索了一个有争议的面向对象编程主题，即多重继承，以加深对面向对象编程的理解。首先，在本章中，我们了解了多重继承的简单机制。同样重要的是，我们回顾了构建继承层次结构的原因以及使用多重继承的可能原因（即指定Is-A、mix-in和Has-A关系）。我们被提醒使用继承来指定Is-A关系支持纯粹的面向对象设计。我们还看到使用多重继承来实现mix-in关系。我们还看了有争议的使用多重继承来快速实现Has-A关系；我们将在[*第10章*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386)，*实现关联、聚合和组合*中看到Has-A的首选实现。
- en: We have seen how having multiple inheritance in our OO design toolkit can lead
    to diamond-shaped hierarchies. We have seen the inevitable issues arising from
    diamond-shaped hierarchies, such as duplication in memory, duplication in construction/destruction,
    and ambiguity when accessing a replicated sub-object. We have also seen that C++
    provides a language-supported mechanism to correct these issues, using virtual
    base classes. We know that virtual base classes solve a tedious problem, yet they
    themselves are not perfect solutions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在我们的面向对象设计工具包中具有多重继承可能会导致菱形层次结构。我们已经看到了菱形层次结构引起的不可避免的问题，比如内存中的重复，构造/析构中的重复，以及访问复制的子对象时的歧义。我们也知道C++提供了一种语言支持的机制来解决这些问题，使用虚基类。我们知道虚基类解决了一个繁琐的问题，但它们本身并不是完美的解决方案。
- en: In an effort to critique diamond-shaped hierarchies, we have looked at the OO
    concept of a discriminator to help us weigh the validity of an OO design using
    MI in a diamond shape. This has also led us to understand that alternate designs
    can apply to a set of objects; sometimes a redesign is a more elegant approach
    in which the solution will yield easier, long-term use.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了批评菱形层次结构，我们已经研究了鉴别器的面向对象概念，以帮助我们权衡使用菱形多重继承的面向对象设计的合理性。这也使我们了解到备选设计可以应用于一组对象；有时重新设计是一种更优雅的方法，解决方案将更容易、更长期地使用。
- en: C++ is a "*you can do anything*" OOP language, and multiple inheritance is a
    controversial OO concept. Knowing when certain MI designs may be warranted and
    understanding language features to help with those MI issues will make you a better
    programmer. Knowing when a redesign is in order is also critical.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种“你可以做任何事情”的面向对象编程语言，多重继承是一个有争议的面向对象概念。了解何时可能需要某些多重继承设计，并理解语言特性来帮助解决这些多重继承问题将使您成为一个更好的程序员。知道何时需要重新设计也是至关重要的。
- en: We are now ready to continue to [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*, to further enhance our
    OOP skills by next learning how to represent association, aggregation, and composition
    with programming techniques. These upcoming concepts will *not* have direct language
    support, but the concepts are instrumental in our OO arsenal of skills. Let's
    move onward!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续[*第10章*]（B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386），*实现关联、聚合和组合*，通过学习如何用编程技术表示关联、聚合和组合，进一步提高我们的面向对象编程技能。这些即将出现的概念将*不*直接得到语言支持，但这些概念对我们的面向对象编程技能至关重要。让我们继续前进！
- en: Questions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Type in (or use the online code for) the diamond-shaped hierarchy example in
    this chapter that uses virtual base classes. Run it as is.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中使用虚基类的菱形继承示例中输入（或使用在线代码）。按原样运行它。
- en: a. How many `LifeForm` sub-objects exist for the instance of `Centaur`?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: a. 对于`Centaur`的实例，有多少个`LifeForm`子对象存在？
- en: 'b. How many times is the `LifeForm` constructor (and destructor) invoked? Hint:
    you may want to place trace statements using `cout` in each of your constructors
    and destructor.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: b. `LifeForm`构造函数（和析构函数）被调用了多少次？提示：你可能想在每个构造函数和析构函数中使用`cout`放置跟踪语句。
- en: c. Which `LifeForm` constructor would be invoked if the constructor selections
    for `LifeForm` in the member initialization list of the `Centaur` constructors
    were omitted?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果在`Centaur`构造函数的成员初始化列表中省略了`LifeForm`的构造函数选择，哪个`LifeForm`构造函数会被调用？
- en: Now, remove the keyword `virtual` from the base class list of `Person` and `Horse`
    (that is, `LifeForm` will no longer be a virtual base class of `Person` and `Horse`.
    `LifeForm` will just be a typical base class of `Person` and `Horse`). Also remove
    the `LifeForm` constructor selection from the member initialization list of the
    `Centaur` constructors. Now, instantiate `Centaur`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`Person`和`Horse`的基类列表中删除关键字`virtual`（也就是说，`LifeForm`将不再是`Person`和`Horse`的虚基类。`LifeForm`将只是`Person`和`Horse`的典型基类）。同时，从`Centaur`构造函数的成员初始化列表中删除`LifeForm`构造函数的选择。现在，实例化`Centaur`。
- en: a. How many `LifeForm` sub-objects exist for the instance of `Centaur`?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: a. 对于`Centaur`的实例，有多少个`LifeForm`子对象存在？
- en: b. Now, how many times is the `LifeForm` constructor (and destructor) invoked?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: b. 现在，`LifeForm`构造函数（和析构函数）被调用了多少次？
