- en: Building a Simple Web Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建简单的Web客户端
- en: '**Hypertext Transfer Protocol** (**HTTP**) is the application protocol that
    powers the World Wide Web (WWW). Whenever you fire up your web browser to do an
    internet search, browse Wikipedia, or make a post on social media, you are using
    HTTP. Many mobile apps also use HTTP behind the scenes. It''s safe to say that
    HTTP is one of the most widely used protocols on the internet.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是推动万维网（WWW）的应用协议。每次您打开网络浏览器进行互联网搜索、浏览维基百科或在社会媒体上发帖时，您都在使用HTTP。许多移动应用程序也暗中使用了HTTP。可以说，HTTP是互联网上使用最广泛的协议之一。'
- en: In this chapter, we will look at the HTTP message format. We will then implement
    a C program, which can request and receive web pages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看HTTP消息格式。然后我们将实现一个C程序，该程序可以请求和接收网页。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The HTTP message format
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP消息格式
- en: HTTP request types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求类型
- en: Common HTTP headers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见HTTP头
- en: HTTP response code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP响应代码
- en: HTTP message parsing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP消息解析
- en: Implementing an HTTP client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现HTTP客户端
- en: Encoding form data (`POST`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码表单数据（`POST`）
- en: HTTP file uploads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP文件上传
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs from this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS. See appendices B, C,
    and D for compiler setup.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以用任何现代C编译器编译。我们推荐在Windows上使用MinGW，在Linux和macOS上使用GCC。有关编译器设置的更多信息，请参阅附录B、C和D。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)找到。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，您可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. When
    compiling on Windows, each example program requires linking with the Winsock library.
    This is accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要与Winsock库链接。这是通过将`-lws2_32`选项传递给`gcc`来实现的。
- en: We provide the exact commands needed to compile each example as they are introduced.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供编译每个示例所需的精确命令，正如它们被介绍时那样。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap06.h`, which we can include in each program. For an
    explanation of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例程序都需要我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*中开发的相同头文件和C宏。为了简洁起见，我们将这些语句放在一个单独的头文件`chap06.h`中，我们可以在每个程序中包含它。有关这些语句的解释，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*。
- en: 'The content of `chap06.h` is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap06.h`的内容如下：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The HTTP protocol
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP协议
- en: HTTP is a text-based client-server protocol that runs over TCP. Plain HTTP runs
    over TCP port `80`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种基于文本的客户端-服务器协议，它运行在TCP之上。纯HTTP运行在TCP端口`80`。
- en: It should be noted that plain HTTP is mostly deprecated for security reasons.
    Today, sites should use HTTPS, the secure version of HTTP. HTTPS secures HTTP
    by merely running the HTTP protocol through a **Transport Layer Security** (**TLS**)
    layer. Therefore, everything we cover in this chapter regarding HTTP also applies
    to HTTPS. See [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading
    Secure Web Pages with HTTPS and OpenSSL*, for more information about HTTPS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，出于安全原因，纯HTTP已被大多数情况下弃用。今天，网站应使用HTTPS，这是HTTP的安全版本。HTTPS通过仅将HTTP协议通过**传输层安全性**（**TLS**）层运行来保护HTTP。因此，本章中关于HTTP的所有内容也适用于HTTPS。有关HTTPS的更多信息，请参阅[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用HTTPS和OpenSSL加载安全网页*。
- en: HTTP works by first having the web client send an HTTP request to the web server.
    Then, the web server responds with an HTTP response. Generally, the HTTP request
    indicates which resource the client is interested in, and the HTTP response delivers
    the requested resource.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP通过首先让网络客户端向网络服务器发送HTTP请求来工作。然后，网络服务器以HTTP响应的形式进行响应。通常，HTTP请求指示客户端感兴趣的资源，而HTTP响应则提供所请求的资源。
- en: 'Visually, the transaction is illustrated in the following graphic:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，交易在以下图形中得到了说明：
- en: '![](img/25330adb-dd3b-4d9e-8cc8-f3c2f5320216.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25330adb-dd3b-4d9e-8cc8-f3c2f5320216.png)'
- en: The preceding graphic illustrates a **GET** request. A **GET** request is used
    when the **Web Client** simply wants the **Web Server** to send it a document,
    image, file, web page, and so on. **GET** requests are the most common. They are
    what your browser sends to a **Web** **Server** while loading up a web page or
    downloading a file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图形说明了**GET**请求。当**Web客户端**只想让**Web服务器**发送文档、图像、文件、网页等内容时，会使用**GET**请求。**GET**请求是最常见的。它们就是你的浏览器在加载网页或下载文件时发送给**Web服务器**的请求。
- en: There are a few other request types that are also worth mentioning.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种其他请求类型也值得提及。
- en: HTTP request types
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求类型
- en: 'Although `GET` requests are the most common, there are, perhaps, three request
    types that are commonly used. The three common HTTP request types are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`GET`请求是最常见的，但可能有三类请求类型被广泛使用。以下三个常见的HTTP请求类型如下：
- en: '`GET` is used when the client wants to download a resource.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端想要下载资源时，使用`GET`。
- en: '`HEAD` is just like `GET`, except that the client only wants information about
    the resource instead of the resource itself. For example, if the client only wants
    to know the size of a hosted file, it could send a `HEAD` request.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`请求与`GET`请求类似，但客户端只想获取资源信息，而不是资源本身。例如，如果客户端只想知道托管文件的大小，它可以发送一个`HEAD`请求。'
- en: '`POST` is used when the client needs to send information to the server. Your
    web browser typically uses a `POST` request when you submit an online form, for
    example. A `POST` request will typically cause a web server to change its state
    somehow. A web server could send an email, update a database, or change a file
    in response to a `POST` request.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`用于客户端需要向服务器发送信息时。例如，当你在网上提交表单时，你的网络浏览器通常使用`POST`请求。`POST`请求通常会导致网络服务器以某种方式改变其状态。网络服务器可能会发送电子邮件、更新数据库或响应`POST`请求更改文件。'
- en: 'In addition to `GET`, `HEAD`, and `POST`, there are a few more HTTP request
    types that are rarely used. They are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`GET`、`HEAD`和`POST`之外，还有一些很少使用的HTTP请求类型。它们如下：
- en: '`PUT` is used to send a document to the web server. `PUT` is not commonly used.
    `POST` is almost universally used to change the web server state.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`用于将文档发送到网络服务器。`PUT`不常用。`POST`几乎被普遍用来改变网络服务器状态。'
- en: '`DELETE` is used to request that the web server should delete a document or
    resource. Again, in practice, `DELETE` is rarely used. `POST` is commonly used
    to communicate web server updates of all types.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`用于请求网络服务器删除文档或资源。同样，在实践中，`DELETE`很少使用。`POST`通常用于传达各种类型的网络服务器更新。'
- en: '`TRACE` is used to request diagnostic information from web proxies. Most web
    requests don''t go through a proxy, and many web proxies don''t fully support
    `TRACE`. Therefore, it''s rare to need to use `TRACE`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`用于请求从Web代理获取诊断信息。大多数Web请求不会通过代理，而且许多Web代理不完全支持`TRACE`。因此，很少需要使用`TRACE`。'
- en: '`CONNECT` is sometimes used to initiate an HTTP connection through a proxy
    server.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONNECT`有时用于通过代理服务器初始化HTTP连接。'
- en: '`OPTIONS` is used to ask which HTTP request types are supported by the server
    for a given resource. A typical web server that implements `OPTIONS` may respond
    with something similar to `Allow: OPTIONS, GET, HEAD, POST`. Many common web servers
    don''t support `OPTIONS`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`用于询问服务器支持哪些HTTP请求类型。一个典型的实现`OPTIONS`的Web服务器可能会响应类似于`Allow: OPTIONS,
    GET, HEAD, POST`的内容。许多常见的Web服务器不支持`OPTIONS`。'
- en: If you send a request that the web server doesn't support, then the server should
    respond with a `400 Bad Request` code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发送一个网络服务器不支持请求，那么服务器应该响应一个`400 Bad Request`代码。
- en: Now that we've seen the types of HTTP requests, let's look at the request format
    in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了HTTP请求的类型，让我们更详细地看看请求格式。
- en: HTTP request format
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求格式
- en: 'If you open your web browser and navigate to `http://www.example.com/page1.htm`,
    your browser will need to send an HTTP request to the web server at `www.example.com`.
    That HTTP request may look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开你的网络浏览器并导航到`http://www.example.com/page1.htm`，你的浏览器需要向`www.example.com`上的网络服务器发送一个HTTP请求。这个HTTP请求可能看起来像这样：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the browser sends a `GET` request by default. This `GET` request
    is asking the server for the document `/page1.htm`. A `GET` request consists of
    HTTP headers only. There is no HTTP body because the client isn't sending data
    to the server. The client is only requesting data from the server. In contrast,
    a `POST` request would contain an HTTP body.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，浏览器默认发送一个`GET`请求。这个`GET`请求是向服务器请求文档`/page1.htm`。一个`GET`请求只包含HTTP头部信息。因为没有HTTP主体，客户端没有向服务器发送数据。客户端只是请求服务器上的数据。相比之下，一个`POST`请求将包含一个HTTP主体。
- en: The first line of an HTTP request is called the **request line**. The request
    line consists of three parts – the request type, the document path, and the protocol
    version. Each part is separated by a space. In the preceding example, the request
    line is `GET /page1.htm HTTP/1.1`. We can see that the request type is `GET`,
    the document path is `/page1.htm`, and the protocol version is `HTTP/1.1`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求的第一行被称为**请求行**。请求行由三部分组成——请求类型、文档路径和协议版本。每个部分之间由空格分隔。在上面的例子中，请求行是`GET
    /page1.htm HTTP/1.1`。我们可以看到请求类型是`GET`，文档路径是`/page1.htm`，协议版本是`HTTP/1.1`。
- en: When dealing with text-based network protocols, it is always important to be
    explicit about line endings. This is because different operating systems have
    standardized on different line-ending conventions. Each line of an HTTP message
    ends with a carriage return, followed by a newline character. In C, this looks
    like `\r\n`. In practice, some web servers may tolerate other line endings. You
    should ensure that your clients always send a proper `\r\n` line ending for maximum
    compatibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理基于文本的网络协议时，始终明确行结束是很重要的。这是因为不同的操作系统采用了不同的行结束约定。HTTP消息的每一行都以一个回车符，后跟一个换行符结束。在C语言中，这看起来像`\r\n`。实际上，一些Web服务器可能容忍其他行结束符。您应该确保您的客户端始终发送正确的`\r\n`行结束符以实现最大兼容性。
- en: 'After the request line, there are various HTTP header fields. Each header field
    consists of its name followed by a colon, and then its value. Consider the `User-Agent:
    Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36` line. This `User-Agent`
    line is telling the web server what software is contacting it. Some web servers
    will serve different documents to different user agents. For example, it is common
    for some websites to serve full documents to search engine spiders while serving
    paywalls to actual visitors. The server generally uses the user-agent HTTP header
    field to determine which is which. At the same time, there is a long history of
    web clients lying in the user-agent field. I suggest you take the high road in
    your applications and clearly identify your application with a unique user-agent
    value.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在请求行之后，有各种HTTP头部字段。每个头部字段由其名称后跟一个冒号，然后是其值组成。考虑一下`User-Agent: Mozilla/5.0 (Windows
    NT 10.0; Win64; x64) AppleWebKit/537.36`这一行。这条`User-Agent`行是在告诉Web服务器正在联系它的软件是什么。一些Web服务器会向不同的用户代理提供不同的文档。例如，一些网站向搜索引擎蜘蛛提供完整的文档，同时向实际访客提供付费墙。服务器通常使用用户代理HTTP头部字段来确定哪个是哪个。同时，在用户代理字段中存在许多Web客户端欺骗的历史。我建议您在您的应用程序中走正道，并使用一个独特的用户代理值清楚地标识您的应用程序。'
- en: The only header field that is actually required is `Host`. The `Host` field
    tells the web server which web host the client is requesting the resource from.
    This is important because one web server may be hosting many different websites.
    The request line tells the web server that the `/page1.htm` document is wanted,
    but it doesn't specify which server that page is on. The `Host` field fills this
    role.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正必需的头部字段是`Host`。`Host`字段告诉Web服务器客户端正在请求哪个Web主机上的资源。这很重要，因为一个Web服务器可能托管多个不同的网站。请求行告诉Web服务器想要`/page1.htm`文档，但它没有指定该页面在哪个服务器上。`Host`字段填补了这个角色。
- en: 'The `Connection: Keep-Alive` line tells the web server that the HTTP client
    would like to issue additional requests after the current request finishes. If
    the client had sent `Connection: Close` instead, that would indicate that the
    client intended to close the TCP connection after the HTTP response was received.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection: Keep-Alive`行告诉Web服务器，在当前请求完成后，HTTP客户端希望发出额外的请求。如果客户端发送了`Connection:
    Close`，那么这表明客户端打算在收到HTTP响应后关闭TCP连接。'
- en: 'The web client must send a blank line after the HTTP request header. This blank
    line is how the web server knows that the HTTP request is finished. Without this
    blank line, the web server wouldn''t know whether any additional header fields
    were still going to being sent. In C, the blank line looks like this: `\r\n\r\n`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Web客户端必须在HTTP请求头部之后发送一个空白行。这个空白行是Web服务器知道HTTP请求已经结束的方式。如果没有这个空白行，Web服务器将不知道是否还有额外的头部字段正在发送。在C语言中，空白行看起来像这样：`\r\n\r\n`。
- en: Let's now consider what the web server would send in reply to an HTTP request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑Web服务器会对HTTP请求发送什么响应。
- en: HTTP response format
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP响应格式
- en: Like the HTTP request, the HTTP response also consists of a header part and
    a body part. Also similar to the HTTP request, the body part is optional. Most
    HTTP responses do have a body part, though.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP请求一样，HTTP响应也由头部部分和主体部分组成。同样，与HTTP请求类似，主体部分是可选的。尽管如此，大多数HTTP响应都有主体部分。
- en: 'The server at `www.example.com` could respond to our HTTP request with the
    following reply:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`www.example.com`服务器可以对我们发送的HTTP请求做出以下响应：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of an HTTP response is the **status line**. The status line consists
    of the protocol version, the response code, and the response code description.
    In the preceding example, we can see that the protocol version is `HTTP/1.1`,
    the response code is `200`, and the response code description is `OK`. `200 OK`
    is the typical response code to an HTTP `GET` request when everything goes ok.
    If the server couldn't find the resource the client has requested, it might respond
    with a `404 Page Not Found` response code instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应的第一行是**状态行**。状态行由协议版本、响应代码和响应代码描述组成。在上面的示例中，我们可以看到协议版本是`HTTP/1.1`，响应代码是`200`，响应代码描述是`OK`。`200
    OK`是当一切顺利时对HTTP `GET`请求的典型响应代码。如果服务器找不到客户端请求的资源，它可能会用`404 Page Not Found`响应代码来响应。
- en: Many of the HTTP response headers are used to assist with caching. The `Date`,
    `Etag`, `Expires`, and `Last-Modified` fields can all be used by the client to
    cache documents.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多HTTP响应头部用于辅助缓存。`Date`、`Etag`、`Expires`和`Last-Modified`字段都可以被客户端用来缓存文档。
- en: The `Content-Type` field tells the client what type of resource it is sending.
    In the preceding example, it is an HTML web page, which is specified with `text/html`.
    HTTP can be used to send all types of resources, such as images, software, and
    videos. Each resource type has a specific `Content-Type`, which tells the client
    how to interpret the resource.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Type`字段告知客户端发送的资源类型。在上面的示例中，它是一个HTML网页，使用`text/html`指定。HTTP可以用来发送所有类型的资源，例如图片、软件和视频。每种资源类型都有一个特定的`Content-Type`，它告诉客户端如何解释该资源。'
- en: The `Content-Length` field specifies the size of the HTTP response body in bytes.
    In this case, we see that the requested resource is `1270` bytes long. There are
    a few ways to determine the body length, but the `Content-Length` field is the
    simplest. We will look at other ways in the *Response Body Length* section later
    in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Length`字段指定了HTTP响应主体的字节数。在这种情况下，我们看到请求的资源长度为`1270`字节。有几种方法可以确定主体长度，但`Content-Length`字段是最简单的方法。我们将在本章后面的“响应主体长度”部分探讨其他方法。'
- en: The HTTP response header section is delineated from the HTTP response body by
    a blank line. After this blank line, the HTTP body follows. Note that the HTTP
    body is not necessarily text-based. For example, if the client requested an image,
    then the HTTP body would likely be binary data. Also consider that, if the HTTP
    body is text-based, such as an HTML web page, it is free to use its own line-ending
    convention. It doesn't have to use the `\r\n` line ending required by HTTP.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应头部部分通过一个空白行与HTTP响应主体部分分开。在这个空白行之后，跟随的是HTTP主体。请注意，HTTP主体不一定是基于文本的。例如，如果客户端请求了一个图片，那么HTTP主体很可能是二进制数据。同时考虑，如果HTTP主体是基于文本的，例如一个HTML网页，它可以使用自己的行结束约定。它不必使用HTTP要求的`\r\n`行结束符。
- en: If the client had sent a HEAD request type instead of `GET`, then the server
    would respond with exactly the same HTTP headers as before, but it would not include
    the HTTP body.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端发送的是HEAD请求类型而不是`GET`，那么服务器将响应与之前完全相同的HTTP头部，但不会包含HTTP主体。
- en: With the HTTP response format defined, let's look at some of the most common
    HTTP response types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了HTTP响应格式之后，让我们看看一些最常见的HTTP响应类型。
- en: HTTP response codes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP响应代码
- en: There are many different types of HTTP response codes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多不同类型的HTTP响应代码。
- en: 'If the request was successful, then the server responds with a code in the
    200 range:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，则服务器会响应一个 200 范围的代码：
- en: '`200 OK`: The client''s request is successful, and the server sends the requested
    resource'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`: 客户端的请求成功，服务器发送请求的资源'
- en: 'If the resource has moved, the server can respond with a code in the 300 range.
    These codes are commonly used to redirect traffic from an unencrypted connection
    to an encrypted one, or to redirect traffic from a `www` subdomain to a bare one.
    They are also used if a website has undergone restructuring, but wants to keep
    incoming links working. The common 300 range codes are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源已移动，服务器可以响应一个 300 范围的代码。这些代码通常用于将流量从未加密的连接重定向到加密连接，或将流量从 `www` 子域名重定向到裸域名。如果网站经过重构但希望保持入站链接正常工作，也会使用这些代码。常见的
    300 范围代码如下：
- en: '`301 Moved Permanently`: The requested resource has moved to a new location.
    This location is indicated by the server in the `Location` header field. All future
    requests for this resource should use this new location.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301 永久移动`: 请求的资源已移动到新的位置。这个位置由服务器在 `Location` 头字段中指示。所有未来的对该资源的请求都应该使用这个新位置。'
- en: '`307 Moved Temporarily`: The requested resource has moved to a new location.
    This location is indicated by the server in the `Location` header field. This
    move may not be permanent, so future requests should still use the original location.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`307 临时移动`: 请求的资源已移动到新的位置。这个位置由服务器在 `Location` 头字段中指示。这种移动可能不是永久的，因此未来的请求仍然应该使用原始位置。'
- en: 'Errors are indicated by 400 or 500 range response codes. Some common ones are
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 错误由 400 或 500 范围的响应代码指示。一些常见的如下：
- en: '`400 Bad Request`: The server doesn''t understand/support the client''s request'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 错误请求`: 服务器不理解/不支持客户端的请求'
- en: '`401 Unauthorized`: The client isn''t authorized for the requested resource'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 未授权`: 客户端没有权限访问请求的资源'
- en: '`403 Forbidden`: The client is forbidden to access the requested resource'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403 禁止访问`: 客户端被禁止访问请求的资源'
- en: '`500 Internal Server Error`: The server encountered an error while trying to
    fulfill the client''s request'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 内部服务器错误`: 服务器在尝试满足客户端请求时遇到了错误'
- en: In addition to a response type, the HTTP server must also be able to unambiguously
    communicate the length of the response body.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了响应类型之外，HTTP 服务器还必须能够明确地传达响应体的长度。
- en: Response body length
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应体长度
- en: The HTTP body response length can be determined a few different ways. The simplest
    is if the HTTP server includes a `Content-Length` header line in its response.
    In that case, the server simply states the body length directly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应体长度可以通过几种不同的方式来确定。最简单的方式是如果 HTTP 服务器在其响应中包含一个 `Content-Length` 头行。在这种情况下，服务器直接声明了体长度。
- en: 'If the server would like to begin sending data before the body''s length is
    known, then it can''t use the `Content-Length` header line. In this case, the
    server can send a `Transfer-Encoding: chunked` header line. This header line indicates
    to the client that the response body will be sent in separate chunks. Each chunk
    begins with its chunk length, encoded in base-16 (hexadecimal), followed by a
    newline, and then the chunk data. The entire HTTP body ends with a zero-length
    chunk.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '如果服务器希望在知道体长度之前开始发送数据，则不能使用 `Content-Length` 头行。在这种情况下，服务器可以发送一个 `Transfer-Encoding:
    chunked` 头行。这个头行指示客户端响应体将以单独的数据块发送。每个数据块以数据块长度开始，该长度以十六进制（十六进制）编码，后跟一个换行符，然后是数据块数据。整个
    HTTP 主体以一个零长度的数据块结束。'
- en: 'Let''s consider an HTTP response example that uses chunked encoding:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个使用分块编码的 HTTP 响应示例：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we see the HTTP body starts with `44` followed by
    a newline. This `44` should be interpreted as hexadecimal. We can use the built-in
    C `strtol()` function to interpret hexadecimal numbers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到 HTTP 主体以 `44` 开头，后跟一个换行符。这个 `44` 应该被解释为十六进制。我们可以使用内置的 C `strtol()`
    函数来解释十六进制数字。
- en: Hexadecimal numbers are commonly written with a `0x` prefix to disambiguate
    them from decimal. We identify them with this prefix here, but keep in mind that
    the HTTP protocol does not add this prefix.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数字通常以 `0x` 前缀来区分它们与十进制数字。我们在这里使用这个前缀来标识它们，但请记住，HTTP 协议不会添加这个前缀。
- en: The `0x44` hexadecimal number is equal to 68 in decimal. After the `44` and
    newline, we see 68 characters that are part of the requested resource. After the
    68 character chunk, the server sends a newline.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制的 `0x44` 数字等于十进制的 68。在 `44` 和换行符之后，我们看到 68 个字符是请求资源的一部分。在 68 个字符的数据块之后，服务器发送一个换行符。
- en: The server then sent `37`. `0x37` is 55 in decimal. After a newline, 55 characters
    are sent as chunk data. The server then sends a zero-length chunk to indicate
    that the response is finished.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后发送了`37`。`0x37`的十进制值是55。换行后，发送55个字符作为块数据。然后服务器发送一个零长度的块来指示响应已结束。
- en: The client should interpret the complete HTTP response after it has decoded
    the chunking as `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
    do eiusmod tempor incididunt ut labore et dolore magna aliqua`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应在解码分块后将完整的HTTP响应解释为`Lorem ipsum dolor sit amet, consectetur adipiscing elit,
    sed do eiusmod tempor incididunt ut labore et dolore magna aliqua`。
- en: 'There are a few other ways to indicate the HTTP response body length besides `Content-Length`
    and `Transfer-Encoding: chunked`. However, the server is limited to those two
    unless the client explicitly states support for additional encoding types in the
    HTTP request.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '除了`Content-Length`和`Transfer-Encoding: chunked`之外，还有几种其他方式可以指示HTTP响应体长度。然而，除非客户端明确表示支持HTTP请求中的附加编码类型，否则服务器仅限于这两种。'
- en: You may sometimes see a server that simply closes the TCP connection when it
    has finished transmitting a resource. That was a common way to indicate resource
    size in `HTTP/1.0`. However, this method shouldn't be used with `HTTP/1.1`. The
    issue with using a closed connection to indicate response length is that it's
    ambiguous as to why the connection was closed. It could be because all data has
    been sent, or it could be because of some other reason. Consider what would happen
    if a network cable is unplugged while data is being sent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您有时会看到服务器在传输完资源后简单地关闭TCP连接。这是`HTTP/1.0`中指示资源大小的一种常见方式。然而，不应使用`HTTP/1.1`。使用关闭的连接来指示响应长度的问题是它不明确为什么连接被关闭。这可能是因为所有数据都已发送，也可能是因为其他原因。考虑如果在数据传输过程中拔掉网络电缆会发生什么。
- en: Now that we've seen the basics of HTTP requests and responses, let's look at
    how web resources are identified.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了HTTP请求和响应的基础，让我们看看如何识别网络资源。
- en: What's in a URL
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL中有什么
- en: '**Uniform Resource Locators** (**URL**), also known as web addresses, provide
    a convenient way to specify particular web resources. You can navigate to a URL
    by typing it into your web browser''s address bar. Alternately, if you''re browsing
    a web page and click on a link, that link is indicated with a URL.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源定位符**（**URL**），也称为网页地址，提供了一种方便的方式来指定特定的网络资源。您可以通过在网页浏览器的地址栏中输入URL来导航到该URL。或者，如果您正在浏览网页并点击链接，该链接将以URL的形式表示。'
- en: 'Consider the `http://www.example.com:80/res/page1.php?user=bob#account` URL.
    Visually, the URL can be broken down like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`http://www.example.com:80/res/page1.php?user=bob#account`这个URL。从视觉上看，URL可以分解如下：
- en: '![](img/afe37f05-570a-41e7-a535-037e9092b533.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afe37f05-570a-41e7-a535-037e9092b533.png)'
- en: The URL can indicate the protocol, the host, the port number, the document path,
    and hash. However, the host is the only required part. The other parts can be
    implied.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: URL可以指示协议、主机、端口号、文档路径和哈希。然而，主机是唯一必需的部分。其他部分可以隐含。
- en: 'We can parse the example URL from the preceding diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解析前面图表中的示例URL：
- en: '**http://**: The part before the first **://** indicates the protocol. In this
    example, the protocol is **http**, but it could be a different protocol such as
    `ftp://` or `https://`. If the protocol is omitted, the application will generally
    make an assumption. For example, your web browser would assume the protocol to
    be **http**.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http://**：第一个**://**之前的部分表示协议。在这个例子中，协议是**http**，但它可以是不同的协议，如`ftp://`或`https://`。如果省略了协议，应用程序通常会做出假设。例如，您的网页浏览器会假设协议是**http**。'
- en: '**www.example.com**: This specifies the hostname. It is used to resolve an
    IP address that the HTTP client can connect to. This hostname must also appear
    in the HTTP request `Host` header field. This is required since multiple hostnames
    can resolve to the same IP address. This part can also be an IP address instead
    of a name. IPv4 addresses are used directly (`http://192.168.50.1/`), but IPv6
    addresses should be put inside square brackets (`http://[::1]/`).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**www.example.com**：这指定了主机名。它用于解析HTTP客户端可以连接到的IP地址。此主机名还必须出现在HTTP请求的`Host`头字段中。这是必需的，因为多个主机名可以解析到同一个IP地址。这部分也可以是一个IP地址而不是名称。IPv4地址可以直接使用（`http://192.168.50.1/`），但IPv6地址应放在方括号内（`http://[::1]/`）。'
- en: '**:80**: The port number can be specified explicitly by using a colon after
    the hostname. If the port number is not specified, then the client uses the default
    port number for the given protocol. The default port number for **http** is **80**,
    and the default port number for **https** is **443**. Non-standard port numbers
    are common for testing and development.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:80**：端口号可以通过在主机名后使用冒号来显式指定。如果没有指定端口号，则客户端使用给定协议的默认端口号。**http**的默认端口号是**80**，**https**的默认端口号是**443**。非标准端口号在测试和开发中很常见。'
- en: '**/res/page1.php?user/bob**: This specifies the document path. The HTTP server
    usually makes a distinction between the part before and after the question mark,
    but the HTTP client should not assign significance to this. The part after the
    question mark is often called the query string.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/res/page1.php?user/bob**：这指定了文档路径。HTTP服务器通常会在问号之前和之后的部分之间做出区分，但HTTP客户端不应对此赋予任何意义。问号之后的部分通常被称为查询字符串。'
- en: '**#account**: This is called the hash. The hash specifies a position within
    a document, and the hash is not sent to the HTTP server. It instead allows a browser
    to scroll to a particular part of a document after the entire document is received
    from the HTTP server.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#account**：这被称为哈希。哈希指定了文档中的位置，哈希不会发送到HTTP服务器。相反，它允许浏览器在从HTTP服务器接收整个文档后滚动到文档的特定部分。'
- en: Now that we have a basic understanding of URLs, let's write code to parse them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对URL有了基本的了解，让我们编写代码来解析它们。
- en: Parsing a URL
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析URL
- en: We will write a C function to parse a given URL.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个C函数来解析给定的URL。
- en: The function takes as input a URL, and it returns as output the hostname, the
    port number, and the document path. To avoid needing to do manual memory management,
    the outputs are returned as pointers to specific parts of the input URL. The input
    URL is modified with terminating null pointers as required.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个URL作为输入，并返回主机名、端口号和文档路径作为输出。为了避免需要手动管理内存，输出作为指向输入URL特定部分的指针返回。输入URL根据需要修改为终止的空指针。
- en: 'Our function begins by printing the input URL. This is useful for debugging.
    The code for that is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能首先打印输入的URL。这对于调试很有用。相应的代码如下：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function then attempts to find `://` in the URL. If found, it reads in
    the first part of the URL as a protocol. Our program only supports HTTP. If the
    given protocol is not HTTP, then an error is returned. The code for parsing the
    protocol is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后尝试在URL中找到`://`。如果找到，它将读取URL的第一部分作为协议。我们的程序只支持HTTP。如果给定的协议不是HTTP，则返回错误。解析协议的代码如下：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, a character pointer, `p`, is declared. `protocol` is
    also declared and set to `0` to indicate that no protocol has been found. `strstr()`
    is called to search for `://` in the URL. If it is not found, then `protocol`
    is left at `0`, and `p` is set to point back to the beginning of the URL. However,
    if `://` is found, then `protocol` is set to the beginning of the URL, which contains
    the protocol. `p` is set to one after `://`, which should be where the hostname
    begins.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，声明了一个字符指针`p`。`protocol`也被声明并设置为`0`，以表示没有找到协议。调用`strstr()`在URL中搜索`://`。如果没有找到，则`protocol`保持为`0`，`p`被设置为指向URL的开始。然而，如果找到了`://`，则`protocol`被设置为URL的开始，其中包含协议。`p`被设置为`://`之后的一个位置，这应该是主机名开始的地方。
- en: If `protocol` was set, the code then checks that it points to the text `http`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`protocol`，代码将检查它是否指向`http`文本。
- en: 'At this point in the code, `p` points to the beginning of the hostname. The
    code can save the hostname into the return variable, `hostname`. The code must
    then scan for the end of the hostname by looking for the first colon, slash, or
    hash. The code for this is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这个点上，`p`指向主机名的开始。代码可以将主机名保存到返回变量`hostname`中。然后代码必须通过查找第一个冒号、斜杠或井号来扫描主机名的结束。相应的代码如下：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once `p` has advanced to the end of the hostname, we must check whether a port
    number was found. A port number starts with a colon. If a port number is found,
    our code returns it in the `port` variable; otherwise, a default port number of
    `80` is returned. The code to check for a port number is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`p`前进到主机名的末尾，我们必须检查是否找到了端口号。端口号以冒号开头。如果找到了端口号，我们的代码将把它返回到`port`变量中；否则，返回默认端口号`80`。检查端口号的代码如下：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the port number, `p` points to the document path. The function returns
    this part of the URL in the `path` variable. Note that our function omits the
    first `/` in the path. This is for simplicity because it allows us to avoid allocating
    any memory. All document paths start with `/`, so the function caller can easily
    prepend that when the HTTP request is constructed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口号之后，`p`指向文档路径。函数将这个URL的部分返回到`path`变量中。请注意，我们的函数省略了路径中的第一个`/`。这是为了简化，因为它允许我们避免分配任何内存。所有文档路径都以`/`开始，因此当构造HTTP请求时，函数调用者可以轻松地将其前置。
- en: 'The code to set the `path` variable is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`path`变量的代码如下：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code then attempts to find a hash, if it exists. If it does exist, it is
    overwritten with a terminating null character. This is because the hash is never
    sent to the web server and is ignored by our HTTP client.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码尝试找到一个哈希值，如果存在的话。如果存在，它会被一个终止的空字符覆盖。这是因为哈希值永远不会发送到Web服务器，并且被我们的HTTP客户端忽略。
- en: 'The code that advances to the hash is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到哈希值的代码如下：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our function has now parsed out the hostname, port number, and document path.
    It then prints out these values for debugging purposes and returns. The final
    code for the `parse_url()` function is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能现在已经解析出了主机名、端口号和文档路径。然后它打印出这些值以进行调试，并返回。`parse_url()`函数的最终代码如下：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have code to parse a URL, we are one step closer to building an
    entire HTTP client.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了解析URL的代码，我们离构建完整的HTTP客户端又近了一步。
- en: Implementing a web client
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现网络客户端
- en: We will now implement an HTTP web client. This client takes as input a URL.
    It then attempts to connect to the host and retrieve the resource given by the
    URL. The program displays the HTTP headers that are sent and received, and it
    attempts to parse out the requested resource content from the HTTP response.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个HTTP网络客户端。这个客户端接受一个URL作为输入。然后它尝试连接到主机并检索URL给出的资源。程序显示发送和接收的HTTP头信息，并尝试从HTTP响应中解析出请求的资源内容。
- en: 'Our program begins by including the chapter header, `chap06.h`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目开始于包含章节标题，`chap06.h`：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then define a constant, `TIMEOUT`. Later in our program, if an HTTP response
    is taking more than `TIMEOUT` seconds to complete, then our program abandons the
    request. You can define `TIMEOUT` as you like, but we give it a value of five
    seconds here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着定义一个常量，`TIMEOUT`。在程序的后半部分，如果HTTP响应完成需要超过`TIMEOUT`秒，那么我们的程序将放弃请求。你可以按自己的喜好定义`TIMEOUT`，但在这里我们给它赋值为五秒：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, please include the entire `parse_url()` function as given in the previous
    section. Our client needs `parse_url()` to find the hostname, port number, and
    document path from a given URL.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请包含上一节中给出的整个`parse_url()`函数。我们的客户端需要`parse_url()`来从一个给定的URL中找到主机名、端口号和文档路径。
- en: 'Another helper function is used to format and send the HTTP request. We call
    it `send_request()`, and its code is given next:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个辅助函数用于格式化和发送HTTP请求。我们称它为`send_request()`，其代码如下：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`send_request()` works by first defining a character buffer in which to store
    the HTTP request. It then uses the `sprintf()` function to write to the buffer
    until the HTTP request is complete. The HTTP request ends with a blank line. This
    blank line tells the server that the entire request header has been received.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_request()`通过首先定义一个字符缓冲区来存储HTTP请求来实现。然后使用`sprintf()`函数将内容写入缓冲区，直到HTTP请求完成。HTTP请求以一个空白行结束。这个空白行告诉服务器整个请求头已经接收完毕。'
- en: Once the request is formatted into `buffer`, `buffer` is sent over an open socket
    using `send()`. `buffer` is also printed to the console for debugging purposes.
    We define one more helper function for our web client. This function, `connect_to_host()`,
    takes in a hostname and port number and attempts to establish a new TCP socket
    connection to it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求被格式化为`buffer`，就使用`send()`通过一个打开的套接字发送`buffer`。`buffer`也被打印到控制台以进行调试。我们为我们的网络客户端定义了一个额外的辅助函数。这个函数，`connect_to_host()`，接受一个主机名和端口号，并尝试建立一个新的TCP套接字连接到它。
- en: 'In the first part of `connect_to_host()`, `getaddrinfo()` is used to resolve
    the hostname. `getnameinfo()` is then used to print out the server IP address
    for debugging purposes. The code for this is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`connect_to_host()`的第一部分，使用`getaddrinfo()`解析主机名。然后使用`getnameinfo()`打印出服务器IP地址以进行调试。相应的代码如下：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the second part of `connect_to_host()`, a new socket is created with `socket()`,
    and a TCP connection is established with `connect()`. If everything goes well,
    the function returns the created socket. The code for the second half of `connect_to_host()`
    is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`connect_to_host()`函数的第二部分，使用`socket()`创建一个新的套接字，并通过`connect()`建立TCP连接。如果一切顺利，函数将返回创建的套接字。`connect_to_host()`函数后半部分的代码如下：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you've been working through this book from the beginning, the code in `connect_to_host()`
    should be very familiar by now. If it's not, please refer to the previous chapters
    for a more detailed explanation of `getaddrinfo()`, `socket()`, and `connect()`. [Chapter
    3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An In-Depth Overview of TCP Connections*,
    should be particularly helpful.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从本书的开头开始工作，到`connect_to_host()`函数中的代码现在应该非常熟悉了。如果不熟悉，请参阅前面的章节，以获取关于`getaddrinfo()`、`socket()`和`connect()`的更详细解释。[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*，应该特别有帮助。
- en: 'With our helper functions out of the way, we can now begin to define the `main()`
    function. We begin `main()` with the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完辅助函数后，我们现在可以开始定义`main()`函数。`main()`函数的起始代码如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, Winsock is initialized, if needed, and the program's
    arguments are checked. If a URL is given as an argument, it is stored in the `url` variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果需要，Winsock被初始化，并检查程序的参数。如果提供了一个URL作为参数，它将被存储在`url`变量中。
- en: 'We can then parse the URL into its hostname, port, and path parts with the
    following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码将URL解析为其主机名、端口和路径部分：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The program then continues by establishing a connection to the target server
    and sending the HTTP request. This is made easy by using the two helper functions
    we defined previously, `connect_to_host()` and `send_request()`. The code for
    this is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接着通过建立与目标服务器的连接并发送HTTP请求来继续。这可以通过使用我们之前定义的两个辅助函数`connect_to_host()`和`send_request()`来实现。相应的代码如下：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One feature of our web client is that it times out if a request takes too long
    to complete. In order to know how much time has elapsed, we need to record the
    start time. This is done using a call to the built-in `clock()` function. We store
    the start time in the `start_time` variable with the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络客户端有一个特性，即如果请求完成时间过长，则会超时。为了知道已经过去了多少时间，我们需要记录开始时间。这通过调用内置的`clock()`函数来完成。我们使用以下方式将开始时间存储在`start_time`变量中：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is now necessary to define some more variables that can be used for bookkeeping
    while receiving and parsing the HTTP response. The requisite variables are as
    follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要定义一些变量，以便在接收和解析HTTP响应时进行记录。所需的变量如下：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, `RESPONSE_SIZE` is the maximum size of the HTTP response
    we reserve memory for. Our program is unable to parse HTTP responses bigger than
    this. If you extend this limit, it may be useful to use `malloc()` to reserve
    memory on the heap instead of the stack.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`RESPONSE_SIZE`是我们为HTTP响应预留内存的最大大小。我们的程序无法解析大于此大小的HTTP响应。如果您扩展此限制，可能需要使用`malloc()`在堆上而不是栈上预留内存。
- en: '`response` is a character array that holds the entire HTTP response. `p` is
    a `char` pointer that keeps track of how far we have written into `response` so
    far. `q` is an additional `char` pointer that is used later. We define `end` as
    a `char` pointer, which points to the end of the `response` buffer. `end` is useful
    to ensure that we don''t attempt to write past the end of our reserved memory.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`response`是一个字符数组，用于存储整个HTTP响应。`p`是一个`char`指针，用于跟踪到目前为止已写入`response`的长度。`q`是一个稍后使用的额外`char`指针。我们定义`end`为一个`char`指针，它指向`response`缓冲区的末尾。`end`非常有用，可以确保我们不会尝试写入预留内存的末尾。'
- en: The `body` pointer is used to remember the beginning of the HTTP response body
    once received.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`指针用于在收到HTTP响应体后记住其起始位置。'
- en: If you recall, the HTTP response body length can be determined by a few different
    methods. We define an enumeration to list the method types, and we define the
    `encoding` variable to store the actual method used. Finally, the `remaining`
    variable is used to record how many bytes are still needed to finish the HTTP
    body or body chunk.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，HTTP响应体长度可以通过几种不同的方法来确定。我们定义了一个枚举来列出方法类型，并定义了`encoding`变量来存储实际使用的方法。最后，`remaining`变量用于记录完成HTTP主体或主体块还需要多少字节。
- en: 'We then start a loop to receive and process the HTTP response. This loop first
    checks that it hasn''t taken too much time and that we still have buffer space
    left to store the received data. The first part of this loop is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始一个循环来接收和处理 HTTP 响应。这个循环首先检查它是否花费了太多时间，并且我们是否还有足够的空间来存储接收到的数据。这个循环的第一部分如下：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then include the code to receive data over the TCP socket. Our code uses
    `select()` with a short timeout. This allows us to periodically check that the
    request hasn''t timed out. You may recall from previous chapters that `select()`
    involves creating `fd_set` and `timeval` structures. The following code creates
    these objects and calls `select()`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们包含接收 TCP 套接字数据的代码。我们的代码使用 `select()` 并设置一个短的超时时间。这允许我们定期检查请求是否超时。您可能还记得，从前面的章节中，`select()`
    涉及创建 `fd_set` 和 `timeval` 结构。以下代码创建了这些对象并调用了 `select()`：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`select()` returns when either the timeout has elapsed, or new data is available
    to be read from the socket. Our code needs to use `FD_ISSET()` to determine whether
    new data is available to be read. If so, we read the data into the buffer at the `p` pointer.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 在超时时间已过或可以从套接字读取新数据时返回。我们的代码需要使用 `FD_ISSET()` 来确定是否有可读取的新数据。如果是这样，我们将数据读取到
    `p` 指针指向的缓冲区中。'
- en: Alternatively, when attempting to read new data, we may find that the socket
    was closed by the web server. If this is the case, we check whether we were expecting
    a closed connection to indicate the end of the transmission. That is the case
    if `encoding == connection`. If so, we print the HTTP body data that was received.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当尝试读取新数据时，我们可能会发现套接字已被网络服务器关闭。如果是这种情况，我们检查是否期望一个关闭的连接来指示传输的结束。如果是这样，即 `encoding
    == connection`，我们将打印接收到的 HTTP 主体数据。
- en: 'The code for reading in new data and detecting a closed connection is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 读取新数据并检测连接已关闭的代码如下：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that, in the preceding code, the `p` pointer is advanced to point to the
    end of received data. `*p` is set to zero, so our received data always ends with
    a null terminator. This allows us to use standard functions on the data that expect
    a null-terminated string. For example, we use the built-in `strstr()` function
    to search through the received data, and `strstr()` expects the input string to
    be null-terminated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述代码中，`p` 指针被向前移动以指向接收到的数据的末尾。`*p` 被设置为零，因此我们的接收数据始终以空终止符结束。这允许我们使用期望空终止字符串的标准函数来处理数据。例如，我们使用内置的
    `strstr()` 函数在接收到的数据中搜索，而 `strstr()` 期望输入字符串是空终止的。
- en: Next, if the HTTP body hasn't already been found, our code searches through
    the received data for a blank line that indicates the end of the HTTP header.
    A blank line is encoded by two consecutive line endings. HTTP defines a line ending
    as `\r\n`, so our code detects a blank line by searching for `\r\n\r\n`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果 HTTP 主体尚未找到，我们的代码会在接收到的数据中搜索一个空白行，该空白行指示 HTTP 标头的结束。空白行由两个连续的行结束符编码。HTTP
    将行结束符定义为 `\r\n`，因此我们的代码通过搜索 `\r\n\r\n` 来检测空白行。
- en: 'The following code finds the end of the HTTP header (which is the beginning
    of the HTTP body) using `strstr()`, and updates the `body` pointer to point to
    the beginning of the HTTP body:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `strstr()` 找到 HTTP 标头的结束（即 HTTP 主体的开始），并将 `body` 指针更新为指向 HTTP 主体开始的位置：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It may be useful to print the HTTP header for debugging. This can be done with
    the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 HTTP 标头以进行调试可能是有用的。这可以通过以下代码完成：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that the headers have been received, we need to determine whether the HTTP
    server is using `Content-Length` or `Transfer-Encoding: chunked` to indicate body
    length. If it doesn''t send either, then we assume that the entire HTTP body has
    been received once the connection is closed.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '现在已经接收了标头，我们需要确定 HTTP 服务器是使用 `Content-Length` 还是 `Transfer-Encoding: chunked`
    来指示主体长度。如果它不发送任何一个，那么我们假设在连接关闭后已经接收了整个 HTTP 主体。'
- en: If the `Content-Length` is found using `strstr()`, we set `encoding = length`
    and store the body length in the `remaining` variable. The actual length is read
    from the HTTP header using the `strtol()` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `strstr()` 找到 `Content-Length`，我们将 `encoding` 设置为 `length` 并将主体长度存储在 `remaining`
    变量中。实际长度是通过 `strtol()` 函数从 HTTP 标头中读取的。
- en: 'If `Content-Length` is not found, then the code searches for `Transfer-Encoding:
    chunked`. If found, we set `encoding = chunked`. `remaining` is set to `0` to
    indicate that we haven''t read in a chunk length yet.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果找不到 `Content-Length`，则代码会搜索 `Transfer-Encoding: chunked`。如果找到，我们将 `encoding`
    设置为 `chunked`。`remaining` 设置为 `0` 以指示我们尚未读取到块长度。'
- en: 'If neither `Content-Length` or `Transfer-Encoding: chunked` is found, then
    `encoding = connection` is set to indicate that we consider the HTTP body received
    when the connection is closed.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '如果没有找到 `Content-Length` 或 `Transfer-Encoding: chunked`，则将 `encoding = connection`
    设置为指示我们在连接关闭时认为已接收到 HTTP 正文。'
- en: 'The code for determining which body length method is used is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确定使用哪种正文长度方法的代码如下：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code could be made more robust by doing case-insensitive searching,
    or by allowing for some flexibility in spacing. However, it should work with most
    web servers as is, and we're going to continue to keep it simple.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以通过进行不区分大小写的搜索或允许一些灵活性来改进其鲁棒性。然而，它应该可以与大多数网络服务器一起正常工作，我们将继续保持其简单性。
- en: 'If the HTTP body start has been identified, and `encoding == length`, then
    the program simply needs to wait until `remaining` bytes have been received. The
    following code checks for this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经识别出 HTTP 正文开始，并且 `encoding == length`，则程序只需等待接收 `remaining` 字节。以下代码检查这一点：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, once `remaining` bytes of the HTTP body have been received,
    it prints the received body and breaks from the `while` loop.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一旦接收到 `remaining` 字节的 HTTP 正文，它将打印接收到的正文并从 `while` 循环中退出。
- en: 'If `Transfer-Encoding: chunked` is used, then the receiving logic is a bit
    more complicated. The following code handles this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '如果使用 `Transfer-Encoding: chunked`，则接收逻辑要复杂一些。以下代码处理这种情况：'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, the `remaining` variable is used to indicate whether
    a chunk length or chunk data is expected next. When `remaining == 0`, the program
    is waiting to receive a new chunk length. Each chunk length ends with a newline;
    therefore, if a newline is found with `strstr()`, we know that the entire chunk
    length has been received. In this case, the chunk length is read using `strtol()`,
    which interprets the hexadecimal chunk length. `remaining` is set to the expected
    chunk length. A chunked message is terminated by a zero-length chunk, so if `0`
    was read, the code uses `goto finish` to break out of the main loop.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`remaining` 变量用于指示是否期望下一个块长度或块数据。当 `remaining == 0` 时，程序正在等待接收新的块长度。每个块长度以换行符结束；因此，如果在
    `strstr()` 中找到换行符，我们知道已经接收到了整个块长度。在这种情况下，块长度使用 `strtol()` 读取，它解释了十六进制块长度。`remaining`
    被设置为期望的块长度。分块消息由零长度的块终止，因此如果读取到 `0`，代码使用 `goto finish` 来跳出主循环。
- en: If the `remaining` variable is non-zero, then the program checks whether at
    least `remaining` bytes of data have been received. If so, that chunk is printed,
    and the `body` pointer is advanced to the end of the current chunk. This logic
    loops until it finds the terminating zero-length chunk or runs out of data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `remaining` 变量非零，则程序检查是否已接收到至少 `remaining` 字节的数据。如果是这样，则打印该块，并将 `body` 指针向前推进到当前块的末尾。这种逻辑会一直循环，直到找到终止的零长度块或数据耗尽。
- en: 'At this point, we''ve shown all of the logic to parse the HTTP response body.
    We only need to end our loops, close the socket, and the program is finished.
    Here is the final code for `web_get.c`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了解析 HTTP 响应体的所有逻辑。我们只需要结束循环，关闭套接字，程序就完成了。以下是 `web_get.c` 的最终代码：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can compile and run `web_get.c` on Linux and macOS with the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在 Linux 和 macOS 上编译和运行 `web_get.c`：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On Windows, the command to compile and run using MinGW is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，使用 MinGW 编译和运行的命令如下：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try running `web_get` with different URLs and study the outputs. You may find
    the HTTP response headers interesting.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的 URL 运行 `web_get` 并研究输出。你可能对 HTTP 响应头感到有趣。
- en: 'The following screenshot shows what happens when we run `web_get` on `http://example.com/`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们在 `http://example.com/` 上运行 `web_get` 时发生的情况：
- en: '![](img/74f1a912-e88f-48ac-a49b-831750b1f4d6.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74f1a912-e88f-48ac-a49b-831750b1f4d6.png)'
- en: '`web_get` only supports the `GET` queries. `POST` queries are also common and
    useful. Let''s now look at HTTP `POST` requests.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`web_get` 只支持 `GET` 查询。`POST` 查询也很常见且有用。现在让我们看看 HTTP `POST` 请求。'
- en: HTTP POST requests
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP POST 请求
- en: An HTTP `POST` request sends data from the web client to the web server. Unlike
    an HTTP `GET` request, a `POST` request includes a body containing data (although
    this body could be zero-length).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `POST` 请求将数据从网络客户端发送到网络服务器。与 HTTP `GET` 请求不同，`POST` 请求包含一个包含数据的正文（尽管这个正文可以是零长度的）。
- en: The `POST` body format can vary, and it should be identified by a `Content-Type`
    header. Many modern, web-based APIs expect a `POST` body to be JSON encoded.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 体的格式可能不同，应该通过 `Content-Type` 头部来识别。许多现代基于 Web 的 API 预期 `POST` 体的数据是
    JSON 编码的。'
- en: 'Consider the following HTTP `POST` request:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 HTTP `POST` 请求：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding example, you can see that the HTTP `POST` request is similar
    to an HTTP `GET` request. Notable differences are as follows: the request starts
    with `POST` instead of `GET`; a `Content-Type` header field is included; a `Content-Length`
    header field is present; and an HTTP message body is included. In that example,
    the HTTP message body is in JSON format, as specified by the `Content-Type` header.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以看到 HTTP `POST` 请求与 HTTP `GET` 请求相似。明显的区别如下：请求以 `POST` 开头而不是 `GET`；包含了一个
    `Content-Type` 头部字段；存在一个 `Content-Length` 头部字段；并且包含了一个 HTTP 消息体。在那个例子中，HTTP 消息体是
    JSON 格式，如 `Content-Type` 头部所指定的。
- en: Encoding form data
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码表单数据
- en: 'If you encounter a form on a website, such as a login form, that form likely
    uses a `POST` request to transmit its data to the web server. A standard HTML
    form encodes the data it sends in a format called **URL encoding**, also called
    **percent encoding**. When URL encoded form data is submitted in an HTTP `POST` request,
    it uses the `Content-Type: application/x-www-form-urlencoded` header.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你在一个网站（如登录表单）上遇到一个表单，该表单很可能使用 `POST` 请求将其数据传输到 web 服务器。标准的 HTML 表单使用称为 **URL
    编码**（也称为 **百分编码**）的格式来编码它发送的数据。当 URL 编码的表单数据在 HTTP `POST` 请求中提交时，它使用 `Content-Type:
    application/x-www-form-urlencoded` 头部。'
- en: 'Consider the following HTML for a submittable form:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下可用于提交的 HTML 表单：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In your web browser, the preceding HTML may render as shown in the following
    screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网页浏览器中，前面的 HTML 可能会渲染成以下截图所示：
- en: '![](img/ca257bf2-56b9-45fd-8dca-7541497ca0ee.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca257bf2-56b9-45fd-8dca-7541497ca0ee.png)'
- en: 'When this form is submitted, its data is encoded in an HTTP request such as
    the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个表单提交时，其数据被编码在以下类似的 HTTP 请求中：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding HTTP request, you can see that `Content-Type: application/x-www-form-urlencoded`
    is used. In this format, each form field and value is paired by an equal sign,
    and multiple form fields are chained together by ampersands.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的 HTTP 请求中，你可以看到使用了 `Content-Type: application/x-www-form-urlencoded`。在这个格式中，每个表单字段和值通过等号配对，多个表单字段通过
    ampersands 连接。'
- en: Special characters in form field names or values must be encoded. Notice that
    `Well Done!` was encoded as `Well+Done%21`. Spaces are encoded with plus symbols,
    and special characters are encoded by a percent sign followed by their two-digit
    hexadecimal value (thus, the exclamation point was encoded as `%21`). A percent
    sign itself would be encoded as `%25`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段名称或值中的特殊字符必须进行编码。注意，`Well Done!` 被编码为 `Well+Done%21`。空格用加号符号编码，特殊字符由一个百分号后跟它们的两位十六进制值编码（因此，感叹号被编码为
    `%21`）。百分号本身会被编码为 `%25`。
- en: File uploads
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件上传
- en: 'When an HTML form includes file uploads, the browser uses a different content
    type. In this case, `Content-Type: multipart/form-data` is used. When `Content-Type:
    multipart/form-data` is used, a boundary specifier is included. This boundary
    is a special delimiter, set by the sender, which separates parts of the submitted
    form data.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '当 HTML 表单包含文件上传时，浏览器使用不同的内容类型。在这种情况下，使用 `Content-Type: multipart/form-data`。当使用
    `Content-Type: multipart/form-data` 时，包含了一个边界指定符。这个边界是一个特殊的分隔符，由发送者设置，用于分隔提交的表单数据的一部分。'
- en: 'Consider the following HTML form:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 HTML 表单：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the user navigates to a web page bearing the HTML form from the preceding
    code, and enters the name `Alice`, the comment `Well Done!`, and selects a file
    to upload called `upload.txt`, then the following HTTP `POST` request could be
    sent by the browser:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户导航到包含前面代码的 HTML 表单的网页，并输入名字 `Alice`，评论 `Well Done!`，并选择一个名为 `upload.txt`
    的文件上传，那么浏览器可能会发送以下 HTTP `POST` 请求：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, when using `multipart/form-data`, each section of data is separated
    by a boundary. This boundary is what allows the receiver to delineate between
    separate fields or uploaded files. It is important that this boundary is chosen
    so that it does not appear in any submitted field or uploaded file!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当使用 `multipart/form-data` 时，每个数据部分由一个边界分隔。这个边界是接收者区分单独字段或上传文件的关键。确保这个边界被选择，以便它不会出现在任何提交的字段或上传的文件中！
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: HTTP is the protocol that powers the modern internet. It is behind every web
    page, every link click, every graphic loaded, and every form submitted. In this
    chapter, we saw that HTTP is a text-based protocol that runs over a TCP connection.
    We learned the HTTP formats for both client requests and server responses.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是推动现代互联网的协议。它背后是每个网页、每个链接点击、每个加载的图形以及每个表单提交。在本章中，我们了解到 HTTP 是一种基于文本的协议，它运行在
    TCP 连接之上。我们学习了客户端请求和服务器响应的 HTTP 格式。
- en: In this chapter, we also implemented a simple HTTP client in C. This client
    had a few non-trivial tasks – parsing a URL, formatting a `GET` request HTTP header,
    waiting for a response, and parsing the received data out of the HTTP response.
    In particular, we looked at handling two different methods of parsing out the
    HTTP body. The first, and easiest, method was `Content-Length`, where the entire
    body length is explicitly specified. The second method was chunked encoding, where
    the body is sent as separate chunks, which our program had to delineate between.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还实现了一个简单的 C 语言 HTTP 客户端。这个客户端有几个非平凡的任务——解析 URL、格式化 `GET` 请求的 HTTP 头部、等待响应以及从
    HTTP 响应中解析接收到的数据。特别是，我们探讨了处理两种不同的解析 HTTP 体的方法。第一种，也是最简单的方法是 `Content-Length`，其中整个体的长度被明确指定。第二种方法是分块编码，其中体被发送为单独的块，我们的程序需要在它们之间进行划分。
- en: We also briefly looked at the `POST` requests and the content formats associated
    with them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要地探讨了 `POST` 请求及其相关的内容格式。
- en: In the next chapter, [Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml), *Building
    a Simple Web Server*, we will develop the counterpart to our HTTP client—an HTTP
    server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第 7 章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)，*构建简单的 Web 服务器*中，我们将开发
    HTTP 客户端的对应物——HTTP 服务器。
- en: Questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题来测试你对本章知识的掌握：
- en: Does HTTP use TCP or UDP?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 使用 TCP 还是 UDP？
- en: What types of resources can be sent over HTTP?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过 HTTP 发送哪些类型的资源？
- en: What are the common HTTP request types?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常见的 HTTP 请求类型有哪些？
- en: What HTTP request type is typically used to send data from the server to the
    client?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常使用哪种 HTTP 请求类型从服务器向客户端发送数据？
- en: What HTTP request type is typically used to send data from the client to the
    server?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常使用哪种 HTTP 请求类型从客户端向服务器发送数据？
- en: What are the two common methods used to determine an HTTP response body length?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定 HTTP 响应体长度的两种常用方法是什么？
- en: How is the HTTP request body formatted for a `POST`-type HTTP request?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何格式化 `POST` 类型的 HTTP 请求体？
- en: The answers to these questions can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以在[附录 A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题答案*中找到。
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about HTTP and HTML, please refer to the following resources:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 HTTP 和 HTML 的信息，请参阅以下资源：
- en: '**RFC 7230**: *Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing* ([https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230))'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 7230**：*超文本传输协议 (HTTP/1.1)：消息语法和路由* ([https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230))'
- en: '**RFC 7231**: *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content* ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231))'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 7231**：*超文本传输协议 (HTTP/1.1)：语义和内容* ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231))'
- en: '**RFC 1866**: *Hypertext Markup Language – 2.0* ([https://tools.ietf.org/html/rfc1866](https://tools.ietf.org/html/rfc1866))'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 1866**：*超文本标记语言 – 2.0* ([https://tools.ietf.org/html/rfc1866](https://tools.ietf.org/html/rfc1866))'
- en: '**RFC 3986**: *Uniform Resource Identifier (URI): Generic Syntax* ([https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986))'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 3986**：*统一资源标识符 (URI)：通用语法* ([https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986))'
