["```cpp\n      #include <iostream>\n      #include <string>\n      #include <string_view>\n      #include <sstream>\n      #include <algorithm>      \n\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          string a { \"a\"  };\n          auto   b ( \"b\"s );\n```", "```cpp\n          string_view c { \"c\"   };\n          auto        d ( \"d\"sv );\n```", "```cpp\n          cout << a << \", \" << b << 'n';\n          cout << c << \", \" << d << 'n';\n```", "```cpp\n          cout << a + b << 'n';\n          cout << a + string{c} << 'n';\n```", "```cpp\n          ostringstream o;\n\n          o << a << \" \" << b << \" \" << c << \" \" << d;\n          auto concatenated (o.str());\n          cout << concatenated << 'n';\n```", "```cpp\n          transform(begin(concatenated), end(concatenated), \n                    begin(concatenated), ::toupper);\n          cout << concatenated << 'n';\n      }\n```", "```cpp\n      $ ./creating_strings \n      a, b\n      c, d\n      ab\n      ac\n      a b c d\n      A B C D\n```", "```cpp\n      #include <iostream>\n      #include <string>\n      #include <algorithm>\n      #include <cctype>\n\n      using namespace std;\n```", "```cpp\n      string trim_whitespace_surrounding(const string &s)\n      {\n```", "```cpp\n          const char whitespace[] {\" tn\"};\n          const size_t first (s.find_first_not_of(whitespace));\n          if (string::npos == first) { return {}; }\n```", "```cpp\n          const size_t last (s.find_last_not_of(whitespace));\n```", "```cpp\n          return s.substr(first, (last - first + 1));\n      }\n```", "```cpp\n      int main()\n      {\n          string s {\" tn string surrounded by ugly\"\n                    \" whitespace tn \"};\n```", "```cpp\n          cout << \"{\" << s << \"}n\";\n          cout << \"{\" \n               << trim_whitespace_surrounding(s) \n               << \"}n\";\n      }\n```", "```cpp\n      $ ./trim_whitespace \n      {  \n        string surrounded by ugly whitespace    \n         }\n      {string surrounded by ugly whitespace}\n```", "```cpp\n      #include <iostream>\n      #include <string_view>\n\n      using namespace std;\n```", "```cpp\n      void print(string_view v)\n      {\n```", "```cpp\n          const auto words_begin (v.find_first_not_of(\" tn\"));\n          v.remove_prefix(min(words_begin, v.size()));\n```", "```cpp\n          const auto words_end (v.find_last_not_of(\" tn\"));\n          if (words_end != string_view::npos) {\n              v.remove_suffix(v.size() - words_end - 1);\n          }\n```", "```cpp\n          cout << \"length: \" << v.length()\n               << \" [\" << v << \"]n\";\n      }\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          print(argv[0]);\n          print({});\n          print(\"a const char * array\");\n          print(\"an std::string_view literal\"sv);\n          print(\"an std::string instance\"s);\n```", "```cpp\n          print(\" tn foobar n t \");\n```", "```cpp\n          char cstr[] {'a', 'b', 'c'};\n          print(string_view(cstr, sizeof(cstr)));\n      }\n```", "```cpp\n      $ ./string_view \n      length: 17 [./string_view]\n      length: 0 []\n      length: 20 [a const char * array]\n      length: 27 [an std::string_view literal]\n      length: 23 [an std::string instance]\n      length: 6 [foobar]\n      length: 3 [abc]\n```", "```cpp\n      #include <iostream>\n\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          cout << \"Please Enter two numbers:n> \";\n          int x;\n          double y;\n```", "```cpp\n          if (cin >> x >> y) {\n              cout << \"You entered: \" << x \n                   << \" and \" << y << 'n';\n```", "```cpp\n          } else {\n              cout << \"Oh no, that did not go well!n\";\n              cin.clear();\n              cin.ignore(\n                  std::numeric_limits<std::streamsize>::max(),\n                  'n');\n          }\n```", "```cpp\n          cout << \"now please enter some \"\n                  \"comma-separated names:n> \";\n\n          for (string s; getline(cin >> ws, s, ',');) {\n              if (s.empty()) { break; }\n              cout << \"name: \"\" << s << \"\"n\";\n          }\n      }\n```", "```cpp\n      $ ./strings_from_user_input \n      Please Enter two numbers:\n      > 1 2\n      You entered: 1 and 2\n      now please enter some comma-separated names:\n      > john doe,  ellen ripley,       alice,    chuck norris,,\n      name: \"john doe\"\n      name: \"ellen ripley\"\n      name: \"alice\"\n      name: \"chuck norris\"\n```", "```cpp\n      $ ./strings_from_user_input\n      Please Enter two numbers:\n      > a b\n      Oh no, that did not go well!\n      now please enter some comma-separated names:\n      > bud spencer, terence hill,,\n      name: \"bud spencer\"\n      name: \"terence hill\"\n```", "```cpp\nfor (string s; getline(cin >> ws, s, ',');) { ... }\n```", "```cpp\n      #include <iostream>\n      #include <fstream>\n      #include <string>\n      #include <algorithm>\n      #include <iterator>      \n\n      using namespace std;\n```", "```cpp\n      template <typename T>\n      size_t wordcount(T &is)\n      {\n          return distance(istream_iterator<string>{is}, {});\n      }\n```", "```cpp\n      int main(int argc, char **argv)\n      {\n          size_t wc;\n```", "```cpp\n          if (argc == 2) {\n              ifstream ifs {argv[1]};\n              wc = wordcount(ifs);\n```", "```cpp\n          } else {\n              wc = wordcount(cin);\n          }\n```", "```cpp\n          cout << \"There are \" << wc << \" wordsn\";\n      };\n```", "```cpp\n      $ echo \"foo bar baz\" | ./count_all_words \n      There are 3 words\n```", "```cpp\n      $ ./count_all_words count_all_words.cpp\n      There are 61 words\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <locale>      \n\n      using namespace std;\n```", "```cpp\n      void print_aligned_demo(int val, \n                              size_t width, \n                              char fill_char = ' ')\n      {\n```", "```cpp\n          cout << \"================n\";\n          cout << setfill(fill_char);\n          cout << left << setw(width) << val << 'n';\n          cout << right << setw(width) << val << 'n';\n          cout << internal << setw(width) << val << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          print_aligned_demo(123456, 15);\n          print_aligned_demo(123456, 15, '_');\n```", "```cpp\n          cout << hex << showbase;\n          print_aligned_demo(0x123abc, 15);\n```", "```cpp\n          cout << oct;\n          print_aligned_demo(0123456, 15);\n```", "```cpp\n          cout << \"A hex number with upper case letters: \"\n               << hex << uppercase << 0x123abc << 'n';\n```", "```cpp\n          cout << \"A number: \" << 100 << 'n';\n          cout << dec;\n\n          cout << \"Oops. now in decimal again: \" << 100 << 'n';\n```", "```cpp\n          cout << \"true/false values: \" \n               << true << \", \" << false << 'n';\n          cout << boolalpha\n               << \"true/false values: \"\n               << true << \", \" << false << 'n';\n```", "```cpp\n          cout << \"doubles: \"\n               << 12.3 << \", \"\n               << 12.0 << \", \"\n               << showpoint << 12.0 << 'n';\n```", "```cpp\n          cout << \"scientific double: \" << scientific \n               << 123000000000.123 << 'n';\n          cout << \"fixed      double: \" << fixed \n               << 123000000000.123 << 'n';\n```", "```cpp\n          cout << \"Very precise double: \" \n               << setprecision(10) << 0.0000000001 << 'n';\n          cout << \"Less precise double: \" \n               << setprecision(1)  << 0.0000000001 << 'n';\n      }\n```", "```cpp\n      $ ./formatting \n      ================\n      123456         \n               123456\n               123456\n      ================\n      123456_________\n      _________123456\n      _________123456\n      ================\n      0x123abc       \n             0x123abc\n      0x       123abc\n      ================\n      0123456        \n              0123456\n              0123456\n      A hex number with upper case letters: 0X123ABC\n      A number: 0X64\n      Oops. now in decimal again: 100\n      true/false values: 1, 0\n      true/false values: true, false\n      doubles: 12.3, 12, 12.0000\n      scientific double: 1.230000E+11\n      fixed      double: 123000000000.123001\n      Very precise double: 0.0000000001\n      Less precise double: 0.0\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <string>\n      #include <algorithm>\n      #include <iterator>\n      #include <vector>      \n\n      using namespace std;\n```", "```cpp\n      struct city {\n          string name;\n          size_t population;\n          double latitude;\n          double longitude;\n      };\n```", "```cpp\n      istream& operator>>(istream &is, city &c)\n      {\n          is >> ws;\n          getline(is, c.name);\n          is >> c.population \n             >> c.latitude \n             >> c.longitude;\n          return is;\n      }\n```", "```cpp\n      int main()\n      {\n          vector<city> l;\n\n          copy(istream_iterator<city>{cin}, {}, \n               back_inserter(l));\n```", "```cpp\n          for (const auto &[name, pop, lat, lon] : l) {\n              cout << left << setw(15) << name\n                   << \" population=\" << pop\n                   << \" lat=\" << lat\n                   << \" lon=\" << lon << 'n';\n          }\n      }\n```", "```cpp\n      Braunschweig\n      250000 52.268874 10.526770\n      Berlin\n      4000000 52.520007 13.404954\n      New York City\n      8406000 40.712784 -74.005941\n      Mexico City\n      8851000 19.432608 -99.133208\n```", "```cpp\n      $ cat cities.txt  | ./initialize_complex_objects\n      Braunschweig    population=250000 lat=52.2689 lon=10.5268\n      Berlin          population=4000000 lat=52.52 lon=13.405\n      New York City   population=8406000 lat=40.7128 lon=-74.0059\n      Mexico City     population=8851000 lat=19.4326 lon=-99.1332\n```", "```cpp\n      istream& operator>>(istream &is, city &c)\n      {\n          is >> ws;\n          getline(is, c.name);\n          is >> c.population >> c.latitude >> c.longitude;\n          return is;\n      }\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>\n      #include <map>\n      #include <iterator>\n      #include <algorithm>\n      #include <numeric>      \n\n      using namespace std;\n```", "```cpp\n      struct meme {\n          string description;\n          size_t year;\n      };\n```", "```cpp\n      istream& operator>>(istream &is, meme &m) {\n          return is >> quoted(m.description) >> m.year;\n      }\n```", "```cpp\n      istream& operator >>(istream &is, \n                           pair<string, meme> &p) {\n          return is >> quoted(p.first) >> p.second;\n      }\n```", "```cpp\n      int main()\n      {\n          map<string, meme> m;\n\n          copy(istream_iterator<pair<string, meme>>{cin},\n               {},\n               inserter(m, end(m)));\n```", "```cpp\n          auto max_func ([](size_t old_max, \n                            const auto &b) {\n              return max(old_max, b.first.length());\n          });\n          size_t width {accumulate(begin(m), end(m), \n                                   0u, max_func)};\n```", "```cpp\n          for (const auto &[meme_name, meme_desc] : m) {\n              const auto &[desc, year] = meme_desc;\n\n              cout << left << setw(width) << meme_name\n                   << \" : \" << desc\n                   << \", \" << year << 'n';\n          }\n      }\n```", "```cpp\n      \"Doge\" \"Very Shiba Inu. so dog. much funny. wow.\" 2013\n      \"Pepe\" \"Anthropomorphic frog\" 2016\n      \"Gabe\" \"Musical dog on maximum borkdrive\" 2016\n      \"Honey Badger\" \"Crazy nastyass honey badger\" 2011\n      \"Dramatic Chipmunk\" \"Chipmunk with a very dramatic look\" 2007\n```", "```cpp\n      $ cat memes.txt | ./filling_containers \n      Doge              : Very Shiba Inu. so dog. much funny. wow., 2013\n      Dramatic Chipmunk : Chipmunk with a very dramatic look, 2007\n      Gabe              : Musical dog on maximum borkdrive, 2016\n      Honey Badger      : Crazy nastyass honey badger, 2011\n      Pepe              : Anthropomorphic frog, 2016\n```", "```cpp\nauto max_func ([](size_t old_max, const auto &b) {\n    return max(old_max, b.first.length());\n});\n\nsize_t width {accumulate(begin(m), end(m), 0u, max_func)};\n```", "```cpp\n      #include <iostream>\n      #include <vector>\n      #include <iterator>\n      #include <unordered_map>\n      #include <algorithm>      \n\n      using namespace std;\n```", "```cpp\n      string word_num(int i) {\n```", "```cpp\n          unordered_map<int, string> m {\n              {1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n              {4, \"four\"}, {5, \"five\"}, //...\n          };\n```", "```cpp\n          const auto match (m.find(i));\n          if (match == end(m)) { return \"unknown\"; }\n          return match->second;\n      };\n```", "```cpp\n      struct bork {\n          int borks;\n\n          bork(int i) : borks{i} {}\n\n          void print(ostream& os) const {\n              fill_n(ostream_iterator<string>{os, \" \"}, \n                     borks, \"bork!\"s);\n          }\n      };\n```", "```cpp\n      ostream& operator<<(ostream &os, const bork &b) {\n          b.print(os);\n          return os;\n      }\n```", "```cpp\n      int main()\n      {\n          const vector<int> v {1, 2, 3, 4, 5};\n```", "```cpp\n          ostream_iterator<int> oit {cout};\n\n          for (int i : v) { *oit = i; }\n          cout << 'n';\n```", "```cpp\n          ostream_iterator<int> oit_comma {cout, \", \"};\n\n          for (int i : v) { *oit_comma = i; }\n          cout << 'n';\n```", "```cpp\n          copy(begin(v), end(v), oit);\n          cout << 'n';\n\n          copy(begin(v), end(v), oit_comma);\n          cout << 'n';\n```", "```cpp\n          transform(begin(v), end(v), \n                    ostream_iterator<string>{cout, \" \"}, \n                    word_num);\n          cout << 'n';\n```", "```cpp\n          copy(begin(v), end(v), \n               ostream_iterator<bork>{cout, \"n\"});\n      }\n```", "```cpp\n      $ ./ostream_printing \n      12345\n      1, 2, 3, 4, 5, \n      12345\n      1, 2, 3, 4, 5, \n      one two three four five \n      bork! \n      bork! bork! \n      bork! bork! bork! \n      bork! bork! bork! bork! \n      bork! bork! bork! bork! bork! \n```", "```cpp\n      #include <iostream>\n      #include <fstream>     \n\n      using namespace std;\n```", "```cpp\n      class redirect_cout_region\n      {\n          using buftype = decltype(cout.rdbuf());\n\n          ofstream ofs;\n          buftype  buf_backup;\n```", "```cpp\n      public:\n          explicit \n          redirect_cout_region (const string &filename)\n              : ofs{filename}, \n                buf_backup{cout.rdbuf(ofs.rdbuf())}\n          {}\n```", "```cpp\n          redirect_cout_region()\n              : ofs{}, \n                buf_backup{cout.rdbuf(ofs.rdbuf())}\n          {}\n```", "```cpp\n          ~redirect_cout_region() { \n              cout.rdbuf(buf_backup); \n          }\n      };\n```", "```cpp\n      void my_output_heavy_function()\n      {\n          cout << \"some outputn\";\n          cout << \"this function does really heavy workn\";\n          cout << \"... and lots of it...n\";\n          // ...\n      }\n```", "```cpp\n      int main()\n      {\n          cout << \"Readable from normal stdoutn\";\n```", "```cpp\n          {\n              redirect_cout_region _ {\"output.txt\"};\n              cout << \"Only visible in output.txtn\";\n              my_output_heavy_function();\n          }\n```", "```cpp\n          {\n              redirect_cout_region _;\n              cout << \"This output will \"\n                      \"completely vanishn\";\n          }\n```", "```cpp\n          cout << \"Readable from normal stdout againn\";\n      }\n```", "```cpp\n      $ ./log_regions \n      Readable from normal stdout\n      Readable from normal stdout again\n```", "```cpp\n      $ cat output.txt \n      Only visible in output.txt\n      some output\n      this function does really heavy work\n      ... and lots of it...\n```", "```cpp\n{\n    cout << \"print to standard outputn\";\n\n    redirect_cout_region la {\"a.txt\"};\n    cout << \"print to a.txtn\";\n\n    redirect_cout_region lb {\"b.txt\"};\n    cout << \"print to b.txtn\";\n}\ncout << \"print to standard output againn\";\n```", "```cpp\nclass redirect_cout_region {\n    using buftype = decltype(cout.rdbuf());\n\n    ofstream ofs;\n    buftype  buf_backup;\n\npublic:\n    explicit \n    redirect_cout_region(const string &filename)\n        : ofs{filename}, \n          buf_backup{cout.rdbuf(ofs.rdbuf())}\n    {}\n\n...\n```", "```cpp\n      #include <iostream>\n      #include <algorithm>\n      #include <string>      \n\n      using namespace std;\n```", "```cpp\n      static constexpr char tolow(char c) {\n          switch (c) {\n          case 'A'...'Z': return c - 'A' + 'a';\n          default:        return c;\n          }\n      }\n```", "```cpp\n      class lc_traits : public char_traits<char> {\n      public:\n```", "```cpp\n          static constexpr \n          void assign(char_type& r, const char_type& a ) {\n              r = tolow(a);\n          }\n```", "```cpp\n          static char_type* copy(char_type* dest, \n                                 const char_type* src, \n                                 size_t count) {\n              transform(src, src + count, dest, tolow);\n              return dest;\n          }\n      };\n```", "```cpp\n      class ci_traits : public char_traits<char> {\n      public:\n```", "```cpp\n          static constexpr bool eq(char_type a, char_type b) {\n              return tolow(a) == tolow(b);\n          }\n```", "```cpp\n          static constexpr bool lt(char_type a, char_type b) {\n              return tolow(a) < tolow(b);\n          }\n```", "```cpp\n          static constexpr int compare(const char_type* s1,\n                                       const char_type* s2,\n                                       size_t count) {\n              for (; count; ++s1, ++s2, --count) {\n                  const char_type diff (tolow(*s1) - tolow(*s2));\n                  if      (diff < 0) { return -1; }\n                  else if (diff > 0) { return +1; }\n              }\n              return 0;\n          }\n```", "```cpp\n          static constexpr \n          const char_type* find(const char_type* p,\n                                size_t count,\n                                const char_type& ch) {\n              const char_type find_c {tolow(ch)};\n\n              for (; count != 0; --count, ++p) {\n                  if (find_c == tolow(*p)) { return p; }\n              }\n\n              return nullptr;\n          }\n      };\n```", "```cpp\n      using lc_string = basic_string<char, lc_traits>;\n      using ci_string = basic_string<char, ci_traits>;\n```", "```cpp\n      ostream& operator<<(ostream& os, const lc_string& str) {\n          return os.write(str.data(), str.size());\n      }\n\n      ostream& operator<<(ostream& os, const ci_string& str) {\n          return os.write(str.data(), str.size());\n      }\n```", "```cpp\n      int main()\n      {\n          cout << \"   string: \" \n               << string{\"Foo Bar Baz\"} << 'n'\n               << \"lc_string: \" \n               << lc_string{\"Foo Bar Baz\"} << 'n'\n               << \"ci_string: \"\n               << ci_string{\"Foo Bar Baz\"} << 'n';\n```", "```cpp\n          ci_string user_input {\"MaGiC PaSsWoRd!\"};\n          ci_string password   {\"magic password!\"};\n```", "```cpp\n          if (user_input == password) {\n              cout << \"Passwords match: \"\" << user_input\n                   << \"\" == \"\" << password << \"\"n\";\n          }\n      }\n```", "```cpp\n      $ ./custom_string \n         string: Foo Bar Baz\n      lc_string: foo bar baz\n      ci_string: Foo Bar Baz\n      Passwords match: \"MaGiC PaSsWoRd!\" == \"magic password!\"\n```", "```cpp\ntemplate <\n    class CharT, \n    class Traits    = std::char_traits<CharT>, \n    class Allocator = std::allocator<CharT>\n    > \nclass basic_string;\n```", "```cpp\n      #include <iostream>\n      #include <iterator>\n      #include <regex>\n      #include <algorithm>\n      #include <iomanip>      \n\n      using namespace std;\n```", "```cpp\n      template <typename InputIt>\n      void print(InputIt it, InputIt end_it)\n      {\n          while (it != end_it) {\n```", "```cpp\n              const string link {*it++};\n              if (it == end_it) { break; }\n              const string desc {*it++};\n```", "```cpp\n              cout << left << setw(28) << desc \n                   << \" : \" << link << 'n';\n          }\n      }\n```", "```cpp\n      int main()\n      {\n          cin >> noskipws;\n          const std::string in {istream_iterator<char>{cin}, {}};\n```", "```cpp\n          const regex link_re {\n              \"<a href=\"([^\"]*)\"[^<]*>([^<]*)</a>\"};\n```", "```cpp\n          sregex_token_iterator it {\n              begin(in), end(in), link_re, {1, 2}};\n```", "```cpp\n          print(it, {});\n      }\n```", "```cpp\n      $ curl -s \"https://isocpp.org/blog\" | ./link_extraction \n      Sign In / Suggest an Article : https://isocpp.org/member/login\n      Register                     : https://isocpp.org/member/register\n      Get Started!                 : https://isocpp.org/get-started\n      Tour                         : https://isocpp.org/tour\n      C++ Super-FAQ                : https://isocpp.org/faq\n      Blog                         : https://isocpp.org/blog\n      Forums                       : https://isocpp.org/forums\n      Standardization              : https://isocpp.org/std\n      About                        : https://isocpp.org/about\n      Current ISO C++ status       : https://isocpp.org/std/status\n      (...and many more...)\n```", "```cpp\nsregex_token_iterator it {begin(in), end(in), link_re, {1, 2}};\n```", "```cpp\nconst string s {\" abc abbccc \"};\nconst regex re {\"a(b*)(c*)\"};\n\nsregex_token_iterator it {begin(s), end(s), re, {1, 2}};\n\nprint( *it ); // prints b\n++it;\nprint( *it ); // prints c\n++it;\nprint( *it ); // prints bb\n++it;\nprint( *it ); // prints ccc\n```", "```cpp\n      #include <iostream>\n      #include <iomanip>      \n\n      using namespace std;\n```", "```cpp\n      class format_guard {\n          decltype(cout.flags()) f {cout.flags()};\n\n      public:\n          ~format_guard() { cout.flags(f); }\n      };\n```", "```cpp\n      template <typename T>\n      struct scientific_type {\n          T value;\n\n          explicit scientific_type(T val) : value{val} {}\n      };\n```", "```cpp\n      template <typename T>\n      ostream& operator<<(ostream &os, const scientific_type<T> &w) {\n          format_guard _;\n          os << scientific << uppercase << showpos;\n          return os << w.value;\n      }\n```", "```cpp\n      int main()\n      {\n          {\n              format_guard _;\n              cout << hex << scientific << showbase << uppercase;\n\n              cout << \"Numbers with special formatting:n\";\n              cout << 0x123abc << 'n';\n              cout << 0.123456789 << 'n';\n          }\n```", "```cpp\n          cout << \"Same numbers, but normal formatting again:n\";\n          cout << 0x123abc << 'n';\n          cout << 0.123456789 << 'n';\n```", "```cpp\n          cout << \"Mixed formatting: \"\n               << 123.0 << \" \"\n               << scientific_type{123.0} << \" \"\n               << 123.456 << 'n';\n      }\n```", "```cpp\n      $ ./pretty_print_on_the_fly \n      Numbers with special formatting:\n      0X123ABC\n      1.234568E-01\n      Same numbers, but normal formatting again:\n      1194684\n      0.123457\n      Mixed formatting: 123 +1.230000E+02 123.456\n```", "```cpp\n      #include <iostream>\n      #include <fstream>\n      #include <system_error>\n      #include <cstring>      \n\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          ifstream f;\n          f.exceptions(f.failbit | f.badbit);\n```", "```cpp\n          try {\n              f.open(\"non_existant.txt\");\n\n              int i;\n              f >> i;\n\n              cout << \"integer has value: \" << i << 'n';\n          }\n```", "```cpp\n          catch (ios_base::failure& e) {\n              cerr << \"Caught error: \";\n              if (errno) {\n                  cerr << strerror(errno) << 'n';\n              } else {\n                  cerr << e.what() << 'n';\n              }\n          }\n      }\n```", "```cpp\n      $ ./readable_error_msg \n      Caught error: ios_base::clear: unspecified iostream_category error\n```", "```cpp\n      $ ./readable_error_msg\n      Caught error: No such file or directory\n```", "```cpp\nifstream f {\"non_existant.txt\"};\nf.exceptions(...); // too late for an exception\n\n```"]