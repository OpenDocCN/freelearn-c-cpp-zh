- en: Machines Talking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器对话
- en: Machine automation and IoT use various APIs for communication with each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 机器自动化和物联网使用各种API进行相互通信。
- en: I like to say that you cannot have IoT without sensors. They truly define IoT.
    Sensors are everywhere these days. Cars, lights, and mobile phones all have a
    myriad of sensors. Laptop computers have led, light, touch, and proximity sensors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢说，没有传感器就无法实现物联网。它们真正定义了物联网。如今，传感器无处不在。汽车、灯光和移动电话都有无数的传感器。笔记本电脑有亮度、光线、触摸和接近传感器。
- en: MQTT and WebSockets are communication and messaging protocols. One use of them
    is to send sensors to remote locations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT和WebSockets是通信和消息协议。它们的一个用途是将传感器发送到远程位置。
- en: You will learn about using Qt APIs for machine-to-machine automation and communication
    to web applications using the `QWebSocket` and `QWebSocketServer` classes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何使用Qt API进行机器到机器的自动化和通信，使用`QWebSocket`和`QWebSocketServer`类与Web应用程序进行通信。
- en: MQTT is a publish-and-subscribe-based TCP/IP protocol for sending sensor data
    over a limited bandwidth network using `QMqttMessage` to a `QMqttClient` and `QMqttSubscription`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是基于发布和订阅的TCP/IP协议，用于通过`QMqttMessage`将传感器数据发送到有限带宽网络中的`QMqttClient`和`QMqttSubscription`。
- en: 'We will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: '**Sensory control **- QtSensor data'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**感官控制** – QtSensor数据'
- en: '**WebSockets **- Bi-directional web communication'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSockets** - 双向Web通信'
- en: '**QMqtt **- Brokers of machine talk'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QMqtt** - 机器对话的代理'
- en: Sensory control – QtSensor data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感官控制 – QtSensor数据
- en: The Qt Sensors API started with Qt Mobility, which itself grew from Qtopia,
    which was later renamed Qt Extended.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Sensors API始于Qt Mobility，Qt Mobility本身又源于Qtopia，后来更名为Qt Extended。
- en: Qt Mobility was a collection of APIs useful for mobile and embedded devices.
    It was intended specifically for use in Nokia phones. Some of the Mobility API
    was integrated into Qt 4 and later into Qt 5.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Mobility是一组适用于移动和嵌入式设备的API集合。它专门用于诺基亚手机。一些Mobility API已集成到Qt 4，后来集成到Qt 5。
- en: Qt Sensors, on the other hand, was put into its own repository when Qt 5 split
    into modules. Qt Sensors started out targeting mobile phone platforms, but as
    computers, such as laptops and Raspberry Pis, gained sensors, the backends expanded.
    You can find backends for iOS, Android, WinRT, generic Linux, Sensorfw, as well
    as Texas Instrument's SensorTag. At my GitHub repository, you can find additional
    sensor backends for Raspberry Pi Sense HAT, and MATRIX Creator for Raspberry Pi.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，当Qt 5拆分为模块时，Qt Sensors被放入了自己的仓库。Qt Sensors最初针对的是移动电话平台，但随着笔记本电脑和树莓派等计算机获得了传感器，后端得到了扩展。你可以找到iOS、Android、WinRT、通用Linux、Sensorfw以及德州仪器的SensorTag的后端。在我的GitHub仓库中，你可以找到Raspberry
    Pi Sense HAT和Raspberry Pi的MATRIX Creator的附加传感器后端。
- en: '**Sensor Framework** (**SensorFW**) is a framework and backend for configuring
    and reading sensor data in a variety of ways. It is tried, tested, and used on
    some of the best alternative mobile devices. It has support for Hybris (which
    is used in Sailfish OS), Linux IIO sensors, as well as for reading directly from
    the Linux filesystem. If you are integrating a new device and need to read various
    sensors, I recommend using Sensor Framework, available from [https://git.merproject.org/mer-core/sensorfw/](https://git.merproject.org/mer-core/sensorfw/)[. ](https://git.merproject.org/mer-core/sensorfw/)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**传感器框架**（**SensorFW**）是一个用于以多种方式配置和读取传感器数据的框架和后端。它已在一些最好的替代移动设备上经过测试和验证。它支持Hybris（用于Sailfish
    OS），Linux IIO传感器，以及直接从Linux文件系统中读取。如果你正在集成新设备并需要读取各种传感器，我建议使用Sensor Framework，可在[https://git.merproject.org/mer-core/sensorfw/](https://git.merproject.org/mer-core/sensorfw/)找到[. ](https://git.merproject.org/mer-core/sensorfw/)'
- en: There are dozens of different sensors for monitoring the environment. Qt Sensors
    handles the most common sensors found in mobile phones and tablets, and provides
    tools to help implement new sensor types that may be developed and become popular.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种不同的传感器用于监控环境。Qt Sensors处理在移动电话和平板电脑中最常见的传感器，并提供工具以帮助实现可能开发并变得流行的新的传感器类型。
- en: Not only are sensors for monitoring the environment; they can also be used as
    an input to the system. The Qt Sensor API includes an ad-hoc `QSensorGestures`,
    which is an API for various device gestures, such as shake, free-fall, hover,
    cover, turnover, and pickup.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅用于监控环境的传感器可以用作系统的输入。Qt Sensor API包括一个临时的`QSensorGestures`，这是一个用于各种设备手势的API，如摇晃、自由落体、悬停、覆盖、翻转和拾取。
- en: Qt Sensors has the C++ and QML APIs. Let's start with the C++ API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Sensors具有C++和QML API。让我们从C++ API开始。
- en: There are actually three ways to use this API. The first is the generic way.
    All the sensor classes are derived from `QSensor`. A more generic way to use them
    is to just use `QSensor`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有三种使用此 API 的方法。第一种是通用方式。所有传感器类都是 `QSensor` 的派生类。使用它们的一个更通用的方式是直接使用 `QSensor`。
- en: QSensor
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`QSensor`'
- en: '`QSensor` has two static functions that we can use. `QSensor::sensorTypes()` which
    returns a `QList` of sensor types; for example, it could be `QLightSensor` or
    `QOrientationSensor`. You can then use `QSensor::sensorForType` or `defaultSensorForType`.
    Usually there is only one sensor for a type, so, using the latter will suffice.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSensor` 有两个静态函数我们可以使用。`QSensor::sensorTypes()` 返回一个传感器类型的 `QList`；例如，它可能是
    `QLightSensor` 或 `QOrientationSensor`。然后你可以使用 `QSensor::sensorForType` 或 `defaultSensorForType`。通常一个类型只有一个传感器，所以，使用后者就足够了。'
- en: 'But first, we need to tell `qmake` that we want to use the `sensors` module,
    so in the `.pro` file, do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要告诉 `qmake` 我们想要使用 `sensors` 模块，因此，在 `.pro` 文件中，执行以下操作：
- en: The source code can be found on the Git repository under the `Chapter07-1` directory,
    in the `cp7` branch.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter07-1` 目录下的 `cp7` 分支中找到。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To include all `QSensors` headers, the include file line is `#include <QtSensors>`,
    so let's add this to our file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含所有 `QSensors` 头文件，包含文件行是 `#include <QtSensors>`，因此让我们将其添加到我们的文件中。
- en: 'Get a list of all sensor types known to the system by using `QSensor::sensorTypes()`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `QSensor::sensorTypes()` 获取系统已知的所有传感器类型列表：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`QSensor` is created by supplying a `QSensor::type` argument, and then you
    call the `setIdentifier` function with a `String` indicating the sensor you want
    to use.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSensor` 是通过提供一个 `QSensor::type` 参数创建的，然后你调用 `setIdentifier` 函数，使用一个 `String`
    指示你想要使用的传感器。'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now have a `QSensor`. You must then call `connectToBackend()` if you are
    using `QSensor` directly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个 `QSensor`。如果你直接使用 `QSensor`，那么你必须调用 `connectToBackend()`：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can then connect to the `readingChanged()` signal and read the values from
    there. To get the `QSensor`, you can use the `sender()` function in any slot,
    and then `qobject_cast` to cast to a `QSensor`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以连接到 `readingChanged()` 信号并从那里读取值。要获取 `QSensor`，你可以在任何槽中使用 `sender()` 函数，然后使用
    `qobject_cast` 来转换到 `QSensor`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `readingChanged()` slot looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`readingChanged()` 槽看起来像这样：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We cast the `QSensor` using the `sender()` function, which returns the object
    that the slot is connected to. We then use that to get the `QSensorReading` using
    the `reading()` function. From the reading, we can get the values the sensor signaled
    to us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `sender()` 函数将 `QSensor` 进行转换，该函数返回槽连接到的对象。然后我们使用它通过 `reading()` 函数获取 `QSensorReading`。从读取中，我们可以获取传感器向我们发出的值。
- en: We still need to call `start()` on the sensor, so we will add this somewhere
    after we connect to the `readingChanged()` signal. This will activate the sensor's backend
    and start reading data from the device.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在传感器上调用 `start()`，因此我们将在连接到 `readingChanged()` 信号之后将其添加到某个地方。这将激活传感器的后端并开始从设备读取数据。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is another way to access a sensor, and that is by using a `QSensor` subclass.
    Let''s have a look at how we will use `QSensor` as a subclass:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 访问传感器的另一种方式是使用 `QSensor` 子类。让我们看看我们将如何使用 `QSensor` 作为子类：
- en: The QSensor subclass
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`QSensor` 子类'
- en: 'A more popular way to use Qt Sensors is to use the standard `QSensors` derived
    classes, such as `QLightSensor` or `QAccelerometer`. This is useful if you know
    exactly which sensors your device has or what you are going to use. It also reduces
    the need for type-casting. In this way, it is also easier to use a class''s sensor-specific
    properties:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt Sensors 的更流行的方式是使用标准 `QSensors` 派生类，例如 `QLightSensor` 或 `QAccelerometer`。如果你确切知道你的设备有哪些传感器或你打算使用什么，这很有用。它还减少了类型转换的需要。以这种方式，它也更容易使用类的特定于传感器的属性：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead of a generic `QSensorReading`, we get a sensor specific reading, `QLightReading`
    in this case, with a sensor-specific value accessor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用的 `QSensorReading` 不同，我们得到一个特定于传感器的读取，例如 `QLightReading`，以及一个特定于传感器的值访问器：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another way to access sensor data is to use a `QSensorFilter`. Let's go there.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 访问传感器数据的另一种方式是使用 `QSensorFilter`。让我们看看那里。
- en: QSensorFilter
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`QSensorFilter`'
- en: There is a third way to access sensor data in C++, which is to use the sensor-specific
    filter class. This provides an efficient callback when signals and slots might
    be too slow, as in the case of `QAccelerometer` and other motion sensors which
    might be running at 200 cycles per second. It also provides a way to apply one
    or more filters that affect the values before they get emitted by the sensor reading
    signals. You could provide additional smoothing and noise reduction, or amplify
    the signal to a greater range.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中访问传感器数据还有第三种方法，即使用传感器特定的过滤器类。当信号和槽可能太慢时，这提供了一种有效的回调，例如在`QAccelerometer`和其他可能以每秒200次周期运行的动态传感器的情况下。它还提供了一种在传感器读取信号发出之前应用一个或多个影响值的过滤器的方式。您可以提供额外的平滑和噪声减少，或者放大信号到一个更大的范围。
- en: In our case, our class would inherit from `QLightFilter`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们的类将继承自`QLightFilter`。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We then implement the filter override.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着实现过滤器覆盖。
- en: 'If the `filter` function returns `true`, it will store the `QLightReading`
    of the `QLightSensor` and the new values will be emitted by, in our case, the
    `QLightSensor` class. Let''s apply a simple moving-average filter to our light
    sensor data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`filter`函数返回`true`，它将存储`QLightSensor`的`QLightReading`，并且新值将由我们的`QLightSensor`类发出。让我们对我们的光传感器数据应用一个简单的移动平均滤波器：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can then create a new `LightFilter` object and set `QLightSensor` to use
    it. Add this before the call to `start()`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个新的`LightFilter`对象，并将`QLightSensor`设置为使用它。在调用`start()`之前添加此代码：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now let's find out about the `QSensor` data and how to access it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解一下`QSensor`数据以及如何访问它。
- en: QSensor data
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSensor数据
- en: '`QSensor` has values that are specific to the respective sensor. You can access
    them either generically with `QSensor`, or by sensor value.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSensor`具有各自传感器特有的值。您可以通过`QSensor`以通用方式访问它们，或者通过传感器值访问。'
- en: QSensorReading
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSensorReading
- en: 'If you are using the more generic `QSensor` class, there is a corresponding
    `QSensorReading` that you can use to retrieve the generic data. For getting any
    sensor-specific data you will need to use the corresponding sensors'' `QSensorReading`
    subclass, such as `QAccelerometerReading`. For example, if we are using the `QSensor`
    to grab accelerometer data, we could do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用更通用的`QSensor`类，则有一个相应的`QSensorReading`类，您可以使用它来检索通用数据。对于获取任何特定传感器数据，您需要使用相应的传感器`QSensorReading`子类，例如`QAccelerometerReading`。例如，如果我们使用`QSensor`来获取加速度计数据，我们可以这样做：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, using the `QAccelerometer` and `QAccelerometerReading` classes to do
    the same thing, would look like this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`QAccelerometer`和`QAccelerometerReading`类做同样的事情，看起来是这样的。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are some data explanations for common sensors:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见传感器的数据解释：
- en: '| **Sensor reading** | **Values** | **Unit** | **Description** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **传感器读取** | **值** | **单位** | **描述** |'
- en: '| `QAccelerometerReading` | `x`, `y`, `z` | ms², meters per second squared
    | Linear acceleration along x, y, z axis |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `QAccelerometerReading` | `x`, `y`, `z` | m²/s², 米每平方秒 | 沿x、y、z轴的线性加速度 |'
- en: '| `QAltimeterReading` | `altitude` | Meters | Meters above average sea level
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `QAltimeterReading` | `altitude` | 米 | 海拔高度 |'
- en: '| `QAmbientLightReading` | `lightLevel` | Dark, Twilight, Light, Bright, Sunny
    | General light level |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `QAmbientLightReading` | `lightLevel` | Dark, Twilight, Light, Bright, Sunny
    | 一般光级 |'
- en: '| `QAmbientTemperatureReading` | `temperature` | Celsius | Degrees Celsius
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `QAmbientTemperatureReading` | `temperature` | 摄氏度 | 摄氏度 |'
- en: '| `QCompassReading` | `azimuth` | Degrees | Degrees from magnetic north |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `QCompassReading` | `azimuth` | 度 | 从磁北方向的角度 |'
- en: '| `QGyroscopeReading` | `x`, `y`, `z` | Degrees per second | Angular velocity
    around the axis |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `QGyroscopeReading` | `x`, `y`, `z` | 每秒度 | 绕轴的角速度 |'
- en: '| `QHumidityReading` | `absoluteHumidity`,`relativeHumidty` | gm³, grams per
    cubic meter | Water vapor in air |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `QHumidityReading` | `absoluteHumidity`,`relativeHumidty` | g/m³, 克每立方米 |
    空气中的水蒸气 |'
- en: '| `QIrProximityReading` | `reflectance` | Decimal fraction 0 - 1 | How much
    infrared light was returned |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `QIrProximityReading` | `reflectance` | 十进制分数 0 - 1 | 反射回来的红外光量 |'
- en: '| `QLidReading` | `backLidClosed`,`frontLidClosed` | Bool | Laptop lid |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `QLidReading` | `backLidClosed`,`frontLidClosed` | 布尔值 | 笔记本电脑盖 |'
- en: '| `QLightReading` | `lux` | Lux | Light measured in lux |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `QLightReading` | `lux` | Lux | 以勒克斯为单位测量的光 |'
- en: '| `QMagnetometerReading` | `x`, `y`, `z` |  Magnetic flux density | Raw flux
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `QMagnetometerReading` | `x`, `y`, `z` | 磁通密度 | 原始磁通 |'
- en: '| `QOrientationReading` | `orientation` | TopUp, TopDown, LeftUp, RightUp,
    FaceUp, FaceDown | Enum device orientation |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `QOrientationReading` | `orientation` | TopUp, TopDown, LeftUp, RightUp,
    FaceUp, FaceDown | 枚举设备方向 |'
- en: '| `QPressureReading` | `pressure`, `temperature` | Pascals, Celsius | Atmospheric
    pressure |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `QPressureReading` | `pressure`, `temperature` | 帕斯卡，摄氏度 | 大气压力 |'
- en: '| `QProximityReading` | `close` | Bool | Close or far away |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `QProximityReading` | `close` | 布尔值 | 靠近或远离 |'
- en: '| `QRotationReading` | `x`, `y`, `z` | Degrees | Rotation around axis in degrees
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `QRotationReading` | `x`, `y`, `z` | 度 | 绕轴旋转的度数 |'
- en: Some of these have sensor-specific readings, such as `QCompass` and `QMagnetometer`—both
    contain calibration levels.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些传感器具有特定的读数，例如`QCompass`和`QMagnetometer`——两者都包含校准级别。
- en: Of course, C++ is not the only way to implement Qt's sensors; you can use them
    in QML as well. Let's find out how.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，C++不是实现Qt传感器的唯一方式；你同样可以在QML中使用它们。让我们来看看如何实现。
- en: QML sensors
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML传感器
- en: 'Of course, you can also use Qt Sensors from QML. In a lot of ways, it is easier
    to implement them this way, as the Qt Quick API has been optimized and simplified,
    so it takes less time to get the sensor up and running. Following our previous
    use of the light sensors, we will continue here. First off is the ever-present
    `import` statement: instead of calling a `start()` function to get it rolling,
    there is an `active` property. Instead of a `Lux` value, the property is `illuminance`.
    Not quite sure why there''s a difference, but there you go:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以从QML中使用Qt Sensors。在许多方面，这种方式实现起来更简单，因为Qt Quick API已经被优化和简化，因此启动传感器所需的时间更少。继我们之前对光传感器的使用之后，我们将继续这样做。首先是一个始终存在的`import`语句：不是通过调用一个`start()`函数来启动，而是一个`active`属性。不是`Lux`值，属性是`illuminance`。不确定为什么有这种差异，但就是这样：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It cannot get much simpler than that. `QtSensors` QML has no filter, so if you
    need to filter anything, you will have to use C++.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经非常简单了。`QtSensors` QML没有过滤器，所以如果你需要过滤任何内容，你将不得不使用C++。
- en: Custom QSensor and the backend engine
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义QSensor和后端引擎
- en: I want to briefly touch on how to create a custom sensor and engine backend.
    If you are on an embedded device, Qt Sensors may not have support for your sensor
    if it is a moisture or an air-quality sensor. You would need to implement your
    own `QSensor` and `QSensorBackend` engine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我想简要地谈谈如何创建自定义传感器和引擎后端。如果你在一个嵌入式设备上，Qt Sensors可能不支持你的传感器，如果它是一个湿度或空气质量传感器。你需要实现自己的`QSensor`和`QSensorBackend`引擎。
- en: There is a script in the directory, `src/sensors/make_sensor.pl`, that you can
    run which will generate a simple `QSensor` derived class, but additionally this
    script will generate Qt Quick classes that derive from `QmlSensor` . The `make_sensor.pl` script
    needs to be run from the `src/sensors` directory. For this exercise, we are going
    to create a sensor for monitoring salt concentrations in our saltwater swimming
    pool, so the name will be `QSaltSensor`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录中有一个脚本`src/sensors/make_sensor.pl`，你可以运行它来生成一个简单的`QSensor`派生类，但此脚本还会生成从`QmlSensor`派生的Qt
    Quick类。`make_sensor.pl`脚本需要从`src/sensors`目录中运行。在这个练习中，我们将创建一个用于监测盐水游泳池中盐浓度的传感器，因此其名称将是`QSaltSensor`。
- en: You can then open these files in an editor, such as Qt Creator, and add what
    you need. Having a new `QSensor` type will also require a new backend that reads
    from the sensor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开这些文件在一个编辑器中，例如Qt Creator，并添加你需要的内容。拥有一个新的`QSensor`类型也将需要一个从传感器读取的新后端。
- en: Custom QSensor
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义QSensor
- en: There is a helper script named `QtSensors/src/sensors/make_sensor.pl`, which
    will create a basic template for a new `QSensor`, `QSensorReading`. It generates
    a simple `QSensor` derived class, but also classes for `QmlSensor` derived classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`QtSensors/src/sensors/make_sensor.pl`的辅助脚本，它将为新的`QSensor`和`QSensorReading`创建一个基本模板。它生成一个简单的`QSensor`派生类，同时也为`QmlSensor`派生类生成类。
- en: If you do not have it in your source directory, it can be found in the Git repository
    at [https://code.qt.io/cgit/qt/qtsensors.git/tree/src/sensors/make_sensor.pl](https://code.qt.io/cgit/qt/qtsensors.git/tree/src/sensors/make_sensor.pl).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的源目录中没有，它可以在Git仓库中找到，网址为[https://code.qt.io/cgit/qt/qtsensors.git/tree/src/sensors/make_sensor.pl](https://code.qt.io/cgit/qt/qtsensors.git/tree/src/sensors/make_sensor.pl)。
- en: The `make_sensor.pl` script needs to be run from the `src/sensors` directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_sensor.pl`脚本需要从`src/sensors`目录中运行。'
- en: You will have to edit the resulting files and fill in a thing. For this example,
    I chose `QSaltSensor` as a class name. Execute the script with the class name
    as the first argument: `make_sensor.pl QSaltSensor`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要编辑生成的文件并填写一些内容。在这个例子中，我选择了`QSaltSensor`作为类名。使用类名作为第一个参数执行脚本：`make_sensor.pl
    QSaltSensor`。
- en: 'It creates the following files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它会创建以下文件：
- en: '`<sensorname>.h`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sensorname>.h`'
- en: '`<sensorname>.cpp`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sensorname>.cpp`'
- en: '`<sensorname>_p.h`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sensorname>_p.h`'
- en: '`imports/sensors/<sensorname>.h`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports/sensors/<sensorname>.h`'
- en: '`imports/sensors/<sensorname>.cpp`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports/sensors/<sensorname>.cpp`'
- en: 'The output of using the `make_sensor.pl` command will appear like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make_sensor.pl`命令的输出将如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Like the output says, you will need to add `qsaltsensor` to the `src/sensors.pro`
    file to the `SENSORS` variable that is used there. Add the `qmlsaltsensor` filepaths
    in the file, `src/imports/sensors/sensors.pro`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，你需要将`qsaltsensor`添加到`src/sensors.pro`文件中的`SENSORS`变量中。在文件`src/imports/sensors/sensors.pro`中添加`qmlsaltsensor`的文件路径。
- en: Start by editing `qsaltsensor.cpp`, which is the class we will use as our `QSensorBackend`.
    The `perl` script we used to create the template has added comments where you
    should edit to customize. You will also need to add any properties.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑`qsaltsensor.cpp`，这是我们用作`QSensorBackend`的类。我们用来创建模板的`perl`脚本已经添加了注释，你应该在这里编辑以进行自定义。你还需要添加任何属性。
- en: Custom QSensorBackend
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义QSensorBackend
- en: There are many reasons why you might want to implement your own sensor backend.
    One of these might be if you have a new type of sensor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有很多原因想要实现自己的传感器后端。其中一个可能是因为你有一种新的传感器类型。
- en: 'You would need to start implementing a backend engine for your new `QSensor`
    type. Begin by deriving from `QSensorBackend`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要开始实现你新的`QSensor`类型的后端引擎。首先，从`QSensorBackend`派生：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The class `QSensorBackend`, has two pure virtual functions you need to implement: `start()`
    and `stop()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类`QSensorBackend`有两个纯虚函数需要实现：`start()`和`stop()`：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The source code can be found on the Git repository under the `Chapter07-2` directory,
    in the `cp7` branch.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter07-2`目录下的`cp7`分支中找到。
- en: Implementing the backend functionality is up to you, based on if you have a
    salt sensor device you want to use. Of course you will have to compile and deploy
    your own Qt Sensors when you do so.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现后端功能取决于你是否有想要使用的盐传感器设备。当然，当你这样做时，你将不得不编译和部署自己的Qt Sensors。
- en: For more information about custom `QSensors` and the backend, look at the Grue
    sensor example in Qt sensors. There is some rather amusing documentation on how
    to implement a custom sensor at [https://doc.qt.io/qt-5/qtsensors-grue-example.html](https://doc.qt.io/qt-5/qtsensors-grue-example.html)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于自定义`QSensors`和后端的信息，请查看Qt传感器的Grue传感器示例。有关如何实现自定义传感器的文档可以在[https://doc.qt.io/qt-5/qtsensors-grue-example.html](https://doc.qt.io/qt-5/qtsensors-grue-example.html)找到。
- en: Sometimes there are more than one sensor plugin on a system for any sensor.
    In this case we will need to tell the system which sensor to use. Let's look at
    how to configure `QSensors`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个系统上可能会有多个传感器插件，针对任何传感器都可能有多个。在这种情况下，我们需要告诉系统使用哪个传感器。让我们看看如何配置`QSensors`。
- en: Sensors.conf
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sensors.conf
- en: If there is more than one backend for a particular sensor, you might need to
    specify which is the default.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特定传感器有多个后端，你可能需要指定哪个是默认的。
- en: 'You can add `qsaltsensor` to the `Sensors.conf` configuration file so the system
    can determine which sensor type is the default for a certain sensor. Of course,
    developers are free to choose whichever registered sensor on the system they want
    to use. The config file''s format is `SensorType = sensor.id`, where `SensorType`
    is the base sensor class name, such as `QLightSensor`, and `sensor.id` is a `String`
    identifier for the specific sensor backend. The following code uses our `saltsensor`
    from the Linux backend and the list sensor from the `sensorfw` backend:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`qsaltsensor`添加到`Sensors.conf`配置文件中，以便系统可以确定某个传感器的默认传感器类型。当然，开发者可以自由选择系统上注册的任何传感器。配置文件的格式是`SensorType
    = sensor.id`，其中`SensorType`是基本传感器类名，例如`QLightSensor`，而`sensor.id`是特定传感器后端的`String`标识符。以下代码使用Linux后端的`saltsensor`和`sensorfw`后端中的列表传感器：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: QSensorGesture
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSensorGesture
- en: '`QSensorGesture` is an API for device gestures using sensors. As I mentioned in
    the introduction, they use ad-hoc gestures, which is to say there is no machine
    learning involved. Qt Sensors offers the following already-baked gestures:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSensorGesture`是一个用于设备手势的传感器API。正如我在介绍中提到的，它们使用临时的手势，也就是说没有涉及机器学习。Qt Sensors提供了以下预定义的手势：'
- en: '`cover`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cover`'
- en: '`doubletap`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doubletap`'
- en: '`freefall`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`freefall`'
- en: '`hover`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hover`'
- en: '`pickup`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pickup`'
- en: '`slam`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slam`'
- en: '`shake`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shake`'
- en: '`turnover`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`turnover`'
- en: '`twist`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twist`'
- en: '`whip`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whip`'
- en: Instructions on how to perform specific gestures in Qt Sensors are detailed
    at [http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html](http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Sensors中执行特定手势的说明可以在[http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html](http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html)中找到。
- en: It is worth noting that `QSensorGesture` uses signals specific to the recognizer.
    The `slam` gesture has the `slam()` signal, which gets emitted when it detects
    the `slam` gesture. It also has the standard `detected("<gesture>")` signal. The `shake2` gesture
    has the `shakeLeft`, `shakeRight`, `shakeUp` and `shakeDown` signals, but also
    the corresponding `detected` signals.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`QSensorGesture`使用识别器特定的信号。`slam`手势有`slam()`信号，当检测到`slam`手势时发出。它还有标准的`detected("<gesture>")`信号。`shake2`手势有`shakeLeft`、`shakeRight`、`shakeUp`和`shakeDown`信号，但还有相应的`detected`信号。
- en: The `QSensorGesture` class does not have the `Q_OBJECT` macro, and creates its
    signals at runtime directly on the `meta` object. As such, `qobject_cast` and
    subclassing `QSensorGesture` while using `Q_OBJECT` will not work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSensorGesture`类没有`Q_OBJECT`宏，并且直接在`meta`对象上在运行时创建其信号。因此，在使用`Q_OBJECT`的同时使用`qobject_cast`和子类化`QSensorGesture`将不会工作。'
- en: '`QSensorGestureManager` has the `recognizerSignals` function, which takes a
    `gestureId` so you can discover signals specific to the gesture, if you need to.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSensorGestureManager`有`recognizerSignals`函数，它接受一个`gestureId`，这样你就可以发现特定于手势的信号，如果你需要的话。'
- en: The source code can be found on the Git repository under the `Chapter07-3` directory,
    in the `cp7` branch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter07-3`目录下的`cp7`分支中找到。
- en: 'To use `QSensorGestures`, create a `QSensorGesture` object, which takes a `QStringList`
    argument of a list of gesture IDs you want to use. You can specify directly which
    gestures you want using a `QStringList` like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`QSensorGestures`，创建一个`QSensorGesture`对象，它接受一个包含你想要使用的手势ID列表的`QStringList`参数。你可以使用这样的`QStringList`直接指定你想要的手势：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Alternatively you can also use `QSensorGestureManager` to get a list of all
    the registered gestures, calling `gestureIds()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`QSensorGestureManager`来获取所有已注册手势的列表，调用`gestureIds()`。
- en: Because of the atypical implementation of `QSensorGesture` (because the signals
    get dynamically created at runtime), using the new style connect syntax, `connect(gesture,
    &QSensorGesture::detected, this, &SomeClass::detectedGesture);`, will result in
    a compiler error, as the new style syntax has compile-time checks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QSensorGesture`的实现不典型（因为信号在运行时动态创建），使用新的连接语法`connect(gesture, &QSensorGesture::detected,
    this, &SomeClass::detectedGesture);`将导致编译器错误，因为新的语法有编译时检查。
- en: 'Once you have these signals connected correctly, you call `startDetection()`
    for `QSensorGesture`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确连接了这些信号，你就可以为`QSensorGesture`调用`startDetection()`：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: QSensorGestureManager
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSensorGestureManager
- en: 'You can get a list of all sensor gestures registered on the system by using
    `QSensorGestureManager`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`QSensorGestureManager`来获取系统上注册的所有传感器手势的列表：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use the `gestureId` from the preceding code to create a new `QSensorGesture`
    object and connect to the detected signal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前一段代码中的`gestureId`来创建一个新的`QSensorGesture`对象，并将其连接到检测到的信号：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: SensorGesture
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SensorGesture
- en: Of course, sensor gestures can be used from QML. The API is slightly different
    in that there is only one type, `SensorGesture`, so it is like using the generic
    `QSensor` class, except that, instead of one gesture per object, `SensorGesture`
    can represent one or more gestures.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，传感器手势也可以在QML中使用。API略有不同，因为只有一个类型，即`SensorGesture`，所以它就像使用通用的`QSensor`类一样，除了`SensorGesture`可以表示一个或多个手势，而不是每个对象一个手势。
- en: '`SensorGesture` does not have its own import, and is lumped into `QtSensors`,
    so we need to use that to indicate we are using the `QtSensors` module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`SensorGesture`没有自己的导入，而是包含在`QtSensors`中，因此我们需要使用它来表示我们正在使用`QtSensors`模块：'
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You specify which gestures you want by writing to the `gestures` property,
    which takes a list of strings of the `id` recognizer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过写入`gestures`属性来指定你想要的手势，该属性接受一个字符串列表的`id`识别器：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since there is only one generic `SensorGesture`, there are no gesture-specific
    signals. The gesture signal is `onDetected`, and a string of which gesture was
    detected is set in the `gesture` property. You will have to use some logic to
    filter for a certain gesture if you are using the component for more than one
    gesture:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个通用的`SensorGesture`，因此没有特定于手势的信号。手势信号是`onDetected`，在`gesture`属性中设置检测到的手势字符串。如果你使用该组件进行多个手势，你将不得不使用一些逻辑来过滤特定手势：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To start the detection, write `true` to the `SensorGesture` enabled property:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始检测，将`true`写入`SensorGesture`的启用属性：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can grab your device and perform the slam gesture as outlined in the Qt
    documentation at [http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html](http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html).
    Depending on your device, it will detect a slam.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以拿起您的设备，按照Qt文档中概述的方式执行slam手势[http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html](http://doc.qt.io/qt-5/sensorgesture-plugins-topics.html)。根据您的设备，它将检测到slam。
- en: WebSockets – Bi-directional web communication
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets – 双向Web通信
- en: Now we are starting to get into the realm of network and the internet. WebSockets
    are a protocol that allows two-way data exchange between a web browser or client
    and a server without polling. You can stream data or send data at any time. Qt
    has support for WebSockets through the use of the `QWebSocket` API. Like normal
    TCP sockets, `QWebSockets` needs a server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始进入网络和互联网的领域。WebSockets是一种协议，允许在Web浏览器或客户端和服务器之间进行双向数据交换，而不需要轮询。您可以流式传输数据或随时发送数据。Qt通过使用`QWebSocket`
    API支持WebSockets。像正常的TCP套接字一样，`QWebSockets`需要一个服务器。
- en: QWebSocketServer
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QWebSocketServer
- en: '`QWebSocketServer` can work in two modes: non-secure and SSL. We start by adding
    `websockets` to the `.pro` file so `qmake` sets up the proper library and header
    paths:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWebSocketServer`可以在两种模式下工作：非安全和SSL。我们首先将`websockets`添加到`.pro`文件中，这样`qmake`就会设置正确的库和头文件路径：'
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then include the `QWebSocketServer` header file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后包含`QWebSocketServer`头文件：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The source code can be found on the Git repository under the `Chapter07-3` directory,
    in the `cp7` branch.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter07-3`目录下的`cp7`分支中找到。
- en: To create a `QWebSocketServer`, it takes a server name as a string, a mode,
    and a parent object. The mode can be `SecureMode` or `NonSecureMode`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`QWebSocketServer`，需要一个字符串形式的服务器名称、一个模式和父对象。模式可以是`SecureMode`或`NonSecureMode`。
- en: '`SecureMode` is is like HTTPS, uses SSL, and the protocol is wss. `NonSecureMode`
    is like HTTPS with the ws protocol:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecureMode`类似于HTTPS，使用SSL，协议是wss。`NonSecureMode`类似于使用ws协议的HTTPS：'
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Like `QSocket`, there is a `newConnection` signal that gets emitted when a
    client attempts to connect to this server. If you are using `SecureMode`, you
    will want to connect to the `sslErrors(const QList<QSslError> &errors)` signal.
    Once the signals you want to use are connected, call `listen` to start the server,
    with a `QHostAddress` and a port number. `QHostAddress::Any` will listen to all
    network interfaces. You can specify one interface''s address. The port number
    is optional and a port of 0 will be assigned a port automatically:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与`QSocket`类似，有一个`newConnection`信号，当客户端尝试连接到该服务器时会发出。如果您使用`SecureMode`，您将想要连接到`sslErrors(const
    QList<QSslError> &errors)`信号。一旦连接了您想要使用的信号，调用`listen`来启动服务器，并指定`QHostAddress`和端口号。`QHostAddress::Any`将监听所有网络接口。您可以指定一个接口的地址。端口号是可选的，端口号为0将自动分配端口号：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we have a `QWebSocketServer` object that listens to incoming connections.
    We can handle this much like we did with the `QSocketServer` using `nextPendingConnection`
    in the corresponding slot we used to connect with the `newConnection` signal.
    That will give us a `QWebSocket` object that represents the connecting client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个监听传入连接的`QWebSocketServer`对象。我们可以像处理`QSocketServer`一样处理它，使用`nextPendingConnection`在相应的槽中连接到`newConnection`信号。这将给我们一个代表连接客户端的`QWebSocket`对象。
- en: QWebSocket
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QWebSocket
- en: 'When a new connection comes in, `QWebSocketServer` emits the `newConnection` signal,
    which, here, calls the `newConnection` slot. We grab `QWebSocket` using the `nextPendingConnection`
    of the server object. With this, we connect to the `QWebSocket` signals:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的连接到来时，`QWebSocketServer`会发出`newConnection`信号，在这里，它调用`newConnection`槽。我们使用服务器对象的`nextPendingConnection`来获取`QWebSocket`。有了这个，我们就连接到`QWebSocket`的信号：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first signal I like to connect is the error signal, as it can help debug.
    Like the `QBluetooth` class, the `error` function is overloaded, so special syntax
    is needed to use this signal.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢连接的第一个信号是错误信号，因为它可以帮助调试。像`QBluetooth`类一样，错误函数是重载的，因此需要特殊的语法来使用此信号。
- en: The `QWebSocket` `error` signal is overloaded, so it needs unique handling to
    compile. `QOverload` is what you need to use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWebSocket`的`error`信号是重载的，因此需要独特的处理才能编译。`QOverload`是您需要使用的。'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are two types of messages that can be sent and received: `text` and `binary`.
    We have to deal with those differently, so there are signals for each. They get
    emitted by the server when the client sends a `text` or `binary` message:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以发送和接收两种类型的消息：`text`和`binary`。我们必须分别处理这些，因此每种类型都有自己的信号。当客户端发送`text`或`binary`消息时，服务器会发出这些信号：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: One difference between `binary` and `text` messages in WebSockets is that the
    `text` messages are terminated with the `0xFF` character.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 中 `binary` 和 `text` 消息之间的一个区别是，`text` 消息以 `0xFF` 字符结尾。
- en: 'The `textMessageReceived` signal sends a `QString`, while the `binaryMessageReceived`
    sends a `QByteArray`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`textMessageReceived` 信号发送 `QString`，而 `binaryMessageReceived` 发送 `QByteArray`：'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: They also work on the frame level, but we are simply handling the entire message.
    If you have continuous streaming data of some kind, you might choose the `textFrameReceived`
    or `binaryFrameReceived` signals.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也在帧级别上工作，但我们只是处理整个消息。如果您有某种类型的连续流数据，您可能会选择 `textFrameReceived` 或 `binaryFrameReceived`
    信号。
- en: Client
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: A WebSocket client would simply use `QWebSocket` and connect to a server that
    supports WebSockets. One use case would be a web page (client) that shows sensor
    data sent though a `QWebSocketServer`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 客户端会简单地使用 `QWebSocket` 并连接到一个支持 WebSocket 的服务器。一个用例是一个网页（客户端），它显示通过
    `QWebSocketServer` 发送的传感器数据。
- en: QtQuick
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QtQuick
- en: Of course, the `QWebSockets` API provides QML components – WebSocket and `WebSocketServer`
    to be exact. As usual, it is quicker than using C++.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`QWebSockets` API 提供了 QML 组件——确切地说，是 `WebSocket` 和 `WebSocketServer`。像往常一样，使用它比使用
    C++ 更快。
- en: WebSocketServer
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocketServer
- en: 'Add the following import line for your `qml` file to use WebSockets:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `qml` 文件中添加以下导入行以使用 WebSocket：
- en: The source code can be found on the Git repository under the `Chapter07-4` directory,
    in the `cp7` branch.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter07-4` 目录下的 `cp7` 分支中找到。
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To start listening with `WebSocketServer`, set the `listen` property to `true`.
    The `url` property, which takes a string, can be set to the address that clients
    will connect to:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `WebSocketServer` 开始监听，将 `listen` 属性设置为 `true`。`url` 属性接受一个字符串，可以设置为客户端将要连接的地址：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When a client connects, the `onClientConnected` signal gets emitted, and its
    `webSocket` property represents the incoming WebSocket client. You also want to
    be able to do error checking so `WebSocketServer` has the `onErrorStringChanged`
    signal, with the `errorString` property. To do so, in the `WebSocketServer` component,
    implement it like this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接时，会发出 `onClientConnected` 信号，其 `webSocket` 属性表示传入的 WebSocket 客户端。您还希望能够进行错误检查，因此
    `WebSocketServer` 有 `onErrorStringChanged` 信号，带有 `errorString` 属性。为此，在 `WebSocketServer`
    组件中实现如下。
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let's see how to handle the WebSocket for both server and client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何处理服务器和客户端的 WebSocket。
- en: WebSocket
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket
- en: Both the client and server use WebSocket element. In the server, as I outlined
    in the *WebSocketServer* section, the client's `WebSocket` object can be obtained
    via the `onClientConnect` signal.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都使用 WebSocket 元素。在服务器端，正如我在 *WebSocketServer* 部分概述的那样，可以通过 `onClientConnect`
    信号获取客户端的 `WebSocket` 对象。
- en: 'Check out how this works in the `WebSocketServer` component, as compared to
    the client:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `WebSocketServer` 组件中的工作方式，与客户端相比：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The client requires the `url` property to be populated so it knows which server
    it will connect to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端需要填充 `url` 属性，以便知道它将连接到哪个服务器：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The incoming message appears in the `onTextMessageReceived` signal with the
    `message` property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 收到的消息会出现在 `onTextMessageReceived` 信号中，带有 `message` 属性。
- en: To send a message to the server or client, `WebSocket` has the `sendMessage`
    function. If this is the server, the `webSocket` would be used to send a message
    of text like this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要向服务器或客户端发送消息，`WebSocket` 有 `sendMessage` 函数。如果是服务器，可以使用 `webSocket` 发送类似文本的消息。
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: WebSockets for Qt Quick does not handle binary messages in the true sense of
    the word. It does happen to have an `onBinaryMessageReceived` signal, but the
    `message` object that gets received is a `String`. I would suggest that if your
    binary message will get messed up by being converted to UTF16-encoded `QString`,
    you might consider using the C++ API.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Qt Quick 的 WebSocket，并不真正处理二进制消息。它确实有一个 `onBinaryMessageReceived` 信号，但接收到的
    `message` 对象是一个 `String`。我建议如果您的二进制消息在转换为 UTF16 编码的 `QString` 时会出错，您可能需要考虑使用 C++
    API。
- en: QMqtt – Brokers of machine talk
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMqtt – 机器对话的代理
- en: MQTT is a publish-and-subscribe messaging transport. There was a similar framework
    in the Qt Mobility stack called Publish and Subscribe, which is now part of the
    officially unsupported `QSystems` API framework, which also includes `QSystemInfo`
    and `QSystemFramework`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT 是一种发布和订阅的消息传输。Qt Mobility 栈中有一个类似的框架，称为发布和订阅，现在它是官方不支持的 `QSystems` API
    框架的一部分，该框架还包括 `QSystemInfo` 和 `QSystemFramework`。
- en: '`QMqtt` is a framework for writing MQTT clients. You will need to install and
    run an MQTT broker, such as Mosquitto or HiveMQ, or use an internet-based service.
    For my development and testing purposes, I chose HiveMQ. You can download it from [https://www.hivemq.com/](https://www.hivemq.com/).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMqtt` 是编写 MQTT 客户端的框架。您需要安装并运行一个 MQTT 代理，如 Mosquitto 或 HiveMQ，或者使用基于互联网的服务。出于我的开发和测试目的，我选择了
    HiveMQ。您可以从 [https://www.hivemq.com/](https://www.hivemq.com/) 下载它。'
- en: They also have a public broker at [http://www.mqtt-dashboard.com/index.html](http://www.mqtt-dashboard.com/index.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还有一个公共代理在 [http://www.mqtt-dashboard.com/index.html](http://www.mqtt-dashboard.com/index.html)。
- en: MQTT has a broker, or server that one or more clients connect to. The clients
    can then publish and/or subscribe to different topics.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT 有一个代理，或服务器，一个或多个客户端连接到。然后客户端可以发布和/或订阅不同的主题。
- en: You can use `QWebSockets` to access a broker, and there is an example in Qt,
    which uses the `WebSocketIODevice` class in the `examples/mqtt/websocketsubscription`
    directory.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `QWebSockets` 访问代理，Qt 中有一个示例，它使用 `examples/mqtt/websocketsubscription`
    目录中的 `WebSocketIODevice` 类。
- en: QMqttClient
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMqttClient
- en: To start developing a `QMqttClient`, you will have to build it yourself, as
    it does not get distributed with Qt itself, unless you get the commercial Qt for
    Automation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始开发 `QMqttClient`，您必须自己构建它，因为它本身并不与 Qt 一起分发，除非您获得商业 Qt for Automation。
- en: You download the open source licensed version from `git://code.qt.io/qt/qtmqtt.git`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 `git://code.qt.io/qt/qtmqtt.git` 下载开源许可版本。
- en: Luckily it is a straightforward and easy build. Once you run `qmake; make &&
    make install;`, you are ready to use it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是一个简单且容易构建的过程。一旦您运行 `qmake; make && make install;`，您就可以使用它了。
- en: In your `pro` file, we need to add the `mqtt` module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `pro` 文件中，我们需要添加 `mqtt` 模块。
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The header file is named `QtMqtt/QMqttClient`, so let''s include that:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件命名为 `QtMqtt/QMqttClient`，所以让我们包含它：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The source code can be found on the Git repository under the `Chapter07-5` directory,
    in the `cp7` branch.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter07-5` 目录下的 `cp7` 分支中找到。
- en: 'The main class we use to access the broker is named `QMqttClient`. It can be
    thought of as the manager. It has a simple construction. You need to specify the
    host and port with the `setHostname` and `setPort` functions. We will use the `hivemq` public
    broker and port `1883`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来访问代理的主要类名为 `QMqttClient`。它可以被认为是管理者。它有一个简单的构造。您需要使用 `setHostname` 和 `setPort`
    函数指定主机和端口。我们将使用 `hivemq` 公共代理和端口 `1883`：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is a good idea connect to any error signals to help debugging when things
    go wrong; let''s do that first:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情出错时，连接到任何错误信号以帮助调试是个好主意；让我们先这么做：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To connect to the `mqtt` broker, call `connectToHost();`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 `mqtt` 代理，请调用 `connectToHost();`：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Since we connected to the `stateChanged` signal, we can wait until we are connected
    to the broker to subscribe to any topics:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们连接到了 `stateChanged` 信号，我们可以等待我们连接到代理后再订阅任何主题：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `QMqttClient::subscribe` function takes a topic in the form of `QMqttTopicFilter`.
    Here, I assign it the `"Qt"` string.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMqttClient::subscribe` 函数接收一个以 `QMqttTopicFilter` 形式的主题。在这里，我将其分配给 `"Qt"`
    字符串。'
- en: It returns a `QMqttSubscription` pointer, which we can use to connect to the
    `stateChanged` signal. We will then simply subscribe to the topic we just published.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 `QMqttSubscription` 指针，我们可以用它来连接到 `stateChanged` 信号。然后我们将简单地订阅我们刚刚发布的主题。
- en: 'Our `subscribe` function looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `subscribe` 函数看起来像这样：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We simply call our function that will then publish something to that topic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是调用我们的函数，然后就会向该主题发布一些内容。
- en: '`QMqttClient::publish` takes a topic name in the form of a `QMqttTopicName`,
    and the message is just a standard `QByteArray`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMqttClient::publish` 接收一个以 `QMqttTopicName` 形式的主题名称，消息只是一个标准的 `QByteArray`。'
- en: 'The `publish` function looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish` 函数看起来像这样：'
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should then see the message we published in the `messageReceived` slot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到我们在 `messageReceived` 插槽中发布的消息：
- en: '![](img/5b5ad8cf-4496-41a9-a675-caa991a0bc0e.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b5ad8cf-4496-41a9-a675-caa991a0bc0e.png)'
- en: Putting it all together
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: I have a Raspberry Pi and a Sense HAT board that I can use to collect sensor
    data. Luckily, I previously wrote a Qt Sensors plugin for the Sense HAT. It happens
    to be in a standalone Git repository and not in any Qt Sensors version, unlike
    the TI SensorTag backend plugin.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个 Raspberry Pi 和一个 Sense HAT 板，可以用它来收集传感器数据。幸运的是，我之前为 Sense HAT 编写了一个 Qt
    Sensors 插件。它恰好在一个独立的 Git 仓库中，而不是任何 Qt Sensors 版本中，与 TI SensorTag 后端插件不同。
- en: If you don't want to write your own Sense HAT sensor plugin you can get my standalone
    Sense HAT plugin from [https://github.com/lpotter/qsensors-sensehatplugin.git](https://github.com/lpotter/qsensors-sensehatplugin.git).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想编写自己的 Sense HAT 传感器插件，你可以从 [https://github.com/lpotter/qsensors-sensehatplugin.git](https://github.com/lpotter/qsensors-sensehatplugin.git)
    获取我的独立 Sense HAT 插件。
- en: The version of Qt Sensors on the Raspbian distribution is 5.7 and does not have
    the pressure and humidity sensors that the Sense HAT has. They were added in later
    Qt Sensors versions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Raspbian 分发版上的 Qt Sensors 版本为 5.7，它没有 Sense HAT 所具有的压力和湿度传感器。这些传感器是在后续的 Qt Sensors
    版本中添加的。
- en: Cross-compiling on a desktop is so much faster than compiling on the device—days
    on the **Raspberry Pi** (**rpi**) as opposed to a few minutes on a good development
    machine. I had some trouble getting the cross-compiling `toolchain` to work, so
    I had to opt for the on-board native compile, which of course takes a very long
    time on a Raspberry Pi. The easiest way is to get Qt's commercial `Boot2Qt` and
    `Automation` packages, as they package it up nicely, and provide binaries and
    support.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面上的交叉编译比在设备上编译要快得多——在 **Raspberry Pi**（**rpi**） 上需要几天时间，而在一个好的开发机上只需要几分钟。我在设置交叉编译
    `toolchain` 时遇到了一些麻烦，所以我不得不选择在板载上使用原生编译，这在 Raspberry Pi 上当然需要非常长的时间。最简单的方法是获取
    Qt 的商业 `Boot2Qt` 和 `Automation` 软件包，因为它们打包得很好，并提供二进制文件和支持。
- en: 'Since this book uses Qt 5.12, we need to get the explicit version of the following
    Qt module repositories, by using the following Git commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书使用 Qt 5.12，我们需要使用以下 Git 命令获取以下 Qt 模块仓库的显式版本：
- en: 'Qt Base: `git clone http://code.qt.io/qt/qtbase.git -b 5.12`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Qt Base: `git clone http://code.qt.io/qt/qtbase.git -b 5.12`'
- en: 'Qt WebSockets: `git clone http://code.qt.io/qt/qtwebsockets.git -b 5.12`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Qt WebSockets: `git clone http://code.qt.io/qt/qtwebsockets.git -b 5.12`'
- en: Qt MQTT: `git clone http://code.qt.io/qt/qtmqtt -b 5.12`
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Qt MQTT: `git clone http://code.qt.io/qt/qtmqtt -b 5.12`'
- en: Qt Sensors: `git clone http://code.qt.io/qt/qtsensors -b 5.12`
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Qt Sensors: `git clone http://code.qt.io/qt/qtsensors -b 5.12`'
- en: We are going to create an app for Raspberry Pi that grabs the Sense HAT's temperature
    and pressure data and distributes them via `QMqtt` and `QWebSockets` to a broker
    running on HiveMQ.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个适用于 Raspberry Pi 的应用程序，该应用程序抓取 Sense HAT 的温度和压力数据，并通过 `QMqtt` 和 `QWebSockets`
    将其分发到运行在 HiveMQ 上的代理。
- en: The source code can be found on the Git repository under the `Chapter07-6` directory,
    in the `cp7` branch.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter07-6` 目录下的 `cp7` 分支中找到。
- en: Start by implementing a `SensorServer` class, which is typically a `QObject`
    derived class.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先实现一个 `SensorServer` 类，这通常是一个从 `QObject` 派生的类。
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We then implement the `QWebSockeIODevice` that we declared as `mDevice` and
    connect to its `socketConnected` signal.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现我们声明的 `QWebSockeIODevice` 并连接到其 `socketConnected` 信号。
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next we call the `connectToBackend()` function of the sensors we want to use.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用我们想要使用的传感器的 `connectToBackend()` 函数。
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The call to `initSensors()` connects to the sensor's backend and sets up `readingChanged`
    signal connections.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `initSensors()` 连接到传感器的后端并设置 `readingChanged` 信号连接。
- en: 'To use `QWebSockets` for the `QMqtt` client, we need to create a `QIODevice`
    that uses `QWebSockets`. Luckily, there is one already written in the `QMqtt`
    `examples/mqtt/websocketssubscription` directory, named `websocketsiodevice`,
    so we will import that into the project:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `QWebSockets` 为 `QMqtt` 客户端，我们需要创建一个使用 `QWebSockets` 的 `QIODevice`。幸运的是，在
    `QMqtt` 的 `examples/mqtt/websocketssubscription` 目录中已经有一个名为 `websocketsiodevice`
    的现成代码，所以我们将将其导入到项目中：
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In our header file, we include `websocketdevice.h`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的头文件中，我们包含 `websocketdevice.h`。
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the class declaration, we instantiate the `WebSocketIODevice` as a class
    member.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中，我们将 `WebSocketIODevice` 实例化为一个类成员。
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To actually use `WebSocketIODevice`, we need to set it as the `QMqttClient`
    transport.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用 `WebSocketIODevice`，我们需要将其设置为 `QMqttClient` 传输。
- en: We first set up our `WebSocketIODevice` and connect to its `socketConnected`
    signal to set up `QMqtt`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置我们的 `WebSocketIODevice` 并连接到其 `socketConnected` 信号以设置 `QMqtt`。
- en: 'The `mqtt` broker at `hivemq` uses a different port number, so we set it in
    the URL:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`hivemq` 上的 `mqtt` 代理使用不同的端口号，所以我们将其设置在 URL 中：'
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we set up `QMqtt` and set its transport to use `WebSocketIODevice`. We
    are using a transport with its own connection, so we do not set the URL for the
    `QMqtt` object, but rely on the `websocket` for connection. We then set up `mqttClient`
    as usual:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置 `QMqtt` 并将其传输设置为使用 `WebSocketIODevice`。我们使用一个具有自己连接的传输，因此我们不需要为 `QMqtt`
    对象设置 URL，而是依赖于 `websocket` 进行连接。然后我们像往常一样设置 `mqttClient`：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We monitor the changing state and act when it becomes `Connected`. We will
    start the `humidity` and `temperature` sensor, and then call subscribe so we can
    monitor when the `mqtt` broker is publishing:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监控状态的变化，并在它变为 `Connected` 时采取行动。我们将启动 `humidity` 和 `temperature` 传感器，然后调用订阅以监控
    `mqtt` 代理发布消息：
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In our sensor''s `readingChanged` slots, we will publish the data to the `mqtt`
    broker:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们传感器的 `readingChanged` 插槽中，我们将数据发布到 `mqtt` 代理：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, let''s see any subscribed messages:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看任何已订阅的消息：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at the different ways of using `QSensors` to read
    a device''s sensor data. There are many supported platforms for Qt Sensors: Android,
    iOS, WinRT , SensorTag, Sensorfw, Linux generic, and Linux iio-sensor-proxy. Sensorfw
    also has support for Linux''s IIO sensors.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 `QSensors` 读取设备传感器数据的多种方式。Qt 传感器支持许多平台：Android、iOS、WinRT、SensorTag、Sensorfw、Linux
    通用和 Linux iio-sensor-proxy。Sensorfw 还支持 Linux 的 IIO 传感器。
- en: I described how to implement custom `QSensor` and `QSensorBackend` to add support
    for sensors not currently supported in Qt Sensors.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我描述了如何实现自定义的 `QSensor` 和 `QSensorBackend` 以添加对 Qt 传感器当前不支持传感器的支持。
- en: We went through the steps involved in using `QtMqtt` to talk to an `mqtt` broker,
    and we looked at how to use `QWebsockets` to communicate to a web server web page.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了使用 `QtMqtt` 与 `mqtt` 代理通信的步骤，并探讨了如何使用 `QWebsockets` 与网页服务器进行通信。
- en: Then I threw them all together to grab sensor data from a Sense HAT, and publish
    them to `mqtt` broker by way of WebSockets.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将它们全部组合起来，从 Sense HAT 获取传感器数据，并通过 WebSocket 将它们发布到 `mqtt` 代理。
- en: In the next chapter, we will discuss using GPS data comprising of location and
    position and mapping.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用包含位置和位置的 GPS 数据以及地图绘制。
