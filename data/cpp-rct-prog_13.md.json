["```cpp\n//------ OnError1 \n#include \"rxcpp/rx.hpp\" \n\nint main() \n{ \n    //------ Creating Observable with an error appended \n    //------ A canned example to demonstrate error \n    auto values = rxcpp::observable<>::range(1, 3). \n                  concat(rxcpp::observable<>:: \n                  error<int>(std::runtime_error(\"Error from producer!\"))); \n\n    values. \n        subscribe( \n         //--------------- on_next \n            [](int v) { printf(\"OnNext: %dn\", v); }, \n            //---------------- on_error \n            [](std::exception_ptr ep) { \n                 printf(\"OnError: %sn\", rxcpp::util::what(ep).c_str()); \n            }, \n            //---------------- on_completed \n            []() { printf(\"OnCompletedn\"); }); \n} \n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nOnError: Error from producer!\n```", "```cpp\n//------- OnError2.cpp \n#include \"rxcpp/rx.hpp\" \n\nint main() { \n    //------- Create a subject instance  \n    //------  and retrieve subscriber abd Observable handle  \n    rxcpp::rxsub::subject<int> sub; \n    auto subscriber = sub.get_subscriber(); \n    auto observable = sub.get_observable(); \n\n    //--------------------------- Subscribe! \n    observable.subscribe( \n        [](int v) { printf(\"OnNext: %dn\", v); }, \n        [](std::exception_ptr ep) { \n            printf(\"OnError: %sn\", rxcpp::util::what(ep).c_str()); \n        }, \n        []() { printf(\"OnCompletedn\"); } \n    );\n```", "```cpp\n    for (int i = 1; i <= 10; ++i) { \n        if (i > 5) { \n            try { \n                std::string().at(1); \n            } \n            catch (std::out_of_range& ex) { \n                //------------ Emit exception. \n                subscriber.on_error(std::make_exception_ptr(ex));\n                break;\n            } \n        } \n        subscriber.on_next(i * 10); \n    } \n    subscriber.on_completed(); \n} \n```", "```cpp\n//------- OnError3.cpp \n#include \"rxcpp/rx.hpp\" \n\nint main() \n{ \n    //------- Create an Observable with appended error \n    auto values = rxcpp::observable<>::range(1, 3). \n        concat(rxcpp::observable<>:: \n        error<int>(std::runtime_error(\"Error from producer!    \"))). \n        //------- Resuming with another Stream \n        on_error_resume_next([](std::exception_ptr ep) { \n            printf(\"Resuming after: %sn\", rxcpp::util::what(ep).c_str()); \n            return rxcpp::observable<>::range(4,6); \n        }); \n\n    values. \n        subscribe( \n            [](int v) {printf(\"OnNext: %dn\", v); }, \n            [](std::exception_ptr ep) { \n                printf(\"OnError: %sn\", rxcpp::util::what(ep).c_str()); }, \n            []() {printf(\"OnCompletedn\"); }); \n} \n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nResuming after: Error from producer! \nOnNext: 4 \nOnNext: 5 \nOnNext: 6 \nOnCompleted \n```", "```cpp\n        //------- Resuming with a default single value \n        on_error_resume_next([](std::exception_ptr ep) { \n            printf(\"Resuming after: %sn\", rxcpp::util::what(ep).c_str()); \n            return rxcpp::observable<>::just(-1); \n        });\n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nResuming after: Error from source \nOnNext: -1 \nOnCompleted\n```", "```cpp\nauto processed_strm = Source_observable. \nmap([](const string& s) { \nreturn do_string_operation(s); \n      }). \n// Translating exception from the source \non_error_resume_next([](std::exception_ptr){ \nreturn rxcpp::sources::error<string>(runtime_error(rxcpp::util::what(ep).c_str())); \n      });\n```", "```cpp\n//------- Retry1.cpp \n#include \"rxcpp/rx.hpp\" \n\nint main() \n{ \n    auto values = rxcpp::observable<>::range(1, 3). \n        concat(rxcpp::observable<>:: \n        error<int>(std::runtime_error(\"Error from producer!\"))). \n        retry(). \n        take(5); \n\n    //----- Subscription \n    values. \n        subscribe( \n            [](int v) {printf(\"OnNext: %dn\", v); }, \n            []() {printf(\"OnCompletedn\"); }); \n} \n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nOnNext: 1 \nOnNext: 2 \nOnCompleted \n```", "```cpp\n//------- Retry2.cpp \n#include \"rxcpp/rx.hpp\" \n\nint main() \n{ \n    auto source = rxcpp::observable<>::range(1, 3). \n        concat(rxcpp::observable<>:: \n        error<int>(std::runtime_error(\"Error from producer!\"))). \n        retry(2); \n\n    source. \n        subscribe( \n            [](int v) {printf(\"OnNext: %dn\", v); }, \n            [](std::exception_ptr ep) { \n                printf(\"OnError: %sn\", rxcpp::util::what(ep).c_str()); }, \n            []() {printf(\"OnCompletedn\"); }); \n}\n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nOnError: Error from producer!\n```", "```cpp\n//------- Finally.cpp \n#include \"rxcpp/rx.hpp\" \n\nint main() \n{ \n    auto values = rxcpp::observable<>::range(1, 3). \n        concat(rxcpp::observable<>:: \n        error<int>(std::runtime_error(\"Error from producer!\"))). \n        //----- Final action \n        finally([]() { printf(\"The final actionn\"); \n    }); \n\n    values. \n        subscribe( \n            [](int v) {printf(\"OnNext: %dn\", v); }, \n            [](std::exception_ptr ep) { \n                  printf(\"OnError: %sn\", rxcpp::util::what(ep).c_str()); }, \n            []() {printf(\"OnCompletedn\"); }); \n}\n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nOnError: Error from producer! \nThe final action\n```", "```cpp\nOnNext: 1 \nOnNext: 2 \nOnNext: 3 \nOnCompleted \nThe final action \n```", "```cpp\n//----------OnError_ObserveOn1.cpp  \n#include \"rxcpp/rx.hpp\" \n#include <iostream> \n#include <thread> \n\nint main() { \n    //---------------- Generate a range of values \n    //---------------- Apply Square function \n    auto values = rxcpp::observable<>::range(1, 4). \n        transform([](int v) { return v * v; }). \n        concat(rxcpp::observable<>:: \n        error<int>(std::runtime_error(\"Error from producer!\"))); \n\n    //------------- Emit the current thread details \n    std::cout << \"Main Thread id => \" \n        << std::this_thread::get_id() \n        << std::endl;\n```", "```cpp\n    //---------- observe_on another thread.... \n    //---------- make it blocking too \n    values.observe_on(rxcpp::synchronize_new_thread()).as_blocking(). \n        subscribe([](int v) { \n             std::cout << \"Observable Thread id => \" \n            << std::this_thread::get_id() \n            << \" \" << v << std::endl; }, \n            [](std::exception_ptr ep) { \n            printf(\"OnError: %sn\", rxcpp::util::what(ep).c_str()); }, \n            []() { std::cout << \"OnCompleted\" << std::endl; }); \n\n    //------------------ Print the main thread details \n    std::cout << \"Main Thread id => \" \n        << std::this_thread::get_id() \n        << std::endl; \n} \n```", "```cpp\nMain Thread id => 5776 \nObservable Thread id => 12184 1 \nObservable Thread id => 12184 4 \nObservable Thread id => 12184 9 \nObservable Thread id => 12184 16 \nOnError: Error from producer! \nMain Thread id => 5776 \n```", "```cpp\n//------- OnError_ObserveOn2.cpp \n#include \"rxcpp/rx.hpp\" \n#include <mutex> \n\nstd::mutex printMutex; \n\nint main() { \n\n    rxcpp::rxsub::subject<int> sub; \n    auto subscriber = sub.get_subscriber(); \n    auto observable1 = sub.get_observable(); \n    auto observable2 = sub.get_observable();\n```", "```cpp\n    auto onNext = [](int v) { \n        std::lock_guard<std::mutex> lock(printMutex); \n        std::cout << \"Observable Thread id => \" \n            << std::this_thread::get_id() \n            << \"t OnNext: \" << v << std::endl; \n    }; \n\n    auto onError = [](std::exception_ptr ep) { \n        std::lock_guard<std::mutex> lock(printMutex); \n        std::cout << \"Observable Thread id => \" \n            << std::this_thread::get_id() \n            << \"t OnError: \" \n            << rxcpp::util::what(ep).c_str() << std::endl; \n    }; \n```", "```cpp\n    //------------- Schedule it in another thread \n    observable1\\. \n        observe_on(rxcpp::synchronize_new_thread()). \n        subscribe(onNext, onError, \n            []() {printf(\"OnCompletedn\"); }); \n\n    //------------- Schedule it in yet another thread \n    observable2\\. \n        observe_on(rxcpp::synchronize_event_loop()). \n        subscribe(onNext, onError, \n            []() {printf(\"OnCompletedn\"); });\n```", "```cpp\n    //------------- Adding new values into the source Stream \n    //------------- Adding error into Stream when exception occurs \n    for (int i = 1; i <= 10; ++i) { \n        if (i > 5) { \n            try { \n                std::string().at(1); \n            } \n            catch (...) { \n                std::exception_ptr eptr = std::current_exception(); \n                subscriber.on_error(eptr);\n                break;\n            } \n        } \n        subscriber.on_next(i * 10); \n    } \n    subscriber.on_completed(); \n\n    //----------- Wait for Two Seconds \n    rxcpp::observable<>::timer(std::chrono::milliseconds(2000)). \n        subscribe([&](long) {}); \n}     \n```", "```cpp\nObservable Thread id => 2644    OnNext: 10 \nObservable Thread id => 2304    OnNext: 10 \nObservable Thread id => 2644    OnNext: 20 \nObservable Thread id => 2304    OnNext: 20 \nObservable Thread id => 2644    OnNext: 30 \nObservable Thread id => 2304    OnNext: 30 \nObservable Thread id => 2644    OnNext: 40 \nObservable Thread id => 2304    OnNext: 40 \nObservable Thread id => 2304    OnNext: 50 \nObservable Thread id => 2304    OnError: invalid string position \nObservable Thread id => 2644    OnNext: 50 \nObservable Thread id => 2644    OnError: invalid string position\n```", "```cpp\n//---------- SubscribeOn.cpp \n#include \"rxcpp/rx.hpp\" \n#include <thread> \n#include <mutex> \n\n//------ A global mutex for output sync. \nstd::mutex printMutex; \n\nint main() { \n    //-------- Creating Observable Streams \n    auto values1 = rxcpp::observable<>::range(1, 4). \n        transform([](int v) { return v * v; }); \n\n    auto values2 = rxcpp::observable<>::range(5, 9). \n                   transform([](int v) { return v * v; }). \n                   concat(rxcpp::observable<>: \n:error<int>(std::runtime_error(\"Error from source\"))); \n```", "```cpp\n    //-------- Schedule it in another thread \n    auto s1 = values1.subscribe_on(rxcpp::observe_on_event_loop()); \n\n    //-------- Schedule it in Yet another thread \n    auto s2 = values2.subscribe_on(rxcpp::synchronize_new_thread()); \n```", "```cpp\n    auto onNext = [](int v) { \n        std::lock_guard<std::mutex> lock(printMutex); \n        std::cout << \"Observable Thread id => \" \n                  << std::this_thread::get_id() \n                  << \"tOnNext: \" << v << std::endl; \n    }; \n\n    auto onError = [](std::exception_ptr ep) { \n        std::lock_guard<std::mutex> lock(printMutex); \n        std::cout << \"Observable Thread id => \" \n                  << std::this_thread::get_id() \n                  << \"tOnError: \" \n                  << rxcpp::util::what(ep).c_str() << std::endl; \n    }; \n```", "```cpp\n    //-------- Subscribing the merged sequence \n    s1.merge(s2).as_blocking().subscribe( \n        onNext, onError, \n        []() { std::cout << \"OnCompleted\" << std::endl; }); \n\n    //-------- Print the main thread details \n    std::cout << \"Main Thread id => \" \n        << std::this_thread::get_id() \n        << std::endl; \n} \n```", "```cpp\nObservable Thread id => 12380   OnNext: 1 \nObservable Thread id => 9076    OnNext: 25 \nObservable Thread id => 12380   OnNext: 4 \nObservable Thread id => 9076    OnNext: 36 \nObservable Thread id => 12380   OnNext: 9 \nObservable Thread id => 12380   OnNext: 16 \nObservable Thread id => 9076    OnNext: 49 \nObservable Thread id => 9076    OnNext: 64 \nObservable Thread id => 9076    OnNext: 81 \nObservable Thread id => 9076    OnError: Error from producer! \nMain Thread id => 10692\n```", "```cpp\n#include \"rxcpp/rx.hpp\" \n\nnamespace Rx { \n    using namespace rxcpp; \n    using namespace rxcpp::sources; \n    using namespace rxcpp::subjects; \n    using namespace rxcpp::util; \n} \n\nusing namespace std; \n\nstruct Employee { \n    string name; \n    string role; \n    int salary; \n}; \n```", "```cpp\nint main() \n{ \n    Rx::subject<Employee> employees; \n\n    // Group Salaries by Role \n    auto role_sal = employees.\n    get_observable(). \n        group_by( \n            [](Employee& e) { return e.role; }, \n            [](Employee& e) { return e.salary; }); \n```", "```cpp\n    // Combine min max and average reductions based on salary. \n    auto result = role_sal. \n        map([](Rx::grouped_observable<string, int> group) { \n            return group. \n                count(). \n                zip([=](int count, int min, int max, double average) { \n                return make_tuple(group.get_key(), count, min, max, average); \n        }, \n        group.min(), \n        group.max(), \n        group.map([](int salary) -> double { return salary; }).average()); \n    }). \n    merge();\n```", "```cpp\n    // Display the aggregated result \n    result. \n        subscribe(Rx::apply_to( \n        [](string role, int count, int min, int max, double avg) { \n          std::cout << role.c_str() << \":tCount = \" << count <<  \n           \", Salary Range = [\" << min  \n            << \"-\" << max << \"], Average Salary = \" << avg << endl; \n        })); \n\n    // Supplying input data \n    Rx::observable<>::from( \n        Employee{ \"Jon\", \"Engineer\", 60000 }, \n        Employee{ \"Tyrion\", \"Manager\", 120000 }, \n        Employee{ \"Arya\", \"Engineer\", 92000 }, \n        Employee{ \"Sansa\", \"Manager\", 150000 }, \n        Employee{ \"Cersei\", \"Accountant\", 76000 }, \n        Employee{ \"Jaime\", \"Engineer\", 52000 }). \n        subscribe(employees.get_subscriber()); \n\n    return 0; \n} \n```", "```cpp\nAccountant:    Count = 1, Salary Range = [76000-76000], Average Salary = 76000 \nEngineer:      Count = 3, Salary Range = [52000-92000], Average Salary = 68000 \nManager:       Count = 2, Salary Range = [120000-150000], Average Salary = 135000 \n```", "```cpp\n//--------- UI_EventsApp.cpp \n#include <rxcpp/rx.hpp> \n#include <cassert> \n#include <cctype> \n#include <clocale> \n\nnamespace Rx { \n    using namespace rxcpp; \n    using namespace rxcpp::sources; \n    using namespace rxcpp::operators; \n    using namespace rxcpp::util; \n    using namespace rxcpp::subjects; \n} \n\nusing namespace Rx; \nusing namespace std::chrono; \n\n// Application events \nenum class AppEvent { \n    Active, \n    Inactive, \n    Data, \n    Close, \n    Finish, \n    Other \n};\n```", "```cpp\nint main() \n{ \n    //------------------- \n    // A or a - Active \n    // I or i - Inactive \n    // D or d - Data \n    // C or c - Close \n    // F or f - Finish \n    // default - Other \n    auto events = Rx::observable<>::create<AppEvent>( \n        [](Rx::subscriber<AppEvent> dest) { \n        std::cout << \"Enter Application Events:\\n\"; \n        for (;;) { \n            int key = std::cin.get(); \n            AppEvent current_event = AppEvent::Other; \n\n            switch (std::tolower(key)) { \n            case 'a': current_event = AppEvent::Active; break; \n            case 'i': current_event = AppEvent::Inactive; break; \n            case 'd': current_event = AppEvent::Data; break; \n            case 'c': current_event = AppEvent::Close; break; \n            case 'f': current_event = AppEvent::Finish; break; \n            default:  current_event = AppEvent::Other; \n            } \n\n            if (current_event == AppEvent::Finish) { \n                dest.on_completed(); \n                break; \n            } \n            else { \n                dest.on_next(current_event); \n            } \n        } \n    }). \n    on_error_resume_next([](std::exception_ptr ep) { \n        return rxcpp::observable<>::just(AppEvent::Finish); \n    }). \n    publish();\n```", "```cpp\n    // Observable containing application active events\n    auto appActive = events. \n        filter([](AppEvent const& event) { \n        return event == AppEvent::Active; \n    }); \n\n    // Observable containing application inactive events\n    auto appInactive = events. \n        filter([](AppEvent const& event) { \n        return event == AppEvent::Inactive; \n    }); \n\n    // Observable containing application data events \n    auto appData = events. \n        filter([](AppEvent const& event) { \n        return event == AppEvent::Data; \n    }); \n\n    // Observable containing application close events\n    auto appClose = events. \n        filter([](AppEvent const& event) { \n        return event == AppEvent::Close; \n    });\n```", "```cpp\n    auto dataFromApp = appActive. \n        map([=](AppEvent const& event) { \n        std::cout << \"**Application Active**n\" << std::flush; \n        return appData. // Return all the data events \n            take_until(appInactive). // Stop recieving data when the application goes inactive \n            finally([]() { \n            std::cout << \"**Application Inactive**n\"; \n        }); \n    }). \n        switch_on_next(). // only listen to most recent data \n        take_until(appClose). // stop everything when Finish/Close event recieved \n        finally([]() { \n        std::cout << \"**Application Close/Finish**n\"; \n    }); \n\n    dataFromApp. \n        subscribe([](AppEvent const& event) { \n        std::cout << \"**Application Data**n\" << std::flush; \n    }); \n\n    events.connect(); \n\n    return 0; \n} \n```"]