- en: Chapter 2. Variables and Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。变量和内存
- en: To write your C++ game program, you will need your computer to remember a lot
    of things. Things such as where in the world is the player, how many hit points
    he has, how much ammunition he has left, where the items are in the world, what
    power-ups they provide, and the letters that make up the player's screen name.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写你的C++游戏程序，你的计算机需要记住很多事情。比如玩家在世界中的位置、他的生命值、剩余的弹药量、世界中的物品位置、它们提供的升级以及组成玩家屏幕名称的字母。
- en: 'The computer that you have actually has a sort of electronic sketchpad inside
    it called *memory,* or RAM. Physically, computer memory is made out of silicon
    and it looks something similar to what is shown in the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你所拥有的计算机内部实际上有一个称为*内存*或RAM的电子草图板。从物理上看，计算机内存是由硅制成的，其外观与以下截图所示类似：
- en: '![Variables and Memory](img/00022.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![变量和内存](img/00022.jpeg)'
- en: Does this RAM look like a parking garage? Because that's the metaphor we're
    going to use
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这RAM看起来像停车场吗？因为这就是我们要用的比喻
- en: RAM is short for Random Access Memory. It is called random access because you
    can access any part of it at any time. If you still have some CDs lying around,
    they are an example of non-random access. CDs are meant to be read and played
    back in order. I still remember jumping tracks on Michael Jackson's *Dangerous*
    album way back when switching tracks on a CD took a lot of time! Hopping around
    and accessing different cells of RAM, however, doesn't take much time at all.
    RAM is a type of fast memory access known as flash memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: RAM是随机访问内存的缩写。它被称为随机访问，因为你可以随时访问它的任何部分。如果你还留着一些CD，它们是非随机访问的例子。CD的设计是按顺序读取和播放的。我还记得在CD切换曲目需要花费很多时间的时候，在迈克尔·杰克逊的*危险*专辑上跳转曲目！然而，在RAM的不同单元格之间跳转并不需要花费太多时间。RAM是一种快速内存访问类型，称为闪存。
- en: RAM is called volatile flash memory because when the computer is shut down,
    RAM's contents are cleared and the old contents of RAM are lost unless they were
    saved to the hard disk first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: RAM被称为易失性闪存，因为当计算机关闭时，RAM的内容会被清除，除非它们之前被保存到硬盘上，否则RAM的旧内容会丢失。
- en: For permanent storage, you have to save your data into a hard disk. There are
    two main types of hard disks, platter-based **Hard Disk Drives** (**HDDs**) and
    **Solid-state Drives** (**SSDs**). SSDs are more modern than platter-based HDDs,
    since they use RAM's fast-access (Flash) memory principle. Unlike RAM, however,
    the data on an SSD persists after the computer is shut down. If you can get an
    SSD, I'd highly recommend that you use it! Platter-based drives are outdated.
    We need a way to reserve a space on the RAM and read and write from it. Fortunately,
    C++ makes this easy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于永久存储，你必须将你的数据保存到硬盘上。主要有两种硬盘类型，基于盘片的**硬盘驱动器**（**HDDs**）和**固态驱动器**（**SSDs**）。与基于盘片的HDDs相比，SSDs更现代，因为它们使用RAM的快速访问（闪存）原理。然而，与RAM不同的是，SSD上的数据在计算机关闭后仍然存在。如果你能获得SSD，我强烈建议你使用它！基于盘片的驱动器已经过时了。我们需要一种方法在RAM上预留空间并从中读取和写入。幸运的是，C++使这变得很容易。
- en: Variables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: A saved location in computer memory that we can read or write to is called a
    *variable*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存中可以读取或写入的保存位置被称为*变量*。
- en: A variable is a component whose value can vary. In a computer program, you can
    think of a variable as a container, into which you can store some data. In C++,
    these data containers (variables) have types. You have to use the right type of
    data container to save your data in your program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个其值可以变化的组件。在计算机程序中，你可以将变量视为一个容器，你可以将一些数据存储在其中。在C++中，这些数据容器（变量）有类型。你必须使用正确的数据容器类型来保存你的程序中的数据。
- en: If you want to save an integer, such as 1, 0, or 20, you will use an `int` type
    container. You can use float-type containers to carry around floating-point (decimal)
    values, such as 38.87, and you can use string variables to carry around strings
    of letters (think of it as a "string of pearls", where each letter is a pearl).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要保存一个整数，比如1、0或20，你将使用`int`类型的容器。你可以使用浮点类型容器来携带浮点（小数）值，比如38.87，你也可以使用字符串变量来携带字母字符串（可以将其视为“珍珠串”，其中每个字母都是一个珍珠）。
- en: 'You can think of your reserved spot in RAM like reserving parking space in
    a parking garage: once we declare our variable and get a spot for it, no one else
    (not even other programs running on the same machine) will be given that piece
    of RAM by the operating system. The RAM beside your variable might be unused or
    it might be used by other programs.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的预留RAM空间想象成在停车场预留停车位：一旦我们声明了变量并为其获取了一个位置，操作系统就不会将那块RAM分配给其他人（甚至不是在同一台机器上运行的另一个程序）。你的变量的RAM旁边可能未被使用，或者可能被其他程序使用。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The operating system exists to keep programs from stepping on each other's toes
    and accessing the same bits of computer hardware at the same time. In general,
    civil computer programs should not read or write to each other's memory. However,
    some types of cheat programs (for example, maphacks) secretly access your program's
    memory. Programs such as PunkBuster were introduced to prevent cheating in online
    games.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统存在是为了防止程序相互干扰，同时访问相同的计算机硬件位。一般来说，公民计算机程序不应该读取或写入彼此的内存。然而，一些类型的作弊程序（例如，地图作弊）秘密访问您的程序内存。为了防止在线游戏中的作弊，引入了像PunkBuster这样的程序。
- en: Declaring variables – touching the silicon
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量 – 触摸硅
- en: Reserving a spot on computer memory using C++ is easy. We'll want to name our
    chunk of memory that we will store our data in with a good, descriptive name.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++在计算机内存中预留位置很容易。我们希望用一个好的、描述性的名称来命名我们将存储数据的内存块。
- en: 'For example, say, we know that player **hit points** (**hp**) will be an integer
    (whole) number, such as 1, 2, 3, or 100\. To get a piece of silicon to store the
    player''s hp in memory, we will declare the following line of code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们知道玩家的**生命值**（**hp**）将是一个整数（整体）数，例如1、2、3或100。为了在内存中存储玩家的hp，我们将声明以下代码行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line of code reserves a small chunk of RAM to store an integer (`int` is
    short for integer), called hp. The following is an example of our chunk of RAM
    used to store the player's hp. This reserves a parking space for us in memory
    (among all the other parking spaces), and we can refer to this space in memory
    by its label (hp).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码为存储整数（`int`代表整数）的内存块预留了一小块RAM，称为hp。以下是我们用于存储玩家hp的RAM块示例。这在我们内存中的所有停车位中为我们预留了一个停车位，我们可以通过其标签（hp）来引用这个内存空间。
- en: '![Declaring variables – touching the silicon](img/00023.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![声明变量 – 触摸硅](img/00023.jpeg)'
- en: Among all the other spaces in memory, we get one spot to store our hp data
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中的所有其他空间中，我们得到一个位置来存储我们的hp数据
- en: 'Notice how the variable space is type-marked in this diagram as **int**: if
    it is a space for a double or a different type of variable. C++ remembers the
    spaces that you reserve for your program in memory not only by name but by the
    type of variable it is as well.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个图中变量空间被标记为**int**：如果它是一个用于double或其他类型变量的空间。C++不仅通过名称，还通过变量的类型来记住您在内存中为程序预留的空间。
- en: Notice that we haven't put anything in hp's box yet! We'll do that later—right
    now, the value of the hp variable is not set, so it will have the value that was
    left in that parking space by the previous occupant (the value left behind by
    another program, perhaps). Telling C++ the type of the variable is important!
    Later, we will declare a variable to store decimal values, such as 3.75.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还没有在hp的框中放入任何东西！我们稍后会做这件事——现在，hp变量的值尚未设置，因此它将保留前一个占用者（可能是另一个程序留下的值）在该停车位上的值。告诉C++变量的类型很重要！稍后，我们将声明一个变量来存储小数值，例如3.75。
- en: Reading and writing to your reserved spot in memory
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在内存中读取和写入您的预留位置
- en: 'Writing a value into memory is easy! Once you have an `hp` variable, you just
    write to it using the `=` sign:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将值写入内存很容易！一旦你有一个`hp`变量，你只需使用`=`符号写入它：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Voila! The player has 500 hp.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！玩家有500 hp。
- en: 'Reading the variable is equally simple. To print out the value of the variable,
    simply put this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 读取变量同样简单。要打印变量的值，只需这样做：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print the value stored inside the hp variable. If you change the
    value of hp, and then use `cout` again, the most up-to-date value will be printed,
    as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出存储在hp变量中的值。如果你更改了hp的值，然后再次使用`cout`，将打印出最新的值，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Numbers are everything
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字是一切
- en: Something that you need to get used to when you start computer programming is
    that a surprising number of things can be stored in computer memory as just numbers.
    A player's hp? As we just saw in the previous section, hp can just be an integer
    number. If the player gets hurt, we reduce this number. If the player gains health,
    we increase the number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习计算机编程时，你需要习惯的是，许多东西都可以以数字的形式存储在计算机内存中。玩家的hp？正如我们在上一节中看到的，hp可以只是一个整数。如果玩家受伤，我们就减少这个数字。如果玩家恢复健康，我们就增加这个数字。
- en: 'Colors can be stored as numbers too! If you''ve used standard image editing
    programs, there are usually sliders that indicate color as how much red, green,
    and blue are being used, such as Pixelmator''s color sliders. A color is then
    represented by three numbers. The purple color shown in the following screenshot
    is (R=127, G=34, B=203):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色也可以存储为数字！如果你使用过标准的图像编辑程序，通常会有表示颜色的滑块，指示使用多少红色、绿色和蓝色，例如Pixelmator的颜色滑块。颜色由三个数字表示。以下屏幕截图显示的紫色颜色是（R=127，G=34，B=203）：
- en: '![Numbers are everything](img/00024.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![数字无处不在](img/00024.jpeg)'
- en: 'What about world geometry? These are also just numbers: all we have to do is
    store a list of 3D space points (x, y, and z coordinates) and then store another
    list of points that explain how those points can be connected to form triangles.
    In the following screenshot, we can see how 3D space points are used to represent
    world geometry:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于世界几何呢？这些也只是数字：我们只需要存储一个包含3D空间点（x、y和z坐标）的列表，然后存储另一个解释这些点如何连接形成三角形的点的列表。在下面的屏幕截图中，我们可以看到如何使用3D空间点来表示世界几何：
- en: '![Numbers are everything](img/00025.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![数字无处不在](img/00025.jpeg)'
- en: The combination of numbers for colors and numbers for 3D space points will let
    you draw large and colored landscapes in your game world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色和3D空间点的数字组合将让你在你的游戏世界中绘制出大型的彩色景观。
- en: The trick with the preceding examples is how we interpret the stored numbers
    so that we can make them mean what we want them to mean.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的技巧在于我们如何解释存储的数字，以便我们可以让它们代表我们想要它们代表的意义。
- en: More on variables
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于变量的内容
- en: 'You can think of variables as animal-carrying cases. A cat carrier can be used
    to carry a cat, but not a dog. Similarly, you should use a float-type variable
    to carry decimal-valued numbers. If you store a decimal value inside an `int`
    variable, it will not fit:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把变量想象成动物携带的箱子。猫携带箱可以用来携带猫，但不能用来携带狗。同样，你应该使用浮点型变量来携带带有小数点的数字。如果你在`int`变量中存储小数值，它将不会适合：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What's really happening here is that C++ does an automatic type conversion on
    38.87, *transmogrifying* it to an integer to fit in the `int` carrying case. It
    drops the decimal to convert 38.87 into the integer value 38.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这里发生的事情是C++对38.87进行自动类型转换，*将其转换为一个整数以适应`int`存储空间。它丢弃小数点，将38.87转换为整数值38。
- en: 'So, for example, we can modify the code to include the use of three types of
    variables, as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以修改代码以包含三种类型变量的使用，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the first three lines, we declare three boxes to store our data parts into,
    as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三行中，我们声明了三个盒子来存储我们的数据部分，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These three lines reserve three spots in memory (like parking spaces). The
    next three lines fill the variables with the values we desire, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行在内存中预留了三个位置（就像停车位一样）。接下来的三行将变量填充为我们想要的值，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In computer memory, this will look as shown in the following figure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机内存中，这看起来如下面的图所示：
- en: '![More on variables](img/00026.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![更多关于变量的内容](img/00026.jpeg)'
- en: 'You can change the contents of a variable at any time. You can write a variable
    using the `=` assignment operator, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时更改变量的内容。你可以使用`=`赋值运算符来写入变量，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also read the contents of a variable at any time. That''s what the
    next three lines of code do, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在任何时候读取变量的内容。这就是下面三行代码所做的事情，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take a look at this line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这一行：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are two uses of the word `hp` in this line. One is between double quotes,
    while the other is not. Words between double quotes are always output exactly
    as you typed them. When double quotes are not used (for example, `<< hp <`), a
    variable lookup is performed. If the variable does not exist, then you will get
    a compiler error (undeclared identifier).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，“hp”一词有两种用法。一种是在双引号之间，另一种则不是。双引号之间的单词总是按照你输入的方式精确输出。当不使用双引号时（例如，`<< hp
    <`），将执行变量查找。如果变量不存在，则你会得到编译器错误（未声明的标识符）。
- en: There is a space in memory that is allocated for the name, a space for how many
    `goldPieces` the player has, and a space for the hp of the player.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中有一个为名称分配的空间，一个为玩家拥有的`goldPieces`数量分配的空间，以及一个为玩家生命值`hp`分配的空间。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In general, you should always try to store the right type of data inside the
    right type of variable. If you happen to store the wrong type of data, your code
    may misbehave.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该始终尝试在正确的变量中存储正确的数据类型。如果你不小心存储了错误的数据类型，你的代码可能会出现异常行为。
- en: Math in C++
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的数学
- en: 'Math in C++ is easy to do; + (plus), - (minus), * (times), / (divide by) are
    all common C++ operations, and proper BEDMAS order will be followed (Brackets,
    Exponents, Division, Multiplication, Addition, and Subtraction). For example,
    we can do as shown in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的数学运算很容易；+ (加)，- (减)，* (乘)，/ (除)都是常见的C++操作，并且将遵循正确的BEDMAS顺序（括号，指数，除法，乘法，加法，减法）。例如，我们可以像以下代码所示进行操作：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another operator that you might not be familiar with yet is % (modulus). Modulus
    (for example, 10 % 3) finds the remainder of when `x` is divided by `y`. See the
    following table for examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还不熟悉另一个运算符：% (取模)。取模（例如，10 % 3）找到当`x`除以`y`时的余数。以下表格中有示例：
- en: '| Operator (name) | Example | Answer |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 运算符（名称） | 示例 | 答案 |'
- en: '| --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| + (plus) | 7 + 3 | 10 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| + (加) | 7 + 3 | 10 |'
- en: '| - (minus) | 8 - 5 | 3 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| - (减) | 8 - 5 | 3 |'
- en: '| * (times) | 5*6 | 30 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| * (乘) | 5*6 | 30 |'
- en: '| / (division) | 12/6 | 2 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| / (除) | 12/6 | 2 |'
- en: '| % (modulus) | 10 % 3 | 1 (because 10/3 is 3 the remainder = 1). |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| % (取模) | 10 % 3 | 1 (因为10除以3等于3，余数=1)。 |'
- en: However, we often don't want to do math in this manner. Instead, we usually
    want to change the value of a variable by a certain computed amount. This is a
    concept that is harder to understand. Say the player encounters an imp and is
    dealt 15 damage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常不希望以这种方式进行数学运算。相反，我们通常希望通过一定的计算量来改变变量的值。这是一个较难理解的概念。比如说，玩家遇到了一个恶魔并受到了15点伤害。
- en: 'The following line of code will be used to reduce the player''s hp by 15 (believe
    it or not):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将用于减少玩家的生命值15点（信不信由你）：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might ask why. Because on the right-hand side, we are computing a new value
    for hp (`hp-15`). After the new value for hp is found (15 less than what it was
    before), the new value is written into the hp variable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么。因为在右侧，我们正在计算hp的新值（hp-15）。在找到hp的新值（比之前少15）后，新值将被写入hp变量。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Pitfall**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱**'
- en: 'An uninitialized variable has the bit pattern that was held in memory for it
    before. Declaring a variable does not clear the memory. So, say we used the following
    line of code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未初始化的变量具有它在内存中之前所持有的位模式。声明一个变量不会清除内存。所以，假设我们使用了以下代码行：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second line of code reduces the hp by 15 from its previous value. What was
    its previous value if we never set hp = 100 or so? It could be 0, but not always.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代码从其之前的值中减少了15点生命值。如果我们从未设置hp = 100或类似值，它的前一个值是多少？它可能是0，但并不总是这样。
- en: One of the most common errors is to proceed with using a variable without initializing
    it first.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的错误之一是在未初始化变量之前就使用它。
- en: 'The following is a shorthand syntax for doing this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个进行此操作的缩写语法：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Besides `-=`, you can use += to add some amount to a variable, *= to multiply
    a variable by an amount, and /= to divide a variable by some amount.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`-=`之外，您还可以使用`+=`向变量添加一些量，使用`*=`将变量乘以一个量，使用`/=`将变量除以一个量。
- en: Exercises
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write down the value of `x` after performing the following operations; then,
    check with your compiler:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作后，写下`x`的值；然后，与您的编译器进行核对：
- en: '| Exercises | Solutions |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 练习 | 答案 |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `int x = 4; x += 4;` | 8 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 4; x += 4;` | 8 |'
- en: '| `int x = 9; x-=2;` | 7 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 9; x-=2;` | 7 |'
- en: '| `int x = 900; x/=2;` | 450 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 900; x/=2;` | 450 |'
- en: '| `int x = 50; x*=2;` | 100 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 50; x*=2;` | 100 |'
- en: '| `int x = 1; x += 1;` | 2 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 1; x += 1;` | 2 |'
- en: '| `int x = 2; x -= 200;` | -198 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 2; x -= 200;` | -198 |'
- en: '| `int x = 5; x*=5;` | 25 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `int x = 5; x*=5;` | 25 |'
- en: Generalized variable syntax
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用变量语法
- en: 'In the previous section, you learned that every piece of data that you save
    in C++ has a type. All variables are created in the same way; in C++, variable
    declarations are of the form:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了在C++中保存的每份数据都有一个类型。所有变量都是以相同的方式创建的；在C++中，变量声明形式如下：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `variableType` tells you what type of data we are going to store in our
    variable. The `variableName` is the symbol we'll use to read or write to that
    piece of memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`variableType`告诉我们我们将要存储在变量中的数据类型。`variableName`是我们将用于读取或写入该内存块的符号。'
- en: Primitive types
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: We previously talked about how all the data inside a computer will at some point
    be a number. Your computer code is responsible for interpreting that number correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了计算机内部的所有数据最终都将是数字。你的计算机代码负责正确解释这个数字。
- en: 'It is said that C++ only defines a few basic data types, as shown in the following
    table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 据说 C++ 只定义了几个基本数据类型，如下表所示：
- en: '| `Char` | A single letter, such as ''a'', ''b'', or ''+'' |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Char` | 一个单独的字母，例如 ''a''、''b'' 或 ''+'' |'
- en: '| `Short` | An integer from -32,767 to +32,768 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | 从 -32,767 到 +32,768 的整数 |'
- en: '| `Int` | An integer from -2,147,483,647 to +2,147,483,648 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | 从 -2,147,483,647 到 +2,147,483,648 的整数 |'
- en: '| `Float` | Any decimal value from approx. -1x1038 to 1x1038 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | 从约 -1x10^38 到 1x10^38 的任何十进制值 |'
- en: '| `Double` | Any decimal value from approx. -1x10308 to 1x10308 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Double` | 从约 -1x10^308 到 1x10^308 的任何十进制值 |'
- en: '| `Bool` | true or false |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | true 或 false |'
- en: There are unsigned versions of each of the variable types mentioned in the preceding
    table. An unsigned variable can contain natural numbers, including 0 (x >= 0).
    An unsigned `short`, for example, might have a value between 0 and 65535.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前表中所提到的每种变量类型都有无符号版本。无符号变量可以包含自然数，包括 0（x >= 0）。例如，无符号 `short` 可能的值在 0 到 65535
    之间。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're further interested in the difference between float and double, please
    feel free to look it up on the Internet. I will keep my explanations only to the
    most important C++ concepts used for games. If you are curious about something
    that's covered by this text, feel free to look it up.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进一步对 float 和 double 之间的区别感兴趣，请随时在互联网上查找。我将只解释最重要的用于游戏的 C++ 概念。如果你对这个文本中涵盖的某件事感到好奇，请随时查找。
- en: It turns out that these simple data types alone can be used to construct arbitrarily
    complex programs. "How?" you ask. Isn't it hard to build a 3D game using just
    floats and integers?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这些简单的数据类型本身就可以用来构建任意复杂的程序。“怎么做到的？”你可能会问。仅使用浮点数和整数构建 3D 游戏难道不难吗？
- en: It is not really difficult to build a game from float and int, but more complex
    data types help. It will be tedious and messy to program if we used loose floats
    for the player's position.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从浮点数和整数构建游戏并不真的很难，但更复杂的数据类型会有帮助。如果我们使用松散的浮点数来表示玩家的位置，编程将会变得繁琐且混乱。
- en: Object types
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类型
- en: 'C++ gives you structures to group variables together, which will make your
    life a lot easier. Take an example of the following block of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了结构来将变量分组在一起，这将使你的生活更加轻松。以下是一段代码示例：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The way this looks in memory is pretty intuitive; a Vector is just a chunk
    of memory with three floats, as shown in the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这在内存中的样子非常直观；Vector 只是一个包含三个浮点数的内存块，如图所示。
- en: '![Object types](img/00027.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![对象类型](img/00027.jpeg)'
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't confuse the struct Vector in the preceding screenshot with the `std::vector`
    of the STL. The Vector object above is meant to represent a three-space vector,
    while STL's `std::vector` type represents a sized collection of values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆前一个截图中的 struct Vector 与 STL 的 `std::vector`。上面的 Vector 对象旨在表示一个三维向量，而 STL
    的 `std::vector` 类型表示一个值的固定大小集合。
- en: 'Here are a couple of review notes about the preceding code listing:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于前面代码列表的复习笔记：
- en: 'First, even before we use our Vector object type, we have to define it. C++
    does not come with built-in types for math vectors (it only supports scalar numbers,
    and they thought that was enough!). So, C++ lets you build your own object constructions
    to make your life easier. We first had the following definition:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，甚至在我们在使用我们的 Vector 对象类型之前，我们必须定义它。C++ 并没有内置的数学向量类型（它只支持标量数，他们认为这已经足够了！）。因此，C++
    允许你构建自己的对象结构，使你的生活更轻松。我们首先有以下定义：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This it tells the computer what a Vector is (it's 3 floats, all of which are
    declared to be sitting next to each other in the memory). The way a Vector will
    look in the memory is shown in preceding figure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉计算机什么是 Vector（它是 3 个浮点数，所有这些都被声明为在内存中相邻）。Vector 在内存中的样子如图所示。
- en: 'Next, we use our Vector object definition to create a Vector instance called
    `v`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们的 Vector 对象定义来创建一个名为 `v` 的 Vector 实例：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `struct` Vector definition doesn't actually create a Vector object. You
    can't do `Vector.x = 1`. "Which object instance are you talking about?" the C++
    compiler will ask. You need to create a Vector instance first, such as Vector
    v1; then, you can do assignments on the v1 instance, such as v1.x = 0.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` Vector定义实际上并没有创建一个Vector对象。你不能做`Vector.x = 1`。"你在谈论哪个对象实例？" C++编译器会问。你需要首先创建一个Vector实例，例如Vector
    v1; 然后，你可以在v1实例上执行赋值，例如v1.x = 0。'
- en: 'We then use this instance to write values into `v`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用这个实例将值写入`v`：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We used commas in the preceding code to initialize a bunch of variables on the
    same line. This is okay in C++. Although you can do each variable on its own line,
    the approach shown here is okay too.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了逗号来初始化同一行上的多个变量。这在C++中是可以的。虽然你可以将每个变量单独放在一行上，但这里展示的方法也是可以的。
- en: 'This makes `v` look as in the preceding screenshot. Then, we print them out:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`v`看起来像前面的截图。然后，我们打印它们：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In both the lines of code here, we access the individual data members inside
    the object by simply using a dot (`.`). `v.x` refers to the `x` member inside
    the object `v`. Each Vector object will have exactly three floats inside it: one
    called `x`, one called `y`, and one called `z`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的两行代码中，我们通过简单地使用点（`.`）访问对象内的单个数据成员。`v.x`指的是对象`v`内的`x`成员。每个Vector对象将正好包含三个浮点数：一个叫`x`，一个叫`y`，一个叫`z`。
- en: Exercise – Player
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 – Player
- en: Define a C++ data struct for a Player object. Then, create an instance of your
    Player class and fill each of the data members with values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个用于Player对象的C++数据结构。然后，创建你的Player类的一个实例，并填充每个数据成员的值。
- en: Solution
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Let''s declare our Player object. We want to group together everything to do
    with the player into the Player object. We do this so that the code is neat and
    tidy. The code you read in Unreal Engine will use objects such as these everywhere;
    so, pay attention:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明我们的Player对象。我们希望将所有与玩家相关的代码组合到Player对象中。我们这样做是为了使代码整洁有序。你在Unreal Engine中看到的代码将到处使用这样的对象；所以，请注意：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The struct Player definition is what tells the computer how a Player object
    is laid out in memory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结构Player定义告诉计算机Player对象在内存中的布局方式。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I hope you noticed the mandatory semicolon at the end of the struct declaration.
    struct object declarations need to have a semicolon at the end, but functions
    do not. This is just a C++ rule that you must remember.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们注意到了结构声明末尾的强制分号。结构对象声明需要在末尾有一个分号，但函数不需要。这只是你必须记住的C++规则。
- en: Inside a Player object, we declared a string for the player's name, a float
    for his hp, and a Vector object for his complete xyz position.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Player对象内部，我们声明了一个用于玩家名称的字符串，一个用于hp的浮点数，以及一个用于玩家完整xyz位置的Vector对象。
- en: When I say object, I mean a C++ struct (or later, we will introduce the term
    class).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说对象时，我指的是C++结构（或者稍后，我们将介绍术语类）。
- en: Wait! We put a Vector object inside a Player object! Yes, you can do that.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们在Player对象中放了一个Vector对象！是的，你可以这样做。
- en: After the definition of what a Player object has inside it, we actually create
    a Player object instance called me and assign it some values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了Player对象内部有什么之后，我们实际上创建了一个名为me的Player对象实例，并给它赋了一些值。
- en: 'After the assignment, the me object looks as shown in the following figure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值之后，me对象看起来如下所示：
- en: '![Solution](img/00028.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案](img/00028.jpeg)'
- en: Pointers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: A particularly tricky concept to grasp is the concept of pointers. Pointers
    aren't that hard to understand but can take a while to get a firm handle on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别难以理解的概念是指针的概念。指针并不难理解，但可能需要一段时间才能牢固掌握。
- en: 'Say we have, as before, declared a variable of the type Player in memory:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们之前已经在内存中声明了一个类型为Player的变量：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now declare a pointer to the Player:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在声明一个指向Player的指针：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `*` characters usually make things special. In this case, the `*` makes
    `ptrMe` special. The `*` is what makes `ptrMe` a pointer type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`字符通常使事物变得特殊。在这种情况下，`*`使`ptrMe`变得特殊。`*`是使`ptrMe`成为指针类型的原因。'
- en: 'We now want to link `ptrMe` to me:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想将`ptrMe`链接到me：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This linkage step is very important. If you don't link the pointer to an object
    before you use the pointer, you will get a memory access violation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链接步骤非常重要。如果你在使用指针之前没有将指针链接到对象，你将得到一个内存访问违规。
- en: '`ptrMe` now refers to the same object as me. Changing `ptrMe` will change me,
    as shown in the following figure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptrMe`现在指向与me相同的对象。改变`ptrMe`将改变me，如下面的图所示：'
- en: '![Pointers](img/00029.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![指针](img/00029.jpeg)'
- en: What can pointers do?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针能做什么？
- en: When we set up the linkage between the pointer variable and what it is pointing
    to, we can manipulate the variable that is pointed to through the pointer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置指针变量和它所指向的内容之间的链接时，我们可以通过指针来操作所指向的变量。
- en: One use of pointers is to refer to the same object from several different locations
    of the code. The Player object is a good candidate for being pointed to. You can
    create as many pointers as you wish to the same object. Objects that are pointed
    to do not necessarily know that they are being pointed at, but changes can be
    made to the object through the pointers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的一个用途是从代码的几个不同位置引用同一个对象。`Player` 对象是很好的候选对象。你可以为同一个对象创建任意数量的指针。被指向的对象不一定知道它们被指向，但可以通过指针对对象进行更改。
- en: 'For instance, say the player got attacked. A reduction in his hp will result,
    and this reduction will be done using the pointer, as shown in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设玩家受到了攻击。他的 hp 会减少，这个减少将通过指针来完成，如图所示代码：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s how the Player object looks now:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 `Player` 对象的当前样子：
- en: '![What can pointers do?](img/00030.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![指针能做什么？](img/00030.jpeg)'
- en: So, we changed `me.name` by changing `ptrMe->name`. Because `ptrMe` points to
    me, changes through `ptrMe` affect me directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过改变 `ptrMe->name` 来改变 `me.name`。因为 `ptrMe` 指向 `me`，通过 `ptrMe` 的更改会直接影响
    `me`。
- en: Besides the funky arrow syntax (use `->` when the variable is a pointer), this
    concept isn't all that hard to understand.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有趣的箭头语法（当变量是指针时使用 `->`），这个概念并不难理解。
- en: Address of operator &
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址运算符 &
- en: Notice the use of the `&` symbol in the preceding code example. The `&` operator
    gets the memory address of a variable. A variable's memory address is where it
    lives in the computer memory space. C++ is able to get the memory address of any
    object in your program's memory. The address of a variable is unique and also,
    kind of, random.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面代码示例中 `&` 符号的使用。`&` 运算符获取变量的内存地址。变量的内存地址是它在计算机内存空间中的位置。C++ 能够获取程序内存中任何对象的内存地址。变量的地址是唯一的，也是随机的。
- en: 'Say, we print the address of an integer variable `x`, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们打印一个整型变量 `x` 的地址，如下所示：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the first run of the program, my computer prints the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序第一次运行时，我的电脑打印了以下内容：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This number (the value of `&x`) is just the memory cell where the variable
    `x` is stored. What this means is that in this particular launch of the program,
    the variable `x` is located at memory cell number 0023F744, as shown in the following
    figure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字（`&x` 的值）只是变量 `x` 存储的内存单元。这意味着在这个特定的程序启动中，变量 `x` 位于内存单元编号 0023F744，如图所示：
- en: '![Address of operator &](img/00031.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![地址运算符 &](img/00031.jpeg)'
- en: 'Now, create and assign a pointer variable to the address of `x`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建并分配一个指针变量到 `x` 的地址：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What we''re doing here is storing the memory address of `x` inside the variable
    `px`. So, we are metaphorically pointing to the variable `x` using another different
    variable called `px`. This might look something similar to what is shown in the
    following figure:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是将变量 `x` 的内存地址存储在变量 `px` 中。所以，我们用另一个叫做 `px` 的不同变量来隐喻地指向变量 `x`。这看起来可能和下面图示的类似：
- en: '![Address of operator &](img/00032.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![地址运算符 &](img/00032.jpeg)'
- en: 'Here, the variable `px` has the address of the variable `x` inside it. In other
    words, the variable `px` is a reference to another variable. Differencing `px`
    means to access the variable that `px` is referencing. Differencing is done using
    the `*` symbol:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量 `px` 包含了变量 `x` 的地址。换句话说，变量 `px` 是另一个变量的引用。对 `px` 进行求差（即访问 `px` 所引用的变量）是通过使用
    `*` 符号来完成的：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Null pointers
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空指针
- en: 'A null pointer is a pointer variable with the value `0`. In general, most programmers
    like to initialize pointers to Null (`0`) on the creation of new pointer variables.
    Computer programs, in general, can''t access the memory address `0` (it is reserved),
    so if you try to reference a Null pointer, your program will crash, as shown in
    the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 空指针是一个值为 `0` 的指针变量。一般来说，大多数程序员喜欢在创建新的指针变量时将其初始化为空（`0`）。计算机程序通常不能访问内存地址 `0`（它是保留的），所以如果你尝试引用空指针，你的程序将会崩溃，如图所示：
- en: '![The Null pointers](img/00033.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![空指针](img/00033.jpeg)'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Pointer Fun with Binky is a fun video about pointers. Take a look at [http://www.youtube.com/watch?v=i49_SNt4yfk](http://www.youtube.com/watch?v=i49_SNt4yfk).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Pointer Fun with Binky 是一个关于指针的有趣视频。看看 [http://www.youtube.com/watch?v=i49_SNt4yfk](http://www.youtube.com/watch?v=i49_SNt4yfk)。
- en: cin
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cin
- en: '`cin` is the way C++ traditionally takes input from the user into the program.
    `cin` is easy to use, because it looks at the type of variable it will put the
    value into as it puts it in. For example, say we want to ask the user his age
    and store it in an `int` variable. We can do that as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`cin` 是 C++ 传统的从用户输入到程序的方式。`cin` 很容易使用，因为它在放置值时会查看将要放入的变量的类型。例如，如果我们想询问用户的年龄并将其存储在一个
    `int` 变量中，我们可以这样做：'
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: printf()
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: printf()
- en: Although we have used `cout` to print out variables so far, you need to know
    about another common function that is used to print to the console. This function
    is called the `printf` function. The `printf` function is included in the `<iostream>`
    library, so you don't have to `#include` anything extra to use it. Some people
    in the gaming industry prefer `printf` to `cout` (I know I do), so let's introduce
    it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们到目前为止已经使用了 `cout` 来打印变量，但你需要了解另一个常用的用于打印到控制台的功能。这个功能被称为 `printf` 函数。`printf`
    函数包含在 `<iostream>` 库中，所以你不需要额外 `#include` 任何内容来使用它。游戏行业的一些人更喜欢使用 `printf` 而不是
    `cout`（我知道我就是这样），所以让我们来介绍它。
- en: 'Let''s proceed to how `printf()` works, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续了解 `printf()` 的工作原理，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 出版物书籍的账户中下载示例代码文件 [http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: 'We start with a format string. The format string is like a picture frame, and
    the variables will get plugged in at the locations of the `%` in the format string.
    Then, the entire thing gets dumped out to the console. In the preceding example,
    the integer variable will be plugged into the location of the first `%` (`%d`),
    and the character will be plugged into the location of the second `%` (`%c`),
    as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个格式字符串开始。格式字符串就像一个画框，变量将会被插入到格式字符串中 `%` 的位置。然后，整个内容会被输出到控制台。在上面的例子中，整数变量将被插入到第一个
    `%` (`%d`) 的位置，字符将被插入到第二个 `%` (`%c`) 的位置，如下面的截图所示：
- en: '![printf()](img/00034.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![printf()](img/00034.jpeg)'
- en: 'You have to use the right format code to get the output to format correctly;
    take a look at the following table:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用正确的格式代码才能正确地格式化输出；请查看以下表格：
- en: '| Data type | Format code |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 格式代码 |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Int | %d |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | %d |'
- en: '| Char | %c |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | %c |'
- en: '| String | %s |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | %s |'
- en: 'To print a C++ string, you must use the `string.c_str()` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印 C++ 字符串，你必须使用 `string.c_str()` 函数：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `s.c_str()` function accesses the C pointer to the string, which `printf`
    needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.c_str()` 函数访问 `printf` 所需的 C 字符串指针。'
- en: If you use the wrong format code, the output won't appear correctly or the program
    might crash.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用错误的格式代码，输出可能不会正确显示，或者程序可能会崩溃。
- en: Exercise
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Ask the user his name and age and take them in using `cin`. Then, issue a greeting
    for him at the console using `printf()` (not `cout`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户的姓名和年龄，并使用 `cin` 读取它们。然后，使用 `printf()`（而不是 `cout`）在控制台为他发出问候。
- en: Solution
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is how the program will look:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是程序的外观：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A string is actually an object type. Inside it is just a bunch of chars!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串实际上是一种对象类型。里面只是一堆字符！
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we spoke about variables and memory. We talked about mathematical
    operations on variables and how simple they were in C++.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了变量和内存。我们讨论了变量上的数学运算以及它们在 C++ 中的简单性。
- en: We also discussed how arbitrarily complex data types can be built using a combination
    of these simpler data types, such as floats, integers, and characters. Constructions
    such as this are called objects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何使用这些更简单的数据类型（如浮点数、整数和字符）的组合来构建任意复杂的数据类型。这种构建称为对象。
