- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Communicating with Market Participants
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与市场参与者通信
- en: In this chapter, we will build the order gateway component at the electronic
    trading exchange that is responsible for accepting client connections, handling
    requests, and publishing responses to clients about their orders when there are
    updates. Fairness, low latency, and low jitter (latency variance) are important
    requirements here to facilitate high-frequency trading participants. We will also
    build the component that publishes market data from the trading exchange. These
    market data updates are designed to allow clients to construct the order book
    of all client orders that the electronic trading exchange holds. These market
    updates need to be sent out as soon as possible when there are order updates and
    when matches occur, so the focus will be on super-low-latency performance. Additionally,
    the exchange needs to periodically provide snapshots of the order book for participants
    that drop packets or start after the market is already open.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建电子交易交易所中的订单网关组件，该组件负责接受客户端连接、处理请求，并在有更新时向客户端发布关于其订单的响应。公平性、低延迟和低抖动（延迟变化）是这里的重要要求，以促进高频交易参与者。我们还将构建从交易交易所发布市场数据的组件。这些市场数据更新旨在允许客户端构建电子交易交易所持有的所有客户订单的订单簿。当有订单更新和匹配发生时，这些市场更新需要尽快发送出去，因此重点将放在超低延迟性能上。此外，交易所还需要定期为那些掉包或在市场已经开盘后开始参与的市场参与者提供订单簿快照。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining the market data protocol and order data protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义市场数据协议和订单数据协议
- en: Building the order gateway server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建订单网关服务器
- en: Building the market data publisher
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建市场数据发布者
- en: Building the main exchange application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建主要交易所应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in the GitHub repository for this book
    at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source code for this chapter can be found in the `Chapter7` directory in the
    repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在本书的GitHub仓库[https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)中找到。本章的源代码可以在仓库中的`Chapter7`目录中找到。
- en: It is important that you have read and understood the design of the electronic
    trading ecosystem presented in the *Designing Our Trading Ecosystem* chapter.
    The components we build in this chapter will interact with the matching engine
    we built in the *Building the C++ Matching Engine* chapter, so we assume you are
    familiar with that. As before, we will use the building blocks we built in the
    *Building the C++ Building Blocks for Low-Latency* *Applications* chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你已经阅读并理解了*设计我们的交易生态系统*章节中展示的电子交易生态系统的设计。我们在本章构建的组件将与我们在*构建C++匹配引擎*章节中构建的匹配引擎交互，因此我们假设你熟悉这一点。和之前一样，我们将使用我们在*构建低延迟应用的C++构建块*章节中构建的构建块。
- en: Defining the market data protocol and order data protocol
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义市场数据协议和订单数据协议
- en: Before we build the components inside the trading exchange that publish market
    data updates and receive and respond to client requests, we need to finalize the
    protocol. The protocol needs to be publicly available so that market participants
    who want to connect to the exchange, process updates, and send order requests
    can build their software. The protocol is the *language* that the exchange and
    market participants will use to communicate. We will have two protocols – one
    for the format of the market data updates and one for the format to send order
    requests and receive order responses in.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建交易交换内部发布市场数据更新并接收和响应客户端请求的组件之前，我们需要最终确定协议。该协议需要公开可用，以便想要连接到交易所、处理更新和发送订单请求的市场参与者能够构建他们的软件。该协议是交易所和市场参与者将用于通信的*语言*。我们将有两个协议——一个用于市场数据更新的格式，另一个用于发送订单请求和接收订单响应的格式。
- en: Designing the market data protocol
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计市场数据协议
- en: For the market data protocol, we will define an internal format that the matching
    engine uses, and a public format meant for the market participants. We saw the
    internal matching format, that is, the `MEMarketUpdate` struct, in the *Building
    the Matching Engine* chapter, in the *Defining the operations and interactions
    in our matching engine* section. In this section, we will define the public market
    data format, which will be encapsulated in the `MDPMarketUpdate` struct. Remember
    that we mentioned that market data formats can be of several types and different
    complexity, for example, the FAST protocol or the SBE protocol. For our market
    data format, we will use the `Chapter7/exchange/market_data/market_update.h` source
    file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于市场数据协议，我们将定义一个内部格式，这是匹配引擎使用的，以及一个公共格式，用于市场参与者。我们在*构建匹配引擎*章节的*定义匹配引擎中的操作和交互*部分中看到了内部匹配格式，即`MEMarketUpdate`结构。在本节中，我们将定义公共市场数据格式，它将被封装在`MDPMarketUpdate`结构中。记住，我们提到市场数据格式可以是几种类型和不同复杂度，例如FAST协议或SBE协议。对于我们的市场数据格式，我们将使用`Chapter7/exchange/market_data/market_update.h`源文件。
- en: Before we look at the market data protocol, a reminder that we first explained
    what a snapshot of market data is, why it is needed, and how it is synthesized
    using incremental market data updates in the *Designing Our Trading Ecosystem*
    chapter in the *Understanding how an exchange publishes information to participants*
    section, in the *Designing the market data publisher* subsection. Additionally,
    we discussed additional details about the snapshot data stream in the same chapter,
    in the *Building a market participant’s interface to the exchange* section. So,
    it would be worthwhile to revisit those sections if a refresher of those concepts
    is required. But just to re-introduce snapshot messages, these are messages that
    contain full information about the state of the limit order book at any given
    time and can be used by market participants if they need to re-construct the full
    limit order book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看市场数据协议之前，提醒一下，我们首先在*设计我们的交易生态系统*章节的*理解交易所如何向参与者发布信息*部分的*设计市场数据发布者*子部分中解释了市场数据快照是什么，为什么需要它，以及它是如何使用增量市场数据更新合成的。此外，我们在同一章节的*构建市场参与者与交易所的接口*部分讨论了快照数据流的更多细节。因此，如果需要复习这些概念，重新访问这些部分将是有益的。但为了重新介绍快照消息，这些消息包含任何给定时间限价订单簿状态的完整信息，并且如果市场参与者需要重新构建完整的限价订单簿，可以使用这些信息。
- en: Before we look at the `MDPMarketUpdate` struct, let us first revisit the `MarketUpdateType`
    enumeration we created in the previous chapter. In this chapter, we will add a
    few new enumeration types here – `CLEAR`, `SNAPSHOT_START`, and `SNAPSHOT_END`
    – which will be needed later. The `CLEAR` message is used to notify clients that
    they should clear/empty the order book on their end, `SNAPSHOT_START` signifies
    that a snapshot message is starting, and `SNAPSHOT_END` signifies that all updates
    in the snapshot update have been delivered.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`MDPMarketUpdate`结构之前，让我们首先回顾一下我们在上一章中创建的`MarketUpdateType`枚举。在本章中，我们将在此处添加几个新的枚举类型——`CLEAR`、`SNAPSHOT_START`和`SNAPSHOT_END`——这些将在以后需要。`CLEAR`消息用于通知客户端他们应该在他们的端清除/清空订单簿，`SNAPSHOT_START`表示快照消息的开始，而`SNAPSHOT_END`表示快照更新中的所有更新都已交付。
- en: 'The updated enumeration list is shown as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的枚举列表如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `MDPMarketUpdate` structure contains an important addition over the `MEMarketUpdate`
    structure, which is a sequence number field. This `size_t seq_num_` field is an
    increasing sequence number value for every market update published by the exchange.
    For every new market update, the sequence number is exactly 1 greater than the
    previous market update. This sequence number field will be used by the market
    data consumers in the market participants’ trading systems to detect gaps in market
    updates. Remember that for our market data publisher, we will publish the market
    data in UDP format, which is an unreliable protocol. So, when there are drops
    in packets at the network level, or if a participant’s system drops a packet,
    they can use the sequence number field to detect that. We present the internal
    `MEMarketUpdate` format again, and the new public `MDPMarketUpdate` format as
    follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MDPMarketUpdate` 结构相对于 `MEMarketUpdate` 结构增加了一个重要的字段，即序列号字段。这个 `size_t
    seq_num_` 字段是交易所发布的每个市场更新的递增序列号值。对于每个新的市场更新，序列号正好比前一个市场更新大1。这个序列号字段将由市场数据消费者在市场参与者的交易系统中用来检测市场更新的间隔。记住，对于我们的市场数据发布者，我们将以
    UDP 格式发布市场数据，这是一个不可靠的协议。所以，当网络层面出现数据包丢失，或者如果某个参与者的系统丢失了一个数据包，他们可以使用序列号字段来检测这一点。我们再次展示
    `MEMarketUpdate` 的内部格式，以及新的公共 `MDPMarketUpdate` 格式如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Hence, `MDPMarketUpdate` is simply `MEMarketUpdate` with a leading `seq_num_`
    field. Before we finish this subsection, we will define two simple typedefs that
    we will need later in this chapter. We saw the first one, `MEMarketUpdateLFQueue`,
    in the previous chapter; the new `MDPMarketUpdateLFQueue` is similar and represents
    a lock-free queue of `MDPMarketUpdate` structures:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`MDPMarketUpdate` 简单地是 `MEMarketUpdate`，只是在前面添加了一个 `seq_num_` 字段。在我们完成这个子节之前，我们将定义两个简单的
    `typedef`，我们将在本章后面用到。我们在上一章中看到了第一个，`MEMarketUpdateLFQueue`；新的 `MDPMarketUpdateLFQueue`
    与之类似，代表一个 `MDPMarketUpdate` 结构的锁免费列队：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That concludes our design of the market data protocol. We will see the design
    of the order data protocol next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对市场数据协议的设计。接下来，我们将看到订单数据协议的设计。
- en: Designing the order data protocol
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计订单数据协议
- en: In this subsection, we will design the public order data protocol the clients
    will use to send order requests to the exchange and receive order responses from
    it, specifically the order gateway server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子节中，我们将设计客户端将用来向交易所发送订单请求并从其接收订单响应的公共订单数据协议，具体来说是订单网关服务器。
- en: 'First, we will see the format of messages sent from the market participant’s
    order gateway to the exchange’s order gateway server. We already discussed the
    `ClientRequestType` enumeration, the `MEClientRequest` struct, and the `ClientRequestLFQueue`
    typedef used by the matching engine in the *Building the C++ Matching Engine*
    chapter, in the *Defining the operations and interactions in our matching engine*
    section. `MEClientRequest` is the internal format used by the matching engine,
    but `OMClientRequest` is the format that the market participants need to use when
    sending order requests to the exchange order gateway server. Like the market data
    format, `OMClientRequest` has a sequence number field, `seq_num_`, and then the
    `MEClientRequest` struct after that. The sequence number field here serves a similar
    purpose as before, to make sure that the exchange and client’s order gateway components
    are in sync with each other. The code for this structure is in the `Chapter7/exchange/order_server/client_request.h`
    file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到从市场参与者的订单网关发送到交易所订单网关服务器的消息格式。在 *构建 C++ 匹配引擎* 章节中，我们已经讨论了 `ClientRequestType`
    枚举、`MEClientRequest` 结构和匹配引擎使用的 `ClientRequestLFQueue` `typedef`，在 *定义匹配引擎中的操作和交互*
    部分。`MEClientRequest` 是匹配引擎使用的内部格式，但 `OMClientRequest` 是市场参与者在向交易所订单网关服务器发送订单请求时需要使用的格式。与市场数据格式类似，`OMClientRequest`
    有一个序列号字段 `seq_num_`，然后是 `MEClientRequest` 结构。这里的序列号字段与之前的作用类似，确保交易所和客户端的订单网关组件彼此同步。这个结构的代码在
    `Chapter7/exchange/order_server/client_request.h` 文件中：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have a symmetrical design of the responses sent from the exchange’s order
    gateway server to the client’s order gateway component. We saw the `MEClientResponse`
    structure in the previous chapter, which is used internally between the matching
    engine and the order gateway server component inside the trading exchange infrastructure.
    The `OMClientResponse` structure is the public format that the market participants
    will use to receive and process order responses in. Like the other structures
    we saw before, there is a sequence number field for synchronization purposes and
    the remaining payload for this structure is the `MEClientResponse` structure.
    This structure can be found in the `Chapter7/exchange/order_server/client_response.h`
    file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为交易所的订单网关服务器发送给客户端订单网关组件的响应设计了一个对称的结构。我们在上一章中看到了`MEClientResponse`结构，它用于交易交换基础设施内部匹配引擎和订单网关服务器组件之间的内部通信。`OMClientResponse`结构是市场参与者用来接收和处理订单响应的公共格式。像之前看到的其他结构一样，有一个用于同步的序列号字段，以及该结构的剩余有效载荷是`MEClientResponse`结构。这个结构可以在`Chapter7/exchange/order_server/client_response.h`文件中找到：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This concludes the design of the new structures we will need in this chapter.
    Next, we will start discussing the implementation of the order gateway server,
    starting with how it handles incoming client requests from market participants.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的新结构设计到此结束。接下来，我们将开始讨论订单网关服务器的实现，首先从它如何处理来自市场参与者的客户端请求开始。
- en: Building the order gateway server
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建订单网关服务器
- en: In this section, we will start building the order gateway server infrastructure,
    which is responsible for setting up a TCP server for clients to connect to. The
    order gateway server also needs to process incoming client requests from different
    clients in the order in which they arrive and forward those to the matching engine.
    Finally, it also needs to receive the order responses from the matching engine
    and forward them to the correct TCP connection for the corresponding market participant.
    We will revisit the design of the order gateway server and how it interacts with
    the matching engine and the market participants, as follows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始构建订单网关服务器基础设施，它负责为客户端设置TCP服务器以连接到。订单网关服务器还需要按照请求到达的顺序处理来自不同客户端的请求，并将它们转发给匹配引擎。最后，它还需要从匹配引擎接收订单响应，并将它们转发给对应市场参与者的正确TCP连接。我们将重新审视订单网关服务器的结构以及它与匹配引擎和市场参与者的交互，如下所述。
- en: '![Figure 7.1 – Order gateway server and its subcomponents](img/B19434_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 订单网关服务器及其子组件](img/B19434_07_01.jpg)'
- en: Figure 7.1 – Order gateway server and its subcomponents
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 订单网关服务器及其子组件
- en: To refresh your memory, the order gateway server receives new TCP connections
    or client requests on established TCP connections. Then, those requests go through
    a FIFO sequencer stage to make sure that requests are processed in the exact order
    in which they arrived at the exchange’s infrastructure. There is a transformation
    between the internal matching engine format and the public order data format we
    described in the previous section. In the previous chapter on *Building the Matching
    Engine*, we already built the communication path to and from the matching engine,
    which is through lock-free queues. All the details behind the design of this component
    as well as what purpose it serves in our electronic trading ecosystem were discussed
    in the *Designing Our Trading Ecosystem* chapter, specifically in the *Understanding
    the layout of the electronic trading ecosystem* and *Understanding how an exchange
    publishes information to participants* sections. So, we would strongly recommend
    revisiting that chapter as you build the order gateway server at the exchange.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您回忆，订单网关服务器接收新的TCP连接或已建立的TCP连接上的客户端请求。然后，这些请求通过一个FIFO序列器阶段，以确保请求按照它们到达交易所基础设施的确切顺序进行处理。在上一节中描述的内部匹配引擎格式和公共订单数据格式之间存在转换。在上一章《构建匹配引擎》中，我们已经构建了匹配引擎的通信路径，这是通过无锁队列实现的。关于该组件的设计细节以及它在我们的电子交易生态系统中所起的作用，在《设计我们的交易生态系统》一章中已有详细讨论，特别是在《理解电子交易生态系统的布局》和《理解交易所如何向参与者发布信息》部分。因此，我们强烈建议在构建交易所的订单网关服务器时重新阅读那一章。
- en: First, we will build the `OrderServer` class, which represents the order gateway
    server component in the preceding diagram. The code for `OrderServer` resides
    in the `Chapter7/exchange/order_server/order_server.h` and `Chapter7/exchange/order_server/order_server.cpp`
    files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建`OrderServer`类，它代表前面图中订单网关服务器组件。`OrderServer`的代码位于`Chapter7/exchange/order_server/order_server.h`和`Chapter7/exchange/order_server/order_server.cpp`文件中。
- en: Defining the data members in the order gateway server
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在网关服务器中定义数据成员的顺序
- en: 'The `OrderServer` class has a few important data members:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderServer`类有几个重要的数据成员：'
- en: A `tcp_server_` variable, which is an instance of the `Common::TCPServer` class,
    which will be used to host a TCP server to poll for, accept incoming connections
    from market participants, and poll the established TCP connections to see whether
    there is data to be read from any of the connections.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`tcp_server_`的变量，它是`Common::TCPServer`类的一个实例，将被用来托管一个TCP服务器以轮询市场参与者的传入连接，并轮询已建立的TCP连接以查看是否有任何连接可以读取数据。
- en: A `fifo_sequencer_` variable, which is an instance of the `FIFOSequencer` class
    and is responsible for making sure that client requests that come in on different
    TCP connections are processed in the correct order in which they came.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`fifo_sequencer_`的变量，它是`FIFOSequencer`类的一个实例，负责确保来自不同TCP连接的客户请求按照它们到达的正确顺序进行处理。
- en: A lock-free queue variable, `outgoing_responses_`, of the `ClientResponseLFQueue`
    type, using which it receives `MEClientResponse` messages from the matching engine,
    which need to be sent out to the correct market participant.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无锁队列变量`outgoing_responses_`，其类型为`ClientResponseLFQueue`，通过它接收来自匹配引擎的`MEClientResponse`消息，这些消息需要发送给正确的市场参与者。
- en: A `std::array` `cid_tcp_socket_` of `TCPSocket` objects of size `ME_MAX_NUM_CLIENTS`,
    which will be used as a hash map from client-id to the `TCPSocket` connection
    for that client.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大小为`ME_MAX_NUM_CLIENTS`的`std::array` `cid_tcp_socket_`，包含`TCPSocket`对象，它将被用作从客户端ID到该客户端`TCPSocket`连接的哈希映射。
- en: Two `std::array`s also of size `ME_MAX_NUM_CLIENTS` to track the exchange-to-client
    and client-to-exchange sequence numbers on the `OMClientResponse` and `OMClientRequest`
    messages. These are the `cid_next_outgoing_seq_num_` and `cid_next_exp_seq_num_`
    variables.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个大小为`ME_MAX_NUM_CLIENTS`的`std::array`，用于跟踪`OMClientResponse`和`OMClientRequest`消息上的交易所到客户端和客户端到交易所的序列号。这些是`cid_next_outgoing_seq_num_`和`cid_next_exp_seq_num_`变量。
- en: 'A Boolean `run_` variable, which will be used to start and stop the `OrderServer`
    thread. Note that it is marked `volatile` since it will be accessed from different
    threads, and we want to prevent compiler optimizations here for correct functionality
    in a multi-threaded environment:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔变量`run_`，它将被用来启动和停止`OrderServer`线程。请注意，它被标记为`volatile`，因为它将从不同的线程中访问，并且我们希望在这里防止编译器优化，以确保在多线程环境中的正确功能：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One more minor declaration before we move on to the next subsection is that
    the `OrderServer` class has the following method declarations, which we will define
    in the subsequent subsections. These are methods corresponding to the constructor,
    the destructor, a `start()` method, and a `stop()` method, but for now, do not
    worry about the details of these; we will be defining them very soon:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一个子节之前，还有一个小的声明，即`OrderServer`类有以下方法声明，我们将在后续子节中定义它们。这些是与构造函数、析构函数、`start()`方法和`stop()`方法相对应的方法，但就目前而言，不要担心这些方法的细节；我们很快就会定义它们：
- en: '[PRE32]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the next subsection, we will initialize and de-initialize the `OrderServer`
    class and its member variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将初始化和销毁`OrderServer`类及其成员变量。
- en: Initializing the order gateway server
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化订单网关服务器
- en: 'The constructor for this class is straightforward. We initialize the three
    arrays with some basic values: sequence numbers set to 1 and `TCPSocket`s set
    to `nullptr`. We will also set the two callback members, `recv_callback_` and
    `recv_finished_callback_`, to point to the `recvCallback()` and `recvFinishedCallback()`
    member functions. We will discuss these callback handling methods in the next
    few subsections. The constructor for `OrderServer` accepts pointers to two lock-free
    queue objects: one to forward `MEClientRequest`s to the matching engine and one
    to receive `MEClientResponse`s from the matching engine. It also accepts a network
    interface and port to use that the order gateway server will listen to and accept
    client connections on:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造函数很简单。我们使用一些基本值初始化三个数组：序列号设置为1，`TCPSocket`设置为`nullptr`。我们还将两个回调成员`recv_callback_`和`recv_finished_callback_`设置为指向`recvCallback()`和`recvFinishedCallback()`成员函数。我们将在接下来的几个小节中讨论这些回调处理方法。`OrderServer`类的构造函数接受两个无锁队列对象的指针：一个用于将`MEClientRequest`转发到匹配引擎，另一个用于从匹配引擎接收`MEClientResponse`。它还接受一个网络接口和端口号，该端口号用于订单网关服务器监听并接受客户端连接：
- en: '[PRE33]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will also define a `start()` method, which will set the bool run_ to be
    true. This is the flag that controls how long the main thread will run. We also
    initialize the `TCPServer` member object to start listening on the interface and
    port that `OrderServer` was provided in the constructor. Finally, it creates and
    launches a thread that will execute the `run()` method, which we will also see
    in the next few subsections. For now, we will not set affinity on any threads
    we create in this application, but we will discuss optimization possibilities
    at the end of this book:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个`start()`方法，它将bool run_设置为true。这是控制主线程运行时间的标志。我们还初始化`TCPServer`成员对象，以便在构造函数中提供的接口和端口上开始监听。最后，它创建并启动一个将执行`run()`方法的线程，我们将在接下来的几个小节中看到这个方法。现在，我们不会为在这个应用程序中创建的任何线程设置亲和性，但我们将在本书的末尾讨论优化可能性：
- en: '[PRE34]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We define a complementary `stop()` method, which simply sets the `run_` flag
    to false, which will cause the `run()` method to finish execution (more on this
    shortly):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个互补的`stop()`方法，它只是将`run_`标志设置为false，这将导致`run()`方法完成执行（关于这一点我们稍后还会讨论）：
- en: '[PRE35]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The destructor for the `OrderServer` class is also quite simple. It calls the
    `stop()` method to instruct the main thread to stop execution and then waits a
    brief period of time for the thread to finish any pending tasks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderServer`类的析构函数也很简单。它调用`stop()`方法指示主线程停止执行，然后等待一段时间，以便线程完成任何挂起的任务：'
- en: '[PRE36]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This concludes the subsection on the initialization of this class. Next, we
    will investigate the functionality needed for `OrderServer` to handle incoming
    client requests over TCP connections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了本小节关于这个类初始化的讨论。接下来，我们将研究`OrderServer`处理通过TCP连接传入的客户端请求所需的功能。
- en: Handling incoming client requests
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理传入的客户端请求
- en: In this subsection, we will discuss the code we need to handle incoming client
    requests. These client requests are received over TCP connections, and these are
    dispatched to the `recvCallback()` and `recvFinishedCallback()` methods through
    the `TCPServer` like we set up in the constructor. We will break down the implementation
    of this method into different blocks so we can understand it better here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将讨论我们需要处理传入客户端请求的代码。这些客户端请求通过TCP连接接收，并通过`TCPServer`（如我们在构造函数中设置的）将这些请求分发给`recvCallback()`和`recvFinishedCallback()`方法。我们将把这个方法的实现分解成不同的块，以便我们更好地理解它。
- en: 'The first code block in this method checks whether the size of the available
    data is at least as large as a complete `OMClientRequest` struct. Then it breaks
    up the available data into blocks of size equal to the size of an `OMClientRequest`
    object, and iterates through the available data. It reinterprets `rcv_buffer_`
    in `TCPSocket` as an `OMClientRequest` struct and saves it in the request variable,
    which is of the `OMClientRequest` pointer type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法中的第一个代码块检查可用数据的大小是否至少与一个完整的`OMClientRequest`结构体的大小一样大。然后它将可用数据分成与`OMClientRequest`对象大小相等的块，并遍历可用数据。它将`TCPSocket`中的`rcv_buffer_`重新解释为`OMClientRequest`结构体，并将其保存到`request`变量中，该变量是`OMClientRequest`指针类型：
- en: '[PRE37]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once it has the `OMClientRequest` it needs to process, it checks whether this
    is the first request from this client. If that is the case, then it tracks the
    `TCPSocket` instance for this client by adding it to the `cid_tcp_socket_` `std::array`,
    which we are using as a hash map:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它获得了需要处理的`OMClientRequest`，它将检查这是否是这个客户端的第一个请求。如果是这种情况，那么它将通过将其添加到我们用作哈希表的`cid_tcp_socket_`
    `std::array`中来跟踪这个客户端的`TCPSocket`实例：
- en: '[PRE38]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If a `TCPSocket` entry for this client-id already existed in the `cid_tcp_socket_`
    container, then we would make sure that the previously tracked `TCPSocket` for
    this client-id matches the `TCPSocket` for the current request. If they do not
    match, we log an error and skip processing this request:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于这个客户端-id已经在`cid_tcp_socket_`容器中存在一个`TCPSocket`条目，那么我们将确保之前跟踪的`TCPSocket`与当前请求的`TCPSocket`匹配。如果不匹配，我们将记录一个错误并跳过处理这个请求：
- en: '[PRE39]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will perform a sequence number check to make sure that the sequence
    number on this `OMClientRequest` is exactly what we expect it to be based on the
    last message we have seen. If there is a mismatch between the expected and received
    sequence numbers, then we log an error and ignore this request:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行一个序列号检查，以确保这个`OMClientRequest`上的序列号与我们根据最后收到的消息所期望的序列号完全一致。如果期望的序列号和接收到的序列号之间存在不匹配，那么我们将记录一个错误并忽略这个请求：
- en: '[PRE40]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One note here is that in a realistic setup, the exchange will send a reject
    back to the client if it receives a request on an incorrect socket or if there
    is a sequence number mismatch, to notify them of the error. We have omitted that
    here for simplicity’s sake, but it is not difficult to add if needed. If we have
    made it this far in the execution of this loop, then we increment the next expected
    sequence number on the next `OMClientRequest` for this client and forward this
    request to the FIFO sequencer data member. One important thing to note here is
    that we also forward `rx_time`, which is the software receive time of this TCP
    packet, to the FIFO sequencer since it will need that information to sequence
    the requests correctly. We will discuss the details of how the FIFO sequencer
    achieves this in the next subsection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个注意事项，在现实设置中，如果交换接收到的请求是在错误的套接字上，或者如果序列号不匹配，它将向客户端发送一个拒绝响应，以通知他们错误。为了简化，这里省略了这一点，但如果需要，添加它并不困难。如果我们已经执行了这个循环的这部分，那么我们将为这个客户端的下一个`OMClientRequest`递增下一个预期的序列号，并将这个请求转发到FIFO序列器数据成员。这里需要注意的是，我们还转发`rx_time`，这是这个TCP数据包的软件接收时间，因为FIFO序列器需要这些信息来正确地排序请求。我们将在下一小节中讨论FIFO序列器如何实现这一点：
- en: '[PRE41]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Remember that the `recvFinishedCallback()` method is called when all the `recvCallback()`
    methods have been dispatched from the current call to `TCPServer::sendAndRecv()`.
    The `recvFinishedCallback()` method instructs `FIFOSequencer` to correctly order
    the `MEClientRequests` that it has queued up and push them to the matching engine.
    This mechanism will become clear when we discuss the design and implementation
    of the `FIFOSequencer` in the next subsection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当所有`recvCallback()`方法从当前对`TCPServer::sendAndRecv()`的调用中分发出去时，会调用`recvFinishedCallback()`方法。`recvFinishedCallback()`方法指示`FIFOSequencer`正确排序它已排队的`MEClientRequests`并将它们推送到匹配引擎。当我们在下一小节中讨论`FIFOSequencer`的设计和实现时，这种机制将变得清晰：
- en: '[PRE42]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we will discuss the FIFO sequencer component, which is responsible for
    maintaining fairness from the perspective of processing client requests. It does
    this by making sure that requests received across different TCP connections are
    processed in the exact order in which they were received in the order gateway
    server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论FIFO序列器组件，该组件负责从处理客户端请求的角度维护公平性。它通过确保在不同TCP连接上接收到的请求以它们在网关服务器接收到的确切顺序进行处理来实现这一点。
- en: Processing requests fairly using the FIFO sequencer
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FIFO序列器公平处理请求
- en: The FIFO sequencer subcomponent in the order gateway server is responsible for
    making sure that client requests are processed in the order of their arrival time.
    This is necessary because the order gateway server reads and dispatches client
    requests from different TCP connections, which arrive at different times. Let
    us get started by first defining the data members inside this class. The code
    for the FIFO sequencer is in the `Chapter7/exchange/order_server/fifo_sequencer.h`
    source file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 订单网关服务器中的 FIFO 序列器子组件负责确保客户端请求按到达时间顺序处理。这是必要的，因为顺序网关服务器从不同的 TCP 连接中读取和调度客户端请求，这些请求到达的时间不同。让我们首先定义这个类内部的数据成员。FIFO
    序列器的代码位于 `Chapter7/exchange/order_server/fifo_sequencer.h` 源文件中。
- en: Defining the data members in the FIFO sequencer
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 FIFO 序列器中的数据成员
- en: First, we define a constant, `ME_MAX_PENDING_REQUESTS`, which represents the
    maximum number of simultaneously pending requests available at the network socket
    across all TCP connections. If the order gateway server is busy with other tasks
    and has not polled the TCP connections for a very short period of time, it is
    possible client requests arrived during that time and are queued at the network
    socket level.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个常量 `ME_MAX_PENDING_REQUESTS`，它表示在网络套接字上所有 TCP 连接中可以同时挂起的最大请求数量。如果顺序网关服务器正忙于其他任务并且没有在非常短的时间内轮询
    TCP 连接，那么在这段时间内可能到达的客户端请求可能会在网络套接字级别排队。
- en: The FIFO sequencer uses this constant to create a `std::array` of that size
    of `RecvTimeClientRequest` structures. This member variable is named `pending_client_requests_`
    in this `FIFOSequencer` class. To count the number of actual pending request entries
    in this `pending_client_requests_` array, we will maintain a `pending_size_` variable
    of the `size_t` type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO 序列器使用此常量来创建一个大小为 `RecvTimeClientRequest` 结构的 `std::array`。在这个 `FIFOSequencer`
    类中，这个成员变量被命名为 `pending_client_requests_`。为了计算 `pending_client_requests_` 数组中实际挂起的请求条目数量，我们将维护一个
    `size_t` 类型的 `pending_size_` 变量。
- en: The `RecvTimeClientRequest` struct has two members – `recv_time_`, of the `Nanos`
    type, and a `request_` variable of the `MEClientRequest` type. This structure
    captures the client request as well as the time of its arrival at the order gateway
    server. We will sort these by time and then process them in order of arrival.
    To make sorting easy, we will define a `<` operator, which returns `true` if the
    client request on the **left-hand side** (**LHS**) was received before the client
    request on the **right-hand side** (**RHS**) of that operator.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecvTimeClientRequest` 结构有两个成员——`recv_time_`，类型为 `Nanos`，以及一个 `request_` 变量，类型为
    `MEClientRequest`。这个结构捕获了客户端请求以及它在订单网关服务器上的到达时间。我们将按时间对这些进行排序，然后按到达顺序处理它们。为了使排序变得容易，我们将定义一个
    `<` 操作符，如果操作符的左侧（**LHS**）的客户端请求在操作符的右侧（**RHS**）的客户端请求之前接收，则返回 `true`。'
- en: 'Finally, the last important member of this class is the `incoming_requests_`
    variable, which is of the `ClientRequestLFQueue` type, which is the lock-free
    queue that the FIFO sequencer uses to send `MEClientRequest`s to the matching
    engine:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个类中最后一个重要的成员变量是 `incoming_requests_`，它属于 `ClientRequestLFQueue` 类型，这是 FIFO
    序列器用来将 `MEClientRequest` 发送到匹配引擎的无锁队列：
- en: '[PRE43]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let us look at the source code to initialize the FIFO sequencer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看源代码以初始化 FIFO 序列器。
- en: Initializing the FIFO sequencer
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化 FIFO 序列器
- en: 'The constructor for the `FIFOSequencer` class is straightforward and self-explanatory.
    It is presented as follows and initializes `incoming_requests_` `ClientRequestLFQueue`
    and `logger_`, which are both passed to it in the constructor for this class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIFOSequencer` 类的构造函数简单明了，易于理解。它如下所示，并初始化 `incoming_requests_` `ClientRequestLFQueue`
    和 `logger_`，这两个都是通过这个类的构造函数传递给它的：'
- en: '[PRE44]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, we will look at the most important functionality inside the FIFO sequencer
    – queueing up client requests and publishing them in order of their receive time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看 FIFO 序列器中最重要的功能——按接收时间顺序排队客户端请求并发布它们。
- en: Publishing client requests in order
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按顺序发布客户端请求
- en: 'We used the `FIFOSequencer::addClientRequest()` method in a previous subsection,
    *Handling incoming client requests*. Here, we present the implementation, which
    is quite simple and involves simply adding it to the end of `pending_client_requests_`
    and incrementing the `pending_size_` variable to signify that there is an additional
    entry that was added. Note here that we only ever expect a maximum of `ME_MAX_PENDING_REQUESTS`
    at a time since we set it to a high value. If this limit is not enough, we have
    the option of increasing the array size and possibly switching to using a `MemPool`
    of `RecvTimeClientRequest` objects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的子节“处理传入客户端请求”中使用了`FIFOSequencer::addClientRequest()`方法。在这里，我们展示了其实现，这相当简单，只需将其添加到`pending_client_requests_`的末尾，并将`pending_size_`变量递增以表示添加了一个额外的条目。请注意，我们始终期望一次最多只有`ME_MAX_PENDING_REQUESTS`，因为我们将其设置为高值。如果这个限制不够，我们有增加数组大小并可能切换到使用`RecvTimeClientRequest`对象的`MemPool`的选项：
- en: '[PRE45]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We also used the `FIFOSequencer::sequenceAndPublish()` method in a previous
    subsection, *Handling incoming client requests*. This is the most important method
    in the `FIFOSequencer` class and performs the following tasks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在之前的子节“处理传入客户端请求”中使用了`FIFOSequencer::sequenceAndPublish()`方法。这是`FIFOSequencer`类中最重要的方法，并执行以下任务：
- en: 'First, it sorts all the `RecvTimeClientRequest` entries in the `pending_client_requests_`
    container in ascending order of their arrival times. It achieves this by using
    the `std::sort()` algorithm, which in turn uses the `<` operator we built for
    `RecvTimeClientRequest` objects to sort the container. One word here: sorting
    can become time consuming if the number of elements is very large, but we rarely
    expect that to be the case here, since the number of simultaneously pending requests
    is expected to be quite low. This would be another optimization area, but we need
    to measure the load and performance of our system in practice before deciding
    how to improve this.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它按到达时间升序对`pending_client_requests_`容器中的所有`RecvTimeClientRequest`条目进行排序。它通过使用`std::sort()`算法来实现这一点，该算法反过来使用我们为`RecvTimeClientRequest`对象构建的`<`运算符来排序容器。这里有一点需要注意：如果元素数量非常大，排序可能会变得耗时，但在这里我们很少期望这种情况发生，因为同时挂起的请求数量预计会相当低。这将是另一个优化领域，但在决定如何改进之前，我们需要在实际中测量我们系统的负载和性能。
- en: After the sorting step, it writes each of the `MEClientRequest` entries to the
    `incoming_requests_` `LFQueue`, which goes to the matching engine.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在排序步骤之后，它将每个`MEClientRequest`条目写入`incoming_requests_` `LFQueue`，该队列流向匹配引擎。
- en: 'Finally, it resets the `pending_size_` variable to mark the end of processing
    and returns from the method:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它将`pending_size_`变量重置以标记处理结束，并从方法返回：
- en: '[PRE46]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This concludes the design and implementation of the `FIFOSequencer` subcomponent
    inside our order gateway server. Now, we can go back to our design of the `OrderServer`
    class by adding functionality to send client responses back out to the clients
    over TCP.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们订单网关服务器内部`FIFOSequencer`子组件的设计和实现的结束。现在，我们可以回到我们的`OrderServer`类的设计，通过添加将客户端响应发送回客户端的功能。
- en: Sending client responses
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送客户端响应
- en: 'In this subsection, we will look at how `OrderServer` performs two important
    tasks in the `run()` method. Remember that this `run()` method is the main loop
    for this class, which is run on the thread we created and launched in the *Initializing
    the order gateway server* subsection, specifically in the `start()` method. The
    `run()` method performs the following two main tasks:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`OrderServer`在`run()`方法中执行的两个重要任务。请记住，这个`run()`方法是这个类的主要循环，它在我们在“初始化订单网关服务器”子节中创建并启动的线程上运行，具体在`start()`方法中。`run()`方法执行以下两个主要任务：
- en: It calls the `poll()` method on the `TCPServer` object it holds. Remember that
    the `poll()` method checks for and accepts new connections, removes dead connections,
    and checks whether there is data available on any of the established TCP connections,
    that is, client requests.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在其持有的`TCPServer`对象上调用`poll()`方法。请记住，`poll()`方法检查并接受新的连接，移除已死连接，并检查是否有任何已建立的TCP连接上有数据可用，即客户端请求。
- en: 'It also calls the `sendAndRecv()` method on the `TCPServer` object it holds.
    The `sendAndRecv()` method reads the data from each of the TCP connections and
    dispatches the callbacks for them. The `sendAndRecv()` call also sends out any
    outgoing data on the TCP connections, that is, client responses. This code block
    is shown as follows and should be quite easy to understand:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还调用它持有的`TCPServer`对象的`sendAndRecv()`方法。`sendAndRecv()`方法从每个TCP连接中读取数据，并为它们分发回调。`sendAndRecv()`调用还会在TCP连接上发送任何出站数据，即客户端响应。这个代码块如下所示，应该很容易理解：
- en: '[PRE68]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `run()` loop also drains the `outgoing_responses_` lock-free queue, which
    the matching engine uses to send out `MEClientResponse` messages that need to
    be dispatched to the correct clients.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()`循环还会清空`outgoing_responses_`无锁队列，匹配引擎使用这个队列来发送需要分发到正确客户端的`MEClientResponse`消息。'
- en: 'It iterates through the available data in the `outgoing_responses_` queue and
    then for each `MEClientResponse` it reads, it first finds out what the correct
    outgoing sequence number is. This is the sequence number on the `OMClientResponse`
    message to be sent to that client ID.     It does this by looking up that answer in the `cid_next_outgoing_seq_num_` array,
    which we are really using as a hash map from the client ID to the sequence number:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历`outgoing_responses_`队列中的可用数据，然后对于每个读取的`MEClientResponse`，它首先找出正确的出站序列号。这是要发送给该客户端ID的`OMClientResponse`消息上的序列号。它是通过在`cid_next_outgoing_seq_num_`数组中查找这个答案来做到这一点的，我们实际上是将它用作从客户端ID到序列号的哈希表：
- en: '[PRE74]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It also checks that it has a valid `TCPSocket` for the client ID that this response
    is meant for. It looks up that information in the `cid_tcp_socket_` array, which
    is a hash map from the client ID to `TCPSocket` objects.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还会检查它是否有一个有效的`TCPSocket`用于这个响应目标客户端ID。它在`cid_tcp_socket_`数组中查找这个信息，这是一个从客户端ID到`TCPSocket`对象的哈希表。
- en: It then sends an `OMClientResponse` message on `TCPSocket` for this client ID
    by calling the `TCPSocket::send()` method. It achieves this by first sending the
    `next_outgoing_seq_num_` value and then the `MEClientResponse` message that the
    matching engine generated. It might not be immediately clear, but this is actually
    sending an `OMClientResponse` message because the `OMClientResponse` message is
    actually just a sequence number field followed by a `MEClientResponse` message,
    which is what we just did.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它通过调用`TCPSocket::send()`方法，向该客户端ID发送一个`OMClientResponse`消息到`TCPSocket`。它是通过首先发送`next_outgoing_seq_num_`值，然后发送由匹配引擎生成的`MEClientResponse`消息来实现的。这可能一开始并不明显，但实际上这是在发送一个`OMClientResponse`消息，因为`OMClientResponse`消息实际上只是一个序列号字段，后面跟着一个`MEClientResponse`消息，这正是我们刚才所做的。
- en: 'Finally, it updates the read index and the sequence number of the next outgoing
    message and continues with the loop:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它更新读取索引和下一个出站消息的序列号，并继续循环：
- en: '[PRE86]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This concludes the full design and implementation of the order gateway server
    component in our electronic trading infrastructure. Next, we will look at the
    component that publishes the public market data to the participants.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们电子交易基础设施中订单网关服务器组件的完整设计和实现。接下来，我们将查看发布公共市场数据给参与者的组件。
- en: Building the market data publisher
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建市场数据发布者
- en: The last component in the electronic trading exchange we need to build is the
    market data publisher, which is how the exchange publishes public market data
    updates to any market participants that need it. Revisiting the design of the
    market data publisher, we present a diagram of how this component communicates
    with the matching engine and publishes to the market data participants over UDP,
    as follows.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的电子交易交易所的最后一个组件是市场数据发布者，这是交易所如何向需要它的任何市场参与者发布公共市场数据更新的方式。回顾市场数据发布者的设计，我们展示了一个图表，说明这个组件如何与匹配引擎通信，并通过UDP向市场数据参与者发布，如下所示。
- en: '![Figure 7.2 – Market data publisher and its subcomponents](img/B19434_07_02.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 市场数据发布者和其子组件](img/B19434_07_02.jpg)'
- en: Figure 7.2 – Market data publisher and its subcomponents
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 市场数据发布者和其子组件
- en: We would like to remind you that the purpose and design of the market data publisher
    were discussed in detail in the *Designing Our Trading Ecosystem* chapter, specifically
    in the *Understanding the layout of the electronic trading ecosystem* and *Understanding
    how an exchange publishes information to participants* sections. We would strongly
    encourage you to revisit those sections to follow along as we build our market
    data publisher component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想提醒您，市场数据发布者的目的和设计在《设计我们的交易生态系统》章节中进行了详细讨论，具体在《理解电子交易生态系统的布局》和《理解交易所如何向参与者发布信息》部分。我们强烈建议您重新阅读这些部分，以便在我们构建市场数据发布组件时能够跟上进度。
- en: Let us get started by first understanding how updates are consumed from the
    matching engine and published by jumping into the `MarketDataPublisher` class.
    All the source code for the `MarketDataPublisher` class is in the `Chapter7/exchange/market_data/market_data_publisher.h`
    and `Chapter7/exchange/market_data/market_data_publisher.cpp` source files.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过了解如何从撮合引擎中消费更新并将其发布到 `MarketDataPublisher` 类来开始。`MarketDataPublisher`
    类的所有源代码都在 `Chapter7/exchange/market_data/market_data_publisher.h` 和 `Chapter7/exchange/market_data/market_data_publisher.cpp`
    源文件中。
- en: Defining the data members in the market data publisher
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义市场数据发布者的数据成员
- en: 'The `MarketDataPublisher` class has the following important members:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketDataPublisher` 类有以下重要成员：'
- en: A `next_inc_seq_num_` variable of the `size_t` type, which represents the sequence
    number to set on the next outgoing incremental market data message. We discussed
    the concepts of incremental and snapshot market data updates in the *Designing
    Our Trading Ecosystem* chapter, in the *Understanding how an exchange publishes
    information to participants* and *Building a market participant’s interface to
    the* *exchange* sections.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `next_inc_seq_num_` 变量，其类型为 `size_t`，代表将在下一个发出的增量市场数据消息上设置的序列号。我们在《设计我们的交易生态系统》章节中讨论了增量快照市场数据更新的概念，在《理解交易所如何向参与者发布信息》和《构建市场参与者与交易所的接口》部分。
- en: An `outgoing_md_updates_` variable of the `MEMarketUpdateLFQueue` type, which
    is a lock-free queue of `MEMarketUpdate` messages. We discussed the `MEMarketUpdate`
    structure in the *Building the C++ Matching Engine* chapter, in the *Defining
    the operations and interactions in our matching engine* section. This `LFQueue`
    is how the matching engine sends the `MEMarketUpdate` messages that the market
    data publisher then publishes over UDP.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `outgoing_md_updates_` 变量，其类型为 `MEMarketUpdateLFQueue`，这是一个 `MEMarketUpdate`
    消息的无锁队列。我们在《构建 C++ 撮合引擎》章节的《定义撮合引擎中的操作和交互》部分讨论了 `MEMarketUpdate` 结构。这个 `LFQueue`
    是撮合引擎发送 `MEMarketUpdate` 消息的方式，然后市场数据发布者通过 UDP 发布这些消息。
- en: An `incremental_socket_` member, which is an `McastSocket` to be used to publish
    UDP messages on the incremental multicast stream.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `incremental_socket_` 的成员，它是一个 `McastSocket`，用于在增量多播流上发布 UDP 消息。
- en: A `snapshot_synthesizer_` variable of the `SnapshotSynthesizer` type, which
    we will discuss in the next subsection. This object will be responsible for generating
    a snapshot of the limit order book from the updates that the matching engine provides
    and periodically publishing a snapshot of the full order book on the snapshot
    multicast stream. This was discussed in the *Designing Our Trading Ecosystem*
    chapter, in the *Understanding how an exchange publishes information to participants*
    section, specifically in the *Designing the market data* *publisher* subsection.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `snapshot_synthesizer_` 变量，我们将在下一小节中讨论。这个对象将负责从撮合引擎提供的更新中生成限价订单簿的快照，并定期在快照多播流上发布整个订单簿的快照。这在《设计我们的交易生态系统》章节的《理解交易所如何向参与者发布信息》部分进行了讨论，特别是在《设计市场数据发布者》子部分。
- en: A lock-free queue instance called `snapshot_md_updates_`, which will be of the
    `MDPMarketUpdateLFQueue` type, which is a lock-free queue containing `MDPMarketUpdate`
    messages. This queue is used by the market data publisher thread to publish `MDPMarketUpdate`
    messages that it sends on the incremental stream to the `SnapshotSynthesizer`
    component. This `LFQueue` is necessary since `SnapshotSynthesizer` runs on a different
    thread than `MarketDataPublisher`, which is primarily so that the snapshot synthesis
    and publishing process do not slow down the latency-sensitive `MarketDataPublisher`
    component.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `snapshot_md_updates_` 的无锁队列实例，其类型为 `MDPMarketUpdateLFQueue`，这是一个包含 `MDPMarketUpdate`
    消息的无锁队列。该队列由市场数据发布线程使用，以将发送到增量流的 `MDPMarketUpdate` 消息发布到 `SnapshotSynthesizer`
    组件。这个 `LFQueue` 是必要的，因为 `SnapshotSynthesizer` 在与 `MarketDataPublisher` 不同的线程上运行，这主要是为了确保快照合成和发布过程不会减慢对延迟敏感的
    `MarketDataPublisher` 组件：
- en: 'The last important member of the `MarketDataPublisher` class is the `run_`
    Boolean variable, which is just used to control when the `MarketDataPublisher`
    thread is started and stopped. Since it is accessed from different threads, like
    the `run_` variable in the `OrderServer` class, it is also marked as `volatile`:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MarketDataPublisher` 类的最后一个重要成员是 `run_` 布尔变量，它仅用于控制何时启动和停止 `MarketDataPublisher`
    线程。由于它可以从不同的线程访问，就像 `OrderServer` 类中的 `run_` 变量一样，因此它也被标记为 `volatile`：'
- en: '[PRE100]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the next section, we will see how these data members are initialized.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到这些数据成员是如何初始化的。
- en: Initializing the market data publisher
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化市场数据发布者
- en: 'In this subsection, we will look at how to initialize `MarketDataPublisher`,
    and how to start and stop the `MarketDataPublisher` component. First, we will
    look at the constructor, which is presented as follows. The `market_updates` argument
    passed to it is the `MEMarketUpdateLFQueue` object, which the matching engine
    will publish market updates on. The constructor also receives the network interface
    and two sets of IPs and ports – one for the incremental market data stream and
    one for the snapshot market data stream. In the constructor, it initializes the
    `outgoing_md_updates_` member with the argument passed in the constructor and
    the `snapshot_md_updates_` `LFQueue` to be of the size `ME_MAX_MARKET_UPDATES`,
    which we first defined back in the *Designing the C++ matching engine* chapter,
    in the *Defining the operations and interactions in our matching engine* *section*,
    and is available in the `common/types.h` source file. It also initializes the
    `logger_` object with a log file for this class and initializes the `incremental_socket_`
    variable with the incremental IP and port provided in the constructor. Finally,
    it creates a `SnapshotSynthesizer` object and passes the `snapshot_md_updates_`
    `LFQueue` and the snapshot multicast stream information:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨如何初始化 `MarketDataPublisher`，以及如何启动和停止 `MarketDataPublisher` 组件。首先，我们将查看构造函数，其表示如下。传递给它的
    `market_updates` 参数是 `MEMarketUpdateLFQueue` 对象，匹配引擎将在其上发布市场更新。构造函数还接收网络接口和两套
    IP 地址和端口号——一套用于增量市场数据流，另一套用于快照市场数据流。在构造函数中，它使用构造函数中传递的参数初始化 `outgoing_md_updates_`
    成员，并将 `snapshot_md_updates_` `LFQueue` 初始化为大小为 `ME_MAX_MARKET_UPDATES`，这是我们之前在
    *设计 C++ 匹配引擎* 章节中定义的，在 *定义匹配引擎中的操作和交互* *部分* 中，并在 `common/types.h` 源文件中可用。它还使用本类的日志文件初始化
    `logger_` 对象，并使用构造函数中提供的增量 IP 地址和端口号初始化 `incremental_socket_` 变量。最后，它创建一个 `SnapshotSynthesizer`
    对象，并将 `snapshot_md_updates_` `LFQueue` 和快照多播流信息传递给它：
- en: '[PRE116]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We also present a `start()` method, shown as follows, which is similar in functionality
    to the `start()` method we saw for the `OrderServer` class. First, it sets the
    `run_` flag to `true`, then creates and launches a new thread and assigns the
    `run()` method to that thread, which will be our main `run` loop for the `MarketDataPublisher`
    component. It also calls the `start()` method on the `SnapshotSynthesizer` object
    so that the `SnapshotSynthesizer` thread can also be launched:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个 `start()` 方法，如下所示，其功能与我们在 `OrderServer` 类中看到的 `start()` 方法类似。首先，它将
    `run_` 标志设置为 `true`，然后创建并启动一个新的线程，并将 `run()` 方法分配给该线程，这将是我们 `MarketDataPublisher`
    组件的主要 `run` 循环。它还调用 `SnapshotSynthesizer` 对象的 `start()` 方法，以便启动 `SnapshotSynthesizer`
    线程：
- en: '[PRE117]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The destructor is quite self-explanatory; it calls the `stop()` method to stop
    the running `MarketDataPublisher` thread, then waits a short amount of time to
    let the thread finish any pending tasks and deletes the `SnapshotSynthesizer`
    object. We will see the implementation of the `stop()` method right after the
    destructor, but it should not be too difficult to guess what that method looks
    like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数相当直观；它调用`stop()`方法来停止正在运行的`MarketDataPublisher`线程，然后等待一小段时间，让线程完成任何挂起的任务，并删除`SnapshotSynthesizer`对象。我们将在析构函数之后立即看到`stop()`方法的实现，但它应该不难猜测该方法的样子：
- en: '[PRE118]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Finally, as mentioned before, we present the `stop()` method. This method simply
    sets the `run_` flag to `false` and instructs the `SnapshotSynthesizer` thread
    to stop as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如之前提到的，我们展示`stop()`方法。该方法只是将`run_`标志设置为`false`，并指示`SnapshotSynthesizer`线程停止：
- en: '[PRE119]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Now that we have seen how to initialize this class, we will look at how `MarketDataPublisher`
    will publish order book updates, first the updates on the incremental updatesmarket
    data channel first and then the market updates on the snapshot updates secondmarket
    data channel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何初始化这个类，我们将看看`MarketDataPublisher`如何发布订单簿更新，首先是增量更新市场数据通道的更新，然后是快照更新市场数据通道的更新。
- en: Publishing order book updates
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布订单簿更新
- en: 'The main `run()` loop in `MarketDataPublisher` does a couple of important things,
    which we will discuss here. First, it drains the `outgoing_md_updates_` queue
    by reading any new `MEMarketDataUpdates` published by the matching engine. This
    part of the code block is shown as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketDataPublisher`中的主要`run()`循环执行几个重要操作，我们将在下面讨论。首先，它通过读取匹配引擎发布的任何新的`MEMarketDataUpdates`来清空`outgoing_md_updates_`队列。以下代码块显示了这部分内容：'
- en: '[PRE120]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Once it has a `MEMarketUpdate` message from the matching engine, it will proceed
    to write it to the `incremental_socket_` UDP socket. But it needs to write out
    the message in the `MDPMarketUpdate` format, which is just a sequence number followed
    by a `MEMarketUpdate` message. As we saw with `OrderServer`, it will achieve this
    here by first writing `next_inc_seq_num_`, which is the next incremental sequence
    number to be sent out on the incremental stream, and then write `MEMarketUpdate`,
    which it received from the matching engine. This logic is shown in the following
    code block, along with the line to increment the read index in the `LFQueue` that
    it just read from:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它从匹配引擎接收到`MEMarketUpdate`消息，它就会继续将其写入`incremental_socket_` UDP套接字。但是，它需要以`MDPMarketUpdate`格式写入消息，这只是一个序列号后面跟着一个`MEMarketUpdate`消息。正如我们在`OrderServer`中看到的那样，它将通过首先写入`next_inc_seq_num_`来实现这一点，这是将要发送到增量流的下一个增量序列号，然后写入它从匹配引擎接收到的`MEMarketUpdate`。这一逻辑在以下代码块中显示，包括它刚刚从`LFQueue`中读取的读取索引增加的行：
- en: '[PRE121]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'It needs to do one additional step here, which is to write the same incremental
    update it wrote to the socket to the `snapshot_md_updates_` `LFQueue` to inform
    the `SnapshotSynthesizer` component about the new incremental update from the
    matching engine that was sent to the clients. That code block is shown as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它还需要执行一个额外的步骤，即将它写入套接字相同的增量更新写入`snapshot_md_updates_` `LFQueue`，以通知`SnapshotSynthesizer`组件关于匹配引擎发送给客户端的新增量更新。以下代码块显示了这部分内容：
- en: '[PRE122]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Finally, it increments the incremental stream sequence number tracker for the
    next message that will be sent out and calls `sendAndRecv()` on `incremental_socket_`
    so that the messages get put on the wire:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它增加增量流序列号跟踪器，以便发送下一个消息，并在`incremental_socket_`上调用`sendAndRecv()`，以便将消息放入线路上：
- en: '[PRE123]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: That concludes all the tasks we need to perform to consume updates from the
    matching engine and generate the incremental market update multicast stream. In
    the next subsection, we will take care of the final key step in the market data
    publisher, which is synthesizing order book snapshots and publishing them periodically
    on the snapshot multicast stream.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们需要执行的所有任务，以从匹配引擎消费更新并生成增量市场更新多播流。在下一个子节中，我们将处理市场数据发布者中的最后关键步骤，即综合订单簿快照并定期在快照多播流上发布它们。
- en: Synthesizing and publishing snapshots
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合和发布快照
- en: This section will be dedicated to the design and implementation of the `SnapshotSynthesizer`
    class, which consumes incremental `MDPMarketDataUpdates` from the `MarketDataPublisher`
    thread, synthesizes a full snapshot of the order book, and periodically publishes
    the full book snapshot on the snapshot multicast stream. All the source code for
    `SnapshotSynthesizer` can be found in the `Chapter7/exchange/market_data/snapshot_synthesizer.h`
    and `Chapter7/exchange/market_data/snapshot_synthesizer.cpp` source files.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将专注于 `SnapshotSynthesizer` 类的设计和实现，该类从 `MarketDataPublisher` 线程中消费增量 `MDPMarketDataUpdates`，合成整个订单簿的完整快照，并定期在快照多播流上发布完整的簿快照。`SnapshotSynthesizer`
    的所有源代码可以在 `Chapter7/exchange/market_data/snapshot_synthesizer.h` 和 `Chapter7/exchange/market_data/snapshot_synthesizer.cpp`
    源文件中找到。
- en: Defining the data members in the snapshot synthesizer
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义快照合成器中的数据成员
- en: 'Let us first define the data members in the `SnapshotSynthesizer` class. The
    important ones are described as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 `SnapshotSynthesizer` 类中的数据成员。其中重要的成员如下所述：
- en: First, `snapshot_md_updates_` of the `MDPMarketUpdateLFQueue` type, which is
    what `MarketDataPublisher` uses to publish incremental `MDPMarketUpdates` to this
    component, which we saw in the previous section.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`snapshot_md_updates_` 是 `MDPMarketUpdateLFQueue` 类型的变量，这是 `MarketDataPublisher`
    用于向该组件发布增量 `MDPMarketUpdates` 的方式，我们之前在章节中已经提到过。
- en: It also has a `snapshot_socket_` variable, which is an `McastSocket` to be used
    to publish snapshot market data updates to the snapshot multicast stream.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还有一个 `snapshot_socket_` 变量，这是一个 `McastSocket`，用于将快照市场数据更新发布到快照多播流。
- en: One of the most important data members is the `ticker_orders_` variable, which
    is a `std::array` of size `ME_MAX_TICKERS` to represent the snapshot of the book
    for each trading instrument. Each element of this array is a `std::array` of `MEMarketUpdate`
    pointers and a maximum size of `ME_MAX_ORDER_IDS` to represent a hash map from
    `OrderId` to the order corresponding to that `OrderId`. As we have done before,
    we use the first `std::array` as a hash map from `TickerId` to the snapshot of
    the limit order book. The second `std::array` is also a hash map from `OrderId`
    to the order information. We will also have an `order_pool_` data member of the
    `MemPool` type of `MEMarketUpdate` objects. This memory pool is what we will use
    to allocate and deallocate `MEMarketUpdate` objects from as we update the order
    book snapshot in the `ticker_orders_` container.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中最重要的数据成员是 `ticker_orders_` 变量，它是一个大小为 `ME_MAX_TICKERS` 的 `std::array`，用于表示每个交易工具的簿快照。这个数组中的每个元素都是一个
    `std::array`，包含 `MEMarketUpdate` 指针和一个最大大小为 `ME_MAX_ORDER_IDS`，用于从 `OrderId` 到对应订单的哈希映射。正如我们之前所做的那样，我们使用第一个
    `std::array` 作为从 `TickerId` 到限价订单簿快照的哈希映射。第二个 `std::array` 也是一个从 `OrderId` 到订单信息的哈希映射。我们还将有一个
    `order_pool_` 数据成员，它是 `MEMarketUpdate` 对象的 `MemPool` 类型。这个内存池是我们将用于在更新 `ticker_orders_`
    容器中的订单簿快照时分配和释放 `MEMarketUpdate` 对象的。
- en: We have two variables to track information about the last incremental market
    data update that `SnapshotSynthesizer` has processed. The first one is the `last_inc_seq_num_`
    variable to track the sequence number on the last incremental `MDPMarketUpdate`
    it has received. The second one is the `last_snapshot_time_` variable used to
    track when the last snapshot was published over UDP since this component will
    only periodically publish the full snapshot of all the books.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有两个变量用于跟踪 `SnapshotSynthesizer` 处理的最后一条增量市场数据更新的信息。第一个是 `last_inc_seq_num_`
    变量，用于跟踪它接收到的最后一条增量 `MDPMarketUpdate` 的序列号。第二个是 `last_snapshot_time_` 变量，用于跟踪最后通过
    UDP 发布快照的时间，因为该组件将只定期发布所有簿的完整快照。
- en: 'There is also a Boolean `run_` variable, which serves a similar purpose as
    the `run_` variables in the `OrderServer` and `MarketDataPublisher` components
    we built before. This will be used to start and stop the `SnapshotSynthesizer`
    thread and will be marked `volatile` since it will be accessed from multiple threads:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个布尔变量 `run_`，它与我们之前构建的 `OrderServer` 和 `MarketDataPublisher` 组件中的 `run_`
    变量具有类似的作用。这个变量将用于启动和停止 `SnapshotSynthesizer` 线程，并且由于它将从多个线程访问，因此会被标记为 `volatile`：
- en: '[PRE124]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: In the next subsection, we will see how these variables are initialized as we
    look at the initialization of the `SnapshotSynthesizer` class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将看到这些变量是如何初始化的，当我们查看 `SnapshotSynthesizer` 类的初始化过程时。
- en: Initializing the snapshot synthesizer
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化快照合成器
- en: 'The `SnapshotSynthesizer` constructor takes an argument of the `MDPMarketUpdateLFQueue`
    type passed to it from the `MarketDataPublisher` component. It also receives the
    network interface name and the snapshot IP and port to represent the multicast
    stream. The constructor initializes the `snapshot_md_updates_` data member from
    the argument passed to it and initializes `logger_` with a new filename. It initializes
    `MEMarketUpdate` `MemPool` to be of the size `ME_MAX_ORDER_IDS`. It also initializes
    `snapshot_socket_` and configures it to publish messages on the snapshot multicast
    IP and port on the provided network interface:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`SnapshotSynthesizer`构造函数接受一个`MDPMarketUpdateLFQueue`类型的参数，该参数由`MarketDataPublisher`组件传递给它。它还接收网络接口名称和快照IP及端口，以表示多播流。构造函数从传递给它的参数初始化`snapshot_md_updates_`数据成员，并用新的文件名初始化`logger_`。它初始化`MEMarketUpdate`
    `MemPool`，使其大小为`ME_MAX_ORDER_IDS`。它还初始化`snapshot_socket_`，并配置它在该提供的网络接口上发布快照多播IP和端口的消息：'
- en: '[PRE150]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We also add a `start()` method here in the same way as we did with our other
    classes before. This `start()` method sets the `run_` flag to true, creates and
    launches a thread, and assigns the `run()` method to the thread:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在这里添加了一个`start()`方法，就像我们之前对其他类所做的那样。这个`start()`方法将`run_`标志设置为true，创建并启动一个线程，并将`run()`方法分配给该线程：
- en: '[PRE151]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The destructor for this class is extremely simple; it just calls the `stop()`
    method. The `stop()` method is also extremely simple and just sets the `run_`
    flag to false so that the `run()` method exits:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的析构函数非常简单；它只是调用`stop()`方法。`stop()`方法也非常简单，只是将`run_`标志设置为false，以便`run()`方法退出：
- en: '[PRE152]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Next, we will look at the important pieces of `SnapshotSynthesizer`, which will
    synthesize the order book snapshots and publish the snapshots periodically.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`SnapshotSynthesizer`的重要部分，它将合成订单簿快照并定期发布快照。
- en: Synthesizing the snapshot of the order book
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合成订单簿快照
- en: The process of synthesizing the snapshot of the order books for the different
    trading instruments is like building `OrderBook`. However, the difference here
    is that the snapshot synthesis process only needs to maintain the last state of
    the live orders, so it is a simpler container. The `addToSnapshot()` method we
    will build next receives an `MDPMarketUpdate` message every time there is a new
    incremental market data update provided to `SnapshotSynthesizer`. We will break
    this method up into several code blocks so that it is easier to follow.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同交易工具合成订单簿快照的过程类似于构建`OrderBook`。然而，这里的区别在于，快照合成过程只需要维护活订单的最后状态，因此它是一个更简单的容器。我们接下来将要构建的`addToSnapshot()`方法每次在向`SnapshotSynthesizer`提供新的增量市场数据更新时都会接收一个`MDPMarketUpdate`消息。我们将把这个方法分成几个代码块，以便更容易理解。
- en: 'In the first code block, we extract the `MEMarketUpdate` piece of the `MDPMarketUpdate`
    message and store it in the `me_market_update` variable. It also finds the `std::array`
    of `MEMarketUpdate` messages for the correct `TickerId` for this instrument from
    the `ticker_orders_ std::array` hash map. We then have a switch case on the type
    of `MarketUpdateType` and then handle each of those cases individually. Before
    we look at each of the cases under the switch case, let us present the initial
    code block in the `addToSnapshot()` method we described:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码块中，我们从`MDPMarketUpdate`消息中提取`MEMarketUpdate`部分，并将其存储在`me_market_update`变量中。它还从`ticker_orders_
    std::array`哈希表中找到对应于该工具的正确`TickerId`的`MEMarketUpdate`消息的`std::array`。然后，我们在`MarketUpdateType`的类型上使用switch
    case，并单独处理每个这些情况。在我们查看switch case下的每个情况之前，让我们先展示`addToSnapshot()`方法中描述的初始代码块：
- en: '[PRE153]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now, we will show the implementation of the `MarketUpdateType::ADD` case in
    the switch case. To handle a `MarketUpdateType::ADD` message, we simply insert
    it into the `MEMarketUpdate` `std::array` at the correct `OrderId` location. We
    create a `MEMarketUpdate` message by allocating it from the `order_pool_` memory
    pool using the `allocate()` call and passing it the `MEMarketUpdate` object to
    copy the fields from:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示`switch case`中`MarketUpdateType::ADD`情况的实现。为了处理`MarketUpdateType::ADD`消息，我们只需将其插入到`MEMarketUpdate`
    `std::array`的正确`OrderId`位置。我们通过从`order_pool_`内存池中分配并使用`allocate()`调用，传递`MEMarketUpdate`对象以复制字段来创建一个`MEMarketUpdate`消息：
- en: '[PRE154]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '`MarketUpdateType::MODIFY` is handled similarly to `MarketUpdateType::ADD`.
    The minor difference here is that we just update the `qty_` and `price_` fields
    and leave the `type_` field on the entry as is:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketUpdateType::MODIFY`的处理方式与`MarketUpdateType::ADD`类似。这里的微小差异是我们只更新`qty_`和`price_`字段，并保持条目上的`type_`字段不变：'
- en: '[PRE155]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The `MarketUpdateType::CANCEL` type does the opposite of what `MarketUpdateType::ADD`
    did. Here, we find `MEMarketUpdate` in the hash map and call `deallocate()` on
    it. We also set the entry in the hash map style `std::array` to `nullptr` to mark
    it as canceled or a dead order:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketUpdateType::CANCEL`类型与`MarketUpdateType::ADD`相反。在这里，我们在哈希表中找到`MEMarketUpdate`，并对其调用`deallocate()`。我们还将在哈希表中的`std::array`条目设置为`nullptr`，以标记其为已取消或死订单：'
- en: '[PRE156]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'We do not need to do anything with the other enumeration values, so we ignore
    them. We just update the last sequence number we have seen on the incremental
    market data stream, which is stored in the `last_inc_seq_num_` data members:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对其他枚举值进行任何操作，因此我们忽略它们。我们只需更新我们在增量市场数据流中看到的最后一个序列号，该序列号存储在`last_inc_seq_num_`数据成员中：
- en: '[PRE157]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This concludes the code to synthesize and update the order book snapshot from
    the incremental `MEMarketUpdate` messages. Next, we will look at how the full
    snapshot stream is generated and published.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了从增量`MEMarketUpdate`消息中合成和更新订单簿快照的代码。接下来，我们将查看如何生成和发布完整的快照流。
- en: Publishing the snapshots
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布快照
- en: 'The next method – `publishSnapshot()` – is called whenever we want to publish
    a complete snapshot of the current state of the order book. Before we look at
    the code to publish the snapshot messages, let us first try to understand the
    format and content of a snapshot message containing the full state of the book
    for multiple instruments. The format of a full snapshot message looks like the
    following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法——`publishSnapshot()`——在我们想要发布订单簿当前状态的完整快照时被调用。在我们查看发布快照消息的代码之前，让我们首先尝试理解包含多个金融工具订单簿完整状态的快照消息的格式和内容。完整的快照消息的格式如下所示：
- en: The first `MDPMarketUpdate` message is of the `MarketUpdateType::SNAPSHOT_START`
    type with `seq_num_ = 0` to mark the beginning of the snapshot messages.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`MDPMarketUpdate`消息是`MarketUpdateType::SNAPSHOT_START`类型，`seq_num_ = 0`，以标记快照消息的开始。
- en: 'Then, for each instrument, we publish the following:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对于每个金融工具，我们发布以下内容：
- en: A `MDPMarketUpdate` message of the `MarketUpdateType::CLEAR` type to instruct
    the client to clear their order book before applying the messages that follow
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`MDPMarketUpdate`消息，消息类型为`MarketUpdateType::CLEAR`，指示客户端在应用后续消息之前清除其订单簿
- en: For each order that exists in the snapshot for this instrument, we publish a
    `MDPMarketUpdate` message with `MarketUpdateType::ADD` till we have published
    the information for all the orders
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于快照中存在的每个订单，我们发布一个`MDPMarketUpdate`消息，消息类型为`MarketUpdateType::ADD`，直到我们发布了所有订单的信息
- en: Finally, we publish a `MDPMarketUpdate` message of the `MarketUpdateType::SNAPSHOT_END`
    type to mark the end of the snapshot messages. One thing to note is that for the
    `SNAPSHOT_START` and `SNAPSHOT_END` messages, we set the `OrderId` value to be
    the last incremental sequence number that was used to construct this snapshot.
    The market participants will use this sequence number to synchronize the snapshot
    market data stream with the incremental market data stream.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们发布一个`MDPMarketUpdate`消息，消息类型为`MarketUpdateType::SNAPSHOT_END`，以标记快照消息的结束。需要注意的是，对于`SNAPSHOT_START`和`SNAPSHOT_END`消息，我们将`OrderId`值设置为用于构建此快照的最后一个增量序列号。市场参与者将使用此序列号来同步快照市场数据流与增量市场数据流。
- en: This design is represented in the following diagram, with a snapshot containing
    data for three instruments.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计在以下图中表示，其中快照包含三个金融工具的数据。
- en: '![Figure 7.3 – Diagram describing the layout of our market data snapshot messages](img/B19434_07_03.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 描述我们的市场数据快照消息布局的图](img/B19434_07_03.jpg)'
- en: Figure 7.3 – Diagram describing the layout of our market data snapshot messages
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 描述我们的市场数据快照消息布局的图
- en: 'With that format in mind, let us look at the code to synthesize and publish
    the snapshot message format we described previously. First, we publish the `MarketUpdateType::SNAPSHOT_START`
    message, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了这种格式之后，让我们看看合成和发布我们之前描述的快照消息格式的代码。首先，我们发布`MarketUpdateType::SNAPSHOT_START`消息，如下所示：
- en: '[PRE158]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Then, we iterate through all the instruments that we will publish the snapshots
    for. The first thing we do is publish the `MDPMarketUpdate` message of the `MarketUpdateType::CLEAR`
    type for that instrument:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有我们将发布快照的金融工具。我们首先为该金融工具发布`MDPMarketUpdate`消息，消息类型为`MarketUpdateType::CLEAR`：
- en: '[PRE159]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Then, we iterate through all the orders for this trading instrument and check
    for live orders – entries that do not have `nullptr` values. For each valid order,
    we publish the `MDPMarketUpdate` message for that `OrderId` with `MarketUpdateType::ADD`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历该交易工具的所有订单，并检查实时订单——即没有`nullptr`值的条目。对于每个有效订单，我们使用`MarketUpdateType::ADD`为该`OrderId`发布`MDPMarketUpdate`消息：
- en: '[PRE160]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Finally, we publish the `MDPMarketUpdate` message with the `MarketUpdateType::SNAPSHOT_END`
    type to signify the end of the snapshot messages this round:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`MarketUpdateType::SNAPSHOT_END`类型发布`MDPMarketUpdate`消息，以表示本轮快照消息的结束：
- en: '[PRE161]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: That concludes the design of the snapshot stream and the code to publish it
    in the `publishSnapshot()` method. In the next subsection, we will finish our
    discussion of the `SnapshotSynthesizer` component in the market data publisher
    infrastructure by implementing the main `run()` loop that ties everything together.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了快照流的规划和在`publishSnapshot()`方法中发布它的代码。在下一小节中，我们将通过实现将一切串联起来的主要`run()`循环来完成对市场数据发布者基础设施中`SnapshotSynthesizer`组件的讨论。
- en: Running the main loop
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行主循环
- en: 'Remember that `SnapshotSynthesizer` runs on its own thread separate from the
    `MarketDataPublisher` thread to not cause latencies on the component that publishes
    the incremental market data stream. The `run()` method is the method assigned
    to the `SnapshotSynthesizer` thread. The only task it performs is checking the
    `snapshot_md_updates_` lock-free queue for new entries, which the `MarketDataPublisher`
    sends incremental `MDPMarketUpdate` messages on. For each incremental `MDPMarketUpdate`
    message it reads, it calls the `addToSnapshot()` method we built earlier. Additionally,
    it checks the `last_snapshot_time_` variable against the current time obtained
    from `getCurrentTime()` to see whether a minute has elapsed. If at least a minute
    has elapsed since the last time a snapshot was published, it calls the `publishSnapshot()`
    method to publish a new snapshot. It also remembers the current time as the last
    time a full snapshot was published:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`SnapshotSynthesizer`在独立的线程上运行，与`MarketDataPublisher`线程分开，以避免对发布增量市场数据流的组件造成延迟。`run()`方法是分配给`SnapshotSynthesizer`线程的方法。它唯一执行的任务是检查`snapshot_md_updates_`无锁队列中的新条目，这是`MarketDataPublisher`发送增量`MDPMarketUpdate`消息的地方。对于它读取的每个增量`MDPMarketUpdate`消息，它调用我们之前构建的`addToSnapshot()`方法。此外，它将`last_snapshot_time_`变量与从`getCurrentTime()`获取的当前时间进行比较，以查看是否已过去一分钟。如果自上次发布快照以来至少过去了一分钟，它将调用`publishSnapshot()`方法来发布一个新的快照。它还记住当前时间作为上次发布完整快照的时间：
- en: '[PRE162]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This concludes the design and implementation of `SnapshotSynthesizer` as well
    as the `MarketDataPublisher` component and our complete electronic trading exchange
    infrastructure. In the next section, we will build the main electronic exchange
    application, which will tie together all the components we have built so far on
    the side of the electronic exchange.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着`SnapshotSynthesizer`以及`MarketDataPublisher`组件和我们的完整电子交易交易所基础设施的设计和实现完成。在下一节中，我们将构建主要的电子交易所应用程序，这将把我们在电子交易所方面构建的所有组件串联起来。
- en: Building the main exchange application
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主要交易所应用程序
- en: 'In this final section of the chapter, as well as the final section of the electronic
    trading exchange discussion, we will build the main exchange application. This
    will be a standalone binary application that will run an order gateway server,
    the matching engine, and the market data publisher and perform the following tasks:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节以及电子交易交易所讨论的最后一节，我们将构建主要交易所应用程序。这将是一个独立的二进制应用程序，它将运行订单网关服务器、匹配引擎和市场数据发布者，并执行以下任务：
- en: The order gateway server accepts client connections and client requests.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单网关服务器接受客户端连接和客户端请求。
- en: The matching engine builds the limit order book.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配引擎构建限价订单簿。
- en: The matching engine also performs matching between client orders.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配引擎也执行客户端订单之间的匹配。
- en: The matching engine and the order gateway server publish client responses.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配引擎和订单网关服务器发布客户端响应。
- en: The matching engine and the market data publisher publish incremental market
    data updates in response to client requests.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配引擎和市场数据发布者根据客户端请求发布增量市场数据更新。
- en: The market data publisher also synthesizes and periodically publishes a full
    snapshot of the order book.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场数据发布者还综合并定期发布订单簿的完整快照。
- en: The complete design is presented in the following diagram.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的设计在以下图中展示。
- en: '![Figure 7.4 – The final trading exchange application and all its components](img/B19434_07_04.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 最终交易交换应用程序及其所有组件](img/B19434_07_04.jpg)'
- en: Figure 7.4 – The final trading exchange application and all its components
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 最终交易交换应用程序及其所有组件
- en: The code for this exchange application is available in the `Chapter7/exchange/exchange_main.cpp`
    source file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此交易所应用程序的代码位于 `Chapter7/exchange/exchange_main.cpp` 源文件中。
- en: 'We will create a `Logger`, `MatchingEngine`, `MarketDataPublisher`, and `OrderServer`
    instance in the global scope. We will also create a signal handling function since
    this application will be killed when a UNIX signal is sent to it. The signal handler
    cleans up the components and exits:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在全局范围内创建 `Logger`、`MatchingEngine`、`MarketDataPublisher` 和 `OrderServer`
    实例。我们还将创建信号处理函数，因为当向应用程序发送 UNIX 信号时，它将被终止。信号处理器清理组件并退出：
- en: '[PRE163]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The `main()` function initializes the logger object, installs the signal handler,
    and sets up three lock-free queues – `client_requests`, of the `ClientRequestLFQueue`
    type, `client_responses`, of the `ClientResponseLFQueue` type, and `market_updates`,
    of the `MEMarketUpdateLFQueue` type – to facilitate communication between the
    three major components:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数初始化日志对象，安装信号处理器，并设置三个无锁队列——`client_requests`，类型为 `ClientRequestLFQueue`，`client_responses`，类型为
    `ClientResponseLFQueue`，以及 `market_updates`，类型为 `MEMarketUpdateLFQueue`，以促进三个主要组件之间的通信：'
- en: '[PRE164]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Then, we create and start the instance of the `MatchingEngine` component and
    pass the three `LFQueue` objects:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建并启动 `MatchingEngine` 组件的实例，并传递三个 `LFQueue` 对象：
- en: '[PRE165]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: We will also create and start the instance of `MarketDataPublisher` and provide
    it with the snapshot and incremental stream information and the `market_updates`
    `LFQueue` object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建并启动 `MarketDataPublisher` 实例，并为其提供快照和增量流信息以及 `market_updates` `LFQueue`
    对象。
- en: 'One note about the interfaces and the IPs and ports specified in this chapter
    as well as the subsequent ones is that we chose these arbitrarily; feel free to
    change them if needed. The important thing here is that the market data stream
    IP:port information used by the electronic exchange and trading clients should
    match, and similarly, the order server IP:port information used by the electronic
    exchange and trading clients match:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章以及随后的章节中指定的接口、IP 和端口的一个注意事项是，我们随意选择了这些；如果需要，请随意更改它们。这里重要的是，电子交易所和交易客户端使用的市场数据流
    IP:port 信息应该匹配，同样，电子交易所和交易客户端使用的订单服务器 IP:port 信息也应该匹配：
- en: '[PRE166]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'We perform similar tasks with the `order_server` object – create `OrderServer`
    and start it after providing it with the order gateway server configuration information:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `order_server` 对象执行类似任务——创建 `OrderServer` 并在提供订单网关服务器配置信息后启动它：
- en: '[PRE167]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Finally, the `main()` thread just sleeps infinitely since the threads within
    the three components will run the exchange from this point on:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main()` 线程将无限期地休眠，因为三个组件内的线程将从这一点开始运行交易所：
- en: '[PRE168]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Running the application as follows will produce some minimal output to the
    screen, but most of the output goes to the log files we create from the three
    components and their subcomponents:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行应用程序将在屏幕上产生一些最小输出，但大部分输出将记录到我们从三个组件及其子组件创建的日志文件中：
- en: '[PRE169]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `exchange_main` application was killed by sending it the `SIGINT` signal
    using the `kill –2 PID` command. We can inspect the log files to see what the
    different components did. Note, however, that the output right now is not super
    interesting. It simply logs that the components were created and started. This
    output will have a lot more information once we add clients for this trading exchange
    that connect and send client requests to it:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kill –2 PID` 命令向 `exchange_main` 应用程序发送 `SIGINT` 信号将其终止。我们可以检查日志文件以查看不同组件做了什么。请注意，但目前的输出并不特别有趣。它只是记录了组件被创建和启动。一旦我们为这个交易交易所添加客户端，它们将连接并发送客户端请求，这种输出将包含更多信息：
- en: '[PRE170]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The `exchange_main.log` file contains information about the creation of the
    different components, as shown:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`exchange_main.log` 文件包含有关不同组件创建的信息，如下所示：'
- en: '[PRE171]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The `exchange_market_data_publisher.log` file creates the UDP sockets and calls
    the `run()` method as shown:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`exchange_market_data_publisher.log` 文件创建 UDP 套接字并调用 `run()` 方法，如下所示：'
- en: '[PRE172]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `exchange_matching_engine.log` file does not have much meaningful output
    yet since no matching was performed and no order book was built:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尚未执行匹配操作且未构建订单簿，`exchange_matching_engine.log` 文件目前没有太多有意义的输出：
- en: '[PRE173]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `exchange_order_server.log` file also contains some information about the
    creation of `TCPServer` and the `run()` method for the main thread:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`exchange_order_server.log`文件还包含有关`TCPServer`的创建和主线程的`run()`方法的一些信息：'
- en: '[PRE174]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Finally, the `exchange_snapshot_synthesizer.log` file outputs the messages
    in an empty snapshot for the different trading instruments, since there are no
    orders in the order book yet:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`exchange_snapshot_synthesizer.log`文件为不同的交易工具输出一个空快照的消息，因为订单簿中还没有订单：
- en: '[PRE175]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: This concludes our discussion, design, and implementation of the electronic
    trading exchange. In the next chapter, we will build the trading system on the
    client’s end.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对电子交易交易所的讨论、设计和实现。在下一章中，我们将构建客户端端的交易系统。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to building the order gateway server and the market
    data publisher components. We also combined the matching engine component we built
    in the previous chapter with the order gateway server and market data publisher
    components we built in this chapter to build the final trading exchange main application.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门用于构建订单网关服务器和市场数据发布者组件。我们还把我们上一章构建的匹配引擎组件与本章构建的订单网关服务器和市场数据发布者组件结合起来，构建最终的交易交易所主应用程序。
- en: First, we defined the public market data protocol that will be used by the exchange
    to publish data on the wire and used by the clients to write market data consumer
    applications. We performed a similar task with the order gateway protocol so that
    client applications can understand the format of the client requests that they
    send to the exchange’s order gateway server and receive responses from.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了交易所将用于在有线上发布数据并供客户端用于编写市场数据消费者应用的公共市场数据协议。我们执行了类似的任务，以订单网关协议，以便客户端应用可以理解它们发送给交易所订单网关服务器的客户端请求的格式，并接收响应。
- en: We built the order gateway server, whose design we established in the *Designing
    Our Trading Ecosystem* chapter. We built the `OrderServer` class, which builds
    and runs `TCPServer`, to accept and manage TCP client connections. We added functionality
    to handle incoming client requests and send client responses. We also built the
    `FIFOSequencer` component, which is responsible for sequencing/ordering the incoming
    TCP client requests in the order in which they were received to maintain fairness
    in the market.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了订单网关服务器，其设计在*设计我们的交易生态系统*章节中确立。我们构建了`OrderServer`类，它构建并运行`TCPServer`以接受和管理TCP客户端连接。我们添加了处理传入客户端请求和发送客户端响应的功能。我们还构建了`FIFOSequencer`组件，它负责按接收到的顺序对传入的TCP客户端请求进行排序/排序，以保持市场中的公平性。
- en: The next component we built was designed in the same chapter, *Designing Our
    Trading Ecosystem*, which is the market data publisher. We built `MarketDataPublisher`,
    which consumes market data updates from the matching engine and generates a multicast
    stream of incremental market data updates. We also added the `SnapshotSynthesizer`
    component, which runs on a different thread and is responsible for consuming market
    data updates from `MarketDataPublisher` and synthesizing the snapshot of the full
    order book. This full snapshot is periodically published by `SnapshotSynthesizer`
    on the snapshot multicast stream.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的下一个组件是在同一章节中设计的，即*设计我们的交易生态系统*，这是市场数据发布者。我们构建了`MarketDataPublisher`，它从匹配引擎消费市场数据更新，并生成一个多播流，包含增量市场数据更新。我们还添加了`SnapshotSynthesizer`组件，它在不同的线程上运行，负责从`MarketDataPublisher`消费市场数据更新并合成完整订单簿的快照。这个完整快照由`SnapshotSynthesizer`定期在快照多播流上发布。
- en: Finally, we built the main electronic trading exchange application, which ties
    together all the exchange side components we have built so far. This will serve
    as the central electronic trading exchange that supports multiple clients and
    different trading instruments for clients to connect and trade as well as receive
    market data updates for.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了主要的电子交易交易所应用程序，它将我们迄今为止构建的所有交易所端组件连接起来。这将作为支持多个客户端和不同交易工具的中心电子交易交易所，供客户端连接和交易，以及接收市场数据更新。
- en: In the next chapter, we switch our focus from the exchange-side infrastructure
    to the market participants’ infrastructure. The next chapter will focus on the
    functionality to connect to the order gateway server and communicate with it,
    as well as receiving and processing the market data updates published by the electronic
    exchange.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注点从交易所基础设施转移到市场参与者基础设施。下一章将专注于连接到订单网关服务器并与它通信的功能，以及接收和处理电子交易所发布的市场数据更新。
- en: Part 3:Building Real-Time C++ Algorithmic Trading Systems
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：构建实时C++算法交易系统
- en: In this part, we will start building the trading client-side C++ algorithmic
    trading system. We will be building components that interface with the trading
    exchange to process market data and connect to and communicate with the exchange
    order gateway. We will also build the C++ framework on which we will build market-making
    and liquidity-taking trading algorithms. In the HFT space, this is where participants
    spend a lot of time and effort trying to reduce latencies and maximize performance
    (and profits). Finally, we will implement the market-making and liquidity-taking
    trading algorithms in this framework, run the entire trading ecosystem, and understand
    the interactions between all the components.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将开始构建交易客户端的C++算法交易系统。我们将构建与交易交易所接口的组件，以处理市场数据，并连接到交易所订单网关进行通信。我们还将构建C++框架，在这个框架上我们将构建市场做市和流动性获取的交易算法。在高频交易领域，参与者会花费大量时间和精力来减少延迟并最大化性能（和利润）。最后，我们将在这个框架中实现市场做市和流动性获取的交易算法，运行整个交易生态系统，并理解所有组件之间的交互。
- en: 'This part contains the following chapters:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B19434_08.xhtml#_idTextAnchor206)*, Processing Market Data and
    Sending Orders to the Exchange in C++*'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19434_08.xhtml#_idTextAnchor206)*，在C++中处理市场数据和向交易所发送订单*'
- en: '[*Chapter 9*](B19434_09.xhtml#_idTextAnchor227)*, Building the C++ Trading
    Algorithm Building Blocks*'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19434_09.xhtml#_idTextAnchor227)*，构建C++交易算法构建块*'
- en: '[*Chapter 10*](B19434_10.xhtml#_idTextAnchor262)*, Building the C++ Market-Making
    and Liquidity-Taking Algorithms*'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19434_10.xhtml#_idTextAnchor262)*，构建C++市场做市和流动性获取算法*'
