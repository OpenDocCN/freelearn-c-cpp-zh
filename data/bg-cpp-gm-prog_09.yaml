- en: Chapter 9. Collision Detection, Pickups, and Bullets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。碰撞检测、拾取物品和子弹
- en: So far we have implemented the main visual aspects of our game. We have a controllable
    character running around in an arena full of zombies that chase him. The problem
    is that they don't interact with each other. A zombie can wander right through
    the player without leaving a scratch. We need to detect collisions between the
    zombies and the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了游戏的主要视觉方面。我们有一个可控的角色在一个充满追逐他的僵尸的竞技场中奔跑。问题是它们彼此之间没有互动。僵尸可以毫无阻碍地穿过玩家。我们需要检测僵尸和玩家之间的碰撞。
- en: If the zombies are going to be able to injure and eventually kill the player,
    it is only fair that we give the player some bullets for his gun. We will then
    need to make sure that the bullets can hit and kill the zombies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果僵尸能够伤害并最终杀死玩家，那么给玩家一些子弹是公平的。然后我们需要确保子弹能够击中并杀死僵尸。
- en: At the same time, if we are writing collision detection code for bullets, zombies,
    and the player, it would be a good time to add a class for health and ammo pickups
    as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们正在为子弹、僵尸和玩家编写碰撞检测代码，那么现在是添加用于健康和弹药拾取的类的好时机。
- en: 'Here is what we will do and the order we will cover the topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要做的事情以及我们将涵盖的主题顺序：
- en: Shooting bullets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击子弹
- en: Adding a crosshair and hiding the mouse pointer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加准星并隐藏鼠标指针
- en: Spawning pickups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成拾取物品
- en: Detecting collisions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Coding the Bullet class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写子弹类
- en: 'We will use the SFML `RectangleShape` class to visually represent a bullet.
    We will code a `Bullet` class that has a `RectangleShape` member as well as other
    member data and functions. We will add bullets to our game in a few steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用SFML的`RectangleShape`类来直观表示子弹。我们将编写一个`Bullet`类，其中包含一个`RectangleShape`成员以及其他成员数据和函数。我们将分几步向游戏中添加子弹：
- en: First we will code the `Bullet.h` file. This will reveal all the details of
    the member data and the prototypes for the functions.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写`Bullet.h`文件。这将显示成员数据的所有细节和函数的原型。
- en: Next we will code the `Bullet.cpp` file which, of course, will contain the definitions
    for all the functions of the `Bullet` class. As we step through it, I will explain
    exactly how an object of type `Bullet` will work and be controlled.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`Bullet.cpp`文件，其中当然将包含`Bullet`类所有函数的定义。当我们逐步进行时，我将解释`Bullet`类型的对象将如何工作和被控制。
- en: Finally, we will declare a whole array full of bullets in the `main` function.
    We will also implement a control scheme for shooting, managing the player's remaining
    ammo, and reloading.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`main`函数中，我们将声明一个完整的子弹数组。我们还将实现射击的控制方案，管理玩家剩余的弹药，并进行重新加载。
- en: Let's get started with step 1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始。
- en: Coding the Bullet header file
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写子弹头文件
- en: To make the new header file, **right-click on Header Files** in the **Solution
    Explorer** and select **Add | New Item...**. In the **Add New Item** window, highlight
    (by left-clicking) **Header File (** `.h` **)** and then in the **Name** field
    type `Bullet.h`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的头文件，**右键单击** **解决方案资源管理器**中的**头文件**，然后选择**添加 | 新项目...**。在**添加新项目**窗口中，通过左键单击**头文件（**`.h`**）**，然后在**名称**字段中键入`Bullet.h`。
- en: 'Add the following private member variables along with the `Bullet` class declaration
    to the `Bullet.h` file. We can then run through and explain what they are for:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bullet.h`文件中，添加以下私有成员变量以及`Bullet`类声明。然后我们可以运行并解释它们的用途：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, the first member is a `Vector2f` called `m_Position`,
    which will hold the bullets location in the game-world.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个成员是一个名为`m_Position`的`Vector2f`，它将保存子弹在游戏世界中的位置。
- en: Next, we declare a `RectangleShape` called `m_BulletShape` as we are using a
    simple non-texture graphic for each bullet, a bit like we did for the time-bar
    in Timber!!!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个名为`m_BulletShape`的`RectangleShape`，因为我们为每颗子弹使用了一个简单的非纹理图形，有点像我们在Timber!!!中为时间条所做的那样。
- en: The code then declares a `Boolean m_InFlight`, which will keep track of whether
    the bullet is currently whizzing through the air, or not. This will enable us
    to decide whether we need to call its `update` function each frame and whether
    or not we need to run collision detection checks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码然后声明了一个`Boolean m_InFlight`，它将跟踪子弹当前是否在空中飞行。这将使我们能够决定是否需要在每帧调用其`update`函数，以及我们是否需要运行碰撞检测检查。
- en: The `float` variable `m_BulletSpeed` will (you can probably guess) hold the
    speed in pixels per second that the bullet will travel at. It is initialized to
    the value of `1000`, which is a little arbitrary—but it works well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`变量`m_BulletSpeed`将（你可能猜到了）保存子弹的像素速度。它被初始化为`1000`的值，这有点随意，但效果很好。'
- en: Next we have two more `float` variables, `m_BulletDistanceX` and `m_BulletDistanceY`.
    As the calculations to move a bullet are a little more complex than those used
    to move a zombie or the player, we will benefit from having these two variables
    that we will perform calculations on. They will be used to decide the horizontal
    and vertical change in the bullets position in each frame.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有另外两个`float`变量，`m_BulletDistanceX`和`m_BulletDistanceY`。由于移动子弹的计算比移动僵尸或玩家的计算稍微复杂一些，我们将受益于这两个变量，我们将对它们进行计算。它们将用于决定每帧子弹位置的水平和垂直变化。
- en: Finally, for the previous code, we have four more `float` variables (`m_MaxX`,
    `m_MinX`, `m_MaxY`, and `m_MinY`) which will later be initialized to hold the
    maximum and minimum, horizontal and vertical positions for the bullet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于前面的代码，我们有另外四个`float`变量（`m_MaxX`、`m_MinX`、`m_MaxY`和`m_MinY`），它们将稍后初始化以保存子弹的水平和垂直位置的最大和最小值。
- en: It is likely that the need for some of these variables is not immediately apparent,
    but it will become clearer when we see each of them in action in the `Bullet.cpp`
    file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能有些变量的需求并不立即显而易见，但当我们在`Bullet.cpp`文件中看到它们各自发挥作用时，它们将变得更清晰。
- en: 'Now add all the public function prototypes to the `Bullet.h` file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有公共函数原型添加到`Bullet.h`文件中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's run through each of the functions in turn, then we can move on to coding
    their definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次审查每个函数，然后我们可以继续编写它们的定义。
- en: First we have the `Bullet` function, which is of course the constructor. In
    this function, we will set up each `Bullet` instance ready for action.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`Bullet`函数，当然是构造函数。在这个函数中，我们将为每个`Bullet`实例设置好准备行动。
- en: The `stop` function will be called when the bullet has been in action but needs
    to stop.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`函数将在子弹已经在行动但需要停止时被调用。'
- en: The `isInFlight` function returns a `Boolean` and will be used to test whether a
    bullet is currently in flight or not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInFlight`函数返回一个布尔值，用于测试子弹当前是否在飞行中。'
- en: The `shoot` function's use is given away by its name, but how it will work deserves
    some discussion. For now, just note that it has four `float` parameters that will
    be passed in. The four values represent the starting (where the player is) horizontal
    and vertical position of the bullet, as well as the vertical and horizontal target
    position (where the crosshair is).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`shoot`函数的用途可以从其名称中得知，但它的工作方式值得讨论。现在，只需注意它有四个`float`参数将被传入。这四个值代表子弹的起始（玩家所在位置）水平和垂直位置，以及垂直和水平目标位置（准星所在位置）。'
- en: 'The `getPosition` function returns a `FloatRect` that represents the location
    of the bullet. This function will be used to detect collisions with zombies. You
    might remember from [Chapter 8](ch08.html "Chapter 8. Pointers, the Standard Template
    Library, and Texture Management"): *Pointers, Standard Template Library, and Texture
    Management* that zombies also had a `getPosition` function.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosition`函数返回一个`FloatRect`，表示子弹的位置。这个函数将用于检测与僵尸的碰撞。您可能还记得来自[第8章](ch08.html
    "第8章。指针、标准模板库和纹理管理")：*指针、标准模板库和纹理管理*中，僵尸也有一个`getPosition`函数。'
- en: Next we have the `getShape` function, which returns an object of type `RectangleShape`.
    As we have discussed, each bullet is represented visually by a `RectangleShape`
    object. The `getShape` function, therefore, will be used to grab a copy of the
    current state of the `RectangleShape`, in order to draw it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有`getShape`函数，它返回一个`RectangleShape`类型的对象。正如我们讨论过的，每个子弹在视觉上都由一个`RectangleShape`对象表示。因此，`getShape`函数将被用来获取`RectangleShape`当前状态的副本，以便绘制它。
- en: Finally, and hopefully as expected, there is the `update`, function which has
    a `float` parameter that represents the fraction of one second that has passed
    since the last time `update` was called. The `update` method will change the position
    of the bullet each frame.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也希望如预期的那样，有`update`函数，它有一个`float`参数，表示自上次调用`update`以来经过的一秒钟的时间。`update`方法将在每一帧改变子弹的位置。
- en: Let's look at and code the function definitions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看并编写函数定义。
- en: Coding the Bullet source file
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写子弹源文件
- en: Now we can create a new `.cpp` file that will contain the function definitions.
    Right-click **Source Files** in the **Solution Explorer** and select **Add | New
    Item...**. In the **Add New Item** window, highlight (by left-clicking) **C++
    File** (`.cpp`) and then in the **Name** field type `Bullet.cpp`. Finally, click
    the **Add** button. We are now ready to code the class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的`.cpp`文件，其中包含函数定义。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加 | 新项目...**。在**添加新项目**窗口中，通过左键单击**C++文件**（`.cpp`）来突出显示，然后在**名称**字段中键入`Bullet.cpp`。最后，单击**添加**按钮。我们现在准备好编写类了。
- en: 'Add the following code, which is the include directives and the constructor.
    We know it is the constructor because the function has the same name as the class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，这是包含指令和构造函数。我们知道这是构造函数，因为函数的名称与类名相同：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only thing that the `Bullet` constructor needs to do is set the size of
    `m_BulletShape`, which is the `RectangleShape` object. The code sets the size
    to two pixels by two pixels.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`构造函数唯一需要做的事情就是设置`m_BulletShape`的大小，这是`RectangleShape`对象。代码将大小设置为两像素乘以两像素。'
- en: 'Next we have the more substantial `shoot` function. Add the following code
    to the `Bullet.cpp` file, study it, and then we can talk about it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是更实质性的`shoot`函数。将以下代码添加到`Bullet.cpp`文件中，研究它，然后我们可以讨论它：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to demystify the shoot function, we will split it up and talk about
    the code we have just added, in chunks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了揭开`shoot`函数的神秘面纱，我们将把它分解并讨论我们刚刚添加的代码块。
- en: 'First let''s remind ourselves about the signature. The shoot function receives
    the starting and target horizontal and vertical positions of a bullet. The calling
    code will supply these based on the position of the player sprite and the position
    of the crosshair. Here it is again:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们回顾一下签名。`shoot`函数接收子弹的起始和目标水平和垂直位置。调用代码将根据玩家精灵的位置和准星的位置提供这些值。这里是它的签名：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the shoot function, we set `m_InFlight` to `true` and position the bullet
    using the parameters `startX` and `startY`. Here is that piece of code again:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shoot`函数内部，我们将`m_InFlight`设置为`true`，并使用参数`startX`和`startY`定位子弹。这里是那段代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we use a bit of simple trigonometry to determine the gradient of travel
    for a bullet. The progression horizontally and vertically of a bullet must vary
    based on the slope of the line created by drawing between the start and target
    of a bullet. The rate of change cannot be the same or very steep shots will arrive
    at the horizontal location before the vertical location, and vice versa for shallow
    shots.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用一些简单的三角学来确定子弹的行进斜率。子弹的水平和垂直进展必须根据在子弹起始和目标之间绘制的线的斜率而变化。变化的速率不能相同，否则非常陡峭的射击将在水平位置到达之前到达垂直位置，对于较浅的射击则相反。
- en: The following code first derives the gradient based on the equation of a line.
    Then it checks whether the gradient is less than zero and if it is, multiplies
    it by `-1`. This is because the start and target coordinates passed in can be
    negative or positive and we always want the amount of progression each frame to
    be positive. Multiplying by `-1` simply makes the negative number into its positive
    equivalent, because a minus multiplied by a minus gives a positive. The actual
    direction of travel will be handled in the `update` function by adding or subtracting
    the positive values we arrive at in this function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码首先根据一条直线的方程推导出斜率。然后它检查斜率是否小于零，如果是，则乘以`-1`。这是因为传入的起始和目标坐标可以是负数或正数，我们总是希望每帧的进度量是正数。乘以`-1`只是将负数变成它的正数等价物，因为负数乘以负数得正数。实际的行进方向将在`update`函数中处理，通过在这个函数中得到的正值进行加减。
- en: Next we calculate a ratio of horizontal to vertical distance by dividing our
    bullet's speed (`m_BulletSpeed`) by one plus the gradient. This will allow us
    to change the bullet's horizontal and vertical position by the correct amount
    each frame, based on the target the bullet is heading toward.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将我们的子弹速度（`m_BulletSpeed`）除以斜率加一来计算水平到垂直距离的比率。这将允许我们根据子弹所指向的目标，每帧正确地改变子弹的水平和垂直位置。
- en: 'Finally, in this part of the code we assign the values to `m_BulletDistanceY`
    and `m_BulletDistanceX`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在代码的这一部分，我们为`m_BulletDistanceY`和`m_BulletDistanceX`赋值：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code is much more straightforward. We simply set a maximum horizontal
    and vertical location that the bullet can reach. We don''t want a bullet carrying
    on forever. We will see this in the `update` function where we test to see whether
    a bullet has passed its maximum or minimum locations:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码要简单得多。我们只是设置了子弹可以到达的最大水平和垂直位置。我们不希望子弹一直飞下去。我们将在`update`函数中看到这一点，我们会测试子弹是否已经超过了它的最大或最小位置：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code moves the **RectangleShape** which represents the bullet
    to its starting location. We use the `setPosition` function as we have often done
    before:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将代表子弹的**RectangleShape**移动到其起始位置。我们像以前经常做的那样使用`setPosition`函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next we have four straightforward functions. Add the `stop`, `isInFlight`,
    `getPosition`, and `getShape` functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有四个简单直接的函数。添加`stop`，`isInFlight`，`getPosition`和`getShape`函数：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `stop` function simply sets the `m_InFlight` variable to `false`. The `isInFlight`
    function returns whatever the value of this same variable currently is. So we
    can see that `shoot` sets the bullet going, `stop` makes it stop, and `isInFlight`
    let us know what the current state is.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`函数只是将`m_InFlight`变量设置为`false`。`isInFlight`函数返回当前这个变量的值。所以我们可以看到`shoot`让子弹飞出去，`stop`让它停下来，`isInFlight`让我们知道当前的状态是什么。'
- en: The `getPosition` function returns a `FloatRect` and we will see how we use
    the `FloatRect` from each game object to detect collisions, soon.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosition`函数返回一个`FloatRect`，我们将看到如何使用每个游戏对象的`FloatRect`来检测碰撞，很快就会看到。'
- en: Finally, for the previous code, `getShape` returns a `RectangleShape` so we
    can draw the bullet once each frame.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于之前的代码，`getShape`返回一个`RectangleShape`，所以我们可以在每一帧中绘制子弹。
- en: 'The last function we need to implement before we can start using `Bullet` objects
    is `update`. Add the following code, study it, and then we can talk about it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`Bullet`对象之前，我们需要实现的最后一个函数是`update`。添加以下代码，研究一下，然后我们可以讨论一下：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `update` function, we use `m_BulletDistanceX` and `m_BulletDistanceY`
    multiplied by the time since the last frame to move the bullet. Remember that
    the values of the two variables were calculated in the `shoot` function and represent
    the gradient (ratio to each other) required to move the bullet at just the right
    angle. Then we use the `setPosition` function to actually move the `RectangleShape`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中，我们使用`m_BulletDistanceX`和`m_BulletDistanceY`乘以自上一帧以来的时间来移动子弹。记住，这两个变量的值是在`shoot`函数中计算的，并且表示移动子弹所需的斜率（彼此的比率）。然后我们使用`setPosition`函数来实际移动`RectangleShape`。
- en: The last thing we do in `update` is test to see whether the bullet has moved
    beyond its maximum range. The slightly convoluted `if` statement checks `m_Position.x`
    and `m_Position.y` against the maximum and minimum values that were calculated
    in the `shoot` function. These maximum and minimum values are stored in `m_MinX`,
    `m_MaxX`, `m_MinY`, and `m_MaxY`. If the test is true, then `m_InFlight` is set
    to `false`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`中我们做的最后一件事是测试子弹是否已经超过了它的最大射程。稍微复杂的`if`语句检查`m_Position.x`和`m_Position.y`与在`shoot`函数中计算的最大和最小值。这些最大和最小值存储在`m_MinX`，`m_MaxX`，`m_MinY`和`m_MaxY`中。如果测试为真，则`m_InFlight`设置为`false`。
- en: The `Bullet` class is done. Now we can see how to shoot some in the `main` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`类已经完成。现在我们可以看看如何在`main`函数中射击一些子弹。'
- en: Making the bullets fly
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让子弹飞
- en: 'We will make the bullets usable with the following six steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下六个步骤使子弹可用：
- en: Add the necessary include directive for the `Bullet` class.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Bullet`类添加必要的包含指令。
- en: Add some control variables and an array to hold some `Bullet` instances.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些控制变量和一个数组来保存一些`Bullet`实例。
- en: Handle the player pressing *R* to reload.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理玩家按下*R*键重新装填。
- en: Handle the player pressing the left mouse button to fire a bullet.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理玩家按下鼠标左键发射子弹。
- en: Update all bullets that are in flight, in each frame.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一帧中更新所有正在飞行的子弹。
- en: Draw the bullets that are in flight, in each frame.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一帧中绘制正在飞行中的子弹。
- en: Including the Bullet class
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含Bullet类
- en: 'Add the include directive to make the Bullet class available:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 添加包含指令以使Bullet类可用：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's move on to the next step.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一步。
- en: Control variables and the bullet array
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制变量和子弹数组
- en: Here are some variables to keep track of bullets, clip sizes, bullets spare/remaining,
    bullets in the clip, the current rate of fire (starting at one per second), and
    the time when the last bullet was fired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些变量来跟踪子弹、弹夹大小、备用/剩余子弹、弹夹中的子弹、当前射速（每秒开始为一颗），以及上一颗子弹被射击的时间。
- en: 'Add the highlighted code and we can move on to seeing all these variables in
    action in the rest of this section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 添加突出显示的代码，我们可以继续看到本节中所有这些变量的实际运行情况：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let's handle what happens when the player presses the ***R*** keyboard
    key, which is used for reloading a clip.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理玩家按下***R***键时会发生什么，这个键用于重新装弹。
- en: Reloading the gun
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新装弹
- en: Now we handle the player input related to shooting bullets. First we will handle
    pressing the ***R*** key to reload the gun. We do so with an SFML event.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理与射击子弹相关的玩家输入。首先，我们将处理按下***R***键重新装弹。我们使用SFML事件来实现。
- en: 'Add the code shown highlighted in the following code block. It is shown with
    lots of context to make sure the code goes in the right place. Study the code
    and then we can talk about it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面突出显示的代码块。为了确保代码放在正确的位置，提供了大量上下文来展示。研究代码，然后我们可以讨论它：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code is nested within the event handling part of the game loop
    (`while(window.pollEvent)`), within the block that only executes when the game
    is actually being played (`if(state == State::Playing)`). It is obvious that we
    don't want the player reloading when the game has finished or is paused and wrapping
    the new code as described achieves this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码嵌套在游戏循环的事件处理部分（`while(window.pollEvent)`）中，只有在游戏实际进行时执行的代码块内（`if(state
    == State::Playing)`）。很明显，我们不希望在游戏结束或暂停时玩家重新装弹，通过描述的新代码实现了这一点。
- en: 'In the new code itself, the first thing we do is test for the **R** key being
    pressed, with `if (event.key.code == Keyboard::R)`. Once we have detected that
    the **R** key was pressed the remaining code is executed. Here is the structure
    of the `if`, `else if`, and `else` blocks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码本身中，我们首先测试是否按下了**R**键，使用`if (event.key.code == Keyboard::R)`。一旦检测到按下**R**键，剩下的代码就会执行。以下是`if`、`else
    if`和`else`块的结构：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous structure allows us to handle three possible scenarios.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的结构允许我们处理三种可能的情况。
- en: The player has pressed `R` and they have more bullets spare than the clip can
    take. In this scenario, the clip is refilled and the number of spare bullets is
    reduced.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家按下了`R`，并且他们有比弹夹能装下的更多的备用子弹。在这种情况下，弹夹被重新填充，备用子弹的数量减少。
- en: The player has some spare bullets but not enough to fill the clip completely.
    In this scenario, the clip is filled with as many spare bullets as the player
    has and the number of spare bullets is set to zero.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家有一些备用子弹，但不足以完全填满弹夹。在这种情况下，弹夹将填满玩家拥有的尽可能多的备用子弹，并且备用子弹的数量被设置为零。
- en: 'The player has pressed R but they have no spare bullets at all. For this scenario,
    we don''t actually need to alter the variables. However, we will play a sound
    effect here when we implement our sound in [C](ch11.html "Chapter 11. Sound Effects,
    File I/O, and Finishing the Game")[hapter 11](ch11.html "Chapter 11. Sound Effects,
    File I/O, and Finishing the Game"): *Sound Effects, File I/O, and Finishing the
    Game*,so we leave the empty `else` block ready.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家按下了R，但他们没有备用子弹。对于这种情况，我们实际上不需要改变变量。但是当我们在[第11章](ch11.html "第11章。音效、文件I/O和完成游戏")中实现声音时，我们会在这里播放声音效果，所以我们留下了空的`else`块。
- en: Let's actually shoot a bullet at last.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实际射击一颗子弹。
- en: Shooting a bullet
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击子弹
- en: 'Next we can handle the left mouse button being clicked to actually fire a bullet.
    Add the highlighted code and study it carefully:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以处理按下鼠标左键来实际射击子弹。添加下面突出显示的代码并仔细研究它：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All of the previous code is wrapped in an `if` statement, which executes whenever
    the left mouse button is pressed, `if (Mouse::isButtonPressed(sf::Mouse::Left))`.
    Note that the code will execute repeatedly, even if the player just holds down
    the button. The code we will go through now controls the rate of fire.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前的代码都包裹在一个`if`语句中，只有当按下鼠标左键时执行，`if (Mouse::isButtonPressed(sf::Mouse::Left))`。请注意，即使玩家只是按住按钮，代码也会重复执行。我们现在要讨论的代码控制射速。
- en: In the previous code, we then check whether the total time elapsed in the game
    (`gameTimeTotal`), minus the time the player last shot a bullet (`lastPressed`),
    is greater than `1000` divided by the current rate of fire, and that the player
    has at least one bullet in the clip. We use `1000` because this is the number
    of milliseconds in a second.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们检查游戏中经过的总时间（`gameTimeTotal`）减去玩家上次射击子弹的时间（`lastPressed`）是否大于`1000`除以当前射速，以及玩家弹夹中至少有一颗子弹。我们使用`1000`是因为这是一秒钟内的毫秒数。
- en: If this test is successful, the code that actually fires a bullet is executed.
    Shooting a bullet is easy because we did all the hard work in the `Bullet` class.
    We simply call `shoot` on the current bullet from the `bullets` array. We pass
    in the player's and crosshair's current horizontal and vertical locations. The
    bullet will be configured and set in flight by the code in the `shoot` function
    of the `Bullet` class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个测试成功，那么实际射击子弹的代码就会执行。射击子弹很容易，因为我们在`Bullet`类中已经做了所有的工作。我们只需在`bullets`数组中的当前子弹上调用`shoot`。我们传入玩家和准星的当前水平和垂直位置。子弹将由`Bullet`类的`shoot`函数中的代码进行配置和发射。
- en: All we have to do is keep track of the array of bullets. First we increment
    the `currentBullet` variable. Then we check to see whether  we fired the last
    bullet (`99`) with the statement `if (currentBullet > 99)`. If it was the last
    bullet, we set `currentBullet` to zero. If it wasn't the last bullet, then the
    next bullet is ready to go whenever the rate of fire permits it and the player
    presses the left mouse button.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是跟踪子弹数组。首先我们增加`currentBullet`变量。然后我们检查是否用语句`if (currentBullet > 99)`发射了最后一颗子弹（`99`）。如果是最后一颗子弹，我们将`currentBullet`设置为零。如果不是最后一颗子弹，那么下一颗子弹就准备好了，只要射速允许并且玩家按下鼠标左键。
- en: Finally, for the previous code, we store the time that the bullet was fired
    in `lastPressed` and decrement `bulletsInClip`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于之前的代码，我们将子弹发射的时间存储在`lastPressed`中，并减少`bulletsInClip`。
- en: Now we can update every bullet, each frame.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以每帧更新每一颗子弹。
- en: Updating the bullets each frame
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每帧更新子弹
- en: 'Add the highlighted code to loop through the bullets array, check whether the
    bullet is in flight, and if it is, call its update function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 添加高亮代码来循环遍历子弹数组，检查子弹是否在飞行，如果是，调用它的更新函数：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And lastly, we can draw all the bullets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以绘制所有的子弹。
- en: Drawing the bullets each frame
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每帧绘制子弹
- en: 'Add the highlighted code to loop through the `bullets` array, check whether
    the bullet is in flight and if it is, draw it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加高亮代码来循环遍历`bullets`数组，检查子弹是否在飞行中，如果是，就绘制它：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the game to try out the bullets. Notice you can fire six shots before you
    need to press ***R*** to reload. The obvious things that are missing are some
    visual indicator of the number of bullets in the clip and the number of spare
    bullets. Another problem is that the player can very quickly run out of bullets,
    especially as the bullets have no stopping power whatsoever. They fly straight
    through the zombies. Add to this that the player is expected to aim at a mouse
    pointer instead of a precision crosshair, and it is plain we have work to do.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏来尝试子弹。注意你可以连续射击六次，然后需要按***R***重新装填。明显缺少的是弹夹中子弹数量和备用子弹数量的一些视觉指示。另一个问题是玩家很快就会用尽子弹，特别是因为子弹根本没有停止力。它们直接穿过僵尸。再加上玩家期望以鼠标指针而不是精确的准星瞄准，我们明显还有工作要做。
- en: In the next chapter, we will give visual feedback through a HUD. We will replace
    the mouse cursor with a crosshair next and then spawn some pickups to replenish
    bullets and health after that. Finally, in this chapter, we will handle collision
    detection to make the bullets and the zombies do damage and make the player able
    to actually get the pickups.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过HUD给出视觉反馈。接下来我们将用一个准星替换鼠标光标，然后在此之后生成一些拾取物品来补充子弹和生命值。最后，在本章中，我们将处理碰撞检测，使子弹和僵尸造成伤害，并使玩家能够真正获得拾取物品。
- en: Giving the player a crosshair
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给玩家一个准星
- en: 'Adding a crosshair is easy and only requires one new concept. Add the highlighted
    code and then we can run through it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个准星很容易，只需要一个新的概念。添加高亮代码，然后我们可以运行它：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First we call the `setMouseCursorVisible` function on our `window` object. We
    then load a `Texture`, declare a `Sprite`, and initialize it in the usual way.
    Furthermore, we set the sprite's origin to its center to make it convenient and
    simpler to make the bullets fly to the middle, as you would expect to happen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们在`window`对象上调用`setMouseCursorVisible`函数。然后我们加载一个`Texture`，声明一个`Sprite`，并以通常的方式初始化它。此外，我们将精灵的原点设置为它的中心，以使子弹飞向中心更加方便和简单，正如你所期望的那样。
- en: 'Now we need to update the crosshair each frame with the world coordinates of
    the mouse. Add the highlighted line of code, which uses the `mouseWorldPosition`
    vector to set the crosshair position each frame:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要每帧更新准星的世界坐标。添加高亮代码行，它使用`mouseWorldPosition`向量来设置每帧的准星位置：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, as you have probably come to expect, we can draw the crosshair for each
    frame. Add the highlighted line of code in the position shown. The line of code
    needs no explanation, but its position after all the other game objects is important
    so it is drawn on top:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如你可能期望的那样，我们可以为每一帧绘制准星。在指定位置添加高亮代码行。这行代码不需要解释，但它在所有其他游戏对象之后的位置很重要，这样它就会被绘制在最上面：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now you can run the game and see the cool crosshair instead of a mouse cursor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行游戏，看到酷炫的准星，而不是鼠标光标：
- en: '![Giving the player a crosshair](img/image_09_001.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![给玩家一个准星](img/image_09_001.jpg)'
- en: Notice how the bullet fires neatly through the center of the crosshair. The
    way the shooting mechanic works is analogous to allowing the player to choose
    to shoot from the hip or aim down the sights. If the player keeps the crosshair
    close to the center, he can fire and turn rapidly, yet has to carefully judge
    the position of distant zombies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意子弹是如何整齐地穿过准星中心的。射击机制的工作方式类似于允许玩家选择从腰部射击或瞄准射击。如果玩家保持准星靠近中心，他可以快速射击和转身，但必须仔细判断远处僵尸的位置。
- en: Alternatively, the player can hover his crosshair directly over the head of
    a distant zombie and score a precise hit; however, he then has much further to
    move the crosshair back if a zombie attacks from another direction.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，玩家可以直接将准星悬停在远处僵尸的头部，进行精确射击；然而，如果僵尸从另一个方向袭击，那么他就需要更远地移动准星。
- en: An interesting improvement to the game would be to add a small random amount
    of inaccuracy to each shot. This inaccuracy could perhaps be mitigated with an
    upgrade between waves.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对游戏的一个有趣改进是为每一枪增加一点小的随机不准确性。这种不准确性可能会在波之间的升级中得到缓解。
- en: Coding a class for pickups
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个用于拾取的类
- en: 'We will code a `Pickup` class that has a `Sprite`, member as well as other
    member data and functions. We will add pickups to our game in just a few steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个`Pickup`类，其中有一个`Sprite`成员以及其他成员数据和函数。我们将在几个步骤中向我们的游戏中添加拾取物品：
- en: First, we will code the `Pickup.h` file. This will reveal all the details of
    the member data and the prototypes for the functions.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写`Pickup.h`文件。这将揭示所有成员数据的细节和函数的原型。
- en: Then we will code the `Pickup.cpp` file which, of course, will contain the definitions
    for all the functions of the `Pickup` class. As we step through it, I will explain
    exactly how an object of type `Pickup` will work and be controlled.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`Pickup.cpp`文件，其中当然将包含`Pickup`类的所有函数的定义。当我们逐步进行时，我将解释`Pickup`类型的对象将如何工作和被控制。
- en: Finally, we will use the `Pickup` class in the `main` function to spawn them,
    update them and draw them.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`main`函数中使用`Pickup`类来生成、更新和绘制它们。
- en: Let's get started with step 1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第1步开始。
- en: Coding the Pickup header file
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写拾取物头文件
- en: To make the new header file, **right-click Header Files** in the **Solution
    Explorer** and select **Add | New Item...**. In the **Add New Item** window, highlight
    (by left-clicking) **Header File (** `.h` **)** and then in the **Name** field
    type `Pickup.h`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的头文件，**在** **解决方案资源管理器** 中**右键单击** **头文件**，然后选择**添加 | 新建项...**。在**添加新项**窗口中，通过左键单击**头文件（**
    `.h` **）**，然后在**名称**字段中键入`Pickup.h`。
- en: 'Add and study the following code in the `Pickup.h` file and then we can go
    through it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Pickup.h`文件中添加并学习以下代码，然后我们可以逐步进行：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code declares all the private variables of the `Pickup` class.
    Although the names should be quite intuitive, it might not be obvious why many
    of them are needed at all. Let''s go through them, starting from the top:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明了`Pickup`类的所有私有变量。虽然这些变量的名称应该很直观，但为什么需要这么多变量可能并不明显。让我们从顶部开始逐个讲解：
- en: '`const int HEALTH_START_VALUE = 50`: This constant variable is used to set
    the starting value of all health pickups. The value will be used to initialize
    the `m_Value` variable, which will need to be manipulated throughout the course
    of a game.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int HEALTH_START_VALUE = 50`：这个常量变量用于设置所有生命值拾取物的起始值。这个值将用于初始化`m_Value`变量，在游戏过程中需要对其进行操作。'
- en: '`const int AMMO_START_VALUE = 12`: This constant variable is used to set the
    starting value of all ammo pickups. The value will be used to initialize the `m_Value`
    variable, which will need to be manipulated throughout the course of a game.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int AMMO_START_VALUE = 12`：这个常量变量用于设置所有弹药拾取物的起始值。这个值将用于初始化`m_Value`变量，在游戏过程中需要对其进行操作。'
- en: '`const int START_WAIT_TIME = 10`: This variable is how long a pickup will wait
    before it re-spawns after disappearing. It will be used to initialize the `m_SecondsToWait`
    variable which can be manipulated throughout the game.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int START_WAIT_TIME = 10`：这个变量是拾取物在消失后重新生成前要等多久。它将用于初始化`m_SecondsToWait`变量，在游戏过程中可以对其进行操作。'
- en: '`const int START_SECONDS_TO_LIVE = 5`: This variable determines how long a
    pickup will last between spawning and being de-spawned. Like the previous three
    constants, it has a non-constant associated with it that can be manipulated throughout
    the course of the game. The non-constant it is used to initialize is `m_SecondsToLive`.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int START_SECONDS_TO_LIVE = 5`：这个变量确定拾取物在生成和消失之间持续多长时间。和前面三个常量一样，它有一个与之关联的非常量，可以在游戏过程中进行操作。它用于初始化`m_SecondsToLive`。'
- en: '`Sprite m_Sprite`: This is the sprite to visually represent the object.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite m_Sprite`：这是用来直观表示对象的精灵。'
- en: '`IntRect m_Arena`: This will hold the size of the current arena to help the
    pickup spawn in a sensible position.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntRect m_Arena`：这将保存当前竞技场的大小，以帮助拾取物在合理的位置生成。'
- en: '`int m_Value`: How much health or ammo is this pickup worth? This value is
    used when the player levels-up the value of the health or ammo pickup.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int m_Value`：这个拾取物值多少生命值或弹药？当玩家升级生命值或弹药拾取物的值时会使用这个值。'
- en: '`int m_Type`: This will be either zero or one for health or ammo. We could
    have used an enumeration class but that seemed like overkill for just two options.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int m_Type`：这将是生命值或弹药的零或一。我们本可以使用一个枚举类，但对于只有两个选项来说，这似乎有点杀鸡用牛刀。'
- en: '`bool m_Spawned`: Is the pickup currently spawned?'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool m_Spawned`：拾取物当前是否生成？'
- en: '`float m_SecondsSinceSpawn`: How long is it since the pickup was spawned?'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsSinceSpawn`：拾取物生成后多长时间了？'
- en: '`float m_SecondsSinceDeSpawn`: How long is it since the pickup was de-spawned
    (disappeared)?'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsSinceDeSpawn`：拾取物消失后多长时间了？'
- en: '`float m_SecondsToLive`: How long should this pickup stay spawned before de-spawning?'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsToLive`：这个拾取物在生成后应该存活多久？'
- en: '`float m_SecondsToWait`: How long should this pickup stay de-spawned before
    re-spawning?'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsToWait`：这个拾取物在消失后应该等多久才重新出现？'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that most of the complexity of this class is due to the variable spawn
    time and its upgradeable nature. If the pickups just re-spawned when collected
    and had a fixed value this would be a very simple class. We need our pickups to
    be upgradeable, so the player is forced to develop a strategy to progress through
    the waves of zombies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个类的大部分复杂性是由于变量生成时间及其可升级的特性。如果拾取物在收集后只是重新生成并具有固定值，那么这将是一个非常简单的类。我们需要我们的拾取物可以升级，所以玩家被迫制定策略来通过僵尸的波次。
- en: 'Next, add the following public function prototypes to the `Pickup.h` file.
    Be sure to familiarize yourself with the new code so we can go through it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Pickup.h`文件中添加以下公共函数原型。确保熟悉新代码，以便我们可以逐步进行：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s talk briefly about each of the function definitions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论每个函数定义：
- en: The first function is the constructor, named after the class. Note that it takes
    a single `int` parameter. This will be used to initialize the type of pickup it
    will be (health or ammo).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数是构造函数，以类的名称命名。注意它只接受一个`int`参数。这将用于初始化它将是什么类型的拾取物（生命值还是弹药）。
- en: The `setArena` function receives an `IntRect`. This function will be called
    for each `Pickup` instance at the start of each wave. The `Pickup` objects will
    then know the areas into which they can spawn.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setArena`函数接收一个`IntRect`。这个函数将在每个波次开始时为每个`Pickup`实例调用。然后`Pickup`对象将知道它们可以生成的区域。'
- en: The `spawn` function will, of course, handle spawning the pickup.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn`函数当然会处理生成拾取物。'
- en: The `getPosition` function, just like in the `Player`, `Zombie`, and `Bullet` classes
    will return a `FloatRect` that represents the current location of the object in
    the game world.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPosition`函数，就像在`Player`、`Zombie`和`Bullet`类中一样，将返回一个代表游戏世界中对象当前位置的`FloatRect`。'
- en: The `getSprite` function returns a `Sprite` object that enables the pickup to
    be drawn, once each frame.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSprite`函数返回一个`Sprite`对象，使得拾取物可以在每一帧中被绘制。'
- en: The `update` function receives the time the previous frame took. It uses this
    value to update its private variables and make decisions about when to spawn and
    de-spawn.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`函数接收上一帧所用的时间。它使用这个值来更新它的私有变量，并决定何时生成和取消生成。'
- en: The `isSpawned` function returns a Boolean that will let the calling code know
    whether or nor the pickup is currently spawned.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSpawned`函数返回一个布尔值，让调用代码知道拾取物当前是否已生成。'
- en: The `gotIt` function will be called when a collision is detected with the player.
    The `Pickup` class code can then prepare itself for re-spawning at the appropriate
    time. Note that it returns an `int` so that the calling code knows how much the
    pickup is worth in either health or ammo.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gotIt`函数在检测到与玩家的碰撞时将被调用。然后`Pickup`类代码可以准备在适当的时间重新生成。请注意，它返回一个`int`，以便调用代码知道拾取物的价值是健康还是弹药。'
- en: The `upgrade` function will be called when the player chooses to levelup the
    properties of a pickup during the levelingup phase of the game.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upgrade`函数将在玩家选择在游戏的升级阶段升级拾取物的属性时被调用。'
- en: Now we have gone through the member variables and function prototypes, it should
    be quite easy to follow along as we code the function definitions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经浏览了成员变量和函数原型，应该很容易跟着我们编写函数定义。
- en: Coding the Pickup class function definitions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Pickup类函数定义
- en: Now we can create a new `.cpp` file that will contain the function definitions.
    Right-click **Source Files** in the **Solution Explorer** and select **Add | New
    Item...**. In the **Add New Item** window, highlight (by left-clicking) **C++
    File (** `.cpp` **)** and then in the **Name** field type `Pickup.cpp`. Finally,
    click the **Add** button. We are now ready to code the class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的`.cpp`文件，其中包含函数定义。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加 | 新项目...**。在**添加新项目**窗口中，通过左键单击**C++文件（**`.cpp`
    **）**突出显示，然后在**名称**字段中键入`Pickup.cpp`。最后，单击**添加**按钮。我们现在准备好编写类的代码了。
- en: 'Add the code shown here to the `Pickup.cpp` file. Be sure to review the code
    so we can discuss it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将此处显示的代码添加到`Pickup.cpp`文件中。确保审查代码，以便我们可以讨论它：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous code, we added the familiar include directives. Then we added
    the `Pickup` constructor. We know it is the constructor because it has the same
    name as the class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们添加了熟悉的包含指令。然后我们添加了`Pickup`构造函数。我们知道这是构造函数，因为它与类名相同。
- en: The constructor receives an `int` called `type` and the first thing the code
    does is assign the value received from `type` to `m_Type`. After this, there is
    an `if…else` block that checks whether `m_Type` is equal to `1`. If it is, `m_Sprite`
    is associated with the health pickup texture and `m_Value` is set to `HEALTH_START_VALUE`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收一个名为`type`的`int`，代码的第一件事就是将从`type`接收到的值赋给`m_Type`。之后，有一个`if…else`块，检查`m_Type`是否等于`1`。如果是，`m_Sprite`将与健康拾取纹理相关联，`m_Value`将设置为`HEALTH_START_VALUE`。
- en: If `m_Type` is not equal to `1`, the `else` block associates the ammo pickup
    texture with `m_Sprite` and assigns the value of `AMMO_START_VALUE` to `m_Value`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_Type`不等于`1`，`else`块将把弹药拾取纹理与`m_Sprite`相关联，并将`AMMO_START_VALUE`的值赋给`m_Value`。
- en: After the `if…else` block, the code sets the origin of `m_Sprite` to the center
    using the `setOrigin` function and assigns `START_SECONDS_TO_LIVE` and `START_WAIT_TIME`
    to `m_SecondsToLive` and `m_SecondsToWait`, respectively.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if…else`块之后，代码使用`setOrigin`函数将`m_Sprite`的原点设置为中心，并将`START_SECONDS_TO_LIVE`和`START_WAIT_TIME`分别赋给`m_SecondsToLive`和`m_SecondsToWait`。
- en: The constructor has successfully prepared a `Pickup` object that is ready for
    use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数已成功准备了一个可以使用的`Pickup`对象。
- en: 'Next we will add the `setArena` function. Examine the code as you add it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将添加`setArena`函数。在添加时检查代码：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `setArena` function that we just coded simply copies the values from the
    passed in `arena`, object but varies the values by plus fifty on the left and
    top and minus fifty on the right and bottom. The Pickup object is now aware of
    the area in which it can spawn. The `setArena` function then calls its own `spawn`
    function to make the final preparations for being drawn and updated each frame.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的`setArena`函数只是简单地复制了传入的`arena`对象的值，但在左侧和顶部增加了五十，右侧和底部减少了五十。现在Pickup对象已经知道它可以生成的区域。`setArena`函数然后调用自己的`spawn`函数，为每一帧的绘制和更新做最后的准备。
- en: 'The `spawn` function is next. Add the following code after the `setArena` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`spawn`函数。在`setArena`函数之后添加以下代码：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `spawn` function does everything necessary to prepare the pickup. First
    it seeds the random number generator and gets a random number for both the horizontal
    and vertical position of the object. Notice that it uses `m_Arena.width` and `m_Arena.height`
    as the ranges for the possible horizontal and vertical positions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`函数执行准备拾取物所需的一切。首先它为随机数生成器设置种子，并获取对象的水平和垂直位置的随机数。请注意，它使用`m_Arena.width`和`m_Arena.height`作为可能水平和垂直位置的范围。'
- en: The `m_SecondsSinceSpawn` is set to zero so the length of time allowed before
    it is de-spawned is reset. The `m_Spawned` variable is set to `true` so that when
    we call `isSpawned`, from `main`, we will get a positive response. Finally, `m_Sprite`
    is moved into position with `setPosition`, ready for drawing to the screen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_SecondsSinceSpawn`设置为零，因此在取消生成之前允许的时间长度被重置。`m_Spawned`变量设置为`true`，因此当我们从`main`中调用`isSpawned`时，我们将得到一个积极的响应。最后，`m_Sprite`通过`setPosition`移动到位置，准备绘制到屏幕上。'
- en: In the following block of code, we have three simple getter functions. The `getPosition`
    function returns a `FloatRect` of the current position of `m_Sprite`, `getSprite`
    returns a copy of `m_Sprite` itself, and `isSpawned` returns `true` or `false`
    depending upon whether the object is currently spawned.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有三个简单的getter函数。`getPosition`函数返回`m_Sprite`当前位置的`FloatRect`，`getSprite`返回`m_Sprite`本身的副本，`isSpawned`根据对象当前是否生成返回`true`或`false`。
- en: 'Add and examine the code we have just discussed:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 添加并检查我们刚刚讨论的代码：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next we will code the `gotIt` function. This function will be called from `main`
    when the player touches/collides with (gets) the pickup. Add the `gotIt` function
    after the `isSpawned` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将编写`gotIt`函数。当玩家触摸/碰撞（获得）拾取物时，将从`main`中调用此函数。在`isSpawned`函数之后添加`gotIt`函数：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `gotIt` function sets `m_Spawned` to `false` so we know not to draw and
    check for collisions at the moment. The `m_SecondsSinceDespawn` is set to zero
    so the countdown to spawning begins again from the start and `m_Value` is returned
    to the calling code so the calling code can handle adding extra ammunition or
    health, as appropriate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`gotIt`函数将`m_Spawned`设置为`false`，所以我们知道此刻不要绘制和检查碰撞。`m_SecondsSinceDespawn`设置为零，因此再次开始生成的倒计时从头开始，`m_Value`返回给调用代码，以便调用代码可以处理添加额外的弹药或生命值。'
- en: 'Next we have the `update` function, which ties together many of the variables
    and functions we have seen so far. Add and familiarize yourself with the `update`
    function and then we can talk about it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`update`函数，它将我们迄今为止看到的许多变量和函数联系在一起。添加并熟悉`update`函数，然后我们可以讨论它：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The update function is divided into four blocks that are considered for execution
    each frame:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数分为四个块，每帧考虑执行一次：'
- en: An `if` block that executes if `m_Spawned` is true—`if (m_Spawned)`. This block
    of code adds the time of this frame to `m_SecondsSinceSpawned`, which keeps track
    of how long the pickup has been spawned.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`m_Spawned`为true，则执行`if`块——`if (m_Spawned)`。这段代码将本帧的时间添加到`m_SecondsSinceSpawned`，以跟踪拾取物已经生成的时间。
- en: A corresponding `else` block that executes if `m_Spawned` is `false`. This block
    adds the time this frame took to `m_SecondsSinceDeSpawn`, which keeps track of
    how long the pickup has waited since it was last de-spawned (hidden).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应的`else`块，如果`m_Spawned`为`false`，则执行。此块将本帧所花费的时间添加到`m_SecondsSinceDeSpawn`，以跟踪拾取物自上次取消生成（隐藏）以来等待的时间。
- en: Another `if` block that executes when the pickup has been spawned for longer
    than it should have been—`if (m_SecondsSinceSpawn > m_SecondsToLive && m_Spawned)`.
    This block sets `m_Spawned` to `false` and resets `m_SecondsSinceDeSpawn` to zero.
    Now block 2 will execute until it is time to spawn again.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个`if`块，当生成的拾取物已经存在的时间超过应该存在的时间时执行——`if (m_SecondsSinceSpawn > m_SecondsToLive
    && m_Spawned)`。这个块将`m_Spawned`设置为`false`，并将`m_SecondsSinceDeSpawn`重置为零。现在块2将执行，直到再次生成的时间到来。
- en: A final `if` block that executes when the time to wait since de-spawning has
    exceeded the necessary wait time, and the pickup is not currently spawned—`if
    (m_SecondsSinceDeSpawn > m_SecondsToWait && !m_Spawned)`. When this block is executed,
    it is time to spawn again and the spawn function is called.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个`if`块，当自上次取消生成以来等待的时间超过必要的等待时间，并且拾取物当前未生成时执行——`if (m_SecondsSinceDeSpawn
    > m_SecondsToWait && !m_Spawned)`。当执行此块时，是时候再次生成了，并调用生成函数。
- en: These four tests and code are what controls the hiding and showing of a pickup.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个测试和代码控制着拾取物的隐藏和显示。
- en: 'Finally, add the definition for the `upgrade` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`upgrade`函数的定义：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `upgrade` function tests for the type of pickup, either health or ammo,
    and then adds 50 percent of the (appropriate) starting value on to `m_Value`.
    The next two lines after the `if…else` blocks increase the amount of time the
    pickup will remain spawned and decrease the amount of time the player has to wait
    between spawns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`upgrade`函数测试拾取物的类型，无论是生命值还是弹药，然后将`m_Value`的初始值的50%添加到其中。在`if…else`块之后的两行增加了拾取物生成的时间和玩家等待生成之间的时间。'
- en: This function is called when the player chooses to levelup the pickups during
    the `LEVELING_UP` state. Our `Pickup` class is ready for use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在`LEVELING_UP`状态下选择升级拾取物时，将调用此函数。我们的`Pickup`类已经准备就绪。
- en: Using the Pickup class
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pickup类
- en: After all that hard work implementing the `Pickup` class, we can now go ahead
    and write code in the game engine to actually put some pickups into the game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有那些辛苦工作实现`Pickup`类之后，我们现在可以继续在游戏引擎中编写代码，真正将一些拾取物放入游戏中。
- en: 'The first thing we do is add an include directive to the `ZombieArena.cpp`
    file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`ZombieArena.cpp`文件中添加一个包含指令：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the following code, we add two `Pickup` instances, one called `healthPickup`
    and the other called `ammoPickup`. We pass the values `1` and `2` respectively
    into the constructor so that they are initialized to the correct type of pickup.
    Add the highlighted code we have just discussed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们添加了两个`Pickup`实例，一个称为`healthPickup`，另一个称为`ammoPickup`。我们分别将值`1`和`2`传递给构造函数，以便它们被初始化为正确类型的拾取物。添加我们刚刚讨论过的突出显示的代码：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `LEVELING_UP` state of the keyboard handling, add the highlighted lines
    within the nested `PLAYING` code block shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在键盘处理的`LEVELING_UP`状态中，添加在嵌套的`PLAYING`代码块中显示的突出行：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The previous code simply passes `arena` into the `setArena` function of each
    pickup. The pickups now know where they can spawn. This code executes for each
    new wave, so as the arena size grows, the `Pickup` objects will get updated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码简单地将`arena`传递给每个拾取物的`setArena`函数。拾取物现在知道它们可以生成的位置。这段代码对于每个新波次都会执行，因此随着竞技场的大小增长，`Pickup`对象将得到更新。
- en: 'The following code simply calls the `update` function for each `Pickup` object,
    on each frame:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码简单地为每个`Pickup`对象在每一帧调用`update`函数：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following code in the draw part of the game loop, checks if the pickup
    is currently spawned and if it is, draws it. Add the highlighted code we have
    just discussed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的绘制部分中的以下代码检查拾取物当前是否生成，如果是，则绘制它。添加我们刚讨论过的突出显示的代码：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now you can run the game and see the pickups spawn and de-spawn. You can't,
    however, actually pick them up yet.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以运行游戏并看到拾取物的生成和消失。但是，您目前无法实际拾取它们。
- en: '![Using the Pickup class](img/image_09_002.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![使用Pickup类](img/image_09_002.jpg)'
- en: Now that we have all the objects in our game, it is a good time to make them
    interact (collide) with each other.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在游戏中有了所有的对象，是时候让它们相互作用（碰撞）了。
- en: Detecting collisions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'We just need to know when certain objects from our game touch certain other
    objects. We can then respond to that event in an appropriate manner. In our classes,
    we have already added functions to call when our objects collide. They are the
    following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要知道游戏中的某些对象何时接触到其他对象。然后我们可以以适当的方式对该事件做出响应。在我们的类中，我们已经添加了在对象碰撞时调用的函数。它们如下：
- en: The `Player` class has a `hit` function. We will call it when a zombie collides
    with the player.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`类有一个`hit`函数。当僵尸与玩家发生碰撞时，我们将调用它。'
- en: The `Zombie` class has a `hit` function. We will call it when a bullet collides
    with a zombie.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zombie`类有一个`hit`函数。当子弹与僵尸发生碰撞时，我们将调用它。'
- en: The `Pickup` class has a `gotIt` function. We will call it when the player collides
    with a pickup.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pickup`类有一个`gotIt`函数。当玩家与拾取物发生碰撞时，我们将调用它。'
- en: 'If necessary, look back to refresh your memory on how each of those functions
    works. All we need to do now is detect the collisions and call the appropriate
    functions. We will use **rectangle intersection** to detect collisions. This type
    of collision detection is really straightforward (especially with SFML). We can
    think of drawing an imaginary rectangle—we can call it a **hitbox** or **bounding
    rectangle**—around the objects we want to test for collision, and then test to
    see whether they intersect. If they do, we have a collision:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，回顾一下每个函数的工作原理。现在我们只需要检测碰撞并调用适当的函数。我们将使用**矩形相交**来检测碰撞。这种类型的碰撞检测非常简单（特别是使用SFML）。我们可以想象绘制一个虚拟的矩形——我们可以称之为**碰撞框**或**边界矩形**——围绕我们想要测试碰撞的对象，然后测试它们是否相交。如果它们相交，我们就有了碰撞：
- en: '![Detecting collisions](img/image_09_003.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![检测碰撞](img/image_09_003.jpg)'
- en: As we can see from the previous image, this is far from perfect. But in this
    situation it is sufficient. To implement this method, all we need to do is test
    for the intersection using the x and y coordinates of both object hit boxes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图像中可以看出，这还远非完美。但在这种情况下已经足够了。要实现这种方法，我们只需要使用两个对象碰撞框的x和y坐标进行相交测试。
- en: 'The code for testing the intersection of two rectangles would look something
    like this. Don''t use the following code. It is for demonstration purposes only:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 检测两个矩形相交的代码看起来可能是这样的。不要使用以下代码。这仅用于演示目的：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We don't need to write this code, however. We will be using the SFML `intersects`
    function, which works on `FloatRect` objects. Think or look back to the `Zombie`,
    `Player`, `Bullet`, and `Pickup` classes, they all had a `getPosition` function,
    which returned a `FloatRect` of the object's current location. We will see how
    we use `getPosition` along with `intersects` to do all our collision detection.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不需要编写这段代码。我们将使用SFML的`intersects`函数，它适用于`FloatRect`对象。回想一下`Zombie`、`Player`、`Bullet`和`Pickup`类，它们都有一个`getPosition`函数，返回对象当前位置的`FloatRect`。我们将看到如何使用`getPosition`和`intersects`来进行所有的碰撞检测。
- en: We will deal with this in three sections of code that will all follow on from
    one another, and they will all go at the end of the update part of our game engine.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三个代码部分处理这个问题，它们将依次跟在游戏引擎更新部分的末尾。
- en: 'We need to know the answer to the following three questions, each frame:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要每帧知道以下三个问题的答案：
- en: Has a zombie been shot?
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有僵尸被击中？
- en: Has the player been touched by a zombie?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家是否被僵尸触碰？
- en: Has the player touched a pickup?
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家是否触碰到了拾取物？
- en: 'First let''s add a couple more variables for `score` and `hiscore`. We can
    then change them when a zombie is killed. Add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们添加几个变量`score`和`hiscore`。然后当杀死僵尸时我们可以改变它们。添加以下代码：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now let's start by detecting whether a zombie is colliding with a bullet.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始检测僵尸是否与子弹发生碰撞。
- en: Has a zombie been shot?
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否有僵尸被击中？
- en: 'The following code might look complicated, but when we step through it we will
    see it is actually nothing we haven''t seen before. Add the following code just
    after the call to update the pickups each frame. Then we can go through it:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可能看起来很复杂，但当我们逐步进行时，我们会发现这实际上并不是我们以前没有见过的东西。在每帧更新拾取物后，添加以下代码。然后我们可以逐步进行：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the next section, we will see all of the zombie and bullet collision detection
    code again. We will do so a bit at a time so we can discuss it. First of all,
    notice the structure of the nested `for` loops (with the code stripped out) as
    follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将再次看到所有的僵尸和子弹碰撞检测代码。我们将一点一点地进行讨论。首先注意嵌套的`for`循环的结构（去掉代码后）如下：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code loops through each and every bullet (0 to 99) for each and every zombie
    (0 to < `numZombies`.).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码循环遍历每一颗子弹（从0到99），对于每一个僵尸（从0到`numZombies`的前一个）。
- en: 'Within the nested `for` loops, we do the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的`for`循环中，我们执行以下操作：
- en: 'Check whether the current bullet is in flight and the current zombie is still
    alive with this code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查当前子弹是否在飞行中，当前僵尸是否仍然活着：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Provided the zombie is alive and the bullet is in flight, we test for a rectangle
    intersection with this code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设僵尸还活着，子弹正在飞行，我们使用以下代码测试矩形相交：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the current bullet and zombie have collided, then we take a number of steps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前子弹和僵尸发生了碰撞，那么我们会采取一些步骤。
- en: 'Stop the bullet with this code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码停止子弹：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Register a hit with the current zombie by calling its `hit` function. Note
    that the `hit` function returns a `Boolean` that let''s the calling code know
    if the zombie is dead yet. This is shown in the following line of code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用其`hit`函数向当前僵尸注册一次命中。请注意，`hit`函数返回一个`Boolean`，让调用代码知道僵尸是否已经死亡。这显示在以下代码行中：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inside this `if` block, which detects when the zombie is dead and not just
    wounded, we do the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`if`块内，检测僵尸是否死亡而不仅仅是受伤时，我们执行以下操作：
- en: Add ten to `score`
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`score`增加十
- en: Change `hiScore` if score has exceeded (beaten) `score`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数超过（击败）`score`，则更改`hiScore`
- en: Reduce `numZombiesAlive` by one
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`numZombiesAlive`减少一个
- en: Check whether all the zombies are dead, `(numZombiesAlive == 0)`, and if so,
    change `state` to `LEVELING_UP`
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否所有僵尸都死了，`(numZombiesAlive == 0)`，如果是，则更改`state`为`LEVELING_UP`
- en: 'Here is the block of code inside `if(zombies[j].hit())` that we have just discussed:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们刚讨论的`if(zombies[j].hit())`内的代码块：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That's the zombies and the bullets taken care of. You could run the game and
    see the blood. Of course you won't see the score until we implement the HUD in
    the next chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了僵尸和子弹。您可以运行游戏并看到血液。当然，在我们在下一章中实现HUD之前，您不会看到分数。
- en: Has the player been touched by a zombie?
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家是否被僵尸触碰？
- en: 'This code is much shorter and simpler than the zombie and bullet collision
    detection. Add the highlighted code just after the previous code we wrote:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比僵尸和子弹碰撞检测要简短和简单得多。在我们编写的先前代码之后添加以下突出显示的代码：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We detect whether a zombie has collided with the player by using a `for` loop
    to loop through all the zombies. For each zombie that is alive, the code uses
    the `intersects` function to test for a collision with the player. When a collision
    has occurred, we call `player.hit`. Then we check whether the player is dead by
    calling `player.getHealth`. If the player's health is equal to or less than zero,
    then we change `state` to `GAME_OVER`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`for`循环遍历所有僵尸来检测僵尸是否与玩家发生碰撞。对于每个活着的僵尸，代码使用`intersects`函数来测试与玩家的碰撞。发生碰撞时，我们调用`player.hit`。然后我们通过调用`player.getHealth`来检查玩家是否死亡。如果玩家的健康值等于或小于零，则我们将`state`更改为`GAME_OVER`。
- en: You can run the game and collisions will be detected. However, as there is no
    HUD or sound effects yet, it is not clear that this is happening. In addition,
    we need to do some more work on resetting the game when the player dies and a
    new game is starting. So, although the game runs, the results are not especially
    satisfying at the moment. We will improve this over the next two chapters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行游戏并检测碰撞。但是，由于尚未添加HUD或音效，因此不清楚是否发生了碰撞。此外，我们需要在玩家死亡并开始新游戏时做更多工作。因此，尽管游戏运行，但目前的结果并不特别令人满意。我们将在接下来的两章中改进这一点。
- en: Has the player touched a pickup?
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家是否触碰了物品？
- en: 'The collision detection code between the player and each of the two pickups
    follows. Add the highlighted code just after the previous code that we added:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家与两个物品之间的碰撞检测代码如下。在我们添加的先前代码之后添加以下突出显示的代码：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The previous code uses two simple `if` statements to see whether either `healthPickup`
    or `ammoPickup` has been touched by the player.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码使用两个简单的`if`语句来查看`healthPickup`或`ammoPickup`是否被玩家触碰。
- en: If a health pickup has been collected, then the `player.increaseHealthLevel`
    function uses the value returned from the `healthPickup.gotIt` function to increase
    the player's health.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已收集了健康物品，则`player.increaseHealthLevel`函数使用从`healthPickup.gotIt`函数返回的值来增加玩家的健康水平。
- en: If an ammo pickup has been collected, then `bulletsSpare` is increased by the
    value returned from `ammoPickup.gotIt`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果弹药捡起已被收集，那么`bulletsSpare`将增加`ammoPickup.gotIt`返回的值。
- en: You can run the game, kill zombies, and collect pickups! Note that when your
    health equals zero, the game will enter the `GAME_OVER` state and pause. To restart
    it, you will need to press *Enter* followed by a number between *1* and *6*. When
    we implement the HUD, the home screen, and the leveling up screen, these steps
    will be intuitive and straightforward for the player. We will do so in the next
    chapter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行游戏，杀死僵尸并收集物品！请注意，当您的健康值等于零时，游戏将进入`GAME_OVER`状态并暂停。要重新开始，您需要按*Enter*，然后输入*1*到*6*之间的数字。当我们实现HUD、主屏幕和升级屏幕时，这些步骤对玩家来说将是直观和简单的。我们将在下一章中这样做。
- en: FAQ
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: 'Here are some questions that might be on your mind:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可能会问的一些问题：
- en: Q) Are there any better ways of doing collision detection?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Q）是否有更好的碰撞检测方法？
- en: 'A) Yes. There are lots more ways to do collision detection, including but not
    limited to the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: A）是的。有许多更多的碰撞检测方法，包括但不限于以下方法：
- en: You can divide objects into multiple rectangles which better fit the shape of
    the sprite. It is perfectly manageable for C++ to check on thousands of rectangles
    each frame. This is especially true when you use techniques such as neighbor checking
    to reduce the number of tests that are necessary each frame.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将对象分成多个更适合精灵形状的矩形。对于C++来说，每帧检查成千上万个矩形是完全可管理的。特别是当您使用邻居检查等技术来减少每帧所需的测试数量时。
- en: For circular objects, you can use the radius overlap method.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于圆形对象，可以使用半径重叠方法。
- en: For irregular polygons, you can use the crossing number algorithm.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不规则多边形，可以使用交叉数算法。
- en: 'All these techniques can be investigated at the following website:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都可以在以下网站上进行调查：
- en: '**Neighbor checking**: [http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/](http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻居检查**：[http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/](http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/)'
- en: '**Radius overlap method**: [http://gamecodeschool.com/essentials/collision-detection-radius-overlap/](http://gamecodeschool.com/essentials/collision-detection-radius-overlap/)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径重叠方法**：[http://gamecodeschool.com/essentials/collision-detection-radius-overlap/](http://gamecodeschool.com/essentials/collision-detection-radius-overlap/)'
- en: '**Crossing number algorithm**: [http://gamecodeschool.com/essentials/collision-detection-crossing-number/](http://gamecodeschool.com/essentials/collision-detection-crossing-number/)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**穿越数算法**：[http://gamecodeschool.com/essentials/collision-detection-crossing-number/](http://gamecodeschool.com/essentials/collision-detection-crossing-number/)'
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That was a busy chapter but we have achieved a lot. Not only did we add bullets
    and pickups to the game through two new classes, but we also made all the objects
    interact as they should by detecting when they collide with each other.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个忙碌的章节，但我们取得了很多成就。我们不仅通过两个新的类为游戏添加了子弹和拾取物，而且还使所有的物体按照应有的方式进行交互，当它们相互碰撞时进行检测。
- en: Despite these achievements, we need to do more work to set up each new game
    and to give the player feedback through a HUD. In the next chapter, we will build
    the HUD.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管取得了这些成就，我们仍需要做更多的工作来设置每个新游戏，并通过HUD向玩家提供反馈。在下一章中，我们将构建HUD。
