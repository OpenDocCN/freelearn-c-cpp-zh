["```cpp\n// Declare SoundBuffer in the usual way \nSoundBuffer zombieBuffer; \n// Declare a Sound object as-per-usual \nSound zombieSound; \n// Load the sound from a file like we have done so often \nzombieBuffer.loadFromFile(\"sound/zombie_growl.wav\"); \n// Associate the Sound object with the Buffer \nzombieSound.setBuffer(zombieBuffer); \n\n```", "```cpp\n// Set the horizontal and vertical positions of the emitter \n// In this case the emitter is a zombie \n// In the Zombie Arena project we could have used  \n// getPosition().x and getPosition().y \n// These values are arbitrary \nfloat x = 500; \nfloat y = 500; \nzombieSound.setPosition(x, y, 0.0f); \n\n```", "```cpp\nzombieSound.setAttenuation(15); \n\n```", "```cpp\nzombieSound.setMinDistance(150); \n\n```", "```cpp\nzombieSound.setLoop(true); \n\n```", "```cpp\nzombieSound.stop(); \n\n```", "```cpp\nif (zombieSound.getStatus() == Sound::Status::Stopped) \n{ \n   // The sound is NOT playing \n   // Take whatever action here \n} \n\nif (zombieSound.getStatus() == Sound::Status::Playing) \n{ \n   // The sound IS playing \n   // Take whatever action here \n} \n\n```", "```cpp\n// Where is the listener?  \n// How we get the values of x and y varies depending upon the game \n// In the Zombie Arena game or the Thomas Was Late game \n// We can use getPosition() \nListener::setPosition(m_Thomas.getPosition().x,  \n   m_Thomas.getPosition().y, 0.0f); \n\n```", "```cpp\njumpSound.setRelativeToListener(true); \njumpSound.play(); \n\n```", "```cpp\n#pragma once \n#include <SFML/Audio.hpp> \n\nusing namespace sf; \n\nclass SoundManager \n{ \n   private: \n      // The buffers \n      SoundBuffer m_FireBuffer; \n      SoundBuffer m_FallInFireBuffer; \n      SoundBuffer m_FallInWaterBuffer; \n      SoundBuffer m_JumpBuffer; \n      SoundBuffer m_ReachGoalBuffer; \n\n      // The Sounds \n      Sound m_Fire1Sound; \n      Sound m_Fire2Sound; \n      Sound m_Fire3Sound; \n      Sound m_FallInFireSound; \n      Sound m_FallInWaterSound; \n      Sound m_JumpSound; \n      Sound m_ReachGoalSound; \n\n      // Which sound should we use next, fire 1, 2 or 3 \n      int m_NextSound = 1; \n\n   public: \n\n      SoundManager(); \n\n      void playFire(Vector2f emitterLocation,  \n         Vector2f listenerLocation); \n\n      void playFallInFire(); \n      void playFallInWater(); \n      void playJump(); \n      void playReachGoal(); \n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"SoundManager.h\" \n#include <SFML/Audio.hpp> \n\nusing namespace sf; \n\nSoundManager::SoundManager() \n{ \n   // Load the sound in to the buffers \n   m_FireBuffer.loadFromFile(\"sound/fire1.wav\"); \n   m_FallInFireBuffer.loadFromFile(\"sound/fallinfire.wav\"); \n   m_FallInWaterBuffer.loadFromFile(\"sound/fallinwater.wav\"); \n   m_JumpBuffer.loadFromFile(\"sound/jump.wav\"); \n   m_ReachGoalBuffer.loadFromFile(\"sound/reachgoal.wav\"); \n\n   // Associate the sounds with the buffers \n   m_Fire1Sound.setBuffer(m_FireBuffer); \n   m_Fire2Sound.setBuffer(m_FireBuffer); \n   m_Fire3Sound.setBuffer(m_FireBuffer); \n   m_FallInFireSound.setBuffer(m_FallInFireBuffer); \n   m_FallInWaterSound.setBuffer(m_FallInWaterBuffer); \n   m_JumpSound.setBuffer(m_JumpBuffer); \n   m_ReachGoalSound.setBuffer(m_ReachGoalBuffer); \n\n   // When the player is 50 pixels away sound is full volume \n   float minDistance = 150; \n   // The sound reduces steadily as the player moves further away \n   float attenuation = 15; \n\n   // Set all the attenuation levels \n   m_Fire1Sound.setAttenuation(attenuation); \n   m_Fire2Sound.setAttenuation(attenuation); \n   m_Fire3Sound.setAttenuation(attenuation); \n\n   // Set all the minimum distance levels \n   m_Fire1Sound.setMinDistance(minDistance); \n   m_Fire2Sound.setMinDistance(minDistance); \n   m_Fire3Sound.setMinDistance(minDistance); \n\n   // Loop all the fire sounds \n   // when they are played \n   m_Fire1Sound.setLoop(true); \n   m_Fire2Sound.setLoop(true); \n   m_Fire3Sound.setLoop(true); \n} \n\n```", "```cpp\nvoid SoundManager::playFire( \n   Vector2f emitterLocation, Vector2f listenerLocation) \n{ \n   // Where is the listener? Thomas. \n   Listener::setPosition(listenerLocation.x,  \n      listenerLocation.y, 0.0f); \n\n   switch(m_NextSound) \n   { \n\n   case 1: \n      // Locate/move the source of the sound \n      m_Fire1Sound.setPosition(emitterLocation.x,  \n         emitterLocation.y, 0.0f); \n\n      if (m_Fire1Sound.getStatus() == Sound::Status::Stopped) \n      { \n         // Play the sound, if its not already \n         m_Fire1Sound.play(); \n      } \n      break; \n\n   case 2: \n      // Do the same as previous for the second sound \n      m_Fire2Sound.setPosition(emitterLocation.x,  \n         emitterLocation.y, 0.0f); \n\n      if (m_Fire2Sound.getStatus() == Sound::Status::Stopped) \n      { \n         m_Fire2Sound.play(); \n      } \n      break; \n\n   case 3: \n      // Do the same as previous for the third sound \n      m_Fire3Sound.setPosition(emitterLocation.x,  \n         emitterLocation.y, 0.0f); \n\n      if (m_Fire3Sound.getStatus() == Sound::Status::Stopped) \n      { \n         m_Fire3Sound.play(); \n      } \n      break; \n   } \n\n   // Increment to the next fire sound \n   m_NextSound++; \n\n   // Go back to 1 when the third sound has been started \n   if (m_NextSound > 3) \n   { \n      m_NextSound = 1; \n   } \n} \n\n```", "```cpp\nvoid SoundManager::playFallInFire() \n{ \n   m_FallInFireSound.setRelativeToListener(true); \n   m_FallInFireSound.play(); \n} \n\nvoid SoundManager::playFallInWater() \n{ \n   m_FallInWaterSound.setRelativeToListener(true); \n   m_FallInWaterSound.play(); \n} \n\nvoid SoundManager::playJump() \n{ \n   m_JumpSound.setRelativeToListener(true); \n   m_JumpSound.play(); \n} \n\nvoid SoundManager::playReachGoal() \n{ \n   m_ReachGoalSound.setRelativeToListener(true); \n   m_ReachGoalSound.play(); \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"TextureHolder.h\" \n#include \"Thomas.h\" \n#include \"Bob.h\" \n#include \"LevelManager.h\" \n#include \"SoundManager.h\" \n\nusing namespace sf; \n\nclass Engine \n{ \nprivate: \n   // The texture holder \n   TextureHolder th; \n\n   // Thomas and his friend, Bob \n   Thomas m_Thomas; \n   Bob m_Bob; \n\n   // A class to manage all the levels \n   LevelManager m_LM; \n\n // Create a SoundManager\n   SoundManager m_SM; \n\n   const int TILE_SIZE = 50; \n   const int VERTS_IN_QUAD = 4; \n\n```", "```cpp\n   ... \n   ... \n   ... \n   // Run will call all the private functions \n   bool detectCollisions(PlayableCharacter& character); \n\n // Make a vector of the best places to emit sounds from\n   void populateEmitters(vector <Vector2f>& vSoundEmitters,\n     int** arrayLevel);\n\n   // A vector of Vector2f for the fire emitter locations\n   vector <Vector2f> m_FireEmitters; \n\npublic: \n   ... \n   ... \n   ... \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n\nusing namespace sf; \nusing namespace std; \n\nvoid Engine::populateEmitters( \n   vector <Vector2f>& vSoundEmitters, int** arrayLevel) \n{ \n\n   // Make sure the vector is empty \n   vSoundEmitters.empty(); \n\n   // Keep track of the previous emitter \n   // so we don't make too many \n   FloatRect previousEmitter; \n\n   // Search for fire in the level \n   for (int x = 0; x < (int)m_LM.getLevelSize().x; x++) \n   { \n      for (int y = 0; y < (int)m_LM.getLevelSize().y; y++) \n      { \n         if (arrayLevel[y][x] == 2)// fire is present \n         { \n            // Skip over any fire tiles too  \n            // near a previous emitter \n            if (!FloatRect(x * TILE_SIZE, \n               y * TILE_SIZE, \n               TILE_SIZE, \n               TILE_SIZE).intersects(previousEmitter)) \n            { \n               // Add the coordiantes of this water block \n               vSoundEmitters.push_back( \n                  Vector2f(x * TILE_SIZE, y * TILE_SIZE)); \n\n               // Make a rectangle 6 blocks x 6 blocks, \n               // so we don't make any more emitters  \n               // too close to this one \n               previousEmitter.left = x * TILE_SIZE; \n               previousEmitter.top = y * TILE_SIZE; \n               previousEmitter.width = TILE_SIZE * 6; \n               previousEmitter.height = TILE_SIZE * 6; \n            } \n\n         } \n\n      } \n\n   } \n   return; \n\n} \n\n```", "```cpp\nvoid Engine::loadLevel() \n{ \n   m_Playing = false; \n\n   // Delete the previously allocated memory \n   for (int i = 0; i < m_LM.getLevelSize().y; ++i) \n   { \n      delete[] m_ArrayLevel[i]; \n\n   } \n   delete[] m_ArrayLevel; \n\n   // Load the next 2d array with the map for the level \n   // And repopulate the vertex array as well \n   m_ArrayLevel = m_LM.nextLevel(m_VALevel); \n\n // Prepare the sound emitters\n   populateEmitters(m_FireEmitters, m_ArrayLevel); \n\n   // How long is this new time limit \n   m_TimeRemaining = m_LM.getTimeLimit(); \n\n   // Spawn Thomas and Bob \n   m_Thomas.spawn(m_LM.getStartPosition(), GRAVITY); \n   m_Bob.spawn(m_LM.getStartPosition(), GRAVITY); \n\n   // Make sure this code isn't run again \n   m_NewLevelRequired = false; \n} \n\n```", "```cpp\n// Handle input specific to Thomas \nif (m_Thomas.handleInput()) \n{ \n   // Play a jump sound \n m_SM.playJump(); \n} \n\n// Handle input specific to Bob \nif (m_Bob.handleInput()) \n{ \n   // Play a jump sound \n m_SM.playJump(); \n} \n\n```", "```cpp\n// Detect collisions and see if characters have reached the goal tile \n// The second part of the if condition is only executed \n// when thomas is touching the home tile \nif (detectCollisions(m_Thomas) && detectCollisions(m_Bob)) \n{ \n   // New level required \n   m_NewLevelRequired = true; \n\n   // Play the reach goal sound \n m_SM.playReachGoal(); \n\n} \nelse \n{ \n   // Run bobs collision detection \n   detectCollisions(m_Bob); \n} \n\n```", "```cpp\n}// End if playing \n\n// Check if a fire sound needs to be played\nvector<Vector2f>::iterator it;\n\n// Iterate through the vector of Vector2f objects\nfor (it = m_FireEmitters.begin();it != m_FireEmitters.end(); it++)\n{\n   // Where is this emitter?\n   // Store the location in pos\n   float posX = (*it).x;\n   float posY = (*it).y;\n   // is the emiter near the player?\n   // Make a 500 pixel rectangle around the emitter\n   FloatRect localRect(posX - 250, posY - 250, 500, 500);\n\n   // Is the player inside localRect?\n   if (m_Thomas.getPosition().intersects(localRect))\n   {\n     // Play the sound and pass in the location as well\n     m_SM.playFire(Vector2f(posX, posY), m_Thomas.getCenter());\n   }\n} \n\n// Set the appropriate view around the appropriate character \n\n```", "```cpp\n// Has character been burnt or drowned? \n// Use head as this allows him to sink a bit \nif (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3) \n{ \n   if (character.getHead().intersects(block)) \n   { \n      character.spawn(m_LM.getStartPosition(), GRAVITY); \n      // Which sound should be played? \n      if (m_ArrayLevel[y][x] == 2)// Fire, ouch! \n      { \n        // Play a sound \n m_SM.playFallInFire(); \n\n      } \n      else // Water \n      { \n        // Play a sound \n m_SM.playFallInWater(); \n      } \n   } \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Hud \n{ \nprivate: \n   Font m_Font; \n   Text m_StartText; \n   Text m_TimeText; \n   Text m_LevelText; \n\npublic: \n   Hud(); \n   Text getMessage(); \n   Text getLevel(); \n   Text getTime(); \n\n   void setLevel(String text); \n   void setTime(String text); \n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Hud.h\" \n\nHud::Hud() \n{ \n   Vector2u resolution; \n   resolution.x = VideoMode::getDesktopMode().width; \n   resolution.y = VideoMode::getDesktopMode().height; \n\n   // Load the font \n   m_Font.loadFromFile(\"fonts/Roboto-Light.ttf\"); \n\n   // when Paused \n   m_StartText.setFont(m_Font); \n   m_StartText.setCharacterSize(100); \n   m_StartText.setFillColor(Color::White); \n   m_StartText.setString(\"Press Enter when ready!\"); \n\n   // Position the text \n   FloatRect textRect = m_StartText.getLocalBounds(); \n\n   m_StartText.setOrigin(textRect.left + \n      textRect.width / 2.0f, \n      textRect.top + \n      textRect.height / 2.0f); \n\n   m_StartText.setPosition( \n      resolution.x / 2.0f, resolution.y / 2.0f); \n\n   // Time \n   m_TimeText.setFont(m_Font); \n   m_TimeText.setCharacterSize(75); \n   m_TimeText.setFillColor(Color::White); \n   m_TimeText.setPosition(resolution.x - 150, 0); \n   m_TimeText.setString(\"------\"); \n\n   // Level \n   m_LevelText.setFont(m_Font); \n   m_LevelText.setCharacterSize(75); \n   m_LevelText.setFillColor(Color::White); \n   m_LevelText.setPosition(25, 0); \n   m_LevelText.setString(\"1\"); \n} \n\n```", "```cpp\nText Hud::getMessage() \n{ \n   return m_StartText; \n} \n\nText Hud::getLevel() \n{ \n   return m_LevelText; \n} \n\nText Hud::getTime() \n{ \n   return m_TimeText; \n} \n\nvoid Hud::setLevel(String text) \n{ \n   m_LevelText.setString(text); \n} \n\nvoid Hud::setTime(String text) \n{ \n   m_TimeText.setString(text); \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"TextureHolder.h\" \n#include \"Thomas.h\" \n#include \"Bob.h\" \n#include \"LevelManager.h\" \n#include \"SoundManager.h\" \n#include \"HUD.h\" \n\nusing namespace sf; \n\nclass Engine \n{ \nprivate: \n   // The texture holder \n   TextureHolder th; \n\n   // Thomas and his friend, Bob \n   Thomas m_Thomas; \n   Bob m_Bob; \n\n   // A class to manage all the levels \n   LevelManager m_LM; \n\n   // Create a SoundManager \n   SoundManager m_SM; \n\n // The Hud   Hud m_Hud;\n   int m_FramesSinceLastHUDUpdate = 0;\n   int m_TargetFramesPerHUDUpdate = 500; \n\n   const int TILE_SIZE = 50; \n\n```", "```cpp\n   // Set the appropriate view around the appropriate character \n   if (m_SplitScreen) \n   { \n      m_LeftView.setCenter(m_Thomas.getCenter()); \n      m_RightView.setCenter(m_Bob.getCenter()); \n   } \n   else \n   { \n      // Centre full screen around appropriate character \n      if (m_Character1) \n      { \n         m_MainView.setCenter(m_Thomas.getCenter()); \n      } \n      else \n      { \n         m_MainView.setCenter(m_Bob.getCenter()); \n      } \n   } \n\n // Time to update the HUD?\n   // Increment the number of frames since the last HUD calculation\n   m_FramesSinceLastHUDUpdate++;\n\n   // Update the HUD every m_TargetFramesPerHUDUpdate frames\n   if (m_FramesSinceLastHUDUpdate > m_TargetFramesPerHUDUpdate)\n   {\n     // Update game HUD text\n     stringstream ssTime;\n     stringstream ssLevel; \n     // Update the time text \n     ssTime << (int)m_TimeRemaining;\n     m_Hud.setTime(ssTime.str());\n     // Update the level text\n     ssLevel << \"Level:\" << m_LM.getCurrentLevel();\n     m_Hud.setLevel(ssLevel.str());\n     m_FramesSinceLastHUDUpdate = 0;\n   } \n}// End of update function \n\n```", "```cpp\n   else \n   { \n      // Split-screen view is active \n\n      // First draw Thomas' side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGLeftView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_LeftView \n      m_Window.setView(m_LeftView); \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Now draw Bob's side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGRightView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_RightView \n      m_Window.setView(m_RightView); \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw bob \n      m_Window.draw(m_Bob.getSprite()); \n\n   } \n\n   // Draw the HUD \n   // Switch to m_HudView \n   m_Window.setView(m_HudView); \n m_Window.draw(m_Hud.getLevel());\n   m_Window.draw(m_Hud.getTime());\n   if (!m_Playing)\n   {\n     m_Window.draw(m_Hud.getMessage());\n   } \n   // Show everything we have just drawn \n   m_Window.display(); \n}// End of draw \n\n```"]