- en: Chapter 10. Don't Panic When You Encounter These Issues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 遇到这些问题时不要慌张
- en: 'During application development, you may get stuck with some issues. Qt is amazing,
    as always, since Qt Creator has an excellent **Debug** mode that can save you
    time when debugging. You''ll learn how to debug either Qt/C++ or Qt Quick/QML
    applications. The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发过程中，你可能会遇到一些问题。Qt 总是令人惊叹，因为 Qt Creator 有一个出色的 **调试** 模式，这可以在调试时节省你的时间。你将学习如何调试
    Qt/C++ 或 Qt Quick/QML 应用程序。本章将涵盖以下主题：
- en: Commonly encountered issues
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题
- en: Debugging Qt applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Qt 应用程序
- en: Debugging Qt Quick applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Qt Quick 应用程序
- en: Useful resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用资源
- en: Commonly encountered issues
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Errors, or more appropriately, unexpected results, are definitely unavoidable
    during application development. Besides, there could also be compiler errors,
    or even application crashes. Please don't panic when you encounter these kinds
    of issues. To ease your pain and help you locate the problem, we have collected
    some commonly encountered and reproducible unexpected results and categorized
    them, as shown in the next sections.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 错误，或者更恰当地说，意外结果，在应用程序开发过程中肯定是不可避免的。此外，还可能有编译器错误，甚至应用程序崩溃。当你遇到这类问题时，请不要慌张。为了减轻你的痛苦并帮助你定位问题，我们已经收集了一些常见的、可复现的意外结果，并将它们分类，如下节所示。
- en: C++ syntax mistakes
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 语法错误
- en: 'For programming beginners, or developers who are not familiar with C and C++,
    the syntax of C++ is not easy to remember. If there are any syntax mistakes, the
    compiler will abort with error messages. In fact, the editor will display tildes
    below problematic statements, as shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编程初学者，或者不熟悉 C 和 C++ 的开发者来说，C++ 的语法并不容易记住。如果出现任何语法错误，编译器将会因为错误信息而终止。实际上，编辑器会在有问题的语句下方显示波浪线，如下所示：
- en: '![C++ syntax mistakes](img/4615OS_10_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![C++ 语法错误](img/4615OS_10_01.jpg)'
- en: 'Among all C++ syntax mistakes, the most common one is a missing semicolon (;).
    C++ needs a semicolon to mark the end of a statement. Therefore, line 7 and line
    8 are equivalent to the following line:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有 C++ 语法错误中，最常见的一个是缺少分号 (;)。C++ 需要分号来标记语句的结束。因此，第 7 行和第 8 行等同于以下行：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This, in C++, is obviously written incorrectly. Not only will the editor highlight
    the error, the compiler will also give you a thorough error message. In this case,
    it''ll display the following message:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，这显然是写错了。不仅编辑器会突出显示错误，编译器也会给你一个详尽的错误信息。在这种情况下，它将显示以下信息：
- en: '`C:\Users\Symeon\OneDrive\Book_Dev\4615OS\4615OS_07\project\Weather_Demo\main.cpp:8:
    error: C2146: syntax error : missing '';'' before identifier ''w''`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\Users\Symeon\OneDrive\Book_Dev\4615OS\4615OS_07\project\Weather_Demo\main.cpp:8:
    错误: C2146: 语法错误 : 在标识符 ''w'' 前缺少 '';''`'
- en: As you can tell, the compiler won't tell you that you should add a semicolon
    at the end of line 7\. Instead, it reads `missing;` before the `w` identifier,
    which is in line 8\. Anyway, in most cases the C++ syntax errors can be detected
    by the compiler, while most of them will first be detected by the editor. Thanks
    to the highlighting feature of Qt Creator, these types of mistakes should be avoided
    effectively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编译器不会告诉你应该在第 7 行末尾添加分号。相反，它在第 8 行的 `w` 标识符之前读取 `missing;`。无论如何，在大多数情况下，C++
    语法错误可以被编译器检测到，而其中大多数首先会被编辑器检测到。多亏了 Qt Creator 的突出显示功能，这些类型的错误应该能够有效地避免。
- en: It's recommended as a good habit that you add a semicolon before you press *Enter*.
    This is because in some cases the syntax may seem correct for compilers and Qt
    Creator, but it's definitely wrongly coded and will cause unexpected behavior.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建议养成一个好习惯，在按下 *Enter* 键之前添加分号。这是因为在某些情况下，语法可能对编译器和 Qt Creator 来说看起来是正确的，但它肯定是不正确的编码，并可能导致意外的行为。
- en: Pointer and memory
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针和内存
- en: Anyone familiar with C and its wild pointers understands how easy it is to make
    a mistake regarding memory management. As we mentioned before, Qt has a superior
    memory management mechanism, which will release its child objects once the parent
    is deleted. This, unfortunately, may lead to a crash if the developer explicitly
    uses `delete` to release a child object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何熟悉 C 及其野指针的人都知道，在内存管理方面出错是多么容易。正如我们之前提到的，Qt 有一个优越的内存管理机制，一旦父对象被删除，它将释放其子对象。不幸的是，如果开发者明确使用
    `delete` 来释放子对象，这可能会导致崩溃。
- en: The primary reason behind this is that `delete` is not a thread-safe operation.
    It may cause a double delete, resulting in a segment fault. Therefore, to release
    memory in a thread-safe way, we use the `deleteLater()` function defined in the
    `QObject` class, which means that this method is available for all classes inherited
    from `QObject`. As stated in the documentation, `deleteLater()` will schedule
    the object for deletion but the deletion won't happen immediately.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的主要原因是 `delete` 不是一个线程安全的操作。它可能会导致双重删除，从而引发段错误。因此，为了以线程安全的方式释放内存，我们使用在 `QObject`
    类中定义的 `deleteLater()` 函数，这意味着这个方法对所有继承自 `QObject` 的类都是可用的。正如文档中所述，`deleteLater()`
    将安排对象进行删除，但删除不会立即发生。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's completely safe to call `deleteLater()` multiple times. Once the first
    deferred deletion is completed, any pending deletions are removed from the event
    queue. There won't be any double deletes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `deleteLater()` 多次是完全安全的。一旦第一次延迟删除完成，任何挂起的删除都将从事件队列中移除。不会发生双重删除。
- en: 'There is another class dealing with memory management in Qt, `QObjectCleanupHandler`.
    This class watches the lifetime of multiple QObjects. You can treat it as a simple
    Qt garbage collector. For instance, there are a lot of `QTcpSocket` objects that
    need to be watched and deleted properly. These kinds of cases are not uncommon,
    especially for networking programs. An easy trick is to add all these objects
    to `QObjectCleanupHandler`. The following piece of code is a simple demonstration
    that adds `QObject` to `QObjectCleanupHandler ch`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 中还有一个处理内存管理的类，`QObjectCleanupHandler`。这个类监视多个 QObjects 的生命周期。你可以将其视为一个简单的
    Qt 垃圾收集器。例如，有很多 `QTcpSocket` 对象需要被监视和正确删除。这类情况并不少见，尤其是在网络程序中。一个简单的技巧是将所有这些对象添加到
    `QObjectCleanupHandler` 中。以下代码片段是一个简单的演示，它将 `QObject` 添加到 `QObjectCleanupHandler
    ch`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding the `t` object to `ch` won't change the parent object of `t` from this
    to `&ch`. `QObjectCleanupHandler` is more like `QList` in this way. If `t` is
    deleted somewhere else, it'll get removed from the list of `ch` automatically.
    If there is no object left, the `isEmpty()` function will return `true`. All objects
    in `QObjectCleanupHandler` will be deleted when it's destroyed. You can also explicitly
    call `clear()` to delete all objects in `QObjectCleanupHandler` manually.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `t` 对象添加到 `ch` 中不会改变 `t` 的父对象从 `this` 到 `&ch`。`QObjectCleanupHandler` 在这方面更像是
    `QList`。如果 `t` 在其他地方被删除，它将自动从 `ch` 的列表中移除。如果没有对象剩下，`isEmpty()` 函数将返回 `true`。当
    `QObjectCleanupHandler` 被销毁时，其中所有的对象都将被删除。你也可以显式调用 `clear()` 来手动删除 `QObjectCleanupHandler`
    中的所有对象。
- en: Incompatible shared libraries
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不兼容的共享库
- en: This type of errors are the so-called DLL Hell, which we discussed in the previous
    chapter. It results from incompatible shared libraries, which may lead to strange
    behavior or crashes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误被称为 DLL 地狱，我们在上一章中讨论过。它是由不兼容的共享库引起的，可能会导致奇怪的行为或崩溃。
- en: In most cases, Qt libraries are backwards compatible, which means that you may
    replace all DLLs with newer ones and not need to recompile executables. Some certain
    modules or APIs may be deprecated and be deleted from a later version of Qt. For
    example, the `QGLWidget` class is replaced by a newly introduced `QOpenGLWidget`
    class in Qt 5.4\. `QGLWidget` is still provided for now though.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Qt 库是向后兼容的，这意味着你可以用新的 DLL 替换所有的 DLL，而不需要重新编译可执行文件。某些特定的模块或 API 可能已经被弃用，并将在
    Qt 的后续版本中删除。例如，`QGLWidget` 类在 Qt 5.4 中被新引入的 `QOpenGLWidget` 类所取代。尽管如此，`QGLWidget`
    目前仍然提供。
- en: In the reverse direction, things are getting pretty bad. If your application
    calls an API that is introduced since, for example, Qt 5.4, the application definitely
    will malfunction with an older version of Qt, such as Qt 5.2.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在相反的方向上，事情变得相当糟糕。如果你的应用程序调用了一个自 Qt 5.4 以来引入的 API，那么应用程序在较老的 Qt 版本（如 Qt 5.2）中肯定会出现故障。
- en: 'The following is a simple program that makes use of `QSysInfo`, which is introduced
    in Qt 5.4\. The `main.cpp` file of this simple `incompat_demo` project is shown
    here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的程序，它使用了在 Qt 5.4 中引入的 `QSysInfo`。这个简单 `incompat_demo` 项目的 `main.cpp`
    文件如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`QSysInfo::currentCpuArchitecture()` returns the architecture of the CPU that
    the application is running on as a `QString` object. If the version of Qt is high
    enough (greater than or equal to 5.4), it''ll run as expected, as shown in the
    following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSysInfo::currentCpuArchitecture()` 返回应用程序正在运行的 CPU 架构，作为一个 `QString` 对象。如果
    Qt 的版本足够高（大于或等于 5.4），它将按预期运行，如下面的截图所示：'
- en: '![Incompatible shared libraries](img/4615OS_10_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![不兼容的共享库](img/4615OS_10_02.jpg)'
- en: 'As you can see, it says we''re running this application on a 64-bit x86 CPU
    machine. However, if we put the compiled executable with DLLs from Qt 5.2, it''ll
    give an error as shown here and crash:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它说我们在一个 64 位 x86 CPU 机器上运行此应用程序。然而，如果我们使用 Qt 5.2 的 DLL 编译的可执行文件，它将显示错误，如这里所示，并崩溃：
- en: '![Incompatible shared libraries](img/4615OS_10_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![不兼容的共享库](img/4615OS_10_03.jpg)'
- en: This situation is rare, of course. However, if this happens, you'll get an idea
    about what goes wrong. From the error dialog, we can see the error is because
    of the missing `QSysInfo::currentCpuArchitecture` line in the dynamic link library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况当然很少见。然而，如果发生这种情况，你会对出了什么问题有一个大概的了解。从错误对话框中，我们可以看到错误是因为动态链接库中缺少 `QSysInfo::currentCpuArchitecture`
    行。
- en: Another DLL Hell is more complex and may be ignored by beginners. All libraries
    must be built by the same compiler. You can't use the MSVC libraries with GCC,
    which holds true for other compilers, such as ICC and Clang. Different compiler
    versions might cause incompatibility as well. You probably don't want to use a
    library compiled by GCC 4.3 in your development environment where the GCC version
    is 4.9\. However, libraries compiled by GCC 4.9.1 should be compatible with those
    compiled by GCC 4.9.2.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 DLL 地狱更为复杂，可能被初学者忽略。所有库都必须由相同的编译器构建。你不能使用 MSVC 库与 GCC 一起，这对其他编译器也适用，例如 ICC
    和 Clang。不同的编译器版本也可能导致不兼容。你可能不希望在 GCC 版本为 4.9 的开发环境中使用由 GCC 4.3 编译的库。然而，由 GCC 4.9.1
    编译的库应该与由 GCC 4.9.2 编译的库兼容。
- en: In addition to compilers, different architectures are often incompatible. For
    example, 64-bit libraries won't work on 32-bit platforms. Similarly, x86 libraries
    and binaries can't be used on the non-x86 devices, such as ARM and MIPS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译器之外，不同的架构通常是不兼容的。例如，64位库在32位平台上无法工作。同样，x86 库和可执行文件不能用于非 x86 设备，如 ARM 和 MIPS。
- en: Doesn't run on Android!
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Android 上无法运行！
- en: Qt was ported to Android not too long ago. Hence, there is a possibility that
    it runs well on a desktop PC but not on Android. On one hand, Android hardware
    varies, not even speaking of thousands of customized ROMs. Therefore, it is reasonable
    that some Android devices may encounter compatibility issues. On the other hand,
    the Qt application running on Android is a native C++ application with a Java
    wrapper, while binary executables are naturally more vulnerable to compatibility
    issues than scripts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 最近才移植到 Android。因此，它在桌面 PC 上运行良好，但在 Android 上可能不行。一方面，Android 硬件各不相同，更不用说成千上万的定制
    ROM 了。因此，一些 Android 设备可能遇到兼容性问题是有道理的。另一方面，在 Android 上运行的 Qt 应用程序是一个带有 Java 包装器的本地
    C++ 应用程序，而二进制可执行文件自然更容易遇到兼容性问题，比脚本更敏感。
- en: 'Anyway, here''s the recipe:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这里有一个步骤：
- en: Try to run your application on another Android handset or virtual Android device.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在另一部 Android 手机或虚拟 Android 设备上运行你的应用程序。
- en: If it still doesn't work, it can be a potential bug of Qt on Android. We'll
    talk about how to report a bug to Qt at the end of this chapter.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果仍然不起作用，它可能是 Qt 在 Android 上的潜在错误。我们将在本章末尾讨论如何向 Qt 报告错误。
- en: Debugging Qt applications
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Qt 应用程序
- en: To debug any Qt application, you need to ensure that you have installed the
    debug symbols of the Qt libraries. On Windows, they are installed together with
    release version DLLs. Meanwhile, on Linux, you may need to install debug symbols
    by the distribution's package manager.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试任何 Qt 应用程序，你需要确保你已经安装了 Qt 库的调试符号。在 Windows 上，它们与发布版本的 DLL 一起安装。同时，在 Linux
    上，你可能需要通过发行版的包管理器安装调试符号。
- en: 'Some developers tend to use a function similar to `printf` to debug the application.
    Qt provides four global functions, which are shown in the following table, to
    print out debug, warnings, and error text:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者倾向于使用类似于 `printf` 的函数来调试应用程序。Qt 提供了四个全局函数，如下表所示，用于打印调试、警告和错误文本：
- en: '| Function | Usage |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 用途 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `qDebug()` | This function is used for writing custom debug output. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `qDebug()` | 此函数用于写入自定义调试输出。|'
- en: '| `qWarning()` | This function is used for reporting warnings and recoverable
    errors. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `qWarning()` | 此函数用于报告警告和可恢复的错误。|'
- en: '| `qCritical()` | This function is used for writing critical error messages
    and reporting system errors. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `qCritical()` | 此函数用于写入关键错误消息和报告系统错误。|'
- en: '| `qFatal()` | This function is used for printing fatal error messages shortly
    before exiting. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `qFatal()` | 此函数用于在退出前打印致命错误消息。|'
- en: Normally, you can just use a C-style method similar to `printf`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以使用类似于`printf`的C风格方法。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, in most cases, we'll include the `<QtDebug>` header file so that we
    can use the stream operator (`<<`) as a more convenient way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，我们会包含`<QtDebug>`头文件，这样我们就可以使用流操作符（`<<`）作为更方便的方式。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most powerful place of these functions is that they can output the contents
    of some complex classes', `QList` and `QMap`. It's noted that these complex data
    types can only be printed through a stream operator (`<<`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数最强大的地方在于它们可以输出某些复杂类、`QList`和`QMap`的内容。需要注意的是，这些复杂的数据类型只能通过流操作符（`<<`）打印。
- en: Both `qDebug()` and `qWarning()` are debugging tools, which mean that they can
    be disabled at compile time by defining `QT_NO_DEBUG_OUTPUT` and `QT_NO_WARNING_OUTPUT`,
    respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`qDebug()`和`qWarning()`都是调试工具，这意味着它们可以通过定义`QT_NO_DEBUG_OUTPUT`和`QT_NO_WARNING_OUTPUT`分别在编译时禁用。'
- en: In addition to these functions, Qt also provides the `QObject::dumpObjectTree()`
    and `QObject::dumpObjectInfo()` functions which are often useful, especially when
    an application looks strange. `QObject::dumpObjectTree()` dumps information about
    signal connections, which is really useful if you think there may be a problem
    in signal slot connections. Meanwhile, the latter dumps a tree of children to
    the debug output. Don't forget to build the application in **Debug** mode, otherwise
    neither of them will print anything.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些功能外，Qt还提供了`QObject::dumpObjectTree()`和`QObject::dumpObjectInfo()`函数，这些函数通常很有用，尤其是在应用程序看起来异常时。`QObject::dumpObjectTree()`会输出信号连接的信息，如果您认为信号槽连接可能存在问题，这会非常有用。同时，后者会将子节点以树状结构输出到调试输出。别忘了以**调试**模式构建应用程序，否则它们都不会打印任何内容。
- en: Apart from these useful debugging functions, Qt Creator has offered an intuitive
    way to debug your application. Ensure that you've installed Microsoft **Console
    debugger** (**CDB**) if you're using an MSVC compiler. In other cases, the GDB
    debugger is bundled in a MinGW version.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些有用的调试功能外，Qt Creator还提供了一种直观的方式来调试您的应用程序。如果您使用的是MSVC编译器，请确保已安装Microsoft **控制台调试器**（**CDB**）。在其他情况下，GDB调试器包含在MinGW版本中。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CDB is now a part of **Windows Driver Kit** (**WDK**); visit [http://msdn.microsoft.com/en-us/windows/hardware/hh852365](http://msdn.microsoft.com/en-us/windows/hardware/hh852365)
    to download it. Don't forget to check Debugging Tools for Windows during the installation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CDB现在是**Windows驱动程序工具包**（**WDK**）的一部分；请访问[http://msdn.microsoft.com/en-us/windows/hardware/hh852365](http://msdn.microsoft.com/en-us/windows/hardware/hh852365)下载它。别忘了在安装过程中检查调试工具包。
- en: 'Consider `Fancy_Clock` from [Chapter 2](ch02.xhtml "Chapter 2. Building a Beautiful
    Cross-platform Clock"), *Building a Beautiful Cross-platform Clock*, as an example.
    In the `MainWindow::setColour()` function, move the cursor to line 97, which is
    `switch (i) {`. Then, navigate to **Debug** | **Toggle Breakpoint** or just press
    *F9* on the keyboard. This will add a breakpoint on line 97, which will add a
    breakpoint marker (a red pause icon in front of a line number) as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以[第2章](ch02.xhtml "第2章. 构建一个漂亮的跨平台时钟")中的`Fancy_Clock`为例，*构建一个漂亮的跨平台时钟*。在`MainWindow::setColour()`函数中，将光标移至第97行，即`switch
    (i) {`。然后，导航到**调试** | **切换断点**，或者直接按键盘上的*F9*。这将在第97行添加一个断点，并添加一个断点标记（行号前的红色暂停图标），如图所示：
- en: '![Debugging Qt applications](img/4615OS_10_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![调试Qt应用程序](img/4615OS_10_04.jpg)'
- en: Now click on the **Start Debugging** button on the pane, which has a bug on
    it, or navigate to **Debug** | **Start Debugging** | **Start Debugging** on the
    menu bar, or press *F5* on the keyboard. This will recompile the application,
    if needed, and start it in **Debug** mode. At the same time, Qt Creator will automatically
    switch to **Debug** mode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击面板上的**开始调试**按钮，它上面有一个错误，或者导航到菜单栏上的**调试** | **开始调试** | **开始调试**，或者按键盘上的*F5*。这将根据需要重新编译应用程序，并以**调试**模式启动。同时，Qt
    Creator将自动切换到**调试**模式。
- en: '![Debugging Qt applications](img/4615OS_10_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![调试Qt应用程序](img/4615OS_10_05.jpg)'
- en: The application is interrupted because of the breakpoint we set. You can see
    a yellow arrow indicating which line the application is currently on, as shown
    in the preceding screenshot. By default, on the right pane, you can see **Locals
    and Expressions** where all the local variables along with their values and types
    are shown. To change the default settings, navigate to **Window** | **Views**,
    and then choose what to display or hide.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中断是因为我们设置的断点。您可以看到一个黄色箭头指示应用程序当前所在的行，如前一张截图所示。默认情况下，在右侧面板中，您可以查看**局部变量和表达式**，其中显示了所有局部变量及其值和类型。要更改默认设置，请转到**窗口**
    | **视图**，然后选择要显示或隐藏的内容。
- en: 'The panes in the **Debug** mode are marked in blue text in this screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中的**调试**模式面板以蓝色文字标记：
- en: '![Debugging Qt applications](img/4615OS_10_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Qt 应用程序](img/4615OS_10_06.jpg)'
- en: Briefly said, you can monitor the variables in **Locals** and expressions in
    **Expressions**. **Stack** displays the current stack and all breakpoints can
    be managed in the **Breakpoints** pane.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您可以在**局部变量**中监控变量，在**表达式**中监控表达式。**堆栈**显示当前堆栈，所有断点都可以在**断点**面板中管理。
- en: On the bottom pane, there are a series of buttons to control the debugging process.
    The first six buttons are **Continue**, **Stop Debugger**, **Step Over**, **Step
    Into**, **Step Out**, and **Restart the debugging session**, respectively. **Step
    Over** is to execute a line of code as a whole. **Step Into** will step into a
    function or a subfunction, while **Step Out** can leave the current function or
    subfunction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部面板中，有一系列按钮用于控制调试过程。前六个按钮分别是**继续**、**停止调试器**、**单步执行**、**进入**、**退出**和**重启调试会话**。**单步执行**是将一行代码作为一个整体执行。**进入**将进入一个函数或子函数，而**退出**可以离开当前函数或子函数。
- en: '**Breakpoints** plays a crucial role in debugging, as you can tell whether
    a breakpoint represents a position or set of positions in the code that interrupts
    the application from being debugged and grants you control. Once it is interrupted,
    you can examine the state of the program or continue the execution, either line-by-line
    or continuously. Qt Creator shows breakpoints in the **Breakpoints** view, which
    is located at the lower-right-hand side by default. You can add or delete breakpoints
    in the **Breakpoints** view. To add a breakpoint, right-click on the **Breakpoints**
    view and select **Add Breakpoint…**; there will be an **Add Breakpoint** dialog
    as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**断点**在调试中起着至关重要的作用，因为它可以告诉您断点代表的是代码中的位置或一组位置，这些位置会中断应用程序的调试并赋予您控制权。一旦中断，您可以检查程序的状态或继续执行，无论是逐行还是连续执行。Qt
    Creator在**断点**视图中显示断点，默认情况下位于右下角。您可以在**断点**视图中添加或删除断点。要添加断点，右键单击**断点**视图并选择**添加断点…**；将出现一个**添加断点**对话框，如下所示：'
- en: '![Debugging Qt applications](img/4615OS_10_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Qt 应用程序](img/4615OS_10_07.jpg)'
- en: In the **Breakpoint type** field, select the location in the program code where
    you want the application to be interrupted. Other options are dependent on the
    selected type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在**断点类型**字段中，选择程序代码中您希望应用程序中断的位置。其他选项取决于所选类型。
- en: To move the breakpoint, simply drag the breakpoint marker and drop it on the
    destination. It's not an often needed function, though.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动断点，只需拖动断点标记并将其放置在目标位置。尽管这不是一个经常需要的功能。
- en: There're many ways to delete a breakpoint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 删除断点有许多方法。
- en: By clicking on the breakpoint marker in the editor, moving the cursor to the
    corresponding line, and navigating to **Debug** | **Toggle Breakpoint**, or by
    pressing *F9*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在编辑器中单击断点标记，将光标移动到相应的行，然后转到**调试** | **切换断点**，或按*F9*
- en: By right-clicking on the breakpoint in the **Breakpoints** view and selecting
    **Delete Breakpoint**
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在**断点**视图中右键单击断点并选择**删除断点**
- en: By selecting the breakpoint in the **Breakpoints** view and pressing the *Delete*
    button on the keyboard
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在**断点**视图中选择断点并按下键盘上的*删除*按钮
- en: 'The most powerful place is the previously introduced **Locals and Expressions**
    view. Every time the program stops under the control of the debugger, it retrieves
    information and displays it in the **Locals and Expressions** view. The **Locals**
    pane shows function parameters and local variables. There is a comprehensive display
    of data belonging to Qt''s basic objects. In this case, when the program is interrupted
    in `MainWindow::setColour()`, there is a pointer whose **Value** is `"MainWindow"`.
    Instead of just memory address of this pointer, it can show you all the data and
    children that belong to this object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最强大的地方是之前介绍的**局部变量和表达式**视图。每次程序在调试器的控制下停止时，它都会检索信息并在**局部变量和表达式**视图中显示。**局部**窗格显示函数参数和局部变量。Qt
    基本对象的数据有全面的显示。在这种情况下，当程序在`MainWindow::setColour()`中断时，有一个其**值**为`"MainWindow"`的指针。除了这个指针的内存地址之外，它还可以显示属于此对象的所有数据和子项：
- en: '![Debugging Qt applications](img/4615OS_10_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Qt 应用程序](img/4615OS_10_08.jpg)'
- en: 'As you can see from preceding screenshot, this is a `MainWindow` instance,
    which is inherited from `QMainWindow`. It has three children items: `_layout`,
    `qt_rubberband`, and `centralWidget`. It''s noted that only slot functions are
    displayed in `[methods]`. Now you''ll understand why the **Locals** pane is the
    most important and commonly used view in the **Debug** mode.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，这是一个`MainWindow`实例，它继承自`QMainWindow`。它有三个子项：`_layout`、`qt_rubberband`和`centralWidget`。请注意，在`[方法]`中只显示槽函数。现在你将理解为什么**局部**窗格是**调试**模式中最重要且最常用的视图。
- en: On the other hand, the **Expressions** pane is even more powerful and can compute
    the values of arithmetic expressions or function calls. Right-click on the **Locals
    and Expressions** view and select **Add New Expression Evaluator…** in the context
    menu.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**表达式**窗格功能更强大，可以计算算术表达式或函数调用的值。在**局部变量和表达式**视图中右键单击，并在上下文菜单中选择**添加新表达式计算器…**。
- en: Note that the context menu entries are available only when the program is interrupted.
    In this case, `Fancy_Clock` is interrupted in the `MainWindow::setColour()` function
    where the local variable, `i`, can be used to perform some arithmetic operations.
    For example, we fill `i * 5` in the **New Evaluated Expression** pop-up dialog.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上下文菜单条目仅在程序中断时可用。在这种情况下，`Fancy_Clock`在`MainWindow::setColour()`函数中被中断，其中局部变量`i`可以用来执行一些算术运算。例如，我们在**新评估表达式**弹出对话框中填写`i
    * 5`。
- en: '![Debugging Qt applications](img/4615OS_10_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Qt 应用程序](img/4615OS_10_09.jpg)'
- en: In addition to arithmetic operations, you can call a function to evaluate the
    return value. However, this function must be accessible to the debugger, which
    means it's either compiled into the executable or can be invoked from a library.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术运算之外，你可以调用一个函数来评估返回值。然而，这个函数必须对调试器是可访问的，这意味着它要么被编译到可执行文件中，要么可以从库中调用。
- en: 'The expression value will be re-evaluated after each step. After you click
    on the **OK** button, the expression `i * 5`, is shown in the **Expressions**
    pane as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的值将在每次步骤后重新评估。点击**确定**按钮后，表达式`i * 5`将如所示在**表达式**窗格中显示：
- en: '![Debugging Qt applications](img/4615OS_10_10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Qt 应用程序](img/4615OS_10_10.jpg)'
- en: The value of `i` is now `3`. Therefore, the expression `i * 5` is evaluated
    as `15`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`i`的值是`3`。因此，表达式`i * 5`被评估为`15`。
- en: '*"Expression evaluators are powerful, but slow down debugger operation significantly.
    It is advisable not to use them excessively, and to remove unneeded expression
    evaluators as soon as possible."*'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"表达式计算器功能强大，但会显著减慢调试器的操作速度。建议不要过度使用，并尽快移除不必要的表达式计算器。"*'
- en: Even if functions used in the expressions have side effects, they will be called
    each time the current frame changes. After all, the expression evaluator is powerful
    but bad for debugging speed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使表达式中的函数有副作用，它们也将在当前帧更改时被调用。毕竟，表达式计算器功能强大，但会影响调试速度。
- en: Debugging Qt Quick applications
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Qt Quick 应用程序
- en: We will use the `Weather_QML` project from [Chapter 7](ch07.xhtml "Chapter 7. Parsing
    JSON and XML Documents to Use Online APIs"), *Parsing JSON and XML Documents to
    Use Online APIs*, as a demonstration program to show how to debug a Qt Quick application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自[第 7 章](ch07.xhtml "第 7 章。解析 JSON 和 XML 文档以使用在线 API")，*解析 JSON 和 XML
    文档以使用在线 API*的`Weather_QML`项目作为演示程序，展示如何调试 Qt Quick 应用程序。
- en: 'First, we need to ensure that QML debugging is enabled. Open the `Weather_QML`
    project in Qt Creator. Then, perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保已启用QML调试。在Qt Creator中打开`Weather_QML`项目。然后，执行以下步骤：
- en: Switch to the **Projects** mode.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**项目**模式。
- en: Expand the **qmake** step in **Build Steps**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建步骤**中扩展**qmake**步骤。
- en: Check **Enable QML debugging** if it's not checked.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未勾选，请勾选**启用QML调试**。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Debugging QML will open a socket at a well-known port, which poses a security
    risk. Anyone on your network could connect to the debugging application and execute
    any JavaScript function. Therefore, you have to make sure there are appropriate
    firewall rules.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调试QML将在一个知名端口上打开一个套接字，这会带来安全风险。您的网络上的任何人都可以连接到调试应用程序并执行任何JavaScript函数。因此，您必须确保有适当的防火墙规则。
- en: The same procedure is used to start QML debugging, which is to navigate to **Debug**
    | **Start Debugging** | **Start Debugging**, or click the **Debug** button, or
    just press *F5*. It may trigger a **Windows Security Alert**, shown in the following
    screenshot. Don't forget to click on the **Allow access** button.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 启动QML调试使用相同的步骤，即导航到**调试** | **开始调试** | **开始调试**，或点击**调试**按钮，或直接按*F5*。它可能会触发**Windows安全警报**，如下面的截图所示。别忘了点击**允许访问**按钮。
- en: '![Debugging Qt Quick applications](img/4615OS_10_11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![调试Qt Quick应用程序](img/4615OS_10_11.jpg)'
- en: Once the application starts running, it behaves and performs as usual. However,
    you can perform some useful tasks in debugging mode. You can see all the elements
    and their properties in the **Locals** pane as we did for the Qt/C++ applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序开始运行，它将像往常一样运行和表现。然而，在调试模式下，您可以执行一些有用的任务。您可以在**局部变量**面板中看到所有元素及其属性，就像我们对Qt/C++应用程序所做的那样。
- en: In addition to just watching these variables, you can change them temporarily
    and see the changes at runtime immediately. To change a value, you can either
    directly change it in the **Locals** pane or change it in **QML/JS Console**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了观察这些变量之外，您还可以临时更改它们，并在运行时立即看到更改。要更改值，您可以直接在**局部变量**面板中更改它，或者在**QML/JS控制台**中更改它。
- en: 'For example, to change the `title` property of `ApplicationWindow`, perform
    the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要更改`ApplicationWindow`的`title`属性，请执行以下步骤：
- en: Expand **ApplicationWindow** | **Properties** in the **Locals** pane.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**局部变量**面板中展开**ApplicationWindow** | **属性**。
- en: Double-click on the `title` entry.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`title`条目。
- en: Change the value from `Weather QML` to `Yahoo! Weather`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值从`Weather QML`更改为`Yahoo! Weather`。
- en: Press the *Enter* or *Return* key on the keyboard to confirm.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按键盘上的*Enter*或*Return*键确认。
- en: Alternatively, you can change it in **QML/JS Console**. There is no need to
    expand `ApplicationWindow`; just click on `ApplicationWindow` in the **Locals**
    pane. You'll notice **Context** on the **QML/JS Console** panel will become `ApplicationWindow`,
    as shown in the following screenshot. Then, just input the `title="Yahoo! Weather"`
    command to change the title.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以在**QML/JS控制台**中更改它。无需展开`ApplicationWindow`；只需在**局部变量**面板中点击`ApplicationWindow`。您会注意到**QML/JS控制台**面板上的**上下文**将变为`ApplicationWindow`，如下面的截图所示。然后，只需输入`title="Yahoo!
    Weather"`命令来更改标题。
- en: '![Debugging Qt Quick applications](img/4615OS_10_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![调试Qt Quick应用程序](img/4615OS_10_12.jpg)'
- en: 'You''ll notice the title in the application window is changed to **Yahoo! Weather**
    immediately, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到应用程序窗口中的标题立即更改为**Yahoo! Weather**，如下所示：
- en: '![Debugging Qt Quick applications](img/4615OS_10_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![调试Qt Quick应用程序](img/4615OS_10_13.jpg)'
- en: Meanwhile, the source code is left intact. This feature is really handy when
    you want to test a better value for a property. Instead of changing it in the
    code and rerunning, you can change and test it on the fly. In fact, you can also
    execute the JavaScript expressions in **QML/JS Console**, not just change their
    values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，源代码保持不变。当您想测试属性的更好值时，这个功能特别方便。您不必在代码中更改并重新运行，可以直接更改并测试。实际上，您还可以在**QML/JS控制台**中执行JavaScript表达式，而不仅仅是更改它们的值。
- en: Useful resources
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用资源
- en: Still getting stuck with an issue? In addition to online search engines, there
    are two online forums that could also be useful for you. The first one is the
    forum in the Qt Project, whose URL is [http://qt-project.org/forums](http://qt-project.org/forums).
    The other one is maintained by a community site, Qt Centre, and its URL is [http://www.qtcentre.org/forum.php](http://www.qtcentre.org/forum.php).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然遇到问题？除了在线搜索引擎外，还有两个在线论坛可能对您也很有用。第一个是 Qt 项目论坛，其网址为 [http://qt-project.org/forums](http://qt-project.org/forums)。另一个是由社区网站
    Qt Centre 维护的，其网址为 [http://www.qtcentre.org/forum.php](http://www.qtcentre.org/forum.php)。
- en: In most cases, you should be able to find similar or even identical problems
    on these websites. If not, you can post a new thread asking for help. Describe
    the problem as thoroughly as possible so that other users can get an idea of what's
    going wrong.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您应该能够在这些网站上找到类似或甚至完全相同的问题。如果没有，您可以发起新的主题寻求帮助。尽可能详细地描述问题，以便其他用户可以了解出了什么问题。
- en: There is a possibility that you did everything correctly but still might be
    getting unexpected results, compiler errors, or crashes. In this case, it may
    be a Qt bug. If you believe that you've encountered a Qt bug, you are encouraged
    to report it. It's easy to report a bug since Qt has a bug tracker, whose URL
    is [https://bugreports.qt.io](https://bugreports.qt.io).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能您已经正确地做了所有事情，但仍然可能得到意外的结果、编译错误或崩溃。在这种情况下，这可能是 Qt 错误。如果您认为您遇到了 Qt 错误，您被鼓励报告它。由于
    Qt 有错误跟踪器，因此报告错误很容易，其网址为 [https://bugreports.qt.io](https://bugreports.qt.io)。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The quality of the bug report dramatically impacts how soon the bug will be
    fixed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 错误报告的质量将直接影响错误被修复的速度。
- en: 'To produce a high-quality bug report, here is a simple step-by-step manual:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成高质量的错误报告，以下是一个简单的分步指南：
- en: Visit the Qt bug tracker website.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Qt 错误跟踪器网站。
- en: Log in. If it's your first time, you need to create a new account. Remember
    to supply a valid e-mail address as this is the only way for the Qt developers
    to contact you.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录。如果是第一次，您需要创建一个新账户。请记住提供有效的电子邮件地址，因为这是 Qt 开发人员与您联系的唯一方式。
- en: Use the **Search** field on the upper-right side to find any similar, or even
    identical bugs.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右上角的**搜索**字段查找任何类似或甚至完全相同的错误。
- en: If you find one, you can leave a comment with any additional information that
    you have. Besides, you can click on **Vote** to vote for that bug. Lastly, you
    could add yourself as a watcher if you want to track the progress.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您发现了错误，您可以在评论中留下任何额外的信息。此外，您还可以点击**投票**为该错误投票。最后，如果您想跟踪进度，可以添加自己作为观察者。
- en: If not, click on **Create New Issues** and fill in the fields.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，请点击**创建新问题**并填写字段。
- en: You should enter a brief descriptive text in **Summary**. This is not only for
    a higher chance to get it fixed, but also good for other people searching for
    existing bugs. For other fields, you're always encouraged to provide as much information
    as you can.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在**摘要**中输入简短的描述性文本。这不仅增加了修复错误的机会，而且对其他正在搜索现有错误的人也有帮助。对于其他字段，您总是被鼓励提供尽可能多的信息。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After having a read through this chapter, you can sort out the majority of Qt-based
    issues on your own. We started off with a few commonly encountered problems, followed
    by how to debug Qt and Qt Quick applications. At the end, there were a few useful
    links to help you crack down on the varied issues and errors. If you encounter
    any problem with a particular Qt bug, don't panic, just go to the bug tracker
    and report it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章后，您可以自己解决大多数基于 Qt 的问题。我们首先介绍了一些常见问题，然后是如何调试 Qt 和 Qt Quick 应用程序。最后，提供了一些有用的链接，以帮助您解决各种问题和错误。如果您遇到特定
    Qt 错误的问题，不要慌张，只需去错误跟踪器报告即可。
