["```cpp\nint s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n```", "```cpp\nint socket(int domain, int type, int protocol);\n```", "```cpp\nint s = socket(AF_INET, SOCK_STREAM, 0);\n\nstruct sockaddr_in server;\nserver.sin_family = AF_INET;\nserver.sin_port = htons(port);\nserver.sin_addr.s_addr = INADDR_ANY;\n\nbind(s, (struct sockaddr*)&server, sizeof(server));\n```", "```cpp\nlisten(s, 5);\n```", "```cpp\nstruct sockaddr_in client;\nint addrlen;\nint new_socket = accept(s, (struct sockaddr_in*)&client, &addrlen);\n// use the new_socket\n```", "```cpp\nchar buffer[BUFFER_MAX_SIZE]; // define BUFFER_MAX_SIZE based on the specifics of the server\nrecv(new_socket, buffer, sizeof(buffer), 0);\n// now the buffer contains received data\n```", "```cpp\nchar msg[] = \"From server with love\";\nsend(new_socket, msg, sizeof(msg), 0);\n```", "```cpp\nclass Networking\n{\npublic:\n  void start_server();\n\npublic:\n  std::shared_ptr<Networking> get_instance();\n  void remove_instance();\n\nprivate:\n  Networking();\n  ~Networking();\n\nprivate:\n  int socket_;\n  sockaddr_in server_;\n  std::vector<sockaddr_in> clients_;\n\nprivate:\n  static std::shared_ptr<Networking> instance_ = nullptr;\n  static int MAX_QUEUED_CONNECTIONS = 1;\n};\n```", "```cpp\nvoid Networking::start_server()\n{\n  socket_ = socket(AF_INET, SOCK_STREAM, 0);\n  // the following check is the only one in this code snippet\n  // we skipped checking results of other functions for brevity, \n  // you shouldn't omit them in your code\n  if (socket_ < 0) { \n    throw std::exception(\"Cannot create a socket\");\n  }\n\n  struct sockaddr_in server;\n  server.sin_family = AF_INET;\n  server.sin_port = htons(port);\n  server.sin_addr.s_addr = INADDR_ANY;\n\n  bind(s, (struct sockaddr*)&server, sizeof(server));\n  listen(s, MAX_QUEUED_CONNECTIONS);\n // the accept() should be here\n}\n```", "```cpp\nvoid Networking::start_server()\n{\n  // code omitted for brevity (see in the previous snippet)\n  while (true) {\n    sockaddr_in client;\n    int addrlen;\n    int new_socket = accept(socket_, (sockaddr_in*)&client, &addrlen);\n    clients_.push_back(client);\n  }\n}\n```", "```cpp\nclass Client\n{\npublic:\n  // public accessors\n\nprivate:\n  int socket_;\n  sockaddr_in connection_info_;\n};\n```", "```cpp\nstd::vector<Client> clients_;\n```", "```cpp\nclass Client\n{\npublic:\n  void send(const std::string& data) {\n    // wraps the call to POSIX send() \n  }\n  std::string receive() {\n    // wraps the call to POSIX recv()\n  }\n\n  // code omitted for brevity \n};\n```", "```cpp\n#define DOUBLE_IT(arg) (arg * arg)\n```", "```cpp\nint res = DOUBLE_IT(3 + 1);\nstd::cout << res << std::endl;\n```", "```cpp\n#define DOUBLE_IT(arg) ((arg) * (arg))\n```", "```cpp\nmodule my_module;\nexport int test;\n\n// instead of\n\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\nint test\n#endif \n```", "```cpp\n// Don't return pointers or references to local variables\ndouble* create_array()\n{\n  double arr[10] = {0.0};\n  return arr;\n}\n```", "```cpp\n#include <array>\n\nstd::array<double> create_array()\n{\n  std::array<double> arr;\n  return arr;\n}\n```", "```cpp\n#include <cstdio>\n#include <cstring>\n\nint main()\n{\n  char small_buffer[4];\n  const char* long_text = \"This text is long enough to overflow small buffers!\";\n strcpy(small_buffer, long_text);\n}\n```", "```cpp\n{\n  \"email\": \"myemail@example.org\",\n  \"password\": \"notSoSIMPLEp4s8\"\n}\n```"]