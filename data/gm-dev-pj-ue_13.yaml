- en: 14\. Spawning the Player Projectile
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 生成玩家投射物
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn about `Anim Notifies` and `Anim States`, which
    can be found inside Animation Montages. You will code your own `Anim Notify` using
    C++ and implement this notify in the `Throw` Animation Montage. Lastly, you will
    learn about Visual and Audio Effects, and how these effects are used in games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习`Anim Notifies`和`Anim States`，这些可以在动画蒙太奇中找到。你将使用C++编写自己的`Anim Notify`，并在`Throw`动画蒙太奇中实现此通知。最后，你将学习视觉和音频效果，以及这些效果在游戏中的使用。
- en: By the end of this chapter, you will be able to play Animation Montages in both
    Blueprints and C++ and know how to spawn objects into the game world using C++
    and the `UWorld` class. These elements of the game will be given audio and visual
    components as an added layer of polish, and your `SuperSideScroller` player character
    will be able to throw projectiles that destroy enemies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够在蓝图和C++中播放动画蒙太奇，并知道如何使用C++和`UWorld`类将对象生成到游戏世界中。这些游戏元素将被赋予音频和视觉组件作为额外的精细层，并且你的`SuperSideScroller`玩家角色将能够投掷摧毁敌人的投射物。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you made great progress with the enemy character's
    AI by creating a behavior tree that would allow the enemy to randomly select points
    from the `BP_AIPoints` actor you created. This gives the `SuperSideScroller` game
    more life as you can now have multiple enemies moving around your game world.
    Additionally, you learned the different tools available in Unreal Engine 4 that
    are used together to make artificial intelligence of various degrees of complexity.
    These tools included the `Navigation Mesh`, behavior trees, and Blackboards.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，通过创建一个行为树，使敌人可以从你创建的`BP_AIPoints`角色中随机选择点，你在敌人角色的AI方面取得了很大的进展。这使得`SuperSideScroller`游戏更加生动，因为现在你可以在游戏世界中有多个敌人移动。此外，你还学会了虚幻引擎4中一些可用于制作各种复杂程度的人工智能的不同工具。这些工具包括`导航网格`、行为树和黑板。
- en: Now that you have enemies running around your level, you need to allow the player
    to defeat these enemies with the player projectile you started to create at the
    end of the previous chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的游戏中有敌人在四处奔跑，你需要允许玩家用上一章末开始创建的玩家投射物来击败这些敌人。
- en: In this chapter, you will learn how to use the `UAnimNotify` class to spawn
    the player projectile at a specific frame of the `Throw` Animation Montage. You
    will also learn how to add this new notify to the Montage itself, and how to add
    a new `Socket` to the main character skeleton from which the projectile will spawn.
    Lastly, you will learn how to use `Particle Systems` and `SoundCues` to add a
    layer of visual and audio polish to the game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用`UAnimNotify`类在`Throw`动画蒙太奇的特定帧生成玩家投射物。你还将学习如何将这个新的通知添加到蒙太奇本身，以及如何向主角骨骼添加一个新的`Socket`，从中投射物将生成。最后，你将学习如何使用`粒子系统`和`声音提示`为游戏添加视觉和音频层。
- en: Let's begin this chapter by learning about `Anim Notifies` and `Anim Notify
    States`. After that, you'll get your hands dirty by creating your own `UAnimNotify`
    class so that you can spawn the player projectile during the `Throw` Animation Montage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习`Anim Notifies`和`Anim Notify States`开始本章。之后，你将通过创建自己的`UAnimNotify`类来实践，以便在`Throw`动画蒙太奇期间生成玩家投射物。
- en: Anim Notifies and Anim Notify States
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Anim Notifies和Anim Notify States
- en: When it comes to creating polished and complex animations, there needs to be
    a way for animators and programmers to add custom events within the animation
    that will allow for additional effects, layers, and functionality to occur. The
    solution in Unreal Engine 4 is to use `Anim Notifies` and `Anim Notify States`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建精致和复杂的动画时，需要一种方式让动画师和程序员在动画中添加自定义事件，以允许发生额外的效果、层和功能。虚幻引擎4中的解决方案是使用`Anim Notifies`和`Anim
    Notify States`。
- en: 'The main difference between `Anim Notify` and `Anim Notify State` is that `Anim
    Notify State` possesses three distinct events that `Anim Notify` does not. These
    events are `Notify Begin`, `Notify End`, and `Notify Tick`, all of which can be
    used in Blueprints or C++. When it comes to these events, Unreal Engine 4 secures
    the following behaviors:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Anim Notify`和`Anim Notify State`之间的主要区别在于`Anim Notify State`具有三个`Anim Notify`没有的独特事件。这些事件分别是`Notify
    Begin`，`Notify End`和`Notify Tick`，所有这些事件都可以在蓝图或C++中使用。当涉及到这些事件时，虚幻引擎4确保以下行为：'
- en: '`Notify State` will always start with `Notify Begin Event`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notify State`始终以`Notify Begin Event`开始。'
- en: '`Notify State` will always finish with `Notify End Event`.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notify State`将始终以`Notify End Event`结束。'
- en: '`Notify Tick Event` will always take place between the `Notify Begin` and `Notify
    End` events.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notify Tick Event`将始终发生在`Notify Begin`和`Notify End`事件之间。'
- en: '`Anim Notify`, however, is a much more simplified version that uses just a
    single function, `Notify()`, to allow programmers to add functionality to the
    notify itself. It works with the mindset of *fire and forget*, meaning you don''t
    need to worry about what happens at the start, end, or anywhere in-between the
    `Notify()` event. It is due to this simplicity of `Anim Notify`, and due to the
    fact that we do not need the events included with `Anim Notify State` that we
    will use `Anim Notify` to spawn the player projectile for the Super Side-Scroller
    game.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Anim Notify`是一个更简化的版本，它只使用一个函数`Notify()`，允许程序员为通知本身添加功能。它的工作方式是“发射并忘记”，这意味着你不需要担心`Notify()`事件的开始、结束或中间发生了什么。正是由于`Anim
    Notify`的简单性，以及我们不需要`Anim Notify State`中包含的事件，我们将使用`Anim Notify`来为Super Side-Scroller游戏生成玩家投射物。
- en: 'Before moving on to the following exercise, where you will create your own
    custom `Anim Notify` in C++, let''s briefly discuss some examples of existing
    `Anim Notifies` that Unreal Engine 4 provides by default. A full list of default
    `Anim Notifies` states can be seen in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，你将在C++中创建自己的自定义`Anim Notify`，让我们简要讨论一些虚幻引擎4默认提供的`Anim Notifies`的示例。默认`Anim
    Notifies`状态的完整列表可以在以下截图中看到：
- en: '![Figure 14.1: The full list of default Anim Notifies provided in Unreal Engine
    4'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1：Unreal Engine 4中提供的默认Anim通知的完整列表'
- en: '](img/B16183_14_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_01.jpg)'
- en: 'Figure 14.1: The full list of default Anim Notifies provided in Unreal Engine
    4'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：Unreal Engine 4中提供的默认Anim通知的完整列表
- en: 'There are two `Anim Notifies` that you will be using later on in this chapter:
    `Play Particle Effect` and `Play Sound`. Let''s discuss these two in more detail
    so that you are familiar with them by the time you use them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，您将使用两个`Anim通知`：`播放粒子效果`和`播放声音`。让我们更详细地讨论这两个，以便在使用它们时您对它们更加熟悉：
- en: '`Play Particle Effect`: The `Play Particle Effect` notify, as the name suggests,
    allows you to spawn and play a particle system at a certain frame of your animation.
    As shown in the following screenshot, you have options to change the VFX being
    used, such as updating the `location`, `rotation`, and `scale` settings of the
    particle. You can even attach the particle to a specified `Socket Name` if you
    so choose:![Figure 14.2: The Details panel of the Play Particle Effect notify,
    which'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`播放粒子效果`：`播放粒子效果`通知允许您在动画的某一帧生成和播放粒子系统，正如其名称所示。如下面的屏幕截图所示，您可以更改正在使用的VFX，例如更新粒子的`位置`、`旋转`和`缩放`设置。您甚至可以将粒子附加到指定的`Socket名称`，如果您愿意的话：![图14.2：播放粒子效果通知的详细面板，其中'
- en: allows you to customize the particle
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您自定义粒子
- en: '](img/B16183_14_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_02.jpg)'
- en: 'Figure 14.2: The Details panel of the Play Particle Effect notify, which allows
    you to customize the particle'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：播放粒子效果通知的详细面板，允许您自定义粒子
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual Effects, or VFX for short, are crucial elements for any game. Visual
    Effects, in Unreal Engine 4, are created using a tool called *Cascade*, inside
    the editor. Since Unreal Engine version 4.20, a new tool called *Niagara* has
    been introduced as a free plugin to improve the quality and pipeline for how VFX
    are made. You can learn more about *Niagara* here: [https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉效果，简称VFX，对于任何游戏来说都是至关重要的元素。在Unreal Engine 4中，使用一个名为*Cascade*的工具在编辑器内创建视觉效果。自Unreal
    Engine版本4.20以来，引入了一个名为*Niagara*的新工具作为免费插件，以改进VFX的质量和流程。您可以在这里了解更多关于*Niagara*的信息：[https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html)。
- en: A very common example used in games is to use this type of notify to spawn dirt
    or other effects underneath the player's feet while they walk or run. Having the
    ability to specify at which frame of the animation these effects spawn is very
    powerful and allows you to create convincing effects for your character.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中常见的一个例子是使用这种类型的通知在玩家行走或奔跑时在玩家脚下生成泥土或其他效果。能够指定在动画的哪一帧生成这些效果非常强大，可以让您为角色创建令人信服的效果。
- en: '`Play Sound`: The `Play Sound` notify allows you to play a `Soundcue` or `Soundwave`
    at a certain frame of your animation. As shown in the following screenshot, you
    have options to change the sound being used, update its `volume` and `pitch` values,
    and even have the sound follow the owner of the sound via attaching it to a specified
    `Socket Name`:![Figure 14.3: The Details panel of the Play Sound notify, which'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`播放声音`：`播放声音`通知允许您在动画的某一帧播放`Soundcue`或`Soundwave`。如下面的屏幕截图所示，您可以更改正在使用的声音，更新其`音量`和`音调`值，甚至通过将其附加到指定的`Socket名称`使声音跟随声音的所有者：![图14.3：播放声音通知的详细面板，其中'
- en: '](img/B16183_14_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_03.jpg)'
- en: 'Figure 14.3: The Details panel of the Play Sound notify, which allows you to
    customize the sound'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：播放声音通知的详细面板，允许您自定义声音
- en: Much like the example given for the `Play Particle Effect` notify, the `Play
    Sound` notify can also be commonly used to play the sounds of footsteps while
    the character is moving. By having control of exactly where on the animation timeline
    you can play a sound, it is possible to create believable sound effects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与`播放粒子效果`通知所示的例子类似，`播放声音`通知也可以常用于在角色移动时播放脚步声。通过精确控制在动画时间轴的哪个位置播放声音，可以创建逼真的声音效果。
- en: 'Although you will not be using `Anim Notify States`, it is still important
    to at least know the options that are available to you by default, as shown in
    the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您将不会使用`Anim通知状态`，但至少了解默认情况下可用的选项仍然很重要，如下面的屏幕截图所示：
- en: '![Figure 14.4: The full list of default Anim Notify States provided to you
    in Unreal Engine 4'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4：Unreal Engine 4中提供给您的默认Anim通知状态的完整列表'
- en: '](img/B16183_14_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_04.jpg)'
- en: 'Figure 14.4: The full list of default Anim Notify States provided to you in
    Unreal Engine 4'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：Unreal Engine 4中提供给您的默认Anim通知状态的完整列表
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The two `Notify` states that are not available in animation sequences are the
    *Montage Notify Window* and *Disable Root Motion* states, as shown in the preceding
    screenshot. For more information regarding notifies, refer to the following documentation:
    [docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.html](http://docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.html).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画序列中不可用的两个“通知”状态是*Montage通知窗口*和*禁用根动作*状态，如前面的屏幕截图所示。有关通知的更多信息，请参阅以下文档：[docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.html](http://docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.html)。
- en: Now that you are more familiar with `Anim Notify` and `Anim Notify State`, let's
    move on to the next exercise, where you will create your own custom `Anim Notify`
    in C++ that you will use to spawn the player projectile.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对`Anim通知`和`Anim通知状态`更加熟悉，让我们继续进行下一个练习，您将在C++中创建自定义的`Anim通知`，用于生成玩家的投射物。
- en: 'Exercise 14.01: Creating a UAnim Notify Class'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.01：创建一个UAnim通知类
- en: The main offensive ability that the player character will have in the `SuperSideScroller`
    game is the projectile that the player can throw at enemies. In the previous chapter,
    you set up the framework and base functionality of the projectile, but right now,
    there is no way for the player to use it. In order to make spawning, or throwing,
    the projectile convincing to the eye, you need to create a custom `Anim Notify`
    that you will then add to the `Throw` Animation Montage. This `Anim Notify` will
    let the player know it's time to spawn the projectile.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色在`SuperSideScroller`游戏中的主要进攻能力是玩家可以向敌人投掷的投射物。在上一章中，您设置了投射物的框架和基本功能，但现在，玩家无法使用它。为了使生成或投掷投射物对眼睛有说服力，您需要创建一个自定义的`Anim
    Notify`，然后将其添加到`Throw`动画蒙太奇中。这个`Anim Notify`将让玩家知道是时候生成投射物了。
- en: 'Do the following to create the new `UAnimNotify` class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作创建新的`UAnimNotify`类：
- en: Inside Unreal Engine 4, navigate to the `File` option and *left-click* to select
    the option for `New C++ Class`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，导航到`文件`选项，*左键单击*选择`新的C++类`选项。
- en: From the `Choose Parent Class` dialogue window, search for `AnimNotify` and
    *left-click* the `AnimNotify` option. Then, *left-click* the `Next` option to
    name the new class.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“选择父类”对话框窗口中，搜索“AnimNotify”并*左键单击*“AnimNotify”选项。然后，*左键单击*“下一步”选项来命名新类。
- en: Name this new class `Anim_ProjectileNotify`. Once named, *left-click* to select
    the `Create Class` option so that Unreal Engine 4 recompiles and hot-reloads the
    new class in Visual Studio.bOnce Visual Studio opens, you will have both the header
    file, `Anim_ProjectileNotify.h`, and the source file, `Anim_ProjectileNotify.cpp`,
    available to you.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此新类命名为`Anim_ProjectileNotify`。命名后，*左键单击*选择`创建类`选项，以便虚幻引擎4重新编译并在Visual Studio中热重载新类。一旦Visual
    Studio打开，您将可以使用头文件`Anim_ProjectileNotify.h`和源文件`Anim_ProjectileNotify.cpp`。
- en: 'The `UAnimNotify` base class has one function that needs to be implemented
    inside your class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UAnimNotify`基类有一个函数需要在您的类中实现：'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function is called automatically when the notify is hit on the timeline
    it is being used in. By overriding this function, you will be able to add your
    own logic to the notify. This function also gives you access to both the `Skeletal
    Mesh` component of the owning notify and the Animation Sequence currently being played.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当时间轴上的通知被击中时，此函数将自动调用。通过覆盖此函数，您将能够向通知添加自己的逻辑。此函数还使您能够访问拥有通知的`骨骼网格`组件以及当前正在播放的动画序列。
- en: 'Next, let''s add the override declaration of this function to the header file.
    In the header file `Anim_ProjectileNotify.h`, add the following code underneath
    the `GENERATED_BODY()`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在头文件中添加此函数的覆盖声明。在头文件`Anim_ProjectileNotify.h`中，在`GENERATED_BODY()`下面添加以下代码：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you added the function to the header file, it is time to define the
    function inside the `Anim_ProjectileNotify` source file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将函数添加到头文件中，是时候在`Anim_ProjectileNotify`源文件中定义该函数了。
- en: 'Inside the `Anim_ProjectileNotify.cpp` source file, define the function and
    add a `UE_LOG()` call that prints the text `"Throw Notify"`, as shown in the following
    code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Anim_ProjectileNotify.cpp`源文件中，定义该函数并添加一个`UE_LOG()`调用，打印文本“Throw Notify”，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For now, you will just use this `UE_LOG()` debugging tool to know that this
    function is correctly being called when you add this notify to the `Throw` Animation
    Montage in the next exercise.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您将仅使用此`UE_LOG()`调试工具，以便知道在下一个练习中将此通知添加到`Throw`动画蒙太奇时，该函数是否被正确调用。
- en: 'In this exercise, you created the groundwork necessary to implement your own
    `AnimNotify` class by adding the following function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您通过添加以下函数创建了实现自己的`AnimNotify`类所需的基础工作：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside this function, you are using `UE_LOG()` to print the custom text `"Throw
    Notify"` in the output log so that you know that this notify is working correctly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，您使用`UE_LOG()`在输出日志中打印自定义文本“Throw Notify”，以便您知道此通知是否正常工作。
- en: Later in this chapter, you will update this function so that it calls logic
    that will spawn the player projectile, but first, let's add the new notify to
    the `Throw` Animation montage.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，您将更新此函数，以便调用将生成玩家投射物的逻辑，但首先，让我们将新通知添加到`Throw`动画蒙太奇中。
- en: 'Exercise 14.02: Adding the Notify to the Throw Montage'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.02：将通知添加到投掷蒙太奇
- en: Now that you have your `Anim_ProjectileNotify` notify, it is time to add this
    notify to the `Throw` Animation Montage so that it can actually be of use to you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了`Anim_ProjectileNotify`通知，是时候将此通知添加到`Throw`动画蒙太奇中，以便实际为您所用。
- en: In this exercise, you will add `Anim_ProjectileNotify` to the timeline of the
    `Throw` Montage at the exact frame of the animation that you'd expect the projectile
    to spawn.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您将在`Throw`蒙太奇的时间轴上的确切帧上添加`Anim_ProjectileNotify`，以便您期望投射物生成。
- en: 'Complete the following steps to achieve this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤以实现此目标：
- en: Back inside Unreal Engine, navigate to the `Content Browser` interface and go
    to the `/MainCharacter/Animation/` directory. Inside this directory, *double-click*
    the `AM_Throw` asset to open the `Animation Montage` editor.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到虚幻引擎，在`内容浏览器`界面中，转到`/MainCharacter/Animation/`目录。在此目录中，*双击*`AM_Throw`资产以打开`动画蒙太奇`编辑器。
- en: At the very bottom of the `Animation Montage` editor, you will find the timeline
    for the animation. By default, you will observe that the *red colored bar* will
    be moving along the timeline as the animation plays.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`动画蒙太奇`编辑器的底部，您将找到动画的时间轴。默认情况下，您会观察到*红色的条*会随着动画的播放而沿着时间轴移动。
- en: '*Left-click* this `red` bar and manually move it to the 22nd `frame`, as close
    as you can, as shown in the following screenshot:![Figure 14.5: The red colored
    bar allows you to manually position'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*这个`红色`条，并手动将其移动到第22个`帧`，尽可能靠近，如下面的截图所示：![图14.5：红色条允许您手动定位'
- en: notifies anywhere on the timeline
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间轴的任何位置发出通知
- en: '](img/B16183_14_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_05.jpg)'
- en: 'Figure 14.5: The red colored bar allows you to manually position notifies anywhere
    on the timeline'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：红色条允许您在时间轴上手动定位通知
- en: 'The 22nd frame of the `Throw` animation is the exact moment in the throw that
    you would expect a projectile to spawn and be thrown by the player. The following
    screenshot shows the frame of the throw animation, as seen inside the editor within
    `Persona`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throw`动画的第22帧是您期望玩家生成并投掷抛射物的确切时刻。以下截图显示了抛掷动画的帧，如在`Persona`编辑器中所见：'
- en: '![Figure 14.6: The exact moment the player projectile should spawn'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.6：玩家抛射物应该生成的确切时刻'
- en: '](img/B16183_14_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_06.jpg)'
- en: 'Figure 14.6: The exact moment the player projectile should spawn'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：玩家抛射物应该生成的确切时刻
- en: Now that you know the position on the timeline that the notify should be played,
    you can now *right-click* on the thin `red` line within the `Notifies` timeline.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经知道通知应该播放的时间轴位置，您现在可以在`Notifies`时间轴上*右键单击*细长的`红色`线。
- en: This will show you a popup where you can add a `Notify` or a `Notify State`.
    In some cases, the `Notifies` timeline may be collapsed and hard to find; simply
    left-click on the word `Notifies` to toggle between collapsed and expanded.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个弹出窗口，您可以在其中添加`Notify`或`Notify State`。在某些情况下，`Notifies`时间轴可能会被折叠并且难以找到；只需左键单击`Notifies`一词，即可在折叠和展开之间切换。
- en: Select `Add Notify` and, from the options provided, find and select `Anim Projectile
    Notify`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Add Notify`，然后从提供的选项中找到并选择`Anim Projectile Notify`。
- en: 'After selecting to add `Anim Projectile Notify` to the Notifies timeline, you
    will see the following:![Figure 14.7: Anim_ProjectileNotify successfully added
    to the Throw Animation Montage'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`Anim Projectile Notify`添加到通知时间轴后，您将看到以下内容：![图14.7：Anim_ProjectileNotify成功添加到Throw动画蒙太奇
- en: '](img/B16183_14_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_07.jpg)'
- en: 'Figure 14.7: Anim_ProjectileNotify successfully added to the Throw Animation
    Montage'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：Anim_ProjectileNotify成功添加到Throw动画蒙太奇
- en: With the `Anim_ProjectileNotify` notify in place on the `Throw` Animation Montage
    timeline, save the montage.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Throw`动画蒙太奇时间轴上放置`Anim_ProjectileNotify`通知后，保存蒙太奇。
- en: If the `Output Log` window is not visible, please re-enable the window by navigating
    to the `Window` option and hover over it for `Developer Tools`. Find the option
    for `Output Log` and *left-click* to enable it.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Output Log`窗口不可见，请通过导航到`Window`选项并悬停在`Developer Tools`上来重新启用窗口。找到`Output
    Log`选项，*左键单击*以启用它。
- en: Now, use `PIE`, and, once in-game, use the *left mouse button* to start playing
    the `Throw` montage.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`PIE`，一旦进入游戏，使用*左鼠标按钮*开始播放`Throw`蒙太奇。
- en: At the point in the animation where you added the notify, you will now see the
    debugging log text `Throw Notify` appear in the output log.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在您添加通知的动画位置，您现在将在输出日志中看到调试日志文本`Throw Notify`出现。
- en: As you may recall from *Chapter 12*, *Animation Blending and Montages*, you
    added the `Play Montage` function to the player character blueprint, `BP_SuperSideScroller_MainCharacter`.
    For the sake of learning C++ in the context of Unreal Engine 4, you will be moving
    this logic from Blueprint to C++ in the upcoming exercises. This is so that we
    don't rely too heavily on Blueprint scripts for the base behavior of the player
    character.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的*第12章*，*动画混合和蒙太奇*中，您已将`Play Montage`函数添加到了玩家角色蓝图`BP_SuperSideScroller_MainCharacter`。为了在Unreal
    Engine 4的上下文中学习C++，您将在即将进行的练习中将此逻辑从蓝图移至C++。这样我们就不会过分依赖蓝图脚本来实现玩家角色的基本行为。
- en: With this exercise complete, you have successfully added your custom `Anim Notify`
    class, `Anim_ProjectileNotify`, to the `Throw` Animation Montage. This notify
    was added at the precise frame in which you expect a projectile to be thrown from
    the player's hand. Since you added the Blueprint logic to the player character
    in *Chapter 12*, *Animation Blending and Montages*, you are able to play this
    `Throw` Animation Montage when the `InputAction` event, `ThrowProjectile`, is
    called when using the *left mouse button*. Before making the transition from playing
    the Throw Animation Montage in Blueprints to playing the Montage from C++, let's
    discuss playing Animation Montages some more.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您已成功将自定义的`Anim Notify`类`Anim_ProjectileNotify`添加到`Throw`动画蒙太奇中。此通知已添加到您期望从玩家手中投掷抛射物的确切帧。由于您在*第12章*，*动画混合和蒙太奇*中为玩家角色添加了蓝图逻辑，因此当使用*左鼠标按钮*调用`InputAction`事件`ThrowProjectile`时，您可以播放此`Throw`动画蒙太奇。在从蓝图中播放Throw动画蒙太奇转换为从C++中播放蒙太奇之前，让我们再讨论一下播放动画蒙太奇。
- en: Playing Animation Montages
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放动画蒙太奇
- en: As you learned in *Chapter 12*, *Animation Blending and Montages*, these items
    are useful for allowing animators to combine individual animation sequences into
    one complete montage. By splitting the Montage into its own unique sections and
    adding notifies for particles and sound, animators and animation programmers can
    make complex sets of montages that handle all the different aspects of the animation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*第12章*，*动画混合和蒙太奇*中所学到的，这些项目对于允许动画师将单独的动画序列组合成一个完整的蒙太奇非常有用。通过将蒙太奇分割为自己独特的部分并为粒子和声音添加通知，动画师和动画程序员可以制作处理动画的所有不同方面的复杂蒙太奇集。
- en: But once the Animation Montage is ready, how do we play this Montage on a character?
    You are already familiar with the first method, which is via Blueprints.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一旦动画蒙太奇准备就绪，我们如何在角色上播放这个蒙太奇？您已经熟悉第一种方法，即通过蓝图。
- en: Playing Animation Montages in Blueprints
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在蓝图中播放动画蒙太奇
- en: 'In Blueprints, the `Play Montage` function is available for you to use, as
    shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中，`Play Montage`函数可供您使用，如下截图所示：
- en: '![Figure 14.8: The Play Montage function in Blueprints'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.8：蓝图中的播放蒙太奇功能'
- en: '](img/B16183_14_08.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_08.jpg)'
- en: 'Figure 14.8: The Play Montage function in Blueprints'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：蓝图中的播放蒙太奇功能
- en: You have already used the function to play the `AM_Throw` Animation Montage.
    This function requires the `Skeletal Mesh` component that the Montage must be
    played on, and it requires the Animation Montage to play.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用了播放“AM_Throw”动画Montage的函数。此函数需要Montage必须在其上播放的“骨骼网格”组件，并且需要播放的动画Montage。
- en: 'The remaining parameters are optional, depending on how your Montage will work.
    Let''s have a quick look at these parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的参数是可选的，具体取决于Montage的工作方式。让我们快速看看这些参数：
- en: '`Play Rate`: The `Play Rate` parameter allows you to increase or decrease the
    playback speed of the Animation Montage. For faster playback, you would increase
    this value; otherwise, you would decrease the value for slower playback speed.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “播放速率”： “播放速率”参数允许您增加或减少动画Montage的播放速度。要加快播放速度，您将增加此值；否则，您将减少值以减慢播放速度。
- en: '`Starting Position`: The `Starting Position` parameter allows you to set the
    starting position, in seconds, along the Montage timeline from which the Montage
    will start playing. For example, in an Animation Montage that has a 3-second timeline,
    you could choose to have the Montage start at the `1.0f` position instead of at
    `0.0f`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “起始位置”： “起始位置”参数允许您设置Montage时间轴上的起始位置（以秒为单位），从该位置开始播放Montage。例如，在一个持续3秒的动画Montage中，您可以选择让Montage从“1.0f”位置开始，而不是从“0.0f”开始。
- en: '`Starting Section`: The `Starting Section` parameter allows you to tell the
    Animation Montage to start at a specific section. Depending on how your Montage
    is set up, you could have multiple sections created for different parts of the
    montage. For example, a shotgun weapon reloading Animation Montage would include
    a section for the initial movement for reload, a looped section for the actual
    bullet reload, and a final section for re-equipping the weapon so that it is ready
    to fire again.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “起始部分”： “起始部分”参数允许您告诉动画Montage从特定部分开始。根据Montage的设置方式，您可以为Montage的不同部分创建多个部分。例如，霰弹枪武器重新装填动画Montage将包括一个用于重新装填的初始移动部分，一个用于实际子弹重新装填的循环部分，以及一个用于重新装备武器的最终部分，以便它准备好再次开火。
- en: 'When it comes to the outputs of the `Play Montage` function, you have a few
    different options:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到“Play Montage”函数的输出时，您有几种不同的选择：
- en: '`On Completed`: The `On Completed` output is called when the Animation Montage
    has finished playing and has been fully blended out.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “完成时”： “完成时”输出在动画Montage完成播放并完全混合结束时调用。
- en: '`On Blend Out`: The `On Blend Out` output is called when the Animation Montage
    begins to blend out. This can occur during `Blend Out Trigger Time`, or if the
    Montage ends prematurely.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “混合结束时”： “混合结束时”输出在动画Montage开始混合结束时调用。这可能发生在“混合触发时间”期间，或者如果Montage过早结束。
- en: '`On Interrupted`: The `On Interrupted` output is called when the Montage begins
    to blend out due to this Montage being interrupted by another Montage that is
    trying to play on the same skeleton.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “中断时”： “中断时”输出在由于另一个试图在相同骨架上播放的Montage中断此Montage而开始混合结束时调用。
- en: '`On Notify Begin & On Notify End`: Both the `On Notify Begin` and `On Notify
    End` outputs are called if you are using the `Montage Notify` option under the
    `Notifies` category in the Animation Montage. The name given to the `Montage`
    `Notify` is returned via the `Notify Name` parameter.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通知开始”和“通知结束”：如果您正在使用动画Montage中“通知”类别下的“Montage通知”选项，则“通知开始”和“通知结束”输出都会被调用。通过“通知名称”参数返回给Montage通知的名称。
- en: Playing Animation Montages in C++
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++中播放动画Montage
- en: On the C++ side, there is only one thing you need to know about, and that is
    the `UAnimInstance::Montage_Play()` function. This function requires the Animation
    Montage to play, the play rate in which to play back the montage, a value of the
    `EMontagePlayReturnType` type, a `float` value for determining the start position
    to play the montage, and a `Boolean` value for determining whether playing this
    Montage should stop or interrupt all montages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++方面，您只需要了解一个事情，那就是“UAnimInstance::Montage_Play()”函数。此函数需要要播放的动画Montage，以及播放Montage的播放速率，EMontagePlayReturnType类型的值，用于确定播放Montage的起始位置的float值，以及用于确定是否停止或中断所有Montage的布尔值。
- en: 'Although you will not be changing the default parameter of `EMontagePlayReturnType`,
    which is `EMontagePlayReturnType::MontageLength`, it is still important to know
    the two values that exist for this enumerator:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您不会更改“EMontagePlayReturnType”的默认参数，即“EMontagePlayReturnType::MontageLength”，但仍然重要知道此枚举器存在的两个值：
- en: '`Montage Length`: The `Montage Length` value returns the length of the Montage
    itself, in seconds.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Montage长度”： “Montage长度”值返回Montage本身的长度，以秒为单位。
- en: '`Duration`: The `Duration` value returns the play duration of the montage,
    which is equal to the length of the montage, divided by the play rate.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “持续时间”： “持续时间”值返回Montage的播放持续时间，等于Montage的长度除以播放速率。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details regarding the `UAnimMontage` class, please refer to the following
    documentation: https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.html.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有关“UAnimMontage”类的更多详细信息，请参阅以下文档：https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.html。
- en: You will learn more about the C++ implementation of playing an Animation Montage
    in the next exercise.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下一个练习中了解有关播放动画Montage的C++实现的更多信息。
- en: 'Exercise 14.03: Playing the Throw Animation in C++'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.03：在C++中播放投掷动画
- en: Now that you have a better understanding of play Animation Montages in Unreal
    Engine 4, both via Blueprints and C++, it is time to migrate the logic for playing
    the `Throw` Animation Montage from Blueprints to C++. The reason behind this change
    is because the Blueprint logic was put into place as a placeholder method so that
    you could preview the `Throw` montage. This book is a more heavily focused C++
    guide to game development, and as such, it is important to learn how to implement
    this logic in code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对在虚幻引擎4中通过蓝图和C++播放动画蒙太奇有了更好的理解，是时候将播放“投掷”动画蒙太奇的逻辑从蓝图迁移到C++了。这个改变的原因是因为蓝图逻辑是作为一个占位方法放置的，这样你就可以预览“投掷”蒙太奇。这本书更加专注于C++游戏开发，因此，学习如何在代码中实现这个逻辑是很重要的。
- en: Let's begin by removing the logic from Blueprints, and then move on to recreating
    the logic in C++ inside the player character class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从蓝图中移除逻辑，然后继续在玩家角色类中用C++重新创建这个逻辑。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Navigate to the player character Blueprint, `BP_SuperSideScroller_MainCharacter`,
    which can be found in the following directory: `/MainCharacter/Blueprints/`. *Double-click*
    this asset to open it.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到玩家角色蓝图，`BP_SuperSideScroller_MainCharacter`，可以在以下目录中找到：`/MainCharacter/Blueprints/`。*双击*这个资源来打开它。
- en: 'Inside this Blueprint, you will find the `InputAction ThrowProjectile` event
    and the `Play Montage` function that you created to preview the `Throw` Animation
    Montage, as shown in the following screenshot. Delete this logic and then recompile
    and save the player character Blueprint:![Figure 14.9: You no longer need this
    placeholder logic inside the player character Blueprint'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个蓝图中，你会找到`InputAction ThrowProjectile`事件和你创建的`Play Montage`函数，用于预览`Throw`动画蒙太奇，如下截图所示。删除这个逻辑，然后重新编译并保存玩家角色蓝图：![图14.9：你不再需要在玩家角色蓝图中使用这个占位逻辑
- en: '](img/B16183_14_09.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_09.jpg)'
- en: 'Figure 14.9: You no longer need this placeholder logic inside the player character
    Blueprint'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：你不再需要在玩家角色蓝图中使用这个占位逻辑
- en: Now, use `PIE` and attempt to throw with the player character by using the *left
    mouse button*. You will observe that the player character no longer plays the
    `Throw` Animation Montage. Let's fix this by adding the required logic in C++.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`PIE`并尝试用*左鼠标按钮*让玩家角色投掷。你会发现玩家角色不再播放`Throw`动画蒙太奇。让我们通过在C++中添加所需的逻辑来修复这个问题。
- en: Open up the header file for the player character in Visual Studio, `SuperSideScroller_Player.h`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开玩家角色的头文件，`SuperSideScroller_Player.h`。
- en: 'The first thing you need to do is create a new variable for the player character
    that will be used for the `Throw` animation. Add the following code under the
    `Private` access modifier:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建一个新的变量，用于玩家角色的`Throw`动画。在`Private`访问修饰符下添加以下代码：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you have a variable that will represent the `Throw` Animation Montage,
    it is time to add the logic for playing the Montage inside the `SuperSideScroller_Player.cpp`
    file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个变量，它将代表“投掷”动画蒙太奇，是时候在`SuperSideScroller_Player.cpp`文件中添加播放蒙太奇的逻辑了。
- en: 'Before you can make the call to `UAnimInstance::Montage_Play()`, you need to
    add the following `include` directory to the existing list at the top of the source
    file in order to have access to this function:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你调用`UAnimInstance::Montage_Play()`之前，你需要在源文件顶部的现有列表中添加以下`include`目录，以便访问这个函数：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we know from *Chapter 9*, *Audio-Visual Elements*, the player character
    already has a function called `ThrowProjectile` that is called whenever the *left
    mouse button* is pressed. As a reminder, this is where the binding occurs in C++:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从*第9章*，*音频-视觉元素*中知道的，玩家角色已经有一个名为`ThrowProjectile`的函数，每当按下*左鼠标按钮*时就会调用。作为提醒，在C++中绑定发生在这里：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update `ThrowProjectile` so that it plays `ThrowMontage`, which you set up
    earlier in this exercise. Add the following code to the `ThrowProjectile()` function.
    Then, we can discuss what is happening here:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ThrowProjectile`，使其播放你在这个练习中设置的`ThrowMontage`。将以下代码添加到`ThrowProjectile()`函数中。然后，我们可以讨论这里发生了什么：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line is checking if the `ThrowMontage` is valid; if we don't have
    a valid Animation Montage assigned, there is no point in continuing the logic,
    and also it can be dangerous to use a NULL object in further function calls as
    it could result in a crash. Next, we are declaring a new Boolean variable, called
    `bIsMontagePlaying`, that determines whether `ThrowMontage` is already playing
    on the player character's skeletal mesh. This check is made because the `Throw`
    Animation Montage should not be played while it is already playing; this will
    cause the animation to break if the player repeatedly presses the *left mouse button*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是检查`ThrowMontage`是否有效；如果我们没有分配有效的动画蒙太奇，继续逻辑就没有意义，而且在后续函数调用中使用NULL对象可能会导致崩溃，这也是很危险的。接下来，我们声明一个新的布尔变量，称为`bIsMontagePlaying`，用于确定`ThrowMontage`是否已经在玩家角色的骨骼网格上播放。这个检查是因为`Throw`动画蒙太奇在已经播放时不应该再次播放；如果玩家反复按下*左鼠标按钮*，这将导致动画中断。
- en: Next, there is an `If` statement that checks that `ThrowMontage` is valid and
    that the Montage is not playing. As long as these conditions are met, it is safe
    to move on and play the Animation Montage.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个`If`语句，检查`ThrowMontage`是否有效，以及蒙太奇是否正在播放。只要满足这些条件，就可以安全地继续播放动画蒙太奇。
- en: Inside the `If` statement, you are telling the player's skeletal mesh to play
    the `ThrowMontage` Animation Montage with a play rate of `1.0f`. The `1.0f` value
    is used so that the Animation Montage plays back at the speed it is intended to.
    Values larger than `1.0f` will make the Montage play back faster, while values
    lower than `1.0f` will make the Montage play back slower. The other parameters
    that you learned about, such as the start position or the `EMontagePlayReturnType`
    parameter, can be left at their `defaults.Head`. Back inside the Unreal Engine
    4 editor, perform a recompile of the code, as you have done in the past.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`If`语句内部，您正在告诉玩家的骨骼网格以`1.0f`的播放速率播放“ThrowMontage”动画蒙太奇。使用`1.0f`值是为了使动画蒙太奇以预期速度播放。大于`1.0f`的值将使蒙太奇以更快的速度播放，而小于`1.0f`的值将使蒙太奇以更慢的速度播放。您学到的其他参数，如起始位置或`EMontagePlayReturnType`参数，可以保持其默认值。回到虚幻引擎4编辑器内，进行代码重新编译，就像您以前做过的那样。
- en: 'After the code recompiles successfully, navigate back to the player character
    blueprint, `BP_SuperSideScroller_MainCharacter`, which can be found in the following
    directory: `/MainCharacter/Blueprints/`. *Double-click* this asset to open it.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码成功重新编译后，导航回玩家角色蓝图“BP_SuperSideScroller_MainCharacter”，该蓝图可以在以下目录中找到：`/MainCharacter/Blueprints/`。*双击*此资源以打开它。
- en: In the `Details` panel of the player character, you will now see the `Throw
    Montage` parameter that you added.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家角色的“详细信息”面板中，您现在将看到您添加的“投掷动画”参数。
- en: '*Left-click* on the drop-down menu for the `Throw Montage` parameter to find
    the `AM_Throw` montage. *Left-click* again on the `AM_Throw` option to select
    it for this parameter. Please refer to the following screenshot to see how the
    variable should be set up:![Figure 14.10: Now, the Throw Montage is assigned the
    AM_Throw montage'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*“投掷动画”参数的下拉菜单，找到“AM_Throw”动画。再次*左键单击*“AM_Throw”选项以选择它作为此参数。请参考以下截图，查看变量应如何设置：![图14.10：现在，投掷动画被分配为AM_Throw动画'
- en: '](img/B16183_14_10.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_10.jpg)'
- en: 'Figure 14.10: Now, the Throw Montage is assigned the AM_Throw montage'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：现在，投掷动画被分配为AM_Throw动画
- en: 'Recompile and save the player character blueprint. Then, use `PIE` to spawn
    the player character and use the *left mouse button* to play `Throw Montage`.
    The following screenshot shows this in action:![Figure 14.11: The player character
    is now able to perform the Throw animation again'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译并保存玩家角色蓝图。然后，使用`PIE`生成玩家角色，并使用*鼠标左键*播放“投掷动画”。以下截图显示了这一过程：![图14.11：玩家角色现在能够再次执行投掷动画
- en: '](img/B16183_14_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_11.jpg)'
- en: 'Figure 14.11: The player character is now able to perform the Throw animation
    again'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：玩家角色现在能够再次执行投掷动画
- en: By completing this exercise, you have learned how to add an `Animation Montage`
    parameter to the player character, as well as how to play the Montage in C++.
    In addition to playing `Throw` Animation Montage in C++, you also added the ability
    to control how often the `Throw` animation can be played by adding the check for
    whether the Montage is already playing. By doing this, you prevent the player
    from spamming the `Throw` input and causing the animation to break or not play
    entirely.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经学会了如何向玩家角色添加“动画蒙太奇”参数，以及如何在C++中播放蒙太奇。除了在C++中播放“投掷”动画蒙太奇之外，您还通过添加检查蒙太奇是否已经在播放来控制“投掷”动画可以播放的频率。通过这样做，您可以防止玩家不断按下“投掷”输入，导致动画中断或完全不播放。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Try setting the play rate of `Animation Montage` from `1.0f` to `2.0f` and recompile
    the code. Observe how increasing the play rate of the animation affects how the
    animation looks and feels for the player.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将“动画蒙太奇”的播放速率从`1.0f`设置为`2.0f`，然后重新编译代码。观察增加动画播放速率如何影响玩家对动画的外观和感觉。
- en: Game World and Spawning Objects
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏世界和生成对象
- en: When it comes to spawning objects into the game world, it is actually the `World`
    object that represents your level that handles the creation of said objects. You
    can think of the `UWorld` class object as the single, top-level object that represents
    your level.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及将对象生成到游戏世界中时，实际上是代表您的关卡的“World”对象处理了这些对象的创建。您可以将“UWorld”类对象视为代表您的关卡的单个顶层对象。
- en: The `UWorld` class can do many things, such as spawning and removing objects
    from the world, detect when levels are being changed or streamed in/out, and even
    perform line traces to assist with inter-object detection. For the sake of this
    chapter, we'll focus on spawning objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`UWorld`类可以做很多事情，比如从世界中生成和移除对象，检测何时正在更改或流入/流出级别，甚至执行线性跟踪以帮助进行对象检测。在本章中，我们将专注于生成对象。'
- en: 'The `UWorld` class has multiple variations of the `SpawnActor()` function,
    depending on how you want to spawn the object, or by which parameters you have
    access to in the context in which you are spawning this object. The three consistent
    parameters to take into consideration are the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`UWorld`类有多种`SpawnActor()`函数的变体，取决于您希望如何生成对象，或者您在生成此对象的上下文中可以访问哪些参数。要考虑的三个一致参数是：'
- en: '`UClass`: The `UClass` parameter is simply the class of the object that you
    want to spawn in.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UClass`：`UClass`参数只是您想要生成的对象的类。'
- en: '`FActorSpawnParameters`: This is a struct of variables that give the spawned
    object more context and references to what has spawned it. For a list of all of
    the variables included within this struct, please refer to this article from the
    Unreal Engine 4 Community Wiki: https://www.ue4community.wiki/Actor#Spawn'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FActorSpawnParameters`：这是一个包含变量的结构，为生成的对象提供更多上下文和引用。有关此结构中包含的所有变量的列表，请参考虚幻引擎4社区维基上的这篇文章：https://www.ue4community.wiki/Actor#Spawn'
- en: 'Let''s briefly discuss one of the more crucial variables included in `FActorSpawnParameters`:
    the `Owner` actor. `Owner` is the actor that has spawned this object, and in the
    case of the player character and the projectile, it will be important for you
    to explicitly reference the player as the owner of the projectile. The reason
    behind this, especially in the context of this game, is that you don''t want the
    projectile to collide with its `Owner`; you want this projectile to ignore the
    owner entirely so that it can only collide with enemies or the level environment.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论`FActorSpawnParameters`中包含的一个更关键的变量：`Owner` actor。`Owner`是生成此对象的actor，在玩家角色和投射物的情况下，您需要明确引用玩家作为投射物的所有者。尤其是在这个游戏的背景下，这是很重要的，因为您不希望投射物与其`Owner`发生碰撞；您希望这个投射物完全忽略所有者，只与敌人或关卡环境发生碰撞。
- en: '`Transform`: When spawning an object into the world, the world needs to know
    the `location`, `rotation`, and `scale` properties of this actor before it can
    spawn it. In some templates of the `SpawnActor()` function, it requires a full
    `Transform` to be passed, while in other templates, `Location` and `Rotation`
    need to be passed in individually.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform`：当将对象生成到世界中时，世界需要知道此actor的`位置`、`旋转`和`缩放`属性，然后才能生成它。在`SpawnActor()`函数的某些模板中，需要传递完整的`Transform`，而在其他模板中，需要单独传递`Location`和`Rotation`。'
- en: Before moving on to spawning the player projectile, let's set up the `Socket`
    location in the player character's `Skeleton` so that the projectile can spawn
    from the *players' hand* during the `Throw` animation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续生成玩家投射物之前，让我们设置玩家角色“骨架”中的“Socket”位置，以便在“投掷”动画期间可以从*玩家手*生成投射物。
- en: 'Exercise 14.04: Creating the Projectile Spawn Socket'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.04：创建投射物生成Socket
- en: In order to spawn the player projectile, you need to determine the `Transform`
    in which the projectile will spawn while primarily focusing on `Location` and
    `Rotation`, rather than `Scale`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成玩家投射物，您需要确定投射物将生成的`Transform`，主要关注`位置`和`旋转`，而不是`缩放`。
- en: In this exercise, you will create a new `Socket` on the player character's `Skeleton`
    that you can then reference in code in order to obtain the location from which
    to spawn the projectile.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在玩家角色的“骨架”上创建一个新的“Socket”，然后可以在代码中引用它，以便获取生成投射物的位置。
- en: 'Let''s get started:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Inside Unreal Engine 4, navigate to the `Content Browser` interface and find
    the `/MainCharacter/Mesh/` directory.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，导航到“内容浏览器”界面，找到“/MainCharacter/Mesh/”目录。
- en: In this directory, find the `Skeleton` asset; that is, `MainCharacter_Skeleton.uasset`.
    *Double-click* to open this `Skeleton`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中，找到“骨架”资产；即“MainCharacter_Skeleton.uasset”。*双击*打开此“骨架”。
- en: To determine the best position for where the projectile should spawn, we need
    to add the `Throw` Animation Montage as the preview animation for the skeleton.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定投射物应该生成的最佳位置，我们需要将“投掷”动画剪辑添加为骨架的预览动画。
- en: In the `Details` panel, under the `Animation` category, find the `Preview Controller`
    parameter and select the `Use Specific Animation` option.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Details”面板中，在“Animation”类别下，找到“Preview Controller”参数，并选择“Use Specific Animation”选项。
- en: Next, *left-click* on the drop-down menu to find and select the `AM_Throw` Animation
    Montage from the list of available animations.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键单击*下拉菜单，找到并选择可用动画列表中的“AM_Throw”动画剪辑。
- en: 'Now, the player character''s `Skeleton` will start previewing the `Throw` Animation
    Montage, as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家角色的“骨架”将开始预览“投掷”动画剪辑，如下面的屏幕截图所示：
- en: '![Figure 14.12: The player character previewing the Throw Animation Montage'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12：玩家角色预览投掷动画剪辑'
- en: '](img/B16183_14_12.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_12.jpg)'
- en: 'Figure 14.12: The player character previewing the Throw Animation Montage'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：玩家角色预览投掷动画剪辑
- en: If you recall from *Exercise 14.02*, *Adding the Notify to the Throw Montage*,
    you added `Anim_ProjectileNotify` at the 22nd frame of the `Throw` animation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得*练习14.02*，*添加到投掷剪辑的通知*，您在“投掷”动画的第22帧添加了“Anim_ProjectileNotify”。
- en: 'Using the timeline at the bottom of the `Skeleton` editor, move the `red` bar
    to as close to the 22nd frame as you can. Please refer to the following screenshot:![Figure
    14.13: The same 22nd frame in which you added Anim_ProjectileNotify i'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“骨架”编辑器底部的时间轴，将“红色”条移动到尽可能接近第22帧。请参考以下屏幕截图：![图14.13：在之前的练习中添加Anim_ProjectileNotify
    i
- en: n an earlier exercise
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中
- en: '](img/B16183_14_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_13.jpg)'
- en: 'Figure 14.13: The same 22nd frame in which you added Anim_ProjectileNotify
    i n an earlier exercise'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：在之前的练习中添加了Anim_ProjectileNotify的第22帧相同的帧
- en: 'At the 22nd frame of the `Throw` animation, the player character should look
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在“投掷”动画的第22帧，玩家角色应该如下所示：
- en: '![Figure 14.14: At the 22nd frame of the Throw Animation Montage, the character’s
    hand is in position to release a projectile'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14：在投掷动画剪辑的第22帧，角色的手位于释放投射物的位置'
- en: '](img/B16183_14_14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_14.jpg)'
- en: 'Figure 14.14: At the 22nd frame of the Throw Animation Montage, the character''s
    hand is in position to release a projectile'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：在投掷动画剪辑的第22帧，角色的手位于释放投射物的位置
- en: 'As you can see, the player character will be throwing the projectile from their
    right hand, so the new `Socket` should be attached to the *right hand*. Let''s
    take a look at the skeletal hierarchy of the player character, as shown in the
    following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，玩家角色将从他们的右手投掷投射物，因此新的“Socket”应该连接到*右手*。让我们看一下玩家角色的骨骼层次结构，如下面的屏幕截图所示：
- en: '![Figure 14.15: The RightHand bone found within the hierarchy'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15：在层次结构中找到的RightHand骨骼'
- en: of the player character’s skeleton
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色的骨架
- en: '](img/B16183_14_15.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_15.jpg)'
- en: 'Figure 14.15: The RightHand bone found within the hierarchy of the player character''s
    skeleton'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：在玩家角色骨架的层次结构中找到的RightHand骨骼
- en: From the skeletal hierarchy, find the `RightHand` bone. This can be found underneath
    the `RightShoulder` bone hierarchy structure.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从骨骼层次结构中找到`RightHand`骨骼。这可以在`RightShoulder`骨骼层次结构下找到。
- en: '*Right-click* on the `RightHand` bone and *left-click* the `Add Socket` option
    from the list of options that appear. Name this socket `ProjectileSocket`.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`RightHand`骨骼，然后*左键单击*出现的选项列表中的`Add Socket`选项。将此插座命名为`ProjectileSocket`。'
- en: Also, when adding a new `Socket`, the hierarchy of the entire `RightHand` will
    expand and the new socket will appear at the bottom.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当添加一个新的`Socket`时，整个`RightHand`的层次结构将扩展，新的插座将出现在底部。
- en: 'With `ProjectileSocket` selected, use the `Transform` widget gizmo to position
    this `Socket` at the following location:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`ProjectileSocket`，使用`Transform`小部件小部件将此`Socket`定位到以下位置：
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final result should look as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该如下所示：
- en: '![Figure 14.16: The final position of ProjectileSocket at the 22nd frame of
    the Throw Animation in world space.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16：抛射物插座在世界空间中抛出动画的第22帧的最终位置。'
- en: '](img/B16183_14_16.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_16.jpg)'
- en: 'Figure 14.16: The final position of ProjectileSocket at the 22nd frame of the
    Throw Animation in world space.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16：抛射物插座在世界空间中抛出动画的第22帧的最终位置。
- en: If your gizmo looks a bit different, that is because the above image shows the
    socket location in world space, not local space.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的小部件看起来有点不同，那是因为上面的图像显示了世界空间中的插座位置，而不是本地空间。
- en: Now that `ProjectileSocket` is positioned where you want it, save the `MainCharacter_Skeleton`
    asset.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`ProjectileSocket`的位置已经就位，保存`MainCharacter_Skeleton`资产。
- en: With this exercise complete, you now know the location that the player projectile
    will spawn from. Since you used the `Throw` Animation Montage in the preview,
    and used the same 22nd frame of the animation, you know this position will be
    correct based on when `Anim_ProjectileNotify` will fire.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在知道玩家抛射物将从哪个位置生成。由于你在预览中使用了`Throw`动画蒙太奇，并使用了相同的动画的第22帧，所以你知道这个位置将根据`Anim_ProjectileNotify`的触发时间是正确的。
- en: Now, let's move on to actually spawning the player projectile in C++.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续在C++中生成玩家抛射物。
- en: 'Exercise 14.05: Preparing the SpawnProjectile() Function'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.05：准备`SpawnProjectile()`函数
- en: Now that you have `ProjectileSocket` in place and there is now a location from
    which to spawn the player projectile, let's add the code necessary to spawn the
    player projectile.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`ProjectileSocket`已经就位，并且现在有一个位置可以生成玩家抛射物了，让我们添加生成玩家抛射物所需的代码。
- en: By the end of this exercise, you will have the function ready to spawn the projectile
    and it will be ready to call from the `Anim_ProjectileNotify` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习结束时，你将有一个准备好生成抛射物的函数，并且它将准备好从`Anim_ProjectileNotify`类中调用。
- en: 'Perform the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: From Visual Studio, navigate to the `SuperSideScroller_Player.h` header file.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Visual Studio中，导航到`SuperSideScroller_Player.h`头文件。
- en: 'You need a class reference variable to the `PlayerProjectile` class. You can
    do this using the variable template class type known as `TSubclassOf`. Add the
    following code to the header file, under the `Private` access modifier:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个指向`PlayerProjectile`类的类引用变量。你可以使用名为`TSubclassOf`的变量模板类类型来实现这一点。在`Private`访问修饰符下，将以下代码添加到头文件中：
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you have the variable ready, it is time to declare the function you
    will use to spawn the projectile.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好变量，是时候声明你将用来生成抛射物的函数了。
- en: 'Add the following function declaration under the declaration of the void `ThrowProjectile()`
    function and the `Public` access modifier:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ThrowProjectile()`函数的声明和`Public`访问修饰符下添加以下函数声明：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before preparing the definition of the `SpawnProjectile()` function, add the
    following `include` directories to the list of includes in the `SuperSideScroller_Player.cpp`
    source file:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备`SpawnProjectile()`函数的定义之前，将以下`include`目录添加到`SuperSideScroller_Player.cpp`源文件的包含列表中：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You need to include `PlayerProjectile.h` because it is required in order to
    reference the collision component of the projectile class. Next, use of the `Engine/World.h`
    include is necessary in order to use the `SpawnActor()` function and access the
    `FActorSpawnParameters` struct. Lastly, you need to use the `Components/SphereComponent.h`
    include in order to update the collision component of the player projectile so
    that it will ignore the player.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要包含`PlayerProjectile.h`，因为这是为了引用抛射物类的碰撞组件而必需的。接下来，使用`Engine/World.h`的包含是为了使用`SpawnActor()`函数和访问`FActorSpawnParameters`结构。最后，你需要使用`Components/SphereComponent.h`的包含，以便更新玩家抛射物的碰撞组件，使其忽略玩家。
- en: 'Next, create the definition of the `SpawnProjectile()` function at the bottom
    of the `SuperSideScroller_Player.cpp` source file, as shown here:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`SuperSideScroller_Player.cpp`源文件的底部创建`SpawnProjectile()`函数的定义，如下所示：
- en: '[PRE12]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing this function needs to do is check whether the `PlayerProjectile`
    class variable is valid. If this object is not valid, there is no point in continuing
    to try and spawn it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要做的第一件事是检查`PlayerProjectile`类变量是否有效。如果这个对象无效，继续尝试生成它就没有意义了。
- en: 'Update the `SpawnProjectile()` function so that it looks as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SpawnProjectile()`函数如下：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if the `PlayerProjectile` object is valid, you'll want to obtain the `UWorld`
    object that the player currently exists in and ensure that this world is valid
    before continuing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`PlayerProjectile`对象有效，你将想要获取玩家当前存在的`UWorld`对象，并确保这个世界在继续之前是有效的。
- en: 'Update the `SpawnProjectile()` function to the following:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SpawnProjectile()`函数如下：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, you have made safety checks to ensure that both `PlayerProjectile`
    and `UWorld` are valid, so now it is safe to attempt to spawn the projectile.
    The first thing to do is declare a new variable of the `FactorSpawnParameters`
    type and assign the player as the owner.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经进行了安全检查，以确保`PlayerProjectile`和`UWorld`都是有效的，所以现在可以安全地尝试生成抛射物了。首先要做的是声明一个新的`FactorSpawnParameters`类型的变量，并将玩家指定为所有者。
- en: 'Add the following code within the most recent `if` statement so that the `SpawnProjectile()`
    function looks like this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最近的`if`语句中添加以下代码，使`SpawnProjectile()`函数看起来像这样：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you have previously learned, the `SpawnActor()` function call from the `UWorld`
    object will require the `FActorSpawnParameters` struct as part of the spawned
    objects' initialization. In the case of the player projectile, you can use the
    `this` keyword as a reference to the player character class for the owner of the
    projectile. This will come in handy later on in this function when you update
    the collision of the projectile after it spawns.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前学到的，`UWorld`对象的`SpawnActor()`函数调用将需要`FActorSpawnParameters`结构作为生成对象的初始化的一部分。对于玩家投射物，你可以使用`this`关键字作为玩家角色类的引用，作为投射物的所有者。这在以后在这个函数中更新投射物的碰撞时会派上用场。
- en: 'Next, you need to handle the `Location` and `Rotation` parameters of the `SpawnActor()`
    function. Add the following lines under the latest line, `SpawnParams.Owner =
    this`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要处理`SpawnActor()`函数的`Location`和`Rotation`参数。在最新的一行下面添加以下行：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the first line, you declare a new `FVector` variable called `SpawnLocation`.
    This vector uses the `Socket` location of the `ProjectileSocket` socket that you
    created in the previous exercise. The `Skeletal Mesh` component returned from
    the `GetMesh()` function contains a function called `GetSocketLocation()` that
    will return the location of the socket with the `FName` that is passed in; in
    this case, the name `ProjectileSocket`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，声明一个名为`SpawnLocation`的新`FVector`变量。这个向量使用你在上一个练习中创建的`ProjectileSocket`插座的`Socket`位置。从`GetMesh()`函数返回的`Skeletal
    Mesh`组件包含一个名为`GetSocketLocation()`的函数，它将返回传入的`FName`的插座位置；在这种情况下，是名为`ProjectileSocket`。
- en: In the second line, you are declaring a new `FRotator` variable called `Rotation`.
    This value is set to the player's forward vector, converted into a `Rotator` container.
    This will ensure that the rotation, or in other words, the direction in which
    the player projectile will spawn, will be in front of the player, and it will
    move away from the player.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，声明一个名为`Rotation`的新`FRotator`变量。这个值设置为玩家的前向向量，转换为`Rotator`容器。这将确保玩家投射物生成的旋转，或者换句话说，方向，将在玩家的前方，并且它将远离玩家。
- en: Now, all of the parameters required to spawn the projectile are ready.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成项目所需的所有参数都已准备好。
- en: 'Add the following line underneath the code from the previous step:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的代码下面添加以下行：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `World->SpawnActor()` function will return an object of the class you are
    attempting to spawn in; in this case, `APlayerProjectile`. This is why you are
    adding `APlayerProjectile* Projectile` before the actual spawning occurs. Then,
    you are passing in the `SpawnLocation`, `Rotation`, and `SpawnParams` parameters
    to ensure that the projectile is spawning where and how you want.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`World->SpawnActor()`函数将返回你尝试生成的类的对象；在这种情况下是`APlayerProjectile`。这就是为什么在实际生成之前要添加`APlayerProjectile*
    Projectile`。然后，你要传入`SpawnLocation`、`Rotation`和`SpawnParams`参数，以确保项目生成在你想要的位置和方式。'
- en: 'Finally, you can add the player character to the array of actors to ignore
    on the player projectile by adding the following lines of code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以通过添加以下代码行将玩家角色添加到要忽略的演员数组中：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that you have a reference to the projectile, this line is updating the `CollisionComp`
    component so that the player, or `SpawnParams.Owner`, is added to the `MoveIgnoreActors`
    array. This array of actors will be ignored by the projectile's collision as it
    moves, which is perfect because this projectile should not collide with the player
    that has thrown it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了投射物的引用，这一行正在更新`CollisionComp`组件，以便将玩家或`SpawnParams.Owner`添加到`MoveIgnoreActors`数组中。这个演员数组将被投射物的碰撞忽略，因为这个投射物不应该与投掷它的玩家发生碰撞。
- en: Return to the editor to recompile the newly added code. After the code compiles
    successfully, this exercise is complete.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器重新编译新添加的代码。代码成功编译后，这个练习就完成了。
- en: With this exercise complete, you now have a function that will spawn the player
    projectile class that is assigned inside the player character. By adding safety
    checks for the validity of both the projectile and the world, you ensure that
    if an object is spawned, it is a valid object inside a valid world.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你现在有一个函数，可以生成分配给玩家角色内的玩家投射物类。通过为投射物和世界的有效性添加安全检查，你确保如果生成了一个对象，它是一个有效的对象在一个有效的世界内。
- en: Next, you set up the appropriate `location`, `rotation`, and `FActorSpawnParameters`
    parameters for the `UWorld SpawnActor()` function to ensure that the player projectile
    spawns at the right location, based on the socket location from the previous exercise,
    with the appropriate direction so that it moves away from the player, and with
    the player character as its `Owner`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为`UWorld SpawnActor()`函数设置适当的`location`、`rotation`和`FActorSpawnParameters`参数，以确保玩家投射物在正确的位置生成，基于上一个练习中的插座位置，以适当的方向远离玩家，并以玩家角色作为其`Owner`。
- en: Now, it is time to update the `Anim_ProjectileNotify` source file so that it
    spawns the projectile.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更新`Anim_ProjectileNotify`源文件，以便生成投射物。
- en: 'Exercise 14.06: Updating the Anim_ProjectileNotify Class'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.06：更新Anim_ProjectileNotify类
- en: You have the function ready to allow the player projectile to spawn, but you
    aren't calling this function anywhere yet. Back in *Exercise 14.01*, *Creating
    a UAnim Notify Class*, you created the `Anim_ProjectileNotify` class, while in
    *Exercise 14.02*, *Adding the Notify to the Throw Montage*, you added this notify
    to the `Throw` Animation Montage.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好允许玩家投射物生成的函数，但是你还没有在任何地方调用这个函数。回到*练习14.01*，*创建UAnim Notify类*，你创建了`Anim_ProjectileNotify`类，而在*练习14.02*，*将通知添加到投掷动画*，你将这个通知添加到`Throw`动画蒙太奇中。
- en: Now it is time to update the `Uanim` `Notify` class so that it calls the `SpawnProjectile()`
    function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更新`Uanim` `Notify`类，以便调用`SpawnProjectile()`函数。
- en: 'Do the following to achieve this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请执行以下操作：
- en: In Visual Studio, open the `Anim_ProjectileNotify.cpp` source file.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，打开`Anim_ProjectileNotify.cpp`源文件。
- en: 'In the source file, you have the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件中，您有以下代码：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remove the `UE_LOG()` line from the `Notify()` function.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Notify()`函数中删除`UE_LOG()`行。
- en: 'Next, add the following `include` lines underneath `Anim_ProjectileNotify.h`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Anim_ProjectileNotify.h`下面添加以下`include`行：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You need to include the `SuperSideScroller_Player.h` header file because it
    is required in order to call the `SpawnProjectile()` function you created in the
    previous exercise. We also included `SkeletalMeshComponent.h` because we will
    reference this component inside the `Notify()` function, so it's best to include
    it here too.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要包含`SuperSideScroller_Player.h`头文件，因为这是在调用您在上一个练习中创建的`SpawnProjectile()`函数时所需的。我们还包括了`SkeletalMeshComponent.h`，因为我们将在`Notify()`函数中引用此组件，所以最好也在这里包含它。
- en: The `Notify()` function passes in a reference to the owning `Skeletal Mesh`,
    labeled `MeshComp`. You can use the skeletal mesh to get a reference to the player
    character by using the `GetOwner()` function and casting the returned actor to
    your `SuperSideScroller_Player` class. We'll do this next.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notify()`函数传入拥有的`Skeletal Mesh`的引用，标记为`MeshComp`。您可以使用骨骼网格来通过使用`GetOwner()`函数并将返回的角色转换为您的`SuperSideScroller_Player`类来获取对玩家角色的引用。我们将在下一步中执行此操作。'
- en: 'Inside the `Notify()` function, add the following line of code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Notify()`函数中，添加以下代码行：
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that you have a reference to the player, you need to add a validity check
    of the `Player` variable before making a call to the `SpawnProjectile()` function.
    Add the following lines of code after the line from the previous step:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经有了对玩家的引用，您需要在调用`SpawnProjectile()`函数之前对`Player`变量进行有效性检查。在上一步的行之后添加以下代码行：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that the `SpawnProjectile()` function is being called from the `Notify()`
    function, return to the editor to recompile and hot-reload the code changes you
    have made.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`SpawnProjectile()`函数从`Notify()`函数中被调用，返回编辑器重新编译和热重载您所做的代码更改。
- en: Before you are able to use `PIE` to run around and throw the player projectile,
    you need to assign the `Player Projectile` variable from the previous exercise.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够使用`PIE`四处奔跑并投掷玩家投射物之前，您需要从上一个练习中分配`Player Projectile`变量。
- en: Inside the `Content Browser` interface, navigate to the `/MainCharacter/Blueprints`
    directory to find the `BP_SuperSideScroller_MainCharacter` Blueprint. *Double-click*
    to open the Blueprint.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`界面中，导航到`/MainCharacter/Blueprints`目录，找到`BP_SuperSideScroller_MainCharacter`蓝图。
    *双击*打开蓝图。
- en: In the `Details` panel, underneath the `Throw Montage` parameter, you will find
    the `Player Projectile` parameter. *Left-click* the drop-down option for this
    parameter and find `BP_PlayerProjectile`. *Left-click* on this option to assign
    it to the `Player Projectile` variable.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Details`面板中，在`Throw Montage`参数下，您将找到`Player Projectile`参数。 *左键单击*此参数的下拉选项，并找到`BP_PlayerProjectile`。
    *左键单击*此选项以将其分配给`Player Projectile`变量。
- en: Recompile and save the `BP_SuperSideScroller_MainCharacter` Blueprint.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译并保存`BP_SuperSideScroller_MainCharacter`蓝图。
- en: Now, use `PIE` and use the *left mouse button*. The player character will play
    the `Throw` animation and the player projectile will spawn.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`PIE`并使用*鼠标左键*。玩家角色将播放`Throw`动画，玩家投射物将生成。
- en: 'Notice that the projectile is spawned from the `ProjectileSocket` function
    you created and that it moves away from the player. The following screenshot shows
    this in action:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，投射物是从您创建的`ProjectileSocket`函数中生成的，并且它远离玩家。以下截图显示了这一点：
- en: '![Figure 14.17: The player can now throw the player projectile'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.17：玩家现在可以投掷玩家投射物'
- en: '](img/B16183_14_17.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_17.jpg)'
- en: 'Figure 14.17: The player can now throw the player projectile'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17：玩家现在可以投掷玩家投射物
- en: With this exercise complete, the player can now throw the player projectile.
    The player projectile, in its current state, is ineffective against enemies and
    just flies through the air. It took a lot of moving parts between the `Throw`
    Animation Montage, the `Anim_ProjectileNotify` class, and the player character
    to get the player to throw the projectile.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，玩家现在可以投掷玩家投射物。当前状态下的玩家投射物对敌人无效，只是在空中飞行。在`Throw`动画Montage、`Anim_ProjectileNotify`类和玩家角色之间需要很多移动部件才能让玩家投掷投射物。
- en: In the upcoming exercises, you will update the player projectile so that it
    destroys enemies and play additional effects such as particles and sound.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将进行的练习中，您将更新玩家投射物，以便销毁敌人并播放额外的效果，如粒子和声音。
- en: Destroying Actors
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁角色
- en: 'So far in this chapter, we have put a lot of focus on spawning, or creating,
    actors inside the game world; the player character uses the `UWorld` class in
    order to spawn the projectile. Unreal Engine 4 and its base `Actor` class come
    with a default function that you can use to destroy, or remove, an actor from
    the game world:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经非常关注在游戏世界中生成或创建角色；玩家角色使用`UWorld`类来生成投射物。Unreal Engine 4及其基本的`Actor`类带有一个默认函数，您可以使用它来销毁或移除游戏世界中的角色：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can find the full implementation of this function in Visual Studio by finding
    the `Actor.cpp` source file in the `/Source/Runtime/Engine/Actor.cpp` directory.
    This function exists in all the classes that extend from the `Actor` class, and
    in the case of Unreal Engine 4, it exists in all classes that can be spawned,
    or placed, inside the game world. To be more explicit, both the `EnemyBase` and
    `PlayerProjectile` classes are *children* of the `Actor` class, and therefore,
    can be destroyed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Visual Studio中找到此函数的完整实现，方法是在`/Source/Runtime/Engine/Actor.cpp`目录中找到`Actor.cpp`源文件。此函数存在于所有扩展自`Actor`类的类中，在Unreal
    Engine 4的情况下，它存在于所有可以在游戏世界中生成或放置的类中。更明确地说，`EnemyBase`和`PlayerProjectile`类都是`Actor`类的*子类*，因此可以被销毁。
- en: 'Looking further into the `AActor::Destroy()` function, you will find the following line:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查看`AActor::Destroy()`函数，您将找到以下行：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will not be going into further detail about what exactly the `UWorld` class
    does in order to destroy an actor, but it is important to emphasize the fact that
    the `UWorld` class is responsible for both the creation and destruction of actors
    inside the world. Feel free to dig deeper into the source engine code to find
    more information about how the `UWorld` class handles the destruction and spawning
    of actors.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论`UWorld`类到底如何销毁角色，但重要的是要强调`UWorld`类负责在世界中创建和销毁角色。随时深入挖掘源引擎代码，找到更多关于`UWorld`类如何处理角色的销毁和生成的信息。
- en: Now that you have more context regarding how Unreal Engine 4 handles the destruction
    and removal of actors from the game world, we'll implement this ourselves for
    the enemy character.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对Unreal Engine 4如何处理游戏世界中的角色的销毁和移除有了更多的上下文，我们将为敌人角色实现这一功能。
- en: 'Exercise 14.07: Creating the DestroyEnemy() Function'
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.07：创建DestroyEnemy()函数
- en: The main part of the gameplay for the `Super SideScroller` game is for the player
    to move around the level and use the projectile to destroy enemies. At this point
    in the project, you have handled the player movement and spawning the player projectile.
    However, the projectile does not destroy enemies yet.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Super SideScroller`游戏的主要玩法是玩家在关卡中移动并使用投射物来摧毁敌人。在项目的这一阶段，你已经处理了玩家移动和生成玩家投射物。然而，投射物还不能摧毁敌人。'
- en: In order to get this functionality in place, we'll start by adding some logic
    to the `EnemyBase` class so that it knows how to handle its destruction and remove
    it from the game once it collides with the player projectile.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们将首先向`EnemyBase`类添加一些逻辑，以便它知道如何处理自己的销毁，并在与玩家投射物碰撞时从游戏中移除它。
- en: 'Complete the following steps to achieve this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤来实现这一点：
- en: First, navigate to Visual Studio and open the `EnemyBase.h` header file.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到Visual Studio并打开`EnemyBase.h`头文件。
- en: 'In the header file, create the declaration of a new function called `DestroyEnemy()`
    under the `Public` access modifier, as shown here:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中，在`Public`访问修饰符下创建一个名为`DestroyEnemy()`的新函数声明，如下所示：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure this function definition is written underneath `GENERATED_BODY()`,
    within the class definition.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这个函数定义写在`GENERATED_BODY()`下面，在类定义内部。
- en: Save these changes to the header file and open the `EnemyBase.cpp` source file
    in order to add the implementation of this function.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这些更改到头文件，并打开`EnemyBase.cpp`源文件，以添加这个函数的实现。
- en: 'Below the `#include` lines, add the following function definition:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`#include`行下面，添加以下函数定义：
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For now, this function will be very simple. All you need to do is call the inherited
    `Destroy()` function from the base `Actor` class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个函数将非常简单。你只需要调用基类`Actor`的继承`Destroy()`函数。
- en: 'Update the `DestroyEnemy()` function so that it looks like this:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`DestroyEnemy()`函数，使其看起来像这样：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this function complete, save the source file and return to the editor so
    that you can recompile and hot-reload the code.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个函数后，保存源文件并返回编辑器，这样你就可以重新编译和热重载代码了。
- en: With this exercise complete, the enemy character now has a function that can
    easily handle the destruction of the actor whenever you choose. The `DestroyEnemy()`
    function is publicly accessible so that it can be called by other classes, which
    will come in handy later when you handle the destruction of the player projectile.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，敌人角色现在有一个函数，可以轻松处理角色的销毁。`DestroyEnemy()`函数是公开可访问的，因此其他类可以调用它，在处理玩家投射物的销毁时会很方便。
- en: The reason you're creating your own unique function to destroy the enemy actor
    is because you will use this function later in this chapter to add VFX and SFX
    to the enemy when they are destroyed by the player projectile.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建自己独特的销毁敌人角色的函数的原因是因为你将在本章后面使用这个函数来为敌人被玩家投射物销毁时添加VFX和SFX。
- en: Before moving on to the polishing elements of the enemy's destruction, let's
    implement a similar function inside the player projectile class so that it can
    also be destroyed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行敌人销毁的润色元素之前，让我们在玩家投射物类中实现一个类似的函数，以便它也可以被销毁。
- en: 'Exercise 14.08: Destroying Projectiles'
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.08：销毁投射物
- en: Now that the enemy characters can handle being destroyed through the new `DestroyEnemy()`
    function you implemented in the previous exercise, it is time to do the same for
    the player projectile.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人角色可以通过你在上一个练习中实现的新的`DestroyEnemy()`函数处理被销毁了，现在是时候为玩家投射物做同样的事情了。
- en: By the end of this exercise, the player projectile will have its own unique
    function to handle its own destruction and removal from the game world.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习结束时，玩家投射物将有自己独特的函数来处理自己的销毁和从游戏世界中移除。
- en: 'Let''s get started:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: In Visual Studio, open the header file for the player projectile; that is, `PlayerProjectile.h`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，打开玩家投射物的头文件；也就是`PlayerProjectile.h`。
- en: 'Under the `Public` access modifier, add the following function declaration:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Public`访问修饰符下，添加以下函数声明：
- en: '[PRE28]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, open the source file for the player projectile; that is, `PlayerProjectile.cpp`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开玩家投射物的源文件；也就是`PlayerProjectile.cpp`。
- en: 'Underneath the void `APlayerProjectile::OnHit` function, add the definition
    of the `ExplodeProjectile()` function:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`APlayerProjectile::OnHit`函数下面，添加`ExplodeProjectile()`函数的定义：
- en: '[PRE29]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For now, this function will work identically to the `DestroyEnemy()` function
    from the previous exercise.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个函数将与上一个练习中的`DestroyEnemy()`函数完全相同。
- en: 'Add the inherited `Destroy()` function to the new `ExplodeProjectile()` function,
    like so:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将继承的`Destroy()`函数添加到新的`ExplodeProjectile()`函数中，如下所示：
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this function complete, save the source file and return to the editor so
    that you can recompile and hot-reload the code.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个函数后，保存源文件并返回编辑器，这样你就可以重新编译和热重载代码了。
- en: With this exercise complete, the player projectile now has a function that can
    easily handle the destruction of the actor whenever you choose. The reason you
    need to create your own unique function to handle destroying the player projectile
    actor is the same reason you created the `DestroyEnemy()` function – you will
    use this function later in this chapter to add VFX and SFX to the player projectile
    when it collides with another actor.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，玩家抛射物现在具有一个可以轻松处理角色摧毁的功能。您需要创建自己独特的函数来处理摧毁玩家抛射物角色的原因与创建`DestroyEnemy()`函数的原因相同-您将在本章后面使用此函数为玩家抛射物与其他角色碰撞时添加VFX和SFX。
- en: Now that you have experience with implementing the `Destroy()` function inside
    both the player projectile and the enemy character, it is time to put these two
    elements together.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了在玩家抛射物和敌人角色内部实现`Destroy()`函数的经验，是时候将这两个元素结合起来了。
- en: In the next activity, you will enable the player projectile in order to destroy
    the enemy character when they collide.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，您将使玩家抛射物能够在碰撞时摧毁敌人角色。
- en: 'Activity 14.01: Projectile Destroying Enemies'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动14.01：抛射物摧毁敌人
- en: Now that both the player projectile and the enemy character can handle being
    destroyed, it is time to go the extra step and allow the player projectile to
    destroy the enemy character when they collide.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家抛射物和敌人角色都可以处理被摧毁的情况，是时候迈出额外的一步，允许玩家抛射物在碰撞时摧毁敌人角色了。
- en: 'Perform the following steps to achieve this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现这一点：
- en: Add the `#include` statement for the `EnemyBase.h` header file toward the top
    of the `PlayerProjectile.cpp` source file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.cpp`源文件的顶部添加`#include`语句，引用`EnemyBase.h`头文件。
- en: Within the void `APlayerProjectile::OnHit()` function, create a new variable
    of the `AEnemyBase*` type and call this variable `Enemy`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`APlayerProjectile::OnHit()`函数中，创建一个`AEnemyBase*`类型的新变量，并将此变量命名为`Enemy`。
- en: Cast the `OtherActor` parameter of the `APlayerProjectile::OnHit()` function
    to the `AEnemyBase*` class and set the `Enemy` variable to the result of this
    cast.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`APlayerProjectile::OnHit()`函数的`OtherActor`参数转换为`AEnemyBase*`类，并将`Enemy`变量设置为此转换的结果。
- en: Use an `if()` statement to check the validity of the `Enemy` variable.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if()`语句检查`Enemy`变量的有效性。
- en: If the `Enemy` is valid, call the `DestroyEnemy()` function from this `Enemy`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Enemy`有效，则从此`Enemy`调用`DestroyEnemy()`函数。
- en: After the `if()` block, make a call to the `ExplodeProjectile()` function.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if()`块之后，调用`ExplodeProjectile()`函数。
- en: Save the changes to the source file and return to the Unreal Engine 4 editor.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存源文件的更改并返回到虚幻引擎4编辑器。
- en: Use `PIE` and then use the player projectile against an enemy to observe the results.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PIE`，然后使用玩家抛射物对抗敌人以观察结果。
- en: 'The expected output is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 14.18: The player throwing the projectile'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.18：玩家投掷抛射物'
- en: '](img/B16183_14_18.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_18.jpg)'
- en: 'Figure 14.18: The player throwing the projectile'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18：玩家投掷抛射物
- en: 'As the projectile hits the enemy, the enemy character is destroyed, as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛射物击中敌人时，敌人角色被摧毁，如下所示：
- en: '![Figure 14.19: The projectile and enemy destroyed'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.19：抛射物和敌人被摧毁'
- en: '](img/B16183_14_19.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_19.jpg)'
- en: 'Figure 14.19: The projectile and enemy destroyed'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19：抛射物和敌人被摧毁
- en: With this activity complete, the player projectile and the enemy character can
    be destroyed when they collide with each other. Additionally, the player projectile
    will be destroyed whenever another actor triggers its `APlayerProjectile::OnHit()` function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，玩家抛射物和敌人角色在碰撞时可以被摧毁。此外，每当另一个角色触发其`APlayerProjectile::OnHit()`函数时，玩家抛射物也将被摧毁。
- en: 'With that, a major element of the `Super SideScroller` game has been completed:
    the player projectile spawning and the enemies being destroyed when they collide
    with the projectile. You can observe that destroying these actors is very simple
    and not very interesting to the player.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，`Super SideScroller`游戏的一个重要元素已经完成：玩家抛射物的生成以及敌人与抛射物碰撞时的摧毁。您可以观察到摧毁这些角色非常简单，对玩家来说并不是很有趣。
- en: This is why, in the upcoming exercises in this chapter, you will learn more
    about Visual and Audio Effects, or VFX and SFX, respectively. You will also implement
    these elements with regard to the enemy character and player projectile.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的即将进行的练习中，您将更多地了解有关视觉和音频效果，即VFX和SFX。您还将针对敌人角色和玩家抛射物实现这些元素。
- en: Now that both the enemy character and the player projectile can be destroyed,
    let's briefly discuss what VFX and SFX are, and how they will impact the project.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人角色和玩家抛射物都可以被摧毁，让我们简要讨论一下VFX和SFX是什么，以及它们将如何影响项目。
- en: Note
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下链接找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Visual and Audio Effects
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉和音频效果
- en: Visual Effects such as particle systems and sound effects such as Sound Cues
    play an important role in video games. They add a level of polish on top of systems,
    game mechanics, and even basic actions that make these elements more interesting
    or more pleasing to perform.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉效果，如粒子系统和声音效果，如声音提示，在视频游戏中扮演着重要角色。它们在系统、游戏机制甚至基本操作之上增添了一层光泽，使这些元素更有趣或更令人愉悦。
- en: Let's start by understanding Visual Effects, followed by Audio Effects.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解视觉效果，然后是音频效果。
- en: '**Visual Effects (VFX)**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉效果（VFX）**'
- en: Visual Effects, in the context of Unreal Engine 4, are made up of what's called
    **Particle Systems**. Particle systems are made up of emitters, and emitters are
    comprised of modules. In these modules, you can control the appearance and behaviors
    of the emitter using materials, meshes, and mathematical modules. The end result
    can be anything from a fire torch, or snow falling, to rain, dust, and so on.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4的上下文中，视觉效果由所谓的**粒子系统**组成。粒子系统由发射器组成，发射器由模块组成。在这些模块中，您可以使用材料、网格和数学模块来控制发射器的外观和行为。最终结果可以是从火炬、雪花、雨、灰尘等各种效果。
- en: Note
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more here: [https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.html](https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.html).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里了解更多信息：[https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.html](https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.html)。
- en: '**Audio Effects (SFX)**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**音频效果（SFX）**'
- en: 'Audio Effects, in the context of Unreal Engine 4, are made up of a combination
    of Sound Waves and Sound Cues:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4的上下文中，音频效果由声波和声音提示的组合组成：
- en: Sound Waves are `.wav` audio format files that can be imported into Unreal Engine
    4.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声波是可以导入到虚幻引擎4中的`.wav`音频格式文件。
- en: Sound Cues combine Sound Wave audio files with other nodes such as Oscillator,
    Modulator, and Concatenator to create unique and complex sounds for your game.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音提示将声波音频文件与其他节点（如振荡器、调制器和连接器）组合在一起，为您的游戏创建独特和复杂的声音。
- en: Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more here: [https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.html](https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.html).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里了解更多信息：[https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.html](https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.html)。
- en: Let's use the game *Portal 2*, developed by Valve, as an example.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Valve开发的游戏*Portal 2*为例。
- en: 'In *Portal 2*, the player uses a portal gun to fire two portals: one *orange*
    and one *blue*. These portals allow the player to travel across gaps, move objects
    from one location to another, and utilize other simple mechanics that layer on
    top of each other to create complex puzzles. The use of these portals, the sound
    effects for firing the portals, and the visual VFX of these portals make the game
    more enjoyable to play. If you are unfamiliar with the game, please watch the
    full walkthrough here: [https://www.youtube.com/watch?v=ZFqk8aj4-PA](https://www.youtube.com/watch?v=ZFqk8aj4-PA).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Portal 2*中，玩家使用传送枪发射两个传送门：一个*橙色*和一个*蓝色*。这些传送门允许玩家穿越间隙，将物体从一个位置移动到另一个位置，并利用其他简单的机制，这些机制叠加在一起，形成复杂的谜题。使用这些传送门，传送门发射的声音效果以及这些传送门的视觉VFX使游戏更加有趣。如果您对这款游戏不熟悉，请观看完整的攻略视频：[https://www.youtube.com/watch?v=ZFqk8aj4-PA](https://www.youtube.com/watch?v=ZFqk8aj4-PA)。
- en: Note
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For further reading regarding the importance of sound and sound design, please
    refer to the following Gamasutra article: [https://www.gamasutra.com/view/news/318157/7_games_worth_studying_for_their_excellent_sound_design.php](https://www.gamasutra.com/view/news/318157/7_games_worth_studying_for_their_excellent_sound_design.php).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有关声音和声音设计重要性的进一步阅读，请参阅以下Gamasutra文章：[https://www.gamasutra.com/view/news/318157/7_games_worth_studying_for_their_excellent_sound_design.php](https://www.gamasutra.com/view/news/318157/7_games_worth_studying_for_their_excellent_sound_design.php)。
- en: 'In the context of Unreal Engine 4, VFX were originally created using a tool
    called `materials`, `static meshes`, and `math` to create interesting and convincing
    effects for the game world. This book will not dive into how this tool works,
    but you can find information about Cascade here: [https://www.ue4community.wiki/Legacy/Introduction_to_Particles_in_UE4_-_2_-_Cascade_at_a_Glance](https://www.ue4community.wiki/Legacy/Introduction_to_Particles_in_UE4_-_2_-_Cascade_at_a_Glance).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4的上下文中，VFX最初是使用称为`材质`、`静态网格`和`数学`的工具创建的，以为游戏世界创建有趣和令人信服的效果。本书不会深入介绍这个工具的工作原理，但您可以在这里找到有关Cascade的信息：[https://www.ue4community.wiki/Legacy/Introduction_to_Particles_in_UE4_-_2_-_Cascade_at_a_Glance](https://www.ue4community.wiki/Legacy/Introduction_to_Particles_in_UE4_-_2_-_Cascade_at_a_Glance)。
- en: 'In more recent versions of the engine, starting in the 4.20 update, there is
    a plugin called `Niagara`, unlike Cascade, uses a system similar to Blueprints
    where you can visually script the behaviors of the effect rather than use a preset
    of modules with pre-defined behavior. You can find more information about Niagara
    here: [https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎的更新版本中，从4.20版本开始，有一个名为`Niagara`的插件，与Cascade不同，它使用类似蓝图的系统，您可以在其中直观地编写效果的行为，而不是使用预定义行为的模块。您可以在这里找到有关Niagara的更多信息：[https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html)。
- en: In *Chapter 9*, *Audio-Visual Elements*, you learned more about audio and how
    audio is handled inside Unreal Engine 4\. All that needs to be known right now
    is that Unreal Engine 4 uses the `.wav` file format to import audio into the engine.
    From there, you can use the `.wav` file directly, referred to as Sound Waves in
    the editor, or you can convert these assets into Sound Cues, which allow you to
    add Audio Effects on top of the sound wave.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*音频-视觉元素*中，您了解了更多关于音频以及音频在虚幻引擎4中的处理。现在需要知道的是，虚幻引擎4使用`.wav`文件格式将音频导入到引擎中。从那里，您可以直接使用`.wav`文件，在编辑器中称为声波，或者您可以将这些资产转换为声音提示，这样可以在声波上添加音频效果。
- en: 'Lastly, there is one important class to know about that you will be referencing
    in the upcoming exercises, and this class is called `UGameplayStatics`. This is
    a static class featured in Unreal Engine that can be used from both C++ and Blueprints,
    and it offers a variety of useful gameplay-related functions. The two functions
    you will be working with in the upcoming exercise are as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个重要的类需要了解，您将在即将进行的练习中引用这个类，这个类叫做`UGameplayStatics`。这是虚幻引擎中的一个静态类，可以从C++和蓝图中使用，它提供了各种有用的与游戏相关的功能。您将在即将进行的练习中使用的两个函数如下：
- en: '[PRE31]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These two functions work in very similar ways; they both require a `World` context
    object in which to spawn the effect, the particle system or audio to spawn, and
    the location in which to spawn the effect. You will be using these functions to
    spawn the destroy effects for the enemy in the next exercise.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的工作方式非常相似；它们都需要一个“World”上下文对象来生成效果，要生成的粒子系统或音频，以及要生成效果的位置。您将使用这些函数来生成敌人的销毁效果。
- en: 'Exercise 14.09: Adding Effects When the Enemy Is Destroyed'
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.09：在敌人被摧毁时添加效果
- en: In this exercise, you will add new content to the project that comes included
    with this chapter and exercise. This includes the particle VFX and sound SFX,
    and all of their required assets. Then, you will update the `EnemyBase` class
    so that it can use audio and particle system parameters to add the layer of polish
    needed when the enemy is destroyed by the player projectile.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您将向项目中添加本章和练习包含的新内容。这包括粒子VFX和声音SFX，以及它们所需的所有资产。然后，您将更新“EnemyBase”类，以便它可以使用音频和粒子系统参数，在玩家投射物销毁敌人时添加所需的光泽层。
- en: By the end of this exercise, you will have an enemy that is visually and audibly
    destroyed when it collides with the player projectile.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本练习结束时，您将拥有一个敌人，当它与玩家投射物碰撞时，会在视觉和听觉上被摧毁。
- en: 'Let''s get started:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: To begin, we need to migrate specific assets from the `Action RPG` project,
    which can be found in the `Learn` tab of `Unreal Engine Launcher`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从“Action RPG”项目中迁移特定资产，这些资产可以在“虚幻引擎启动器”的“学习”选项卡中找到。
- en: 'From `Epic Games Launcher`, navigate to the `Learn` tab and, under the `Games`
    category, you will find `Action RPG`:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Epic Games Launcher”导航到“学习”选项卡，在“游戏”类别下，您将找到“Action RPG”：
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will be taking additional assets from the Action RPG project in later exercises
    of this chapter, so you should keep this project open so as to avoid redundant
    opening of the project.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后续练习中，您将从动作RPG项目中获取其他资产，因此应保持此项目打开，以避免重复打开项目。
- en: Left-click the `Action RPG` game project and then left-click the `Create Project`
    option.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击“Action RPG”游戏项目，然后左键单击“创建项目”选项。
- en: From here, select engine version 4.24 and choose which directory to download
    the project to. Then, *left-click* the `Create` button to start installing the
    project.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，选择引擎版本4.24，并选择要下载项目的目录。然后，*左键单击*“创建”按钮开始安装项目。
- en: Once the `Action RPG` project has finished downloading, navigate to the `Library`
    tab of `Epic Games Launcher` to find `ActionRPG` under the `My Projects` section.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Action RPG”项目下载完成后，导航到“Epic Games Launcher”的“库”选项卡，找到“My Projects”部分下的“ActionRPG”。
- en: '*Double-click* the `ActionRPG` project to open it in the Unreal Engine editor.'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“ActionRPG”项目，以在Unreal Engine编辑器中打开它。'
- en: In the editor, find the `A_Guardian_Death_Cue` audio asset in the `Content Browser`
    interface. *Right-click* this asset and select `Asset Actions` and then `Migrate`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在“内容浏览器”界面中找到“A_Guardian_Death_Cue”音频资产。*右键单击*此资产，然后选择“资产操作”，然后选择“迁移”。
- en: After selecting `Migrate`, you will be presented with all the assets that are
    referenced in `A_Guardian_Death_Cue`. This includes all audio classes and sound
    wave files. Choose `OK` from the `Asset Report` dialogue window.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“迁移”后，您将看到所有在“A_Guardian_Death_Cue”中引用的资产。这包括所有音频类和声波文件。从“资产报告”对话框中选择“确定”。
- en: Next, you will need to navigate to the `Content` folder for your `Super SideScroller`
    project and *left-click* `Select Folder`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要导航到“Super SideScroller”项目的“内容”文件夹，*左键单击*“选择文件夹”。
- en: Once the migration process is complete, you will be given a notification in
    the editor saying that the migration was completed successfully.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移过程完成后，您将在编辑器中收到通知，通知您迁移已成功完成。
- en: 'Do the same migration steps for the `P_Goblin_Death` VFX asset. The two primary
    assets you are adding to the project are as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对“P_Goblin_Death” VFX资产执行相同的迁移步骤。您要添加到项目中的两个主要资产如下：
- en: '[PRE32]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `P_Goblin_Death` particle system asset references additional assets such
    as materials and textures that are included in the `Effects` directory, while
    `A_Guardian_Death_Cue` references additional sound wave assets included in the
    `Assets` directory.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: “P_Goblin_Death”粒子系统资产引用了“Effects”目录中包含的材质和纹理等其他资产，而“A_Guardian_Death_Cue”引用了“Assets”目录中包含的其他声音波资产。
- en: After migrating these folders into your `Content` directory, open the Unreal
    Engine 4 editor of your `SuperSideScroller` project to find the new folders included
    in your project's `Content Browser`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些文件夹迁移到“SuperSideScroller”项目的“内容”目录后，打开Unreal Engine 4编辑器，以在项目的“内容浏览器”中找到包含在项目中的新文件夹。
- en: The particle you will be using for the enemy character's destruction is called
    `P_Goblin_Death` and can be found in the `/Effects/FX_Particle/` directory. The
    sound you will be using for the enemy character's destruction is called `A_Guardian_Death_Cue`
    and can be found in the `/Assets/Sounds/Creatures/Guardian/` directory. Now that
    the assets you need have been imported into the editor, let's move on to the code.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您将用于敌人角色销毁的粒子称为“P_Goblin_Death”，可以在“/Effects/FX_Particle/”目录中找到。您将用于敌人角色销毁的声音称为“A_Guardian_Death_Cue”，可以在“/Assets/Sounds/Creatures/Guardian/”目录中找到。现在您需要的资产已导入到编辑器中，让我们继续进行编码。
- en: Open Visual Studio and navigate to the header file for the enemy base class;
    that is, `EnemyBase.h`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并导航到敌人基类的头文件；也就是“EnemyBase.h”。
- en: 'Add the following `UPROPERTY()` variable. This will represent the particle
    system for when the enemy is destroyed. Make sure this is declared under the `Public`
    access modifier:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`UPROPERTY()`变量。这将代表敌人被销毁时的粒子系统。确保这是在“Public”访问修饰符下声明的：
- en: '[PRE33]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following `UPROPERTY()` variable. This will represent the sound for
    when the enemy is destroyed. Make sure this is declared under the `Public` access
    modifier:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`UPROPERTY()`变量。这将代表敌人被销毁时的声音。确保这是在“Public”访问修饰符下声明的：
- en: '[PRE34]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With these two properties defined, let's move on and add the logic required
    to spawn and use these effects for when the enemy is destroyed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个属性的定义，让我们继续添加所需的逻辑，以便在敌人被摧毁时生成和使用这些效果。
- en: 'Inside the source file for the enemy base class, `EnemyBase.cpp`, add the following
    includes for the `UGameplayStatics` and `UWorld` classes:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人基类的源文件`EnemyBase.cpp`中，添加以下包含`UGameplayStatics`和`UWorld`类：
- en: '[PRE35]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will be using the `UGameplayStatics` and `UWorld` classes to spawn the sound
    and particle system into the world when the enemy is destroyed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人被摧毁时，您将使用`UGameplayStatics`和`UWorld`类将声音和粒子系统生成到世界中。
- en: 'Within the `AEnemyBase::DestroyEnemy()` function, you have one line of code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AEnemyBase::DestroyEnemy()`函数中，您有一行代码：
- en: '[PRE36]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following line of code above the `Destroy()` function call:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Destroy()`函数调用之前添加以下代码行：
- en: '[PRE37]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is necessary to define the `UWorld` object before attempting to spawn a particle
    system or sound because a `World` context object is required.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试生成粒子系统或声音之前，有必要定义`UWorld`对象，因为需要一个`World`上下文对象。
- en: 'Next, use an `if()` statement to check the validity of the `World` object you
    just defined:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`if()`语句检查您刚刚定义的`World`对象的有效性：
- en: '[PRE38]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Within the `if()` block, add the following code to check the validity of the
    `DeathEffect` property, and then spawn this effect using the `SpawnEmitterAtLocation`
    function from `UGameplayStatics`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if()`块内，添加以下代码来检查`DeathEffect`属性的有效性，然后使用`UGameplayStatics`的`SpawnEmitterAtLocation`函数生成这个效果：
- en: '[PRE39]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It cannot be emphasized enough that you should ensure an object is valid before
    attempting to spawn or manipulate the object. By doing so, you can avoid engine crashes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 无法再次强调，在尝试生成或操作对象之前，您应该确保对象是有效的。这样做可以避免引擎崩溃。
- en: 'After the `if(DeathEffect)` block, perform the same validity check of the `DeathSound`
    property and then spawn the sound using the `UGameplayStatics::SpawnSoundAtLocation`
    function:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if(DeathEffect)`块之后，执行`DeathSound`属性的相同有效性检查，然后使用`UGameplayStatics::SpawnSoundAtLocation`函数生成声音：
- en: '[PRE40]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Before calling the `Destroy()` function, you need to make checks regarding whether
    both the `DeathEffect` and `DeathSound` properties are valid, and if so, spawn
    those effects using the proper `UGameplayStatics` function. This ensures that
    regardless of whether either property is valid, the enemy character will still
    be destroyed.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Destroy()`函数之前，您需要检查`DeathEffect`和`DeathSound`属性是否都有效，如果是，则使用适当的`UGameplayStatics`函数生成这些效果。这样无论这两个属性是否有效，敌人角色都将被摧毁。
- en: Now that the `AEnemyBase::DestroyEnemy()` function has been updated to spawn
    these effects, return to the Unreal Engine 4 editor to compile and hot-reload
    these code changes.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`AEnemyBase::DestroyEnemy()`函数已经更新以生成这些效果，返回到虚幻引擎4编辑器中编译和热重载这些代码更改。
- en: Within the `Content Browser` interface, navigate to the `/Enemy/Blueprints/`
    directory. *Double-click* the `BP_Enemy` asset to open it.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`界面中，导航到`/Enemy/Blueprints/`目录。*双击*`BP_Enemy`资源以打开它。
- en: In the `Details` panel of the enemy Blueprint, you will find the `Death Effect`
    and `Death Sound` properties. *Left-click* on the drop-down list for the `Death
    Effect` property and find the `P_Goblin_Death` particle system.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人蓝图的`Details`面板中，您将找到`Death Effect`和`Death Sound`属性。*左键单击*`Death Effect`属性的下拉列表，并找到`P_Goblin_Death`粒子系统。
- en: Next, underneath the `Death Effect` parameter, *left-click* on the drop-down
    list for the `Death Sound` property and find the `A_Guardian_Death_Cue` Sound
    Cue.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Death Effect`参数下方，*左键单击*`Death Sound`属性的下拉列表，并找到`A_Guardian_Death_Cue`声音提示。
- en: Now that these parameters have been updated and assigned the correct effect,
    compile and save the enemy Blueprint.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这些参数已经更新并分配了正确的效果，编译并保存敌人蓝图。
- en: 'Using `PIE`, spawn the player character and throw a player projectile at an
    enemy. If an enemy is not present in your level, please add one. When the player
    projectile collides with the enemy, the VFX and SFX you added will play, as shown
    in the following screenshot:![Figure 14.20: Now, the enemy explodes and gets destroyed
    in a blaze of glory'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PIE`，生成玩家角色并向敌人投掷玩家投射物。如果你的关卡中没有敌人，请添加一个。当玩家投射物与敌人碰撞时，你添加的VFX和SFX将播放，如下截图所示：![图14.20：现在，敌人爆炸并在火光中被摧毁
- en: '](img/B16183_14_20.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_20.jpg)'
- en: 'Figure 14.20: Now, the enemy explodes and gets destroyed in a blaze of glory'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20：现在，敌人爆炸并在火光中被摧毁
- en: With this exercise complete, the enemy character now plays a particle system
    and a Sound Cue when it is destroyed by the player projectile. This adds a nice
    layer of polish to the game, and it makes it more satisfying to destroy the enemies.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，敌人角色现在在被玩家投射物摧毁时播放粒子系统和声音提示。这为游戏增添了一层精致，使得摧毁敌人更加令人满意。
- en: In the next exercise, you will add a new particle system and audio components
    to the player projectile so that it looks and sounds more interesting while it
    flies through the air.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将为玩家投射物添加新的粒子系统和音频组件，使其在飞行时看起来更有趣并且听起来更有趣。
- en: 'Exercise 14.10: Adding Effects to the Player Projectile'
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.10：向玩家投射物添加效果
- en: In its current state, the player projectile functions the way it is intended
    to; it flies through the air, collides with objects in the game world, and is
    destroyed. However, visually, the player projectile is just a ball with a plain
    white texture.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，玩家投射物的功能是按预期的方式运行的；它在空中飞行，与游戏世界中的物体碰撞，并被摧毁。然而，从视觉上看，玩家投射物只是一个带有纯白色纹理的球。
- en: In this exercise, you will add a layer of polish to the player projectile by
    adding both a particle system and an audio component so that the projectile is
    more enjoyable to use.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将通过添加粒子系统和音频组件为玩家投射物增添一层精致，使得投射物更加愉快使用。
- en: 'Complete the following steps to achieve this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤以实现这一点：
- en: Much like the previous exercises, we will need to migrate assets from the `Action
    RPG` project to our `Super SideScroller` project. Please refer to *Exercise 14.09*,
    *Adding Effects When the Enemy Is Destroyed*, on how to install and migrate assets
    from the `Action RPG` project.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的练习一样，我们需要从“动作RPG”项目迁移资产到我们的“Super SideScroller”项目。请参考*练习14.09*，“在敌人被销毁时添加效果”，了解如何安装和迁移来自“动作RPG”项目的资产。
- en: 'The two primary assets you are adding to the project are as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您要添加到项目中的两个主要资产如下：
- en: '[PRE41]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `P_Env_Fire_Grate_01` particle system asset references additional assets,
    such as materials and textures, that are included in the `Effects` directory,
    while `A_Ambient_Fire01_Cue` references additional sound wave and sound attenuation
    assets included in the `Assets` directory.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_Env_Fire_Grate_01`粒子系统资产引用了其他资产，例如包含在“Effects”目录中的材质和纹理，而`A_Ambient_Fire01_Cue`引用了包含在“Assets”目录中的其他声音波和声音衰减资产。'
- en: The particle you will be using for the player projectile is called `P_Env_Fire_Grate_01`
    and can be found in the `/Effects/FX_Particle/` directory. This is the same directory
    that's used by the `P_Goblin_Death` VFX from the previous exercise. The sound
    you will be using for the player projectile is called `A_Ambient_Fire01_Cue` and
    can be found in the `/Assets/Sounds/Ambient/` directory.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您将用于玩家投射物的粒子是名为`P_Env_Fire_Grate_01`，可以在“/Effects/FX_Particle/”目录中找到。这是与之前练习中使用的`P_Goblin_Death`
    VFX相同的目录。您将用于玩家投射物的声音是名为`A_Ambient_Fire01_Cue`，可以在“/Assets/Sounds/Ambient/”目录中找到。
- en: '*Right-click* on each of these assets in the `Content Browser` interface of
    the `Action RPG` project and select `Asset Actions` and then `Migrate`.'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*“动作RPG”项目的“内容浏览器”界面中的每个资产，然后选择“资产操作”，然后选择“迁移”。'
- en: Make sure to choose the directory of the `Content` folder for your `Super SideScroller`
    project before confirming the migration.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认迁移之前，请确保选择“Super SideScroller”项目的“内容”文件夹目录。
- en: Now that the required assets have been migrated to our project, let's continue
    creating the player projectile class.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，必需的资产已迁移到我们的项目中，让我们继续创建玩家投射物类。
- en: Open Visual Studio and navigate to the header file for the player projectile
    class; that is, `PlayerProjectile.h`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，并导航到玩家投射物类的头文件；即“PlayerProjectile.h”。
- en: 'Under the `Private` access modifier, underneath the declaration of the `UStaticMeshComponent*
    MeshComp` class component, add the following code to declare a new audio component
    for the player projectile:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Private`访问修饰符下，在`UStaticMeshComponent* MeshComp`类组件声明下面，添加以下代码以声明玩家投射物的新音频组件：
- en: '[PRE42]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, add the following code underneath the declaration of the audio component
    in order to declare a new particle system component:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在音频组件声明下面添加以下代码，以声明一个新的粒子系统组件：
- en: '[PRE43]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instead of using properties that can be defined within the Blueprint, such as
    in the enemy character class, these effects will be components of the player projectile.
    This is because these effects should be attached to the collision component of
    the projectile so that they move with the projectile as it travels across the
    level when thrown.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 与在蓝图中可以定义的属性不同，例如在敌人角色类中，这些效果将成为玩家投射物的组件。这是因为这些效果应该附加到投射物的碰撞组件上，以便它们随着投射物在关卡中移动时移动。
- en: 'With these two components declared in the header file, open the source file
    for the player projectile and add the following includes to the list of `include`
    lines at the top of the file:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中声明这两个组件后，打开玩家投射物的源文件，并将以下包含添加到文件顶部的`include`行列表中：
- en: '[PRE44]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You need a reference to both the audio component and the particle system classes
    in order to create these sub-objects using the `CreateDefaultSubobject` function,
    and to attach these components to `RootComponent`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要引用音频组件和粒子系统类，以便使用`CreateDefaultSubobject`函数创建这些子对象，并将这些组件附加到`RootComponent`。
- en: 'Add the following lines in order to create the default sub-object of the `ProjectileMovementSound`
    component, and to attach this component to `RootComponent`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行以创建`ProjectileMovementSound`组件的默认子对象，并将此组件附加到`RootComponent`：
- en: '[PRE45]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, add the following lines in order to create the default sub-object for
    the `ProjectileEffect` component, and to attach this component to `RootComponent`:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下行以创建`ProjectileEffect`组件的默认子对象，并将此组件附加到`RootComponent`：
- en: '[PRE46]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that you have created, initialized, and attached these two components to
    `RootComponent`, return to the Unreal Engine 4 editor to recompile and hot-reload
    these code changes.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经创建、初始化并将这两个组件附加到`RootComponent`，返回到Unreal Engine 4编辑器中重新编译并热重载这些代码更改。
- en: From the `Content Browser` interface, navigate to the `/MainCharacter/Projectile/`
    directory. Find the `BP_PlayerProjectile` asset and *double-click* it to open
    the Blueprint.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“内容浏览器”界面，导航到“/MainCharacter/Projectile/”目录。找到“BP_PlayerProjectile”资产，*双击*打开蓝图。
- en: In the `Components` tab, you will find the two new components you added using
    the preceding code. Observe that these components are attached to the `CollisionComp`
    component, also known as `RootComponent`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在“组件”选项卡中，您将找到使用前面的代码添加的两个新组件。请注意，这些组件附加到`CollisionComp`组件，也称为`RootComponent`。
- en: '*Left-click* to select the `ProjectileEffect` component and, within the `Details`
    panel, assign the `P_Env_Fire_Grate_01` VFX asset to this parameter, as shown
    in the following screenshot:![Figure 14.21: Now, you can apply the P_Env_fire_Grate_01
    VFX asset to the'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*选择`ProjectileEffect`组件，并在“详细信息”面板中将“P_Env_Fire_Grate_01” VFX资产分配给此参数，如下截图所示：![图14.21：现在，您可以将P_Env_fire_Grate_01
    VFX资产应用到'
- en: Particle System component you added earlier
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前添加的粒子系统组件
- en: '](img/B16183_14_21.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_21.jpg)'
- en: 'Figure 14.21: Now, you can apply the P_Env_fire_Grate_01 VFX asset to the Particle
    System component you added earlier'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21：现在，您可以将P_Env_fire_Grate_01 VFX资产应用到您之前添加的粒子系统组件
- en: 'Before assigning the audio component, let''s adjust the `Transform` of the
    `ProjectileEffect` VFX asset. Update the `Rotation` and `Scale` parameters of
    the `Transform` for the VFX so that they match what is shown in the following screenshot:![Figure
    14.22: The updated Transform of the particle system component'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分配音频组件之前，让我们调整`ProjectileEffect` VFX资产的`Transform`。更新VFX的`Transform`的`Rotation`和`Scale`参数，使其与以下截图中显示的内容匹配：![图14.22：粒子系统组件的更新变换
- en: so that it fits better with the projectile
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以便它更好地适应抛射物
- en: '](img/B16183_14_22.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_22.jpg)'
- en: 'Figure 14.22: The updated Transform of the particle system component so that
    it fits better with the projectile'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22：粒子系统组件的更新变换，以便更好地适应抛射物
- en: 'Navigate to the `Viewport` tab within the Blueprint to view these changes to
    the `Transform`. `ProjectileEffect` should look as follows:![Figure 14.23: Now,
    the fire VFX has been scaled and rotated appropriately'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到蓝图中的`Viewport`选项卡，查看`Transform`的这些更改。`ProjectileEffect`应该如下所示：![图14.23：现在，火焰VFX已经被适当地缩放和旋转
- en: '](img/B16183_14_23.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_23.jpg)'
- en: 'Figure 14.23: Now, the fire VFX has been scaled and rotated appropriately'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.23：现在，火焰VFX已经被适当地缩放和旋转
- en: Now that the VFX has been set up, *left-click* the `ProjectileMovementSound`
    component and assign `A_Ambient_Fire01_Cue` to this component.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在VFX已经设置好了，*左键单击*`ProjectileMovementSound`组件，并将`A_Ambient_Fire01_Cue`分配给该组件。
- en: 'Save and recompile the `BP_PlayerProjectile` Blueprint. Use `PIE` and observe
    that when you throw the projectile, it now shows the VFX asset and plays the assigned
    sound:![Figure 14.24: The player projectile now has a VFX and an SFX as it flies
    through the air'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新编译`BP_PlayerProjectile`蓝图。使用`PIE`并观察当你投掷抛射物时，它现在显示了VFX资产并播放了分配的声音：![图14.24：玩家抛射物现在在飞行时有了VFX和SFX
- en: '](img/B16183_14_24.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_24.jpg)'
- en: 'Figure 14.24: The player projectile now has a VFX and an SFX as it flies through
    the air'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.24：玩家抛射物现在在飞行时有了VFX和SFX
- en: With this exercise complete, the player projectile now has a VFX and an SFX
    that play together while it flies through the air. These elements bring the projectile
    to life and make the projectile much more interesting to use.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，玩家的抛射物现在有了一个VFX和一个SFX，它们在飞行时一起播放。这些元素使抛射物栩栩如生，并使其更有趣。
- en: Since the VFX and SFX are created as components of the projectile, they are
    also destroyed when the projectile is destroyed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 由于VFX和SFX是作为抛射物的组件创建的，它们在抛射物被销毁时也会被销毁。
- en: In the next exercise, you will add a particle notify and a sound notify to the
    `Throw` Animation Montage in order to provide more of an impact when the player
    throws the player projectile.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将向`Throw`动画蒙太奇添加一个粒子通知和一个声音通知，以便在玩家投掷抛射物时提供更多的影响。
- en: 'Exercise 14.11: Adding VFX and SFX Notifies'
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.11：添加VFX和SFX通知
- en: So far, you have been implementing polish elements to the game via C++, which
    is a valid means of implementation. In order to give variety, and to expand your
    knowledge of the Unreal Engine 4 toolset, this exercise will walk you through
    how to use notifies in Animation Montages to add particle systems and audio within
    the animation. Let's get started!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在通过C++实现游戏的抛光元素，这是一种有效的实现手段。为了增加变化，并扩展你对虚幻引擎4工具集的了解，这个练习将教你如何在动画蒙太奇中使用通知来添加粒子系统和音频。让我们开始吧！
- en: 'Much like the previous exercises, we will need to migrate assets from the `Action
    RPG` project to our `Super SideScroller` project. Please refer to *Exercise 14.09*,
    *Adding Effects When the Enemy Is Destroyed*, to learn how to install and migrate
    assets from the `Action RPG` project. Perform the following steps:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的练习一样，我们需要从`Action RPG`项目迁移资产到我们的`Super SideScroller`项目。请参考*练习14.09*，*当敌人被销毁时添加特效*，学习如何从`Action
    RPG`项目安装和迁移资产。执行以下步骤：
- en: Open the `ActionRPG` project and navigate to the `Content Browser` interface.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ActionRPG`项目，并导航到`Content Browser`界面。
- en: 'The two primary assets you are adding to the project are as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到项目中的两个主要资产如下：
- en: '[PRE47]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `P_Skill_001` particle system asset references additional assets such as
    *materials* and *textures* that are included in the `Effects` directory, while
    `A_Ability_FireballCast_Cue` references additional *sound wave* assets included
    in the `Assets` directory.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_Skill_001`粒子系统资产引用了`Effects`目录中包含的*材质*和*纹理*等其他资产，而`A_Ability_FireballCast_Cue`引用了`Assets`目录中包含的其他*声音波*资产。'
- en: The particle you will be using for the player when the projectile is thrown
    is called `P_Skill_001` and can be found in the `/Effects/FX_Particle/` directory.
    This is the same directory used by the `P_Goblin_Death` and `P_Env_Fire_Grate_01`
    VFX assets from the previous exercises. The sound you will be using for the enemy
    character destruction is called `A_Ambient_Fire01_Cue` and can be found in the
    `/Assets/Sounds/Ambient/` directory.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛射物被投掷时，玩家将使用的粒子是`P_Skill_001`，可以在`/Effects/FX_Particle/`目录中找到。这是之前练习中使用的`P_Goblin_Death`和`P_Env_Fire_Grate_01`
    VFX资产所使用的相同目录。你将用于敌人角色销毁的声音称为`A_Ambient_Fire01_Cue`，可以在`/Assets/Sounds/Ambient/`目录中找到。
- en: '*Right-click* on each of these assets in the `Content Browser` interface of
    the `Action RPG` project and select `Asset Actions` and then `Migrate`.'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`Action RPG`项目的`Content Browser`界面中的每个资产，然后选择`Asset Actions`，然后选择`Migrate`。'
- en: Make sure to choose the directory of the `Content` folder for your `Super SideScroller`
    project before confirming the migration.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认迁移之前，请确保选择`Super SideScroller`项目的`Content`文件夹的目录。
- en: Now that the assets you need have been migrated into your project, let's move
    on to adding the required notifies to the `AM_Throw` asset. Make sure to return
    to your `Super SideScroller` project before continuing with this exercise.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要的资产已经迁移到你的项目中，让我们继续添加所需的通知到`AM_Throw`资产。在继续进行这个练习之前，请确保返回到你的`Super SideScroller`项目。
- en: From the `Content Browser` interface, navigate to the `/MainCharacter/Animation/`
    directory. Find the `AM_Throw` asset and *double-click* it to open it.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`内容浏览器`界面，导航到`/MainCharacter/Animation/`目录。找到`AM_Throw`资产并*双击*打开它。
- en: Underneath the preview window in the center of the `Animation Montage` editor,
    find the `Notifies` section. This is the same section where you added `Anim_ProjectileNotify`
    earlier in this chapter.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`动画蒙太奇`编辑器中央的预览窗口下方，找到`通知`部分。这是您在本章早些时候添加`Anim_ProjectileNotify`的相同部分。
- en: 'To the right of the `Notifies` track, you will find a `+` sign that allows
    you to use additional notify tracks. *Left-click* to add a new track, as shown
    in the following screenshot:![Figure 14.25: It is useful to add multiple tracks
    to the timeline in order to keep things organized when adding multiple notifies'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`通知`轨道的右侧，您会找到一个`+`号，允许您使用额外的通知轨道。*左键单击*添加一个新轨道，如下图所示：![图14.25：在时间轴上添加多个轨道以在添加多个通知时保持组织
- en: '](img/B16183_14_25.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_25.jpg)'
- en: 'Figure 14.25: It is useful to add multiple tracks to the timeline in order
    to keep things organized when adding multiple notifies'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.25：在时间轴上添加多个轨道以在添加多个通知时保持组织
- en: In the same frame as `Anim_ProjectileNotify`, *right-click* within the new track
    you created in the previous step. From the `Add Notify` list, *left-click* to
    select `Play Particle Effect`.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`Anim_ProjectileNotify`相同的帧中，在上一步创建的新轨道内*右键单击*。从`添加通知`列表中*左键单击*选择`播放粒子效果`。
- en: Once created, *left-click* to select the new notify and access its `Details`
    panel. In `Details`, add the `P_Skill_001` VFX asset to the `Particle System` parameter.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，*左键单击*选择新通知并访问其`详细信息`面板。在`详细信息`中，将`P_Skill_001` VFX资产添加到`粒子系统`参数中。
- en: 'After you''ve added this new VFX, you will notice that the VFX is placed almost
    toward the bottom, where the player characters'' feet are, but not exactly where
    you want it. This VFX should be placed directly on the floor, or at the base of
    the character. The following screenshot demonstrates this location:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个新的VFX之后，您会注意到VFX几乎放在了玩家角色的脚下，但不完全是您想要的位置。这个VFX应该直接放在地板上，或者放在角色的底部。以下屏幕截图展示了这个位置：
- en: '![Figure 14.26: The location of the particle notify is not on the ground'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.26：粒子通知的位置不在地面上'
- en: '](img/B16183_14_26.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_26.jpg)'
- en: 'Figure 14.26: The location of the particle notify is not on the ground'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.26：粒子通知的位置不在地面上
- en: In order to fix this, you need to add a new `Socket` to the player character skeleton.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您需要向玩家角色骨架添加一个新的`插座`。
- en: Navigate to the `/MainCharacter/Mesh/` directory. *Double-click* the `MainCharacter_Skeleton`
    asset to open it.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/MainCharacter/Mesh/`目录。*双击*`MainCharacter_Skeleton`资产以打开它。
- en: From the `Skeleton` bone hierarchy on the left-hand side, *right-click* on the
    `Hips` bone and *left-click* to select the `Add Socket` option. Name this new
    socket `EffectSocket`.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的`骨骼`骨骼层次结构上，*右键单击*`Hips`骨骼，*左键单击*选择`添加插座`选项。将此新插座命名为`EffectSocket`。
- en: '*Left-click* this socket from the hierarchy of bones in order to view its current
    location. By default, its location is set to the same position as the `Hips` bone.
    The following screenshot shows this location:![Figure 14.27: The default location
    of this socket is in the center of the player skeleton'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*从骨骼层次结构中选择此插座，以查看其当前位置。默认情况下，其位置设置为与`Hips`骨骼相同的位置。以下屏幕截图显示了此位置：![图14.27：此插座的默认位置位于玩家骨架的中心'
- en: '](img/B16183_14_27.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_27.jpg)'
- en: '[PRE48]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This position will be closer to the ground and the player characters'' feet.
    The final location can be seen in the following screenshot:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位置将更靠近地面和玩家角色的脚。最终位置如下图所示：
- en: '![Figure 14.28: Moving the socket location to the base of the player skeleton'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.28：将插座位置移动到玩家骨架的底部
- en: '](img/B16183_14_28.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_28.jpg)'
- en: 'Figure 14.28: Moving the socket location to the base of the player skeleton'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.28：将插座位置移动到玩家骨架的底部
- en: Now that you have a location for the particle notify, return to the `AM_Throw`
    Animation Montage.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经有了粒子通知的位置，请返回到`AM_Throw`动画蒙太奇。
- en: Within the `Details` panel of the `Play Particle Effect` notify, there is the
    `Socket Name` parameter. Use `EffectSocket` as the name.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`播放粒子效果`通知的`详细信息`面板中，有`插座名称`参数。使用`EffectSocket`作为名称。
- en: Note
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If `EffectSocket` does not appear via the autocomplete, close and reopen the
    Animation Montage. Once reopened, the `EffectSocket` option should appear for
    you.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`EffectSocket`没有出现在自动完成中，请关闭并重新打开动画蒙太奇。重新打开后，`EffectSocket`选项应该会出现。
- en: 'Lastly, the scale of the particle effect is a little too big, so adjust the
    scale of the projectile so that its value is as follows:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，粒子效果的比例有点太大，因此调整投影物的比例，使其值如下：
- en: '[PRE49]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, when the particle effect is played via this notify, its position and scale
    will be correct, as shown here:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当通过此通知播放粒子效果时，其位置和比例将是正确的，如下所示：
- en: '![Figure 14.29: The particle now plays at the base of the player character
    skeleton'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.29：粒子现在在玩家角色骨架的底部播放'
- en: '](img/B16183_14_29.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_29.jpg)'
- en: 'Figure 14.29: The particle now plays at the base of the player character skeleton'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.29：粒子现在在玩家角色骨架的底部播放
- en: To add the `Play Sound` notify, add a new track to the `Notifies` timeline section;
    you should now have three in total.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`播放声音`通知，请在`通知`时间轴部分添加一个新轨道；现在总共应该有三个。
- en: 'On this new track, and at the same frame position as both the `Play Particle
    Effect` and `Anim_ProjectileNotify` notifies, *right-click* and select the `Play
    Sound` notify from the `Add Notify` selection. The following screenshot shows
    where to find this notify:![Figure 14.30: The Play Sound notify that you learned
    about earlier in this chapter'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新轨道上，并且与`播放粒子效果`和`Anim_ProjectileNotify`通知的帧位置相同，*右键单击*并从`添加通知`选择中选择`播放声音`通知。以下屏幕截图显示了如何找到此通知：![图14.30：您在本章中早些时候了解到的播放声音通知
- en: '](img/B16183_14_30.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_30.jpg)'
- en: 'Figure 14.30: The Play Sound notify that you learned about earlier in this
    chapter'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.30：您在本章早些时候了解到的Play Sound通知
- en: Next, *left-click* to select the `Play Sound` notify and access its `Details`
    panel.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键单击*选择`Play Sound`通知并访问其`Details`面板。
- en: From the `Details` panel, find the `Sound` parameter and assign `A_Ability_FireballCast_Cue`.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Details`面板中找到`Sound`参数，并分配`A_Ability_FireballCast_Cue`。
- en: 'With the sound assigned, when the `Throw` animation is played back, you will
    see the VFX play and you will hear the sound. The `Notifies` tracks should look
    as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 分配了声音后，当播放`Throw`动画时，您将看到VFX播放并听到声音。`Notifies`轨道应如下所示：
- en: '![Figure 14.31: The final notify set up on the Throw Animation Montage timeline'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.31：投掷动画蒙太奇时间轴上的最终通知设置'
- en: '](img/B16183_14_31.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_31.jpg)'
- en: 'Figure 14.31: The final notify set up on the Throw Animation Montage timeline'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.31：投掷动画蒙太奇时间轴上的最终通知设置
- en: Save the `AM_Throw` asset and use `PIE` to throw the player projectile.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`AM_Throw`资产并使用`PIE`来投掷玩家投射物。
- en: 'Now, when you throw the projectile, you will see the particle notify play the
    `P_Skill_001` VFX and you will hear the `A_Ability_FireballCast_Cue` SFX. The
    result will look as follows:![Figure 14.32: Now, when the player throws the projectile,
    powerful VFX and SFX are played'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您投掷投射物时，您将看到粒子通知播放`P_Skill_001` VFX，并听到`A_Ability_FireballCast_Cue` SFX。结果将如下所示：![图14.32：现在，当玩家投掷投射物时，会播放强大的VFX和SFX
- en: '](img/B16183_14_32.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_32.jpg)'
- en: 'Figure 14.32: Now, when the player throws the projectile, powerful VFX and
    SFX are played'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.32：现在，当玩家投掷投射物时，会播放强大的VFX和SFX
- en: With this final exercise complete, the player now plays powerful VFX and SFX
    when the player projectile is thrown. This gives the throw animation more power
    and it feels like the player character is using a lot of energy to throw the projectile.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个最后的练习后，玩家现在在投掷玩家投射物时会播放强大的VFX和SFX。这使得投掷动画更有力量，感觉就像玩家角色在用很多能量来投掷投射物。
- en: In the following final activity, you will use the knowledge you've gained from
    the last few exercises to add VFX and SFX to the player projectile when it is
    destroyed.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的最后一个活动中，您将利用您从最近几个练习中获得的知识，为玩家投射物在被销毁时添加VFX和SFX。
- en: 'Activity 14.02: Adding Effects for When the Projectile Is Destroyed'
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动14.02：为投射物销毁时添加效果
- en: In this final activity, you will use the knowledge that you've gained from adding
    VFX and SFX elements to the player projectile and the enemy character to create
    an explosion effect for when the projectile collides with an object instead. The
    reason we're adding this additional explosion effect is to add a level of polish
    on top of destroying the projectile when it collides with environment objects.
    It would look awkward and out of place if the player projectile were to hit an
    object and disappear without any audio or visual feedback from the player.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的活动中，您将利用您从为玩家投射物和敌人角色添加VFX和SFX元素中获得的知识，为投射物与物体碰撞时创建爆炸效果。我们添加这个额外的爆炸效果的原因是为了在销毁投射物与环境物体碰撞时增加一定的光泽度。如果玩家投射物撞击物体并在没有任何音频或视觉反馈的情况下消失，那将显得尴尬和不合时宜。
- en: You will add both a particle system and Sound Cue parameters to the player projectile
    and spawn these elements when the projectile collides with an object.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为玩家投射物添加粒子系统和声音提示参数，并在投射物与物体碰撞时生成这些元素。
- en: 'Perform the following steps to achieve the expected output:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现预期输出：
- en: Inside the `PlayerProjectile.h` header file, add a new particle system variable
    and a new sound base variable.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.h`头文件中，添加一个新的粒子系统变量和一个新的声音基础变量。
- en: Name the particle system variable `DestroyEffect` and name the sound base variable
    `DestroySound`.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粒子系统变量命名为`DestroyEffect`，将声音基础变量命名为`DestroySound`。
- en: In the `PlayerProjectile.cpp` source file, add the include for `UGameplayStatics`
    to the list of includes.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.cpp`源文件中，将`UGameplayStatics`的包含添加到包含列表中。
- en: Update the `APlayerProjectile::ExplodeProjectile()` function so that it now
    spawns both the `DestroyEffect` and `DestroySound` objects. Return to the Unreal
    Engine 4 editor and recompile the new C++ code. Inside the `BP_PlayerProjectile`
    Blueprint, assign the `P_Explosion` VFX, which is already included in your project
    by default, to the `Destroy Effect` parameter of the projectile.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`APlayerProjectile::ExplodeProjectile()`函数，使其现在生成`DestroyEffect`和`DestroySound`对象。返回虚幻引擎4编辑器并重新编译新的C++代码。在`BP_PlayerProjectile`蓝图中，将默认包含在您的项目中的`P_Explosion`
    VFX分配给投射物的`Destroy Effect`参数。
- en: Assign the `Explosion_Cue` SFX, which is already included in your project by
    default, to the `Destroy Sound` parameter of the projectile.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Explosion_Cue` SFX分配给投射物的`Destroy Sound`参数，该SFX已默认包含在您的项目中。
- en: Save and compile the player projectile Blueprint.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译玩家投射蓝图。
- en: Use `PIE` to observe the new player projectile's destruction VFX and SFX.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PIE`观察新的玩家投射物销毁VFX和SFX。
- en: 'The expected output is as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 14.33: Projectile VFX and SFX'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.33：投射物VFX和SFX'
- en: '](img/B16183_14_33.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_14_33.jpg)'
- en: 'Figure 14.33: Projectile VFX and SFX'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.33：投射物VFX和SFX
- en: With this activity complete, you now have experience with adding polish elements
    to the game. Not only have you added these elements through C++ code, but you've
    added elements through other tools from Unreal Engine 4\. At this point, you have
    enough experience to add particle systems and audio to your game without having
    to worry about how to implement these features.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，您现在已经有了为游戏添加光泽元素的经验。您不仅通过C++代码添加了这些元素，还通过虚幻引擎4的其他工具添加了这些元素。在这一点上，您已经有足够的经验来为您的游戏添加粒子系统和音频，而不必担心如何实现这些功能。
- en: Note
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned a lot about the importance of Visual and Audio
    Effects in the world of game development. Using a combination of C++ code and
    notifies, you were able to bring gameplay functionality to the player projectile
    and the enemy character colliding, as well as a layer of polish to this functionality
    by adding VFX and SFX. On top of this, you learned about how objects are spawned
    and destroyed in Unreal Engine 4.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了在游戏开发世界中视觉和音频效果的重要性。通过使用C++代码和通知的组合，您能够为玩家的抛射物和敌人角色的碰撞带来游戏功能，以及通过添加VFX和SFX来提升这些功能。除此之外，您还了解了在虚幻引擎4中如何生成和销毁对象。
- en: Moreover, you learned about how Animation Montages are played, both from Blueprints
    and through C++. By migrating the logic of playing the `Throw` Animation Montage
    from Blueprint to C++, you learned how both methods work and how to use both implementations
    for your game.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还了解了动画蒙太奇如何在蓝图和C++中播放。通过将从蓝图播放“投掷”动画蒙太奇的逻辑迁移到C++，您学会了两种方法的工作原理，以及如何为游戏使用这两种实现。
- en: By adding a new Animation Notify using C++, you were able to add this notify
    to the `Throw` Animation Montage, which allows the player to spawn the player
    projectile you created in the previous chapter. Through the use of the `UWorld->SpawnActor()`
    function, and adding a new socket to the player skeleton, you were able to spawn
    the player projectile at the exact frame of the `Throw` animation, and at the
    exact position that you wanted to.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用C++添加新的动画通知，您能够将此通知添加到“投掷”动画蒙太奇中，从而允许玩家生成上一章中创建的玩家抛射物。通过使用`UWorld->SpawnActor()`函数，并向玩家骨骼添加新的插座，您能够在“投掷”动画的确切帧和您想要的确切位置生成玩家抛射物。
- en: Lastly, you learned how to use the `Play Particle Effect` and `Play Sound` notifies
    within the Throw Animation Montage to add VFX and SFX to the throw of the player
    projectile. This chapter has given you the opportunity to learn about the different
    methods that exist inside Unreal Engine 4 when it comes to using VFX and SFX for
    your game.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学会了如何在“投掷”动画蒙太奇中使用“播放粒子效果”和“播放声音”通知，为玩家抛射物的投掷添加VFX和SFX。本章让您有机会了解虚幻引擎4中在游戏中使用VFX和SFX时存在的不同方法。
- en: Now that the player projectile can be thrown and destroy enemy characters, it
    is time to implement the final set of mechanics for the game. In the next chapter,
    you will create the collectibles that the player can collect, and you will also
    create a powerup for the player that will improve the players' movement mechanics
    for a short period of time.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家的抛射物可以被投掷并摧毁敌人角色，是时候实现游戏的最后一组机制了。在下一章中，您将创建玩家可以收集的可收集物品，并为玩家创建一个可以在短时间内改善玩家移动机制的增益道具。
