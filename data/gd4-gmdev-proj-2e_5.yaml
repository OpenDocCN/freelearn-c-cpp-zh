- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: '3D Minigolf: Dive into 3D by Building a Minigolf Course'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D迷你高尔夫：通过构建迷你高尔夫球场深入3D
- en: The previous projects in this book have been designed in 2D space. This is intentional
    to introduce the features and concepts of Godot while keeping the projects’ scopes
    limited. In this chapter, you’ll venture into the 3D side of game development.
    For some, 3D development feels significantly more difficult to manage. For others,
    it is more straightforward. In either case, there is certainly an additional layer
    of complexity for you to understand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前面的项目都是设计在2D空间中的。这是故意的，为了在保持项目范围有限的同时介绍Godot的功能和概念。在这一章中，你将进入游戏开发的3D领域。对于一些人来说，3D开发感觉管理起来要困难得多。对于其他人来说，它可能更直接。无论如何，你确实需要理解一个额外的复杂层。
- en: If you’ve never worked with any kind of 3D software before, you may find yourself
    encountering many new concepts. This chapter will explain them as much as possible,
    but remember to refer to the Godot documentation whenever you need a more in-depth
    understanding of a particular topic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过任何类型的3D软件，你可能会发现自己遇到了许多新概念。这一章将尽可能多地解释它们，但请记住，在需要更深入理解特定主题时，务必参考Godot文档。
- en: The game you’ll make in this chapter is called *3D Minigolf*. In it, you’ll
    build a small minigolf course, a ball, and an interface for aiming and shooting
    the ball toward the hole.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中将要制作的游戏叫做*3D迷你高尔夫*。在其中，你将构建一个小型迷你高尔夫球场、一个球和一个瞄准并射击球向洞的方向的界面。
- en: 'Here are some of the things you’ll learn in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将学习到的一些内容如下：
- en: Navigating Godot’s 3D editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航Godot的3D编辑器
- en: '`Node3D` and its properties'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node3D`及其属性'
- en: Importing 3D meshes and using 3D collision shapes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入3D网格和使用3D碰撞形状
- en: How to use 3D cameras
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用3D相机
- en: Setting up lighting and environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置灯光和环境
- en: An introduction to PBR and materials
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PBR和材质简介
- en: Before diving in, a brief introduction to 3D in Godot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，简要介绍Godot中的3D。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Download the game assets from the following link and unzip them into your new
    project folder:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载游戏资源，并将其解压到你的新项目文件夹中：
- en: '[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到本章的完整代码：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf)
- en: Introduction to 3D
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D简介
- en: One of the strengths of Godot is its ability to handle both 2D and 3D games.
    Much of what you’ve learned earlier in this book will apply equally well in 3D
    – nodes, scenes, signals, etc. But changing from 2D to 3D also brings with it
    a whole new layer of complexity and capabilities. First, you’ll find that there
    are some additional features available in the 3D editor window, and it’s a good
    idea to familiarize yourself with how to navigate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Godot的一个优势是它能够处理2D和3D游戏。你在本书前面学到的许多内容在3D中同样适用——节点、场景、信号等。但是，从2D转换到3D也带来了一整个新的复杂性和功能层。首先，你会发现3D编辑器窗口中有一些额外的功能可用，熟悉如何导航是个好主意。
- en: Orienting in 3D space
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在3D空间中的定位
- en: 'Open a new project and click on the **3D** button at the top of the editor
    window to see the 3D project view:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的项目，然后在编辑器窗口顶部点击**3D**按钮，以查看3D项目视图：
- en: '![Figure 5.1: The 3D workspace](img/B19289_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：3D工作区](img/B19289_05_01.jpg)'
- en: 'Figure 5.1: The 3D workspace'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：3D工作区
- en: The first things you should notice are the three colored lines in the center.
    These are the `x` (red), `y` (green), and `z` (blue) axes. The point where they
    meet is the `(0,` `0, 0)`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该注意到的中心的三条彩色线条。这些是`x`（红色）、`y`（绿色）和`z`（蓝色）轴。它们相交的点就是`(0, 0, 0)`。
- en: 3D coordinates
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 3D坐标
- en: Just as you used `Vector2(x, y)` to indicate a position in 2D space, you’ll
    use `Vector3(x, y, z)` to describe a position in three dimensions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你使用`Vector2(x, y)`来表示2D空间中的位置一样，你将使用`Vector3(x, y, z)`来描述三维空间中的位置。
- en: One issue that often arises when working in 3D is that different applications
    use different conventions for orientation. Godot uses the `x` is pointing to the
    left/right, then `y` is up/down and `z` is forward/back. If you use other popular
    3D software, you may find that some of them use **Z-Up**. It’s good to be aware
    of this, as it can lead to confusion when moving between different programs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 3D 工作时经常出现的一个问题是，不同的应用程序使用不同的方向约定。Godot 使用 `x` 指向左/右，然后 `y` 是上/下，`z` 是前/后。如果您使用其他流行的
    3D 软件，您可能会发现其中一些使用 **Z-Up**。了解这一点是好的，因为它可以在在不同程序之间移动时导致混淆。
- en: 'Another important thing to be aware of is the unit of measure. In 2D, Godot
    measures everything in pixels, which makes sense as the natural basis for measurement
    when drawing on the screen. However, when working in 3D space, pixels aren’t really
    useful. Two objects of the same size will occupy different areas on the screen
    depending on how far away they are from the camera (more about cameras soon).
    For this reason, in 3D space, all objects in Godot are measured in generic units.
    While it’s most common to refer to them as “meters,” you’re free to call these
    units whatever you like: inches, millimeters, or even light years, depending on
    the scale of your game world.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要事项是度量单位。在 2D 中，Godot 以像素为单位测量一切，这在屏幕上绘制时作为测量的自然基础是有意义的。然而，当在 3D 空间中工作时，像素并不太有用。两个相同大小的对象将根据它们与摄像机的距离不同而占据屏幕上的不同区域（关于摄像机的更多信息即将揭晓）。因此，在
    3D 空间中，Godot 中的所有对象都使用通用单位进行测量。虽然通常将它们称为“米”，但您可以根据游戏世界的比例自由命名这些单位：英寸、毫米，甚至光年。
- en: Godot’s 3D editor
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Godot 的 3D 编辑器
- en: 'Before moving too deeply into building a game, it will be useful to review
    how to navigate in 3D space. The view camera is controlled using the mouse and
    keyboard:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入构建游戏之前，回顾如何在 3D 空间中导航将是有用的。视图摄像机使用鼠标和键盘控制：
- en: '*Mouse wheel up/down*: Zoom in/out on the current target'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*鼠标滚轮上下滚动*: 在当前目标上放大/缩小'
- en: '*Middle button* + *drag*: Orbit the camera around the current target'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中间按钮* + *拖动*: 围绕当前目标旋转摄像机'
- en: '*Shift* + *middle button* + *drag*: Pan the camera up/down/left/right'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift* + *中间按钮* + *拖动*: 摄像机向上/下/左/右平移'
- en: '*Right button* + *drag*: Rotate the camera in place'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*右键按钮* + *拖动*: 在原地旋转摄像机'
- en: Note that some of these movements are based on a camera target, or **focus**.
    To focus on an object in space, you can select it and press *F*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中一些动作是基于摄像机目标或**焦点**的。要聚焦于空间中的某个对象，您可以选中它并按 *F* 键。
- en: Freelook navigation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Freelook 导航
- en: If you’re familiar with popular 3D games such as *Minecraft*, you can press
    *Shift* + *F* to switch to FreeLook mode. In this mode, you can use the *W*/*A*/*S*/*D*
    keys to fly around the scene while aiming with the mouse. Press *Shift* + *F*
    again to exit FreeLook mode.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉流行的 3D 游戏，如 *Minecraft*，您可以按 *Shift* + *F* 切换到 FreeLook 模式。在此模式下，您可以使用
    *W*/*A*/*S*/*D* 键在场景中飞行，同时用鼠标瞄准。再次按 *Shift* + *F* 退出 FreeLook 模式。
- en: 'You can also affect the camera’s view by clicking on the **Perspective** label
    in the upper-left corner of the viewport. Here, you can snap the camera to a particular
    orientation such as **Top View** or **Front View**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过点击视口左上角的**透视**标签来影响摄像机的视图。在这里，您可以快速将摄像机定位到特定的方向，例如**俯视图**或**前视图**：
- en: '![Figure 5.2: Perspective menu](img/B19289_05_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：透视菜单](img/B19289_05_02.jpg)'
- en: 'Figure 5.2: Perspective menu'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：透视菜单
- en: This can be especially useful on large displays when combined with the use of
    multiple viewports. Click the **View** menu and you can split the screen into
    multiple views, allowing you to see an object from all sides simultaneously.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这在结合使用多个视口的大屏幕上特别有用。点击 **视图** 菜单，您可以将屏幕分割成多个视图，让您能够同时从各个方向看到对象。
- en: Keyboard shortcuts
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘快捷键
- en: Note that each of these menu options has a keyboard shortcut associated with
    it. You can click on **Editor** -> **Editor Settings** -> **3D** to see and adjust
    the keyboard shortcuts to your liking.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些菜单选项中的每一个都与一个键盘快捷键相关联。您可以通过点击 **编辑器** -> **编辑器设置** -> **3D** 来查看并调整您喜欢的键盘快捷键。
- en: Adding 3D objects
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 3D 对象
- en: 'It’s time to add your first 3D node. Just as all 2D nodes inherit from `Node2D`,
    which provides properties such as `Node3D`, which provides spatial properties.
    Add one to the scene and you’ll see the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加您的第一个 3D 节点了。就像所有 2D 节点继承自 `Node2D`，它提供了诸如 `Node3D` 这样的属性，它提供了空间属性。将一个添加到场景中，您将看到以下内容：
- en: '![Figure 5.3: Node3D with a gizmo](img/B19289_05_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：带有操纵杆的 Node3D](img/B19289_05_03.jpg)'
- en: 'Figure 5.3: Node3D with a gizmo'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：带有gizmo的Node3D
- en: That colorful object you see is not the node, but rather a 3D **gizmo**. The
    gizmo is a tool that allows you to move and rotate objects in space. The three
    rings control rotation, while the three arrows move the object along the three
    axes. Notice that the rings and arrows are color-coded to match the axis colors.
    The arrows move the object *along* the corresponding axis, while the rings rotate
    the object *around* a particular axis. There are also three small squares that
    lock one axis and allow you to move along the object in a plane.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的那个五彩斑斓的对象不是节点，而是一个3D**gizmo**。gizmo是一个工具，允许你在空间中移动和旋转对象。三个环控制旋转，而三个箭头沿着三个轴移动对象。注意，环和箭头是按照轴的颜色进行着色编码的。箭头沿着相应的轴移动对象，而环则围绕特定的轴旋转对象。还有三个小方块可以锁定一个轴，并允许你在对象的平面上移动。
- en: Take a few minutes to experiment and get familiar with the gizmo. Delete the
    node and add another if you find yourself getting lost.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间进行实验，熟悉gizmo。如果你发现自己迷失方向，可以删除节点并添加另一个。
- en: 'Sometimes the gizmo gets in the way. You can click on the mode icons to restrict
    yourself to only one type of transformation: **Movement**, **Rotation**, or **Scaling**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候gizmo会碍事。你可以点击模式图标来限制自己只进行一种类型的变换：**移动**、**旋转**或**缩放**：
- en: '![Figure 5.4: Select mode icons](img/B19289_05_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：选择模式图标](img/B19289_05_04.jpg)'
- en: 'Figure 5.4: Select mode icons'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：选择模式图标
- en: The *Q*/*W*/*E*/*R* keys are shortcuts for these buttons, allowing you to quickly
    change between modes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Q*/*W*/*E*/*R*键是这些按钮的快捷键，允许你快速在模式之间切换。'
- en: Global versus local space
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局空间与局部空间
- en: 'By default, the gizmo control operates in a global space. Try rotating the
    object – no matter how you turn it, the gizmo’s movement arrows still point along
    the global axes. Now try this: put the `Node3D` node back into its original position
    and orientation (or delete it and add a new one). Rotate the object around one
    axis and then click the **Use Local Space** button (note the **T** shortcut):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，gizmo控制操作在全局空间中。尝试旋转对象——无论你怎么转动它，gizmo的移动箭头仍然沿着全局轴指向。现在尝试这样做：将`Node3D`节点放回其原始位置和方向（或者删除它并添加一个新的）。围绕一个轴旋转对象，然后点击**使用局部空间**按钮（注意**T**快捷键）：
- en: '![Figure 5.5: Toggling Local Space mode](img/B19289_05_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：切换局部空间模式](img/B19289_05_05.jpg)'
- en: 'Figure 5.5: Toggling Local Space mode'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：切换局部空间模式
- en: Observe what happens to the gizmo arrows. They now point along the object’s
    *local* axes and not the world’s axes. When you click and drag the arrows, they
    move the object relative to its own rotation. You can toggle back to global space
    by clicking the button again. Switching back and forth between these two modes
    can make it much easier to place an object exactly where you want it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 观察gizmo箭头的指向。现在它们沿着对象的**局部**轴而不是世界轴指向。当你点击并拖动箭头时，它们会相对于对象的自身旋转移动对象。你可以再次点击按钮切换回全局空间。在这些两种模式之间切换可以使放置对象到你想要的位置变得容易得多。
- en: Transforms
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换
- en: Look at the Inspector for `Node3D`. Under the **Transform** section, you’ll
    see the node’s **Position**, **Rotation**, and **Scale** properties. As you move
    the object around, you’ll see these values change. Just as in 2D, these values
    are *relative* to the node’s parent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Inspector中的`Node3D`。在**变换**部分，你会看到节点的**位置**、**旋转**和**缩放**属性。当你移动对象时，你会看到这些值发生变化。就像在2D中一样，这些值是相对于节点的父节点**相对**的。
- en: 'Together, these three quantities make up the node’s `transform` property, which
    is a Godot `Transform3D` object. `Transform3D` has two sub-properties: `origin`
    and `basis`. The `origin` property represents the body’s position, while the `basis`
    property contains three vectors that define the body’s local coordinate axes.
    Think of the three axis arrows in the gizmo when you were in **Local** **Space**
    mode.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个量共同构成了节点的`transform`属性，这是一个Godot的`Transform3D`对象。`Transform3D`有两个子属性：`origin`和`basis`。`origin`属性表示物体的位置，而`basis`属性包含三个向量，这些向量定义了物体的局部坐标轴。当你处于**局部**空间模式时，想想gizmo中的三个轴箭头。
- en: You’ll see how to use these properties later in this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本节后面了解如何使用这些属性。
- en: Meshes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: Just like `Node2D`, a `Node3D` node has no size or appearance of its own. In
    2D, you added `Sprite2D` to display a texture attached to a node. In 3D, you’ll
    typically want to add a **mesh**. A mesh is a mathematical description of a three-dimensional
    shape. It consists of a collection of points called **vertices**. These vertices
    are connected by lines, called **edges**, and multiple edges (at least three)
    together make a **face**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Node2D`一样，`Node3D`节点没有自己的大小或外观。在2D中，你添加`Sprite2D`来显示节点上的纹理。在3D中，你通常想要添加一个**网格**。网格是三维形状的数学描述。它由称为**顶点**的点集合组成。这些顶点通过称为**边**的线连接，多个边（至少三个）共同构成一个**面**。
- en: 'A cube, for example, is composed of eight vertices, twelve edges, and six faces:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个立方体由八个顶点、十二条边和六个面组成：
- en: '![Figure 5.6: Vertices, edges, and faces](img/B19289_05_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6：顶点、边和面](img/B19289_05_06.jpg)'
- en: 'Figure 5.6: Vertices, edges, and faces'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：顶点、边和面
- en: If you’ve ever used 3D design software, this may already be familiar to you.
    If you haven’t, and you’re interested in learning about 3D modeling, *Blender*
    is a very popular open source tool for designing 3D objects. You can find many
    tutorials and lessons on the internet to help you get started with Blender.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过3D设计软件，这对你来说可能已经熟悉了。如果你还没有，并且你对学习3D建模感兴趣，*Blender*是一个非常流行的开源工具，用于设计3D对象。你可以在互联网上找到许多教程和课程，帮助你开始使用Blender。
- en: Primitives
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始形状
- en: 'If you haven’t already created or downloaded a 3D model, or if you just need
    a simple shape quickly, Godot has the ability to create certain 3D meshes directly.
    Add a `MeshInstance3D` node as a child of your `Node3D` node, and in the Inspector,
    look for the **Mesh** property:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建或下载3D模型，或者你只需要快速创建一个简单形状，Godot有直接创建某些3D网格的能力。将一个`MeshInstance3D`节点作为你的`Node3D`节点的子节点，然后在检查器中查找**网格**属性：
- en: '![Figure 5.7: Adding a new mesh](img/B19289_05_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7：添加新的网格](img/B19289_05_07.jpg)'
- en: 'Figure 5.7: Adding a new mesh'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：添加新的网格
- en: These predefined shapes are called **primitives**, and they represent a handy
    collection of common useful shapes. Select **New BoxMesh** and you’ll see a cube
    appear on the screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预定义的形状被称为**原始形状**，它们代表了一组常用的有用形状。选择**新建BoxMesh**，你将在屏幕上看到一个立方体出现。
- en: Importing meshes
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入网格
- en: 'Whatever modeling software you may use, you will need to export your models
    in a format that is readable by Godot. Godot supports a number of file formats
    for importing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么建模软件，你都需要将你的模型导出为Godot可读的格式。Godot支持多种文件格式用于导入：
- en: '`glTF` – supported in both text (`.gltf`) and binary (`.``glb`) versions'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glTF` – 支持文本（`.gltf`）和二进制（`.glb`）版本'
- en: '`DAE (COLLADA)` – an old format that is still supported'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAE (COLLADA)` – 尽管是旧格式，但仍然受到支持'
- en: '`OBJ (Wavefront)` – supported, but limited due to the format limitations'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJ (Wavefront)` – 受支持，但由于格式限制而有限'
- en: '`ESCN` – a Godot-specific file format that Blender can export'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ESCN` – Blender可以导出的Godot特定文件格式'
- en: '`FBX` – a commercial format that has limited support'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FBX` – 一个具有有限支持的商业格式'
- en: The recommended format is `.gltf`. It has the most features and is very well
    supported in Godot. See the appendix for details about exporting `.gltf` files
    from Blender for use in Godot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的格式是`.gltf`。它具有最多的功能，并且在Godot中得到了非常好的支持。有关从Blender导出`.gltf`文件以供Godot使用的详细信息，请参阅附录。
- en: You’ll see how to import some pre-built `.gltf` scenes later in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章后面看到如何导入一些预构建的`.gltf`场景。
- en: Cameras
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像机
- en: 'Try running the scene with your cube mesh. Where is it? In 3D, you won’t see
    anything in the game viewport unless you have a `Camera3D` camera in the scene.
    Add one, and you’ll see a new node that looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行带有你的立方体网格的场景。它在哪？在3D中，除非场景中有`Camera3D`摄像机，否则你不会在游戏视图中看到任何东西。添加一个，你将看到一个看起来像这样的新节点：
- en: '![Figure 5.8: Camera widget](img/B19289_05_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8：摄像机小部件](img/B19289_05_08.jpg)'
- en: 'Figure 5.8: Camera widget'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：摄像机小部件
- en: 'Use the camera’s gizmo to position it a little bit above and point toward the
    cube:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用摄像机的辅助工具将其放置在稍微高于位置并指向立方体：
- en: '![Figure 5.9: Aiming the camera](img/B19289_05_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9：调整摄像机方向](img/B19289_05_09.jpg)'
- en: 'Figure 5.9: Aiming the camera'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：调整摄像机方向
- en: The pinkish-purple, pyramid-shaped object is called the camera’s **frustum**.
    It represents the camera’s view and can be made narrow or wide to affect the camera’s
    **field of view**. The triangular shape at the top of the frustum indicates the
    camera’s “up” direction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那个粉紫色、金字塔形状的对象被称为摄像机的**视锥体**。它表示摄像机的视角，可以变窄或变宽以影响摄像机的**视野**。视锥体顶部的三角形形状表示摄像机的“向上”方向。
- en: As you’re moving the camera around, you can press the **Preview** button in
    the upper-right of the viewport to check what the camera sees. Go ahead and experiment
    with positioning the camera and adjusting its **FOV**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在周围移动摄像机时，您可以在视口的右上角按下**预览**按钮来检查摄像机看到的内容。您可以尝试调整摄像机的位置并调整其**FOV**。
- en: Orientation
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方向
- en: 'Note that the camera’s frustum faces along the `transform.basis` is the object’s
    local set of axes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，摄像机的视锥体沿着`transform.basis`方向是物体的局部坐标轴集：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These new concepts and editor functions will help you to navigate and work in
    3D space. Refer back to this section if you need a reminder of what a particular
    3D-related term means. In the next section, you’ll start setting up your first
    3D project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的概念和编辑器功能将帮助您在3D空间中导航和工作。如果您需要提醒某个特定3D相关术语的含义，请参考本节。在下一节中，您将开始设置您的第一个3D项目。
- en: Project setup
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Now that you’ve learned how to navigate in Godot’s 3D editor, you’re ready to
    start on the minigolf game. As with the other projects, download the game assets
    from the following link and unzip them into your project folder. The unzipped
    `assets` folder contains images, 3D models, and other items you’ll need to complete
    the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在Godot的3D编辑器中导航，您就可以开始制作迷你高尔夫游戏了。与其他项目一样，从以下链接下载游戏资源，并将其解压到您的项目文件夹中。解压后的`assets`文件夹包含您完成游戏所需的图像、3D模型和其他项目。
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并从[https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition)下载项目资源。
- en: You’ll notice a few different folders in `assets`. The `courses` folder has
    some pre-built minigolf holes for you to try out and compare to the ones you make.
    Don’t look at them yet – try and follow the steps to make your own first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`assets`中有几个不同的文件夹。`courses`文件夹包含一些预构建的迷你高尔夫洞，您可以尝试并比较您自己制作的洞。现在不要看它们——尝试按照步骤制作您自己的第一个。
- en: 'This game will use the left mouse click as an input. Open `click` and then
    click the plus sign to add the **Left Mouse Button** input to it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏将使用左键点击作为输入。打开`click`，然后点击加号将**左鼠标按钮**输入添加到其中：
- en: '![Figure 5.10: Assigning a mouse button input](img/B19289_05_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10：分配鼠标按钮输入](img/B19289_05_10.jpg)'
- en: 'Figure 5.10: Assigning a mouse button input'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：分配鼠标按钮输入
- en: 'While you’re in **Project Settings**, you can also set how the game behaves
    when the game window is resized. During gameplay, the user may choose to resize
    the window, which could disrupt the layout of your UI or show a distorted view
    of the game. To prevent this, navigate to the **Display/Window** section and find
    the **Stretch/Mode** setting. Change it to **viewport**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在**项目设置**中时，您还可以设置当游戏窗口大小调整时游戏的行为。在游戏过程中，用户可能会选择调整窗口大小，这可能会破坏您的UI布局或显示扭曲的游戏视图。为了防止这种情况，导航到**显示/窗口**部分并找到**拉伸/模式**设置。将其更改为**视口**：
- en: '![Figure 5.11: Setting window stretch mode](img/B19289_05_11.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11：设置窗口拉伸模式](img/B19289_05_11.jpg)'
- en: 'Figure 5.11: Setting window stretch mode'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：设置窗口拉伸模式
- en: 'That completes the setup of the project. Now, you can move on to building the
    first part of the game: the minigolf course.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了项目的设置。现在，您可以继续构建游戏的第一个部分：迷你高尔夫球场。
- en: Creating the course
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建课程
- en: For the first scene, add a `Node3D` node called `Hole` and save the scene. As
    you did in *Jungle Jump*, you’re going to make a generic scene containing all
    the nodes and code that any hole will need, then inherit from this scene to make
    as many individual holes as you want to have in the game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个场景，添加一个名为`Hole`的`Node3D`节点并保存场景。就像在*Jungle Jump*中做的那样，您将创建一个通用的场景，包含任何洞所需的节点和代码，然后从这个场景继承以创建游戏中您想要的任意数量的单独洞。
- en: Next, add a `GridMap` node to the scene.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向场景中添加一个`GridMap`节点。
- en: Understanding GridMaps
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解网格地图
- en: '`GridMap` is the 3D equivalent of the `TileMap` node you used earlier in the
    book. It allows you to use a collection of meshes (contained in a `MeshLibrary`
    collection – similar to `TileSet`) and lay them out in a grid. Because it operates
    in 3D, you can stack the meshes in any direction, although for this project you’ll
    stick to one plane.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridMap`是您在本书早期使用的`TileMap`节点的3D等价物。它允许您使用一个由`MeshLibrary`集合（类似于`TileSet`）包含的网格（网格）并按网格排列。因为它在3D中操作，所以您可以按任意方向堆叠网格，尽管在这个项目中您将坚持一个平面。'
- en: Making a MeshLibrary collection
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建网格库集合
- en: In the `res://assets/` folder, you’ll find a pre-generated `MeshLibrary` feature
    named `golf_tiles.tres` containing all the necessary course parts along with their
    collision shapes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `res://assets/` 文件夹中，你可以找到一个预先生成的 `MeshLibrary` 功能 `golf_tiles.tres`，其中包含所有必要的课程部分以及它们的碰撞形状。
- en: To create your own `MeshLibrary` function, you’ll make a 3D scene containing
    the individual meshes you want to use, add collisions to them, and then export
    that scene into a `MeshLibrary` collection. If you open `golf_tiles.tscn`, you’ll
    see the original scene that was used to create `golf_tiles.tres`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的 `MeshLibrary` 函数，你需要制作一个包含你想要使用的单个网格的 3D 场景，为它们添加碰撞，然后将该场景导出为 `MeshLibrary`
    集合。如果你打开 `golf_tiles.tscn`，你会看到用于创建 `golf_tiles.tres` 的原始场景。
- en: 'In this scene, you’ll see all the individual golf course tile meshes, as they
    were imported from Blender, where they were originally modeled. To add collision
    shapes to each one, Godot has a handy shortcut: select a mesh and you’ll see a
    **Mesh** menu appear in the toolbar at the top of the viewport:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，你会看到所有从 Blender 导入的单独高尔夫球场瓦片网格，它们最初是在 Blender 中建模的。为了给每个瓦片添加碰撞形状，Godot
    提供了一个方便的快捷方式：选择一个网格，你会在视口顶部的工具栏中看到一个 **网格** 菜单：
- en: '![Figure 5.12: The Mesh menu](img/B19289_05_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12：网格菜单](img/B19289_05_12.jpg)'
- en: 'Figure 5.12: The Mesh menu'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：网格菜单
- en: Select `StaticBody3D` node along with a `CollisionShape3D` node using the mesh’s
    data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格的数据选择 `StaticBody3D` 节点和 `CollisionShape3D` 节点。
- en: Once all the collisions are added, you can choose `GridMap` can use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有碰撞都添加完毕，你可以选择 `GridMap` 可以使用。
- en: Drawing the first hole
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制第一个洞
- en: Drag the `MeshLibrary` file into the `GridMap` node. You’ll see a list of the
    available tiles appear on the right side of the editor viewport.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MeshLibrary` 文件拖入 `GridMap` 节点。你会在编辑器视口的右侧看到一个可用的瓦片列表。
- en: To match the size of the tiles, set `(1,` `1, 1)`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配瓦片的大小，设置 `(1,` `1, 1)`。
- en: 'To make sure the collisions with the ball will look good, find `0.5`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保球与碰撞看起来很好，找到 `0.5`：
- en: '![Figure 5.13: Working with Physics Material](img/B19289_05_13.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13：使用物理材质](img/B19289_05_13.jpg)'
- en: 'Figure 5.13: Working with Physics Material'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：使用物理材质
- en: Try drawing by selecting a tile piece from the list and placing it in the scene
    by left-clicking. You can rotate a piece around the `y` axis by pressing **S**.
    To remove a tile, right-click on it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过从列表中选择瓦片块并将其通过左键点击放置在场景中来绘制。你可以通过按 **S** 键在 `y` 轴周围旋转一个块。要删除瓦片，右键点击它。
- en: 'For now, stick to a simple layout. You can get fancy later when everything
    is working:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，坚持简单的布局。当一切正常工作时，你可以变得复杂一些：
- en: '![Figure 5.14: Example course layout](img/B19289_05_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14：示例课程布局](img/B19289_05_14.jpg)'
- en: 'Figure 5.14: Example course layout'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：示例课程布局
- en: You can check out what this will look like when the game runs. Add a `Camera3D`
    feature to the scene and move it to a position where it can look down on the course.
    Remember, you can press **Preview** to check what the camera sees.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看游戏运行时的样子。将 `Camera3D` 功能添加到场景中，并将其移动到一个可以俯瞰课程的位置。记住，你可以按 **预览** 按钮检查相机看到的画面。
- en: Play the scene. You’ll notice that everything is very dark, unlike how it looks
    in the editor window. By default, a 3D scene has no *environment* or *lighting*
    configured.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 播放场景。你会注意到一切都非常暗，与编辑器窗口中的样子不同。默认情况下，3D 场景没有配置 *环境* 或 *光照*。
- en: Environment and lighting
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境和照明
- en: Lighting is a complex subject all on its own. Choosing where to place lights
    and how they’re configured can dramatically affect how a scene looks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 照明是一个复杂的主题。选择放置光源的位置以及它们的配置可以显著影响场景的外观。
- en: 'Godot provides three lighting nodes in 3D:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 在 3D 中提供了三个光照节点：
- en: '`OmniLight3D`: For light that is emitted in all directions, such as from a
    light bulb'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OmniLight3D`：用于从所有方向发射的光，例如来自灯泡'
- en: '`DirectionalLight3D`: Light from a distant source, such as sunlight'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirectionalLight3D`：来自远处的光源，例如阳光'
- en: '`SpotLight3D`: A cone-shaped light projected from a point, similar to a flashlight
    or lantern'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpotLight3D`：从一个点投射出的锥形光，类似于手电筒或灯笼'
- en: In addition to placing individual lights, you can also set up *ambient* light
    – light that is produced by the environment – using a `WorldEnvironment` node.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了放置单个光源外，你还可以使用 `WorldEnvironment` 节点设置 *环境* 光 – 由环境产生的光。
- en: 'Rather than start from scratch, Godot will let you start with the default lighting
    setup that you see in the editor window using the buttons in the toolbar:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是从头开始，Godot 允许你使用工具栏中的按钮从编辑器窗口中看到的默认照明设置开始：
- en: '![Figure 5.15: Lighting and environment settings](img/B19289_05_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15：照明和环境设置](img/B19289_05_15.jpg)'
- en: 'Figure 5.15: Lighting and environment settings'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：照明和环境设置
- en: The first two buttons allow you to toggle the preview sun (directional light)
    and environment. Note that the environment doesn’t just affect lighting, it generates
    a sky texture as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个按钮允许你切换预览太阳（方向光）和环境。请注意，环境不仅影响照明，还会生成天空纹理。
- en: If you click on the three dots, you can see the default settings for these.
    Click the `WorldEnvironment` node and a `DirectionalLight3D` node in your scene.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击三个点，你可以看到这些的默认设置。点击场景中的 `WorldEnvironment` 节点和 `DirectionalLight3D` 节点。
- en: If you zoom in on your mesh, you may notice that the shadows don’t look very
    good. The default shadow settings need to be adjusted, so select `DirectionalLight3D`
    and change `100` to `40`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你放大你的网格，你可能会注意到阴影看起来不太好。默认的阴影设置需要调整，所以选择 `DirectionalLight3D` 并将 `100` 改为
    `40`。
- en: Adding the hole
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加球洞
- en: Now that you have the course laid out, you need a way to detect when the ball
    falls into the hole.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经布置了球场，你需要一种方法来检测球是否掉入球洞。
- en: Add an `Area3D` node named `Hole`. This node works exactly like its 2D version
    – it can signal when a body enters its defined shape. Add a `CollisionShape3D`
    child to the area. In the `0.25` and `0.08`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `Hole` 的 `Area3D` 节点。这个节点与其 2D 版本完全一样——它可以在物体进入其定义的形状时发出信号。将一个 `CollisionShape3D`
    子节点添加到区域中。在 `0.25` 和 `0.08`。
- en: 'Position `Hole` where you placed the hole tile for your course. Make sure the
    cylinder shape doesn’t project above the top of the hole, or the ball will count
    as “in” when it hasn’t dropped in yet. You might find it useful to use the **Perspective**
    button and change to **Top View** to make sure you’ve got it centered properly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Hole` 放置在你为球场放置的球洞瓷砖的位置。确保圆柱形状不会投影到球洞顶部以上，否则球在还没有掉入时会被计为“在洞内”。你可能发现使用 **Perspective**
    按钮并切换到 **Top View** 来确保它正确居中很有用：
- en: '![Figure 5.16: Positioning the hole](img/B19289_05_16.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16：定位球洞](img/B19289_05_16.jpg)'
- en: 'Figure 5.16: Positioning the hole'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：定位球洞
- en: You also need to mark the starting position for the ball, so add a `Marker3D`
    node named `Tee` to the scene. Position it where you want the ball to start. Make
    sure you place it above the surface so that the ball doesn’t spawn inside the
    ground.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要标记球的起始位置，因此将一个名为 `Tee` 的 `Marker3D` 节点添加到场景中。将其放置在你希望球开始的位置。确保将其放置在表面之上，这样球就不会在地面内部生成。
- en: With that, you’re finished making the first course. Take a few minutes to look
    around and make sure you’re happy with the layout. Remember, this shouldn’t be
    a complex or challenging layout. It’s going to introduce the player to the game,
    and you’ll be using it to test that everything is working correctly later. To
    do that, you next need to create the golf ball.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就完成了第一轮次的制作。花几分钟时间四处看看，确保你对布局满意。记住，这不应该是一个复杂或具有挑战性的布局。它将向玩家介绍游戏，你也会用它来测试一切是否正常工作。为此，你接下来需要创建高尔夫球。
- en: Making the ball
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作球
- en: Since the ball needs physics – gravity, friction, collision with walls, and
    so on – `RigidBody3D` will be the best choice of node. Rigid bodies work similarly
    in 3D to the ones you’ve used before in 2D, and you’ll use the same methods to
    interact with them, such as `_integrate_forces()` and `apply_impulse()`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于球需要物理特性——重力、摩擦、与墙壁的碰撞等——因此 `RigidBody3D` 将是节点选择的最佳选择。刚体在 3D 中的工作方式与你在 2D 中使用的方式相似，你将使用相同的方法与它们交互，例如
    `_integrate_forces()` 和 `apply_impulse()`。
- en: Create a new scene with a `RigidBody3D` node named `Ball` and save it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为 `Ball` 的 `RigidBody3D` 节点，然后保存它。
- en: Since you need a simple sphere shape and Godot includes primitive shapes, there’s
    no need for a fancy 3D model here. Add a `MeshInstance3D` child and choose **New
    SphereMesh** for the **Mesh** property in the Inspector.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要一个简单的球体形状，而 Godot 包含原始形状，因此这里不需要复杂的 3D 模型。添加一个 `MeshInstance3D` 子节点，并在检查器中选择
    **New SphereMesh** 作为 **Mesh** 属性。
- en: The default size is much too large, so click on the `0.05` and `0.1`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认大小太大，所以点击 `0.05` 和 `0.1`。
- en: Add a `CollisionShape3D` node and give it a `SphereShape3D`. Set its `0.05`
    to match the mesh.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `CollisionShape3D` 节点，并给它一个 `SphereShape3D`。将其 `0.05` 设置与网格匹配。
- en: Testing the ball
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试球
- en: Add an instance of the `Ball` scene to your course. Position it over one of
    the tiles and play the scene. You should see the ball fall and land on the ground.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Ball` 场景的一个实例添加到你的课程中。将其放置在某个瓦片上方并播放场景。你应该看到球落下并落在地面上。
- en: You can also temporarily give the ball some motion by setting the `y`axis is
    up. Don’t forget to set it back to `(0, 0, 0)` before you move on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过设置 `y` 轴向上来暂时给球一些运动。不要忘记在继续之前将其设置回 `(0, 0, 0)`。
- en: Improving ball collisions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改善球碰撞
- en: You may have noticed when adjusting the velocity that the ball sometimes goes
    through the wall and/or bounces oddly, especially if you choose a high-velocity
    value. There are several things you can do to improve the ball’s behavior.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在调整速度时，球有时会穿过墙壁和/或以奇怪的方式弹跳，尤其是如果你选择了一个高速值。你可以做几件事情来改善球的行为。
- en: 'First, you can use **continuous collision detection** (**CCD**). Using CCD
    alters the way the physics engine calculates collisions. Normally, the engine
    operates by first moving the object and then testing for and resolving collisions.
    This is fast and works for most common situations. When using CCD, the engine
    projects the object’s movement along its path and attempts to predict where the
    collision may occur. This is slower (computationally) than the default behavior,
    especially when simulating many objects, but it is much more accurate. Since you
    only have one ball in a very small environment, CCD is a good option because it
    won’t introduce any noticeable performance penalty. You can find it in the Inspector
    as **Continuous CD**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用**连续碰撞检测**（**CCD**）。使用 CCD 改变了物理引擎计算碰撞的方式。通常，引擎通过首先移动对象，然后测试和解决碰撞来运行。这很快，并且适用于大多数常见情况。当使用
    CCD 时，引擎会沿着对象的路径预测其移动，并尝试预测碰撞可能发生的位置。这比默认行为（在计算上）要慢，尤其是在模拟许多对象时，但它要准确得多。由于你只有一个球，且环境非常小，因此
    CCD 是一个好的选择，因为它不会引入任何明显的性能惩罚。你可以在检查器中找到它作为**连续 CD**：
- en: "![Figure 5.17: The \uFEFFCCD toggle](img/B19289_05_17.jpg)"
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17：CCD 开关](img/B19289_05_17.jpg)'
- en: 'Figure 5.17: The CCD toggle'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：CCD 开关
- en: 'The ball also needs a little more action, so in the `0.25`. This property determines
    how “bouncy” a collision will be. The value can range from `0` (no bounce at all)
    to `1.0` (the bounciest):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 球也需要一点额外的动作，所以在 `0.25`。这个属性决定了碰撞会有多“弹跳”。值可以从 `0`（完全没有弹跳）到 `1.0`（最弹跳）：
- en: '![Figure 5.18: Physics material bounce settings](img/B19289_05_18.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18：物理材质弹跳设置](img/B19289_05_18.jpg)'
- en: 'Figure 5.18: Physics material bounce settings'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：物理材质弹跳设置
- en: You may also have noticed that the ball takes a long time to come to a complete
    stop. Set the `0.5` and `1`. These values can be thought of as analogous to air
    resistance – causing the object to slow down regardless of interaction with the
    surface. Increasing these means the player won’t have to wait as long for the
    ball to stop moving, and it won’t appear to be spinning in place after it stops
    rolling.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能已经注意到球需要很长时间才能完全停下来。设置 `0.5` 和 `1`。这些值可以被认为是与空气阻力相似——使物体减速，无论是否与表面相互作用。增加这些值意味着玩家不需要等待那么长时间球才会停止移动，而且球在停止滚动后不会看起来像是在原地旋转。
- en: You’re finished setting up the ball, but here’s another good place to pause
    and make sure you have everything the way you want it before moving on. Does the
    ball feel like it’s bouncing and rolling convincingly? When it hits a wall, does
    it bounce too much or too little? When you’ve adjusted the ball’s behavior to
    your satisfaction, move on to the next section, where you’ll set up how to launch
    the ball.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了球体的设置，但这里是一个好的地方可以暂停一下，确保在继续之前一切如你所愿。球感觉像是在弹跳和滚动吗？当它撞到墙壁时，弹跳是否过多或过少？当你对球的动作调整满意后，继续到下一部分，在那里你将设置如何发射球。
- en: Adding UI
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户界面
- en: 'Now that the ball is on the course, you need a way to aim and hit it. There
    are many possible control schemes for this type of game. For this project, you’ll
    use a two-step process:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在球已经在赛道上了，你需要一种方法来瞄准和击打它。对于这类游戏，有许多可能的控制方案。对于这个项目，你将使用两步过程：
- en: '**Aim**: An arrow appears, swinging back and forth. Clicking the mouse button
    sets the aim direction.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标**：出现一个箭头，来回摆动。点击鼠标按钮设置目标方向。'
- en: '**Shoot**: A power bar moves up and down. Clicking the mouse sets the power
    and launches the ball.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**射击**：一个力量条上下移动。点击鼠标设置力量并发射球。'
- en: Aiming the arrow
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对准箭头
- en: 'Drawing an object in 3D is not as easy as it is in 2D. In many cases, you’ll
    have to switch to a 3D modeling program such as Blender to create your game’s
    objects. However, in this case, Godot’s primitives will do fine. To make an arrow,
    you need two meshes: a long thin rectangle and a triangular prism.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 3D 中绘制对象不像在 2D 中那么容易。在许多情况下，你将不得不切换到 3D 建模程序，如 Blender，来创建你的游戏对象。然而，在这种情况下，Godot
    的原语将做得很好。要制作箭头，你需要两个网格：一个长而窄的矩形和一个三角棱柱。
- en: Making your own model
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 制作自己的模型
- en: If you’re comfortable using a separate 3D modeling program such as *Blender*,
    feel free to use that to create the arrow mesh instead of following the following
    procedure. Just drop the exported model into your Godot project folder and load
    it with a `MeshInstance3D` node. See the last chapter for details about importing
    models directly from Blender.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉使用单独的 3D 建模程序，如 *Blender*，请随意使用它来创建箭头网格而不是遵循以下步骤。只需将导出的模型放入你的 Godot 项目文件夹中，并用
    `MeshInstance3D` 节点加载它。请参阅最后一章中有关直接从 Blender 导入模型的详细信息。
- en: 'Start a new scene by adding a `Node3D` node called `Arrow` and give it a `MeshInstance3D`
    child. Give this mesh a `BoxMesh` function and set the box’s `(0.5, 0.2, 2)`.
    This will be the body of the arrow, but before moving on, there is a problem.
    If you rotate the parent node, the mesh rotates around its center. You need it
    to rotate around its end, so change the `MeshInstance3D` node to `(0, 0, -1)`.
    Remember, this property is measured relative to the node’s parent, so this is
    offsetting the mesh from the `Node3D` node:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个名为 `Arrow` 的 `Node3D` 节点并为其添加一个 `MeshInstance3D` 子节点来开始一个新的场景。给这个网格赋予一个
    `BoxMesh` 函数并设置盒子的 `(0.5, 0.2, 2)`。这将成为箭头的主体，但在继续之前，有一个问题。如果你旋转父节点，网格将围绕其中心旋转。你需要它围绕其末端旋转，所以将
    `MeshInstance3D` 节点更改为 `(0, 0, -1)`。记住，这个属性是相对于节点的父节点测量的，所以这是将网格从 `Node3D` 节点偏移：
- en: '![Figure 5.19: Offsetting the base](img/B19289_05_19.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19：偏移基础](img/B19289_05_19.jpg)'
- en: 'Figure 5.19: Offsetting the base'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：偏移基础
- en: Try rotating the root node (`Arrow`) with the gizmo to confirm that the shape
    is now offset correctly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 gizmo 旋转根节点（`Arrow`）以确认形状现在已正确偏移。
- en: When it’s viewed in the game, the arrow should be semi-transparent. You can
    also give it a color to make it stand out more. To change a mesh’s visual properties,
    you need to use **Material**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当它在游戏中查看时，箭头应该是半透明的。你也可以给它一个颜色，使其更加突出。要更改网格的视觉属性，你需要使用 **材质**。
- en: 'Under the mesh properties (where you set the size), you’ll see a `StandardMaterial3D`
    node in this box:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格属性（设置大小的地方）下，你会在该框中看到一个 `StandardMaterial3D` 节点：
- en: '![Figure 5.20: Offsetting the base](img/B19289_05_20.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20：偏移基础](img/B19289_05_20.jpg)'
- en: 'Figure 5.20: Offsetting the base'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：偏移基础
- en: If you click this new material object to expand it, you’ll see a long list of
    new properties. Don’t worry, there are only two that you need to change.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击这个新的材质对象以展开它，你会看到一个长长的属性列表。别担心，你只需要更改其中两个。
- en: First, expand the **Transparency** section and set **Transparency** to **Alpha**.
    This property tells the rendering engine that this object can allow light to pass
    through it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，展开 **透明度** 部分，并将 **透明度** 设置为 **Alpha**。此属性告诉渲染引擎该对象可以允许光线通过。
- en: Next, the color of an object is set in the `128`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对象的颜色在 `128` 中设置。
- en: Now, to create the pointy end of the arrow, add another `MeshInstance3D` node,
    and this time, choose a `PrismMesh` mesh. Set its `(1.5, 1.5, 0.2)` so that you
    have a flat triangular shape. To place it at the end of the rectangle, change
    its `0, 0, -2.75)` and its `(-90,` `0, 0)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建箭头的尖端，添加另一个 `MeshInstance3D` 节点，这次选择一个 `PrismMesh` 网格。将其设置为 `(1.5, 1.5,
    0.2)` 以获得一个平坦的三角形形状。为了将其放置在矩形的末端，将其更改为 `(0, 0, -2.75)` 和 `(-90, 0, 0)`。
- en: Finally, scale the whole arrow down by setting the root node’s `0.25,` `0.25,
    0.25)`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过设置根节点的 `0.25, 0.25, 0.25)` 将整个箭头缩小。
- en: 'You also need to set the prism’s material just as you did with the other section.
    To do this quickly, select the box shape and find its material property again.
    In the dropdown for the material, choose **Copy**. You can then go to the prism
    mesh and paste the same material onto it. Note that since they have the same material,
    any change you make to one shape will apply to both shapes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要像对待其他部分一样设置棱镜的材质。为此，快速选择盒子形状并再次找到其材质属性。在材质下拉菜单中选择 **复制**。然后你可以转到棱镜网格并将相同的材质粘贴到它上面。请注意，由于它们具有相同的材质，对其中一个形状所做的任何更改都将应用于两个形状：
- en: '![Figure 5.21: Positioning the arrow](img/B19289_05_21.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21：定位箭头](img/B19289_05_21.jpg)'
- en: 'Figure 5.21: Positioning the arrow'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：定位箭头
- en: Your aiming arrow is complete. Save the scene and instance it into your `Hole`
    scene.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你的瞄准箭头已完成。保存场景并将其实例化到你的 `Hole` 场景中。
- en: UI display
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 显示
- en: Create a new scene using a `CanvasLayer` layer named `UI`. In this scene, you’ll
    show the power bar as well as the shot count for the player’s score. Just as it
    did in 2D, this node will cause its contents to be drawn above the main scene.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 `UI` 的 `CanvasLayer` 层创建一个新的场景。在这个场景中，你将显示电力条以及玩家的得分次数。就像在 2D 中一样，这个节点将导致其内容被绘制在主场景之上。
- en: 'Add a `Label` node, then a `MarginContainer` node. In that, add a `VboxContainer`
    node, and in that, two `Label` nodes and a `TextureProgressBar` node. Name them
    as shown:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `Label` 节点，然后一个 `MarginContainer` 节点。在其中，添加一个 `VboxContainer` 节点，并在其中添加两个
    `Label` 节点和一个 `TextureProgressBar` 节点。按所示命名：
- en: '![Figure 5.22: The UI node layout](img/B19289_05_22.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22：UI 节点布局](img/B19289_05_22.jpg)'
- en: 'Figure 5.22: The UI node layout'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：UI 节点布局
- en: In the `MarginContainer` section, set `20`. Add the `Xolonium-Regular.ttf` font
    to both of the `Label` nodes and set their font sizes to `30`. Set the `Shots`
    to `PowerLabel` to **Power**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MarginContainer` 部分，设置 `20`。将 `Xolonium-Regular.ttf` 字体添加到两个 `Label` 节点中，并将它们的字体大小设置为
    `30`。将 `Shots` 设置为 `PowerLabel` 的 **Power**。
- en: Add the font for the `Message` label, using a larger font size of `80`, and
    set its text to `Get Ready!`. Choose **Center** from the **Anchor Presets** menu,
    then click the eye symbol next to the message to hide it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更大的字体大小 `80` 为 `Message` 标签添加字体，并将其文本设置为 `Get Ready!`。从 **锚点预设** 菜单中选择 **居中**，然后点击消息旁边的眼睛符号以隐藏它。
- en: Drag one of the colored bar textures from `res://assets` into the `PowerBar`.
    By default, `TextureProgressBar` grows from left to right, so for a vertical orientation,
    change **Fill Mode** to **Bottom to Top**. Change **Value** to a few different
    values to see the result.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `res://assets` 中的一个彩色条纹理拖放到 `PowerBar` 中。默认情况下，`TextureProgressBar` 从左向右增长，因此对于垂直方向，将
    **填充模式** 更改为 **从下到上**。将 **值** 设置为几个不同的值以查看结果。
- en: 'The completed UI layout should look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的 UI 布局应如下所示：
- en: '![Figure 5.23: The UI preview](img/B19289_05_23.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23：UI 预览](img/B19289_05_23.jpg)'
- en: 'Figure 5.23: The UI preview'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23：UI 预览
- en: Add an instance of `UI` in the `Hole` scene. Because it’s `CanvasLayer`, it
    will be drawn on top of the 3D camera view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Hole` 场景中添加 `UI` 的一个实例。因为它是 `CanvasLayer`，它将被绘制在 3D 摄像机视图之上。
- en: Now that you’ve finished drawing the course and you’ve added the UI, you have
    all of the visual elements that the player will see while playing. Your next task
    will be to make these parts work together by adding some code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了课程的绘制并添加了 UI，你拥有了玩家在游戏过程中将看到的全部视觉元素。你的下一个任务将通过添加一些代码使这些部分协同工作。
- en: Scripting the game
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏脚本编写
- en: 'In this section, you’ll create the scripts needed to make everything work together.
    The flow of the game will be as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建使一切协同工作的脚本。游戏流程如下：
- en: Place the ball at the `Tee`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球放置在 `Tee` 上。
- en: Switch to **Aim** mode and animate the arrow until the player clicks.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **Aim** 模式并动画化箭头，直到玩家点击。
- en: Switch to **Power** mode and animate the power bar until the player clicks.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **Power** 模式并动画化电力条，直到玩家点击。
- en: Launch the ball.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射球。
- en: Repeat the process from *step 2* until the ball falls into the hole.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从 *步骤 2* 开始的过程，直到球落入洞中。
- en: UI code
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 代码
- en: 'Add this script to the `UI` instance to update the UI elements:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本添加到 `UI` 实例中，以更新 UI 元素：
- en: '[PRE1]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These functions provide a way to update the UI elements when they need to display
    a new value. As you did in *Space Rocks*, changing the progress bar’s texture
    based on its value gives a nice low/medium/high feel to the power level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能提供了一种在需要显示新值时更新 UI 元素的方法。正如你在 *Space Rocks* 中所做的那样，根据进度条的值更改纹理，为电力水平提供了良好的低/中/高感觉。
- en: Main script
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主脚本
- en: 'Add a script to the `Hole` scene and start with these variables:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `Hole` 场景添加脚本，并从以下变量开始：
- en: '[PRE2]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `enum` lists the states the game can be in, while the `power` and `angle`
    variables will be used to set their respective values and change them over time.
    You can control the animation speed (and therefore the difficulty) by adjusting
    the two exported variables.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 列出了游戏可能处于的状态，而 `power` 和 `angle` 变量将用于设置它们各自的价值并在时间上改变它们。你可以通过调整两个导出变量来控制动画速度（因此难度）。'
- en: 'Next, set the initial values before starting to play:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在开始游戏之前设置初始值：
- en: '[PRE3]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The ball gets moved to the tee position, and you change to the `AIM` state to
    begin.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 球被移动到球座位置，然后你切换到 `AIM` 状态开始。
- en: 'Here’s what needs to happen for each game state:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个游戏状态，需要发生以下情况：
- en: '[PRE4]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`AIM` places the aiming arrow at the ball’s position and makes it visible.
    Recall that you offset the arrow, so it will appear to be pointing out from the
    ball. When you rotate the arrow, you’ll rotate it around the `y` axis so that
    it remains parallel to the ground.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIM` 将瞄准箭头放置在球的位置并使其可见。回想一下，你偏移了箭头，所以它看起来是从球向外指。当你旋转箭头时，你将在 `y` 轴周围旋转它，使其保持与地面平行。'
- en: Also, note that when entering the `SHOOT` state, you call the `shoot()` function
    on the ball, which you haven’t defined yet. You’ll add that in the next section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在进入 `SHOOT` 状态时，你在球上调用 `shoot()` 函数，但你还没有定义它。你将在下一节中添加它。
- en: 'The next step is to check for user input:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查用户输入：
- en: '[PRE5]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only input for the game (so far) is clicking the left mouse button. Depending
    on what state you’re currently in, clicking it will transition to the next state.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的唯一输入（到目前为止）是点击左鼠标按钮。根据你当前的状态，点击它将过渡到下一个状态。
- en: 'In `_process()`, you’ll determine what to animate based on the state. For now,
    it just calls the function that animates the appropriate property:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_process()` 中，你将根据状态确定要动画化的内容。目前，它只是调用动画化适当属性的函数：
- en: '[PRE6]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Both of these functions are similar. They gradually change a value between
    two extremes, reversing direction when the limit is reached. Note that the arrow
    is animating over a 180° range (+90° to -90°):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都很相似。它们在两个极端值之间逐渐改变一个值，当达到极限时反转方向。注意，箭头在 180° 范围内动画化（+90° 到 -90°）：
- en: '[PRE7]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To detect when the ball drops into the hole, select the `Area3D` node that
    you positioned at the hole and connect its `body_entered` signal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测球掉入洞中，选择你放置在洞中的 `Area3D` 节点并连接其 `body_entered` 信号：
- en: '[PRE8]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Lastly, the player will need to be able to start the whole process again after
    the ball comes to a stop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当球停止时，玩家将需要能够重新开始整个过程。
- en: Ball script
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球脚本
- en: In the ball’s script, there are two functions needed. First, an *impulse* must
    be applied to the ball to start it moving. Second, when the ball stops moving,
    it needs to notify the main scene so that the player can take the next shot.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在球的脚本中，需要两个函数。首先，必须对球施加一个*冲量*以启动其运动。其次，当球停止运动时，它需要通知主场景，以便玩家可以进行下一次投篮。
- en: 'Make sure you add this script to the `Ball` scene, not the instance of the
    ball in the `Hole` scene:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此脚本添加到 `Ball` 场景中，而不是 `Hole` 场景中的球实例：
- en: '[PRE9]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you saw in the *Space Rocks* game, you can use the physics state in `_integrate_forces()`
    to safely stop the ball if the speed has gotten very low. Due to floating point
    issues, the velocity may not slow to `0` on its own. Its `linear_velocity` value
    may be something like `0.00000001` for quite some time after it appears to stop.
    Rather than wait, you can just stop the ball if the speed falls below `0.1`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *Space Rocks* 游戏中看到的，你可以在 `_integrate_forces()` 中使用物理状态安全地停止球，如果速度变得非常低。由于浮点数问题，速度可能不会自行减慢到
    `0`。它的 `linear_velocity` 值可能在它看起来停止后的一段时间内仍然是 `0.00000001`。与其等待，你可以在速度低于 `0.1`
    时停止球。
- en: There’s also the chance that the ball happens to bounce over the wall and fall
    off the course. If this happens, you can reload the scene to let the player start
    over.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能发生球意外地弹过墙壁并掉出赛道的情况。如果发生这种情况，你可以重新加载场景，让玩家重新开始。
- en: 'Go back to the `Hole` scene and connect the `Ball` instance’s `stopped` signal:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `Hole` 场景并连接 `Ball` 实例的 `stopped` 信号：
- en: '[PRE10]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Testing it out
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: Try playing the scene. You should see the arrow rotating at the ball’s position.
    When you click the mouse button, the arrow stops, and the power bar starts moving
    up and down. When you click again, the ball is launched.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试播放场景。你应该看到箭头在球的位置旋转。当你点击鼠标按钮时，箭头停止，力量条开始上下移动。当你再次点击时，球被发射出去。
- en: If any of those steps don’t work, don’t go any further. Go back and try to find
    what you missed in the previous section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些步骤中的任何一个不起作用，不要继续前进。返回并尝试在上一个部分中找到你遗漏的内容。
- en: Once everything is working, you’ll notice some areas that need improvement.
    First, when the ball stops moving, the arrow may not point in the direction you
    want. The reason for this is that the starting angle is always `0`, which points
    along the `z`axis, and then the arrow swings +/-90° from there. In the next two
    sections, you’ll have a choice of two options for how to improve the aiming.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常后，你会注意到一些需要改进的区域。首先，当球停止移动时，箭头可能不会指向你想要的方向。这是因为起始角度始终是 `0`，它沿着 `z` 轴指向，然后箭头从那里摆动
    +/-90°。在接下来的两个部分中，你将有两个选项来改进瞄准。
- en: Option 1 for improving aiming
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高瞄准的选项1
- en: Aiming can be improved by pointing the 180° arc directly toward the hole at
    the beginning.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 瞄准可以通过在开始时直接将 180° 弧指向洞来改进。
- en: 'Add a variable called `hole_dir` to the top of the script. You can find this
    direction by using some vector math:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个名为 `hole_dir` 的变量。你可以通过一些向量数学找到这个方向：
- en: '[PRE11]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember that the ball’s position is its center, so it’s slightly above the
    surface, while the hole’s center is a bit below it. Because of this, a vector
    pointing from the ball to the hole would also point at a downward angle into the
    ground. To prevent this and keep the arrow level, you can use only the `x` and
    `z` values from the `position` to produce `Vector2`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，球的位置是其中心，所以它略微高于表面，而洞的中心则略低于它。因此，从球到洞的向量也会指向地面的向下角度。为了防止这种情况并保持箭头水平，你可以只使用
    `position` 中的 `x` 和 `z` 值来生成 `Vector2`。
- en: 'Now, the initial angle can be set when starting the `AIM` state:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以在启动 `AIM` 状态时设置初始角度：
- en: '[PRE12]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the animation of the arrow can use that initial direction as the basis
    for the +/-90° swing:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头的动画可以使用这个初始方向作为 +/-90° 摆动的基准：
- en: '[PRE13]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try playing again. The arrow should now always point in the general direction
    of the hole. This is better, but you still may have a difficult time aiming.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试玩游戏。现在箭头应该总是指向洞的大致方向。这更好，但你仍然可能难以瞄准。
- en: Option 2 for improving aiming
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高瞄准的选项2
- en: If you’d prefer to have more control over your aiming, then instead of animating
    the arrow and clicking to set the aim, you could directly control the arrow by
    moving the mouse side-to-side.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢对瞄准有更多控制，那么你可以直接通过移动鼠标左右来控制箭头，而不是通过动画箭头和点击来设置瞄准。
- en: 'To accomplish this, you can make use of one of Godot’s `InputEvent` types:
    `InputEventMouseMotion`. This event occurs whenever the mouse moves, and it includes
    a `relative` property representing how far the mouse moved in the previous frame.
    You can use this value to rotate that arrow by a small amount.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以使用 Godot 的 `InputEvent` 类型之一：`InputEventMouseMotion`。这个事件在鼠标移动时发生，并包括一个
    `relative` 属性，表示鼠标在上一个帧中移动的距离。你可以使用这个值来旋转箭头一个小量。
- en: First, disable the arrow animation by removing the `AIM` section from `_process()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过从 `_process()` 中移除 `AIM` 部分来禁用箭头动画。
- en: 'Add a variable so that you can control how much the arrow will rotate based
    on the mouse movement:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个变量，以便你可以根据鼠标移动来控制箭头的旋转程度：
- en: '[PRE14]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, write the following code to `_input()` to check for mouse movement and
    rotate the arrow:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `_input()` 中写入以下代码以检查鼠标移动并旋转箭头：
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Capturing the mouse
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕捉鼠标
- en: You may have noticed that as you’re moving the mouse, it can leave the game
    window, and when you click, you don’t interact with the game anymore. Most 3D
    games solve this problem by *capturing* the mouse – locking the mouse to the window.
    When you do this, you also need to give the player a way to free the mouse so
    that they can close the program or click on other windows, and a way to re-capture
    it to come back to the game.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当你移动鼠标时，它可能会离开游戏窗口，当你点击时，你不再与游戏交互。大多数3D游戏通过 *捕捉* 鼠标来解决这个问题——将鼠标锁定在窗口上。当你这样做时，你还需要为玩家提供一个释放鼠标的方法，以便他们可以关闭程序或点击其他窗口，以及一个重新捕捉鼠标的方法来回到游戏。
- en: For this game, you’ll capture the mouse at first, and then if the player presses
    *Esc*, free it and pause the game. Clicking in the game window will un-pause and
    resume.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这款游戏，你首先需要捕捉鼠标，然后如果玩家按下 *Esc*，释放鼠标并暂停游戏。在游戏窗口中点击将取消暂停并继续。
- en: 'All of this functionality is controlled through the `Input.mouse_mode` property.
    Then, `mouse_mode` can be set to one of the following values:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都通过 `Input.mouse_mode` 属性控制。然后，`mouse_mode` 可以设置为以下值之一：
- en: '`MOUSE_MODE_VISIBLE`: This is the default mode. The mouse is visible and free
    to move in and out of the window.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOUSE_MODE_VISIBLE`: 这是默认模式。鼠标可见，可以自由地在窗口内外移动。'
- en: '`MOUSE_MODE_HIDDEN`: The mouse cursor is hidden.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOUSE_MODE_HIDDEN`: 鼠标光标被隐藏。'
- en: '`MOUSE_MODE_CAPTURED`: The mouse is hidden and its position is locked to the
    window.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOUSE_MODE_CAPTURED`: 鼠标被隐藏，并且其位置被锁定到窗口。'
- en: '`MOUSE_MODE_CONFINED`: The mouse is visible, but confined to the window.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOUSE_MODE_CONFINED`: 鼠标可见，但被限制在窗口内。'
- en: 'Start by capturing the mouse in `_ready()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`_ready()`中捕获鼠标：
- en: '[PRE16]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `_process()`, you don’t want to animate things while the mouse is released:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_process()`中，当鼠标释放时，你不想对事物进行动画处理：
- en: '[PRE17]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To release the mouse, add this condition to `_input()`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放鼠标，在`_input()`中添加以下条件：
- en: '[PRE18]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, to re-capture the mouse when the window is clicked, add this right before
    `match_state`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当窗口被点击时，为了重新捕获鼠标，在`match_state`之前添加以下内容：
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Play the scene to try it out.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 播放场景以尝试它。
- en: Camera improvements
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相机改进
- en: Another problem, especially if you have laid out a relatively large course,
    is that if you place your camera near the tee, it won’t show the other parts of
    the course well, or at all. You need your camera to move, showing other parts
    of the course so the player can aim comfortably.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题，特别是如果你布置了一个相对较大的赛道，那就是如果你将相机放置在发球台附近，它将无法很好地显示赛道上的其他部分，甚至根本不显示。你需要你的相机移动，显示赛道的其他部分，以便玩家可以舒适地瞄准。
- en: 'There are two main ways you could address this problem:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的主要有两种方法：
- en: 'Multiple cameras: place several cameras at different locations around the course.
    Attach `Area3D` nodes to them, and when the ball enters a camera’s area, make
    that camera active by setting its `current` property to `true`.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多个相机：在赛道周围的不同位置放置几个相机。将`Area3D`节点附加到它们上，当球进入一个相机的区域时，通过将其`current`属性设置为`true`来激活该相机。
- en: 'Moving camera: stick to having one camera, but make it move along with the
    ball, so the player’s perspective is always based on the ball’s location.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动相机：坚持使用一个相机，但让它随着球移动，这样玩家的视角总是基于球的位置。
- en: Both of these schemes have pros and cons. Option 1 requires more planning, deciding
    exactly where to position the cameras, and how many to use. For that reason, this
    section will focus on option 2.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方案都有优点和缺点。选项1需要更多的规划，决定确切的位置放置相机，以及使用多少个。因此，本节将重点介绍选项2。
- en: In many 3D games, the player can control a camera that rotates and moves. Typically,
    this control scheme uses a combination of mouse and keyboard. Since you’re already
    using mouse movement for aiming (if you chose that option), the *W*/*A*/*S*/*D*
    keys are a good choice. The mouse wheel can be used to control the camera’s zoom.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多3D游戏中，玩家可以控制一个旋转和移动的相机。通常，这种控制方案使用鼠标和键盘的组合。由于你已经在瞄准时使用了鼠标移动（如果你选择了该选项），*W*/*A*/*S*/*D*键是一个不错的选择。鼠标滚轮可以用来控制相机的缩放。
- en: 'Add these new actions in the **Input** **Map** property:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在**输入** **映射**属性中添加这些新动作：
- en: '![Figure 5.24: Input map](img/B19289_05_24.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图5.24：输入映射](img/B19289_05_24.jpg)'
- en: 'Figure 5.24: Input map'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：输入映射
- en: Creating a gimbal
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建万向节
- en: 'The camera movement needs to have some restrictions. For one, it should always
    remain level and not become tilted side to side. Try this: take a camera and rotate
    it a small amount around `y` (the gizmo’s green ring), then a small amount around
    `x` (the red ring). Now, reverse the `y` rotation and click the **Preview** button.
    See how the camera has become tilted?'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 相机移动需要有一定的限制。一方面，它应该始终保持水平，不要向两侧倾斜。尝试这样做：拿一个相机，围绕`y`（工具箱的绿色环）旋转一小部分，然后围绕`x`（红色环）旋转一小部分。现在，反转`y`旋转并点击**预览**按钮。看看相机是否已经倾斜了吗？
- en: The solution to this problem is to place the camera on a `Node3D` nodes, which
    will control the camera’s left/right and up/down movement respectively.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将相机放置在`Node3D`节点上，这将分别控制相机的左右和上下移动。
- en: First, make sure to remove any other `Camera3D` nodes in the scene, so that
    you don’t have any conflict over which camera is being used.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保从场景中移除任何其他`Camera3D`节点，以免在哪个相机被使用上产生冲突。
- en: 'Create a new scene and add two `Node3D` nodes and a `Camera3D` node, naming
    them as shown in *Figure 5**.25*:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加两个`Node3D`节点和一个`Camera3D`节点，命名如*图5**.25*所示：
- en: '![Figure 5.25: Camera gimbal node setup](img/B19289_05_25.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图5.25：相机万向节节点设置](img/B19289_05_25.jpg)'
- en: 'Figure 5.25: Camera gimbal node setup'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：相机万向节节点设置
- en: Set the `Camera3D` to `(0, 0, 10)` so that it’s offset and looking toward the
    origin.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Camera3D`设置为`(0, 0, 10)`，使其偏移并朝向原点。
- en: 'Here’s how the gimbal works: the outer node is allowed to rotate *only* in
    `y`, while the inner one rotates *only* in `x`. You can try it yourself, but make
    sure to turn on **Use Local Space** (see the *Introduction to 3D space* section).
    Remember to only move the *green* ring of the outer gimbal node, and only the
    *red* ring of the inner one. Don’t change the camera at all. Reset all rotations
    back to zero once you’ve finished experimenting.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是万向节的工作原理：外节点允许仅在`y`轴上旋转，而内节点仅在`x`轴上旋转。您可以亲自尝试，但请确保开启**使用局部空间**（见*3D空间简介*部分）。记住，只移动外万向节节点的*绿色*环，以及内节点的*红色*环。不要改变相机。一旦您完成实验，将所有旋转重置为零。
- en: 'To control this motion in the game, attach a script to the root node and add
    the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制游戏中的这种运动，将脚本附加到根节点并添加以下内容：
- en: '[PRE20]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the right/left actions rotate the root `Node3D` node around
    its `y`axis, while the up/down actions rotate `GimbalInner` on its `x`axis. The
    entire gimbal system’s `scale` property is used to handle zooming. Finally, the
    rotation and zoom are limited by using `clamp()`, preventing the user from flipping
    the camera upside down or zooming too close or far away.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，左右动作旋转根`Node3D`节点绕其`y`轴，上下动作旋转`GimbalInner`绕其`x`轴。整个万向节系统的`scale`属性用于处理缩放。最后，通过使用`clamp()`限制旋转和缩放，防止用户将相机翻转过来或缩放得太近或太远。
- en: Add an instance of `CameraGimbal` to the `Hole` scene.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Hole”场景中添加一个`CameraGimbal`实例。
- en: 'The next step is to make the camera follow the ball. You can do this in `_process()`
    by setting the camera’s position to the ball’s:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让相机跟随球。您可以在`_process()`中通过设置相机的位置为球的位置来实现这一点：
- en: '[PRE21]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Play the scene and test that you can rotate and zoom the camera and that it
    moves when the ball when you make a shot.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 播放场景并测试您是否可以旋转和缩放相机，以及当您射击时球会移动。
- en: Designing a full course
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计完整课程
- en: 'Once the ball falls into the hole, the player should advance to play the next
    hole. Add this variable at the top of `hole.gd`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦球落入洞中，玩家应前进到下一个洞进行游戏。在`hole.gd`顶部添加此变量：
- en: '[PRE22]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will let you set the next hole that will be loaded. In the Inspector, select
    the **Next Hole** property to choose what scene to load next.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让您设置将要加载的下一个洞。在检查器中，选择**下一个洞**属性以选择下一个要加载的场景。
- en: 'Add the loading code in the `WIN` state:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WIN`状态中添加加载代码：
- en: '[PRE23]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Your `Hole` scene is intended to be the generic scaffold for building multiple
    holes the player can play through. Now that you have it working, you can use it
    to make multiple scenes using **Scene** -> **New** **Inherited Scene**.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您的“Hole”场景旨在成为构建多个玩家可以玩过的通用脚手架。现在您已经让它工作，您可以使用它通过**场景** -> **新建** **继承场景**来创建多个场景。
- en: 'Using this technique, you can make as many holes as you want and chain them
    together into the full golf course. Here’s the second hole in the example project:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，您可以创建尽可能多的洞，并将它们连接成完整的高尔夫球场。以下是在示例项目中的第二个洞：
- en: '![Figure 5.26: Example course layout](img/B19289_05_26.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图5.26：示例课程布局](img/B19289_05_26.jpg)'
- en: 'Figure 5.26: Example course layout'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：示例课程布局
- en: Visual effects
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉效果
- en: 'The appearance of the ball and the other meshes in your scene have been intentionally
    left very plain. You can think of the flat, white ball as a blank canvas, ready
    to be painted. First, a bit of vocabulary:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 球和其他网格在场景中的外观被有意地留得很简单。您可以将扁平的白色球视为空白画布，准备上色。首先，一些词汇：
- en: '**Textures**: Textures are flat, 2D images that are *wrapped* around 3D objects.
    Imagine wrapping a gift: the flat paper is folded around the package, conforming
    to its shape. Textures can be simple or complex, depending on the shape they’re
    designed to be applied to.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：纹理是围绕3D对象*包裹*的平面、2D图像。想象一下包裹礼物：扁平的纸张折叠在包裹上，适应其形状。纹理可以是简单的，也可以是复杂的，这取决于它们设计要应用的形状。'
- en: '`StandardMaterial3D`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StandardMaterial3D`.'
- en: '**Materials**: Godot uses a graphics rendering model called **Physically Based
    Rendering** (**PBR**). The goal of PBR is to render graphics in a way that accurately
    models the way light works in the real world. These effects are applied to meshes
    using their material property. Materials are essentially containers for textures
    and shaders. The material’s properties determine how the texture and shader effects
    are applied. Using Godot’s built-in material properties, you can simulate a wide
    range of physical materials, such as stone, cloth, or metal. If the built-in properties
    aren’t enough for your purposes, you can write your own shader code to add even
    more effects.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材料**: Godot 使用一种名为 **基于物理的渲染**（**PBR**）的图形渲染模型。PBR 的目标是渲染图形，使其能够准确模拟现实世界中光的行为。这些效果通过使用其材料属性应用于网格。材料本质上是一个纹理和着色器的容器。材料的属性决定了纹理和着色器效果的应用方式。使用
    Godot 内置的材料属性，你可以模拟各种物理材料，如石头、布料或金属。如果内置属性不足以满足你的需求，你可以编写自己的着色器代码来添加更多效果。'
- en: Adding materials
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加材料
- en: In the `Ball` scene, select `MeshInstance` and in its `StandardMaterial3D` node.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在“球”场景中，选择“MeshInstance”，并在其“StandardMaterial3D”节点中。
- en: Expand the material and you’ll see a large number of properties, far more than
    can be covered here. This section will focus on some of the most useful ones for
    making the ball look more appealing. You are encouraged to visit [https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html](https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html)
    for a full explanation of all the settings.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 展开材料，你会看到大量的属性，远超过这里所能涵盖的范围。本节将重点介绍一些制作球体更具吸引力的最有用属性。我们鼓励你访问 [https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html](https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html)
    以获得所有设置的完整解释。
- en: 'To begin, try experimenting with these parameters:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试对这些参数进行实验：
- en: '**Albedo**: This property sets the base color of the material. Change this
    to make the ball whatever color you’d like. If you’re working with an object that
    needs a texture, this is where you’d add it as well.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反照率**: 这个属性设置了材料的基色。更改它可以使球体呈现你想要的任何颜色。如果你正在处理需要纹理的对象，这里也是添加纹理的地方。'
- en: '`0` and `1`. The **Metallic** value controls *shininess*. Higher values will
    reflect more light, as with metallic substances. The **Roughness** value applies
    an amount of blur to the reflection. Lower values are more reflective, such as
    the polished surface of a mirror. You can simulate a wide variety of materials
    by adjusting these two properties. *Figure 5**.27* is a guide to how the **Roughness**
    and **Metallic** properties affect the appearance of an object. Keep in mind that
    lighting and other factors will alter the appearance as well. Understanding how
    light and reflections interact with surface properties is a big part of designing
    effective 3D objects:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 和 `1`。**金属**值控制**光泽度**。更高的值会反射更多光线，就像金属物质一样。**粗糙度**值对反射应用一定程度的模糊。较低的值更具有反射性，例如镜子的抛光表面。通过调整这两个属性，你可以模拟各种材料。*图
    5.27* 是一个关于 **粗糙度** 和 **金属** 属性如何影响物体外观的指南。请记住，照明和其他因素也会改变外观。理解光和反射如何与表面属性相互作用是设计有效
    3D 对象的重要组成部分：'
- en: '![Figure 5.27: Metallic and Roughness values](img/B19289_05_27.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27：金属和粗糙度值](img/B19289_05_27.jpg)'
- en: 'Figure 5.27: Metallic and Roughness values'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27：金属和粗糙度值
- en: '**Normal Map**: Normal mapping is a 3D graphics technique for simulating the
    appearance of bumps and dents on a surface. Modeling these in the mesh itself
    would result in a large increase in the number of polygons, or faces, making up
    the object, leading to reduced performance. Instead, a 2D texture is used that
    maps the pattern of light and shadow that would result from these small surface
    features. The lighting engine then uses that information to alter the reflection
    as if those details were actually there. A properly constructed normal map can
    add a great amount of detail to an otherwise bland-looking object.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线贴图**: 法线贴图是一种 3D 图形技术，用于模拟表面上的凹凸效果。在网格本身中建模这些效果会导致组成对象的三角形或面数大量增加，从而导致性能降低。相反，使用一个
    2D 纹理来映射这些小表面特征会产生光和影的模式。然后，照明引擎使用这些信息来改变反射，就像这些细节实际上存在一样。一个正确构建的法线贴图可以为原本看起来平淡无奇的对象添加大量细节。'
- en: 'The ball is a perfect example of a good use case for normal mapping because
    a real golf ball has hundreds of dimples on its surface, but the sphere primitive
    you’re using is a smooth surface. Using a regular texture could add spots, but
    they would look flat as if they were painted on the surface. A normal map to simulate
    those dimples would look like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 球体是一个很好的正常映射用例的例子，因为真实的高尔夫球在其表面有数百个凹坑，但你使用的球体原语是一个光滑的表面。使用常规纹理可能会添加斑点，但它们看起来会像涂在表面上的，显得很平。模拟这些凹坑的正常映射看起来会是这样：
- en: '![Figure 5.28: A normal map](img/B19289_05_28.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图5.28：正常映射](img/B19289_05_28.jpg)'
- en: 'Figure 5.28: A normal map'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28：正常映射
- en: The pattern of red and blue contains information telling the engine which direction
    it should assume the surface is facing at that point, and therefore which direction
    the light should bounce in that position. Note the stretching along the top and
    bottom – that’s because this image is made to be wrapped around a sphere shape.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 红色和蓝色的图案包含信息，告诉引擎在那个点表面应该朝向哪个方向，因此光线应该在那个位置反射的方向。注意顶部和底部的拉伸——这是因为这张图片是为了包裹球形形状而制作的。
- en: 'Enable the `res://assets/ball_normal_map.png` into the `-0.5` and `-1.0` works
    best:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 将`res://assets/ball_normal_map.png`启用到`-0.5`和`-1.0`，效果最佳：
- en: '![Figure 5.29: A ball with a normal map](img/B19289_05_29.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图5.29：带有正常映射的球体](img/B19289_05_29.jpg)'
- en: 'Figure 5.29: A ball with a normal map'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29：带有正常映射的球体
- en: Take some time to experiment with these settings and find a combination you
    like. Don’t forget to try playing the scene as well, as the ambient lighting of
    the `WorldEnvironment` feature will affect the final result.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间实验这些设置，找到你喜欢的组合。别忘了尝试播放场景，因为`WorldEnvironment`功能的周围照明会影响最终结果。
- en: In the next section, you’ll learn how to adjust the `WorldEnvironment` settings
    to change the look of the scene.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何调整`WorldEnvironment`设置以改变场景的外观。
- en: Lighting and Environment
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照明和环境
- en: You’ve been using the default lighting setup, which you added to your scene
    back in the first section. While you may be happy with this lighting setup, you
    can also adjust it to dramatically change the appearance of your game.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在使用默认的照明设置，这是你在第一部分中添加到场景中的。虽然你可能对这个照明设置感到满意，但你也可以调整它以显著改变游戏的外观。
- en: 'The `WorldEnvironment` node contains an `Environment` property that controls
    the background, sky, ambient light, and other aspects of the scene’s appearance.
    Select the node and click the property to expand it:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorldEnvironment`节点包含一个`Environment`属性，用于控制场景的背景、天空、环境光和其他外观方面。选择节点并点击属性以展开它：'
- en: '![Figure 5.30: Environment properties](img/B19289_05_30.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图5.30：环境属性](img/B19289_05_30.jpg)'
- en: 'Figure 5.30: Environment properties'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30：环境属性
- en: 'There are a lot of settings here, some of which are only really useful in specific
    advanced situations. However, these are the ones you’ll find yourself using the
    most often:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多设置，其中一些只在特定的高级情况下真正有用。然而，这些是你最常使用的：
- en: '`Sky` material. Sky materials can either be special textures that wrap around
    the scene (see the next game for an example) or one that’s automatically generated
    by the engine. The default sky that you’re using now is the latter: `ProceduralSkyMaterial`.
    Expand it to take a look at the properties – you can configure the sky’s colors
    and the sun’s appearance.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sky`材质。天空材质可以是围绕场景包裹的特殊纹理（参见下一节中的示例）或者由引擎自动生成的材质。你现在使用的默认天空材质是后者：`ProceduralSkyMaterial`。展开它查看属性——你可以配置天空的颜色和太阳的外观。'
- en: '**Ambient Light**: This is global light that affects all meshes with the same
    intensity. You can set its color and how much of it is generated by the sky. To
    see the effect, try setting the color to white and reducing the **Sky Contribution**
    a bit.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境光**：这是一种影响所有网格的全局光，强度相同。你可以设置其颜色以及由天空生成多少。为了看到效果，尝试将颜色设置为白色并稍微减少**天空贡献**。'
- en: '**Screen Space Reflection** (**SSR**), **Screen Space Ambient Occlusion** (**SSAO**),
    **Screen Space Indirect Lighting** (**SSIL**), and **Signed Distance Field Global**
    **Illumination** (**SDFGI**).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕空间反射**（**SSR**）、**屏幕空间环境遮挡**（**SSAO**）、**屏幕空间间接照明**（**SSIL**）和**有符号距离场全局照明**（**SDFGI**）。'
- en: These options provide more advanced control over how lighting and shadows are
    processed. An entire book could be written about the art of good lighting, but
    for the purposes of this section, you should know that each of these features
    introduces a tradeoff between realistic rendering and performance. Most advanced
    lighting features are not available at all for low-end devices, such as mobile
    or older PC hardware. If you’d like to learn more, the Godot documentation has
    an extensive introduction to the usage of these lighting features.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项提供了更高级的控制，以处理光照和阴影。关于良好光照的艺术可以写一本书，但为了本节的目的，你应该知道每个这些功能都引入了真实渲染和性能之间的权衡。大多数高级光照功能在低端设备上根本不可用，例如移动设备或较旧的PC硬件。如果你想了解更多，Godot文档提供了这些光照功能的广泛介绍。
- en: The **Glow** lighting feature simulates the filmic effect of light that “bleeds”
    into its surroundings, making objects appear to be emitting light. Note that this
    is different from the **Emission** property of materials, which causes objects
    to actually emit light. Glow is enabled by default, but at a very subtle setting
    that may not be apparent in bright lighting.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**Glow** 灯光功能模拟了光线“渗透”到周围环境中的电影效果，使物体看起来像是在发光。请注意，这与材料的**发射**属性不同，后者会使物体实际上发出光线。Glow默认启用，但设置非常微妙，在明亮的光照下可能不明显。'
- en: Feel free to experiment with the various environment settings. If you get completely
    lost and want to return to the default, delete the `WorldEnvironment` node, and
    you’ll be able to add the default version back again from the menu.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试各种环境设置。如果你完全迷失方向并想恢复默认设置，删除`WorldEnvironment`节点，然后你可以从菜单中再次添加默认版本。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to 3D development. One of Godot’s great strengths
    is that the same tools and workflow are used in both 2D and 3D. Everything you
    learned about the process of creating scenes, instancing, and using signals works
    in the same way. For example, an interface you build with control nodes for a
    2D game can be dropped into a 3D game and will work just the same.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了3D开发。Godot的一个巨大优势是，2D和3D中使用的工具和工作流程相同。你关于创建场景、实例化和使用信号的过程所学的所有内容在3D中同样适用。例如，你为2D游戏使用控制节点构建的界面可以放入3D游戏中，并且会以相同的方式工作。
- en: In this chapter, you learned how to navigate the 3D editor to view and place
    nodes using gizmos. You learned about meshes and how to quickly make your own
    objects using Godot’s primitives. You used `GridMap` to lay out your minigolf
    course. You learned about using cameras, lighting, and the world environment to
    design how your game will appear on the screen. Finally, you got a taste of using
    PBR rendering via Godot’s `SpatialMaterial` resource.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用操纵杆在3D编辑器中导航以查看和放置节点。你了解了网格以及如何使用Godot的原生功能快速创建自己的对象。你使用了`GridMap`来布置你的迷你高尔夫球场。你学习了如何使用相机、光照和世界环境来设计你的游戏在屏幕上的外观。最后，你尝试了通过Godot的`SpatialMaterial`资源使用PBR渲染。
- en: In the next project, you’ll continue working in 3D and extend your understanding
    of transforms and meshes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，你将继续在3D环境中工作，并扩展你对变换和网格的理解。
