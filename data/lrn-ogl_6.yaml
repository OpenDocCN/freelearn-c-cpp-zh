- en: Implementing a Skybox Using a Cubemap
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用立方体贴图实现天空盒
- en: In this chapter, we’ll create a skybox using a cubemap. So, let’s first understand
    what a cubemap is. It is a combination of multiple textures combined into a single
    texture, which is a cube. It is basically a series of six individual 2D textures
    that are mapped to a cube. They usually would have some sort of pattern to them,
    in a way that they actually flow from one side to the other. A skybox is essentially
    a cubemap, but a massive one. The player and the game world is essentially within
    that big cube. It encompasses the entire scene with six images of the game environment;
    if you, as a player, are inside a skybox and you try to look around, it would
    feel like you have a high-resolution world around you. And, if you try to reach
    for the edges of the cube you wouldn't be able to do that, because it's just infinitely
    far away from you. In this chapter, we’ll learn how to implement a skybox using
    a cubemap to create amazing worlds within your game
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用立方体贴图创建一个天空盒。因此，让我们首先了解什么是立方体贴图。它是由多个纹理组合成单个纹理，形成一个立方体。它基本上是一系列六个单独的
    2D 纹理，它们被映射到一个立方体上。它们通常会有某种图案，以这种方式从一侧流动到另一侧。天空盒本质上是一个立方体贴图，但非常大。玩家和游戏世界基本上位于这个大立方体内部。它包含整个场景的六个游戏环境图像；如果你作为一个玩家，身处天空盒中并试图环顾四周，你会感觉周围有一个高分辨率的宇宙。而且，如果你试图触摸立方体的边缘，你将无法做到，因为它离你无限远。在本章中，我们将学习如何使用立方体贴图实现天空盒，以在你的游戏中创建令人惊叹的世界。
- en: We’ll start by creating shaders for our Skybox.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的天空盒创建着色器。
- en: You can refer to all the code files for this chapter in the `Chapter06` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 的 `Chapter06` 文件夹中找到本章的所有代码文件。GitHub 链接可以在书的序言中找到。
- en: Creating shaders for the skybox
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为天空盒创建着色器
- en: 'As usual, we''ll begin with creating our shaders. We''ll initiate by duplicating
    our shader files, `core.vs`, and `core.frag`, and name those copied files as `skybox.vs`
    and `skybox.frag`. We''ll now carry out some modification on these shader files;
    take a look at the following steps to understand the changes that will be made:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将从创建我们的着色器开始。我们将复制我们的着色器文件 `core.vs` 和 `core.frag`，并将这些复制的文件命名为 `skybox.vs`
    和 `skybox.frag`。现在，我们将对这些着色器文件进行一些修改；看看以下步骤，以了解将要进行的更改：
- en: 'We''ll begin with making modifications to our `skybox.vs` shader. Take a look
    at the following code and implement the following modification in your shader
    file:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从修改我们的 `skybox.vs` 着色器开始。看看以下代码，并在你的着色器文件中实现以下修改：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have made the changes, save the file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 修改完成后，保存文件。
- en: 'Next, we''ll move on to `Skybox.frag` and carry out the following highlighted
    changes to the code:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转到 `Skybox.frag` 并对代码进行以下突出显示的更改：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save these changes to your shaders.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些更改保存到你的着色器中。
- en: Now we have modified our shader files to implement the skybox, we'll move on
    to make modifications to our `main.cpp` file and create our skybox.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了着色器文件以实现天空盒，我们将继续修改 `main.cpp` 文件并创建我们的天空盒。
- en: Modifications to the main.cpp file
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 main.cpp 文件的修改
- en: 'In the `main.cpp` file, there are a few changes we need to make. Follow the
    steps shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 文件中，我们需要做一些修改。遵循以下步骤：
- en: 'First of all, we need to create a new shader object, so before we define `GLfloat
    cubeVertices[]`, we need to add `Shader skyboxShader()`. And, to that we''ll pass
    the locations of our shader files: `"res/shaders/skybox.vs"` and `"res/shaders/skybox.frag"`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的着色器对象，因此在我们定义 `GLfloat cubeVertices[]` 之前，我们需要添加 `Shader skyboxShader()`。我们将向其中传递着色器文件的路径：`"res/shaders/skybox.vs"`
    和 `"res/shaders/skybox.frag"`。
- en: Next, we're going to need some more vertices for the skybox. Luckily, you can
    refer those to the `main.cpp` file present inside the `advanced_opengl` folder.
    Add these vertices to our code.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为天空盒添加更多的顶点。幸运的是，你可以参考位于 `advanced_opengl` 文件夹内的 `main.cpp` 文件中的那些顶点。将这些顶点添加到我们的代码中。
- en: Once you've got the skybox vertices all set up, you will need to create a vertex
    array object and vertex buffer object for the skybox. So, let's do that right
    now.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你设置了天空盒的顶点，你将需要为天空盒创建一个顶点数组对象和顶点缓冲区对象。所以，让我们现在就做吧。
- en: After we have defined `glBindVertexArray(0)`, we'll add `GLuint skyboxVAO` and
    `skyboxVBO;`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义了 `glBindVertexArray(0)` 之后，我们将添加 `GLuint skyboxVAO` 和 `skyboxVBO;`。
- en: Then, we'll add `glGenVertexArrays();` the vertex array is going to take the
    parameter `1` and then a skybox vertex array object, `skyboxVAO`. Next, we're
    going to generate the buffers into the skybox vertex buffer object.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加 `glGenVertexArrays();`，顶点数组将接受参数 `1`，然后是一个天空盒顶点数组对象，`skyboxVAO`。接下来，我们将生成缓冲区到天空盒顶点缓冲对象中。
- en: So, we'll add `glGenBuffers();` and to that we'll pass the parameter as `1`
    and `&skyboxVBO`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将添加 `glGenBuffers();` 并传递参数 `1` 和 `&skyboxVBO`。
- en: Then add `glBindVertexArray()`, and to that we'll pass `skyboxVAO`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加 `glBindVertexArray()`，我们将传递 `skyboxVAO` 给它。
- en: Next, we add `glBindBuffer()`, and for this we'll pass `GL_ARRAY_BUFFER` and
    `skyboxVBO`. It's very similar to what we've already done before in the previous
    chapters, so all of this should be very familiar.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加 `glBindBuffer()`，我们将传递 `GL_ARRAY_BUFFER` 和 `skyboxVBO`。这与我们在前几章中已经做过的非常相似，所以所有这些都应该非常熟悉。
- en: Add `glBufferData()`, and the first parameter it will take here is `GL_ARRAY_BUFFER`,
    and the size of the skybox vertices array. Next, we need to actually pass in `skyboxVertices`,
    and finally, we're just going to set it to `GL_STATIC_DRAW`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `glBufferData()`，这里它将接受的第一个参数是 `GL_ARRAY_BUFFER`，以及天空盒顶点数组的尺寸。接下来，我们需要实际传递
    `skyboxVertices`，最后，我们将它设置为 `GL_STATIC_DRAW`。
- en: 'Then we''ll add `GLEnableVertexAttribArray()`. We''re going to set this to
    `0`. Next, we''re going to add `glVertexAttribPointer()`. This is going to take
    `0`, `3`, `GL_FLOAT`, `GL_FALSE`, `3 * sizeof( GLfloat)`, `( GLvoid * ) 0`. Take
    a look at the following code to understand the description:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加 `GLEnableVertexAttribArray()`。我们将将其设置为 `0`。接下来，我们将添加 `glVertexAttribPointer()`。这将接受
    `0`，`3`，`GL_FLOAT`，`GL_FALSE`，`3 * sizeof( GLfloat)`，`( GLvoid * ) 0`。请查看以下代码以了解描述：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the Texture.h file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Texture.h 文件
- en: 'Next, we will actually load the textures, so what we''re going to do is create
    a separate texture file, and we''ll just have a method for loading the textures,
    and also a separate method for loading cube textures. The reason for doing this
    is we''re going to be using this code regularly, and it''s just that we have to
    rewrite these every single time. If we want to do multiple objects, especially,
    we don''t want to rewrite this every single time. Let''s take a look at the following
    steps to create the `Texture.h` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实际加载纹理，所以我们将创建一个单独的纹理文件，我们将有一个用于加载纹理的方法，还有一个用于加载立方体纹理的单独方法。这样做的原因是我们将经常使用此代码，而且我们每次都必须重写这些代码。如果我们想处理多个对象，尤其是，我们不希望每次都重写这些代码。让我们看看以下步骤来创建
    `Texture.h` 文件：
- en: First of all, we'll create an empty header file and name that as `Texture.h`,
    and add that to our project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个空的头文件，并将其命名为 `Texture.h`，然后将其添加到我们的项目中。
- en: 'Then, in `Texture.h`, we''ll add the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `Texture.h` 中，我们将添加以下代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, we'll add some header files, such as `#define GLEW_STATIC` (if you didn't
    statically link GLEW, then you don't need to put this line here), `#include <GL/glew.h>`,
    and `#include <vector>`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一些头文件，例如 `#define GLEW_STATIC`（如果你没有静态链接 GLEW，那么你不需要在这里放置此行），`#include
    <GL/glew.h>` 和 `#include <vector>`。
- en: Next, we'll create a class called `TextureLoading` and begin adding all our
    code to it.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `TextureLoading` 的类，并将所有代码添加到其中。
- en: We'll type `public`, and the first method we're going to have is a `static GLuint
    LoadTexture()` and to that we'll pass `GLchar *path`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将输入 `public`，我们将拥有的第一个方法是 `static GLuint LoadTexture()`，我们将传递 `GLchar *path`
    给它。
- en: Now, we'll go to our `main.cpp` file, and we'll cut and paste all the load and
    create textures and texture loading-related code, and paste it into the `LoadTextureMethod`
    that we created in the previous step.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将转到我们的 `main.cpp` 文件，并将所有加载和创建纹理以及纹理加载相关的代码剪切并粘贴到我们在上一步创建的 `LoadTextureMethod`
    中。
- en: 'Now, let''s have a look at what we need to change in here; check out the following
    highlighted code to understand the changes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看这里需要更改的内容；查看以下突出显示的代码以了解更改：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we go back to `main.cpp`, and add `#include Texture.h`, then come to the
    location in the code where we want to load textures, and there we''ll add the
    following to load our texture code: `GLuint cubeTexture = TextureLoading::LoadTexture(
    "res/images/container2.png" )` and also update the bind texture code, as highlighted
    here:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们回到 `main.cpp`，添加 `#include Texture.h`，然后来到代码中我们想要加载纹理的位置，在那里我们将添加以下代码来加载我们的纹理：`GLuint
    cubeTexture = TextureLoading::LoadTexture( "res/images/container2.png" )`，并且更新绑定的纹理代码，如这里所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s run it and check if our `Texture.h` code builds successfully, and
    that it compiles without any errors. You should get the following output on your
    screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它并检查我们的 `Texture.h` 代码是否成功构建，并且编译时没有错误。你应该在屏幕上看到以下输出：
- en: '![](img/3bae1e53-cba6-4a9d-9190-ca6f79006b2c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bae1e53-cba6-4a9d-9190-ca6f79006b2c.png)'
- en: This isn't the cubemap at the moment, as we were just sorting out the texturing,
    but making a separate texture will allow us to easily reuse texture loading.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这还不是立方体贴图，因为我们只是整理了纹理，但创建一个单独的纹理将使我们能够轻松地重用纹理加载。
- en: Adding cube mapping code to Texture.h
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将立方体贴图代码添加到 Texture.h
- en: 'So now, what we actually want to do is essentially the similar process as we
    did with the texture file, but for cube mapping. The code will be very similar,
    so to begin with what we are going to do is duplicate the texture loading code
    and paste below it. Then, we''ll make the following highlighted changes to the
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在实际上想要做的过程基本上与我们处理纹理文件时的过程相似，但针对立方体贴图。代码将非常相似，所以首先我们要做的是复制纹理加载代码并将其粘贴在下面。然后，我们将对代码进行以下突出显示的更改：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we added `GLchars` because we don't have one path; remember,
    we're going to have six different paths. Then, we created the `for` loop because
    we wanted to go over our six different images with ease, and also we didn't want
    to repeat the code, which was the whole point of doing what we're doing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了 `GLchars`，因为我们没有一条路径；记住，我们将会拥有六条不同的路径。然后，我们创建了 `for` 循环，因为我们想要轻松地遍历我们的六张不同图像，而且我们也不想重复代码，这正是我们这样做的主要目的。
- en: 'So, if we go back to our main file that is in our `main.cpp`, we can actually
    finish off what we were doing. Go to the section where we are loading our texture
    file, and after that code, add the following highlighted code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们回到我们的主文件，它位于我们的 `main.cpp` 中，我们实际上可以完成我们正在做的事情。转到我们加载纹理文件的段落，并在该代码之后添加以下突出显示的代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we added the cubemap texture. The order here does matter,
    so you can't just willy-nilly put it in. If you downloaded other images from a
    website, you might need to rearrange it properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了立方体贴图纹理。这里的顺序很重要，所以你不能随意放置它。如果你从网站上下载了其他图像，你可能需要正确地重新排列它。
- en: Drawing the skybox
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制天空盒
- en: 'Now, what we need to actually do is, well, draw the skybox, so let''s begin
    by following the steps shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上需要做的是，嗯，绘制天空盒，所以让我们开始按照这里显示的步骤进行：
- en: Go to the location in our code where we're done with all the model matrix stuff,
    and we're going to add `glDepthFunc()`; and in there, we need to pass `GL_LEQUAL`.
    This changes the depth function, so the depth test passes when values are equal
    to the depth buffer's content.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们的代码中处理完所有模型矩阵的地方，我们将添加 `glDepthFunc()`；在那里，我们需要传递 `GL_LEQUAL`。这改变了深度函数，所以当值等于深度缓冲区的内容时，深度测试通过。
- en: Next, we're going to add `skyboxShader.Use()`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `skyboxShader.Use()`。
- en: Then, add `view = glmm::mat4()`. And in here, we are going to pass `glm::mat3()`,
    and to that we'll pass `camera.GetViewMatrix()`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加 `view = glmm::mat4()`。在这里，我们将传递 `glm::mat3()`，并且我们将传递 `camera.GetViewMatrix()`。
- en: 'Next, add `glUniformMatrix4fv()`. For this, we will pass the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `glUniformMatrix4fv()`。为此，我们将传递以下内容：
- en: '`glGetUniformLocation( skyboxShader.Program, "view" ), 1, GL_FALSE, glm::value_ptr(
    view )`.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`glGetUniformLocation( skyboxShader.Program, "view" ), 1, GL_FALSE, glm::value_ptr(
    view )`。'
- en: 'We need to do something very similar for the projection matrix as well. So,
    we will add the following code: `glUniformMatrix4fv( glGetUniformLocation( skyboxShader.Program,
    "projection" ), 1, GL_FALSE, glm::value_ptr( projection ) );`.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要对投影矩阵做类似的事情。所以，我们将添加以下代码：`glUniformMatrix4fv( glGetUniformLocation( skyboxShader.Program,
    "projection" ), 1, GL_FALSE, glm::value_ptr( projection ) );`。
- en: Now what we need to do is just add the skybox cube. So, add `glBindVertexArray();`
    function and to that we'll pass `skyboxVAO`, and then add `glBindTexture()`. And
    for the bind texture function, it's going to be `GL_TEXTURE_CUBE_MAP`. Then, add
    the `cubemapTexture` that we call the `LoadCubemap` method.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要做的是添加天空盒立方体。所以，添加 `glBindVertexArray();` 函数，并将 `skyboxVAO` 传递给它，然后添加 `glBindTexture()`。对于绑定纹理函数，它将是
    `GL_TEXTURE_CUBE_MAP`。然后，添加我们通过 `LoadCubemap` 方法调用的 `cubemapTexture`。
- en: 'Then, add `glDrawArrays();`. And, the parameters we''ll pass are as follows:
    `GL_TRIANGLES`, `0`, `36`. Again, this is just a cube, so it''s very simple stuff.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加 `glDrawArrays();`。我们将传递的参数如下：`GL_TRIANGLES`，`0`，`36`。再次强调，这只是一个立方体，所以这只是一个非常简单的事情。
- en: Next, add `glBindVertexArray()`. For that, pass `0`, as we normally would.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`glBindVertexArray()`。为此，传递`0`，就像我们通常做的那样。
- en: Now, we just need to set the `glDepthFunc()` back, and to that we're going to
    pass `GL_LESS`; this just sets it back to default.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要将`glDepthFunc()`设置回默认值，我们将传递`GL_LESS`；这仅仅是将它设置回默认状态。
- en: 'And now, we should be ready to run, so let''s run this and check what output
    we get on the screen. We should get the following scene:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该准备好运行了，让我们运行这个程序并检查屏幕上显示的输出。我们应该看到以下场景：
- en: '![](img/2fb9e2cb-ad73-4ba2-9020-70d1ea3aa7e7.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fb9e2cb-ad73-4ba2-9020-70d1ea3aa7e7.png)'
- en: It literally does look like we've created a 3D world. If you try moving away,
    you can see the cube getting smaller and smaller. But, everything else is staying
    the same because we're going to be infinitely far away from all of the sides.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实看起来我们已经创建了一个3D世界。如果你尝试远离，你会看到立方体变得越来越小。但是，其他一切保持不变，因为我们将会无限远地远离所有侧面。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we generated a Skybox using a cubemap, and learned to apply
    various textures to it. We also learned how to create the separate texture file
    to load our textures in the code. Also, we learned how to draw the skybox and
    created our game world using it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用立方体贴图生成了一个Skybox，并学习了如何将其应用于各种纹理。我们还学习了如何在代码中创建单独的纹理文件来加载我们的纹理。此外，我们还学习了如何绘制Skybox，并使用它创建我们的游戏世界。
- en: 'There''s a bonus chapter for you on Model Loading on the following link: [https://www.packtpub.com/sites/default/files/downloads/ModelLoading.pdf](https://www.packtpub.com/sites/default/files/downloads/ModelLoading.pdf)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中有一个关于模型加载的附加章节：[https://www.packtpub.com/sites/default/files/downloads/ModelLoading.pdf](https://www.packtpub.com/sites/default/files/downloads/ModelLoading.pdf)
- en: In this chapter, you'll learn how to setup Assimp (Open Asset Import Library)
    on Windows using CMake for all our Model Loading needs. You'll also get to learn
    how to create mesh class and Model class to handle loading of our model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Windows上使用CMake设置Assimp（Open Asset Import Library），以满足我们所有的模型加载需求。你还将学习如何创建网格类和模型类来处理我们的模型加载。
