["```cpp\nclass SpaceShip : public Drawable \n{ \nprivate: \n   Sprite m_Sprite; \n   // More private members \npublic: \n\n   virtual void draw(RenderTarget& target,  \n      RenderStates states) const; \n\n   // More public members \n\n}; \n\n```", "```cpp\nvoid SpaceShip::SpaceShip \n{ \n   // Set up the spaceship \n} \n\nvoid SpaceShip::draw(RenderTarget& target, RenderStates states) const \n{ \n   target.draw(m_Sprite, states); \n} \n\n// Any other functions \n\n```", "```cpp\nSpaceShip m_SpaceShip; \n// create other objects here \n// ... \n\n// In the draw function \n// Rub out the last frame \nm_Window.clear(Color::Black); \n\n// Draw the spaceship \nm_Window.draw(m_SpaceShip); \n// More drawing here \n// ... \n\n// Show everything we have just drawn \nm_Window.display(); \n\n```", "```cpp\nvoid drawThisObject(RenderWindow window) \n{ \n   window.draw(m_Sprite) \n} \n\n```", "```cpp\n playerHero.draw(m_Window); \n\n```", "```cpp\nvector<GameObject> m_GameObjects; \n// Code to initialise all game objects \n// Including tiles, characters, enemies, bullets and anything else \n\n// In the update function \nfor (i = m_GameObjects.begin(); i != m_GameObjects.end(); i++) \n{ \n   (*i).update(elapsedTime); \n} \n// That's it! \n\n// In the draw function \n// Rub out the last frame \nm_Window.clear(Color::Black); \n\nfor (i = m_GameObjects.begin(); i != m_GameObjects.end(); i++) \n{ \n   m_Window.draw(*i); \n} \n\n// Show everything we have just drawn \nm_Window.display(); \n// That's it! \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Particle \n{ \nprivate: \n   Vector2f m_Position; \n   Vector2f m_Velocity; \n\npublic: \n   Particle(Vector2f direction); \n\n   void update(float dt); \n\n   void setPosition(Vector2f position); \n\n   Vector2f getPosition(); \n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Particle.h\" \n\nParticle::Particle(Vector2f direction) \n{ \n\n   // Determine the direction \n   //m_Velocity = direction; \n   m_Velocity.x = direction.x; \n   m_Velocity.y = direction.y; \n} \n\nvoid Particle::update(float dtAsSeconds) \n{ \n   // Move the particle \n   m_Position += m_Velocity * dtAsSeconds; \n} \n\nvoid Particle::setPosition(Vector2f position) \n{ \n   m_Position = position; \n\n} \n\nVector2f Particle::getPosition() \n{ \n   return m_Position; \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"Particle.h\" \n\nusing namespace sf; \nusing namespace std; \n\nclass ParticleSystem : public Drawable \n{ \nprivate: \n\n   vector<Particle> m_Particles; \n   VertexArray m_Vertices; \n   float m_Duration; \n   bool m_IsRunning = false; \n\npublic: \n\n   virtual void draw(RenderTarget& target, RenderStates states) const; \n\n   void init(int count); \n\n   void emitParticles(Vector2f position); \n\n   void update(float elapsed); \n\n   bool running(); \n\n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include <SFML/Graphics.hpp> \n#include \"ParticleSystem.h\" \n\nusing namespace sf; \nusing namespace std; \n\nvoid ParticleSystem::init(int numParticles) \n{ \n   m_Vertices.setPrimitiveType(Points); \n   m_Vertices.resize(numParticles); \n\n   // Create the particles \n\n   for (int i = 0; i < numParticles; i++) \n   { \n      srand(time(0) + i); \n      float angle = (rand() % 360) * 3.14f / 180.f; \n      float speed = (rand() % 600) + 600.f; \n\n      Vector2f direction; \n\n      direction = Vector2f(cos(angle) * speed, \n         sin(angle) * speed); \n\n      m_Particles.push_back(Particle(direction)); \n\n   } \n\n} \n\n```", "```cpp\nvoid ParticleSystem::update(float dt) \n{ \n   m_Duration -= dt; \n   vector<Particle>::iterator i; \n   int currentVertex = 0; \n\n   for (i = m_Particles.begin(); i != m_Particles.end(); i++) \n   { \n      // Move the particle \n      (*i).update(dt); \n\n      // Update the vertex array \n      m_Vertices[currentVertex].position = (*i).getPosition(); \n\n      // Move to the next vertex \n      currentVertex++; \n   } \n\n   if (m_Duration < 0) \n   { \n      m_IsRunning = false; \n   } \n\n} \n\n```", "```cpp\nvoid ParticleSystem::emitParticles(Vector2f startPosition) \n{ \n   m_IsRunning = true; \n   m_Duration = 2; \n\n   vector<Particle>::iterator i; \n   int currentVertex = 0; \n\n   for (i = m_Particles.begin(); i != m_Particles.end(); i++) \n   { \n      m_Vertices[currentVertex].color = Color::Yellow; \n      (*i).setPosition(startPosition); \n\n      currentVertex++; \n   } \n\n} \n\n```", "```cpp\nvoid ParticleSystem::draw(RenderTarget& target, RenderStates states) const \n{ \n   target.draw(m_Vertices, states); \n} \n\n```", "```cpp\nbool ParticleSystem::running() \n{ \n   return m_IsRunning; \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"TextureHolder.h\" \n#include \"Thomas.h\" \n#include \"Bob.h\" \n#include \"LevelManager.h\" \n#include \"SoundManager.h\" \n#include \"HUD.h\" \n#include \"ParticleSystem.h\" \n\nusing namespace sf; \n\nclass Engine \n{ \nprivate: \n   // The texture holder \n   TextureHolder th; \n\n // create a particle system\n   ParticleSystem m_PS; \n\n   // Thomas and his friend, Bob \n   Thomas m_Thomas; \n   Bob m_Bob; \n\n```", "```cpp\nEngine::Engine() \n{ \n   // Get the screen resolution and create an SFML window and View \n   Vector2f resolution; \n   resolution.x = VideoMode::getDesktopMode().width; \n   resolution.y = VideoMode::getDesktopMode().height; \n\n   m_Window.create(VideoMode(resolution.x, resolution.y), \n      \"Thomas was late\", \n      Style::Fullscreen); \n\n   // Initialize the full screen view \n   m_MainView.setSize(resolution); \n   m_HudView.reset( \n      FloatRect(0, 0, resolution.x, resolution.y)); \n\n   // Inititialize the split-screen Views \n   m_LeftView.setViewport( \n      FloatRect(0.001f, 0.001f, 0.498f, 0.998f)); \n\n   m_RightView.setViewport( \n      FloatRect(0.5f, 0.001f, 0.499f, 0.998f)); \n\n   m_BGLeftView.setViewport( \n      FloatRect(0.001f, 0.001f, 0.498f, 0.998f)); \n\n   m_BGRightView.setViewport( \n      FloatRect(0.5f, 0.001f, 0.499f, 0.998f)); \n\n   // Can this graphics card use shaders? \n   if (!sf::Shader::isAvailable()) \n   { \n      // Time to get a new PC \n      m_Window.close(); \n   } \n\n   m_BackgroundTexture = TextureHolder::GetTexture( \n      \"graphics/background.png\"); \n\n   // Associate the sprite with the texture \n   m_BackgroundSprite.setTexture(m_BackgroundTexture); \n\n   // Load the texture for the background vertex array \n   m_TextureTiles = TextureHolder::GetTexture( \n      \"graphics/tiles_sheet.png\"); \n\n // Initialize the particle system\n   m_PS.init(1000); \n\n}// End Engine constructor \n\n```", "```cpp\n   // Update the HUD every m_TargetFramesPerHUDUpdate frames \n   if (m_FramesSinceLastHUDUpdate > m_TargetFramesPerHUDUpdate) \n   { \n      // Update game HUD text \n      stringstream ssTime; \n      stringstream ssLevel; \n\n      // Update the time text \n      ssTime << (int)m_TimeRemaining; \n      m_Hud.setTime(ssTime.str()); \n\n      // Update the level text \n      ssLevel << \"Level:\" << m_LM.getCurrentLevel(); \n      m_Hud.setLevel(ssLevel.str()); \n\n      m_FramesSinceLastHUDUpdate = 0; \n   } \n\n // Update the particles\n   if (m_PS.running())\n   {\n     m_PS.update(dtAsSeconds);\n   } \n\n}// End of update function \n\n```", "```cpp\n// Is character colliding with a regular block \nif (m_ArrayLevel[y][x] == 1) \n{ \n\n   if (character.getRight().intersects(block)) \n   { \n      character.stopRight(block.left); \n   } \n   else if (character.getLeft().intersects(block)) \n   { \n      character.stopLeft(block.left); \n   } \n\n   if (character.getFeet().intersects(block)) \n   { \n      character.stopFalling(block.top); \n   } \n   else if (character.getHead().intersects(block)) \n   { \n      character.stopJump(); \n   } \n} \n\n// More collision detection here once  \n// we have learned about particle effects \n\n// Has the character's feet touched fire or water?\n// If so, start a particle effect\n// Make sure this is the first time we have detected this\n// by seeing if an effect is already running\nif (!m_PS.running())\n{\n   if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)\n   {\n     if (character.getFeet().intersects(block))\n     {\n        // position and start the particle system\n        m_PS.emitParticles(character.getCenter());\n     }\n   }\n} \n\n// Has the character reached the goal? \nif (m_ArrayLevel[y][x] == 4) \n{ \n   // Character has reached the goal \n   reachedGoal = true; \n}  \n\n```", "```cpp\nvoid Engine::draw() \n{ \n   // Rub out the last frame \n   m_Window.clear(Color::White); \n\n   if (!m_SplitScreen) \n   { \n      // Switch to background view \n      m_Window.setView(m_BGMainView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_MainView \n      m_Window.setView(m_MainView);     \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n\n // Draw the particle system\n      if (m_PS.running())\n      {\n         m_Window.draw(m_PS);\n      } \n   } \n   else \n   { \n      // Split-screen view is active \n\n      // First draw Thomas' side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGLeftView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_LeftView \n      m_Window.setView(m_LeftView); \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n // Draw the particle system\n      if (m_PS.running())\n      {\n         m_Window.draw(m_PS);\n      } \n\n      // Now draw Bob's side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGRightView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_RightView \n      m_Window.setView(m_RightView); \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw bob \n      m_Window.draw(m_Bob.getSprite()); \n\n // Draw the particle system\n      if (m_PS.running())\n      {\n         m_Window.draw(m_PS);\n      }           \n   } \n\n   // Draw the HUD \n   // Switch to m_HudView \n   m_Window.setView(m_HudView); \n   m_Window.draw(m_Hud.getLevel()); \n   m_Window.draw(m_Hud.getTime()); \n   if (!m_Playing) \n   { \n      m_Window.draw(m_Hud.getMessage()); \n   } \n\n   // Show everything we have just drawn \n   m_Window.display(); \n} \n\n```", "```cpp\n// attributes from vertShader.vert \nvarying vec4 vColor; \nvarying vec2 vTexCoord; \n\n// uniforms \nuniform sampler2D uTexture; \nuniform float uTime; \n\nvoid main() { \n   float coef = sin(gl_FragCoord.y * 0.1 + 1 * uTime); \n   vTexCoord.y +=  coef * 0.03; \n   gl_FragColor = vColor * texture2D(uTexture, vTexCoord); \n} \n\n```", "```cpp\n//varying \"out\" variables to be used in the fragment shader \nvarying vec4 vColor; \nvarying vec2 vTexCoord; \n\nvoid main() { \n    vColor = gl_Color; \n    vTexCoord = (gl_TextureMatrix[0] * gl_MultiTexCoord0).xy; \n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; \n} \n\n```", "```cpp\n// Three views for the background \nView m_BGMainView; \nView m_BGLeftView; \nView m_BGRightView; \n\nView m_HudView; \n\n// Declare a sprite and a Texture for the background \nSprite m_BackgroundSprite; \nTexture m_BackgroundTexture; \n\n// Declare a shader for the background\nShader m_RippleShader; \n\n// Is the game currently playing? \nbool m_Playing = false; \n\n// Is character 1 or 2 the current focus? \nbool m_Character1 = true; \n\n```", "```cpp\n// Can this graphics card use shaders?\nif (!sf::Shader::isAvailable())\n{\n   // Time to get a new PC\n   m_Window.close();\n}\nelse\n{\n   // Load two shaders (1 vertex, 1 fragment)\n   m_RippleShader.loadFromFile(\"shaders/vertShader.vert\",\n     \"shaders/rippleShader.frag\");} \n\nm_BackgroundTexture = TextureHolder::GetTexture( \n   \"graphics/background.png\"); \n\n```", "```cpp\nvoid Engine::draw() \n{ \n   // Rub out the last frame \n   m_Window.clear(Color::White); \n\n // Update the shader parameters\n   m_RippleShader.setUniform(\"uTime\", m_GameTimeTotal.asSeconds()); \n\n   if (!m_SplitScreen) \n   { \n      // Switch to background view \n      m_Window.setView(m_BGMainView); \n      // Draw the background \n //m_Window.draw(m_BackgroundSprite);\n\n     // Draw the background, complete with shader effect\n     m_Window.draw(m_BackgroundSprite, &m_RippleShader); \n\n      // Switch to m_MainView \n      m_Window.setView(m_MainView);     \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n\n      // Draw the particle system \n      if (m_PS.running()) \n      { \n         m_Window.draw(m_PS); \n      } \n   } \n   else \n   { \n      // Split-screen view is active \n\n      // First draw Thomas' side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGLeftView); \n      // Draw the background \n //m_Window.draw(m_BackgroundSprite);\n\n      // Draw the background, complete with shader effect\n      m_Window.draw(m_BackgroundSprite, &m_RippleShader); \n\n      // Switch to m_LeftView \n      m_Window.setView(m_LeftView); \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw the particle system \n      if (m_PS.running()) \n      { \n         m_Window.draw(m_PS); \n      } \n\n      // Now draw Bob's side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGRightView); \n      // Draw the background \n //m_Window.draw(m_BackgroundSprite);\n      // Draw the background, complete with shader effect\n      m_Window.draw(m_BackgroundSprite, &m_RippleShader); \n\n      // Switch to m_RightView \n      m_Window.setView(m_RightView); \n\n      // Draw the Level \n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw bob \n      m_Window.draw(m_Bob.getSprite()); \n\n      // Draw the particle system \n      if (m_PS.running()) \n      { \n         m_Window.draw(m_PS); \n      } \n\n   } \n\n   // Draw the HUD \n   // Switch to m_HudView \n   m_Window.setView(m_HudView); \n   m_Window.draw(m_Hud.getLevel()); \n   m_Window.draw(m_Hud.getTime()); \n   if (!m_Playing) \n   { \n      m_Window.draw(m_Hud.getMessage()); \n   } \n\n   // Show everything we have just drawn \n   m_Window.display(); \n} \n\n```"]