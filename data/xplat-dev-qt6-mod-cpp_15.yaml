- en: '*Chapter 12*: Performance Considerations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：性能考虑'
- en: In this chapter, we will give you an overview of performance optimization techniques
    and how you can apply them in the context of Qt-based application development.
    Performance is a very important factor in the success of your application. Performance
    failures can result in business failures, poor customer relationships, a reduction
    in competitiveness, and revenue loss. Delaying performance optimization can have
    a huge cost in terms of your reputation and organizational image. Therefore, it
    is important to do performance tuning.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述性能优化技术以及如何在基于Qt的应用程序开发环境中应用它们。性能是应用程序成功的非常重要的因素。性能失败可能导致业务失败、客户关系恶化、竞争力降低和收入损失。延迟性能优化可能会在声誉和组织形象方面产生巨大的成本。因此，进行性能调优非常重要。
- en: You will also learn about performance bottlenecks and how to overcome them.
    We will discuss different profiling tools to diagnose performance problems, focusing
    specifically on some popular tools. Then, you will learn how to profile and benchmark
    performance. The chapter also introduces **Qt Modeling Language** (**QML**) Profiler
    and Flame Graph to find underlying bottlenecks in your Qt Quick application. You
    will also learn about some best practices that you should follow while developing
    your Qt application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解性能瓶颈以及如何克服它们。我们将讨论不同的分析工具来诊断性能问题，特别关注一些流行的工具。然后，您将学习如何对性能进行分析和基准测试。本章还介绍了Qt建模语言（QML）分析器和火焰图，以找出Qt
    Quick应用程序中的潜在瓶颈。您还将了解在开发Qt应用程序时应遵循的一些最佳实践。
- en: 'We will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Understanding performance optimization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解性能优化
- en: Optimizing C++ code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化C++代码
- en: Using concurrency, parallelism, and multithreading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发、并行和多线程
- en: Profiling a Qt Quick application using QML Profiler and Flame Graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QML分析器和火焰图对Qt Quick应用程序进行分析
- en: Other Qt Creator analysis tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他Qt Creator分析工具
- en: Optimizing graphical performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化图形性能
- en: Creating benchmarks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基准测试
- en: Different analysis tools and optimization strategies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的分析工具和优化策略
- en: Performance considerations for Qt Widgets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt小部件的性能考虑
- en: Learning best practices of QML coding
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习QML编码的最佳实践
- en: By the end of the chapter, you will have learned to write high-performance optimized
    code for both C++- and QML-based applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学会为基于C++和QML的应用程序编写高性能优化代码。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest desktop platform such as Windows
    10, Ubuntu 20.04, or macOS 10.14.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新的桌面平台上安装Qt 6.0.0和Qt Creator 4.14.0的最低版本，如Windows 10、Ubuntu 20.04或macOS
    10.14。
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter12/QMLPerformanceDemo](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter12/QMLPerformanceDemo).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter12/QMLPerformanceDemo](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter12/QMLPerformanceDemo)。
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots used in this chapter are taken on the Windows platform. You
    will see similar screens based on the underlying platforms in your machine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的屏幕截图是在Windows平台上拍摄的。您将在您的机器上看到基于底层平台的类似屏幕。
- en: Understanding performance optimization
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解性能优化
- en: Performance optimization is done to improve an application's performance. You
    may be wondering why this is necessary. There are many reasons why an application
    requires performance optimization. When there is a performance problem reported
    by your users or the **quality assurance** (**QA**) team, the developers may discover
    something affecting the overall application performance. This may occur due to
    underlying hardware limitations, poor implementation of code, or scalability challenges.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化是为了提高应用程序的性能。您可能想知道为什么这是必要的。应用程序需要性能优化有很多原因。当用户或质量保证团队报告性能问题时，开发人员可能会发现影响整体应用程序性能的问题。这可能是由于底层硬件限制、代码实现不佳或可扩展性挑战引起的。
- en: Optimization is part of the application development process. This can involve
    optimizing code for performance or optimization for memory usage. Optimization
    aims to optimize an application's behavior so that it satisfies the product requirements
    for speed, memory footprint, power usage, and so on. As a result, optimization
    is almost as crucial as coding functionality in the production phase. Customers
    may report performance problems as glitches, slow response, and missing functionalities.
    A faster application executes more efficiently while consuming fewer resources
    and can handle more tasks in the same amount of time as a slower application.
    In today's competitive world, faster software means a competitive advantage over
    rivals. Performance matters a lot on embedded and mobile platforms, with factors
    such as speed, memory, and power consumption being prevalent.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是应用程序开发过程的一部分。这可能涉及对性能进行优化或对内存使用进行优化。优化旨在优化应用程序的行为，以满足产品对速度、内存占用、功耗等方面的要求。因此，优化几乎和在生产阶段编写功能一样重要。客户可能会报告性能问题，如故障、响应缓慢和功能缺失。更快的应用程序执行效率更高，同时消耗更少的资源，并且可以在相同的时间内处理更多的任务，而更慢的应用程序则不能。在当今竞争激烈的世界中，更快的软件意味着与竞争对手的竞争优势。性能在嵌入式和移动平台上非常重要，速度、内存和功耗等因素非常普遍。
- en: In a Waterfall process, performance improvement is carried out after application
    development, during the integration and verification phase. However, in today's
    Agile world, code performance should be evaluated every couple of sprints for
    overall application performance. Performance optimization is a continuous process,
    whereas defect fixing is a one-time task. It is an iterative process in which
    you will always find something to improve and there will be always scope for improvement
    in your application. According to the **Theory of Constraints** (**TOC**), there
    is typically one problem in a complex application that restricts the application
    from achieving its optimal performance. Such constraints are known as **bottlenecks**.
    An application's top performance is limited by bottlenecks, hence you should consider
    performance optimization during your application development life cycle. If ignored,
    your new product may become a complete disaster and may even ruin your reputation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在瀑布流程中，性能改进是在应用程序开发之后，在集成和验证阶段进行的。然而，在今天的敏捷世界中，代码性能应该在每两个迭代中进行评估，以提高整体应用程序性能。性能优化是一个持续的过程，而缺陷修复是一次性的任务。这是一个迭代的过程，在这个过程中，您总会发现有些地方可以改进，您的应用程序总会有改进的空间。根据约束理论，一个复杂应用程序通常会有一个限制应用程序达到最佳性能的问题。这些约束被称为瓶颈。一个应用程序的最佳性能受到瓶颈的限制，因此您应该在应用程序开发生命周期中考虑性能优化。如果忽视了这一点，您的新产品可能会变成一个完全的灾难，甚至可能会毁掉您的声誉。
- en: Before you jump into optimization, you should define a goal. Then, you should
    identify the bottleneck or the constraint. After that, think about how you can
    fix the constraint. You can improve your code and re-evaluate the performance.
    If it doesn't meet the set goal, you need to repeat the process. However, remember
    that premature optimization can be the root of all evil. You should implement
    the primary functionalities first before validating your product and implementing
    early users' feedback. Remember to make the application run first, then make its
    functionalities right, and then make it faster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行优化之前，您应该先确定一个目标。然后，您应该确定瓶颈或约束条件。之后，考虑如何解决约束条件。您可以改进您的代码并重新评估性能。如果达不到设定的目标，您需要重复这个过程。然而，请记住，过早的优化可能是万恶之源。在验证产品并实施早期用户反馈之前，您应该先实现主要功能。记住先让应用程序运行起来，然后确保其功能正确，最后再提高其速度。
- en: When you set a performance goal, you need to choose the right technique. There
    can be multiple goals, such as faster launch time, a smaller application binary,
    or less **random-access memory** (**RAM**) usage. One goal can impact another
    goal, so you have to find a balance based on the expected criteria—for example,
    optimizing the code for performance may impact memory optimization. There may
    be different ways to improve overall performance; however, you should also follow
    the organizational coding guidelines and best practices. If you are contributing
    to an open source project or are a freelance application developer, you should
    follow standard coding practices to maintain overall code quality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设定性能目标时，您需要选择正确的技术。可能会有多个目标，比如更快的启动时间、更小的应用程序二进制文件，或者更少的随机访问内存（RAM）使用。一个目标可能会影响另一个目标，因此您必须根据预期的标准找到平衡点，例如，为了性能而优化代码可能会影响内存优化。提高整体性能的方法可能有很多，但您也应该遵循组织的编码准则和最佳实践。如果您正在为一个开源项目做贡献或者是自由应用程序开发人员，您应该遵循标准的编码实践以保持整体代码质量。
- en: 'Some of the important tricks we will be following for performance improvement
    are listed as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循的一些重要技巧来提高性能如下：
- en: Using better algorithms and libraries
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更好的算法和库
- en: Using optimal data structures
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最佳数据结构
- en: Allocating memory responsibly and optimizing memory
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责分配内存和优化内存
- en: Avoiding unnecessary copying
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的复制
- en: Removing repeated computation
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除重复计算
- en: Increasing concurrency
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加并发性
- en: Using compiler binary optimization flags
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编译器二进制优化标志
- en: In the following sections, we will discuss opportunities to improve overall
    application performance in our C++ code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论如何改进我们的C++代码以提高整体应用程序性能的机会。
- en: Optimizing C++ code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化C++代码
- en: In most Qt applications, a significant part of the coding is done in C++, hence
    you should be aware of C++ optimization tricks. This section is about implementing
    some of the best practices while writing C++ code. When C++ implementations are
    written without optimization, they run slowly and consume a lot of resources.
    Better optimization of your C++ code also offers better control over memory management
    and copying. There are many opportunities to improve algorithms, ranging from
    small logical blocks to using **Standard Template Libraries** (**STLs**), to writing
    better data structures and libraries. There are several excellent books and articles
    on this topic. We will be discussing a few important points for running code faster
    and using fewer resources.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Qt应用程序中，很大一部分编码是用C++完成的，因此您应该了解C++优化技巧。本节是关于在编写C++代码时实施一些最佳实践。如果不对C++实现进行优化，它们会运行缓慢并消耗大量资源。更好地优化您的C++代码还可以更好地控制内存管理和复制。有许多机会可以改进算法，从小的逻辑块到使用标准模板库（STLs），再到编写更好的数据结构和库。关于这个主题有几本优秀的书籍和文章。我们将讨论一些重要的点，以使代码运行更快并使用更少的资源。
- en: 'Some of the important C++ optimization techniques are listed here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的C++优化技巧：
- en: Focus on algorithms, not on micro-optimization
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于算法，而不是微优化
- en: Don't construct objects and copy unnecessarily
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要不必要地构造对象和复制
- en: Use C++11 features such as move constructor, lambdas, and the `constexpr` functions
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++11特性，如移动构造函数、lambda和constexpr函数
- en: Choose static linking and position-dependent code
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择静态链接和位置相关代码
- en: Prefer 64-bit code and 32-bit data
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择64位代码和32位数据
- en: Minimize array writes and prefer array indexing to pointers
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化数组写入，优先使用数组索引而不是指针
- en: Prefer regular memory access patterns
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择正常的内存访问模式
- en: Reduce control flow
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少控制流
- en: Avoid data dependencies
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免数据依赖
- en: Use optimal algorithms and data structures
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最佳算法和数据结构
- en: Use caching
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存
- en: Use precomputed tables to avoid repeated computation
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预计算表来避免重复计算
- en: Prefer buffering and batching
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首选缓冲和批处理
- en: Since this book requires previous knowledge of C++, we expect that you will
    be aware of these best practices. As a C++ programmer, always stay updated with
    the latest C++ standards such as C++17 and C++20\. These will help you in writing
    efficient code with great features. We won't be discussing these in detail in
    this section, but will leave this for your self-exploration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书需要对C++有先前的了解，我们期望您已经了解这些最佳实践。作为一名C++程序员，始终要了解最新的C++标准，如C++17和C++20。这将帮助您编写具有出色功能的高效代码。我们不会在本节详细讨论这些内容，而是留给您自行探索。
- en: 'You can read more about C++ core guidelines at the following link: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关C++核心指南的更多信息：[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)。
- en: 'You can learn more about optimizing C++ code at the following link: [https://www.agner.org/optimize/](https://www.agner.org/optimize/).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关优化C++代码的更多信息：[https://www.agner.org/optimize/](https://www.agner.org/optimize/)。
- en: Go through the listed approaches to improve your C++ code. Next, we will discuss
    how to improve application performance with concurrency and multithreading in
    the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览列出的方法来改进您的C++代码。接下来，我们将在下一节讨论如何通过并发和多线程来提高应用程序性能。
- en: Using concurrency, parallelism, and multithreading
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发、并行和多线程
- en: 'Since you are already a C++ developer, you might be aware of these terms, which
    may be used interchangeably. However, there are differences in these terms. Let''s
    revisit these terms here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经是一名C++开发人员，您可能已经了解这些术语，这些术语可以互换使用。然而，这些术语之间存在差异。让我们在这里重新审视这些术语：
- en: '**Concurrency** is the execution of multiple programs at the same time (concurrent).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**是同时执行多个程序（并发）。'
- en: '**Parallelism** is the simultaneous running of a portion of your program in
    parallel, utilizing the multiple cores in a multi-core processor.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性**是在多核处理器中并行运行程序的一部分，利用多个核心。'
- en: '**Multithreading** is the capability of a **central processing unit** (**CPU**)
    to run multiple threads for the same program, concurrently supported by the operating
    system.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多线程**是**中央处理单元**（**CPU**）同时运行同一程序的多个线程的能力，由操作系统支持。'
- en: For example, you may launch multiple instances of a **Portable Document Format**
    (**PDF**) reader and Qt Creator. Qt Creator can run multiple tools by itself.
    Your system Task Manager can show you all the processes running simultaneously.
    This is known as concurrency. It is also commonly known as multitasking.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以启动多个**便携式文档格式**（**PDF**）阅读器和Qt Creator的实例。Qt Creator可以自行运行多个工具。您的系统任务管理器可以显示所有同时运行的进程。这被称为并发性。它也通常被称为多任务处理。
- en: But if you use parallel computing techniques to process your data, then this
    is called parallelism. Complex applications with huge data processing requirements
    use this technique. Note that parallel computing on a single-core processor is
    an illusion.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您使用并行计算技术来处理数据，那么这被称为并行性。具有巨大数据处理需求的复杂应用程序使用这种技术。请注意，并行计算在单核处理器上是一种幻觉。
- en: A thread is the smallest executable unit of a process. There can be several
    threads in a process, but there is only one main thread. Multithreading is concurrency
    within the same process. Only one core is used by a conventional single-threaded
    application. A program with multiple threads can be distributed to multiple cores,
    allowing true concurrency. As a result, a multithreaded application provides better
    performance on multi-core hardware.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是进程的最小可执行单元。一个进程中可以有多个线程，但只有一个主线程。多线程是在同一进程内的并发。传统的单线程应用程序只使用一个核心。具有多个线程的程序可以分布到多个核心，从而实现真正的并发。因此，多线程应用程序在多核硬件上提供更好的性能。
- en: 'Let''s discuss a few important classes in Qt that provide concurrency and multithreading,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论Qt中提供并发和多线程的一些重要类，如下所示：
- en: '`QThread` is used to manage one thread of control within a program.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QThread`用于在程序内管理一个线程控制。'
- en: '`QThreadPool` is used to manage and recycle individual `QThread` objects to
    help reduce thread creation costs in a multithreaded application.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QThreadPool`用于管理和回收单个`QThread`对象，以帮助减少多线程应用程序中的线程创建成本。'
- en: '`QRunnable` is an interface class for representing a task or piece of code
    that needs to be executed.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QRunnable`是一个表示需要执行的任务或代码片段的接口类。'
- en: '`QtConcurrent` offers high-level **application programming interfaces** (**APIs**)
    that help in writing multithreaded programs without using low-level threading
    primitives.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtConcurrent`提供高级**应用程序编程接口**（**API**），帮助编写多线程程序而不使用低级线程原语。'
- en: '`QFuture` permits threads to be synchronized against multiple computational
    results that will be available at a later point in time.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFuture`允许线程在稍后的时间点同步多个计算结果。'
- en: '`QFutureWatcher` provides information and notifications about a `QFuture` object
    using signals and slots.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFutureWatcher`使用信号和槽提供有关`QFuture`对象的信息和通知。'
- en: '`QFutureSynchronizer` is a convenience class that simplifies the synchronization
    of one or more `QFuture` objects.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFutureSynchronizer`是一个方便的类，简化了一个或多个`QFuture`对象的同步。'
- en: 'Threads are primarily used in two scenarios, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线程主要用于两种情况，如下所示：
- en: To make use of multi-core CPUs to speed up processing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用多核CPU加速处理
- en: Offload long-running processing or blocking calls to other threads to keep the
    **graphical user interface** (**GUI**) thread or other time-critical threads responsive
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将长时间运行的处理或阻塞调用卸载到其他线程，以保持**图形用户界面**（**GUI**）线程或其他时间关键的线程的响应
- en: 'Let''s briefly discuss the most basic concurrency concept known as a `QThread`
    class offers a thread abstraction in Qt with convenience methods. You can start
    a new custom thread by subclassing the `QThread` class, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下最基本的并发概念，即`QThread`类在Qt中提供了一个线程抽象，并提供了方便的方法。您可以通过对`QThread`类进行子类化来启动一个新的自定义线程，如下所示：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can create a new instance of this class and invoke its `start()` function.
    This will create a new thread and then call the `run()` function in the context
    of this new thread. Another approach is to directly create a `QThread` object
    and invoke the `start()` function, which will start an event loop. In comparison
    to a conventional C++ thread class, `QThread` supports thread interruption, which
    isn't supported in C++11 and later. You may wonder why we can't just use the C++
    standard thread class. This is because you can use the signals and slots mechanism
    with `QThread` in a multithread-safe way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建此类的新实例并调用其`start()`函数。这将创建一个新线程，然后在这个新线程的上下文中调用`run()`函数。另一种方法是直接创建一个`QThread`对象并调用`start()`函数，这将启动一个事件循环。与传统的C++线程类相比，`QThread`支持线程中断，而C++11及以后的版本不支持。您可能会想知道为什么我们不能只使用C++标准线程类。这是因为您可以以多线程安全的方式使用`QThread`的信号和槽机制。
- en: 'You can also use the multithreading mechanism in QML using `WorkerScript`.
    JavaScript code can execute in parallel with the GUI thread using the `WorkerScript`
    QML type. To enable the use of threads in a Qt Quick application, import the module
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在QML中使用多线程机制，使用`WorkerScript`。 JavaScript代码可以使用`WorkerScript` QML类型与GUI线程并行执行。要在Qt
    Quick应用程序中启用线程的使用，可以按照以下方式导入模块：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One JavaScript can be attached to each `WorkerScript` object. The script will
    run in a different thread and QML context when `WorkerScript.sendMessage()` is
    called. When the script is finished, it can send a response to the GUI thread,
    invoking the `WorkerScript.onMessage()` signal handler. You can exchange data
    between threads by using signals and signal handlers. Let''s have a look at a
    simple `WorkerScript` usage, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`WorkerScript`对象可以附加一个JavaScript。当调用`WorkerScript.sendMessage()`时，脚本将在不同的线程和QML上下文中运行。脚本完成后，它可以向GUI线程发送响应，调用`WorkerScript.onMessage()`信号处理程序。您可以使用信号和信号处理程序在线程之间交换数据。让我们看一个简单的`WorkerScript`用法，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code snippet uses a JavaScript file, `messaging.mjs`, which performs
    the operations in a new thread. Let''s look at the sample script, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用了一个名为`messaging.mjs`的JavaScript文件，在新线程中执行操作。让我们看一下示例脚本，如下所示：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can send a message from the click of a button or based on some user action.
    It will invoke the `sendMessage(jsobject message)` method, where your complex
    messaging operations will take place. You can read more about different threading
    mechanisms and use cases at the following link: [https://doc.qt.io/qt-6/threads-technologies.html](https://doc.qt.io/qt-6/threads-technologies.html).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从按钮点击或基于某些用户操作发送消息。它将调用`sendMessage(jsobject message)`方法，其中将进行复杂的消息传递操作。您可以在以下链接了解有关不同线程机制和用例的更多信息：[https://doc.qt.io/qt-6/threads-technologies.html](https://doc.qt.io/qt-6/threads-technologies.html)。
- en: 'Since this book is written for experienced C++ developers, it is expected that
    you will be familiar with terms such as `mutex`, `semaphore`, `read-write lock`,
    and so on. Qt provides convenience classes to use these mechanisms while implementing
    a multithreading application. We won''t deep dive into these Qt classes with examples.
    You can learn more about the use of `QMutex`, `QSemaPhore`, `QReadWriteLock`,
    and `QWaitCondition` at the following link: [https://doc.qt.io/qt-6/threads-synchronizing.html](https://doc.qt.io/qt-6/threads-synchronizing.html).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书是为有经验的C++开发人员编写的，因此预期您将熟悉诸如`mutex`、`semaphore`、`read-write lock`等术语。Qt提供了方便的类来使用这些机制来实现多线程应用程序。我们不会深入研究这些Qt类及其示例。您可以在以下链接了解有关`QMutex`、`QSemaPhore`、`QReadWriteLock`和`QWaitCondition`的使用：[https://doc.qt.io/qt-6/threads-synchronizing.html](https://doc.qt.io/qt-6/threads-synchronizing.html)。
- en: In this section, we learned how concurrency mechanisms can be used to improve
    overall application performance. Don't implement it unnecessarily for simple tasks
    as this may result in degraded performance. In the next section, we will discuss
    the use of the QML Profiler tool for profiling a Qt Quick application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用并发机制来提高整体应用程序性能。不要为简单的任务不必要地实现它，因为这可能会导致性能下降。在下一节中，我们将讨论使用QML
    Profiler工具来对Qt Quick应用程序进行性能分析。
- en: Profiling a Qt Quick application using QML Profiler and Flame Graph
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QML Profiler和Flame Graph对Qt Quick应用程序进行性能分析
- en: QML in Qt 6 takes advantage of **graphics processing units** (**GPUs**) and
    uses hardware acceleration for rendering. This feature makes QML superior to Qt
    Widgets in terms of performance. However, there can be bottlenecks in your QML
    code that may impact overall application performance. In this section, we will
    focus on using the built-in tool to find these bottlenecks. Qt Creator provides
    seamless integration with multiple tools. The most important tool is **QML Profiler**.
    It is provided by Qt and works on all Qt-supported platforms. Other than QML Profiler,
    Qt Creator also provides third-party tools such as **Valgrind**, **Heob**, and
    **Performance Analyzer**. You can enable new plugins or remove some plugins from
    **About Plugins…**, available under the **Help** menu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6中的QML利用**图形处理单元**（**GPU**）并使用硬件加速进行渲染。这个特性使得QML在性能方面优于Qt Widgets。然而，您的QML代码中可能存在性能瓶颈。在本节中，我们将专注于使用内置工具来找到这些瓶颈。Qt
    Creator提供了与多个工具的无缝集成。最重要的工具是**QML Profiler**。它由Qt提供，并在所有Qt支持的平台上工作。除了QML Profiler，Qt
    Creator还提供第三方工具，如**Valgrind**、**Heob**和**Performance Analyzer**。您可以在**关于插件...**（位于**帮助**菜单下）中启用新插件或删除一些插件。
- en: Let's discuss QML Profiler, which you will be using most of the time to find
    the bottlenecks in your QML code. The goal of QML Profiler is to help you identify
    bottlenecks by providing you with details such as the time taken by a code block
    to do a certain operation, after which you can decide to reimplement the code
    with suitable GUI elements or better data structures or algorithms.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下QML Profiler，这是您在大部分时间内用来找到QML代码中瓶颈的工具。QML Profiler的目标是通过提供诸如代码块执行某个操作所需的时间等细节来帮助您识别瓶颈，之后您可以决定是否重新实现代码，使用合适的GUI元素或更好的数据结构或算法。
- en: 'Follow these steps to start profiling and optimizing your Qt Quick application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始分析和优化您的Qt Quick应用程序：
- en: Open an existing Qt Quick project or create a new Qt Quick application using
    Qt Creator's **New Project** creation wizard.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开现有的Qt Quick项目或使用Qt Creator的**新建项目**创建向导创建新的Qt Quick应用程序。
- en: Once the project is created, add some code to it. Then, select **QML Profiler**
    under the **Analyze** menu to run the QML Profiler tool. The **Analyze** context
    menu can differ from platform to platform based on installed plugins. The following
    screenshot shows the **QML Profiler** option in the Windows platform. In Linux,
    you may see a few more options, such as **Valgrind Memory Analyzer**, **Valgrind
    Memory Analyzer with GDB**, and **Valgrind Function Profiler**:![Figure 12.1 –
    QML Profiler option in Qt Creator integrated development environment (IDE)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，向其中添加一些代码。然后，在**分析**菜单下选择**QML Profiler**运行QML Profiler工具。根据安装的插件，**分析**上下文菜单在不同平台上可能有所不同。以下截图显示了Windows平台上的**QML
    Profiler**选项。在Linux上，您可能会看到一些其他选项，例如**Valgrind Memory Analyzer**，**Valgrind Memory
    Analyzer with GDB**和**Valgrind Function Profiler**：![图12.1 - Qt Creator集成开发环境（IDE）中的QML
    Profiler选项
- en: '](img/Figure_12.1_B16231.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B16231.jpg)'
- en: Figure 12.1 – QML Profiler option in Qt Creator integrated development environment
    (IDE)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - Qt Creator集成开发环境（IDE）中的QML Profiler选项
- en: When you hit the **QML Profiler** option, your Qt Quick application will run
    by QML Profiler. You will see the **QML Profiler** window appear below the code
    editor. You may also see the following message:![Figure 12.2 – QML Profiler retry
    message
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击**QML Profiler**选项时，您的Qt Quick应用程序将通过QML Profiler运行。您会看到**QML Profiler**窗口出现在代码编辑器下方。您可能还会看到以下消息：![图12.2
    - QML Profiler重试消息
- en: '](img/Figure_12.2_B16231.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B16231.jpg)'
- en: Figure 12.2 – QML Profiler retry message
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - QML Profiler重试消息
- en: If you get this popup, just hit **Retry**. You will notice that the profiling
    will begin and you will also notice the output screen. In the sample application,
    we are creating new rectangles on a mouse click, as illustrated in the following
    screenshot:![Figure 12.3 – Output of sample Qt Quick application
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您看到此弹出窗口，只需点击**重试**。您会注意到分析将开始，并且您还会注意到输出屏幕。在示例应用程序中，我们在鼠标点击时创建新的矩形，如下截图所示：![图12.3
    - 示例Qt Quick应用程序的输出
- en: '](img/Figure_12.3_B16231.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B16231.jpg)'
- en: Figure 12.3 – Output of sample Qt Quick application
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 示例Qt Quick应用程序的输出
- en: On the **user interface** (**UI**), perform some user interactions—such as click
    a button—to do a certain operation. Then, click the **Stop** button located on
    the title bar of the profiler window. You will also see two more buttons on both
    sides of the **Stop** button. If you hover your mouse over them, you will see
    their functionalities, such as **Start QML Profiler analysis** and **Disable Profiling**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**用户界面**（**UI**）上执行一些用户交互 - 例如点击按钮执行某个操作。然后，点击分析器窗口标题栏上的**停止**按钮。您还会在**停止**按钮的两侧看到另外两个按钮。如果将鼠标悬停在它们上面，您会看到它们的功能，例如**开始QML
    Profiler分析**和**禁用分析**。
- en: 'An overview of the **QML Profiler** window is shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**QML Profiler**窗口的概述：
- en: '![Figure 12.4 – QML Profiler window showing Stop button and tabbed views'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - 显示停止按钮和选项卡视图的QML Profiler窗口'
- en: '](img/Figure_12.4_B16231.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.4_B16231.jpg)'
- en: Figure 12.4 – QML Profiler window showing Stop button and tabbed views
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 显示停止按钮和选项卡视图的QML Profiler窗口
- en: Once you stop the profiler, you will see the **QML Profiler** window is updated
    with some views. You will notice that there are three tabs under the profiler
    window—namely **Timeline**, **Flame Graph**, and **Statistics**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您停止分析器，您会看到**QML Profiler**窗口已更新并显示了一些视图。您会注意到分析器窗口下有三个选项卡 - 分别是**时间轴**，**火焰图**和**统计**。
- en: Let's look at the first tab on QML Profiler—click on the **Timeline** tab. The
    following screenshot shows a sample view of the output:![Figure 12.5 – QML Profiler
    showing timeline details
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看QML Profiler的第一个选项卡 - 点击**时间轴**选项卡。以下截图显示了输出的示例视图：![图12.5 - 显示时间轴详细信息的QML
    Profiler
- en: '](img/Figure_12.5_B16231.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.5_B16231.jpg)'
- en: Figure 12.5 – QML Profiler showing timeline details
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 - 显示时间轴详细信息的QML Profiler
- en: 'You will notice that there are six different sections under the timeline display:
    **Scene Graph**, **Memory Usage**, **Compiling**, **Creating**, **Binding**, and
    **JavaScript**. These sections give us an overview of the different stages of
    application processing such as compilation, component creation, and logical execution.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到时间轴显示下有六个不同的部分：**场景图**，**内存使用**，**编译**，**创建**，**绑定**和**JavaScript**。这些部分给我们提供了应用程序处理的不同阶段的概述，例如编译，组件创建和逻辑执行。
- en: You can find colorful bars on the timeline. You can use the mouse wheel to zoom
    in and zoom out on specific timeline sections. You can also move the timeline
    by pressing the left mouse button at the bottom region of the timeline and move
    in either direction to locate an area of interest.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在时间轴上找到彩色的条形图。您可以使用鼠标滚轮放大和缩小特定的时间轴部分。您还可以通过按住时间轴底部区域的鼠标左键并向任何方向移动来移动时间轴，以定位感兴趣的区域。
- en: 'The different sections of the **Timeline** tab are illustrated in the following
    screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间轴**选项卡的不同部分如下截图所示：'
- en: '![Figure 12.6 – Timeline tab showing different sections'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 - 显示不同部分的时间轴选项卡'
- en: '](img/Figure_12.6_B16231.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.6_B16231.jpg)'
- en: Figure 12.6 – Timeline tab showing different sections
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 - 显示不同部分的时间轴选项卡
- en: You can click on the **Expand** button to see further details under each section,
    as illustrated in the following screenshot:![Figure 12.7 – Timeline tab showing
    different subsections under Scene Graph and profiling options
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以点击**展开**按钮以查看每个部分下的更多细节，如下图所示：![图12.7 - 时间轴选项卡显示场景图下不同子部分和分析选项
- en: '](img/Figure_12.7_B16231.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.7_B16231.jpg)'
- en: Figure 12.7 – Timeline tab showing different subsections under Scene Graph and
    profiling options
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 - 时间轴选项卡显示场景图下不同子部分和分析选项
- en: If you click on one of the bars under the `QtQuick/Rectangle` type, total duration
    taken for creating an object, and the location of code displayed on a pop-up window,
    over the **QML Profiler** window. You can use the yellow arrows in the top-left
    corner to jump to previous or next events. This section is illustrated in the
    following screenshot:![Figure 12.8 – Details of an object under the Creating section
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击`QtQuick/Rectangle`类型下的柱状图之一，将会显示创建对象所花费的总时间以及代码位置的弹出窗口，覆盖**QML Profiler**窗口。您可以使用左上角的黄色箭头跳转到上一个或下一个事件。本节在下图中有所说明：![图12.8
    - 创建部分下对象的详细信息
- en: '](img/Figure_12.8_B16231.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.8_B16231.jpg)'
- en: Figure 12.8 – Details of an object under the Creating section
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 - 创建部分下对象的详细信息
- en: You can switch between different tabs at the bottom of the **QML Profiler**
    window. Once you have explored the **Timeline** tab, let's open up the **Flame
    Graph** tab. Under this tab, you will find a visualization of the **Total Time**,
    **Memory**, and **Allocations** of your application as a percentage. You can switch
    between these views by clicking on the dropdown located in the top-right corner
    of the **QML Profiler** window, as shown in the following screenshot:![Figure
    12.9 – Flame Graph showing Allocations view
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在**QML Profiler**窗口底部在不同选项卡之间切换。一旦您探索了**时间轴**选项卡，让我们打开**火焰图**选项卡。在此选项卡下，您将以百分比形式找到应用程序的**总时间**、**内存**和**分配**的可视化。您可以通过单击**QML
    Profiler**窗口右上角的下拉菜单在这些视图之间切换，如下图所示：![图12.9 - 火焰图显示分配视图
- en: '](img/Figure_12.9_B16231.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.9_B16231.jpg)'
- en: Figure 12.9 – Flame Graph showing Allocations view
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 - 火焰图显示分配视图
- en: The **Flame Graph** view provides a more compact statistics summary. The horizontal
    bars depict one aspect of the samples gathered for a certain function in comparison
    to the same aspect of all samples combined. The nesting indicates a call tree
    that shows, for example, which functions call the other function.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**火焰图**视图提供了更紧凑的统计摘要。水平条形图显示了针对某个函数收集的样本的一个方面，与所有样本组合的相同方面进行比较。嵌套表示呈现了一个调用树，例如显示了哪些函数调用了其他函数。'
- en: As seen in the following screenshot, you can also see the percentage value displayed
    on the left side of the code editor. Based on which component is consuming more
    time, you can tweak your code:![Figure 12.10 – QML Profiler showing percentage
    time spent for a specific portion of the code
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，您还可以在代码编辑器的左侧看到显示的百分比值。根据哪个组件消耗了更多时间，您可以调整您的代码：![图12.10 - QML Profiler显示代码特定部分所花费的时间百分比
- en: '](img/Figure_12.10_B16231.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B16231.jpg)'
- en: Figure 12.10 – QML Profiler showing percentage time spent for a specific portion
    of the code
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 - QML Profiler显示代码特定部分所花费的时间百分比
- en: Since data collection takes time, you may notice a little lag before the data
    is displayed. When you click the **Enable Profiling** button, data is transferred
    to QML Profiler, therefore don't terminate the application immediately.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据收集需要时间，您可能会注意到数据显示之前有一点延迟。当您点击**启用分析**按钮时，数据将传输到QML Profiler，因此不要立即终止应用程序。
- en: To disable the automatic start of data collection when an application is launched,
    select the **Disable Profiling** button. When you toggle the button, data collection
    will start again.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用应用程序启动时自动开始数据收集，请选择**禁用分析**按钮。切换按钮时，数据收集将重新开始。
- en: 'Let''s move to the next tab: the **QML Profiler** window. This tab reveals
    statistical details about the processes in a table structure. The following screenshot
    illustrates the statistics of the code execution for our sample code:![Figure
    12.11 – QML Profiler showing statistics of code execution'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到下一个选项卡：**QML Profiler**窗口。该选项卡以表格结构显示了有关进程的统计详细信息。下图说明了我们示例代码的代码执行统计信息：![图12.11
    - QML Profiler显示代码执行的统计信息
- en: '](img/Figure_12.11_B16231.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B16231.jpg)'
- en: Figure 12.11 – QML Profiler showing statistics of code execution
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 - QML Profiler显示代码执行的统计信息
- en: You can also attach QML Profiler to an externally started application through
    **QML Profiler (Attach to Waiting Application)** under the **Analyze** menu. Once
    you select the option, you will see the following dialog:![Figure 12.12 – QML
    Profiler showing remote execution option
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过**分析**菜单下的**QML Profiler（附加到等待应用程序）**将QML Profiler附加到外部启动的应用程序。选择该选项后，您将看到以下对话框：![图12.12
    - QML Profiler显示远程执行选项
- en: '](img/Figure_12.12_B16231.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.12_B16231.jpg)'
- en: Figure 12.12 – QML Profiler showing remote execution option
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 - QML Profiler显示远程执行选项
- en: To save all of the data collected, right-click on any QML Profiler view and
    select **Save QML Trace** in the context menu. You can select **Load QML Trace**
    to see the saved data. You can also send the saved data to others for review or
    load data that they have saved.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存收集的所有数据，请右键单击任何QML Profiler视图，并在上下文菜单中选择**保存QML跟踪**。您可以选择**加载QML跟踪**以查看保存的数据。您还可以将保存的数据发送给其他人进行审查，或加载他们保存的数据。
- en: 'In this section, we discussed different options available in QML Profiler.
    By using this tool, you can easily find code that is causing performance issues.
    More details are available at this link: [https://doc.qt.io/qtcreator/creator-qml-performance-monitor.html](https://doc.qt.io/qtcreator/creator-qml-performance-monitor.html).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了QML Profiler中提供的不同选项。使用这个工具，您可以轻松找到导致性能问题的代码。更多详细信息请访问此链接：[https://doc.qt.io/qtcreator/creator-qml-performance-monitor.html](https://doc.qt.io/qtcreator/creator-qml-performance-monitor.html)。
- en: In the next section, we will discuss further how to use other analytical tools
    to optimize your Qt code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步讨论如何使用其他分析工具来优化您的Qt代码。
- en: Other Qt Creator analysis tools
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Qt Creator分析工具
- en: 'In the earlier section, we discussed QML Profiler, but you may need to analyze
    your C++ and Qt Widgets code. Qt Creator provides integration with some of the
    famous analysis tools to help you analyze your Qt application. Some of the tools
    that come with Qt Creator are listed here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们讨论了QML Profiler，但您可能需要分析您的C++和Qt Widgets代码。Qt Creator提供了与一些著名分析工具的集成，以帮助您分析Qt应用程序。Qt
    Creator附带的一些工具列在这里：
- en: '**Heob**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heob**'
- en: '**Performance Analyzer**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析器**'
- en: '**Valgrind**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Valgrind**'
- en: '**Clang Tools: Clang-Tidy and Clazy**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clang工具：Clang-Tidy和Clazy**'
- en: '**Cppcheck**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cppcheck**'
- en: '**Chrome Trace Format** (**CTF**) visualizer'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chrome跟踪格式**（**CTF**）可视化器'
- en: Let's briefly discuss these tools and become familiar with them before getting
    into their documentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究这些工具并熟悉它们的文档之前，让我们简要讨论一下。
- en: To use Heob, you first need to download and install it. Buffer overruns and
    memory leaks can be easily detected with Heob. It works by overriding the caller
    process's heap functions. An access violation is raised when a buffer overrun
    occurs, and stack traces of the offending code and buffer allocation are noted.
    You will find the stack traces when the application exits normally. It doesn't
    require any recompilation or relinking of the target application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Heob，您首先需要下载并安装它。使用Heob可以轻松检测缓冲区溢出和内存泄漏。它通过覆盖调用者进程的堆函数来工作。当发生缓冲区溢出时，会引发访问冲突，并记录违规代码和缓冲区分配的堆栈跟踪。当应用程序正常退出时，您将找到堆栈跟踪。它不需要重新编译或重新链接目标应用程序。
- en: You can read about its usage on the official documentation link at [https://doc.qt.io/qtcreator/creator-heob.html](https://doc.qt.io/qtcreator/creator-heob.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档链接上阅读有关其用法的更多信息：[https://doc.qt.io/qtcreator/creator-heob.html](https://doc.qt.io/qtcreator/creator-heob.html)。
- en: 'You can download the binary from [SourceForge.net](http://SourceForge.net)
    or build it from the source code. The source code of Heob can be found at the
    following link: [https://github.com/ssbssa/heob](https://github.com/ssbssa/heob).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[SourceForge.net](http://SourceForge.net)下载二进制文件，也可以从源代码构建。Heob的源代码可以在以下链接找到：[https://github.com/ssbssa/heob](https://github.com/ssbssa/heob)。
- en: 'The Linux Performance Analyzer tool is integrated with Qt Creator and can be
    used to analyze an application''s CPU and memory utilization on Linux desktop
    or Linux-based embedded systems. The `perf` tool takes periodic snapshots of an
    application''s call tree and visualizes them in a timeline view or as a flame
    graph, using the utility included with the Linux kernel. You can launch it on
    your Linux machine from the **Performance Analyzer** option under the **Analyze**
    menu, as illustrated in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Linux性能分析器工具与Qt Creator集成，可用于分析Linux桌面或基于Linux的嵌入式系统上的应用程序的CPU和内存利用率。`perf`工具定期对应用程序的调用树进行快照，并使用Linux内核附带的实用程序将它们可视化为时间线视图或火焰图。您可以在Linux机器上从**分析**菜单下的**性能分析器**选项中启动它，如下截图所示：
- en: '![Figure 12.13 – Qt Creator showing Performance Analyzer option'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13 - Qt Creator显示性能分析器选项'
- en: '](img/Figure_12.13_B16231.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.13_B16231.jpg)'
- en: Figure 12.13 – Qt Creator showing Performance Analyzer option
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 - Qt Creator显示性能分析器选项
- en: 'Please note that the `perf` utility, you will get an equivalent warning dialog,
    as shown in the next screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`perf`实用程序，您将会得到一个等效的警告对话框，如下截图所示：
- en: '![Figure 12.14 – Qt Creator showing Performance Analyzer warning dialog'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14 - Qt Creator显示性能分析器警告对话框'
- en: '](img/Figure_12.14_B16231.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.14_B16231.jpg)'
- en: Figure 12.14 – Qt Creator showing Performance Analyzer warning dialog
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 - Qt Creator显示性能分析器警告对话框
- en: 'Use the following command to install the `perf` tool on your Ubuntu machine:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在您的Ubuntu机器上安装`perf`工具：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are using a different Linux distribution, you can use the corresponding
    command. `perf` may fail for the specific Linux kernel, with a warning about the
    kernel version. In that case, type the following command with the appropriate
    kernel version:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用不同的Linux发行版，您可以使用相应的命令。`perf`可能会因特定的Linux内核而失败，并显示有关内核版本的警告。在这种情况下，请使用适当内核版本的以下命令：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the `perf` setup is done, you can see the predefined events in the command
    prompt with the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`perf`设置后，您可以使用以下命令在命令提示符中查看预定义事件：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, launch Qt Creator and open a Qt project. Select `perf` tool and an additional
    assistance program is included with Qt Creator, it may appear in Qt Creator several
    seconds after it was created. The **Processing delay** field contains an estimate
    for this delay. The data collection continues until you click the **Stop collecting
    profile data** button or close the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动Qt Creator并打开一个Qt项目。选择`perf`工具，并在Qt Creator中创建几秒钟后，可能会出现一个额外的辅助程序。**处理延迟**字段包含此延迟的估计值。数据收集将持续进行，直到您单击**停止收集配置文件数据**按钮或关闭应用程序。
- en: 'You can also load `perf.data` and analyze an application from **Performance
    Analyzer Options** under the **Analyze** menu, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从**分析**菜单下的**性能分析器选项**加载`perf.data`并分析应用程序，如下所示：
- en: '![Figure 12.15 – Context menu showing Performance Analyzer options'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 - 上下文菜单显示性能分析器选项'
- en: '](img/Figure_12.15_B16231.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.15_B16231.jpg)'
- en: Figure 12.15 – Context menu showing Performance Analyzer options
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 - 上下文菜单显示性能分析器选项
- en: 'You can read more about usage of Performance Analyzer at the following link:
    [https://doc.qt.io/qtcreator/creator-cpu-usage-analyzer.html](https://doc.qt.io/qtcreator/creator-cpu-usage-analyzer.html).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接阅读有关性能分析器的更多用法：[https://doc.qt.io/qtcreator/creator-cpu-usage-analyzer.html](https://doc.qt.io/qtcreator/creator-cpu-usage-analyzer.html)。
- en: On macOS, there is an equivalent tool called **Instructions**; however, this
    is not integrated with Qt Creator. You can launch it separately and look at the
    **Time Profiler** section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，有一个名为**Instructions**的等效工具；但是，这个工具没有与Qt Creator集成。您可以单独启动它，并查看**时间分析器**部分。
- en: On Linux and macOS, `memcheck`. You can change this to `callgrind` from the
    profiler drop-down option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，`memcheck`。您可以从分析器下拉选项中将其更改为`callgrind`。
- en: 'You can learn more about Valgrind at the following link: [https://doc.qt.io/qtcreator/creator-valgrind-overview.html](https://doc.qt.io/qtcreator/creator-valgrind-overview.html).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关Valgrind的更多信息：[https://doc.qt.io/qtcreator/creator-valgrind-overview.html](https://doc.qt.io/qtcreator/creator-valgrind-overview.html)。
- en: 'The next tool available in Qt Creator is **Clang-Tidy** and **Clazy…**. These
    tools can be used to locate issues in your C++ code through static analysis. **Clang-Tidy**
    provides diagnostics and fixes for common programming errors such as style violations
    or interface misuse. On the other hand, **Clazy** highlights Qt-related compiler
    errors, such as wasteful memory allocation and API usage, and suggests refactoring
    activities to remedy some of the problems. Clang-Tidy includes the Clang static
    analyzer capabilities. You do not need to set up Clang tools individually because
    they are distributed and integrated with Qt Creator. When you run **Clang-Tidy
    and Clazy…**, as illustrated in the following screenshot, you will see the analysis
    details under the **Profiler** window and the progress under the **Application
    Output** window below the code editor:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator中的下一个工具是**Clang-Tidy**和**Clazy...**。这些工具可用于通过静态分析在您的C++代码中定位问题。**Clang-Tidy**提供了常见编程错误的诊断和修复，如样式违规或接口误用。另一方面，**Clazy**突出显示与Qt相关的编译器错误，如浪费的内存分配和API使用，并建议重构活动以解决一些问题。Clang-Tidy包括Clang静态分析器的功能。您无需单独设置Clang工具，因为它们已经与Qt
    Creator集成和分发。当您运行**Clang-Tidy和Clazy...**，如下面的屏幕截图所示，您将在**分析器**窗口下看到分析细节，并在代码编辑器下方的**应用程序输出**窗口中看到进度：
- en: '![Figure 12.16 – Context menu showing the Clang-Tidy and Clazy… option'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 - 显示Clang-Tidy和Clazy...选项的上下文菜单'
- en: '](img/Figure_12.16_B16231.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.16_B16231.jpg)'
- en: Figure 12.16 – Context menu showing the Clang-Tidy and Clazy… option
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 - 显示Clang-Tidy和Clazy...选项的上下文菜单
- en: Let's run the tool on an existing Qt example. In the application window, you
    will see the analysis running, and in the profiler window, you will see the results.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在现有的Qt示例上运行该工具。在应用程序窗口中，您将看到分析正在运行，并在分析器窗口中，您将看到结果。
- en: 'You can explore the documentation further at the following link: [https://doc.qt.io/qtcreator/creator-clang-tools.html](https://doc.qt.io/qtcreator/creator-clang-tools.html).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接进一步探索文档：[https://doc.qt.io/qtcreator/creator-clang-tools.html](https://doc.qt.io/qtcreator/creator-clang-tools.html)。
- en: Qt Creator also includes another tool called **cppcheck**. This tool has experimental
    integration with Qt Creator. You can enable it from **About Plugins…**, available
    under the **Help** menu. You can use this to detect undefined behavior and dangerous
    coding constructs. The tool provides options to check warnings, style, performance,
    portability, and information.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator还包括另一个工具称为**cppcheck**。这个工具与Qt Creator有实验性的集成。您可以在**帮助**菜单下的**关于插件...**中启用它。您可以使用它来检测未定义的行为和危险的编码结构。该工具提供了检查警告、样式、性能、可移植性和信息的选项。
- en: The last analysis tool integrated with Qt Creator is the **CTF visualizer**.
    You can use this along with QML Profiler. Tracing information might provide you
    further insight into the data that QML Profiler collects. You can find why a simple
    binding is taking so long, such as being possibly impacted by the C++ code or
    by slow disk operation. Full stack tracing may be used to trace from the top-level
    QML or JavaScript down to C++ and all the way down to the kernel area. This allows
    you to assess an application's performance and determine if poor performance is
    caused by the CPU or other programs on the same system. Tracing provides insight
    into what the system is doing and why an application is behaving in an undesired
    way. To see Chrome trace events, utilize the CTF visualizer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与Qt Creator集成的最后一个分析工具是**CTF可视化器**。您可以与QML Profiler一起使用它。跟踪信息可能会让您进一步了解QML Profiler收集的数据。您可以找出为什么简单的绑定需要这么长时间，比如可能受到C++代码或慢磁盘操作的影响。完整的堆栈跟踪可以用于从顶层QML或JavaScript跟踪到C++，一直跟踪到内核区域。这使您能够评估应用程序的性能，并确定性能不佳是由CPU还是同一系统上的其他程序引起的。跟踪提供了关于系统正在做什么以及应用程序为何以不希望的方式行为的见解。要查看Chrome跟踪事件，请使用CTF可视化器。
- en: 'You can learn more about the CTF visualizer at the following link: [https://doc.qt.io/qtcreator/creator-ctf-visualizer.html](https://doc.qt.io/qtcreator/creator-ctf-visualizer.html).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关CTF可视化器的更多信息：[https://doc.qt.io/qtcreator/creator-ctf-visualizer.html](https://doc.qt.io/qtcreator/creator-ctf-visualizer.html)。
- en: In this section, we have discussed different analysis tools available in Qt
    Creator. In the next section, we will discuss further how to optimize and locate
    graphical performance issues.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Qt Creator中可用的不同分析工具。在下一节中，我们将进一步讨论如何优化和定位图形性能问题。
- en: Optimizing graphical performance
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化图形性能
- en: We discussed graphics and animation in [*Chapter 8*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176),
    *Graphics and Animations*. In this section, we will explore factors that impact
    performance in graphics and animation. Graphics performance is essential in any
    application. If your application is poorly implemented, then users may see flickering
    in the UI or the UI may not update as expected. As a developer, you must make
    every effort to ensure that the rendering engine maintains a 60 **frames-per-second**
    (**FPS**) refresh rate. There are only 16 **milliseconds** (**ms**) between each
    frame in which processing should be done at 60 FPS, which includes the processing
    necessary to upload the draw primitives to the graphics hardware.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B16231_08_Final_ASB_ePub.xhtml#_idTextAnchor176)中讨论了图形和动画，*图形和动画*。在本节中，我们将探讨影响图形和动画性能的因素。图形性能在任何应用程序中都是至关重要的。如果您的应用程序实现不佳，用户可能会在UI中看到闪烁，或者UI可能无法按预期更新。作为开发人员，您必须尽一切努力确保渲染引擎保持60帧每秒的刷新率。在每帧之间只有16毫秒，其中应该以60帧每秒的速度进行处理，这包括将绘制基元上传到图形硬件所需的处理。
- en: To avoid any glitch in graphical performance, you should use asynchronous, event-driven
    programming wherever possible. If your application has huge data processing requirements
    and complex calculations, then use worker threads to do the processing. You should
    never manually spin an event loop. Don't spend more than a few ms per frame in
    blocking functions. If you don't follow these points, the users will see the GUI
    flickering or freezing, resulting in a bad **user experience** (**UX**). When
    it comes to generating graphics and animations on the UI the QML engine is very
    efficient and powerful. However, there are a few tricks you can use to make things
    even go faster. Instead of writing your own, utilize Qt 6's built-in capabilities.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免图形性能出现任何故障，您应该尽可能使用异步、事件驱动的编程。如果您的应用程序具有巨大的数据处理需求和复杂的计算，则使用工作线程进行处理。您不应该手动旋转事件循环。不要在阻塞函数中每帧花费超过几毫秒的时间。如果不遵循这些要点，用户将看到GUI闪烁或冻结，导致糟糕的用户体验（UX）。在生成UI上的图形和动画方面，QML引擎非常高效和强大。但是，您可以使用一些技巧使事情变得更快。不要编写自己的代码，而是利用Qt
    6的内置功能。
- en: While drawing graphics, you should choose opaque primitives if possible. Opaque
    primitives are faster to render by the renderer and to draw on the GPU. Hence,
    between `QImage::Format_RGB32` when passing photos to a `QQuickImageProvider`.
    Please note that overlapping compound items cannot be batched. Avoid clipping
    if possible as it breaks batching. Instead of clipping an image, use `QQuickImageProvider`
    to generate a cropped image. Applications that require a monochromatic background
    should use `QQuickWindow::setColor()` rather than a top-level `Rectangle` element.
    `QQuickWindow::setColor()` invokes `glClear()`, which is faster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制图形时，如果可能的话，应选择不透明的基元。不透明的基元在渲染器上更快，也更快地绘制在GPU上。因此，在将照片传递给`QQuickImageProvider`时，应选择`QImage::Format_RGB32`。请注意，重叠的复合项无法进行批处理。尽量避免裁剪，因为它会破坏批处理。而是使用`QQuickImageProvider`裁剪图像。需要单色背景的应用程序应该使用`QQuickWindow::setColor()`而不是顶层的`Rectangle`元素。`QQuickWindow::setColor()`调用`glClear()`，速度更快。
- en: While using `Image`, make use of the `sourceSize` property. The `sourceSize`
    property enables Qt to downsize the image before loading it into memory, ensuring
    that huge images consume no more memory than is required. When the `smooth` attribute
    is set to `true`, Qt filters the image to make it look smoother when it is scaled
    or changed from its original size. If the image is rendered at the same size as
    its `sourceSize` property, this makes no difference. On some older hardware, this
    property will influence the performance of your application. The `antialiasing`
    property directs Qt to smooth down aliasing artifacts around the edges of the
    image. This property will affect your program's performance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Image`时，请使用`sourceSize`属性。`sourceSize`属性使Qt能够在将图像加载到内存之前将其缩小，确保巨大的图像消耗的内存不超过所需的量。当`smooth`属性设置为`true`时，Qt会对图像进行滤波，使其在缩放或从原始大小更改时看起来更平滑。如果图像以与其`sourceSize`属性相同的大小呈现，则不会有任何区别。在一些较旧的硬件上，此属性将影响应用程序的性能。`antialiasing`属性指示Qt平滑处理图像边缘周围的混叠伪影。此属性将影响程序的性能。
- en: Better graphical performance can be achieved by effective batching. The renderer
    can provide statistics on how well the batching runs, how many batches are utilized,
    which batches are kept, which are opaque, and which are not. To enable this, add
    an environment variable such as `QSG_RENDERER_DEBUG` and set the value to `render`.
    Unless an image is too huge, a texture atlas is used by the `Image` and `BorderImage`
    QML types. If you are creating textures using C++, then call `QQuickWindow::createTexture()`
    and pass `QQuickWindow::TextureCanUseAtlas`. You can use another environment variable,
    `QSG_ATLAS_OVERLAY`, to colorize the atlas textures, which helps in identifying
    them easily.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效的批处理可以实现更好的图形性能。渲染器可以提供有关批处理运行情况、使用了多少批处理、保留了哪些批处理、哪些是不透明的以及哪些不是的统计信息。要启用此功能，请添加一个环境变量，如`QSG_RENDERER_DEBUG`，并将值设置为`render`。除非图像太大，否则`Image`和`BorderImage`
    QML类型将使用纹理图集。如果您正在使用C++创建纹理，则调用`QQuickWindow::createTexture()`并传递`QQuickWindow::TextureCanUseAtlas`。您可以使用另一个环境变量`QSG_ATLAS_OVERLAY`来给图集纹理上色，这有助于轻松识别它们。
- en: 'To visualize the various aspects of the scene graph''s default renderer, the
    `QSG_VISUALIZE` environment variable can be set to one of the values. You can
    do this in Qt Creator by going to the `QSG_VISUALIZE` and setting the value for
    that variable, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化场景图的默认渲染器的各个方面，可以将`QSG_VISUALIZE`环境变量设置为以下值之一。您可以在Qt Creator中通过转到`QSG_VISUALIZE`并设置该变量的值来执行此操作：
- en: '`QSG_VISUALIZE` = `overdraw`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSG_VISUALIZE` = `overdraw`'
- en: '`QSG_VISUALIZE` = `batches`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSG_VISUALIZE` = `batches`'
- en: '`QSG_VISUALIZE` = `clip`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSG_VISUALIZE` = `clip`'
- en: '`QSG_VISUALIZE` = `changes`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSG_VISUALIZE` = `changes`'
- en: When `QSG_VISUALIZE` is set to `overdraw`, overdraw is visualized in the renderer.
    To highlight overdraws, all elements are visualized in `Rectangle` just to draw
    a white background, as `Window` also has a white background. In this case, using
    an `Item` property instead of `Rectangle` can improve performance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当`QSG_VISUALIZE`设置为`overdraw`时，渲染器中会可视化过度绘制。为了突出过度绘制，所有元素都以`Rectangle`形式可视化，只是为了绘制白色背景，因为`Window`也有白色背景。在这种情况下，使用`Item`属性而不是`Rectangle`可以提高性能。
- en: Setting `QSG_VISUALIZE` to `batches` causes batches to be visualized in the
    renderer. Unmerged batches are drawn with a diagonal line pattern, whereas merged
    batches are drawn with a solid color. A small number of distinct colors indicates
    effective batching. Unmerged batches are undesirable if they contain a large number
    of individual nodes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将`QSG_VISUALIZE`设置为`batches`会导致批次在渲染器中可视化。未合并的批次以对角线图案绘制，而合并的批次以纯色绘制。少量不同的颜色表示有效的批处理。如果未合并的批次包含大量单独的节点，则是不理想的。
- en: All QML components that derive from `Item` have a property called `clip`. By
    default, the `clip` value is set to `false`. This property informs the scene graph
    not to render any child elements that extend beyond the boundaries of their parent.
    When `QSG_VISUALIZE` is set to `clip`, red spots appear on top of the scene to
    indicate clipping. Because Qt Quick `Items` do not clip by default, clipping is
    often not shown. Clipping prevents the ability to batch multiple components together,
    which impacts graphical performance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从`Item`派生的QML组件都有一个名为`clip`的属性。默认情况下，`clip`值设置为`false`。此属性通知场景图不要渲染超出其父级边界的任何子元素。当`QSG_VISUALIZE`设置为`clip`时，红点会出现在场景顶部以指示剪切。因为Qt
    Quick `Items`默认不剪切，所以通常不会显示剪切。剪切会阻止将多个组件批处理在一起，这会影响图形性能。
- en: When `QSG_VISUALIZE` is set to `changes`, changes in the renderer are shown.
    A flashing overlay of random color is used to highlight changes in the scene graph.
    Modifications to a primitive are shown by a solid color, but changes to an ancestor—
    such as changes to the matrix or opacity—are shown by a pattern.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当`QSG_VISUALIZE`设置为`changes`时，渲染器中的更改会显示出来。随机颜色的闪烁叠加用于突出显示场景图中的更改。对基元的修改显示为纯色，但对祖先的更改（例如对矩阵或不透明度的更改）则显示为图案。
- en: 'Experiment with these environment variables in your Qt Quick application. You
    can learn more about these rendering flags at the following link: [https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Qt Quick应用程序中尝试这些环境变量。您可以在以下链接了解有关这些渲染标志的更多信息：[https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html)。
- en: Qt Quick helps in building great applications with a fluid UI and dynamic transitions.
    However, you should consider some of the factors to avoid performance implications.
    When you add an animation to a property, all bindings are impacted and re-evaluated,
    which references the property. To avoid performance issues, you may remove the
    binding before running the animation and then reassign it after the animation
    is complete. During the animation, avoid using JavaScript. Script animations should
    be used with caution because they run in the main thread.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick有助于构建具有流畅UI和动态过渡的出色应用程序。但是，您应该考虑一些因素以避免性能影响。当您向属性添加动画时，所有绑定都会受到影响并重新评估，这会引用该属性。为了避免性能问题，您可以在运行动画之前删除绑定，然后在动画完成后重新分配它。在动画期间，避免使用JavaScript。应谨慎使用脚本动画，因为它们在主线程中运行。
- en: 'You can use Qt Quick particles to create a nice particle effect. However, its
    performance depends on underlying hardware capabilities. To render more particles,
    you will need faster graphics hardware. Your graphics hardware should be capable
    to draw at or above 60 FPS. You can learn more about optimizing particle performance
    at the following link: [https://doc.qt.io/qt-6/qtquick-particles-performance.html](https://doc.qt.io/qt-6/qtquick-particles-performance.html).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Qt Quick粒子创建漂亮的粒子效果。但是，其性能取决于底层硬件能力。要渲染更多粒子，您需要更快的图形硬件。您的图形硬件应能够以60 FPS或更高的速度绘制。您可以在以下链接了解有关优化粒子性能的更多信息：[https://doc.qt.io/qt-6/qtquick-particles-performance.html](https://doc.qt.io/qt-6/qtquick-particles-performance.html)。
- en: In this section, we discussed different considerations to optimize graphical
    performance. In the next section, we will discuss further how to benchmark your
    application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了优化图形性能的不同考虑因素。在下一节中，我们将进一步讨论如何对应用程序进行基准测试。
- en: Creating benchmarks
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基准测试
- en: We have learned about benchmarking in [*Chapter 9*](B16231_09_Final_ASB_ePub.xhtml#_idTextAnchor221),
    *Testing and Debugging*. Let's look at some aspects of benchmarking to evaluate
    performance issues. We've already talked about Qt Test's support for benchmarking,
    which is a calculation of the average time required by a particular task. The
    `QBENCHMARK` macro is used to benchmark a function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第9章*](B16231_09_Final_ASB_ePub.xhtml#_idTextAnchor221)中学习了基准测试，*测试和调试*。让我们看一下基准测试的一些方面，以评估性能问题。我们已经讨论了Qt
    Test对基准测试的支持，这是对特定任务所需的平均时间的计算。`QBENCHMARK`宏用于对函数进行基准测试。
- en: 'The following code snippet shows benchmarking key clicks on a line edit:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了对行编辑中关键点击的基准测试：
- en: '[PRE7]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also benchmark convenience functions provided by Qt. The following
    code benchmarks the `QString::localeAwareCompare()` function. Let''s look at the
    sample code here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以对Qt提供的便利函数进行基准测试。以下代码对`QString::localeAwareCompare()`函数进行基准测试。让我们看一下这里的示例代码：
- en: '[PRE8]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also run benchmark tests in QML. The Qt benchmark framework will run
    functions with names that begin with `benchmark_` several times, with an average
    timing value recorded for the runs. It is similar to the `QBENCHMARK` macro in
    the C++ version of `QTestLib`. You can prefix the test function name with `benchmark_once_`
    to get the effect of the `QBENCHMARK_ONCE` macro.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在QML中运行基准测试。Qt基准测试框架将以`benchmark_`开头的函数运行多次，并记录运行的平均时间值。这类似于C++版本的`QTestLib`中的`QBENCHMARK`宏。您可以在测试函数名称前加上`benchmark_once_`以获得`QBENCHMARK_ONCE`宏的效果。
- en: 'You can also use the `Benchmark` or `CreationBenchmark`. It also allows you
    to perform both automated and manual benchmarking. Automated tests can be used
    for regression testing, whereas manual tests can be done to understand the capabilities
    of new hardware. It comes with built-in features such as the FPS counter, which
    is very important for GUI applications. You can find the frame rate by running
    the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Benchmark`或`CreationBenchmark`。它还允许您执行自动化和手动基准测试。自动化测试可用于回归测试，而手动测试可用于了解新硬件的功能。它具有内置功能，如FPS计数器，对于GUI应用程序非常重要。您可以通过运行以下命令找到帧速率：
- en: '[PRE9]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also run all the automated tests with a simple command, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过简单的命令运行所有自动化测试，如下所示：
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To explore more about the tool and look at the examples, please refer to the
    following link: [https://github.com/qt-labs/qmlbench](https://github.com/qt-labs/qmlbench).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关该工具的更多信息并查看示例，请参阅以下链接：[https://github.com/qt-labs/qmlbench](https://github.com/qt-labs/qmlbench)。
- en: 'We have seen benchmarking object creation in Qt Widgets and QML and we also
    benchmarked a Qt function. You can also analyze without using any macros. You
    can simply use `QTime` or `QElapsedTimer` to measure the time taken by a portion
    of a code or a function, as illustrated in the following code snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在Qt Widgets和QML中基准测试对象创建，我们还对Qt函数进行了基准测试。您还可以在不使用任何宏的情况下进行分析。您可以简单地使用`QTime`或`QElapsedTimer`来测量代码或函数部分所花费的时间，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we have used `elapsed()` to measure the time
    taken for a code segment. The difference is that you can evaluate a few lines
    inside a function—you don't have to write a separate test project. It's a quick
    way to find performance issues without evaluating a whole project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`elapsed()`来测量代码段所花费的时间。不同之处在于您可以在函数内评估几行代码，而不必编写单独的测试项目。这是一种快速找到性能问题的方法，而不必评估整个项目。
- en: 'You can also benchmark your Qt Quick 3D application. Here''s an article on
    how to do it: [https://www.qt.io/blog/introducing-qtquick3d-benchmarking-application](https://www.qt.io/blog/introducing-qtquick3d-benchmarking-application).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以对您的Qt Quick 3D应用程序进行基准测试。以下是如何执行的文章：[https://www.qt.io/blog/introducing-qtquick3d-benchmarking-application](https://www.qt.io/blog/introducing-qtquick3d-benchmarking-application)。
- en: In this section, we discussed benchmarking techniques. In the next section,
    we will discuss more profiling tools.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了基准测试技术。在下一节中，我们将讨论更多的分析工具。
- en: Different analysis tools and optimization strategies
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的分析工具和优化策略
- en: You can optimize your application at multiple levels other than just at a code
    level. Optimization can also be done at a memory or binary. You can modify your
    application to make it work more efficiently by using fewer resources. However,
    there can be a trade-off between memory and performance. Based on your hardware
    configuration, you can decide a strategy as to whether memory usage or processing
    time is important. In some embedded platforms with memory limitations, you can
    allow the processing time to be a little longer to use less memory and keep the
    application responsive. You can also delegate some part of the optimization task
    to the compiler.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码级别以外的多个级别优化您的应用程序。优化也可以在内存或二进制上进行。您可以修改应用程序以使其更有效地使用更少的资源。但是，内存和性能之间可能存在权衡。根据您的硬件配置，您可以决定内存使用或处理时间哪个更重要。在一些具有内存限制的嵌入式平台上，您可以允许处理时间稍长一些，以使用更少的内存并保持应用程序的响应性。您还可以将优化任务的一部分委托给编译器。
- en: Let's have a look at different strategies we can use to build, analyze, and
    deploy faster.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以使用哪些不同的策略来构建、分析和部署更快。
- en: Memory profiling and analysis tools
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分析和分析工具
- en: In this section, we will discuss some additional tools you can use to analyze
    your application. Note that we won't be discussing these tools in detail. You
    can visit the respective tool website and learn from their documentation. In addition
    to the available tools in Qt Creator, you can use the following tools on your
    Windows machine.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些额外的工具，您可以使用这些工具来分析您的应用程序。请注意，我们不会详细讨论这些工具。您可以访问各自的工具网站，并从其文档中学习。除了Qt
    Creator中提供的工具之外，您还可以在Windows机器上使用以下工具。
- en: 'Let''s have a look at the list of tools, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看工具列表，如下所示：
- en: '**AddressSanitizer** (**ASan**) is an address monitoring tool built by Google
    and part of Sanitizers.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AddressSanitizer**（**ASan**）是由Google开发的地址监视工具，是Sanitizers的一部分。'
- en: '**AQTime Pro** finds issues and memory leaks with application runtime analysis
    and performance profiling.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AQTime Pro**通过应用程序运行时分析和性能分析找到问题和内存泄漏。'
- en: '**Deleaker** is a tool for C++ developers who want to find all possible known
    leaks in their projects. It can detect memory leaks, **Graphics Device Interface**
    (**GDI**) leaks, and other leaks.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deleaker**是一个面向C++开发人员的工具，他们希望在其项目中找到所有可能的已知泄漏。它可以检测内存泄漏、**图形设备接口**（**GDI**）泄漏和其他泄漏。'
- en: '**Intel Inspector XE** is a memory and thread debugger from Intel.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intel Inspector XE**是英特尔的内存和线程调试器。'
- en: '**PurifyPlus** is a runtime analysis tool suite that monitors your program
    as it runs and reports on key aspects of its behavior.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PurifyPlus**是一个运行时分析工具套件，可在程序运行时监视您的程序并报告其行为的关键方面。'
- en: '**Visual Leak Detector** is a free, robust, open-source memory leak detection
    system for Visual C++.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Leak Detector**是Visual C++的免费、强大、开源的内存泄漏检测系统。'
- en: '**Very Sleepy** is a CPU profiler based on sampling.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Very Sleepy**是基于采样的CPU分析器。'
- en: '**Visual Studio Profiler** (**VSTS**) can be used for CPU sampling, instrumentation,
    and memory allocation.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Profiler**（**VSTS**）可用于CPU采样、插装和内存分配。'
- en: '**MTuner** utilizes a novel approach to memory profiling and analysis, keeping
    an entire time-based history of memory operations.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MTuner**采用一种新颖的方法进行内存分析和分析，保留了整个基于时间的内存操作历史记录。'
- en: '**Memory Leak Detection Tool** is a high-performance memory leak detection
    tool.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memory Leak Detection Tool**是一个高性能的内存泄漏检测工具。'
- en: '**Heob** detects buffer overruns and memory leaks. Integrated into Qt Creator.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heob**可以检测缓冲区溢出和内存泄漏。集成到Qt Creator中。'
- en: '**Process Explorer** can query and visualize several systems and performance
    counters for each process, and I regularly use it for preliminary investigations.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Process Explorer**可以查询和可视化每个进程的多个系统和性能计数器，我经常用它进行初步调查。'
- en: '**System Explorer** shows all system calls issued by any running processes
    in a long list and supports filters to select processes we''d like to observe.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System Explorer**显示任何运行进程发出的所有系统调用的长列表，并支持选择我们想要观察的进程的过滤器。'
- en: '**RAMMap** examines a system''s global memory usage, which requires quite a
    bit of Windows internal knowledge.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAMMap**检查系统的全局内存使用情况，这需要相当多的Windows内部知识。'
- en: '**VMMap** shows detailed information on a single application''s memory usage.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMMap**显示单个应用程序的内存使用的详细信息。'
- en: '**Coreinfo** gives detailed information about the processor, information you
    might need when doing low-level optimization work.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Coreinfo**提供有关处理器的详细信息，这是您在进行低级优化工作时可能需要的信息。'
- en: '**Bloaty** performs a deep analysis of the binary. It aims to accurately attribute
    every byte of the binary to a symbol or compile the unit that produced it.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bloaty**对二进制文件进行深入分析。它旨在准确地将二进制文件的每个字节归因于产生它的符号或编译单元。'
- en: In this section, we briefed you about some of the third-party profiling tools.
    In the next section, we will discuss how to optimize your binary during linking.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您简要介绍了一些第三方分析工具。在下一节中，我们将讨论如何在链接期间优化二进制文件。
- en: Optimizing during linking
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接期间进行优化
- en: In earlier sections, we discussed how to find bottlenecks and optimize a code
    segment that is impacting an application's performance. Fortunately, most compilers
    now include a mechanism that allows you to do such optimizations while maintaining
    the modularity and cleanliness of your code. This is referred to as **link-time
    code generation** (**LTCG**) or **link-time optimization** (**LTO**). LTO is the
    optimization of a program during the linking process. The linker collects all
    object files and integrates them into a single program. Because the linker can
    view the entire program, it can do whole-program analysis and optimization. However,
    the linker generally only sees the program after it has been translated into machine
    code. Rather than converting each source file to machine code one by one, we postpone
    the code-generation procedure until the very end—linking time. Code generation
    at linking time enables not just smart inlining of code but also does optimizations
    such as devirtualizing functions and better elimination of redundant code. This
    technique can be used to improve application launch time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了如何找到瓶颈并优化影响应用程序性能的代码段。幸运的是，大多数编译器现在都包括一种机制，允许您在保持代码的模块化和清晰性的同时进行这些优化。这被称为**链接时代码生成**（**LTCG**）或**链接时优化**（**LTO**）。LTO是在链接过程中对程序进行优化。链接器收集所有目标文件并将它们集成到一个程序中。由于链接器可以查看整个程序，它可以进行整个程序的分析和优化。然而，链接器通常只在程序被转换为机器代码之后才能看到程序。我们不是将每个源文件逐个转换为机器代码，而是将代码生成过程推迟到最后—链接时间。在链接时间进行代码生成不仅可以智能地内联代码，还可以进行诸如取消虚拟函数和更好地消除冗余代码等优化。这种技术可用于改善应用程序的启动时间。
- en: To enable this mechanism in Qt, you have to build from the source code. At the
    configure step, add `-ltcg` to the command-line options. Compiling all of your
    source code at once during the compilation stage will provide you all of the optimization
    benefits of full LTO. You can optimize your application launch time at a toolchain,
    platform, and application level.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Qt中启用此机制，您必须从源代码构建。在配置步骤中，将`-ltcg`添加到命令行选项。在编译阶段一次性编译所有源代码将为您提供完整LTO的所有优化好处。您可以在工具链、平台和应用程序级别优化应用程序的启动时间。
- en: 'Learn more about these performance tips at the following link: [https://wiki.qt.io/Performance_Tip_Startup_Time](https://wiki.qt.io/Performance_Tip_Startup_Time).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接了解更多关于这些性能提示：[https://wiki.qt.io/Performance_Tip_Startup_Time](https://wiki.qt.io/Performance_Tip_Startup_Time)。
- en: You can delegate the optimization task to the compiler at times. When you enable
    optimization flags, the compiler will try to boost the performance and optimize
    the code block, at the cost of compilation time and—probably—debugging capability.
    You can enable compiler-level optimization flags for your desired compilers such
    as **GNU Compiler Collection** (**GCC**) or Clang.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可以将优化任务委托给编译器。当您启用优化标志时，编译器将尝试提高性能并优化代码块，代价是编译时间和—可能—调试能力。您可以为所需的编译器启用编译器级优化标志，如**GNU编译器集合**（**GCC**）或Clang。
- en: 'Look at GCC optimization options for available C++ compilers at the following
    link: [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GCC优化选项，可用C++编译器的链接：[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)。
- en: 'You can learn about different flags in Clang at the following link: [https://clang.llvm.org/docs/CommandGuide/clang.html](https://clang.llvm.org/docs/CommandGuide/clang.html).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解Clang中的不同标志：[https://clang.llvm.org/docs/CommandGuide/clang.html](https://clang.llvm.org/docs/CommandGuide/clang.html)。
- en: In this section, you learned about link-time optimization. In the next section,
    we will discuss how to build your Qt application faster.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了链接时优化。在下一节中，我们将讨论如何更快地构建您的Qt应用程序。
- en: Building a Qt application faster
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快地构建Qt应用程序
- en: In a large complex project, the time spent on building a project is increasingly
    becoming valuable. In general, the longer the build time, the more time you lose
    every day. If you multiply that by the time for a complete team, you lose a lot
    of time just waiting for the build to finish. While having to wait hours for each
    small change to be rebuilt might make you more careful about details and drive
    you to think about each step in depth, it may also limit a more Agile process
    or collaboration. In this section, we will provide a short guide for dealing with
    optimization in C++ using Qt.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型复杂项目中，构建项目所花费的时间越来越有价值。一般来说，构建时间越长，每天失去的时间就越多。如果将这个时间乘以一个完整团队的时间，你就会花费很多时间等待构建完成。虽然不得不等待每个小改动重新构建数小时可能会使您更加注意细节，并迫使您深入思考每一步，但它也可能限制更敏捷的流程或协作。在本节中，我们将提供一个简短的指南，介绍如何使用Qt处理C++中的优化。
- en: 'Please note the following points you should follow to speed up your build process:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下几点，以加快构建过程：
- en: Use parallel building flags
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行构建标志
- en: Make use of a precompiled header (`pch`)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用预编译头（`pch`）
- en: Remove redundant targets from makefile
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从makefile中删除冗余的目标
- en: Use forward declarations in classes
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中使用前向声明
- en: 'The most effective way while building a large project is to use a parallel-build
    approach. A parallel build can be enabled by passing an additional parameter.
    In Qt Creator, you can enable `-j8`. You can instruct your compiler to build in
    a parallel way through the following command-line statement:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大型项目时，最有效的方法是使用并行构建方法。可以通过传递额外的参数来启用并行构建。在Qt Creator中，您可以启用`-j8`。您可以通过以下命令行语句指示编译器以并行方式构建：
- en: '[PRE12]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last number depends on your hardware. `-j8` instructs to run eight threads
    in parallel. Based on your machine configuration, you may use `-j4`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的数字取决于您的硬件。`-j8`指示并行运行八个线程。根据您的机器配置，您可以使用`-j4`。
- en: 'You can also enable a parallel build for the `-MP` flag. You can instruct `cl`
    to run parallel by adding the following flag in the `.pro` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为`-MP`标志启用并行构建。您可以通过在`.pro`文件中添加以下标志来指示`cl`并行运行：
- en: '[PRE13]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A precompiled header is an excellent technique to drastically minimize a compiler's
    load. When a compiler parses a file, it must parse the entire code, along with
    the standard headers and other third-party sources. `pch` allows you to define
    which files are frequently used so that the compiler may precompile them before
    starting a build and utilize the results while building each `.cpp` file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译头是一种极大地减少编译器负担的优秀技术。当编译器解析文件时，它必须解析整个代码，包括标准头文件和其他第三方源。`pch`允许您定义哪些文件经常使用，以便编译器在开始构建之前对它们进行预编译，并在构建每个`.cpp`文件时利用结果。
- en: 'To use a precompiled header file, add the following lines of code to the `.pro`
    file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预编译头文件，请将以下代码添加到`.pro`文件中：
- en: '[PRE14]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you use the `Q_OBJECT` macro, the meta-object compiler generates additional
    files. Don't use the `Q_OBJECT` macro unnecessarily, unless you require relevant
    features such as the signals and slots mechanism or translation. When you add
    the `Q_OBJECT` macro, `moc` will generate a `moc_<ClassName>.cpp` file, which
    adds to the compilation complexity.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`Q_OBJECT`宏，元对象编译器会生成额外的文件。除非您需要相关功能，如信号和槽机制或翻译，否则不要不必要地使用`Q_OBJECT`宏。当您添加`Q_OBJECT`宏时，`moc`将生成一个`moc_<ClassName>.cpp`文件，这会增加编译的复杂性。
- en: 'You can include this file at the end of your `.cpp` file, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`.cpp`文件的末尾包含此文件，如下所示：
- en: '[PRE15]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also lower the dependencies of each `.cpp` file by using forward declarations
    for small projects and a forward header in large projects. Forwarding classes
    will shorten the duration of a partial build during standard work. Most classes
    can contain forward declarations in the `forwards.h` file. By having such a file,
    you may drastically minimize the number of includes in header files, usually by
    including `forwards.h`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在小型项目中使用前向声明和在大型项目中使用前向头文件来降低每个`.cpp`文件的依赖关系。前向类将缩短标准工作期间部分构建的持续时间。大多数类可以在`forwards.h`文件中包含前向声明。通过拥有这样的文件，您可以大大减少头文件中的包含数量，通常是包含`forwards.h`。
- en: As a result, `qmake` will notice this and remove this file from the list of
    targets. This will reduce the load on the compiler.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`qmake`会注意到这一点，并将此文件从目标列表中删除。这将减少编译器的负担。
- en: In this section, you learned how to reduce the application build time. In the
    next section, we will discuss some of the best practices in the Qt Widgets-based
    application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了如何减少应用程序的构建时间。在下一节中，我们将讨论基于Qt Widgets的应用程序中的一些最佳实践。
- en: Performance considerations for Qt Widgets
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Widgets的性能考虑
- en: The Qt Widgets module renders widgets utilizing the raster engine, a software
    renders using CPU rather than GPU. In most cases, it can provide the desired performance.
    However, the Qt Widgets module is very old and lacks the latest capabilities.
    Since QML is entirely hardware-accelerated, you should consider adopting it for
    your application's UI.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Widgets模块利用光栅引擎渲染小部件，这是一种使用CPU而不是GPU的软件渲染。在大多数情况下，它可以提供所需的性能。但是，Qt Widgets模块非常古老，缺乏最新的功能。由于QML完全是硬件加速的，您应该考虑在应用程序的UI中采用它。
- en: If your widgets don't need `mouseTracking`, `tabletTracking`, or similar event
    capturing, turn it off. Your application will use more CPU time as a result of
    this tracking. Maintain a smaller style sheet and keep it all in one style sheet
    instead of applying it to individual widgets. A large style sheet will take longer
    for Qt to process the information into the rendering system, which may affect
    the application's performance. Use custom styles instead of a style sheet as this
    can provide you better performance.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的小部件不需要`mouseTracking`、`tabletTracking`或类似的事件捕获，请关闭它。由于此跟踪，您的应用程序将使用更多的CPU时间。保持较小的样式表，并将其全部放在一个样式表中，而不是应用于单个小部件。大型样式表将需要更长的时间才能将信息处理到渲染系统中，这可能会影响应用程序的性能。使用自定义样式而不是样式表，因为这可以为您提供更好的性能。
- en: Don't create screens unnecessarily and keep them hidden. Create a screen only
    when it is required. While using `QStackedWidget`, avoid adding too many pages
    and populating them with many widgets. It requires Qt to discover them all recursively
    during the rendering and event handling stages, causing the program to run slowly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不要不必要地创建屏幕并将其隐藏。只有在需要时才创建屏幕。在使用`QStackedWidget`时，避免添加太多页面并用许多小部件填充它们。这需要Qt在渲染和事件处理阶段递归地发现它们，导致程序运行缓慢。
- en: Use asynchronous methods wherever feasible for huge operations, to avoid blocking
    the main process, and keep your software running smoothly. Multithreading is extremely
    useful for parallelizing several processes in event loops. However, if not done
    correctly, such as by repeatedly creating and removing threads or by poorly implemented
    inter-thread communications, it may result in undesired outcome.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用异步方法进行大型操作，以避免阻塞主进程，并保持软件平稳运行。多线程对于在事件循环中并行化多个进程非常有用。但是，如果不正确地执行，例如通过重复创建和删除线程或实现不良的线程间通信，可能会导致不良结果。
- en: Different C++ containers yield different speeds. Qt's vector container is slightly
    slower than the one in the STL. Overall, the old C++ array is still the fastest,
    but it lacks sorting capabilities. Use what is most appropriate for your needs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的C++容器产生不同的速度。Qt的向量容器比STL中的向量容器稍慢。总的来说，旧的C++数组仍然是最快的，但它缺乏排序能力。使用最适合您需求的内容。
- en: In this section, you learned about best practices while using the Qt Widgets
    module. In the next section, we will discuss best practices in QML.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了在使用Qt Widgets模块时的最佳实践。在下一节中，我们将讨论QML的最佳实践。
- en: Learning best practices of QML coding
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习QML编码的最佳实践
- en: It is important to follow certain best practices while coding in QML. You should
    keep the file under a certain line limit and should have consistent indentation
    and structural attributes, as well as following a standard naming convention.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML编码时遵循某些最佳实践非常重要。您应该保持文件在一定的行限制内，并且应该具有一致的缩进和结构属性，以及遵循标准的命名约定。
- en: 'You can structure your QML object attributes in the following order:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下顺序结构化您的QML对象属性：
- en: '[PRE16]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you are using multiple properties from a group of properties, then use group
    notation, as shown next:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用一组属性中的多个属性，则使用组表示法，如下所示：
- en: '[PRE17]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Treating groups of properties as a block can ease confusion and help relate
    the properties with other properties.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将一组属性视为一个块可以减少混乱，并有助于将属性与其他属性相关联。
- en: QML and JavaScript do not enforce private properties like C++ does. There is
    a need to hide these private properties—for example, when the properties are part
    of the implementation. To effectively gain private properties in a QML item, you
    can embed inside a `QtObject{...}` to hide the properties. This prevents the properties
    from being accessed outside of the QML file and JavaScript. To minimize the impact
    on performance, try to group all private properties into the same `QtObject` scope.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: QML和JavaScript不像C++那样强制执行私有属性。有必要隐藏这些私有属性，例如当属性是实现的一部分时。为了在QML项中有效地获得私有属性，您可以将其嵌入到`QtObject{...}`中以隐藏这些属性。这可以防止在QML文件和JavaScript之外访问这些属性。为了最小化对性能的影响，尝试将所有私有属性分组到同一个`QtObject`范围中。
- en: 'The following code snippet illustrates the use of `QtObject`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了如何使用`QtObject`：
- en: '[PRE18]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It takes time for property resolution. While the result of a lookup can sometimes
    be cached and reused, it is generally preferable to avoid doing extra work if
    at all feasible. You should try to use the common base just once in a loop.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 属性解析需要时间。虽然查找的结果有时可以被缓存和重复使用，但通常最好避免额外的工作。您应该尝试在循环中只使用共同的基础一次。
- en: If any of the properties change, the property binding expression is re-evaluated.
    If you have a loop where you do some processing but only the result matters, then
    it is better to create a temporary accumulator then assign it to the property
    you want to update, rather than incrementally updating the property itself, to
    prevent triggering re-evaluation of binding expressions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何属性发生变化，属性绑定表达式将被重新评估。如果您有一个循环，在其中进行一些处理，但只有结果很重要，那么最好创建一个临时累加器，然后将其赋值给要更新的属性，而不是逐步更新属性本身，以防止触发绑定表达式的重新评估。
- en: To prevent a continuous overhead of leaving items that are invisible because
    they are children of a non-visible active element, they should be initialized
    lazily and destroyed when no longer in use. An object loaded using a `Loader`
    element may be released by resetting the `source` or `sourceComponent` property
    of `Loader`, but other items can be explicitly destroyed. It may be required to
    keep the item active in some situations, in which case it should be made invisible.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免因为它们是不可见元素的子元素而持续产生开销，它们应该在需要时进行延迟初始化，并在不再使用时进行销毁。使用`Loader`元素加载的对象可以通过重置`Loader`的`source`或`sourceComponent`属性来释放，但其他项目可以显式销毁。在某些情况下可能需要保持项目处于活动状态，在这种情况下应该使其不可见。
- en: In general, opaque content is much faster to draw than translucent content.
    The reason for this is that translucent content requires blending, and the renderer
    may be able to better optimize opaque content. Even if an image has only one translucent
    pixel, it is viewed as totally transparent. The same may be said for a `BorderImage`
    element with translucent edges.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不透明内容的绘制速度比半透明内容快得多。原因在于半透明内容需要混合，而渲染器可能能够更好地优化不透明内容。即使一幅图像只有一个半透明像素，它也被视为完全透明。对于具有半透明边缘的`BorderImage`元素也可以这样说。
- en: Avoid doing long logical calculations in QML. Use C++ for implementing business
    logic. If you still need to use JavaScript-based implementation for doing some
    complex operation or processing, then use `WorkerScript`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在QML中进行长时间的逻辑计算。使用C++来实现业务逻辑。如果仍然需要使用基于JavaScript的实现来执行一些复杂的操作或处理，则使用`WorkerScript`。
- en: 'The Qt Quick Compiler lets you compile QML source code into a final binary.
    The application''s launch time can be greatly reduced by enabling this. You do
    not have to deploy the `.qml` files along with the application. You can enable
    Qt Quick Compiler by adding the following line to your Qt project (`.pro`) file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick编译器允许您将QML源代码编译成最终的二进制文件。通过启用这一功能，可以大大减少应用程序的启动时间。您不必将`.qml`文件与应用程序一起部署。您可以通过将以下行添加到Qt项目（`.pro`）文件中来启用Qt
    Quick编译器：
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To learn more about Qt Quick best practices, read the documentation at the
    following link: [https://doc.qt.io/qt-6/qtquick-bestpractices.html](https://doc.qt.io/qt-6/qtquick-bestpractices.html).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Qt Quick最佳实践的信息，请阅读以下链接的文档：[https://doc.qt.io/qt-6/qtquick-bestpractices.html](https://doc.qt.io/qt-6/qtquick-bestpractices.html)。
- en: 'You can also explore more about Qt Quick performance in the documentation found
    at the following link: [https://doc.qt.io/qt-6/qtquick-performance.html](https://doc.qt.io/qt-6/qtquick-performance.html).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在以下链接找到的文档中了解更多关于Qt Quick性能的信息：[https://doc.qt.io/qt-6/qtquick-performance.html](https://doc.qt.io/qt-6/qtquick-performance.html)。
- en: In this section, we learned some of the best practices while coding in QML.
    We will now summarize our learning in this chapter.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在QML编码时的一些最佳实践。现在我们将在本章总结我们的学习。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed performance considerations and how to improve
    your overall application performance. We started with improving C++ code. Then,
    we explained how concurrency techniques can help in making your application faster.
    You learned about QML Profiler and other profiling tools. You also understood
    the importance of using best practices while coding in Qt. Now, you can use these
    techniques in everyday coding. You don't have to be an extraordinary application
    developer to do performance optimization. If you follow best practices, design
    patterns, and write better algorithms, then your application will have fewer defects
    and fewer customer complaints. It is a continuous process, and you will gradually
    become better at it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了性能考虑因素以及如何提高整体应用程序性能。我们从改进C++代码开始。然后，我们解释了并发技术如何帮助加快应用程序速度。您了解了QML
    Profiler和其他性能分析工具的重要性。您还了解了在Qt编码时使用最佳实践的重要性。现在，您可以在日常编码中使用这些技术。您不必成为非凡的应用程序开发人员来进行性能优化。如果您遵循最佳实践、设计模式并编写更好的算法，那么您的应用程序将有更少的缺陷和更少的客户投诉。这是一个持续的过程，您将逐渐变得更好。
- en: Congratulations! You have learned the basics of performance optimization. If
    you are curious to know more, then you can read more books specifically written
    for performance tuning. Happy coding in Qt. Remember—writing better and high-performant
    code can reduce the CPU cycle, which in turn reduces the carbon footprint, hence
    effectively, if you code better, you can save the planet and fight climate change!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经学会了性能优化的基础知识。如果您想了解更多，可以阅读专门为性能调优编写的更多书籍。在Qt中愉快地编码。记住，编写更好和高性能的代码可以减少CPU周期，从而减少碳足迹，因此，如果您编写更好的代码，您可以拯救地球，抵抗气候变化！
