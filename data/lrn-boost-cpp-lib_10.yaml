- en: Chapter 10. Concurrency with Boost
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用Boost进行并发
- en: '**Threads** represent concurrent streams of execution within a process. They
    are a low-level abstraction for **concurrency** and are exposed by the system
    programming libraries or system call interfaces of operating systems, for example,
    POSIX threads, Win32 Threads. On multiprocessor or multicore systems, operating
    systems can schedule two threads from the same process to run in parallel on two
    different cores, thus achieving true **parallelism**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**代表进程内的并发执行流。它们是**并发**的低级抽象，并由操作系统的系统编程库或系统调用接口公开，例如，POSIX线程、Win32线程。在多处理器或多核系统上，操作系统可以调度同一进程的两个线程在两个不同的核上并行运行，从而实现真正的**并行**。'
- en: Threads are a popular mechanism to abstract concurrent tasks that can potentially
    run in parallel with other such tasks. Done right, threads can simplify program
    structure and improve performance. However, concurrency and parallelism introduce
    complexities and nondeterministic behavior unseen in single-threaded programs,
    and doing it right can often be the biggest challenge when it comes to threads.
    A wide variance in the native multithreading libraries or interfaces across operating
    systems makes the tasks of writing portable concurrent software using threads
    even more difficult. The Boost Thread library eases this problem by providing
    a portable interface to create threads and higher level abstractions for concurrent
    tasks. The **Boost Coroutine** library provides a mechanism to create cooperative
    *coroutines* or functions which can be exited and resumed, retaining states of
    automatic objects between such calls. Coroutines can express event-driven logic
    in a simpler way, and avoid the overhead of threads in some cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一种流行的机制，用于抽象可能与其他类似任务并行运行的并发任务。如果做得好，线程可以简化程序结构并提高性能。然而，并发和并行性引入了在单线程程序中看不到的复杂性和非确定性行为，做到正确通常是涉及线程时最大的挑战。不同操作系统上本地多线程库或接口的广泛差异使得使用线程编写可移植的并发软件的任务变得更加困难。Boost
    Thread库通过提供一个可移植的接口来创建线程和更高级别的抽象来缓解这个问题。Boost Coroutine库提供了一种创建协作*协程*或可以退出和恢复的函数的机制，在这些调用之间保留自动对象的状态。协程可以以更简单的方式表达事件驱动逻辑，并在某些情况下避免线程的开销。
- en: 'This chapter is a hands-on introduction to using the Boost Thread library and
    also features a short account of the Boost Coroutine library. It is divided into
    the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对使用Boost Thread库的实际介绍，还包括对Boost Coroutine库的简要介绍。它分为以下几个部分：
- en: Creating concurrent tasks with Boost Thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost Thread创建并发任务
- en: Concurrency, signaling, and synchronization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发、信号和同步
- en: Boost Coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost协程
- en: Even if you have never written multithreaded programs or concurrent software,
    this would be a good starting point. We will also touch upon the thread library
    in the C++11 Standard Library, which is based on the Boost Thread library and
    introduces additional refinements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您从未编写过多线程程序或并发软件，这也是一个很好的起点。我们还将涉及基于Boost Thread库的C++11标准库中的线程库，并引入额外的改进。
- en: Creating concurrent tasks with Boost Thread
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost Thread创建并发任务
- en: 'Consider a program that prints greetings in different languages. There is one
    list of greetings in Anglo-Saxon languages, such as English, German, Dutch, Danish,
    and so on. There is a second list of greetings in Romance languages, such as Italian,
    Spanish, French, Portuguese, and so on. Greetings from both language groups need
    to be printed, and we do not want to delay printing the greetings from one group
    because of the other, that is, we want to print greetings from both the groups
    *concurrently*. Here is one way to print both the groups of greetings:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个以不同语言打印问候语的程序。有一个用盎撒克逊语言，如英语、德语、荷兰语、丹麦语等的问候语列表。还有一个用罗曼语言，如意大利语、西班牙语、法语、葡萄牙语等的问候语列表。需要打印来自两种语言组的问候语，我们不希望因为其中一组的问候语而延迟打印另一组的问候语，也就是说，我们希望同时打印来自两个组的问候语。以下是同时打印两组问候语的一种方法：
- en: '**Listing 10.1: Interleaved tasks**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.1：交错任务**'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we have two vectors of greetings, and printing the
    greetings in each is an independent task. We interleave these two tasks by printing
    one greeting from each array, and thus the two tasks progress concurrently. From
    the code, we can tell that a Latin and an Anglo-Saxon greeting will be printed
    alternately in the exact order as shown:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有两个问候语的向量，并且在每个向量中打印问候语是一个独立的任务。我们通过从每个数组中打印一个问候语来交错这两个任务，因此这两个任务同时进行。从代码中，我们可以看出拉丁语和盎格鲁-撒克逊语的问候语将交替打印，顺序如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the two tasks were run interleaved, and in that sense concurrently, the
    distinction between them in code was totally muddled to the extent that they were
    coded in a single function. By separating them into separate functions and running
    them in separate threads, the tasks can be totally decoupled from each other yet
    be run concurrently. In addition, threads would allow for their parallel execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个任务是交替运行的，并且在某种意义上是同时进行的，但它们在代码中的区别完全混乱，以至于它们被编码在一个单一的函数中。通过将它们分开成单独的函数并在单独的线程中运行，这些任务可以完全解耦，但可以同时运行。此外，线程可以允许它们并行执行。
- en: Using Boost Threads
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost Threads
- en: 'Every running process has at least one thread of execution. A traditional "hello
    world" program with a `main` function also has a single thread, often called the
    **main thread**. Such programs are called **single-threaded**. Using Boost Threads,
    we can create programs with multiple threads of execution that run concurrent
    tasks. We can rewrite the listing 10.1 using Boost Threads so that the code for
    an individual task is cleanly factored out, and the tasks potentially run in parallel
    when parallel hardware is available. Here is how we can do this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行的进程至少有一个执行线程。传统的“hello world”程序具有一个`main`函数，也有一个单一线程，通常称为**主线程**。这样的程序称为**单线程**。使用Boost
    Threads，我们可以创建具有多个执行线程的程序，这些线程并发运行任务。我们可以使用Boost Threads重写列表10.1，以便将单个任务的代码清晰地分解出来，并且在有并行硬件可用时，任务可能并行运行。我们可以这样做：
- en: '**Listing 10.2: Concurrent tasks as threads**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.2：作为线程的并发任务**'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We define a function `printGreets` that takes a vector of greetings and prints
    all the greetings in the vector (lines 8-13). This is the code for the task, simplified
    and factored out. This function is invoked once each on the two greeting vectors.
    It is called once from the `main` function, which executes in the main thread
    (line 17), and once from a second thread of execution that we spawn by instantiating
    an object of type `boost::thread`, passing it the function to invoke and its arguments
    (line 16). The header file `boost/thread.hpp` provides types and functions needed
    for using Boost Threads (line 1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数`printGreets`，它接受一个问候语的向量并打印向量中的所有问候语（第8-13行）。这是任务的代码，简化并分解出来。这个函数在两个问候语向量上分别被调用一次。它从`main`函数中调用一次，该函数在主线程中执行（第17行），并且从我们通过实例化`boost::thread`对象来生成的第二个执行线程中调用一次，传递给它要调用的函数和它的参数（第16行）。头文件`boost/thread.hpp`提供了使用Boost
    Threads所需的类型和函数（第1行）。
- en: The object `t1` of type `boost::thread` wraps a native thread, for example,
    `pthread_t`, Win32 thread `HANDLE`, and so on. For conciseness, we simply refer
    to "the thread `t1`" to mean the underlying thread as well as the `boost::thread`
    object wrapping it, unless it is necessary to distinguish between the two. The
    object `t1` is constructed by passing a function object (the initial function
    of the thread) and all the arguments to pass to the function object (line 16).
    Upon construction, the underlying native thread starts running immediately by
    calling the passed function with the arguments provided. The thread terminates
    when this function returns. This happens concurrently with the `printGreets` function
    called from the `main` function (line 17).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`boost::thread`的对象`t1`包装了一个本地线程，例如`pthread_t`，Win32线程`HANDLE`等。为了简洁起见，我们简单地指“线程`t1`”来表示底层线程以及包装它的`boost::thread`对象，除非有必要区分两者。通过传递函数对象（线16）和传递给函数对象的所有参数来构造对象`t1`。在构造时，底层本地线程立即通过调用传递的函数和提供的参数开始运行。当此函数返回时，线程终止。这与从`main`函数调用的`printGreets`函数（第17行）同时发生。
- en: 'One possible output from this program is:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的一个可能的输出是：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Latin greets are printed in the order they appear in the `romance` vector,
    and the Anglo-Saxon greets are printed in the order they appear in the `angloSaxon`
    vector. But there is no predictable order in which they are interleaved. This
    lack of determinism is a key feature in concurrent programming and a source of
    some of the difficulty. What is possibly more unnerving is that even the following
    output is possible:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 拉丁语问候语按照它们在`romance`向量中出现的顺序打印，盎格鲁-撒克逊语问候语按照它们在`angloSaxon`向量中出现的顺序打印。但它们交错的顺序是不可预测的。这种缺乏确定性是并发编程的一个关键特征，也是一些困难的来源。可能更令人不安的是，甚至以下输出也是可能的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the two greets `Buenos dias!` (Spanish) and `Godmorgen!` (Dutch)
    are interleaved, and `Good morning!` was printed before the new line following
    `Bom dia!` could be printed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个问候语`Buenos dias!`（西班牙语）和`Godmorgen!`（荷兰语）是交错的，而`Good morning!`在`Bom dia!`后的换行之前被打印出来。
- en: We call the `join` member function on `t1` to wait for the underlying thread
    to terminate (line 18). Since the main thread and the thread `t1` run concurrently,
    either can terminate before the other. If the `main` function terminated first,
    it would terminate the program and the `printGreets` function running in the thread
    `t1` would be terminated before it finished execution. By calling `join`, the
    main function ensures that it does not exit while `t1` is still running.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`t1`上调用`join`成员函数来等待底层线程终止（第18行）。由于主线程和线程`t1`并发运行，任何一个都可以在另一个之前终止。如果`main`函数先终止，它将终止程序，并且在线程`t1`中运行的`printGreets`函数在执行完之前将被终止。通过调用`join`，主函数确保在`t1`仍在运行时不会退出。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Linking against Boost Thread Library**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到Boost线程库
- en: Boost Thread is not a header-only library but has to be built from the sources.
    [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing Boost*, describes
    the details of building the Boost libraries from their sources, their **name layout
    variants**, and naming conventions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Thread不是一个仅包含头文件的库，而是必须从源代码构建的。[第1章](ch01.html "第1章。介绍Boost")，*介绍Boost*，描述了从源代码构建Boost库的细节，它们的**名称布局变体**和命名约定。
- en: To build a running program from listing 10.2, you need to link your compiled
    objects with these libraries. To build the preceding example, you must link with
    Boost Thread and Boost System libraries. On Linux, you must also link against
    `libpthread`, which contains the Pthreads library implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表10.2构建一个运行的程序，您需要将编译后的对象与这些库链接起来。要构建前面的示例，您必须链接Boost线程和Boost系统库。在Linux上，您还必须链接`libpthread`，其中包含Pthreads库的实现。
- en: 'Assuming the source file is `Listing9_2.cpp`, here is the g++ command line
    on Linux to compile and link the source to build a binary:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设源文件是`Listing9_2.cpp`，以下是在Linux上编译和链接源代码以构建二进制文件的g++命令行：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Linking to `libboost_chrono` is necessary only if we use the Boost Chrono library.
    The option `-pthread` sets the necessary preprocessor and linker flags to enable
    compiling a multithreaded application and linking it against `libpthread`. If
    you did not use your native package manager to install Boost on Linux, or if you
    are trying to build on another platform, such as Windows, then refer to the detailed
    build instructions in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing
    Boost*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用Boost Chrono库时才需要链接到`libboost_chrono`。选项`-pthread`设置了必要的预处理器和链接器标志，以启用编译多线程应用程序并将其链接到`libpthread`。如果您没有使用本机包管理器在Linux上安装Boost，或者正在尝试在其他平台上构建，比如Windows，则请参考[第1章](ch01.html
    "第1章。介绍Boost")中的详细构建说明，*介绍Boost*。
- en: If you are on C++11, you can use the Standard Library threads instead of Boost
    Threads. For this, you have to include the Standard Library header `thread`, and
    use `std::thread` instead of `boost::thread`. Boost Thread and `std::thread` are
    not drop-in replacements of each other, and therefore some changes would be necessary.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是C++11，可以使用标准库线程而不是Boost Threads。为此，您必须包含标准库头文件`thread`，并使用`std::thread`代替`boost::thread`。Boost
    Thread和`std::thread`不能直接替换彼此，因此可能需要进行一些更改。
- en: Moving threads and waiting on threads
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动线程和等待线程
- en: 'An object of `std::thread` is associated with and manages exactly one thread
    in a process. Consider the following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread`对象与进程中的一个线程关联并管理。考虑以下代码片段：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the `boost::thread` object `thr` is created (line 4), it gets associated
    with a new native thread (`pthread_t`, handle to a Windows thread, and so on),
    which executes the function pointed to by `thrFunc`. Now `boost::thread` is a
    movable but not a copyable type. When the `makeThread` function returns `thr`
    by value (line 7), the ownership of the underlying native thread handle is moved
    from the object `thr` in `makeThread` to `thr1` in the `main` function (line 11).
    Thus you can create a thread in one function and return it to the calling function,
    *transferring ownership* in the process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`boost::thread`对象`thr`（第4行）时，它与一个新的本机线程（`pthread_t`，Windows线程句柄等）相关联，该线程执行`thrFunc`指向的函数。现在`boost::thread`是可移动但不可复制的类型。当`makeThread`函数通过值返回`thr`（第7行）时，底层本机线程句柄的所有权从`makeThread`中的对象`thr`移动到`main`函数中的`thr1`（第11行）。因此，您可以在一个函数中创建一个线程，并将其返回给调用函数，在此过程中*转移所有权*。
- en: Ultimately though, we wait for the thread to finish execution inside the `main`
    function by calling `join` (line 13). This ensures that the `main` function does
    not exit until the thread `thr1` terminates. Now it is entirely possible that
    by the time `makeThread` returned `thr`, the underlying thread had already completed
    execution. In this case, `thr1.join()` (line 13) returns immediately. On the other
    hand, the underlying thread could well continue to execute while the control on
    the main thread is transferred to the `main` function, and even as `join` was
    called on `thr1` (line 13). In this case, `thr1.join()` would block, waiting for
    the thread to exit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们在`main`函数内等待线程完成执行，通过调用`join`（第13行）。这确保了在线程`thr1`终止之前，`main`函数不会退出。现在完全有可能，在`makeThread`返回`thr`时，底层线程已经完成了执行。在这种情况下，`thr1.join()`（第13行）会立即返回。另一方面，当主线程上的控制转移到`main`函数时，底层线程可能会继续执行，即使在`thr1`（第13行）上调用了`join`。在这种情况下，`thr1.join()`将会阻塞，等待线程退出。
- en: 'Sometimes, we may want a thread to run its course and exit, and we would never
    bother to check on it again. Moreover, it may not matter whether the thread terminated
    or not. Imagine a personal finance desktop application that features a nifty stock
    ticker thread that keeps displaying stock prices of a configurable set of companies
    in one corner of the window. It is started by the main application and keeps doing
    its job of fetching the latest prices of stocks and showing them until the application
    exits. There is little point for the main thread to wait on this thread before
    exiting. When the application terminates, the stock ticker thread is also terminated
    and cleaned up in its wake. We can explicitly request this behavior for a thread
    by calling `detach` on the `boost::thread` object, as shown in the following snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望一个线程运行完毕并退出，之后就不再关心它了。此外，线程是否终止可能并不重要。想象一下，一个个人财务桌面应用程序具有一个巧妙的股票行情线程，它在窗口的一个角落不断显示一组可配置公司的股票价格。它由主应用程序启动，并继续执行其获取最新股票价格并显示的工作，直到应用程序退出。主线程在退出之前等待此线程没有多大意义。应用程序终止时，股票行情线程也会终止并在其退出时进行清理。我们可以通过在`boost::thread`对象上调用`detach`来显式请求线程的此行为，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we call `detach` on a `boost::thread` object, the ownership of the underlying
    native thread is passed to the C++ runtime, which continues to execute the thread
    until either the thread terminates or the program terminates, killing the thread.
    After the call to `detach`, the `boost::thread` object no longer refers to a valid
    thread, and the program can no longer check the status of the thread or interact
    with it in any way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`boost::thread`对象上调用`detach`时，底层本机线程的所有权被传递给C++运行时，它将继续执行线程，直到线程终止或程序终止并杀死线程。在调用`detach`之后，`boost::thread`对象不再引用有效线程，程序不再能够检查线程的状态或以任何方式与其交互。
- en: A thread is said to be joinable if and only if neither `detach` nor `join` has
    been called on the `boost::thread` object. The `joinable` method on the `boost::thread`
    returns `true` if and only if the thread is joinable. If you call `detach` or
    `join` on a `boost::thread` object that is not joinable, the calls return immediately
    with no other effect. If we do not call `join` on a `boost::thread` object, then
    `detach` is called in its destructor, when the thread goes out of scope.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`boost::thread`对象上既没有调用`detach`也没有调用`join`时，线程才被认为是可连接的。`boost::thread`的`joinable`方法仅在线程可连接时返回`true`。如果您在不可连接的`boost::thread`对象上调用`detach`或`join`，则调用将立即返回，没有其他效果。如果我们没有在`boost::thread`对象上调用`join`，则在线程超出范围时将调用`detach`。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Differences between `boost::thread` and `std::thread`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread`和`std::thread`之间的区别'
- en: You must call either `join` or `detach` on a `std::thread` object; otherwise,
    the destructor of `std::thread` calls `std::terminate` and aborts the program.
    Moreover, calling `join` or `detach` on a `std::thread` that is not joinable will
    result in a `std::system_error` exception being thrown. Thus you call any one
    of `join` and `detach` on `std::thread`, and you do so once and only once. This
    is in contrast to the behavior of `boost::thread` we just described.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在`std::thread`对象上调用`join`或`detach`；否则，`std::thread`的析构函数将调用`std::terminate`并中止程序。此外，在不可连接的`std::thread`上调用`join`或`detach`将导致抛出`std::system_error`异常。因此，您在`std::thread`上调用`join`和`detach`中的任何一个，并且只调用一次。这与我们刚刚描述的`boost::thread`的行为相反。
- en: 'We can get `boost::thread` to emulate this behavior of `std::thread` by defining
    the following preprocessor macros, and it is a good idea to emulate the behavior
    of `std::thread` in any new code that you write:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义以下预处理器宏使`boost::thread`模拟`std::thread`的行为，而且在您编写的任何新代码中模拟`std::thread`的行为是一个好主意：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Thread IDs
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程ID
- en: At any time, each running thread in a process has a unique identifier. This
    identifier is represented by the type `boost::thread::id` and can be obtained
    from a `boost::thread` object by calling the `get_id` method. To get the ID of
    the current thread, we must use `boost::this_thread::get_id()`. A string representation
    of the ID can be printed to an `ostream` object, using an overloaded insertion
    operator (`operator<<`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，进程中的每个运行线程都有一个唯一的标识符。此标识符由类型`boost::thread::id`表示，并且可以通过调用`get_id`方法从`boost::thread`对象中获取。要获取当前线程的ID，我们必须使用`boost::this_thread::get_id()`。可以使用重载的插入运算符（`operator<<`）将ID的字符串表示打印到`ostream`对象中。
- en: 'Thread IDs can be ordered using an `operator<` so they can easily be stored
    in ordered associative containers (`std::set` / `std::map`). Thread IDs can be
    compared using an `operator==` and can be stored in unordered associative containers
    too (`std::unordered_set` / `std::unordered_map`). Storing threads in associative
    containers indexed by their IDs is an effective means of supporting lookups on
    threads:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 线程ID可以使用`operator<`进行排序，因此它们可以轻松地存储在有序的关联容器（`std::set` / `std::map`）中。线程ID可以使用`operator==`进行比较，并且可以存储在无序的关联容器中（`std::unordered_set`
    / `std::unordered_map`）。将线程存储在由其ID索引的关联容器中是支持线程查找的有效手段：
- en: '**Listing 10.3: Using thread IDs**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.3：使用线程ID**'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we create five threads and each runs the function
    `doStuff`. The function `doStuff` is passed an assigned name of the thread it
    runs; we name the threads `thread1` through `thread5`, and put them in a `std::map`
    indexed by their IDs (lines 26). Because `boost::thread` is movable but not copyable,
    we move the thread objects into the map. The `doStuff` function simply prints
    the ID of the current thread using the method `boost::this_thread::get_id` (line
    12), as part of some diagnostic message, and then sleeps for 2 seconds using `boost::this_thread::sleep_for`,
    which is passed a duration of type `boost::chrono::duration` (see [Chapter 8](ch08.html
    "Chapter 8. Date and Time Libraries"), *Date and Time Libraries*). We can also
    use duration types provided by Boost Date Time, that is, `boost::posix_time::time_duration`
    and its subtypes, instead of `boost::chrono`, but for that we would need to use
    the `boost::this_thread::sleep` function rather than `sleep_for`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了五个线程，每个线程都运行函数`doStuff`。函数`doStuff`被分配了一个线程运行的名称；我们将线程命名为`thread1`到`thread5`，并将它们放在一个由它们的ID索引的`std::map`中（第26行）。因为`boost::thread`是可移动但不可复制的，我们将线程对象移动到地图中。`doStuff`函数简单地使用`boost::this_thread::get_id`方法（第12行）打印当前线程的ID作为一些诊断消息的一部分，然后使用`boost::this_thread::sleep_for`休眠2秒，该方法接受`boost::chrono::duration`类型的持续时间（参见[第8章](ch08.html
    "第8章。日期和时间库")，“日期和时间库”）。我们还可以使用Boost Date Time提供的持续时间类型，即`boost::posix_time::time_duration`及其子类型，而不是`boost::chrono`，但是为此我们需要使用`boost::this_thread::sleep`函数而不是`sleep_for`。
- en: Cores and threads
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心和线程
- en: Many modern computers have multiple CPU cores on a single die and there might
    be multiple dice in a processor package. To get the number of physical cores on
    the computer, you can use the static function `boost::thread::physical_concurrency`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代计算机在单个芯片上有多个CPU核心，并且处理器包中可能有多个芯片。要获取计算机上的物理核心数，可以使用静态函数`boost::thread::physical_concurrency`。
- en: Modern Intel CPUs support Intel's HyperThreading technology, which maximizes
    utilization of a single core by using two sets of registers allowing two threads
    to be multiplexed on the core at any given point and reducing the costs of context
    switching. On an Intel system with eight cores and supporting HyperThreading,
    the maximum number of threads that can be scheduled to run in parallel at any
    given time is then 8x2 = 16\. The static function `boost::thread::hardware_concurrency`
    returns this number for the local machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现代英特尔CPU支持英特尔的超线程技术，该技术通过使用两组寄存器最大限度地利用单个核心，允许在任何给定时间点上在核心上复用两个线程，并降低上下文切换的成本。在支持超线程的具有八个核心的英特尔系统上，可以并行调度的最大线程数为8x2
    = 16。静态函数`boost::thread::hardware_concurrency`为本地机器返回此数字。
- en: These numbers are useful in deciding the optimal number of threads in your program.
    However, it is possible for these functions to return 0 if the numbers are not
    available from the underlying system. You should test these functions thoroughly
    on each platform where you plan to use them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字对于决定程序中的最佳线程数是有用的。但是，如果这些数字在底层系统中不可用，这些函数可能会返回 0。您应该在计划使用它们的每个平台上彻底测试这些函数。
- en: Managing shared data
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理共享数据
- en: All threads in a process have access to the same global memory, so the results
    of computations performed in one thread are relatively easy to share with other
    threads. Concurrent read-only operations on shared memory do not require any coordination,
    but any write to shared memory requires synchronization with any read or write.
    Threads that share *mutable data* and other resources need mechanisms to *arbitrate
    access* to shared data and signal each other about events and state changes. In
    this section, we explore the mechanisms for coordination between multiple threads.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进程中的所有线程都可以访问相同的全局内存，因此在一个线程中执行的计算结果相对容易与其他线程共享。对共享内存的并发只读操作不需要任何协调，但对共享内存的任何写入都需要与任何读取或写入同步。共享*可变数据*和其他资源的线程需要机制来*仲裁对共享数据的访问*并向彼此发出关于事件和状态更改的信号。在本节中，我们探讨了多个线程之间的协调机制。
- en: Creating and coordinating concurrent tasks
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和协调并发任务
- en: Consider a program that generates the difference between two text files à la
    the Unix `diff` utility. You need to read two files, and then apply an algorithm
    to identify the parts that are identical and the parts that have changed. For
    most text files, reading both the files and then applying a suitable algorithm
    (based on the Longest Common Subsequence problem) works perfectly well. The algorithm
    itself is beyond the scope of this book and not germane to the present discussion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个生成两个文本文件之间差异的程序，类似于 Unix 的 `diff` 实用程序。您需要读取两个文件，然后应用算法来识别相同部分和已更改部分。对于大多数文本文件，读取两个文件，然后应用适当的算法（基于最长公共子序列问题）都能很好地工作。算法本身超出了本书的范围，与当前讨论无关。
- en: 'Consider the tasks we need to perform:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们需要执行的任务：
- en: 'R1: Read complete contents of the first file'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'R1: 读取第一个文件的完整内容'
- en: 'R2: Read complete contents of the second file'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'R2: 读取第二个文件的完整内容'
- en: 'D: Apply the diff algorithm to the contents of the two files'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'D: 对两个文件的内容应用差异算法'
- en: 'The tasks R1 and R2 conceivably produce two arrays of characters containing
    the file content. The task D consumes the content produced by R1 and R2 and produces
    the diff as another array of characters. There is no ordering required between
    R1 and R2, and we can read the two files concurrently in separate threads. For
    simplicity, D commences only once both R1 and R2 are complete, that is, both R1
    and R2 must happen before D. Let us start by writing the code to read a file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任务 R1 和 R2 可能产生包含文件内容的两个字符数组。任务 D 消耗了 R1 和 R2 产生的内容，并将差异作为另一个字符数组产生。R1 和 R2
    之间不需要顺序，我们可以在单独的线程中同时读取两个文件。为简单起见，D 仅在 R1 和 R2 完成后才开始，也就是说，R1 和 R2 必须在 D 之前发生。让我们从编写读取文件的代码开始：
- en: '**Listing 10.4a: Reading contents of a file**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 10.4a: 读取文件内容**'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Given a file name, the function `readFromFile` reads the contents of the entire
    file and returns it in a `vector<char>`. We read the file contents into the underlying
    array of the `vector`, to get at which we call the `data` member function introduced
    in C++11 (line 11). We open the file for reading (line 8), and obtain the size
    of the file using the `boost::filesystem::size` function (line 9). We also define
    a stub of a method `diffContent` to compute the diff between the contents of two
    files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 给定文件名，函数 `readFromFile` 读取整个文件的内容并将其返回为 `vector<char>`。我们将文件内容读入 `vector` 的基础数组中，为了获取它，我们调用了
    C++11 中引入的 `data` 成员函数（第11行）。我们打开文件进行读取（第8行），并使用 `boost::filesystem::size` 函数获取文件的大小（第9行）。我们还定义了一个计算两个文件内容差异的方法
    `diffContent` 的存根。
- en: How can we employ the `readFromFile` function to read a file in a separate thread
    and return the vector containing the contents of the file to the calling thread?
    The calling thread needs a way to wait for the read to complete in the reader
    thread, and then get at the content read. In other words, the calling thread needs
    to wait for the future result of an asynchronous operation. The `boost::future`
    template provides an easy way to enforce such ordering between tasks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用 `readFromFile` 函数在单独的线程中读取文件并将包含文件内容的向量返回给调用线程？调用线程需要一种等待读取完成的方式，并且然后获取所读取的内容。换句话说，调用线程需要等待异步操作的未来结果。`boost::future`
    模板提供了一种简单的方式来强制执行任务之间的这种顺序。
- en: boost::future and boost::promise
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: boost::future 和 boost::promise
- en: The `boost::future<>` template is used to represent the result of a computation
    that potentially happens in the future. An object of type `boost::future<T>` represents
    a proxy for an object of type `T` that will potentially be produced in the future.
    Loosely speaking, `boost::future` enables a calling code to wait or block for
    an event to happen—the event of producing a value of a certain type. This mechanism
    can be used to signal events and pass values from one thread to another.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::future<>` 模板用于表示可能在将来发生的计算结果。类型为 `boost::future<T>` 的对象代表将来可能产生的类型为
    `T` 的对象的代理。粗略地说，`boost::future` 使调用代码能够等待或阻塞事件的发生——产生某种类型的值的事件。这种机制可以用于信号事件并从一个线程传递值到另一个线程。'
- en: 'The producer of the value or the source of the event needs a way to communicate
    with the future object in the calling thread. For this, an object of type `boost::promise<T>`,
    associated with the future object in the calling thread, is used to signal events
    and send values. Thus `boost::future` and `boost::promise` objects work in pairs
    to signal events and pass values across threads. We will now see how we can guarantee
    that the two file read operations in two threads precede the diff operation using
    Boost futures and promises:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值的生产者或事件的来源需要一种与调用线程中的future对象通信的方法。为此，使用与调用线程中的future对象关联的`boost::promise<T>`类型的对象来发出事件并发送值。因此，`boost::future`和`boost::promise`对象成对工作，以在线程之间传递事件和值。现在我们将看到如何使用Boost
    futures和promises来保证两个文件读取操作在两个线程中先于diff操作：
- en: '**Listing 10.4b: Returning values from a thread using futures and promises**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.4b：使用futures和promises从线程返回值**'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To be able to use `boost::future` and `boost::promise`, we need to include `boost/thread/future.hpp`
    (line 3). If we did not define the preprocessor symbol `BOOST_THREAD_PROVIDES_FUTURE`
    (line 1), then we would need to use `boost::unique_future` instead of `boost::future`.
    This example would work unchanged if we replaced `boost::future` with `boost::unique_future`,
    but in general there are differences in the capabilities of the two facilities,
    and we stick to `boost::future` throughout this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用`boost::future`和`boost::promise`，我们需要包括`boost/thread/future.hpp`（第3行）。如果我们没有定义预处理符号`BOOST_THREAD_PROVIDES_FUTURE`（第1行），那么我们需要使用`boost::unique_future`而不是`boost::future`。如果我们用`boost::unique_future`替换`boost::future`，这个例子将不变，但一般来说，这两种设施的能力有所不同，我们在本书中坚持使用`boost::future`。
- en: The function `diffFiles` (lines 6 and 7) takes two file names and returns their
    diff. It reads the first file synchronously (line 23) using the `readFromFile`
    function in listing 10.4a, and creates a thread called `reader` to read the second
    file concurrently (line 13). In order to be notified, when the `reader` thread
    is done reading and gets the content read, we need to set up a future-promise
    pair. Since we want to return a value of type `std::vector<char>` from the `reader`
    thread, we define a promise called `promised_value` of type `boost::promise<std::vector<char>>`
    (line 9). The `get_future` member of the promise object returns the associated
    future object and is used to move-construct `future_result` (lines 10-11). This
    sets up `promised_value` and `future_result` as the promise-future pair we work
    with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`diffFiles`函数（第6和7行）接受两个文件名并返回它们的差异。它同步读取第一个文件（第23行），使用列表10.4a中的`readFromFile`函数，并创建一个名为`reader`的线程并发读取第二个文件（第13行）。为了在`reader`线程完成读取并获取读取的内容时得到通知，我们需要设置一个future-promise对。由于我们想要从`reader`线程返回`std::vector<char>`类型的值，我们定义了一个名为`promised_value`的`boost::promise<std::vector<char>>`类型的promise（第9行）。promise对象的`get_future`成员返回关联的future对象，并用于移动构造`future_result`（第10-11行）。这将`promised_value`和`future_result`设置为我们要处理的promise-future对。'
- en: To read contents of `file2`, we create the `reader` thread passing a lambda
    (lines 14-20). The lambda captures `promised_value` and the name of the file to
    read (line 14). It reads the contents of the file and calls `set_value` on the
    promise object, passing in the content read (line 17). It then prints a diagnostic
    message and returns. Concurrently, with this, the calling thread also reads in
    the other file `file1` into the buffer `content1` and then calls `get` on `future_result`
    (line 26). This call blocks until the associated promise is set via the call to
    `set_value` (line 17). It returns the `vector<char>` set in the promise and this
    is used to move-construct `content2`. If the promise was already set, when `get`
    is called on the future, it returns the value without blocking the calling thread.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取`file2`的内容，我们创建了`reader`线程，传递了一个lambda（第14-20行）。lambda捕获了`promised_value`和要读取的文件的名称（第14行）。它读取文件的内容并在promise对象上调用`set_value`，传递读取的内容（第17行）。然后打印诊断消息并返回。与此同时，调用线程也将另一个文件`file1`读入缓冲区`content1`，然后在`future_result`上调用`get`（第26行）。此调用会阻塞，直到通过调用`set_value`（第17行）设置了关联的promise。它返回在promise中设置的`vector<char>`，并用于移动构造`content2`。如果在调用`get`时promise已经设置，它会返回值而不会阻塞调用线程。
- en: We now have the data needed to compute the diff, and we do so by passing the
    buffers `content1` and `content2` to the `diffContent` function (line 27). Note
    that we call `join` on the `reader` thread before returning `diff` (line 28).
    This would be necessary only if we wanted to ensure that the `reader` thread exited
    before returning from the function. We could also call `detach` instead of `join`
    to not wait for the reader thread to exit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了计算差异所需的数据，并且通过将缓冲区`content1`和`content2`传递给`diffContent`函数（第27行）来进行计算。请注意，在返回`diff`之前，我们在`reader`线程上调用`join`（第28行）。只有在我们希望确保`reader`线程在函数返回之前退出时才需要这样做。我们也可以调用`detach`而不是`join`来不等待读取线程退出。
- en: Waiting for future
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待future
- en: 'The `get` member function of `boost::future<>` blocks the calling thread until
    the associated promise is set. It returns the value set in the promise. Sometimes,
    you might want to block for a short duration and go ahead if the promise is not
    set. To do this, you have to use the `wait_for` member function and specify the
    duration to wait using `boost::chrono::duration` (see [Chapter 8](ch08.html "Chapter 8. Date
    and Time Libraries"), *Date and Time Libraries*):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::future<>`的`get`成员函数会阻塞调用线程，直到关联的promise被设置。它返回promise中设置的值。有时，您可能希望阻塞一小段时间，如果promise没有设置，则继续进行。为此，您必须使用`wait_for`成员函数，并使用`boost::chrono::duration`指定等待的持续时间（参见[第8章](ch08.html
    "第8章。日期和时间库")，“日期和时间库”）。'
- en: '**Listing 10.5: Waiting and timing out on a future**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.5：等待和超时future**'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example demonstrates how we can wait for a fixed duration on a future object.
    We create a promise-future pair (lines 11-12), but the template argument for `boost::future<>`
    and `boost::promise<>` is void. This means that we can use this pair purely for
    signaling/waiting, but not for transferring any data across threads.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了我们如何在future对象上等待固定的持续时间。我们创建了一个promise-future对（第11-12行），但是`boost::future<>`和`boost::promise<>`的模板参数是void。这意味着我们可以纯粹用于信号/等待，但不能在线程之间传输任何数据。
- en: We create a thread `thr` (line 16) passing it a lambda, which captures the promise
    object. This thread simply sleeps for a random duration between 10 and 19 seconds
    by passing a random duration to `boost::this_thread::sleep_for` (line 22) and
    then exits. The duration is constructed using the `boost::chrono::seconds` function
    (line 23) and passed a random interval `secs` computed using the `rand` function
    (line 18). We use `rand` for brevity, although more reliable and robust facilities
    are available in Boost and C++11\. To use `rand`, we need to call `srand` to seed
    the random number generator. On Windows, we must call `srand` in each thread that
    calls `rand` as we have shown here (line 17), while on POSIX, we should call `srand`
    once per process, which could be at the start of `main`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个线程`thr`（第16行），传递一个lambda，它捕获了promise对象。这个线程简单地睡眠在10到19秒之间的随机持续时间，通过将随机持续时间传递给`boost::this_thread::sleep_for`（第22行），然后退出。持续时间是使用`boost::chrono::seconds`函数构造的（第23行），并传递了使用`rand`函数计算的随机间隔`secs`（第18行）。我们使用`rand`是为了简洁起见，尽管Boost和C++11中提供了更可靠和健壮的设施。要使用`rand`，我们需要调用`srand`来种子随机数生成器。在Windows上，我们必须在每个调用`rand`的线程中调用`srand`，就像我们在这里展示的（第17行），而在POSIX上，我们应该在每个进程中调用`srand`，这可以在`main`的开始处。
- en: After sleeping for a specific duration, the thread `thr` calls `set_value` on
    the promise and returns (line 24). Since the promise is of type `boost::promise<void>`,
    `set_value` does not take any parameters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定持续时间后，线程`thr`调用promise的`set_value`并返回（第24行）。由于promise的类型是`boost::promise<void>`，`set_value`不带任何参数。
- en: In the main thread, we run a loop calling `wait_for` on the future associated
    with `promise`, passing a duration of 2 seconds each time (line 30). The function
    `wait_for` returns a value of the enum type `boost::future_state`. Each time `wait_for`
    times out, it returns `boost::future_state::timeout`. Once the promise is set
    (line 24), the `wait_for` call returns `boost::future_state::ready` and the loop
    breaks. The `is_ready` member function of `boost::future` returns `true` (line
    35), and the future's state as returned by the `get_state` member function is
    `boost::future_state::ready` (line 36).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，我们运行一个循环，每次调用与`promise`相关联的future的`wait_for`，传递2秒的持续时间（第30行）。`wait_for`函数返回枚举类型`boost::future_state`的值。每次`wait_for`超时，它返回`boost::future_state::timeout`。一旦promise被设置（第24行），`wait_for`调用返回`boost::future_state::ready`并且循环中断。`boost::future`的`is_ready`成员函数返回`true`（第35行），并且`get_state`成员函数返回的future状态是`boost::future_state::ready`（第36行）。
- en: Throwing exceptions across threads
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线程之间抛出异常
- en: 'If the initial function passed to the `boost::thread` constructor allows any
    exceptions to propagate, then the program is immediately aborted by a call to
    `std::terminate`. This creates a problem if we need to throw an exception from
    one thread to indicate a problem to another thread, or propagate an exception
    we caught in one thread to another. The promise/future mechanism comes in handy
    for this purpose too. Consider how, in Listing 10.4a and 10.4b, you would handle
    the case when a file does not exist or is not readable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`boost::thread`构造函数的初始函数允许任何异常传播，那么程序将立即通过调用`std::terminate`中止。如果我们需要从一个线程向另一个线程抛出异常来指示问题，或者传播我们在一个线程中捕获的异常到另一个线程，那么promise/future机制也很方便。考虑一下，在清单10.4a和10.4b中，当文件不存在或不可读时，你将如何处理：
- en: '**Listing 10.6: Transporting exceptions across threads**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.6：在线程之间传递异常**'
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If `file2` is the name of a file that does not exist or is not readable (line
    25), then the function `readFromFile` throws an exception (line 10) that is caught
    by the `reader` thread (line 27). The `reader` thread sets the exception in the
    promise object by using the `set_exception` member function (lines 28-29). Notice
    that we create a copy of the exception object using `boost::copy_exception` and
    set it in the promise object (line 29). Once an exception is set in the promise,
    the call to `get` on the future object (line 35) throws that exception, which
    needs to be caught and handled (line 38).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`file2`是一个不存在或不可读的文件的名称（第25行），那么`readFromFile`函数会抛出一个异常（第10行），被`reader`线程捕获（第27行）。`reader`线程使用`set_exception`成员函数在promise对象中设置异常（第28-29行）。请注意，我们使用`boost::copy_exception`创建异常对象的副本并将其设置在promise对象中（第29行）。一旦promise中设置了异常，对future对象的`get`调用（第35行）会抛出该异常，需要捕获和处理（第38行）。
- en: shared_future
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shared_future
- en: 'The `boost::future` object can only be waited upon by one thread. It is not
    copyable but is movable; thus, its ownership can be transferred from one thread
    to another and one function to another, but never shared. If we want multiple
    threads to wait on the same condition using the future mechanism, we need to use
    `boost::shared_future`. In the following example, we create a publisher thread
    that waits for a fixed duration before setting a promise with its thread ID. We
    also create three subscriber threads, which poll a `boost::shared_future` object
    associated with the promise object at different periodicities until it is ready,
    and then retrieves the thread ID of the publisher object from the `shared_future`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::future`对象只能由一个线程等待。它不可复制，但可移动；因此，它的所有权可以从一个线程转移到另一个线程，从一个函数转移到另一个函数，但不能共享。如果我们希望多个线程使用future机制等待相同的条件，我们需要使用`boost::shared_future`。在下面的示例中，我们创建一个发布者线程，在设置带有其线程ID的promise之前等待固定的持续时间。我们还创建了三个订阅者线程，它们以不同的周期性轮询与promise对象关联的`boost::shared_future`对象，直到它准备就绪，然后从`shared_future`中检索发布者对象的线程ID：'
- en: '**Listing 10.7: Using shared_future**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.7：使用shared_future**'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following the familiar pattern, we create a promise (line 11) and a `boost::future`
    (line 12). Using the future object, we move-initialize a `shared_future` object
    `shfut` (line 13). The `publisher` thread captures the promise (line 14) and sleeps
    for 15 seconds (line 21) before setting its ID string into the promise (line 22).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照熟悉的模式，我们创建一个promise（第11行）和一个`boost::future`（第12行）。使用future对象，我们move-initialize一个`shared_future`对象`shfut`（第13行）。`publisher`线程捕获promise（第14行），并在设置其ID字符串到promise之前睡眠15秒（第21行）。
- en: For the subscriber threads, we store the function object generated by the lambda
    expression in a variable called `thrFunc` (line 24) so that it can be reused multiple
    times. The initial function for the subscriber thread takes a `shared_future`
    parameter by value, and also the `waitFor` parameter, which specifies the frequency
    of polling the `shared_future` in seconds. The subscriber spins in a loop calling
    `wait_for` on the shared future, timing out after `waitFor` seconds. It comes
    out of the loop once the promise is set (line 22) and retrieves the value set
    in the promise (the publisher's thread ID) by calling `get` on the `shared_future`
    (line 35).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于订阅者线程，我们将lambda表达式生成的函数对象存储在名为`thrFunc`的变量中（第24行），以便可以多次重用。订阅者线程的初始函数通过值传递一个`shared_future`参数，并且还有一个`waitFor`参数，该参数指定以秒为单位轮询`shared_future`的频率。订阅者在一个循环中调用`shared_future`上的`wait_for`，在`waitFor`秒后超时。一旦promise被设置（第22行），它就会退出循环，并通过在`shared_future`上调用`get`（第35行）来检索promise中设置的值（发布者线程的ID）。
- en: Three subscriber threads are spawned (lines 38-40). Note how the arguments to
    their initial function, the `shared_future` object, and the wait period in seconds,
    are passed as additional arguments to `boost::thread` object's variadic constructor
    template. Note that `shared_future` is copyable and the same `shared_future` object
    `shfut` is copied into the three subscriber threads.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 三个订阅者线程被创建（第38-40行）。请注意，它们初始函数的参数，`shared_future`对象和以秒为单位的等待时间作为额外参数传递给`boost::thread`对象的可变构造函数模板。请注意，`shared_future`是可复制的，同一个`shared_future`对象`shfut`被复制到三个订阅者线程中。
- en: std::future and std::promise
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::future和std::promise
- en: 'The C++11 Standard Library provides `std::future<>`, `std::shared_future<>`,
    and `std::promise<>` templates that are pretty much identical in behavior to their
    Boost library counterparts. The Boost version''s additional member functions are
    experimental, but leaving those aside, they mirror their Standard Library counterparts.
    For example, we can rewrite listing 10.5 and 10.7 by replacing the following symbols
    in the program text:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准库提供了`std::future<>`、`std::shared_future<>`和`std::promise<>`模板，它们的行为几乎与它们的Boost库对应物相同。Boost版本的额外成员函数是实验性的，但是除此之外，它们与标准库对应物相同。例如，我们可以通过在程序文本中替换以下符号来重写10.5和10.7清单：
- en: Replace `boost::thread` with `std::thread`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`boost::thread`替换为`std::thread`
- en: Replace `boost::future` with `std::future`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`boost::future`替换为`std::future`
- en: Replace `boost::promise` with `std::promise`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`boost::promise`替换为`std::promise`
- en: Replace `boost::shared_promise` with `std::shared_promise`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`boost::shared_promise`替换为`std::shared_promise`
- en: Replace `boost::chrono` with `std::chrono`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`boost::chrono`替换为`std::chrono`
- en: In addition, we would need to replace the included headers `boost/thread.hpp`,
    `boost/thread/future.hpp`, and `boost/chrono.hpp` with the Standard Library headers
    `thread`, `future`, and `chrono` respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要用标准库头文件`thread`、`future`和`chrono`分别替换包含的头文件`boost/thread.hpp`、`boost/thread/future.hpp`和`boost/chrono.hpp`。
- en: 'In listing 10.6, we used the `set_exception` member function of `boost::promise`
    to enable passing an exception across thread boundaries. This would require some
    changes to work with `std::promise`. C++11 introduces `std::exception_ptr`, a
    special smart pointer type with shared ownership semantics that must wrap exception
    objects so that they can be passed across functions and threads (see [Appendix](apa.html
    "Appendix A. C++11 Language Features Emulation"), *C++11 Language Features Emulation*).
    The `set_exception` member function of `std::promise` takes a parameter of type
    `std::exception_ptr` instead of a `std::exception`. The following snippet shows
    how you would change listing 10.6 to use the Standard Library:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在10.6清单中，我们使用`boost::promise`的`set_exception`成员函数来实现在线程边界传递异常。这需要一些更改才能与`std::promise`一起工作。C++11引入了`std::exception_ptr`，这是一种具有共享所有权语义的特殊智能指针类型，必须包装异常对象，以便它们可以在函数和线程之间传递（见[附录](apa.html
    "附录 A. C++11语言特性模拟")，*C++11语言特性模拟*）。`std::promise`的`set_exception`成员函数接受一个`std::exception_ptr`类型的参数，而不是`std::exception`。以下代码片段显示了如何更改10.6清单以使用标准库：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we call `std::current_exception` (line 29), which returns a `std::exception_ptr`
    object that wraps the currently active exception in the catch block. This `exception_ptr`
    is passed to the `set_exception` member function of `std::promise` (line 28).
    These type and function declarations are available from the Standard Library header
    `exception` (line 2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`std::current_exception`（第29行），它返回一个包装在catch块中当前活动异常的`std::exception_ptr`对象。这个`exception_ptr`被传递给`std::promise`的`set_exception`成员函数（第28行）。这些类型和函数声明可以从标准库头文件`exception`（第2行）中获得。
- en: 'We can also create a `std::exception_ptr` object from an exception object using
    `std::make_exception_ptr`, as shown in the following snippet (line 29):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`std::make_exception_ptr`从异常对象创建一个`std::exception_ptr`对象，如下面的代码片段所示（第29行）：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: std::packaged_task and std::async
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::packaged_task和std::async
- en: While threads are powerful constructs, the full generality and control that
    they provide comes at the cost of simplicity. In a lot of cases, it works best
    to operate at a higher level of abstraction than creating explicit threads to
    run tasks. The Standard Library provides the `std::async` function template and
    `std::packaged_task` class template that provide different levels of abstractions
    for creating concurrent tasks, freeing the programmer from having to write a lot
    of boilerplate code in the process. They have counterparts in the Boost library
    (`boost::async` and `boost::packaged_task`) that are incompletely implemented
    and less portable to use as of this writing (Boost version 1.57), especially in
    pre-C++11 environments.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然线程是强大的构造，但它们提供的完整的通用性和控制是以简单性为代价的。在许多情况下，最好以比创建显式线程运行任务更高的抽象级别进行操作。标准库提供了`std::async`函数模板和`std::packaged_task`类模板，为创建并发任务提供了不同的抽象级别，从而使程序员免于在此过程中编写大量样板代码。它们在Boost库中有对应物（`boost::async`和`boost::packaged_task`），但在撰写本文时（Boost版本1.57），它们的实现不完整，且在早期C++11环境中使用起来不太方便。
- en: std::packaged_task
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: std::packaged_task
- en: 'The `std::packaged_task<>` class template is used to create asynchronous tasks.
    You need to explicitly create a thread that runs the task or calls the task manually
    using the overloaded `operator()` in `packaged_task`. But you do not need to manually
    set up promise-future pairs or deal with promises in any way. Here is listing
    10.6, rewritten using `std::packaged_task`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::packaged_task<>`类模板用于创建异步任务。您需要显式创建一个运行任务的线程，或者使用`packaged_task`中重载的`operator()`手动调用任务。但您不需要手动设置promise-future对，也不需要以任何方式处理promise。这里是使用`std::packaged_task`重写的列表10.6：'
- en: '**Listing 10.8: Using std::packaged_task**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.8：使用std::packaged_task**'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we read two files and compute their diff. To read the files,
    we use the function `readFromFile`, which returns the file contents in a `vector<char>`
    or throws an exception if the file is not readable. We read one of the two files
    by a blocking call to `readFromFile` (line 25), and read the other file on a separate
    thread.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们读取两个文件并计算它们的差异。为了读取文件，我们使用`readFromFile`函数，它返回一个`vector<char>`中的文件内容，或者如果文件不可读则抛出异常。我们通过阻塞调用`readFromFile`（第25行）读取其中一个文件，并在单独的线程中读取另一个文件。
- en: To read the second file concurrently with the first one, we wrap the `readFromFile`
    function in a `std::packaged_task` called `readerTask` (lines 19-20) and run it
    in a separate thread. The specific type of `readerTask` is `std::packaged_task<buffer_t(const
    std::string&)>`. The template argument to `packaged_task` is the wrapped function
    type. Before starting this task on a separate thread, we must first get a reference
    to the associated future object. We get this reference to the future object by
    calling the `get_future` member function of `packaged_task` (line 21). Next, we
    create a thread and move the packaged task to this thread (line 24). This is necessary
    because `packaged_task` is movable but not copyable, which is why the `get_future`
    method must be called on the `packaged_task` object before it is moved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与第一个文件同时读取第二个文件，我们将`readFromFile`函数包装在名为`readerTask`的`std::packaged_task`中（第19-20行），并在单独的线程中运行它。`readerTask`的具体类型是`std::packaged_task<buffer_t(const
    std::string&)>`。`packaged_task`的模板参数是包装的函数类型。在将此任务在单独的线程上启动之前，我们必须首先获取与之关联的future对象的引用。我们通过调用`packaged_task`的`get_future`成员函数（第21行）来获取与future对象的引用。接下来，我们创建一个线程并将打包的任务移动到这个线程（第24行）。这是必要的，因为`packaged_task`是可移动的但不可复制的，这就是为什么必须在将`packaged_task`对象移动之前调用`get_future`方法的原因。
- en: The thread `thread2` reads `file2` by calling the `readFromFile` function passed
    to it in a `packaged_task`. The `vector<char>` returned by `readFromFile` can
    be obtained from the future object associated with `readerTask` by a call to the
    `get` member function of the future (line 28). The `get` call will throw any exception
    originally thrown by `readFromFile`, such as when the named file does not exist.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 线程`thread2`通过调用传递给它的`readFromFile`函数来读取`file2`。通过调用与`readerTask`关联的future对象的`get`成员函数（第28行），可以获取`readFromFile`返回的`vector<char>`。`get`调用将抛出`readFromFile`最初抛出的任何异常，比如当命名文件不存在时。
- en: std::async
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: std::async
- en: 'The `std::async` function template creates a task from a function object that
    can potentially run concurrently in a separate thread. It returns a `std::future`
    object, which can be used to block on the task or wait for it. It is available
    through the Standard Library header file `future`. With `std::async`, we no longer
    need to explicitly create threads. Instead, we pass to `std::async` the function
    to execute, the arguments to pass, and an optional launch policy. `std::async`
    runs the function either asynchronously in a different thread or synchronously
    on the calling thread based on the launch policy specified. Here is a simple rewrite
    of listing 10.5 using `std::async`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::async`函数模板从一个函数对象创建一个任务，这个任务可以在一个单独的线程中并发运行。它返回一个`std::future`对象，可以用来阻塞任务或等待它。它通过标准库头文件`future`提供。使用`std::async`，我们不再需要显式创建线程。相反，我们将要执行的函数、要传递的参数以及可选的启动策略传递给`std::async`。`std::async`根据指定的启动策略，要么在不同的线程中异步运行函数，要么在调用线程中同步运行函数。这里是使用`std::async`简单重写列表10.5的示例：'
- en: '**Listing 10.9: Using std::async to create concurrent tasks**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.9：使用std::async创建并发任务**'
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While `packaged_task` abstracts promises, `std::async` abstracts threads themselves,
    and we no longer deal with objects of `std::thread`. Instead, we call `std::async`,
    passing it a launch policy `std::launch::async` (line 16), a function object (line
    17), and any number of arguments that the function object takes. It returns a
    future object and runs the function passed to it asynchronously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`packaged_task`抽象了promise，`std::async`抽象了线程本身，我们不再处理`std::thread`的对象。相反，我们调用`std::async`，传递一个启动策略`std::launch::async`（第16行），一个函数对象（第17行），以及函数对象所需的任意数量的参数。它返回一个future对象，并异步运行传递给它的函数。
- en: Like the constructor of `thread`, `std::async` is a variadic function and is
    passed all the arguments that need to be forwarded to the function object. The
    function object is created using a lambda expression and does little, besides
    sleeping for a duration passed to it as a parameter. The `duration` is a random
    value between 10 and 19 seconds and is passed to the `async` call as the sole
    argument for the function object (line 24). The function object returns the duration
    of sleep (line 23). We call the `wait_for` member function on the future object
    to wait for short periods till the future is set (line 28). We retrieve the return
    value of the task from the future object by calling its `get` member function
    (line 34).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与`thread`的构造函数一样，`std::async`是一个可变参数函数，并传递需要转发给函数对象的所有参数。函数对象使用lambda表达式创建，并且除了按参数传递的持续时间休眠外，几乎不做任何事情。`duration`是10到19秒之间的随机值，并作为函数对象的唯一参数传递给`async`调用（第24行）。函数对象返回休眠的持续时间（第23行）。我们调用future对象的`wait_for`成员函数，以等待短时间直到future设置（第28行）。我们通过调用其`get`成员函数从future对象中检索任务的返回值（第34行）。
- en: Launch policy
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动策略
- en: We used the launch policy `std::launch::async` to indicate that we want the
    task to run on a separate thread. This would launch the task immediately in a
    separate thread. Using the other standard launch policy `std::launch::deferred`
    , we can launch the task lazily, when we first call `get` or `wait` (non-timed
    wait functions) on the associated future object. The task would run synchronously
    in the thread that calls `get` or `wait`. This also means that the task would
    never be launched if one used the `deferred` policy and did not call `get` or
    `wait`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用启动策略`std::launch::async`来指示我们希望任务在单独的线程上运行。这将立即在单独的线程中启动任务。使用另一个标准启动策略`std::launch::deferred`，我们可以在首次调用与关联future对象的`get`或`wait`（非定时等待函数）时懒惰地启动任务。任务将在调用`get`或`wait`的线程中同步运行。这也意味着，如果使用`deferred`策略并且没有调用`get`或`wait`，任务将永远不会启动。
- en: We could not have used `std::launch::deferred` in the listing 10.10\. This is
    because we wait for the future to be ready (line 28) before calling `get` in the
    same thread (line 34). The task would never be launched until we called `get`,
    but the future could never be ready unless the task was launched and returned
    a value; so we would spin eternally in the `while` loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在列表10.10中使用`std::launch::deferred`。这是因为我们在同一线程中等待future准备好（第28行）之前调用`get`（第34行）。任务在我们调用`get`之前永远不会启动，但是除非任务启动并返回一个值，future永远不会准备好；所以我们会在`while`循环中永远旋转。
- en: 'While creating a task using `std::async`, we may also omit the launch policy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`std::async`创建任务时，我们也可以省略启动策略：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In such cases, the behavior is equivalent to the following call:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，行为等同于以下调用：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is up to the implementation to choose the behavior conforming to either `std::launch::async`
    or `std::launch::deferred`. Moreover, the implementation would only create a new
    thread if the runtime libraries needed to support multithreading are linked to
    the program. With the default policy, when multithreading is enabled, `std::async`
    either launches new tasks in new threads or posts them to an internal thread pool.
    If there are no free threads in the pool or free cores, the tasks would be launched
    synchronously.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以选择符合`std::launch::async`或`std::launch::deferred`的行为。此外，只有在运行时库需要支持多线程的情况下，实现才会创建一个新线程并链接到程序。使用默认策略时，当启用多线程时，`std::async`要么在新线程中启动新任务，要么将它们发布到内部线程池。如果线程池中没有空闲线程或空闲核心，任务将被同步启动。
- en: Lock-based thread synchronization methods
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于锁的线程同步方法
- en: So far, we saw how we can delegate functions to be run on separate threads using
    `boost::thread` and `std::thread`. We saw the use of `boost::future` and `boost::promise`
    to communicate results and exceptions between threads and to impose order between
    tasks through blocking calls. Sometimes, you can break down your program into
    independent tasks that can be run concurrently, producing a value, a side effect,
    or both, which is then consumed by another part of the program. Launching such
    tasks and waiting on them using futures is an effective strategy. Once the tasks
    have returned, you can start on the next phase of computations that consume the
    results of the first phase.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用`boost::thread`和`std::thread`委托函数在单独的线程上运行。我们看到了使用`boost::future`和`boost::promise`在线程之间通信结果和异常，并通过阻塞调用在任务之间施加顺序。有时，您可以将程序分解为可以并发运行的独立任务，产生一个值、一个副作用或两者，然后由程序的另一部分消耗。启动这样的任务并使用futures等待它们是一种有效的策略。一旦任务返回，您可以开始下一个消耗第一阶段结果的计算阶段。
- en: Often though, multiple threads need to access and modify the same data structures
    concurrently and repeatedly. These accesses need to be ordered reliably and isolated
    from each other to prevent inconsistencies from creeping into the underlying data
    structure due to uncoordinated, concurrent accesses. In this section, we look
    at the Boost libraries that help us take care of these concerns.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常需要多个线程同时访问和修改相同的数据结构。这些访问需要可靠地排序并且相互隔离，以防止由于不协调的并发访问导致底层数据结构中出现不一致。在本节中，我们将看一下帮助我们解决这些问题的Boost库。
- en: Data races and atomic operations
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据竞争和原子操作
- en: 'Consider the following code snippet. We create two threads, and each thread
    increments a shared integer variable a fixed number of times in a loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段。我们创建两个线程，每个线程在循环中递增一个共享的整数变量固定次数：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What value of `x` would be printed at the end of the program? Since each thread
    increments `x` a million times and there are two threads, one could expect it
    to be `2000000`. You can verify for yourself that the increment operator is called
    on `x` no less and no more than `N*max` times, where `N=2` is the number of threads
    and `max` is a million. Yet I saw `2000000` being printed not for once; each time
    it was a smaller number. This behavior might vary depending on the OS and hardware,
    but it is common enough. Clearly, some increments are not taking effect.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 程序结束时`x`的值是多少？由于每个线程对`x`递增了一百万次，而且有两个线程，人们可能期望它是`2000000`。你可以自行验证，递增运算符在`x`上被调用的次数不少于`N*max`次，其中`N=2`是线程数，`max`是一百万。然而，我看到`2000000`被打印出来不止一次；每次都是一个较小的数字。这种行为可能会因操作系统和硬件而有所不同，但它是相当常见的。显然，一些递增操作没有生效。
- en: The reason becomes clear when you realize that the operation `++x` involves
    reading the value of `x`, adding one to the value, and writing this result back
    into `x`. Say the value of `x` is `V` and two threads perform the operation `++x`
    on `V`. Each of the two threads can read V as the value of `x`, perform the increment,
    and write back V+1\. Therefore, after two threads, each incrementing `x` once,
    the value of `x` could still be as if it was incremented only once. Depending
    on the machine architecture, for some "primitive" data types, it may require two
    CPU instructions to update the value of a variable. Two such operations executing
    concurrently could end up setting the value to what neither intended due to *partial
    writes*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到操作`++x`涉及读取`x`的值，将一个添加到该值，然后将结果写回`x`时，原因就变得清楚了。假设`x`的值是`V`，两个线程对`V`执行操作`++x`。两个线程中的每一个都可以将V读取为`x`的值，执行递增操作，然后将V+1写回。因此，两个线程分别对`x`进行一次递增操作后，`x`的值仍然可能是如果只递增了一次。根据机器架构的不同，对于某些“原始”数据类型，更新变量的值可能需要两个CPU指令。并发执行两个这样的操作可能会由于*部分写入*而将值设置为两者都不想要的值。
- en: Interleaved operations like these represent a **data race**—the threads performing
    them are said to race against each other in performing the operation steps and
    their exact sequence, and therefore, the results are unpredictable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样交错的操作代表了**数据竞争**—执行它们的线程被认为在执行操作步骤及其确切顺序上相互竞争，因此结果是不可预测的。
- en: 'Let us use the notation [r=v1, w=v2] to indicate that a thread *read* the value
    v1 from the variable `x` and *wrote* back v2\. Note that there can be an arbitrary
    duration between the time a thread reads the value of `x` and the time when it
    writes back a value. So the notation [r=v1, … is used to indicate that a value
    v1 was read but the write back is yet to happen, and the notation … w=v2] indicates
    that the pending write happened. Now consider two threads each incrementing `x`
    a million times, as shown in the following sequence:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用符号[r=v1，w=v2]来表示一个线程从变量`x`中*读取*值v1并*写回*值v2。请注意，在线程读取变量`x`的值和写回值之间可能有任意长的持续时间。因此，符号[r=v1，…用于表示已经读取了值v1，但尚未进行写回，符号…w=v2]表示待定的写回已经发生。现在考虑两个线程分别对`x`进行一百万次递增操作，如下所示：
- en: '![Data races and atomic operations](img/1217OT_10_01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![数据竞争和原子操作](img/1217OT_10_01.jpg)'
- en: For simplicity, assume that partial writes cannot happen. At time **t1**, both
    Thread 1 and Thread 2 read the value of `x` as 0\. Thread 2 increments this value
    and writes back the value 1\. Thread 2 continues reading and incrementing the
    value of `x` for 999998 more iterations until it writes back the value 999999
    at time **t999999**. Following this, Thread 1 increments the value 0 that it had
    read at **t1** and writes back the value 1\. Next, both Thread 1 and Thread 2
    read the value 1, and Thread 1 writes back 2 but Thread 2 hangs on. Thread 1 goes
    on for 999998 more iterations, reading and incrementing the value of `x`. It writes
    the value 1000000 to `x` at time **t1999999** and exits. Thread 2 now increments
    the value 1 that it had read at **t1000001** and writes back. For two million
    increments, the final value of `x` could well be 2\. You can change the number
    of iterations to any number greater than or equal to 2, and the number of threads
    to any number greater than or equal to 2, and this result would still hold—a measure
    of the nondeterminism and nonintuitive aspects of concurrency. When we see the
    operation `++x`, we intuitively think of it as an indivisible or *atomic operation,*
    when it really is not.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，假设部分写入是不可能发生的。在时间**t1**，线程1和线程2都将变量`x`的值读取为0。线程2递增这个值，并将值写回为1。线程2继续读取和递增`x`的值999998次，直到在时间**t999999**写回值999999。之后，线程1递增了它在**t1**读取的值0，并将值写回为1。接下来，线程1和线程2都读取了值1，线程1写回2，但线程2挂起。线程1继续进行999998次迭代，读取和递增`x`的值。它在时间**t1999999**将值1000000写入`x`并退出。线程2现在递增了它在**t1000001**读取的值1并写回。对于两百万次递增，`x`的最终值可能是2。你可以将迭代次数更改为大于或等于2的任意数字，将线程数更改为大于或等于2的任意数字，这个结果仍然成立——这是并发的不确定性和非直观方面的一种度量。当我们看到操作`++x`时，我们直观地认为它是一个不可分割的或*原子操作*，但实际上并非如此。
- en: An **atomic operation** runs without any observable intermediate states. Such
    operations cannot interleave. Intermediate states created by an atomic operation
    are not visible to other threads. Machine architectures provide special instructions
    for performing atomic read-modify-write operations, and operating systems often
    provide library interfaces for atomic types and operations that use these primitives.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作在没有任何可观察的中间状态的情况下运行。这些操作不能交错。原子操作创建的中间状态对其他线程不可见。机器架构提供了执行原子读取-修改-写入操作的特殊指令，操作系统通常提供了使用这些原语的原子类型和操作的库接口。
- en: The increment operation `++x` is clearly nonatomic. The variable `x` is a shared
    resource and between a read, increment, and a subsequent write to `x` by one thread,
    any number of read-modify-writes to `x` can take place from other threads—the
    operations can be interleaved. For such nonatomic operations, we must find means
    of making them **thread-safe,** that is, by preventing interleaving of operations,
    such as `++x`, across multiple threads.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 增量操作`++x`显然是不可重入的。变量`x`是一个共享资源，在一个线程的读取、增量和随后的写入`x`之间，其他线程可以进行任意数量的读取-修改-写入操作——这些操作可以交错进行。对于这样的不可重入操作，我们必须找到使它们**线程安全**的方法，即通过防止多个线程之间的操作交错，比如`++x`。
- en: Mutual exclusion and critical sections
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互斥排斥和临界区
- en: 'One way to make the `++x` operation thread-safe is to perform it in a **critical
    section**. A critical section is a section of code that cannot be executed simultaneously
    by two different threads. Thus, two increments of `x` from different threads can
    be interleaved. Threads must adhere to this protocol and can use a **mutex** to
    do so. A mutex is a primitive used for synchronizing concurrent access to shared
    resources, such as the variable `x`. We use the `boost::mutex` class for this
    purpose, as shown in the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使`++x`操作线程安全的一种方法是在**临界区**中执行它。临界区是一段代码，不能同时被两个不同的线程执行。因此，来自不同线程的两次对`x`的增量可以交错进行。线程必须遵守这个协议，并且可以使用**互斥对象**来实现。互斥对象是用于同步并发访问共享资源的原语，比如变量`x`。我们在这个示例中使用`boost::mutex`类来实现这一目的，如下例所示：
- en: '**Listing 10.10: Using mutexes**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.10：使用互斥对象**'
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We declare a mutex object of type `boost::mutex` (line 9), capture it in the
    lambda that generates the initial function for the threads (line 11), and then
    protect the increment operation on the variable `x` by locking the mutex before
    performing it (line 13) and unlocking it afterwards (line 15). The increment operation
    on `x` (line 14) is the critical section. This code prints the following each
    and every time:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`boost::mutex`类型的互斥对象（第9行），在生成线程的初始函数的lambda中捕获它（第11行），然后在执行增量操作之前通过锁定互斥对象来保护变量`x`（第13行），并在之后解锁它（第15行）。对`x`的增量操作（第14行）是临界区。这段代码每次都会打印以下内容：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'How does this work? The mutex object has two states: **locked** and **unlocked**.
    The first thread to call the `lock` member function on a mutex that is unlocked,
    locks it and the call to `lock` returns. Other threads that call `lock` on the
    already-locked mutex simply **block**, which means the OS scheduler does not schedule
    these threads to run, unless some event (like the unlocking of the mutex in question)
    takes place. The thread with the lock then increments `x` and calls the `unlock`
    member function on the mutex to relinquish the lock it is holding. At this point,
    one of the threads that is blocked in the `lock` call is woken up, the call to
    `lock` in that thread returns, and the thread is scheduled to run. Which waiting
    thread is woken up depends on the underlying native implementation. This goes
    on until all the threads (in our example, just two) have run to completion. The
    lock ensures that at any point in time, only one thread exclusively holds the
    lock and is thus free to increment `x`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？互斥对象有两种状态：**锁定**和**未锁定**。第一个调用未锁定互斥对象的`lock`成员函数的线程会锁定它，并且`lock`的调用会返回。其他调用已锁定互斥对象的`lock`的线程会**阻塞**，这意味着操作系统调度程序不会安排这些线程运行，除非发生某些事件（比如所讨论的互斥对象解锁）。然后持有锁的线程增加`x`并调用互斥对象的`unlock`成员函数来释放它持有的锁。此时，阻塞在`lock`调用中的一个线程会被唤醒，该线程的`lock`调用返回，并且该线程被安排运行。等待唤醒的线程取决于底层的本地实现。这一过程会一直持续，直到所有线程（在我们的示例中，只有两个）都运行完成。锁确保在任何时刻，只有一个线程独占持有锁，并且可以自由地增加`x`。
- en: 'The section we choose to protect with the mutex is critical. We could have
    alternatively protected the entire for-loop, as shown in the following snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择用互斥对象保护的部分是关键的。我们也可以选择保护整个for循环，就像下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The final value of `x` would still be the same (`2000000`) as with listing 10.10,
    but the critical section would be bigger (lines 13-15). One thread would run its
    entire loop before the other thread could even increment `x` once. By limiting
    the extent of the critical section and the time a thread holds the lock, multiple
    threads can make more equitable progress.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`的最终值仍然与10.10清单中一样（`2000000`），但临界区会更大（第13-15行）。一个线程会在另一个线程甚至只能增加`x`一次之前运行完整个循环。通过限制临界区的范围和线程持有锁的时间，多个线程可以取得更加公平的进展。'
- en: 'A thread may choose to probe and see whether it can acquire a lock on a mutex
    but not block if it cannot. To do so, the thread must call the `try_lock` member
    function instead of the `lock` member function. A call to `try_lock` returns `true`
    if the mutex was locked and `false` otherwise, and does not block if the mutex
    was not locked:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程也可以选择探测并查看是否可以获取互斥对象的锁，但如果不能则不阻塞。为此，线程必须调用`try_lock`成员函数而不是`lock`成员函数。调用`try_lock`会在互斥对象被锁定时返回`true`，否则返回`false`，并且如果互斥对象未被锁定则不会阻塞：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A thread may also choose to block for a specified duration while waiting to
    acquire a lock, using the `try_lock_for` member function. The call to `try_lock_for`
    returns `true` if it succeeds in acquiring the lock and as soon as it does. Otherwise,
    it blocks for the entire length of the specified duration and returns false once
    it times out without acquiring the lock:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程也可以选择在等待获取锁时阻塞指定的持续时间，使用`try_lock_for`成员函数。如果成功获取锁并且一旦获取锁，`try_lock_for`的调用会返回`true`。否则，它会在指定持续时间内阻塞，并且一旦超时而未获取锁则返回false：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mutexes should be held for as short a duration as possible over as small a section
    of code as necessary. Since mutexes serialize the execution of critical sections,
    holding a mutex over longer durations delays the progress of other threads waiting
    to lock the mutex.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥对象应该在尽可能短的时间内持有，覆盖尽可能小的代码段。由于互斥对象串行化了临界区的执行，持有互斥对象的时间越长，等待锁定互斥对象的其他线程的进展就会延迟。
- en: boost::lock_guard
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: boost::lock_guard
- en: 'Acquiring a lock on a mutex and failing to release it is disastrous, as any
    other thread waiting on the mutex will never make any progress. The bare `lock`
    / `try_lock` and `unlock` calls on the mutex are not a good idea, and we need
    some means of locking and unlocking mutexes in an exception-safe way. The `boost::lock_guard<>`
    template uses the **Resource Acquisition Is Initialization** (**RAII**) idiom
    to lock and unlock mutexes in its constructor and destructor:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在互斥锁上获取锁并未能释放它是灾难性的，因为任何其他等待互斥锁的线程都将无法取得任何进展。在互斥锁上的裸`lock` / `try_lock`和`unlock`调用并不是一个好主意，我们需要一些在异常安全方式下锁定和解锁互斥锁的方法。`boost::lock_guard<>`模板使用**资源获取即初始化**（**RAII**）范式在其构造函数和析构函数中锁定和解锁互斥锁：
- en: '**Listing 10.11: Using boost::lock_guard**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.11：使用boost::lock_guard**'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a `boost::lock_guard` object (line 13), we lock the section of code following
    the instantiation of the lock guard till the end of the scope. The `lock_guard`
    acquires the lock in the constructor and releases it in the destructor. This ensures
    that even in the face of an exception arising in the critical section, the mutex
    is always unlocked once the scope is exited. You pass the type of the lock as
    a template argument to `lock_guard`. `boost::lock_guard` can be used not only
    with `boost::mutex` but with any type that conforms to the **BasicLockable** concept,
    that is, has accessible `lock` and `unlock` member functions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`boost::lock_guard`对象（第13行），我们锁定在锁保护实例化后的代码部分，直到作用域结束。`lock_guard`在构造函数中获取锁，并在析构函数中释放锁。这确保即使在关键部分出现异常，一旦作用域退出，互斥锁总是被解锁。您将锁的类型作为模板参数传递给`lock_guard`。`boost::lock_guard`不仅可以与`boost::mutex`一起使用，还可以与符合**BasicLockable**概念的任何类型一起使用，即具有可访问的`lock`和`unlock`成员函数。
- en: 'We can also use `boost::lock_guard` to encapsulate a mutex that is already
    locked. To do so we need to pass a second argument to the `lock_guard` constructor
    indicating that it should assume ownership of the mutex without trying to lock
    it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`boost::lock_guard`来封装已经锁定的互斥锁。为此，我们需要向`lock_guard`构造函数传递第二个参数，指示它应该假定拥有互斥锁而不尝试锁定它：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`boost::lock_guard` either locks the underlying mutex in its constructor or
    adopts an already-locked mutex. The only way to release the mutex is to let the
    `lock_guard` go out of scope. `lock_guard` is neither copyable nor movable, so
    you cannot pass them around from one function to the next, nor store them in containers.
    You cannot use `lock_guard` to wait on a mutex for specific durations.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lock_guard`在其构造函数中锁定底层互斥锁，或者采用已经锁定的互斥锁。释放互斥锁的唯一方法是让`lock_guard`超出作用域。`lock_guard`既不可复制也不可移动，因此您不能将它们从一个函数传递到另一个函数，也不能将它们存储在容器中。您不能使用`lock_guard`等待特定持续时间的互斥锁。'
- en: boost::unique_lock
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: boost::unique_lock
- en: The `boost::unique_lock<>` template is a more flexible alternative that still
    uses RAII to manage mutex-like locks but provides an interface to manually lock
    and unlock as required. For this additional flexibility, `unique_lock` has to
    maintain an additional data member to keep track of whether the mutex is owned
    by the thread or not. We can use `unique_lock` to manage any class conforming
    to the **Lockable** concept. A class conforms to the Lockable concept if it conforms
    to BasicLockable and additionally, defines an accessible `try_lock` member function—just
    as `boost::mutex` does.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::unique_lock<>`模板是一种更灵活的替代方案，它仍然使用RAII来管理类似互斥锁，但提供了手动锁定和解锁的接口。为了获得这种额外的灵活性，`unique_lock`必须维护一个额外的数据成员，以跟踪互斥锁是否被线程拥有。我们可以使用`unique_lock`来管理符合**Lockable**概念的任何类。如果一个类符合Lockable概念，那么它符合BasicLockable，并且另外定义了一个可访问的`try_lock`成员函数，就像`boost::mutex`一样。'
- en: 'We can use `boost::unique_lock` as a drop-in replacement for `boost::lock_guard`,
    but `unique_lock` should not be used if `lock_guard` suffices for a purpose. `unique_lock`
    is typically useful when we want to mix manual locking with exception-safe lock
    management. For example, we can rewrite listing 10.11 to use `unique_lock`, as
    shown in the following snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`boost::unique_lock`用作`boost::lock_guard`的替代品，但是如果`lock_guard`足够用于某个目的，则不应使用`unique_lock`。当我们想要将手动锁定与异常安全的锁管理混合使用时，`unique_lock`通常很有用。例如，我们可以重写列表10.11以使用`unique_lock`，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Unlike in listing 10.11, we do not create a new `lock_guard` object in each
    iteration of the loop. Instead, we create a single `unique_lock` object encapsulating
    the mutex before the loop begins (line 12). The `boost::defer_lock` argument passed
    to the `unique_lock` constructor tells the constructor not to lock the mutex immediately.
    The mutex is locked before incrementing the shared variable by calling the `lock`
    member function of `unique_lock` (line 16) and unlocked after the operation by
    calling the `unlock` member function of `unique_lock` (line 21). In the event
    of an exception, the `unique_lock` destructor unlocks the mutex only if it is
    locked.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表10.11不同，我们不会在每次循环迭代中创建一个新的`lock_guard`对象。相反，我们在循环开始之前创建一个封装互斥锁的单个`unique_lock`对象（第12行）。传递给`unique_lock`构造函数的`boost::defer_lock`参数告诉构造函数不要立即锁定互斥锁。在调用`unique_lock`的`lock`成员函数（第16行）增加共享变量之前，互斥锁被锁定，并且在操作之后通过调用`unique_lock`的`unlock`成员函数（第21行）解锁。在发生异常时，如果互斥锁被锁定，`unique_lock`析构函数将解锁互斥锁。
- en: The `owns_lock` member function of `unique_lock` returns `true` if the `unique_lock`
    owns a lock on the mutex, and `false` otherwise (lines 13 and 18). The `mutex`
    member function of `unique_lock` returns a pointer to the stored mutex (line 19)
    or `nullptr` if `unique_lock` does not wrap a valid mutex.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_lock`的`owns_lock`成员函数在`unique_lock`拥有互斥锁时返回`true`，否则返回`false`（第13行和第18行）。`unique_lock`的`mutex`成员函数返回存储的互斥锁的指针（第19行），如果`unique_lock`没有包装有效的互斥锁，则返回`nullptr`。'
- en: Deadlocks
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 死锁
- en: Mutexes provide for exclusive ownership of shared resources and many real-world
    problems deal with multiple shared resources. Take the case of a multiplayer first-person
    shooting game. It maintains and updates two lists in real time. There is a set
    A of shooters who are players with ammunition of some sort, and a second set U
    of players that are unarmed. When a player exhausts her ammo, she is moved from
    A to U. When her ammo is replenished, she is moved back from U to A. Thread 1
    handles moving elements from A to U and thread 2 handles moving elements from
    U to A.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁提供了对共享资源的独占所有权，而许多现实世界的问题涉及多个共享资源。以多人第一人称射击游戏为例。它实时维护和更新两个列表。一个是A组射手，他们是带有某种弹药的玩家，另一个是U组玩家，他们是手无寸铁的。当玩家用尽弹药时，她会从A组移动到U组。当她的弹药补充时，她会从U组移回A组。线程1负责将元素从A组移动到U组，线程2负责将元素从U组移动到A组。
- en: 'When a new player joins the game, she is added to either U or A, depending
    on whether she has ammo. When a player is killed in the game, she is removed from
    whichever set (U or A) she was part of. But when ammo is either exhausted or replenished,
    the player is moved between U and A; so both U and A need to be edited. Consider
    the following code in which one thread is responsible for moving players from
    A to U when ammo is exhausted, and another thread is responsible for the movement
    back (U to A) when ammo is replenished:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新玩家加入游戏时，她会被添加到U组或A组，具体取决于她是否有弹药。当玩家在游戏中被杀死时，她会从U组或A组中被移除。但当弹药用尽或补充时，玩家会在U组和A组之间移动；因此U组和A组都需要被编辑。考虑以下代码，其中一个线程负责在弹药用尽时将玩家从A组移动到U组，另一个线程负责在弹药补充时将玩家从U组移回A组：
- en: '**Listing 10.12: Deadlock example**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.12：死锁示例**'
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each time a player's ammo is exhausted, the `onAmmoExhausted` (line 42) function
    is called with the ID of the player. This function creates a thread that runs
    the function `a2u` (line 18) to move this player from set A (`armed`) to set U
    (`unarmed`). Similarly, when player's ammo is replenished, the `onAmmoReplenished`
    (line 47) function is called and this, in turn, runs the function `u2a` in a separate
    thread to move the player from the set U (`unarmed`) to the set A (`armed`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家的弹药用尽时，都会调用`onAmmoExhausted`（第42行）函数，并传递玩家的ID。这个函数创建一个线程来运行`a2u`函数（第18行），将这个玩家从A组（武装）移动到U组（非武装）。同样，当玩家的弹药补充时，会调用`onAmmoReplenished`（第47行）函数，然后在一个单独的线程中运行`u2a`函数，将玩家从U组（非武装）移动到A组（武装）。
- en: The mutexes `amtx` and `umtx` control access to the sets `armed` and `unarmed`.
    To move a player from A to U, the function `a2u` first acquires a lock on `amtx`
    (line 19) and looks up the player in `armed` (line 20). If the player is found,
    the thread acquires a lock on `umtx` (line 23), puts the player in `unarmed` (line
    23), releases the lock on `umtx` (line 24), and removes the player from `armed`
    (line 25).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁`amtx`和`umtx`控制着对`armed`和`unarmed`组的访问。要将玩家从A组移动到U组，函数`a2u`首先获取`amtx`的锁（第19行），然后在`armed`中查找玩家（第20行）。如果找到了玩家，线程会在`umtx`上获取锁（第23行），将玩家放入`unarmed`（第23行），释放`umtx`上的锁（第24行），并从`armed`中移除玩家（第25行）。
- en: The function `u2a` has essentially the same logic but acquires the lock on `umtx`
    first, followed by `amtx`, and this leads to a fatal flaw. If one player exhausts
    ammo and another replenishes ammo at around the same time, two threads could run
    `a2u` and `u2a` concurrently. Perhaps rarely, it could happen that the `exhausted`
    thread locks `amtx` (line 19), but before it can lock `umtx` (line 23), the `replenished`
    thread locks `umtx` (line 31). Now the exhausted thread waits for `umtx`, which
    is held by the `replenished` thread, and the `replenished` thread waits for `amtx`,
    which is held by the `exhausted` thread. There is no conceivable way for the two
    threads to proceed from this state, and they are locked in a deadlock.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`u2a`本质上具有相同的逻辑，但首先获取`umtx`的锁，然后是`amtx`，这导致了一个致命的缺陷。如果一个玩家在大约相同的时间内用尽弹药，另一个玩家补充弹药，两个线程可能会同时运行`a2u`和`u2a`。也许很少见，但可能发生的是，`exhausted`线程锁定了`amtx`（第19行），但在它可以锁定`umtx`（第23行）之前，`replenished`线程锁定了`umtx`（第31行）。现在，`exhausted`线程等待`umtx`，而`umtx`被`replenished`线程持有，而`replenished`线程等待`amtx`，而`amtx`被`exhausted`线程持有。这两个线程没有任何可能的方式可以从这种状态中继续，它们陷入了死锁。
- en: A **deadlock** is a state in which two or more threads vying for shared resources
    are blocked, waiting on some resources while holding others, such that it is *impossible*
    for any of the threads to progress from that state.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**是指两个或更多个线程竞争共享资源时被阻塞，它们在等待某些资源的同时持有其他资源，以至于任何一个线程都*不可能*从这种状态中前进。'
- en: 'In our example, only two threads were involved, and it is relatively easy to
    debug and fix the problem. The gold standard for fixing deadlocks is to ensure
    **fixed lock-acquisition order**—any thread acquires two given locks in the same
    order. By rewriting `u2a`, as shown in the following snippet, we can ensure that
    a deadlock is not possible:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，只涉及了两个线程，相对容易调试和修复问题。修复死锁的黄金标准是确保**固定的锁获取顺序**——任何线程以相同的顺序获取两个给定的锁。通过重写`u2a`，如下面的代码片段所示，我们可以确保不会发生死锁：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we make sure that `u2a` locks `amtx` first before locking
    `umtx`, just like `a2u` does. We could have manually acquired the locks in this
    order but instead, we demonstrate the use of `boost::lock` to do this. We create
    the `unique_lock` objects, `lka` and `lku`, with the `defer_lock` flag to indicate
    we do not want to acquire the locks yet. We then call `boost::lock`, passing the
    `unique_lock`s in the order we would like to acquire them, and `boost::lock` ensures
    that order is observed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们确保`u2a`在锁定`umtx`之前先锁定`amtx`，就像`a2u`一样。我们本可以手动按照这个顺序获取锁，但相反，我们演示了使用`boost::lock`来实现这一点。我们创建了`unique_lock`对象`lka`和`lku`，并使用`defer_lock`标志来指示我们暂时不想获取锁。然后我们调用`boost::lock`，按照我们想要获取它们的顺序传递`unique_lock`，`boost::lock`确保了这个顺序被遵守。
- en: There are two reasons for using `boost::unique_lock` instead of `boost::lock_guard`
    in this example. First, we can create `unique_lock`s without immediately locking
    the mutex. Second, we can call `unlock` to release the `unique_lock` early (line
    40) and increase lock granularity, which promotes concurrency.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`boost::unique_lock`而不是`boost::lock_guard`有两个原因。首先，我们可以创建`unique_lock`而不立即锁定互斥锁。其次，我们可以调用`unlock`提前释放`unique_lock`（第40行），增加锁的粒度，促进并发。
- en: Besides fixed lock-acquisition order, another way to avoid deadlocks is for
    threads to probe locks (using `try_lock`) and backtrack if they fail to acquire
    a particular lock. This typically makes code more complex, but may be necessary
    sometimes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了固定的锁获取顺序，避免死锁的另一种方法是让线程探测锁（使用`try_lock`），如果未能获取特定锁，则回溯。这通常会使代码更复杂，但有时可能是必要的。
- en: There are many real-world examples of code with deadlocks, like the one in our
    example, which might be working correctly for years but with deadlocks lurking
    in them. Sometimes, the probability of hitting the deadlock could be very low
    when run on one system, and you might immediately hit it when you run the same
    code on another system, all purely because of variances in thread scheduling on
    the two systems.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多现实世界的代码示例出现死锁，就像我们例子中的代码一样，可能多年来一直正常工作，但其中潜藏着死锁。有时，在一个系统上运行时命中死锁的概率可能非常低，但当你在另一个系统上运行相同的代码时，可能会立即遇到死锁，这纯粹是因为两个系统上的线程调度差异。
- en: Synchronizing on conditions
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在条件上进行同步
- en: Mutexes serialize access to shared data by creating critical sections. A critical
    section is like a room with a lock and a waiting area outside. One thread acquires
    the lock and occupies the room while others arrive outside, wait for the occupant
    to vacate the room, and then take its place in some defined order. Sometimes,
    threads need to wait on a condition becoming true, such as some shared data changing
    state. Let us look at the producer-consumer problem to see examples of threads
    waiting on conditions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁通过创建临界区来串行访问共享数据。临界区就像一个带有锁和外部等待区的房间。一个线程获取锁并占据房间，而其他线程在外面等待，等待占有者离开房间，然后按照某种定义好的顺序取代它的位置。有时，线程需要等待条件变为真，比如一些共享数据改变状态。让我们看看生产者-消费者问题，看看线程等待条件的例子。
- en: Condition variables and producer-consumer problem
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件变量和生产者-消费者问题
- en: The Unix command-line utility **grep** searches files for text patterns specified
    using regular expressions. It can search through a whole list of files. To search
    for a pattern in a file, its complete contents must be read and searched for the
    pattern. Depending on the number of files to search, one or more threads can be
    employed to concurrently read contents of files into buffers. The buffers can
    be stored in some data structure that indexes them by file and offset. Multiple
    threads can then process these buffers and search them for the pattern.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Unix命令行实用程序**grep**使用正则表达式在文件中搜索文本模式。它可以搜索整个文件列表。要在文件中搜索模式，必须读取完整内容并搜索模式。根据要搜索的文件数量，可以使用一个或多个线程并发地将文件内容读入缓冲区。缓冲区可以存储在某种数据结构中，通过文件和偏移量对其进行索引。然后多个线程可以处理这些缓冲区并搜索其中的模式。
- en: What we just described is an example of a producer-consumer problem in which
    a set of threads generates some content and puts them in a data structure, and
    a second set of threads reads the content off the data structure, and performs
    computations on it. If the data structure is empty, the consumers must wait until
    a producer adds some content. If data fills up the data structure, then the producers
    must wait for consumers to process some data and make room in the data structure
    before trying to add more content. In other words, consumers wait on certain conditions
    to fulfill and these are fulfilled as a result of the actions of the producers,
    and vice versa.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述的是生产者-消费者问题的一个例子，其中一组线程生成一些内容并将其放入数据结构中，第二组线程从数据结构中读取内容，并对其进行计算。如果数据结构为空，消费者必须等待，直到生产者添加一些内容。如果数据填满了数据结构，那么生产者必须等待消费者处理一些数据，并在尝试添加更多内容之前在数据结构中腾出空间。换句话说，消费者等待某些条件得到满足，这些条件是由生产者的行为导致的，反之亦然。
- en: One way to model such conditions, wait on them, and signal them, is by using
    `boost::condition_variable` objects. A **condition variable** is associated with
    a testable runtime condition or predicate in the program. A thread tests the condition
    and if it is not true, the thread waits for that condition to become true using
    a `condition_variable` object. Another thread that causes the condition to become
    true signals the condition variable, and this wakes up one or more waiting threads.
    Condition variables are inherently associated with shared data and represent some
    condition being fulfilled for the shared data. In order for the waiting thread
    to first test a condition on the shared data, it must acquire the mutex. In order
    for the signaling thread to change the state of shared data, it too needs the
    mutex. In order for the waiting thread to wake up and verify the result of the
    change, it again needs the mutex. Thus we need to use `boost::mutex` in conjunction
    with a `boost::condition_variable`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟这种条件、等待它们并发出信号的一种方法是使用`boost::condition_variable`对象。**条件变量**与程序中可测试的运行时条件或谓词相关联。线程测试条件，如果条件不成立，则线程使用`condition_variable`对象等待条件成立。导致条件成立的另一个线程发出条件变量的信号，这会唤醒一个或多个等待的线程。条件变量与共享数据固有相关，并表示共享数据的某个条件被满足。为了让等待的线程首先测试共享数据的条件，它必须获取互斥锁。为了让发出信号的线程改变共享数据的状态，它也需要互斥锁。为了让等待的线程醒来并验证变化的结果，它再次需要互斥锁。因此，我们需要使用`boost::mutex`与`boost::condition_variable`结合使用。
- en: 'We will now solve the producer-consumer problem for a fixed-sized queue using
    condition variables. There is a queue of a fixed size, which means the maximum
    number of elements in the queue is bounded. One or more threads produce content
    and **enqueue** them (append them to the queue). One or more threads **dequeue**
    content (remove content from the head of the queue) and perform computations on
    the content. We use a circular queue implemented on top of a fixed size `boost::array`
    rather than any STL data structure, such as `std::list` or `std::deque`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用条件变量解决固定大小队列的生产者-消费者问题。队列的大小是固定的，这意味着队列中的元素数量是有限的。一个或多个线程生产内容并将其入队（追加到队列）。一个或多个线程出队内容（从队列头部移除内容）并对内容进行计算。我们使用在固定大小的`boost::array`上实现的循环队列，而不是任何STL数据结构，如`std::list`或`std::deque`。
- en: '**Listing 10.13: Using condition variables for a thread-safe, fixed-size queue**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.13：使用条件变量实现线程安全的固定大小队列**'
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this listing, we define the `CircularQueue<>` template and its member functions,
    including the `pop` (line 11) and `push` (line 32) member functions, which are
    of particular interest. A call to `push` blocks until there is space in the queue
    to add a new element. A call to `pop` blocks until it is able to read and remove
    an element from the top of the queue. The utility function `top` (line 21) blocks
    until it is able to read an element from the top of the queue, a copy of which
    it returns.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，我们定义了`CircularQueue<>`模板及其成员函数，包括特别感兴趣的`pop`（第11行）和`push`（第32行）成员函数。调用`push`会阻塞，直到队列中有空间添加新元素。调用`pop`会阻塞，直到能够从队列顶部读取并移除一个元素。实用函数`top`（第21行）会阻塞，直到能够从队列顶部读取一个元素，并返回其副本。
- en: To implement the necessary synchronization, we define the mutex `qlock` (line
    58) and two condition variables, `canRead` (line 59) and `canWrite` (line 60).
    The `canRead` condition variable is associated with a predicate that checks whether
    there are any elements in the queue which could thus be read. The `canWrite` condition
    variable is associated with a predicate that checks whether there is any space
    left in the queue where a new element can be added. The mutex `qlock` needs to
    be locked to edit the queue and to check the state of the queue in any way.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现必要的同步，我们定义了互斥锁`qlock`（第58行）和两个条件变量，`canRead`（第59行）和`canWrite`（第60行）。`canRead`条件变量与一个检查队列中是否有可读元素的谓词相关联。`canWrite`条件变量与一个检查队列中是否还有空间可以添加新元素的谓词相关联。编辑队列和以任何方式检查队列状态都需要锁定`qlock`互斥锁。
- en: The `pop` method first acquires a lock on `qlock` (line 12) and then checks
    whether the queue is empty (line 13). If the queue is empty, the call must block
    until there is an item available to read. To do this, `pop` calls the `wait` method
    on the `canRead` condition variable, passing it the lock `lock` and a lambda predicate
    to test (line 14). The call to `wait` unlocks the mutex in `lock` and blocks.
    If a call to the `push` method from another thread succeeds and thus data is available,
    the `push` method unlocks the mutex (line 39) and signals the `canRead` condition
    variable by calling the `notify_one` method (line 40). This wakes up exactly one
    thread blocked in the `wait` call inside a `pop` method call. The `wait` call
    atomically locks the mutex, checks whether the predicate (`size() > 0`) is true
    and if so, returns (line 14). If the predicate is not true, it once again unlocks
    the mutex and goes back to waiting.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop`方法首先在`qlock`（第12行）上获取锁，然后检查队列是否为空（第13行）。如果队列为空，调用必须阻塞，直到有可读取的项目为止。为此，`pop`调用`canRead`条件变量上的`wait`方法，传递锁`lock`和一个lambda谓词进行测试（第14行）。调用`wait`会解锁`lock`中的互斥锁并阻塞。如果另一个线程的`push`方法调用成功并且数据可用，`push`方法会解锁互斥锁（第39行）并通过调用`notify_one`方法（第40行）通知`canRead`条件变量。这会唤醒在`pop`方法调用内部的`wait`调用中阻塞的一个线程。`wait`调用会原子性地锁定互斥锁，检查谓词（`size()
    > 0`）是否为真，如果是，则返回（第14行）。如果谓词不为真，则再次解锁互斥锁并返回等待。'
- en: The `pop` method is either woken up from its wait, and verifies that there is
    an element to read after reacquiring the mutex lock, or it never has to wait because
    there were elements to read already. Thus, `pop` proceeds to remove the element
    at the head of the list (line 16). After removing the element, it unlocks the
    mutex (line 17) and calls `notify_one` on the `canWrite` condition (line 18).
    In case it popped an element from a queue that was full, and there were threads
    blocked in `push`, waiting for some room in the queue, the call to `notify_one`
    wakes up exactly one thread blocked in `canWrite.wait(...)` inside `push` (line
    35) and gives it the chance to add an item to the queue.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop`方法要么从等待中唤醒，并在重新获取互斥锁后验证是否有要读取的元素，要么根本不需要等待，因为已经有要读取的元素。因此，`pop`继续移除列表头部的元素（第16行）。在移除元素后，它会解锁互斥锁（第17行）并在`canWrite`条件上调用`notify_one`（第18行）。如果它从一个满队列中弹出一个元素，并且有线程在`push`中阻塞，等待队列中的空间，那么调用`notify_one`会唤醒在`push`内部的`canWrite.wait(...)`中阻塞的一个线程（第35行），并给它添加一个项目到队列的机会。'
- en: The implementation of `push` is really symmetrical and uses the same concepts
    we described for `pop`. We pass the mutex to the `wait` method on the condition
    variable, wrapped in a `unique_lock` and not a `lock_guard` because the wait method
    needs to access the underlying mutex to unlock it manually. The underlying mutex
    is retrieved from a `unique_lock` by calling the `mutex` member function of `unique_lock`;
    `lock_guard` does not provide such a mechanism.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`的实现实际上是对称的，并使用了我们描述的`pop`相同的概念。我们将互斥锁传递给条件变量上的`wait`方法，用`unique_lock`包装而不是`lock_guard`，因为`wait`方法需要手动访问底层互斥锁进行解锁。通过调用`unique_lock`的`mutex`成员函数从`unique_lock`中检索底层互斥锁；`lock_guard`不提供这样的机制。'
- en: To test our implementation, we create a `CircularQueue` of 200 elements of type
    `int` (line 65), a producer thread that pushes 10,000 elements into the queue
    (line 67), and four consumer threads that pop 2,500 elements each (lines 82-85).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的实现，我们创建了一个包含200个`int`类型元素的`CircularQueue`（第65行），一个将10,000个元素推入队列的生产者线程（第67行），以及四个每个弹出2,500个元素的消费者线程（第82-85行）。
- en: The consumer threads are not created individually but as part of a **thread
    group**. A thread group is an object of type `boost::thread_group`, which provides
    an easy way to manage multiple threads together. Since we want to create four
    consumer threads using the same initial function and join them all, it is easy
    to create a `thread_group` object (line 82), create four threads in a loop using
    its `create_thread` member function (line 84), and wait on all the threads in
    the group by calling the `join_all` method (line 88).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者线程不是单独创建的，而是作为**线程组**的一部分创建的。线程组是`boost::thread_group`类型的对象，它提供了一种管理多个线程的简单方法。由于我们想要使用相同的初始函数创建四个消费者线程并将它们全部加入，因此很容易创建一个`thread_group`对象（第82行），使用其`create_thread`成员函数在循环中创建四个线程（第84行），并通过调用`join_all`方法等待组中的所有线程（第88行）。
- en: Condition variable nuances
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件变量细微差别
- en: We call `notify_one` to signal the `canRead` condition variable and wake up
    exactly one thread waiting to read (line 39). Instead, we could have called `notify_all`
    to *broadcast* the event and wake up all waiting threads, and it would still have
    worked. However, we only put one new element in the queue in each call to `push`,
    so exactly one of the threads woken up would read the new element off the queue.
    The other threads would check the number of elements in the queue, find it empty,
    and go back to waiting, resulting in unnecessary context switches.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`notify_one`来通知`canRead`条件变量并唤醒等待读取的一个线程（第39行）。相反，我们可以调用`notify_all`来*广播*事件并唤醒所有等待的线程，它仍然可以工作。但是，我们每次调用`push`时只向队列中放入一个新元素，因此被唤醒的线程中只有一个会从队列中读取新元素。其他线程会检查队列中的元素数量，发现它为空，然后回到等待状态，导致不必要的上下文切换。
- en: But if we added a load of elements to the queue, calling `notify_all` might
    be a better alternative than `notify_one`. Calling `notify_one` would wake up
    only one waiting thread, which would process the elements serially in a loop (lines
    63-65). Calling `notify_all` would wake up all the threads, and they would process
    the elements concurrently much quicker.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们向队列中添加了大量元素，调用`notify_all`可能比`notify_one`更好。调用`notify_one`只会唤醒一个等待的线程，它会在循环中逐个处理元素（第63-65行）。调用`notify_all`会唤醒所有线程，它们会并发地更快地处理元素。
- en: One common conundrum is whether to call `notify_one`/`notify_all` while holding
    the mutex, as we have done in our examples earlier, or after releasing it. Both
    options work equally well, but there might be some difference in the performance.
    If you signal a condition variable while holding the mutex, the woken up threads
    would immediately block, waiting for the mutex until you release it. So there
    are two additional context switches per thread and these can have an impact on
    the performance. Therefore, if you unlock the mutex first before signaling the
    condition variable, you could see some performance benefits. Therefore, signaling
    *after* unlocking is the often preferred approach.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的难题是在持有互斥锁时是否调用`notify_one`/`notify_all`，就像我们之前的例子中所做的那样，还是在释放锁之后。这两种选择都同样有效，但在性能上可能会有一些差异。如果在持有互斥锁时发出条件变量信号，被唤醒的线程会立即阻塞，等待释放锁。因此，每个线程会有两次额外的上下文切换，这可能会影响性能。因此，如果在发出条件变量信号之前先解锁互斥锁，可能会带来一些性能优势。因此，通常更倾向于在解锁之后发出信号。
- en: The Readers-Writers problem
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读者-写者问题
- en: Take the case of an online catalog of a library. The library maintains a look-up
    table of books. For simplicity, let us imagine that the books can only be looked
    up by titles, and titles are unique. Multiple threads representing various clients
    perform look-ups on the library concurrently. From time to time, the librarian
    adds new books to the catalog and rarely, takes a book off the catalog. A new
    book can be added only if a book with the same title is not already present, or
    if an older edition of the title is present.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以图书馆的在线目录为例。图书馆维护一张书籍查找表。为简单起见，让我们假设书籍只能通过标题查找，并且标题是唯一的。代表各种客户端的多个线程同时在图书馆进行查找。图书管理员不时地向目录中添加新书，很少从目录中取走一本书。只有在没有相同标题的书籍或者存在旧版标题时，才能添加新书。
- en: 'In the following snippet, we define a type representing a book entry and the
    public interface of the `LibraryCatalog` class that represents the library catalog:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们定义了一个表示书目条目的类型，以及代表图书馆目录的`LibraryCatalog`类的公共接口：
- en: '**Listing 10.14a: Library catalog types and interfaces**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.14a：图书馆目录类型和接口**'
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The member function `find_book` is used to look up a single title and returns
    it as `book_t` object wrapped in `boost::optional`. Using `boost::optional`, we
    can return an empty value if a title is not found (see [Chapter 2](ch02.html "Chapter 2. The
    First Brush with Boost's Utilities"), *The First Brush with Boost's Utilities*).
    The member function `find_books` looks up a list of titles passed to it as a `vector`
    and returns a vector of `book_t` objects. The member function `add_book` adds
    a title to the catalog and `remove_book` removes a title from the catalog.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数`find_book`用于查找单个标题，并将其作为`book_t`对象包装在`boost::optional`中返回。使用`boost::optional`，如果找不到标题，我们可以返回一个空值（见[第2章](ch02.html
    "第2章。与Boost实用工具的初次接触")，“与Boost实用工具的初次接触”）。成员函数`find_books`查找作为`vector`传递给它的标题列表，并返回`book_t`对象的向量。成员函数`add_book`向目录中添加标题，`remove_book`从目录中删除标题。
- en: We want to implement the class to allow multiple threads to look up titles concurrently.
    We also want to allow the librarian to add and remove titles concurrently with
    the reads, without hurting correctness or consistency.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现该类以允许多个线程同时查找标题。我们还希望允许图书管理员在读取时并发地添加和删除标题，而不会影响正确性或一致性。
- en: 'As long as data in the catalog does not change, multiple threads can concurrently
    look up titles without the need for any synchronization; because read-only operations
    cannot introduce inconsistencies. But since the catalog does allow the librarian
    to add and remove titles, we must make sure that these operations do not interleave
    with read operations. In thus formulating our requirements, we just stated the
    classic concurrency problem known as the Readers-Writers problem. The Readers-Writers
    problem lays down the following constraints:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 只要目录中的数据不发生变化，多个线程可以同时查找标题，而无需任何同步；因为只读操作不会引入不一致性。但由于目录允许图书管理员添加和删除标题，我们必须确保这些操作不会与读操作交错。在这样制定我们的要求时，我们刚刚陈述了众所周知的并发问题，即读者-写者问题。读者-写者问题规定了以下约束：
- en: Any writer thread must have exclusive access to a data structure
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何写线程必须对数据结构进行排他访问
- en: Any reader thread can share access to the data structure with other reader threads,
    in the absence of a writer thread
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有写入线程的情况下，任何读取线程都可以与其他读取线程共享对数据结构的访问。
- en: In the above statements, *reader thread* refers to threads performing only read-only
    operations like looking up titles, and *writer thread* refers to threads that
    modify the contents of the data structure in some way, such as adding and removing
    titles. This is sometimes referred to as **Multiple Readers Single Writer** (**MRSW**)
    model, as it allows either multiple concurrent readers or a single exclusive writer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语句中，*读取线程*指的是只执行只读操作的线程，比如查找标题，*写入线程*指的是以某种方式修改数据结构内容的线程，比如添加和删除标题。这有时被称为**多读者单写者**（**MRSW**）模型，因为它允许多个并发读者或单个独占写者。
- en: 'While `boost::mutex` allows a single thread to acquire an exclusive lock, it
    does not allow multiple threads to share a lock. We need to use `boost::shared_mutex`
    for this purpose. `boost::shared_mutex` conforms to the *SharedLockable* concept,
    which subsumes the Lockable concept, and additionally, defines `lock_shared` and
    `unlock_shared` member functions, which should be called by reader threads. Because
    `shared_mutex` also conforms to Lockable, it can be locked for exclusive access
    using `boost::lock_guard` or `boost::unique_lock`. Let us now look at the implementation
    of `LibraryCatalog`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`boost::mutex`允许单个线程获取排他锁，但它不允许多个线程共享锁。我们需要使用`boost::shared_mutex`来实现这一目的。`boost::shared_mutex`符合*SharedLockable*概念，它包含Lockable概念，并且另外定义了`lock_shared`和`unlock_shared`成员函数，应该由读取线程调用。因为`shared_mutex`也符合Lockable，所以可以使用`boost::lock_guard`或`boost::unique_lock`来对其进行排他访问。现在让我们来看一下`LibraryCatalog`的实现：
- en: '**Listing 10.14b: Library catalog implementation**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.14b：图书馆目录实现**'
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The method `find_book` performs read-only operations on the catalog and therefore
    acquires a shared lock using the `boost::shared_lock` template (line 17). It releases
    the lock after retrieving a matching book, if any (line 23). The method `find_books`
    is implemented in terms of `find_book`, which it calls in a loop for each title
    in the list passed to it. This allows for better overall concurrency between reader
    threads at the cost of a slight performance hit, due to repeated locking and unlocking
    of the `shared_mutex`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`find_book`对目录执行只读操作，因此使用`boost::shared_lock`模板（第17行）获取共享锁。在检索到匹配的书籍后释放锁（第23行）。方法`find_books`是根据`find_book`实现的，它在传递给它的列表中的每个标题上调用循环中的`find_book`。这允许更好地在读取线程之间实现整体并发性，但会因为重复锁定和解锁`shared_mutex`而导致轻微的性能损失。
- en: Both `add_book` and `remove_book` are mutating functions that potentially change
    the number of elements in the catalog. In order to modify the catalog, both methods
    require exclusive or write locks on the catalog. For this reason, we use `unique_lock`
    instances to acquire an exclusive lock on the `shared_mutex` (lines 43 and 59).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_book`和`remove_book`都是可能改变目录中元素数量的变异函数。为了修改目录，这两种方法都需要对目录进行排他性或写入锁定。因此，我们使用`unique_lock`实例来获取`shared_mutex`（第43行和第59行）上的排他锁。'
- en: Upgradable locks
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可升级的锁
- en: There is one glaring problem in the implementation of `add_book` and `remove_book`
    methods in listing 10.14b. Both methods modify the catalog conditionally, based
    on the outcome of a look-up that is run first. Yet an exclusive lock is acquired
    unconditionally at the start of both operations. One could conceivably call `remove_book`
    with a nonexistent title or `add_book` with an edition of a book that is already
    in the catalog, in a loop, and seriously hamper the concurrency of the system
    doing nothing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单10.14b中`add_book`和`remove_book`方法的实现中存在一个明显的问题。这两种方法都是有条件地修改目录，根据首先运行的查找的结果。然而，在这两个操作的开始处无条件地获取了排他锁。可以想象，可能会在循环中调用`remove_book`，并严重阻碍系统的并发性，因为标题不存在，或者使用已经在目录中的书的版本调用`add_book`。
- en: If we acquired a shared lock to perform the look up, we would have to release
    it before acquiring an exclusive lock for modifying the catalog. In this case,
    the results of the look up would no longer be reliable, as some other thread could
    have modified the catalog between the time the shared lock is released and the
    exclusive lock acquired.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们获取了共享锁来执行查找，那么在获取排他锁修改目录之前，我们必须释放它。在这种情况下，查找的结果将不再可靠，因为在释放共享锁和获取排他锁之间，其他线程可能已经修改了目录。
- en: 'This problem can be addressed by using `boost::upgrade_lock` and a set of associated
    primitives. This is shown in the following rewrite of `add_book`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过使用`boost::upgrade_lock`和一组相关的原语来解决。这在以下`add_book`的重写中显示：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Instead of acquiring an exclusive lock to start with, we acquire an *upgrade
    lock* before performing the look up (line 2), and then *upgrade* it to a unique
    lock only if we need to modify the catalog (lines 6-7 and 11-12). To acquire an
    upgrade lock, we wrap the shared mutex in an `upgrade_lock<boost::shared_mutex>`
    instance (line 2). This blocks if there is an exclusive lock or another upgrade
    lock on the mutex in effect, but proceeds otherwise even if there be shared locks.
    Thus, at any point in time, there can be any number of shared locks and at most
    one upgrade lock on a mutex. Acquiring an upgrade lock thus does not impact read
    concurrency. Once the look up is performed, and it is determined that a write
    operation needs to be performed, the upgrade lock is promoted to a unique lock
    by wrapping it in an instance of `upgrade_to_unique_lock<boost::shared_mutex>`
    (lines 6-7 and 11-12). This blocks until there are no remaining shared locks,
    and then *atomically* releases the upgrade ownership and acquires an exclusive
    ownership on the `shared_mutex`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是从一开始就获取独占锁，而是在执行查找之前获取*升级锁*（第2行），然后只有在需要修改目录时才将其*升级*为唯一锁（第6-7行和第11-12行）。要获取升级锁，我们将共享互斥量包装在`upgrade_lock<boost::shared_mutex>`实例中（第2行）。如果互斥量上有独占锁或另一个升级锁在生效，则会阻塞，但否则即使有共享锁也会继续。因此，在任何时间点，互斥量上可以有任意数量的共享锁，最多只能有一个升级锁。因此，获取升级锁不会影响读并发性。一旦执行查找，并确定需要执行写操作，升级锁就会通过将其包装在`upgrade_to_unique_lock<boost::shared_mutex>`实例中（第6-7行和第11-12行）来升级为唯一锁。这会阻塞，直到没有剩余的共享锁，然后*原子地*释放升级所有权并在`shared_mutex`上获取独占所有权。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Acquiring an upgrade lock indicates intent to potentially upgrade it to an exclusive
    lock and perform writes or modifications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 获取升级锁表示有可能将其升级为独占锁并执行写入或修改。
- en: Performance of shared_mutex
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享互斥量的性能
- en: '`boost::shared_mutex` is slower than `boost::mutex` but acquiring additional
    read locks on an already read-locked mutex is much faster. It is ideally suited
    for frequent concurrent reads with infrequent need for exclusive write access.
    Any time you deal with frequent writes, just use `boost::mutex` to provide exclusive
    write access.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::shared_mutex`比`boost::mutex`慢，但在已经被读锁定的互斥量上获取额外的读锁要快得多。它非常适合频繁的并发读取，很少需要独占写访问。每当需要频繁写入时，只需使用`boost::mutex`来提供独占写访问。'
- en: Most solutions to the MRSW problem either prefer readers over writers or the
    other way round. In **read-preferring solutions**, when a shared lock is in effect,
    new reader threads can acquire a shared lock even with a writer waiting to acquire
    an exclusive lock. This leads to write-starvation as the writer only ever gets
    an exclusive lock at a point when no readers are around. In **write-preferring
    solutions**, if there is a writer thread waiting on an exclusive lock, then new
    readers are queued even if existing readers hold a shared lock. This impacts the
    concurrency of reads. Boost 1.57 (current release) provides a shared/exclusive
    lock implementation that is completely fair and does not have either a reader-
    or a writer-bias.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数MRSW问题的解决方案要么偏向读取者，要么偏向写入者。在**偏向读取的解决方案**中，当共享锁生效时，新的读取线程可以获取共享锁，即使有一个等待获取独占锁的写入者。这导致写入者饥饿，因为写入者只有在没有读取者时才能获取独占锁。在**偏向写入的解决方案**中，如果有一个写入者线程在等待独占锁，那么即使现有的读取者持有共享锁，新的读取者也会排队。这会影响读取的并发性。Boost
    1.57（当前版本）提供了一个完全公平的共享/独占锁实现，既不偏向读取者也不偏向写入者。
- en: Standard Library primitives
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准库原语
- en: The C++11 Standard Library introduces `std::mutex` and a whole host of RAII
    wrappers for locks, including `std::lock_guard`, `std::unique_lock`, and `std::lock`,
    available in the header `mutex`. C++11 Standard Library also introduces `std::condition_variable`
    available in the header `condition_variable`. The C++14 Standard Library introduces
    `std::shared_timed_mutex`, which corresponds to `boost::shared_mutex` and `std::shared_lock`,
    both available in the header `mutex`. They correspond to their Boost counterparts
    of the same names, and have very similar interfaces. There is no upgrade lock
    facility in the Standard Library as of C++14, nor any equivalent of the convenient
    `boost::thread_group`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准库引入了`std::mutex`和一整套用于锁的RAII包装器，包括`std::lock_guard`、`std::unique_lock`和`std::lock`，都在头文件`mutex`中可用。C++11标准库还引入了`std::condition_variable`，可在头文件`condition_variable`中使用。C++14标准库引入了`std::shared_timed_mutex`，对应于`boost::shared_mutex`和`std::shared_lock`，都在头文件`mutex`中可用。它们对应于它们的同名Boost对应物，并且具有非常相似的接口。截至C++14，标准库中没有升级锁设施，也没有方便的`boost::thread_group`的等效物。
- en: Boost Coroutine
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost协程
- en: 'Coroutines are functions that can *yield* or relinquish control to another
    coroutine, and then given control back, resuming from the point at which they
    earlier yielded. The state of automatic variables is maintained between a yield
    and the resumption. Coroutines can be used for complex control flow patterns with
    surprisingly simple and clean code. The Boost Coroutine library provides two types
    of coroutines:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是可以*yield*或放弃控制权给另一个协程的函数，然后再次获得控制权，从之前放弃控制权的地方继续执行。自动变量的状态在yield和恢复之间保持不变。协程可用于复杂的控制流模式，代码既简单又清晰。Boost协程库提供了两种类型的协程：
- en: '**Asymmetric coroutines**: Asymmetric coroutines distinguish between a caller
    and a callee coroutine. With asymmetric coroutines, a callee can only yield back
    to the caller. They are often used for unidirectional data transfer from either
    the callee to caller, or the other way.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称协程：非对称协程区分调用者和被调用者协程。使用非对称协程时，被调用者只能向调用者产生输出。它们通常用于从被调用者到调用者的单向数据传输，或者反之亦然。
- en: '**Symmetric coroutines**: Such coroutines can *yield* to other coroutines,
    irrespective of who the caller was. They can be used to generate complex cooperative
    chains of coroutines.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称协程：这种协程可以*yield*给其他协程，不管调用者是谁。它们可以用于生成复杂的协作协程链。
- en: When a coroutine yields control, it is said to be suspended—its registers are
    saved and it relinquishes control to another function. On resumption, the registers
    are restored and execution continues beyond the point of yield. The Boost Coroutine
    library utilizes the Boost Context library for this purpose.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程放弃控制时，它被挂起，即它的寄存器被保存，并且它放弃控制给另一个函数。在恢复时，寄存器被恢复，执行继续到挂起点之后。Boost Coroutine库利用Boost
    Context库来实现这一目的。
- en: A distinction is made between *stackful coroutines* versus *stackless coroutines*.
    A stackful coroutine can be suspended from within a function called by the coroutine,
    that is, from a nested stackframe. With stackless coroutines, only the top level
    routine may suspend itself. In this chapter, we only look at asymmetric stackful
    coroutines.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈协程*与*无堆栈协程*之间有区别。堆栈协程可以从由协程调用的函数中挂起，也就是说，从嵌套的堆栈帧中挂起。对于无堆栈协程，只有顶层例程可以挂起自己。在本章中，我们只关注不对称的堆栈协程。'
- en: Asymmetric coroutines
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不对称协程
- en: The core template used to define asymmetric coroutines is called `boost::coroutines::asymmetric_coroutine<>`.
    It takes a single type parameter that represents the type of value transferred
    from one coroutine to the other. It can be `void` if no value needs to be transferred.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义不对称协程的核心模板称为`boost::coroutines::asymmetric_coroutine<>`。它接受一个表示从一个协程传输到另一个协程的值类型参数。如果不需要传输值，可以是`void`。
- en: 'Coroutines that call other coroutines or yield to them must have a way to refer
    to other coroutines. The nested type `asymmetric_coroutine<T>::push_type` represents
    a coroutine that provides data of type `T`, and the nested type `asymmetric_coroutine<T>::pull_type`
    represents a coroutine that consumes the data of type `T`. Both the types are
    callable types, with an overloaded `operator()`. Using these types, we shall now
    write a program that uses coroutines to read data from a vector of elements:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 调用其他协程或向它们产出数据的协程必须有一种方式来引用其他协程。嵌套类型`asymmetric_coroutine<T>::push_type`表示提供类型为`T`的数据的协程，而嵌套类型`asymmetric_coroutine<T>::pull_type`表示消耗类型为`T`的数据的协程。这两种类型都是可调用类型，具有重载的`operator()`。使用这些类型，我们现在将编写一个程序，使用协程从元素的向量中读取数据：
- en: '**Listing 10.15: Using asymmetric coroutines**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10.15：使用不对称协程**'
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To start with, we define two alias templates called `pull_type` and `push_type`
    referring to `asymmetric_coroutine<T>::pull_type` and `asymmetric_coroutine<T>::push_type`
    for a type parameter T (lines 7-9 and 11-13).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了两个别名模板，称为`pull_type`和`push_type`，分别指向类型参数T的`asymmetric_coroutine<T>::pull_type`和`asymmetric_coroutine<T>::push_type`（第7-9行和11-13行）。
- en: The function `getNextElem` (line 16) is meant to be used as a coroutine that
    passes the next element from a vector to the caller each time it is called. The
    `main` function populates this vector (lines 26-27) and then calls `getNextElem`
    repeatedly to get each element. Thus data is transferred from `getNextElem` to
    `main`, `main` being the caller routine, and `getNextElem`, the callee routine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`getNextElem`（第16行）旨在用作协程，每次调用时将下一个元素从向量传递给调用者。`main`函数填充了这个向量（第26-27行），然后重复调用`getNextElem`以获取每个元素。因此，数据从`getNextElem`传输到`main`，`main`是调用者例程，`getNextElem`是被调用者例程。
- en: 'Depending on whether the coroutine pushes data to the caller or pulls data
    from it, it should have one of the following two signatures:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 根据协程是向调用者推送数据还是从中拉取数据，它应该具有以下两种签名之一：
- en: '`void (push_type&)`: Coroutine pushes data to caller'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void (push_type&)`：协程向调用者推送数据'
- en: '`void(pull_type&)`: Coroutine pulls data from caller'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void(pull_type&)`：协程从调用者拉取数据'
- en: The `pull_type` or `push_type` reference passed to the coroutine refers to the
    calling context and represents the conduit through which it pushes data to, or
    pulls data from the caller.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给协程的`pull_type`或`push_type`引用表示调用上下文，并代表通过它向调用者推送数据或从调用者拉取数据的通道。
- en: 'The caller routine must wrap the function in `pull_type` or `push_type`, depending
    on whether it intends to pull data from it or push data to it. In our case, the
    `main` function must wrap `getNextElem` in an instance of `pull_type`. However,
    the signature of `getNextElem` is:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者例程必须使用`pull_type`或`push_type`包装函数，具体取决于它是打算从中拉取数据还是向其中推送数据。在我们的情况下，`main`函数必须在`pull_type`的实例中包装`getNextElem`。然而，`getNextElem`的签名是：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Thus we must adapt it to a conforming signature using some mechanism such as
    lambda or `bind`. We use `boost::bind` to bind the second parameter of `getNextElem`
    to the vector (lines 29-30) and wrap the resulting unary function object in a
    `pull_type` instance called `greet_func`. Creating the instance of `pull_type`
    invokes the `getNextElem` coroutine for the first time.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须使用某种机制（如lambda或`bind`）将其调整为符合签名。我们使用`boost::bind`将`getNextElem`的第二个参数绑定到向量（第29-30行），并将结果的一元函数对象包装在名为`greet_func`的`pull_type`实例中。创建`pull_type`实例会首次调用`getNextElem`协程。
- en: We can use `greet_func` in a Boolean context to check whether a value is available
    from the callee, and we use this to spin in a loop (line 32). In each iteration
    of the loop, we call the `get` member function on the `pull_type` instance to
    obtain the next value furnished by `getNextElem` (line 33). We then invoke the
    overloaded `operator()` of `pull_type` to relinquish control to the `getNextElem`
    coroutine (line 34).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在布尔上下文中使用`greet_func`来检查是否从被调用者那里获得了值，并且我们使用这一点在循环中旋转（第32行）。在循环的每次迭代中，我们调用`pull_type`实例上的`get`成员函数，以获取`getNextElem`提供的下一个值（第33行）。然后，我们调用`pull_type`的重载`operator()`，将控制权交给`getNextElem`协程（第34行）。
- en: On the other side, the `getNextElem` coroutine does not use a conventional return
    value to send data back to the caller. It iterates through the vector and uses
    the overloaded `operator()` on the calling context to return each element (line
    20). If the caller had to push data to the callee instead, then the caller would
    have wrapped the callee in `push_type`, and the callee would be passed the caller's
    reference wrapped in `pull_type`. In the next chapter, we will see how Boost Asio
    uses coroutines to simplify asynchronous, event-driven logic.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`getNextElem`协程不使用传统的返回值将数据发送回调用者。它通过向量进行迭代，并在调用上下文中使用重载的`operator()`来返回每个元素（第20行）。如果调用者必须将数据推送到被调用者，那么调用者将在`push_type`中包装被调用者，被调用者将传递给调用者的引用包装在`pull_type`中。在下一章中，我们将看到Boost
    Asio如何使用协程来简化异步事件驱动逻辑。
- en: Self-test questions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all options that apply:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: What happens if you do not call `join` or `detach` on a `boost::thread` object
    and a `std::thread` object?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`boost::thread`对象和`std::thread`对象上不调用`join`或`detach`会发生什么？
- en: a. `join` is called on underlying thread of `boost::thread`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在`boost::thread`的基础线程上调用`join`。
- en: b. `std::terminate` is called for `std::thread`, terminating the program.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: b. 对于`std::thread`，将调用`std::terminate`，终止程序。
- en: c. `detach` is called on underlying thread of `boost::thread`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在`boost::thread`的基础线程上调用`detach`。
- en: d. `detach` is called on underlying thread of `std::thread`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在`std::thread`的基础线程上调用`detach`。
- en: What happens if an exception is allowed to propagate past the initial function
    with which a `boost::thread` object is created?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果允许异常传播到创建`boost::thread`对象的初始函数之外会发生什么？
- en: a. The program is terminated via `std::terminate`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: a. 程序将通过`std::terminate`终止。
- en: b. It is undefined behavior.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: b. 这是未定义的行为。
- en: c. The call to `get` on the `future` object throws an exception in the calling
    thread.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在调用线程上`future`对象的`get`调用会抛出异常。
- en: d. The thread is terminated but the exception is not propagated.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: d. 线程终止，但异常不会传播。
- en: Should you call `notify_one` or `notify_all` on a `condition_variable` object
    without holding the associated mutex?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不持有相关互斥量的情况下，您应该在`condition_variable`对象上调用`notify_one`或`notify_all`吗？
- en: a. No, the call will block.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: a. 不会，调用会阻塞。
- en: b. Yes, but it may result in priority inversion in some cases.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: b. 是的，但在某些情况下可能会导致优先级反转。
- en: c. No, some waiting threads may miss the signal.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: c. 不会，一些等待的线程可能会错过信号。
- en: d. Yes, it may even be faster.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: d. 是的，甚至可能更快。
- en: What is the advantage of using `boost::unique_lock` over `boost::lock_guard`?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`boost::unique_lock`而不是`boost::lock_guard`的优势是什么？
- en: a. `boost::unique_lock` is more efficient and lightweight.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: a. `boost::unique_lock`更有效率和轻量级。
- en: b. `boost::unique_lock` can or adopt an already acquired lock.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: b. `boost::unique_lock`可以或者采用已经获取的锁。
- en: c. `boost::lock_guard` cannot be unlocked and relocked mid-scope.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: c. `boost::lock_guard`不能在中间范围内解锁和重新锁定。
- en: d. `boost::unique_lock` can defer acquiring a lock.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: d. `boost::unique_lock`可以推迟获取锁。
- en: Which of the following are true of `boost::shared_mutex`?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些关于`boost::shared_mutex`是正确的？
- en: a. `shared_mutex` is more lightweight and faster than `boost::mutex`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: a. `shared_mutex`比`boost::mutex`更轻量级和更快。
- en: b. Boost implementation of `shared_mutex` does not have reader- or writer-bias.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: b. Boost对`shared_mutex`的实现没有读者或写者偏向。
- en: c. `shared_mutex` can be used as an upgradable lock.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: c. `shared_mutex`可以用作可升级的锁。
- en: d. `shared_mutex` is ideal for systems with high-write contention.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: d. `shared_mutex`非常适合高写入争用的系统。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to write concurrent logic in terms of threads
    and tasks using the Boost Thread library and the C++11 Standard Library. We learned
    how to use the futures and promises paradigm to define ordering of operations
    across concurrent tasks, and some abstractions around futures and promises in
    the Standard Library. We also studied various lock-based thread synchronization
    primitives and applied them to some common multithreading problems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Boost Thread库和C++11标准库来编写线程和任务的并发逻辑。我们学习了如何使用期望和承诺范式来定义并发任务之间的操作顺序，以及标准库中围绕期望和承诺的一些抽象。我们还研究了各种基于锁的线程同步原语，并将它们应用于一些常见的多线程问题。
- en: 'Multithreading is a difficult and complex topic, and this chapter merely introduces
    the portable APIs available in Boost to write concurrent programs. The Boost Thread
    library and the concurrent programming interfaces in the C++ Standard Library
    are an evolving set, and we did not cover several features: the C++ memory model
    and atomics, Boost Lockfree, thread cancellation, experimental continuations with
    `boost::future`s, and several more topics. Architectural concerns in designing
    concurrent systems and concurrent data structures are other relevant topics that
    are outside the scope of this book. Hopefully, the concepts and methods presented
    in this chapter will help you explore further in these directions.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一个困难而复杂的主题，本章仅介绍了Boost中可用的便携式API来编写并发程序。Boost Thread库和C++标准库中的并发编程接口是一个不断发展的集合，我们没有涵盖几个功能：C++内存模型和原子操作，Boost
    Lockfree，线程取消，使用`boost::future`进行实验性延续等等。设计并发系统和并发数据结构的架构问题是其他相关主题，超出了本书的范围。希望本章介绍的概念和方法能帮助您在这些方向上进一步探索。
- en: References
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: '*C++ Concurrency in Action*, *Anthony Williams*, *Manning Publications*'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ Concurrency in Action*, *Anthony Williams*, *Manning Publications*'
- en: 'Lockfree data structures: [http://www.boost.org/libs/lockfree](http://www.boost.org/libs/lockfree)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无锁数据结构：[http://www.boost.org/libs/lockfree](http://www.boost.org/libs/lockfree)
- en: '*A proposal to add coroutines to the C++ standard library (Revision 1)*, *Oliver
    Kowalke* and *Nat Goodspeed*: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3985.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3985.pdf)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向C++标准库添加协程的提案（修订版1）*，*Oliver Kowalke* 和 *Nat Goodspeed*: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3985.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3985.pdf)'
- en: 'Lock-Free Programming, Herb Sutter: [https://youtu.be/c1gO9aB9nbs](https://youtu.be/c1gO9aB9nbs)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '无锁编程，Herb Sutter: [https://youtu.be/c1gO9aB9nbs](https://youtu.be/c1gO9aB9nbs)'
- en: 'atomic<> Weapons (video), Herb Sutter:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'atomic<> Weapons（视频），Herb Sutter:'
- en: '[https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2](https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2](https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2)'
- en: '[https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2](https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2](https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2)'
