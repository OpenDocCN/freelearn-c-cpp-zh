- en: 8\. Dynamic Programming I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 动态规划I
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Analyze whether the dynamic programming approach can be applied to a given problem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析动态规划方法是否适用于给定问题
- en: Compare and choose the right approach between memoization and tabulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较并选择记忆化和表格法之间的正确方法
- en: Choose an appropriate caching solution using memoization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择使用记忆化的适当缓存解决方案
- en: Analyze a problem using a naive brute-force approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用朴素的蛮力方法分析问题
- en: Develop a dynamic programming solution by implementing progressively optimized
    algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现逐步优化的算法来开发动态规划解决方案
- en: In this chapter, you will be introduced to the dynamic programming approach.
    This chapter will guide you through implementing this approach for solving some
    well-known problems in computer science.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将介绍动态规划方法。本章将指导您实现这种方法来解决计算机科学中一些众所周知的问题。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: Loved and feared in equal measure by many programmers, **dynamic programming**
    (**DP**) is a conceptual extension of the divide-and-conquer paradigm that pertains
    to a specific class of problems. The difficulties involved in dynamic programming
    problems are multi-faceted and often require creativity, patience, and the ability
    to visualize abstract concepts. However, the challenges these problems pose frequently
    have elegant and surprisingly simple solutions, which can provide a programmer
    with insights that reach far beyond the scope of the immediate task.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员对**动态规划**（**DP**）既爱又恐惧，它是分治范例的概念扩展，适用于特定类别的问题。动态规划问题涉及的困难是多方面的，通常需要创造力、耐心和对抽象概念的可视化能力。然而，这些问题提出的挑战通常有优雅且令人惊讶地简单的解决方案，这些解决方案可以为程序员提供超出即时任务范围的见解。
- en: In the previous chapter, we discussed several techniques, such as the divide-and-conquer
    and the greedy approach. These approaches, though quite effective in the right
    circumstances, will not produce optimal results in certain situations. For example,
    in the previous chapter, we discussed how Dijkstra's algorithm does not produce
    optimal results for graphs with negative edge weights, whereas the Bellman-Ford
    algorithm does. For problems that can be solved recursively, but cannot be solved
    using the aforementioned techniques, a DP solution may often be the best approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了几种技术，比如分治和贪婪方法。这些方法在适当的情况下非常有效，但在某些情况下不会产生最佳结果。例如，在上一章中，我们讨论了Dijkstra算法对于具有负边权重的图不会产生最佳结果，而Bellman-Ford算法会。对于可以递归解决但不能使用前述技术解决的问题，DP解决方案通常是最佳方法。
- en: 'DP problems are also encountered in a wide variety of situations. Here are
    just a few broad examples:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DP问题也出现在各种情况下。以下只是一些广泛的例子：
- en: Combinatorics (counting the number of combinations/permutations of a sequence
    matching certain criteria)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合数学（计算符合特定条件的序列的组合/排列数）
- en: Strings/arrays (edit distance, longest common subsequence, longest increasing
    subsequence, and so on)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串/数组（编辑距离、最长公共子序列、最长递增子序列等）
- en: Graphs (shortest path problem)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图（最短路径问题）
- en: Machine learning (speech/face recognition)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习（语音/人脸识别）
- en: Let's begin by understanding the basic idea of dynamic programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解动态规划的基本思想开始。
- en: What Is Dynamic Programming?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是动态规划？
- en: 'The best way to answer this question is by example. To illustrate the purpose
    of dynamic programming, let''s consider the Fibonacci sequence:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题的最佳方法是通过例子。为了说明动态规划的目的，让我们考虑斐波那契数列：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By observing the preceding sequence, we can see that, beginning with the third
    element, each term is equal to the sum of the two preceding terms. This can be
    simply expressed with the following formula:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察前述序列，我们可以看到，从第三个元素开始，每个项都等于前两个项的和。这可以用以下公式简单表示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can clearly see, the terms of this sequence have a recursive relationship
    – the current term, *F(n)*, is based on the results of previous terms, *F(n-1)*
    and *F(n-2)*, and thus the preceding equation, that is, *F(n) = F(n-1) + F(n-2)*,
    is described as the **recurrence relation** of the sequence. The initial terms,
    *F(0)* and *F(1)*, are described as the **base cases**, or the points in which
    a solution is produced without the need to recurse further. These operations are
    shown in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以清楚地看到，这个序列的项之间存在递归关系 - 当前项*F(n)*基于前面项*F(n-1)*和*F(n-2)*的结果，因此前述方程*F(n)
    = F(n-1) + F(n-2)*被描述为序列的**递归关系**。初始项*F(0)*和*F(1)*被描述为**基本情况**，或者在不需要进一步递归的情况下产生解决方案的点。这些操作如下图所示：
- en: '![Figure 8.1: Computing the nth term in the Fibonacci sequence](img/C14498_08_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：计算斐波那契数列的第n项](img/C14498_08_01.jpg)'
- en: 'Figure 8.1: Computing the nth term in the Fibonacci sequence'
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：计算斐波那契数列的第n项
- en: 'Describing the preceding figure in English might look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语描述前述图可能是这样的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We describe the preceding approach as a **top-down solution** because it begins
    at the top of the recursion tree (that is, the solution) and traverses down its
    branches until it reaches the base cases. In C++, this could be written using
    the following recursive function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前述方法描述为**自顶向下的解决方案**，因为它从递归树的顶部（即解决方案）开始，并沿着其分支向下遍历，直到达到基本情况。在C++中，这可以使用以下递归函数来编写：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By observing the tree further, we can see that several **subproblems**, or intermediate
    problems that must be solved to find the ultimate solution, must be solved more
    than once. For example, the solution for *F(2)* must be found to get the solution
    for *F(4) [F(3) + F(2)]* and *F(3) [F(2) + F(1)]*. Thus, the Fibonacci sequence
    is said to exhibit a property known as **overlapping subproblems**. This is one
    of the defining characteristics that separate a standard divide-and-conquer problem
    from a dynamic programming problem; in the former, subproblems tend to be unique,
    whereas in the latter, the same subproblems must be solved repeatedly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进一步观察树，我们可以看到几个必须多次解决的**子问题**，或者说必须解决以找到最终解决方案的中间问题。例如，必须找到*F(2)*的解决方案才能得到*F(4)
    [F(3) + F(2)]*和*F(3) [F(2) + F(1)]*的解决方案。因此，斐波那契数列被认为具有**重叠子问题**的特性。这是将标准的分治问题与动态规划问题区分开的定义特征之一；在前者中，子问题往往是唯一的，而在后者中，相同的子问题必须重复解决。
- en: We can also see that several of the solution branches are completely identical
    to each other. For example, finding the solution for *F(2)* is going to require
    the same set of calculations, regardless of whether you need it to solve *F(4)*
    or *F(3)*. This demonstrates the second defining characteristic of dynamic programming
    problems, which is known as the optimal substructure. A problem is said to exhibit
    an **optimal substructure** when the optimal solution to the overall problem can
    be formed through some combination of the optimal solutions of its subproblems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到几个解决方案分支彼此完全相同。例如，找到*F(2)*的解决方案将需要相同的一组计算，无论您需要它来解决*F(4)*还是*F(3)*。这展示了动态规划问题的第二个定义特征，即最优子结构。当问题的最优解可以通过其子问题的最优解的某种组合形成时，问题被认为具有**最优子结构**。
- en: For a problem to be solvable using dynamic programming, it must possess these
    two properties. Because of the overlapping subproblems property, the complexity
    of these problems tends to increase exponentially as the input increases; however,
    exploiting the optimal substructure property makes it possible to reduce the complexity
    significantly. So, in essence, the purpose of DP is to devise a method of caching
    previous solutions as a means to avoid the repeated calculation of previously
    solved subproblems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用动态规划解决问题，问题必须具备这两个特性。由于重叠子问题的特性，这些问题的复杂性随着输入的增加而呈指数级增长；然而，利用最优子结构的特性可以显著减少复杂性。因此，DP的目的实质上是设计一种缓存先前解决方案的方法，以避免重复计算先前解决的子问题。
- en: Memoization – The Top-Down Approach
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备忘录化 - 自顶向下的方法
- en: 'No, this is not "memorization," though that would also describe this technique
    quite accurately. Using memoization, we can reformulate the top-down solution
    we described previously to make use of the optimal substructure property exhibited
    by the Fibonacci sequence. Our program logic will essentially be the same as it
    was before, only now, after having found the solution at every step, we will cache
    the results in an array, indexed according to the current value of *n* (in this
    problem, *n* represents the **state** or set of parameters defining the current
    recursive branch). At the very beginning of each function call, we will check
    to see whether we have a solution available in the cache for state *F(n)*. If
    so, we will simply return the cached value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是“记忆”，尽管这也可以相当准确地描述这种技术。使用备忘录化，我们可以重新制定我们之前描述的自顶向下解决方案，以利用斐波那契数列所展示的最优子结构特性。我们的程序逻辑基本上与以前一样，只是现在，在每一步找到解决方案后，我们将结果缓存到一个数组中，根据当前值*n*进行索引（在这个问题中，*n*代表定义当前递归分支的**状态**或参数集）。在每次函数调用的开始，我们将检查是否在缓存中有状态*F(n)*的解决方案可用。如果有，我们将简单地返回缓存的值：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The recursion tree now looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 递归树现在看起来是这样的：
- en: '![Figure 8.2: Computing the nth term in the Fibonacci sequence using cached
    solutions](img/C14498_08_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：使用缓存解决方案计算斐波那契数列中的第n个项](img/C14498_08_02.jpg)'
- en: 'Figure 8.2: Computing the nth term in the Fibonacci sequence using cached solutions'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.2：使用缓存解决方案计算斐波那契数列中的第n个项
- en: 'By doing this, we have eliminated quite a bit of redundant work. This technique
    of recursively caching solutions in a top-down manner is known as **memoization**,
    and can essentially be employed for any DP problem, assuming the following are
    true:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们消除了相当多的冗余工作。这种以自顶向下递归地缓存解决方案的技术称为**备忘录化**，并且基本上可以用于任何DP问题，只要以下条件为真：
- en: You can devise a caching scheme that exploits the similarity of different states
    while preserving their uniqueness.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以设计一个利用不同状态的相似性并保持其唯一性的缓存方案。
- en: You can accumulate the solutions for the requisite subproblems before exceeding
    the available stack space.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在超出可用堆栈空间之前，您可以累积所需子问题的解决方案。
- en: The first point means that the method of indexing results for later use should
    be both valid and useful. In order for a caching scheme to be valid, it must only
    be considered a match for states whose solutions are derived from the same series
    of subproblems; in order for it to be useful, it must not be so state-specific
    that it cannot be effectively used (for example, if every subproblem is assigned
    a unique index in the cache, the conditional "`if(memo[KEY] != UNKNOWN)`" will
    never be true).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点意味着索引结果以供以后使用的方法应该既有效又有用。为了使缓存方案有效，它必须只被视为与其解决方案源自相同一系列子问题的状态匹配；为了使其有用，它必须不是那么特定于状态，以至于无法有效使用（例如，如果每个子问题在缓存中被分配一个唯一的索引，条件"`if(memo[KEY]
    != UNKNOWN)`"将永远不会成立）。
- en: The second point refers to the possibility of causing a stack overflow error,
    which is a fundamental limitation of any top-down approach if the number of recursive
    calls is likely to be very high. A stack overflow occurs when a program exceeds
    the allotted amount of memory that's available on the call stack. Depending on
    the nature of a given problem, it is possible that the depth of recursion that's
    required may prevent memoization from being a viable option; as always, it is
    quite beneficial to assess the potential complexity of the task at hand before
    choosing an approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点指的是可能引起堆栈溢出错误的可能性，这是任何自顶向下方法的基本限制，如果递归调用的次数可能非常高。堆栈溢出发生在程序超出调用堆栈上可用的内存分配量时。根据给定问题的性质，可能需要的递归深度可能会阻止记忆化成为可行的选择；因此，在选择方法之前评估手头任务的潜在复杂性是非常有益的。
- en: Memoization is frequently a decent optimization method for DP problems. However,
    in many cases, a better option is available, which we will study in the following
    section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化经常是动态规划问题的一个不错的优化方法。然而，在许多情况下，有更好的选择，我们将在下一节中学习。
- en: Tabulation – the Bottom-Up Approach
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制表 - 自底向上的方法
- en: The *heart* of dynamic programming is tabulation, which is the inverse approach
    to memoization. In fact, though the term *dynamic programming* is sometimes applied
    to both memoization and tabulation, its use is generally assumed to refer specifically
    to the latter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划的核心是制表法，这是记忆化的逆向方法。事实上，尽管动态规划这个术语有时被应用于记忆化和制表，但通常认为它特指后者。
- en: The standard implementation of tabulation consists of storing the solutions
    for the base cases and then iteratively filling a table with the solutions for
    every subproblem, which can then be reused to find the solutions for other subproblems.
    Tabulated solutions are generally considered to be a bit harder to conceptualize
    than memoized ones because the state of each subproblem must be represented in
    a way that can be expressed iteratively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 制表的标准实现包括存储基本情况的解决方案，然后迭代地填充一个表格，其中包含每个子问题的解决方案，然后可以重复使用这些解决方案来找到其他子问题的解决方案。制表解决方案通常被认为比记忆化的解决方案更难以理解，因为每个子问题的状态必须以可以迭代表示的方式来表示。
- en: 'A tabulated solution to computing the Fibonacci sequence would look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数列的制表解决方案如下：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the Fibonacci example, the state is quite simple since it's one-dimensional
    and unconditional — the formula always holds that, for any n greater than *1*,
    *F(n) = F(n-1) + F(n-2)*. However, DP problems often contain several dimensions
    that define a given state and may have multiple conditions that affect how states
    transition between each other. In such cases, determining how to represent the
    current state may require a fair amount of creativity, in addition to a comprehensive
    understanding of the problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在斐波那契数列的例子中，状态非常简单，因为它是一维的和无条件的——对于任何大于1的n，公式总是成立，即F(n) = F(n-1) + F(n-2)。然而，动态规划问题通常包含定义给定状态的多个维度，并且可能有多个条件影响状态之间的转换。在这种情况下，确定如何表示当前状态可能需要相当多的创造力，以及对问题的全面理解。
- en: The advantages of tabulation, however, are significant. In addition to the fact
    that tabulated solutions frequently tend to be much more efficient in terms of
    memory, they also produce a complete lookup table encompassing every given state.
    Therefore, if you are likely to receive queries about any state of the problem,
    tabulation is likely to be your best option.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，制表的优势是显著的。除了制表解决方案通常在内存方面更有效之外，它们还产生一个包含每个给定状态的完整查找表。因此，如果你可能会收到关于问题的任何状态的查询，制表很可能是你最好的选择。
- en: Interestingly, any problem that can be solved with memoization can theoretically
    be reformulated into a tabulated solution, and vice versa. Using the former can
    often provide immense insight into how to approach the latter. Over the next few
    sections, we will explore several classical examples of dynamic programming problems
    and demonstrate how employing multiple approaches (beginning with naive brute
    force) can lead you to the level of understanding that's required for the tabulated
    solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，任何可以通过记忆化解决的问题理论上都可以重新制定为制表解决方案，反之亦然。使用前者通常可以为如何处理后者提供巨大的见解。在接下来的几节中，我们将探讨动态规划问题的几个经典示例，并演示如何使用多种方法（从朴素的蛮力开始）可以使你达到制表解决方案所需的理解水平。
- en: Subset Sum Problem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子集和问题
- en: Imagine that you are implementing the logic for a digital cash register. Whenever
    a customer needs change, you would like to display a message that tells the cashier
    whether or not the money currently in the register can be combined in some way
    so that its sum is equal to the amount of change required. For example, if a product
    costs $7.50 and the customer pays $10.00, the message would report whether the
    money in the register can be used to produce exactly $2.50 in change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为一个数字现金注册逻辑。每当顾客需要找零时，你希望显示一条消息，告诉收银员当前注册处的钱是否可以以某种方式组合，使其总和等于所需的找零金额。例如，如果一个产品售价为7.50美元，顾客支付10.00美元，消息将报告注册处的钱是否可以用来产生精确的2.50美元的找零。
- en: 'Let''s say that the register currently contains ten quarters (10 x $0.25),
    four dimes (4 x $0.10), and six nickels (6 x $0.05). We can easily conclude that
    the target sum of $2.50 can be formed in the following ways:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设注册处当前包含十个25美分的硬币（10 x 0.25美元），四个10美分的硬币（4 x 0.10美元）和六个5美分的硬币（6 x 0.05美元）。我们可以很容易地得出结论，2.50美元的目标总额可以以下列方式形成：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these parameters, the problem is rather straightforward and can be solved
    by simply trying all the available combinations of money until a sum matching
    $2.50 is found. But what if the change that's required is $337.81, and the register
    contains 100 banknotes/coins divided into denominations of $20.00, $10.00, $5.00,
    $1.00, $0.25, $0.10, $0.05, and $0.01? We can clearly see that trying every possible
    sum becomes quite impractical as the complexity increases. This is an example
    of a classic problem known as the subset sum problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些参数，问题就变得相当简单，可以通过简单地尝试所有可用的货币组合，直到找到与2.50美元相匹配的总和。但是，如果需要的找零是337.81美元，而收银机包含100张面额分别为20.00美元、10.00美元、5.00美元、1.00美元、0.25美元、0.10美元、0.05美元和0.01美元的纸币/硬币呢？我们可以清楚地看到，随着复杂度的增加，尝试每种可能的总和变得相当不切实际。这是一个被称为子集和问题的经典问题的例子。
- en: 'In its most basic form, the `S`, and an integer, `x`, is there a subset of
    `S`''s elements whose sum is equal to `x`? Take a look at the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，对于集合`S`和整数`x`，是否存在`S`的元素的一个子集，其总和等于`x`？看下面的例子：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the preceding set as an example, we can find the following 16 subsets:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以前面的集合为例，我们可以找到以下16个子集：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By listing the total amount of subsets that can be produced for sets of different
    sizes, we get the following numbers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出不同大小的集合可以产生的子集总数，我们得到以下数字：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From this list, we can deduce that the total number of subsets that can be formed
    from a set of size `n` is equal to *2**n*, which demonstrates that the number
    of subsets to consider increases exponentially with the size of *n*. Assuming
    the number of elements in *S* is small, say 10 elements or less, a brute-force
    approach to this problem could find the solution rather quickly; but if we reconsider
    the example of a cash register containing 100 different banknotes/coins, the size
    of *S* would be equal to 100, which would require exploring 1,267,650,600,228,229,401,496,703,205,376
    subsets!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表中，我们可以推断出从大小为`n`的集合中可以形成的子集的总数等于*2**n*，这表明要考虑的子集数量随着*n*的大小呈指数增长。假设*S*中的元素数量较小，比如10个元素或更少，那么对这个问题的蛮力方法可能会很快找到解决方案；但是如果我们重新考虑一个包含100种不同纸币/硬币的收银机的例子，*S*的大小将等于100，这将需要探索1,267,650,600,228,229,401,496,703,205,376个子集！
- en: 'Solving the Subset Sum Problem – Step 1: Evaluating the Need for DP'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决子集和问题-步骤1：评估是否需要DP
- en: 'Our first step when faced with a problem like this is to determine whether
    it can (and/or should) be solved with DP. To reiterate, a problem is solvable
    with DP if it has the following properties:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这样的问题，我们的第一步是确定它是否可以（和/或应该）用DP解决。重申一下，如果问题具有以下特性，则可以用DP解决：
- en: '**Overlapping subproblems**: Like the standard divide-and-conquer approach,
    the final solution can be derived by combining the solutions of smaller subproblems
    in some way; in contrast to divide and conquer, however, certain subproblems will
    be encountered multiple times.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠子问题**：与标准的分治方法一样，最终解可以通过某种方式结合较小子问题的解来得出；与分治方法相反，某些子问题会被多次遇到。'
- en: '**Optimal substructure**: The optimal solution for a given problem can be produced
    by the optimal solutions of its subproblems.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最优子结构**：给定问题的最优解可以由其子问题的最优解产生。'
- en: 'Let''s analyze the preceding example in terms of whether or not it possesses
    these characteristics:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据是否具有这些特征来分析前面的例子：
- en: '![Figure 8.3: Optimal substructure and overlapping subproblems'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：最优子结构和重叠子问题'
- en: '](img/C14498_08_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_08_03.jpg)'
- en: ''''
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: ''''
- en: 'Figure 8.3: Optimal substructure and overlapping subproblems'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.3：最优子结构和重叠子问题
- en: Reformatting the collection of subsets as shown clearly illustrates how each
    new subset of size n is formed by appending a single new element to a subset of
    size `n - 1`. This is the optimal approach for constructing a new subset and holds
    true for every subset of size greater than 0\. Thus, the subset sum problem has
    an **optimal substructure**. We can also see that several subsets are derived
    from the same "subsubset" (for example, both *{ 13 79 45 }* and *{ 13 79 29 }*
    are based on *{ 13 79 }*). Therefore, the problem also has **overlapping subproblems**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新整理子集的集合，如图所示清楚地说明了每个大小为n的新子集是如何通过向大小为`n-1`的子集追加一个新元素来形成的。这是构建新子集的最佳方法，并且对于大于0的每个子集大小都成立。因此，子集和问题具有**最优子结构**。我们还可以看到，几个子集都是从相同的“子子集”派生出来的（例如，*{13
    79 45}*和*{13 79 29}*都基于*{13 79}*）。因此，该问题还具有**重叠子问题**。
- en: Having satisfied both of our criteria, we can conclude that this problem can
    be solved with dynamic programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 满足了我们的两个标准后，我们可以得出结论，这个问题可以用动态规划解决。
- en: Step 2 – Defining the States and the Base Cases
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步-定义状态和基本情况
- en: Having determined that this is a DP problem, we now must determine what constitutes
    a state within the context of this problem. In other words, in terms of the question
    that we are trying to answer, what makes one possible solution different from
    another?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确定这是一个DP问题后，我们现在必须确定在这个问题的背景下什么构成了一个状态。换句话说，就我们试图回答的问题而言，什么使一个可能的解决方案与另一个不同？
- en: Though it is generally advisable to consider these aspects of the problem early
    in the process, it is often quite difficult to define the states of a DP problem
    without having a clear understanding of how the ultimate result is formed, and
    thus it is often quite helpful to start by implementing a solution in the most
    straightforward way possible. Therefore, we will develop our understanding of
    the subset sum problem's base case(s) and states by solving it in two different
    ways that are much simpler to implement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常建议在过程的早期考虑问题的这些方面，但通常很难在没有清晰理解最终结果是如何形成的情况下定义DP问题的状态，因此最好从最直接的方式开始实施解决方案。因此，我们将通过两种更简单的方式解决子集和问题来发展我们对基本情况和状态的理解。
- en: 'Throughout our exploration of dynamic programming, we will consider a total
    of four different approaches to each problem: **brute force**, **backtracking**,
    **memoization**, and **tabulation**. As with any DP problem, all of these approaches
    are capable of producing the correct result, but the first three quickly demonstrate
    their limitations as the size of the input increases. Nevertheless, implementing
    progressively optimized solutions in this way can be used to great effect when
    tackling any dynamic programming problem.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索动态规划的过程中，我们将考虑每个问题的四种不同方法：**蛮力**，**回溯**，**记忆化**和**表格化**。与任何DP问题一样，所有这些方法都能够产生正确的结果，但前三种方法在输入规模增加时很快显示出它们的局限性。然而，以这种方式逐渐实现优化的解决方案在解决任何动态规划问题时都可以产生很大的效果。
- en: 'Step 2.a: Brute Force'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2.a：蛮力
- en: 'Despite its inefficiency, a brute-force solution can be quite informative in
    developing an understanding of the problem at hand. Implementing brute-force approaches
    can be an essential step in the process of forming a DP solution for several reasons:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其效率低下，蛮力解决方案在开发对手头问题的理解方面可能非常有益。以蛮力方法实现可能是形成DP解决方案过程中的一个重要步骤，原因有几个：
- en: '**Simplicity**: The simplicity of writing a solution without any consideration
    of its efficiency can be an excellent way to develop an understanding of the fundamental
    aspects of the problem; it can also lead to insights about the problem''s nature
    that may otherwise be missed in the act of trying to comprehend its complexity
    without sufficient context.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：在不考虑效率的情况下编写解决方案的简单性可以是开发对问题基本方面的理解的绝佳方式；它还可以带来关于问题性质的见解，否则可能会在尝试理解其复杂性时因缺乏足够的上下文而被忽略。'
- en: '**The certainty of solution correctness**: Oftentimes, a particularly complex
    DP solution will require quite a bit of redesign as the problem is better understood.
    Because of this, it is essential to have a way to compare your solution''s output
    to the correct answer.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案正确性的确定性**：通常，特别复杂的DP解决方案在更好地理解问题时需要进行重新设计。因此，比较解决方案的输出与正确答案是至关重要的。'
- en: '**Ability to visualize the subproblems**: A brute-force solution will generate
    every potential solution and then choose the ones that meet the criteria of the
    problem. This provides an effective means for visualizing how a correct solution
    is formed, which can then be inspected for essential patterns that can be used
    in later approaches.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化子问题的能力**：蛮力解决方案将生成每个潜在解决方案，然后选择符合问题标准的解决方案。这提供了一种有效的方式来可视化正确解决方案的形成方式，然后可以检查其中可以在后续方法中使用的基本模式。'
- en: The following exercise demonstrates the implementation of the brute-force approach.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了蛮力方法的实现。
- en: 'Exercise 36: Solving the Subset Sum Problem by Using the Brute-Force Approach'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习36：使用蛮力方法解决子集和问题
- en: 'In this exercise, we shall find a solution to the subset sum problem using
    the brute-force approach. Let''s get started:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用蛮力方法找到子集和问题的解决方案。让我们开始吧：
- en: 'Let''s begin by including the following headers (and the `std` namespace for
    convenience):'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括以下标头（以及`std`命名空间以方便起见）：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Additionally, let''s define a preprocessor constant called `DEBUG` and a macro
    called `PRINT`, which will print to `stderr` only if `DEBUG` is not zero:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，让我们定义一个名为`DEBUG`的预处理器常量和一个名为`PRINT`的宏，它将仅在`DEBUG`不为零时打印到`stderr`：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will now declare a new function, `SubsetSum_BruteForce()`, that takes two
    arguments — an array of integers, `set`, and an integer, `sum` — and returns a
    Boolean:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将声明一个新函数`SubsetSum_BruteForce（）`，它接受两个参数 - 一个整数数组`set`和一个整数`sum` - 并返回一个布尔值：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s declare another function, `GetAllSubsets()`, which takes four arguments
    — two integer vectors, `set` and `subset`; an integer; `index`; and a three-dimensional
    vector of integers called `allSubsets` (passed by reference). We will use this
    function to generate all subsets of *S* recursively:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们声明另一个函数`GetAllSubsets（）`，它接受四个参数 - 两个整数向量`set`和`subset`；一个整数`index`；和一个名为`allSubsets`的三维整数向量（通过引用传递）。我们将使用此函数递归地生成*S*的所有子集：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Returning to our `SubsetSum_BruteForce()` function, we can now declare `allSubsets`
    and call the function:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`SubsetSum_BruteForce（）`函数，我们现在可以声明`allSubsets`并调用该函数：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can iterate through each subset and compare its sum to `target`, returning
    `true` if a match is found:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以遍历每个子集并将其总和与`target`进行比较，如果找到匹配，则返回`true`：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If a matching sum is not found after checking every subset, we return `false`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在检查每个子集后找不到匹配的和，我们返回`false`：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, in the `main()` function, let''s define our set and target as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main（）`函数中，让我们定义我们的集合和目标如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now call `SubsetSum_BruteForce()` with these inputs like so:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以这样调用`SubsetSum_BruteForce（）`与这些输入：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Upon running the preceding code, you should see the following output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码后，您应该看到以下输出：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s set `target` to a sum that is not found in the set:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`target`设置为一个集合中找不到的和：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the program again should produce the following output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行程序应该产生以下输出：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, let''s redefine our `DEBUG` constant to 1:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将我们的`DEBUG`常量重新定义为1：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the program now will produce the following output:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行程序将产生以下输出：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Thus, we are able to find the required subset using the brute-force approach.
    Note that we are basically trying out every possibility in order to find the solution.
    In the following section, we shall apply one layer of optimization over it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够使用蛮力方法找到所需的子集。请注意，我们基本上是尝试找到解决方案的每种可能性。在下一节中，我们将对其进行一层优化。
- en: 'Step 2.b: Optimizing Our Approach – Backtracking'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2.b：优化我们的方法 - 回溯
- en: Clearly, the brute-force approach leaves a lot to be desired. In terms of performance,
    it is about as inefficient as it possibly could be. By indiscriminately checking
    every possible subset, we consider options long after the point where we could
    determine that they will never lead to a solution (for example, subsets with sums
    exceeding the target). To improve our algorithm, we can utilize **backtracking**
    to exclude all the branches of subproblems that are guaranteed to be invalid.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，蛮力方法还有很多不足之处。在性能方面，它几乎是尽可能低效的。通过不加区分地检查每个可能的子集，我们在可以确定它们永远不会导致解决方案的点之后仍然考虑选项（例如，总和超过目标的子集）。为了改进我们的算法，我们可以利用**回溯法**来排除所有已经被保证无效的子问题的分支。
- en: 'The main advantage of implementing a backtracking solution before attempting
    to use DP is that it requires us to determine the base case(s) and intermediate
    recursive states of the problem. As we defined earlier in this chapter, a base
    case is a condition in a recursive function that does not rely on further recursion
    to produce an answer. For further clarification, consider the problem of calculating
    the factorial of a number (the factorial of a number, *n*, is equivalent to *n
    * (n-1) * (n-2) * (n-3) … * 1*). We could code a C++ function that accomplishes
    this as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用DP之前实现回溯解决方案的主要优势是，它要求我们确定问题的基本情况和中间递归状态。正如我们在本章前面定义的那样，基本情况是递归函数中的一个条件，它不依赖于进一步递归来产生答案。为了进一步澄清，考虑计算一个数字的阶乘的问题（一个数字*n*的阶乘等于*n
    * (n-1) * (n-2) * (n-3) … * 1*）。我们可以编写一个C++函数来实现这个问题，如下所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The structure of this recursive function can be illustrated like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归函数的结构可以用下面的方式来说明：
- en: '![Figure 8.4: Recursively calculating the Nth factorial](img/C14498_08_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：递归计算第N个阶乘](img/C14498_08_04.jpg)'
- en: 'Figure 8.4: Recursively calculating the Nth factorial'
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.4：递归计算第N个阶乘
- en: The `n = 1` condition is the base case because that is the point at which the
    solution can be returned without recursing further.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`n = 1`的条件是基本情况，因为这是可以在不进一步递归的情况下返回解决方案的点。'
- en: 'In the subset sum problem, one way to define our base cases would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在子集和问题中，定义我们的基本情况的一种方式是：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have established base cases, we need to define our intermediate
    states. Using our brute-force algorithm''s output as a reference, we can analyze
    how subsets of each size group are formed to plot out our state transitions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本情况，我们需要定义中间状态。使用我们的蛮力算法的输出作为参考，我们可以分析每个大小组的子集是如何形成的，以绘制出我们的状态转换：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, the size `0` and size `1` states are the simplest to understand.
    We begin with an empty set and we can add any of the elements to it in order to
    create all subsets of size 1.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大小为`0`和大小为`1`的状态是最容易理解的。我们从一个空集开始，我们可以添加任何元素到它，以创建所有大小为1的子集。
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can follow the same line of logic for size 2 subsets. Simply take each subset
    of size 1 and append every element whose index is greater than the highest-indexed
    element already in the subset. This is essentially the approach we took in our
    brute-force implementation; however, this time, we will consider the sum of each
    subset as we process them, and terminating them when the current sum exceeds the
    target:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对大小为2的子集采用相同的逻辑。只需取每个大小为1的子集，并附加索引大于子集中已有的最高索引的每个元素。这本质上是我们在蛮力实现中采取的方法；然而，这一次，我们在处理它们时将考虑每个子集的总和，并在当前总和超过目标时终止它们。
- en: '![Figure 8.5: Eliminating values that exceed the target](img/C14498_08_05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：消除超过目标值的值](img/C14498_08_05.jpg)'
- en: 'Figure 8.5: Eliminating values that exceed the target'
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：消除超过目标值的值
- en: 'When `target` is equal to `58`, we can see that none of the subsets of size
    3 or 4 need to be considered. Thus, we can describe our intermediate state transition
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当`target`等于`58`时，我们可以看到不需要考虑大小为3或4的子集。因此，我们可以描述我们的中间状态转换如下：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we should ask the following questions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该问以下问题：
- en: What is the minimal amount of data needed to represent this state?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示这种状态所需的最少数据是什么？
- en: How can we reformulate the preceding logic to remove unnecessary information?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何重新构思前面的逻辑以去除不必要的信息？
- en: 'Consider the specific problem we are trying to solve: finding whether a subset
    of elements exists within the set whose sum is equal to the target. According
    to the problem description, our task does not require that we produce the actual
    subsets, but only their sums. So, our pseudocode could be more succinctly expressed
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们要解决的具体问题：找出是否存在一个子集的元素，其总和等于目标值。根据问题描述，我们的任务不需要产生实际的子集，而只需要它们的总和。因此，我们的伪代码可以更简洁地表示如下：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using this new approach, we can essentially represent each state transition
    with only two integers, `sum` and `i`, eliminating the need to store *2**n* subset
    arrays in the worst case. Furthermore, we can remove the need to keep track of
    the target value by inverting the problem (that is, starting at `target` and subtracting
    `set[i]` at each step). As a final optimization, we can sort the set before calling
    the function, which allows us to determine that there are no other valid possibilities
    as soon as the sum exceeds the target. We'll implement this in C++ in the following
    exercise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新方法，我们基本上可以用两个整数`sum`和`i`来表示每个状态转换，从而在最坏情况下消除了存储*2**n*子集数组的需要。此外，我们可以通过反转问题（即从`target`开始，并在每一步减去`set[i]`）来消除跟踪目标值的需要。最后，我们可以在调用函数之前对集合进行排序，这样我们就可以在总和超过目标时确定没有其他有效可能性。我们将在接下来的练习中用C++来实现这一点。
- en: 'Exercise 37: Solving the Subset Sum Problem by Using Backtracking'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习37：使用回溯法解决子集和问题
- en: 'In this exercise, we shall solve a problem similar to the one demonstrated
    in *Exercise 36*, *Solving the Subset Sum Problem by Using the Brute-Force Approach*,
    but using a backtracking approach and a more complex input to highlight the differences.
    Let''s get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将解决一个类似于*练习36*中演示的问题，即*使用蛮力方法解决子集和问题*，但是使用回溯方法和更复杂的输入来突出差异。让我们开始吧：
- en: 'To implement the backtracking solution for the subset sum problem, we define
    a function called `SubsetSum_Backtracking()`, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现子集和问题的回溯解决方案，我们定义一个名为`SubsetSum_Backtracking()`的函数，如下所示：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As is often the case in recursive functions, we define our base cases at the
    very beginning:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在递归函数中经常这样，我们在一开始就定义了基本情况：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At each step, our options are to add the current element''s value to the sum,
    or to keep the sum as-is. We can condense this logic into one line like so:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一步，我们的选择是将当前元素的值加到总和中，或者保持总和不变。我们可以将这个逻辑压缩成一行，如下所示：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Returning to `main`, let''s sort the set and add our call to `SubsetSum_Backtracking()`
    underneath the call to `SubsetSum_BruteForce()`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`main`，让我们对集合进行排序，并在调用`SubsetSum_BruteForce()`之后添加我们对`SubsetSum_Backtracking()`的调用：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For the sake of testing, we will implement a function that will display the
    time each approach takes to find the solution. First, we will need to include
    the `<time.h>` and `<iomanip>` headers:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，我们将实现一个函数，它将显示每种方法找到解决方案所花费的时间。首先，我们需要包含`<time.h>`和`<iomanip>`头文件：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will also define an array of strings called `types`, which we will use to
    label the results of each approach:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将定义一个名为`types`的字符串数组，我们将用它来标记每种方法的结果：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will write another function, `GetTime()`, that takes a reference to
    a `clock_t` object called `timer` and a `string type`, and then returns `void`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写另一个函数`GetTime()`，它接受一个名为`timer`的`clock_t`对象的引用和一个`string`类型，然后返回`void`：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s rewrite the `main()` function so that we can perform each function
    call sequentially and compare the time taken by each approach:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重写`main()`函数，以便我们可以依次执行每个函数调用并比较每种方法所花费的时间：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s redefine our input to highlight the difference in efficiency
    between the two approaches:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们重新定义我们的输入，以突出两种方法之间效率的差异：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Your output will produce something along the lines of the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的输出将产生类似以下内容的东西：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for the time taken would vary depending on your system. Please
    note the difference in the values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间取值会根据您的系统而有所不同。请注意数值上的差异。
- en: As you can see, in this particular case, the answer was found over 1,000 times
    faster using the backtracking approach. In the following section, we shall optimize
    this solution further by making use of caching.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这种特殊情况下，使用回溯方法找到答案要快1000多倍。在接下来的部分中，我们将通过利用缓存来进一步优化这个解决方案。
- en: 'Step 3: Memoization'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：记忆化
- en: Though significantly better than brute force, the backtracking solution is still
    far from ideal. Consider a case where the target sum is high and not in the set
    — if the target is greater than or equal to the sum of every element in the set,
    we could easily determine the result by calculating the total in advance and checking
    that the target is within the valid range. However, if the target sum is just
    slightly under this amount, our algorithm will still be forced to explore practically
    every possibility before finishing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比蛮力方法好得多，但回溯解决方案仍然远非理想。考虑一个目标和集合中没有的情况-如果目标大于或等于集合中每个元素的总和，我们可以通过预先计算总和并检查目标是否在有效范围内来轻松确定结果。然而，如果目标总和略低于这个数额，我们的算法仍然需要在完成之前探索几乎每种可能性。
- en: To demonstrate this difference, try running your code from the previous exercise
    using `6799` as the target (exactly 1 less than the total sum of all the elements
    of the set). On the author's machine, the backtracking solution took about 0.268
    seconds on average to produce the result – nearly 350 times longer than the average
    time taken with the target value used in the exercise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种差异，尝试使用`6799`作为目标来运行上一个练习中的代码（恰好比集合中所有元素的总和少1）。在作者的机器上，回溯解决方案平均花费大约0.268秒来产生结果-几乎比练习中使用的目标值所花费的平均时间长了近350倍。
- en: Thankfully, we already have all the information we need to devise a top-down
    solution while utilizing memoization. Even better, we hardly have to modify our
    previous approach at all to implement it!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经拥有了所有需要设计自顶向下解决方案并利用记忆化的信息。更好的是，我们几乎不需要修改我们以前的方法来实现它！
- en: Devising a Caching Scheme
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计缓存方案
- en: 'The most important aspect of using memoization is to define a caching scheme.
    Caching results for memoized solutions can be done in a number of ways, but the
    most common are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记忆化最重要的方面是定义一个缓存方案。对于记忆化解决方案的缓存结果可以通过多种方式来完成，但最常见的方式如下：
- en: Simple arrays, with states represented by numerical indices
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单数组，状态由数字索引表示
- en: Hash tables/maps, with states represented by descriptive strings that are hashed
    using built-in language features
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表/映射，状态由使用内置语言特性散列的描述性字符串表示
- en: Hash tables/maps, with states represented by hash values that are created using
    an original hashing formula
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表/映射，状态由使用原始哈希公式创建的哈希值表示
- en: 'The choice to make here is largely context-dependent, but here are some general
    guidelines:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要做出的选择在很大程度上取决于上下文，但以下是一些一般性指导方针：
- en: Arrays/vectors that are accessed by a numerical index tend to be much faster
    than maps, which must locate a given key in the map in order to determine whether
    or not it has already been cached.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数字索引访问的数组/向量通常比必须在映射中定位给定键以确定是否已经被缓存的映射要快得多。
- en: Even when states can be represented as integers, if the cache keys are quite
    large, the memory requirements of an array large enough to encompass them may
    be unreasonable. In this case, maps are a better option.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使状态可以表示为整数，如果缓存键非常大，足以包含它们的数组的内存需求可能是不合理的。在这种情况下，映射是更好的选择。
- en: Hash tables (for example, `std::unordered_map`) tend to be much faster than
    standard map/dictionary structures for locating and retrieving keys (but are still
    slower than arrays).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表（例如`std::unordered_map`）在定位和检索键时往往比标准的映射/字典结构快得多（但仍然比数组慢）。
- en: '`std::map` is much more versatile than `std::unordered_map` in terms of what
    types of data can be used as keys. Although `std::unordered_map` can technically
    offer the same functionality, it requires the programmer to create their own hashing
    function for data types it is not equipped to store as keys by default.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`在可以用作键的数据类型方面比`std::unordered_map`更加灵活。尽管`std::unordered_map`在技术上可以提供相同的功能，但它要求程序员为默认情况下无法存储为键的数据类型创建自己的哈希函数。'
- en: 'As you may recall from the introduction to this chapter, a caching scheme should
    be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得本章节介绍的那样，缓存方案应该是这样的：
- en: '**Valid**: Cache keys must be represented in a way that avoids collisions between
    different states that are not used to solve the same set of subproblems.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效**：缓存键必须以一种方式表示，以避免不用于解决相同子问题集的不同状态之间发生冲突。'
- en: '**Worthwhile/useful**: If your caching scheme is so specific that it never
    actually produces any "hits", then it essentially accomplishes nothing.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有价值/有用**：如果您的缓存方案如此特定，以至于实际上从未产生任何“命中”，那么它基本上什么也没做。'
- en: 'In the subset sum problem, we may mistakenly come to believe that failing to
    find the target from a state with a given `sum` value means that it would be impossible
    to get a true result from any other state with the same sum. Therefore, we may
    decide to cache every solution based solely on the value of `sum` (that is, `if(memo[sum]
    != UNKNOWN) return memo[sum];`). This is an example of an invalid caching scheme
    because it fails to take into account the fact that there may be multiple ways
    to reach the same sum within the same set, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在子集和问题中，我们可能错误地认为，从具有给定`sum`值的状态中找不到目标意味着从具有相同和的任何其他状态中都不可能得到真正的结果。因此，我们可能决定仅基于`sum`的值缓存每个解决方案（即`if(memo[sum]
    != UNKNOWN) return memo[sum];`）。这是一个无效的缓存方案的例子，因为它未考虑到在同一组内可能有多种达到相同和的方式，如下所示：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Suppose the target value is `8` in the preceding example. If the third case
    is encountered first, `memo[6]` would be set to `false`, which is obviously incorrect
    since the target can be reached from both of the other cases by including the
    4th element (`2`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在前面的例子中目标值为`8`。如果首先遇到第三种情况，`memo[6]`将被设置为`false`，这显然是不正确的，因为目标可以通过包括第4个元素（`2`）从其他两种情况中达到。
- en: An example of a useless memoization scheme would be one where the keys are equal
    to the indices of the subset because every possible state will contain a completely
    unique key; as a result, states that are formed from the same set of subproblems
    will not trigger a cache hit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无用的记忆化方案的例子是，其中键等于子集的索引，因为每个可能的状态都将包含一个完全独特的键；因此，由相同子问题集形成的状态不会触发缓存命中。
- en: If you are unsure about the efficacy of your caching scheme, it can be useful
    to store a counter that increments on every cache hit. If the final value of this
    counter is equal to `0`, or is very low relative to the number of states you have
    to consider, you can conclude that your caching scheme needs revision.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对自己的缓存方案的有效性不确定，可以有用的是存储一个在每次缓存命中时递增的计数器。如果这个计数器的最终值等于`0`，或者相对于您需要考虑的状态数量来说非常低，那么您可以得出结论，您的缓存方案需要修订。
- en: We shall explore the implementation of memoization with the use of a vector
    for caching.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用向量进行缓存的记忆化实现。
- en: 'Exercise 38: Solving the Subset Sum Problem by Using Memoization'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习38：使用记忆化解决子集和问题
- en: 'In this exercise, we shall try to implement the same solution that we implemented
    in *Exercise 37*, *Solving the Subset Sum Problem by Using Backtracking*, but
    with the addition of memoization. Let''s get started:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试实现与*练习37*中实现的相同解决方案，即使用回溯法解决子集和问题，但增加了记忆化。让我们开始吧：
- en: 'We will now create another function called `SubsetSum_Memoization()`. The definition
    for this function will be identical to `SubsetSub_Backtracking()`, except that
    it will include a reference to a two-dimensional integer vector called `memo`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建另一个名为`SubsetSum_Memoization()`的函数。这个函数的定义将与`SubsetSub_Backtracking()`完全相同，只是它将包括对名为`memo`的二维整数向量的引用：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Much of our code for this function will look quite similar to the backtracking
    approach. For example, our base cases will be defined exactly like they were previously:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的大部分代码看起来与回溯法的方法非常相似。例如，我们的基本情况将与以前定义的完全相同：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, the pivotal difference is that after the base cases, rather than immediately
    investigating the next two states, we check the `memo` table for cached results:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关键的区别在于，在基本情况之后，我们不是立即调查下两种状态，而是检查`memo`表以获取缓存的结果：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we should insert a call to `SubsetSum_Memoization()` in the `main()` function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在`main()`函数中插入对`SubsetSum_Memoization()`的调用：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s define `target` as `6799` and run our code. You should see an output
    similar to this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`target`定义为`6799`并运行我们的代码。您应该看到类似于这样的输出：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for time taken would vary depending on your system. Please
    note the difference in the values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间值会根据您的系统而有所不同。请注意值的差异。
- en: We can see from the output that caching has optimized our problem by an exponential
    factor.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从输出中看到，缓存已经将我们的问题优化了指数倍。
- en: 'Step 4: Tabulation'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步：制表
- en: So far, we have implemented three different algorithmic approaches to solving
    the subset sum problem, each of which has a significant improvement over the one
    preceding it. However, let's say that we wanted a list of every possible subset
    sum in a given set. We would have to run our algorithm repeatedly for each sum,
    from 1 to the total sum of the entire set. For situations such as these, tabulation
    is often the only efficient option.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了三种不同的算法方法来解决子集和问题，每种方法都比前一种有了显著的改进。然而，假设我们想要得到给定集合中每个可能子集和的列表。我们将不得不针对每个和从1到整个集合的总和重复运行我们的算法。对于这类情况，表格化通常是唯一有效的选择。
- en: 'Implementing an iterative tabulated solution to a problem like this is often
    rather hard to conceptualize. Whereas recursive formulations of a problem lend
    themselves well to multidimensional states and branching conditions, a tabulated
    solution has to somehow condense the layers of complexity into a simple set of
    iterations using the standard `for`/`while` loops:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实现迭代的表格化解决方案对于这样的问题通常很难概念化。虽然问题的递归公式很适合多维状态和分支条件，但表格化解决方案必须以某种方式将复杂性层次压缩成一组简单的迭代，使用标准的`for`/`while`循环：
- en: '![Figure 8.6: Depiction of how the complexity of the subset sum problem’s recursive
    structure is reduced in the tabulated DP solution](img/C14498_08_06.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：展示了子集和问题递归结构的复杂性在表格化DP解决方案中是如何减少的](img/C14498_08_06.jpg)'
- en: 'Figure 8.6: Depiction of how the complexity of the subset sum problem''s recursive
    structure is reduced in the tabulated DP solution'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：展示了子集和问题的递归结构在表格化DP解决方案中是如何减少的
- en: There are several methods for tackling this reduction, but ultimately it tends
    to come down to whether or not you understand the problem well enough to make
    the correct generalizations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题，但最终归根结底是你是否足够理解问题，能够做出正确的概括。
- en: 'Like memoization, the first goal after defining the base case(s) and states
    of the problem is to develop a scheme for storing the solutions for different
    states. Typically, tabulated approaches use simple arrays/vectors for this purpose.
    We have already looked at an example of a very simple DP table in the calculation
    of the Fibonacci sequence:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与记忆化一样，在定义了问题的基本情况和状态之后，第一个目标是开发一种用于存储不同状态解的方案。通常，表格化方法使用简单的数组/向量来实现这一目的。我们已经看过一个非常简单的DP表的例子，即斐波那契数列的计算：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Earlier in this chapter, we also discussed how to calculate factorials recursively.
    A bottom-up approach to filling the table for that problem would look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们还讨论了如何递归地计算阶乘。填充该问题的表格的自底向上方法将如下所示：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are very simple examples because they only contain a single dimension
    and no conditional logic. Each state has a consistent, predictable formula from
    beginning to end.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常简单的例子，因为它们只包含一个维度和没有条件逻辑。每个状态从头到尾都有一个一致、可预测的公式。
- en: The primary difference between those examples and the subset sum problem is
    that the minimal way to represent each state uniquely in the latter requires two
    dimensions — the index in the set and the current sum.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子与子集和问题之间的主要区别在于，后者中唯一表示每个状态的最小方式需要两个维度——集合中的索引和当前总和。
- en: 'Let''s consider some of the insights we have gained about this problem in greater
    depth:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地考虑一些关于这个问题的见解：
- en: Each possible subset of size `k` can be formed by taking new elements and appending
    them onto every subset of size `k – 1`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个大小为`k`的可能子集都可以通过取新元素并将其附加到每个大小为`k-1`的子集上来形成。
- en: 'If a solution has been found at index `i` with a sum value of `x`, then any
    sequence of state transitions that eventually lead to that same set of conditions
    will produce an identical result:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在索引`i`处找到了和值为`x`的解，那么最终导致相同条件的任何状态转换序列都会产生相同的结果：
- en: '![Figure 8.7: Multiple paths with the same sum value on the same index value](img/C14498_08_07.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：相同索引值上具有相同和值的多条路径](img/C14498_08_07.jpg)'
- en: 'Figure 8.7: Multiple paths with the same sum value on the same index value'
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：相同索引值上具有相同和值的多条路径
- en: Both of these recursive paths have a sum value equal to `8` and an index value
    equal to `3` at the states indicated in red which, due the optimal substructure
    of the subset sum problem, means that the solution for that state only needs to
    be found once — its result will be the same any time those conditions are arrived
    at, regardless of what occurred before.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条递归路径都在红色标记的状态处具有和值等于`8`和索引值等于`3`，由于子集和问题的最优子结构，这意味着该状态的解只需要找到一次——无论之前发生了什么，每次到达这些条件时，其结果都将是相同的。
- en: With these facts in mind, we can essentially invert our top-down approach to
    develop the bottom-up approach.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些事实，我们基本上可以颠倒我们的自顶向下方法，来发展自底向上的方法。
- en: '**Top-down logic:**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**自顶向下的逻辑：**'
- en: Start at the target sum and the first index of the set.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从目标总和和集合的第一个索引开始。
- en: 'Iterate through the set:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历集合：
- en: - If the sum is reduced to zero, the result is `TRUE`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果总和减少到零，则结果为`TRUE`。'
- en: - If the end of the set is reached or the target is exceeded, the result is
    `FALSE`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果到达集合的末尾或超过目标，则结果为`FALSE`。'
- en: - Otherwise, you can either subtract the current value from the sum or ignore
    it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '- 否则，您可以从总和中减去当前值或忽略它。'
- en: If the target can be found from state `S`, where the sum is equal to `x` and
    the index is equal to `i`, then the target can also be found from any earlier
    state that eventually leads to the state `S`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可以从状态`S`找到目标，其中总和等于`x`，索引等于`i`，那么也可以从任何最终导致状态`S`的较早状态找到目标。
- en: '**Bottom-up logic:**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**自底向上的逻辑：**'
- en: Start with sum and index values equal to `0`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从和值和索引值等于`0`开始。
- en: 'Iterate through the set:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历集合：
- en: - If a sum equal to `x` can be found between indices `0` and `i`, then a sum
    equal to `x` can also be found between indices `0` and `i+1`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果在索引`0`和`i`之间找到和为`x`的总和，则在索引`0`和`i+1`之间也可以找到和为`x`的总和。'
- en: - If a sum equal to `x` can be found between indices `0` and `i`, then a sum
    equal to `x + set[i]` can be found between indices `0` and `i+1`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果可以在索引`0`和`i`之间找到总和等于`x`，则可以在索引`0`和`i+1`之间找到总和等于`x + set[i]`。'
- en: 'In terms of how the table is filled, the top-down approach can be described
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就填充表的方式而言，自顶向下的方法可以描述如下：
- en: 'If the sum equals `x` and index equals `i` at state S1, the value of `memo(i,
    x) = true` if either of the following occurs:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总和等于`x`且索引等于`i`在状态S1中，如果发生以下情况之一，则`memo(i, x) = true`：
- en: - The target can be found from state S2 (where the sum equals `x – set[i]` and
    index equals `i + 1`), OR…
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '- 目标可以从状态S2中找到（其中总和等于`x – set[i]`且索引等于`i + 1`），或者…'
- en: - The target can be found from state S3 (where the sum equals `x` and index
    equals `i + 1`)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '- 目标可以从状态S3中找到（其中总和等于`x`且索引等于`i + 1`）'
- en: - Otherwise, `memo(i, x) = false`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '- 否则，`memo(i, x) = false`。'
- en: 'The bottom-up version of this logic would be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑的自底向上版本如下：
- en: 'If the sum equals `x` and index equals `i`, the value of `DP(i, x) = true`
    if either of the following occurs:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总和等于`x`且索引等于`i`，则如果发生以下情况之一，则`DP(i, x) = true`：
- en: - `x` is less than the value of `set[i]` and `DP(i-1, x) = true`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '- `x`小于`set[i]`的值且`DP(i-1, x) = true`'
- en: - `x` is greater than, or equal to, the value of `set[i]` and `DP(i-1, sum)
    = true OR DP(i-1, sum – set[i]) = true`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '- `x`大于或等于`set[i]`的值且`DP(i-1, sum) = true OR DP(i-1, sum – set[i]) = true`'
- en: - Otherwise, `DP(i, x) = false`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '- 否则，`DP(i, x) = false`。'
- en: In other words, if we have already determined that a sum, `x`, can be formed
    between indices `0` and `i` (inclusive), then clearly, a sum equal to both `x`
    and `x + set[i]` can be formed between indices `0` and `i + 1`. We'll take a look
    at the implementation of this in the following exercise.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们已经确定了可以在索引`0`和`i`（包括）之间形成总和`x`，那么很明显，可以在索引`0`和`i + 1`之间形成总和等于`x`和`x
    + set[i]`。我们将在下一个练习中看一下这个实现。
- en: 'Exercise 39: Solving the Subset Sum Problem by Using Tabulation'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习39：使用表格法解决子集和问题
- en: 'In this exercise, we shall modify the solution for *Exercise 38*, *Solving
    the Subset Sum Problem by Using Memoization*, so that we can use tabulation by
    converting the logic from top-down to bottom-up. Let''s get started:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改*练习38*的解决方案，即使用备忘录解决子集和问题，以便我们可以通过将逻辑从自顶向下转换为自底向上来使用表格化。让我们开始吧：
- en: 'We will define a new function called — you guessed it — `SubsetSum_Tabulation()`
    that takes an integer vector called `set` as an argument and returns a two-dimensional
    Boolean vector:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`SubsetSum_Tabulation()`的新函数，该函数以整数向量`set`作为参数并返回一个二维布尔向量：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We declare a two-dimensional Boolean vector called `DP`. The first dimension''s
    size should be equal to the length of `set`, and the second dimension''s size
    should be equal to the highest possible subset sum in the set (that is, the total
    sum of all elements) plus one. Every value of DP should be initialized to `false`,
    except for the base cases (that is, the sum is equal to zero):'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个名为`DP`的二维布尔向量。第一维的大小应该等于`set`的长度，第二维的大小应该等于集合中可能的最高子集和（即所有元素的总和）加一。DP的每个值都应初始化为`false`，除了基本情况（即总和等于零）：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we iterate across two nested `for` loops, corresponding to the first and
    second dimensions of the `DP` table:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们遍历两个嵌套的`for`循环，对应于`DP`表的第一维和第二维：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, to fill the table, use the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码填充表：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we once again modify the `main()` function to include our tabulated solution:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们再次修改`main()`函数以包括我们的表格化解决方案：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see an output something like the one shown here:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到类似于这里显示的输出：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间值将根据您的系统而有所不同。请注意值的差异。
- en: 'As we can see, the time taken by the tabulated solution is longer than both
    the memoization and backtracking solutions. However, using the DP table returned
    by `SubsetSum_Tabulation()`, we can use the following code to find every possible
    subset sum:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所看到的，表格化解决方案所花费的时间比备忘录和回溯解决方案都要长。然而，使用`SubsetSum_Tabulation()`返回的DP表，我们可以使用以下代码找到每个可能的子集和：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of this should begin and end like this:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个输出应该以这样开始和结束：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Thus, we have optimized the solution and also obtained the sum values of all
    the states.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经优化了解决方案，并且还获得了所有状态的总和值。
- en: Throughout this chapter, we've explored a variety of ways of solving the subset
    sum problem, which, in turn, demonstrated the clear superiority of the dynamic
    programming approach; however, despite the comparative advantages that DP solutions
    have over the alternatives, we also demonstrated how the naive and relatively
    inefficient approaches can help us better understand the problem, which greatly
    simplifies the process of devising a solution using DP.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了解决子集和问题的各种方法，这反过来证明了动态规划方法的明显优势；然而，尽管DP解决方案相对于其他方法具有比较优势，我们还演示了如何使用朴素和相对低效的方法来更好地理解问题，这极大地简化了使用DP设计解决方案的过程。
- en: Some of the logic that's required by dynamic programming solutions may initially
    appear to be quite complex and difficult to grasp. It is highly recommended that
    you fully understand each solution approach we discussed in this section before
    proceeding further, since this is a process that can be accelerated by using different
    input parameters and comparing the results. Additionally, drawing diagrams of
    how different solutions are formed from given inputs can be particularly helpful.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划解决方案所需的一些逻辑可能最初看起来相当复杂且难以理解。强烈建议在继续之前充分理解我们在本节讨论的每种解决方案方法，因为这是一个可以通过使用不同的输入参数并比较结果来加速的过程。此外，绘制如何从给定输入形成不同解决方案的图表可能特别有帮助。
- en: 'Activity 18: Travel Itinerary'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动18：旅行行程
- en: You are designing a web application for a travel agency that wants to help clients
    plan their holiday itineraries. A major aspect of this software concerns route
    planning, which allows users to specify multiple locations they would like to
    visit and then view a list of cities they would have to pass through en route
    to their final destination.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在为一家旅行社设计一个网络应用程序，帮助客户规划他们的假期行程。这个软件的一个主要方面是路线规划，允许用户指定他们想要访问的多个位置，然后查看他们在最终目的地前经过的城市列表。
- en: Your agency has contracts with specific transportation companies in every major
    city, and each transportation company has set limits on how far they can travel.
    Whereas a plane or train can traverse multiple cities and even entire countries,
    a bus or taxi service may only be willing to travel one or two cities beyond their
    initial location. When your software produces the list of possible intermediate
    stops, it also displays the maximum number of cities the transportation company
    at that location is willing to travel so that clients can plot their course accordingly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '您的旅行社与每个主要城市的特定交通公司有合同，并且每家交通公司都对他们可以行驶的距离设定了限制。而飞机或火车可以穿越多个城市，甚至整个国家，但公共汽车或出租车服务可能只愿意在初始位置之外行驶一两个城市。当您的软件生成可能的中间停靠点列表时，它还会显示交通公司在该位置愿意行驶的最大城市数量，以便客户可以相应地规划他们的行程。 '
- en: You recently realized that your application needs some method of allowing clients
    to filter the number of options presented to them since many popular tourist locations
    are separated by dense clusters of towns. To do this, you want to determine the
    total number of possible ways to reach the ultimate destination from a given starting
    location so that you can reduce the amount of information that's displayed when
    it becomes excessive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您最近意识到您的应用程序需要一些方法，允许客户过滤呈现给他们的选项数量，因为许多热门旅游地点之间被密集的城镇分隔。为此，您希望确定从给定起始位置到最终目的地的可能方式的总数，以便在信息过多时减少显示的信息量。
- en: 'Your application already has the capability to calculate the list of locations
    on the ideal route between a departure point and destination. From this, you have
    derived the following data:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序已经具备计算出理想路线上的位置列表的能力。基于此，您得出了以下数据：
- en: '`N`: An integer representing the number of cities between the source and the
    destination'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N`：表示起点和目的地之间的城市数量的整数'
- en: '`distance`: An array of integers representing the maximum number of cities
    the transportation company at each location is willing to traverse'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance`：表示每个位置的交通公司愿意穿越的最大城市数量的整数数组'
- en: Your task is to implement an algorithm that will calculate the total number
    of possible ways that the destination can be reached by traveling through a sequence
    of intermediate locations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是实现一个算法，计算通过一系列中间位置旅行到达目的地的可能方式的总数。
- en: '**Input**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**'
- en: The first line contains a single integer, `N`, the number of cities between
    the starting point, and the destination.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含一个整数`N`，表示起点和目的地之间的城市数量。
- en: The second line contains `N` space-separated integers, where each integer, di,
    represents the maximum distance that can be traveled starting from the city at
    index `i`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行包含`N`个空格分隔的整数，其中每个整数di表示从索引`i`的城市出发可以行驶的最大距离。
- en: '**Output**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: Your program should output a single integer and the total number of ways to
    traverse the cities beginning at index `0` and ending at index `N`. Because the
    values get quite large as `N` increases, output each result as `modulo 1000000007`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应输出一个整数和从索引`0`开始到索引`N`结束的穿越城市的总方式数。因为随着`N`的增加，值会变得非常大，所以请将每个结果输出为`模1000000007`。
- en: '**Example**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'Suppose you were given the following input:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您获得了以下输入：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This means there are a total of six cities between the source and target locations.
    From a given city at index `i`, you have the option of traveling to any other
    city within the range of `i + 1` to `i + distance[i]` (inclusive). If we were
    to think of the sequence of cities as a graph, the adjacencies for the preceding
    example would be as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在起点和目标位置之间总共有六个城市。从索引`i`的给定城市，您可以选择在`i + 1`到`i + distance[i]`（包括）的范围内前往任何其他城市。如果我们将城市序列视为图形，那么上面例子的相邻城市将如下所示：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Observe the following figure for further clarification:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表以获得进一步的澄清：
- en: '![Figure 8.8: Example of city adjacencies](img/C14498_08_08.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：城市相邻示例](img/C14498_08_08.jpg)'
- en: 'Figure 8.8: Example of city adjacencies'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：城市相邻示例
- en: 'In the preceding example, the destination can be reached in the following ways
    (with `E` representing the end point):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，可以通过以下方式到达目的地（其中`E`表示终点）：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This gives us an answer of `9`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个答案为`9`。
- en: In general, the traversal always starts at index `0` and ends at index `N`.
    It is guaranteed that the sum of a city's index `i` with `distance[i]` will never
    be greater than `N`, and that every city will have a corresponding distance value
    of at least `1`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，遍历总是从索引`0`开始，结束于索引`N`。可以保证城市索引`i`与`distance[i]`的和永远不会大于`N`，并且每个城市都将具有至少`1`的对应距离值。
- en: '**Test Cases**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例**'
- en: 'The following test cases should help you to understand this problem better:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试案例应该帮助您更好地理解这个问题：
- en: '![Figure 8.9: Activity 18 simple test cases'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：活动18简单测试案例'
- en: '](img/C14498_08_09.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_08_09.jpg)'
- en: 'Figure 8.9: Activity 18 simple test cases'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：活动18简单测试案例
- en: 'Here are some more complex test cases:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些更复杂的测试案例：
- en: '![Figure 8.10: Activity 18 complex test cases'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：活动18复杂测试案例'
- en: '](img/C14498_08_10.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_08_10.jpg)'
- en: 'Figure 8.10: Activity 18 complex test cases'
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：活动18复杂测试案例
- en: '**Extra Credit**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外学分**'
- en: 'Assuming you have found an approach that passes the preceding test cases within
    reasonable time limits, you can truly test the efficiency of your algorithm with
    one final test case, with `N` equal to `10000000`. Because the number of values
    would take too much space to print, you can use the following code to generate
    the array values programmatically:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已找到了一个在合理时间限制内通过了前面的测试用例的方法，您可以使用一个最终的测试用例来真正测试算法的效率，其中`N`等于`10000000`。因为值的数量太多，打印出来会占用太多空间，您可以使用以下代码来以编程方式生成数组值：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Your program should print `318948158` as the result of this test case. An optimal
    algorithm should be able to find the result in under one second.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应该打印出`318948158`作为这个测试用例的结果。一个最佳算法应该能够在一秒内找到结果。
- en: '**Activity Guidelines**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南**'
- en: An optimal approach will run in `O(n)` time and require exactly `n` iterations.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳方法将在`O(n)`时间内运行，并且需要确切的`n`次迭代。
- en: If you are completely unsure as to how to formulate the DP solution, use the
    incremental approach that was described in this chapter, that is, by using brute
    force first and then progressively optimizing the solution.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您完全不确定如何制定DP解决方案，请使用本章中描述的增量方法，即首先使用蛮力，然后逐渐优化解决方案。
- en: For insights into how the problem's states are formed, consider the recurrence
    relation exhibited by the Fibonacci sequence.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解问题的状态是如何形成的，可以考虑斐波那契数列所展示的递推关系。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 556.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第556页找到。
- en: Dynamic Programming on Strings and Sequences
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和序列上的动态规划
- en: So far, our exploration of dynamic programming has primarily focused on combinatorial
    problems and calculating terms of integer sequences with defined formulae. Now,
    we will consider another one of DP's most common uses, that is, working with patterns
    in sequences of data. The most typical scenarios in which a programmer would use
    DP for this purpose generally concern searching, comparing, and constructing strings.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对动态规划的探索主要集中在组合问题和计算具有定义公式的整数序列的项上。现在，我们将考虑DP的另一个最常见用途之一，即处理数据序列中的模式。程序员通常会使用DP来搜索、比较和构建字符串的最典型情况通常涉及到这个目的。
- en: As software developers, we often work collaboratively with several individuals
    who all have the ability to make contributions and modifications to the same project.
    Since the possibility always exists that a programmer may inadvertently introduce
    a bug into the code, or that the team may try a different approach for a given
    feature and then decide to return to their original method, it becomes extremely
    important to have some system of version control. In the event that a feature
    that was working recently mysteriously develops a glitch, it is essential to have
    the ability to see the changes that were made to the code, particularly in terms
    of how they differ from an earlier version. All version control systems therefore
    have a "diff" feature that analyzes the similarity between two versions of the
    same code and then displays this in some way to the user.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发人员，我们经常与几个人合作，他们都有能力对同一个项目进行贡献和修改。由于程序员可能会无意中引入代码错误，或者团队可能尝试不同的方法来实现某个功能，然后决定返回到原始方法，因此拥有某种版本控制系统变得非常重要。如果最近工作正常的功能突然出现故障，那么有能力查看对代码所做的更改是至关重要的，特别是在它们与早期版本的不同之处。因此，所有版本控制系统都有一个“差异”功能，它分析同一代码的两个版本之间的相似性，然后以某种方式向用户显示这一点。
- en: 'For example, say you had added the following code to the repository:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您已将以下代码添加到存储库中：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the following day, you made some changes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，您做了一些更改：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A diff utility would then display something similar to the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，差异实用程序会显示类似于以下内容：
- en: '![Figure 8.11: Diff utility output](img/C14498_08_11.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：差异实用程序输出](img/C14498_08_11.jpg)'
- en: 'Figure 8.11: Diff utility output'
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：差异实用程序输出
- en: To accomplish this, the utility needs to compute the similarity of the two code
    files by taking into account the fact that the sequence of text that is common
    to both versions may not necessarily be contiguous in the string. Additionally,
    parts of the original text may have been removed or appear in additional locations
    in the new version. This demonstrates the need for **approximate** (or "**fuzzy**")
    **string matching**, a technique that frequently makes use of dynamic programming.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，实用程序需要计算两个代码文件的相似性，考虑到两个版本中共同的文本序列可能不一定在字符串中是连续的。此外，原始文本的部分可能已被删除或出现在新版本的其他位置。这展示了**近似**（或**模糊**）**字符串匹配**的需求，这种技术通常使用动态规划。
- en: The Longest Common Subsequence Problem
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最长公共子序列问题
- en: 'The **longest common subsequence problem** (commonly abbreviated as **LCS**)
    is one of the most famous classical examples of dynamic programming. It answers
    the following question: given two sequences of data, what is the longest subsequence
    common to both of them?'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**最长公共子序列问题**（通常缩写为**LCS**）是动态规划最著名的经典例子之一。它回答了以下问题：给定两个数据序列，它们的最长公共子序列是什么？'
- en: 'As an example, consider two strings, `A` and `B`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑两个字符串，`A`和`B`：
- en: '![Figure 8.12: Two given strings for finding the longest common subsequence](img/C14498_08_12.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：用于查找最长公共子序列的两个给定字符串](img/C14498_08_12.jpg)'
- en: 'Figure 8.12: Two given strings for finding the longest common subsequence'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：用于查找最长公共子序列的两个给定字符串
- en: 'The longest common subsequence would be "`LONGEST`":'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最长公共子序列将是"`LONGEST`"：
- en: '![Figure 8.13: Longest common subsequence in the given strings](img/C14498_08_13.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13：给定字符串中的最长公共子序列](img/C14498_08_13.jpg)'
- en: 'Figure 8.13: Longest common subsequence in the given strings'
  id: totrans-332
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.13：给定字符串中的最长公共子序列
- en: Equipped with the insights that we've gained from the series of approaches we
    implemented for the subset sum problem, let's be a bit smarter about how we attack
    this one. We will start by formulating some ideas about the structure of the problem
    in advance, starting with the base cases.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们从子集和问题实现的一系列方法中获得的见解，让我们对如何提前攻击这个问题的结构有一些聪明的想法。我们将从基本情况开始制定一些关于问题结构的想法。
- en: 'Since it tends to be quite difficult to understand the nature of a DP problem
    for large inputs without first having considered the trivial ones, let''s create
    some examples of different scenarios using small input strings and try to find
    the length of the longest common subsequence (LCS):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 由于很难理解大输入的DP问题的性质，而没有先考虑微不足道的问题，让我们使用小输入字符串创建一些不同情景的例子，并尝试找到最长公共子序列（LCS）的长度：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the case where either or both strings are empty, it should be fairly obvious
    that the length of the longest common subsequence will always be equal to zero:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中一个或两个字符串为空的情况下，很明显最长公共子序列的长度总是等于零：
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'These two cases have a simple binary definition – either they have a common
    character, or they do not:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况有一个简单的二进制定义 - 要么它们有一个共同的字符，要么没有：
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Things become a bit more interesting with strings of length 2, but the logic
    is still quite trivial. Given two strings of length 2, they either are identical,
    have one character in common, or have no characters in common:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长度为2的字符串，情况变得更有趣，但逻辑仍然相当简单。给定长度为2的两个字符串，它们要么相同，要么有一个共同的字符，要么没有共同的字符：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, the complexity of the problem is beginning to emerge. This case demonstrates
    that the comparisons progressively become much less straightforward:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题的复杂性开始显现。这种情况表明，比较逐渐变得更加不那么直接：
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'By now, it should be fairly obvious that the LCS problem does indeed contain
    overlapping subproblems. Similar to the previous problem, we can observe that
    there are 2n possible subsets of a given string, with `n` being equal to the string''s
    length, except now we have two sequences to contend with. Even worse is the fact
    that we are not simply considering the subsets of each sequence independently,
    but must also make comparisons between them:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，很明显LCS问题确实包含有重叠子问题。与之前的问题类似，我们可以观察到给定字符串有2n个可能的子集，其中`n`等于字符串的长度，只是现在我们有两个序列要处理。更糟糕的是，我们不仅仅考虑每个序列的子集，还必须在它们之间进行比较：
- en: '![Figure 8.14: All possible character subsequences of two strings, ABCX and
    ACY](img/C14498_08_14.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14：两个字符串ABCX和ACY的所有可能字符子序列](img/C14498_08_14.jpg)'
- en: 'Figure 8.14: All possible character subsequences of two strings, ABCX and ACY'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.14：两个字符串ABCX和ACY的所有可能字符子序列
- en: 'The fact that we are not merely looking for consecutive groups of characters
    has several implications: firstly, the same sequence of characters can occur multiple
    times throughout the string and can be spaced across either string in any possible
    arrangement, assuming the order of the characters is the same. Secondly, there
    can be many common subsequences beginning from any given index.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们不仅仅是在寻找连续的字符组，这有一些含义：首先，相同的字符序列可以在整个字符串中多次出现，并且可以跨越任一字符串以任何可能的排列方式分布，假设字符的顺序是相同的。其次，从任一给定索引开始，可能有许多共同的子序列。
- en: 'Before implementing our brute-force approach, let''s also define what constitutes
    a state for this problem. Let''s assume that we are maintaining two pointers,
    `i` and `j`, which represent character indices in `A` and `B`, respectively, as
    well as a record of the subsequence of common characters we have found:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施我们的蛮力方法之前，让我们也定义一下这个问题的状态。假设我们维护两个指针，`i`和`j`，它们分别表示`A`和`B`中的字符索引，以及我们找到的共同字符的子序列的记录：
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we have reached the end of either string, there is nothing else to compare
    because the indices of subsequences are ordered:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经到达了任一字符串的末尾，那么没有其他可比较的了，因为子序列的索引是有序的：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the characters are equal, there is no advantage in not including it in our
    found subsequence. We increment both pointers because any given character can
    only be considered once per subsequence:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符相等，将其包含在我们找到的子序列中并没有优势。我们增加两个指针，因为任何给定字符在子序列中只能考虑一次：
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we have not found a match, we have the choice to either explore the next
    subset of A''s characters, or the next subset of B''s characters. We do not include
    the case of incrementing both indices simultaneously from this state because it
    would be redundant. That case will be explored by the next function call. Outlining
    the structure of this recurrence would look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到匹配，我们可以选择要么探索A的字符的下一个子集，要么探索B的字符的下一个子集。我们不包括同时从这个状态递增两个索引的情况，因为那样会是多余的。这种情况将在下一个函数调用中探索。这个递归的结构如下所示：
- en: '![Figure 8.15: Subproblem tree for the longest subsequence problem](img/C14498_08_15.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15：最长子序列问题的子问题树](img/C14498_08_15.jpg)'
- en: 'Figure 8.15: Subproblem tree for the longest subsequence problem'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.15：最长子序列问题的子问题树
- en: 'In the preceding figure, the overlapping subproblems have been color coded.
    The optimal substructure of this problem is still not quite clear yet, but we
    can still make some basic generalizations:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，重叠子问题已经被着色。这个问题的最优子结构还不太清楚，但我们仍然可以做一些基本的概括：
- en: We only need to compare subsets of equal length.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需要比较相等长度的子集。
- en: From a given state, the possibilities for the next state can be explored by
    incrementing `i`, `j`, or both.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定的状态开始，可以通过增加`i`、`j`或两者来探索下一个状态的可能性。
- en: Our search always ends when the end of either string is reached.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的搜索总是在到达任一字符串的末尾时结束。
- en: Hopefully, our preliminary brute-force implementation can provide additional
    insights. Let's get right to it in the following exercise.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们的初步蛮力实现可以提供额外的见解。让我们在下一个练习中立即开始。
- en: 'Exercise 40: Finding the Longest Common Subsequence by Using the Brute-Force
    Approach'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习40：使用蛮力方法找到最长公共子序列
- en: 'In this exercise, we shall use the brute-force approach to solve this problem,
    just like we did for the subset sum problem in *Exercise 36*, *Solving the Subset
    Sum Problem by Using the Brute-Force Approach*. Let''s get started:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用蛮力方法来解决这个问题，就像我们在*练习36*中解决子集和问题时所做的那样，使用蛮力方法。让我们开始吧：
- en: 'Begin by including the following headers and defining the `DEBUG` and `PRINT`
    macros that we used in the previous chapter:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先包括以下头文件，并定义我们在上一章中使用的`DEBUG`和`PRINT`宏：
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a function called `LCS_BruteForce()` that takes the following arguments
    – two strings, `A` and `B`, two integers, `i` and `j`, and a vector of integer
    pairs, `subsequence` – and returns an integer. Above this function, we will also
    declare a two-dimensional vector of integer pairs with a global scope, that is,
    `found`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`LCS_BruteForce()`的函数，该函数接受以下参数 - 两个字符串`A`和`B`，两个整数`i`和`j`，以及一个整数对的向量`subsequence`
    - 并返回一个整数。在这个函数之上，我们还将声明一个具有全局范围的二维整数对向量，即`found`：
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`A` and `B` are, of course, the strings we are comparing, `i` and `j` represent
    our current positions in `A` and `B`, respectively, and `subsequence` is the collection
    of index pairs that form each common subsequence, which will be collected in `found`
    for output.'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A`和`B`当然是我们要比较的字符串，`i`和`j`分别表示我们在`A`和`B`中的当前位置，`subsequence`是形成每个公共子序列的索引对的集合，它将在`found`中收集以进行输出。'
- en: 'Since we already have pseudocode to work with, we can implement our function
    with relative ease by simply inserting each line of pseudocode into our function
    as comments and translating it into C++ code underneath:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了伪代码可以使用，我们可以通过简单地将伪代码的每一行插入到我们的函数中作为注释，并在其下面将其翻译成C++代码来相对容易地实现我们的函数：
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `main()`, we''ll receive input in the form of two strings, and then call
    our function on it:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们将以两个字符串的形式接收输入，然后调用我们的函数：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Like we did in the previous chapter, we will also output the subsequences found
    to `stderr` if `DEBUG` is not set to `0`. However, because of the greater complexity
    of this problem, we will put this output in a separate function, `PrintSubsequences()`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在上一章中所做的那样，如果`DEBUG`没有设置为`0`，我们还将输出找到的子序列到`stderr`。然而，由于这个问题的复杂性更大，我们将把这个输出放在一个单独的函数`PrintSubsequences()`中：
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can then call this function in `main()`, specifying that it should be ignored
    unless `DEBUG` is set:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在`main()`中调用这个函数，指定只有在`DEBUG`设置为`1`时才应该被忽略：
- en: '[PRE75]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Setting `DEBUG` to `1` and using `ABCX` and `ACYXB` as input should produce
    the following output:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DEBUG`设置为`1`，并使用`ABCX`和`ACYXB`作为输入应该产生以下输出：
- en: '[PRE76]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This output shows us all the possible combinations of subsequence pairs. Let's
    analyze this output in the following section and work toward optimizing our solution.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了所有可能的子序列对的组合。让我们在下一节中分析这个输出，并努力优化我们的解决方案。
- en: First Steps Toward Optimization – Finding the Optimal Substructure
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化的第一步 - 寻找最优子结构
- en: 'Let''s revisit the logic of our previous approach again to see how it may be
    optimized. Using the input strings from the previous exercise, `ABCX` and `ACYXB`,
    if our current state has `i = 0` and `j = 0`, we can clearly see that the only
    possibility for our next state is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾我们先前的方法的逻辑，看看如何进行优化。使用上一个练习中的输入字符串`ABCX`和`ACYXB`，如果我们当前的状态是`i = 0`和`j
    = 0`，我们可以清楚地看到我们下一个状态的唯一可能性如下：
- en: '[PRE77]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As you may recall, one of our initial insights is that the LCS is equal to
    `0` if either or both strings are empty. We can also generalize that the LCS of
    a given prefix of `A` and a given prefix of `B` is equal to the maximum LCS of
    A''s prefix reduced by one character with `B`, and `B`''s prefix reduced by one
    character with `A`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的那样，我们最初的一个见解是，如果一个或两个字符串为空，LCS等于`0`。我们还可以推广，`A`的给定前缀和`B`的给定前缀的LCS等于A的前缀减少一个字符与`B`的最大LCS，以及`B`的前缀减少一个字符与`A`的最大LCS：
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Using this concept of the LCS for two strings being based on the LCS of their
    prefixes, we can redefine our logic as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 利用两个字符串的LCS基于它们的前缀的LCS的概念，我们可以重新定义我们的逻辑如下：
- en: '[PRE79]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Using memoization, we can store our results at every step in a two-dimensional
    table, with the first dimension equal to the size of `A` and the second dimension
    equal to the size of `B`. Assuming we have not reached the base case, we can check
    whether we have a cached result stored in `memo[i - 1][j - 1]`. If we do, we return
    the result; if not, we recursively explore possibilities in the same way as before
    and store the results accordingly. We'll implement this in the following activity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记忆化，我们可以在一个二维表中的每一步存储我们的结果，第一维等于`A`的大小，第二维等于`B`的大小。假设我们还没有达到基本情况，我们可以检查我们是否在`memo[i
    - 1][j - 1]`中存储了一个缓存的结果。如果有，我们返回结果；如果没有，我们以与之前相同的方式递归地探索可能性，并相应地存储结果。我们将在下一个活动中实现这一点。
- en: 'Activity 19: Finding the Longest Common Subsequence by Using Memoization'
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动19：使用记忆化找到最长公共子序列
- en: In solving the subset sum problem, we implemented various approaches, namely
    brute force, backtracking, memoization, and tabulation. In this activity, your
    task is to independently implement a solution to the longest common subsequence
    problem using memoization.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决子集和问题时，我们实现了各种方法，包括蛮力、回溯、记忆化和表格法。在这个活动中，您的任务是独立使用记忆化来实现最长公共子序列问题的解决方案。
- en: '**Input**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**'
- en: Two strings, *A* and *B*, respectively.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串*A*和*B*。
- en: '**Output**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: The length of the longest common subsequence of *A* and *B*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*和*B*的最长公共子序列的长度。'
- en: '**Test Cases**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例**'
- en: 'The following test cases should help you to understand this problem better:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试案例应该帮助您更好地理解这个问题：
- en: '![Figure 8.16: Activity 19 test cases'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：活动19测试案例'
- en: '](img/C14498_08_16.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_08_16.jpg)'
- en: 'Figure 8.16: Activity 19 test cases'
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.16：活动19测试案例
- en: '**Activity Guidelines:**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南：**'
- en: You can represent the state in two dimensions, with the first dimension bound
    by the length of *A*, and the second bound by the length of *B*.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以用两个维度表示状态，第一个维度受*A*的长度限制，第二个维度受*B*的长度限制。
- en: Very little must be changed to convert the brute-force algorithm into a memoized
    one.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎没有什么需要改变来将蛮力算法转换为记忆化算法。
- en: Make sure your approach has a way to differentiate between subproblems that
    have already been cached versus those that have not.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的方法有办法区分已经被缓存和尚未被缓存的子问题。
- en: Note
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 563.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第563页找到。
- en: From Top-Down to Bottom-Up – Converting the Memoized Approach into a Tabulated
    Approach
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从自顶向下到自底向上——将记忆化方法转换为表格法
- en: 'If we were to print out the values of the memo table for the pair of strings
    `ABCABDBEFBA` and `ABCBEFBEAB`, it would look like this (note that values of `-1`
    are unknown):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出对字符串`ABCABDBEFBA`和`ABCBEFBEAB`的记忆表的值，它会是这样的（请注意，值为`-1`的是未知的）：
- en: '![Figure 8.17: Memo table for ABCABDBEFBA and ABCBEFBE](img/C14498_08_17.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图8.17：ABCABDBEFBA和ABCBEFBE的记忆表](img/C14498_08_17.jpg)'
- en: 'Figure 8.17: Memo table for ABCABDBEFBA and ABCBEFBE'
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.17：ABCABDBEFBA和ABCBEFBE的记忆表
- en: 'Looking up any of the row/column combinations where the characters are equal
    (say the 7th row and 7th column), we notice a pattern: the value at `memo[i][j]`
    is equal to `memo[i - 1][j - 1] + 1`.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 查找任何字符相等的行/列组合（比如第7行和第7列），我们注意到一个模式：`memo[i][j]`的值等于`memo[i - 1][j - 1] + 1`。
- en: Now, let's look at the other case (that is, the characters are not equal); the
    pattern we see is that `memo[i][j]` is equal to the maximum of `memo[i - 1][j]`
    and `memo[i][j - 1]`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种情况（即字符不相等）；我们看到的模式是`memo[i][j]`等于`memo[i - 1][j]`和`memo[i][j - 1]`的最大值。
- en: Assuming that we have found the optimal substructure of a problem, it is often
    quite a simple task to form a solution using tabulation by merely taking the table
    produced by a memoized solution and devising a scheme to build it from the bottom
    up. We will need to formulate some of our logic a bit differently, but the general
    ideas will essentially be the same. The first difference to contend with is the
    fact that the memo table's values are initialized to `UNKNOWN` (`-1`). Remember
    that a tabulated solution will fill the *entire* table with the appropriate results,
    and so nothing should be *unknown* by the time the algorithm has finished.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经找到了问题的最优子结构，使用记忆化解决方案形成解决方案通常是一个非常简单的任务，只需简单地采用由记忆化解决方案产生的表，并设计一种方案从底部构建它。我们需要以稍微不同的方式制定一些逻辑，但总体思路基本相同。需要处理的第一个不同之处是记忆表的值被初始化为`UNKNOWN`（`-1`）。记住，表格解决方案将用适当的结果填充*整个*表，因此在算法完成时不应该有任何*未知*的值。
- en: 'Let''s take the unknown value in the second row and third column; what should
    this be equal to? Assuming the prefixes we are considering at that point are `AB_________`
    and `ABC_______`, it should be fairly clear that the LCS at this point is equal
    to `2`. Now, let''s consider the unknown value in the 10th row and the 9th column:
    the prefixes we are considering at this point are `ABCABDBEFB_` and `ABCBEFBEA_`,
    and the LCS that''s found at this point is `ABC_B__EFB_` —> `ABCBEFB___`, which
    is seven characters long. We can logically deduce that the LCS value at a given
    state is either equal to the previously found LCS, or one greater than the previously
    found LCS if the characters are equal. The lowest possible LCS value, of course,
    should be equal to 0\. So, our logic for filling a DP table iteratively would
    look something like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看第二行和第三列的未知值；这个值应该等于多少？假设我们在那一点考虑的前缀是`AB_________`和`ABC_______`，很明显，在这一点上LCS的值等于`2`。现在，让我们考虑第10行和第9列的未知值：我们在这一点考虑的前缀是`ABCABDBEFB_`和`ABCBEFBEA_`，在这一点找到的LCS是`ABC_B__EFB_`
    —> `ABCBEFB___`，长度为七个字符。我们可以逻辑推断，在给定状态下LCS的值要么等于先前找到的LCS，要么比先前找到的LCS多一个，如果字符相等的话。当然，最低可能的LCS值应该等于0。因此，我们迭代地填充DP表的逻辑看起来应该是这样的：
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Our logic is essentially identical to what it was for the memoized solution,
    except that rather than recursively finding the values of unexplored states to
    fill the current state's value in the table, we fill the values for those states
    first and then simply reuse them as needed. We'll put this logic into code in
    the following activity.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的逻辑本质上与记忆化解决方案相同，只是我们不是递归地找到未探索状态的值来填充表中当前状态的值，而是首先填充这些状态的值，然后根据需要简单地重用它们。我们将在以下活动中将这种逻辑转化为代码。
- en: 'Activity 20: Finding the Longest Common Subsequence Using Tabulation'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动20：使用表格法找到最长公共子序列
- en: In this activity, your task is to implement a bottom-up solution to the longest
    common subsequence problem using tabulation.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您的任务是使用表格法实现最长公共子序列问题的自底向上解决方案。
- en: '**Input**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**'
- en: Two strings, *A* and *B*, respectively.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串，*A*和*B*。
- en: '**Output**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: The length of the longest common subsequence of *A* and *B*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*和*B*的最长公共子序列的长度。'
- en: '**Extra Credit**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外学分**'
- en: In addition to the length of the LCS, also output the actual characters it contains.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了LCS的长度之外，还输出它包含的实际字符。
- en: '**Test Cases**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**'
- en: 'The following test cases should help you to understand this problem better:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试用例应该有助于您更好地理解这个问题：
- en: '![Figure 8.18: Activity 20 test cases'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：活动20测试用例'
- en: '](img/C14498_08_18.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_08_18.jpg)'
- en: 'Figure 8.18: Activity 20 test cases'
  id: totrans-427
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.18：活动20测试用例
- en: '**Activity Guidelines**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南**'
- en: Like the subset sum problem, the tabulated solution requires iterating over
    two nested `for` loops.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与子集和问题一样，表格解决方案需要迭代两个嵌套的`for`循环。
- en: For a given state, `LCS(I, j)`, there are three possibilities that need to be
    handled – either the string's prefix is empty, the last characters of *A*'s and
    *B*'s prefixes are equal, or the last characters of *A*'s and *B*'s prefixes are
    not equal.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定状态`LCS(I, j)`，有三种可能需要处理——要么字符串的前缀为空，要么*A*和*B*的前缀的最后一个字符相等，要么*A*和*B*的前缀的最后一个字符不相等。
- en: Finding the characters of the LCS can be done by backtracking through the DP
    table.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过回溯DP表格可以找到LCS的字符。
- en: Note
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 568.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在568页找到。
- en: 'Activity 21: Melodic Permutations'
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动21：旋律排列
- en: Note
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: This activity is based around the traditional Western 8-note equal temperament
    scale, although students do not need to know anything about music theory to perform
    this activity. All the necessary information about the musical aspect is provided
    here.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动是基于传统的西方8音符均匀音阶，尽管学生不需要了解任何音乐理论来进行这个活动。所有关于音乐方面的必要信息都在这里提供了。
- en: 'Musical set theory is a form of categorization for musical harmonies and melodies
    according to the intervallic relations of their notes. In musical terminology,
    an interval can be defined as the distance between two notes in terms of their
    relative positions when written in musical notation:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐集合理论是一种根据音符的间隔关系对音乐和旋律进行分类的形式。在音乐术语中，间隔可以被定义为音符在音乐符号中的相对位置之间的距离：
- en: '![Figure 8.19: Musical notations](img/C14498_08_19.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19：音乐符号](img/C14498_08_19.jpg)'
- en: 'Figure 8.19: Musical notations'
  id: totrans-439
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.19：音乐符号
- en: 'The following figure demonstrates the distance between different musical notes
    when represented as musical notations:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了用音乐符号表示不同音符之间的距离：
- en: '![Figure 8.20: Musical intervals](img/C14498_08_20.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20：音乐间隔](img/C14498_08_20.jpg)'
- en: 'Figure 8.20: Musical intervals'
  id: totrans-442
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.20：音乐间隔
- en: 'You are a music theorist who is curious about how many times a permutation
    of a particular note set appears within the melodies of various composers. Given
    the notes of a complete melody and a set of notes, count the number of times any
    [permutation](http://www.apple.com) of the note set appears within the melody.
    For any valid permutation, notes can be repeated any amount of times and can occur
    in any order:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一个对各种作曲家的旋律中特定音符集的排列出现了多少次感到好奇的音乐理论家。给定完整旋律的音符和一组音符，计算音符集的任何[排列](http://www.apple.com)在旋律中出现的次数。对于任何有效的排列，音符可以重复任意次数，并且可以以任何顺序出现：
- en: '[PRE81]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following notes are described as *enharmonically equivalent* and should
    be considered identical:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的注释被描述为*同音异名*，应被视为相同的：
- en: '[PRE82]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following diagram illustrates this equivalence on a piano:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了钢琴上的这种等价关系：
- en: '![Figure 8.21: Enharmonically equivalent notes represented on a section of
    a piano](img/C14498_08_21.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21：钢琴上表示的同音异名音符](img/C14498_08_21.jpg)'
- en: 'Figure 8.21: Enharmonically equivalent notes represented on a section of a
    piano'
  id: totrans-449
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.21：钢琴上表示的同音异名音符
- en: 'Thus, the following combinations of notes would be considered equivalent:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下音符组合将被视为等价的：
- en: '[PRE83]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following are a few sample inputs and corresponding outputs:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例输入和相应的输出：
- en: 'Input:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '[PRE84]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Output: `21`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：`21`
- en: 'Input:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '[PRE85]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output: `27`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：`27`
- en: 'Input:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '[PRE86]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Output: `315`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：`315`
- en: 'Input:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '[PRE87]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Output: `945`'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：`945`
- en: 'Input:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '[PRE88]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Output: `1323`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：`1323`
- en: 'The guidelines for this activity are as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的指导方针如下：
- en: You do not actually have to know anything about music theory to solve this problem
    beyond what is explained in the description.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，你解决这个问题并不需要了解音乐理论之外的东西，除了描述中解释的内容。
- en: Is there a better way to represent the notes? Could they be converted into a
    format that would be more amenable to a tabulated DP solution?
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有没有更好的方法来表示这些音符？它们能否被转换成更适合表格DP解决方案的格式？
- en: What is the total count of subsets for *n* elements? Could this bit of information
    be useful in solving this problem?
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*元素的子集的总数是多少？这个信息对解决这个问题有用吗？'
- en: Note
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 574.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在574页找到。
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have analyzed and implemented two archetypal examples of
    dynamic programming and learned several methods by which different DP problems
    may be approached. We have also learned how to identify the characteristics of
    problems that can be solved with DP, how DP algorithms should be considered conceptually,
    and how the concepts of states, base cases, and recurrence relations can be used
    to break a complex problem down into much simpler components.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析并实施了动态规划的两个典型例子，并学习了几种不同DP问题可能被解决的方法。我们还学习了如何识别可以用DP解决的问题的特征，DP算法应该如何在概念上考虑，以及状态、基本情况和递归关系的概念如何被用来将一个复杂的问题分解成更简单的组成部分。
- en: We have just barely scratched the surface of the dynamic programming technique.
    Indeed, the two problems we explored in depth are actually quite similar, both
    conceptually and in terms of how their solutions are implemented. However, many
    of these similarities serve to demonstrate several commonalities that are encountered
    in nearly every DP problem, and, as such, they serve as an excellent introduction
    to a topic that is admittedly quite complex and difficult to master.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '我们只是刚刚触及了动态规划技术的表面。事实上，我们深入探讨的两个问题在概念上和解决方案的实现方式上实际上是非常相似的。然而，这些相似之处中的许多都用来展示几乎每个DP问题中遇到的一些共同点，因此，它们作为对一个明显相当复杂和难以掌握的主题的绝佳介绍。 '
- en: Using dynamic programming is a skill that you are unlikely to improve at merely
    through the act of reading or observing. The only way to truly get better with
    this technique is through solving as many problems with it as possible, preferably
    without guidance. At first, certain difficult DP problems may necessitate many
    attempts before the optimal solution is found, but the experience that you garner
    through this often arduous process is arguably much greater than what you are
    likely to gain through simply studying the solutions of any number of DP problems.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态规划是一种技能，你不太可能仅通过阅读或观察来提高。真正提高这种技术的唯一方法是尽可能多地解决问题，最好是不受指导地解决。起初，某些困难的DP问题可能需要多次尝试才能找到最佳解决方案，但通过这种常常艰难的过程获得的经验，可能比你仅仅通过研究任意数量的DP问题的解决方案所获得的要大得多。
- en: The progressive approach to solving DP problems that was demonstrated in this
    chapter can serve you well in the future, but it is by no means the only way to
    arrive at the ultimate solution. After having solved a number of DP problems,
    you will undoubtedly begin to notice certain patterns that will make it possible
    to devise tabulated solutions from the start. However, these patterns are not
    likely to be discovered until you have encountered a range of different DP problems.
    Keep in mind the fact that with DP, just like any challenging skill, continuous
    practice will make it easier, and, before long, what originally appeared extremely
    daunting will eventually seem thoroughly manageable, and even quite fun!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示的解决DP问题的渐进方法在未来会对你有所帮助，但这绝不是到达最终解决方案的唯一方法。在解决了许多DP问题之后，你无疑会开始注意到某些模式，这将使得从一开始就能设计出表格化的解决方案成为可能。然而，这些模式可能直到你遇到各种不同的DP问题之后才会被发现。请记住，使用DP，就像任何具有挑战性的技能一样，持续的练习会让它变得更容易，而且不久之后，最初看起来极其艰巨的事情最终会变得非常容易处理，甚至相当有趣！
- en: In the final chapter, we will learn how to apply dynamic programming to more
    advanced situations and develop a deeper understanding of how DP problems that
    appear quite different from one another at first glance are often just variations
    on the same set of concepts. Finally, we will conclude this book by revisiting
    the topic of graphs to demonstrate how the DP paradigm can be effectively applied
    to the shortest path problem.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将学习如何将动态规划应用于更高级的情况，并深入了解一开始看起来完全不同的DP问题通常只是相同概念的变体。最后，我们将通过重新讨论图的主题来结束这本书，以展示DP范式如何有效地应用于最短路径问题。
