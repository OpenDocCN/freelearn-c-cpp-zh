- en: Chapter 3. Interactive 3D Data Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 交互式3D数据可视化
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a virtual camera for 3D rendering
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用于3D渲染的虚拟相机
- en: Creating a 3D plot with perspective rendering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用透视渲染创建3D图表
- en: Creating an interactive environment with GLFW
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GLFW创建交互式环境
- en: Rendering a volumetric dataset – MCML simulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染体数据集 – MCML模拟
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: OpenGL is a very attractive platform for creating dynamic, highly interactive
    tools for visualizing data in 3D. In this chapter, we will build upon the fundamental
    concepts discussed in the previous chapter and extend our demos to incorporate
    more sophisticated OpenGL features for 3D rendering. To enable 3D visualization,
    we will first introduce the basic steps of setting up a virtual camera in OpenGL.
    In addition, to create more interactive demos, we will introduce the use of GLFW
    callback functions for handling user inputs. Using these concepts, we will illustrate
    how to create an interactive 3D plot with perspective rendering using OpenGL.
    Finally, we will demonstrate how to render a 3D volumetric dataset generated from
    a Monte Carlo simulation of light transport in biological tissue. By the end of
    this chapter, readers will be able to visualize data in 3D with perspective rendering
    and interact with the environment dynamically through user inputs for a wide range
    of applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL是一个非常吸引人的平台，用于创建动态、高度交互的工具，以在3D中可视化数据。在本章中，我们将基于前一章讨论的基本概念，并扩展我们的演示，以包含更多复杂的OpenGL
    3D渲染功能。为了实现3D可视化，我们首先将介绍在OpenGL中设置虚拟相机的基本步骤。此外，为了创建更多交互式演示，我们将介绍使用GLFW回调函数来处理用户输入。使用这些概念，我们将说明如何使用OpenGL创建具有透视渲染的交互式3D图表。最后，我们将演示如何渲染由生物组织中光传输的蒙特卡洛模拟生成的3D体数据集。到本章结束时，读者将能够使用透视渲染可视化数据，并通过用户输入动态地与环境交互，适用于广泛的用途。
- en: Setting up a virtual camera for 3D rendering
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用于3D渲染的虚拟相机
- en: Rendering a 3D scene is similar to taking a photograph with a digital camera
    in the real world. The steps that are taken to create a photograph can also be
    applied in OpenGL.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，渲染3D场景类似于使用数码相机拍照。创建照片所采取的步骤也可以应用于OpenGL。
- en: For example, you can move the camera from one position to another and adjust
    the viewpoint freely in space, which is known as **viewing transformation**. You
    can also adjust the position and orientation of the the object of interest in
    the scene. However, unlike in the real world, in the virtual world you can position
    the object at any orientation freely without any physical constraints, termed
    as **modeling transformation**. Finally, we can exchange camera lenses to adjust
    the zoom and create different perspectives the process is called **projection
    transformation**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将相机从一个位置移动到另一个位置，并在空间中自由调整视点，这被称为**视图变换**。你还可以调整场景中感兴趣对象的位姿。然而，与现实世界不同，在虚拟世界中，你可以自由地以任何方向定位对象，没有任何物理约束，这被称为**建模变换**。最后，我们可以更换相机镜头来调整缩放并创建不同的视角，这个过程被称为**投影变换**。
- en: When you take a photo applying the viewing and modeling transformation, the
    digital camera takes the information and creates an image on your screen. This
    process is called **rasterization**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用视图和建模变换拍照时，数码相机获取信息并在你的屏幕上创建图像。这个过程称为**光栅化**。
- en: These sets of matrices—encompassing the viewing transformation, modeling transformation,
    and projection transformation—are the fundamental elements we can adjust at run-time,
    which allows us to create an interactive and dynamic rendering of the scene. To
    get started, we will first look into the setup of the camera matrix, and how we
    can create a scene with different perspectives.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵集——包括视图变换、建模变换和投影变换——是我们可以在运行时调整的基本元素，这使我们能够创建场景的交互式和动态渲染。要开始，我们将首先探讨相机矩阵的设置，以及我们如何创建具有不同视角的场景。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code in this chapter is based on the final demo from the previous
    chapter. Basically, we will be modifying the previous implementation by setting
    up a camera model using a perspective matrix. In the upcoming chapters, we will
    explore the use of the **OpenGL Shading Language** (**GLSL**) to enable even more
    complex rendering techniques and higher performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的源代码基于上一章的最终演示。基本上，我们将通过使用透视矩阵设置摄像机模型来修改之前的实现。在接下来的章节中，我们将探讨使用 **OpenGL 着色语言**（**GLSL**）来启用更复杂的渲染技术和更高的性能。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s get started on the first new requirement for handling perspective transformation
    in OpenGL. Since the camera parameters depend on the window size, we need to first
    implement a callback function that handles a window resize event and updates the
    matrices accordingly:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始处理 OpenGL 中透视变换的第一个新要求。由于摄像机参数依赖于窗口大小，我们首先需要实现一个处理窗口大小事件的回调函数，并相应地更新矩阵：
- en: 'Define the function prototype for the callback function:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义回调函数的函数原型：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Preset the camera parameters: the vertical **field of view angle** (**fovY**),
    the distance to the **Near clipping plane** (front), the distance to **Far clipping
    plane** (back), and the screen aspect ratio (**width**/**height**):![How to do
    it...](img/9727OS_03_01.jpg)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预设摄像机参数：垂直 **视野角度**（**fovY**），到 **近裁剪面**（前）的距离，到 **远裁剪面**（后）的距离，以及屏幕纵横比（**宽度**/**高度**）![如何做到这一点...](img/9727OS_03_01.jpg)
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set up the viewport of the virtual camera (using the window size):'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置虚拟摄像机的视口（使用窗口大小）：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Specify the matrix mode as `GL_PROJECTION` and allow subsequent matrix operations
    to be applied to the projection matrix stack:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩阵模式指定为 `GL_PROJECTION` 并允许后续的矩阵操作应用于投影矩阵栈：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Load the identity matrix to the current matrix (that is, reset the matrix to
    its default state):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单位矩阵加载到当前矩阵中（即重置矩阵到其默认状态）：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Set up the perspective projection matrix for the virtual camera:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为虚拟摄像机设置透视投影矩阵：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The purpose of the `framebuffer_size_callback` function is to handle callback
    events from the GLFW library. Upon resizing the window, an event will be captured
    and the callback function provides a mechanism to update the virtual camera parameters
    accordingly. One important problem is that changing the aspect ratio of the screen
    can introduce distortion if we do not adjust our virtual camera rendering parameters
    appropriately. Therefore, the `update` function also calls the `glViewport` function
    to ensure that the graphic is rendered onto the new viewable area.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`framebuffer_size_callback` 函数的目的是处理来自 GLFW 库的回调事件。当窗口大小改变时，将捕获一个事件，回调函数提供了一个机制来相应地更新虚拟摄像机的参数。一个重要的问题是，如果我们不适当调整虚拟摄像机渲染参数，改变屏幕的纵横比可能会引入扭曲。因此，`update`
    函数也会调用 `glViewport` 函数，以确保图形被渲染到新的可视区域。'
- en: Furthermore, imagine we are taking a photo of a scene with a camera physically
    in the real world. The `gluPerspective` function basically controls the camera
    lens' zoom (that is, the field of view angle) as well as the camera sensor (that
    is, the image plane) aspect ratio. One major difference between the virtual and
    real camera is the concept of a near clipping and far clipping plane (front and
    back variables) that limits the viewable area of the rendered image. These constraints
    are related to more advanced topics (the depth buffer and depth testing) and how
    the graphical engine works with a virtual 3D scene. One rule of thumb is, we should
    never set an unnecessarily large value as it will affect the precision of the
    depth testing result, which can lead to z-fighting issue. **Z-fighting** is a
    phenomenon that occurs when objects share very similar depth values and the precision
    of the depth value is not sufficient to resolve the ambiguity (due to precision
    loss in the floating-point representation during the 3D rendering process). Setting
    a higher resolution depth buffer, or reducing the distance between the clipping
    planes, is often the simplest way to mitigate such problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，想象一下我们正在用真实世界中的物理摄像头拍摄一个场景。`gluPerspective`函数基本上控制着摄像头镜头的缩放（即视场角）以及摄像头传感器（即图像平面）的宽高比。虚拟摄像头和真实摄像头之间一个主要的不同之处在于近裁剪面和远裁剪面（前后变量）的概念，它限制了渲染图像的可视区域。这些限制与更高级的主题（深度缓冲区和深度测试）以及图形引擎如何与虚拟3D场景协同工作有关。一个经验法则是，我们永远不应该设置一个不必要的过大值，因为它会影响深度测试结果的精度，这可能导致Z冲突问题。**Z冲突**是一种现象，当物体具有非常相似的深度值且深度值的精度不足以解决这种歧义（由于3D渲染过程中的浮点表示精度损失）时发生。设置更高分辨率的深度缓冲区或减少裁剪面之间的距离通常是减轻此类问题的最简单方法。
- en: The sample code provides perspective rendering of a scene that resembles how
    the human eye sees the world. For example, an object will appear larger if it
    is closer to the camera and smaller if it is farther away. This allows for a more
    realistic view of a scene. On the other hand, by controlling the field of view
    angle, we can exaggerate perspective distortion, similar to capturing a scene
    with an ultra-wide angle lens.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码提供了场景的透视渲染，类似于人眼观察世界的方式。例如，如果一个物体离摄像头更近，它看起来会更大；如果它离摄像头更远，它看起来会更小。这允许我们更真实地观察场景。另一方面，通过控制视场角，我们可以夸大透视扭曲，类似于使用超广角镜头捕捉场景。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Alternatively, we can set up the camera with the `glFrustum()` function by
    replacing the `gluPerspective()` function with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，我们可以通过用以下代码替换`gluPerspective()`函数来使用`glFrustum()`函数设置摄像头： '
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `glFrustum` function takes the corners of the near clipping and far clipping
    planes to construct the projective matrix. Fundamentally, there is no difference
    between the `gluPerspective` and `glFrustum` functions, so they are interchangeable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`glFrustum` 函数接受近裁剪面和远裁剪面的角点来构建投影矩阵。从根本上讲，`gluPerspective` 和 `glFrustum` 函数之间没有区别，因此它们可以互换使用。'
- en: As we can see, the virtual camera in OpenGL can be updated upon changes to the
    screen frame buffer (window size) and these event updates are captured with the
    callback mechanism of the GLFW library. Of course, we can also handle other events
    such as keyboard and mouse inputs. Further details on how to handle additional
    events will be discussed later. In the next section, let's implement the rest
    of the demo to create our first 3D plot with perspective rendering.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，OpenGL中的虚拟摄像头可以在屏幕帧缓冲区（窗口大小）变化时更新，这些事件更新通过GLFW库的回调机制捕获。当然，我们也可以处理其他事件，例如键盘和鼠标输入。关于如何处理其他事件的更多细节将在稍后讨论。在下一节中，让我们实现演示的其余部分，以创建我们的第一个具有透视渲染的3D图形。
- en: Creating a 3D plot with perspective rendering
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用透视渲染创建3D图形
- en: In the previous chapter, we showed a heat map of a 2D Gaussian distribution
    with varying standard deviation over time. Now, we will continue with more advanced
    rendering of the same dataset in 3D and demonstrate the effectiveness of visualizing
    multi-dimensional data with OpenGL. The code base from the previous chapter will
    be modified to enable 3D rendering.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了随时间变化的二维高斯分布的标准差热图。现在，我们将继续使用相同的数据集在3D中进行更高级的渲染，并展示使用OpenGL可视化多维数据的有效性。上一章的代码库将被修改以启用3D渲染。
- en: 'Instead of rendering the 2D Gaussian distribution function on a plane, we take
    the output of the Gaussian function ![Creating a 3D plot with perspective rendering](img/9727OS_03_13.jpg)
    as the z (height) value as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在平面上渲染二维高斯分布函数，而是将高斯函数 ![创建具有透视渲染的3D图](img/9727OS_03_13.jpg) 的输出作为 z（高度）值，如下所示：
- en: '![Creating a 3D plot with perspective rendering](img/9727OS_03_20.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![创建具有透视渲染的3D图](img/9727OS_03_20.jpg)'
- en: Here **A** is the amplitude of the distribution centered at ![Creating a 3D
    plot with perspective rendering](img/9727OS_03_21.jpg), and ![Creating a 3D plot
    with perspective rendering](img/9727OS_03_12.jpg) are the standard deviations
    (spread) of the distribution in the *x* and *y* directions. In our example, we
    will vary the spread of the distribution over time to change its shape in 3D.
    Additionally, we will apply a heat map to each vertex based on the height for
    better visualization effect.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 **A** 是以 ![创建具有透视渲染的3D图](img/9727OS_03_21.jpg) 和 ![创建具有透视渲染的3D图](img/9727OS_03_12.jpg)
    为中心的分布的振幅，而 ![创建具有透视渲染的3D图](img/9727OS_03_12.jpg) 是分布沿 *x* 和 *y* 方向的标准差（分散度）。在我们的例子中，我们将随时间改变分布的分散度以改变其在3D中的形状。此外，我们还将根据高度应用热图到每个顶点，以获得更好的可视化效果。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: With the camera set up using the projection model, we can render our graph in
    3D with the desired effects by changing some of the virtual camera parameters
    such as the field of view angle for perspective distortion as well as the rotation
    angles for different viewing angles. To reduce coding complexity, we will re-use
    the `draw2DHeatMap` and `gaussianDemo` functions implemented in [Chapter 2](ch02.html
    "Chapter 2. OpenGL Primitives and 2D Data Visualization"), *OpenGL Primitives
    and 2D Data Visualization* with minor modifications. The rendering techniques
    will be based on the OpenGL primitives described in the previous chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用投影模型设置好相机后，我们可以通过改变一些虚拟相机参数（如视场角以实现透视扭曲以及不同视角的旋转角度）来以期望的效果渲染我们的图。为了减少编码复杂性，我们将重新使用在
    [第2章](ch02.html "第2章。OpenGL原语和2D数据可视化")，*OpenGL原语和2D数据可视化* 中实现的 `draw2DHeatMap`
    和 `gaussianDemo` 函数，并进行一些小的修改。渲染技术将基于前一章中描述的OpenGL原语。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s modify the final demo in [Chapter 2](ch02.html "Chapter 2. OpenGL Primitives
    and 2D Data Visualization"), *OpenGL Primitives and 2D Data Visualization* (`main_gaussian_demo.cpp`
    in the code package) to enable perspective rendering in 3D. The overall code structure
    is provided here to orient readers first and major changes will be discussed in
    smaller blocks sequentially:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 [第2章](ch02.html "第2章。OpenGL原语和2D数据可视化")，*OpenGL原语和2D数据可视化* 中的最终演示（代码包中的
    `main_gaussian_demo.cpp`），以启用3D中的透视渲染。首先提供整体代码结构以引导读者，主要更改将按顺序在较小的块中讨论：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the preceding framework in mind, inside the `main` function let''s add
    the new `callback` function for handling window resizing implemented in the previous
    section:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记前面的框架，在 `main` 函数中，让我们添加之前章节中实现的窗口调整大小的 `callback` 函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s define several global variables and initialize them for perspective
    rendering, including the zoom level (`zoom`) and rotation angles around the *x*
    (`beta`) and *z* (`alpha`) axes, respectively:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义几个全局变量并初始化它们以进行透视渲染，包括缩放级别（`zoom`）以及围绕 *x* （`beta`）和 *z* （`alpha`）轴的旋转角度，分别：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition, outside the `main` loop, let''s initialize some parameters for
    rendering the Gaussian distribution, including the standard deviation (sigma),
    sign, and step size for dynamically changing the function over time:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `main` 循环之外，让我们初始化一些用于渲染高斯分布的参数，包括标准差（sigma）、符号和随时间动态改变函数的步长：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `while` loop, we perform the following transformations to render the
    Gaussian function in 3D:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，我们执行以下变换以在3D中渲染高斯函数：
- en: 'Specify the matrix mode as `GL_MODELVIEW` to allow subsequent matrix operations
    to be applied to the `MODELVIEW` matrix stack:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩阵模式指定为 `GL_MODELVIEW` 以允许后续的矩阵操作应用于 `MODELVIEW` 矩阵栈：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Perform the translation and rotation of the object:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行对象的平移和旋转：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Draw the origin (with the *x*, *y*, and *z* axes) and the Gaussian function
    in 3D. Dynamically plot a series of Gaussian functions with varying sigma values
    over time and reverse the sign once a certain threshold is reached:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在3D中绘制原点（带有 *x*、*y* 和 *z* 轴）和高斯函数。动态地绘制一系列具有不同sigma值的高斯函数，并在达到某个阈值时反转符号：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For handling each of the preceding drawing tasks, we implement the origin visualizer,
    Guassian function generator, and 3D point visualizer in separate functions.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了处理上述每个绘图任务，我们在单独的函数中实现了原点可视化器、高斯函数生成器和3D点可视化器。
- en: 'To visualize the origin, implement the following drawing function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化原点，实现以下绘图函数：
- en: 'Define the function prototype:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数原型：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Draw the *x*, *y*, and *z* axes in red, green, and blue, respectively:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别用红色、绿色和蓝色绘制*x*、*y*和*z*轴：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the implementation of the Gaussian function demo, we have broken down the
    problem into two parts: a Gaussian data generator and a heat map visualizer function
    with point drawing. Together with 3D rendering and the heat map, we can now clearly
    see the shape of the Gaussian distribution and how the samples animate and move
    in space over time:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高斯函数演示的实现，我们将问题分解为两部分：一个高斯数据生成器和带有点绘制的热图可视化函数。结合3D渲染和热图，我们现在可以清楚地看到高斯分布的形状以及样本如何在空间中随时间动画和移动：
- en: 'Generate the Gaussian distribution:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成高斯分布：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, implement the `draw2DHeatMap` function to visualize the result. Note
    that, unlike in [Chapter 2](ch02.html "Chapter 2. OpenGL Primitives and 2D Data
    Visualization"), *OpenGL Primitives and 2D Data Visualization*, we use the z value
    inside the `glVertex3f` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`draw2DHeatMap`函数以可视化结果。注意，与[第2章](ch02.html "第2章。OpenGL原语和2D数据可视化")不同，*OpenGL原语和2D数据可视化*，我们在`glVertex3f`函数内部使用z值：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The rendered result is shown in the following screenshot. We can see that the
    transparency (alpha blending) allows us to see through the data points and provides
    a visually appealing result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染结果如下所示。我们可以看到透明度（alpha混合）使我们能够看到数据点，并提供了视觉上吸引人的结果：
- en: '![How to do it...](img/9727OS_03_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_02.jpg)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This simple example demonstrates the use of perspective rendering as well as
    OpenGL transformation functions to rotate and translate the rendered objects in
    virtual space. As you can see, the overall code structure remains the same as
    in [Chapter 2](ch02.html "Chapter 2. OpenGL Primitives and 2D Data Visualization"),
    *OpenGL Primitives and 2D Data Visualization* and the major changes primarily
    include setting up the camera parameters for perspective rendering (inside the
    `framebuffer_size_callback` function) and performing the required transformations
    to render the Gaussian function in 3D (after setting the matrix mode to `GL_MODELVIEW`).
    Two very commonly used transformation functions to manipulate virtual objects
    include `glRotatef` and `glTranslatef`, which allow us to position objects at
    any orientation and position. These functions can significantly improve the dynamics
    of your own application, with very minimal cost in development and computation
    time since they are heavily optimized.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例演示了透视渲染的使用以及OpenGL变换函数来在虚拟空间中旋转和移动渲染对象。正如你所见，整体代码结构与[第2章](ch02.html "第2章。OpenGL原语和2D数据可视化")相同，*OpenGL原语和2D数据可视化*，主要变化包括设置透视渲染的相机参数（在`framebuffer_size_callback`函数内部）以及执行所需的变换以在3D中渲染高斯函数（在将矩阵模式设置为`GL_MODELVIEW`之后）。两个非常常用的变换函数来操纵虚拟对象包括`glRotatef`和`glTranslatef`，这些函数允许我们将对象定位在任何方向和位置。这些函数可以显著提高你自己的应用程序的动态性，因为它们在开发和计算时间上的成本非常低，因为它们经过了高度优化。
- en: 'The `glRotatef` function takes four parameters: the rotation angle and three
    components of the direction vector *(x, y, z)*, which define the axis of rotation.
    The function also replaces the current matrix with the product of the rotation
    matrix and the current matrix:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`glRotatef`函数接受四个参数：旋转角度和方向向量的三个分量 *(x, y, z)*，这些分量定义了旋转轴。该函数还将当前矩阵替换为旋转矩阵和当前矩阵的乘积：'
- en: '![How it works...](img/9727OS_03_14.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9727OS_03_14.jpg)'
- en: Here ![How it works...](img/9727OS_03_15.jpg) and ![How it works...](img/9727OS_03_16.jpg).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 ![它是如何工作的...](img/9727OS_03_15.jpg) 和 ![它是如何工作的...](img/9727OS_03_16.jpg)。
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: One may ask, what if we would like to position two objects at different orientations
    and positions? What if we would like to position many parts in space relative
    to one another? The answer to these is to use the `glPushMatrix` and `glPopMatrix`
    functions to control the stack of transformation matrices. The concept behind
    this can get relatively complex for a model with a large number of parts and keeping
    a history of the state machine with many components can be tedious. To address
    this issue, we will look into newer versions of GLSL support (OpenGL 3.x and higher).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有人会问，如果我们想将两个对象放置在不同的方向和位置怎么办？如果我们想将许多部分在空间中相对于彼此定位怎么办？对这些问题的答案是使用 `glPushMatrix`
    和 `glPopMatrix` 函数来控制变换矩阵的堆栈。对于具有大量部件的模型，这个概念可能会相对复杂，并且保持具有许多组件的状态机的历史可能会很繁琐。为了解决这个问题，我们将探讨
    GLSL 支持的新版本（OpenGL 3.x 及更高版本）。
- en: Creating an interactive environment with GLFW
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GLFW 创建交互式环境
- en: In the previous two sections, we focused on the creation of 3D objects and on
    utilizing basic OpenGL rendering techniques with a virtual camera. Now, we are
    ready to incorporate user inputs, such as mouse and keyboard inputs, to enable
    more dynamic interactions using camera control features such as zoom and rotate.
    These features will be the fundamental building blocks for the upcoming applications
    and the code will be reused in later chapters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，我们专注于创建 3D 对象以及利用虚拟相机的基本 OpenGL 渲染技术。现在，我们准备将用户输入，如鼠标和键盘输入，结合到使用相机控制功能（如缩放和旋转）的更动态的交互中。这些功能将是即将到来的应用程序的基本构建块，代码将在后面的章节中重用。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The GLFW library provides a mechanism to handle user inputs from different environments.
    The event handlers are implemented as callback functions in C/C++, and, in the
    previous tutorials, we bypassed these options for the sake of simplicity. To get
    started, we first need to enable these callback functions and implement basic
    features to control the rendering parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GLFW 库提供了一个机制来处理来自不同环境的用户输入。事件处理程序以 C/C++ 中的回调函数的形式实现，在前面的教程中，我们为了简化而跳过了这些选项。要开始，我们首先需要启用这些回调函数并实现基本功能来控制渲染参数。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To handle keyboard inputs, we attach our own implementation of the `callback`
    functions back to the event handler of GLFW. We will perform the following operations
    in the `callback` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理键盘输入，我们将自己的 `callback` 函数实现附加到 GLFW 的事件处理程序上。在 `callback` 函数中，我们将执行以下操作：
- en: 'Define the following global variables (including a new variable called `locked`
    to track whether the mouse button is pressed down, as well as the angles of rotation
    and zoom level) that will be updated by the `callback` functions:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义以下全局变量（包括一个名为 `locked` 的新变量，用于跟踪鼠标按钮是否按下，以及旋转角度和缩放级别），这些变量将由 `callback` 函数更新：
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the keyboard `callback` function prototype:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义键盘 `callback` 函数原型：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we receive any event other than the key press event, ignore it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果收到除按键事件之外的任何事件，则忽略它：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `switch` statement to handle each key press case:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `switch` 语句来处理每个按键事件的案例：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the *Esc* key is pressed, exit the program:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按下 *Esc* 键，则退出程序：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the space bar is pressed, start or stop the animation by toggling the variable:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按下空格键，通过切换变量来开始或停止动画：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the direction keys (up, down, left, and right) are pressed, update the variables
    that control the angles of rotation for the rendered object:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按下方向键（上、下、左和右），则更新控制渲染对象旋转角度的变量：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, if the *Page Up* or *Page Down* keys are pressed, zoom in and out from
    the object by updating the `zoom` variable:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果按下 *Page Up* 或 *Page Down* 键，则通过更新 `zoom` 变量来从对象中缩放或缩小：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To handle mouse click events, we implement another `callback` function similar
    to the one for the keyboard. The mouse click event is rather simple as there is
    only a limited set of buttons available:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理鼠标点击事件，我们实现另一个类似于键盘的 `callback` 函数。鼠标点击事件相当简单，因为可用的按钮有限：
- en: 'Define the mouse press `callback` function prototype:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义鼠标按键的 `callback` 函数原型：
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Ignore all inputs except for the left click event for simplicity:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，忽略除左键点击事件之外的所有输入：
- en: '[PRE27]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Toggle the `lock` variable to store the mouse hold event. The `lock` variable
    will be used to determine whether the mouse movement is used for rotating the
    object:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换 `lock` 变量以存储鼠标按下事件。`lock` 变量将用于确定鼠标移动是否用于旋转对象：
- en: '[PRE28]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For handling mouse movement events, we need to create another `callback` function.
    The `callback` function for mouse movement takes the *x* and *y* coordinates from
    the window instead of unique key inputs:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理鼠标移动事件，我们需要创建另一个`callback`函数。鼠标移动的`callback`函数从窗口中获取*x*和*y*坐标，而不是唯一的键输入：
- en: 'Define the `callback` function prototype that takes in the mouse coordinates:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个接受鼠标坐标的`callback`函数原型：
- en: '[PRE29]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Upon mouse press and mouse movement, we update the rotation angles of the object
    with the *x* and *y* coordinates of the mouse:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在鼠标按下和移动时，我们使用鼠标的*x*和*y*坐标更新对象的旋转角度：
- en: '[PRE30]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we will implement the mouse scroll callback function, which allows
    users to scroll up and down to zoom in and zoom out of the object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现鼠标滚动回调函数，允许用户通过滚动来放大和缩小对象。
- en: 'Define the `callback` function prototype that captures the `x` and `y` scroll
    variables:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个捕获`x`和`y`滚动变量的`callback`函数原型：
- en: '[PRE31]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Take the y parameter (up and down scroll) and update the zoom variable:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取y参数（上下滚动）并更新缩放变量：
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With all of the `callback` functions implemented, we are now ready to link these
    functions to the GLFW library event handlers. The GLFW library provides a platform-independent
    API for handling each of these events, so the same code will run in Windows, Linux,
    and Mac OS X seamlessly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有`callback`函数实现之后，我们现在可以准备将这些函数链接到GLFW库的事件处理器。GLFW库提供了一个平台无关的API来处理这些事件，因此相同的代码可以在Windows、Linux和Mac
    OS X上无缝运行。
- en: 'To integrate the callbacks with the GLFW library, call the following functions
    in the `main` function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将回调函数与GLFW库集成，请在`main`函数中调用以下函数：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The end result is an interactive interface that allows the user to control
    the rendering object freely in space. First, when the user scrolls the mouse (see
    the following screenshots), we translate the object forward or backward. This
    creates the visual perception that the object is zoomed in or zoomed out of the
    camera:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是用户可以自由控制空间中渲染对象的交互式界面。首先，当用户滚动鼠标（见以下截图）时，我们向前或向后移动对象。这产生了视觉上的感知，即对象被相机放大或缩小：
- en: '![How to do it...](img/9727OS_03_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_03.jpg)'
- en: 'Here is another screenshot at a different zoom level:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个不同缩放级别的截图：
- en: '![How to do it...](img/9727OS_03_04.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_04.jpg)'
- en: These simple yet powerful techniques allow users to manipulate virtual objects
    in real-time and can be extremely useful when visualizing complex datasets. Additionally,
    we can rotate the object at different angles by holding the mouse button and dragging
    the object in various directions. The screenshots below show how we can render
    the graph at any arbitrary angle to better understand the data distribution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单而强大的技术允许用户实时操纵虚拟对象，并且在可视化复杂数据集时可能非常有用。此外，我们可以通过按住鼠标按钮并在不同方向上拖动对象来以不同的角度旋转对象。下面的截图显示了我们可以如何以任意角度渲染图表以更好地理解数据分布。
- en: 'Here is a screenshot showing the side view of the Gaussian function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一张显示高斯函数侧视图的截图：
- en: '![How to do it...](img/9727OS_03_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_05.jpg)'
- en: 'Here is a screenshot showing the Gaussian function from the top:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一张从顶部显示高斯函数的截图：
- en: '![How to do it...](img/9727OS_03_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_06.jpg)'
- en: 'Finally, here is a screenshot showing the Gaussian function from the bottom:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一张显示高斯函数底部的截图：
- en: '![How to do it...](img/9727OS_03_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_07.jpg)'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This sample code illustrates the basic interface needed to build interactive
    applications that are highly portable across multiple platforms using OpenGL and
    the GLFW library. The use of `callback` functions in the GLFW library allows non-blocking
    calls that run in parallel with the rendering engine. This concept is particularly
    useful since input devices such as the mouse, keyboard, and joysticks all have
    different input rates and latency. These `callback` functions allow for asynchronous
    execution without blocking the main rendering loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码展示了构建跨多个平台高度可移植的交互式应用程序所需的基本界面，这些应用程序使用OpenGL和GLFW库。在GLFW库中使用`callback`函数允许非阻塞调用，这些调用与渲染引擎并行运行。这个概念特别有用，因为鼠标、键盘和游戏手柄等输入设备都有不同的输入速率和延迟。这些`callback`函数允许异步执行而不阻塞主渲染循环。
- en: The `glfwSetKeyCallback`, `glfwSetFramebufferSizeCallback`, `glfwSetScrollCallback`,
    `glfwSetMouseBcuttonCallback`, and `glfwSetCursorPosCallback` functions provide
    controls over the mouse buttons and scrolling wheel, keyboard inputs, and window
    resizing events. These are only some of the many handlers we can implement with
    the GLFW library support. For example, we can further extend the error handling
    capabilities by adding additional `callback` functions. Also, we can handle window
    closing and opening events, thereby enabling even more sophisticated interfaces
    with multiple windows. With the examples provided thus far, we have introduced
    the basics of how to create interactive interfaces with relatively simple API
    calls.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`glfwSetKeyCallback`、`glfwSetFramebufferSizeCallback`、`glfwSetScrollCallback`、`glfwSetMouseBcuttonCallback`和`glfwSetCursorPosCallback`函数提供了对鼠标按钮和滚动轮、键盘输入以及窗口调整大小事件的控制。这些只是我们可以使用GLFW库支持实现的许多处理程序中的一部分。例如，我们可以通过添加额外的`callback`函数来进一步扩展错误处理能力。此外，我们可以处理窗口关闭和打开事件，从而实现与多个窗口的更复杂接口。到目前为止提供的示例中，我们介绍了如何通过相对简单的API调用创建交互式界面的基础知识。'
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For complete coverage of GLFW library function calls, this website provides
    a comprehensive set of examples and documentation for all callback functions as
    well as the handling of inputs and other events: [http://www.glfw.org/docs/latest/](http://www.glfw.org/docs/latest/).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面覆盖GLFW库函数调用，本网站提供了一套全面的示例和文档，包括所有回调函数以及输入和其他事件的处理：[http://www.glfw.org/docs/latest/](http://www.glfw.org/docs/latest/)。
- en: Rendering a volumetric dataset – MCML simulation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染体积数据集 – MCML模拟
- en: In this section, we will demonstrate the rendering of a 3D volumetric dataset
    generated from a Monte Carlo simulation of light transport in biological tissue,
    called **Monte Carlo for multi-layered media** (**MCML**). For simplicity, the
    simulation output file is included with the code bundle for this chapter so that
    readers can directly run the demo without setting up the simulation code. The
    source code for the Monte Carlo simulation is described in detail in a series
    of publications listed in the *See also* section and the GPU implementation is
    available online for interested readers ([https://code.google.com/p/gpumcml/](https://code.google.com/p/gpumcml/)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示从生物组织中光传输的蒙特卡洛模拟生成的3D体积数据集的渲染，称为**多层介质蒙特卡洛**（**MCML**）。为了简化，本章代码包中包含了模拟输出文件，以便读者可以直接运行演示，而无需设置模拟代码。蒙特卡洛模拟的源代码在“参见”部分列出的系列出版物中有详细描述，并且对于感兴趣的读者，GPU实现可在网上获得（[https://code.google.com/p/gpumcml/](https://code.google.com/p/gpumcml/))）。
- en: 'Light transport in biological tissue can be modeled with the **radiative transport
    equation** (**RTE**), which has proven difficult to solve analytically for complex
    geometry. The time-dependent RTE can be expressed as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生物组织中的光传输可以用**辐射传输方程**（**RTE**）来模拟，该方程对于复杂几何形状来说，解析求解已被证明是困难的。时间相关的RTE可以表示为：
- en: '![Rendering a volumetric dataset – MCML simulation](img/9727OS_03_17.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![渲染体积数据集 – MCML模拟](img/9727OS_03_17.jpg)'
- en: Here ![Rendering a volumetric dataset – MCML simulation](img/9727OS_03_18.jpg)
    is the radiance [*W m^(−2)sr^(−1)*] defined as the radiant power [*W*] crossing
    an infinitesimal area at location *r* perpendicular to the direction *Ω* per unit
    solid angle, *μ[s]* is the scattering coefficient, *μ[a]* is the absorption coefficient,
    *ν* is the speed of light, and ![Rendering a volumetric dataset – MCML simulation](img/9727OS_03_19.jpg)
    is the source term. To solve the RTE numerically, Wilson and Adam introduced the
    **Monte Carlo** (**MC**) method, which is widely accepted as a gold-standard approach
    for photon migration modeling due to its accuracy and versatility (especially
    for complex tissue geometry).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 ![渲染体积数据集 – MCML模拟](img/9727OS_03_18.jpg) 是辐射亮度 [*W m^(−2)sr^(−1)*]，定义为穿过位置
    *r* 处垂直于方向 *Ω* 的单位立体角的无穷小面积上的辐射功率 [*W*]，*μ[s]* 是散射系数，*μ[a]* 是吸收系数，*ν* 是光速，而 ![渲染体积数据集
    – MCML模拟](img/9727OS_03_19.jpg) 是源项。为了数值求解RTE，威尔逊和亚当引入了**蒙特卡洛**（**MC**）方法，由于其准确性和多功能性（特别是对于复杂组织几何形状），该方法被广泛接受为光子迁移建模的金标准方法。
- en: The MC method is a statistical sampling technique that has been applied to a
    number of important problems in many different fields, ranging from radiation
    therapy planning in medicine to option pricing in finance. The name Monte Carlo
    is derived from the resort city in Monaco that is known for its casinos, among
    other attractions. As its name implies, the key feature of the MC method involves
    the exploitation of random chance (through the generation of random numbers with
    a particular probability distribution) to model the physical process in question.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MC 方法是一种统计抽样技术，已被应用于许多不同领域的许多重要问题，从医学中的放射治疗计划到金融中的期权定价。蒙特卡洛这个名字来源于摩纳哥的度假胜地，该地以其赌场等景点而闻名。正如其名所示，MC
    方法的关键特征涉及利用随机机会（通过生成具有特定概率分布的随机数）来模拟所讨论的物理过程。
- en: In our case, we are interested in modeling photon propagation in biological
    tissue. The MCML algorithm provides an MC model of steady-state light transport
    in multi-layered media. In particular, we will simulate photon propagation in
    a homogeneous medium with a circular light source incident on the tissue surface
    in order to compute the light dose (absorbed energy) distribution. Such computations
    have a wide range of applications, including treatment planning for light therapies
    such as photodynamic therapy (this can be considered a light-activated chemotherapy
    for cancer).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们感兴趣的是模拟生物组织中的光子传播。MCML 算法提供了多层介质中稳态光传输的蒙特卡洛模型。特别是，我们将模拟在组织表面具有圆形光源的均匀介质中的光子传播，以计算光剂量（吸收能量）分布。这类计算有广泛的应用范围，包括光疗（如光动力疗法）的治疗计划（这可以被视为一种针对癌症的光激活化疗）。
- en: Here, we demonstrate how to integrate our code base for displaying volumetric
    data with OpenGL rendering functions. We will take advantage of techniques such
    as alpha blending, perspective rendering, and heat map rendering. Together with
    the GLFW interface for capturing user inputs, we can create an interactive visualizer
    that can display a large volumetric dataset in real-time and control a slicer
    that magnifies a plane of data points within the volumetric dataset using a few
    simple key inputs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示如何将我们的代码库与 OpenGL 渲染函数集成以显示体量数据。我们将利用诸如 alpha 混合、透视渲染和热图渲染等技术。结合 GLFW
    接口捕获用户输入，我们可以创建一个交互式可视化器，可以实时显示大量体量数据，并使用几个简单的键输入控制放大体量数据集中数据点平面的切片器。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The simulation result is stored in an ASCII text file that contains a 3D matrix.
    Each value in the matrix represents the absorbed photon energy density at some
    fixed position within the voxelized geometry. Here, we will provide a simple parser
    that extracts the simulation output matrix from the file and stores it in the
    local memory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟结果存储在一个包含 3D 矩阵的 ASCII 文本文件中。矩阵中的每个值代表在体素化几何结构中某个固定位置的吸收光子能量密度。在这里，我们将提供一个简单的解析器，从文件中提取模拟输出矩阵并将其存储在本地内存中。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s get started by implementing the MCML data parser, the jet color scheme
    heat map generator, as well as the slicer in OpenGL:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现 MCML 数据解析器、喷射颜色方案热图生成器以及 OpenGL 中的切片器开始：
- en: 'Take the data from the simulation output text file and store it in floating-point
    arrays:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模拟输出的文本文件中获取数据并将其存储在浮点数组中：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Encode the simulation output values using a custom color map for display:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义颜色图对模拟输出值进行编码以进行显示：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the heat map generator with the jet color scheme:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用喷射颜色方案实现热图生成器：
- en: '[PRE36]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Draw all data points on screen with transparency enabled:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上绘制所有数据点，并启用透明度：
- en: '[PRE37]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Draw three slices of data points for cross-sectional visualization:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制三个数据点的切片以进行横截面可视化：
- en: '[PRE38]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In addition, we need to update the `key_callback` function for moving the slices:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要更新 `key_callback` 函数以移动切片：
- en: '[PRE39]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, to complete the demo, simply call the `drawMCMLPoints` and `drawMCMLSlices`
    functions inside the `main` loop using the same code structure for perspective
    rendering introduced in the previous demo for plotting a Gaussian function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成演示，只需在 `main` 循环中调用 `drawMCMLPoints` 和 `drawMCMLSlices` 函数，并使用之前演示中用于绘制高斯函数的透视渲染相同的代码结构即可：
- en: '[PRE40]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The simulation results, representing the photon absorption distribution in
    a voxelized geometry, are displayed in 3D in the following screenshot. The light
    source illuminates the tissue surface (*z=0* at the bottom) and propagates through
    the tissue (positive *z* direction) that is modeled as an infinitely wide homogeneous
    medium. The photon absorption distribution follows the expected shape for a finite-sized,
    flat, and circular beam:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，以3D形式显示了模拟结果，表示在体素化几何形状中的光子吸收分布。光源照亮组织表面（底部*z=0*），并通过模拟为无限宽的均匀介质组织的组织传播（正*z*方向）。光子吸收分布遵循有限尺寸、平坦和圆形光束的预期形状：
- en: '![How to do it...](img/9727OS_03_08.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_03_08.jpg)'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: This demo illustrates how we can take a volumetric dataset generated from a
    Monte Carlo simulation (and, more generally, a volumetric dataset from any application)
    and render it with a highly interactive interface using OpenGL. The data parser
    takes an ASCII text file as input. Then, we turn the floating-point data into
    individual vertices that can fit into our rendering pipeline. Upon initialization,
    the variables `mcml_vertices` and `mcml_data` store the pre-computed heat map
    data as well as the position of each data point. The `parser` function also computes
    the maximum and minimum value in the dataset for heat map visualization. The `getHeatMapColor`
    function takes the simulation output value and maps it to a color in the jet color
    scheme. The algorithm basically defines a color spectrum and we remap the value
    based on its range.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示说明了我们如何将蒙特卡洛模拟（以及更一般地，任何应用程序生成的体数据集）生成的体数据集通过一个高度交互式的界面使用OpenGL进行渲染。数据解析器以ASCII文本文件作为输入。然后，我们将浮点数据转换为可以适应我们的渲染管道的单独顶点。初始化时，变量`mcml_vertices`和`mcml_data`存储预先计算的热图数据以及每个数据点的位置。`parser`函数还计算数据集中的最大值和最小值，以便进行热图可视化。`getHeatMapColor`函数将模拟输出值映射到喷气色系中的颜色。该算法基本上定义了一个颜色光谱，并根据其范围重新映射值。
- en: 'In the following screenshot, we show a top view of the simulation result, which
    allows us to visualize the symmetry of the light distribution:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们展示了模拟结果的一个俯视图，这使我们能够可视化光分布的对称性：
- en: '![How it works...](img/9727OS_03_09.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_03_09.jpg)'
- en: 'The `drawMCMLSlices` function takes a slice (that is, a plane) of data and
    renders the data points at the full opacity and a larger point size. This provides
    a useful and very common visualization method (especially in medical imaging)
    that allows users to examine the volumetric data in detail by moving the cross-sectional
    slices. As we can see in the following screenshot, we can shift the slicer in
    the *x*, *y*, and *z* directions to visualize the desired regions of interest:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawMCMLSlices`函数接受一个数据切片（即一个平面），并以全不透明度和更大的点大小渲染数据点。这提供了一种有用且非常常见的可视化方法（特别是在医学成像中），允许用户通过移动横截面切片来详细检查体数据。正如以下屏幕截图所示，我们可以沿*x*、*y*和*z*方向移动切片器来可视化感兴趣的区域：'
- en: '![How it works...](img/9727OS_03_10.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_03_10.jpg)'
- en: There's more...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This demo provides an example of real-time volumetric data visualization for
    rendering simulation data in an interactive 3D environment. The current implementation
    can be easily modified for a wide range of applications that require volumetric
    dataset visualization. Our approach provides an intuitive way to render complex
    3D datasets with a heat map generator and a slicer as well as 3D perspective rendering
    techniques using OpenGL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示提供了一个在交互式3D环境中渲染模拟数据的实时体数据可视化的示例。当前的实现可以很容易地修改，以适应需要体数据集可视化的广泛应用程序。我们的方法提供了一个直观的方式来渲染复杂的3D数据集，包括热图生成器、切片器和使用OpenGL的3D透视渲染技术。
- en: One important observation is that this demo required a significant number of
    `glVertex3f` calls, which can become a major performance bottleneck. To address
    this, in the upcoming chapters, we will explore more sophisticated ways to handle
    memory transfer and draw even more complex models with **Vertex Buffer Objects**
    (**VBOs**), a memory buffer in your graphics card designed to store information
    about vertices. This will lead us towards fragment programs and custom vertex
    shader programs (that is, moving from OpenGL 2.0 to OpenGL 3.2 or higher). However,
    the simplicity of using classical OpenGL 2.0 calls is an important consideration
    if we are aiming for a short development cycle, minimal overhead, and backward
    compatibility with older hardware.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的观察是，这个演示需要大量的 `glVertex3f` 调用，这可能会成为性能瓶颈的主要因素。为了解决这个问题，在接下来的章节中，我们将探讨更复杂的方法来处理内存传输，并使用**顶点缓冲对象**（**VBOs**）绘制更复杂的模型，**VBOs**是显卡中的内存缓冲区，用于存储顶点信息。这将引导我们走向片段程序和自定义顶点着色器程序（即从OpenGL
    2.0过渡到OpenGL 3.2或更高版本）。然而，如果我们目标是缩短开发周期、最小化开销以及与旧硬件的向后兼容性，那么使用经典OpenGL 2.0调用的简单性是一个重要的考虑因素。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For further information, please consult the following references:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参考以下参考文献：
- en: E. Alerstam & W. C. Y. Lo, T. Han, J. Rose, S. Andersson-Engels, and L. Lilge,
    "Next-generation acceleration and code optimization for light transport in turbid
    media using GPUs," *Biomed. Opt. Express 1*, 658-675 (2010).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E. Alerstam & W. C. Y. Lo, T. Han, J. Rose, S. Andersson-Engels, 和 L. Lilge,
    "使用GPU对浑浊介质中光传输的下一代加速和代码优化," *Biomed. Opt. Express 1*, 658-675 (2010).
- en: W. C. Y. Lo, K. Redmond, J. Luu, P. Chow, J. Rose, and L. Lilge, "Hardware acceleration
    of a Monte Carlo simulation for photodynamic therapy treatment planning," *J.
    Biomed. Opt. 14*, 014019 (2009).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W. C. Y. Lo, K. Redmond, J. Luu, P. Chow, J. Rose, 和 L. Lilge, "用于光动力治疗计划的光动力治疗蒙特卡洛模拟的硬件加速,"
    *J. Biomed. Opt. 14*, 014019 (2009).
- en: L. Wang, S. Jacques, and L. Zheng, "MCML - Monte Carlo modeling of light transport
    in multi-layered tissues," *Comput. Meth. Prog. Biol. 47*, 131–146 (1995).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W. Wang, S. Jacques, 和 L. Zheng, "MCML - 多层组织中光传输的蒙特卡洛建模," *Comput. Meth. Prog.
    Biol. 47*, 131–146 (1995).
- en: B. Wilson and G. Adam, "A Monte Carlo model for the absorption and flux distributions
    of light in tissue," *Med. Phys. 10*, 824 (1983).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B. Wilson 和 G. Adam, "组织中光吸收和通量分布的蒙特卡洛模型," *Med. Phys. 10*, 824 (1983).
