- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Adding Install Support for Your Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的库添加安装支持
- en: In [*Chapter 6*](B21152_06.xhtml#_idTextAnchor152), *Installing Dependencies
    and ExternalProject_Add*, we looked at installing existing libraries and using
    them in our project. Understanding how to use installed libraries can be incredibly
    useful, especially when combined with `ExternalProject_Add`. Now, we’re going
    to turn the tables and look at how to add install support to our own library.
    This is a large topic, and there are many different options available. We won’t
    be able to cover everything, but we’ll aim to introduce the CMake `install` command,
    what it does, and how to use it, as well as several available configuration options.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21152_06.xhtml#_idTextAnchor152)，《安装依赖项和ExternalProject_Add》中，我们讨论了如何安装现有库并在项目中使用它们。了解如何使用已安装的库非常有用，特别是当与`ExternalProject_Add`结合使用时。现在，我们将转变思路，看看如何为我们自己的库添加安装支持。这是一个庞大的话题，提供了许多不同的选项。我们无法涵盖所有内容，但我们将着重介绍CMake的`install`命令，它的作用以及如何使用它，还会介绍一些可用的配置选项。
- en: The skills you’ll learn in this chapter will be very useful if you ever choose
    to make your own library installable and available through `ExternalProject_Add`
    or your application packageable. By doing this, you’ll make it easier for other
    developers to use your library and potentially save them from having to build
    it multiple times.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你将学到的技能，如果你以后选择使自己的库可安装并通过`ExternalProject_Add`或将你的应用打包，都会非常有用。通过这样做，你将使其他开发者更容易使用你的库，并可能避免他们多次构建它。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Adding install support to a library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为库添加安装支持
- en: Dealing with nested dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理嵌套依赖项
- en: When and how to use `COMPONENTS`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何使用`COMPONENTS`
- en: Supporting different versions of a library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同版本的库
- en: Writing a find module file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写查找模块文件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续学习，请确保你已经满足[*第1章*](B21152_01.xhtml#_idTextAnchor019)，《入门》中列出的要求。包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行最新**操作系统**(**OS**)的Windows、Mac或Linux机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的C/C++编译器（如果你还没有，建议使用系统默认的编译器）
- en: 'The code examples in this chapter can be found by following this link: [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)。
- en: Adding install support to a library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为库添加安装支持
- en: When adding install support to a library, everything revolves around the `install`
    command. The `install` command is how we tell CMake what to install, as well as
    the relative layout of files. The good news is there’s very little to change in
    our existing `CMakeLists.txt` files, and in most cases, there’s not a great deal
    to add either. What we do add though can be quite confusing at first glance, which
    we’ll try to demystify here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为库添加安装支持时，一切都围绕着`install`命令。`install`命令是我们告诉CMake要安装什么内容，以及文件的相对布局。好消息是，我们现有的`CMakeLists.txt`文件几乎不需要做什么更改，并且在大多数情况下，也不需要添加太多内容。不过，第一次看到我们添加的内容时可能会有些困惑，我们将在这里尽量解释清楚。
- en: As with earlier chapters, we’ll work through a concrete example and show how
    to add install support to the simplest of our existing libraries, `mc-array`.
    This is a static library that provides support for a resizable array in C (very
    similar to `std::vector` in C++). We’ve used this throughout our *Game of Life*
    application and it’s a particularly useful utility to rely on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将通过一个具体的示例，展示如何为我们现有的最简单库之一`mc-array`添加安装支持。这个静态库提供了在C语言中支持可调整大小的数组（非常类似于C++中的`std::vector`）。我们在整个《生命游戏》应用中都使用了它，它是一个特别有用的工具。
- en: 'We’ll start by looking at `ch7/part-1/lib/array/CMakeLists.txt`. The first
    change is we’ve now committed this library to be used as a static library by explicitly
    providing the `STATIC` argument to the `add_library` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看`ch7/part-1/lib/array/CMakeLists.txt`开始。第一个变化是，我们已经明确通过提供`STATIC`参数将这个库提交为静态库，来进行使用：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: include(GNUInstallDirs)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: include(GNUInstallDirs)
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: target_include_directories(
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: target_include_directories(
- en: ${PROJECT_NAME}
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}
- en: PUBLIC
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PUBLIC
- en: $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
- en: 'FetchContent), the first generator expression, BUILD_LOCAL_INTERFACE, will
    evaluate to true, so ${CMAKE_CURRENT_SOURCE_DIR}/include will be used. In the
    case when our library is installed, the relative location of the include files
    may be different from that of a normal build, so we can provide a slightly different
    location relative to the install include directory. ${CMAKE_INSTALL_INCLUDEDIR}
    is provided by GNUInstallDirs, and we’ll use it later in one of our install commands
    when we install (copy) the .h files to the install folder. It’s also possible
    to use a relative path for $<INSTALL_INTERFACE>, which will be evaluated from
    the root of the install prefix:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FetchContent），第一个生成器表达式 `BUILD_LOCAL_INTERFACE` 将评估为 true，因此 ${CMAKE_CURRENT_SOURCE_DIR}/include
    将被使用。当我们的库被安装时，包含文件的相对位置可能与正常构建时不同，因此我们可以提供相对于安装目录稍微不同的位置。`${CMAKE_INSTALL_INCLUDEDIR}`
    是由 GNUInstallDirs 提供的，我们将在稍后的 `install` 命令中使用它，将 .h 文件安装（复制）到安装文件夹中。也可以使用相对路径来为
    $<INSTALL_INTERFACE> 提供路径，这将从安装前缀的根目录进行评估：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: set_target_properties(${PROJECT_NAME} PROPERTIES mc-array, when building Debug
    and Release respectively, we’ll get libmc-arrayd.a and libmc-array.a on macOS
    and Linux, and mc-array d.lib and mc-array.lib on Windows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(${PROJECT_NAME} PROPERTIES mc-array，当我们分别构建 Debug 和 Release
    时，我们将在 macOS 和 Linux 上得到 libmc-arrayd.a 和 libmc-array.a，在 Windows 上得到 mc-array
    d.lib 和 mc-array.lib。
- en: With that, we have everything we need to start adding the `install` commands
    themselves.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这些，我们就可以开始添加 `install` 命令本身了。
- en: The CMake install command
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake 安装命令
- en: CMake’s `install` command is incredibly versatile, but its usage can be difficult
    to grasp when first encountering it. A key thing to be aware of is the functionality
    of `install` varies wildly based on the arguments passed to it. For those familiar
    with C++, you can think of how `install` is implemented as a form of `install`
    are context-dependent (their order, or positioning, is significant), which can
    also make things quite confusing. With all this in mind, let’s look at a concrete
    example.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake 的 `install` 命令非常灵活，但在第一次遇到时可能会觉得难以理解。需要注意的一点是，`install` 的功能会根据传递给它的参数而大不相同。对于熟悉
    C++ 的人来说，可以将 `install` 的实现看作是某种形式的 `install`，其功能依赖于上下文（它们的顺序或位置是有意义的），这也可能让事情变得相当混乱。考虑到这一点，让我们看一个具体的例子。
- en: The first argument passed to `install` decides what kind of `install` command
    will be performed; these are called `TARGETS`, `EXPORT`, and `DIRECTORY`. The
    rule essentially defines what the `install` command is concerned with.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传递给 `install` 的第一个参数决定了将执行哪种类型的 `install` 命令；这些被称为 `TARGETS`、`EXPORT` 和 `DIRECTORY`。该规则本质上定义了
    `install` 命令所关注的内容。
- en: 'Let’s review the first install command in our `CMakeLists.txt` file:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `CMakeLists.txt` 文件中的第一个安装命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The effect of this command is to install the build artifact of our library,
    in this case, `libmc-array.a` on macOS/Linux, and `mc-array.lib` on Windows, to
    a `lib` folder under the install location we selected using `CMAKE_INSTALL_PREFIX`
    (or a default system location if this is not provided).
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令的作用是将我们库的构建产物安装到指定位置，在 macOS/Linux 上是 `libmc-array.a`，在 Windows 上是 `mc-array.lib`，并将其安装到我们使用
    `CMAKE_INSTALL_PREFIX` 选定的 `lib` 文件夹中（如果未提供该路径，则为默认的系统位置）。
- en: 'The first argument, `TARGETS`, refers to the targets we want to install. In
    our case, this is the library we created with the `add_library` command earlier
    in the `CMakeLists.txt` file. As this is a small library, we reused the project
    name for the target, but if we selected a different name, we would refer to that.
    An example showing this is illustrated below:'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个参数 `TARGETS` 指的是我们要安装的目标。在我们的案例中，这就是我们之前在 `CMakeLists.txt` 文件中使用 `add_library`
    命令创建的库。由于这是一个小型库，我们重用了项目名称作为目标，但如果我们选择了其他名称，我们将引用那个名称。下面是一个展示这个的例子：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See `ch7/part-2/lib/array/CMakeLists.txt` for an example of using a different
    name for the library (target), rather than reusing the project name. We’ll use
    this approach throughout the remainder of the chapter to help disambiguate the
    project/package from the individual targets/libraries.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参见 `ch7/part-2/lib/array/CMakeLists.txt`，了解如何使用不同的库名称（目标），而不是重用项目名称。我们将在本章其余部分采用这种方法，帮助区分项目/包与各个目标/库。
- en: The second argument we pass to the first `install` command is `EXPORT ${PROJECT_NAME}-config`.
    Exporting means making targets available to other projects (usually through `find_package`).
    By adding this line, we’re notifying CMake that we want to export this target
    and associate it with a config file named after our project (`${PROJECT_NAME}-config`),
    which expands to `mc-array-config` in our case). This step does not yet create
    the export file but allows us to refer to the export in a later `install` command
    to generate a `<project-name>-config.cmake` file (we could also have gone with
    `${PROJECT_NAME}Config` and had CMake generate a `<ProjectName>Config.cmake` file
    for us).
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们传递给第一个`install`命令的第二个参数是`EXPORT ${PROJECT_NAME}-config`。导出意味着将目标提供给其他项目（通常通过`find_package`）。通过添加这行代码，我们通知CMake，我们希望导出这个目标，并将其与一个以我们项目命名的配置文件（`${PROJECT_NAME}-config`，在我们这里扩展为`mc-array-config`）关联。此步骤尚未创建导出文件，但允许我们在后续的`install`命令中引用该导出，以生成`<project-name>-config.cmake`文件（我们也可以选择`${PROJECT_NAME}Config`，让CMake为我们生成`<ProjectName>Config.cmake`文件）。
- en: The final argument is `ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}`. This tells
    CMake where we want to install our static library’s `.a`/`.lib` file. This isn’t
    strictly necessary, as CMake will select a default system location, but being
    explicit and using the helpful `CMAKE_INSTALL_LIBDIR` variable provided by `GNUInstallDirs`
    will make our `CMakeLists.txt` file more self-documenting. It’s highly likely
    `${CMAKE_INSTALL_LIBDIR}` will simply expand to `lib`, but using this approach
    does provide a customization point if users want to override the library install
    directory for some reason.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的参数是`ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}`。这告诉CMake我们希望安装静态库的`.a`/`.lib`文件的位置。这并不是严格必要的，因为CMake会选择一个默认的系统位置，但显式指定并使用`GNUInstallDirs`提供的有用变量`CMAKE_INSTALL_LIBDIR`会使我们的`CMakeLists.txt`文件更加自文档化。`${CMAKE_INSTALL_LIBDIR}`很可能会扩展为`lib`，但使用这种方式提供了一个自定义点，如果用户希望覆盖库安装目录，可以根据需要进行调整。
- en: 'With just the preceding `install` command added to our `CMakeLists.txt` file,
    if we run the following command from `ch7/part-1/lib/array`:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只需将前面的`install`命令添加到我们的`CMakeLists.txt`文件中，如果我们从`ch7/part-1/lib/array`目录运行以下命令：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll see the following output:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们会看到以下输出：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (For context, `ch7/part-1/lib/array/CMakeLists.txt` does already contain a complete
    install example, but feel free to comment out the later `install` commands to
    see what does and doesn’t get installed with each command.)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （为提供上下文，`ch7/part-1/lib/array/CMakeLists.txt`已经包含了一个完整的安装示例，但可以随意注释掉后面的`install`命令，看看每个命令安装了什么，没安装什么。）
- en: 'This is a good start, but there’s still not enough information for CMake to
    find and use our library. Now that our library file is installed, and the export
    target is created, we can review the next `install` command:'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个好的开始，但CMake仍然缺少足够的信息来找到并使用我们的库。现在库文件已经安装，导出目标也已经创建，我们可以查看下一个`install`命令：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `install` command refers to the `EXPORT` rule. The first argument, `EXPORT
    ${PROJECT_NAME}-config`, links this command to the earlier `install(TARGETS)`
    command that introduced the `${PROJECT_NAME}-config` export. This command creates
    and installs the export file itself, ensuring it ends up in our `install` folder
    (this is the `mc-array-config.cmake` file). We need to provide the location of
    where this file should be installed. If we don’t, we’ll see the following error
    message:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`install`命令涉及到`EXPORT`规则。第一个参数`EXPORT ${PROJECT_NAME}-config`将这个命令与先前介绍的`${PROJECT_NAME}-config`导出链接在一起。此命令创建并安装导出文件，确保它最终被放入我们的`install`文件夹中（即`mc-array-config.cmake`文件）。我们需要提供此文件应安装的位置。如果我们没有提供，将看到以下错误信息：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is achieved with the `DESTINATION` argument. We again lean on the `GNUInstallDirs`
    variable `CMAKE_INSTALL_LIBDIR`, and then specify a folder named `cmake`, followed
    by our project name. CMake knows to search this location, and it’s also possible
    to switch the order of `${PROJECT_NAME}` and `cmake` if preferred (this is more
    important if installing to the default system directory and will determine how
    the CMake config files are organized):'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是通过`DESTINATION`参数实现的。我们再次依赖于`GNUInstallDirs`变量`CMAKE_INSTALL_LIBDIR`，然后指定一个名为`cmake`的文件夹，接着是我们的项目名称。CMake知道要搜索这个位置，如果需要，也可以调整`${PROJECT_NAME}`和`cmake`的顺序（如果安装到默认系统目录，这一点更为重要，它决定了CMake配置文件的组织方式）：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'NAMESPACE minimal-cmake::'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'NAMESPACE minimal-cmake::'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[2/3] Install the project...'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[2/3] 正在安装项目...'
- en: '-- Install configuration: "Debug"'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: -- 安装配置：“调试”
- en: '-- Installing: .../array/install/lib/libmc-arrayd.a'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: -- 正在安装：.../array/install/lib/libmc-arrayd.a
- en: '-- Installing: .../array/install/lib/cmake/mc-array/mc-array-config.cmake'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: -- 安装：.../array/install/lib/cmake/mc-array/mc-array-config.cmake
- en: '-- Installing: .../array/install/lib/cmake/mc-array/mc-array-config-debug.cmake'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: -- 安装：.../array/install/lib/cmake/mc-array/mc-array-config-debug.cmake
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: cmake --build build --target install --config Release
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build --target install --config Release
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '...'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '-- Installing: .../array/install/lib/cmake/mc-array/mc-mc-array-config.cmake
    and mc-array-config-debug.cmake/mc-array-config-release.cmake files to see what’s
    going on under the hood. There’s quite a lot of generated code that we can safely
    ignore, but the key lines to notice are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: -- 安装：.../array/install/lib/cmake/mc-array/mc-mc-array-config.cmake 和 mc-array-config-debug.cmake/mc-array-config-release.cmake
    文件，以查看底层发生了什么。有许多生成的代码我们可以安全地忽略，但需要注意的关键行如下：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'CMake is creating an imported target for us (as `mc-array` has already been
    built) and is then setting properties on the target to show where to find its
    `include` files. It then iterates through the different build config files, and
    in each of them sets more properties on the imported target based on the configuration:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake 正在为我们创建一个导入的目标（因为 `mc-array` 已经构建完成），然后设置该目标的属性以显示在哪里可以找到它的 `include`
    文件。然后它会遍历不同的构建配置文件，并在每个文件中根据配置为导入的目标设置更多属性：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This informs CMake where to find the library, and what the build type (or configuration)
    is.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通知 CMake 库的位置，以及构建类型（或配置）。
- en: Delving into these files isn’t something that’s often needed, but knowing roughly
    what they’re doing is a huge help in understanding how to debug issues when things
    can’t be found. It’s also good to appreciate there’s no magic going on; CMake
    has just automatically generated a number of the commands we’d otherwise have
    to write by hand (and has likely done a better job than we’d manage on our own).
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 深入研究这些文件并不是经常需要的，但大致了解它们在做什么，对于理解如何调试无法找到的文件问题非常有帮助。也值得注意的是，这里并没有什么魔法；CMake
    只是自动生成了我们本该手动编写的许多命令（而且很可能做得比我们自己写得更好）。
- en: 'The final (and thankfully simplest) `install` command concerns the `DIRECTORY`
    rule:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终（幸运的是最简单的）`install` 命令涉及到 `DIRECTORY` 规则：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this install step, we’re simply copying the contents of one directory to
    another, in this case, the `include` directory. We use `CMAKE_CURRENT_LIST_DIR`
    to get the path to the current `CMakeLists.txt` file we’re in, and then refer
    to the `include` files in our source directory from there. For the `DESTINATION`,
    we use `CMAKE_INSTALL_INCLUDEDIR` (which should look familiar from the earlier
    `target_include_directories` call where we used it along with the `INSTALL_INTERFACE`
    generator expression). This will add our `include` files under `include/minimal-cmake`
    (by convention, `CMAKE_INSTALL_INCLUDEDIR` will expand to `include`).
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个安装步骤中，我们只是将一个目录的内容复制到另一个目录，在这种情况下是 `include` 目录。我们使用 `CMAKE_CURRENT_LIST_DIR`
    获取当前 `CMakeLists.txt` 文件的路径，然后从那里引用源目录中的 `include` 文件。对于 `DESTINATION`，我们使用 `CMAKE_INSTALL_INCLUDEDIR`（这在之前的
    `target_include_directories` 调用中使用过，它与 `INSTALL_INTERFACE` 生成表达式一起使用）。这将把我们的 `include`
    文件放在 `include/minimal-cmake` 下（根据约定，`CMAKE_INSTALL_INCLUDEDIR` 会扩展为 `include`）。
- en: 'If we run `cmake --build build --target install` once more, we’ll see our `include`
    file will be copied to the expected install location:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们再运行一次 `cmake --build build --target install`，我们会看到我们的 `include` 文件会被复制到预期的安装位置：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: File sets
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件集
- en: CMake `3.23` introduced a new feature called `target_sources` command. Specifying
    a file set allows headers to automatically be installed as part of the `TARGET`
    install command. We,re sticking with the traditional approach in this book, but
    do see [https://cmake.org/cmake/help/latest/command/target_sources.html#file-sets](https://cmake.org/cmake/help/latest/command/target_sources.html#file-sets)
    for more information on specifying file sets.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake `3.23` 引入了一个名为 `target_sources` 命令的新特性。指定一个文件集可以使头文件自动作为 `TARGET` 安装命令的一部分进行安装。我们在本书中坚持传统方法，但请查看
    [https://cmake.org/cmake/help/latest/command/target_sources.html#file-sets](https://cmake.org/cmake/help/latest/command/target_sources.html#file-sets)
    了解更多关于指定文件集的信息。
- en: With our `.h` files in place, we now have everything we need to install our
    library and use it in another project.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了 `.h` 文件，我们现在拥有了安装我们的库并在另一个项目中使用它所需的一切。
- en: 'The `install` folder structure now looks like the following:'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`install` 文件夹结构现在看起来如下：'
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We,ve covered a lot, so don’t worry if everything doesn’t 100% make sense. The
    concepts of installing, exporting, and importing targets will all start to make
    more sense the more you use them. The silver lining is adding install support
    only took around 10 lines of code, which isn’t too bad in the grand scheme of
    things. In `ch7/part-2/lib/array`, as well as changing the name of the `mc-array`
    target to `dynamic-array`, we’ve added a `CMakePreset.json` file to set the `install`
    directory (`"installDir"`). Simply run `cmake --preset default`, and then `cmake
    --build build --``target install`.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经涵盖了很多内容，所以如果一切并不完全明了也不用担心。安装、导出和导入目标的概念随着你使用得越多会变得越清晰。一个积极的方面是，添加安装支持仅仅花了大约10行代码，在大局上看，这并不算太多。在`ch7/part-2/lib/array`中，除了将`mc-array`目标的名称更改为`dynamic-array`，我们还添加了一个`CMakePreset.json`文件来设置`install`目录（`"installDir"`）。只需运行`cmake
    --preset default`，然后运行`cmake --build build --target install`。
- en: Let’s now look at how to use our array library from our *Game of* *Life* application.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在我们的*生命游戏*应用中使用我们的数组库。
- en: Using our newly installed library
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用我们新安装的库
- en: The good news is using the library we’ve just installed is a lot simpler. If
    we review `ch7/part-2/app/CMakeLists.txt`, there are two additions and one removal
    compared to the earlier example in `ch6/part-4/app/CMakeLists.txt`.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好消息是，使用我们刚刚安装的库变得简单多了。如果我们回顾一下`ch7/part-2/app/CMakeLists.txt`，与早期的`ch6/part-4/app/CMakeLists.txt`相比，有两个添加和一个删除。
- en: 'The first addition is as follows:'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个添加如下：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The name of the package (`mc-array`) is the name we assigned to the export.
    This is not the same as the target. It is equivalent to the name we assigned to
    the config file (`mc-array-config.cmake`).
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包的名称（`mc-array`）是我们分配给导出的名称。这与目标名称不同。它相当于我们分配给配置文件（`mc-array-config.cmake`）的名称。
- en: 'The `FetchContent` call which was used to bring `minimal-cmake-array` into
    the build has been removed as it’s no longer needed, and the only other change
    is updating the `target_link_libraries` command to refer to the new target along
    with the namespace prefix we added:'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于将`minimal-cmake-array`引入构建的`FetchContent`调用已经被移除，因为它不再需要，唯一的其他变化是更新`target_link_libraries`命令，使其引用新目标并添加我们之前添加的命名空间前缀：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '"CMAKE_PREFIX_PATH":'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"CMAKE_PREFIX_PATH"：'
- en: '"${sourceDir}/../third-party/installshared-ninja), and then build a configuration
    of our choosing, for example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"${sourceDir}/../third-party/installshared-ninja"，然后构建我们选择的配置，例如：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve now successfully used our installed library from our current application.
    The application can be launched as normal by running `./build/shared-ninja/Debug/minimal-cmake_game-of-life_window`
    from the application directory. As each `part-<n>` is entirely self-contained,
    every example will also need to have the third-party dependencies installed as
    before, as well as the shaders compiled by running `compile-shader-<platform>.sh/bat`.
    Each chapter’s `README.md` file describes the commands required to build and run
    every example; please refer to them for a recap of all the necessary steps.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经成功地从当前应用中使用了已安装的库。可以像往常一样运行应用，通过在应用目录下运行`./build/shared-ninja/Debug/minimal-cmake_game-of-life_window`来启动应用。由于每个`part-<n>`都是完全独立的，所以每个示例仍然需要像之前一样安装第三方依赖，并通过运行`compile-shader-<platform>.sh/bat`编译着色器。每章的`README.md`文件都描述了构建和运行每个示例所需的命令；请参考它们以回顾所有必要的步骤。
- en: Now we’ve installed a simple static library, we’re going to look at a slightly
    more complex case where we handle installing a library with its own dependencies.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经安装了一个简单的静态库，接下来我们将探讨一个稍微复杂一点的案例，处理安装一个有自己依赖关系的库。
- en: Dealing with nested dependencies
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理嵌套依赖
- en: When we say nested dependencies, we mean dependencies of the library we’d like
    to depend on ourselves (you can think of these as indirect dependencies, also
    known as **transitive dependencies**). For example, if an application depends
    on Library A, and Library A depends on Library B, then as far as the application
    is concerned, Library B is nested inside Library A. Whether that dependency is
    private (hidden from the application) or public (visible to the application) also
    affects how we handle it.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们说到嵌套依赖时，我们指的是我们想要依赖的库的依赖项（你可以把这些看作是间接依赖，也叫做**传递性依赖**）。例如，如果一个应用依赖于库A，而库A又依赖于库B，那么就应用而言，库B嵌套在库A中。无论这个依赖是私有的（对应用隐藏）还是公共的（对应用可见），都影响我们如何处理它。
- en: In the example we just looked at (`mc-array`), we fortunately did not have any
    dependencies to worry about when providing install support. Things get a little
    more complicated when we do, but once we understand what is needed and why, it’s
    not that much work to support.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们刚才看到的示例（`mc-array`）中，幸运的是，当提供安装支持时，我们不需要担心任何依赖项。如果有依赖项，事情会变得稍微复杂一些，但一旦我们理解了需要做什么以及为什么做，支持起来并不复杂。
- en: To better understand this, we’ll turn our attention to our *Game of Life* library,
    `mc-gol`, situated in `ch7/part-2/lib/gol`. It would be good to add install support
    to this library as well as `mc-array`, so, if we replicate the three CMake `install`
    commands we just walked through, and add them to the bottom of `ch7/part-2/lib/gol/CMakeLists.txt`,
    along with adding `include(GNUInstallDirs)` at the top and updating `target_include_directories`
    with `INSTALL_INTERFACE`), we can see what happens (see `part-3` for the exact
    changes).
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们将注意力转向我们的*生命游戏*库，`mc-gol`，它位于`ch7/part-2/lib/gol`。最好为这个库以及`mc-array`添加安装支持，所以，如果我们复制刚才演示的三个CMake
    `install`命令，并将它们添加到`ch7/part-2/lib/gol/CMakeLists.txt`的底部，同时在顶部添加`include(GNUInstallDirs)`并更新`target_include_directories`与`INSTALL_INTERFACE`，我们可以看看会发生什么（请参阅`part-3`获取确切的更改）。
- en: 'If we configure, build, and install the shared version of the library from
    `ch7/part-2/lib/gol` (by setting `MC_GOL_SHARED=ON`), things will work as expected,
    but if we try to build the static version of the library, we’ll see three errors
    reported by CMake:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们从`ch7/part-2/lib/gol`配置、构建并安装共享版本的库（通过设置`MC_GOL_SHARED=ON`），一切都会按预期工作，但如果我们尝试构建库的静态版本，我们会看到CMake报告三处错误：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The reason for these errors is that the dependencies we,re using in `mc-gol`
    we brought in with `FetchContent` also need to be exported, as they’re treated
    as being part of the static library that’s being built and installed. This is
    the case even if the dependencies are marked `PRIVATE` in `target_link_libraries`.
    There are two separate ways to handle this problem. We’ll look at the first as
    part of `mc-gol`, and the second as part of a new library we’ll extract in the
    *Public nested* *dependencies* section.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些错误的原因是，我们在`mc-gol`中使用的依赖项是通过`FetchContent`引入的，也需要被导出，因为它们被视为构建和安装的静态库的一部分。即使这些依赖项在`target_link_libraries`中被标记为`PRIVATE`，情况依然如此。处理这个问题有两种不同的方法。我们将作为`mc-gol`的一部分来看第一个方法，并作为我们将在*公共嵌套*
    *依赖项*部分中提取的新库来看第二个方法。
- en: Private nested dependencies
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 私有嵌套依赖项
- en: 'In the case of `mc-gol`, we explicitly made all dependencies private (they
    are only used in `gol.c`), and we do not want clients or users of the library
    to be aware of them. Fortunately, there is a convenient generator expression we
    can use to ensure these targets are not exported and are only visible at build
    time. We’ve come across it before in the context of `target_include_directories`,
    and that is `BUILD_LOCAL_INTERFACE`:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`mc-gol`的情况下，我们显式地将所有依赖项设置为私有（它们仅在`gol.c`中使用），并且我们不希望客户端或库的用户知道它们。幸运的是，有一个方便的生成器表达式，我们可以使用它来确保这些目标不会被导出，并且只在构建时可见。我们之前在`target_include_directories`的上下文中遇到过它，那就是`BUILD_LOCAL_INTERFACE`：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: target_link_libraries(
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: target_link_libraries(
- en: game-of-life PRIVATE
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: game-of-life PRIVATE
- en: $<BUILD_LOCAL_INTERFACE:minimal-cmake::dynamic-array
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: $<BUILD_LOCAL_INTERFACE:minimal-cmake::dynamic-array
- en: as-c-math and mc-utils) inside BUILD_LOCAL_INTERFACE, but putting everything
    inside it ensures minimal-cmake::dynamic-array is not added to INTERFACE_LINK_LIBRARIES
    in the generated mc-gol-config.cmake file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: as-c-math 和 mc-utils）在BUILD_LOCAL_INTERFACE内，但将所有内容放入其中可以确保minimal-cmake::dynamic-array不会被添加到生成的mc-gol-config.cmake文件的INTERFACE_LINK_LIBRARIES中。
- en: 'The only other change needed is to ensure we install the shared library files
    (which we didn’t need in the case of `mc-array`, as it could only be built as
    static). The `install` `TARGET` command now looks like this:'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一需要的其他更改是确保我们安装共享库文件（在`mc-array`的情况下我们不需要这个，因为它只能构建为静态库）。现在，`install` `TARGET`
    命令如下所示：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: target_link_libraries(
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: target_link_libraries(
- en: draw
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: draw
- en: PUBLIC as-c-math
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PUBLIC as-c-math
- en: PRIVATE $<BUILD_LOCAL_INTERFACE:bgfx::bgfx minimal-cmake::dynamic-array>)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PRIVATE $<BUILD_LOCAL_INTERFACE:bgfx::bgfx minimal-cmake::dynamic-array>)
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: install(
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: install(
- en: EXPORT ${PROJECT_NAME}-config
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: EXPORT ${PROJECT_NAME}-config
- en: DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
- en: 'NAMESPACE minimal-cmake::'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'NAMESPACE minimal-cmake::'
- en: find_package command for the mc-draw package to first locate the as-c-math dependency,
    before attempting to locate the draw library that depends on as-c-math.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`find_package`命令首先定位`as-c-math`依赖项，然后再尝试定位依赖于`as-c-math`的draw库。
- en: 'On its own, all the preceding change does is change the name of what would
    have been the generated `mc-draw-config.cmake` file to `mc-draw-targets.cmake`,
    but this is because we’re going to craft our own config file, and then refer to
    this generated file from there. To do this, we create a new file called `mc-draw-config.cmake.in`
    in the same directory as our `CMakeLists.txt` file. It is a template file used
    to generate the real `mc-draw-config.cmake` file and its contents are as follows:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单独来看，所有前述的变更只是将原本会生成的`mc-draw-config.cmake`文件的名称更改为`mc-draw-targets.cmake`，但这是因为我们将自己制作配置文件，然后从那里引用这个生成的文件。为此，我们在与`CMakeLists.txt`文件相同的目录中创建一个新的文件，命名为`mc-draw-config.cmake.in`。这是一个模板文件，用于生成实际的`mc-draw-config.cmake`文件，其内容如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line is needed when using `configure_package_config_file` (a command
    we’ll get to shortly), we then bring in a CMake module (`CMakeFindDependencyMacro`)
    to allow us to call `find_dependency` on `as-c-math`. The `find_dependency` command
    is a wrapper around `find_package` and is specially designed to be used in package
    configuration files (see [https://cmake.org/cmake/help/latest/module/CMakeFindDependencyMacro.html](https://cmake.org/cmake/help/latest/module/CMakeFindDependencyMacro.html)
    for more information about `find_dependency`).
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行在使用`configure_package_config_file`时是必需的（这是我们稍后会介绍的命令），然后我们引入一个CMake模块（`CMakeFindDependencyMacro`），以便我们能在`as-c-math`上调用`find_dependency`。`find_dependency`命令是`find_package`的包装器，专门设计用于在包配置文件中使用（有关`find_dependency`的更多信息，请参见[https://cmake.org/cmake/help/latest/module/CMakeFindDependencyMacro.html](https://cmake.org/cmake/help/latest/module/CMakeFindDependencyMacro.html)）。
- en: Even though we brought `as-c-math` in using `FetchContent`, and built it as
    part of the main build, it also needs install support for us to be able to make
    it part of the export set. This is so the call to `find_package(mc-draw)` can
    first find `as-c-math`, as mentioned earlier (to see how this support was added,
    please refer to [https://github.com/pr0g/as-c-math](https://github.com/pr0g/as-c-math)
    and see the `bfdd853` commit). The last line includes the generated file from
    our earlier `install` `EXPORT` command (`mc-draw-targets.cmake`).
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使我们使用`FetchContent`将`as-c-math`引入，并作为主构建的一部分进行构建，它也需要安装支持，以便我们能够将其作为导出集的一部分。这是为了让调用`find_package(mc-draw)`时首先能找到`as-c-math`，正如之前提到的（要查看如何添加此支持，请参考[https://github.com/pr0g/as-c-math](https://github.com/pr0g/as-c-math)并查看`bfdd853`提交）。最后一行包含了我们之前`install`的`EXPORT`命令生成的文件（`mc-draw-targets.cmake`）。
- en: 'What is left is to now manually generate the new `mc-draw-config.cmake` file
    using this template as input. To do this, we use the previously mentioned `configure_package_config_file`
    command. We need to include the `CMakePackageConfigHelpers` CMake module first,
    and then the calling code is as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 剩下的就是手动使用此模板生成新的`mc-draw-config.cmake`文件。为此，我们使用前面提到的`configure_package_config_file`命令。我们需要先包含`CMakePackageConfigHelpers`
    CMake模块，然后调用代码如下：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: find_package(mc-draw CONFIG REQUIRED)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: find_package(mc-draw CONFIG REQUIRED)
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Found package configuration file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的包配置文件：
- en: ../minimal-cmake/ch7/part-4/lib/draw/install/lib/cmake/mc-draw/mc-draw-config.cmake
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ../minimal-cmake/ch7/part-4/lib/draw/install/lib/cmake/mc-draw/mc-draw-config.cmake
- en: 'but it set mc-draw_FOUND to FALSE so package "mc-draw" is considered to be
    NOT FOUND.  Reason given by package:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但它将mc-draw_FOUND设置为FALSE，因此包“mc-draw”被认为是未找到。包给出的原因是：
- en: 'The following imported targets are referenced, but are missing: NOT_FOUND until
    the issue can be addressed.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下导入的目标被引用，但缺失：在问题解决之前显示为NOT_FOUND。
- en: 'Everything should now be working, so from `ch7/part-4/app`, if we configure
    and build (using the CMake preset will make this easier), we can launch our updated
    application:'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一切应该已经正常工作，所以从`ch7/part-4/app`开始，如果我们配置并构建（使用CMake预设将使这变得更简单），我们可以启动我们更新后的应用程序：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember, we’ll also need to have built and installed the other required libraries
    in `part-4`, which includes `SDL2` and `bgfx` in the `third-party` folder, and
    `mc-array`, `mc-gol`, and `mc-draw` in the `lib` folder. There are `CMakePreset.json`
    files in every `lib` folder to correctly configure the install and prefix paths;
    simply run `cmake --preset list` to display which are available, and then `cmake
    --preset <preset-name>` to configure. To build and install, run `cmake --build
    build/<build-folder> --target install` for each library.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，我们还需要构建并安装`part-4`中的其他必需库，包括位于`third-party`文件夹中的`SDL2`和`bgfx`，以及位于`lib`文件夹中的`mc-array`、`mc-gol`和`mc-draw`。每个`lib`文件夹中都有`CMakePreset.json`文件来正确配置安装和前缀路径；只需运行`cmake
    --preset list`显示可用的预设，然后运行`cmake --preset <preset-name>`进行配置。要构建和安装，请为每个库运行`cmake
    --build build/<build-folder> --target install`。
- en: A reminder for the third-party dependencies, just run `cmake -B build -G <generator>`
    and `cmake --build build` in the `third-party` folder to have `ExternalProject_Add`
    handle everything with `SDL2` and `bgfx`. The one last thing to remember is to
    compile the shaders if you haven’t already (this can be done by running the corresponding
    batch/shell script for your platform from the `app` folder after building and
    installing `bgfx`).
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于第三方依赖的提醒，只需在`third-party`文件夹中运行`cmake -B build -G <generator>`和`cmake --build
    build`，让`ExternalProject_Add`处理所有与`SDL2`和`bgfx`的相关操作。最后要记住的是，如果你还没有编译着色器，可以在构建并安装`bgfx`后，从`app`文件夹运行对应的批处理/脚本来编译。
- en: The reward will be an updated *Game of Life* application with slightly more
    pleasant colors and grid lines with the help of our new `mc-draw` library.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 奖励将是一个更新版的*生命游戏*应用程序，借助我们新的`mc-draw`库，界面颜色和网格线将更加愉悦。
- en: '![Figure 7.1: Improved Game of Life application](img/B21152_07_1.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.1：改进版生命游戏应用程序](img/B21152_07_1.jpg)'
- en: 'Figure 7.1: Improved Game of Life application'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.1：改进版生命游戏应用程序
- en: The enhanced *Game of Life* application is also now interactive. Clicking outside
    the grid will pause and resume the simulation, and clicking a grid square will
    toggle the cell on or off. It’s fun to experiment with the wild patterns you can
    generate by making a few small modifications to the grid.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新后的*生命游戏*应用程序现在也可以互动了。点击网格外的地方将暂停和恢复模拟，而点击一个网格单元将切换该单元的开关状态。通过对网格进行少量修改，生成的各种奇特图案很有趣。
- en: Next, we’re going to look at how to break up a library into separate pieces
    called **components**.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何将库拆分为独立的部分，这些部分被称为**组件**。
- en: When and how to add COMPONENTS
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 何时以及如何添加组件
- en: As a library grows, there may come a point when it makes sense to split the
    overall library into several smaller pieces. At this point, you may want to start
    thinking of your library as more of a package, composed of one or more different
    libraries. Splitting your package into separate components can be helpful for
    users as they then only need to link to the functionality they need to use. This
    can help keep application binary sizes down and improve build times by reducing
    link times to external dependencies. On the library side, it can also be beneficial
    for decoupling code and breaking dependencies.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着库的增长，可能会有一个时刻，当将整体库拆分为几个更小的部分时变得有意义。在这一点上，你可能会开始把库看作是一个包，由一个或多个不同的库组成。将包拆分为独立的组件，对于用户来说非常有帮助，因为他们只需要链接所需的功能。这有助于减小应用程序的二进制文件大小，并通过减少与外部依赖项的链接时间来提高构建速度。对于库本身，拆分代码也有利于解耦和打破依赖。
- en: 'To demonstrate this, we’re going to update our `mc-draw` library to have three
    separate components: `vertex`, `line`, and `quad`. We can then explicitly request
    the components we need in the `find_package` call like so:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示这个，我们将更新我们的`mc-draw`库，使其包含三个独立的组件：`vertex`、`line`和`quad`。然后，我们可以在`find_package`调用中明确请求所需的组件，如下所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: target_link_libraries(
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: target_link_libraries(
- en: '...'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: minimal-cmake::vertex
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: minimal-cmake::vertex
- en: minimal-cmake::line
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: minimal-cmake::line
- en: minimal-cmake::quad
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: minimal-cmake::quad
- en: '...'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '@PACKAGE_INIT@'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '@PACKAGE_INIT@'
- en: valid components that can be searched for
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以搜索的有效组件
- en: set(_draw_supported_components vertex line quad)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: set(_draw_supported_components vertex line quad)
- en: iterate through components attempting to be found
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历组件，尝试查找
- en: foreach(component ${${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS})
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: foreach(component ${${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS})
- en: '# if we couldn''t find the component, set the draw library to no'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果我们找不到组件，设置绘图库为no'
- en: '# longer be found and notify the user about the missing component'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '# 找不到后，通知用户缺少的组件'
- en: if (NOT ${component} IN_LIST _draw_supported_components)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: if (NOT ${component} IN_LIST _draw_supported_components)
- en: set(mc-draw_FOUND False)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: set(mc-draw_FOUND False)
- en: 'set(mc-draw_NOT_FOUND_MESSAGE "Unsupported component: ${component}")'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: set(mc-draw_NOT_FOUND_MESSAGE "不支持的组件：${component}")
- en: else()
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: else()
- en: include(${CMAKE_CURRENT_LIST_DIR}/${component}-config.cmake)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: include(${CMAKE_CURRENT_LIST_DIR}/${component}-config.cmake)
- en: endif()
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: endforeach()
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: endforeach()
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: find_package(mc-draw CONFIG REQUIRED COMPONENTS circle)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: find_package(mc-draw CONFIG REQUIRED COMPONENTS circle)
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Found package configuration file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的包配置文件：
- en: ../minimal-cmake/ch7/part-5/lib/draw/install/lib/cmake/mc-draw/mc-draw-config.cmake
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ../minimal-cmake/ch7/part-5/lib/draw/install/lib/cmake/mc-draw/mc-draw-config.cmake
- en: 'but it set mc-draw_FOUND to FALSE so package "mc-draw" is considered to be
    NOT FOUND.  Reason given by package:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但它将mc-draw_FOUND设置为FALSE，因此包“mc-draw”被认为未找到。包给出的原因是：
- en: 'Unsupported component: circle'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持的组件：circle
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: project(
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: project(
- en: mc-draw
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: mc-draw
- en: LANGUAGES C
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: LANGUAGES C
- en: CMakeLists.txt file in the same way we can refer to the project name, only instead
    of using ${PROJECT_NAME}, we use ${PROJECT_VERSION}.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过与 CMakeLists.txt 文件相同的方式引用项目名称，只是这次不是使用 ${PROJECT_NAME}，而是使用 ${PROJECT_VERSION}。
- en: Most of the remaining changes then simply replace `${PROJECT_NAME}` with `${PROJECT_NAME}-${PROJECT_VERSION}`,
    or append it in the case of the `ARCHIVE`, `LIBRARY`, and `RUNTIME` destinations.
    The reason for this change is to make it possible to install multiple versions
    of the same library in the same location.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，大多数剩余的修改只是将 `${PROJECT_NAME}` 替换为 `${PROJECT_NAME}-${PROJECT_VERSION}`，或者在
    `ARCHIVE`、`LIBRARY` 和 `RUNTIME` 目标的情况下附加它。这样做的原因是为了使得在同一位置安装多个版本的相同库成为可能。
- en: 'The last addition we need is the `write_basic_package_version_file` CMake command
    to generate a `*-config-version` file for us. It looks as follows:'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要的最后一个添加是 `write_basic_package_version_file` CMake 命令，用于为我们生成一个 `*-config-version`
    文件。它看起来如下：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We name it `mc-draw-config-version` and pass `${PROJECT_VERSION}` to the `VERSION`
    argument. The `COMPATIBILITY` field is to decide how strict the library should
    be when accepting a version request. The options are `AnyNewerVersion`, `SameMajorVersion`,
    `SameMinorVersion`, and `ExactVersion`. We’ve chosen `SameMajorVersion`, which
    means so long as at least the first number in the version matches, the library
    will be found.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将其命名为 `mc-draw-config-version` 并将 `${PROJECT_VERSION}` 传递给 `VERSION` 参数。`COMPATIBILITY`
    字段用于决定库在接受版本请求时的严格程度。选项有 `AnyNewerVersion`、`SameMajorVersion`、`SameMinorVersion`
    和 `ExactVersion`。我们选择了 `SameMajorVersion`，这意味着只要版本的第一个数字匹配，库就会被找到。
- en: 'The `find_package` call in our app folder’s `CMakeLists.txt` file is updated
    very slightly to the following:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应用程序文件夹中的 `CMakeLists.txt` 文件中的 `find_package` 调用稍微更新为以下内容：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'CMake Error at CMakeLists.txt:16 (find_package):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 错误位于 CMakeLists.txt 的第 16 行 (find_package)：
- en: Could not find a configuration file for package "mc-draw" that is compatible
    with requested version "2.0".
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 找不到与请求的版本 "2.0" 兼容的 "mc-draw" 包的配置文件。
- en: 'The following configuration files were considered but not accepted:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置文件被考虑过，但未被接受：
- en: ../minimal-cmake/ch7/part-6/lib/draw/install/lib/cmake/mc-draw-3.5.4/mc-draw-config.cmake,
    AnyNewerVersion when we installed the library, asking for 2.0 would not produce
    an error as the installed version, 3.5.4, would be greater than the 2.0 version
    requested. Deciding which scheme to use can be difficult and will depend on your
    willingness to support backward compatibility. For more information about the
    different compatibility modes, please see https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#generating-a-package-version-file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ../minimal-cmake/ch7/part-6/lib/draw/install/lib/cmake/mc-draw-3.5.4/mc-draw-config.cmake，AnyNewerVersion，当我们安装库时，要求
    2.0 不会产生错误，因为已安装的版本 3.5.4 会大于请求的 2.0 版本。决定使用哪种方案可能会很困难，这将取决于你愿意支持的向后兼容性。有关不同兼容模式的更多信息，请参见
    [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#generating-a-package-version-file](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#generating-a-package-version-file)。
- en: Writing a find module file
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写查找模块文件
- en: Before we wrap up talking about installing, there’s one more topic that is useful
    to cover. So far, we’ve talked exclusively about finding dependencies using config
    mode, but there is an alternative mode we briefly touched on in [*Chapter 6*](B21152_06.xhtml#_idTextAnchor152),
    *Installing Dependencies and ExternalProject_Add*, called **Module mode**. Module
    mode is useful when integrating with libraries that are not natively built with
    CMake (so config files cannot be automatically generated for us).
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们结束关于安装的讨论之前，还有一个话题是有用的。到目前为止，我们只讨论了使用配置模式查找依赖项，但也有一种模式，我们在 [*第 6 章*](B21152_06.xhtml#_idTextAnchor152)
    中简单提到过，叫做 **模块模式**。模块模式在与没有使用 CMake 本地构建的库集成时很有用（因此无法为我们自动生成配置文件）。
- en: In `ch7/part-7/cmake`, a new file has been added called `Findmc-gol.cmake`,
    which acts as a find module file for the `mc-gol` library we’ll install in `ch7/part-7/lib/gol/install`.
    The find module file is technically redundant, as we can use the generated `mc-gol-config.cmake`
    file in config mode as before, however, imagine we’d built this library using
    a separate tool, and know where the build artifacts (library files) and header
    files are found.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `ch7/part-7/cmake` 目录中，添加了一个新的文件 `Findmc-gol.cmake`，它充当了我们将在 `ch7/part-7/lib/gol/install`
    中安装的 `mc-gol` 库的查找模块文件。该查找模块文件从技术上讲是多余的，因为我们可以像以前一样使用生成的 `mc-gol-config.cmake`
    文件进行配置模式，但假设我们使用一个单独的工具构建了这个库，并知道构建产物（库文件）和头文件的位置。
- en: 'To bring the `mc-gol` library into our build using `find_package`, we first
    need to review the `Findmc-gol.cmake` find module file. The first line uses the
    `find_path` CMake command to populate the `mc-gol_INCLUDE_DIR` variable:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将 `mc-gol` 库引入我们的构建中使用 `find_package`，我们首先需要查看 `Findmc-gol.cmake` 查找模块文件。第一行使用
    `find_path` CMake 命令来填充 `mc-gol_INCLUDE_DIR` 变量：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `mc-gol_PATH` variable is one we provide when configuring our main application
    to give the path relative to the include and library files (this is set in our
    `CMakePresets.json` file found in `ch7/part-7/app`). What’s essentially happening
    is a form of pattern matching, where the value we pass to `PATHS` matches the
    path to where the `include` files will be found.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mc-gol_PATH` 变量是我们在配置主应用程序时提供的，用来指定相对于包含文件和库文件的路径（这在 `ch7/part-7/app` 中的 `CMakePresets.json`
    文件中设置）。本质上，发生的情况是一种模式匹配，我们传递给 `PATHS` 的值与 `include` 文件所在的路径匹配。'
- en: 'The next line does a nearly identical operation, only this time instead of
    populating the `include` directory variable, it populates `mc-gol_LIBRARY`, holding
    the path to the library file using `find_library`:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一行执行几乎相同的操作，不过这次不是填充 `include` 目录变量，而是使用 `find_library` 填充 `mc-gol_LIBRARY`，保存库文件的路径：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `NAMES` argument expects the exact name of our library (multiple names can
    be provided here). We must also include the name of the debug version of our library
    with the `d` postfix as we’re using `CMAKE_DEBUG_POSTFIX` to disambiguate `Debug`
    and `Release` versions of our library. If we don’t do this, `find_library` will
    not find the debug version of our library. It’s also worth mentioning that `find_library`
    is not recursive, so we must provide the exact folder location where our library
    files are stored.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NAMES` 参数要求提供我们库的精确名称（这里可以提供多个名称）。我们还必须包含带有 `d` 后缀的库的调试版本名称，因为我们使用 `CMAKE_DEBUG_POSTFIX`
    来区分库的 `Debug` 和 `Release` 版本。如果我们不这么做，`find_library` 将找不到库的调试版本。还值得一提的是，`find_library`
    并不递归查找，所以我们必须提供库文件存储的精确文件夹位置。'
- en: Next comes a handy CMake-provided utility called `find_package_handle_standard_args`
    to handle proper messaging if the two earlier variables (`mc-gol_INCLUDE_DIR`
    and `mc-gol_LIBRARY`) cannot be found. It handles other details related to the
    `find_package` call too, though, for the moment, we don’t need to concern ourselves
    with them. To learn more about what the command is doing behind the scenes, you
    can visit [https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html](https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html)
    for more information.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来是一个非常有用的 CMake 提供的工具，名为 `find_package_handle_standard_args`，用于在找不到前面提到的两个变量（`mc-gol_INCLUDE_DIR`
    和 `mc-gol_LIBRARY`）时进行适当的消息处理。它还处理与 `find_package` 调用相关的其他细节，尽管目前我们不需要关注这些细节。如果你想了解更多关于该命令幕后做了什么，可以访问
    [https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html](https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html)
    获取更多信息。
- en: 'Finally, if the library was found, we call `add_library` with `minimal-cmake::game-of-life`
    as an imported target, and `set_target_properties`, associating the variables
    we populated with the `minimal-cmake::game-of-life` target:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果库文件被找到，我们会调用 `add_library` 并将 `minimal-cmake::game-of-life` 作为一个导入的目标，同时使用
    `set_target_properties` 将我们填充的变量与 `minimal-cmake::game-of-life` 目标关联起来：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding two commands are remarkably like the commands CMake generates
    for us in the `mc-gol-config-debug/release.cmake` and `mc-gol-config.cmake` files
    in `ch7/part-7/lib/gol/install/lib/cmake/mc-gol`. To keep things simple, we’re
    not doing as much to handle different configurations (debug versus release) or
    library types (static versus shared), but all this is possible if needed.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面提到的两个命令非常类似于 CMake 在 `ch7/part-7/lib/gol/install/lib/cmake/mc-gol` 文件夹中的 `mc-gol-config-debug/release.cmake`
    和 `mc-gol-config.cmake` 文件为我们生成的命令。为了简化，我们没有做太多工作来处理不同的配置（调试版与发布版）或库类型（静态与共享），但如果需要，这一切都是可以实现的。
- en: 'The penultimate step is to let CMake know where to find our new `Findmc-gol.cmake`
    file, and to fill in the `mc-gol_PATH` variable. We do both things in `ch7/part-7/app/CMakePresets.json`
    by updating `CMAKE_MODULE_PATH` to include the location of our new find module
    file, and setting `mc-gol_PATH` to where our library files are found:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 倒数第二步是让 CMake 知道在哪里找到我们新的 `Findmc-gol.cmake` 文件，并填写 `mc-gol_PATH` 变量。我们在 `ch7/part-7/app/CMakePresets.json`
    文件中完成这两项工作，通过更新 `CMAKE_MODULE_PATH` 以包含我们新找模块文件的位置，并设置 `mc-gol_PATH` 为我们库文件所在的位置：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final change is to our `CMakeLists.txt` file in `ch7/part-7/app`, where
    we must explicitly specify `MODULE`, instead of `CONFIG` for `mc-gol`:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的修改是在 `ch7/part-7/app` 中的 `CMakeLists.txt` 文件，我们必须明确指定 `MODULE`，而不是 `CONFIG`，用于
    `mc-gol`：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '...'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '-- Found mc-gol: /Users/tomhultonharrop/dev/minimal-cmake/ch7/part-'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '-- 找到 mc-gol: /Users/tomhultonharrop/dev/minimal-cmake/ch7/part-'
- en: 7/lib/gol/install/lib/libgame-of-lifed.dylib
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 7/lib/gol/install/lib/libgame-of-lifed.dylib
- en: '...'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
