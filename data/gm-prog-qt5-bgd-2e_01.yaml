- en: Introduction to Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt简介
- en: In this chapter, you will learn what Qt is and how it evolved. We will describe
    the structure of the Qt framework and the differences between its versions. Finally,
    you will learn how to decide which Qt licensing scheme is right for your projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Qt是什么以及它是如何演变的。我们将描述Qt框架的结构及其版本之间的差异。最后，你将学习如何决定哪种Qt许可方案适合你的项目。
- en: 'The main topics covered in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题包括：
- en: Qt history
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt历史
- en: Supported platforms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的平台
- en: Structure of the Qt framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt框架结构
- en: Qt versions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt版本
- en: Qt licenses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt许可
- en: A journey through time
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时光之旅
- en: The development of Qt started in 1991 by two Norwegians—Eirik Chambe-Eng and
    Haavard Nord—who were looking to create a cross-platform GUI programming toolkit.
    The first commercial client of Trolltech (the company that created the Qt toolkit)
    was the European Space Agency. The commercial use of Qt helped Trolltech sustain
    further development. At that time, Qt was available for two platforms—Unix/X11
    and Windows—however, developing with Qt for Windows required buying a proprietary
    license, which was a significant drawback in porting the existing Unix/Qt applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的发展始于1991年，由两位挪威人——Eirik Chambe-Eng和Haavard Nord——发起，他们希望创建一个跨平台的GUI编程工具包。Trolltech（创建Qt工具包的公司）的第一个商业客户是欧洲航天局。Qt的商业使用帮助Trolltech维持了进一步的发展。当时，Qt适用于两个平台——Unix/X11和Windows——然而，使用Qt为Windows进行开发需要购买专有许可，这在移植现有的Unix/Qt应用程序时是一个重大的缺点。
- en: A major step forward was the release of Qt Version 3.0 in 2001, which saw the
    initial support for Mac as well as an option to use Qt for Unix and Mac under
    a liberal GPL license. Still, Qt for Windows was only available under a paid license.
    Nevertheless, at that time, Qt had support for all the important players in the
    market—Windows, Mac, and Unix desktops, with Trolltech's mainstream product and
    Qt for embedded Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年Qt 3.0版本的发布是一个重要的进步，它最初支持Mac，并提供了一个在自由GPL许可下使用Qt为Unix和Mac的选项。然而，Qt for
    Windows仍然仅限于付费许可。尽管如此，在当时，Qt已经支持市场上的所有重要玩家——Windows、Mac和Unix桌面，包括Trolltech的主流产品和Qt
    for嵌入式Linux。
- en: In 2005, Qt 4.0 was released, which was a real breakthrough for a number of
    reasons. First, the Qt API was completely redesigned, which made it cleaner and
    more coherent. Unfortunately, at the same time, it made the existing Qt-based
    code incompatible with 4.0, and many applications needed to be rewritten from
    scratch or required much effort to be adapted to the new API. It was a difficult
    decision, but from the time perspective, we can see it was worth it. Difficulties
    caused by changes in the API were well countered by the fact that Qt for Windows
    was finally released under GPL. Many optimizations were introduced that made Qt
    significantly faster. Lastly, Qt, which was a single library until now, was divided
    into a number of modules. This allowed programmers to only link to the functionality
    that they used in their applications, reducing the memory footprint and the dependencies
    of their software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，Qt 4.0发布，这在多个方面都是一个真正的突破。首先，Qt API被完全重新设计，使其更加清晰和一致。不幸的是，与此同时，它使得现有的基于Qt的代码与4.0版本不兼容，许多应用程序需要从头开始重写或需要大量努力才能适应新的API。这是一个艰难的决定，但从时间角度来看，我们可以看到这是值得的。API变化带来的困难被Qt
    for Windows最终在GPL下发布的事实很好地抵消了。引入了许多优化，使Qt显著更快。最后，Qt，直到现在都是一个单一库，被分割成多个模块。这允许程序员仅链接到他们在应用程序中使用的功能，减少了内存占用和软件的依赖性。
- en: In 2008, Trolltech was sold to Nokia, which at that time was looking for a software
    framework to help it expand and replace its Symbian platform in the future. The
    Qt community became divided; some people were thrilled, others were worried after
    seeing Qt's development get transferred to Nokia. Either way, new funds were pumped
    into Qt, speeding up its progress and opening it for mobile platforms—Symbian
    and then Maemo and MeeGo.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，Trolltech被诺基亚收购，当时诺基亚正在寻找一个软件框架来帮助其扩展并未来取代其Symbian平台。Qt社区出现了分歧；看到Qt的开发转移到诺基亚后，一些人感到兴奋，而另一些人则感到担忧。无论如何，新的资金被注入Qt，加速了其发展，并使其对移动平台开放——首先是Symbian，然后是Maemo和MeeGo。
- en: For Nokia, Qt was not considered a product of its own, but rather a tool. Therefore,
    Nokia decided to introduce Qt to more developers by adding a very liberal **Lesser
    General Public License** (**LGPL**) that allowed the usage of the framework for
    both open and closed source development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诺基亚来说，Qt并不是其自己的产品，而是一种工具。因此，诺基亚决定通过添加一个非常自由的**较轻量级通用公共许可证**（**LGPL**）来向更多开发者介绍Qt，该许可证允许框架用于开源和闭源开发。
- en: Bringing Qt to new platforms and less powerful hardware required a new approach
    to create user interfaces and to make them more lightweight, fluid, and attractive.
    Nokia engineers working on Qt came up with a new declarative language to develop
    such interfaces—the **Qt Modeling Language** (**QML**) and a Qt runtime for it
    called **Qt Quick**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将Qt引入新的平台和较弱的硬件需要一种新的方法来创建用户界面，并使它们更轻量、流畅和吸引人。在Qt上工作的诺基亚工程师提出了一种新的声明性语言来开发此类界面——**Qt建模语言**（**QML**）以及为其提供的Qt运行时**Qt
    Quick**。
- en: The latter became the primary focus of the further development of Qt, practically
    stalling all non-mobile-related work, channeling all efforts to make Qt Quick
    faster, easier, and more widespread. Qt 4 was already in the market for seven
    years, and it became obvious that another major version of Qt had to be released.
    It was decided to bring more engineers to Qt by allowing anyone to contribute
    to the project. The Qt Project founded by Nokia in 2011 provided an infrastructure
    for code review and introduced an open governance model, allowing outside developers
    to participate in decision making.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 后者成为了Qt进一步发展的主要焦点，实际上阻碍了所有非移动相关的工作，将所有努力都集中在使Qt Quick更快、更简单、更广泛地使用。Qt 4已经在市场上存在了七年，显然必须发布Qt的另一个主要版本。决定通过允许任何人向项目贡献来吸引更多工程师。诺基亚于2011年成立的Qt项目为代码审查提供了基础设施，并引入了开放治理模式，允许外部开发者参与决策。
- en: Nokia did not manage to finish working on Qt 5.0\. As a result of an unexpected
    turnover of Nokia toward different technology in 2011, the Qt division was sold
    in mid 2012 to the Finnish company Digia that managed to complete the effort and
    release Qt 5.0, a completely restructured framework, in December of the same year.
    While Qt 5.0 introduced a lot of new features, it was mostly compatible with Qt
    4 and allowed developers to seamlessly migrate to the new major version.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 诺基亚未能完成Qt 5.0的开发工作。由于2011年诺基亚意外转向不同技术的转变，Qt部门在2012年中被出售给了芬兰公司Digia，该公司成功完成了这项工作，并在同年12月发布了Qt
    5.0，这是一个完全重构的框架。虽然Qt 5.0引入了许多新功能，但它与Qt 4大部分兼容，允许开发者无缝迁移到新的大版本。
- en: In 2014, Digia formed the Qt Company that is now responsible for Qt development,
    commercialization, and licensing. All Qt-related web resources scattered across
    Qt Project and Digia websites were eventually unified at [https://www.qt.io/](https://www.qt.io/).
    Qt continues to receive bug fixes, new features, and new platform support. This
    book is based on Qt 5.9, which was released in 2017.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，Digia成立了Qt公司，现在负责Qt的开发、商业化和许可。所有散布在Qt项目和Digia网站上的Qt相关网络资源最终都统一到了[https://www.qt.io/](https://www.qt.io/)。Qt继续接收错误修复、新功能和新的平台支持。本书基于2017年发布的Qt
    5.9。
- en: The cross-platform programming
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编程
- en: 'Qt is an application-programming framework that is used to develop cross-platform
    applications. What this means is that software written for one platform can be
    ported and executed on another platform with little or no effort. This is obtained
    by limiting the application source code to a set of calls to routines and libraries
    available to all the supported platforms, and by delegating all tasks that may
    differ between platforms (such as drawing on the screen and accessing system data
    or hardware) to Qt. This effectively creates a layered environment (as shown in
    the following diagram), where Qt hides all platform-dependent aspects from the
    application code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个用于开发跨平台应用程序的应用程序编程框架。这意味着为某个平台编写的软件可以轻松地移植到另一个平台执行，几乎不需要任何努力。这是通过限制应用程序源代码为所有支持的平台提供的例程和库的调用集来实现的，并通过将所有可能在平台之间不同的任务（如屏幕绘制、访问系统数据或硬件）委托给Qt来实现的。这实际上创建了一个分层环境（如下面的图所示），其中Qt隐藏了所有平台相关的方面，使其从应用程序代码中不可见：
- en: '![](img/38e091d7-0475-4051-9142-4d9fc1c14a04.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38e091d7-0475-4051-9142-4d9fc1c14a04.png)'
- en: Of course, at times, we need to use some functionality that Qt doesn't provide.
    In such situations, it is important to use a conditional compilation for platform-specific
    code. Qt provides a wide set of macros specifying the current platform. We will
    return to this topic in [Chapter 6](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml),
    *Qt Core Essentials*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时我们需要使用 Qt 不提供的一些功能。在这种情况下，使用条件编译来编写特定平台的代码非常重要。Qt 提供了一组广泛的宏，用于指定当前平台。我们将在
    [第 6 章](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml)，*Qt 核心基础*中回到这个话题。
- en: Supported platforms
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持的平台
- en: 'The framework is available for a number of platforms, ranging from classical
    desktop environments through embedded systems to mobile devices. Qt 5.9 supports
    the following platforms:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架适用于多种平台，从传统的桌面环境到嵌入式系统再到移动设备。Qt 5.9 支持以下平台：
- en: 'Desktop platforms: Windows, Linux, and macOS'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面平台：Windows、Linux 和 macOS
- en: 'Mobile platforms: UWP, Android, and iOS'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动平台：UWP、Android 和 iOS
- en: 'Embedded platforms: VxWorks, INTEGRITY, QNX, and Embedded Linux'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式平台：VxWorks、INTEGRITY、QNX 和嵌入式 Linux
- en: It is likely that the list of supported platforms will change in future Qt versions.
    You should refer to the Supported Platforms documentation page for your Qt version
    for detailed information about supported versions of operating systems and compilers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，在未来的 Qt 版本中，支持的平台列表将发生变化。你应该参考你 Qt 版本的“支持的平台”文档页面，以获取有关支持的操作系统和编译器版本的详细信息。
- en: GUI scalability
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI 可伸缩性
- en: For the most part of the history of desktop application development, specifying
    sizes of GUI elements in pixels was the common practice. While most operating
    systems had **dots per inch** (**DPI**) settings and APIs for taking it into account
    for a long time, the majority of existing displays had approximately the same
    DPI, so applications without high DPI support were common.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面应用程序开发的绝大部分历史中，以像素为单位指定 GUI 元素的大小是常见的做法。虽然大多数操作系统长期以来都有 **每英寸点数**（**DPI**）设置和相应的
    API 来考虑它，但大多数现有的显示器具有大约相同的 DPI，因此没有高 DPI 支持的应用程序很常见。
- en: The situation changed when high-DPI displays became more common in the market—most
    notably in mobile phones and tablets, but also in laptops and desktops. Now, even
    if you only target desktop platforms, you should think about supporting different
    DPI settings. When you target mobile devices, this becomes mandatory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当高DPI显示器在市场上变得更加普遍时，情况发生了变化——最显著的是在手机和平板电脑上，但笔记本电脑和台式机上也是如此。现在，即使你只针对桌面平台，你也应该考虑支持不同的DPI设置。当你针对移动设备时，这变得强制性的。
- en: If you are using Qt Widgets or Qt Quick, you often don't need to specify pixel
    sizes at all. Standard widgets and controls will use fonts, margins, and offsets
    defined by the style. If layouts are used, Qt will determine positions and sizes
    of all GUI items automatically. Avoid specifying constant sizes for GUI elements
    when possible. You may use sizes related to sizes of other GUI elements, the window,
    or the screen. Qt also provides an API for querying screen DPI, GUI style metrics,
    and font metrics, which should help to determine the optimal size for the current
    device.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Qt Widgets 或 Qt Quick，你通常根本不需要指定像素大小。标准小部件和控制将使用由样式定义的字体、边距和偏移量。如果使用布局，Qt
    将自动确定所有 GUI 元素的位置和大小。尽可能避免为 GUI 元素指定固定大小。你可以使用与其它 GUI 元素大小、窗口或屏幕大小相关的尺寸。Qt 还提供了一组
    API 用于查询屏幕 DPI、GUI 样式指标和字体指标，这有助于确定当前设备的最佳尺寸。
- en: On macOS and iOS, Qt Widgets and Qt Quick applications are scaled automatically
    using a virtual coordinate system. Pixel values in the application remain the
    same, but the GUI will scale according to the DPI of the current display. For
    example, if the pixel ratio is set to 2 (a common value for retina displays),
    creating a widget with 100 "pixels" width will produce a widget with 200 physical
    pixels. That means that the application doesn't have to be highly aware of DPI
    variations. However, this scaling does not apply to OpenGL, which always uses
    physical pixels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 iOS 上，Qt Widgets 和 Qt Quick 应用程序使用虚拟坐标系自动缩放。应用程序中的像素值保持不变，但 GUI 将根据当前显示的
    DPI 进行缩放。例如，如果像素比设置为 2（这是视网膜显示的常见值），则创建宽度为 100 "像素"的小部件将生成具有 200 个物理像素的小部件。这意味着应用程序不必高度关注
    DPI 变化。然而，这种缩放不适用于 OpenGL，它始终使用物理像素。
- en: Qt versions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 版本
- en: Each Qt version number (for example, 5.9.2) consists of major, minor, and patch
    components. Qt pays special attention to forwards and backwards compatibility
    between different versions. Small changes which are both forwards and backwards
    compatible (typically bug fixes without changing any API) are indicated by changing
    only the patch version. New minor versions usually bring in new API and features,
    so they are not forwards compatible. However, all minor versions are backwards
    binary and source compatible. This means that if you're transitioning to a newer
    minor version (for example, from 5.8 to 5.9), you should always be able to rebuild
    your project without changes. You can even transition to a new minor version without
    rebuilding, by only updating shared Qt libraries (or letting the package manager
    of the OS do that). Major releases indicate big changes and may break backwards
    compatibility. However, the latest major release (5.0) was mostly source compatible
    with the previous version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Qt版本号（例如，5.9.2）由主版本、次版本和补丁版本组成。Qt特别关注不同版本之间的向前和向后兼容性。只有当变更既向前又向后兼容（通常是无需更改任何API的bug修复）时，才会通过仅更改补丁版本来表示这些小变更。新的次版本通常引入新的API和功能，因此它们不是向前兼容的。然而，所有次版本都是向后二进制和源兼容的。这意味着如果您正在过渡到新的次版本（例如，从5.8到5.9），您应该始终能够不进行任何更改就重新构建您的项目。您甚至可以通过仅更新共享的Qt库（或让操作系统的包管理器执行此操作）来过渡到新的次版本，而无需重新构建。主要版本表示重大变更，可能会破坏向后兼容性。然而，最新的主要版本（5.0）与上一个版本在源代码级别上主要兼容。
- en: Qt declares **Long Term Support** (**LTS**) for certain versions. LTS versions
    receive patch-level releases with bug fixes and security fixes for three years.
    Commercial support is available for even longer periods. Current LTS releases
    at the time of writing are 5.6 and 5.9.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为某些版本声明**长期支持**（**LTS**）。LTS版本在三年内接收补丁级别的发布，包括bug修复和安全修复。商业支持可提供更长时间。截至撰写本文时，当前的LTS发布版本是5.6和5.9。
- en: Structure of Qt framework
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt框架的结构
- en: As Qt expanded over time, its structure evolved. At first, it was just a single
    library, then a set of libraries. When it became harder to maintain and update
    for the growing number of platforms that it supported, a decision was made to
    split the framework into much smaller modules contained in two module groups—Qt
    Essentials and Qt Add-ons. A major decision relating to the split was that each
    module could now have its own independent release schedule.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Qt随着时间的推移而扩展，其结构也发生了演变。最初，它只是一个单独的库，然后是一组库。当它难以维护和更新它所支持的不断增长的平台时，决定将框架拆分为包含在两个模块组中的更小的模块——Qt
    Essentials和Qt Add-ons。与拆分相关的一个主要决定是，每个模块现在都可以有自己的独立发布计划。
- en: Qt Essentials
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Essentials
- en: 'The Essentials group contains modules that are mandatory to implement for every
    supported platform. This implies that if you are implementing your system using
    modules from this group only, you can be sure that it can be easily ported to
    any other platform that Qt supports. The most important relations between Qt Essentials
    modules are shown in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Essentials组包含必须为每个支持的平台实现的模块。这意味着如果您仅使用此组中的模块来实现您的系统，您可以确信它可以轻松地移植到Qt支持的任何其他平台。Qt
    Essentials模块之间最重要的关系如下所示：
- en: '![](img/79abeacb-c7bb-4486-a20e-de558d8e5e3b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79abeacb-c7bb-4486-a20e-de558d8e5e3b.png)'
- en: 'Some of the modules are explained as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对一些模块的解释：
- en: The **Qt Core** module contains the most basic Qt functionality that all other
    modules rely on. It provides support for event processing, meta-objects, data
    I/O, text processing, and threading. It also brings a number of frameworks, such
    as the Animation framework, the State Machine framework, and the Plugin framework.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Core**模块包含所有其他模块所依赖的最基本的Qt功能。它提供对事件处理、元对象、数据I/O、文本处理和线程的支持。它还带来了一些框架，例如动画框架、状态机框架和插件框架。'
- en: The **Qt GUI** module provides basic cross-platform support to build user interfaces.
    It contains the common functionality required by more high-level GUI modules (Qt
    Widgets and Qt Quick). Qt GUI contains classes that are used to manipulate windows
    that can be rendered using either the raster engine or OpenGL. Qt supports desktop
    OpenGL as well as OpenGL ES 1.1 and 2.0.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt GUI**模块提供了构建用户界面的基本跨平台支持。它包含更多高级GUI模块（Qt Widgets和Qt Quick）所需的功能。Qt GUI包含用于操作可以使用光栅引擎或OpenGL渲染的窗口的类。Qt支持桌面OpenGL以及OpenGL
    ES 1.1和2.0。'
- en: '**Qt Widgets** extends the GUI module with the ability to create a user interface
    using widgets, such as buttons, edit boxes, labels, data views, dialog boxes,
    menus, and toolbars, which are arranged using a special layout engine. Qt Widgets
    utilizes Qt''s event system to handle input events in a cross-platform way. This
    module also contains the implementation of an object-oriented 2D graphics canvas
    called Graphics View.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Widgets** 通过使用小部件（如按钮、编辑框、标签、数据视图、对话框、菜单和工具栏）以及使用特殊布局引擎来创建用户界面，扩展了 GUI
    模块。Qt Widgets 利用 Qt 的事件系统以跨平台的方式处理输入事件。此模块还包含一个面向对象的 2D 图形画布的实现，称为 Graphics View。'
- en: '**Qt Quick** is an extension of Qt GUI, which provides a means to create lightweight
    fluid user interfaces using QML. It is described in more detail later in this
    chapter, as well as in [Chapter 11](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml)*,
    Introduction to Qt Quick*.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Quick** 是 Qt GUI 的扩展，它提供了使用 QML 创建轻量级流畅用户界面的方法。它将在本章后面以及 [第 11 章](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml)*，Qt
    Quick 简介* 中更详细地描述。'
- en: '**Qt QML** is an implementation of the QML language used in Qt Quick. It also
    provides API to integrate custom C++ types into QML''s JavaScript engine and to
    integrate QML code with C++.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt QML** 是 Qt Quick 中使用的 QML 语言的实现。它还提供了 API，用于将自定义 C++ 类型集成到 QML 的 JavaScript
    引擎中，以及将 QML 代码与 C++ 集成。'
- en: '**Qt Network** brings support for IPv4 and IPv6 networking using TCP and UDP.
    It also contains HTTP, HTTPS, FTP clients, and it extends support for DNS lookups.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Network** 提供了对 IPv4 和 IPv6 网络的支持，使用 TCP 和 UDP。它还包含 HTTP、HTTPS、FTP 客户端，并扩展了对
    DNS 查询的支持。'
- en: '**Qt Multimedia** allows programmers to access audio and video hardware (including
    cameras and FM radio) to record and play multimedia content. It also features
    3D positional audio support.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Multimedia** 允许程序员访问音频和视频硬件（包括摄像头和 FM 收音机）以录制和播放多媒体内容。它还提供了 3D 位置音频支持。'
- en: '**Qt SQL** brings a framework that is used to manipulate SQL databases in an
    abstract way.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt SQL** 提供了一个用于以抽象方式操作 SQL 数据库的框架。'
- en: There are also other modules in this group, but we will not focus on them in
    this book. If you want to learn more about them, you can look them up in the Qt
    reference manual.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此组中还有其他模块，但在此书中我们将不关注它们。如果您想了解更多关于它们的信息，可以在 Qt 参考手册中查找。
- en: Qt Add-ons
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Add-ons
- en: 'This group contains modules that are optional for any platform. This means
    that if a particular functionality is not available on some platform or there
    is nobody willing to spend time working on this functionality for a platform,
    it will not prevent Qt from supporting this platform. We''ll mention some of the
    most important modules here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此组包含任何平台都可选的模块。这意味着如果某些平台上的特定功能不可用，或者没有人愿意花时间为此平台上的此功能工作，这不会阻止 Qt 支持该平台。我们将在下面提到一些最重要的模块：
- en: '**Qt Concurrent**: This handles multi-threaded processing'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Concurrent**：这处理多线程处理'
- en: '**Qt 3D**: This provides high-level OpenGL building blocks'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt 3D**：这提供了高级 OpenGL 构建块'
- en: '**Qt Gamepad**: This enables applications to support gamepad hardware'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Gamepad**：这使应用程序能够支持游戏手柄硬件'
- en: '**Qt D-Bus**: This allows your application to communicate with others via the
    D-Bus mechanism'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt D-Bus**：这允许您的应用程序通过 D-Bus 机制与其他应用程序进行通信'
- en: '**Qt XML Patterns**: This helps us to access XML data'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt XML Patterns**：这帮助我们访问 XML 数据'
- en: Many other modules are also available, but we will not cover them here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他模块也可用，但在此处我们将不涉及它们。
- en: qmake
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: qmake
- en: Some Qt features require additional build steps during the compilation and linking
    of the project. For example, **Meta-Object Compiler** (**moc**), **User Interface
    Compiler** (**uic**), and **Resource Compiler** (**rcc**) may need to be executed
    to handle Qt's C++ extensions and features. For convenience, Qt provides the **qmake**
    executable that manages your Qt project and generates files required for building
    it on the current platform (such as Makefile for the make utility). qmake reads
    the project's configuration from a project file with the `.pro` extension. Qt
    Creator (the IDE that comes with Qt) automatically creates and updates that file,
    but it can be edited manually to alter the build process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Qt 功能在项目的编译和链接过程中需要额外的构建步骤。例如，**元对象编译器**（**moc**）、**用户界面编译器**（**uic**）和**资源编译器**（**rcc**）可能需要执行以处理
    Qt 的 C++ 扩展和功能。为了方便，Qt 提供了 **qmake** 可执行文件，该文件管理您的 Qt 项目并生成在当前平台上构建它所需的文件（例如，make
    工具的 Makefile）。qmake 从具有 `.pro` 扩展名的项目文件中读取项目的配置。Qt Creator（Qt 伴随的 IDE）自动创建和更新该文件，但可以手动编辑以更改构建过程。
- en: Alternatively, CMake can be used to organize and build the project. Qt provides
    CMake plugins for performing all the necessary build actions. Qt Creator also
    has fairly good support for CMake projects. CMake is more advanced and powerful
    than qmake, but it's probably not needed for projects with a simple build process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 CMake 来组织和构建项目。Qt 提供了用于执行所有必要构建操作的 CMake 插件。Qt Creator 也对 CMake 项目有相当好的支持。CMake
    比 qmake 更高级、更强大，但对于具有简单构建过程的项目来说，可能并不需要。
- en: Modern C++ standards
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代C++标准
- en: You can use modern C++ in your Qt projects. Qt's build tool (qmake) allows you
    to specify the C++ standard you want to target. Qt itself introduces an improved
    and extended API by using new C++ features when possible. For example, it uses
    ref-qualified member functions and introduces methods accepting initializer lists
    and rvalue references. It also introduces new macros that help you deal with compilers
    that may or may not support new standards.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的 Qt 项目中使用现代 C++。Qt 的构建工具（qmake）允许您指定要针对的 C++ 标准版本。Qt 本身通过尽可能使用新的 C++ 特性引入了改进和扩展的
    API。例如，它使用 ref-qualified 成员函数，并引入了接受初始化列表和右值引用的方法。它还引入了新的宏，帮助您处理可能或可能不支持新标准的编译器。
- en: If you use a recent C++ revision, you have to pay attention to the compiler
    versions you use across the target platforms because older compilers may not support
    the new standard. In this book, we will assume C++11 support, as it is widely
    available already. Thus, we'll use C++11 features in our code, such as range-based
    `for` loops, scoped enumerations, and lambda expressions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是最新的 C++ 版本，您必须注意您在目标平台上的编译器版本，因为较旧的编译器可能不支持新的标准。在本书中，我们将假设支持 C++11，因为它已经广泛可用。因此，我们将使用
    C++11 的特性，例如基于范围的 `for` 循环、作用域枚举和 lambda 表达式。
- en: Choosing the right license
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的许可证
- en: Qt is available under two different licensing schemes—you can choose between
    a commercial license and an open source one. We will discuss both here to make
    it easier for you to choose. If you have any doubts regarding whether a particular
    licensing scheme applies to your use case, you better consult a professional lawyer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 在两种不同的许可方案下可用——您可以选择商业许可或开源许可。我们将在这里讨论两者，以便您更容易选择。如果您对特定许可方案是否适用于您的用例有疑问，您最好咨询专业律师。
- en: An open source license
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源许可证
- en: The advantage of open source licenses is that we don't have to pay anyone to
    use Qt; however, the downside is that there are some limitations imposed on how
    it can be used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开源许可证的优势是我们不必为使用 Qt 向任何人付费；然而，缺点是它对如何使用 Qt 施加了一些限制。
- en: When choosing the open source edition, we have to choose between GPL 3.0 and
    LGPL 3\. Since LGPL is more liberal, in this chapter we will focus on it. Choosing
    LGPL allows you to use Qt to implement systems that are either open source or
    closed source—you don't have to reveal the sources of your application to anyone
    if you don't want to.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择开源版本时，我们必须在 GPL 3.0 和 LGPL 3.0 之间进行选择。由于 LGPL 更为宽松，在本章中我们将重点关注它。选择 LGPL 允许您使用
    Qt 来实现开源或闭源的系统——如果您不想的话，不需要向任何人透露您应用程序的源代码。
- en: 'However, there are a number of restrictions you need to be aware of:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些限制您需要了解：
- en: Any modifications that you make to Qt itself need to be made public, for example,
    by distributing source code patches alongside your application binary.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Qt 本身进行的任何修改都需要公开，例如，通过将源代码补丁与您的应用程序二进制文件一起分发。
- en: LGPL requires that users of your application must be able to replace Qt libraries
    that you provide them with other libraries with the same functionality (for example,
    a different version of Qt). This usually means that you have to dynamically link
    your application against Qt so that the user can simply replace Qt libraries with
    his own. You should be aware that such substitutions can decrease the security
    of your system; thus, if you need it to be very secure, open source may not be
    the option for you.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LGPL 要求您的应用程序用户能够用具有相同功能的其他库（例如，Qt 的不同版本）替换您提供的 Qt 库。这通常意味着您必须将您的应用程序动态链接到 Qt，以便用户可以简单地用自己的
    Qt 库替换它们。您应该意识到这种替换可能会降低您系统的安全性；因此，如果您需要非常安全，开源可能不是您的选择。
- en: LGPL is incompatible with a number of licenses, especially proprietary ones,
    so it is possible that you won't be able to use Qt with some commercial components.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LGPL 与许多许可证不兼容，特别是专有许可证，因此您可能无法使用 Qt 与某些商业组件一起使用。
- en: Some Qt modules may have different licensing restrictions. For example, Qt Charts,
    Qt Data Visualization, and Qt Virtual Keyboard modules are not available under
    LGPL and can only be used under GPL or the commercial license.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Qt模块可能有不同的许可限制。例如，Qt Charts、Qt 数据可视化和Qt 虚拟键盘模块在LGPL下不可用，只能使用GPL或商业许可证。
- en: The open source edition of Qt can be downloaded directly from [https://www.qt.io](https://www.qt.io).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的开源版本可以直接从[https://www.qt.io](https://www.qt.io)下载。
- en: A commercial license
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业许可证
- en: Most of the restrictions are lifted if you decide to buy a commercial license
    for Qt. This allows you to keep the entire source code a secret, including any
    changes you may want to incorporate into Qt. You can freely link your application
    statically against Qt, which means fewer dependencies, a smaller deployment bundle
    size, and a faster startup. It also increases the security of your application,
    as end users cannot inject their own code into the application by replacing a
    dynamically loaded library with their own.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定购买Qt的商业许可证，大多数限制都会被解除。这允许你将整个源代码保密，包括你可能想要整合到Qt中的任何更改。你可以自由地将你的应用程序静态链接到Qt，这意味着更少的依赖项、更小的部署包大小和更快的启动速度。这也有助于提高你应用程序的安全性，因为最终用户不能通过用自己的库替换动态加载的库来向应用程序中注入自己的代码。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the architecture of Qt. We saw how it evolved
    over time and we had a brief overview of what it looks like now. Qt is a complex
    framework and we will not manage to cover it all, as some parts of its functionality
    are more important for game programming than others that you can learn on your
    own in case you ever need them. Now that you know what Qt is, we can proceed with
    the next chapter, where you will learn how to install Qt on to your development
    machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了Qt的架构。我们看到了它是如何随着时间的推移而演变的，并对它现在的样子有一个简要的了解。Qt是一个复杂的框架，我们不可能涵盖所有内容，因为其功能的一些部分对于游戏编程来说比其他部分更重要，这些部分你可能需要时可以自己学习。现在你已经知道了Qt是什么，我们可以继续到下一章，在那里你将学习如何在你的开发机器上安装Qt。
