- en: Design Patterns and C++
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式和C++
- en: C++ is not just an object-oriented language, and it doesn't just offer dynamic
    polymorphism, so design in C++ is not just about the Gang of Four patterns. In
    this chapter, you will learn about the commonly used C++ idioms and design patterns
    and where to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++不仅仅是一种面向对象的语言，它不仅仅提供动态多态性，因此在C++中设计不仅仅是关于四人帮的模式。在本章中，你将学习关于常用的C++习语和设计模式以及它们的使用场景。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Writing idiomatic C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写习惯用法的C++
- en: Curiously recurring template pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异递归模板模式
- en: Creating objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象
- en: Tracking state and visiting objects in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪状态和访问对象在C++中
- en: Dealing with memory efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效处理内存
- en: That's quite a list! Let's not waste time and jump right in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的列表！让我们不浪费时间，直接开始吧。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code from this chapter requires the following tools to build and run:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码需要以下工具来构建和运行：
- en: A compiler supporting C++20
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持C++20的编译器
- en: CMake 3.15+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.15+
- en: The source code snippets from the chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码片段可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter06)找到。
- en: Writing idiomatic C++
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写习惯用法的C++
- en: If you're familiar with object-oriented programming languages, you must have
    heard of the Gang of Four's design patterns. While they can be implemented in
    C++ (and often are), this multi-paradigm language often takes a different approach
    for achieving the same goals. If you want to beat the performance of the so-called
    coffee-based languages such as Java or C#, sometimes paying the cost of virtual
    dispatch is too much. In many cases, you'll know upfront what types you'll deal
    with. If that happens, you can often write more performant code using the tools
    available both in the language and in the standard library. Out of many, there's
    a group that we will start this chapter with – the language idioms. Let's start
    our journey by looking at a few of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象的编程语言，你一定听说过四人帮的设计模式。虽然它们可以在C++中实现（而且经常被实现），但这种多范式语言通常采用不同的方法来实现相同的目标。如果你想要超越Java或C#等所谓的基于咖啡的语言的性能，有时付出虚拟调度的代价太大了。在许多情况下，你会提前知道你将处理的类型。如果发生这种情况，你通常可以使用语言和标准库中提供的工具编写更高性能的代码。其中有一个我们将从本章开始的一组
    - 语言习语。让我们通过查看其中一些来开始我们的旅程。
- en: By definition, an idiom is a construct that recurs in a given language, an expression
    that's specific to the language. "Native speakers" of C++ should know its idioms
    by intuition. We already mentioned smart pointers, which are one of the most common
    ones. Let's now discuss a similar one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，习语是在特定语言中反复出现的构造，是特定于该语言的表达。C++的“母语者”应该凭直觉知道它的习语。我们已经提到智能指针，这是最常见的之一。现在让我们讨论一个类似的。
- en: Automating scope exit actions using RAII guards
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RAII保护自动化作用域退出操作
- en: One of the most powerful expressions in C++ is the brace closing a scope. This
    is the place where destructors get called and the RAII magic happens. To tame
    this spell, you don't need to use smart pointers. All you need is an RAII guard
    – an object that, when constructed, will remember what it needs to do when destroyed.
    This way, regardless of whether the scope exits normally or by an exception, the
    work will happen automatically.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++中最强大的表达之一是用于关闭作用域的大括号。这是析构函数被调用和RAII魔术发生的地方。为了驯服这个咒语，你不需要使用智能指针。你只需要一个RAII保护
    - 一个对象，当构造时，将记住它在销毁时需要做什么。这样，无论作用域是正常退出还是由异常退出，工作都会自动发生。
- en: 'The best part – you don''t even need to write an RAII guard from scratch. Well-tested
    implementation already exists in various libraries. If you''re using GSL, which
    we mentioned in the previous chapter, you can use `gsl::finally()`. Consider the
    following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分 - 你甚至不需要从头开始编写一个RAII保护。经过充分测试的实现已经存在于各种库中。如果你使用我们在上一章中提到的GSL，你可以使用`gsl::finally()`。考虑以下例子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we take a timestamp at the start of the function and another one at the
    end. Try running this example and see how uncommenting the `throw` statement affects
    the execution. In both cases, our RAII guard will properly print the execution
    time (assuming the exception is caught somewhere).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在函数开始时取一个时间戳，然后在结束时再取一个。尝试运行这个例子，看看取消注释`throw`语句如何影响执行。在这两种情况下，我们的RAII保护将正确打印执行时间（假设异常在某处被捕获）。
- en: Let's now discuss a few more popular C++ idioms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些更流行的C++习语。
- en: Managing copyability and movability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理可复制性和可移动性
- en: When designing a new type in C++, it's important to decide whether it should
    be copyable and movable. Even more important is implementing those semantics for
    a class correctly. Let's discuss those issues now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中设计新类型时，重要的是决定它是否可以复制和移动。更重要的是正确实现类的语义。现在让我们讨论这些问题。
- en: Implementing non-copyable types
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现不可复制类型
- en: 'There are cases when you don''t want your class to be copied. Classes that
    are very expensive to copy are one example. Another would be those subject to
    error due to slicing. In the past, a common way to prevent such objects from copying
    was by using the non-copyable idiom:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你不希望你的类被复制。非常昂贵的复制类是一个例子。另一个例子是由于切片而导致错误的类。过去，防止这些对象复制的常见方法是使用不可复制的习语：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note, however, that such a class is also not movable, although it''s easy to
    not notice it when reading the class definition. A better approach would be to
    just add the two missing members (the move constructor and move assignment operator)
    explicitly. As a rule of thumb, when declaring such special member functions,
    always declare all of them. This means that from C++11 onward, the preferred way
    would be to write the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这样的类也是不可移动的，尽管在阅读类定义时很容易忽略这一点。更好的方法是明确地添加两个缺失的成员（移动构造函数和移动赋值运算符）。作为一个经验法则，当声明这样的特殊成员函数时，总是声明所有这些函数。这意味着从C++11开始，首选的方法是编写以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, the members were defined directly in the target type without the
    helper `NonCopyable` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，成员是直接在目标类型中定义的，而没有辅助的`NonCopyable`类型。
- en: Adhering to the rules of three and five
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循三和五法则
- en: 'There''s one more thing to mention when discussing special member functions:
    if you don''t delete them and are providing your own implementations, most probably
    you need to define all of them, including the destructor, too. This was called
    the rule of three in C++98 (due to the need to define three functions: the copy
    constructor, the copy assignment operator, and the destructor) and since C++11''s
    move operations, it is now replaced by the rule of five (the two additional ones
    being the move constructor and the move assignment operator). Applying these rules
    can help you avoid resource management issues.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论特殊成员函数时，还有一件事需要提到：如果您不删除它们并提供自己的实现，很可能需要定义所有这些函数，包括析构函数。在C++98中，这被称为三法则（由于需要定义三个函数：复制构造函数、复制赋值运算符和析构函数），自C++11的移动操作以来，它现在被五法则取代（另外两个是移动构造函数和移动赋值运算符）。应用这些规则可以帮助您避免资源管理问题。
- en: Adhering to the rule of zero
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循零法则
- en: 'If, on the other hand, you''re good to go with just the default implementations
    of all special member functions, then just don''t declare them at all. This is
    a clear sign that you want the default behavior. It''s also the least confusing.
    Consider the following type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您只使用所有特殊成员函数的默认实现，那么根本不要声明它们。这清楚地表明您想要默认行为。这也是最不令人困惑的。考虑以下类型：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Even though we defaulted all the members, the class is still non-copyable.
    That''s because it has a `unique_ptr` member that is non-copyable itself. Fortunately,
    Clang will warn you about this, but GCC does not by default. A better approach
    would be to apply the rule of zero and instead write the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们默认了所有成员，但这个类仍然是不可复制的。这是因为它有一个`unique_ptr`成员，它本身是不可复制的。幸运的是，Clang会警告您，但GCC默认情况下不会。更好的方法是应用零规则，而不是写以下内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we have less boilerplate code and by looking at the members, it's easier
    to notice that it does not support copying.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更少的样板代码，并且通过查看成员，更容易注意到它不支持复制。
- en: There's one more important idiom to know about when it comes to copying that
    you'll get to know in a minute. Before that happens, we shall touch on yet another
    idiom, which can (and should) be used to implement the first one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论复制时，还有一个重要的习惯用法需要了解，您将在一分钟内了解到。在此之前，我们将涉及另一个习惯用法，可以（并且应该）用于实现第一个习惯用法。
- en: Using hidden friends
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用隐藏友元
- en: In essence, hidden friends are non-member functions defined in the body of the
    type that declares them as a friend. This makes such functions impossible to call
    in ways other than by using **Argument-Dependent Lookup** (**ADL**), effectively
    making them hidden. Because they reduce the number of overloads a compiler considers,
    they also speed up compilation. A bonus of this is that they provide shorter error
    messages than their alternatives. Their last interesting property is that they
    cannot be called if an implicit conversion should happen first. This can help
    you avoid such accidental conversions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，隐藏的友元是在声明它们为友元的类型的主体中定义的非成员函数。这使得这样的函数无法通过其他方式调用，而只能通过**参数相关查找**（**ADL**）来调用，有效地使它们隐藏起来。因为它们减少了编译器考虑的重载数量，它们也加快了编译速度。这样做的额外好处是，它们提供比其替代品更短的错误消息。它们的最后一个有趣的特性是，如果应该首先发生隐式转换，它们就不能被调用。这可以帮助您避免这种意外转换。
- en: Although friends in C++ are generally not recommended, things look differently
    for hidden friends; if the advantages from the previous paragraph don't convince
    you, you should also know that they should be the preferred way of implementing
    customization points. Now, you're probably wondering what those customization
    points are. Briefly speaking, they are callables used by the library code that
    the user can specialize in for their types. The standard library reserves quite
    a lot of names for those, such as `begin`, `end`, and their reverse and `const`
    variations, `swap`, `(s)size`, `(c)data`, and many operators, among others. If
    you decide to provide your own implementation for any of those customization points,
    it had better behave as the standard library expects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在C++中通常不建议使用友元，但对于隐藏的友元，情况看起来不同；如果前面段落中的优势不能说服您，您还应该知道，它们应该是实现定制点的首选方式。现在，您可能想知道这些定制点是什么。简而言之，它们是库代码使用的可调用对象，用户可以为其类型进行专门化。标准库为这些保留了相当多的名称，例如`begin`、`end`及其反向和`const`变体，`swap`、`(s)size`、`(c)data`和许多运算符，等等。如果您决定为任何这些定制点提供自己的实现，最好是符合标准库的期望。
- en: 'Okay, enough theory for now. Let''s see how to provide a customization point
    specialization using a hidden friend in practice. For example, let''s create an
    oversimplified class to manage arrays of types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在理论够了。让我们看看如何在实践中使用隐藏的友元来提供定制点专门化。例如，让我们创建一个过于简化的类来管理类型的数组：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we defined a destructor, which means we should provide other
    special member functions too. We implement them in the next section, using our
    hidden friend `swap`. Note that despite being declared in the body of our `Array`
    class, this `swap` function is still a non-member function. It accepts two `Array`
    instances and doesn't have access to this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们定义了一个析构函数，这意味着我们还应该提供其他特殊成员函数。我们将在下一节中使用我们隐藏的友元“swap”来实现它们。请注意，尽管在我们的“Array”类的主体中声明，但这个“swap”函数仍然是一个非成员函数。它接受两个“Array”实例，并且没有访问权限。
- en: Using the `std::swap` line makes the compiler first look for `swap` functions
    in the namespaces of the swapped members. If not found, it will fall back to `std::swap`.
    This is called the *two-step ADL and fallback idiom*, or *two-step* for short,
    because we first make `std::swap` visible, and then call `swap`. The `noexcept`
    keyword tells the compiler that our `swap` function does not throw, which allows
    it to generate faster code in certain situations. Aside from `swap`, always mark
    your default and move constructors with this keyword too for the same reason.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“std::swap”行使编译器首先在交换成员的命名空间中查找“swap”函数。如果找不到，它将退回到“std::swap”。这被称为“两步ADL和回退惯用语”，或简称为“两步”，因为我们首先使“std::swap”可见，然后调用“swap”。“noexcept”关键字告诉编译器我们的“swap”函数不会抛出异常，这允许它在某些情况下生成更快的代码。除了“swap”，出于同样的原因，始终使用这个关键字标记默认和移动构造函数。
- en: Now that we have a `swap` function, let's use it to apply another idiom to our
    `Array` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有一个“swap”函数，让我们使用它来应用另一个惯用语到我们的“Array”类。
- en: Providing exception safety using the copy-and-swap idiom
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用复制和交换惯用语提供异常安全性
- en: As we mentioned in the previous section, because our `Array` class defines a
    destructor, according to the rule of five, it should also define other special
    member functions. In this section, you'll learn about an idiom that lets us do
    this without boilerplate, while also adding strong exception safety as a bonus.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，因为我们的“Array”类定义了一个析构函数，根据五法则，它还应该定义其他特殊成员函数。在本节中，您将了解一种惯用语，让我们可以在没有样板文件的情况下做到这一点，同时还额外提供强异常安全性。
- en: 'If you''re not familiar with the exception safety levels, here''s a quick recap
    of the levels your functions and types can offer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉异常安全级别，这里是您的函数和类型可以提供的级别的快速回顾：
- en: '**No guarantee**: This is the most basic level. No guarantees are made about
    the state of your object after an exception is thrown while it''s being used.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无保证**：这是最基本的级别。在对象在使用时抛出异常后，不对其状态做任何保证。'
- en: '**Basic exception safety**: Side effects are possible, but your object won''t
    leak any resources, will be in a valid state, and will contain valid data (not
    necessarily the same as before the operation). Your types should always offer
    at least this level.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本异常安全性**：可能会有副作用，但您的对象不会泄漏任何资源，将处于有效状态，并且将包含有效数据（不一定与操作之前相同）。您的类型应该至少提供这个级别。'
- en: '**Strong exception safety**: No side effects will happen. The object''s state
    will be the same as before the operation.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强异常安全性**：不会发生任何副作用。对象的状态将与操作之前相同。'
- en: '**No-throw guarantee**: Operations will always succeed. If an exception is
    thrown during the operation, it will be caught and handled internally so the operation
    does not throw exceptions outside. Such operations can be marked as `noexcept`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无抛出保证**：操作将始终成功。如果在操作期间抛出异常，它将被内部捕获和处理，因此操作不会在外部抛出异常。此类操作可以标记为“noexcept”。'
- en: 'So, how can we kill these two birds with one stone and write no-boilerplate
    special members while also providing strong exception safety? It''s pretty easy,
    actually. As we have our `swap` function, let''s use it to implement the assignment
    operators:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何一举两得地写出无样板文件的特殊成员，并提供强异常安全性呢？实际上很容易。由于我们有我们的“swap”函数，让我们使用它来实现赋值运算符：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our case, a single operator suffices for both the copy and move assignments.
    In the copy case, we take the parameter by value, so this is where a temporary
    copy is being made. Then, all we need to do is swap the members. We have not only
    achieved strong exception safety but were also able to not throw from the assignment
    operator's body. However, an exception can still be thrown right before the function
    gets called, when the copy happens. In the case of the move assignment, no copy
    is made as taking by value will just take the moved object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，一个运算符就足够了，既适用于复制赋值，也适用于移动赋值。在复制的情况下，我们通过值来获取参数，因此这是临时复制正在进行的地方。然后，我们所需要做的就是交换成员。我们不仅实现了强异常安全性，而且还能够在赋值运算符的主体中不抛出异常。然而，在函数被调用之前，当复制发生时，仍然可能抛出异常。在移动赋值的情况下，不会进行复制，因为通过值获取将只获取移动的对象。
- en: 'Now, let''s define the copy constructor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义复制构造函数：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This guy can throw depending on `T` and because it allocates memory. Now, let''s
    define the move constructor too:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以根据“T”和分配内存而抛出异常。现在，让我们也定义移动构造函数：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we use `std::exchange` so that our members get initialized and `other`'s
    members get cleaned up, all on the initialization list. The constructor is declared
    `noexcept` for performance reasons. For instance, `std::vector` can move their
    elements when they grow only if they're `noexcept` move-constructible, and will
    copy otherwise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用“std::exchange”来初始化我们的成员，并在初始化列表上清理“other”的成员。构造函数声明为“noexcept”是出于性能原因。例如，如果“std::vector”只在移动构造时是“noexcept”可移动的，否则将进行复制。
- en: That's it. We've created an `array` class providing strong exception safety
    with little effort and no code duplication.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们创建了一个提供强异常安全性的“array”类，而且几乎没有代码重复。
- en: Let's now tackle yet another C++ idiom, which can be spotted in a few places
    in the standard library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来解决另一个C++惯用语，它可以在标准库的几个地方找到。
- en: Writing niebloids
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写niebloids
- en: Niebloids, named after Eric Niebler, are a type of function object that the
    standard uses for customization points from C++17 onward. With the introduction
    of standard ranges described in [Chapter 5](315eea2a-c029-4bc3-a159-4f897d393639.xhtml)*,
    Leveraging C++ Language Features*, their popularity started to grow, but they
    were first proposed by Niebler back in 2014\. **Their purpose is to disable ADL
    where it's not wanted so overloads from other namespaces are not considered by
    the compiler**. Remember the *two-step idiom* from the previous sections? Because
    it's inconvenient and easy to forget, the notion of *customization point objects*
    was introduced. In essence, these are function objects performing the *two-step*
    for you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Niebloids，以Eric Niebler的名字命名，是C++17及以后标准使用的一种函数对象类型，用于定制点。随着标准范围的引入，它们的流行度开始增长，但它们最早是在2014年由Niebler提出的。它们的目的是在不需要时禁用ADL，因此编译器不会考虑来自其他命名空间的重载。还记得前面章节中的*两步法*吗？由于它不方便且容易忘记，所以引入了*定制点对象*的概念。本质上，这些是为您执行*两步法*的函数对象。
- en: If your libraries should provide customization points, it's probably a good
    idea to implement them using niebloids. All the customization points in the standard
    library introduced in C++17 and later are implemented this way for a reason. Even
    if you just need to create a function object, still consider using niebloids.
    They offer all the good parts of ADL while reducing the drawbacks. They allow
    specialization and together with concepts they give you a way to customize the
    overload set of your callables. They also allow better customization of algorithms,
    all at the slight cost of writing a bit more verbose code than usual.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的库应该提供定制点，最好使用niebloids来实现它们。C++17及以后引入的标准库中的所有定制点都是出于某种原因以这种方式实现的。即使您只需要创建一个函数对象，仍然要考虑使用niebloids。它们提供了ADL的所有优点，同时减少了缺点。它们允许特化，并且与概念一起，它们为您提供了一种定制可调用函数重载集合的方法。它们还允许更好地定制算法，只是写的代码比通常多一点。
- en: 'In this section, we''ll create a simple range algorithm that we''ll implement
    as a niebloid. Let''s call it `contains` as it will simply return a Boolean value
    denoting whether a given element is found in the range or not. First, let''s create
    the function object itself, starting with the declaration of its iterator-based
    call operator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个简单的范围算法，我们将其实现为niebloid。让我们称之为`contains`，因为它将简单地返回一个布尔值，表示范围中是否找到了给定的元素。首先，让我们创建函数对象本身，从其基于迭代器的调用操作符的声明开始：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It looks verbose, but all this code has a purpose. We make our struct `final`
    to aid the compiler in generating more efficient code. If you look at the template
    parameters, you'll see an iterator and a sentinel – the basic building blocks
    of each standard range. The sentinel is often an iterator, but it can be any semiregular
    type that can be compared with the iterator (a semiregular type is copyable and
    default-initializable). Next, `T` is the type of element to search for, while
    `Proj` denotes a projection – an operation to apply to each range element before
    comparison (the default of `std::identity` simply passes its input as output).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '看起来冗长，但所有这些代码都有其目的。我们使我们的结构`final`以帮助编译器生成更高效的代码。如果您查看模板参数，您会看到迭代器和哨兵 - 每个标准范围的基本构建块。哨兵通常是一个迭代器，但它可以是任何可以与迭代器比较的半正则类型（半正则类型是可复制和默认可初始化的）。接下来，`T`是要搜索的元素类型，而`Proj`表示投影
    - 在比较之前对每个范围元素应用的操作（`std::identity`的默认值只是将其输入作为输出传递）。 '
- en: After the template parameters, there come the requirements for them; the operator
    requires that we can compare the projected value and the searched-for value for
    equality. After those constraints, we simply specify the function parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板参数之后，有它们的要求；操作符要求我们可以比较投影值和搜索值是否相等。在这些约束之后，我们只需指定函数参数。
- en: 'Let''s now see how it''s implemented:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看它是如何实现的：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we simply iterate over the elements, invoking the projection on each element
    and comparing it with the searched-for value. We return `true` if found and `false`
    otherwise (when `first == last`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是遍历元素，对每个元素调用投影并将其与搜索值进行比较。如果找到则返回`true`，否则返回`false`（当`first == last`时）。
- en: 'The preceding function would work even if we didn''t use standard ranges; we
    also need an overload for ranges. Its declaration can be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有使用标准范围，前面的函数也可以工作；我们还需要为范围重载。它的声明可以如下所示：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time, we take a type satisfying the `input_range` concept, the element
    value, and the type of projection as template parameters. We require that the
    range's iterator after calling the projection can be compared for equality with
    objects of type `T`, similarly as before. Finally, we use the range, the value,
    and the projection as our overload's parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用满足`input_range`概念的类型，元素值和投影类型作为模板参数。我们要求在调用投影后，范围的迭代器可以与类型为`T`的对象进行比较，与之前类似。最后，我们使用范围、值和投影作为我们重载的参数。
- en: 'The body of this operator will be pretty straightforward, too:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的主体也会非常简单：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We simply call the previous overload using an iterator and sentinel from the
    given range, while passing the value and our projection unchanged. Now, for the
    last part, we need to provide a `contains` niebloid instead of just the `contains_fn`
    callable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用给定范围的迭代器和哨兵调用先前的重载，同时传递值和我们的投影不变。现在，对于最后一部分，我们需要提供一个`contains` niebloid，而不仅仅是`contains_fn`可调用：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By declaring an inline variable named `contains` of type `contains_fn`, we
    allow anyone to call our niebloid using the variable name. Now, let''s call it
    ourselves to see whether it works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一个名为`contains`的内联变量，类型为`contains_fn`，我们允许任何人使用变量名调用我们的niebloid。现在，让我们自己调用它看看它是否有效：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that's it. Our ADL-inhibiting functor works as intended.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的抑制ADL的函数符合预期工作。
- en: If you think all of this is a tad too verbose, then you might be interested
    in `tag_invoke`, which might become part of the standard at some point in the
    future. Refer to the *Further reading* section for a paper on this topic and a
    YouTube video that explains ADL, niebloids, hidden friends, and `tag_invoke` nicely.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为所有这些都有点啰嗦，那么你可能会对`tag_invoke`感兴趣，它可能会在将来的某个时候成为标准的一部分。请参考*进一步阅读*部分，了解有关这个主题的论文和YouTube视频，其中详细解释了ADL、niebloids、隐藏的友元和`tag_invoke`。
- en: Let's now move on to yet another useful C++ idiom.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向另一个有用的C++习惯用法。
- en: Policy-based design idiom
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略的设计模式
- en: Policy-based design was first introduced by Andrei Alexandrescu in his excellent
    *Modern C++ Design* book. Although published in 2001, many ideas showed in it
    are still used today. We recommend reading it; you can find it linked in the *Further
    reading* section at the end of this chapter. The policy idiom is basically a compile-time
    equivalent of the Gang of Four's Strategy pattern. If you need to write a class
    with customizable behavior, you can make it a template with the appropriate policies
    as template parameters. A real-world example of this could be standard allocators,
    passed as a policy to many C++ containers as the last template parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计最初是由Andrei Alexandrescu在他出色的*现代C++设计*书中引入的。尽管该书于2001年出版，但其中许多想法今天仍在使用。我们建议阅读它；你可以在本章末尾的*进一步阅读*部分找到它的链接。策略习惯用法基本上是Gang
    of Four的策略模式的编译时等价物。如果您需要编写一个具有可定制行为的类，您可以将其作为模板与适当的策略作为模板参数。这在实际中的一个例子可能是标准分配器，作为最后一个模板参数传递给许多C++容器作为策略。
- en: 'Let''s return to our `Array` class and add a policy for debug printing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Array`类，并为调试打印添加一个策略：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we can use a default policy that won''t print anything. `NullPrintingPolicy`
    can be implemented as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以使用一个不会打印任何东西的默认策略。`NullPrintingPolicy`可以实现如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, regardless of the arguments given, it won't do anything. The
    compiler will completely optimize it out, so no overhead will be paid when the
    debug printing feature is not used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，无论给定什么参数，它都不会做任何事情。编译器会完全优化它，因此在不使用调试打印功能时不会产生任何开销。
- en: 'If we want our class to be a bit more verbose, we can use a different policy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的类更加冗长，我们可以使用不同的策略：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time, we''ll simply print the text passed to the policy to `cout`. We
    also need to modify our class to actually use our policy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只需将传递给策略的文本打印到`cout`。我们还需要修改我们的类来实际使用我们的策略：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We simply call the policy's `operator()`, passing the text to be printed. Since
    our policies are stateless, we can instantiate it each time we need to use it
    without extra cost. An alternative could also be to just call a static function
    from it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需调用策略的`operator()`，将要打印的文本传递进去。由于我们的策略是无状态的，我们可以在需要使用它时每次实例化它，而不会产生额外的成本。另一种选择也可以是直接从中调用静态函数。
- en: 'Now, all we need to do is to instantiate our `Array` class with the desired
    policy and use it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要用所需的策略实例化我们的`Array`类并使用它：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One drawback of using compile-timed policies is that the template instantiations
    using different policies are of different types. This means more work is required
    to, for instance, assign from a regular `Array` class to one with `CoutPrintingPolicy`.
    To do so, you would need to implement assignment operators as template functions
    with the policy as the template parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译时策略的一个缺点是使用不同策略的模板实例化是不同类型的。这意味着需要更多的工作，例如从常规的`Array`类分配到具有`CoutPrintingPolicy`的类。为此，您需要将策略作为模板参数实现赋值运算符作为模板函数。
- en: Sometimes an alternative to using policies is to use traits. As an example,
    take `std::iterator_traits`, which can be used to use various information about
    iterators when writing algorithms that use them. An example could be `std::iterator_traits<T>::value_type`,
    which can work for both custom iterators defining a `value_type` member, and simple
    ones such as pointers (in which case `value_type` would refer to the pointed-to
    type).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用特征作为使用策略的替代方案。例如，`std::iterator_traits`可以用于在编写使用迭代器的算法时使用有关迭代器的各种信息。例如，`std::iterator_traits<T>::value_type`可以适用于定义了`value_type`成员的自定义迭代器，以及简单的迭代器，比如指针（在这种情况下，`value_type`将指向被指向的类型）。
- en: Enough about policy-based design. Next on our list is a powerful idiom that
    can be applied in multiple scenarios.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基于策略的设计就说这么多。接下来我们要讨论的是一个可以应用于多种情景的强大习惯用法。
- en: Curiously recurring template pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇异递归模板模式
- en: Despite having *pattern* in its name, the **Curiously Recurring Template Pattern**
    (**CRTP**) is an idiom in C++. It can be used to implement other idioms and design
    patterns and to apply static polymorphism, to name a few areas. Let's start with
    this last one as we'll cover the others later on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它的名字中有*模式*一词，**奇异递归模板模式**（**CRTP**）是C++中的一种习惯用法。它可以用于实现其他习惯用法和设计模式，并应用静态多态性，等等。让我们从最后一个开始，因为我们稍后会涵盖其他内容。
- en: Knowing when to use dynamic versus static polymorphism
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解何时使用动态多态性与静态多态性
- en: When mentioning polymorphism, many programmers will think of dynamic polymorphism,
    where the information needed to perform a function call is gathered at runtime.
    In contrast to this, static polymorphism is about determining the calls at compile
    time. An advantage of the former is that you can modify the list of types at runtime,
    allowing extending your class hierarchies through plugins and libraries. The big
    advantage of the second is that it can get better performance if you know the
    types upfront. Sure, in the first case you can sometimes expect your compiler
    to devirtualize your calls, but you cannot always count on it doing so. However,
    in the second case, you can get longer compilation times.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在提到多态性时，许多程序员会想到动态多态性，其中执行函数调用所需的信息在运行时收集。与此相反，静态多态性是关于在编译时确定调用的。前者的优势在于你可以在运行时修改类型列表，允许通过插件和库扩展你的类层次结构。后者的优势在于，如果你提前知道类型，它可以获得更好的性能。当然，在第一种情况下，你有时可以期望编译器去虚拟化你的调用，但你不能总是指望它这样做。然而，在第二种情况下，你可以获得更长的编译时间。
- en: Looks like you cannot win in all cases. Still, choosing the right type of polymorphism
    for your types can go a long way. If performance is at stake, we strongly suggest
    you consider static polymorphism. CRTP is an idiom that can be used to apply it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来你不能在所有情况下都赢。不过，为你的类型选择正确的多态类型可以走很远。如果性能受到影响，我们强烈建议你考虑静态多态性。CRTP是一种可以用来应用它的习惯用法。
- en: Many design patterns can be implemented in one way or another. As the cost of
    dynamic polymorphism is not always worth it, the Gang of Four design patterns
    are often not the best solution in C++. If your type hierarchy should be extended
    at runtime, or compile times are a much bigger issue than performance for you
    (and you don't plan on using modules any time soon), then the classical implementations
    of the Gang of Four patterns may be a good fit. Otherwise, you can try to implement
    them using static polymorphism or by applying simpler C++-focused solutions, some
    of which we describe in this chapter. It's all about choosing the best tool for
    the job.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设计模式可以以一种或另一种方式实现。由于动态多态性的成本并不总是值得的，四人帮设计模式在C++中通常不是最好的解决方案。如果你的类型层次结构应该在运行时扩展，或者编译时间对你来说比性能更重要（而且你不打算很快使用模块），那么四人帮模式的经典实现可能是一个很好的选择。否则，你可以尝试使用静态多态性来实现它们，或者通过应用更简单的面向C++的解决方案，其中我们在本章中描述了一些。关键是选择最适合工作的工具。
- en: Implementing static polymorphism
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现静态多态性
- en: 'Let''s now implement our statically polymorphic class hierarchy. We''ll need
    a base template class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现我们的静态多态类层次结构。我们需要一个基本模板类：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The template parameter for the base class is the derived class. This may seem
    odd at first, but it allows us to `static_cast` to the correct type in our interface
    function, in this case, named `appear_in_full_glory`. We then call the implementation
    of this function in a derived class. Derived classes could be implemented like
    so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的模板参数是派生类。这一开始可能看起来很奇怪，但它允许我们在我们的接口函数中`static_cast`到正确的类型，这种情况下，命名为`appear_in_full_glory`。然后我们在派生类中调用这个函数的实现。派生类可以这样实现：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each of these classes derives from our `GlamorousItem` base class using itself
    as the template argument. Each also implements the required function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类中的每一个都使用自身作为模板参数从我们的`GlamorousItem`基类派生。每个也实现了所需的函数。
- en: 'Note that, as opposed to dynamic polymorphism, the base class in CRTP is a
    template, so you''ll get a different base type for each of your derived classes.
    This means you can''t easily create a container of your `GlamorousItem` base class.
    What you can do, however, is several things:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与动态多态性相反，CRTP中的基类是一个模板，因此你将为你的派生类得到不同的基本类型。这意味着你不能轻松地创建一个`GlamorousItem`基类的容器。然而，你可以做一些事情：
- en: Store them in a tuple.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们存储在一个元组中。
- en: Create a `std::variant` of your derived classes.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的派生类的`std::variant`。
- en: Add one common class to wrap all instantiations of `Base`. You can use a variant
    for this one as well.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个通用类来包装所有`Base`的实例化。你也可以为这个使用一个变体。
- en: 'In the first case, we could use the class as follows. First, create the tuple
    of instances of `base`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们可以按照以下方式使用该类。首先，创建`base`实例的元组：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our type-aliased tuple will be able to store any glamorous items. Now, all
    we need to do is to call the interesting function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类型别名元组将能够存储任何迷人的物品。现在，我们需要做的就是调用有趣的函数：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because we're trying to iterate a tuple, the easiest way to do so is to call
    `std::apply`, which invokes the given callable on all the elements of the given
    tuple. In our case, the callable is a lambda that accepts only `GlamorousItem`
    base class. We use fold expressions, introduced in C++17, to ensure our function
    will be called for all elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们试图迭代一个元组，最简单的方法是调用`std::apply`，它在给定元组的所有元素上调用给定的可调用对象。在我们的情况下，可调用对象是一个只接受`GlamorousItem`基类的lambda。我们使用C++17引入的折叠表达式来确保我们的函数将被所有元素调用。
- en: 'If we were to use a variant instead of a tuple, we''d need to use `std::visit`,
    like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用变体而不是元组，我们需要使用`std::visit`，就像这样：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `std::visit` function basically takes the variant and calls the passed lambda
    on the object stored in it. Here, we create an array of our glamorous variants,
    so we can just iterate over it like over any other container, visiting each variant
    with the appropriate lambda.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::visit`函数基本上接受变体并在其中存储的对象上调用传递的lambda。在这里，我们创建了一个我们迷人变体的数组，所以我们可以像对待任何其他容器一样迭代它，用适当的lambda访问每个变体。'
- en: 'If you find it not intuitive to write from the interface user''s perspective,
    consider this next approach, which wraps the variant into yet another class, in
    our case called `CommonGlamorousItem`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得从接口用户的角度来写不直观，考虑下一种方法，将变体包装到另一个类中，我们这里称为`CommonGlamorousItem`：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To construct our wrapper, we use a forwarding constructor (`templated T&&` being
    its parameter). We then forward instead of moving to create the `item_` wrapped
    variant, as this way we only move r-value inputs. We also constrain the template
    parameters, so on one hand, we only wrap the `GlamorousItem` base class and on
    the other, our template is not used as a move or copy constructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构造我们的包装器，我们使用了一个转发构造函数（`templated T&&`是它的参数）。然后我们转发而不是移动来创建`item_`包装变体，因为这样我们只移动了右值输入。我们还约束了模板参数，因此一方面，我们只包装`GlamorousItem`基类，另一方面，我们的模板不会被用作移动或复制构造函数。
- en: 'We also need to wrap our member function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要包装我们的成员函数：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, the `std::visit` call is an implementation detail. The user can
    use this wrapper class in the following way:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`std::visit`调用是一个实现细节。用户可以以以下方式使用这个包装器类：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This approach lets the user of the class write easy-to-understand code, but
    still keep the performance of static polymorphism.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让类的使用者编写易于理解的代码，但仍然保持了静态多态性的性能。
- en: To offer a similar user experience, albeit with worse performance, you can also
    use a technique called type erasure, which we'll discuss next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供类似的用户体验，尽管性能较差，您也可以使用一种称为类型擦除的技术，我们将在下面讨论。
- en: Interlude – using type erasure
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插曲-使用类型擦除
- en: Although type erasure isn't related to CRTP, it fits in nicely with our current
    example, which is why we're showing it here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类型擦除与CRTP无关，但它与我们当前的示例非常契合，这就是为什么我们在这里展示它的原因。
- en: The type erasure idiom is about hiding the concrete type under a polymorphic
    interface. A great example of this approach can be found in Sean Parent's talk
    *Inheritance Is The Base Class of Evil* from the *GoingNative 2013* conference.
    We highly recommend you watch it in your spare time; you can find a link to it
    in the *Further reading* section. In the standard library, you can find it in
    `std::function`, `std::shared_ptr's deleter`, or `std::any`, among others.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除习惯是关于在多态接口下隐藏具体类型。这种方法的一个很好的例子可以在Sean Parent的演讲*Inheritance Is The Base
    Class of Evil*中找到，这是*GoingNative 2013*会议上的一个很好的例子。我们强烈建议您在空闲时间观看它；您可以在*进一步阅读*部分找到它的链接。在标准库中，您可以在`std::function`、`std::shared_ptr`的删除器或`std::any`等中找到它。
- en: The convenience of use and flexibility comes at a price – this idiom needs to
    use pointers and virtual dispatch, which makes the mentioned utilities from the
    standard library bad to use in performance-oriented use cases. Beware.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方便和灵活性是有代价的-这种习惯用法需要使用指针和虚拟分发，这使得标准库中提到的实用程序在性能导向的用例中使用起来不好。小心。
- en: 'To introduce type erasure to our example, we no longer need CRTP. This time,
    our `GlamorousItem` class will wrap dynamically polymorphic objects in a smart
    pointer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将类型擦除引入我们的示例中，我们不再需要CRTP。这次，我们的`GlamorousItem`类将使用智能指针来包装动态多态对象。
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, we store a pointer to base (`TypeErasedItemBase`), which will point
    to derived wrappers for our items (`TypeErasedItem<T>s`). The base class can be
    defined as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们存储了一个指向基类（`TypeErasedItemBase`）的指针，它将指向我们项目的派生包装器（`TypeErasedItem<T>`）。基类可以定义如下：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each derived wrapper needs to implement this interface, too:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个派生的包装器也需要实现这个接口：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The base class's interface is implemented by calling the function from the wrapped
    object. Note that the idiom is called "type erasure" because the `GlamorousItem`
    class doesn't know what `T` it is actually wrapping. The `information` type gets
    erased when the item gets constructed, but it all works because `T` implements
    the required methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用包装对象的函数来实现基类的接口。请注意，这种习惯用法被称为“类型擦除”，因为`GlamorousItem`类不知道它实际包装的是什么`T`。当项目被构造时，`information`类型被擦除了，但这一切都能正常工作，因为`T`实现了所需的方法。
- en: 'The concrete items can be implemented in a simpler manner, as shown next:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的项目可以以更简单的方式实现，如下所示：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, they don't need to inherit from any base. All we need is duck typing
    – if it quacks like a duck, it's probably a duck. And if it can appear in full
    glory, it's probably glamorous.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，它们不需要继承任何基类。我们只需要鸭子类型-如果它像鸭子一样嘎嘎叫，那么它可能是一只鸭子。如果它可以以全荣耀出现，那么它可能是迷人的。
- en: 'Our type-erased API can be used as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类型擦除API可以如下使用：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We just create an array of our wrappers and iterate over it, all using simple,
    value-based semantics. We find it the most pleasant to use, as the polymorphism
    is hidden from the caller as an implementation detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需创建一个包装器数组，并对其进行迭代，所有这些都使用简单的基于值的语义。我们发现这是最愉快的使用方式，因为多态性对调用者来说是作为实现细节隐藏的。
- en: However, a big drawback of this approach is, as we mentioned before, poor performance.
    Type erasure comes at a price, so it should be used sparingly and definitely not
    in the hot path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的一个很大的缺点是，正如我们之前提到的，性能较差。类型擦除是有代价的，因此应该谨慎使用，绝对不要在热路径中使用。
- en: Now that we've described how to wrap and erase types, let's switch to discussing
    how to create them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了如何包装和擦除类型，让我们转而讨论如何创建它们。
- en: Creating objects
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: In this section, we'll discuss common solutions to problems related to object
    creation. We'll discuss various types of object factories, go through builders,
    and touch on composites and prototypes. However, we'll take a slightly different
    approach than the Gang of Four when describing their solutions. They proposed
    complex, dynamically polymorphic class hierarchies as proper implementations of
    their patterns. In the C++ world, many patterns can be applied to real-world problems
    without introducing as many classes and the overhead of dynamic dispatch. That's
    why in our case, the implementations will be different and in many cases simpler
    or more performant (although more specialized and less "generic" in the Gang of
    Four sense). Let's dive right in.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论与对象创建相关的常见问题的解决方案。我们将讨论各种类型的对象工厂，通过构建者，并涉及组合和原型。然而，我们将采用与四人帮在描述他们的解决方案时略有不同的方法。他们提出了复杂的、动态多态的类层次结构作为他们模式的适当实现。在C++世界中，许多模式可以应用于现实世界的问题，而不引入太多的类和动态分派的开销。这就是为什么在我们的情况下，实现将是不同的，在许多情况下更简单或更高效（尽管在四人帮的意义上更专业化和不那么“通用”）。让我们马上开始。
- en: Using factories
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂
- en: The first type of creational patterns we'll discuss here are factories. They're
    useful when the object construction can be done in a single step (a pattern useful
    if it cannot be covered right after factories), but when the constructor just
    isn't good enough on its own. There are three types of factories – factory methods,
    factory functions, and factory classes. Let's introduce them one by one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论的第一种创建模式是工厂。当对象的构造可以在单个步骤中完成时（如果不能在工厂之后立即完成的模式很有用），但构造函数本身并不够好时，它们是有用的。有三种类型的工厂-工厂方法、工厂函数和工厂类。让我们依次介绍它们。
- en: Using factory methods
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用工厂方法
- en: 'Factory methods, also called the *named constructor idiom*, are basically member
    functions that call a private constructor for you. When do we use them? Here are
    a few scenarios:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法，也称为“命名构造函数惯用法”，基本上是调用私有构造函数的成员函数。我们什么时候使用它们？以下是一些情况：
- en: '**When there are many different ways to construct an object, which would make
    errors likely**. For example, imagine constructing a class for storing different
    color channels for a given pixel; each channel is represented by a one-byte value.
    Using just a constructor would make it too easy to pass the wrong order of channels,
    or values meant for a different color palette entirely. Also, switching the pixel''s
    internal representation of colors would get tricky pretty fast. You could argue
    that we should have different types representing colors in those different formats,
    but often, using a factory method is a valid approach as well.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当有许多不同的方法来构造一个对象，这可能会导致错误**。例如，想象一下构造一个用于存储给定像素的不同颜色通道的类；每个通道由一个字节值表示。仅使用构造函数会使得很容易传递错误的通道顺序，或者值是为完全不同的调色板而设计的。此外，切换像素的颜色内部表示会变得非常棘手。你可以说我们应该有不同类型来表示这些不同格式的颜色，但通常，使用工厂方法也是一个有效的方法。'
- en: '**When you want to force the object to be created on the heap or in another
    specific memory area**. If your object takes up loads of space on the stack and
    you''re afraid you''ll run out of stack memory, using a factory method is a solution.
    The same if you require all instances to be created in some area of memory on
    a device, for instance.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当你想要强制对象在堆上或在另一个特定的内存区域中创建**。如果你的对象在堆栈上占用大量空间，而你担心会用尽堆栈内存，使用工厂方法是一个解决方案。如果你要求所有实例都在设备上的某个内存区域中创建，也是一样。'
- en: '**When constructing your object can fail, but you cannot throw exceptions**.
    You should use exceptions instead of other methods of error handling. When used
    properly, they can yield cleaner and better-performing code. However, some projects
    or environments require that exceptions are disabled. In such cases, using a factory
    method will allow you to report errors happening during construction.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当构造对象可能失败，但你不能抛出异常**。你应该使用异常而不是其他错误处理方法。当使用正确时，它们可以产生更清洁和性能更好的代码。然而，一些项目或环境要求禁用异常。在这种情况下，使用工厂方法将允许您报告在构造过程中发生的错误。'
- en: 'A factory method for the first case we described could look as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述的第一种情况的工厂方法可能如下所示：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This class has two factory methods (actually, the C++ standard doesn''t recognize
    the term *method*, calling them *member functions* instead): `fromRgba` and `fromBgra`.
    Now it''s harder to make a mistake and initialize the channels in the wrong order.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个工厂方法（实际上，C++标准不承认术语“方法”，而是称它们为“成员函数”）：`fromRgba`和`fromBgra`。现在更难出错并以错误的顺序初始化通道。
- en: Note that having a private constructor effectively inhibits any class from inheriting
    from your type, as without access to its constructor, no instances can be created.
    If that's your goal and not a side effect, however, you should prefer to just
    mark your class as final.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，拥有私有构造函数实际上会阻止任何类从您的类型继承，因为没有访问其构造函数，就无法创建实例。然而，如果这是您的目标而不是副作用，您应该更喜欢将您的类标记为最终。
- en: Using factory functions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用工厂函数
- en: As opposed to using factory member functions, we can also implement them using
    non-member ones. This way, we can provide better encapsulation, as described by
    Scott Meyers in his article linked in the *Further reading* section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用工厂成员函数相反，我们也可以使用非成员函数来实现它们。这样，我们可以提供更好的封装，正如Scott Meyers在他的文章中所描述的。
- en: 'In the case of our `Pixel`, we could also create a free function to fabricate
    its instances. This way, our type could have simpler code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Pixel`的情况下，我们也可以创建一个自由函数来制造它的实例。这样，我们的类型可以有更简单的代码：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using this approach makes our design conform to the open-closed principle described
    in [Chapter 1](475bdf95-9ad0-4bdc-9e5d-5083405fe48a.xhtml)*, Importance of Software
    Architecture and Principles of Great Design*. It's easy to add more factory functions
    for other color palettes without the need to modify the `Pixel` struct itself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法使我们的设计符合[第1章](475bdf95-9ad0-4bdc-9e5d-5083405fe48a.xhtml)*，软件架构的重要性和优秀设计原则*中描述的开闭原则。可以很容易地添加更多的工厂函数来处理其他颜色调色板，而无需修改`Pixel`结构本身。
- en: 'This implementation of `Pixel` allows the user to initialize it by hand instead
    of using one of our provided functions. If we want, we can inhibit this behavior
    by changing the class declaration. Here''s how it could look after the fix:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`Pixel`的实现允许用户手动初始化它，而不是使用我们提供的函数之一。如果我们希望，可以通过更改类声明来禁止这种行为。修复后的样子如下：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This time, our factory functions are friends of our class. However, the type
    is no longer an aggregate, so we can no longer use aggregate initialization (`Pixel{}`),
    including designated initializers. Also, we gave up on the open-closed principle.
    The two approaches offer different trade-offs, so choose wisely.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们的工厂函数是我们类的朋友。然而，类型不再是一个聚合，所以我们不能再使用聚合初始化（`Pixel{}`），包括指定的初始化器。此外，我们放弃了开闭原则。这两种方法提供了不同的权衡，所以要明智选择。
- en: Choosing the return type of a factory
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择工厂的返回类型
- en: Yet another thing you should choose when implementing an object factory is the
    actual type it should return. Let's discuss the various approaches.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现对象工厂时，您还应该选择它应该返回的实际类型。让我们讨论各种方法。
- en: In the case of `Pixel`, which is a value type and not a polymorphic one, the
    simplest approach works the best – we simply return by value. If you produce a
    polymorphic type, return it by a smart pointer (**never** use a naked pointer
    for this as this will yield memory leaks at some point). If the caller should
    own the created object, usually returning it in `unique_ptr` to the base class
    is the best approach. In the not-so-common cases where your factory and the caller
    must both own the object, use `shared_ptr` or another reference-counted alternative.
    Sometimes it's enough that the factory keeps track of the object but doesn't store
    it. In such cases, store `weak_ptr` inside the factory and return `shared_ptr`
    outside.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Pixel`这种值类型而不是多态类型的情况，最简单的方法效果最好——我们只需返回值。如果您生成多态类型，请使用智能指针返回它（**永远**不要使用裸指针，因为这将在某个时候导致内存泄漏）。如果调用者应该拥有创建的对象，通常将其返回到基类的`unique_ptr`中是最好的方法。在不太常见的情况下，您的工厂和调用者都必须拥有对象时，使用`shared_ptr`或其他引用计数的替代方案。有时，工厂跟踪对象但不存储它就足够了。在这种情况下，在工厂内部存储`weak_ptr`，在外部返回`shared_ptr`。
- en: Some C++ programmers would argue that you should return specific types using
    an out parameter, but that's not the best approach in most cases. In the case
    of performance, returning by value is usually the best choice, as compilers will
    not make extra copies of your object. If the issue is with the type being non-copyable,
    from C++17 onward, the standard specifies where copy elision is mandatory, so
    returning such types by value is usually not an issue. If your function returns
    multiple objects, use a pair, tuple, struct, or container.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C++程序员会认为您应该使用输出参数返回特定类型，但在大多数情况下，这不是最佳方法。在性能方面，按值返回通常是最佳选择，因为编译器不会对对象进行额外的复制。如果问题是类型不可复制，从C++17开始，标准规定了复制省略是强制性的，因此通常按值返回这些类型不是问题。如果您的函数返回多个对象，请使用pair、tuple、struct或容器。
- en: 'If something goes wrong during construction, you have several choices:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建过程中出现问题，您有几种选择：
- en: Return `std::optional` of your type if there's no need to provide error messages
    to the caller.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不需要向调用者提供错误消息，则返回您的类型的`std::optional`。
- en: Throw an exception if errors during construction are rare and should be propagated.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在构建过程中出现错误很少且应该传播，则抛出异常。
- en: Return `absl::StatusOr` of your type if errors during construction are common
    (see Abseil's documentation for this template in the *Further reading* section).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在构建过程中出现错误很常见（请参阅Abseil文档中的模板），则返回您的类型的`absl::StatusOr`（请参阅*进一步阅读*部分）。
- en: Now that you know what to return, let's discuss our last type of factories.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道应该返回什么了，让我们讨论我们最后一种工厂类型。
- en: Using factory classes
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用工厂类
- en: 'Factory classes are types that can fabricate objects for us. They can help
    decouple polymorphic object types from their callers. They can allow for using
    object pools (in which reusable objects are kept so that you don''t need to constantly
    allocate and free them) or other allocation schemes. Those are just a few examples
    of how they can be useful. Let''s take a closer look at yet another one. Imagine
    you need to create different polymorphic types based on input parameters. In some
    cases, a polymorphic factory function such as the one shown next is not enough:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂类是可以为我们制造对象的类型。它们可以帮助解耦多态对象类型与其调用者。它们可以允许使用对象池（其中可重用的对象被保留，这样您就不需要不断分配和释放它们）或其他分配方案。这些只是它们可以有用的一些例子。让我们更仔细地看看另一个例子。想象一下，您需要根据输入参数创建不同的多态类型。在某些情况下，像下面显示的多态工厂函数一样的多态工厂函数是不够的：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What if we wanted to open other kinds of documents as well, such as OpenDocument
    text files? It may be ironic to discover that the preceding open factory is not
    open for extension. It might not be a big issue if we own the codebase, but if
    the consumers of our library need to register their own types, this can be an
    issue. To solve it, let''s use a factory class that will allow registering functions
    to open different kinds of documents, as shown next:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想打开其他类型的文档，比如OpenDocument文本文件，可能会讽刺地发现前面的打开工厂不适用于扩展。如果我们拥有代码库，这可能不是一个大问题，但如果我们库的消费者需要注册自己的类型，这可能是一个问题。为了解决这个问题，让我们使用一个工厂类，允许注册函数来打开不同类型的文档，如下所示：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The class doesn''t do much yet, but it has a map from extensions to functions
    that should be called to open files of given types. Now we''ll add two public
    member functions. The first one will register new file types:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类目前还没有做太多事情，但它有一个从扩展到应该调用以打开给定类型文件的函数的映射。现在我们将添加两个公共成员函数。第一个将注册新的文件类型：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we have a way of filling the map. The second new public function will open
    the documents using an appropriate opener:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了填充映射的方法。第二个新的公共函数将使用适当的打开者打开文档：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Basically, we extract the extension from the file path, throw an exception if
    it's empty, and if not, we look for an opener in our map. If found, we use it
    to open the given file, and if not, the map will throw another exception for us.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们从文件路径中提取扩展名，如果为空则抛出异常，如果不为空，则在我们的映射中寻找打开者。如果找到，我们使用它来打开给定的文件，如果没有，映射将为我们抛出另一个异常。
- en: 'Now we can instantiate our factory and register custom file types such as the
    OpenDocument text format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实例化我们的工厂并注册自定义文件类型，比如OpenDocument文本格式：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that we're registering a lambda because it can be converted to our `ConcreteOpener`
    type, which is a function pointer. However, if our lambda had state, this wouldn't
    be the case. In such a situation, we would need to use something to wrap us up.
    One such thing could be `std::function`, but the drawback of this would be the
    need to pay the cost of type erasure each time we would want to run the function.
    In the case of opening files, that's probably okay. If you need better performance,
    however, consider using a type such as `function_ref`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们注册了一个lambda，因为它可以转换为我们的`ConcreteOpener`类型，这是一个函数指针。但是，如果我们的lambda有状态，情况就不同了。在这种情况下，我们需要使用一些东西来包装我们。这样的东西可能是`std::function`，但这样做的缺点是每次运行函数时都需要付出类型擦除的代价。在打开文件的情况下，这可能没问题。但是，如果你需要更好的性能，考虑使用`function_ref`这样的类型。
- en: An example implementation of this utility proposed to the C++ standard (not
    yet accepted) can be found on Sy Brand's GitHub repo referred to in the *Further
    reading* section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提议的这个实用程序的示例实现（尚未被接受）可以在Sy Brand的GitHub存储库中找到，该存储库在*进一步阅读*部分中有引用。
- en: 'Okay, now that we have our opener registered in the factory, let''s use it
    to open a file and extract some text out of it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们在工厂中注册了我们的打开者，让我们使用它来打开一个文件并提取一些文本出来：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And that's all! If you want to provide the consumers of your library with a
    way to register their own types, they must have access to your map at runtime.
    You can either provide them with an API to reach it or make the factory static
    and allow them to register from anywhere in the code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果你想为你的库的消费者提供一种注册他们自己类型的方式，他们必须在运行时访问你的映射。你可以提供一个API让他们访问它，或者将工厂设为静态，并允许他们从代码的任何地方注册。
- en: That does it for factories and building objects in a single step. Let's discuss
    another popular pattern to be used if factorys aren't a good fit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是工厂和在单一步骤中构建对象的全部内容。让我们讨论另一个流行的模式，如果工厂不合适的话可以使用。
- en: Using builders
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构建者
- en: 'Builders are similar to factories, a creational pattern coming from the Gang
    of Four. Unlike factories, they can help you build more complex objects: those
    that cannot be built in a single step, such as types assembled from many separate
    parts. They also provide you with a way to customize the construction of objects.
    In our case, we''ll skip designing complex hierarchies of builders. Instead, we''ll
    show how a builder can help. We''ll leave implementing hierarchies to you, as
    an exercise.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者类似于工厂，是来自四人帮的一种创建模式。与工厂不同，它们可以帮助你构建更复杂的对象：那些无法在单一步骤中构建的对象，例如由许多单独部分组装而成的类型。它们还为你提供了一种自定义对象构建的方式。在我们的例子中，我们将跳过设计复杂的构建者层次结构。相反，我们将展示构建者如何帮助。我们将把实现层次结构的工作留给你作为练习。
- en: Builders are needed when an object cannot be produced in a single step, but
    having a fluent interface can just make them pleasant to use if the single step
    is not trivial. Let's demonstrate creating fluent builder hierarchies using CRTP.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象无法在单一步骤中产生时，就需要构建者，但如果单一步骤不是微不足道的话，具有流畅接口只会让它们更加愉快。让我们使用CRTP来演示创建流畅的构建者层次结构。
- en: In our case, we'll create a CRTP, `GenericItemBuilder`, that we'll use as our
    base builder, and `FetchingItemBuilder`, which will be a more specialized one
    that can fetches data using a remote address if that's a supported feature. Such
    specializations can even live in different libraries, for instance, consuming
    different APIs that may or may not be available at build time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将创建一个CRTP，`GenericItemBuilder`，它将作为我们的基本构建者，以及`FetchingItemBuilder`，它将是一个更专业的构建者，可以使用远程地址获取数据（如果支持的话）。这样的专业化甚至可以存在于不同的库中，例如，使用可能在构建时可用或不可用的不同API。
- en: 'For demo purposes, we''ll build instances of our `Item` struct from [Chapter
    5](315eea2a-c029-4bc3-a159-4f897d393639.xhtml)*, Leveraging C++ Language Features*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将从[第5章](315eea2a-c029-4bc3-a159-4f897d393639.xhtml)*，利用C++语言特性*构建我们的`Item`结构的实例：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you want, you can enforce that `Item` instances are built using a builder
    by making the default constructor private and making the builders friends:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过将默认构造函数设为私有并使构建者成为友元来强制使用构建者构建`Item`实例。
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our builder''s implementation can be started as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建者实现可以从以下开始：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although it's generally not recommended to create protected members, we want
    our descendant builders to be able to reach our item. An alternative would be
    to use just the public methods of our base builder in derived ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常不建议创建受保护的成员，但我们希望我们的后代构建者能够访问我们的项目。另一种方法是在派生类中只使用基本构建器的公共方法。
- en: 'We take the name in the builder''s constructor, as it''s a single input coming
    from the user that needs to be set when we create our item. This way, we make
    sure that it will be set. An alternative would be to check whether it''s okay
    at the final stage of building, when the object is being released to the user.
    In our case, the build step can be implemented as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建器的构造函数中接受名称，因为它是来自用户的单个输入，在创建项目时需要设置。这样，我们确保它将被设置。另一种选择是在建造的最后阶段检查它是否可以，当对象被释放给用户时。在我们的情况下，构建步骤可以实现如下：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We enforce that the builder is "consumed" when this method is called; it must
    be an r-value. This means we can either use the builder in one line or move it
    in the last step to mark its end of work. We then set the creation time for our
    item and move it outside of the builder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强制要求在调用此方法时“消耗”构建器；它必须是一个r值。这意味着我们可以在一行中使用构建器，或者在最后一步将其移动以标记其工作结束。然后我们设置我们的项目的创建时间并将其移出构建器。
- en: 'Our builder''s API could offer functions such as the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建器API可以提供以下功能：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Each of them returns the concrete (derived) builder object as an r-value reference.
    Perhaps counterintuitively, this time such a return type should be preferred to
    returning by value. This is to avoid unnecessary copies of `item_` when building.
    On the other hand, returning by an l-value reference could lead to dangling references
    and would make calling `build()` harder because the returned l-value reference
    wouldn't match the expected r-value one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它们中的每一个都将具体（派生）构建器对象作为r值引用返回。也许出乎意料的是，这次应该优先返回此返回类型，而不是按值返回。这是为了避免在构建时不必要地复制`item_`。另一方面，通过l值引用返回可能导致悬空引用，并且会使调用`build()`变得更加困难，因为返回的l值引用将无法匹配预期的r值引用。
- en: 'The final builder type could look as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的构建器类型可能如下所示：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It''s just a class that reuses the constructors from our generic builder. It
    can be used as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个重用我们通用构建器的构造函数的类。可以如下使用：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the final interface can be called using function chaining and
    the method names make the whole invocation fluent to read, hence the name *fluent
    interfaces*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，最终的接口可以使用函数链接调用，并且方法名称使整个调用流畅易读，因此称为*流畅接口*。
- en: 'What if we were to not load each item directly, but rather use a more specialized
    builder that could load parts of the data from a remote endpoint? We could define
    it as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不直接加载每个项目，而是使用一个更专门的构建器，可以从远程端点加载数据的部分，会怎么样？我们可以定义如下：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We also use CRTP to inherit from our generic builder and also enforce giving
    us a name. This time, however, we extend the base builder with our own function
    to fetch the contents and put them in the item we''re building. Thanks to CRTP,
    when we call a function from our base builder, we''ll get the derived one returned,
    which makes the interface much easier to use. It can be called in the following
    manner:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用CRTP从我们的通用构建器继承，并强制要求给我们一个名称。然而，这一次，我们用我们自己的函数扩展基本构建器，以获取内容并将其放入我们正在构建的项目中。由于CRTP，当我们从基本构建器调用函数时，我们将得到派生的返回，这使得接口更容易使用。可以以以下方式调用：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: All nice and dandy!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好！
- en: Builders can also come in handy if you need to always create immutable objects.
    As the builder has access to private members of the class, it can modify them,
    even if the class doesn't provide any setters for them. That's of course not the
    only case when you can benefit from using them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要始终创建不可变对象，构建器也很有用。由于构建器可以访问类的私有成员，它可以修改它们，即使类没有为它们提供任何设置器。当然，这并不是您可以从使用它们中受益的唯一情况。
- en: Building with composites and prototypes
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用复合和原型构建
- en: A case where you would need to use a builder is when creating a composite. A
    composite is a design pattern in which a group of objects is treated as one, all
    sharing the same interface (or the same base type). An example would be a graph,
    which you could compose out of subgraphs, or a document, which could nest other
    documents. When you would call `print()` on such an object, all its sub-objects
    would get their `print()` functions called in order to print the whole composite.
    The builder pattern can be useful for creating each sub-object and composing them
    all together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用构建器的情况是创建复合体。复合体是一种设计模式，其中一组对象被视为一个对象，所有对象共享相同的接口（或相同的基本类型）。一个例子是图形，您可以将其组合成子图形，或者文档，它可以嵌套其他文档。当您在这样的对象上调用`print()`时，所有子对象都会按顺序调用它们的`print()`函数以打印整个复合体。构建器模式对于创建每个子对象并将它们全部组合在一起非常有用。
- en: 'Prototype is yet another pattern that can be used for object construction.
    If your type is very costly to create anew, or you just want to have a base object
    to build upon, you might want to use this pattern. It boils down to providing
    a way to clone your object, which you could later either use on its own or modify
    so it becomes what it should be. In the case of a polymorphic hierarchy, just
    add `clone()` like so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是另一种可以用于对象构建的模式。如果您的类型创建成本很高，或者您只想要一个基本对象来构建，您可能想要使用这种模式。它归结为提供一种克隆对象的方法，您稍后可以单独使用它，或者修改它以使其成为应该成为的样子。在多态层次结构的情况下，只需添加`clone()`，如下所示：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our `MapWithPointsOfInterests` object could clone the points too, so we don't
    need to re-add each of them manually. This way, we can have some default provided
    to the end user when they create their own map. Note also that in some cases,
    instead of using a prototype, a simple copy constructor would suffice.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MapWithPointsOfInterests`对象也可以克隆这些点，这样我们就不需要手动重新添加每一个。这样，当用户创建自己的地图时，我们可以为其提供一些默认值。还要注意，在某些情况下，简单的复制构造函数就足够了，而不是使用原型。
- en: We have now covered object creation. We touched on variants along the way, so
    why not revisit them (pun intended) to see how else they can help us?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了对象创建。我们沿途提到了变体，那么为什么不重新访问它们（双关语）以看看它们如何帮助我们？
- en: Tracking state and visiting objects in C++
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中跟踪状态和访问对象
- en: State is a design pattern meant to help change the behavior of an object when
    its internal state changes. The behavior for different states should be independent
    of each other so that adding new states doesn't affect the current ones. The simple
    approach of implementing all the behavior in the stateful object doesn't scale
    and is not open for extension. Using the state pattern, new behavior can be added
    by introducing new state classes and defining the transitions between them. In
    this section, we'll show a way to implement states and a state machine leveraging
    `std::variant` and statically polymorphic double dispatch. In other words, we'll
    build a finite state machine by joining the state and visitor patterns in a C++
    way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一种设计模式，旨在在对象的内部状态发生变化时帮助改变对象的行为。不同状态的行为应该彼此独立，以便添加新状态不会影响当前状态。在状态对象中实现所有行为的简单方法不具有可扩展性。使用状态模式，可以通过引入新的状态类并定义它们之间的转换来添加新行为。在本节中，我们将展示一种使用`std::variant`和静态多态双重分派来实现状态和状态机的方法。
- en: 'First, let''s define our states. In our example, let''s model the states of
    a product in a store. They can be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的状态。在我们的示例中，让我们模拟商店中产品的状态。它们可以如下所示：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our states can have properties of their own, such as the count of items left.
    Also, as opposed to dynamically polymorphic ones, they don''t need to inherit
    from a common base. Instead, they are all stored in one variant, as shown next:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态可以有自己的属性，比如剩余物品的数量。与动态多态性相反，它们不需要从一个共同的基类继承。相反，它们都存储在一个变体中，如下所示：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Aside from states, we also need events for state transitions. Check the following
    code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了状态，我们还需要用于状态转换的事件。检查以下代码：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, our events can also have properties and don''t inherit from
    a common base. Now, we need to implement the transitions between the states. This
    can be done as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的事件也可以有属性，并且不需要从一个共同的基类继承。现在，我们需要实现状态之间的转换。可以按以下方式完成：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If a purchase is made, the state can change, but it can also stay the same.
    We can also use templates to handle several states at once:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进行购买，状态可以改变，但也可以保持不变。我们还可以使用模板一次处理多个状态：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If an item gets discontinued, it doesn''t matter what state it was in. Okay,
    let''s now implement the last supported transition:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商品停产，无论它处于什么状态都无所谓。好的，现在让我们实现最后一个受支持的转换：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The next piece of the puzzle we need is a way to define multiple call operators
    in one object generically so that the best matching overload can be called. We''ll
    use it later to call the transitions we just defined. Our helper can look as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个拼图是一种定义多个调用运算符的方式，以便可以调用最佳匹配的重载。我们稍后将使用它来调用我们刚刚定义的转换。我们的辅助程序可以如下所示：
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We create an `overload` struct that will provide all the call operators passed
    to it during construction, using variable templates, a fold expression, and a
    class template argument deduction guide. For a more in-depth explanation of this,
    along with an alternative way of implementing visitation, refer to Bartłomiej
    Filipek's blog post in the *Further reading* section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`overload`结构，它将在构造期间提供所有传递给它的调用运算符，使用可变模板、折叠表达式和类模板参数推导指南。有关此的更深入解释，以及实现访问的另一种替代方式，请参阅Bartłomiej
    Filipek在*进一步阅读*部分中的博客文章。
- en: 'We can now start implementing the state machine itself:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现状态机本身：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Our `process_event` function will accept any of our defined events. It will
    call an appropriate `on_event` function using the current state and the passed
    event and switch to the new state. If an `on_event` overload is found for the
    given state and event, the first lambda will get called. Otherwise, the constraint
    won't be satisfied and the second, more generic overload will get called. This
    means if there's an unsupported state transition, we'll just throw an exception.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`process_event`函数将接受我们定义的任何事件。它将使用当前状态和传递的事件调用适当的`on_event`函数，并切换到新状态。如果找到给定状态和事件的`on_event`重载，将调用第一个lambda。否则，约束条件将不满足，并将调用第二个更通用的重载。这意味着如果存在不受支持的状态转换，我们将抛出异常。
- en: 'Now, let''s provide a way to report the current state:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提供一种报告当前状态的方法：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we use our overload to pass three lambdas, each returning a report string
    generated by visiting our state object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的重载来传递三个lambda，每个lambda返回一个通过访问我们的状态对象生成的报告字符串。
- en: 'We can now call our solution:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用我们的解决方案：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Upon running, this will yield the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，将产生以下输出：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That is, unless you uncomment the last line with the unsupported transition,
    in which case an exception will be thrown at the end.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，除非您取消注释具有不受支持的转换的最后一行，否则在最后将抛出异常。
- en: Our solution is much more performant than dynamic polymorphism-based ones, although
    the list of supported states and events is constrained to those provided at compile
    time. For more information on states, variants, and the various ways of visitations,
    see Mateusz Pusz's talk from CppCon 2018, also listed in the *Further reading*
    section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案比基于动态多态性的解决方案要高效得多，尽管受支持的状态和事件列表受限于编译时提供的状态。有关状态、变体和各种访问方式的更多信息，请参阅Mateusz
    Pusz在CppCon 2018的演讲，也列在*进一步阅读*部分中。
- en: Before we close this chapter, one last thing we'd like for you to learn about
    is handling memory. Let's begin our last section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我们想让您了解的最后一件事是处理内存。让我们开始我们的最后一节。
- en: Dealing with memory efficiently
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效处理内存
- en: Even if you don't have very limited memory, it's a good idea to look at how
    you use it. Usually, memory throughput is the performance bottleneck of modern-day
    systems, so it's always important to make good use of it. Performing too many
    dynamic allocations can slow down your program and lead to memory fragmentation.
    Let's learn a few ways to mitigate those issues.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您没有非常有限的内存，查看您如何使用它也是一个好主意。通常，内存吞吐量是现代系统的性能瓶颈，因此始终重要的是充分利用它。执行太多的动态分配可能会减慢程序速度并导致内存碎片化。让我们学习一些减轻这些问题的方法。
- en: Reducing dynamic allocations using SSO/SOO
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SSO/SOO减少动态分配
- en: 'Dynamic allocations can sometimes cause you other trouble than just throwing
    when you construct objects despite not having enough memory. They often cost you
    CPU cycles and can cause memory fragmentation. Fortunately, there is a way to
    protect against it. If you''ve ever used `std::string` (post GCC 5.0), you most
    probably used an optimization called **Small String Optimization** (**SSO**).
    This is one example of a more general optimization named **Small Object Optimization**
    (**SSO**), which can be spotted in types such as Abseil''s InlinedVector. The
    main idea is pretty straightforward: if the dynamically allocated object is small
    enough, it should be stored inside the class that owns it instead of being dynamically
    allocated. In `std::string`''s case, usually, there''s a capacity, length, and
    the actual string to store. If the string is short enough (in GCC''s case, on
    64-bit platforms, it''s 15 bytes), it will be stored in some of those members.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配有时会给您带来麻烦，不仅在构造对象时抛出异常，而且还会花费CPU周期并导致内存碎片化。幸运的是，有一种方法可以防范这种情况。如果您曾经使用过`std::string`（GCC
    5.0之后），您很可能使用了一种称为**小字符串优化**（**SSO**）的优化。这是**小对象优化**（**SSO**）的一个更普遍的优化的例子，可以在Abseil的InlinedVector等类型中找到。其主要思想非常简单：如果动态分配的对象足够小，它应该存储在拥有它的类内部，而不是动态分配。在`std::string`的情况下，通常有容量、长度和实际要存储的字符串。如果字符串足够短（在GCC的情况下，在64位平台上，它是15个字节），它将存储在其中的某些成员中。
- en: 'Storing objects in place instead of allocating them somewhere else and storing
    just the pointer has one more benefit: less pointer chasing. Each time you need
    to reach to data stored behind a pointer, you increase the pressure on the CPU
    caches and risk needing to fetch data from the main memory. If this is a common
    pattern, it can influence the overall performance of your app, especially if the
    pointed-to addresses aren''t guessed by the CPU''s prefetcher. Using techniques
    such as SSO and SOO are invaluable in reducing those issues.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象存储在原地而不是在其他地方分配并仅存储指针还有一个好处：减少指针追踪。每次需要访问指针后面存储的数据时，都会增加CPU缓存的压力，并有可能需要从主内存中获取数据。如果这是一个常见的模式，它可能会影响您的应用程序的整体性能，特别是如果CPU的预取器没有猜测到指向的地址。使用SSO和SOO等技术在减少这些问题方面是非常宝贵的。
- en: Saving memory by herding COWs
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过管理COW来节省内存
- en: If you used GCC's `std::string` before GCC 5.0, you might have used a different
    optimization called **Copy-On-Write** (**COW**). The COW string implementation,
    when it had multiple instances created with the same underlying character array,
    was actually sharing the same memory address for it. When the string was written
    to, the underlying storage was copied — hence the name.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在GCC 5.0之前使用过GCC的`std::string`，您可能使用了一种称为**写时复制**（**COW**）的不同优化。当使用相同的基础字符数组创建多个实例时，COW字符串实现实际上共享相同的内存地址。当字符串被写入时，基础存储被复制，因此得名。
- en: This technique helped save memory and keep the caches hot, and often offered
    solid performance on a single thread. Beware of using it in multi-threaded contexts,
    though. The need for using locks can be a real performance killer. As with any
    performance-related topic, it's best to just measure whether in your case it's
    the best tool for the job.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有助于节省内存并保持高速缓存热度，并且通常在单线程上提供了可靠的性能。但要注意在多线程环境中使用它。使用锁可能会严重影响性能。与任何与性能相关的主题一样，最好的方法是测量在您的情况下是否是最佳工具。
- en: Let's now discuss a feature of C++17 that can help you achieve good performance
    with dynamic allocations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下C++17的一个功能，它可以帮助您实现动态分配的良好性能。
- en: Leveraging polymorphic allocators
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用多态分配器
- en: The feature we're talking about is polymorphic allocators. To be specific, the
    `std::pmr::polymorphic_allocator` and the polymorphic `std::pmr::memory_resource`
    class that the allocator uses to allocate memory.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在讨论的功能是多态分配器。具体来说，是`std::pmr::polymorphic_allocator`和多态`std::pmr::memory_resource`类，分配器使用它来分配内存。
- en: 'In essence, it allows you to easily chain memory resources to make the best
    use of your memory. Chains can be as simple as one resource that reserves a big
    chunk and distributes it, falling back to another that simply calls `new` and
    `delete` if it depletes memory. They can also be much more complex: you can build
    a long chain of memory resources that handle pools of different sizes, offer thread-safety
    only when needed, bypass the heap and go for the system''s memory directly, return
    you the last freed chunk of memory to provide cache hotness, and do other fancy
    stuff. Not all of these capabilities are offered by the standard polymorphic memory
    resources, but thanks to their design, it''s easy to extend them.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，它允许您轻松地链接内存资源，以充分利用您的内存。链可以简单到一个资源保留一个大块并分配它，然后退回到另一个资源，如果它耗尽内存，就简单地调用`new`和`delete`。它们也可以更复杂：您可以构建一个长链的内存资源，处理不同大小的池，仅在需要时提供线程安全性，绕过堆直接使用系统内存，返回您最后释放的内存块以提供高速缓存，以及执行其他花哨的操作。并非所有这些功能都由标准多态内存资源提供，但由于它们的设计，很容易扩展它们。
- en: Let's first tackle the topic of memory arenas.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论内存区域的主题。
- en: Using memory arenas
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内存区域
- en: A memory arena, also called a region, is just a large chunk of memory that exists
    for a limited time. You can use it to allocate smaller objects that you use for
    the lifetime of the arena. Objects in the arena can be either deallocated as usual
    or erased all at once in a process called *winking out*. We'll describe it later
    on.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域，也称为区域，只是存在有限时间的大块内存。您可以使用它来分配您在区域的生命周期内使用的较小对象。区域中的对象可以像往常一样被释放，或者在称为*闪烁*的过程中一次性擦除。我们稍后会描述它。
- en: Arenas have several great advantages over the usual allocations and deallocations
    – they increase performance because they limit the memory allocations that need
    to grab upstream resources. They also reduce fragmentation of memory, because
    any fragmentation that would happen will happen inside the arena. Once an arena's
    memory is released, the fragmentation is no more as well. A great idea is to create
    separate arenas per thread. If only a single thread uses an arena, it doesn't
    need to use any locking or other thread-safety mechanisms, reducing thread contention
    and giving you a nice boost in performance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 区域相对于通常的分配和释放具有几个巨大的优势-它们提高了性能，因为它们限制了需要获取上游资源的内存分配。它们还减少了内存的碎片化，因为任何碎片化都将发生在区域内。一旦释放了区域的内存，碎片化也就消失了。一个很好的主意是为每个线程创建单独的区域。如果只有一个线程使用区域，它就不需要使用任何锁定或其他线程安全机制，减少了线程争用，并为您提供了良好的性能提升。
- en: 'If your program is single-threaded, a low-cost solution to increase its performance
    could be as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序是单线程的，提高其性能的低成本解决方案可能如下：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The default resource if you won't set any explicitly will be `new_delete_resource`,
    which calls `new` and `delete` each time just like regular `std::allocator` does,
    and with all the thread-safety it provides (and costs).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不明确设置任何资源，那么默认资源将是`new_delete_resource`，它每次调用`new`和`delete`，就像常规的`std::allocator`一样，并且具有它提供的所有线程安全性（和成本）。
- en: 'If you use the preceding code snippet, all the allocations done using `pmr`
    allocators would be done with no locks. You still need to actually use the `pmr`
    types, though. To do so with standard containers, for instance, you need to simply
    pass `std::pmr::polymorphic_allocator<T>` as the allocator template parameter.
    Many standard containers have `pmr`-enabled type aliases. The two variables created
    next are of the same type and both will use the default memory resource:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用前面的代码片段，那么使用`pmr`分配器进行的所有分配都将不使用锁。但是，您仍然需要实际使用`pmr`类型。例如，要在标准容器中使用，您只需将`std::pmr::polymorphic_allocator<T>`作为分配器模板参数传递。许多标准容器都有启用`pmr`的类型别名。接下来创建的两个变量是相同类型，并且都将使用默认内存资源：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first one gets the resource passed explicitly, though. Let's now go through
    the resources available in `pmr`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个显式传递资源。现在让我们来看看`pmr`中可用的资源。
- en: Using the monotonic memory resource
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单调内存资源
- en: The first one we'll discuss is `std::pmr::monotonic_buffer_resource`. It's a
    resource that only allocates memory and doesn't do anything on deallocation. It
    will only deallocate memory when the resource is destructed or on an explicit
    call to `release()`. This, connected with no thread safety, makes this type extremely
    performant. If your application occasionally needs to perform a task that does
    lots of allocations on a given thread, then releases all the objects used at once
    afterward, using monotonic resources will yield great gains. It's also a great
    base building block for chains of resources.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的第一个是`std::pmr::monotonic_buffer_resource`。它是一个只分配内存而不在释放时执行任何操作的资源。它只会在资源被销毁或显式调用`release()`时释放内存。这种类型与无线程安全连接，使其极其高效。如果您的应用程序偶尔需要在给定线程上执行大量分配的任务，然后随后一次性释放所有使用的对象，使用单调资源将带来巨大的收益。它也是链式资源的一个很好的基本构建块。
- en: Using pool resources
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用池资源
- en: 'A common combo of two resources is to use a pool resource on top of a monotonic
    buffer resource. The standard pool resources create pools of different-sized chunks.
    There are two types in `std::pmr`, `unsynchronized_pool_resource` for use when
    only one thread allocates and deallocates from it and `synchronized_pool_resource`
    for multi-threaded use. Both should provide you with much better performance compared
    to the global allocator, especially when using the monotonic buffer as their upstream
    resource. If you wonder how to chain them, here''s how:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 两种资源的常见组合是在单调缓冲区资源之上使用池资源。标准池资源创建不同大小块的池。在`std::pmr`中有两种类型，`unsynchronized_pool_resource`用于仅有一个线程从中分配和释放的情况，`synchronized_pool_resource`用于多线程使用。与全局分配器相比，两者都应该提供更好的性能，特别是在使用单调缓冲区作为上游资源时。如果您想知道如何链接它们，下面是方法：
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We create a 1 MB buffer for the arena to reuse. We pass it to a monotonic resource,
    which is then passed to an unsynchronized pool resource, creating a simple yet
    efficient chain of allocators that won't call new until all the initial buffer
    is used up.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为区域创建了一个1 MB的缓冲区以供重复使用。我们将其传递给单调资源，然后传递给不同步的池资源，从而创建一个简单而有效的分配器链，直到使用完所有初始缓冲区之前都不会调用new。
- en: You can pass a `std::pmr::pool_options` object to both the pool types to limit
    the max count of blocks of a given size (`max_blocks_per_chunk`) or the size of
    the largest block (`largest_required_pool_block`). Passing 0 causes the implementation's
    default to be used. In the case of GCC's library, the actual blocks per chunk
    differ depending on the block size. If the max size is exceeded, the pool resource
    will allocate directly from its upstream resource. It also goes to the upstream
    resource if the initial memory was depleted. In this case, it allocates geometrically
    growing chunks of memory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`std::pmr::pool_options`对象传递给两种池类型，以限制给定大小的块的最大数量（`max_blocks_per_chunk`）或最大块的大小（`largest_required_pool_block`）。传递0会导致使用实现的默认值。在GCC库的情况下，实际块的数量取决于块的大小。如果超过最大大小，池资源将直接从其上游资源分配。如果初始内存耗尽，它也会转向上游资源。在这种情况下，它会分配几何增长的内存块。
- en: Writing your own memory resource
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自己的内存资源
- en: If the standard memory resources don't suit all your needs, you can always create
    a custom one quite simply. For instance, a good optimization that not all standard
    library implementations offer is to keep track of the last chunks of a given size
    that were released and return them back on the next allocations of given sizes.
    This `Most Recently Used` cache can help you increase the hotness of data caches,
    which should help your app's performance. You can think of it as a set of LIFO
    queues for chunks.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准内存资源不适合您的所有需求，您总是可以相当简单地创建自定义资源。例如，不是所有标准库实现都提供的一个很好的优化是跟踪已释放的给定大小的最后一块块，并在下一个给定大小的分配上将它们返回。这个`最近使用`缓存可以帮助您增加数据缓存的热度，这应该有助于您的应用程序性能。您可以将其视为一组用于块的LIFO队列。
- en: 'Sometimes you might also want to debug allocations and deallocations. In the
    following snippet, I have written a simple resource that can help you with this
    task:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能还希望调试分配和释放。在下面的代码片段中，我编写了一个简单的资源，可以帮助您完成这项任务：
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our verbose resource inherits from the polymorphic base resource. It also accepts
    an upstream resource, which it will use for actual allocations. It has to implement
    three private functions – one for allocating, one for deallocating, and one for
    comparing instances of the resource itself. Here''s the first one:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的冗长资源继承自多态基础资源。它还接受一个上游资源，它将用于实际分配。它必须实现三个私有函数 - 一个用于分配，一个用于释放，一个用于比较资源实例。这是第一个：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All it does is print the allocation size on the standard output and then use
    the upstream resource to allocate memory. The next one will be similar:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是在标准输出上打印分配大小，然后使用上游资源来分配内存。下一个将类似：
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We log how much memory we deallocate and use the upstream to perform the task.
    Now the last required function is stated next:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录我们释放多少内存并使用上游执行任务。现在下一个所需的最后一个函数被陈述如下：
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We simply compare the addresses of the instances to know whether they're equal.
    The `[[nodiscard]]` attribute helps us be sure that the caller actually consumes
    the returned value, which can help us avoid accidental misuse of our function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需比较实例的地址，以知道它们是否相等。`[[nodiscard]]`属性可以帮助我们确保调用者实际上消耗了返回的值，这可以帮助我们避免意外滥用我们的函数。
- en: That's it. For a powerful feature such as the `pmr` allocators, the API isn't
    that complex now, isn't it?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。对于`pmr`分配器这样一个强大的功能，API现在并不那么复杂，是吗？
- en: Aside from tracking allocations, we can also use `pmr` to guard us against allocating
    when we shouldn't.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跟踪分配之外，我们还可以使用`pmr`来防止在不应该分配时进行分配。
- en: Ensuring there are no unexpected allocations
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保没有意外的分配
- en: 'The special `std::pmr::null_memory_resource()` will throw an exception when
    anyone tries to allocate memory using it. You can safeguard from performing any
    allocations using `pmr` by setting it as the default resource as shown next:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的`std::pmr::null_memory_resource()`将在任何人尝试使用它分配内存时抛出异常。您可以通过将其设置为默认资源来防止使用`pmr`执行任何分配，如下所示：
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can also use it to limit allocation from the upstream when it shouldn''t
    happen. Check the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用它来限制在不应该发生时从上游分配。检查以下代码：
- en: '[PRE72]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If anybody tries to allocate more than the buffer size we set, `std::bad_alloc`
    would be thrown.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人尝试分配超过我们设置的缓冲区大小，将抛出`std::bad_alloc`。
- en: Let's move on to our last item in this chapter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行本章的最后一项任务。
- en: Winking out memory
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 眨眼内存
- en: Sometimes not having to deallocate the memory, as the monotonic buffer resource
    does, is still not enough for performance. A special technique called *winking*
    out can help here. Winking out objects means that they're not only not deallocated
    one by one, but their constructors aren't called too. The objects simply evaporate,
    saving time that would normally be spent calling destructors for each object and
    their members (and their members...) in the arena.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有时不需要释放内存，就像单调缓冲资源一样，对性能来说还不够。一种称为*眨眼*的特殊技术可以在这里帮助。眨眼对象意味着它们不仅不是逐个释放，而且它们的构造函数也不会被调用。对象只是蒸发，节省了通常用于调用每个对象及其成员（和它们的成员...）的析构函数所需的时间。
- en: 'NOTE: This is an advanced topic. Be careful when using this technique, and
    only use it if the possible gain is worth it.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是一个高级主题。在使用这种技术时要小心，并且只有在可能的收益值得时才使用它。
- en: This technique can save your precious CPU cycles, but it's not always possible
    to use it. Avoid winking out memory if your objects handle resources other than
    memory. Otherwise, you will get resource leaks. The same goes if you depend on
    any side effects the destructors of your objects would have.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以节省您宝贵的CPU周期，但并非总是可能使用它。如果您的对象处理的资源不仅仅是内存，避免眨眼内存。否则，您将会出现资源泄漏。如果您依赖于对象的析构函数可能产生的任何副作用，情况也是如此。
- en: 'Let''s now see winking out in action:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看眨眼的实际效果：
- en: '[PRE73]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, we created a polymorphic allocator by hand that'll use our default resource
    – a monotonic one that logs each time it reaches upstream. To create objects,
    we'll use a C++20 addition to `pmr`, the `new_object` function. We create a vector
    of strings. We can pass the first one using `push_back`, because it's small enough
    to fit into the small-string buffer we have thanks to SSO. The second string would
    need to allocate a string using the default resource and only then pass it to
    our vector if we used `push_back`. Emplacing it causes the string to be constructed
    inside the vector's functions (not before the call), so it will use the vector's
    allocator. Finally, we don't call the destructors of allocated objects anywhere,
    and just deallocate everything at once, when we exit the scope. This should give
    us hard-to-beat performance.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们手工创建了一个多态分配器，它将使用我们的默认资源——一个每次到达上游时都会记录的单调资源。为了创建对象，我们将使用C++20中对`pmr`的新增功能`new_object`函数。我们创建了一个字符串向量。我们可以使用`push_back`传递第一个字符串，因为它足够小，可以适应我们由于SSO而拥有的小字符串缓冲区。第二个字符串需要使用默认资源分配一个字符串，然后才能将其传递给我们的向量，如果我们使用`push_back`。将其置于内部会导致字符串在调用之前（而不是之前）在向量的函数内部构造，因此它将使用向量的分配器。最后，我们没有在任何地方调用分配对象的析构函数，只有在退出作用域时才释放所有内容。这应该给我们带来难以超越的性能。
- en: That was the last item on our list for this chapter. Let's summarize what we've
    learned.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一项内容。让我们总结一下我们学到的东西。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through various idioms and patterns used in the C++
    world. You should now be able to write fluent, idiomatic C++. We've demystified
    how to perform automatic cleanup. You can now write safer types that properly
    move, copy, and swap. You learned how to use ADL to your advantage both with compilation
    times and writing customization points. We discussed how to choose between static
    and dynamic polymorphism. We also learned how to introduce policies to your types,
    when to use type erasure, and when not.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了C++世界中使用的各种习语和模式。现在你应该能够流利地编写C++。我们已经揭开了如何执行自动清理的神秘面纱。您现在可以编写更安全的类型，正确地移动、复制和交换。您学会了如何利用ADL来优化编译时间和编写定制点。我们讨论了如何在静态和动态多态性之间进行选择。我们还学会了如何向类型引入策略，何时使用类型擦除，何时不使用。
- en: What's more, we discussed how to create objects using factories and fluent builders.
    Moreover, using memory arenas for this is also no longer arcane magic. So is writing
    state machines using tools such as variants.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了如何使用工厂和流畅构建器创建对象。此外，使用内存区域也不再是神秘的魔法。使用诸如变体之类的工具编写状态机也是如此。
- en: We did all that as well as touching on extra topics down the road. Phew! The
    next stop on our journey will be about building your software and packaging it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还触及了一些额外的话题。哦！我们旅程的下一站将是关于构建软件和打包的内容。
- en: Questions
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the rules of three, five, and zero?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三、五和零的规则是什么？
- en: When do we use niebloids versus hidden friends?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们何时使用niebloids而不是隐藏的友元？
- en: How can arrays interfaces be improved to be more production-ready?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何改进数组接口以使其更适合生产？
- en: What are fold expressions?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 折叠表达式是什么？
- en: When shouldn't you use static polymorphism?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时不应该使用静态多态性？
- en: How can we save on one more allocation in the winking out example?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在眨眼示例中，我们如何节省一次额外的分配？
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*tag_invoke: A general pattern for supporting customisable functions*, Lewis
    Baker, Eric Niebler, Kirk Shoop, ISO C++ proposal, [https://wg21.link/p1895](https://wg21.link/p1895)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*tag_invoke：支持可定制函数的通用模式*，Lewis Baker，Eric Niebler，Kirk Shoop，ISO C++提案，[https://wg21.link/p1895](https://wg21.link/p1895)'
- en: '*tag_invoke :: niebloids evolved*, Gašper Ažman for the Core C++ Conference,
    YouTube video, [https://www.youtube.com/watch?v=oQ26YL0J6DU](https://www.youtube.com/watch?v=oQ26YL0J6DU)'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*tag_invoke :: niebloids进化*，Gašper Ažman为Core C++会议制作的YouTube视频，[https://www.youtube.com/watch?v=oQ26YL0J6DU](https://www.youtube.com/watch?v=oQ26YL0J6DU)'
- en: '*Inheritance Is The Base Class of Evil*, Sean Parent for the GoingNative 2013
    Conference, Channel9 video, [https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil](https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil)'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*继承是邪恶的基类*，Sean Parent为GoingNative 2013会议制作的Channel9视频，[https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil](https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil)'
- en: '*Modern C++ Design*, Andrei Alexandrescu, Addison-Wesley, 2001'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*现代C++设计*，Andrei Alexandrescu，Addison-Wesley，2001'
- en: '*How Non-Member Functions Improve Encapsulation*, Scott Meyers, Dr. Dobbs article,
    [https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197](https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197)'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*非成员函数如何改进封装*，Scott Meyers，Dr. Dobbs文章，[https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197](https://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197)'
- en: '*Returning a Status or a Value*, Status User Guide, Abseil documentation, [https://abseil.io/docs/cpp/guides/status#returning-a-status-or-a-value](https://abseil.io/docs/cpp/guides/status#returning-a-status-or-a-value)'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*返回状态或值*，Status用户指南，Abseil文档，[https://abseil.io/docs/cpp/guides/status#returning-a-status-or-a-value](https://abseil.io/docs/cpp/guides/status#returning-a-status-or-a-value)'
- en: '`function_ref`, GitHub repository, [https://github.com/TartanLlama/function_ref](https://github.com/TartanLlama/function_ref)'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function_ref`，GitHub存储库，[https://github.com/TartanLlama/function_ref](https://github.com/TartanLlama/function_ref)'
- en: '*How To Use std::visit With Multiple Variants*, Bartłomiej Filipek, post on
    Bartek''s coding blog, [https://www.bfilipek.com/2018/09/visit-variants.html](https://www.bfilipek.com/2018/09/visit-variants.html)'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如何使用std::visit处理多个变体*，Bartłomiej Filipek，Bartek的编码博客文章，[https://www.bfilipek.com/2018/09/visit-variants.html](https://www.bfilipek.com/2018/09/visit-variants.html)'
- en: 'CppCon 2018: Mateusz Pusz, *Effective replacement of dynamic polymorphism with
    std::variant*, YouTube video, [https://www.youtube.com/watch?v=gKbORJtnVu8](https://www.youtube.com/watch?v=gKbORJtnVu8)'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CppCon 2018：Mateusz Pusz，*使用std::variant有效替代动态多态性*，YouTube视频，[https://www.youtube.com/watch?v=gKbORJtnVu8](https://www.youtube.com/watch?v=gKbORJtnVu8)
