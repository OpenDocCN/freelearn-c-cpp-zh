- en: In-scene Video and Visual Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景视频和视觉效果
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'UE4 has some amazing in-game visual effects. Media Framework is a very cool
    tool and is used to add in-scene video to a game. Unreal also has some significantly-developed,
    but not entirely ready-to-go, tools for capturing realtime video. In this chapter,
    we''ll capture a section of video from gameplay, then project it onto a surface
    as in-scene video playback. Unreal also offers a huge variety of visual FX, and
    to spice up our weapon impacts, we''ll add some impact particles with physics to
    have a basis for these kinds of options as well. This chapter will focus on:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: UE4有一些令人惊叹的游戏内视觉效果。媒体框架是一个非常酷的工具，用于向游戏中添加场景视频。Unreal还有一些显著发展的，但尚未完全准备就绪的工具用于捕获实时视频。在本章中，我们将从游戏玩法中捕获一段视频，然后将其投影到表面上作为场景视频播放。Unreal还提供了大量的视觉效果，为了使我们的武器冲击更加生动，我们将添加一些带有物理的冲击粒子，以作为这些选项的基础。本章将重点关注：
- en: Creating an in-game video player with Media Framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体框架创建游戏内视频播放器
- en: Create assets and a material to add this to any actor in the map
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建资产和材质，以便将其添加到地图中的任何演员
- en: Triggering and repeating our video
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发并重复我们的视频
- en: Adding physics-based particles to the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向游戏中添加基于物理的粒子
- en: Creating an emitter for our projectiles and spawning it on hit-events
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的投射物创建发射器并在击中事件上生成它
- en: Orienting and modifying particles to have a cool motion/feel
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位和修改粒子以获得酷炫的运动/感觉
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will implement its components in the `Chapter 12` branch of our
    project on GitHub: [https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将在GitHub上我们项目的`Chapter 12`分支中实现其组件：[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12)。
- en: We used Engine version 4.19.2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了4.19.2版本的引擎。
- en: Playing in-scene video with Media Framework
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用媒体框架播放场景中的视频
- en: Media Framework adds several helpful key systems to play videos in-engine. However,
    the one we will focus on here is playing an in-scene video with audio playback
    on a "screen" triggered by our player. This is a very common and popular feature
    in many games, and using Unreal's render target materials, you can put realtime
    renders of other areas of your map anywhere. The classic example being security
    cameras showing you other areas. But to reiterate, we're just focusing on how
    to get a movie into the game to prove what can be done and learn what's involved
    in adding it to a game. First, however, we'll need a few new items.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体框架为在引擎中播放视频添加了几个有用的关键系统。然而，我们将重点关注的是通过我们的播放器触发“屏幕”上的音频播放的场景视频。这在许多游戏中是一个非常常见且受欢迎的功能，使用Unreal的渲染目标材质，你可以将地图其他区域的实时渲染放置在任何地方。一个经典的例子是安全摄像头显示其他区域。但为了重申，我们只是关注如何将电影放入游戏以证明可以做什么，以及了解将其添加到游戏中的涉及内容。首先，我们还需要一些新项目。
- en: Creating our assets
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的资产
- en: 'There are several components needed to make a nice in-scene video player, let''s
    quickly enumerate them here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个优秀的场景视频播放器需要几个组件，让我们快速列举一下：
- en: 'The source video, of course! In Epic''s documentation, they list supported
    files, but a nice short version is: when in doubt, use MP4s, as they work across
    every platform (more on the specific one here in a moment).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然是源视频！在Epic的文档中，他们列出了支持的文件格式，但一个简洁的版本是：如果有疑问，使用MP4，因为它们在所有平台上都适用（具体内容稍后在此处介绍）。
- en: A File Media Source object that references, well, this source media (in our
    case, our video).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文件媒体源对象，它引用了，嗯，这个源媒体（在我们的案例中，是我们的视频）。
- en: A Media Player object that does the work at runtime.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在运行时执行工作的媒体播放器对象。
- en: An associated Media Texture asset.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相关的媒体纹理资产。
- en: A Material that uses this texture.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此纹理的材料。
- en: Now, the great news about UE4 is that lot of this is automated for you, so don't
    get intimidated by that list, this will go surprisingly quickly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于UE4的巨大好消息是，很多操作都为你自动化了，所以不要被那个列表吓到，这个过程会出乎意料地快。
- en: 'As a quick aside, I''ll describe generally where this specific video came from,
    as the actual video file is key to this whole concept. There are, of course, a
    number of ways to capture video. While this book is not meant to be an endorsement
    of any specific outside products (other than recognizing what development tools
    and versions were used), doing an internet search on "Windows screen capture,"
    is an easy solution. Also, using some of the game-streaming tools and apps on
    mobile devices can do this too: many have a "game mode" that captures the video
    and saves it.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速说明，我将简要描述这个特定视频的来源，因为实际的视频文件是这个概念的关键。当然，有几种方法可以捕获视频。虽然这本书并不是为了推荐任何特定的外部产品（除了承认所使用的开发工具和版本），但通过在互联网上搜索“Windows
    屏幕捕获”是一个简单的解决方案。此外，使用移动设备上的某些游戏流媒体工具和应用程序也可以做到这一点：许多都有“游戏模式”，可以捕获视频并保存。
- en: Check out the Sequence Recorder in the editor (Windows | Sequence Recorder),
    as this may be just what you need. I found a few issues with using it in the past;
    but there is constant work being done with systems like that, and if you can get
    comfortable with a supported system built in to UE4, it's the best way to go.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中查看序列录制器（Windows | 序列录制器），因为这可能是你需要的。我过去在使用它时发现了一些问题；但是，像这样的系统一直在进行持续的工作，如果你能熟悉
    UE4 内置的受支持系统，这将是最简单的方法。
- en: 'The checked-in asset you can see is literally just me walking over to our Countess
    introduction in-game scene and capturing it out to an MP4 video that will be uploaded
    with the branch to GitHub. So with this video file added to our content folder,
    we can get back to the editor, and making items in our content browser:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到的已签入资产实际上只是我走进游戏中的 Countess 介绍场景，并将其捕获成 MP4 视频的过程，这个视频将与分支一起上传到 GitHub。所以，将这个视频文件添加到我们的内容文件夹后，我们可以回到编辑器，并在内容浏览器中制作项目：
- en: 'The next thing needed, as noted, is a File Media Source:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，接下来我们需要的是一个文件媒体源：
- en: '![](img/94bba451-c2a6-47b3-8078-fe72ea895525.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94bba451-c2a6-47b3-8078-fe72ea895525.png)'
- en: 'And as you''ll see, there''s really not much to this particular object, just
    point it to the source media and note there are options for platform player overrides:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个特定对象实际上并没有什么复杂，只需将其指向源媒体，并注意有平台播放器覆盖选项：
- en: '![](img/fc4142d4-1e5e-4446-a745-f7d5b5406dc9.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc4142d4-1e5e-4446-a745-f7d5b5406dc9.png)'
- en: 'The last thing we''ll add here is our Media Player. Note that when making a
    new media player, you''ll get this popup and definitely want to check the box
    (as it is what automates making the media texture and wiring it up for us):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要添加的最后一件事是我们的媒体播放器。请注意，在创建新的媒体播放器时，你会得到这个弹出窗口，并且绝对需要勾选这个框（因为它会自动为我们生成媒体纹理并将其连接起来）：
- en: '![](img/04f11ba2-7f72-4ec5-9583-dfea740d1370.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04f11ba2-7f72-4ec5-9583-dfea740d1370.png)'
- en: 'After clicking ok, we can continue:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 点击确定后，我们可以继续：
- en: '![](img/0efda684-9634-489c-950b-d6b3e6281ca9.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0efda684-9634-489c-950b-d6b3e6281ca9.png)'
- en: And in here, simply drag and drop the CountessVid asset we just made into its
    list in the bottom left and the player is ready with its default settings. Our
    texture asset is now automatically created and associated (again, a great streamlining
    feature of modern UE4!). Now all we need is a material that we can generate by
    dragging the texture onto an actor, so let's progress to that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只需将我们刚刚制作的 CountessVid 资产简单地拖放到左下角的列表中，播放器就准备好了，默认设置已经完成。我们的纹理资产现在已自动创建并关联（再次强调，这是现代
    UE4 的一个非常好的简化功能！）。现在我们需要的只是一个材质，我们可以通过将纹理拖放到一个演员上来生成它，所以让我们继续进行。
- en: Building and playing the video in-scene
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在场景中构建和播放视频
- en: 'Theoretically, you can now play a video on any static mesh actor or a number
    of surfaces. Typically, though, it is just a plane, which can be dragged from
    the modes window right into the level. We''ll generate a material by dragging
    the media texture directly on to the actor we want to use (our plane in this case),
    and then you can see a dead-simple material is added and is set on the surface.
    So after doing all of that, as seen here, there''s one tricky part left: the audio
    that will fail to play if we don''t right-click the +Add Component for our in-scene
    screen (plane), add a Media Sound component, and hook its media to our player:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你现在可以在任何静态网格演员或多个表面上播放视频。通常情况下，这只是一个平面，可以从模式窗口直接拖动到级别中。我们将通过将媒体纹理直接拖放到我们想要使用的演员（在这种情况下是我们的平面）上来生成一个材质，然后你可以看到添加了一个非常简单的材质，并设置在表面上。所以完成所有这些后，如这里所见，还剩下一个小问题：如果我们在场景中的屏幕（平面）上不右键单击+添加组件，添加一个媒体声音组件，并将其媒体连接到播放器，音频将无法播放：
- en: '![](img/6deb5680-765e-4133-b22e-7dd11ada8c2c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6deb5680-765e-4133-b22e-7dd11ada8c2c.png)'
- en: 'Manually hooking up the audio this way is one of the only complaints I have
    about the process these days, so now that we''re pretty close to having everything
    we need, it''s just a matter of triggering the video and checking it out:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式手动连接音频是现在我对这个流程的唯一抱怨之一，所以现在我们几乎拥有了所有需要的东西，只需要触发视频并查看它：
- en: '![](img/0bf9c68e-d2bc-4909-b874-88269bf738e7.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bf9c68e-d2bc-4909-b874-88269bf738e7.png)'
- en: Here a simple trigger volume is added in front of our screen, a blueprint-level
    variable (of Media Player type) is added on the left in the level blueprint, and
    with the volume selected, right-clicking in the blueprint event area lets you
    directly drop its on-actor-overlap event in and trigger an Open Source node, which
    is also set to point to our new asset. So note, this logic will trigger any and
    all instances of this material, which uses our media player, which can be great,
    but also may not be exactly what you want. There are a number of solutions there –
    the most obvious, but not nicest for asset cleanliness, is just to duplicate the
    player for each individual thing you want to play separately. Anyway, there you
    have it, we can now walk over to the screen to see and hear the Countess' intro
    sequence as many times as we like, as we trigger our MP4 video thereof!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在屏幕前方添加了一个简单的触发体积，在关卡蓝图左侧添加了一个蓝图级别的变量（媒体播放器类型），选中体积后，在蓝图事件区域右键单击可以直接将它的actor-overlap事件拖入并触发一个开源节点，该节点也设置为指向我们新的资产。所以请注意，这个逻辑将触发任何使用我们媒体播放器的该材料实例，这可能很好，但也可能不是你想要的。这里有几个解决方案——最明显但不是最优雅的解决方案是，为每个需要单独播放的东西复制播放器。无论如何，现在我们可以走到屏幕前，像我们触发MP4视频那样多次观看和听到伯爵夫人的开场序列！
- en: 'One last point: when playing, this video comes across pretty dark in the scene:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：当播放时，这个视频在场景中看起来相当暗：
- en: '![](img/89c0251d-3826-4711-a1ec-75fcb723d52e.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89c0251d-3826-4711-a1ec-75fcb723d52e.png)'
- en: 'To correct that, I just did a very simple multiply on the color output in the
    material. Once again, there are a number of ways you could approach this; I always
    start with the simplest and if that does the job, move on! You can check that
    change out here, modify the constant value in the material, see the effect it
    has on our output in the game:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这一点，我在材质中的颜色输出上进行了非常简单的乘法操作。再次强调，你可以用多种方法来处理这个问题；我总是从最简单的方法开始，如果它有效，就继续前进！你可以在这里检查这个变化，修改材质中的常量值，看看它对我们游戏中的输出有什么影响：
- en: '![](img/45abc86b-83f2-462d-bbb4-59b3d86eeb2f.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45abc86b-83f2-462d-bbb4-59b3d86eeb2f.png)'
- en: Now let's check out a couple more great visual FX that can be made with UE4
    as we haven't used their particle system much yet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看一些使用UE4制作的更多优秀的视觉效果，因为我们还没有充分利用它们的粒子系统。
- en: Adding physics particles
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加物理粒子
- en: 'Our goal here will have two parts: first, to add some sparks off of our projectile
    hits when they impact, but then to get those sparks bouncing around in the physics
    universe without utterly killing our framerate. One great piece of news is that
    UE4 supports GPU particles across all kinds of platforms for you, and in general
    this is where you want to be doing that kind of work. Should you find yourself
    in a game that is GPU-bound because of its complex visuals (or low-bar for platform
    hardware specifications), these kinds of things are often the first to go; but
    let''s not worry about that now, let''s make some pretty sparks first.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标将有两个部分：首先，在弹射物击中时添加一些火花，但随后要让这些火花在物理宇宙中弹跳，而不会完全杀死我们的帧率。一个好消息是，UE4支持所有平台上的GPU粒子，通常你希望在这里做这类工作。如果你发现自己在一个因为复杂视觉效果（或平台硬件规格低）而受GPU限制的游戏中，这类事情通常是首先被放弃的；但现在我们不要担心这个，让我们先做一些漂亮的火花。
- en: Creating our initial emitter on projectile hit
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在弹射物击中创建初始发射器
- en: 'So some of you may remember way back at the beginning of the book that we added
    the starter content pack. Well, now we can finally put a bit more of that to use.
    Scrolling down near the bottom of the folders is StarterContent/Particles (or
    just do a wildcard search for P_Sparks in the search box). This is not exactly
    what we want, but it''s close, which is always saves time. Notice that it is already
    using some spark and smoke GPU Sprite emitters (the other being a flash/burst).
    It seems pretty close, so why not start here? Similarly for C++ classes and all
    other aspects of game development, if you can begin with something that is at
    least partially already doing the job you want, always put that to use and begin
    modifying from there for efficiency. Now, let''s take a look at these sparks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有些人可能还记得在书的开始处我们添加了起始内容包。现在，我们终于可以更充分地利用它了。在文件夹底部滚动，可以看到 StarterContent/Particles（或只需在搜索框中执行
    P_Sparks 的通配符搜索）。这并不完全是我们想要的，但已经很接近了，这总是能节省时间。注意，它已经使用了一些火花和烟雾 GPU Sprite 发射器（另一个是闪光/爆发）。看起来很接近，所以为什么不从这里开始呢？同样，对于
    C++ 类和游戏开发的各个方面，如果你可以开始使用至少部分已经完成你想要的工作的内容，始终利用它并从那里开始修改以提高效率。现在，让我们来看看这些火花：
- en: '![](img/638b0e7e-a827-445d-abd9-83eb5fcabb05.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/638b0e7e-a827-445d-abd9-83eb5fcabb05.png)'
- en: 'As we''ll be modifying them to behave a bit differently, I simply copy and
    paste the emitter (P_Sparks asset) up to FirstPersonCPP/FX. I also renamed it
    to P_ImpactSparks so as to avoid confusion when browsing for it. Now we have our
    own fresh copy and can begin modifying it. First, though, let''s take a step back
    and just get them to spawn upon projectile impacts. We''ll need to add a new variable
    to our MasteringProjectile class and spawn them around where we spawn impact sounds:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将对它们进行一些修改以使其行为略有不同，我只需将发射器（P_Sparks 资产）复制粘贴到 FirstPersonCPP/FX 中。我还将其重命名为
    P_ImpactSparks 以避免在查找时产生混淆。现在我们有了自己的副本，可以开始修改它了。不过，首先，让我们退一步，让它们在投射物撞击时生成。我们需要在我们的
    MasteringProjectile 类中添加一个新变量，并在生成撞击声音的附近生成它们：
- en: 'First in our projectile''s header file we add:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的投射物头文件中添加：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then in `OnHit` down at the bottom in the `.cpp` file we add:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `.cpp` 文件底部的 `OnHit` 中添加：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And just like that, we have particles spawning at the hit locations. Simply
    go to each projectile in the `FirstPersonCPP/Blueprints/Weapons` folder and set
    all of their ImpactParticle variables to use the newly copied P_ImpactSparks asset.
    For those going through this step by step, you''ll notice some problems at this
    point:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们在撞击位置生成了粒子。只需转到 `FirstPersonCPP/Blueprints/Weapons` 文件夹中的每个投射物，并将它们的 ImpactParticle
    变量设置为使用新复制的 P_ImpactSparks 资产。对于那些按步骤进行的人，你们在这个阶段可能会注意到一些问题：
- en: '![](img/eaf700c3-cdef-4030-ae77-29ef1aba06e8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaf700c3-cdef-4030-ae77-29ef1aba06e8.png)'
- en: 'First, our particle systems (emitters) live forever, and second, they always
    spawn straight up and down with no imparted sense of velocity and simply flow
    to the ground as a stationary fountain would. The first is trivial to fix: open
    P_ImpactSparks in Cascade (double click the asset) and you''ll see three emitters
    in its main window. Click on the Required bar on each and scroll down on the Details
    menu, and you''ll see all three have a looping count set to 0 (loop forever) –
    set it to 1 as that fixes our infinite systems here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的粒子系统（发射器）永远存在，其次，它们总是垂直向上和向下生成，没有任何速度感，就像静止的喷泉一样简单地流向地面。第一个问题很容易解决：在 Cascade
    中打开 P_ImpactSparks（双击资产），你会在主窗口中看到三个发射器。点击每个的 Required 栏，并在 Details 菜单中向下滚动，你会看到所有三个都有一个循环计数设置为
    0（无限循环）——将其设置为 1 以修复我们这里的无限系统：
- en: '![](img/92dd359d-834f-4032-a7b0-642ae60d36ee.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92dd359d-834f-4032-a7b0-642ae60d36ee.png)'
- en: I'm not a huge fan of the user interface in Cascade, but with practice I have
    seen FX artists that work in it masterfully and can find and modify systems very
    quickly. In this case, we'll likely want to increase the sparks' velocity and
    reduce that emitter's lifetime, but these are all more or less cosmetic things.
    Our last issues are to get them orienting properly for the way the projectiles
    hit the surfaces and make sure we can tune the spark behavior coming off of them
    if needed for performance reasons.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是特别喜欢 Cascade 中的用户界面，但通过实践，我看到了一些熟练使用它的特效艺术家，他们可以非常快速地找到并修改系统。在这种情况下，我们可能希望增加火花的速度并减少发射器的寿命，但这些更多是外观上的事情。我们最后的任务是确保它们以正确的方式对准投射物撞击的表面，并确保我们可以在需要时调整火花的行为以优化性能。
- en: So why not use Niagara, the newer editor for the particles? Honestly, in this
    instance, it was my own familiarity with Cascade; but of course anyone is welcome
    to use Niagara and I will add a link to it (which starts with a link to the differences
    and similarities to Cascade) in Further Reading. Similar to Matinee vs. Sequencer
    earlier, both will remain and be supported, but long-term, it probably *is* a
    good idea to move to Niagara.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不使用 Niagara，这个更新的粒子编辑器呢？说实话，在这个例子中，是我自己对 Cascade 的熟悉程度；但当然，任何人都可以使用 Niagara，我会在“进一步阅读”中添加一个链接（该链接从与
    Cascade 的差异和相似之处开始）。类似于早期的 Matinee 与 Sequencer，两者都将继续存在并得到支持，但从长远来看，可能确实是一个好主意转向
    Niagara。
- en: Orienting and adjusting physics of the particles
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对粒子物理进行定位和调整
- en: Having particle systems just rain down boring-looking sparks is not going to
    cut it with this type of effect, we need the sparks to align in a way that makes
    sense from the projectile impact. This will take just a little bit more code work
    and a little bit more Cascade work; but should come out looking good.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 仅让粒子系统降下看起来无聊的火花并不能满足这种效果，我们需要火花以符合弹道冲击的方式排列。这需要一点额外的代码工作和一点额外的 Cascade 工作量；但最终效果应该会很不错。
- en: '**Note:** If you use blueprints to spawn various effects, it makes it much
    easier to hook up outside factors to these emitters and systems. Technical artists
    often find this invaluable to allow for a quick iteration of systems until they
    get things looking right. Just be aware that a well-meaning content creator can
    make one small node that ends up testing a huge amount of physics collisions accidentally,
    so this kind of experimentation can be dangerous for performance!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**如果你使用蓝图来生成各种效果，这将使你更容易将这些发射器和系统连接到外部因素。技术艺术家通常发现这一点非常有价值，可以快速迭代系统，直到它们看起来正确。只是要注意，一个有良好意图的内容创作者可能会意外地测试大量物理碰撞，所以这种实验可能会对性能造成危险！'
- en: 'First, the quick code change:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，快速代码更改：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are a *lot* of options here, you can use Hit.Normal/Hit.ImpactNormal instead
    of the velocity to build your rotation, and not attach the particles if desired,
    for example. I found here that attaching the system made the particles feel like
    they were being "pulled with" the projectile and made for a bit of a chaotic look,
    which I liked, setting the rotation along the velocity as well. In Cascade, only
    the smoke system was currently set to inherit the parent''s velocity; I made the
    sparks do so as well (right-click in the emitter''s column area, add that field,
    and select it). Note the reduced Emitter Duration tuned value on the left:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多选项，你可以使用 Hit.Normal/Hit.ImpactNormal 来代替速度来构建你的旋转，例如，如果需要的话，不附加粒子。我发现在这里，附加系统使粒子感觉像是被“拉扯”的，这产生了一种混乱的外观，我喜欢这种效果，同时沿着速度设置旋转。在
    Cascade 中，目前只有烟雾系统被设置为继承父级的速度；我将火花也设置为这样做（在发射器的列区域右键单击，添加该字段，并选择它）。注意左侧的减少发射器持续时间调整值：
- en: '![](img/1e14d42b-b119-4799-a233-168754f44efb.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e14d42b-b119-4799-a233-168754f44efb.png)'
- en: The end result is not quite ready for professional quality, knowing your limits
    is an important trait in growing with a team as well. Still, hopefully the journey
    here helped to boost your confidence in Unreal's awesome visual effects. There's
    so much more to explore, but having the fundamentals to take a project forward
    is what this book is all about.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果还不完全适合专业质量，了解自己的限制是随着团队成长的重要特质。不过，希望这段旅程有助于增强你对 Unreal 精彩视觉效果的信心。还有更多东西可以探索，但拥有推动项目前进的基础是这本书的主要内容。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We''ve touched on just about all of the major systems traditional UE4 has to
    offer. While there are a few more specialized systems, at this point, you should
    be comfortable making a traditional game on whatever platform is desired in UE4\.
    The Unreal community has a huge amount of visual FX that can be downloaded for
    free, knowing the above you should have the confidence to go explore its deep
    options! There''s only one area we haven''t really explored yet; it''s one of
    the newest to UE4 and what we''ll cover in the next chapter: AR and VR, Unreal''s
    Augmented Reality and Virtual Reality API and projects. This is also the end of
    the updates for our main GitHub project: from its humble origins as the FirstPersonCPP
    template, to FrozenCove, its fog and lighting, to the Countess and her AI, to
    loading and saving, and effects and optimizations. I hope you have found it an
    inspiring and meaningful journey. Now on to the new worlds of AR and VR!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了传统UE4提供的几乎所有主要系统。虽然还有一些更专业的系统，但在这个阶段，你应该能够舒适地在UE4中制作任何平台上的传统游戏。虚幻社区有大量的视觉特效可以免费下载，了解上述内容后，你应该有信心去探索其深层次选项！我们还没有真正探索的一个领域是；这是UE4中最新的之一，我们将在下一章中介绍：增强现实和虚拟现实，虚幻的增强现实和虚拟现实API和项目。这也是我们主要GitHub项目的更新结束：从它作为FirstPersonCPP模板的谦卑起源，到FrozenCove的雾和光照，到Countess和她的AI，到加载和保存，以及效果和优化。我希望你发现这是一次启发性和有意义的旅程。现在，让我们进入增强现实和虚拟现实的新世界！
- en: Questions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Why is MP4 typically the best choice for videos in UE4? (Hint: see the *Further
    reading* section for some details)'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么MP4通常是UE4中视频的最佳选择？（提示：查看*进一步阅读*部分以获取一些详细信息）
- en: If a single Media Player is referenced on multiple actors, what happens when
    opening that media?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个媒体播放器被多个演员引用，打开该媒体时会发生什么？
- en: What's the quick simple way to get your video texture and video material?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有什么快速简单的方法可以获取你的视频纹理和视频素材？
- en: Why was the constant multiplier added to color output of the material here?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在这里添加了颜色输出的常数乘数？
- en: What's a good strategy to save time in both C++ and asset creation that we used
    with the particle emitter?
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在粒子发射器上使用了什么好的策略来节省时间，无论是在C++还是在资产创建中？
- en: Why should we attach the emitter to our projectile rather than have it stay
    still in space, as first implemented?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该将发射器附加到我们的弹道上，而不是让它像最初实现的那样在空间中保持静止？
- en: How did we get the emitters aligned with the projectile direction?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是如何将发射器与弹道方向对齐的？
- en: When is it disadvantageous to have particles simulate on the GPU (which can
    easily be changed in Cascade)?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，让粒子在GPU上模拟（在Cascade中可以轻松更改）是不利的？
- en: Further reading
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Supported video types in Media Framework:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体框架支持的视频类型：
- en: '[https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference](https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference](https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference)'
- en: 'Niagara particle editor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尼亚加拉粒子编辑器：
- en: '[https://docs.unrealengine.com/en-us/Engine/Niagara](https://docs.unrealengine.com/en-us/Engine/Niagara)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Engine/Niagara](https://docs.unrealengine.com/en-us/Engine/Niagara)'
